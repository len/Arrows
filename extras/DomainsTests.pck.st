'From Cuis 5.0 [latest update: #4163] on 23 May 2020 at 9:38:19 am'!
'Description Please enter a description for this package'!
!provides: 'DomainsTests' 1 162!
SystemOrganization addCategory: #DomainsTests!


!classDefinition: #AbelianGroupTest category: #DomainsTests!
TestCase subclass: #AbelianGroupTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DomainsTests'!
!classDefinition: 'AbelianGroupTest class' category: #DomainsTests!
AbelianGroupTest class
	instanceVariableNames: ''!

!classDefinition: #AlgebraicGeometryTest category: #DomainsTests!
TestCase subclass: #AlgebraicGeometryTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DomainsTests'!
!classDefinition: 'AlgebraicGeometryTest class' category: #DomainsTests!
AlgebraicGeometryTest class
	instanceVariableNames: ''!

!classDefinition: #AlgebraicNumbersTest category: #DomainsTests!
TestCase subclass: #AlgebraicNumbersTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DomainsTests'!
!classDefinition: 'AlgebraicNumbersTest class' category: #DomainsTests!
AlgebraicNumbersTest class
	instanceVariableNames: ''!

!classDefinition: #ChainComplexTest category: #DomainsTests!
TestCase subclass: #ChainComplexTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DomainsTests'!
!classDefinition: 'ChainComplexTest class' category: #DomainsTests!
ChainComplexTest class
	instanceVariableNames: ''!

!classDefinition: #CommutativeAlgebraTest category: #DomainsTests!
TestCase subclass: #CommutativeAlgebraTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DomainsTests'!
!classDefinition: 'CommutativeAlgebraTest class' category: #DomainsTests!
CommutativeAlgebraTest class
	instanceVariableNames: ''!

!classDefinition: #EllipticCurvesTest category: #DomainsTests!
TestCase subclass: #EllipticCurvesTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DomainsTests'!
!classDefinition: 'EllipticCurvesTest class' category: #DomainsTests!
EllipticCurvesTest class
	instanceVariableNames: ''!

!classDefinition: #GraphTest category: #DomainsTests!
TestCase subclass: #GraphTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DomainsTests'!
!classDefinition: 'GraphTest class' category: #DomainsTests!
GraphTest class
	instanceVariableNames: ''!

!classDefinition: #GroupTest category: #DomainsTests!
TestCase subclass: #GroupTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DomainsTests'!
!classDefinition: 'GroupTest class' category: #DomainsTests!
GroupTest class
	instanceVariableNames: ''!

!classDefinition: #MathematicsTest category: #DomainsTests!
TestCase subclass: #MathematicsTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DomainsTests'!
!classDefinition: 'MathematicsTest class' category: #DomainsTests!
MathematicsTest class
	instanceVariableNames: ''!

!classDefinition: #MatrixTest category: #DomainsTests!
TestCase subclass: #MatrixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DomainsTests'!
!classDefinition: 'MatrixTest class' category: #DomainsTests!
MatrixTest class
	instanceVariableNames: ''!

!classDefinition: #ModuleTest category: #DomainsTests!
TestCase subclass: #ModuleTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DomainsTests'!
!classDefinition: 'ModuleTest class' category: #DomainsTests!
ModuleTest class
	instanceVariableNames: ''!

!classDefinition: #MonomialTest category: #DomainsTests!
TestCase subclass: #MonomialTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DomainsTests'!
!classDefinition: 'MonomialTest class' category: #DomainsTests!
MonomialTest class
	instanceVariableNames: ''!

!classDefinition: #NumberFieldTest category: #DomainsTests!
TestCase subclass: #NumberFieldTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DomainsTests'!
!classDefinition: 'NumberFieldTest class' category: #DomainsTests!
NumberFieldTest class
	instanceVariableNames: ''!

!classDefinition: #PAdicsTest category: #DomainsTests!
TestCase subclass: #PAdicsTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DomainsTests'!
!classDefinition: 'PAdicsTest class' category: #DomainsTests!
PAdicsTest class
	instanceVariableNames: ''!

!classDefinition: #PolynomialTest category: #DomainsTests!
TestCase subclass: #PolynomialTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DomainsTests'!
!classDefinition: 'PolynomialTest class' category: #DomainsTests!
PolynomialTest class
	instanceVariableNames: ''!

!classDefinition: #PowerSeriesTest category: #DomainsTests!
TestCase subclass: #PowerSeriesTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DomainsTests'!
!classDefinition: 'PowerSeriesTest class' category: #DomainsTests!
PowerSeriesTest class
	instanceVariableNames: ''!

!classDefinition: #RingTest category: #DomainsTests!
TestCase subclass: #RingTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DomainsTests'!
!classDefinition: 'RingTest class' category: #DomainsTests!
RingTest class
	instanceVariableNames: ''!

!classDefinition: #SequenceTest category: #DomainsTests!
TestCase subclass: #SequenceTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DomainsTests'!
!classDefinition: 'SequenceTest class' category: #DomainsTests!
SequenceTest class
	instanceVariableNames: ''!

!classDefinition: #SimplicialComplexTest category: #DomainsTests!
TestCase subclass: #SimplicialComplexTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DomainsTests'!
!classDefinition: 'SimplicialComplexTest class' category: #DomainsTests!
SimplicialComplexTest class
	instanceVariableNames: ''!

!classDefinition: #TupleTest category: #DomainsTests!
TestCase subclass: #TupleTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DomainsTests'!
!classDefinition: 'TupleTest class' category: #DomainsTests!
TupleTest class
	instanceVariableNames: ''!

!classDefinition: #Benchmark category: #DomainsTests!
Object subclass: #Benchmark
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DomainsTests'!
!classDefinition: 'Benchmark class' category: #DomainsTests!
Benchmark class
	instanceVariableNames: ''!

!classDefinition: #AlgebraicNumbersBenchmark category: #DomainsTests!
Benchmark subclass: #AlgebraicNumbersBenchmark
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DomainsTests'!
!classDefinition: 'AlgebraicNumbersBenchmark class' category: #DomainsTests!
AlgebraicNumbersBenchmark class
	instanceVariableNames: ''!

!classDefinition: #GroebnerBasisBenchmark category: #DomainsTests!
Benchmark subclass: #GroebnerBasisBenchmark
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DomainsTests'!
!classDefinition: 'GroebnerBasisBenchmark class' category: #DomainsTests!
GroebnerBasisBenchmark class
	instanceVariableNames: ''!

!classDefinition: #GroupBenchmark category: #DomainsTests!
Benchmark subclass: #GroupBenchmark
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DomainsTests'!
!classDefinition: 'GroupBenchmark class' category: #DomainsTests!
GroupBenchmark class
	instanceVariableNames: ''!

!classDefinition: #IntegersBenchmark category: #DomainsTests!
Benchmark subclass: #IntegersBenchmark
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DomainsTests'!
!classDefinition: 'IntegersBenchmark class' category: #DomainsTests!
IntegersBenchmark class
	instanceVariableNames: ''!

!classDefinition: #ModularMatrixBenchmark category: #DomainsTests!
Benchmark subclass: #ModularMatrixBenchmark
	instanceVariableNames: 'field matrix'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DomainsTests'!
!classDefinition: 'ModularMatrixBenchmark class' category: #DomainsTests!
ModularMatrixBenchmark class
	instanceVariableNames: ''!

!classDefinition: #PolynomialBenchmark category: #DomainsTests!
Benchmark subclass: #PolynomialBenchmark
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DomainsTests'!
!classDefinition: 'PolynomialBenchmark class' category: #DomainsTests!
PolynomialBenchmark class
	instanceVariableNames: ''!

!classDefinition: #SmallMatrixBenchmark category: #DomainsTests!
Benchmark subclass: #SmallMatrixBenchmark
	instanceVariableNames: 'integerMatrix binaryMatrix modularMatrix'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DomainsTests'!
!classDefinition: 'SmallMatrixBenchmark class' category: #DomainsTests!
SmallMatrixBenchmark class
	instanceVariableNames: ''!

!classDefinition: #SparsePolynomialMultiplicationBenchmark category: #DomainsTests!
Benchmark subclass: #SparsePolynomialMultiplicationBenchmark
	instanceVariableNames: 'p pPlusOne pBigCoefficients pBigExponents pBigCoefficientsPlusOne pBigExponentsPlusOne'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DomainsTests'!
!classDefinition: 'SparsePolynomialMultiplicationBenchmark class' category: #DomainsTests!
SparsePolynomialMultiplicationBenchmark class
	instanceVariableNames: ''!

!classDefinition: #TupleConvolutionBenchmark category: #DomainsTests!
Benchmark subclass: #TupleConvolutionBenchmark
	instanceVariableNames: 'a b'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DomainsTests'!
!classDefinition: 'TupleConvolutionBenchmark class' category: #DomainsTests!
TupleConvolutionBenchmark class
	instanceVariableNames: ''!

!classDefinition: #CASBenchmark category: #DomainsTests!
Object subclass: #CASBenchmark
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DomainsTests'!
!classDefinition: 'CASBenchmark class' category: #DomainsTests!
CASBenchmark class
	instanceVariableNames: ''!


!AlgebraicNumbersBenchmark commentStamp: '<historical>' prior: 0!
AlgebraicNumbersBenchmark new run

testComplexAlgebraicNumberAddition	1.1 per second. (25 May 2018)
testComplexAlgebraicNumberDivision	63.9 per second.
testComplexAlgebraicNumberProduct	68.3 per second.
testComplexAlgebraicNumberSquare	2,080 per second.
testRealAlgebraicNumberAddition	0.936 per second.
testRealAlgebraicNumberDivision	61.7 per second.
testRealAlgebraicNumberProduct	67.1 per second.
testRealAlgebraicNumberSquare	2,010 per second.

testComplexAlgebraicNumberAddition	0.907 per second. (18 May 2018)
testComplexAlgebraicNumberDivision	61 per second.
testComplexAlgebraicNumberProduct	64.7 per second.
testComplexAlgebraicNumberSquare	1,760 per second.
testRealAlgebraicNumberAddition	0.997 per second.
testRealAlgebraicNumberDivision	58.2 per second.
testRealAlgebraicNumberProduct	62.6 per second.
testRealAlgebraicNumberSquare	1,730 per second.

testComplexAlgebraicNumberAddition	0.84 per second.
testComplexAlgebraicNumberDivision	58.4 per second.
testComplexAlgebraicNumberProduct	61.6 per second.
testComplexAlgebraicNumberSquare	1,770 per second.
testRealAlgebraicNumberAddition	0.952 per second.
testRealAlgebraicNumberDivision	48.3 per second.
testRealAlgebraicNumberProduct	56.2 per second.
testRealAlgebraicNumberSquare	1,460 per second.

testComplexAlgebraicNumberAddition	1.08 per second. (29 Apr 2018)
testComplexAlgebraicNumberDivision	57.6 per second.
testComplexAlgebraicNumberProduct	61.2 per second.
testComplexAlgebraicNumberSquare	1,660 per second.
testRealAlgebraicNumberAddition	0.78 per second.
testRealAlgebraicNumberDivision	55.8 per second.
testRealAlgebraicNumberProduct	59.1 per second.
testRealAlgebraicNumberSquare	1,610 per second.' 
!

!GroebnerBasisBenchmark commentStamp: 'len 5/12/2018 18:35:32' prior: 0!
GroebnerBasisBenchmark new run

fixed katsura generators:
testCyclic3	10,600 per second.
testCyclic4	1,870 per second.
testCyclic5	6.69 per second.
testEliminationExample	3,280 per second.
testKatsura2	16,400 per second.
testKatsura3	3,990 per second.
testKatsura4	559 per second.
testModularCyclic3	9,680 per second.
testModularKatsura2	14,800 per second.
testModularKatsura3	4,110 per second.
testModularKatsura4	674 per second.

changed Buchberger>>run to do full reductions (calling reduceFull:).
This seems to be slower when the number of variables is low, but starts to pay off for n > 3
testCyclic3	10,200 per second.
testCyclic4	1,810 per second.
testCyclic5	6.56 per second.
testEliminationExample	3,260 per second.
testKatsura2	16,800 per second.
testKatsura3	4,230 per second.
testKatsura4	554 per second.
testModularCyclic3	9,810 per second.
testModularKatsura2	16,000 per second.
testModularKatsura3	4,470 per second.
testModularKatsura4	695 per second.

testCyclic3	14,400 per second. (11 May 2018, Buchberger>>run replaced Set by OrderedCollection)
testCyclic4	1,810 per second.
testCyclic5	3.37 per second.
testEliminationExample	3,950 per second.
testKatsura2	23,600 per second.
testKatsura3	6,120 per second.
testKatsura4	487 per second.
testModularCyclic3	13,300 per second.
testModularKatsura2	22,000 per second.
testModularKatsura3	6,270 per second.
testModularKatsura4	593 per second.

testCyclic3	14,600 per second. (10 May 2018, optimized Buchberger to reduce the polynomials from S before adding them to basis, fixed definition of the ideal of cyclic n-roots)
testCyclic4	1,860 per second.
testCyclic5	2.64 per second.
testEliminationExample	3,920 per second.
testKatsura2	23,900 per second.
testKatsura3	6,400 per second.
testKatsura4	496 per second.
testModularCyclic3	13,900 per second.
testModularKatsura2	22,500 per second.
testModularKatsura3	6,400 per second.
testModularKatsura4	613 per second.' 

testCyclic3	8,190 per second. (9 May 2018, optimized Buchberger>>run, added i0)
testCyclic4	2,920 per second.
testCyclic5	1,060 per second.
testCyclic6	381 per second.
testEliminationExample	2,820 per second.
testKatsura2	16,300 per second.
testKatsura3	3,930 per second.
testKatsura4	42.2 per second.
testModularCyclic3	7,820 per second.
testModularKatsura2	15,200 per second.
testModularKatsura3	3,630 per second.
testModularKatsura4	54.4 per second.

testCyclic3	4,730 per second. (25 Dec 2017, after refactoring MultivariatePolynomial and removing MonomialIndexedTuple)
testCyclic4	1,040 per second.
testCyclic5	258 per second.
testCyclic6	63.5 per second.
testEliminationExample	1,700 per second.
testKatsura2	13,900 per second.
testKatsura3	2,060 per second.
testKatsura4	16.7 per second.
testModularCyclic3	4,480 per second.
testModularKatsura2	12,800 per second.
testModularKatsura3	1,900 per second.
testModularKatsura4	22.3 per second.' 

testCyclic3	4,400 per second. (optimized GroebnerBasis>>reduce:)
testCyclic4	1,000 per second.
testCyclic5	238 per second.
testCyclic6	58 per second.
testEliminationExample	1,840 per second.
testKatsura2	13,600 per second.
testKatsura3	1,950 per second.
testKatsura4	15.6 per second.
testModularCyclic3	4,270 per second.
testModularKatsura2	12,600 per second.
testModularKatsura3	1,800 per second.
testModularKatsura4	20.6 per second.

testCyclic3	2,260 per second. (modular inversion using extended euclid)
testCyclic4	520 per second.
testCyclic5	124 per second.
testCyclic6	28.9 per second.
testEliminationExample	897 per second.
testKatsura2	6,690 per second.
testKatsura3	869 per second.
testKatsura4	10.6 per second.
testModularCyclic3	2,430 per second.
testModularKatsura2	7,470 per second.
testModularKatsura3	1,050 per second.
testModularKatsura4	15.5 per second.

testCyclic3	2,230 per second. (polynomials as sorted dictionaries monomial -> coefficient)
testCyclic4	512 per second.
testCyclic5	121 per second.
testCyclic6	28.7 per second.
testEliminationExample	867 per second.
testKatsura2	6,700 per second.
testKatsura3	860 per second.
testKatsura4	11 per second.
testModularCyclic3	2,320 per second.
testModularKatsura2	6,960 per second.
testModularKatsura3	858 per second.
testModularKatsura4	12.1 per second.

testCyclic3	2,270 per second. (polynomials as dictionaries monomial -> coefficient)
testCyclic4	511 per second.
testCyclic5	118 per second.
testCyclic6	26.1 per second.
testEliminationExample	816 per second.
testKatsura2	6,750 per second.
testKatsura3	866 per second.
testKatsura4	11.8 per second.
testModularCyclic3	2,410 per second.
testModularKatsura2	6,780 per second.
testModularKatsura3	844 per second.
testModularKatsura4	13.3 per second.

testCyclic3	2,240 per second. (with Groebner bases kept sorted, GroebnerBasis>>initialize)
testCyclic4	520 per second.
testCyclic5	120 per second.
testCyclic6	26 per second.
testEliminationExample	720 per second.
testKatsura2	6,730 per second.
testKatsura3	755 per second.
testKatsura4	34.9 per second.
testModularCyclic3	2,310 per second.
testModularKatsura2	6,720 per second.
testModularKatsura3	727 per second.
testModularKatsura4	33 per second.

testCyclic3	2,140 per second. (reverted Monomial>>hash)
testCyclic4	676 per second.
testCyclic5	112 per second.
testCyclic6	36.2 per second.
testEliminationExample	773 per second.
testKatsura2	6,430 per second.
testKatsura3	821 per second.
testKatsura4	7.72 per second.
testModularCyclic3	2,220 per second.
testModularKatsura2	6,490 per second.
testModularKatsura3	797 per second.
testModularKatsura4	12.6 per second.

testCyclic3	2,240 per second. (defined Monomial>>hash as 'exponents hash')
testCyclic4	682 per second.
testCyclic5	116 per second.
testCyclic6	40.4 per second.
testEliminationExample	827 per second.
testKatsura2	6,650 per second.
testKatsura3	857 per second.
testKatsura4	7.82 per second.
testModularCyclic3	2,370 per second.
testModularKatsura2	6,840 per second.
testModularKatsura3	861 per second.
testModularKatsura4	13.6 per second.

testCyclic3	1,780 per second. (spur 32 bits)
testCyclic4	354 per second.
testCyclic5	26.8 per second.
testCyclic6	12.2 per second.
testEliminationExample	614 per second.
testKatsura2	5,540 per second.
testKatsura3	130 per second.
testKatsura4	10.7 per second.
testModularCyclic3	177 per second.
testModularKatsura2	194 per second.

[self new modularCyclic: 7 :: groebnerBasis] bench
 '3.63 per second.' (spur 32 bits)
 '165 seconds.' 

testCyclic3	1,300 per second.
testCyclic4	264 per second.
testCyclic5	60.1 per second.
testCyclic6	9.7 per second.
testElimination	143 per second.
testKatsura2	4,230 per second.
testKatsura3	407 per second.
testKatsura4	4.06 per second.
testModularCyclic3	175 per second.
testModularKatsura2	194 per second. 

testCyclic3	1,130 per second.
testCyclic4	195 per second.
testCyclic5	48.7 per second.
testCyclic6	9.31 per second.
testElimination	116 per second.
testKatsura2	3,440 per second.
testKatsura3	354 per second.
testKatsura4	2.8 per second.
testModularCyclic3	149 per second.
testModularKatsura2	184 per second.'

'testCyclic3	1,080 per second.
testCyclic4	36.8 per second.
testCyclic5	1.19 per second.
testElimination	77.1 per second.
testKatsura2	3,810 per second.
testKatsura3	26.1 per second.
testModularCyclic3	173 per second.
testModularKatsura2	201 per second.' 

testCyclic3	1,060 per second.
testCyclic4	56.3 per second.
testCyclic5	1.08 per second.
testElimination	241 per second.
testKatsura2	4,790 per second.
testKatsura3	11.5 per second.
testModularCyclic3	173 per second.
testModularKatsura2	200 per second.

testCyclic3	615 per second.
testCyclic4	29.2 per second.
testCyclic5	1.38 per second.
testElimination	43.5 per second.
testKatsura2	2,330 per second.
testKatsura3	7.21 per second.

testCyclic3	632 per second.
testCyclic4	4.34 per second.
testElimination	3.45 per second.
testKatsura2	2,190 per second.
testKatsura3	0.288 per second.

testCyclic3	524 per second.
testCyclic4	4.85 per second.
testElimination	2.82 per second.
testKatsura2	1,950 per second.
testKatsura3	0.251 per second.

testCyclic3	540 per second.
testCyclic4	3.73 per second.
testElimination	2 per second.
testKatsura2	2,130 per second.
testKatsura3	0.257 per second.

testCyclic3	494 per second.
testCyclic4	2.41 per second.
testElimination	1.34 per second.
testKatsura2	1,950 per second.
testKatsura3	5.38 seconds.

testCyclic3	393 per second.
testCyclic4	1.62 per second.
testElimination	1.29 per second.
testKatsura2	1,830 per second.
testKatsura3	6.58 seconds.

old:
testCyclic3	312 per second.
testElimination	0.911 per second.
testKatsura2	1,260 per second.
!

!GroupBenchmark commentStamp: '<historical>' prior: 0!
GroupBenchmark new run

testJ1Order	3.95 per second. (spur 32 bits)
testM12Order	86.7 per second.

testJ1Order	2.39 per second.
testM12Order	57.4 per second.

testJ1Order	2.51 per second.
testM12Order	56.9 per second.
!

!IntegersBenchmark commentStamp: 'len 11/22/2016 11:57:33' prior: 0!
self new run

test1000Factorial	5,620 per second. (spur 32 bits)

test1000Factorial	1,250 per second.
!

!ModularMatrixBenchmark commentStamp: '<historical>' prior: 0!
Some tests on a 300x300 matrix over Z/32003.

self new run

testAddition	384 per second.
testGaussianElimination	1.88 per second.
testImage	1.84 per second.
testKernel	0.736 per second.
testSquared	1.39 per second.
testTransposition	89.8 per second.

testAddition	387 per second.
testGaussianElimination	1.82 per second.
testSquared	1.43 per second.
testTransposition	89.7 per second.

testAddition	203 per second.
testGaussianElimination	1.81 per second.
testSquared	1.32 per second.
testTransposition	66.9 per second.!

!PolynomialBenchmark commentStamp: 'len 5/26/2018 19:40:36' prior: 0!
PolynomialBenchmark new run

testAdditionOverZ	25.4 per second.
testAdditionOverZ2	283 per second.
testDivisionOverQ	5.23 per second.
testDivisionOverZ	5.25 per second.
testFactorizationOverZ17	10.2 per second
testFiniteField	20.1 per second.
testFiniteFieldPolynomialFactorization	336 per second.
testGCDOverQ	8.2 per second.
testGCDOverZ	4.81 per second.
testGCDOverZ2	10.3 per second.
testMultiplication2OverZ	154 per second.
testMultiplication2OverZ2	681 per second.
testMultiplicationOverZ	2.7 per second.
testMultiplicationOverZ2	4,060 per second.
testMultivariatePolynomialAdditionOverZ	106 per second.
testPseudoDivision	5,060 per second.
testPseudoRemainder	5,050 per second.
testRealRoots	24.4 per second.

testFiniteField	18.2 per second. (25 Dec 2017, after refactoring MultivariatePolynomial and removing MonomialIndexedTuple)
testFiniteFieldPolynomialFactorization	255 per second.
testMultivariatePolynomialAdditionOverZ	102 per second.
testPolynomialAdditionOverZ	33.4 per second.
testPolynomialAdditionOverZ2	269 per second.
testPolynomialDivisionOverQ	3.32 per second.
testPolynomialDivisionOverZ	2.96 per second.
testPolynomialGCDOverQ	3.56 per second.
testPolynomialGCDOverZ	4.74 per second.
testPolynomialGCDOverZ2	24.6 per second.
testPolynomialMultiplication2OverZ	168 per second.
testPolynomialMultiplication2OverZ2	686 per second.
testPolynomialMultiplicationOverZ	2.72 per second.
testPolynomialMultiplicationOverZ2	4,090 per second.
testPolynomialPseudoDivision	4,840 per second.
testPolynomialPseudoRemainder	4,810 per second.
testPolynomialRealRoots	40.7 per second.
testRealAlgebraicNumberAddition	2.9 per second.
testRealAlgebraicNumberDivision	241 per second.
testRealAlgebraicNumberProduct	308 per second.
testRealAlgebraicNumberSquare	5,630 per second.

testFiniteField	17.1 per second.
testFiniteFieldPolynomialFactorization	97.8 per second.
testMultivariatePolynomialAdditionOverZ	93.9 per second.
testPolynomialAdditionOverZ	32.6 per second.
testPolynomialAdditionOverZ2	136 per second.
testPolynomialDivisionOverQ	2.63 per second.
testPolynomialDivisionOverZ	2.74 per second.
testPolynomialGCDOverQ	2.88 per second.
testPolynomialGCDOverZ	4.3 per second.
testPolynomialGCDOverZ2	11.3 per second.
testPolynomialMultiplication2OverZ	163 per second.
testPolynomialMultiplication2OverZ2	628 per second.
testPolynomialMultiplicationOverZ	2.7 per second.
testPolynomialMultiplicationOverZ2	3,760 per second.
testPolynomialPseudoDivision	4,110 per second.
testPolynomialPseudoRemainder	4,080 per second.
testPolynomialRealRoots	39.7 per second.
testRealAlgebraicNumberAddition	5.44 seconds.
testRealAlgebraicNumberDivision	154 per second.
testRealAlgebraicNumberProduct	177 per second.
testRealAlgebraicNumberSquare	4,200 per second.

testFiniteField	17.5 per second. (spur 32 bits)
testFiniteFieldPolynomialFactorization	81.3 per second.
testMultivariatePolynomialAdditionOverZ	86.8 per second.
testPolynomialAdditionOverZ	31.2 per second.
testPolynomialAdditionOverZ2	135 per second.
testPolynomialDivisionOverQ	2.57 per second.
testPolynomialDivisionOverZ	2.64 per second.
testPolynomialGCDOverQ	2.44 per second.
testPolynomialGCDOverZ	3.51 per second.
testPolynomialGCDOverZ2	9.86 per second.
testPolynomialMultiplication2OverZ	105 per second.
testPolynomialMultiplication2OverZ2	627 per second.
testPolynomialMultiplicationOverZ	2.72 per second.
testPolynomialMultiplicationOverZ2	3,400 per second.
testPolynomialPseudoDivision	3,660 per second.
testPolynomialPseudoRemainder	3,640 per second.
testPolynomialRealRoots	38.7 per second.
testRealAlgebraicNumberAddition	5.27 seconds.
testRealAlgebraicNumberDivision	148 per second.
testRealAlgebraicNumberProduct	170 per second.
testRealAlgebraicNumberSquare	3,970 per second.

testFiniteField	14.6 per second.
testFiniteFieldPolynomialFactorization	58.4 per second.
testMultivariatePolynomialAdditionOverZ	51.7 per second.
testPolynomialAdditionOverZ	15.8 per second.
testPolynomialAdditionOverZ2	94 per second.
testPolynomialDivisionOverQ	1.66 per second.
testPolynomialDivisionOverZ	1.67 per second.
testPolynomialGCDOverQ	1.54 per second.
testPolynomialGCDOverZ	2.22 per second.
testPolynomialGCDOverZ2	7.01 per second.
testPolynomialMultiplication2OverZ	78 per second.
testPolynomialMultiplication2OverZ2	384 per second.
testPolynomialMultiplicationOverZ	0.598 per second.
testPolynomialMultiplicationOverZ2	2,220 per second.
testPolynomialPseudoDivision	2,300 per second.
testPolynomialPseudoRemainder	2,300 per second.
testPolynomialRealRoots	27.3 per second.
testRealAlgebraicNumberAddition	5.24 seconds.
testRealAlgebraicNumberDivision	110 per second.
testRealAlgebraicNumberProduct	132 per second.
testRealAlgebraicNumberSquare	2,720 per second.

testFiniteField	11.1 per second.
testFiniteFieldPolynomialFactorization	58 per second.
testMultivariatePolynomialAdditionOverZ	FAILED
testPolynomialAdditionOverZ	11.9 per second.
testPolynomialAdditionOverZ2	76.2 per second.
testPolynomialDivisionOverQ	1.23 per second.
testPolynomialDivisionOverZ	1.12 per second.
testPolynomialGCDOverQ	1.16 per second.
testPolynomialGCDOverZ	1.45 per second.
testPolynomialGCDOverZ2	4.64 per second.
testPolynomialMultiplication2OverZ	33.9 per second.
testPolynomialMultiplication2OverZ2	58.4 per second.
testPolynomialMultiplicationOverZ	0.588 per second.
testPolynomialMultiplicationOverZ2	2,260 per second.
testPolynomialPseudoDivision	1,210 per second.
testPolynomialPseudoRemainder	1,220 per second.
testPolynomialRealRoots	22.8 per second.
testRealAlgebraicNumberAddition	5.28 seconds.
testRealAlgebraicNumberDivision	74.1 per second.
testRealAlgebraicNumberProduct	88.6 per second.
testRealAlgebraicNumberSquare	2,020 per second.

testFiniteField	10.8 per second.
testFiniteFieldPolynomialFactorization	55.1 per second.
testMultivariatePolynomialAdditionOverZ	FAILED
testPolynomialAdditionOverZ	11.9 per second.
testPolynomialAdditionOverZ2	69 per second.
testPolynomialDivisionOverQ	1.2 per second.
testPolynomialDivisionOverZ	1.04 per second.
testPolynomialGCDOverQ	1.12 per second.
testPolynomialGCDOverZ	1.38 per second.
testPolynomialGCDOverZ2	4.25 per second.
testPolynomialMultiplication2OverZ	33 per second.
testPolynomialMultiplication2OverZ2	61.4 per second.
testPolynomialMultiplicationOverZ	0.578 per second.
testPolynomialMultiplicationOverZ2	2,220 per second.
testPolynomialPseudoDivision	1,220 per second.
testPolynomialPseudoRemainder	1,220 per second.
testPolynomialRealRoots	23.1 per second.
testRealAlgebraicNumberAddition	6.11 seconds.
testRealAlgebraicNumberDivision	78.2 per second.
testRealAlgebraicNumberProduct	90.3 per second.
testRealAlgebraicNumberSquare	2,020 per second.

testFiniteField	11.3 per second.
testFiniteFieldPolynomialFactorization	54.5 per second.
testPolynomialAdditionOverZ	10.8 per second.
testPolynomialAdditionOverZ2	75 per second.
testPolynomialDivisionOverQ	1.17 per second.
testPolynomialDivisionOverZ	1.06 per second.
testPolynomialGCDOverQ	1.11 per second.
testPolynomialGCDOverZ	1.38 per second.
testPolynomialGCDOverZ2	4.53 per second.
testPolynomialMultiplication2OverZ	32 per second.
testPolynomialMultiplication2OverZ2	58 per second.
testPolynomialMultiplicationOverZ	0.563 per second.
testPolynomialMultiplicationOverZ2	2,120 per second.
testPolynomialPseudoDivision	1,220 per second.
testPolynomialPseudoRemainder	1,190 per second.
testPolynomialRealRoots	23 per second.
testRealAlgebraicNumberAddition	5.96 seconds.
testRealAlgebraicNumberDivision	70.8 per second.
testRealAlgebraicNumberProduct	81.7 per second.
testRealAlgebraicNumberSquare	1,820 per second!

!SmallMatrixBenchmark commentStamp: 'len 1/22/2018 20:06:14' prior: 0!
This benchmark tests some basic operations on 64x64 matrices over Z, Z/2Z, and Z/32003Z.

self new run

testAdditionZ	7,830 per second. (23/1/2018)
testAdditionZ2	216,000 per second.
testAdditionZp	8,140 per second.
testCopyZ	158,000 per second.
testCopyZ2	448,000 per second.
testCopyZp	176,000 per second.
testImageZ	FAILED
testImageZ2	35.5 per second.
testImageZp	141 per second.
testKernelZ	FAILED
testKernelZ2	14.4 per second.
testKernelZp	61.5 per second.
testMultiplicationZ	164 per second.
testMultiplicationZ2	171 per second.
testMultiplicationZp	130 per second.
testTranspositionZ	4,520 per second.
testTranspositionZ2	1,400 per second.
testTranspositionZp	1,930 per second.

testAdditionZ	7,770 per second.
testAdditionZ2	88,100 per second.
testAdditionZp	8,140 per second.
testCopyZ	145,000 per second.
testCopyZ2	441,000 per second.
testCopyZp	164,000 per second.
testImageZ	FAILED
testImageZ2	31.2 per second.
testImageZp	133 per second.
testKernelZ	FAILED
testKernelZ2	13.7 per second.
testKernelZp	59.7 per second.
testMultiplicationZ	169 per second.
testMultiplicationZ2	158 per second.
testMultiplicationZp	128 per second.
testTranspositionZ	4,360 per second.
testTranspositionZ2	1,090 per second.
testTranspositionZp	1,960 per second.

testAdditionZ	7,960 per second.
testAdditionZ2	85,700 per second.
testAdditionZp	7,710 per second.
testCopyZ	162,000 per second.
testCopyZ2	477,000 per second.
testCopyZp	181,000 per second.
testMultiplicationZ	174 per second.
testMultiplicationZ2	161 per second.
testMultiplicationZp	130 per second.
testTranspositionZ	4,600 per second.
testTranspositionZ2	1,090 per second.
testTranspositionZp	2,110 per second.

testAdditionZ	7,840 per second. (spur 32 bits)
testAdditionZ2	86,600 per second.
testCopyZ	144,000 per second.
testCopyZ2	471,000 per second.
testMultiplicationZ	171 per second.
testMultiplicationZ2	159 per second.
testTranspositionZ	4,390 per second.
testTranspositionZ2	1,010 per second.

testAdditionZ	5,220 per second.
testAdditionZ2	42,600 per second.
testCopyZ	84,700 per second.
testCopyZ2	210,000 per second.
testMultiplicationZ	122 per second.
testMultiplicationZ2	106 per second.
testTranspositionZ	2,020 per second.
testTranspositionZ2	603 per second.

testAdditionZ	4,500 per second.
testAdditionZ2	33,700 per second.
testCopyZ	58,200 per second.
testCopyZ2	164,000 per second.
testMultiplicationZ	20.1 per second.
testMultiplicationZ2	7.81 per second.
testTranspositionZ	1,580 per second.
testTranspositionZ2	565 per second.
!

!SparsePolynomialMultiplicationBenchmark commentStamp: '<historical>' prior: 0!
Timings giving in [1] on computers with 0.8ghz - 1ghz intel cpus: general purpose system 20s-100s, tuned systems 2.3s-10s. For big coefficients: singular 28s, pari 77s.

[1] R.J. Fateman, Comparing the speed of sparse polynomial multiplication.


self new run

testBigCoefficientsProduct	8.5 seconds. (25 Dec 2017, after refactoring MultivariatePolynomial and removing MonomialIndexedTuple)
testBigExponentsProduct	6.38 seconds.
testProduct	0.295 per second.

testBigCoefficientsProduct	8.39 seconds. (polynomials as sorted dictionaries monomial -> coefficient)
testBigExponentsProduct	9.86 seconds.
testProduct	0.328 per second.

testBigCoefficientsProduct	10.5 seconds. (polynomials as dictionaries monomial -> coefficient)
testBigExponentsProduct	10.2 seconds.
testProduct	0.289 per second.
!

!TupleConvolutionBenchmark commentStamp: 'len 6/6/2019 09:09:54' prior: 0!
self new run



testConvolution	3.02  runs per second!

!CASBenchmark commentStamp: '<historical>' prior: 0!
These benchmarks show some of the fundamental bottlenecks for a computational algebra system in pure Smalltalk. Many important algorithms end up doing these operations.

To run the benchmarks, just doIt:
self new run

Cuis 4.5 with Cog 4.5 #9 (r3370, 2015-06-04), 32 bits, Intel i5-3210M @ 2.5Ghz, cache 3072 KB, 4990 bobomips, running inside virtualbox
testEqualsBytes	40,600 per second.
testEqualsWords	36,100 per second.
testHashBytes	245,000 per second.
testHashWords	23,500 per second.
testModularConvolutionBytes	20.6 per second.
testModularConvolutionWords	16.9 per second.
testModularDotProductBytes	36,900 per second.
testModularDotProductWords	30,400 per second.
testModularSumBytes	26,200 per second.
testModularSumWords	21,600 per second.
testPermutationCompositionArray	33,900 per second.
testPermutationCompositionWords	31,400 per second.

Cuis 5.0 with Cog 5.0-201611161032, 32 bits, Intel i5-3210M @ 2.5Ghz, cache 3072 KB, 4990 bobomips, running inside virtualbox
testEqualsBytes	59,900 per second.
testEqualsWords	49,600 per second.
testHashBytes	249,000 per second.
testHashWords	23,000 per second.
testModularConvolutionBytes	27.2 per second.
testModularConvolutionWords	23.9 per second.
testModularDotProductBytes	41,000 per second.
testModularDotProductWords	37,000 per second.
testModularSumBytes	37,900 per second.
testModularSumWords	34,100 per second.
testPermutationCompositionArray	69,100 per second.
testPermutationCompositionWords	51,900 per second.
!

!AbelianGroupTest methodsFor: 'as yet unclassified' stamp: 'len 5/13/2019 20:38:26'!
testAbelianGroup: G
	| one a b c |
	one _ G identity.
	a _ G atRandomBits: 100.
	b _ G atRandomBits: 100.
	c _ G atRandomBits: 100.
	self assert: one ∑ a = a.
	self assert: a ∑ one = a.
	self assert: a ∑ b = (b ∑ a). "commutativity"
	self assert: (a ∑ b ∑ c) = (a ∑ (b ∑ c)). "associativity"! !

!AbelianGroupTest methodsFor: 'as yet unclassified' stamp: 'len 5/15/2019 00:06:32'!
testAbelianGroupHomomorphism: phi
	| G H a b |
	G _ phi domain.
	H _ phi codomain.
	a _ G atRandomBits: 100.
	b _ G atRandomBits: 100.
	self assert: (phi value: G identity) = H identity.
	self assert: (phi value: a∑b) = ((phi value: a)∑(phi value: b))! !

!AbelianGroupTest methodsFor: 'as yet unclassified' stamp: 'len 5/28/2019 09:47:47'!
testAsPermutationGroup
	| A |
	A _ AbelianGroup orders: #(2 5 4 2).
	self assert: A asPermutationGroup asAbelianGroup invariants = A invariants! !

!AbelianGroupTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 08:53:00'!
testDirectSum
	| A B C |
	A _ É asAbelianGroup.
	B _ (É / (2 to: 10) atRandom) asAbelianGroup.
	C _ A ê B.
	self testAbelianGroup: C.
	C -< {A. B} do: [:each| self testAbelianGroupHomomorphism: each].
	{A. B} >- C do: [:each| self testAbelianGroupHomomorphism: each]! !

!AbelianGroupTest methodsFor: 'as yet unclassified' stamp: 'len 5/26/2019 12:18:23'!
testExponent
	| G |
	G _ AbelianGroup orders: #(2 3 7).
	self assert: G exponent = 42.
	G _ AbelianGroup orders: #(2 4 6).
	self assert: G exponent = 12! !

!AbelianGroupTest methodsFor: 'as yet unclassified' stamp: 'len 5/28/2019 09:10:30'!
testFreeAbelianGroup
	| G |
	G _ AbelianGroup orders: #(0 0).
	self assert: G rank = 2.
	self assert: G invariants = #(0 0).
	self assert: G torsion invariants = #().
	self assert: G torsion isTrivial.
	self assert: G isTorsion not.
	self assert: G isFree.
	self assert: G torsion isTorsion.
	self assert: G torsion isFree "because it's trivial"! !

!AbelianGroupTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 08:53:07'!
testIntegerTuples
	| M |
	M _ É ^ (1 to: 10) atRandom.
	self testAbelianGroup: M asAbelianGroup.
	self testAbelianGroupHomomorphism: (M projection: (1 to: M rank) atRandom) asAbelianGroupMap! !

!AbelianGroupTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 08:55:20'!
testIntegers
	| G x1 x2 g1 g2 |
	G _ É asAbelianGroup.
	self testAbelianGroup: G.
	x1 _ É atRandomBits: 100.
	x2 _ É atRandomBits: 100.
	g1 _ G !! x1.
	g2 _ G !! x2.
	self assert: É !! g1 = x1.
	self assert: É !! G identity = 0.
	self assert: É !! (g1 ∑ g2) = (x1 + x2).
	self assert: É !! g1 inverse = x1 negated.! !

!AbelianGroupTest methodsFor: 'as yet unclassified' stamp: 'len 5/28/2019 09:10:45'!
testInvariants
	self assert: (AbelianGroup orders: #(1 3 5 12)) invariants = #(3 60).
	self assert: (AbelianGroup orders: #(2 3)) invariants = #(6).
	self assert: (AbelianGroup orders: #(6)) invariants = #(6).
	self assert: (AbelianGroup orders: #(2 6)) invariants = #(2 6).
	self assert: (AbelianGroup orders: #(3 4 5)) invariants = #(60).
	self assert: (AbelianGroup orders: #(0 6)) invariants = #(0 6).
! !

!AbelianGroupTest methodsFor: 'as yet unclassified' stamp: 'len 5/29/2019 12:36:50'!
testInvariantsAndPrimaryInvariants
	| invariants primaryInvariants A |
	invariants _ {2^2*3*(5^2). 2^5*(3^3)*(5^2)}.
	primaryInvariants _ {2^2. 2^5. 3. 3^3. 5^2. 5^2} asBag.
	A _ AbelianGroup orders: invariants shuffled.
	self assert: A invariants = invariants.
	self assert: A primaryInvariants = primaryInvariants.
	A _ AbelianGroup orders: primaryInvariants asArray shuffled.
	self assert: A invariants = invariants.
	self assert: A primaryInvariants = primaryInvariants! !

!AbelianGroupTest methodsFor: 'as yet unclassified' stamp: 'len 5/26/2019 12:18:23'!
testIsCyclic
	| G |
	G _ AbelianGroup orders: #(2 3).
	self assert: G isCyclic.
	G _ AbelianGroup orders: #(6).
	self assert: G isCyclic.
	G _ AbelianGroup orders: #(2 2).
	self assert: G isCyclic not.
	G _ AbelianGroup orders: #(2 4).
	self assert: G isCyclic not.
	G _ AbelianGroup orders: #().
	self assert: G isCyclic.
	G _ AbelianGroup orders: #(0).
	self assert: G isCyclic.
	G _ AbelianGroup orders: #(3 4 5).
	self assert: G isCyclic! !

!AbelianGroupTest methodsFor: 'as yet unclassified' stamp: 'len 4/22/2020 18:56:59'!
testIsTrivial
	| G |
	G _ AbelianGroup orders: #().
	self assert: G isTrivial.
	G _ AbelianGroup orders: #(1 1).
	self assert: G isTrivial.
	G _ AbelianGroup orders: #(1 1 2).
	self assert: G isTrivial not.
	G _ AbelianGroup orders: #(1 1 0).
	self assert: G isTrivial not.
	G _ AbelianGroup orders: #(2).
	self assert: G isTrivial not.
	G _ AbelianGroup orders: #(0).
	self assert: G isTrivial not.
! !

!AbelianGroupTest methodsFor: 'as yet unclassified' stamp: 'len 5/29/2019 12:37:05'!
testMixedAbelianGroup
	| G |
	G _ AbelianGroup orders: #(0 0 2 3).
	self assert: G rank = 2.
	self assert: G primaryInvariants = #(0 0 2 3) asBag.
	self assert: G torsion primaryInvariants = #(2 3) asBag.
	self assert: G isTorsion not.
	self assert: G isFree not.
	self assert: G isMixed.
	self assert: G torsion isTorsion.
	self assert: G torsion isFree not.
	self assert: G torsionFree isFree.
	self assert: G torsionFree rank = 2! !

!AbelianGroupTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 08:55:36'!
testModularIntegers
	| R |
	R _ É / (2 to: 10) atRandom.
	self testAbelianGroup: R asAbelianGroup.
	self testAbelianGroupHomomorphism: R projection asAbelianGroupMap! !

!AbelianGroupTest methodsFor: 'as yet unclassified' stamp: 'len 5/26/2019 12:18:23'!
testOrder
	self assert: (AbelianGroup orders: #(2 3)) size = 6.
	self assert: (AbelianGroup orders: #(0 2 3)) size isInfinite! !

!AbelianGroupTest methodsFor: 'as yet unclassified' stamp: 'len 5/26/2019 12:18:23'!
testOrderOfElements
	| G g |
	G _ AbelianGroup orders: #(2 3 4 5 0).
	g _ G !! [:a :b :c :d :e| a*(b^2)*(d^4)].
	self assert: g order = 30.
	g _ G !! [:a :b :c :d :e| a*e].
	self assert: g order = 0! !

!AbelianGroupTest methodsFor: 'as yet unclassified' stamp: 'len 5/29/2019 12:37:13'!
testTorsionAbelianGroup
	| G |
	G _ AbelianGroup orders: #(2 3).
	self assert: G rank = 0.
	self assert: G primaryInvariants = #(2 3) asBag.
	self assert: G = G torsion.
	self assert: G isTorsion.
	self assert: G isFree not.
	self assert: G isMixed not.
	self assert: G torsionFree isTrivial! !

!AlgebraicGeometryTest methodsFor: 'affine' stamp: 'len 5/23/2020 09:33:01'!
testAffinePlaneCurveMultiplicity
	| A C |
	A _ AffineSpace new: #(x y) over: Ñ.
	C _ A subscheme: A coordinateRing !! [:x :y| y^2 - (x^3)].
	self assert: (C multiplicityAt: (1,1)) = 1.
	self assert: (C multiplicityAt: (0,0)) = 2! !

!AlgebraicGeometryTest methodsFor: 'affine' stamp: 'len 5/23/2020 08:56:07'!
testAffineSchemeCartesianProduct
	| X1 X2 P |
	X1 _ AffineVariety circle.
	X2 _ AffineVariety romanSurface.
	P _ X1 ◊ X2.
	self assert: (P ambient -< {X1 ambient. X2 ambient} collect: [:each| P apply: each]) = {X1. X2}.
	self assert: X1 dimension + X2 dimension = P dimension.
	self assert: X1 ambient dimension + X2 ambient dimension = P ambient dimension.
	self assert: (X1 pointsCountOver: É/3) * (X2 pointsCountOver: É/3) = (P pointsCountOver: É/3).
	self assert: (P satisfies: (5,2,6,2,6) % 7)! !

!AlgebraicGeometryTest methodsFor: 'affine' stamp: 'len 5/23/2020 09:33:01'!
testAffineSchemeCreation
	| A x y z X Y |
	A _ AffineSpace new: 3 over: Ñ.
	x _ A coordinateRing x.
	y _ A coordinateRing y.
	z _ A coordinateRing z.
	X _ A subscheme: x - y.
	Y _ X subscheme: {x^2 - (z^3). y^3 - (z^4)}.
	self assert: X ambient = A.
	"Y is defined as subscheme of X, so it contains the equations of X plus the two new equations, but its ambient space is still A (not X):"
	self assert: Y ambient = A! !

!AlgebraicGeometryTest methodsFor: 'affine' stamp: 'len 10/18/2016 20:58'!
testAffineSpace
	| K A |
	K _ PrimeField new: 23.
	A _ AffineSpace new: 3 over: K.
	self assert: A dimension = 3.
	self assert: A scalars = K.
	self assert: A coordinateRing = (K polynomialsIn: 3).
	self assert: A ambient = A.
	self assert: A coordinateRing spec = A! !

!AlgebraicGeometryTest methodsFor: 'affine' stamp: 'len 5/23/2020 08:56:11'!
testProjectiveClosure
	"From Magma Handbook example Scheme_projective-closure (H118E23)."
	| A1 u v X PX X2 |
	A1 _ AffineSpace new: #(u v) over: É/5.
	u _ A1 coordinateRing x: #u.
	v _ A1 coordinateRing x: #v.
	X _ A1 subscheme: u^2 - (v^5).
	PX _ X projectiveClosure.
	self assert: (PX patch: 3) = X.
	X2 _ PX patch: 2.
	self assert: X2 projectiveClosure = X projectiveClosure! !

!AlgebraicGeometryTest methodsFor: 'affine' stamp: 'len 5/23/2020 08:56:14'!
testProjectiveEmbedding
	| A1 u v X PX affinePointsEmbedded projectivePoints |
	A1 _ AffineSpace new: #(u v) over: É/5.
	u _ A1 coordinateRing x: #u.
	v _ A1 coordinateRing x: #v.
	X _ A1 subscheme: u^2 - (v^5).
	PX _ X projectiveClosure.
	affinePointsEmbedded _ X points asSet apply: X projectiveEmbedding.
	projectivePoints _ PX points asSet.
	self assert: projectivePoints >= affinePointsEmbedded.
	"the projective scheme has one more point at infinity:"
	self assert: affinePointsEmbedded size + 1 = projectivePoints size! !

!AlgebraicGeometryTest methodsFor: 'conics' stamp: 'len 5/23/2020 09:33:01'!
testConicCoefficients
	self assert: (Conic coefficients: (1,2,3,4,5,6)) coefficients = (1,2,3,4,5,6).
	self assert: (Conic polynomial: (Ñ polynomialsIn: 3) !! [:x :y :z| x^2 + (x*y*5) + (y^2) + (z^2)]) coefficients = (1,5,0,1,0,1)! !

!AlgebraicGeometryTest methodsFor: 'conics' stamp: 'len 5/23/2020 09:33:01'!
testConicDeterminant
	self assert: (Conic coefficients: ((1,2,3,4,5,6) over: Ñ)) determinant = (41/4)! !

!AlgebraicGeometryTest methodsFor: 'conics' stamp: 'len 5/23/2020 09:33:01'!
testConicIsSmooth
	self assert: (Conic coefficients: ((1,-1,0) over: Ñ)) isSmooth not.
	self assert: (Conic coefficients: (1,1,1,1,1,0) % 2) isSmooth! !

!AlgebraicGeometryTest methodsFor: 'general' stamp: 'len 5/23/2020 09:33:01'!
testDifference
	| A x y C X2 D O |
	A _ AffineSpace new: 2 over: Ñ.
	x _ A coordinateRing x.
	y _ A coordinateRing y.
	C _ A subscheme: x * y. "union of x-axis and y-axis"
	X2 _ A subscheme: x^2. "y-axis with double multiplicity"
	D _ X2 - C. "y-axis with multiplicity 1"
	self assert: D ideal = (A coordinateRing * x).
	O _ A subscheme: {x. y}.
	D _ C - O.
	self assert: D = C.
	self assert: (C - A) isEmpty "removing the ambient space removes all"! !

!AlgebraicGeometryTest methodsFor: 'general' stamp: 'len 5/23/2020 09:33:01'!
testEllipticCurvesAreSmooth
	| R x y C |
	R _ Ñ polynomialsIn: #(x y z).
	x _ R x.
	y _ R y.
	C _ R / (x^3 - (x*3) + 3 - (y^2) homogenizedIn: 3) :: proj.
	self assert: C isSmooth.
	C _ R / (x^3 + x - (y^2) homogenizedIn: 3) :: proj.
	self assert: C isSmooth.
	C _ R / (x^3 - x - (y^2) homogenizedIn: 3) :: proj.
	self assert: C isSmooth! !

!AlgebraicGeometryTest methodsFor: 'general' stamp: 'len 5/23/2020 09:33:01'!
testEmpty
	| A X |
	A _ Ñ polynomialsIn: #(x y z).
	X _ A / {A continuantOfOrder: 2. A continuantOfOrder: 3} :: spec.
	self assert: X isEmpty! !

!AlgebraicGeometryTest methodsFor: 'general' stamp: 'len 5/23/2020 09:33:01'!
testEqualVarietiesDifferentIdeals
	| A x I I2 V V2 |
	A _ Ñ polynomials.
	x _ A x.
	I _ A * {x}.
	I2 _ A * {x^2}.
	V _ I variety.
	V2 _ I2 variety.
	self assert: V = V2.
	self assert: I ~= I2! !

!AlgebraicGeometryTest methodsFor: 'general' stamp: 'len 5/23/2020 09:33:01'!
testEqualVarietiesDifferentIdeals2
	| A x y I I2 V V2 |
	A _ Ñ polynomialsIn: #(x y).
	x _ A x.
	y _ A y.
	I _ A * {x. y}.
	I2 _ A * {x^2. y}.
	V _ I variety.
	V2 _ I2 variety.
	self assert: V = V2.
	self assert: I ~= I2! !

!AlgebraicGeometryTest methodsFor: 'general' stamp: 'len 5/23/2020 09:33:01'!
testFinite
	| A x y X |
	A _ Ñ polynomialsIn: #(x y).
	x _ A x.
	y _ A y.
	X _ A / {x*x - 1. y*y - (x*x) - 3} :: spec.
	self assert: X isFinite! !

!AlgebraicGeometryTest methodsFor: 'general' stamp: 'len 5/23/2020 09:33:01'!
testIntersection
	| A x y V V2 W |
	A _ Ñ polynomialsIn: #(x y).
	x _ A x.
	y _ A y.
	V _ A / {y} :: spec.
	V2 _ A / {x*x - 1} :: spec.
	W _ V /\ V2.
	self assert: (W satisfies: (1, 0)).
	self assert: (W satisfies: (0, 1)) not! !

!AlgebraicGeometryTest methodsFor: 'general' stamp: 'len 5/23/2020 09:33:01'!
testLinearSubspaceAsAlgebraicVariety
	| S V |
	S _ Ñ ^ 3 grassmannian: 2 :: atRandomBits: 10.
	V _ S asAlgebraicVariety.
	self assert: V dimension + 1 = S rank. "because it's projective"
	self assert: (V satisfies: (S x: 1) coordinates).
	self assert: (V satisfies: (S x: 2) coordinates)! !

!AlgebraicGeometryTest methodsFor: 'general' stamp: 'len 5/23/2020 09:33:01'!
testLocalAndGlobalDimension
	"'A Singluar Introduction to Commutative Algebra', Example A.8.4 (local and global dimension)."
	| R I X |
	R _ Ñ polynomialsIn: #(x y z).
	I _ R * (R generate: [:x :y :z| {x*z. y*z}]).
	X _ (R / I) spec.
	self assert: X dimension = 2. "global dimension of X"
	self assert: (X !! (0,0,0)) stalk dimension = 2. "dimension of X at (0,0,0)"
	self assert: (X !! (1,0,0)) stalk dimension = 2. "dimension of X at (1,0,0)"
	self assert: (X !! (0,0,1)) stalk dimension = 1. "dimension of X at (0,0,1)"! !

!AlgebraicGeometryTest methodsFor: 'general' stamp: 'len 5/23/2020 09:31:47'!
testMorphismsOfProjectiveVarieties
	"'A Singular Introduction To Commutative Algebra', Example A.6.8 (morphisms of projective varieties)."
	| P A x y z X f1 f2 f3 I J Y phi Z |
	P _ ProjectiveSpace new: #(x y z) over: Ü. "å^2à"
	A _ P coordinateRing. "à[x,y,z]"
	x _ A x. y _ A y. z _ A z.
	X _ P subscheme: {z^3 - (x*(y^2)) + (y^3)}.
	f1 _ x*z. f2 _ x*y. f3 _ x^2 + (y*z).
	"In order for (f1,f2,f3) to define a projective morphism (not just a rational map) it must never be zero at any point of X, this means the intersection of X with V(J) must be empty:"
	I _ X ideal.
	J _ A * {f1. f2. f3}.
	self assert: (A / (I + J)) dimension = 0.
	Y _ P subscheme: J.
	self assert: (X /\ Y) isEmpty.
	phi _ X to: P representatives: {f1. f2. f3}.
	"The image is a curve of degree 6:"
	Z _ phi image.
	self assert: Z isCurve.
	self assert: Z degree = 6! !

!AlgebraicGeometryTest methodsFor: 'general' stamp: 'len 5/23/2020 09:33:01'!
testMultiplicity
	"Example from Sage documentation."
	| A X q1 q2 |
	A _ AffineSpace new: 4 over: Ñ.
	X _ A subscheme: (A coordinateRing !! [:x :y :z :w| {z*y - (x^7). w - (2*z)}]).
	q1 _ X !! (Ñ tuple: {1. (1/3). 3. 6}).
	q2 _ X !! (Ñ zeroTuple: 4).
	self assert: q1 multiplicity = 1.
	self assert: q2 multiplicity = 2! !

!AlgebraicGeometryTest methodsFor: 'general' stamp: 'len 5/23/2020 09:33:01'!
testMultiplicity2
	"Example from Sage documentation."
	| P X q1 q2 q3 |
	P _ ProjectiveSpace new: 4 over: Ñ.
	X _ P subscheme: (P coordinateRing !! [:x :y :z :w :t| {y^2 - (x*t). w^7 - (t*w*(x^5)) - (z^7)}]).
	q1 _ X !! (0,0,1,1,1).
	self assert: q1 multiplicity = 1.
	q2 _ X !! (1,0,0,0,0).
	self assert: q2 multiplicity = 3.
	q3 _ X !! (0,0,0,0,1).
	self assert: q3 multiplicity = 7! !

!AlgebraicGeometryTest methodsFor: 'general' stamp: 'len 5/23/2020 09:31:47'!
testMultiplicity3
	"Example from Sage documentation."
	| P X q |
	P _ ProjectiveSpace new: 3 over: Ü.
	X _ P subscheme: (P coordinateRing !! [:x :y :z :w| z^5*(x^2)*w - (y^8)]).
	q _ X !! (2,0,0,1).
	self assert: q multiplicity = 5! !

!AlgebraicGeometryTest methodsFor: 'general' stamp: 'len 5/23/2020 09:33:01'!
testMultiplicityAndTangentCone
	"'A Singular Introduction to Commutative Algebra', Example A.8.5."
	| R C T p |
	R _ Ñ polynomialsIn: #(x y).
	C _ (R / (R !! [:x :y| x^3 - y squared])) spec.
	p _ C !! (0,0).
	self assert: p multiplicity = 2.
	T _ (R / (R !! [:x :y| y^2])) spec.
	self assert: p tangentCone = T.
"	L _ (R / (R !! [:x :y| 100 atRandom * x + (100 atRandom * y)])) spec
	...
"! !

!AlgebraicGeometryTest methodsFor: 'general' stamp: 'len 5/23/2020 09:33:01'!
testNotEmpty
	| A x y X |
	A _ Ñ polynomialsIn: #(x y).
	x _ A x.
	y _ A y.
	X _ A  / {x*x - 1. y*y - (x*x) - 3} :: spec.
	self assert: X isEmpty not! !

!AlgebraicGeometryTest methodsFor: 'general' stamp: 'len 5/23/2020 09:33:01'!
testNotFinite
	| A x y X |
	A _ Ñ polynomialsIn: #(x y).
	x _ A x.
	y _ A y.
	X _ A / {y*y - (x*x) - 3} :: spec.
	self assert: X isFinite not! !

!AlgebraicGeometryTest methodsFor: 'general' stamp: 'len 5/23/2020 09:33:01'!
testReduced
	| A R x y z X |
	A _ AffineSpace new: 3 over: Ñ.
	R _ A coordinateRing.
	x _ R x.
	y _ R y.
	z _ R z.
	X _ A subscheme: {x*(y^3). x^2*z}.
	self assert: X isReduced not.
	self assert: X reduced = (A subscheme: {x*y. x*z})! !

!AlgebraicGeometryTest methodsFor: 'general' stamp: 'len 5/23/2020 09:33:01'!
testRingHomomorphismSpec
	| A B x y phi |
	A _ Ñ polynomialsIn: #(x y z).
	B _ Ñ polynomialsIn: #(x y).
	x _ B x.
	y _ B y.
	phi _ A to: B evaluating: [:f| f value: {x-y. x. y}].
	self assert: phi spec domain = B spec.
	self assert: phi spec codomain = A spec.
	self assert: phi spec asRingMap = phi! !

!AlgebraicGeometryTest methodsFor: 'general' stamp: 'len 5/23/2020 09:33:01'!
testSingularCubics
	| R x y C |
	R _ Ñ polynomialsIn: #(x y z).
	x _ R x.
	y _ R y.
	C _ R / (x^3 - (y^2) homogenizedIn: 3) :: proj.
	self assert: (C !! (1,1,1)) isSmooth.
	self assert: (C !! (0,0,1)) isSmooth not.
	self assert: C isSingular.
	C _ R / (x^3 + (x^2) - (y^2) homogenizedIn: 3) :: proj.
	self assert: C isSingular! !

!AlgebraicGeometryTest methodsFor: 'general' stamp: 'len 5/23/2020 09:33:01'!
testSmoothness
	| R C |
	R _ Ñ polynomialsIn: #(x y).
	"cuspidal curve:"
	C _ (R / (R !! [:x :y| y^2 - (x^3)])) spec.
	self assert: C isSmooth not.
	self assert: C isSingular.
	self assert: (C !! (1,1)) isSmooth.
	self assert: (C !! (0,0)) isSmooth not! !

!AlgebraicGeometryTest methodsFor: 'general' stamp: 'len 5/23/2020 09:32:13'!
testSmoothnessOverCC
	| P R C |
	P _ ProjectiveSpace new: 2 over: Ü.
	R _ P coordinateRing.
	C _ P subscheme: R !! [:x :y :z| x].
	self assert: C isSingular not.
	C _ P subscheme: R !! [:x :y :z| y^2*z - (x^3)].
	self assert: C isSingular.
	C _ P subscheme: R !! [:x :y :z| y^2*z - (x^3) + (z^3)].
	self assert: C isSingular not! !

!AlgebraicGeometryTest methodsFor: 'general' stamp: 'len 5/23/2020 08:57:20'!
testSmoothnessOverFiniteField
	| P R C |
	P _ ProjectiveSpace new: 2 over: É/19.
	R _ P coordinateRing.
	C _ P subscheme: R !! [:x :y :z| x^3 + (y^3) + (z^3)].
	self assert: C isSingular not.
	C _ P subscheme: R !! [:x :y :z| x^4 - (x*(z^3))].
	self assert: C isSingular.
	C _ P subscheme: R !! [:x :y :z| x^5 + (y^5*19) + (z^5)].
	self assert: C isSingular.
	C _ P subscheme: R !! [:x :y :z| x^5 + (y^5*9) + (z^5)].
	self assert: C isSingular not! !

!AlgebraicGeometryTest methodsFor: 'general' stamp: 'len 5/23/2020 09:33:17'!
testSmoothnessOverQQ
	| P C |
	P _ ProjectiveSpace new: 2 over: Ñ.
	C _ P subscheme: P coordinateRing !! [:x :y :z| x^3 - (y^2*z)].
	self assert: C isSingular! !

!AlgebraicGeometryTest methodsFor: 'general' stamp: 'len 5/23/2020 08:57:40'!
testSpecZ
	self assert: É spec dimension = 1.
	self assert: É spec isNoetherian.
	self assert: (É spec includes: É*5).
	self deny: (É spec includes: É*6).
	self assert: É spec isInitial not.
	self assert: É spec isTerminal! !

!AlgebraicGeometryTest methodsFor: 'general' stamp: 'len 5/23/2020 08:57:54'!
testSpecZSubschemes
	self assert: É spec >= (É / 2) spec.
	self assert: (É / 10) spec >= (É / 5) spec.
	self deny: (É / 10) spec >= (É / 3) spec.
	self assert: (É / 10) spec /\ (É / 15) spec = (É / 5) spec.
	self assert: (É / 10) spec \/ (É / 15) spec = (É / 30) spec! !

!AlgebraicGeometryTest methodsFor: 'finite rings' stamp: 'len 5/23/2020 08:56:16'!
testProjectiveLineOverFiniteRing
	| P |
	P _ ProjectiveLine over: É/6.
	"P(Z/6Z) has 12 points: [0:1], [1:1], [2:1], [3:1], [4:1], [5:1], [1:2], [3:2], [5:2], [1:3], [2:3] and [1:0] (Henri Cohen, 'A Course in Computational Algebraic Number Theory', 478p)"
	self assert: P points size = 12.
	self assert: (Iterator on: P points performing: #do:) size = 12! !

!AlgebraicGeometryTest methodsFor: 'finite rings' stamp: 'len 5/23/2020 08:56:27'!
testProjectiveLineOverFiniteRing2AsDirectProduct
	| P |
	P _ ProjectiveLine over: É/2 ◊ (É/2). "isomorphic to É/2[x]/<x(x+1)>"
	self assert: P points size = 9.
	self assert: (Iterator on: P points performing: #do:) size = 9! !

!AlgebraicGeometryTest methodsFor: 'finite rings' stamp: 'len 5/23/2020 08:56:37'!
testProjectiveLineOverFiniteRing2AsQuotient
	| R P |
	R _ (É/2) polynomials.
	R _ R / (R x * (R x + 1)). "isomorphic to É/2 ◊ (É/2)"
	P _ ProjectiveLine over: R.
	self assert: P points size = 9.
	self assert: (Iterator on: P points performing: #do:) size = 9! !

!AlgebraicGeometryTest methodsFor: 'finite rings' stamp: 'len 5/23/2020 08:56:42'!
testProjectiveLineOverFiniteRing4
	| P |
	P _ ProjectiveLine over: É/4 ◊ (É/4).
	self assert: P points size = 36.
	self assert: (Iterator on: P points performing: #do:) size = 36! !

!AlgebraicGeometryTest methodsFor: 'finite rings' stamp: 'len 5/23/2020 08:56:49'!
testProjectiveLineOverFiniteRing5
	| P |
	P _ ProjectiveLine over: É/2 ◊ (É/2) ◊ (É/2).
	self assert: P points size = 27.
	self assert: (Iterator on: P points performing: #do:) size = 27! !

!AlgebraicGeometryTest methodsFor: 'finite rings' stamp: 'len 5/23/2020 08:56:53'!
testProjectiveLineOverFiniteRing6
	| R P |
	R _ (É/2) polynomials.
	R _ R / (R x^3 - R x).
	P _ ProjectiveLine over: R.
	self assert: P points size = 18.
	self assert: (Iterator on: P points performing: #do:) size = 18! !

!AlgebraicGeometryTest methodsFor: 'projective' stamp: 'len 5/23/2020 08:56:56'!
testProjectivePlaneCurveArithmeticGenus
	| R f C |
	R _  (É/5) polynomialsIn: 3.
	f _ R !! [:x :y :z| y^2*(z^7) - (x^9) - (x*(z^8))].
	C _ ProjectivePlaneCurve polynomial: f.
	self assert: C arithmeticGenus = 28.
	"self assert: C genus = 4"! !

!AlgebraicGeometryTest methodsFor: 'projective' stamp: 'len 5/23/2020 08:56:59'!
testProjectivePlaneOverFiniteField
	| P |
	P _ ProjectiveSpace new: 2 over: É/5.
	self assert: P points size = 31.
	self assert: (Iterator on: P points performing: #do:) size = 31! !

!AlgebraicGeometryTest methodsFor: 'projective' stamp: 'len 5/23/2020 08:57:01'!
testProjectivePlaneOverFiniteRing
	| P |
	P _ ProjectiveSpace new: 2 over: É/4.
	self assert: P points size = 28
	"this plane has 28 points and 28 lines (falling into 7 neighbour classes of size 4), each line has 6 points and each point is on 6 lines"! !

!AlgebraicGeometryTest methodsFor: 'projective' stamp: 'len 5/23/2020 09:33:01'!
testProjectiveSchemeAffinePatches
	| E p a |
	E _ EllipticCurve cremona37a.
	p _ E !! ((2,-3) over: Ñ).
	a _ p dehomogenizedIn: 2.
	"the affine point is in the second standard affine patch:"
	self assert: (E patch: 2) == a codomain.
	"and when we homogenize again, the same projective embedding is used and come back to the same projective point on exactly the same projective curve:"
	self assert: a homogenized = p.
	self assert: a homogenized codomain == E! !

!AlgebraicGeometryTest methodsFor: 'projective' stamp: 'len 5/23/2020 09:33:01'!
testProjectiveSchemeDegree
	"Example from Sage documentation."
	| P X |
	P _ ProjectiveSpace new: 5 over: Ñ.
	X _ P subscheme: (P coordinateRing !! [:x :y :z :w :t :u| x^7 + (x*y*z*(t^4)) - (u^7)]).
	self assert: X degree = 7! !

!AlgebraicGeometryTest methodsFor: 'projective' stamp: 'len 5/23/2020 08:57:04'!
testProjectiveSchemeDegree2
	"Example from Sage documentation."
	| P X |
	P _ ProjectiveSpace new: 3 over: É/13.
	X _ P subscheme: (P coordinateRing !! [:x :y :z :w| {y^3 - (w^3). x + (7*z)}]).
	self assert: X degree = 3! !

!AlgebraicGeometryTest methodsFor: 'projective' stamp: 'len 5/23/2020 09:33:01'!
testProjectiveSchemeDegree3
	"Example from Sage documentation."
	| P X |
	P _ ProjectiveSpace new: 4 over: Ñ.
	X _ P subscheme: (P coordinateRing !! [:x :y :z :w :u| {x^7 - (y*(z^3)*(w^2)*u). w*(z^2) - (y*(u^2)). z^3 + (y^3)}]).
	self assert: X degree = 63! !

!AlgebraicGeometryTest methodsFor: 'projective' stamp: 'len 10/18/2016 20:58'!
testProjectiveSpace
	| K P |
	K _ PrimeField new: 23.
	P _ ProjectiveSpace new: 3 over: K.
	self assert: P dimension = 3.
	self assert: P scalars = K.
	self assert: P coordinateRing = (K polynomialsIn: 4).
	self assert: P ambient = P.
	self assert: P coordinateRing proj = P! !

!AlgebraicGeometryTest methodsFor: 'projective' stamp: 'len 5/23/2020 08:57:08'!
testProjectiveSpaceOverFiniteField
	| P S |
	P _ ProjectiveSpace new: 1 over: É/3.
	S _ P points.
	self assert: S size = 4.
	self assert: S asSet size = 4.
	S _ P pointsOver: (É/3 extensionDegree: 2).
	self assert: S size = 10.
	self assert: S asSet size = 10! !

!AlgebraicGeometryTest methodsFor: 'projective' stamp: 'len 5/23/2020 08:57:11'!
testProjectiveSpaceOverModularIntegers
	| N n P numberOfPoints |
	N _ (2 to: 6) atRandom.
	n _ (1 to: 3) atRandom.
	P _ ProjectiveSpace new: n over: É/N.
	"formula from Cohen's 'A course in computational algebraic number theory' page 486:"
	numberOfPoints _ N^n * (N factors asSet product: [:p| (0 to: n) sum: [:i| 1/(p^i)]]).
	self assert: P points asSet size = numberOfPoints.
	self assert: P points size = numberOfPoints! !

!AlgebraicGeometryTest methodsFor: 'rational maps' stamp: 'len 5/23/2020 09:33:01'!
testRationalMap
	"Example from Magma handbook Scheme_map-creation (H118E32)."
	| A1 A2 x y f X |
	A1 _ AffineSpace new: #(t) over: Ñ.
	A2 _ AffineSpace new: #(x y) over: Ñ.

	f _ A1 to: A2 evaluatingWithArguments: [:t| {t^3 + t. (t^2 - 3)}].

	self assert: f domain = A1.
	self assert: f codomain = A2.

	x _ A2 coordinateRing x.
	y _ A2 coordinateRing y.
	X _ A2 subscheme: {x^2*-1 + (y^3) + (y^2*11) + (y*40) + 48}.
	self assert: f image = X! !

!AlgebraicGeometryTest methodsFor: 'rational maps' stamp: 'len 5/23/2020 09:33:01'!
testRationalMap2
	"Example from Cox's IVA pag. 234. Parametrization of the tangent surface of the twisted cubic."
	| A2 A3 x y z f X |
	A2 _ AffineSpace new: #(t u) over: Ñ.
	A3 _ AffineSpace new: 3 over: Ñ.

	f _ A2 to: A3 evaluatingWithArguments: [:t :u| {t + u. t^2 + (t*u*2). t^3 + (t^2*u*3)}].

	x _ A3 coordinateRing x.
	y _ A3 coordinateRing y.
	z _ A3 coordinateRing z.
	X _ A3 subscheme: {x^3*z - (x*y^2*(3/4)) - (x*y*z*(3/2)) + (y^3) + (z^2*(1/4))}.
	self assert: f image = X! !

!AlgebraicGeometryTest methodsFor: 'rational maps' stamp: 'len 5/23/2020 09:33:01'!
testRationalMapAffineExample
	"From lecture notes MIT 18.782 Introduction to Arithmetic Geometry, Lecture #15, Fall 2013, 10/29/2013, Example 15.19."
	| A2 x y X A1 phi phi2 phiInv |
	A2 _ AffineSpace new: 2 over: Ñ.
	x _ A2 coordinateRing x.
	y _ A2 coordinateRing y.
	X _ A2 subscheme: x^2 + (y^2) - 1.
	A1 _ AffineSpace new: 1 over: Ñ.
	phi _ X to: A1 evaluatingWithArguments: [:x0 :y0| {y0 / (x0 + 1)}].
	phi2 _ X to: A1 evaluatingWithArguments: [:x0 :y0| {1 - x0 / y0}].
	self assert: phi = phi2.
	phiInv _ A1 to: X evaluatingWithArguments: [:t| {1 - (t^2) / (1 + (t^2)). t*2 / (1 + (t^2))}].
	self assert: (phi ∑ phiInv) isIdentity.
	self assert: phi isRegular not.
	self assert: phi isDominant.
"	self assert: phi isSurjective."
	self assert: phiInv isRegular not.
	self assert: phiInv isDominant.
"	self assert: phiInv isSurjective not"! !

!AlgebraicGeometryTest methodsFor: 'rational maps' stamp: 'len 5/23/2020 09:33:01'!
testRationalMapImage
	| A X X2 f |
	A _ AffineSpace new: #(x y) over: Ñ.
	"circle centered at (0,0):"
	X _ A subscheme: A coordinateRing !! [:x :y| x^2 + (y^2) - 1].
	"circle centered at: (1,2):"
	X2 _ A subscheme: A coordinateRing !! [:x :y| (x-1)^2 + ((y-2)^2) - 1].
	"translation by (1,2):"
	f _ X to: A evaluatingWithArguments: [:x :y| {x+1. y+2}].
	self assert: f image = X2.
	"global translation by (1,2):"
	f _ A to: A evaluatingWithArguments: [:x :y| {x+1. y+2}].
	self assert: (X apply: f) = X2! !

!AlgebraicGeometryTest methodsFor: 'rational maps' stamp: 'len 5/23/2020 09:33:01'!
testRationalMapLinearMapConversion
	| A2 A3 V2 V3 f f2 p f3 |
	A2 _ AffineSpace new: 2 over: Ñ.
	A3 _ AffineSpace new: 3 over: Ñ.
	V2 _ Ñ^2.
	V3 _ Ñ^3.

	f _ V2 => V3 atRandomBits: 100.
	f2 _ A2 => A3 !! f.

	p _ V2 atRandomBits: 100.
	self assert: (f value: p) = (f2 value: p).

	f3 _ V2 => V3 !! f2.
	self assert: f = f3! !

!AlgebraicGeometryTest methodsFor: 'rational points' stamp: 'len 5/23/2020 08:57:14'!
testRationalPointsOverFiniteField
	| P C |
	P _ ProjectiveSpace new: 2 over: É/7.
	C _ P subscheme: P coordinateRing !! [:x :y :z| x^3 + (y^3) - (z^3)].
	self assert: C points size = 9.
	self assert: (Iterator on: C points performing: #do:) size = 9! !

!AlgebraicGeometryTest methodsFor: 'rational points' stamp: 'len 5/23/2020 09:33:01'!
testSturmfelsExample1
	"Bernd Sturmfels, 'Ideals, Varieties and Macaulay 2', 1. A Curve in Affine 3-Space."
	| R x y I C C1 C2 |
	R _ Ñ polynomialsIn: #(x y z). "default ordering is trevlex"
	x _ R x.
	y _ R y.
"	z _ R z."
	I _ R * {x^4 - (y^5). x^3 - (y^7)}.
	self assert: I groebnerBasis reduced printString = '{x^8 - x^3y^3, x^4y^2 - x^3, y^5 - x^4}'.
	C _ I variety.
	self assert: C dimension = 1.
	self assert: C codimension = 2.
	"The degree of a curve in complex affine 3-space is the number of intersection points with a general plane. It coincides with the degree of the projective closure of our curve:"
	self assert: C projectiveClosure degree = 28.
	"We first extract the components which are transverse to the plane x = 0:"
	C1 _ C \ (R / R x) spec.
	self assert: C1 = (R / {x*(y^2) - 1. y^5 - (x^4). x^5 - (y^3)}) spec.
	"And next we extract the component which lies in the clane x = 0:"
	C2 _ C - C1. "NOTE: the article uses ideal saturation, and this is colon"
	self assert: C2 = (R / {x^3. y^5}) spec.
	"self deny: C isReduced." "this fails!!!!!!"
	self assert: C1 projectiveClosure degree = 13.
	self assert: C1 isReduced "equivalent to C1 ideal = C1 ideal radical"! !

!AlgebraicGeometryTest methodsFor: 'rational points' stamp: 'len 5/23/2020 09:33:01'!
testSturmfelsExample2
	"Bernd Sturmfels, 'Ideals, Varieties and Macaulay 2', 2. Intersecting Our Curve With a Surface."
	| R x y z C S theirunion ourpoints |
	R _ Ñ polynomialsIn: #(x y z). "default ordering is trevlex"
	x _ R x.
	y _ R y.
	z _ R z.
	C _ (R / {x^4 - (y^5). x^3 - (y^7)}) spec.
	C _ C \ (R / R x) spec. "this is C1 from example1"
	S _ (R / (x^5 + (y^5) + (z^5) - 1)) spec.
	theirunion _ C \/ S.
	"In this case, the union's ideal coincides with the product of the ideals:"
	self assert: theirunion ideal = (C ideal * S ideal).
	"The intersection of the curve and the surface (whose defining ideal is the sum of the respective ideals):"
	ourpoints _ C /\ S.
	"We get a finite set of points:"
	self assert: ourpoints dimension = 0.
	"The number of points is 65:"
	self assert: ourpoints projectiveClosure degree = 65.
	"Each of the points is multiplicity-free:"
	self assert: ourpoints isReduced. "equivalent to the original: ourpoints reduced projectiveClosure degree = 65."! !

!AlgebraicGeometryTest methodsFor: 'rational points' stamp: 'len 5/23/2020 09:33:01'!
testTwistedCubic
	| P R M C |
	P _ ProjectiveSpace new: 3 over: Ñ.
	R _ P coordinateRing.
	"R indeterminateNames: #(u v w t)"
	M _ R matrix: (2@3) coefficients: ((1,2,3,2,3,4) collect: [:i| R x: i]).
	C _ P subscheme: (M minors: 2).
	self assert: C dimension = 1.
	self assert: C isSmooth! !

!AlgebraicGeometryTest methodsFor: 'rational points' stamp: 'len 5/23/2020 09:33:01'!
testTwistedCubicDegree
	"Twisted cubic in P^3 with homogeneous coordinates x,y,w,z."
	| A X |
	A _ Ñ polynomialsIn: #(x y z w).
	X _ (A / [:x :y :z :w| {x^2 - (y*w). x*z - (y^2)}]) proj.
	"At this point X is still reducible, it is the union of a line x=y=0 and the twisted cubic:"
	self assert: X degree = 4.
	"To cut out X, we impose an additional equation x^3 - (z * (w^2)) = 0:"
	X _ (A / [:x :y :z :w| {x^2 - (y*w). x*z - (y^2). x^3 - (z*(w^2))}]) proj.
	"But we get the twisted cubic (in some sense) 'counted with multiplicity 2', so the degree is 6
	(BUT NOT REALLY, MAGMA GIVES 3 LIKE US, I DONT REMEMBER WHERE I GOT THIS EXAMPLE FROM BUT THE CORRECT ANSWER IS 3)"
	self assert: X degree = 3! !

!AlgebraicGeometryTest methodsFor: 'tangent cone' stamp: 'len 5/23/2020 09:33:01'!
testTangentCone
	"'A Singular Introduction to Commutative Algebra', Example 5.5.13."
	| R I J X |
	R _ Ñ polynomialsIn: #(x y z).
	I _ R * (R !! [:x :y :z| {y*z + (z^2) + (x^3). y^2 + (x*z) + (y^4)}]).
	X _ (R/I) spec.
	J _ R * (R !! [:x :y :z| {y^2 + (x*z). y*z + (z^2). x*(z^2) - (y*(z^2))}]).
	self assert: (X !! (0,0,0)) tangentCone ideal = J! !

!AlgebraicGeometryTest methodsFor: 'tangent cone' stamp: 'len 5/23/2020 09:33:01'!
testTangentCone2
	"M. Kreuzer, 'Computational Commutative Algebra', Example 6.5.27."
	| R J T I |
	R _ Ñ polynomialsIn: 4.
	J _ R * (R generate: [:x1 :x2 :x3 :x4| {x1*x2 - (x3^2). x2^2 - (x4^5)}]).
	T _ (R/J) spec tangentConeAt: (0,0,0,0).
	I _ R * (R generate: [:x1 :x2 :x3 :x4| {x1*x2 - (x3^2). x2^2. x2*(x3^2). x3^4}]).
	self assert: T ideal = I! !

!AlgebraicGeometryTest methodsFor: 'tangent cone' stamp: 'len 5/23/2020 09:33:01'!
testTangentConeAndTangentSpace
	"Example from https://en.wikipedia.org/wiki/Tangent_cone."
	| A x y S o |
	A _ AffineSpace new: #(x y) over: Ñ.
	x _ A coordinateRing x.
	y _ A coordinateRing y.
	"this curve is singular at (0,0):"
	S _ A subscheme: x^2 + (x^3) - (y^2).
	o _ S !! (0,0).
	"the tangent cone is the union of the two lines x = y and x = -y:"
	self assert: o tangentCone = (A subscheme: (x + y) * (x - y)).
	"the tangent space is the whole plane:"
	self assert: o tangentSpace = A! !

!AlgebraicGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:33:01'!
testSmoothnessOverÑ
	| P C |
	P _ ProjectiveSpace new: 2 over: Ñ.
	C _ P subscheme: P coordinateRing !! [:x :y :z| x^3 - (y^2*z)].
	self assert: C isSingular! !

!AlgebraicGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:32:00'!
testSmoothnessOverÜ
	| P R C |
	P _ ProjectiveSpace new: 2 over: Ü.
	R _ P coordinateRing.
	C _ P subscheme: R !! [:x :y :z| x].
	self assert: C isSingular not.
	C _ P subscheme: R !! [:x :y :z| y^2*z - (x^3)].
	self assert: C isSingular.
	C _ P subscheme: R !! [:x :y :z| y^2*z - (x^3) + (z^3)].
	self assert: C isSingular not! !

!AlgebraicNumbersTest methodsFor: 'as yet unclassified' stamp: 'len 4/30/2018 05:39:40'!
testArithmetic
	| sqrt2 sqrt3 sqrt5 sqrt6 |
	sqrt2 _ ComplexAlgebraicNumber sqrt2.
	sqrt3 _ ComplexAlgebraicNumber sqrt: 3.
	sqrt5 _ ComplexAlgebraicNumber sqrt: 5.
	sqrt6 _ ComplexAlgebraicNumber sqrt: 6.
	self assert: sqrt2 squared = 2.
	self assert: (sqrt2 + sqrt3) * sqrt2 = (2 + sqrt6).
	self assert: (sqrt3 / sqrt5) squared reciprocal = (5/3).
"	self assert: (((5 root: 3) + sqrt2 - sqrt2) ^ 3) asRational = 5"! !

!AlgebraicNumbersTest methodsFor: 'as yet unclassified' stamp: 'len 4/30/2018 05:39:54'!
testDivision
	| sqrt3 sqrt5 |
	sqrt3 _ ComplexAlgebraicNumber sqrt: 3.
	sqrt5 _ ComplexAlgebraicNumber sqrt: 5.
	self assert: sqrt3 / sqrt5 / sqrt3 / sqrt5 = (1/5)! !

!AlgebraicNumbersTest methodsFor: 'as yet unclassified' stamp: 'len 4/29/2018 23:50:51'!
testMultiplicationByi
	| a |
	a _ ComplexAlgebraicNumber sqrt2.
	self assert: a i i = a negated! !

!AlgebraicNumbersTest methodsFor: 'as yet unclassified' stamp: 'len 4/30/2018 04:54:12'!
testNorm
	| a |
	a _ ComplexAlgebraicNumber phi.
	self assert: a norm = a conjugates product! !

!AlgebraicNumbersTest methodsFor: 'as yet unclassified' stamp: 'len 4/30/2018 05:40:10'!
testProduct
	| sqrt3 sqrt5 |
	sqrt3 _ ComplexAlgebraicNumber sqrt: 3.
	sqrt5 _ ComplexAlgebraicNumber sqrt: 5.
	self assert: sqrt3 * sqrt5 * sqrt3 * sqrt5 = 15! !

!AlgebraicNumbersTest methodsFor: 'as yet unclassified' stamp: 'len 4/29/2018 18:49:57'!
testRealArithmetic
	| sqrt2 sqrt3 sqrt5 sqrt6 |
	sqrt2 _ RealAlgebraicNumber sqrt2.
	sqrt3 _ RealAlgebraicNumber sqrt: 3.
	sqrt5 _ RealAlgebraicNumber sqrt: 5.
	sqrt6 _ RealAlgebraicNumber sqrt: 6.
	self assert: sqrt2 squared asRational = 2.
	self assert: (sqrt2 + sqrt3) * sqrt2 = (2 + sqrt6).
	self assert: (sqrt3 / sqrt5) squared reciprocal = (5/3).
"	self assert: (((five root: 3) + sqrt2 - sqrt2) ^ 3) asRational = 5"! !

!AlgebraicNumbersTest methodsFor: 'as yet unclassified' stamp: 'len 6/4/2016 21:59'!
testRealDivision
	| sqrt3 sqrt5 |
	sqrt3 _ RealAlgebraicNumber sqrt: 3.
	sqrt5 _ RealAlgebraicNumber sqrt: 5.
	self assert: (sqrt3 / sqrt5 / sqrt3 / sqrt5) asRational = (1/5)! !

!AlgebraicNumbersTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:33:01'!
testRealNormalizationBug
	| f interval x |
	x _ Ñ polynomials x.
	f _ x^4 * 1576875 - (x^2 * 877250) + 43923.
	interval _ RealInterval open: (-260139/1345600) closed: (81631/134560).
	RealAlgebraicNumber polynomial: f bounds: interval! !

!AlgebraicNumbersTest methodsFor: 'as yet unclassified' stamp: 'len 6/4/2016 21:59'!
testRealProduct
	| sqrt3 sqrt5 |
	sqrt3 _ RealAlgebraicNumber sqrt: 3.
	sqrt5 _ RealAlgebraicNumber sqrt: 5.
	self assert: (sqrt3 * sqrt5 * sqrt3 * sqrt5) asRational = 15! !

!AlgebraicNumbersTest methodsFor: 'as yet unclassified' stamp: 'len 6/4/2016 21:59'!
testRealSquare
	| sqrt2 |
	sqrt2 _ RealAlgebraicNumber sqrt2.
	self assert: sqrt2 squared asRational = 2! !

!AlgebraicNumbersTest methodsFor: 'as yet unclassified' stamp: 'len 4/29/2018 18:48:17'!
testRealSquareRoot
	| a |
	a _ RealAlgebraicNumber sqrt2.
	self assert: a squareRoot squared = a! !

!AlgebraicNumbersTest methodsFor: 'as yet unclassified' stamp: 'len 6/4/2016 22:00'!
testRealSum
	| sqrt2 sqrt3 sqrt5 |
	sqrt2 _ RealAlgebraicNumber sqrt: 2.
	sqrt3 _ RealAlgebraicNumber sqrt: 3.
	sqrt5 _ RealAlgebraicNumber sqrt: 5.
	self assert: sqrt3 + sqrt5 + sqrt2 - sqrt3 - sqrt5 = sqrt2! !

!AlgebraicNumbersTest methodsFor: 'as yet unclassified' stamp: 'len 4/30/2018 05:40:24'!
testSquare
	| sqrt2 |
	sqrt2 _ ComplexAlgebraicNumber sqrt2.
	self assert: sqrt2 squared = 2! !

!AlgebraicNumbersTest methodsFor: 'as yet unclassified' stamp: 'len 4/29/2018 18:49:16'!
testSquareRoot
	| a |
	a _ ComplexAlgebraicNumber sqrt2.
	self assert: a squareRoot squared = a! !

!AlgebraicNumbersTest methodsFor: 'as yet unclassified' stamp: 'len 1/20/2018 19:18:17'!
testSum
	| sqrt2 sqrt3 sqrt5 |
	sqrt2 _ ComplexAlgebraicNumber sqrt: 2.
	sqrt3 _ ComplexAlgebraicNumber sqrt: 3.
	sqrt5 _ ComplexAlgebraicNumber sqrt: 5.
	self assert: sqrt3 + sqrt5 + sqrt2 - sqrt3 - sqrt5 = sqrt2! !

!AlgebraicNumbersTest methodsFor: 'as yet unclassified' stamp: 'len 4/30/2018 04:53:56'!
testTrace
	| a |
	a _ ComplexAlgebraicNumber phi.
	self assert: a trace = a conjugates sum! !

!ChainComplexTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 08:59:39'!
newChainComplex
	^ self newChainComplexOver: {É. É/64 atRandom nextPrime. Ñ} atRandom! !

!ChainComplexTest methodsFor: 'as yet unclassified' stamp: 'len 4/23/2020 00:35:38'!
newChainComplexOver: aRing
	| X |
	X _ SimplicialComplex perform: #(kleinBottle realProjectivePlane torus) atRandom.
	^ X chainComplexOver: aRing! !

!ChainComplexTest methodsFor: 'as yet unclassified' stamp: 'len 4/29/2020 12:43:53'!
testChainComplexExample
	self assert: self newChainComplex verify! !

!ChainComplexTest methodsFor: 'as yet unclassified' stamp: 'len 4/23/2020 00:38:24'!
testIdentity
	| C id |
	C _ self newChainComplex.
	id _ C id.
	self assert: id isIdentity! !

!ChainComplexTest methodsFor: 'as yet unclassified' stamp: 'len 4/23/2020 00:38:31'!
testIdentityImage
	| C id |
	C _ self newChainComplex.
	id _ C id.
	self assert: id image = C! !

!ChainComplexTest methodsFor: 'as yet unclassified' stamp: 'len 4/23/2020 00:38:36'!
testIdentityKernel
	| C id |
	C _ self newChainComplex.
	id _ C id.
	self assert: id kernel isTrivial! !

!ChainComplexTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 08:59:45'!
testModulePresentationExample
	| M C |
	M _ É^2 / {(1,2)}.
	C _ M presentation.
	self assert: C verify.
	self assert: C isExact! !

!ChainComplexTest methodsFor: 'as yet unclassified' stamp: 'len 4/26/2020 00:06:38'!
testShift
	| C k i |
	C _ self newChainComplex.
	self assert: C >> 0 = C.
	k _ (-5 to: 5) atRandom.
	self assert: (C >> k) verify.
	self assert: C >> k << k = C.
	self assert: C >> k = (C << k negated).
	self assert: (C >> k) degree = (C degree + k).
	i _ (-5 to: 5) atRandom.
	self assert: (C >> k at: i+k) = ((C at: i) * ((-1)^k))! !

!CommutativeAlgebraTest methodsFor: 'affine ring' stamp: 'len 5/23/2020 09:33:01'!
testAffineRingElementOperations
	"Magma handbook example H105E1."
	| R A x y |
	R _ Ñ polynomialsIn: #(x y).
	A _ R / (R generate: [:x1 :y1| {x1^2 - (y1^2) + 2. y1^3 - 5}]).
	x _ A x. y _ A y.
	self assert: x^2 = (y^2 - 2).
	"self assert: x reciprocal = ..."! !

!CommutativeAlgebraTest methodsFor: 'affine ring' stamp: 'len 5/23/2020 09:33:01'!
testAffineRingIdealIntersectionRandom
	| R f1 f2 J A |
	R _ Ñ polynomialsIn: #(x y).
	[(f1 _ R atRandomBits: 10) isZero] whileTrue.
	[(f2 _ R atRandomBits: 10) isZero] whileTrue.
	J _ R * {f1. f2}.
	A _ R/J.
	self testIdealIntersectionRandom: A! !

!CommutativeAlgebraTest methodsFor: 'affine ring' stamp: 'len 5/23/2020 09:33:01'!
testAffineRingIdealMembershipRandom
	| R f1 f2 J A g I h |
	R _ Ñ polynomialsIn: #(x y z).
	[(f1 _ R atRandomBits: 10) isZero] whileTrue.
	[(f2 _ R atRandomBits: 10) isZero] whileTrue.
	J _ R * {f1. f2}.
	A _ R/J.
	g _ A atRandomBits: 10.
	I _ A * g.
	h _ I atRandomBits: 10.
	self assert: (I includes: h)! !

!CommutativeAlgebraTest methodsFor: 'affine ring' stamp: 'len 5/23/2020 09:33:01'!
testAffineRingIdealOperations
	"Magma handbook, example H105E2."
	| R A I J |
	R _ Ñ polynomialsIn: #(x y z) "ordering: #lex".
	A _ R / (R generate: [:x :y :z| {x^2 - y + 1. y^3 + z - 1}]).
	I _ A * (A generate: [:x :y :z| x^3*y*(z^2)]).
	self deny: I isRadical.
	J _ A * (A generate: [:x :y :z| {x*(y^2) + (x*y) - (x*z) + x. y*z. z^2 - z}]).
	self assert: I radical = J. "this fails probably because PolynomialIdeal>>radical is broken"
	"... and then some tests of primary decomposition"! !

!CommutativeAlgebraTest methodsFor: 'division and normal forms' stamp: 'len 5/23/2020 09:33:01'!
testBuchbergerNormalForm
	"A Singular Introduction to Commutative Algebra, Example 1.6.12."
	| R x y z f G h |
	R _ Ñ polynomialsIn: #(x y z) ordering: #glex.
	x _ R x. y _ R y. z _ R z.
	f _ x^3 + (y^2) + (z^2*2) + x + y + 1.
	G _ GroebnerBasis new add: R x; add: R y; yourself.
	h _ G reduce: f.
	self assert: h = (z^2*2 + x + y + 1).
	h _ G reduceFull: f.
	self assert: h = (z^2 + (1/2))! !

!CommutativeAlgebraTest methodsFor: 'division and normal forms' stamp: 'len 5/23/2020 09:33:01'!
testMoraNormalForm
	"A Singular Introduction to Commutative Algebra, Example 1.7.7."
	| R f G h |
	R _ Ñ polynomialsIn: #(x y z) ordering: #lgrevlex.
	f _ R !! [:x :y :z| x^2 + (y^2) + (z^3) + (x^4) + (y^5)].
	G _ StandardBasis new add: R x; add: R y; yourself.
	h _ G reduce: f.
	self assert: h = (R !! [:x :y :z| z^3 + (x^4) + (y^5)])! !

!CommutativeAlgebraTest methodsFor: 'division and normal forms' stamp: 'len 5/23/2020 09:33:01'!
testMultivariateDivisionExample
	| P x y z F f |
	P _ Ñ polynomialsIn: #(x y z) ordering: #glex.
	x _ P x.
	y _ P y.
	z _ P z.
	F _ {x^2 - (y*z). y^2 - (z*x). z^2 - (x*y)}.
	f _ x^3 + (y^3 * 3).
	self assert: (f divisionBy: F) remainder = (y^3 * 4)! !

!CommutativeAlgebraTest methodsFor: 'division and normal forms' stamp: 'len 5/23/2020 09:33:01'!
testMultivariateDivisionExample2
	| R f f1 f2 |
	R _ Ñ polynomialsIn: #(x y z) ordering: #lex.
	f _ R !! [:x :y :z| x^5*(y^3)].
	f1 _ R !! [:x :y :z| x^3*(y^2) - ((y^2)*z)].
	f2 _ R !! [:x :y :z| x*(y^2) - (y*z)].
	self assert: (f divisionBy: {f1. f2}) printString = 'x^5y^3 = (x^2y)(x^3y^2 - y^2z) + (xyz + z^2)(xy^2 - yz) + yz^3'! !

!CommutativeAlgebraTest methodsFor: 'division and normal forms' stamp: 'len 5/23/2020 09:33:01'!
testMultivariateDivisionExample3
	| R f f1 f2 |
	R _ Ñ polynomialsIn: #(x y z) ordering: #lex.
	f _ R !! [:x :y :z| x^3*(y^2) + (x*y) + x + 1].
	f1 _ R !! [:x :y :z| x^3 + 1].
	f2 _ R !! [:x :y :z| y^2 + 1].
	self assert: (f divisionBy: {f1. f2}) printString = 'x^3y^2 + xy + x + 1 = (y^2)(x^3 + 1) + (-1)(y^2 + 1) + xy + x + 2'! !

!CommutativeAlgebraTest methodsFor: 'division and normal forms' stamp: 'len 5/23/2020 09:33:01'!
testMultivariateDivisionExample4
	| R f f1 f2 |
	R _ Ñ polynomialsIn: #(x y) ordering: #lex.
	f _ R !! [:x :y| x^2*(y^3) - (x*(y^2)*2)].
	f1 _ R !! [:x :y| x^2*y - (x*2)].
	f2 _ R !! [:x :y| y^3 + 4].
	self assert: (f divisionBy: {f1. f2}) printString = 'x^2y^3 - 2xy^2 = (y^2)(x^2y - 2x) + (0)(y^3 + 4) + 0'.
	self assert: (f divisionBy: {f2. f1}) printString = 'x^2y^3 - 2xy^2 = (x^2)(y^3 + 4) + (0)(x^2y - 2x) + -4x^2 - 2xy^2'! !

!CommutativeAlgebraTest methodsFor: 'testing examples' stamp: 'len 5/23/2020 09:33:01'!
testCyclic7Correctness
	"Test correctness of the ideal of cyclic 7-roots checking against one generated by Singular."
	| txt |
	txt _ ((Ñ polynomialsIn: 7) cyclicIdeal generators sorted: [:a :b| a leadingMonomial >= b leadingMonomial]) printString.
	#('(' ')' '{' '}' ' ') do: [:each| txt _ txt copyReplaceAll: each with: ''].
	self assert: txt = 'x1x2x3x4x5x6x7-1,x1x2x3x4x5x6+x1x2x3x4x5x7+x1x2x3x4x6x7+x1x2x3x5x6x7+x1x2x4x5x6x7+x1x3x4x5x6x7+x2x3x4x5x6x7,x1x2x3x4x5+x2x3x4x5x6+x1x2x3x4x7+x1x2x3x6x7+x1x2x5x6x7+x1x4x5x6x7+x3x4x5x6x7,x1x2x3x4+x2x3x4x5+x3x4x5x6+x1x2x3x7+x1x2x6x7+x1x5x6x7+x4x5x6x7,x1x2x3+x2x3x4+x3x4x5+x4x5x6+x1x2x7+x1x6x7+x5x6x7,x1x2+x2x3+x3x4+x4x5+x5x6+x1x7+x6x7,x1+x2+x3+x4+x5+x6+x7'! !

!CommutativeAlgebraTest methodsFor: 'testing examples' stamp: 'len 5/23/2020 09:33:01'!
testKatsura7Correctness
	"Test correctness of Katsura-7 ideal checking against one generated by Singular."
	| txt |
	txt _ ((Ñ polynomialsIn: 7) katsuraIdeal generators sorted: [:a :b| a leadingMonomial >= b leadingMonomial]) printString.
	#('(' ')' '{' '}' ' ') do: [:each| txt _ txt copyReplaceAll: each with: ''].
	self assert: txt = 'x1^2+2x2^2+2x3^2+2x4^2+2x5^2+2x6^2+2x7^2-x1,2x1x2+2x2x3+2x3x4+2x4x5+2x5x6+2x6x7-x2,x2^2+2x1x3+2x2x4+2x3x5+2x4x6+2x5x7-x3,2x2x3+2x1x4+2x2x5+2x3x6+2x4x7-x4,x3^2+2x2x4+2x1x5+2x2x6+2x3x7-x5,2x3x4+2x2x5+2x1x6+2x2x7-x6,x1+2x2+2x3+2x4+2x5+2x6+2x7-1'! !

!CommutativeAlgebraTest methodsFor: 'algorithms' stamp: 'len 5/23/2020 09:33:01'!
testExtendedBuchberger
	| I algorithm G G2 |
	I _ (Ñ polynomialsIn: #(a b c d)) cyclicIdeal.
	I _ I orderedBy: #grevlex.
	G _ (algorithm _ ExtendedBuchberger on: I) basis.
	self assert: algorithm verify.
	self assert: G verify.
	G2 _ (Buchberger on: I) basis.
	self assert: G reduced = G2 reduced.
	self assert: algorithm matrix * (I scalars tuple: I generators) = (I scalars tuple: G)! !

!CommutativeAlgebraTest methodsFor: 'groebner' stamp: 'len 4/14/2020 00:53:45'!
testGroebnerBasis: G ideal: I
	"Test G is a Groebner basis of the ideal I."
	| g division |
	self assert: G verify.
	I generators do: [:each| self assert: (G reduces: each)].
	G do: [:each| self assert: (I includes: each)]. "but this will use Groebner bases.."
	[g _ I atRandomBits: 200. g isZero] whileTrue.
	self assert: (G reduces: g).
	"The leading term of any polynomial in I is divisible by the leading term of some polynomial in G:"
	self assert: (G anySatisfy: [:any| any leadingMonomial | g leadingMonomial]).
	"The multivariate division of any polynomial in I by G gives the remainder 0:"
	division _ g divisionBy: G.
	self assert: division remainder isZero.
	self assert: division verify.
	self assert: G reduced isReduced.
	self assert: G minimal isMinimal! !

!CommutativeAlgebraTest methodsFor: 'groebner' stamp: 'len 5/23/2020 09:33:01'!
testGroebnerCyclic3
	| I G |
	I _ (Ñ polynomialsIn: 3) cyclicIdeal.
	G _ I groebnerBasis.
	self testGroebnerBasis: G ideal: I! !

!CommutativeAlgebraTest methodsFor: 'groebner' stamp: 'len 5/23/2020 09:33:01'!
testGroebnerCyclic3Lexicographic
	| I G |
	I _ (Ñ polynomialsIn: 3 ordering: #lex) cyclicIdeal.
	G _ I basis.
	self testGroebnerBasis: G ideal: I! !

!CommutativeAlgebraTest methodsFor: 'groebner' stamp: 'len 5/23/2020 09:00:08'!
testGroebnerCyclic3OverZ2
	| I G |
	I _ (É/2 polynomialsIn: 3) cyclicIdeal.
	G _ I groebnerBasis.
	self testGroebnerBasis: G ideal: I! !

!CommutativeAlgebraTest methodsFor: 'groebner' stamp: 'len 5/23/2020 09:33:01'!
testGroebnerCyclic3Reduced
	| I G |
	I _ (Ñ polynomialsIn: #(x y z)) cyclicIdeal.
	I _ I orderedBy: #lex.
	G _ I basis reduced.
	self assert: G printString = '{x + y + z, y^2 + yz + z^2, z^3 - 1}' 
! !

!CommutativeAlgebraTest methodsFor: 'groebner' stamp: 'len 5/23/2020 09:33:01'!
testGroebnerCyclic3TotalLexicographic
	| I G |
	I _ (Ñ polynomialsIn: 3 ordering: #glex) cyclicIdeal.
	G _ I basis.
	self testGroebnerBasis: G ideal: I! !

!CommutativeAlgebraTest methodsFor: 'groebner' stamp: 'len 5/23/2020 09:33:01'!
testGroebnerCyclic3TotalReverseLexicographic
	| I G |
	I _ (Ñ polynomialsIn: 3 ordering: #grevlex) cyclicIdeal.
	G _ I basis.
	self testGroebnerBasis: G ideal: I! !

!CommutativeAlgebraTest methodsFor: 'groebner' stamp: 'len 5/23/2020 09:33:01'!
testGroebnerCyclic4
	| I G |
	I _ (Ñ polynomialsIn: 4) cyclicIdeal.
	G _ I groebnerBasis.
	self testGroebnerBasis: G ideal: I! !

!CommutativeAlgebraTest methodsFor: 'groebner' stamp: 'len 5/23/2020 09:00:11'!
testGroebnerCyclic4OverZ127
	| I G |
	I _ (É/127 polynomialsIn: 4) cyclicIdeal.
	G _ I groebnerBasis.
	self testGroebnerBasis: G ideal: I! !

!CommutativeAlgebraTest methodsFor: 'groebner' stamp: 'len 5/23/2020 09:00:13'!
testGroebnerCyclic4OverZ2
	| I G |
	I _ (É/2 polynomialsIn: 4) cyclicIdeal.
	G _ I groebnerBasis.
	self testGroebnerBasis: G ideal: I! !

!CommutativeAlgebraTest methodsFor: 'groebner' stamp: 'len 5/23/2020 09:33:01'!
testGroebnerCyclic5
	| I G |
	I _ (Ñ polynomialsIn: 5) cyclicIdeal.
	G _ I groebnerBasis.
	self testGroebnerBasis: G ideal: I! !

!CommutativeAlgebraTest methodsFor: 'groebner' stamp: 'len 5/23/2020 09:00:16'!
testGroebnerCyclic5OverZ127
	| I G |
	I _ (É/127 polynomialsIn: 5) cyclicIdeal.
	G _ I groebnerBasis.
	self testGroebnerBasis: G ideal: I! !

!CommutativeAlgebraTest methodsFor: 'groebner' stamp: 'len 5/23/2020 09:00:20'!
testGroebnerCyclic5OverZ2
	| I G |
	I _ (É/2 polynomialsIn: 5) cyclicIdeal.
	G _ I groebnerBasis.
	self testGroebnerBasis: G ideal: I! !

!CommutativeAlgebraTest methodsFor: 'groebner' stamp: 'len 5/23/2020 09:33:01'!
testGroebnerCyclic5Reduced
	| I G |
	I _ (Ñ polynomialsIn: 5) cyclicIdeal.
	G _ I groebnerBasis reduced.
	self assert: G isReduced.
	self testGroebnerBasis: G ideal: I.
	self assert: (I scalars * G) groebnerBasis reduced = G! !

!CommutativeAlgebraTest methodsFor: 'groebner' stamp: 'len 5/23/2020 09:33:01'!
testGroebnerExample
	| P x y z I G |
	P _ Ñ polynomialsIn: #(x y z) ordering: #lex.
	x _ P x.
	y _ P y.
	z _ P z.
	I _ P * {x^2 - (y*z). y^2 - (z*x). z^2 - (x*y)}.
	G _ I basis minimal.
	self assert: G asSet = {x^2 - (y*z). x*z - (y^2). x*y - (z^2). y^3 - (z^3)} asSet! !

!CommutativeAlgebraTest methodsFor: 'groebner' stamp: 'len 5/23/2020 09:33:01'!
testGroebnerExample2
	| R x y f1 f2 I G |
	R _ Ñ polynomialsIn: #(x y) ordering: #lex.
	x _ R x.
	y _ R y.
	f1 _ (x-1)^2 + (y-2^2) - (3^2).
	f2 _ (x+1)^2 + (y-1^2) - (2^2).
	I _ R * {f1. f2}.
	G _ I basis reduced.
	self assert: G printString = '{x + (1/2)y + (1/2), y^2 - 2y - (11/5)}' ! !

!CommutativeAlgebraTest methodsFor: 'groebner' stamp: 'len 5/23/2020 09:33:01'!
testGroebnerExample3
	"From some question in math.stackexchange.com."
	| R I G |
	R _ Ñ polynomialsIn: #(x y) ordering: #glex.
	I _ R * (R !! [:x :y| {x^2*y + x + 1. x*(y^2) + y + 1. x - y}]).
	G _ I basis reduced.
	self assert: G printString = '{y^3 + y + 1, x - y}' "this is as computed by Singular"! !

!CommutativeAlgebraTest methodsFor: 'groebner' stamp: 'len 5/23/2020 09:33:01'!
testGroebnerExample4Minimal
	"Example from Cox, Little, O'Shea, 'Ideals, Varieties and Algorithms', p. 90, continued in p. 93."
	| R I G |
	R _ Ñ polynomialsIn: #(x y) ordering: #grevlex.
	I _ R * (R !! [:x :y| {x^3 - (x*y*2). x^2*y - (y^2*2) + x}]).
	G _ I basis minimal.
	self assert: G printString = '{x^2, xy, y^2 - (1/2)x}' 
! !

!CommutativeAlgebraTest methodsFor: 'groebner' stamp: 'len 5/23/2020 09:33:01'!
testGroebnerKatsura2
	| I G |
	I _ (Ñ polynomialsIn: 2) katsuraIdeal.
	G _ I groebnerBasis.
	self testGroebnerBasis: G ideal: I! !

!CommutativeAlgebraTest methodsFor: 'groebner' stamp: 'len 5/23/2020 09:33:01'!
testGroebnerKatsura3
	| I G |
	I _ (Ñ polynomialsIn: 3) katsuraIdeal.
	G _ I groebnerBasis.
	self testGroebnerBasis: G ideal: I! !

!CommutativeAlgebraTest methodsFor: 'groebner' stamp: 'len 5/23/2020 09:33:01'!
testGroebnerTrivial
	"The 3 polynomials have no common zeroes, the Groebner basis should be {1}."
	| Qx x y I |
	Qx _ Ñ polynomialsIn: #(x y) ordering: #lex.
	x _ Qx x.
	y _ Qx y.
	I _ Qx * {x + y. x^2 - 1. y^2 - (x*2)}.
	self assert: I groebnerBasis minimal isTrivial! !

!CommutativeAlgebraTest methodsFor: 'hilbert series' stamp: 'len 5/23/2020 09:00:05'!
testAffineRingDimensionAsVectorSpace
	"Example from answer in math.stackexchange 'What does Hilbert series of monomial ideals describe?'."
	| S a b I |
	S _ É/17 polynomialsIn: #(a b).
	a _ S x: 1.
	b _ S x: 2.
	I _ S * {a^6. a^3*b. a^2*(b^4). b^5}.
	self assert: (S/I) vectorSpaceDimension = 17! !

!CommutativeAlgebraTest methodsFor: 'hilbert series' stamp: 'len 5/23/2020 09:33:01'!
testHilbertSeriesOfPolynomialIdeal
	"Derksen, Kemper 'Computational Invariant Theory', Example 1.4.9."
	| t R x y z w I H |
	t _ Ñ polynomials fractions x.
	R _ Ñ polynomialsIn: #(x y z w) "ordering: #lex".
	x _ R x.
	y _ R y.
	z _ R z.
	w _ R x: 4.
	I _ R * {x*z - (y^2). x*w - (y*z). y*w - (z^2)}.
	H _ I hilbertSeriesAt: t.
	self assert: H = (t^2 * 3 - (t^3 * 2) / ((1 - t) ^ 4))! !

!CommutativeAlgebraTest methodsFor: 'hilbert series' stamp: 'len 5/23/2020 09:33:01'!
testHilbertSeriesOfPolynomialQuotient
	"Derksen, Kemper 'Computational Invariant Theory', Example 1.4.9."
	| t R x y z w I H |
	t _ Ñ polynomials fractions x.
	R _ Ñ polynomialsIn: #(x y z w) "ordering: #lex".
	x _ R x.
	y _ R y.
	z _ R z.
	w _ R x: 4.
	I _ R * {x*z - (y^2). x*w - (y*z). y*w - (z^2)}.
	H _ (R/I) hilbertSeriesAt: t.
	self assert: H = (1 + (2*t) / (1 - t) squared)! !

!CommutativeAlgebraTest methodsFor: 'hilbert series' stamp: 'len 5/23/2020 09:33:01'!
testHilbertSeriesOfPolynomialQuotient2
	"Derksen, Kemper 'Computational Invariant Theory', Example 1.4.9."
	| t R x y z w I H dim deg |
	t _ Ñ polynomials fractions x.
	R _ Ñ polynomialsIn: #(x y z w).
	x _ R x.
	y _ R y.
	z _ R z.
	w _ R x: 4.
	I _ R * {x*z - (y^2). x*w - (y*z). y*w - (z^2)}.
	H _ (R/I) hilbertSeriesAt: t.
	dim _ (H orderAt: 1) negated.
	self assert: (R/I) dimension = dim.
	deg _ (H * ((1 - H numerator parent x) ^ dim) value: 1) asInteger. "should be limit from below"
	self assert: (R/I) degree = deg! !

!CommutativeAlgebraTest methodsFor: 'hilbert series' stamp: 'len 5/23/2020 09:33:01'!
testHilbertSeriesOfPolynomialRing
	| t R H |
	t _ Ñ polynomials fractions x.
	R _ Ñ polynomialsIn: 4.
	H _ R hilbertSeriesAt: t.
	self assert: H = ((1 - t) ^ -4)! !

!CommutativeAlgebraTest methodsFor: 'ideal operations' stamp: 'len 5/23/2020 09:33:01'!
testIdealColon
	| R x y z I J |
	R _ Ñ polynomialsIn: #(x y z).
	x _ R x.
	y _ R y.
	z _ R z.
	I _ R * {x*y - 1. x^3*(z^2) - (y^2). x*(z^3) - x - 1}.
"	J _ R * {x*y - 1. x^2*z - y. x*(z^3) - x - 1}."
	self assert: I : R asIdeal = I.
	self assert: R asIdeal : I = R asIdeal.
	J _ R * {I atRandomBits: 10. I atRandomBits: 10}. "J <= I"
	self assert: I : J = R asIdeal! !

!CommutativeAlgebraTest methodsFor: 'ideal operations' stamp: 'len 5/23/2020 09:33:01'!
testIdealColon2
	"Example from Cox IVA 205p."
	| R x y z I J Q |
	R _ Ñ polynomialsIn: #(x y z).
	x _ R x.
	y _ R y.
	z _ R z.
	I _ R * {x*z - (y^2). x^3 - (y*z)}.
	J _ R * {x. y}.
	Q _ I : J.
	self assert: Q = (I : (R * x) /\ (I : (R * y))).
	self assert: Q = (R * {x*z - (y^2). x^3 - (y*z). x^2*y - (z^2)})! !

!CommutativeAlgebraTest methodsFor: 'ideal operations' stamp: 'len 5/23/2020 09:33:01'!
testIdealElimination
	"Example from Cox IVA 123 p. NOTE: this is a little slow."
	| Qx x y z I |
	Qx _ Ñ polynomialsIn: #(x y z).
	x _ Qx x. y _ Qx y. z _ Qx z.
	I _ Qx * {x^2 + y + z - 1. x + (y^2) + z - 1. x + y + (z^2) - 1}.
	self assert: (I eliminateAll: #(1 2)) generator = (z^6 - (z^4*4) + (z^3*4) - (z^2))! !

!CommutativeAlgebraTest methodsFor: 'ideal operations' stamp: 'len 5/23/2020 09:00:22'!
testIdealEqualsUnitIdeal
	| R x y I |
	R _ É/7 polynomialsIn: #(x y) ordering: #glex.
	x _ R x.
	y _ R y.
	I _ R * {x + 1. x - 1. y - 2}.
	self assert: I = R oneIdeal! !

!CommutativeAlgebraTest methodsFor: 'ideal operations' stamp: 'len 5/23/2020 09:33:01'!
testIdealHomogenization
	"The homogenization of an ideal can be bigger than the ideal generated by the homogenized generators."
	| Qx x y z f1 f2 I f3 J |
	Qx _ Ñ polynomialsIn: #(x y z).
	x _ Qx x.
	y _ Qx y.
	z _ Qx z.
	"Ideal for the twisted cubic:"
	f1 _ y - (x^2).
	f2 _ z - (x^3).
	I _ Qx * {f1. f2}.
	"Now a polynomial in I:"
	f3 _ f2 - (f1*x).
	self assert: (I homogenized includes: f3 homogenized).
	"But it's not in the ideal generated by the homogenized generators:"
	J _ Qx * {f1 homogenized. f2 homogenized}.
	self deny: (J includes: f3 homogenized)! !

!CommutativeAlgebraTest methodsFor: 'ideal operations' stamp: 'len 5/23/2020 09:33:01'!
testIdealIntersection
	"Example from Cox IVA 194 p."
	| Qxy x y I J K |
	Qxy _ Ñ polynomialsIn: #(x y).
	x _ Qxy x.
	y _ Qxy y.
	I _ Qxy * {x^2 * y}.
	J _ Qxy * {x * (y^2)}.
	K _ Qxy * {x^2*(y^2)}.
	self assert: I /\ J = K! !

!CommutativeAlgebraTest methodsFor: 'ideal operations' stamp: 'len 5/23/2020 09:33:01'!
testIdealIntersectionRandom
	self testIdealIntersectionRandom: (Ñ polynomialsIn: #(x y))! !

!CommutativeAlgebraTest methodsFor: 'ideal operations' stamp: 'len 5/10/2019 04:31:29'!
testIdealIntersectionRandom: aRing
	| R f1 f2 g I J K |
	R _ aRing.
	f1 _ R atRandomBits: 10.
	f2 _ R atRandomBits: 10.
	g _ R atRandomBits: 10.
	I _ R * {f1. g}.
	J _ R * {f2. g}.
	K _ R * {g}.
	self assert: I /\ J >= K! !

!CommutativeAlgebraTest methodsFor: 'ideal operations' stamp: 'len 5/23/2020 09:33:01'!
testIdealIsPrime
	| R x y I |
	R _ Ñ polynomialsIn: #(x y).
	x _ R x: #x.
	y _ R x: #y.
	I _ R * {x^2 - (y^2) - 1}.
	self assert: I isPrime! !

!CommutativeAlgebraTest methodsFor: 'ideal operations' stamp: 'len 5/23/2020 09:33:01'!
testIdealIsRadical
	"Becker, Weispfenning, 'Groebner Bases', Exercise 8.21."
	| R x y I |
	R _ Ñ polynomialsIn: #(x y).
	x _ R x: #x.
	y _ R x: #y.
	I _ R * {x^2 + y. y^2 + x}.
	self assert: (R / I) dimension = 0.
	self assert: I isRadical! !

!CommutativeAlgebraTest methodsFor: 'ideal operations' stamp: 'len 5/23/2020 09:33:01'!
testIdealMembership
	| Qxy x y f g I J h k |
	Qxy _ Ñ polynomialsIn: #(x y).
	x _ Qxy x.
	y _ Qxy y.
	f _ x^2 - y.
	g _ x^3 - x.
	I _ Qxy * {f. g}.
	J _ Qxy * {x^2. y^3}.
	h _ y^2 - y.
	k _ x*y - x.
	self assert: (I includes: h).
	self assert: (I includes: k).
	self assert: (J includes: h) not.
	self assert: (J includes: k) not! !

!CommutativeAlgebraTest methodsFor: 'ideal operations' stamp: 'len 5/23/2020 09:33:01'!
testIdealMembership2
	| Qxy x y I |
	Qxy _ Ñ polynomialsIn: #(x y).
	x _ Qxy x.
	y _ Qxy y.
	I _ Qxy * {x*x. y*2 + x}.
	self assert: (I includes: (x + y) squared)! !

!CommutativeAlgebraTest methodsFor: 'ideal operations' stamp: 'len 5/23/2020 09:33:01'!
testIdealMembership3
	| Qx x y z w f g I |
	Qx _ Ñ polynomialsIn: #(x y z w).
	x _ Qx x.
	y _ Qx y.
	z _ Qx z.
	w _ Qx x: #w.
	f _ x*z-(y^2). "twisted cubic"
	g _ z*(y*w-(z^2)) - (w*(x*w-(y*z))).
	I _ Qx * {f. g}.
	"The twisted cubic C in P^3 is the set-theoretic complete intersection
	of f=0 and g=0, but not a scheme-theoretic or ideal-theoretic complete
	intersection (the ideal is not radical since includes f^2):"
	self assert: (I includes: f^2)! !

!CommutativeAlgebraTest methodsFor: 'ideal operations' stamp: 'len 5/23/2020 09:00:26'!
testIdealMembership4
	| R x y z I |
	R _ É/127 polynomialsIn: #(x y z) ordering: #glex.
	x _ R x.
	y _ R y.
	z _ R z.
	I _ R * {x*y + z. y^3 + 1. z^2 - (x*5) - 1}.
	self assert: (I includes: (x*y + z) + (y^3 + 1)).
	self assert: (I includes: x*z*(z^2 - (x*5) - 1))! !

!CommutativeAlgebraTest methodsFor: 'ideal operations' stamp: 'len 5/23/2020 09:34:55'!
testIdealMembership5
	| R x y I |
	R _ É/7 polynomialsIn: #(x y) ordering: #glex.
	x _ R x.
	y _ R y.
	I _ R * {x*y + 1. y^2 - 1}.
	self assert: (I includes: x+y)! !

!CommutativeAlgebraTest methodsFor: 'ideal operations' stamp: 'len 5/23/2020 09:33:01'!
testIdealMembershipRandom
	self testIdealMembershipRandom: (Ñ polynomialsIn: #(x y z))! !

!CommutativeAlgebraTest methodsFor: 'ideal operations' stamp: 'len 2/23/2017 09:08:24'!
testIdealMembershipRandom: aRing
	| R f1 f2 f3 I g |
	R _ aRing.
	[(f1 _ R atRandomBits: 10) isZero] whileTrue.
	[(f2 _ R atRandomBits: 10) isZero] whileTrue.
	[(f3 _ R atRandomBits: 10) isZero] whileTrue.
	I _ R * {f1. f2. f3}.
	g _ I atRandomBits: 100.
	self assert: (I includes: g)! !

!CommutativeAlgebraTest methodsFor: 'ideal operations' stamp: 'len 5/23/2020 09:33:01'!
testIdealRadical
	| R x y I J |
	R _ Ñ polynomialsIn: #(x y).
	x _ R x: #x.
	y _ R x: #y.
	I _ R * {x^3. y^2}.
	J _ R * {x. y}.
	self assert: I radical = J! !

!CommutativeAlgebraTest methodsFor: 'ideal operations' stamp: 'len 5/23/2020 09:34:55'!
testIdealRadicalZeroDimNotPerfectField
	"Counterexample that shows how Seidenberg algorithm fails over a non-perfect field.
	From Becker and Weispfenning 'Groebner Bases', Springer-Verlag, 1993. Example 8.16."
	| p F R t x y I |
	p _ #(3 5 7 11) atRandom.
	F _ (É / p) polynomialsIn: #(t) :: fractions.
	R _ F polynomialsIn: #(x y).
	t _ F x: #t.
	x _ R x.
	y _ R y.
	I _ R * {x^p - t. y^p - t}.
	self assert: (I includes: x^p - (y^p)).
	self deny: (I includes: x - y).
	self assert: (I radical includes: x - y)! !

!CommutativeAlgebraTest methodsFor: 'ideal operations' stamp: 'len 5/23/2020 09:33:01'!
testIdealRadicalZeroDimPerfectField
	"Seidenberg algorithm works for 0-dimensional ideals over a perfect field." 
	| R y z I J |
	R _ Ñ polynomialsIn: #(y z).
	y _ R x: #y.
	z _ R x: #z.
	I _ R * {y + z. z^2}.
	J _ R * {y. z}.
	self assert: I radical = J! !

!CommutativeAlgebraTest methodsFor: 'ideal operations' stamp: 'len 5/23/2020 09:33:01'!
testIdealSaturation
	"Example from SageMath reference."
	| R x y z I J S |
	R _ Ñ polynomialsIn: #(x y z).
	x _ R x.
	y _ R y.
	z _ R z.
	I _ R * {x^5*(z^3). x*y*z. y*(z^4)}.
	J _ R * z.
	S _ R * {y. x^5}.
	self assert: (I saturation: J) = S! !

!CommutativeAlgebraTest methodsFor: 'ideal operations' stamp: 'len 5/23/2020 09:33:01'!
testLocalIdeals
	"Magma handbook, example H104E4."
	| R I J A M |
	self notYetImplemented.
	R _ Ñ polynomialsIn: #(x y z) ordering: #llex.
	I _ R * (R generate: [:x :y :z| {x*y - z. x^3*(z^2) - (y^2). x*(z^3) - x - y}]).
	J _ R * (R generate: [:x :y :z| {x*y - z. x^2*z - y. x*(z^3) - x - y}]).
	A _ R * (R generate: [:x :y :z|
		{x^2 - (y^2) + (2*(x^3)*z).
		x*y + (y^2) - (x^3*z).
		y^3.
		x*z + (y*z).
		y*z.
		z^2}]).
	self assert: I * J = A. "hangs here"
	M _ R * (R generate: [:x :y :z| {x + y. y^2. z}]).
	self assert: I /\ J = M.
	self deny: A = M.
	self assert: A <= M! !

!CommutativeAlgebraTest methodsFor: 'ideal operations' stamp: 'len 5/23/2020 09:33:01'!
testPolynomialRingHomomorphismKernel
	| A B x y phi |
	A _ Ñ polynomialsIn: #(x y z).
	B _ Ñ polynomialsIn: #(x y).
	x _ B x.
	y _ B y.
	phi _ A to: B evaluating: [:f| f value: {x-y. x. y}].
	self assert: phi kernel = (A * (A x - A y + A z)).
	self assert: (phi value: (phi kernel atRandomBits: 15)) isZero! !

!CommutativeAlgebraTest methodsFor: 'ideal operations' stamp: 'len 5/23/2020 09:33:01'!
testRadicalMembership
	| R x y z g1 g2 f I |
	R _ Ñ polynomialsIn: #(x y z).
	x _ R x.
	y _ R y.
	z _ R z.
	g1 _ x^4*(y^2) + (z^2) - (x*(y^3)*z*4) - (y^5*z*2).
	g2 _ (x + (y^2)) ^ 2.
	f _ y*z - (x^3).
	I _ R * {g1. g2}.
	self assert: (I radicalContains: f)! !

!CommutativeAlgebraTest methodsFor: 'ideal operations' stamp: 'len 5/23/2020 09:33:01'!
testSquarefreeMonomialIdealPrimaryDecomposition
	"Miller, Sturmfels, 'Combinatorial Commutative Algebra', Example 1.8."
	| R a b c d e I |
	R _ Ñ polynomialsIn: #(a b c d e).
	a _ R x: 1. b _ R x: 2. c _ R x: 3. d _ R x: 4. e _ R x: 5.
	I _ R * {a*d. a*e. b*c*d. b*e. c*e. d*e}.
	self assert: I primaryDecomposition = {R * {d. e}. R * {a. b. e}. R * {a. c. e}. R * {a. b. c. d}} asSet! !

!CommutativeAlgebraTest methodsFor: 'ideal basics' stamp: 'len 5/23/2020 09:33:01'!
testIdealElementOperations
	"Magma handbook example H103E2."
	| R x y z I |
	R _ Ñ polynomialsIn: #(x y z) "ordering: #lex".
	x _ R x. y _ R y. z _ R z.
	I _ R * {(x + y)^3. (y - z)^2. y^2*z + z}.
	self assert: (I reduce: (y^2*z + z)) isZero.
	"I basis reduceFull: x^3 = ..."
	"I basis reduce: z^4 + (y^2))"
	self deny: (I includes: x+y).
	self assert: (I radicalContains: x+y).
	self assert: (I radicalContains: (x+y)^2).
	self deny: (I radicalContains: z).
	self assert: (x^4 + y - z s: x^2 + y - z) = (x^2*y negated + (x^2*z) + y - z)! !

!CommutativeAlgebraTest methodsFor: 'ideal basics' stamp: 'len 5/23/2020 09:33:01'!
testMonomialIdeal
	"Test ideals generated by monomials are automatically created as MonomialIdeal."
	| R f g h |
	R _ Ñ polynomialsIn: 3.
	f _ R !! [:x :y :z| x^2 + y].
	g _ R !! [:x :y :z| z^3].
	h _ R !! [:x :y :z| x^2*y].
	self assert: (R * {f. g. h}) class ~= MonomialIdeal.
	self assert: (R * {g. h}) class = MonomialIdeal! !

!CommutativeAlgebraTest methodsFor: 'ideal basics' stamp: 'len 5/23/2020 09:34:55'!
testZeroIdeal
	| zero |
	zero _ É * #(). "the zero ideal {0}"
	self assert: zero isZero.
	self assert: (zero includes: 0).
	self deny: (zero includes: 42)! !

!CommutativeAlgebraTest methodsFor: 'krull dimension' stamp: 'len 5/23/2020 09:33:01'!
testKrullDimension
	| R I Q |
	R _ Ñ polynomialsIn: #(x y).
	self assert: R dimension = 2.
	I _ R * {R x. R y}.
	Q _ R / I.
	self assert: Q dimension = 0.
	I _ R * R zero. "zero ideal"
	Q _ R / I.
	self assert: Q dimension = 2! !

!CommutativeAlgebraTest methodsFor: 'krull dimension' stamp: 'len 5/23/2020 09:33:01'!
testKrullDimension2
	"Example from SageMath."
	| R x y I |
	R _ Ñ polynomialsIn: #(x y).
	x _ R x.
	y _ R y.
	I _ R * {x*y. x*y + 1}.
	self assert: (R / I) dimension < 0.
	I _ R * {x*(x*y + 1). y*(x*y + 1)}.
	self assert: (R / I) dimension = 1.
	I _ R * {x^3*y. x*(y^2)}.
	self assert: (R / I) dimension = 1! !

!CommutativeAlgebraTest methodsFor: 'krull dimension' stamp: 'len 5/23/2020 09:34:55'!
testKrullDimensionFiniteField
	"Example from SageMath."
	| R x y I Q |
	R _ É/32003 polynomialsIn: #(x y z).
	self assert: R dimension = 3.
	x _ R x.
	y _ R y.
	I _ R * {x^2 - y. x^3}.
	Q _ R / I.
	self assert: Q dimension = 1! !

!CommutativeAlgebraTest methodsFor: 'krull dimension' stamp: 'len 5/23/2020 09:34:55'!
testKrullDimensionFiniteField2
	"Example from SageMath."
	| R x y I |
	R _ É/2147483659 polynomialsIn: #(x y).
	x _ R x.
	y _ R y.
	I _ R * {x*y. x*y + 1}.
	self assert: (R / I) dimension < 0.
	I _ R * {x*(x*y + 1). y*(x*y + 1)}.
	self assert: (R / I) dimension = 1.
	I _ R * {x^3*y. x*(y^2)}.
	self assert: (R / I) dimension = 1! !

!CommutativeAlgebraTest methodsFor: 'krull dimension' stamp: 'len 5/23/2020 09:35:10'!
testKrullDimensionOverZZ
	| R I Q |
	R _ É polynomialsIn: #(x y).
	self assert: R dimension = 3.
"	I _ R * {R x. R y}.
	Q _ R / I.
	self assert: Q dimension = 0.
"	I _ R * R zero. "zero ideal"
	Q _ R / I.
	self assert: Q dimension = 3! !

!CommutativeAlgebraTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testKrullDimensionOverÉ
	| R I Q |
	R _ É polynomialsIn: #(x y).
	self assert: R dimension = 3.
"	I _ R * {R x. R y}.
	Q _ R / I.
	self assert: Q dimension = 0.
"	I _ R * R zero. "zero ideal"
	Q _ R / I.
	self assert: Q dimension = 3! !

!EllipticCurvesTest methodsFor: 'as yet unclassified' stamp: 'len 11/11/2016 10:14'!
testBInvariants
	| W |
	W _ WeierstrassEquation coefficients: (1,2,3,4,5).
	self assert: W b2 = 9.
	self assert: W b4 = 11.
	self assert: W b6 = 29.
	self assert: W b8 = 35! !

!EllipticCurvesTest methodsFor: 'as yet unclassified' stamp: 'len 11/11/2016 10:30'!
testCInvariants
	| W |
	W _ WeierstrassEquation coefficients: (0,-1,1,-10,-20).
	self assert: W c4 = 496.
	self assert: W c6 = 20008! !

!EllipticCurvesTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:33:01'!
testGroupLaw
	| E P Q O |
	E _ EllipticCurve cremona389a1.
	P _ E pointAt: (Ñ tuple: #(-1 1)).
	Q _ E pointAt: (Ñ tuple: #(0 -1)).
	O _ E pointAt: (Ñ tuple: #(0 1 0)).
	self assert: P+Q = (E pointAt: (Ñ tuple: #(4 8))).
	self assert: P-Q = (E pointAt: (Ñ tuple: #(1 0))).
	self assert: 3*P - (5*Q) = (E pointAt: (Ñ tuple: {328/361. -2800/6859})).
	self assert: O+P = P.
	self assert: P+O = P.
	self assert: P-P = O! !

!EllipticCurvesTest methodsFor: 'as yet unclassified' stamp: 'len 8/27/2018 22:15:43'!
testPointAtX
	| E p |
	E _ EllipticCurve secp256k1.
	p _ E scalars modulus.
	10 count: [(E pointsAtX: p atRandom) allSatisfy: [:each| E satisfies: each coordinates]]! !

!EllipticCurvesTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testWeierstrassEquationInvariants
	| W |
	W _ WeierstrassEquation coefficients: (É ^ 5 atRandomBits: 100).
	self assert: W b8 * 4 = (W b2 * W b6 - W b4 squared).
	self assert: W discriminant * 1728 = (W c4 ^ 3 - W c6 squared)! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 11/16/2016 10:04'!
testAutomorphismsK3
	"Aut(K3) = Sym(3)"
	| G A |
	G _ Graph K: 3.
	A _ G automorphisms.
	self assert: A = A ambient
! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 4/8/2018 05:49:45'!
testAutomorphismsP3
	"Aut(P3) = {id, (1 3)}"
	| G A |
	G _ Graph P: 3.
	A _ G automorphisms.
	self assert: A = (PermutationGroup on: G values generators: {#((1 3))})! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 12/30/2017 16:17:24'!
testCartesianProduct
	| G H |
	G _ Graph unordered addEdge: 1 -> 2; yourself.
	H _ G ◊ G.
	self assert: H size = 4.
	self assert: H numberOfEdges = 4! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 11/16/2016 10:08'!
testChromaticNumber
	| G |
	G _ Graph unordered add: 1; add: 2; add: 3; yourself. 
	self assert: G chromaticNumber = 1. "edgeless graph"
	self assert: (Graph K: 3) chromaticNumber = 3.
	self assert: (Graph C: 5) chromaticNumber = 3.
	self assert: (Graph C: 6) chromaticNumber = 2.
	self assert: (Graph W: 6) chromaticNumber = 4.
	self assert: (Graph W: 5) chromaticNumber = 3.
	self assert: (Graph S: 6) chromaticNumber = 2! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testChromaticPolynomialComplete
	| x |
	x _ É polynomials x.
	self assert: (Graph K: 3) chromaticPolynomial = (x*(x-1)*(x-2))! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testChromaticPolynomialCylic
	| x n |
	x _ É polynomials x.
	n _ 4 atRandom.
	self assert: (Graph C: n) chromaticPolynomial = (x-1^n + ((-1)^n * (x-1)))! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testChromaticPolynomialPath
	| x n |
	x _ É polynomials x.
	n _ 4 atRandom + 1.
	self assert: (Graph P: n) chromaticPolynomial = (x-1^(n-1)*x)! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 5/10/2019 04:31:47'!
testComplement
	| G H |
	G _ Graph unordered addEdges: {#a -> #b. #b -> #c. #d -> #e}; yourself.
	H _ G complement.
	self assert: (G \/ H) isComplete.
	self assert: (G /\ H) isEdgeless.
	self assert: H complement = G! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 11/16/2016 10:08'!
testConnectedComponents
	| G |
	G _ Graph unordered addEdges: {#a -> #b. #b -> #c. #d -> #e}; yourself.
	self assert: G components size = 2.
	self assert: (G components collect: [:each| each order]) = #(2 3) asSet.
	self assert: G components anyOne components size = 1! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 5/25/2016 03:39'!
testDistance
	| G |
	G _ Digraph unordered addEdges: {#a -> #b. #b -> #c. #d -> #e}; yourself.
	self assert: (G distanceFrom: #a to: #c) = 2.
	self assert: (G distanceFrom: #d to: #e) = 1.
	self assert: (G distanceFrom: #b to: #b) = 0.
	self assert: (G distanceFrom: #a to: #e) isInfinite! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 5/25/2016 03:39'!
testEquals
	| G H |
	G _ Digraph ordered addEdges: {#a -> #b. #b -> #c. #c -> #a. #X -> #Y}; yourself.
	H _ Digraph ordered addEdges: {#a -> #b. #b -> #c. #c -> #a}; yourself.
	self assert: G ~= H.
	H addEdge: #X -> #Y.
	self assert: G = H.
	self assert: G hash = H hash! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 5/25/2016 03:15'!
testImplicit
	| G |
	G _ RootedDigraph unordered roots: {2^3} children: [:each| each divisors copyWithout: each].
	self assert: G size = 4.
	self assert: G values asSet = #(1 2 4 8) asSet.
	self assert: G edges size = 6! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 5/10/2019 04:31:55'!
testIntersection
	| G H I |
	G _ Digraph unordered addEdges: {#a -> #b. #b -> #c. #d -> #e. #x -> #b}; yourself.
	H _ Digraph unordered addEdges: {#A -> #B. #b -> #c. #d -> #e. #X -> #X. #b -> #a}; yourself.
	I _ G /\ H.
	self assert: I numberOfEdges = 2.
	self assert: (I hasEdge: #b -> #c).
	self assert: (I hasEdge: #d -> #e)! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 5/25/2016 03:40'!
testIsComplete
	| G |
	G _ Digraph unordered.
	G addEdges: {#a -> #b. #b -> #a. #b -> #c. #a -> #c. #c -> #a}.
	G _ G reflexive.
	self assert: G isComplete not.
	G addEdge: #c -> #b.
	self assert: G isComplete! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 11/16/2016 10:03'!
testIsConnected
	| G |
	G _ Graph unordered addEdges: {#a -> #b. #b -> #c. #d -> #e}; yourself.
	self assert: G isConnected not.
	G addEdge: #e -> #a.
	self assert: G isConnected! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 5/25/2016 03:39'!
testIsCyclic
	| G |
	G _ Digraph unordered addEdges: {#a -> #b. #b -> #c. #d -> #e}; yourself.
	self assert: G isCyclic not.
	G addEdge: #e -> #a.
	self assert: G isCyclic not.
	G addEdge: #c -> #a.
	self assert: G isCyclic! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 5/25/2016 03:40'!
testIsSimple
	| G |
	G _ Digraph ordered addEdges: {#a -> #b. #b -> #c. #d -> #e}; yourself.
	self assert: G isSimple.
	G addEdge: #c -> #b.
	self assert: G isSimple.
	G addEdge: #c -> #b.
	self assert: G isSimple not! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 5/25/2016 03:41'!
testIsSimple2
	| G |
	G _ Digraph ordered addEdges: {#a -> #b. #b -> #c. #d -> #e}; yourself.
	self assert: G isSimple.
	G addEdge: #c -> #c.
	self assert: G isSimple not "a graph with a loop is not simple"! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 11/16/2016 10:08'!
testIsomorphism
	| G H |
	G _ Graph unordered.
	5 timesRepeat: [G addEdge: 5 atRandom -> 5 atRandom].
	H _ G shuffled.
	self assert: G ~ H.
	G _ Graph C: 5. "pentagon"
	H _ G copy.
	G addEdges: {1 -> 6. 6 -> 2}. "make a little triangle"
	H addEdges: {1 -> 6. 6 -> 3}. "same, but skip vertex 2 in the middle"
	H _ H shuffled.
	self deny: G ~ H! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 11/16/2016 10:04'!
testPetersenGraph
	| G |
	G _ Graph petersen.
	self assert: G nodes size = 10.
	self assert: G edges size = 15.
	self assert: G isCubic.
	self assert: G radius = 2.
	self assert: G diameter = 2.
"	self assert: G girth = 5"! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 5/25/2016 03:41'!
testShortestPath
	| G |
	G _ Digraph unordered.
	G addEdges: {#a -> #b. #b -> #a. #b -> #c. #a -> #c. #c -> #a}.
	self assert: (G shortestPathFrom: #c to: #b) asArray = #(a b).
	G addEdge: #c -> #b.
	self assert: (G shortestPathFrom: #c to: #b) asArray = #(b)! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 5/25/2016 03:39'!
testTransposed
	| G T |
	G _ Digraph unordered addEdges: {#a -> #b. #b -> #c. #d -> #e}; yourself.
	T _ G transposed.
	self assert: (G hasEdge: #b -> #c).
	self assert: (G hasEdge: #c -> #b) not.
	self assert: (T hasEdge: #b -> #c) not.
	self assert: (T hasEdge: #c -> #b)! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testTuttePolynomial
	| G P x y T |
	G _ Graph ordered addEdges: {1->2. 2->3. 3->4. 4->1. 1->3}; yourself.
	P _ É polynomialsIn: #(x y).
	x _ P x.
	y _ P y.
	T _ x*(x^2 + (x+y)) + (x^2 + (x+y)) + (x*y + (y^2)).
	self assert: G tuttePolynomial = T! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testTuttePolynomial2
	| G P x y T |
	G _ Graph ordered addEdges: {1->2. 2->3. 3->4. 4->1. 1->3}; yourself.
	P _ É polynomialsIn: #(x y).
	x _ P x.
	y _ P y.
	T _ x*(x^2 + (x+y)) + (x^2 + (x+y)) + (x*y + (y^2)).
	self assert: G tuttePolynomial = T! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testTuttePolynomialK3
	| G P x y T |
	G _ Graph K: 3.
	P _ É polynomialsIn: #(x y).
	x _ P x.
	y _ P y.
	T _ x^2 + x + y.
	self assert: G tuttePolynomial = T! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testTuttePolynomialK4
	| G P x y T |
	G _ Graph K: 4.
	P _ É polynomialsIn: #(x y).
	x _ P x.
	y _ P y.
	T _ x^3 + (x^2*3) + (x*2) + (x*y*4) + (y*2) + (y^2*3) + (y^3).
	self assert: G tuttePolynomial = T! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 11/16/2016 10:08'!
testUndirectedEdgeContraction
	| G |
	G _ Graph ordered addEdges: {1->2. 2->3. 3->4. 4->1. 1->3}; yourself.
	self assert: G edges size = 5.
	self assert: (G / (1->2)) edges size = 4.
	self assert: (G / (1->2) / ((1->2)->3)) edges size = 3! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 5/10/2019 04:36:25'!
testUnion
	| G |
	G _ Digraph unordered addEdges: {#a -> #b. #b -> #c. #d -> #e. #x -> #b}; yourself.
	self assert: (G \/ G transposed) = G symmetric! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 5/1/2020 03:56:35'!
smallGroupAtRandom
	^ {[SymmetricGroup new: 3].
	[AlternatingGroup new: 3].
	[PermutationGroup klein].
	[LinearGroup klein].
	[AbelianGroup orders: ((1 to: 3 atRandom) collect: [:i| (0 to: 5) atRandom])]} atRandom value! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 2/1/2018 23:02:45'!
testActionOrbitOf
	| G |
	G _ PermutationGroup on: (1 to: 8) generators: {#((1 3 2) (4 6 5)). #((1 2 3) (4 5 6)). #((7 8))}.
	self assert: (G action orbitOf: 1) = #(1 2 3) asSet.
	self assert: (G action orbitOf: 4) = #(4 6 5) asSet.
	self assert: (G action orbitOf: 7) = #(7 8) asSet! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 2/1/2018 23:04:44'!
testActionStabilizerOf
	| G g1 g2 g3 id H |
	G _ SymmetricGroup new: 8.
	g1 _ G !! #((1 3 2) (4 6 5)).
	g2 _ G !! #((1 2 3) (4 5 6)).
	g3 _ G !! #((7 8)).
	id _ G identity.
	H _ G span: {g1. g2. g3}.
	self assert: (H action stabilizerOf: 1) asSet = {id. g3} asSet.
	self assert: (H action stabilizerOf: 7) asSet = {id. g1. g2} asSet! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 4/25/2020 08:59:32'!
testAlternatingIsSymmetricCommutator
	| S A |
	S _ SymmetricGroup new: 3.
	A _ S alternatingSubgroup.
	self assert: A = S commutator.
	self assert: (S indexOf: A) = 2! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 4/30/2019 11:51:49'!
testAlternatingOrder
	| A |
	A _ AlternatingGroup new: 3.
	self assert: A order = (3 factorial / 2)! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 2/1/2018 23:07:09'!
testBigOrder1
	"Test fast computation of group order with Schreier-Sims algorithm.
	This is Sym(10), with order 10!!."
	| G |
	G _ PermutationGroup new: 10 generators: {#((1 2)). #(10 1 2 3 4 5 6 7 8 9)}.
	self assert: G order = 10 factorial! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 1/30/2018 21:25:14'!
testBigOrder2
	"Test fast computation of group order with Schreier-Sims algorithm.
	This is the Mathieu group on 12 points, the second smallest of the 26 sporadic simple groups, with order 95040."
	self assert: PermutationGroup M12 order = 95040! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 4/30/2019 11:52:42'!
testCauchyFrobeniusLemma
	"Also called Brunside's lemma, Burnside counting theorem, or orbit-counting theorem."
	| X G phi sum |
	X _ 1 to: 3.
	G _ AlternatingGroup on: X.
	phi _ GroupAction from: (G, X) to: X evaluatingWithArguments: [:f :x| f value: x].
	sum _ G elements sum: [:g| (phi fixedPointsOf: g) size].
	self assert: phi orbits size * G order = sum! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 1/28/2018 08:37:03'!
testConjugacyClasses
	"From wikipedia article on conjugacy classes."
	self assert: (SymmetricGroup new: 3) conjugacyClasses size = 3.
	self assert: (SymmetricGroup new: 4) conjugacyClasses size = 5! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 11/6/2016 10:04'!
testD3
	| D S A |
	D _ PermutationGroup dihedral: 2*3.
	self testGroup: D.
	S _ SymmetricGroup new: 3.
	self assert: D = S.
	A _ AlternatingGroup new: 3.
	self assert: D commutator = A.
	self assert: D center isTrivial! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 4/21/2020 06:11:42'!
testDirectProduct
	| S A G g |
	S _ self smallGroupAtRandom.
	A _ self smallGroupAtRandom.
	G _ S ◊ A.
	g _ G atRandom.
	self assert: g ∑ g inverse = G identity.
	self testGroup: G.
	{S. A} >- G do: [:each| self testGroupHomomorphism: each].
	G -< {S. A} do: [:each| self testGroupHomomorphism: each]! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 5/5/2019 18:14:45'!
testGroup: G
	| e a b c |
	e _ G identity.
	a _ G atRandomBits: 100.
	b _ G atRandomBits: 100.
	c _ G atRandomBits: 100.
	self assert: e ∑ a = a.
	self assert: a ∑ e = a.
	self assert: a ∑ a inverse = e.
	self assert: a inverse ∑ a = e.
	self assert: (a ∑ b) ∑ c = (a ∑ (b ∑ c))! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 5/5/2019 18:43:04'!
testGroupAction: phi
	| G X e g h x |
	G _ phi group.
	X _ phi space.
	e _ G identity.
	g _ G atRandomBits: 100.
	h _ G atRandomBits: 100.
	x _ X atRandomBits: 100.
	self assert: (phi value: {e. x}) = x.
	self assert: (phi value: {g. phi value: {h. x}}) = (phi value: {g ∑ h. x})! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 5/26/2019 08:43:33'!
testGroupAlgebra
	| G R a b c xa xb xc |
	G _ self smallGroupAtRandom.
	R _ G groupAlgebra.
	a _ G atRandom.
	b _ G atRandom.
	c _ G atRandom.
	xa _ R embed: a.
	xb _ R embed: b.
	xc _ R embed: c.
	self assert: xa*xb = (R embed: a∑b).
	self assert: xa*2 + xb*xc - (xa*xc) - (xb*xc) = (R embed: a∑c).
	self assert: (xa + xb) * (xa - xb) = (xa^2 - (xb^2) + (xb*xa) - (xa*xb))! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 5/26/2019 08:43:44'!
testGroupAlgebraIsARing
	| G R a a2 b b2 c c2 e e2 |
	G _ self smallGroupAtRandom.
	R _ G groupAlgebra.
	e _ G identity.
	a _ G atRandom.
	b _ G atRandom.
	c _ G atRandom.
	e2 _ R embed: e.
	a2 _ R embed: a.
	b2 _ R embed: b.
	c2 _ R embed: c.
	self assert: e2 = R one.
	self assert: e2 * a2 = a2.
	self assert: a2 * e2 = a2.
	self assert: (a2 * b2 * c2) = (a2 * (b2 * c2)).
	G isCommutative ifTrue: [self assert: a2 * b2 = (b2 * a2)].! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 5/5/2019 18:43:49'!
testGroupHomomorphism: phi
	| G H a b |
	G _ phi domain.
	H _ phi codomain.
	a _ G atRandomBits: 100.
	b _ G atRandomBits: 100.
	self assert: (phi value: G identity) = H identity.
	self assert: (phi value: a ∑ b) = ((phi value: a) ∑ (phi value: b))! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 11/6/2016 10:03'!
testHessian
	| H |
	H _ PermutationGroup hessian.
	self assert: H elements size = 216.
	self testGroup: H! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 4/30/2019 11:51:16'!
testIsSolvable
	| G |
	G _ SymmetricGroup new: 3.
	self assert: G isSolvable! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 4/30/2019 11:52:58'!
testIsSolvableNot
	| G |
	G _ AlternatingGroup new: 5.
	self assert: G isSolvable not! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 4/22/2020 06:38:34'!
testKleinFour
	| V S A |
	V _ PermutationGroup klein.
	self testGroup: V.
	S _ V ambient.
	self assert: (V isNormalIn: S).
	A _ S commutator.
	self assert: (V isNormalIn: A)! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 5/25/2019 04:46:36'!
testLagrangeTheorem
	"G finite group, H subgroup of G, then |H| divides |G|."
	| G H |
	G _ self smallGroupAtRandom.
	H _ G span: ((1 to: 3 atRandom) collect: [:i| G atRandom]) asSet.
	self assert: H order | G order! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testModularIntegersUnits
	| m R U |
	m _ (2 to: 100) atRandom.
	R _ É / m.
	U _ R units.
	self assert: U size = (Sequence phi value: m).
	self testGroup: U! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 4/30/2019 11:53:11'!
testOrbitStabilizerTheorem
	| X G phi p |
	X _ 1 to: 4.
	G _ AlternatingGroup on: X.
	phi _ GroupAction from: (G, X) to: X evaluatingWithArguments: [:f :x| f value: x].
	p _ X atRandom.
	self assert: (phi stabilizerOf: p) order * (phi orbitOf: p) size = G order! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 1/30/2018 21:34:39'!
testPermutationGroupAction
	self testGroupAction: (SymmetricGroup new: 10) action.
	self testGroupAction: (PermutationGroup cyclic: 15) action! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 12/22/2016 21:40:10'!
testPermutationGroupHomomorphism
	"Magma Handbook, Example H57E2."
	| C15 h im |
	C15 _ PermutationGroup cyclic: 15.
	h _ C15 to: C15 evaluating: [:g| g ^ 3].
	im _ h image.
	self assert: im space size = 15. "a permutation group acting on a set of cardinality 15"
	self assert: im size = 5. "of order 5"
	self assert: im isCyclic! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 4/30/2019 11:51:29'!
testSymmetricOrder
	| G |
	G _ SymmetricGroup new: 4.
	self assert: G order = 4 factorial! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 11/14/2016 08:35'!
testTrivial
	| G |
	G _ PermutationGroup new: 4 generators: #().
	self assert: G size = 1.
	self assert: G isTrivial! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:33:01'!
testAlgebraicExtension
	| x E a b |
	x _ Ñ polynomials x.
	E _ Ñ extension: x^4 - 2.
	a _ E x.
	self assert: (a^4) representative asScalar = 2.
	b _ a^2 + (E embed: 3).
	self assert: b minimalPolynomial = (x^2 - (x*6) + 7)! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 7/2/2016 05:48'!
testBitCount
	| v |
	v _ 1 << 3000 :: atRandom.
	self assert: (v printStringBase: 2 :: count: [:x| x = $1]) = v bitCount! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 7/2/2016 05:48'!
testBitParity
	| v |
	v _ 1 << 3000 :: atRandom.
	self assert: ((v printStringBase: 2 :: count: [:x| x = $1]) bitAnd: 1) = v bitParity! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 4/26/2018 08:16:17'!
testCRT
	| crt |
	crt _ CRT mod: #(2 5 7).
	self assert: (crt solve: #(0 2 0)) = 42! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/16/2016 13:35:30'!
testCartesianProduct
	| P x |
	P _ CartesianProduct components: {PrimeField new: 3. GaloisField new: 4. SymmetricGroup new: 5}.
	self assert: P elements size = (3*4*5 factorial).
	x _ {(P at: 1) atRandom. (P at: 2) atRandom. (P at: 3) atRandom}.
	self assert: (P elements includes: x)! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/4/2015 01:46'!
testContinuedFractions
	| x |
	x _ ContinuedFraction fromFraction: 415/93.
	self assert: x coefficients = (4, 2, 6, 7).
	self assert: x asFraction = (415/93)! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/4/2015 22:01'!
testContinuedFractions2
	-2 to: 2 by: 1/2 do:
		[:x| self assert: (ContinuedFraction fromFraction: x) asFraction = x]! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 3/27/2016 04:47'!
testContinuedFractionsE
	| x e |
	e _ ContinuedFraction e.
	x _ e convergentAt: 20.
	self assert: (x asFloat - 1 exp) abs < 0.0000001! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 3/27/2016 04:47'!
testContinuedFractionsGoldenRatio
	| x phi |
	phi _ ContinuedFraction phi.
	x _ phi convergentAt: 20.
	self assert: (x asFloat - 1.6180339887) abs < 0.000001! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 5/9/2020 10:16:07'!
testContinuedFractionsGoldenRatio2
	| phi denominators |
	phi _ ContinuedFraction phi.
	denominators _ phi convergents collect: [:each| each asRational denominator].
	self assert: (denominators equals: Sequence fibonacci << 1 upTo: 100)! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/3/2015 02:18'!
testContinuedFractionsNegated
	| x |
	x _ ContinuedFraction fromFraction: 415/93.
	self assert: x negated asFraction = (-415/93)! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/3/2015 02:19'!
testContinuedFractionsReciprocal
	| x |
	x _ ContinuedFraction fromFraction: 415/93.
	self assert: x reciprocal asFraction = (93/415)! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:33:01'!
testCyclotomicPolynomials
	| P |
	P _ Ñ polynomials.
	1 to: 20 do: [:n| self assert: (P cyclotomic: n) degree = n phi]! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:33:01'!
testCyclotomicPolynomials2
	| P x n |
	P _ Ñ polynomials.
	x _ P x.
	n _ 100 atRandom.
	self assert: (n divisors product: [:d| P cyclotomic: d]) = (x^n - 1)! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 5/9/2020 14:00:45'!
testExtendedEuclid
	| a b euclid g u v |
	a _ -1000 to: 1000 :: atRandom.
	b _ -1000 to: 1000 :: atRandom.
	euclid _ a xgcd: b.
	g _ euclid at: 1.
	u _ euclid at: 2.
	v _ euclid at: 3.
	self assert: g | a.
	self assert: g | b.
	self assert: ({u. v} * {a. b}) sum = g.
	self assert: g = (a gcd: b)! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:33:01'!
testFieldAutomorphisms
	self assert: Ñ automorphisms isTrivial! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:33:01'!
testFreeAlgebra
	| A f g h |
	A _ Ñ freeAlgebraIn: #(x y z).
	f _ A atRandomBits: 100.
	g _ A atRandomBits: 100.
	h _ A atRandomBits: 100.
	self assert: (f*g)*h = (f*(g*h)). "associativity"
	self assert: (f+g)*h = (f*h + (g*h)). "distributivity"
	self assert: f * A one = f.
	self assert: A one * f = f! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testFunctionComposition
	| f g a |
	f _ É carrier to: É carrier evaluating: [:x| x * 2].
	g _ É carrier to: É carrier evaluating: [:x| x + 1].
	a _ 1000 atRandom.
	self assert: (f ∑ g value: a) = (f value: (g value: a)).
	self assert: (g ∑ f value: a) = (g value: (f value: a))! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testFunctionComposition2
	| f g a |
	f _ É carrier to: Ñ carrier evaluating: [:x| x asRatio / 2].
	g _ Ñ carrier to: É carrier evaluating: [:x| x numerator].
	a _ 1000 atRandom.
	self assert: (f ∑ g value: a asRatio) = (f value: (g value: a asRatio)).
	self assert: (g ∑ f value: a) = (g value: (f value: a))! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testFunctionComposition3
	| f g |
	f _ É carrier to: Ñ carrier evaluating: [:x| x / 2].
	g _ É carrier to: É carrier evaluating: [:x| x + 1].
	self should: [g ∑ f] raise: DomainError! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/11/2016 20:01:51'!
testFundamentalDiscriminant
	self assert: ((1 to: 33) select: [:each| each isFundamentalDiscriminant]) =  #(1 5 8 12 13 17 21 24 28 29 33).
	self assert: ((0 to: -31 by: -1) select: [:each| each isFundamentalDiscriminant]) = #(-3 -4 -7 -8 -11 -15 -19 -20 -23 -24 -31) 
! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 6/4/2016 21:56'!
testInfinity
	self assert: Infinity positive > Infinity negative.
	self assert: Infinity positive > 127934879182734.
	self assert: Infinity negative < -198273498712341.
	self assert: Infinity positive >= 127934879182734.
	self assert: Infinity negative <= -198273498712341.
	self assert: -918723948719 > Infinity negative.
	self assert: 91872123948719 < Infinity positive! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 7/8/2016 05:34'!
testInfinityUndeterminates
	self should: [Infinity positive + Infinity negative] raise: Error.
	self should: [Infinity positive * 0] raise: Error.
	self should: [Infinity positive / Infinity positive] raise: Error.
	self should: [Infinity positive ^ 0] raise: Error
! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/13/2015 02:02'!
testIntegerDivisors
	self assert: 12 numberOfDivisors = 6.
	self assert: 12 divisors size = 6! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testIntegerIdealsPrimePrimarySemiprime
	self assert: (É*5) isPrime.
	self assert: (É*6) isPrime not.
	self assert: (É*25) isPrimary.
	self assert: (É*30) isPrimary not.
	self assert: (É*30) isSemiprime.
	self assert: (É*12) isSemiprime not! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 5/15/2020 12:11:58'!
testIntegerSplit
	"Split algorithm from 'Fast Algorithms for Linear Algebra Modulo N', Arne Storjohann, Thom Mulders."
	| D a M |
	10000 timesRepeat:
		[D _ 100 atRandom.
		a _ D atRandom - 1.
		M _ a split: D.
		self assert: M > 0.
		self assert: M | D.
		M factors asSet do: [:p| self deny: p | a].
		(D / M) factors asSet do: [:p| self assert: p | a]]! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testIteratorCovering
	| F |
	F _ É / 3.
	self assert: (F^3 upTo: 3^3) asSet size = (3^3).
	self assert: (É^3 upTo: 100) asSet size = 100! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/16/2016 13:35:55'!
testIteratorCovering2
	| F |
	F _ GaloisField new: 9.
	self assert: ((F^3) upTo: 9^3) asSet size = (9^3).
	self assert: ((F^3) upTo: 9^3+100) asSet size = (9^3)! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/16/2016 13:36:04'!
testIteratorCovering3
	| F |
	F _ GaloisField new: 3.
	self assert: ((F^4) upTo: 3^4) asSet size = (3^4).
	self assert: ((F^4) upTo: 3^4+100) asSet size = (3^4)! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/26/2016 23:11:25'!
testJacobiAndLegendreSymbols
	| a p |
	10 timesRepeat:
		[p _ (1000 atRandom + 2) nextPrime. "an odd prime"
		a _ 1000 atRandom - 1.
		self assert: (a legendre: p) = (a jacobi: p)]! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/28/2016 08:34:47'!
testKroneckerAndLegendreSymbols
	| a p |
	10 timesRepeat:
		[p _ (1000 atRandom + 2) nextPrime. "an odd prime"
		a _ 1000 atRandom - 1.
		self assert: (a legendre: p) = (a kronecker: p)]! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/28/2016 08:51:30'!
testKroneckerSymbol
	| a b c |
	a _ (-100 to: 100) atRandom.
	b _ (-100 to: 100) atRandom.
	self assert: ((a kronecker: b) = 0) = ((a gcd: b) ~= 1).
	c _ (-100 to: 100) atRandom.
	self assert: (a*b kronecker: c) = ((a kronecker: c) * (b kronecker: c)).
	b*c = 0 ifFalse: [self assert: (a kronecker: b*c) = ((a kronecker: b) * (a kronecker: c))]! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/26/2016 23:13:26'!
testLegendreSymbol
	self assert: ((1 to: 10) collect: [:k| k legendre: 43]) = #(1 -1 -1 1 -1 1 -1 -1 1 1)! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 4/30/2020 09:42:31'!
testMapsInducedByHom
	| X Y Z f g h yz zx |
	X _ #(1 2 3) asSet asDomain.
	Y _ {$x. $y. $z} asSet asDomain.
	Z _ #(a b c) asSet asDomain.
	f _ X to: Y evaluating: [:each| Y atRandom: (Random seed: each hash)].
	g _ f => Z. "Hom(-,Z)"
	self assert: g domain = (Y => Z). "it is contravariant"
	self assert: g codomain = (X => Z).
	yz _ Y to: Z evaluating: [:each| Z atRandom: (Random seed: each hash)].
	self assert: (g value: yz) = (yz ∑ f).
	h _ Z => f. "Hom(Z,-)"
	self assert: h domain = (Z => X). "it is covariant"
	self assert: h codomain = (Z => Y).
	zx _ Z to: X evaluating: [:each| X atRandom: (Random seed: each hash)].
	self assert: (h value: zx) = (f ∑ zx)! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 7/2/2016 21:04'!
testPartitions
	self assert: 42 partitions size =  53174! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 2/1/2018 22:41:50'!
testPermutationProduct
	| G a b |
	G _ SymmetricGroup new: 5.
	a _ G !! #((1 4 5) (2 3)).
	b _ G !! #((2 4) (5 1)).
	self assert: b*a = (G !! #((1 2 3 4))).
	self assert: a*a = (G !! #((1 5 4)))! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 2/1/2018 22:42:32'!
testPermutationProduct2
	| G a b |
	G _ SymmetricGroup new: 5.
	a _ G !! #((1 4 5) (2 3)).
	b _ G !! #((2 4) (5 1)).
	self assert: b*a = (G !! #((1 2 3 4))).
	self assert: a*a = (G !! #((1 5 4)))! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 2/1/2018 23:38:29'!
testPermutationProduct3
	| G a b |
	G _ SymmetricGroup new: 4.
	a _ G !! #((2 3 4)).
	b _ G !! #((1 2) (3 4)).
	self assert: b*a = (G !! #((1 2 4))).
	self assert: a*b = (G !! #((1 3 2)))! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:33:01'!
testPolynomialVectorSpace
	| Qx V S x |
	Qx _ Ñ polynomials.
	x _ Qx x.
	V _ Qx filtrationAt: 5.
	S _ V span: {Qx one. x^2. x*2}.
	self assert: (S includes: V !! (x^2 + 2)).
	self deny: (S includes: V !! (x^3 + 2)).
	self assert: Qx !! (S orthogonalProjection value: x^3 - (x^2) + (x*2) + 3) = ((x^2) negated + (x*2) + 3)! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/13/2015 01:54'!
testPrimeSignature
	self assert: 1 primeSignature = #().
	self assert: 7 primeSignature = #(1).
	self assert: (7*5) primeSignature = #(1 1).
	self assert: 12 primeSignature = #(2 1).
	self assert: 100 primeSignature = #(2 2).
	self assert: 42 primeSignature = #(1 1 1).
	self assert: 16 primeSignature = #(4)! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/21/2016 20:21:11'!
testRadicalAndIsSquareFree
	| n |
	n _ (-1000 to: 1000) atRandom.
	self assert: n isSquareFree = (n radical = n)! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 6/4/2016 21:48'!
testRealIntervalIntersects
	| I J |
	I _ RealInterval open: -1 closed: 0.
	J _ RealInterval open: 0 closed: 1.
	self assert: (I intersects: J) not.
	J _ RealInterval closed: 0 open: 1.
	self assert: (I intersects: J).
	J _ RealInterval closed: -2 closed: -1.
	self assert: (I intersects: J) not! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 3/3/2016 23:22'!
testWord
	| x y |
	x _ Word x: #x.
	y _ Word x: #y.
	self assert: (x*y) * y reciprocal = x.
	self assert: (x*y * (y reciprocal * x reciprocal)) isEmpty.
	self assert: x*y*y * (y reciprocal * y reciprocal * x) = (x^2).
	self assert: x * (y * y * x) = (x * y * (y * x)).
	self assert: (x*y * (x*y) reciprocal) isEmpty! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 1/10/2018 11:31:05'!
testWordOrdering
	| F p q r |
	F _ FreeMonoid new: 3.
	p _ F atRandomBits: 20 atRandom.
	r _ F atRandomBits: 20 atRandom.
	[p < (q _ F atRandomBits: 20 atRandom)] whileFalse.
	self assert: p*r <= (q*r).
	self assert: r*p <= (r*q).
	p _ q * r.
	self assert: (p > q or: [p = q and: [r isEmpty]]).
	self assert: (p > r or: [p = r and: [q isEmpty]])! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 03:30'!
testYoungTableauxSemistandard
	| T |
	T _ YoungTableau rows: #((1 1 2 2 3) (2 3 4 4) (4) (5)).
	self assert: T isSemistandard.
	self assert: T shape = #(5 4 1 1)! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 03:30'!
testYoungTableauxStandard
	| T |
	T _ YoungTableau rows: #((1 4 6 8) (2 5 7) (3)).
	self assert: T isStandard.
	self assert: T weight = #(1 1 1 1 1 1 1 1).
	self assert: T shape = #(4 3 1)! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/3/2019 05:00:17'!
testEchelonOverFiniteField
	"From Magma Handbook example H26E10."
	| K w A |
	K _ GaloisField new: 8.
	w _ K x.
	A _ K matrix: 4@3 coefficients: {1. w. w^5. 0. w^3. w^4. w. 1. w^6. w^3. 1. w^4}.
	self assert: A echelon = (K matrix: 4@3 coefficients: {1. 0. 0. 0. 1. 0. 0. 0. 1. 0. 0. 0})! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/23/2020 09:34:55'!
testHNFvsCHNF
	| A |
	A _ É atRandomMatrix: 4 bits: 50.
	self assert: A HNF = A antitransposed CHNF antitransposed! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/23/2020 09:34:55'!
testHermiteNormalForm
	"Example from wikipedia."
	| A H |
	A _ É matrix: { (3,3,1,4). (0,1,0,0). (0,0,19,16). (0,0,0,3) }.
	H _ É matrix: { (3,0,1,1). (0,1,0,0). (0,0,19,1). (0,0,0,3) }.
	self assert: A HNF = H! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/23/2020 09:34:55'!
testHermiteNormalForm10
	"Bug."
	| A H |
	A _ É matrix: #((1 2 3 0) (1 2 3 1)).
	H _ É matrix: #((1 2 3 0) (0 0 0 1)).
	self assert: A HNF = H! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/23/2020 09:34:55'!
testHermiteNormalForm2
	| A H |
	A _ É matrix: { (9,-36,30). (-36,192,-180). (30,-180,180) }.
	H _ É matrix: { (3,0,30). (0,12,0). (0,0,60) }.
	self assert: A HNF = H! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/23/2020 09:34:55'!
testHermiteNormalForm3
	"Example from wikipedia"
	| A H |
	A _ É matrix: { (2,3,6,2). (5,6,1,6). (8,3,1,1) }.
	H _ É matrix: { (1,0,50,-11). (0,3,28,-2). (0,0,61,-13) }.
	self assert: A HNF = H! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/23/2020 09:34:55'!
testHermiteNormalForm4
	"Example from Sage"
	| A B |
	A _ É matrix: {(1,2,3,4). (5,6,7,8). (9,10,11,12)}.
	B _ É matrix: {(1,2,3,4). (0,4,8,12). (0,0,0,0)}.
	self assert: A HNF = B.
	self assert: A echelon = B "the echelon form of integers matrices is the hermite normal form"! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/23/2020 09:34:55'!
testHermiteNormalForm5
	"From Magma Handbook example H26E10."
	| A H |
	A _ É matrix: #((2 -4 12 7 0) (3 -3 5 -1 4) (2 -1 -4 -5 -12) (0 3 6 -2 0)).
	H _ É matrix: #((1 1 1 6 -164) (0 3 0 16 -348) (0 0 2 13 -200) (0 0 0 19 -316)).
	self assert: A HNF = H! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/23/2020 09:34:55'!
testHermiteNormalForm6
	"From MuPAD documentation."
	| A H |
	A _ É matrix: #(
		(25 -300 1050 -1400 630)
		(-300 4800 -18900 26880 -12600)
		(1050 -18900 79380 -117600 56700)
		(-1400 26880 -117600 179200 -88200)
		(630 -12600 56700 -88200 44100)).
	H _ É matrix: #(
		(5 0 -210 -280 630)
		(0 60 0 0 0)
		(0 0 420 0 0)
		(0 0 0 840 0)
		(0 0 0 0 2520)).
	self assert: A HNF = H "this fails, but it seems to be a bug in MuPAD, because 'H isHermiteNormalForm' answers false"! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/23/2020 09:34:55'!
testHermiteNormalForm7
	"Example from GAP manual."
	| A H |
	A _ É matrix: #((1 15 28) (4 5 6) (7 8 9)).
	H _ É matrix: #((1 0 1) (0 1 1) (0 0 3)).
	self assert: A HNF = H! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/23/2020 09:34:55'!
testHermiteNormalForm8
	"Example from Pernet-Stein 'Fast computation of Hermite normal forms of random integer matrices'."
	| A H |
	A _ É matrix: #((-5 8 -3 -9 5 5) (-2 8 -2 -2 8 5) (7 -5 -8 4 3 -4) (1 -1 6 0 8 -3)).
	H _ É matrix: #((1 0 3 237 -299 90) (0 1 1 103 -130 40) (0 0 4 352 -450 135) (0 0 0 486 -627 188)).
	self assert: A HNF = H! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/23/2020 09:34:55'!
testHermiteNormalForm9
	"Example from Pernet-Stein 'Fast computation of Hermite normal forms of random integer matrices'."
	| A H |
	A _ É matrix: #((-1 2 5 65 2) (4 -1 -3 1 -2) (-1 -2 1 -1 1)).
	H _ É matrix: #((1 0 17 259 7) (0 1 31 453 13) (0 0 40 582 17)).
	self assert: A HNF = H! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/23/2020 09:33:01'!
testHermiteNormalFormOverPolynomials
	"From MuPAD documentation."
	| R x A H |
	R _ Ñ polynomials.
	x _ R x.
	A _ R matrix: 2 coefficients: {x^2 + 3. (x*2 - 1)^2. (x + 2)^2. x^2*3 + 5}.
	H _ R matrix: 2 coefficients: {R one. (x^3*4 + (x^2*47) - (x*76) + 20) / 49. R zero. x^4 + (x^3*12) - (x^2*13) - (x*12) - 11}.
	self assert: A HNF = H! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/23/2020 09:34:55'!
testHowellNormalForm1
	"Examples from 'Fast Algorithms for Linear Algebra Modulo N', Arne Storjohann, Thom Mulders."
	| R A B C D H |
	R _ É/12.
	A _ R matrix: #((4 1 0) (0 0 5) (0 0 0)).
	B _ R matrix: #((8 5 5) (0 9 8) (0 0 10)).
	C _ R matrix: #((4 1 10) (0 0 5) (0 0 0)).
	D _ R matrix: #((4 1 0) (0 0 1) (0 0 0)).
	H _ R matrix: #((4 1 0) (0 3 0) (0 0 1)).
	self assert: A echelon = H.
	self assert: B echelon = H.
	self assert: C echelon = H.
	self assert: D echelon = H
! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/23/2020 09:34:55'!
testHowellNormalForm2
	| m R t u |
	100 timesRepeat:
		[[m _ 256 atRandom + 1. m isPrime] whileTrue.
		R _ É/m.
		t _ R atRandomTuple: 5 atRandom.
		u _ R units atRandom.
		self assert: t asRowMatrix echelon = (t*u) asRowMatrix echelon]! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/23/2020 09:34:55'!
testHowellNormalForm3
	"Example from 'Spans in the module (Z/mZ)^s', John A. Howell (1986)."
	| R A H |
	R _ É/6.
	A _ R matrix: #((2 1)).
	H _ R matrix: #((2 1) (0 3)).
	self assert: A echelon = H! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/23/2020 09:33:01'!
testIsEchelonForm
	| A E |
	A _ self newRandomMatrix: 6 atRandom @ 6 atRandom over: Ñ.
	E _ A echelon.
	self assert: E isEchelonForm.
	self assert: E isReducedEchelonForm! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/23/2020 09:34:55'!
testIsHermiteNormalForm
	"Example from wikipedia."
	| A H |
	A _ É matrix: { (3,3,1,4). (0,1,0,0). (0,0,19,16). (0,0,0,3) }.
	H _ É matrix: { (3,0,1,1). (0,1,0,0). (0,0,19,1). (0,0,0,3) }.
	self assert: A isHermiteNormalForm not.
	self assert: H isHermiteNormalForm! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/23/2020 09:34:55'!
testIsHermiteNormalForm2
	| M |
	M _ É matrix: {(2,0,1,11). (0,1,5,12). (0,0,6,12). (0,0,0,33)}.
	self assert: M isHermiteNormalForm.
	self assert: M transposed isHermiteNormalForm not.
	M _ É matrix: {(2,0,1,11). (0,1,5,12). (0,0,6,12). (0,0,0,33). (0,0,0,0)}.
	self assert: M isHermiteNormalForm.
	M _ É matrix: {(2,0,1,11). (0,1,5,12). (0,0,6,12). (0,0,0,33). (0,0,0,1)}.
	self assert: M isHermiteNormalForm not! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/23/2020 09:33:01'!
testJordanNormalForm
	| A jordan B |
"	<timeout: 2>"
	A _ Ñ matrix: { (5,4,2,1). (0,1,-1,-1). (-1,-1,3,0). (1,1,-1,2) }.
	jordan _ A jordan.
	self assert: jordan size = 3.
	B _ Ñ matrix: 1 scalar: 1.
	self assert: (jordan includes: B).
	B _ Ñ matrix: 1 scalar: 2.
	self assert: (jordan includes: B).
	B _ Ñ matrix: 2 scalar: 4 :: at: 1@2 put: 1; yourself.
	self assert: (jordan includes: B)! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/23/2020 09:33:01'!
testRCF
	| A |
	A _ Ñ matrix: #((-2 0 0) (-1 -4 -1) (2 4 0)).
	self assert: A RCF = (Ñ matrix: #((-2 0 0) (0 0 -4) (0 1 -4)))! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/23/2020 09:33:01'!
testRCF2
	"Example from wikipedia:"
	| A C |
	A _ Ñ matrix: #(
		(-1 3 -1 0 -2 0 0 -2)
		(-1 -1 1 1 -2 -1 0 -1)
		(-2 -6 4 3 -8 -4 -2 1)
		(-1 8 -3 -1 5 2 3 -3)
		(0 0 0 0 0 0 0 1)
		(0 0 0 0 -1 0 0 0)
		(1 0 0 0 2 0 0 0)
		(0 0 0 0 4 0 1 0)).
	C _ Ñ matrix: #(
		(0 1 0 0 0 0 0 0)
		(1 1 0 0 0 0 0 0)
		(0 0 0 0 0 0 0 -1)
		(0 0 1 0 0 0 0 -4)
		(0 0 0 1 0 0 0 -4)
		(0 0 0 0 1 0 0 2)
		(0 0 0 0 0 1 0 4)
		(0 0 0 0 0 0 1 0)).
	self assert: A RCF = C! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/23/2020 09:34:55'!
testRCFAndInvariantFactors
	"Example from Magma documentation."
	| K A R x |
	K _ É/5.
	A _ K matrix: 5 coefficients: (#(0 2 4 2 0 2 2 2 3 3 3 4 4 1 3 0 0 0 0 1 0 0 0 1 0) apply: É -> K).
	R _ K matrix: 5 coefficients: (#(1 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 1 0) apply: É -> K).
	self assert: A RCF = R.
	x _ K polynomials x.
	self assert: A invariantFactors = {x - 1. x^2 - 1. x^2 - 1}
	"TODO: test transformation T such that T*A*T inverse = R"! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/23/2020 09:34:55'!
testReducerPivots
	| A |
	A _ É matrix: {(0,-1,-1). (0,-20,1). (0,1,2)}.
	self assert: A reduction pivots asArray = {1@2. 2@3}! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/23/2020 09:34:55'!
testSmithNormalForm
	| A |
	A _ É matrix: { (2,4,4). (-6,6,12). (10,-4,-16) }.
	self assert: A SNF = (É diagonalMatrix: #(2  6 12))! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/23/2020 09:34:55'!
testSmithNormalForm2
	| A |
	"Reduced Laplacian matrix of K_4:"
	A _ É matrix: { (3,-1,-1). (-1,3,-1). (-1,-1,3) }.
	self assert: A SNF = (É diagonalMatrix: #(1  4  4))! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/23/2020 09:34:55'!
testSmithNormalForm3
	"Example from Willian Stein, 'Algebraic Number Theory, A Computational Approach'."
	| A |
	A _ É matrix: { (1,4,9). (16,25,36). (49,64,81) }.
	self assert: A SNF = (É diagonalMatrix: #(1 3 72))! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/23/2020 09:34:55'!
testSmithNormalForm4
	"Smith form of a 3x3 matrix of rank 2.
	Example from Willian Stein, 'Algebraic Number Theory, A Computational Approach'."
	| A |
	A _ É matrix: #((2 3 4) (5 6 7) (8 9 10)).
	self assert: A SNF = (É diagonalMatrix: #(1 3 0)) "this fails with SNF because Cohen defines SNF only for nonsingular matrices, so use SNF2"! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/23/2020 09:34:55'!
testSmithNormalForm5
	"Example from youtube video: 'Derek Holt: Algorithms for finitely presented groups' @ 25:49."
	| A |
	A _ É matrix: #((1 2 0 -2) (0 2 2 0) (-1 -4 4 2)).
	self assert: A SNF = (É matrix: #((1 0 0 0) (0 2 0 0) (0 0 6 0)))! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/23/2020 09:34:55'!
testSmithNormalForm6
	"From Magma Handbook example H26E10."
	| A |
	A _ É matrix: #((2 -4 12 7 0) (3 -3 5 -1 4) (2 -1 -4 -5 -12) (0 3 6 -2 0)).
	self assert: A elementaryDivisors = #(1 1 1 2)! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/23/2020 09:34:55'!
testSmithNormalForm7
	"From GAP manual."
	| A |
	A _ É matrix: #((1 15 28) (4 5 6) (7 8 9)).
	self assert: A SNF = (É diagonalMatrix: #(1 1 3))! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/23/2020 09:34:55'!
testSmithNormalForm8
	| A |
	A _ É matrix: #((2 1 -3) (3 -2 -1) (1 -3 2)).
	self assert: A SNF = (É diagonalMatrix: #(1 7 0))! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/23/2020 09:34:55'!
testSmithNormalForm9
	| A |
	A _ É matrix: #((1 2 3 4 5 6 7) (1 0 1 0 1 0 1) (2 4 5 6 1 1 1) (1 4 2 5 2 0 0) (0 0 1 1 2 2 3)).
	self assert: A SNF = (É matrix: #((1 0 0 0 0 0 0) (0 1 0 0 0 0 0) (0 0 1 0 0 0 0) (0 0 0 1 0 0 0) (0 0 0 0 2 0 0)))! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/23/2020 09:34:55'!
testSmithNormalFormDiagonal
	| A |
	A _ É matrix: #((2 0 0) (0 1 0) (0 0 0)).
	self assert: A SNF = (É diagonalMatrix: #(1 2 0)).
	A _ É matrix: #((5 0 0) (0 2 0) (0 0 0)).
	self assert: A SNF = (É diagonalMatrix: #(1 10 0))! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/23/2020 09:33:01'!
testSmithNormalFormOverPolynomials
	"Example from Sage documentation."
	| R x A |
	R _ Ñ polynomials.
	x _ R x.
	A _ (R matrix: 2 scalar: x) - (R matrix: #((3 -4) (1 -1))).
	self assert: A SNF = (R diagonalMatrix: {R one. x^2 - (x*2) + 1})! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/23/2020 09:34:55'!
testSmithNormalFormOverPolynomialsOverPrimeField1
	"Example form Magma handbook (H88E7)."
	| K P x a |
	K _ É/5.
	P _ K polynomials.
	x _ P x.
	a _ P matrix: 5 evaluating: [:i :j| x^i + (x^j)].
	self assert: a elementaryDivisors = {x. x^3 + (x^2*3) + x}! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/23/2020 09:34:55'!
testSmithNormalFormOverPolynomialsOverPrimeField2
	"Example form Magma handbook (H88E7)."
	| K P x a ax |
	K _ É/5.
	P _ K polynomials.
	x _ P x.
	a _ É matrix: 5 coefficients: #(0 2 4 2 0 2 2 2 3 3 3 4 4 1 3 0 0 0 0 1 0 0 0 1 0).
	a _ a over: P.
	ax _ a identity * x - a.
	self assert: ax SNF = (P diagonalMatrix: {P one. P one. x - 1. x^2 - 1. x^2 - 1}).
	self assert: ax elementaryDivisors = {P one. P one. x - 1. x^2 - 1. x^2 - 1}! !

!MatrixTest methodsFor: 'invariants' stamp: 'len 5/23/2020 09:34:55'!
testCauchyDeterminantProductFormula
	| A B |
	A _ Ñ matrix: {(1,1,1). (3,5,7). (9,25,49)}.
	B _ Ñ matrix: {(1,0,4). (1,1,1). (2,-2,-3)}.
	self assert: A determinant * B determinant = (A * B) determinant.
	A _ É matrix: {(1,1,1). (3,5,7). (9,25,49)}.
	B _ É matrix: {(1,0,4). (1,1,1). (2,-2,-3)}.
	self assert: A determinant * B determinant = (A * B) determinant! !

!MatrixTest methodsFor: 'invariants' stamp: 'len 5/23/2020 09:33:01'!
testCharacteristicMatrixAndPolynomialOverQ
	| n A |
	n _ 5 atRandom.
	A _ Ñ atRandomMatrix: n bits: n*5.
	self assert: A characteristicPolynomial = A characteristicMatrix determinant! !

!MatrixTest methodsFor: 'invariants' stamp: 'len 5/23/2020 09:34:55'!
testCharacteristicMatrixAndPolynomialOverZ
	| n A |
	n _ 5 atRandom.
	A _ É atRandomMatrix: n bits: n*5.
	self assert: A characteristicPolynomial = A characteristicMatrix determinant! !

!MatrixTest methodsFor: 'invariants' stamp: 'len 5/23/2020 09:33:01'!
testCharacteristicPolynomial
	| A B |
	A _ Ñ atRandomMatrix: 5 bits: 100.
	self assert: (A characteristicPolynomial value: A) isZero.
	B _ Ñ atRandomMatrix: 5 bits: 100.
	self assert: (A*B) characteristicPolynomial = (B*A) characteristicPolynomial! !

!MatrixTest methodsFor: 'invariants' stamp: 'len 5/23/2020 09:34:55'!
testCharacteristicPolynomialExample1x1
	| A x |
	A _ É matrix: #((42)).
	x _ É polynomials x.
	self assert: A characteristicPolynomial = (x - 42)! !

!MatrixTest methodsFor: 'invariants' stamp: 'len 5/23/2020 09:34:55'!
testCharacteristicPolynomialExample2x2
	| A x |
	A _ É matrix: #((1 2) (3 4)).
	x _ É polynomials x.
	self assert: A characteristicPolynomial = (x^2 - (x*5) - 2)! !

!MatrixTest methodsFor: 'invariants' stamp: 'len 5/23/2020 09:34:55'!
testCharacteristicPolynomialExample3x3
	| A x |
	A _ É matrix: #((1 2 3) (4 5 6) (7 8 9)).
	x _ É polynomials x.
	self assert: A characteristicPolynomial = (x^3 - (x^2*15) - (x*18))! !

!MatrixTest methodsFor: 'invariants' stamp: 'len 5/23/2020 09:34:55'!
testCharacteristicPolynomialExample4x4
	| A x |
	A _ É matrix: #((1 2 3 4) (5 6 7 8) (9 10 11 12) (13 14 15 16)).
	x _ É polynomials x.
	self assert: A characteristicPolynomial = (x^4 - (x^3*34) - (x^2*80))! !

!MatrixTest methodsFor: 'invariants' stamp: 'len 3/9/2020 12:51:34'!
testCharacteristicPolynomialOver: R
	| n A p B |
	n _ 5 atRandom.
	A _ R atRandomMatrix: n bits: 100.
	p _ A characteristicPolynomial.
	self assert: (p value: A) isZero.
	self assert: p degree = n.
	self assert: p isMonic.
	self assert: A transposed characteristicPolynomial = p.
	B _ R atRandomMatrix: n bits: 100.
	self assert: (A*B) characteristicPolynomial = (B*A) characteristicPolynomial! !

!MatrixTest methodsFor: 'invariants' stamp: 'len 5/23/2020 09:34:55'!
testCharacteristicPolynomialOverIntegers
	^ self testCharacteristicPolynomialOver: É! !

!MatrixTest methodsFor: 'invariants' stamp: 'len 5/23/2020 09:34:55'!
testCharacteristicPolynomialOverModularIntegers
	^ self testCharacteristicPolynomialOver: É/(2 to: 256) atRandom! !

!MatrixTest methodsFor: 'invariants' stamp: 'len 5/23/2020 09:34:55'!
testCharacteristicPolynomialOverMultivariatePolynomials
	^ self testCharacteristicPolynomialOver: (É polynomialsIn: 3)! !

!MatrixTest methodsFor: 'invariants' stamp: 'len 5/23/2020 09:33:01'!
testCharacteristicPolynomialOverRationals
	^ self testCharacteristicPolynomialOver: Ñ! !

!MatrixTest methodsFor: 'invariants' stamp: 'len 5/23/2020 09:34:55'!
testCharacteristicPolynomialOverUnivariatePolynomials
	^ self testCharacteristicPolynomialOver: É polynomials! !

!MatrixTest methodsFor: 'invariants' stamp: 'len 5/23/2020 09:33:01'!
testDeterminant
	| m |
	m _ Ñ matrix: { (2,1). (-1,0) }.
	self assert: m determinant = 1! !

!MatrixTest methodsFor: 'invariants' stamp: 'len 5/23/2020 09:34:55'!
testDeterminant2
	| vandermonde |
	vandermonde _ Ñ matrix: {(1,1,1). (3,5,7). (9,25,49)}.
	self assert: vandermonde determinant = 16.
	vandermonde _ É matrix: {(1,1,1). (3,5,7). (9,25,49)}.
	self assert: vandermonde determinant = 16! !

!MatrixTest methodsFor: 'invariants' stamp: 'len 5/23/2020 09:33:01'!
testMinimalPolynomial
	| m f |
	m _ Ñ atRandomMatrix: 5 bits: 100.
	f _ m minimalPolynomial.
	self assert: f | m characteristicPolynomial.
	self assert: (f value: m) isZero! !

!MatrixTest methodsFor: 'invariants' stamp: 'len 5/23/2020 09:34:55'!
testPermanent
	"Example from https://en.wikipedia.org/wiki/Permanent_(mathematics)"
	| A |
	A _ É matrix: 4 coefficients: #(1 1 1 1 2 1 0 0 3 0 1 0 4 0 0 1).
	self assert: A permanent = 10! !

!MatrixTest methodsFor: 'invariants' stamp: 'len 5/23/2020 09:34:55'!
testRank
	| vandermonde |
	vandermonde _ Ñ matrix: {(1,1,1). (3,5,7). (9,25,49)}.
	self assert: vandermonde rank = 3.
	vandermonde _ É matrix: {(1,1,1). (3,5,7). (9,25,49)}.
	self assert: vandermonde rank = 3! !

!MatrixTest methodsFor: 'invariants' stamp: 'len 5/23/2020 09:34:55'!
testRank2
	| m |
	m _ Ñ matrix: {(1,1,1). (2,2,0). (3,3,1)}.
	self assert: m rank = 2.

	m _ É matrix: {(1,1,1). (2,2,2). (5,5,5)}.
	self assert: m rank = 1! !

!MatrixTest methodsFor: 'invariants' stamp: 'len 5/23/2020 09:33:01'!
testRankNullityTheorem
	| n A |
	n _ 6 atRandom.
	A _ self newRandomMatrix: n@n over: Ñ.
	self assert: A rank + A nullity = n! !

!MatrixTest methodsFor: 'invariants' stamp: 'len 5/23/2020 09:34:55'!
testRankOverPolynomialsOverZ5
	"Example form Magma handbook (H88E7)."
	| K P x a |
	K _ É/5.
	P _ K polynomials.
	x _ P x.
	a _ P matrix: 5 evaluating: [:i :j| x^i + (x^j)].
	self assert: a rank = 2! !

!MatrixTest methodsFor: 'other' stamp: 'len 11/11/2016 09:00'!
testAdjugate
	| A I |
	A _ Matrix rows: { (2,1,1). (-1,0,1). (0,2,1) }.
	I _ A identity.
	self assert: A * A adjugate = (I * A determinant)! !

!MatrixTest methodsFor: 'other' stamp: 'len 11/11/2016 09:00'!
testAdjugate2
	| A B |
	A _ Matrix rows: { (-3,2,-5). (-1,0,-2). (3,-4,1) }.
	B _ Matrix rows: { (-8,18,-4). (-5,12,-1). (4,-6,2) }.
	self assert: A adjugate = B! !

!MatrixTest methodsFor: 'other' stamp: 'len 5/23/2020 09:33:01'!
testAdjugateCramerRule
	| A I |
	A _ Ñ matrix: 3 evaluating: [:i :j| Ñ atRandomBits: 10].
	I _ A identity.
	self assert: A * A adjugate = (I * A determinant)! !

!MatrixTest methodsFor: 'other' stamp: 'len 5/23/2020 09:33:01'!
testAdjugateProperties
	| A B I c |
	A _ Ñ matrix: { (-3,2,-5). (-1,0,-2). (3,-4,1) }.
	B _ Ñ matrix: { (-1,2,3). (1,-2,1). (2,2,-1) }.
	c _ 7.
	I _ Ñ identityMatrix: 3.
	self assert: I adjugate = I.
	self assert: (A * B) adjugate = (B adjugate * A adjugate).
	self assert: (A*c) adjugate = (A adjugate * (c^2)).
	self assert: (A^5) adjugate = (A adjugate ^ 5).
	self assert: A transposed adjugate = A adjugate transposed! !

!MatrixTest methodsFor: 'other' stamp: 'len 5/23/2020 09:33:01'!
testCayleyHamiltorTheoremInQ
	| A |
	A _ Ñ atRandomMatrix: 6 atRandom bits: 100.
	self assert: (A characteristicPolynomial value: A) isZero! !

!MatrixTest methodsFor: 'other' stamp: 'len 5/23/2020 09:34:55'!
testCayleyHamiltorTheoremInZ
	| A |
	A _ É atRandomMatrix: 6 atRandom bits: 100.
	self assert: (A characteristicPolynomial value: A) isZero! !

!MatrixTest methodsFor: 'other' stamp: 'len 5/23/2020 09:34:55'!
testDomainError
	| A B |
	A _ É identityMatrix: 4.
	self should: [A / 2] raise: DomainError.
	B _ Ñ identityMatrix: 4.
	self should: [A + B] raise: DomainError.
	self should: [A * B] raise: DomainError! !

!MatrixTest methodsFor: 'other' stamp: 'len 5/23/2020 09:33:01'!
testFundamentalSubspacesDefinitions
	| m n A |
	m _ 6 atRandom.
	n _ 6 atRandom.
	A _ self newRandomMatrix: m@n over: Ñ.
"	self assert: A coimage = (Ñ^n span: A rows)." "definition"
"	self assert: A image = (Ñ^m span: A columns)." "definition"
	self assert: A coimage = A transposed image. "definition"
	self assert: A cokernel = A transposed kernel. "definition"! !

!MatrixTest methodsFor: 'other' stamp: 'len 5/23/2020 09:33:01'!
testFundamentalSubspacesDimensions
	| m n A r |
	m _ 6 atRandom.
	n _ 6 atRandom.
	A _ self newRandomMatrix: m@n over: Ñ.
	r _ A rank.
	self assert: A image rank = r.
	self assert: A kernel rank = (n - r).
	self assert: A nullity = (n - r). "definition"
	self assert: A coimage rank = r.
	self assert: A cokernel rank = (m - r)! !

!MatrixTest methodsFor: 'other' stamp: 'len 5/23/2020 09:33:01'!
testInverse
	| A I |
	A _ Ñ matrix: { (2,1,1). (-1,0,1). (0,2,1) }.
	I _ Ñ identityMatrix: 3.
	self assert: A inverse * A = I.
	self assert: A * A inverse = I! !

!MatrixTest methodsFor: 'other' stamp: 'len 5/23/2020 09:33:01'!
testInverse2
	| Qx x f A |
	Qx _ Ñ polynomials.
	x _ Qx x.
	f _ x^8 + (x^6) - (3*(x^4)) - (3*(x^3)) + (8*(x^2)) + (2*x) - 5.
	A _ f companion.
	self assert: (A * A inverse) isIdentity! !

!MatrixTest methodsFor: 'other' stamp: 'len 5/23/2020 09:33:01'!
testKernelImageTheorem
	| n A |
	n _ 6 atRandom.
	A _ self newRandomMatrix: n@n over: Ñ.
	self assert: A kernel rank + A image rank = n! !

!MatrixTest methodsFor: 'other' stamp: 'len 5/23/2020 09:34:55'!
testKroneckerProduct
	| A B C |
	A _ É matrix: #((1 2) (3 4)).
	B _ É matrix: #((0 5) (6 7)).
	C _ É matrix: #((0 5 0 10) (6 7 12 14) (0 15 0 20) (18 21 24 28)).
	self assert: A ë B = C! !

!MatrixTest methodsFor: 'other' stamp: 'len 5/23/2020 09:33:01'!
testLeftInverse
	| A |
	[A _ Ñ atRandomMatrix: 5@3 bits: 1000. A rank = 3] whileFalse.
	self assert: (A retraction * A) isIdentity! !

!MatrixTest methodsFor: 'other' stamp: 'len 5/23/2020 09:34:55'!
testLeftRightIdentity
	| A |
	A _ É atRandomMatrix: 5 atRandom @ 5 atRandom bits: 100.
	self assert: A leftIdentity * A = A.
	self assert: A * A rightIdentity = A! !

!MatrixTest methodsFor: 'other' stamp: 'len 5/23/2020 09:34:55'!
testMinor
	| A |
	A _ É matrix: #((1 2 3) (4 5 6) (7 8 9)).
	self assert: (A minor: 2@3) = -6! !

!MatrixTest methodsFor: 'other' stamp: 'len 5/23/2020 09:34:55'!
testMinors
	| A |
	A _ É matrix: 2@3 coefficients: (1 to: 6).
	self assert: (A minors: 2) asArray = #(-3 -6 -3)! !

!MatrixTest methodsFor: 'other' stamp: 'len 5/23/2020 09:33:01'!
testQRDecomposition
	| n A QR Q R |
	n _ 3.
	[A _ Ñ atRandomMatrix: n bits: n*n. A isFullRank] whileFalse.
	A _ A over: Ö.
	QR _ A QR.
	Q _ QR first.
	R _ QR second.
	self assert: Q * R = A.
	self assert: Q isOrthogonal.
	self assert: R isUpperTriangular! !

!MatrixTest methodsFor: 'other' stamp: 'len 5/23/2020 09:31:27'!
testQRDecomposition2
	"Example from wikipedia:"
	| A Q R |
	A _ Ö matrix: 3@3 coefficients: #(12 -51 4 6 167 -68 -4 24 -41).
	Q _ Ö matrix: 3@3 coefficients: {6/7. -69/175. -58/175. 3/7. 158/175. 6/175. -2/7. 6/35. -33/35}.
	R _ Ö matrix: 3@3 coefficients: #(14 21 -14 0 175 -70 0 0 35).
	self assert: A QR = {Q. R}! !

!MatrixTest methodsFor: 'other' stamp: 'len 5/23/2020 09:33:01'!
testRightInverse
	| A |
	[A _ Ñ atRandomMatrix: 3@5 bits: 1000. A rank = 3] whileFalse.
	self assert: (A * A section) isIdentity! !

!MatrixTest methodsFor: 'other' stamp: 'len 5/23/2020 09:33:01'!
testSimilarity
	"Examples from wikipedia article on SNF"
	| A B C |
	A _ Ñ matrix: {(1,2). (0,1)}.
	B _ Ñ matrix: {(3,-4). (1,-1)}.
	C _ Ñ matrix: {(1,0). (1,2)}.
	self assert: A ~ B.
	self deny: A ~ C! !

!MatrixTest methodsFor: 'other' stamp: 'len 5/23/2020 09:33:01'!
testSimilarity2
	| n A B P |
	n _ 5 atRandom.
	A _ Ñ atRandomMatrix: n bits: 10*n*n.
	[(P _ Ñ atRandomMatrix: n bits: 10*n*n) isSingular] whileTrue.
	B _ Ñ atRandomMatrix: n bits: 10*n*n.
	self assert: A ~ (P inverse * A * P).
	self deny: A ~ B! !

!MatrixTest methodsFor: 'other' stamp: 'len 5/23/2020 09:34:55'!
testTransposed
	| A |
	A _ É atRandomMatrix: 6 atRandom @ 6 atRandom bits: 1000.
	self assert: A columns = A transposed rows.
	self assert: A transposed transposed = A! !

!MatrixTest methodsFor: 'solving' stamp: 'len 5/23/2020 09:33:01'!
testBacklash
	"Example from Sage documentation. Non-singular and square."
	| A B X |
	A _ Ñ matrix: 3 coefficients: #(1 2 4 5 3 1 1 2 -1).
	B _ Ñ matrix: 3@2 coefficients: #(1 5 1 2 1 5).
	X _ A \ B.
	self assert: X = (Ñ matrix: 3@2 coefficients: {-1/7. -11/7. 4/7. 23/7. 0. 0}).
	self assert: A * X = B! !

!MatrixTest methodsFor: 'solving' stamp: 'len 4/21/2020 21:21:51'!
testBacklashGaloisFieldMatrixRandom
	self testBacklashMatrixRandomOver: (GaloisField new: 5 atRandom nextPrime to: 3 atRandom)! !

!MatrixTest methodsFor: 'solving' stamp: 'len 5/23/2020 09:34:55'!
testBacklashIntegerMatrixRandom
	self testBacklashMatrixRandomOver: É! !

!MatrixTest methodsFor: 'solving' stamp: 'len 5/23/2020 09:34:55'!
testBacklashIntegerTuple
	"Example from Sage documentation."
	| A v x |
	A _ É matrix: 2@3 coefficients: #(1 2 3 2 4 6).
	v _ É tuple: #(-1 -2).
	x _ A \ v.
"	self assert: x = (É tuple: #(-1 0 0))."
	self assert: A * x = v! !

!MatrixTest methodsFor: 'solving' stamp: 'len 5/23/2020 09:34:55'!
testBacklashIntegerTuple2
	"Example from GAP manual."
	| A b |
	A _ É matrix: #((1 2 7) (4 5 6) (7 8 9) (10 11 19) (5 7 12)).
	A _ A transposed.
	b _ É tuple: #(95 115 182).
"	x _ É tuple: #(2285 -5854 4888 -1299 0)." "<- GAP comes up with this solution, but this is not very small"
	self assert: A * (A \ b) = b! !

!MatrixTest methodsFor: 'solving' stamp: 'len 5/23/2020 09:34:55'!
testBacklashIntegerTuple3
	| A b |
	A _ É matrix: #((-8 1 -7 -9 -2 -1) (5 -2 3 -3 1 1) (7 0 6 4 -5 -8) (-7 -10 5 9 -4 4) (3 -4 1 -2 3 -8) (-7 3 2 6 7 -1) (4 8 5 1 -8 -9) (9 5 0 -10 -8 8) (-6 2 -6 -9 -5 6)).
	A _ A transposed.
	b _ É tuple: #(3 -1 -1 -7 9 8).
	"x _ É tuple: #(38 25 -6 1 -34 -12 3 -3 -44)." "shortest solution"
	self assert: A * (A \ b) = b! !

!MatrixTest methodsFor: 'solving' stamp: 'len 5/23/2020 09:34:55'!
testBacklashIntegerTupleBug
	| A b x |
	A _ É matrix: 3@3 coefficients: #(1 0 0 0 1 0 0 0 10).
	b _ É tuple: #(0 0 10).
	x _ A \ b.
	self assert: A * x = b! !

!MatrixTest methodsFor: 'solving' stamp: 'len 5/23/2020 09:34:55'!
testBacklashIntegerTupleRandom
	self testBacklashTupleRandomOver: É! !

!MatrixTest methodsFor: 'solving' stamp: 'len 3/9/2020 19:17:52'!
testBacklashMatrixRandomOver: R
	| n m n2 A v b x |
	100 timesRepeat:
		[n _ 5 atRandom.
		m _ 5 atRandom.
		A _ R atRandomMatrix: m@n bits: m*n*5.
		n2 _ 5 atRandom.
		v _ R atRandomMatrix: n@n2 bits: n*n2*5.
		b _ A*v.
		x _ A \ b.
		self assert: A*x = b]! !

!MatrixTest methodsFor: 'solving' stamp: 'len 5/23/2020 09:33:01'!
testBacklashNoSolution
	"Example from Sage documentation."
	| A v |
	A _ Ñ matrix: 2@3 coefficients: #(1 2 3 2 4 6).
	v _ Ñ tuple: #(1 1).
	self assert: (A \ v) isNil! !

!MatrixTest methodsFor: 'solving' stamp: 'len 5/23/2020 09:33:01'!
testBacklashNonSquare
	"Example from Sage documentation."
	| A B X |
	A _ Ñ matrix: 2@4 coefficients: #(0 -1 1 0 -2 2 1 0).
	B _ Ñ matrix: 2@2 coefficients: #(1 0 1 -1).
	X _ A \ B.
	self assert: X = (Ñ matrix: 4@2 coefficients: {-3/2. 1/2. -1. 0. 0. 0. 0. 0}).
	self assert: A * X = B! !

!MatrixTest methodsFor: 'solving' stamp: 'len 5/23/2020 09:33:01'!
testBacklashNonSquare2
	| A B X |
	A _ Ñ matrix: 2@4 coefficients: #(0 0 -1 1 0 -2 2 1).
	B _ Ñ matrix: 2@2 coefficients: #(1 0 1 -1).
	X _ A \ B.
	self assert: A * X = B! !

!MatrixTest methodsFor: 'solving' stamp: 'len 5/23/2020 09:34:55'!
testBacklashPascal3
	"Example from Matlab documentation. Non-singular and square."
	| A u x |
	A _ É matrix: 3 coefficients: #(1 1 1 1 2 3 1 3 6). "pascal(3)"
	u _ É tuple: #(3 1 4).
	x _ A \ u.
	self assert: x = (É tuple: #(10 -12 5)).
	self assert: A * x = u! !

!MatrixTest methodsFor: 'solving' stamp: 'len 5/23/2020 09:34:55'!
testBacklashPascal3Magic3
	"Example from Matlab documentation. Non-singular and square."
	| A B X |
	A _ É matrix: 3 coefficients: #(1 1 1 1 2 3 1 3 6). "pascal(3)"
	B _ É matrix: 3 coefficients: #(8 1 6 3 5 7 4 9 2). "magic(3)"
	X _ A \ B.
	self assert: X = (É matrix: 3 coefficients: #(19 -3 -1 -17 4 13 6 0 -6)).
	self assert: A * X = B! !

!MatrixTest methodsFor: 'solving' stamp: 'len 5/23/2020 09:33:01'!
testBacklashPolynomialMatrixRandom
	self testBacklashMatrixRandomOver: Ñ polynomials! !

!MatrixTest methodsFor: 'solving' stamp: 'len 5/23/2020 09:33:01'!
testBacklashPolynomialTupleRandom
	self testBacklashTupleRandomOver: Ñ polynomials! !

!MatrixTest methodsFor: 'solving' stamp: 'len 5/23/2020 09:34:55'!
testBacklashPrimeFieldMatrixRandom
	self testBacklashMatrixRandomOver: É/256 atRandom nextPrime! !

!MatrixTest methodsFor: 'solving' stamp: 'len 5/23/2020 09:34:55'!
testBacklashPrimeFieldTupleRandom
	self testBacklashTupleRandomOver: É/256 atRandom nextPrime! !

!MatrixTest methodsFor: 'solving' stamp: 'len 4/21/2020 21:20:40'!
testBacklashPrimePowerRingMatrixRandom
	self testBacklashMatrixRandomOver: (PrimePowerRing new: 10 atRandom nextPrime to: 3 atRandom) ! !

!MatrixTest methodsFor: 'solving' stamp: 'len 5/23/2020 09:34:55'!
testBacklashProductRingMatrixRandom
	self testBacklashMatrixRandomOver: É ◊ (É/(64 atRandom + 1))! !

!MatrixTest methodsFor: 'solving' stamp: 'len 5/23/2020 09:33:01'!
testBacklashRationalMatrixRandom
	self testBacklashMatrixRandomOver: Ñ! !

!MatrixTest methodsFor: 'solving' stamp: 'len 5/23/2020 09:33:01'!
testBacklashRationalTuple
	"Example from Sage documentation."
	| A v x |
	A _ Ñ matrix: 3 coefficients: #(1 2 3 -1 2 5 2 3 1).
	v _ Ñ tuple: #(1 2 3).
	x _ A \ v.
	self assert: x = (-13/12, (23/12), (-7/12)).
	self assert: A * x = v! !

!MatrixTest methodsFor: 'solving' stamp: 'len 5/23/2020 09:33:01'!
testBacklashRationalTuple2
	"Example from GAP manual."
	| A b x |
	A _ Ñ matrix: #((1 2 7) (4 5 6) (7 8 9) (10 11 19) (5 7 12)).
	b _ Ñ tuple: #(95 115 182).
	x _ Ñ tuple: {47/4. -17/2. 67/4. 0. 0}.
	self assert: A transposed \ b = x! !

!MatrixTest methodsFor: 'solving' stamp: 'len 5/23/2020 09:33:01'!
testBacklashRationalTupleRandom
	self testBacklashTupleRandomOver: Ñ! !

!MatrixTest methodsFor: 'solving' stamp: 'len 5/23/2020 09:33:01'!
testBacklashSingular
	"Example from Sage documentation."
	| A B X |
	A _ Ñ matrix: 2@3 coefficients: #(1 2 3 2 4 6).
	B _ Ñ matrix: 2@2 coefficients: #(6 -6 12 -12).
	X _ A \ B.
	self assert: X = (Ñ matrix: 3@2 coefficients: (6, -6, 0, 0, 0, 0)).
	self assert: A * X = B! !

!MatrixTest methodsFor: 'solving' stamp: 'len 5/23/2020 09:33:01'!
testBacklashTupleNonSquare
	"Example from Sage documentation."
	| A v x |
	A _ Ñ matrix: 2@3 coefficients: #(1 2 3 2 4 6).
	v _ (-1/2, -1).
	x _ (-1/2, 0, 0).
	self assert: A \ v = x! !

!MatrixTest methodsFor: 'solving' stamp: 'len 3/9/2020 19:18:49'!
testBacklashTupleRandomOver: R
	| n m A v b x |
	100 timesRepeat:
		[n _ 5 atRandom.
		m _ 5 atRandom.
		A _ R atRandomMatrix: m@n bits: m*n*5.
		v _ R atRandomTuple: n bits: n*5.
		b _ A*v.
		x _ A \ b.
		self assert: A*x = b]! !

!MatrixTest methodsFor: 'solving' stamp: 'len 5/23/2020 09:34:55'!
testBacklashZnMatrixRandom
	self testBacklashMatrixRandomOver: É/(64 atRandom + 1)! !

!MatrixTest methodsFor: 'solving' stamp: 'len 5/23/2020 09:33:01'!
testCokernelMatrix
	"From Sage."
	| A B |
	A _ Ñ matrix: {(1,2,4,-7,4). (1,1,0,2,-1). (1,0,3,-3,1). (0,-1,-1,3,-2). (0,0,-1,2,-1)}.
	B _ Ñ matrix: {(1,0,-1,2,-1). (0,1,-1,1,-4)}.
	self assert: A cokernel echelon = B "we have to perform an addition echelonization"! !

!MatrixTest methodsFor: 'solving' stamp: 'len 5/23/2020 09:34:55'!
testCokernelMatrixInteger
	"From Sage."
	| A B |
	A _ É matrix: {(1,2,4,-7,4). (1,1,0,2,-1). (1,0,3,-3,1). (0,-1,-1,3,-2). (0,0,-1,2,-1)}.
	B _ É matrix: {(1,0,-1,2,-1). (0,1,-1,1,-4)}.
	self assert: A cokernel echelon = B "we have to perform an additional echelonization"! !

!MatrixTest methodsFor: 'solving' stamp: 'len 5/23/2020 09:33:01'!
testKernel
	| A K |
	A _ Ñ matrix: {(1, 0, -3, 0, 2, -8). (0, 1, 5, 0, -1, 4). (0, 0, 0, 1, 7, -9). (0, 0, 0, 0, 0, 0)}.
	K _ Ñ matrix: {(3,-5,1,0,0,0). (-2,1,0,-7,1,0). (8,-4,0,9,0,1)}.
	self assert: A kernel = K! !

!MatrixTest methodsFor: 'solving' stamp: 'len 5/23/2020 09:34:55'!
testKernelInteger
	"Example from GAP manual."
	| A K |
	A _ É matrix: #((1 2 7) (4 5 6) (7 8 9) (10 11 19) (5 7 12)).
	A _ A transposed.
	K _ É matrix: #((1 18 -9 2 -6) (0 24 -13 3 -7)).
	self assert: A kernel echelon = K "we have to perform an addition echelonization"! !

!MatrixTest methodsFor: 'solving' stamp: 'len 5/23/2020 09:33:01'!
testKernelRational
	"Example from GAP manual."
	| A K |
	A _ Ñ matrix: #((1 2 7) (4 5 6) (7 8 9) (10 11 19) (5 7 12)).
	A _ A transposed.
	K _ Ñ matrix: {{-7/4. 9/2. -15/4. 1. 0}. {-3/4. -3/2. 1/4. 0. 1}}.
	self assert: A kernel = K! !

!MatrixTest methodsFor: 'solving' stamp: 'len 5/23/2020 09:33:01'!
testSlashWithMatrix
	| A B X  |
	A _ Ñ matrix: 3 coefficients: #(1 1 3 2 0 4 -1 6 -1).
	B _ Ñ matrix: 1@3 coefficients: #(2 19 8).
	X _ B / A.
	self assert: X = (Ñ matrix: 1@3 coefficients: #(1 2 3)).
	self assert: X * A = B! !

!MatrixTest methodsFor: 'solving' stamp: 'len 5/23/2020 09:33:01'!
testSlashWithTuple
	| A b x  |
	A _ Ñ matrix: 3 coefficients: #(1 1 3 2 0 4 -1 6 -1).
	b _ Ñ tuple: #(2 19 8).
	x _ b / A.
	self assert: x = (Ñ tuple: #(1 2 3)).
	self assert: x * A = b! !

!MatrixTest methodsFor: 'private' stamp: 'len 3/9/2020 12:21:09'!
newRandomMatrix: shape over: aRing
	| samples |
	2 atRandom = 1 ifTrue: [^ aRing atRandomMatrix: shape bits: 100].
	samples _ {aRing zero. aRing one. aRing one negated}.
	^ aRing matrix: shape evaluating: [:i :j| 2 atRandom > 1 ifTrue: [aRing zero] ifFalse: [samples atRandom]]! !

!ModuleTest methodsFor: 'bugs' stamp: 'len 5/23/2020 09:34:55'!
testHomRelationsBug
	| V |
	V _ É^1 / {5}.
	self assert: V dual invariants = #(5)! !

!ModuleTest methodsFor: 'bugs' stamp: 'len 5/23/2020 09:34:55'!
testHomRelationsBug2
	| V W X |
	V _ É^2 / {(2,0)}.
	W _ É^3 / {(2,2,2)}.
	X _ V => W.
	self assert: (X !! (X relations atRandomBits: 100) coordinates) isZero! !

!ModuleTest methodsFor: 'bugs' stamp: 'len 5/23/2020 09:34:55'!
testHomRelationsBug3
	| V W |
	V _ É^1 / {2}.
	W _ É^(5 atRandom).
	self assert: (V => W) isTrivial! !

!ModuleTest methodsFor: 'bugs' stamp: 'len 5/23/2020 09:34:55'!
testModuleMapBug
	| M f |
	M _ É^1 / {2}.
	f _ M dual atRandomBits: 100.
	self testLinearMap: f! !

!ModuleTest methodsFor: 'bugs' stamp: 'len 4/21/2020 05:55:42'!
testPIDCoordinatesOfBug
	| M S |
	M _ self newFreeModuleOver: self newScalarsPID.
	S _ M grassmannian: (1 to: M rank) atRandom :: atRandomBits: 50.
	self assert: (S generators allSatisfy: [:each| (S coordinatesOf: each) notNil])! !

!ModuleTest methodsFor: 'isomorphisms' stamp: 'len 8/17/2019 16:39:14'!
testFirstIsomorphismTheorem: f
	self assert: f codomain >= f image.
	self assert: f domain >= f kernel.
	self assert: f domain / f kernel ~ f image! !

!ModuleTest methodsFor: 'isomorphisms' stamp: 'len 8/17/2019 16:41:10'!
testFirstIsomorphismTheoremOver: aRing
	| M N f |
	M _ self newFreeModuleOver: aRing.
	N _ self newFreeModuleOver: aRing.
	f _ M => N atRandomBits: 100.
	self testFirstIsomorphismTheorem: f
! !

!ModuleTest methodsFor: 'isomorphisms' stamp: 'len 8/17/2019 16:41:54'!
testFirstIsomorphismTheoremOverCyclotomicField
	self testFirstIsomorphismTheoremOver: (CyclotomicField new: 7)! !

!ModuleTest methodsFor: 'isomorphisms' stamp: 'len 8/17/2019 16:42:05'!
testFirstIsomorphismTheoremOverGaloisField
	self testFirstIsomorphismTheoremOver: (GaloisField new: 10 atRandom nextPrime to: 3 atRandom + 1)! !

!ModuleTest methodsFor: 'isomorphisms' stamp: 'len 5/23/2020 09:33:01'!
testFirstIsomorphismTheoremOverPolynomials
	self testFirstIsomorphismTheoremOver: Ñ polynomials! !

!ModuleTest methodsFor: 'isomorphisms' stamp: 'len 5/23/2020 09:33:01'!
testFirstIsomorphismTheoremOverQ
	self testFirstIsomorphismTheoremOver: Ñ! !

!ModuleTest methodsFor: 'isomorphisms' stamp: 'len 8/17/2019 16:42:25'!
testFirstIsomorphismTheoremOverQuadraticField
	self testFirstIsomorphismTheoremOver: (QuadraticField sqrt: -5)! !

!ModuleTest methodsFor: 'isomorphisms' stamp: 'len 5/23/2020 09:34:55'!
testFirstIsomorphismTheoremOverZ
	self testFirstIsomorphismTheoremOver: É! !

!ModuleTest methodsFor: 'isomorphisms' stamp: 'len 8/17/2019 17:20:25'!
testSecondIsomorphismTheorem: M
	| S T |
	S _ M grassmannian: (0 to: M rank) atRandom :: atRandomBits: 50.
	T _ M grassmannian: (0 to: M rank) atRandom :: atRandomBits: 50.
	self assert: S+T <= M.
	self assert: S /\ T <= M.
	self assert: (S+T)/T ~ (S/(S /\ T))! !

!ModuleTest methodsFor: 'isomorphisms' stamp: 'len 5/2/2018 17:43:35'!
testSecondIsomorphismTheoremOverCyclotomicField
	self testSecondIsomorphismTheorem: (CyclotomicField new: 7) ^ 5! !

!ModuleTest methodsFor: 'isomorphisms' stamp: 'len 5/2/2018 17:43:03'!
testSecondIsomorphismTheoremOverGaloisField
	self testSecondIsomorphismTheorem: (GaloisField new: 10 atRandom nextPrime to: 3 atRandom + 1) ^ 5! !

!ModuleTest methodsFor: 'isomorphisms' stamp: 'len 5/23/2020 09:33:01'!
testSecondIsomorphismTheoremOverPolynomials
	self testSecondIsomorphismTheorem: Ñ polynomials ^ 2! !

!ModuleTest methodsFor: 'isomorphisms' stamp: 'len 5/23/2020 09:33:01'!
testSecondIsomorphismTheoremOverQ
	self testSecondIsomorphismTheorem: Ñ ^ 5! !

!ModuleTest methodsFor: 'isomorphisms' stamp: 'len 5/2/2018 17:42:41'!
testSecondIsomorphismTheoremOverQuadraticField
	self testSecondIsomorphismTheorem: (QuadraticField sqrt: -5) ^ 5! !

!ModuleTest methodsFor: 'isomorphisms' stamp: 'len 5/23/2020 09:34:55'!
testSecondIsomorphismTheoremOverZ
	self testSecondIsomorphismTheorem: É^3! !

!ModuleTest methodsFor: 'isomorphisms' stamp: 'len 5/2/2018 17:33:15'!
testThirdIsomorphismTheorem: M
	| S T |
	S _ M grassmannian: (0 to: M rank) atRandom :: atRandomBits: 50.
	T _ S grassmannian: (0 to: S rank) atRandom :: atRandomBits: 50.
	self assert: S/T <= (M/T).
	self assert: (M/T)/(S/T) ~ (M/S)! !

!ModuleTest methodsFor: 'isomorphisms' stamp: 'len 5/2/2018 17:43:44'!
testThirdIsomorphismTheoremOverCyclotomicField
	self testThirdIsomorphismTheorem: (CyclotomicField new: 7) ^ 5! !

!ModuleTest methodsFor: 'isomorphisms' stamp: 'len 5/2/2018 17:43:16'!
testThirdIsomorphismTheoremOverGaloisField
	self testThirdIsomorphismTheorem: (GaloisField new: 10 atRandom nextPrime to: 3 atRandom + 1) ^ 5! !

!ModuleTest methodsFor: 'isomorphisms' stamp: 'len 5/23/2020 09:33:01'!
testThirdIsomorphismTheoremOverPolynomials
	self testThirdIsomorphismTheorem: Ñ polynomials ^ 2! !

!ModuleTest methodsFor: 'isomorphisms' stamp: 'len 5/23/2020 09:33:01'!
testThirdIsomorphismTheoremOverQ
	self testThirdIsomorphismTheorem: Ñ ^ 5! !

!ModuleTest methodsFor: 'isomorphisms' stamp: 'len 5/2/2018 17:42:52'!
testThirdIsomorphismTheoremOverQuadraticField
	self testThirdIsomorphismTheorem: (QuadraticField sqrt: -5) ^ 5! !

!ModuleTest methodsFor: 'isomorphisms' stamp: 'len 5/23/2020 09:34:55'!
testThirdIsomorphismTheoremOverZ
	self testThirdIsomorphismTheorem: É^3! !

!ModuleTest methodsFor: 'maps' stamp: 'len 5/23/2020 09:33:01'!
testAdjoint
	| V W f fAdjoint phi |
	V _ self newFreeModuleOver: Ñ.
	W _ self newFreeModuleOver: Ñ.
	f _ V => W atRandomBits: 50.
	fAdjoint _ f adjoint.
	self assert: fAdjoint domain = f codomain dual.
	self assert: fAdjoint codomain = f domain dual.
	phi _ W dual atRandomBits: 20.
	self assert: (fAdjoint value: phi) = (phi ∑ f)! !

!ModuleTest methodsFor: 'maps' stamp: 'len 5/23/2020 09:33:01'!
testAdjointAndHomFunctor
	"Given a R-linear map f, applying the Hom(-, R) produces the adjoint (the dual map).
	Example from 'A Singular Introduction To Commutative Algebra, pp. 115, procedure kontraHom."
	| f |
	f _ Ñ^3 => (Ñ^4) :: atRandomBits: 100.
	self assert: (f => Ñ asScalarModule) = f adjoint! !

!ModuleTest methodsFor: 'maps' stamp: 'len 5/17/2020 07:34:53'!
testCoequalizer
	| A B f g coeq |
	A _ self newFreeModule.
	B _ self newFreeModuleOver: A scalars.
	f _ (A => B) atRandomBits: 50 atRandom.
	g _ (A => B) atRandomBits: 50 atRandom.
	coeq _ f coequalizer: g.
	self assert: (f -> coeq) notNil.
	self assert: f -> coeq = (g -> coeq)! !

!ModuleTest methodsFor: 'maps' stamp: 'len 5/23/2020 09:33:01'!
testColift
	| M X A i Y f g |
	M _ Ñ^3.
	X _ Ñ^4.
	A _ (X => M atRandomBits: 20) kernel.
	i _ A >-> X.
	Y _ Ñ^5.
	f _ A => Y atRandomBits: 20.
	g _ f / i.
	self assert: (X => Y includes: g).
	self assert: i -> g = f

"	| M N phi cokernel L eta eta0 |
	M _ Ñ^3.
	N _ Ñ^4.
	phi _ (M => N) atRandomBits: 20.
	cokernel _ phi cokernel.
	L _ Ñ^5.
	eta _ N to: L evaluating: [:x| L atRandomBits: 20]. ???
	self assert: (phi -> eta) isZero.
	eta0 _ eta / (M ->> cokernel).
	self assert: (cokernel => L includes: eta0).
	self assert: M ->> cokernel -> eta0 = eta"! !

!ModuleTest methodsFor: 'maps' stamp: 'len 5/23/2020 09:33:01'!
testComposition
	| X Y Z f g x |
	X _ Ñ ^ 3.
	Y _ Ñ ^ 5.
	Z _ Ñ ^ 4.
	f _ X => Y atRandomBits: 1000.
	g _ Y => Z atRandomBits: 1000.
	x _ X atRandomBits: 1000.
	self assert: (X => Z includes: g ∑ f).
	self assert: (g ∑ f value: x) = (g value: (f value: x)).
	self should: [f ∑ g] raise: DomainError! !

!ModuleTest methodsFor: 'maps' stamp: 'len 5/23/2020 09:33:01'!
testCompositionError
	| X Y Z f g |
	X _ Ñ ^ 3.
	Y _ Ñ ^ 5.
	Z _ Ñ ^ 4.
	f _ X => Y atRandomBits: 1000.
	g _ Y => Z atRandomBits: 1000.
	self should: [f ∑ g] raise: DomainError! !

!ModuleTest methodsFor: 'maps' stamp: 'len 4/18/2020 15:31:09'!
testEqualizer
	| A B f g eq |
	A _ self newFreeModule.
	B _ self newFreeModuleOver: A scalars.
	f _ (A => B) atRandomBits: 100 atRandom.
	g _ (A => B) atRandomBits: 100 atRandom.
	eq _ f equalizer: g.
	self assert: (eq -> f) notNil.
	self assert: eq -> f = (eq -> g)! !

!ModuleTest methodsFor: 'maps' stamp: 'len 4/19/2020 08:01:52'!
testImage
	| f image v w |
	f _ self newLinearMap.
	image _ f image.
	v _ f domain atRandomBits: 100.
	w _ f value: v.
	self assert: (image includes: w)! !

!ModuleTest methodsFor: 'maps' stamp: 'len 5/23/2020 09:33:01'!
testInverse
	| V f |
	V _ Ñ ^ 3.
	f _ V automorphisms atRandomBits: 1000.
	self assert: (f ∑ f inverse) isIdentity.
	self assert: (f inverse ∑ f) isIdentity! !

!ModuleTest methodsFor: 'maps' stamp: 'len 4/19/2020 08:03:08'!
testKernel
	| f kernel v |
	f _ self newLinearMap.
	kernel _ f kernel.
	v _ kernel atRandomBits: 100.
	self assert: (f value: v) isZero! !

!ModuleTest methodsFor: 'maps' stamp: 'len 4/19/2020 08:03:17'!
testKernelZ2
	| V f kernel |
	V _ (PrimeField new: 2) ^ 3.
	f _ V dual evaluating: [:v| v coordinates sum].
	kernel _ f kernel.
	self assert: (kernel apply: f) isTrivial.
	self assert: kernel rank = 2.
	self assert: (kernel includes: V !! (0,1,1))! !

!ModuleTest methodsFor: 'maps' stamp: 'len 5/23/2020 09:33:01'!
testLift
	| M X B Y p f g |
	M _ Ñ^3.
	X _ Ñ^4.
	B _ (M => X atRandomBits: 20) cokernel.
	p _ X ->> B.
	Y _ Ñ^5.
	f _ Y => B atRandomBits: 20.
	g _ p \ f.
	self assert: (Y => X includes: g).
	self assert: g -> p = f

"	| M N phi kernel L tau tau0 |
	M _ Ñ^3.
	N _ Ñ^4.
	phi _ (M => N) atRandomBits: 20.
	kernel _ phi kernel.
	L _ Ñ^5.
	tau _ L to: M evaluating: [:x| kernel atRandomBits: 20].
	self assert: (tau -> phi) isZero.
	tau0 _ kernel >-> M \ tau.
	self assert: (L => kernel includes: tau0).
	self assert: tau0 -> (kernel >-> M) = tau"! !

!ModuleTest methodsFor: 'maps' stamp: 'len 5/23/2020 09:33:01'!
testLinearForm1
	| V f |
	V _ Ñ ^ 3.
	f _ V dual evaluating: [:v| v x + v y - v z].
	self assert: (f value: (1,1,1)) = 1.
	self assert: (f value: (2,2,1)) = 3.
	self assert: (f value: (3,1, -1)) = 5! !

!ModuleTest methodsFor: 'maps' stamp: 'len 5/23/2020 09:33:01'!
testLinearForm2
	| V f |
	V _ Ñ ^ 3.
	f _ V dual evaluating: [:v| v x + v y - v z].
	self assert: f domain = V.
	self assert: f kernel rank = 2.
	self assert: f image rank = 1! !

!ModuleTest methodsFor: 'maps' stamp: 'len 5/23/2020 09:33:01'!
testLinearFormAsPolynomial
	| V f x |
	V _ Ñ ^ 5 atRandom.
	f _ V dual atRandomBits: 100.
	x _ V atRandomBits: 100.
	self assert: (f value: x) = (f asPolynomial value: x coordinates).
	self assert: f parent !! f asPolynomial = f! !

!ModuleTest methodsFor: 'maps' stamp: 'len 3/14/2020 19:13:38'!
testLinearFormZ2
	| V f |
	V _ (PrimeField new: 2) ^ 4.
	f _ V dual evaluating: [:v| v coordinates sum].
	self assert: f domain = V.
	self assert: f kernel rank = 3.
	self assert: f image rank = 1.
	self assert: (f kernel includes: V !! (1,1,1,1))! !

!ModuleTest methodsFor: 'maps' stamp: 'len 3/2/2017 04:46:35'!
testLinearMap
	| f |
	f _ self newLinearMap.
	self testLinearMap: f! !

!ModuleTest methodsFor: 'maps' stamp: 'len 10/16/2016 09:17'!
testLinearMap: f
	| a1 a2 b1 b2 x |
	a1 _ f domain atRandomBits: 20.
	a2 _ f domain atRandomBits: 20.
	b1 _ f value: a1.
	b2 _ f value: a2.
	self assert: (f value: f domain zero) isZero.
	x _ f domain scalars atRandomBits: 20.
	self assert: (f value: a1 * x + a2) = (b1 * x + b2)! !

!ModuleTest methodsFor: 'maps' stamp: 'len 11/2/2016 04:01'!
testLinearMapZ2
	| V f kernel v |
	V _ (PrimeField new: 2) ^ (5 atRandom + 1).
	[f _ V endomorphisms atRandom.
	(kernel _ f kernel) isTrivial or: [kernel = V]] whileTrue. "find one with non-trivial kernel"
	[v _ V atRandom. kernel includes: v] whileTrue.
	self assert: (f value: v) isZero not.
	v _ kernel atRandom.
	self assert: (f value: v) isZero! !

!ModuleTest methodsFor: 'maps' stamp: 'len 5/23/2020 09:34:55'!
testMapDirectSumAndTensorProductBug
	| V W f g |
	V _ É^3.
	W _ É^2.
	f _ V endomorphisms atRandomBits: 100.
	g _ W endomorphisms atRandomBits: 100.
	"doing it twice should give the same thing:"
	self assert: (fëg) domain = (fëg) domain.
	self assert: (fêg) domain = (fêg) domain! !

!ModuleTest methodsFor: 'maps' stamp: 'len 5/23/2020 09:33:01'!
testMapToBiggerDimensionIsNotSurjective
	| V W f |
	 V _ Ñ^4 atRandom.
	W _ Ñ^(V rank atRandom - 1).
	f _ (W => V) atRandomBits: 100.
	self assert: f isSurjective not! !

!ModuleTest methodsFor: 'maps' stamp: 'len 5/23/2020 09:33:01'!
testMapToSmallerDimensionIsNotInjective
	| V W f |
	 V _ Ñ^4 atRandom.
	W _ Ñ^(V rank atRandom - 1).
	f _ (V => W) atRandomBits: 100.
	self assert: f isInjective not! !

!ModuleTest methodsFor: 'maps' stamp: 'len 5/23/2020 09:33:01'!
testMapsInducedByHom
	"Example from 'A Singular Introduction to Commutative Algebra', Example 2.1.7 (Maps Induced by Hom)."
	| X Y Z f g h yz zx |
	X _ Ñ^3.
	Y _ Ñ^3.
	Z _ Ñ^2.
	f _ X to: Y matrix: (Ñ matrix: 3 coefficients: (1 to: 9)).
	g _ f => Z. "Hom(-,Z)"
	self assert: g domain = (Y => Z). "it is contravariant"
	self assert: g codomain = (X => Z).
	self assert: g matrix = ((Ñ identityMatrix: 2) ë f matrix transposed).
	yz _ Y => Z atRandomBits: 100.
	self assert: (g value: yz) = (yz ∑ f).
	h _ Z => f. "Hom(Z,-)"
	self assert: h domain = (Z => X). "it is covariant"
	self assert: h codomain = (Z => Y).
	self assert: h matrix = (f matrix ë (Ñ identityMatrix: 2)).
	zx _ Z => X atRandomBits: 100.
	self assert: (h value: zx) = (f ∑ zx)! !

!ModuleTest methodsFor: 'maps' stamp: 'len 4/19/2020 08:03:33'!
testPreimage
	| f w v |
	f _ self newLinearMap.
	w _ f image atRandomBits: 100.
	v _ f preimage: w.
	self assert: (f value: v) = w! !

!ModuleTest methodsFor: 'maps' stamp: 'len 5/18/2018 19:43:10'!
testProjection: f
	| v |
	self testLinearMap: f.
	v _ f domain atRandomBits: 20.
	self assert: (f value: v) = (f value: (f value: v)). "idempotent at v"
	self assert: f isIdempotent.
	self assert: (f image apply: f) = f image.
	self assert: (f codomain apply: f) = f image! !

!ModuleTest methodsFor: 'maps' stamp: 'len 4/19/2020 08:03:44'!
testPullback
	| X Y Z f g P p1 p2 |
	Z _ self newFreeModule.
	X _ self newFreeModuleOver: Z scalars.
	Y _ self newFreeModuleOver: Z scalars.
	f _ (X => Z) atRandomBits: 20.
	g _ (Y => Z) atRandomBits: 20.
	P _ f /\ g.
	p1 _ P -> X.
	p2 _ P -> Y.
	self assert: p1 -> f = (p2 -> g)! !

!ModuleTest methodsFor: 'maps' stamp: 'len 4/19/2020 08:03:53'!
testPushout
	| X Y Z f g P i1 i2 |
	Z _ self newFreeModule.
	X _ self newFreeModuleOver: Z scalars.
	Y _ self newFreeModuleOver: Z scalars.
	f _ (Z => X) atRandomBits: 20.
	g _ (Z => Y) atRandomBits: 20.
	P _ f \/ g.
	i1 _ X -> P.
	i2 _ Y -> P.
	self assert: f -> i1 = (g -> i2)! !

!ModuleTest methodsFor: 'maps' stamp: 'len 5/23/2020 09:33:01'!
testRetraction
	| V W f r |
	V _ Ñ^3.
	W _ Ñ^4.
	[f _ V => W atRandomBits: 100. f isInjective] whileFalse.
	r _ f retraction.
	self assert: r isSurjective.
	self assert: r ∑ f = V id! !

!ModuleTest methodsFor: 'maps' stamp: 'len 5/23/2020 09:33:01'!
testSection
	| V W f s |
	V _ Ñ^4.
	W _ Ñ^3.
	[f _ V => W atRandomBits: 100. f isSurjective] whileFalse.
	s _ f section.
	self assert: s isInjective.
	self assert: f ∑ s = W id! !

!ModuleTest methodsFor: 'other' stamp: 'len 5/23/2020 09:33:01'!
testAdjointMap
	| V W f a |
	V _ Ñ ^ (1 to: 3) atRandom.
	W _ Ñ ^ (1 to: 5) atRandom.
	f _ V => W atRandomBits: 100.
	a _ f adjoint.
	self assert: a kernel = f image annihilatorSpace.
	self assert: a image = f kernel annihilatorSpace.
	self assert: f isSurjective = a isInjective.
	self assert: f isInjective = a isSurjective! !

!ModuleTest methodsFor: 'other' stamp: 'len 5/23/2020 09:33:01'!
testAdjointProperties
	| V W U f g a |
	V _ Ñ ^ (1 to: 4) atRandom.
	W _ Ñ ^ (1 to: 4) atRandom.
	f _ V => W atRandomBits: 100.
	g _ V => W atRandomBits: 100.
	a _ Ñ atRandomBits: 10.
	self assert: (f + g) adjoint = (f adjoint + g adjoint).
	self assert: (f * a) adjoint = (f adjoint * a).
	U _ Ñ ^ (1 to: 4) atRandom.
	f _ U => V atRandomBits: 100.
	self assert: (g ∑ f) adjoint = (f adjoint ∑ g adjoint)! !

!ModuleTest methodsFor: 'other' stamp: 'len 5/23/2020 09:33:01'!
testAnnihilator
	| V v S S0 |
	V _ Ñ ^ 3.
	v _ (1,-2,1).
	S _ V span: {v}.
	S0 _ S annihilatorSpace.
	self assert: S0 rank = S corank.
	S0 basis do: [:f| self assert: (f value: v) isZero]! !

!ModuleTest methodsFor: 'other' stamp: 'len 5/23/2020 09:33:01'!
testAnnihilatorProperties
	| V S T |
	V _ Ñ ^ 5.
	S _ (V grassmannian: 4) atRandomBits: 100.
	T _ (S grassmannian: 2) atRandomBits: 100.
	T _ V span: T basis. "hack, otherwise T ambient = S"
	self assert: T <= S.
	self assert: T annihilatorSpace >= S annihilatorSpace. "reverses inclusions"
	self assert: (S + T) annihilatorSpace = (S annihilatorSpace /\ T annihilatorSpace).
	self assert: S rank + S annihilatorSpace rank = V rank.
	self assert: V annihilatorSpace isTrivial.
"	self assert: S annihilator annihilator = S dual dual"! !

!ModuleTest methodsFor: 'other' stamp: 'len 5/23/2020 09:34:55'!
testAnnihilatorZ2
	| V v S S0 |
	V _ (É / 2) ^ 4.
	[(v _ V atRandom) isZero] whileTrue.
	S _ V span: {v}.
	S0 _ S annihilatorSpace.
	self assert: S0 rank = S corank.
	S0 generators do: [:f| self assert: (f value: v) isZero]! !

!ModuleTest methodsFor: 'other' stamp: 'len 5/23/2020 09:33:01'!
testCanonicalMorphisms
	| V W |
	V _ Ñ^3.
	W _ V span: {(1,2,3)}.
	self assert: (V null -> W) isZero. "canonical morphism from initial object"
	self assert: (V -> W null) isZero. "canonical morphism to terminal object"
	self assert: ((W -> W null) value: (V !! (1,2,3))) isZero.
	self assert: (W -> V value: (V !! (2,4,6))) = (V !! (2,4,6)). "canonical morphism to overobject"! !

!ModuleTest methodsFor: 'other' stamp: 'len 4/18/2020 22:10:36'!
testDirectSum
	| M N S |
	M _ self newFreeModule.
	N _ self newFreeModuleOver: M scalars.
	S _ M ê N.
	self testFreeModule: S.
	{M. N} >- S do: [:each| self testLinearMap: each].
	S -< {M. N} do: [:each| self testLinearMap: each]! !

!ModuleTest methodsFor: 'other' stamp: 'len 5/23/2020 09:34:55'!
testDiscriminant
	| M |
	M _ É^3.
	self assert: M discriminant = 1.
	self assert: (M span: {(1,2,3)}) discriminant = 14.
	self assert: (M span: {(1,2,3). (1,1,1)}) discriminant = 6 ! !

!ModuleTest methodsFor: 'other' stamp: 'len 5/23/2020 09:34:55'!
testExampleModulesOverZ12
	| M A B |
	M _ É/12^3.
	A _ M span: {(4,1,0). (0,0,5)}.
	B _ M span: {(8,5,5). (0,9,8). (0,0,10)}.
	self assert: A = B! !

!ModuleTest methodsFor: 'other' stamp: 'len 1/21/2018 21:47:53'!
testFreeModule: M
	| c t v x y |
	x _ M atRandomBits: 10 * M rank.
	self assert: x = (M elementAt: (M coordinatesOf: x)).
	y _ M atRandomBits: 10 * M rank.
	c _ M scalars atRandomBits: 20.
	v _ x * c + y.
	t _ (M coordinatesOf: x) * c + (M coordinatesOf: y).
	self assert: v = (M elementAt: t).
"	self testLinearMap: M basis coordinatesMap"! !

!ModuleTest methodsFor: 'other' stamp: 'len 5/23/2020 09:34:55'!
testFreeModuleDiscriminant
	"From Sage documentation of FreeModule."
	| M |
	M _ É^3.
	self assert: M discriminant = 1.
	self assert: (M span: {(1,2,3)}) discriminant = 14.
	self assert: (M span: {(1,2,3). (1,1,1)}) discriminant = 6! !

!ModuleTest methodsFor: 'other' stamp: 'len 3/14/2020 17:35:53'!
testGrassmannRelation
	| V S T |
	V _ self newVectorSpace.
	S _ (V grassmannian: V rank atRandom) atRandomBits: 20.
	T _ (V grassmannian: V rank atRandom) atRandomBits: 20.
	self assert: S rank + T rank = ((S + T) rank + (S /\ T) rank)! !

!ModuleTest methodsFor: 'other' stamp: 'len 5/23/2020 09:33:01'!
testGrassmannian
	| G S |
	G _ Ñ^3 grassmannian: 2.
	S _ G atRandomBits: 20.
	self assert: S rank = 2.
	self assert: (G includes: S).
	self assert: (G dual includes: S complement)! !

!ModuleTest methodsFor: 'other' stamp: 'len 5/14/2019 18:51:08'!
testSubmoduleInclusionOver: aRing
	| V S P v w |
	V _ aRing^3.
	[v _ V atRandomBits: 10. v isZero] whileTrue.
	S _ V span: {v}.
	[w _ V atRandomBits: 10. S includes: w] whileTrue.
	P _ V span: {w*(V scalars atRandomBits: 10)-v. w}.
	self assert: S < P.
	self assert: P > S.
	self assert: S ~= P.
	self assert: P ~= S.
	self assert: (S > P) not.
	self assert: (P < S) not! !

!ModuleTest methodsFor: 'other' stamp: 'len 5/23/2020 09:34:55'!
testSubmoduleInclusionOverBinaryPolynomials
	self testSubmoduleInclusionOver: (É/2) polynomials! !

!ModuleTest methodsFor: 'other' stamp: 'len 5/23/2020 09:33:01'!
testSubmoduleInclusionOverRationalPolynomials
	self testSubmoduleInclusionOver: Ñ polynomials! !

!ModuleTest methodsFor: 'other' stamp: 'len 5/23/2020 09:34:55'!
testSubmoduleInclusionOverZ
	self testSubmoduleInclusionOver: É! !

!ModuleTest methodsFor: 'other' stamp: 'len 5/23/2020 09:34:55'!
testSubmoduleIntersection
	| M S T T2 |
	M _ É ^ 3.
	S _ M span: {(1, 1, 1). (2, 0, -2)}.
	self assert: S /\ M = S.
	self assert: M /\ S = S.
	self assert: S /\ S = S.
	T _ M span: {(3,1,-1)}.
	self assert: S /\ T = T.
	T2 _ M span: {(3,1,-1). (0,1,0)}.
	self assert: S /\ T2 = T! !

!ModuleTest methodsFor: 'other' stamp: 'len 5/23/2020 09:34:55'!
testSubmoduleSum
	| V v w S T P |
	V _ É ^ 3.
	[v _ V atRandomBits: 10. v isZero not] whileFalse.
	[w _ V atRandomBits: 10. w isZero not and: [v ~= w]] whileFalse.
	S _ V span: {v}.
	T _ V span: {w}.
	P _ V span: {v. w}.
	self assert: S + T = P.
	self assert: T + S = P.
	T _ V span: {v - w. v + w}.
	self assert: S + T = P! !

!ModuleTest methodsFor: 'other' stamp: 'len 5/23/2020 09:33:01'!
testSubspaceInclusion
	| V S P v w |
	V _ Ñ ^ 3.
	[v _ V atRandomBits: 10. v isZero] whileTrue.
	S _ V span: {v}.
	[w _ V atRandomBits: 10. S includes: w] whileTrue.
	P _ V span: {v-w. w}.
	self assert: S < P.
	self assert: P > S.
	self assert: S ~= P.
	self assert: P ~= S.
	self assert: (S > P) not.
	self assert: (P < S) not! !

!ModuleTest methodsFor: 'other' stamp: 'len 5/23/2020 09:33:01'!
testSubspaceIntersection
	| V S T T2 |
	V _ Ñ ^ 3.
	S _ V span: {(1, 1, 1). (2, 0, -2)}.
	self assert: S /\ V = S.
	self assert: S /\ S = S.
	T _ V span: {(3,1,-1)}.
	self assert: S /\ T = T.
	T2 _ V span: {(3,1,-1). (0,1,0)}.
	self assert: S /\ T2 = T! !

!ModuleTest methodsFor: 'other' stamp: 'len 5/23/2020 09:33:01'!
testSubspaceIntersectionAndSum
	"Example from wikipedia Zassenhaus algorithm"
	| V U W |
	V _ Ñ ^ 4.
	U _ V span: {(1,-1,0,1). (0,0,1,-1)}.
	W _ V span: {(5,0,-3,3). (0,5,-3,-2)}.
	self assert: U + W = (V span: {(1,0,0,0). (0,1,0,-1). (0,0,1,-1)}).
	self assert: U /\ W = (V span: {(1,-1,0,1)})! !

!ModuleTest methodsFor: 'other' stamp: 'len 5/23/2020 09:33:01'!
testSubspaceOfSubspace
	| V S s T t |
	V _ Ñ ^ 3.
	S _ (V grassmannian: 2) atRandomBits: 100.
	T _ (S grassmannian: 1) atRandomBits: 100.
	self assert: S < V.
	self assert: T < S.
	self assert: T < V.
	[s _ S atRandomBits: 100. T includes: s] whileTrue.
	[t _ T atRandomBits: 100. t isZero] whileTrue.
	self assert: (S includes: s).
	self assert: (S includes: t).
	self assert: (T includes: t)! !

!ModuleTest methodsFor: 'other' stamp: 'len 5/23/2020 09:33:01'!
testSubspaceSum
	| V v w S T P |
	V _ Ñ ^ 3.
	[v _ V atRandomBits: 10. v isZero not] whileFalse.
	[w _ V atRandomBits: 10. w isZero not and: [v ~= w]] whileFalse.
	S _ V span: {v}.
	T _ V span: {w}.
	P _ V span: {v. w}.
	self assert: S + T = P.
	self assert: T + S = P.
	T _ V span: {v - w. v + w}.
	self assert: S + T = P! !

!ModuleTest methodsFor: 'other' stamp: 'len 5/23/2020 09:33:01'!
testSubspaceSumRandom
	| V S T U |
	V _ Ñ^5.
	S _ (V grassmannian: (0 to: V rank) atRandom) atRandomBits: 100.
	T _ (V grassmannian: (0 to: V rank) atRandom) atRandomBits: 100.
	U _ S + T.
	self assert: S <= U.
	self assert: T <= U! !

!ModuleTest methodsFor: 'other' stamp: 'len 5/23/2020 09:33:01'!
testTuplesQ
	self testFreeModule: (Ñ ^ 5 atRandom)! !

!ModuleTest methodsFor: 'other' stamp: 'len 5/23/2020 09:33:01'!
testTuplesRationalFunctionsQ
	| F |
	F _ Ñ polynomials fractions.
	self testFreeModule: F ^ 3 atRandom! !

!ModuleTest methodsFor: 'other' stamp: 'len 5/23/2020 09:34:55'!
testTuplesZ
	self testFreeModule: (É ^ 5 atRandom)! !

!ModuleTest methodsFor: 'other' stamp: 'len 5/23/2020 09:34:55'!
testTuplesZ2
	self testFreeModule: ((É / 2) ^ 5 atRandom)! !

!ModuleTest methodsFor: 'other' stamp: 'len 5/23/2020 09:34:55'!
testTuplesZ4
	self testFreeModule: ((É / 4) ^ 5 atRandom)! !

!ModuleTest methodsFor: 'other' stamp: 'len 5/23/2020 09:34:55'!
testZModuleInvariantsAndIsomorphismExample
	| M |
	M _ É^3 / {(0,-2,1). (-2,0,1)}.
	self assert: M invariants = #(0 2).
	self assert: M ~ (É^1 / {2} ê (É^1))! !

!ModuleTest methodsFor: 'other' stamp: 'len 5/23/2020 09:34:55'!
testZModuleInvariantsAndIsomorphismExample2
	| M |
	M _ É^3 / {(2,1,0)}.
	self assert: M invariants = #(0 0).
	self assert: M ~ (É^2)! !

!ModuleTest methodsFor: 'other' stamp: 'len 5/23/2020 09:34:55'!
testZModuleInvariantsAndIsomorphismExample3
	| M |
	M _ É^1 / {2} ê (É^1) / {(1,2)}.
	self assert: M invariants = #(4).
	self assert: M ~ (É^1/{4})! !

!ModuleTest methodsFor: 'quotient and complement' stamp: 'len 5/23/2020 09:33:01'!
testOrthogonalProjection
	| V S p v |
	V _ Ñ ^ 3.
	S _ V span: {(1, 1, 0). (1, 0, 0)}.
	p _ S orthogonalProjection.
	self testProjection: p.
	v _ (78, 21, 139).
	self assert: (p value: v) = (p value: (p value: v)). "idempotent at v"
	self assert: p isIdempotent.
	self assert: p kernel = S complement.
	self assert: p image = S.
	self assert: (S apply: p) = S! !

!ModuleTest methodsFor: 'quotient and complement' stamp: 'len 5/23/2020 09:33:01'!
testOrthogonalProjection2
	| V S p v |
	V _ Ñ ^ 3.
	S _ (V grassmannian: 2) atRandomBits: 30.
	p _ S orthogonalProjection.
	self testProjection: p.
	v _ V atRandomBits: 50.
	self assert: (p value: v) = (p value: (p value: v)). "idempotent at v"
	self assert: p isIdempotent.
	self assert: p kernel = S complement.
	self assert: p image = S.
	self assert: (S apply: p) = S! !

!ModuleTest methodsFor: 'quotient and complement' stamp: 'len 5/23/2020 09:33:01'!
testPerp
	| V S p perp |
	V _ Ñ ^ 3.
	S _ V span: {(1, 1, 1). (2, 0, -2)}.
	perp _ S complement.
	self assert: perp rank = 1.
	self assert: (V innerProduct value: {perp basis first. S basis first}) isZero.
	self assert: (V innerProduct value: {perp basis first. S basis second}) isZero.
	p _ S orthogonalProjection.
	self assert: p kernel = perp! !

!ModuleTest methodsFor: 'quotient and complement' stamp: 'len 5/23/2020 09:33:01'!
testPerpProperties
	| V S T |
	V _ Ñ ^ 3.
	S _ V span: {(1, 1, 1). (2, 0, -2)}.
	T _ V span: {(1, -1, -3)}. "subspace of S"
	self assert: S + S complement = V.
	self assert: T + T complement = V.
	self assert: (S /\ S complement) isTrivial.
	self assert: S <= S complement complement.
	self assert: S complement < T complement "because S > T"! !

!ModuleTest methodsFor: 'quotient and complement' stamp: 'len 5/23/2020 09:34:55'!
testPerpZ2
	| V S perp |
	V _ (É / 2) ^ 3.
	S _ V span: {(1,1,1) % 2}.
	perp _ S complement.
	self assert: perp rank = 2.
	self assert: (V innerProduct value: {S basis first. perp basis first}) isZero.
	self assert: (V innerProduct value: {S basis first. perp basis second}) isZero! !

!ModuleTest methodsFor: 'quotient and complement' stamp: 'len 5/23/2020 09:34:55'!
testQuotientGolay1
	"Construct the quotient (Z/3Z)^11 by the Golay code.
	(Example from Magma H28E10.)"
	| V S Q |
	V _ É/3 ^ 11.
	S _ V span: {(1,0,0,0,0,0,1,1,1,1,1). (0,1,0,0,0,0,0,1,2,2,1). (0,0,1,0,0,0,1,0,1,2,2). (0,0,0,1,0,0,2,1,0,1,2). (0,0,0,0,1,0,2,2,1,0,1). (0,0,0,0,0,1,1,2,2,1,0)}.
	Q _ (V/S) base. "free vector space equipped with embedding into (Z/3Z)^11"
	self assert: Q rank = 5.
	self assert: Q degree = 5! !

!ModuleTest methodsFor: 'quotient and complement' stamp: 'len 5/23/2020 09:34:55'!
testQuotientGolay2
	"Construct the quotient (Z/3Z)^11 by the Golay code as a subspace (the orthogonal complement of the Golay code).
	(Example from Magma H28E11.)"
	| V S Q |
	V _ É/3 ^ 11.
	S _ V span: ({(1,0,0,0,0,0,1,1,1,1,1). (0,1,0,0,0,0,0,1,2,2,1). (0,0,1,0,0,0,1,0,1,2,2). (0,0,0,1,0,0,2,1,0,1,2). (0,0,0,0,1,0,2,2,1,0,1). (0,0,0,0,0,1,1,2,2,1,0)} collect: [:each| each over: V scalars]).
	Q _ S complement.
	self assert: Q rank = 5.
	self assert: Q degree = 11! !

!ModuleTest methodsFor: 'quotient and complement' stamp: 'len 5/23/2020 09:33:01'!
testQuotientMaps
	| V S Q pi v s |
	V _ Ñ ^ 5.
	S _ V grassmannian: (1 to: V rank) atRandom :: atRandomBits: 50.
	Q _ V/S.
	pi _ V -> Q.
	v _ V atRandomBits: 100.
	s _ pi value: v.
	self assert: (Q includes: s).
	self assert: (V includes: (pi section value: s)).
	self assert: s = (pi value: (pi section value: s))! !

!ModuleTest methodsFor: 'quotient and complement' stamp: 'len 5/23/2020 09:34:55'!
testQuotientModuleAnnihilator
	"Example from Sage (removed denominators)"
	| v1 v2 v3 V W |
	v1 _ (1,0,0). v2 _ (3,4,2). v3 _ (0,0,2).
	V _ É^3 span: {v1. v2. v3}.
	W _ V ambient span: {v1 + (v2*2). v1*9 + (v2*2). v3*4}.
	self assert: (V/W) annihilator = (É*16)
	
"original with denominators:
	| v1 v2 v3 V W |
	v1 _ (1/2,0,0). v2 _ (3/2,2,1). v3 _ (0,0,1).
	V _ QQ^3 span: {v1. v2. v3} over: É.
	W _ QQ^3 span: {v1 + (v2*2). v1*9 + (v2*2). v3*4} over: É.
	self assert: (V/W) annihilator = (É*16)
"! !

!ModuleTest methodsFor: 'quotient and complement' stamp: 'len 5/23/2020 09:34:55'!
testQuotientModuleInvariants
	"Example from Sage (removed denominators)"
	| v1 v2 v3 V W |
	v1 _ (1,2,2). v2 _ (3,4,2). v3 _ (0,0,2).
	V _ É^3 span: {v1. v2. v3}.
	W _ V ambient span: {v1*2 + (v2*4). v1*9 + (v2*12). v3*4}.
	self assert: (V/W) invariants = #(4 12)

"original with denominators:
	| v1 v2 v3 V W |
	v1 _ (1/2,1,1). v2 _ (3/2,2,1). v3 _ (0,0,1).
	V _ QQ^3 span: {v1. v2. v3} over: É.
	W _ QQ^3 span: {v1*2 + (v2*4). v1*9 + (v2*12). v3*4} over: É.
	self assert: (V/W) invariants = #(4 12)
"! !

!ModuleTest methodsFor: 'quotient and complement' stamp: 'len 5/23/2020 09:34:55'!
testQuotientModuleInvariants2
	"Example from Sage"
	| V W |
	V _ É^3.
	W _ V span: {(1,2,0). (0,1,0). (0,2,0)}.
	self assert: (V/W) invariants = #(0) "from example in sage fgp_module.py"! !

!ModuleTest methodsFor: 'quotient and complement' stamp: 'len 5/23/2020 09:34:55'!
testQuotientModuleIsFinite
	"Example from Sage (removed denominators)"
	| v1 v2 v3 V W |
	v1 _ (1,0,0). v2 _ (3,4,2). v3 _ (0,0,2).
	V _ É^3 span: {v1. v2. v3}.
	W _ V ambient span: {v1 + (v2*2). v1*9 + (v2*2). v3*4}.
	self assert: (V/W) isFinite.
	W _ V null.
	self assert: (V/W) isFinite not

"original with denominators:
	| v1 v2 v3 V W |
	v1 _ (1/2,0,0). v2 _ (3/2,2,1). v3 _ (0,0,1).
	V _ QQ^3 span: {v1. v2. v3} over: É.
	W _ QQ^3 span: {v1 + (v2*2). v1*9 + (v2*2). v3*4} over: É.
	self assert: (V/W) isFinite.
	W _ V null.
	self assert: (V/W) isFinite not
"! !

!ModuleTest methodsFor: 'quotient and complement' stamp: 'len 8/17/2019 12:46:13'!
testQuotientSpace
	| V S Q |
	V _ self newVectorSpace.
	S _ V grassmannian: (1 to: V rank) atRandom :: atRandomBits: V rank * 10.
	Q _ V/S.
	self assert: Q rank = (V rank - S rank).
"	self assert: (Q includes: S + (V atRandomBits: V rank * 10))."
	self assert: (V / V null) rank = V rank.
	self assert: (V / V) rank = 0! !

!ModuleTest methodsFor: 'quotient and complement' stamp: 'len 5/23/2020 09:33:01'!
testQuotientSpace2
	| V M x |
	V _ Ñ^3.
	M _ V / (V !! (1,2,3)).
	x _ V -> M value: (1,2,3).
	self assert: x isZero.
"	self assert: (M lifting value: x) = (0,0,0)"! !

!ModuleTest methodsFor: 'tensor product' stamp: 'len 4/21/2020 13:55:13'!
testTensorHomAdjunction
	| V W U A B phi |
	V _ self newSmallVectorSpace.
	W _ self newFreeModuleOver: V scalars.
	U _ self newFreeModuleOver: V scalars.
	A _ VëW => U.
	B _ V => (W => U).
	self assert: A ~ B.
	phi _ A to: B evaluating: [:f| B evaluating: [:v| W to: U evaluating: [:w| f value: ((V,W) -> A domain value: {v. w})]]].
	self testLinearMap: phi.
	self assert: phi isIsomorphism! !

!ModuleTest methodsFor: 'tensor product' stamp: 'len 5/23/2020 09:33:01'!
testTensorProductAssociativity
	| V1 V2 V3 |
	V1 _ Ñ ^ 2.
	V2 _ Ñ ^ 3.
	V3 _ Ñ ^ 4.
	self assert: (V1 ë V2) ë V3 ~ (V1 ë (V2 ë V3))! !

!ModuleTest methodsFor: 'tensor product' stamp: 'len 5/23/2020 09:33:01'!
testTensorProductCommutativity
	| V W |
	V _ Ñ ^ 3.
	W _ Ñ ^ 4.
	self assert: V ë W ~ (W ë V)! !

!ModuleTest methodsFor: 'tensor product' stamp: 'len 5/23/2020 09:33:01'!
testTensorProductDimension
	| V1 V2 |
	V1 _ Ñ ^ 5 atRandom.
	V2 _ Ñ ^ 5 atRandom.
	self assert: (V1 ë V2) rank = (V1 rank * V2 rank)! !

!ModuleTest methodsFor: 'tensor product' stamp: 'len 5/23/2020 09:33:01'!
testTensorProductDistributivity
	| A B C |
	A _ Ñ ^ 3.
	B _ Ñ ^ 4.
	C _ Ñ ^ 2.
	self assert: A ê B ë C ~ (A ë C ê (B ë C))! !

!ModuleTest methodsFor: 'tensor product' stamp: 'len 4/21/2020 13:54:31'!
testTensorProductDualHomIsomorphism
	| V W A B |
	V _ self newVectorSpace.
	W _ self newFreeModuleOver: V scalars.
	A _ V dual ë W.
	B _ V => W.
	self assert: A ~ B.
"	phi _ A to: B evaluating: [:t| B evaluating: [:v| t second * (t first value: v)]].
	self testLinearMap: phi.
	self assert: phi isIsomorphism"! !

!ModuleTest methodsFor: 'tensor product' stamp: 'len 4/21/2020 13:54:46'!
testTensorProductDualIsomorphism
	| V W A B |
	V _ self newVectorSpace.
	W _ self newFreeModuleOver: V scalars.
	A _ V dual ë W dual.
	B _ (V ë W) dual.
	self assert: A ~ B.
"	phi _ A to: B evaluating: [:s| B evaluating: [:t| (s first value: t first) * (s second value: t second)]].
	self testLinearMap: phi.
	self assert: phi isIsomorphism"! !

!ModuleTest methodsFor: 'tensor product' stamp: 'len 5/23/2020 09:34:55'!
testTensorProductExample
	self assert: É^1 ë (É^1/{2}) ~ (É^1/{2})! !

!ModuleTest methodsFor: 'tensor product' stamp: 'len 5/23/2020 09:33:01'!
testTensorProductOfLinearForms
	| V W f g t v w |
	V _ Ñ ^ 3.
	W _ Ñ ^ 4.
	f _ V dual atRandomBits: 10.
	g _ W dual atRandomBits: 10.
	t _ f ë g.
	self assert: t domain = (V ë W).
	self assert: t codomain = (f codomain ë g codomain).
	v _ V atRandomBits: 10.
	w _ W atRandomBits: 10.
	self assert: (t value: ((V, W) -> t domain value: {v. w})) = ( (f codomain, g codomain) -> t codomain value: {f value: v. g value: w})! !

!ModuleTest methodsFor: 'tensor product' stamp: 'len 4/21/2020 08:46:15'!
testTensorProductRelations
	| V W T v v1 v2 w w1 w2 c composition |
	V _ self newVectorSpace.
	W _ self newFreeModuleOver: V scalars.
	T _ V ë W.
	composition _ (V, W) -> T.
	v _ V atRandomBits: 40.
	v1 _ V atRandomBits: 40.
	v2 _ V atRandomBits: 40.
	w _ W atRandomBits: 40.
	w1 _ W atRandomBits: 40.
	w2 _ W atRandomBits: 40.
	c _ V scalars atRandomBits: 40.
	self assert: (composition value: {v1. w}) + (composition value: {v2. w}) = (composition value: {v1 + v2. w}).
	self assert: (composition value: {v. w1}) + (composition value: {v. w2}) = (composition value: {v. w1 + w2}).
	self assert: (composition value: {v. w})*c = (composition value: {v*c. w}).
	self assert: (composition value: {v. w})*c = (composition value: {v. w*c})! !

!ModuleTest methodsFor: 'private' stamp: 'len 4/21/2020 05:52:54'!
newFreeModule
	^ self newFreeModuleOver: self newScalarsRing! !

!ModuleTest methodsFor: 'private' stamp: 'len 5/2/2020 17:27:00'!
newFreeModuleOver: scalars
	| M N |
	M _ 3 atRandom = 1 ifTrue: [scalars asScalarModule] ifFalse: [scalars ^ 3 atRandom].
	4 atRandom = 1 ifTrue:
		[N _ self newFreeModuleOver: scalars.
		2 atRandom = 1 ifTrue: [^ M => N].
		^ M ë N].
	4 atRandom = 1 ifTrue: [^ M endomorphisms].
	4 atRandom = 1 ifTrue: [^ M dual].
	^ M! !

!ModuleTest methodsFor: 'private' stamp: 'len 5/23/2020 09:34:55'!
newLinearMap
	| K V W |
	K _ {Ñ. É / #(2 3 5 7) atRandom} atRandom.
	V _ self newFreeModuleOver: K.
	W _ self newFreeModuleOver: K.
	^ V => W !! (self newMatrix: W rank @ V rank over: K)! !

!ModuleTest methodsFor: 'private' stamp: 'len 3/9/2020 20:42:07'!
newMatrix: shape over: aRing
	| samples |
	2 atRandom = 1 ifTrue: [^ aRing atRandomMatrix: shape bits: 100].
	samples _ {aRing zero. aRing one. aRing one negated}.
	^ aRing matrix: shape evaluating: [:i :j| 2 atRandom > 1 ifTrue: [aRing zero] ifFalse: [samples atRandom]]! !

!ModuleTest methodsFor: 'private' stamp: 'len 5/23/2020 09:34:55'!
newScalarsField
	^ {Ñ. É/10 atRandom nextPrime. Ñ polynomials fractions. (É/10 atRandom nextPrime) polynomials fractions. GaloisField new: 2 to: 2} atRandom! !

!ModuleTest methodsFor: 'private' stamp: 'len 5/23/2020 09:34:55'!
newScalarsPID
	^ {Ñ. É/2. É. Ñ polynomials} atRandom! !

!ModuleTest methodsFor: 'private' stamp: 'len 5/23/2020 09:34:55'!
newScalarsRing
	^ {É. Ñ. É/10 atRandom nextPrime. Ñ polynomials. (É/10 atRandom nextPrime) polynomials. Ñ polynomials fractions. (É/10 atRandom nextPrime) polynomials fractions} atRandom! !

!ModuleTest methodsFor: 'private' stamp: 'len 5/23/2020 09:34:55'!
newSmallVectorSpace
	^ self newFreeModuleOver: {Ñ. É / #(2 3 5 7) atRandom} atRandom! !

!ModuleTest methodsFor: 'private' stamp: 'len 4/21/2020 05:57:02'!
newVectorSpace
	^ self newFreeModuleOver: self newScalarsField! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 2/26/2017 09:25:17'!
testAntigradedLexOrdering
	"Example from 'Using Algebraic Geometry', Cox, Little, O'Shea, Ch. 4, 3.2."
	| M x y |
	M _ FreeAbelianMonoid new: 2 ordering: #lglex. "antigraded lex order"
	x _ M x: 1.
	y _ M x: 2.
	self assert: M identity > x.
	self assert: x > y.
	self assert: x^2 > (x*y).
	self assert: x*y > (y^2).
	self assert: (y^2) > (x^3)! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 2/26/2017 09:25:24'!
testAntigradedRevlexOrdering
	"Example from 'Using Algebraic Geometry', Cox, Little, O'Shea, Ch. 4, 3.3."
	| M x y z ordering |
	"The antigraded revlex order:"
	ordering _ LocalGradedReverseLexicographicOrdering indeterminates: #(3 2 1).
	M _ FreeAbelianMonoid new: 3 ordering: ordering.
	x _ M x: 1.
	y _ M x: 2.
	z _ M x: 3.
	self assert: M identity > x.
	self assert: x > y.
	self assert: y > z.
	self assert: x^2 > (x*y).
	self assert: x*y > (y^2).
	self assert: (x*z) > (y*z).
	self assert: (y*z) > (z^2)! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 11/22/2016 08:31:09'!
testHash
	| m1 m2 |
	m1 _ Monomial exponents: #(1 2 0).
	m2 _ Monomial exponents: #(1 2 0 0 0 0 0).
	self assert: m1 hash = m2 hash! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testLocalMonomialOrderings
	"Examples from Magma handbook."
	| f |
	f _ É polynomialsIn: #(x y z) ordering: #llex :: generate: [:x :y :z| 1 + x + y + z + (x^7) + (x^8*(y^7)) + (y^5) + (z^10)].
	self assert: f printString = '1 + x + x^7 + y + y^5 + x^8y^7 + z + z^{10}'.
	self assert: (f orderedBy: #lgrevlex) printString = '1 + z + y + x + y^5 + x^7 + z^{10} + x^8y^7'! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 2/26/2017 09:25:19'!
testMonomialDivision
	| M x y |
	M _ FreeAbelianMonoid new: 2.
	x _ M x: 1.
	self assert: x*x = (M x: 1 to: 2).
	y _ M x: 2.
	self assert: x*x*y / (x*y) = x.
	self assert: x*y*x / x = (x*y).
	self assert: x*y*x*y / (x*y) = (x*y)! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 2/26/2017 09:25:22'!
testMonomialGCD
	| M x y a b |
	M _ FreeAbelianMonoid new: 2.
	x _ M x: 1.
	y _ M x: 2.
	a _ x*x*y*y*y.
	b _ x*x*x*y*y.
	self assert: (a gcd: b) = (x*x*y*y)! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 2/26/2017 09:25:12'!
testMonomialLCM
	| M x y a b |
	M _ FreeAbelianMonoid new: 2.
	x _ M x: 1.
	y _ M x: 2.
	a _ x*x.
	b _ x*y*y.
	self assert: (a lcm: b) = (x*x*y*y)! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testMonomialOrderings
	| P x y z f lex glex grevlex |
	P _ É polynomialsIn: 3.

	x _ P x.
	y _ P y.
	z _ P z.

	f _ 10*x - (7*(y^4)) + (11*(y^3)*z).

	lex _ MonomialOrdering lex: 3.
	glex _ MonomialOrdering glex: 3.
	grevlex _ MonomialOrdering grevlex: 3.

	self assert: (f orderedBy: lex) leadingCoefficient = 10.
	self assert: (f orderedBy: glex) leadingCoefficient = -7.
	self assert: (f orderedBy: grevlex) leadingCoefficient = -7 "this matches the definition in Singular"! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testMonomialOrderings2
	"Examples from Macaulay2 documentation."
	| R a b c d f |
	R _ É polynomialsIn: #(a b c d).
	a _ R x: 1.
	b _ R x: 2.
	c _ R x: 3.
	d _ R x: 4.

	f _ a + (b^100) + (c*d).

	self assert: (f orderedBy: #lex) printString = 'a + b^{100} + cd'.
	self assert: (f orderedBy: #grevlex) printString = 'b^{100} + cd + a'.
	self assert: (f orderedBy: #glex) printString = 'b^{100} + cd + a'! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testMonomialOrderings3
	"Examples from Derksen, Kemper 'Computational Invariant Theory' 1.1.1."
	| P x1 x2 x3 x4 f |
	P _ É polynomialsIn: 4.
	x1 _ P x: 1.
	x2 _ P x: 2.
	x3 _ P x: 3.
	x4 _ P x: 4.
	f _ x1 + (x2*x4) + (x3^2).
	self assert: (f orderedBy: #lex) leadingTerm = x1.
	self assert: (f orderedBy: #glex) leadingTerm = (x2*x4).
	self assert: (f orderedBy: #grevlex) leadingTerm = (x3^2)! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 5/10/2018 19:38:00'!
testMonomialOrderings4
	"Examples from en.wikipedia.org/wiki/Monomial_order to illustrate the difference between graded lexicographic and graded reverse lexicographic."
	| M S |
	M _ FreeAbelianMonoid new: 3 ordering: #glex.
	S _ Set new.
	1 to: 3 do: [:i| i to: 3 do: [:j| S add: (M x: i) * (M x: j)]].
	self assert: (S sorted: [:a :b| a > b]) printString = '({x1}^2, {x1}{x2}, {x1}{x3}, {x2}^2, {x2}{x3}, {x3}^2)'.
	M _ M orderedBy: #grevlex.
	S _ S collect: [:each| M !! each].
	self assert: (S sorted: [:a :b| a > b]) printString = '({x1}^2, {x1}{x2}, {x2}^2, {x1}{x3}, {x2}{x3}, {x3}^2)'! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 4/22/2020 06:30:07'!
testMonomialOrderingsExample
	| a b lex glex grevlex |
	lex _ FreeAbelianMonoid new: 3 ordering: #lex.
	a _ lex exponents: #(3 2 8).
	b _ lex exponents: #(2 9 2).
	glex _ FreeAbelianMonoid new: 3 ordering: #glex.
	grevlex _ FreeAbelianMonoid new: 3 ordering: #grevlex.
	self assert: a > b.
	self assert: glex !! a > (glex !! b).
	self assert: grevlex !! a < (grevlex !! b)! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 4/22/2020 06:30:42'!
testMonomialOrderingsExample2
	| a b lex glex |
	lex _ FreeAbelianMonoid new: 3 ordering: #lex.
	a _ lex exponents: #(0 2 9).
	b _ lex exponents: #(0 5 3).
	glex _ FreeAbelianMonoid new: 3 ordering: #glex.
"	grevlex _ FreeAbelianMonoid new: 3 ordering: #grevlex."
	self assert: b > a.
	self assert: glex !! a > (glex !! b).
"	self assert: grevlex !! a < (grevlex !! b)"! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 4/22/2020 06:31:12'!
testMonomialOrderingsExample3
	| a b lex glex grevlex |
	lex _ FreeAbelianMonoid new: 3 ordering: #lex.
	a _ lex exponents: #(2 1 2).
	b _ lex exponents: #(1 3 1).
	glex _ FreeAbelianMonoid new: 3 ordering: #glex.
	grevlex _ FreeAbelianMonoid new: 3 ordering: #grevlex.
	self assert: a > b.
	self assert: glex !! a > (glex !! b).
	self assert: grevlex !! a < (grevlex !! b)! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 2/26/2017 09:25:07'!
testMonomialOrderingsOfIndeterminates
	| M x y z |
	M _ FreeAbelianMonoid new: 3.
	x _ M x: 1.
	y _ M x: 2.
	z _ M x: 3.
	{MonomialOrdering lex: 3.
	MonomialOrdering llex: 3.
	MonomialOrdering glex: 3.
	MonomialOrdering grevlex: 3} do: [:ordering| 
		self assert: (x orderedBy: ordering) > (y orderedBy: ordering).
		self assert: (y orderedBy: ordering) > (z orderedBy: ordering)]! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 2/26/2017 09:25:09'!
testMonomialOrderingsOfIndeterminatesReordered
	| M x y z |
	M _ FreeAbelianMonoid new: 3 ordering: (MonomialOrdering lex: #(2 1 3)).
	x _ M x: 1.
	y _ M x: 2.
	z _ M x: 3.
	self assert: y > x.
	self assert: x > z! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:33:01'!
testMonomialOrderingsSingularExample
	"'A Singular Introduction to Commutative Algebra', Example 1.2.13 (monomial orderings)."
	| f |
	f _ (Ñ polynomialsIn: #(x y z)) !! [:x :y :z| x^3*y*z + (x^3) + (x*(y^2)) + (y^5) + (z^4)].
	"Global orderings:"
	self assert: (f orderedBy: #lex) printString =  'x^3yz + x^3 + xy^2 + y^5 + z^4'.
	self assert: (f orderedBy: #grevlex) printString = 'y^5 + x^3yz + z^4 + x^3 + xy^2'.
	self assert: (f orderedBy: #glex) printString = 'x^3yz + y^5 + z^4 + x^3 + xy^2'.
	"TODO: weighted total lexicographic ordering"
	"Local orderings don't match because we implemented them with Magma conventions."
! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 2/26/2017 09:25:14'!
testMonomialProduct
	| M x y |
	M _ FreeAbelianMonoid new: 2.
	x _ M x: 1.
	self assert: x*x = (M x: 1 to: 2).
	y _ M x: 2.
	self assert: x*y = (y*x).
	self assert: x*y*y = (x*(y*y)).
	self assert: ((x*y*y) at: 2) = 2.
	self assert: (x*y*x*x*y) degree = 5! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testWeightedMonomialOrderings
	| P x y z f lex glex grevlex revlex |
	P _ É polynomialsIn: 3.

	x _ P x.
	y _ P y.
	z _ P z.

	f _ 10*x - (7*(y^4)) + (11*(y^3)*z).

	lex _ WeightedMonomialOrdering lex: (1 to: 3).
	glex _ WeightedMonomialOrdering glex: (1 to: 3).
	grevlex _ WeightedMonomialOrdering grevlex: (1 to: 3).
	revlex _ WeightedMonomialOrdering grevlex: (1 to: 3).

	self assert: (f orderedBy: lex) leadingCoefficient = 10.
	self assert: (f orderedBy: glex) leadingCoefficient = -7.
	self assert: (f orderedBy: grevlex) leadingCoefficient = 11.
	self assert: (f orderedBy: revlex) leadingCoefficient = 11! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testWeightedMonomialOrderingsConsistency
	| P x y z f lex glex grevlex revlex |
	P _ É polynomialsIn: 3.

	x _ P x.
	y _ P y.
	z _ P z.

	f _ 10*x - (7*(y^4)) + (11*(y^3)*z).

	lex _ WeightedMonomialOrdering lex: (1 to: 3).
	glex _ WeightedMonomialOrdering glex: (1 to: 3).
	grevlex _ WeightedMonomialOrdering grevlex: (1 to: 3).
	revlex _ WeightedMonomialOrdering grevlex: (1 to: 3).

	self assert: (f orderedBy: lex) monomials asArray = (f orderedBy: #lex) monomials asArray.
	self assert: (f orderedBy: glex) monomials asArray = (f orderedBy: #glex) monomials asArray.
	self assert: (f orderedBy: grevlex) monomials asArray = (f orderedBy: #grevlex) monomials asArray.
	self assert: (f orderedBy: revlex) monomials asArray = (f orderedBy: #revlex) monomials asArray! !

!NumberFieldTest methodsFor: 'as yet unclassified' stamp: 'len 12/10/2016 21:58:12'!
testCyclotomicFieldDiscriminant
	self assert: (CyclotomicField new: 20) discriminant = 4000000.
	self assert: (CyclotomicField new: 18) discriminant = -19683! !

!NumberFieldTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:33:01'!
testMinimalPolynomial
	"Example from 'Algebraic Number Theory: A Computational Approach' by William Stein (28 pp)."
	| x K a |
	x _ Ñ polynomials x.
	K _ Ñ extension: x^2 - 2.
	a _ K x.
	self assert: a minimalPolynomial = (x^2 - 2).
	self assert: (a/2 + 3) minimalPolynomial = (x^2 - (x*6) + (17/2))! !

!NumberFieldTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:33:01'!
testMinimalPolynomial2
	"Example from 'Algebraic Number Theory: A Computational Approach' by William Stein (29 pp)."
	| x K a alpha |
	x _ Ñ polynomials x.
	K _ QuadraticField sqrt: 5.
	a _ K x.
	self assert: a squared = 5.
	alpha _ (1 + a) / 2.
	self assert: alpha minimalPolynomial = (x^2 - x - 1)! !

!NumberFieldTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:33:01'!
testMinimalPolynomial3
	"Example from 'Algebraic Number Theory: A Computational Approach' by William Stein (29 pp)."
	| x alpha |
	x _ Ñ polynomials x.
	alpha _ 1 + 5 squareRoot / 2.
	self assert: alpha minimalPolynomial = (x^2 - x - 1)! !

!NumberFieldTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:33:01'!
testNormAndTrace
	| F a b |
"	x _ Ñ polynomials x.
	F _ Ñ extension: x^4 - (x^2*420) + 40000."
	F _ Ñ extensionDegree: (2 to: 4) atRandom.
	a _ F atRandomBits: 100.
	b _ F atRandomBits: 100.
	self assert: (a + b) trace = (a trace + b trace).
	self assert: (a * b) norm = (a norm * b norm)! !

!NumberFieldTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:33:01'!
testNormOfAlgebraicInteger
	| F a |
	F _ Ñ extensionDegree: (2 to: 4) atRandom.
	a _ F integers atRandomBits: 100.
	self assert: a norm isIntegral! !

!NumberFieldTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:33:01'!
testNormTraceAndMinimalPolynomial
	"Example H38E17 from Magma documentation."
	| x F a |
	x _ Ñ polynomials x.
	F _ Ñ extension: x^4 - (x^2*420) + 40000.
	a _ F x / 2.
	self assert: a trace = 0.
	self assert: a norm = 2500.
	self assert: a minimalPolynomial = (x^4 - (x^2*105) + 2500)! !

!NumberFieldTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:33:01'!
testQSqrt2
	| E x |
	x _ Ñ polynomials x.
	E _ Ñ adjoin: RealAlgebraicNumber sqrt2.
	self assert: E x minimalPolynomial = E polynomial.
	self assert: E x squared minimalPolynomial = (x - 2)! !

!NumberFieldTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:33:01'!
testQSqrt2RealEmbeddings
	| E embeddings roots |
	E _ Ñ adjoin: RealAlgebraicNumber sqrt2.
	embeddings _ E realEmbeddings.
	roots _ (E polynomial rootsIn: Ö) asSet.
	self assert: (embeddings collect: [:f| f value: E x]) asSet = roots! !

!NumberFieldTest methodsFor: 'as yet unclassified' stamp: 'len 12/14/2016 14:59:36'!
testQuadraticFieldFundamentalDiscriminant
	self assert: (QuadraticField sqrt: 102) discriminant = 408.
	self assert: (QuadraticField sqrt: 720) discriminant = 5.
	self assert: (QuadraticField sqrt: 2) discriminant = 8! !

!NumberFieldTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:33:01'!
testQuadraticFieldSqrt2
	| E x |
	E _ QuadraticField sqrt: 2.
	x _ Ñ polynomials x.
	self assert: E x minimalPolynomial = E polynomial.
	self assert: E x squared minimalPolynomial = (x - 2).
	self assert: E discriminant = 8! !

!NumberFieldTest methodsFor: 'as yet unclassified' stamp: 'len 12/10/2016 21:42:04'!
testQuadraticFieldSqrtMinusFive
	| E |
	E _ QuadraticField sqrt: -5.
	self assert: E x minimalPolynomial = E polynomial.
	self assert: E x squared = (E embed: -5).
	self assert: E x ^ 4 = (E embed: 25).
	self assert: E discriminant = -20! !

!NumberFieldTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:33:01'!
testSignature
	| x F |
	x _ Ñ polynomials x.
	F _ NumberField polynomial: x^2 + 1.
	self assert: F signature = #(0 1).
	F _ NumberField polynomial: x^3 - 2.
	self assert: F signature = #(1 1).
	F _ CyclotomicField new: 5.
	self assert: F signature = #(0 2).
	F _ NumberField polynomial: x^6 + x + 1.
	self assert: F signature = #(0 3).
	F _ NumberField polynomial: x^3 + (x^2) - (x*5) - 1.
	self assert: F signature = #(3 0)! !

!NumberFieldTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:33:01'!
testTotallyImaginary
	| x E |
	x _ Ñ polynomials x.
	E _ NumberField polynomial: x^2 + 2.
	self assert: E isImaginary.
	E _ NumberField polynomial: x^2 - 2.
	self assert: E isImaginary not.
	E _ NumberField polynomial: x^4 - 2.
	self assert: E isImaginary not! !

!NumberFieldTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:33:01'!
testTotallyReal
	| x E |
	x _ Ñ polynomials x.
	E _ NumberField polynomial: x^2 + 2.
	self assert: E isReal not.
	E _ NumberField polynomial: x^2 - 2.
	self assert: E isReal.
	E _ NumberField polynomial: x^4 - 2.
	self assert: E isReal not! !

!PAdicsTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testAddition
	| R a b c |
	R _ É adic: 5.
	a _ R !! 123.
	b _ R !! -445.
	c _ R !! (123 - 445).
	self assert: a+b = c.
	self assert: {c precision. c absolutePrecision. c relativePrecision} = #(20 20 20).
	c _ a+b.
	self assert: {c precision. c absolutePrecision. c relativePrecision} = #(20 20 20)! !

!PAdicsTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testAddition2
	| Z7 a b c |
	Z7 _ É adic: 7.
	a _ Z7 !! 676.
	b _ Z7 !! 123.
	c _ Z7 !! (676+123).
	self assert: a+b = c! !

!PAdicsTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testAddition3
	| Z7 a b c |
	Z7 _ É adic: 7.
	a _ Z7 !! -676.
	b _ Z7 !! 123.
	c _ Z7 !! (-676+123).
	self assert: a+b = c! !

!PAdicsTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testAdditiveInverse
	| R a b |
	R _ É adic: 7.
	a _ R !! -676.
	b _ R !! 676.
	self assert: a = b negated.
	self assert: a negated negated = a! !

!PAdicsTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testFractionsField
	| Z7 Q7 |
	Z7 _ É adic: 7.
	Q7 _ Ñ adic: 7.
	self assert: Z7 fractions = Q7! !

!PAdicsTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testLocalProperties
	| R |
	R _ É adic: 7.
	self assert: R isLocal.
	self assert: R maximalIdeal = (R * 7)! !

!PAdicsTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testMultiplication
	| R a b c |
	R _ É adic: 5.
	a _ R !! 123.
	b _ R !! -445.
	c _ R !! (123 * -445).
	self assert: a * b = c.
	self assert: {c precision. c absolutePrecision. c relativePrecision} = #(20 20 19)! !

!PAdicsTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testMultiplication2
	| R a b c |
	R _ É adic: 7.
	a _ R !! 676.
	b _ R !! 123.
	c _ R !! (676 * 123).
	self assert: a * b = c! !

!PAdicsTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testMultiplication3
	| R a b c p |
	R _ É adic: 5.
	p _ R uniformizer.
	a _ R !! 123.
	b _ p^8 + 1.
	c _ R !! (123 * (5^8 + 1)).
	self assert: a * b = c.
	self assert: {c precision. c absolutePrecision. c relativePrecision} = #(20 20 20)! !

!PAdicsTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testMultiplicationBug
	| R zero |
	R _ É adic: 5.
	zero _ R zero.
	self assert: zero * zero = zero! !

!PAdicsTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testNormAndValuation
	| R x |
	R _ É adic: 7.
	x _ R !! 13.
	self assert: x valuation = 0.
	self assert: x abs = 1.
	x _ x * (7*7).
	self assert: x valuation = 2.
	self assert: x abs = (1/(7*7)).
	R _ É adic: 7.
	x _ R !! 0.
	self assert: x valuation = Infinity positive.
	self assert: x abs = 0! !

!PAdicsTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testPrecision
	"Some tests to match Magma."
	| R p a |
	R _ É adic: 5.
	p _ R uniformizer.
	self assert: p precision = 20.
	a _ p*p negated.
	self assert: {a precision. a absolutePrecision. a relativePrecision} = #(21 21 19).
	a _ R !! -25.
	self assert: {a precision. a absolutePrecision. a relativePrecision} = #(20 20 18)! !

!PAdicsTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testProjectionToPrimePowerRingAndLifting
	| R a x |
	R _ É adic: 7.
	a _ (-1024 to: 1024) atRandom.
	x _ R !! a.
	self assert: ((É/(7^5)) !! x) lift = a.
	self assert: ((É/(7^(5 to: 10) atRandom)) !! x) lift = a! !

!PAdicsTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testSubstraction
	| R a b c |
	R _ É adic: 7.
	a _ R !! 676.
	b _ R !! 123.
	c _ R !! (676 - 123).
	self assert: a - b = c! !

!PolynomialTest methodsFor: 'arithmetic' stamp: 'len 4/25/2018 21:52:52'!
testArithmeticOver: R
	| x f g |
	x _ R polynomials x.
	f _ x^2 + (x*2) - 1.
	g _ x^2 - (x*2) + 1.
	self assert: f+g = (x^2 * 2).
	self assert: f-g = (x*4 - 2).
	self assert: f*g = (x^4 - (x^2 * 4) + (x*4) - 1).
	self assert: f*g // g = f.
	self assert: (f*g \\ g) isZero.
	self assert: (f*g + (x - 1) \\ g) = (x - 1)
! !

!PolynomialTest methodsFor: 'arithmetic' stamp: 'len 5/23/2020 09:33:21'!
testArithmeticQQ
	self testArithmeticOver: Ñ! !

!PolynomialTest methodsFor: 'arithmetic' stamp: 'len 5/23/2020 09:34:55'!
testArithmeticZ2
	self testArithmeticOver: É/2! !

!PolynomialTest methodsFor: 'arithmetic' stamp: 'len 5/23/2020 09:34:55'!
testArithmeticZ3
	self testArithmeticOver: É/3! !

!PolynomialTest methodsFor: 'arithmetic' stamp: 'len 5/23/2020 09:34:55'!
testArithmeticZm
	self testArithmeticOver: É/(2 + 100 atRandom)! !

!PolynomialTest methodsFor: 'gcd' stamp: 'len 5/23/2020 09:34:55'!
testContentAndPrimitive
	| Zx Zxy x y f |
	Zx _ É polynomialsIn: #(x).
	Zxy _ Zx polynomialsIn: #(y).
	x _ Zx x.
	y _ Zxy x.
	f _ 2*x*y + (2*(x^2)).
	self assert: f primitivePart * f content = f! !

!PolynomialTest methodsFor: 'gcd' stamp: 'len 5/23/2020 09:34:55'!
testContentAndPrimitiveAtRandom
	| Zx f |
	Zx _ É polynomials.
	f _ Zx atRandomBits: 100 maxDegree: (1 to: 10) atRandom.
	self assert: f primitivePart * f content = f! !

!PolynomialTest methodsFor: 'gcd' stamp: 'len 5/23/2020 09:33:01'!
testExtendedEuclidBug
	| x f1 f2 |
	x _ Ñ polynomials x.
	f1 _ x^2 + 1.
	f2 _ x - 1.
	self assert: (f1 xgcd: f2) first = (f1 gcd: f2)! !

!PolynomialTest methodsFor: 'gcd' stamp: 'len 5/23/2020 09:33:01'!
testGCD
	| P x f g |
	P _ Ñ polynomials.
	x _ P x.
	f _ x^4 - 1.
	g _ x^6 - 1.
	self assert: (f gcd: g) = (x^2 - 1)! !

!PolynomialTest methodsFor: 'gcd' stamp: 'len 5/23/2020 09:34:55'!
testGCDMultivariate
	| Zxy x y f g |
	Zxy _ É polynomialsIn: #(x y) ordering: #lex.
	x _ Zxy x.
	y _ Zxy y.
	f _ (x+y)*(y-x).
	g _ (y-x)^2.
	self assert: (f gcd: g) = (x-y)! !

!PolynomialTest methodsFor: 'gcd' stamp: 'len 5/23/2020 09:33:01'!
testGCDMultivariate2
	"Example from Sage documentation."
	| R x y f g |
	R _ Ñ polynomialsIn: #(x y).
	x _ R x. y _ R y.
	f _ x^2*y*(x+y)*3.
	g _ x*(y^2 - (x^2))*9.
	self assert: (f gcd: g) = (x^2 + (x*y))! !

!PolynomialTest methodsFor: 'gcd' stamp: 'len 5/23/2020 09:33:01'!
testGCDMultivariateOverQ
	| R x y f g |
	R _ Ñ polynomialsIn: #(x y).
	x _ R x. y _ R y.
	f _ x^2*y*6.
	g _ x*(y^2)*15 + (x^3*(y^2)*21).
	self assert: (f gcd: g) = (x*y)! !

!PolynomialTest methodsFor: 'gcd' stamp: 'len 5/23/2020 09:34:55'!
testGCDMultivariateOverZ
	| R x y f g |
	R _ É polynomialsIn: #(x y).
	x _ R x. y _ R y.
	f _ x^2*y*6.
	g _ x*(y^2)*15 + (x^3*(y^2)*21).
	self assert: (f gcd: g) = (x*y*3)! !

!PolynomialTest methodsFor: 'gcd' stamp: 'len 5/23/2020 09:33:01'!
testGCDOverRationalFunctions
	| R x y f g |
	R _ Ñ polynomialsIn: #(y) :: fractions polynomials.
	x _ R x. y _ R scalars x.
	f _ x^2*y*6.
	g _ x*(y^2)*15 + (x^3*(y^2)*21).
	self assert: (f gcd: g) = x! !

!PolynomialTest methodsFor: 'gcd' stamp: 'len 5/23/2020 09:34:55'!
testGCDOverZ
	| x f g |
	x _ É polynomials x.
	f _ (x^4 - 1)*6.
	g _ (x^6 - 1)*9.
	self assert: (f gcd: g) = ((x^2 - 1)*3)! !

!PolynomialTest methodsFor: 'gcd' stamp: 'len 5/23/2020 09:34:55'!
testGCDOverZ2
	| x f g h |
	x _ É/2 :: polynomials x.
	h _ x^3 - x + 1.
	f _ h * (x + 1) * x.
	g _ h * (x + 1) * (x^2 + 1).
	self assert: (f gcd: g) = (h * (x + 1))! !

!PolynomialTest methodsFor: 'gcd' stamp: 'len 5/23/2020 09:33:01'!
testMultivariateGCDBug
	| x |
	x _ Ñ polynomialsIn: 3 :: x.
	self assert: (x^2 gcd: x) = x! !

!PolynomialTest methodsFor: 'division' stamp: 'len 5/12/2020 12:33:23'!
testDivision: F
	| Fx f g |
	Fx _ F polynomials.
	f _ Fx atRandomBits: 50 maxDegree: 5 atRandom.
	[g _ Fx atRandomBits: 50 maxDegree: 5 atRandom. g isZero] whileTrue.
	self assert: (f // g) * g + (f \\ g) = f! !

!PolynomialTest methodsFor: 'division' stamp: 'len 5/10/2020 02:23:03'!
testDivisionPrimeField65535
	self testDivision: (PrimeField new: 2^17 - 1)! !

!PolynomialTest methodsFor: 'division' stamp: 'len 5/10/2020 02:22:44'!
testDivisionPrimeFieldZ2
	self testDivision: (PrimeField new: 2)! !

!PolynomialTest methodsFor: 'division' stamp: 'len 5/23/2020 09:33:01'!
testDivisionQ
	self testDivision: Ñ! !

!PolynomialTest methodsFor: 'division' stamp: 'len 5/23/2020 09:33:01'!
testDivisionQ1
	| P x f g |
	P _ Ñ polynomials.
	x _ P x.
	f _ x.
	g _ 1 - (x*3).
	self assert: f // g = (P !! (-1/3)).
	self assert: f \\ g = (P !! (1/3))! !

!PolynomialTest methodsFor: 'division' stamp: 'len 5/23/2020 09:33:01'!
testDivisionQ2
	| P x f g |
	P _ Ñ polynomials.
	x _ P x.
	f _ x.
	g _ 1 + (x*3).
	self assert: f // g = (P !! (1/3)).
	self assert: f \\ g = (P !! (-1/3))! !

!PolynomialTest methodsFor: 'division' stamp: 'len 5/23/2020 09:33:01'!
testDivisionRationalFunctions
	self testDivision: Ñ polynomials fractions! !

!PolynomialTest methodsFor: 'division' stamp: 'len 5/23/2020 09:34:55'!
testDivisionRationalFunctionsZ2
	self testDivision: (É/2) polynomials fractions! !

!PolynomialTest methodsFor: 'division' stamp: 'len 5/13/2020 08:53:01'!
testDivisionRationalFunctionsZ65535
	self testDivision: (PrimeField new: 2^17 - 1) polynomials fractions! !

!PolynomialTest methodsFor: 'division' stamp: 'len 5/23/2020 09:34:55'!
testDivisionZ1
	| P x f g |
	P _ É polynomials.
	x _ P x.
	f _ x.
	g _ 1 + (x*3).
	self assert: f // g = (P !! 0).
	self assert: f \\ g = x! !

!PolynomialTest methodsFor: 'division' stamp: 'len 5/23/2020 09:34:55'!
testDivisionZ2
	| P x f g |
	P _ É polynomials.
	x _ P x.
	f _ x.
	g _ 1 - (x*3).
	self assert: f // g = (P !! -1).
	self assert: f \\ g = (1 - (x*2))! !

!PolynomialTest methodsFor: 'division' stamp: 'len 5/23/2020 09:34:55'!
testDivisionZ3
	| P x f g |
	P _ É polynomials.
	x _ P x.
	f _ x.
	g _ 1 - x.
	self assert: f // g = (P !! -1).
	self assert: f \\ g = (P !! 1)! !

!PolynomialTest methodsFor: 'division' stamp: 'len 5/23/2020 09:34:55'!
testDivisionZ4
	| P x f g |
	P _ É polynomials.
	x _ P x.
	f _ x.
	g _ 1 + x.
	self assert: f // g = (P !! 1).
	self assert: f \\ g = (P !! -1)! !

!PolynomialTest methodsFor: 'division' stamp: 'len 5/23/2020 09:34:55'!
testDivisionZ5
	| P x f g |
	P _ É polynomials.
	x _ P x.
	f _ x*4.
	g _ x*2.
	self assert: f // g = (P !! 2).
	self assert: f \\ g = (P !! 0)! !

!PolynomialTest methodsFor: 'division' stamp: 'len 5/23/2020 09:34:55'!
testDivisionZ6
	| P x f g |
	P _ É polynomials.
	x _ P x.
	f _ x*4.
	g _ x*3.
	self assert: f // g = (P !! 1).
	self assert: f \\ g = x! !

!PolynomialTest methodsFor: 'division' stamp: 'len 5/23/2020 09:34:55'!
testDivisionZ7
	| P x f g |
	P _ É polynomials.
	x _ P x.
	f _ x*4+1.
	g _ x^2*3.
	self assert: f // g = (P !! 0).
	self assert: f \\ g = f! !

!PolynomialTest methodsFor: 'division' stamp: 'len 5/23/2020 09:34:55'!
testDivisionZ8
	| P x f g |
	P _ É polynomials.
	x _ P x.
	f _ x*(-10).
	g _ x*(-9).
	self assert: f // g = (P !! 1).
	self assert: f \\ g = x negated! !

!PolynomialTest methodsFor: 'division' stamp: 'len 5/23/2020 09:34:55'!
testDivisionZ9
	| P x f g |
	P _ É polynomials.
	x _ P x.
	f _ x*(-10).
	g _ x*(-3).
	self assert: f // g = (P !! 3).
	self assert: f \\ g = (x*(-1))! !

!PolynomialTest methodsFor: 'division' stamp: 'len 5/23/2020 09:34:55'!
testExactDivisionBug
	| Zx x f |
	Zx _ É polynomials.
	x _ Zx x.
	f _ x*2.
	self assert: f ˜ f = Zx one! !

!PolynomialTest methodsFor: 'division' stamp: 'len 5/23/2020 09:33:01'!
testExactDivisionMultivariate
	| Qxy x y f g |
	Qxy _ Ñ polynomialsIn: #(x y).
	x _ Qxy x.
	y _ Qxy y.
	f _ x-y.
	g _ x+y.
	self assert: f * g ˜ g = f.
	self assert: f * g ˜ f = g! !

!PolynomialTest methodsFor: 'division' stamp: 'len 5/23/2020 09:33:01'!
testExactDivisionMultivariate2
	| Qxy x y f g |
	Qxy _ Ñ polynomialsIn: #(x y).
	x _ Qxy x.
	y _ Qxy y.
	f _ x-y.
	g _ x+y.
	self assert: (f * g divisionBy: g) quotient = f.
	self assert: (f * g divisionBy: f) quotient = g! !

!PolynomialTest methodsFor: 'division' stamp: 'len 5/23/2020 09:33:01'!
testExactDivisionQ
	| x f g |
	x _ Ñ polynomials x.
	f _ x^2 + x + 1.
	g _ 1 - x.
	self assert: f * g ˜ g = f.
	self assert: f * g ˜ f = g! !

!PolynomialTest methodsFor: 'division' stamp: 'len 5/23/2020 09:33:01'!
testExactDivisionQRandom
	| Qx f g |
	Qx _ Ñ polynomials.
	f _ Qx atRandomBits: 100 maxDegree: (1 to: 10) atRandom.
	g _ Qx atRandomBits: 100 maxDegree: (1 to: 10) atRandom.
	self assert: f * g ˜ g = f.
	self assert: f * g ˜ f = g! !

!PolynomialTest methodsFor: 'division' stamp: 'len 5/23/2020 09:34:55'!
testExactDivisionZ
	| x f g |
	x _ É polynomials x.
	f _ x^2 + x + 1.
	g _ 1 - x.
	self assert: f * g ˜ g = f.
	self assert: f * g ˜ f = g! !

!PolynomialTest methodsFor: 'division' stamp: 'len 5/23/2020 09:34:55'!
testMultivariateDivision
	"Example from Cox IVA 62 p."
	| Zxy x y f f1 f2 division |
	Zxy _ É polynomialsIn: #(x y) ordering: (MonomialOrdering lex: #(2 1)).
	x _ Zxy x.
	y _ Zxy y.
	f _ x*(y^2)+1.
	f1 _ x*y+1.
	f2 _ y+1.
	division _ f divisionBy: {f1. f2}.
	self assert: division quotients = {y. y one negated}.
	self assert: division remainder = (y one * 2).
	self assert: division verify! !

!PolynomialTest methodsFor: 'division' stamp: 'len 5/23/2020 09:34:55'!
testMultivariateDivision2
	"Example from Cox IVA 63 p."
	| Zxy x y f f1 f2 division |
	Zxy _ É polynomialsIn: #(x y) ordering: (MonomialOrdering lex: #(2 1)).
	x _ Zxy x.
	y _ Zxy y.
	f _ x^2*y + (x*(y^2)) + (y^2).
	f1 _ x*y-1.
	f2 _ y^2-1.
	division _ f divisionBy: {f1. f2}.
	self assert: division quotients = {x+y. y one}.
	self assert: division remainder = (x+y+1).
	self assert: division verify! !

!PolynomialTest methodsFor: 'division' stamp: 'len 5/23/2020 09:34:55'!
testMultivariateDivision3
	"Example from Cox IVA 67 p."
	| Zxy x y f f1 f2 division |
	Zxy _ É polynomialsIn: #(x y) ordering: (MonomialOrdering lex: #(2 1)).
	x _ Zxy x.
	y _ Zxy y.
	f _ x^2*y + (x*(y^2)) + (y^2).
	f1 _ x*y-1.
	f2 _ y^2-1.
	division _ f divisionBy: {f2. f1}.
	self assert: division quotients = {x+1. x}.
	self assert: division remainder = (x*2+1).
	self assert: division verify! !

!PolynomialTest methodsFor: 'division' stamp: 'len 5/23/2020 09:34:55'!
testPseudoDivision1
	| Zxy x y division |
	Zxy _ É polynomialsIn: #(x y).
	x _ Zxy x.
	y _ Zxy y.
	division _ x^2 + (y^2) pseudoDivisionBy: y - x in: 2.
	self assert: division quotient asMultivariate = (x + y).
	self assert: division remainder asMultivariate = (x^2 * 2).
	self assert: division verify! !

!PolynomialTest methodsFor: 'division' stamp: 'len 5/23/2020 09:33:01'!
testPseudoDivision2
	| Zxy x y division |
	Zxy _ Ñ polynomialsIn: #(x y).
	x _ Zxy x.
	y _ Zxy y.
	division _ x^2 + (y^2) pseudoDivisionBy: (y-x)*2 in: 2.
	self assert: division quotient asMultivariate = ((x+y) * 2).
	self assert: division remainder asMultivariate = (x^2 * 8).
	self assert: division verify! !

!PolynomialTest methodsFor: 'division' stamp: 'len 5/23/2020 09:34:55'!
testPseudoDivision3
	| Zxy x y division |
	Zxy _ É polynomialsIn: #(x y).
	x _ Zxy x.
	y _ Zxy y.
	division _ x^2 + (y^2) pseudoDivisionBy: y - x in: 2.
	self assert: division quotient asMultivariate = (x + y).
	self assert: division remainder asMultivariate = (x^2 * 2).
	self assert: division verify.

	division _ x^2 + (y^2) pseudoDivisionBy: x - y in: 2.
	self assert: division quotient asMultivariate = (x + y) negated.
	self assert: division remainder asMultivariate = (x^2 * 2).
	self assert: division verify! !

!PolynomialTest methodsFor: 'division' stamp: 'len 5/12/2020 12:33:15'!
testPseudoDivision: R
	| Rx f g division |
	Rx _ R polynomials.
	f _ Rx atRandomBits: 50 maxDegree: 5 atRandom.
	[g _ Rx atRandomBits: 50 maxDegree: 5 atRandom. g isZero] whileTrue.
	division _ f pseudoDivisionBy: g.
	self assert: division verify! !

!PolynomialTest methodsFor: 'division' stamp: 'len 5/23/2020 09:33:01'!
testPseudoDivisionOverPolynomialRing1
	self testPseudoDivision: Ñ polynomials! !

!PolynomialTest methodsFor: 'division' stamp: 'len 5/23/2020 09:33:01'!
testPseudoDivisionOverPolynomialRing2
	self testPseudoDivision: (Ñ polynomialsIn: 2)! !

!PolynomialTest methodsFor: 'division' stamp: 'len 5/23/2020 09:34:55'!
testPseudoDivisionUnivariate
	| Zx x division |
	Zx _ É polynomials.
	x _ Zx x.
	division _ x^3 + x + 1 pseudoDivisionBy: (x^2 * 3) + x + 1.
	self assert: division quotient = (x*3 - 1).
	self assert: division remainder = (x*7 + 10).
	self assert: division delta = 2.
	self assert: division verify! !

!PolynomialTest methodsFor: 'division' stamp: 'len 5/23/2020 09:34:55'!
testPseudoDivisionUnivariate2
	"Example from Zippel book"
	| Zx a b |
	Zx _ É polynomials.
	a _ Zx coefficients: #(1 0 1 0 -3 -3 8 2 -5) reversed.
	b _ Zx coefficients: #(3 0 5 0 -4 -9 21) reversed.
	^ self assert: (a pseudoDivisionBy: b) verify! !

!PolynomialTest methodsFor: 'division' stamp: 'len 5/23/2020 09:34:55'!
testPseudoDivisionZ
	self testPseudoDivision: É! !

!PolynomialTest methodsFor: 'division' stamp: 'len 5/23/2020 09:34:55'!
testPseudoDivisionZ12
	self testPseudoDivision: É / 12! !

!PolynomialTest methodsFor: 'division' stamp: 'len 5/23/2020 09:34:55'!
testPseudoDivisionZ6
	self testPseudoDivision: É / 6! !

!PolynomialTest methodsFor: 'division' stamp: 'len 5/23/2020 09:34:55'!
testPseudoDivisionZ8
	self testPseudoDivision: É / 8! !

!PolynomialTest methodsFor: 'division' stamp: 'len 5/23/2020 09:34:55'!
testPseudoRemainder
	| Zx x a b r |
	Zx _ É polynomials.
	x _ Zx x.
	a _ x^8 + (x^6) - (3*(x^4)) - (3*(x^3)) + (8*(x^2)) + (2*x) - 5.
	b _ 3*(x^6) + (5*(x^4)) - (4*(x^2)) - (9*x) + 21.
	r _ Zx coefficients: #(-9 0 3 0 -15).
	self assert: (a pseudoRem: b) = r.
	self assert: (a pseudoDivisionBy: b) remainder = r! !

!PolynomialTest methodsFor: 'division' stamp: 'len 5/23/2020 09:34:55'!
testRemainderInconsistency
	"In Sage these two give the same result (1), same in Magma."
	| X x |
	X _ É polynomials x.
	x _ Ñ polynomials x.
	self assert: (x \\ (1 - x)) leadingCoefficient = (X \\ (1 - X)) leadingCoefficient! !

!PolynomialTest methodsFor: 'remainder sequences' stamp: 'len 5/23/2020 09:34:55'!
testEPRS
	"Example from Zippel."
	| a b eprs |
	a _ É polynomials coefficients: #(1 0 1 0 -3 -3 8 2 -5) reversed.
	b _ É polynomials coefficients: #(3 0 5 0 -4 -9 21) reversed.
	eprs _ a eprs: b :: collect: [:each| each coefficients reversed asArray] :: asArray.
	self assert: eprs = #((1 0 1 0 -3 -3 8 2 -5)
		(3 0 5 0 -4 -9 21)
		(-15 0 3 0 -9) 
		(15795 30375 -59535) 
		(1254542875143750 -1654608338437500) (12593338795500743100931141992187500))! !

!PolynomialTest methodsFor: 'remainder sequences' stamp: 'len 5/23/2020 09:34:55'!
testPPRS
	"Example from Zippel."
	| a b pprs |
	a _ É polynomials coefficients: #(1 0 1 0 -3 -3 8 2 -5) reversed.
	b _ É polynomials coefficients: #(3 0 5 0 -4 -9 21) reversed.
	pprs _ a pprs: b :: collect: [:each| each coefficients reversed asArray] :: asArray.
	self assert: pprs = #((1 0 1 0 -3 -3 8 2 -5) 
		(3 0 5 0 -4 -9 21)
		(-5 0 1 0 -3)
		(13 25 -49)
		(4663 -6150)
		(1))! !

!PolynomialTest methodsFor: 'remainder sequences' stamp: 'len 5/23/2020 09:34:55'!
testSPRS
	"Example from Zippel."
	| a b sprs |
	a _ É polynomials coefficients: #(1 0 1 0 -3 -3 8 2 -5) reversed.
	b _ É polynomials coefficients: #(3 0 5 0 -4 -9 21) reversed.
	sprs _ a sprs: b :: collect: [:each| each coefficients reversed asArray] :: asArray.
	self assert: sprs = #((1 0 1 0 -3 -3 8 2 -5)
		#(3 0 5 0 -4 -9 21)
		#(15 0 -3 0 9)
		#(65 125 -245)
		#(9326 -12300)
		#(260708))
! !

!PolynomialTest methodsFor: 'evaluation' stamp: 'len 5/23/2020 09:34:55'!
testEvaluationHomomorphism
	| Zx f g a |
	Zx _ É polynomials.
	f _ Zx atRandomBits: 1000 maxDegree: 10.
	g _ Zx atRandomBits: 1000 maxDegree: 10.
	a _ É atRandomBits: 100.
	self assert: (f+g value: a) = ((f value: a) + (g value: a)).
	self assert: (f-g value: a) = ((f value: a) - (g value: a)).
	self assert: (f*g value: a) = ((f value: a) * (g value: a)).
	self assert: (f^3 value: a) = ((f value: a)^3)! !

!PolynomialTest methodsFor: 'evaluation' stamp: 'len 3/31/2016 06:56'!
testEvaluationHomomorphism: F
	| Fx f g a |
	Fx _ F polynomials.
	f _ Fx atRandomDegree: 10 atRandom.
	g _ Fx atRandomDegree: 10 atRandom.
	a _ F atRandom.
	self assert: (f+g value: a) = ((f value: a) + (g value: a)).
	self assert: (f-g value: a) = ((f value: a) - (g value: a)).
	self assert: (f*g value: a) = ((f value: a) * (g value: a)).
	self assert: (f^3 value: a) = ((f value: a)^3)! !

!PolynomialTest methodsFor: 'evaluation' stamp: 'len 5/23/2020 09:34:55'!
testEvaluationHomomorphismMultivariate
	| Zxyz f g a |
	Zxyz _ É polynomialsIn: #(x y z).
	f _ Zxyz atRandomBits: 1000 maxDegree: 10.
	g _ Zxyz atRandomBits: 1000 maxDegree: 10.
	a _ É atRandomTuple: 3 bits: 100.
	self assert: (f+g value: a) = ((f value: a) + (g value: a)).
	self assert: (f-g value: a) = ((f value: a) - (g value: a)).
	self assert: (f*g value: a) = ((f value: a) * (g value: a)).
	self assert: (f^3 value: a) = ((f value: a)^3)! !

!PolynomialTest methodsFor: 'evaluation' stamp: 'len 10/18/2016 21:01'!
testEvaluationHomomorphismZ2
	self testEvaluationHomomorphism: (PrimeField new: 2)! !

!PolynomialTest methodsFor: 'evaluation' stamp: 'len 5/23/2020 09:34:55'!
testEvaluationHomomorphismZm
	self testEvaluationHomomorphism: É / (2 + 100 atRandom).
	self testEvaluationHomomorphism: É / (2^13 - 2).
	self testEvaluationHomomorphism: É / (2^31 - 2)! !

!PolynomialTest methodsFor: 'evaluation' stamp: 'len 12/2/2016 11:17:17'!
testEvaluationHomomorphismZp
	self testEvaluationHomomorphism: (PrimeField new: 3).
	self testEvaluationHomomorphism: (PrimeField new: 5).
	self testEvaluationHomomorphism: (PrimeField new: 2^13 - 1).
	self testEvaluationHomomorphism: (PrimeField new: 2^31 - 1)! !

!PolynomialTest methodsFor: 'evaluation' stamp: 'len 5/23/2020 09:34:55'!
testEvaluationMultivariate
	| Zxyz f a x y z |
	Zxyz _ É polynomialsIn: #(x y z).
	x _ Zxyz x. y _ Zxyz y. z _ Zxyz z.
	f _ x^2 * y - z.
	a _ É atRandomTuple: 3 bits: 100.
	self assert: (f value: a) = ((a at: 1)^2 * (a at: 2) - (a at: 3))! !

!PolynomialTest methodsFor: 'factorization' stamp: 'len 5/23/2020 09:34:55'!
testFiniteFieldFactorization
	| F Fx x one f factors |
	F _ É / 3.
	Fx _ F polynomials.
	x _ Fx x.
	one _ Fx one.
	f _ x^11 + (x^9 * 2) + (x^8 * 2) + (x^6) + (x^5) + (x^3 * 2) + (x^2 * 2) + one.
	factors _ f factors.
	self assert: factors size = 8.
	self assert: (factors occurrencesOf: x + (one*2)) = 4.
	self assert: (factors occurrencesOf: x^2 + one) = 3.
	self assert: (factors occurrencesOf: x + one) = 1.
	self assert: (factors inject: Fx one into: [:a :b| a*b]) = f! !

!PolynomialTest methodsFor: 'factorization' stamp: 'len 5/23/2020 09:34:55'!
testFiniteFieldFactorization2
	| Z3 x f factors |
	Z3 _ É / 3.
	x _ Z3 polynomials x.
	f _ (x-1)^2*(x-2).
	factors _ f factors.
	self assert: factors size = 3.
	self assert: (factors occurrencesOf: x-1) = 2.
	self assert: (factors occurrencesOf: x-2) = 1! !

!PolynomialTest methodsFor: 'factorization' stamp: 'len 4/9/2018 21:30:09'!
testFiniteFieldFactorization3
	| F9 x f factors |
	F9 _ GaloisField new: (3^2).
	x _ F9 polynomials x.
	f _ (x-1)^2*(x-2).
	factors _ f factors.
	self assert: factors size = 3.
	self assert: (factors occurrencesOf: x-1) = 2.
	self assert: (factors occurrencesOf: x-2) = 1! !

!PolynomialTest methodsFor: 'factorization' stamp: 'len 5/23/2020 09:34:55'!
testFiniteFieldFactorization4
	| R x f factors |
	R _ É / 2.
	x _ R polynomials x.
	f _ x^24 - 1.
	factors _ f factors.
	self assert: factors size = 16.
	self assert: (factors occurrencesOf: x+1) = 8.
	self assert: (factors occurrencesOf: x^2+x+1) = 8! !

!PolynomialTest methodsFor: 'factorization' stamp: 'len 5/23/2020 09:34:55'!
testFiniteFieldFactorization5
	| R x |
	R _ É / 2.
	x _ R polynomials x.
	self assert: (x^15 - 1) factors = {x + 1. x^2 + x + 1. x^4 + (x^3) + (x^2) + x + 1. x^4 + x + 1. x^4 + (x^3) + 1} asBag! !

!PolynomialTest methodsFor: 'factorization' stamp: 'len 5/23/2020 09:34:55'!
testFiniteFieldIrreduciblePolynomials
	"Z/<3>[x] has 8 irreducible monic polynomials of degree 3, out of 27 monic polynomials of degree 3."
	| F Fx f count |
	F _ É / 3.
	Fx _ F polynomials.
	count _ 0.
	F tuples: 3 do: [:each|
		f _ (Fx coefficients: each, F one).
		f isIrreducible
			ifTrue:
				[count _ count + 1.
				self assert: f factors size = 1]
			ifFalse:
				[self assert: f factors size > 1]].
	self assert: count = 8! !

!PolynomialTest methodsFor: 'factorization' stamp: 'len 5/23/2020 09:34:55'!
testFiniteFieldIsIrreducible
	| F Fx x f |
	F _ É / 3.
	Fx _ F polynomials.
	x _ Fx x.
	f _ x^3 + (x*2) + 1.
	self assert: f factors size = 1.
	self assert: f isIrreducible! !

!PolynomialTest methodsFor: 'factorization' stamp: 'len 5/23/2020 09:34:55'!
testFiniteFieldSFF
	| F Fx x one f factors |
	F _ É / 3.
	Fx _ F polynomials.
	x _ Fx x.
	one _ Fx one.
	f _ x^11 + (x^9 * 2) + (x^8 * 2) + (x^6) + (x^5) + (x^3 * 2) + (x^2 * 2) + one.
	factors _ f squareFreeFactorization.
	self assert: factors size = 8.
	self assert: (factors occurrencesOf: x + (one*2)) = 4.
	self assert: (factors occurrencesOf: x^2 + one) = 3.
	self assert: (factors occurrencesOf: x + one) = 1! !

!PolynomialTest methodsFor: 'factorization' stamp: 'len 5/23/2020 09:34:55'!
testIntegerFactorization
	| x f factors |
	x _ É polynomials x.
	f _ (x*2-1)^2*(x-2)*(x^2 + 1)*(x^2-2)*18.
	factors _ f factors.
	self assert: factors size = 8.
	self assert: factors asSet size = 6.
	self assert: factors product = f! !

!PolynomialTest methodsFor: 'factorization' stamp: 'len 5/23/2020 09:33:01'!
testRationalFactorization
	| x f factors |
	x _ Ñ polynomials x.
	f _ (x-(1/2))^2*(x-2)*(x^2 + 1)*(x^2-2).
	factors _ f factors.
	self assert: factors size = 5.
	self assert: factors asSet size = 4.
	self assert: factors product monic = f monic "up to a unit"! !

!PolynomialTest methodsFor: 'roots' stamp: 'len 5/23/2020 09:34:55'!
testFiniteFieldRoots
	| Z3 x f roots |
	Z3 _ É / 3.
	x _ Z3 polynomials x.
	f _ (x-1)^2*(x-2).
	roots _ f allRoots.
	self assert: roots size = 3.
	self assert: (roots occurrencesOf: (Z3 project: 1)) = 2.
	self assert: (roots occurrencesOf: (Z3 project: 2)) = 1! !

!PolynomialTest methodsFor: 'roots' stamp: 'len 5/23/2020 09:33:01'!
testRationalRoots
	| x f roots |
	x _ Ñ polynomials x.
	f _ (x-(1/2))^2*(x-2)*(x^2 + 1)*(x^2-2).
	roots _ f allRoots.
	self assert: roots size = 3.
	self assert: (roots occurrencesOf: 1/2) = 2.
	self assert: (roots occurrencesOf: 2) = 1! !

!PolynomialTest methodsFor: 'roots' stamp: 'len 5/23/2020 09:33:01'!
testRationalRootsBug
	| x f roots |
	x _ Ñ polynomials x.
	f _ x^3*-1 + (3*x) + 2.
	roots _ f allRoots.
	self assert: roots size = 3.
	self assert: (roots occurrencesOf: -1) = 2.
	self assert: (roots occurrencesOf: 2) = 1! !

!PolynomialTest methodsFor: 'roots' stamp: 'len 5/23/2020 09:33:01'!
testRealRoots
	| x f roots |
	x _ Ñ polynomials x.
	f _ (x-(1/2))^2*(x-2)*(x^2 + 1)*(x^2-2).
	roots _ f allRootsIn: Ö.
	self assert: roots size = 5.
	self assert: roots asSet size = 4.
	self assert: (roots occurrencesOf: 1/2) = 2.
	self assert: (roots occurrencesOf: 2) = 1! !

!PolynomialTest methodsFor: 'etc' stamp: 'len 5/23/2020 09:34:55'!
testAllMonomialsOfDegree
	| d n |
	n _ 5 atRandom.
	d _ 5 atRandom.
	self assert: (É polynomialsIn: n :: allMonomialsOfDegree: d) size = (n+d-1 choose: d)! !

!PolynomialTest methodsFor: 'etc' stamp: 'len 5/23/2020 09:33:01'!
testCRT
	| x f1 f2 f3 crt r1 r2 r3 h |
	x _ Ñ polynomials x.
	f1 _ x^5 + 1.
	f2 _ x^2 + 1.
	f3 _ x - 1.
	crt _ CRT mod: {f1. f2. f3}.
	r1 _ x-1.
	r2 _ x+1.
	r3 _ x-x. "zero"
	h _ crt solve: {r1. r2. r3}.
	self assert: h \\ f1 = r1.
	self assert: h \\ f2 = r2.
	self assert: h \\ f3 = r3! !

!PolynomialTest methodsFor: 'etc' stamp: 'len 5/23/2020 09:33:01'!
testCompanionMatrix
	| x p |
	x _ Ñ polynomials x.
	p _ x^2 + (x*2) - 1.
	self assert: p companion characteristicPolynomial = p.
	self assert: p companion minimalPolynomial = p! !

!PolynomialTest methodsFor: 'etc' stamp: 'len 5/23/2020 09:34:55'!
testDiscriminant
	| Zx x f g |
	Zx _ É polynomials.
	x _ Zx x.
	f _ x^2 + x + 1.
	g _ x^3 + 1.
	self assert: (f*g) discriminant = (f discriminant * g discriminant * (f resultant: g) squared)! !

!PolynomialTest methodsFor: 'etc' stamp: 'len 5/23/2020 09:34:55'!
testDiscriminant2
	| Zx x f |
	Zx _ É polynomials.
	x _ Zx x.
	f _ x^2 - x - 36042.
	self assert: f discriminant = 144169 "this is a prime, although looks like a square :)"! !

!PolynomialTest methodsFor: 'etc' stamp: 'len 5/23/2020 09:34:55'!
testDomainError
	| f g |
	f _ É polynomials atRandomBits: 10.
	self should: [f / 2] raise: DomainError.
	g _ Ñ polynomials atRandomBits: 100 maxDegree: 5. "will have denominators"
	self should: [f + g] raise: DomainError.
	self should: [f * g] raise: DomainError! !

!PolynomialTest methodsFor: 'etc' stamp: 'len 5/23/2020 09:34:55'!
testGaussLemma
	"Lemma (Gauss): The product of two primitive polynomials is primitive."
	| Zx f g |
	Zx _ É polynomials.
	f _ Zx atRandomBits: 100 maxDegree: (5 to: 10) atRandom.
	g _ Zx atRandomBits: 100 maxDegree: (5 to: 10) atRandom.
	self assert: (f primitivePart * g primitivePart) isPrimitive! !

!PolynomialTest methodsFor: 'etc' stamp: 'len 5/23/2020 09:33:01'!
testHeight
	| x |
	x _ Ñ polynomials x.
	self assert: (x * 2 - 5) height =  5.
	self assert: (x * 5 - 2) height =  5! !

!PolynomialTest methodsFor: 'etc' stamp: 'len 5/23/2020 09:33:01'!
testInclusionInFractionField
	| R F |
	R _ Ñ polynomials.
	F _ R fractions.
	self assert: R <= F.
	self assert: F >= R.
	self deny: R >= F.
	self deny: F <= R! !

!PolynomialTest methodsFor: 'etc' stamp: 'len 5/23/2020 09:33:01'!
testInterpolation
	| Qx f |
	Qx _ Ñ polynomials.
	f _ Qx interpolate: {1 -> 2. 2 -> 3. 4 -> 5}.
	self assert: (f value: 1) = 2.
	self assert: (f value: 2) = 3.
	self assert: (f value: 4) = 5! !

!PolynomialTest methodsFor: 'etc' stamp: 'len 5/23/2020 09:33:01'!
testInterpolation2
	| Qx f |
	Qx _ Ñ polynomials.
	f _ Qx interpolate: {1 -> 2. 2 -> 4. 3 -> 9}.
	self assert: (f value: 1) = 2.
	self assert: (f value: 2) = 4.
	self assert: (f value: 3) = 9! !

!PolynomialTest methodsFor: 'etc' stamp: 'len 5/23/2020 09:34:55'!
testIsIrreducible
	"The polynomial x^4 + 1 is irreducible in Z[x] and Q[x], and it is reducible Z/p[x] for all prime numbers p."
	| p |
	self assert: (É polynomials !! [:x| x^4 + 1] :: isIrreducible).
	self assert: (Ñ polynomials !! [:x| x^4 + 1] :: isIrreducible).
	p _ 1000 atRandom nextPrime.
	self deny: (É/p :: polynomials !! [:x| x^4 + 1] :: isIrreducible)! !

!PolynomialTest methodsFor: 'etc' stamp: 'len 5/23/2020 09:33:01'!
testIsIrreducibleOverQ
	| x f |
	x _ Ñ polynomials x.
	f _ x^4 + 1.
	self assert: f isIrreducible.
	self assert: f negated isIrreducible.
	self assert: (f*2) isIrreducible.
	self assert: (f*(x+1)) isIrreducible not! !

!PolynomialTest methodsFor: 'etc' stamp: 'len 5/23/2020 09:34:55'!
testIsIrreducibleOverZ
	| x f |
	x _ É polynomials x.
	f _ x^4 + 1.
	self assert: f isIrreducible.
	self assert: f negated isIrreducible.
	self assert: (f*2) isIrreducible not.
	self assert: (f*(x+1)) isIrreducible not.
! !

!PolynomialTest methodsFor: 'etc' stamp: 'len 5/23/2020 09:34:55'!
testIsNilpotentOverZm
	| m R N U d f k |
	m _ (2 to: 100) atRandom.
	R _ É/m.
	N _ R nilradical asSet.
	U _ R units asSet.
	d _ (1 to: 5) atRandom.
	f _ R polynomials coefficients: ((1 to: d) collect: [:i| N atRandom]).
	self assert: f isNilpotent.
	k _ (1 to: d) atRandom.
	f _ R polynomials coefficients: ((1 to: d) collect: [:i| i=k ifTrue: [U atRandom] ifFalse: [N atRandom]]).
	self assert: f isNilpotent not! !

!PolynomialTest methodsFor: 'etc' stamp: 'len 5/23/2020 09:34:55'!
testIsSeparableNot
	"A tipical example of a polynomial that is NOT separable."
	| p F x Fy y f |
	p _ 5. "any prime p"
	F _ É/p :: polynomials fractions.
	x _ F x.
	Fy _ F polynomialsIn: #(y).
	y _ Fy x.
	f _ y^p - x.
	self assert: f isSeparable not! !

!PolynomialTest methodsFor: 'etc' stamp: 'len 5/23/2020 09:34:55'!
testIsUnitOverZm
	| m R N U d f k |
	m _ (2 to: 100) atRandom.
	R _ É/m.
	N _ R nilradical asSet.
	U _ R units asSet.
	d _ (0 to: 5) atRandom.
	f _ R polynomials coefficients: ({U atRandom}, ((1 to: d) collect: [:i| N atRandom])).
	self assert: f isUnit.
	f _ R polynomials coefficients: ({N atRandom}, ((1 to: d) collect: [:i| N atRandom])).
	self assert: f isUnit not.
	d _ (1 to: 5) atRandom.
	k _ (1 to: d) atRandom.
	f _ R polynomials coefficients: ({U atRandom}, ((1 to: d) collect: [:i| i=k ifTrue: [U atRandom] ifFalse: [N atRandom]])).
	self assert: f isUnit not! !

!PolynomialTest methodsFor: 'etc' stamp: 'len 5/23/2020 09:34:55'!
testQuotientRingBug
	"This is fixed by making ideals of Z[x] have generators with positive leading coefficient. But it could be still a problem for polynomials over other rings."
	| R f Q pi a b |
	R _ É polynomials.
	f _ R !! [:x| x^2*-1 - 1].
	Q _ R/f.
	pi _ Q projection.
	a _ R x - 1.
	b _ R x^2 + 1.
	self assert: (pi value: a) + (pi value: b) = (pi value: a+b)! !

!PolynomialTest methodsFor: 'etc' stamp: 'len 5/23/2020 09:34:55'!
testResultant
	| Zx x f g f2 g2 h |
	Zx _ É polynomials.
	x _ Zx x.
	f _ x^2 + x + 1.
	f2 _ f * (x + 2).
	g _ x^3 + 1.
	g2 _ g * (x + 2).
	h _ x^4 + 1.
	self assert: (f resultant: g) isZero not. "not 0 because f and g have no common roots"
	self assert: (f2 resultant: g2) isZero. "res(f2,g2) = 0 because f2 and g2 have a common root -2."
	self assert: (-1)^(f degree * g degree) * (f resultant: g) = (g resultant: f).
	self assert: (f * g resultant: h) = ((f resultant: h) * (g resultant: h))! !

!PolynomialTest methodsFor: 'etc' stamp: 'len 5/23/2020 09:34:55'!
testResultant2
	| Zx x f g |
	Zx _ É polynomials.
	x _ Zx x.
	f _ 2 * (x - 5) * (x - 11).
	g _ 3 * (x - 7).
	self assert: (f resultant: g) = ((2 ^ 1) * (3^2) * (5 - 7) * (11 - 7))! !

!PolynomialTest methodsFor: 'etc' stamp: 'len 5/23/2020 09:34:55'!
testShift
	| Zx x f |
	Zx _ É polynomials.
	x _ Zx x.
	f _ Zx atRandomBits: 10.
	self assert: (f shift: 10) degree = (f degree + 10).
	self assert: ((f shift: 10) shift: -10) = f.
	self assert: f * (x^3) = (f shift: 3).
	self assert: (f * (x^3) shift: -3) = f! !

!PolynomialTest methodsFor: 'etc' stamp: 'len 5/23/2020 09:33:01'!
testSquareFree
	| P x f1 f2 f3 f |
	P _ Ñ polynomials.
	x _ P x.
	f1 _ x^2 + x + 1.
	f2 _ 1 - x.
	f3 _ x - 2.
	f _ f1*f1*f2*f3*f3*f3.
	self assert: f squareFree = (f1 * f2 * f3)! !

!PolynomialTest methodsFor: 'etc' stamp: 'len 5/23/2020 09:33:01'!
testSquareFreeMultivariate
	| P x y f1 f2 f |
	P _ Ñ polynomialsIn: #(x y).
	x _ P x.
	y _ P y.
	f1 _ x + 1.
	f2 _ y + 1.
	f _ f1*f1*f2*f2.
	self assert: f squareFree = (f1 * f2)! !

!PolynomialTest methodsFor: 'etc' stamp: 'len 5/23/2020 09:34:55'!
testSubresultant
	"deg(gcd(f,g)) = d iff subresultant(f,g,k) = 0 for all k < d and subresultant(f,g,d) ~= 0, and the d-th subresultant coefficient is in fact a gcd of f and g."
	| x f g |
	x _ É polynomials x.
	f _ (x^4 - 1)*6.
	g _ (x^6 - 1)*9.
	"self assert: (f gcd: g) = ((x^2 - 1)*3)"
	self assert: (f subresultant: 0 with: g) isZero.
	self assert: (f subresultant: 1 with: g) isZero.
	self assert: (f subresultant: 2 with: g) isZero not.
	self assert: (f subresultant: 2 with: g) primitivePart = (x^2 - 1)! !

!PolynomialTest methodsFor: 'etc' stamp: 'len 5/23/2020 09:34:55'!
testSubresultant0
	| Zx x f g |
	Zx _ É polynomials.
	x _ Zx x.
	f _ 2 * (x - 5) * (x - 11).
	g _ 3 * (x - 7).
	self assert: (f resultant: g) = (f subresultant: 0 with: g) asScalar! !

!PolynomialTest methodsFor: 'etc' stamp: 'len 5/23/2020 09:34:55'!
testUnitAndAssociateBug1
	| R x f g |
	R _ É/6 :: polynomials.
	x _ R x.
	f _ x*3+2.
	g _ f*(-1).
	self assert: f normalized = g normalized! !

!PolynomialTest methodsFor: 'etc' stamp: 'len 5/23/2020 09:34:55'!
testUnitAndAssociateBug2
	| R x f u g |
	R _ É/4 :: polynomials.
	x _ R x.
	f _ x+1.
	u _ x*2+1.
	self assert: u isUnit.
	g _ f*u.
	self assert: f normalized = g normalized! !

!PolynomialTest methodsFor: 'etc' stamp: 'len 5/23/2020 09:33:01'!
testUnivariateMultivariateConversion
	| Qx x y f |
	Qx _ Ñ polynomialsIn: #(x y).
	x _ Qx x.
	y _ Qx y.
	f _ x^2*y.
	self assert: f asUnivariate asMultivariate = f.
"	self assert: (f asUnivariateIn: 1 :: asMultivariate) = f."
	self assert: (f asUnivariateIn: 2 :: asMultivariate) = f! !

!PolynomialTest methodsFor: 'etc' stamp: 'len 5/23/2020 09:33:01'!
testUnivariateMultivariateConversion2
	| Qx x y f f2 x0 y0 |
	Qx _ Ñ polynomialsIn: #(x y).
	x _ Qx x.
	y _ Qx y.
	f _ Qx zero.
	10 timesRepeat: [f _ f + (10 atRandom - 5 * (x ^ (3 atRandom - 1) * (y ^ (3 atRandom - 1))))].
	f2 _ f asUnivariate.
	self assert: f2 asMultivariate = f.
	x0 _ (-100 to: 100) atRandom.
	y0 _ (-100 to: 100) atRandom.
	self assert: ((f2 value: y0) value: x0) = (f value: {x0. y0})! !

!PolynomialTest methodsFor: 'etc' stamp: 'len 5/23/2020 09:33:01'!
testZeroCoefficientBug
	| Qx |
	Qx _ Ñ polynomials.
	self assert: (Qx one * 0) isZero! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:33:01'!
testArithmeticÑ
	self testArithmeticOver: Ñ! !

!PowerSeriesTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:33:01'!
cos
	"The power series expansion of cos(x)."
	^ Ñ powerSeries coefficients:
		(Sequence to: Ñ evaluating: [:n| n even ifTrue: [0] ifFalse: [|k| k _ n-1/2. (-1)^k / (2*k) factorial]])! !

!PowerSeriesTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:33:01'!
exp
	"The power series expansion of exp(x)."
	^ Ñ powerSeries
		coefficients: (Sequence to: Ñ evaluating: [:n| 1 / n factorial])! !

!PowerSeriesTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:33:01'!
sin
	"The power series expansion of sin(x)."
	^ Ñ powerSeries
		coefficients: (Sequence to: Ñ evaluating: [:n| n odd ifTrue: [0] ifFalse: [|k| k _ n/2-1. (-1)^k / (2*k+1) factorial]])! !

!PowerSeriesTest methodsFor: 'as yet unclassified' stamp: 'len 4/14/2020 18:10:55'!
testAddition
	| a b c |
	a _ self cos.
	b _ self sin.
	c _ a+b.
	self assert: c-a = b.
	self assert: c-b = a.
	self assert: (c + c negated) isZero.
	self assert: {c precision. c absolutePrecision. c relativePrecision} = #(20 20 20)! !

!PowerSeriesTest methodsFor: 'as yet unclassified' stamp: 'len 4/14/2020 18:14:48'!
testAdditiveInverse
	| a zero |
	a _ self cos.
	self assert: a negated negated = a.
	self assert: (a + a negated) isZero.
	zero _ a - a.
	self assert: zero isZero.
	self assert: zero negated = zero! !

!PowerSeriesTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:33:01'!
testLocalProperties
	| R |
	R _ Ñ powerSeries.
	self assert: R isLocal.
	self assert: R maximalIdeal = (R * R x)! !

!PowerSeriesTest methodsFor: 'as yet unclassified' stamp: 'len 5/3/2020 10:09:34'!
testMultiplicativeInverse
	| a one |
	a _ self cos.
	one _ a parent one.
	self assert: a * a inverse = one.
	self assert: one inverse = one! !

!PowerSeriesTest methodsFor: 'as yet unclassified' stamp: 'len 4/14/2020 18:11:21'!
testSinSquaredPlusCosSquared
	| cos sin |
	sin _ self sin.
	cos _ self cos.
	self assert: cos squared + sin squared = cos parent one! !

!RingTest methodsFor: 'euclidean' stamp: 'len 5/23/2020 09:34:55'!
testCongruenceSolving1
	| R a b solutions |
	R _ É/20.
	a _ R !! 11.
	b _ R !! 15.
	solutions _ a \ b.
	self assert: solutions first = (R !! 5).
	self assert: solutions size = 1! !

!RingTest methodsFor: 'euclidean' stamp: 'len 5/23/2020 09:34:55'!
testCongruenceSolving2
	| R a b solutions |
	R _ É/12167.
	a _ R !! 230.
	b _ R !! 1081.
	solutions _ a \ b.
	self assert: (solutions includes: (R !! 2491)).
	self assert: solutions size = 23.
	self assert: (solutions allSatisfy: [:x| a*x = b])! !

!RingTest methodsFor: 'euclidean' stamp: 'len 5/4/2020 06:15:35'!
testEuclideanRing: R
	"Test division on a pair of elements:"
	| a b q r |
	self assert: R isEuclidean.
	R size < 300 ifTrue: [self testSmallEuclideanRing: R].
	100 timesRepeat:
		[a _ R atRandomBits: 30.
		[b _ R atRandomBits: 30. b isZero] whileTrue.
		q _ a // b.
		r _ a \\ b.
		self assert: a = (q * b + r).
		self assert: (r isZero or: [r valuation < b valuation])]! !

!RingTest methodsFor: 'euclidean' stamp: 'len 6/19/2019 14:13:07'!
testGCD: R
	R size < 60 ifTrue: [self testGCDAll: R].
	self testGCDZero: R.
	100 timesRepeat:
		[| a b gcd |
		[(a _ R atRandomBits: 30) isZero] whileTrue.
		[(b _ R atRandomBits: 30) isZero] whileTrue.
		gcd _ a gcd: b.
		self assert: gcd | a.
		self assert: gcd | b.
		self assert: gcd = gcd normalized]! !

!RingTest methodsFor: 'euclidean' stamp: 'len 6/16/2019 17:22:36'!
testGCDAll: R
	R do: [:a|
		a isZero ifFalse:
			[R do: [:b|
				b isZero ifFalse:
					[| gcd |
					gcd _ a gcd: b.
					self assert: gcd | a.
					self assert: gcd | b.
					self assert: gcd = gcd normalized.
					R do: [:c| (c | a and: [c | b]) ifTrue: [self assert: c valuation <= gcd valuation]]]]]]! !

!RingTest methodsFor: 'euclidean' stamp: 'len 6/16/2019 16:43:23'!
testGCDZero: R
	| a gcd |
	a _ R atRandomBits: 100.
	gcd _ a gcd: R zero.
	self assert: gcd = (R zero gcd: a).
	self assert: gcd = a normalized.
	self assert: (R zero gcd: R zero) = R zero! !

!RingTest methodsFor: 'euclidean' stamp: 'len 5/4/2020 05:30:23'!
testGaloisRingGCD
	| R |
	R _ GaloisRing new: 3 atRandom nextPrime to: 2 atRandom to: 2 atRandom.
	self testGCD: R! !

!RingTest methodsFor: 'euclidean' stamp: 'len 5/3/2020 11:06:05'!
testGaloisRingIsEuclidean
	| R |
	R _ GaloisRing new: 3 atRandom nextPrime to: 2 atRandom to: 2 atRandom.
	self testEuclideanRing: R! !

!RingTest methodsFor: 'euclidean' stamp: 'len 5/12/2020 12:41:30'!
testGaloisRingLCM
	| R |
	R _ GaloisRing new: 3 atRandom nextPrime to: 2 atRandom to: 2 atRandom.
	self testLCM: R! !

!RingTest methodsFor: 'euclidean' stamp: 'len 5/18/2020 08:51:45'!
testIntegersXXGCD
	-100 to: 100 do: [:a|
		-100 to: 100 do: [:b|
			self testXXGCD: a with: b]]! !

!RingTest methodsFor: 'euclidean' stamp: 'len 6/19/2019 14:13:15'!
testLCM: R
	R size < 60 ifTrue: [self testLCMAll: R].
	self testLCMZero: R.
	100 timesRepeat:
		[| a b lcm |
		[(a _ R atRandomBits: 30) isZero] whileTrue.
		[(b _ R atRandomBits: 30) isZero] whileTrue.
		lcm _ a lcm: b.
		self assert: a | lcm.
		self assert: b | lcm.
		self assert: lcm = lcm normalized]! !

!RingTest methodsFor: 'euclidean' stamp: 'len 6/17/2019 04:40:57'!
testLCMAll: R
	R do: [:a|
		a isZero ifFalse:
			[R do: [:b|
				b isZero ifFalse:
					[| lcm |
					lcm _ a lcm: b.
					self assert: a | lcm.
					self assert: b | lcm.
					self assert: lcm = lcm normalized.
					R do: [:c| (c isZero not and: [a | c and: [b | c]]) ifTrue: [self assert: c valuation >= lcm valuation]]]]]]! !

!RingTest methodsFor: 'euclidean' stamp: 'len 6/17/2019 04:37:30'!
testLCMZero: R
	| a lcm |
	a _ R atRandomBits: 100.
	lcm _ a lcm: R zero.
	self assert: lcm = (R zero lcm: a).
	self assert: lcm = R zero.
	self assert: (R zero lcm: R zero) = R zero! !

!RingTest methodsFor: 'euclidean' stamp: 'len 5/23/2020 09:34:55'!
testModularIntegersEuclideanExample
	"Some random example built in Magma online calculator."
	| R a b c |
	R _ É/12.
	a _ R !! 2.
	b _ R !! 9.
	c _ a lcm: b.
	self assert: c = (R !! 6).
	self assert: c // a = (R !! 3).
	self assert: c // b = (R !! 10)! !

!RingTest methodsFor: 'euclidean' stamp: 'len 5/23/2020 09:34:55'!
testModularIntegersEuclideanExample2
	"Some random example built in Magma online calculator."
	| R a b |
	R _ É/39.
	a _ R !! 36.
	b _ R !! 3.
	self assert: a // b = (R !! 12)! !

!RingTest methodsFor: 'euclidean' stamp: 'len 5/23/2020 09:34:55'!
testModularIntegersEuclideanExample3
	"Some random example built in Magma online calculator."
	| R a b |
	R _ É/78.
	a _ R !! 9.
	b _ R !! 39.
	self assert: a // b = (R !! 0)! !

!RingTest methodsFor: 'euclidean' stamp: 'len 5/23/2020 09:34:55'!
testModularIntegersEuclideanExample4
	"Some random example built in Magma online calculator."
	| R a b |
	R _ É/230.
	a _ R !! 205.
	b _ R !! 128.
	self assert: (a gcd: b) = (R !! 1).
	self assert: (a lcm: b) = (R !! 10).! !

!RingTest methodsFor: 'euclidean' stamp: 'len 5/23/2020 09:34:55'!
testModularIntegersEuclideanExample5
	"Some random example built in Magma online calculator."
	| R a b |
	R _ É/10.
	a _ R !! 4.
	b _ R !! 8.
	self assert: b normalized = (R !! 2).
	self assert: b unit = (R !! 9).
	self assert: (a gcd: b) = (R !! 2).
	self assert: (a lcm: b) = (R !! 2)! !

!RingTest methodsFor: 'euclidean' stamp: 'len 5/23/2020 09:34:55'!
testModularIntegersEuclideanExample6
	"Some random example built in Magma online calculator."
	| R a b |
	R _ É/12.
	a _ R !! 4.
	b _ R !! 8.
	self assert: a // b = (R !! 11).
	self assert: b // a = (R !! 2)! !

!RingTest methodsFor: 'euclidean' stamp: 'len 5/23/2020 09:34:55'!
testModularIntegersEuclideanExample7
	"Some random example built in Magma online calculator."
	| R a b |
	R _ É/6.
	a _ R !! 4.
	b _ R !! 3.
	self assert: (a gcd: b) = (R !! 1).
	self assert: (a lcm: b) = (R !! 0)! !

!RingTest methodsFor: 'euclidean' stamp: 'len 5/23/2020 09:34:55'!
testModularIntegersEuclideanExample8
	"Some random example built in Magma online calculator."
	| R a b |
	R _ É/10.
	a _ R !! 6.
	b _ R !! 4.
	self assert: a // b = (R !! 4).
	self assert: b // a = (R !! 4)! !

!RingTest methodsFor: 'euclidean' stamp: 'len 5/23/2020 09:34:55'!
testModularIntegersEuclideanExample9
	"Some random example built in Magma online calculator."
	| R a b |
	R _ É/10.
	a _ R !! 2.
	b _ R !! 4.
	self assert: a // b = (R !! 8).
	self assert: b // a = (R !! 2)! !

!RingTest methodsFor: 'euclidean' stamp: 'len 5/23/2020 09:34:55'!
testModularIntegersRingGCD
	| R |
	R _ É/(2 to: 256) atRandom.
	self testGCD: R! !

!RingTest methodsFor: 'euclidean' stamp: 'len 5/23/2020 09:34:55'!
testModularIntegersRingIsEuclidean
	| R |
	R _ É/(2 to: 256) atRandom.
	self testEuclideanRing: R! !

!RingTest methodsFor: 'euclidean' stamp: 'len 5/23/2020 09:34:55'!
testModularIntegersRingLCM
	| R |
	R _ É/(2 to: 256) atRandom.
	self testLCM: R! !

!RingTest methodsFor: 'euclidean' stamp: 'len 5/23/2020 09:34:55'!
testModularIntegersXXGCD
	| R |
	R _ É/12.
	R do: [:a| R do: [:b| self testXXGCD: a with: b]]! !

!RingTest methodsFor: 'euclidean' stamp: 'len 5/23/2020 09:33:01'!
testPolynomialsOverFieldGCD
	| F R |
	F _ 2 atRandom = 1 ifTrue: [Ñ] ifFalse: [GaloisField new: 5 atRandom nextPrime to: 3 atRandom].
	R _ F polynomials.
	self testGCD: R! !

!RingTest methodsFor: 'euclidean' stamp: 'len 5/23/2020 09:33:01'!
testPolynomialsOverFieldIsEuclidean
	| F R |
	F _ 2 atRandom = 1 ifTrue: [Ñ] ifFalse: [GaloisField new: 5 atRandom nextPrime to: 3 atRandom].
	R _ F polynomials.
	self testEuclideanRing: R! !

!RingTest methodsFor: 'euclidean' stamp: 'len 5/23/2020 09:33:01'!
testPolynomialsOverFieldLCM
	| F R |
	F _ 2 atRandom = 1 ifTrue: [Ñ] ifFalse: [GaloisField new: 5 atRandom nextPrime to: 3 atRandom].
	R _ F polynomials.
	self testLCM: R! !

!RingTest methodsFor: 'euclidean' stamp: 'len 5/23/2020 09:33:01'!
testPolynomialsOverFieldXXGCD
	| F R |
	F _ 2 atRandom = 1 ifTrue: [Ñ] ifFalse: [GaloisField new: 5 atRandom nextPrime to: 3 atRandom].
	R _ F polynomials.
	self testXXGCD: R! !

!RingTest methodsFor: 'euclidean' stamp: 'len 6/16/2019 17:46:04'!
testPrimePowerRingIsEuclidean
	| p k R |
	p _ 10 atRandom nextPrime.
	k _ 10 atRandom.
	R _ PrimePowerRing new: p to: k.
	self testEuclideanRing: R! !

!RingTest methodsFor: 'euclidean' stamp: 'len 5/23/2020 09:34:55'!
testRationalIntegerRingGCDAndLCM
	self testGCD: É.
	self testLCM: É! !

!RingTest methodsFor: 'euclidean' stamp: 'len 5/23/2020 09:34:55'!
testRationalIntegerRingIsEuclidean
	self testEuclideanRing: É! !

!RingTest methodsFor: 'euclidean' stamp: 'len 5/4/2020 06:16:11'!
testSmallEuclideanRing: R
	"Test division on all pairs of elements:"
	R do: [:b|
		b isZero ifFalse:
			[R do: [:a|
				| q r |
				q _ a // b.
				r _ a \\ b.
				self assert: a = (q * b + r).
				self assert: (r isZero or: [r valuation < b valuation])]]]! !

!RingTest methodsFor: 'euclidean' stamp: 'len 5/23/2020 09:34:55'!
testValuationRingGCD
	| R |
	R _ É localizationAt: 5.
	self testGCD: R! !

!RingTest methodsFor: 'euclidean' stamp: 'len 5/23/2020 09:34:55'!
testValuationRingIsEuclidean
	| R |
	R _ É localizationAt: 5.
	self testEuclideanRing: R! !

!RingTest methodsFor: 'euclidean' stamp: 'len 5/23/2020 09:34:55'!
testValuationRingLCM
	| R |
	R _ É localizationAt: 5.
	self testLCM: R! !

!RingTest methodsFor: 'euclidean' stamp: 'len 5/18/2020 09:02:31'!
testXXGCD: R
	100 timesRepeat:
		[| a b |
		a _ R atRandomBits: 30.
		b _ R atRandomBits: 30.
		self testXXGCD: a with: b]! !

!RingTest methodsFor: 'euclidean' stamp: 'len 5/18/2020 08:50:20'!
testXXGCD: a with: b
	| result g s t u v |
	result _ a xxgcd: b.
	g _ result at: 1.
	s _ result at: 2.
	t _ result at: 3.
	u _ result at: 4.
	v _ result at: 5.
	self assert: g = (a gcd: b).
	self assert: s*a + (t*b) = g.
	self assert: (u*a + (v*b)) isZero.
	self assert: (s*v - (t*u)) isUnit! !

!RingTest methodsFor: 'finite rings' stamp: 'len 5/23/2020 09:34:55'!
testFiniteRing1
	| R |
	R _ (É/2) polynomials.
	R _ R / (R x^3 - R x).
	self testRing: R.
	self testSmallRingUnitsAndAssociates: R.
	self assert: R isField not.
	self assert: R size = 8.
	self assert: R units size = 2.
	self assert: R zeroDivisors size = 6.
	self assert: R radical asSet = {R zero. R x^2 + R x} asSet
	"also, this ring has two maximal ideals"! !

!RingTest methodsFor: 'finite rings' stamp: 'len 5/23/2020 09:34:55'!
testFiniteRing2
	| R |
	R _ (É/2) polynomials.
	R _ R / (R x * (R x + 1)).
	self testRing: R.
	self testSmallRingUnitsAndAssociates: R.
	self assert: R isField not.
	self assert: R size = 4.
	self assert: R zeroDivisors size = 3.
	self assert: R characteristic = 2.
	self assert: R isLocal not.
	"more about this ring: two maximal (and princial as well) ideals (so not a local ring)"! !

!RingTest methodsFor: 'finite rings' stamp: 'len 5/23/2020 09:34:55'!
testFiniteRing2Alternative
	| R |
	R _ É/2 ◊ (É/2).
	self testRing: R.
	self testSmallRingUnitsAndAssociates: R.
	self assert: R isField not.
	self assert: R size = 4.
	self assert: R zeroDivisors size = 3.
	self assert: R characteristic = 2.
	self assert: R isLocal not.
	"more about this ring: two maximal (and principal as well) ideals (so not a local ring)"! !

!RingTest methodsFor: 'finite rings' stamp: 'len 5/23/2020 09:34:55'!
testFiniteRing3
	| R |
	R _ É/4 ◊ (É/4).
	self testRing: R.
	self testSmallRingUnitsAndAssociates: R.
	self assert: R characteristic = 4.
	self assert: R isField not.
	self assert: R size = 16.
	self assert: R zeroDivisors size = 12.
	self assert: R units size = 4.
	self assert: R radical isTrivial not.
	"more about this ring: two maximal ideals (so not a local ring), and non-trivial jacobson radical"! !

!RingTest methodsFor: 'finite rings' stamp: 'len 5/23/2020 09:34:55'!
testFiniteRingJacobsonRadical
	| R |
	R _ É/12.
	self assert: R radical = (R*6)! !

!RingTest methodsFor: 'finite rings' stamp: 'len 5/23/2020 09:34:55'!
testFiniteRingLocalAndNotLocal
	| R S |
	R _ É/6. "this is not a Galois ring, the zero-divisors dont form an ideal"
	S _ É/8. "this is a Galois ring"
	self assert: R isLocal not.
	self assert: S isLocal! !

!RingTest methodsFor: 'finite rings' stamp: 'len 5/23/2020 09:34:55'!
testFiniteRingsAreArtinian
	| R |
	R _ É/6. "not local"
	self assert: R isArtinian.
	R _ É/8. "local, prime power ring, Galois ring"
	self assert: R isArtinian.
	R _ É/4 ◊ (É/4).
	self assert: R isArtinian.
	R _ GaloisRing new: 3 to: 2 to: 4.
	self assert: R isArtinian! !

!RingTest methodsFor: 'finite rings' stamp: 'len 5/9/2020 17:21:42'!
testGaloisField
	| p k F |
	p _ #(2 3 5) atRandom.
	k _ #(1 2 3) atRandom.
	F _ GaloisField new: p to: k.
	self assert: F isField.
	self assert: F characteristic = p.
	self testRing: F.
	self testRingHomomorphism: F projection.
	self testSmallRingUnitsAndAssociates: F! !

!RingTest methodsFor: 'finite rings' stamp: 'len 5/9/2020 17:18:36'!
testGaloisField2
	| GF pi x one a |
	GF _ GaloisField new: 3^3.
	self assert: GF isField.
	self assert: GF characteristic = 3.
	pi _ GF projection.
	x _ pi domain x.
	one _ pi domain one.
	a _ pi value: x^2 + one.
	self assert: a * a inverse = GF one.
	[(a _ GF atRandom) isZero] whileTrue.
	self assert: a * a inverse = GF one! !

!RingTest methodsFor: 'finite rings' stamp: 'len 5/9/2020 17:13:29'!
testGaloisRing
	| R |
	R _ GaloisRing new: 3 to: 3 to: 2.
	self testRing: R.
	self testSmallRingUnitsAndAssociates: R.
	self assert: R characteristic = (3^3).
	self assert: R size = (3^3^2).
	self assert: R isLocal.
	self assert: R isEuclidean! !

!RingTest methodsFor: 'finite rings' stamp: 'len 4/19/2019 04:55:59'!
testGaloisRingCanonicalEmbeddingIntoOverring
	"Canonical homomorphism from GR(p^n,m) to GR(p^n,m*k)."
	| p n m k A B phi |
	p _ #(2 3 5) atRandom.
	n _ 3 atRandom.
	m _ 3 atRandom.
	k _ 3 atRandom.
	A _ GaloisRing new: p to: n to: m.
	B _ GaloisRing new: p to: n to: m * k.
	phi _ A -> B.
	self testRingHomomorphism: phi! !

!RingTest methodsFor: 'finite rings' stamp: 'len 5/15/2019 07:04:02'!
testGaloisRingCanonicalProjectionOntoResidueField
	"Canonical homomorphism from GR(p^n,m) to GF(p,m).
	This sends 'a' in Z/(p^n)Z[x]/f to 'a mod p' in Z/pZ[x]/(f mod p) where f mod p means reducing the coefficients mod p."
	| p n m A B phi |
	p _ #(2 3 5) atRandom.
	n _ 3 atRandom.
	m _ 3 atRandom.
	A _ GaloisRing new: p to: n to: m.
	B _ GaloisField new: p to: m.
	phi _ A -> B.
	self testRingHomomorphism: phi! !

!RingTest methodsFor: 'finite rings' stamp: 'len 5/22/2018 03:53:54'!
testGaloisRingNilradical
	| R |
	R _ GaloisRing new: 3 to: 3 to: 2.
	self assert: R nilradical = (R * 3)! !

!RingTest methodsFor: 'finite rings' stamp: 'len 5/4/2020 06:27:21'!
testGaloisRingUnitsSize
	| R |
	R _ GaloisRing new: 3 to: 2 to: 2.
	self assert: R units asSet size = 72! !

!RingTest methodsFor: 'finite rings' stamp: 'len 5/23/2020 09:34:55'!
testIntegersModuloOneIsTrivial
	self assert: (É/1) isTrivial! !

!RingTest methodsFor: 'finite rings' stamp: 'len 5/23/2020 09:34:55'!
testModularIntegers
	| R |
	R _ É / 256 atRandom.
	self testRing: R.
	self testSmallRingUnitsAndAssociates: R.
	self testRingHomomorphism: R projection! !

!RingTest methodsFor: 'finite rings' stamp: 'len 5/23/2020 09:34:55'!
testModularIntegersAnnihilator
	| R |
	R _ É/64 atRandom.
	R do: [:x|
		| ann |
		ann _ x annihilator.
		self assert: (x * ann generator) isZero.
		R do: [:y| (x*y) isZero ifTrue: [self assert: (ann includes: y)]]]! !

!RingTest methodsFor: 'finite rings' stamp: 'len 5/23/2020 09:34:55'!
testModularIntegersFactorization
	| R |
	R _ É/(2 to: 1000) atRandom.
	100 timesRepeat:
		[| x factors |
		x _ R atRandom.
		factors _ x factors.
		self assert: (factors asSet allSatisfy: [:each| each isIrreducible]).
		self assert: (x isZero or: [x isUnit or: [x normalized = factors product]])]! !

!RingTest methodsFor: 'finite rings' stamp: 'len 5/9/2020 17:22:07'!
testModularIntegersLift
	self assert: ((2 to: 100) allSatisfy: [:m| (1 to: m) allSatisfy: [:x| (x % m) lift % m = (x % m)]])! !

!RingTest methodsFor: 'finite rings' stamp: 'len 5/23/2020 09:34:55'!
testModularIntegersPrimesExamples
	| R |
	R _ É/6.
	self assert: (R primes asSet collect: [:each| each representative]) = #(2 3 4) asSet.
	R _ É/12.
	self assert: (R primes asSet collect: [:each| each representative]) = #(2 3 9 10) asSet! !

!RingTest methodsFor: 'finite rings' stamp: 'len 5/23/2020 09:34:55'!
testModularIntegersPrimitiveRoots
	| X |
	"number of primitive roots in Z/nZ for n=2 to 17:"
	X _ #(1 1 1 2 1 2 0 2 2 4 0 4 2 0 0 8).
	self assert: ((2 to: 17) collect: [:m| (É/m) count: [:x| x isPrimitiveRoot]]) = X.
	X withIndexDo: [:n :i|
		n > 0
			ifTrue: [self assert: (É/(i+1)) primitiveRoot isPrimitiveRoot]
			ifFalse: [self should: [(É/(i+1)) primitiveRoot] raise: Error]]! !

!RingTest methodsFor: 'finite rings' stamp: 'len 5/23/2020 09:34:55'!
testModularIntegersProperties
	| m R |
	m _ (2 to: 10) atRandom.
	R _ É/m.
	self assert: R isPIR.
	self assert: m isPrime = R isField.
	self assert: m isPrimePower = R isLocal.
	self assert: R isField = R isIntegralDomain.
	self assert: R isField = R isPID! !

!RingTest methodsFor: 'finite rings' stamp: 'len 5/23/2020 09:34:55'!
testModularIntegersTrivial
	| R |
	R _ É/1.
	self assert: R isTrivial.
	self assert: R size = 1.
	self assert: R zero = R one! !

!RingTest methodsFor: 'finite rings' stamp: 'len 5/23/2020 09:34:55'!
testModularIntegersUnitsIrreduciblesAndReducibles
	"From 'A Special Subring Associated with Irreducible Elements in the Ring of Z/nZ', Augustine Musukwa, Khumbo Kumwenda, Journal of Mathematics (2017)."
	| m R factors p |
	m _ (2 to: 100) atRandom.
	R _ É/m.
	self assert: R units asSet size = m phi.
	factors _ m factors.
	self assert: R irreducibles size = (m phi * ((factors asSet select: [:each| (factors occurrencesOf: each) > 1]) sum: [:each| 1/each] ifEmpty: [0])).
	p _ 10 atRandom nextPrime.
	m _ p ^ (2 to: 4) atRandom.
	R _ É/m.
	self assert: R reducibles size = (R irreducibles size / (p - 1) - 1)! !

!RingTest methodsFor: 'finite rings' stamp: 'len 5/23/2020 09:34:55'!
testModularIntegersUnitsIrreduciblesAndReduciblesExamples
	"Examples from 'A Special Subring Associated with Irreducible Elements in the Ring of Z/nZ', Augustine Musukwa, Khumbo Kumwenda, Journal of Mathematics (2017)."
	| R |
	R _ É/8.
	self assert: (R units asSet collect: [:each| each representative]) = #(1 3 5 7) asSet.
	self assert: (R irreducibles asSet collect: [:each| each representative]) = #(2 6) asSet.
	R _ É/36.
	self assert: (R units asSet collect: [:each| each representative]) = #(1 5 7 11 13 17 19 23 25 29 31 35) asSet.
	self assert: (R irreducibles asSet collect: [:each| each representative]) = #(2 3 10 14 15 21 22 26 33 34) asSet.
	R _ É/25.
	self assert: R irreducibles size = 4.
	self assert: R reducibles isEmpty.
	R _ É/32.
	self assert: R irreducibles size = 8.
	self assert: R reducibles size = 7.
	R _ É/343.
	self assert: R irreducibles size = 42.
	self assert: R reducibles size = 6! !

!RingTest methodsFor: 'finite rings' stamp: 'len 5/23/2020 09:34:55'!
testPrimeField
	| p F |
	p _ 256 atRandom nextPrime.
	F _ É / p.
	self assert: F isField.
	self assert: F characteristic = p.
	self testRing: F.
	self testRingHomomorphism: F projection.
	self testSmallRingUnitsAndAssociates: F! !

!RingTest methodsFor: 'finite rings' stamp: 'len 5/23/2020 09:34:55'!
testPrimeFieldEulerTheorem
	| p F a |
	p _ 256 atRandom nextPrime.
	F _ É / p.
	[a _ F atRandom. a isZero] whileTrue.
	self assert: a ^ (p - 1) = F one! !

!RingTest methodsFor: 'finite rings' stamp: 'len 5/23/2020 09:34:55'!
testPrimeFieldLogarithm
	| F g a b p |
	p _ 17.
	F _ É/p.
	g _ F primitiveRoot.
	[(a _ F atRandom) isZero] whileTrue.
	[(b _ F atRandom) isZero] whileTrue.
	self assert: g ^ (a log: g) = a.
	self assert: (a log: g) + (b log: g) \\ (p-1) = ((a*b log: g) \\ (p-1)).
	self assert: (a log: g) - (b log: g) \\ (p-1) = ((a/b log: g) \\ (p-1))! !

!RingTest methodsFor: 'finite rings' stamp: 'len 5/23/2020 09:34:55'!
testPrimeFieldPrimitiveRoot
	| p F g i x |
	p _ 100 atRandom nextPrime.
	F _ É/p.
	g _ F primitiveRoot.
	self assert: g multiplicativeOrder = (p-1).
	i _ 1.
	x _ g.
	[x = F one] whileFalse: [x _ x*g. i _ i+1].
	self assert: i = (p-1)! !

!RingTest methodsFor: 'finite rings' stamp: 'len 5/9/2020 17:26:33'!
testPrimeFieldQuadraticResidues
	| F |
	F _ PrimeField new: 1000 atRandom nextPrime.
	self assert: F atRandom squared isQuadraticResidue.
	self assert: ((1000 count: [F atRandom isQuadraticResidue]) between: 400 and: 600)! !

!RingTest methodsFor: 'finite rings' stamp: 'len 5/9/2020 17:28:46'!
testPrimeFieldSquareRoot
	| F a x |
	100 timesRepeat:
		[F _ PrimeField new: (1000 atRandom + 1) nextPrime.
		a _ F atRandom squared.
		x _ a squareRoot.
		self assert: x squared = a]! !

!RingTest methodsFor: 'finite rings' stamp: 'len 5/23/2020 09:34:55'!
testPrimeFieldUnitsSize
	| F |
	F _ É/256 atRandom nextPrime.
	self assert: F units size = (F size - 1)! !

!RingTest methodsFor: 'finite rings' stamp: 'len 5/9/2020 17:15:40'!
testPrimePowerRing
	| R |
	R _ PrimePowerRing new: 3 to: 3.
	self testRing: R.
	self testSmallRingUnitsAndAssociates: R.
	self assert: R characteristic = (3^3).
	self assert: R size = (3^3).
	self assert: R isLocal.
	self assert: R isEuclidean.
	self assert: R maximalIdeal = (R*3)! !

!RingTest methodsFor: 'finite rings' stamp: 'len 5/23/2020 09:34:55'!
testPrimePowerRingCanonicalProjections
	"Canonical homomorphism from É/<p^n> to É/<p^m> with 1 <= m <= n."
	| p n m A B phi a b |
	p _ 100 atRandom nextPrime.
	n _ 4 atRandom.
	A _ É/(p^n).
	m _ n atRandom.
	B _ É/(p^m).
	phi _ A -> B.
	a _ A atRandom.
	b _ phi value: a.
	self assert: (B includes: b).
	self assert: a representative \\ (p^m) = b representative.
	self testRingHomomorphism: phi! !

!RingTest methodsFor: 'finite rings' stamp: 'len 6/5/2019 14:25:29'!
testPrimePowerRingNilradical
	| R |
	R _ PrimePowerRing new: 3 to: 3.
	self assert: R nilradical = (R * 3)! !

!RingTest methodsFor: 'finite rings' stamp: 'len 5/23/2020 09:34:55'!
testPrimePowerRingNilradicalAndUnits
	| p n R |
	p _ 30 atRandom nextPrime.
	n _ 4 atRandom.
	R _ É/(p^n).
	self assert: R units size + R nilradical size = R size! !

!RingTest methodsFor: 'finite rings' stamp: 'len 5/9/2020 17:29:15'!
testPrimePowerRingSquareRoot
	| F a x |
	100 timesRepeat:
		[F _ PrimePowerRing new: 10 atRandom nextPrime to: 3 atRandom.
		a _ F atRandom squared.
		x _ a squareRoot.
		self assert: x squared = a]! !

!RingTest methodsFor: 'finite rings' stamp: 'len 5/8/2020 18:03:43'!
testPrimePowerRingValuationAndUnit
	| R x |
	R _ PrimePowerRing new: 3 to: 5.
	x _ R !! 5.
	self assert: x valuation = 0.
	self assert: x unit = x.
	x _ R !! (3*3*5*2).
	self assert: x valuation = 2.
	self assert: x unit = (R !! 10).
	"this is undefined for an Euclidean valuation, but we define it at 0 to be +infinity in order to make it compatible with the p-adic valuation:"
	x _ R !! 0.
	self assert: x valuation = Infinity positive! !

!RingTest methodsFor: 'finite rings' stamp: 'len 5/10/2020 19:58:36'!
testQuasiGaloisRing1
	| p r n A |
	p _ #(2 3) atRandom.
	r _ 3 atRandom.
	n _ 3 atRandom+1.
	A _ QuasiGaloisRing new: p to: r to: n.
	self testRing: A.
	self testRingUnitsAndAssociates: A.
	self assert: A characteristic = p.
	self assert: A size = (p^(r*n)).
	self assert: A isLocal.
	self assert: A isFinite.
	self assert: A isField not! !

!RingTest methodsFor: 'finite rings' stamp: 'len 5/23/2020 09:34:55'!
testSmallPrimeField
	| p F E |
	p _ 20 atRandom nextPrime.
	F _ É/p.
	E _ SmallPrimeField new: p.
	F do: [:a|
		F do: [:b| | c d |
			c _ E !! a representative.
			d _ E !! b representative.
			self assert: (a+b) representative = (c+d) representative.
			self assert: (a-b) representative = (c-d) representative.
			self assert: (a*b) representative = (c*d) representative.
			b isZero ifFalse:
				[self assert: (a/b) representative = (c/d) representative.
				self assert: b inverse representative = d inverse representative]]]! !

!RingTest methodsFor: 'finite rings' stamp: 'len 5/9/2020 17:27:49'!
testSmallPrimeFieldTables
	| p F g |
	p _ 20 atRandom nextPrime.
	F _ SmallPrimeField new: p.
	g _ F primitiveRoot.
	1 to: p-1 do: [:n| self assert: (F expTable at: n) = (g^n) representative].
	0 to: p-2 do: [:n| self assert: (F logTable at: (g^n) representative) = n]! !

!RingTest methodsFor: 'finite rings' stamp: 'len 5/9/2020 17:28:07'!
testSquareRootModulo2
	| F |
	F _ PrimeField new: 2.
	self assert: F zero squareRoot = F zero.
	self assert: F one squareRoot = F one! !

!RingTest methodsFor: 'finite rings' stamp: 'len 5/23/2020 09:34:55'!
testZ6IsNotPID
	self assert: (É/6) isPID not! !

!RingTest methodsFor: 'finite rings' stamp: 'len 5/23/2020 09:34:55'!
testZ6PrimeNeedNotBeIrreducible
	| R a |
	R _ É/6.
	a _ R!!2.
	self assert: a isPrime.
	self assert: a isIrreducible not! !

!RingTest methodsFor: 'general' stamp: 'len 5/23/2020 09:34:55'!
testCanonicalMorphisms
	| R x Q |
	R _ Ñ polynomials.
	x _ R x.
	Q _ R / (x^2 + 1).
	self assert: (É -> R value: 4) = (R !! 4). "canonical morphism from initial object"
	self assert: (R -> Q value: x^2 + 2) = Q one. "canonical morphism to quotient object"! !

!RingTest methodsFor: 'general' stamp: 'len 5/13/2020 06:06:15'!
testDivisionByUnits: R
	100 timesRepeat:
		[| x u |
		x _ R atRandomBits: 30.
		u _ R units atRandomBits: 30.
		self assert: x*u // u = x.
		self assert: x // u = (x * u inverse)]! !

!RingTest methodsFor: 'general' stamp: 'len 5/23/2020 09:34:55'!
testKrullDimension
	| R I |
	self assert: É dimension = 1.
	self assert: Ñ dimension = 0.
	self assert: (É polynomialsIn: 2) dimension = 3.
	R _ Ñ polynomialsIn: #(x y).
	I _ R * {R x ^ 2 + (R y ^ 2) - 1}.
	self assert: (R / I) dimension = 1! !

!RingTest methodsFor: 'general' stamp: 'len 5/23/2020 09:34:55'!
testNilradical
	self assert: É nilradical = (É*0).
	self assert: (É/12) nilradical = (É/12*6)! !

!RingTest methodsFor: 'general' stamp: 'len 9/22/2018 19:03:04'!
testProductRing
	| R S P |
	R _ self newRing.
	S _ self newRing.
	P _ R ◊ S.
	self testRing: P.
	self testRingHomomorphism: (P projection: 2 atRandom)! !

!RingTest methodsFor: 'general' stamp: 'len 5/23/2020 09:33:27'!
testQQ
	self testRing: Ñ! !

!RingTest methodsFor: 'general' stamp: 'len 5/13/2020 06:07:00'!
testRing: R
	self testRingAxioms: R.
	self testRingUnitsAndAssociates: R.
	self testDivisionByUnits: R! !

!RingTest methodsFor: 'general' stamp: 'len 5/13/2020 06:44:18'!
testRingAxioms: R
	| one zero a b c |
	one _ R one.
	zero _ R zero.
	100 timesRepeat:
		[a _ R atRandomBits: 20.
		b _ R atRandomBits: 20.
		c _ R atRandomBits: 20.
		self assert: a * one = a.
		self assert: one * a = a.
		self assert: zero * a = zero.
		self assert: a * zero = zero.
		self assert: zero + a = a.
		self assert: a + zero = a.
		"commutativity of addition:"
		self assert: a + b = (b + a).
		"associativity of addition:"
		self assert: a + b + c = (a + (b + c)).
		"associativity of multiplication:"
		self assert: a * b * c = (a * (b * c)).
		"distributivity:"
		self assert: (a + b) * c = (a * c + (b * c)).
		"commutativity of multiplication:"
		R isCommutative ifTrue: [self assert: a * b = (b * a)]]! !

!RingTest methodsFor: 'general' stamp: 'len 3/13/2018 20:15:02'!
testRingHomomorphism: phi
	| R S a b |
	R _ phi domain.
	S _ phi codomain.
	a _ R atRandomBits: 10.
	b _ R atRandomBits: 10.
	self assert: (phi value: R zero) = S zero.
	self assert: (phi value: R one) = S one.
	self assert: (phi value: a + b) = ((phi value: a) + (phi value: b)).
	self assert: (phi value: a * b) = ((phi value: a) * (phi value: b)) "this sometimes fails because f and -f are not equal regular functions, for example"! !

!RingTest methodsFor: 'general' stamp: 'len 5/11/2020 03:06:02'!
testRingUnitsAndAssociates: R
"	R size < 100 ifTrue: [^ self testSmallRingUnitsAndAssociates: R]."
	100 timesRepeat:
		[| x u |
		x _ R atRandomBits: 30.
		u _ (R atRandomBits: 30) unit.
		self assert: x unit isUnit.
		self assert: u unit = u.
		self assert: u * u inverse = R one.
		self assert: x normalized * x unit = x.
		self assert: x normalized = (x * u) normalized]! !

!RingTest methodsFor: 'general' stamp: 'len 5/8/2020 18:03:09'!
testSmallRingUnitsAndAssociates: R
	R do: [:x| self assert: x unit isUnit].
	R units do: [:u| self assert: u unit = u].
	R units do: [:u| self assert: u * u inverse = R one].
	R do: [:x| self assert: x normalized * x unit = x].
	R size < 80
		ifTrue:
			[R units do: [:u|
				R do: [:x| self assert: x normalized = (x * u) normalized]]]
		ifFalse:
			[R do: [:x|
				| u |
				u _ R atRandom unit.
				self assert: x normalized = (x * u) normalized]]! !

!RingTest methodsFor: 'general' stamp: 'len 5/23/2020 09:35:15'!
testZZ
	self testRing: É! !

!RingTest methodsFor: 'general' stamp: 'len 5/23/2020 09:35:28'!
testZZIdeals
	self assert: (É * 3 includes: 6).
	self deny: (É * 3 includes: 7).
	self assert: (É * 0) isTrivial.
	self assert: (É * 1) isOne! !

!RingTest methodsFor: 'general' stamp: 'len 5/23/2020 09:35:33'!
testZZPrimeNotMaximalIdeal
	| I |
	I _ É * 0.
	self assert: I isPrime.
	self assert: I isMaximal not! !

!RingTest methodsFor: 'local rings' stamp: 'len 6/26/2019 13:00:09'!
testDVR: V
	| a b p |
	self assert: V isLocal.
	self assert: V isIntegralDomain.
	self assert: V isEuclidean.
	self assert: V one valuation = 0.
	p _ V uniformizer.
	self assert: p valuation = 1.
	a _ V atRandomBits: 100.
	self assert: (a*p) valuation = (a valuation + 1).
	b _ V atRandomBits: 100.
	self assert: (a*b) valuation = (a valuation + b valuation)! !

!RingTest methodsFor: 'local rings' stamp: 'len 5/23/2020 09:34:55'!
testLocalHomomorphism
	| f |
	f _ É/4 to: É/2 evaluating: [:x| É/2 !! x representative].
	self assert: f isLocal
! !

!RingTest methodsFor: 'local rings' stamp: 'len 5/23/2020 09:34:55'!
testValuationRing1
	| V |
	V _ É localizationAt: 5.
	self testRing: V.
	self testRingHomomorphism: V -> Ñ! !

!RingTest methodsFor: 'local rings' stamp: 'len 5/23/2020 09:34:55'!
testValuationRing2
	| V |
	V _ É localizationAt: 5.
	self testDVR: V! !

!RingTest methodsFor: 'localizations' stamp: 'len 5/13/2020 06:50:08'!
testFractionsRing
	| R F |
	R _ self newRing.
	F _ R fractions.
	self testRing: R.
	self testRingHomomorphism: R -> F! !

!RingTest methodsFor: 'localizations' stamp: 'len 5/23/2020 09:34:55'!
testLocalizationInclusions
	| Z2 Z3 Z6 |
	Z2 _ É localizationAt: 2.
	Z3 _ É localizationAt: 3.
	Z6 _ É localizationAt: 6. "<- this is not a prime ideal, it shouldn't be allowed"
	self assert: Z6 >= Z2.
	self assert: Z6 >= Z3.
	self deny: Z3 >= Z2.
	self deny: Z2 >= Z3.
	self deny: Z2 >= Z6! !

!RingTest methodsFor: 'localizations' stamp: 'len 5/23/2020 09:34:55'!
testLocalizationMaximalIdeal
	| Z2 |
	Z2 _ É localizationAt: 2.
	self assert: Z2 maximalIdeal = (Z2 * (Z2 !! 2))! !

!RingTest methodsFor: 'localizations' stamp: 'len 5/23/2020 09:34:55'!
testLocalizationOfModularIntegers1
	| R |
	R _ É/60.
	self assert: (R localizationAt: (R*2)) = (É/4).
	self assert: (R localizationAt: (R*3)) = (É/3).
	self assert: (R localizationAt: (R*5)) = (É/5)! !

!RingTest methodsFor: 'localizations' stamp: 'len 5/23/2020 09:34:55'!
testLocalizationOfModularIntegers2
	| R P L phi |
	R _ É/60.
	P _ R*2.
	L _ R localizationAt: P. "the localization is actually the prime power ring Z/4Z"
	"localization map:"
	phi _ R -> L.
	self testRingHomomorphism: phi.
	"everything not in P maps to a unit:"
	R do: [:each| self assert: ((P includes: each) or: [(phi value: each) isUnit])]! !

!RingTest methodsFor: 'localizations' stamp: 'len 5/23/2020 09:34:55'!
testLocalizationOfModularIntegers3
	| R P L phi |
	R _ É/60.
	P _ R*3.
	L _ R localizationAt: P. "the localization is actually the field GF(3)"
	"localization map:"
	phi _ R -> L.
	self testRingHomomorphism: phi.
	"everything not in P maps to a unit:"
	R do: [:each| self assert: ((P includes: each) or: [(phi value: each) isUnit])]! !

!RingTest methodsFor: 'localizations' stamp: 'len 5/23/2020 09:34:55'!
testLocalizationOfZAt2
	| L |
	L _ É localizationAt: 2.
	self assert: Ñ !! (L !! (1/3)) = (1/3).
	self should: [L !! (3/2)] raise: Error.
	self assert: Ñ !! (L !! 2) = 2.
	self assert: Ñ !! (L !! 3) = 3.
	self assert: (L atRandomBits: 10) denominator odd.
	self testRing: L.
	self testRingHomomorphism: É -> L! !

!RingTest methodsFor: 'polynomials' stamp: 'len 5/4/2020 06:30:23'!
testMultivariatePolynomialRing
	| R P |
	R _ self newRing.
	P _ R polynomialsIn: #(x y z).
	self testRing: R.
	self testRingHomomorphism: R -> P! !

!RingTest methodsFor: 'polynomials' stamp: 'len 5/4/2020 06:29:53'!
testPolynomialRing
	| R P |
	R _ self newRing.
	P _ R polynomials.
	self testRing: P.
	self testRingHomomorphism: R -> P! !

!RingTest methodsFor: 'polynomials' stamp: 'len 5/23/2020 09:34:55'!
testPolynomialRingPrimeNotMaximalIdeal
	"Z[x]/<x> is isomorphic to Z, which is an integral domain but not a field. So <x> is prime but not maximal."
	| R I |
	R _ É polynomials.
	I _ R * R x.
	self assert: I isPrime.
	self assert: I isMaximal not! !

!RingTest methodsFor: 'polynomials' stamp: 'len 5/23/2020 09:33:01'!
testPolynomialRingPrimeNotMaximalIdeal2
	"Q[x,y]/<x> is isomorphic to Q[y], which is an integral domain but not a field. So <x> is prime but not maximal."
	| R I |
	R _ Ñ polynomialsIn: 2.
	I _ R * R x.
	self assert: I isPrime.
	self assert: I isMaximal not! !

!RingTest methodsFor: 'polynomials' stamp: 'len 5/13/2020 06:28:58'!
testRationalFunctions
	| R P F |
	R _ self newField.
	P _ R polynomials.
	F _ P fractions.
	self testRing: F.
	self testRingHomomorphism: R -> F.
	self testRingHomomorphism: P -> F! !

!RingTest methodsFor: 'quotients' stamp: 'len 10/6/2016 20:32'!
testQuotientRing
	| Q |
	Q _ self newQuotientRing.
	self testRing: Q.
	self testRingHomomorphism: Q projection! !

!RingTest methodsFor: 'quotients' stamp: 'len 2/27/2017 20:51:24'!
testQuotientRing2
	| Q pi f g |
	Q _ self newQuotientRing.
	f _ Q base atRandomBits: 10.
	g _ Q relations atRandomBits: 10.
	pi _ Q projection.
	self assert: (pi value: g) isZero.
	self assert: (Q includes: (pi value: f)).
	self testRingHomomorphism: pi.
"	self assert: (pi value: f) = (pi value: f + g)."
"	h _ Q atRandomBits: 100.
	self assert: (pi value: (pi section value: h)) = h"! !

!RingTest methodsFor: 'quotients' stamp: 'len 5/23/2020 09:33:01'!
testQuotientRingNotIntegralDomain
	| R |
	R _ Ñ polynomials.
	R _ R / (R x^2 - 1).
	self assert: R isField not.
	self assert: R isIntegralDomain not! !

!RingTest methodsFor: 'quotients' stamp: 'len 5/23/2020 09:33:01'!
testQuotientRingWhichIsAField
	| R |
	R _ Ñ polynomials.
	R _ R / (R x^2 + (R x * 2) + 2).
	self assert: R isField! !

!RingTest methodsFor: 'private' stamp: 'len 5/23/2020 09:34:55'!
newField
	| R |
	R _ {Ñ. É / 256 atRandom nextPrime} atRandom.
	"TODO: function fields, p-adics, power series"
"	R _ 2 atRandom = 1 ifTrue: [R extensionDegree: 3 atRandom + 1]."
"	2 atRandom = 1 ifTrue: [^ R polynomials fractions]."
	^ R! !

!RingTest methodsFor: 'private' stamp: 'len 5/23/2020 09:34:55'!
newQuotientRing
	| R I |
	2 atRandom = 1 ifTrue: [^ É / (2 to: 10) atRandom].
	R _ Ñ polynomials.
	I _ R * (R atRandomBits: 10 maxDegree: 5).
	^ R / I! !

!RingTest methodsFor: 'private' stamp: 'len 5/23/2020 09:34:55'!
newRing
	4 atRandom = 1 ifTrue: [^ self newQuotientRing].
	2 atRandom = 1 ifTrue: [^ {É. Ñ. É / 64 atRandom} atRandom polynomialsIn: (1 to: 3) atRandom].
	^ {É. Ñ. É / 64 atRandom} atRandom! !

!RingTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testÉ
	self testRing: É! !

!RingTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testÉIdeals
	self assert: (É * 3 includes: 6).
	self deny: (É * 3 includes: 7).
	self assert: (É * 0) isTrivial.
	self assert: (É * 1) isOne! !

!RingTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testÉPrimeNotMaximalIdeal
	| I |
	I _ É * 0.
	self assert: I isPrime.
	self assert: I isMaximal not! !

!RingTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:33:01'!
testÑ
	self testRing: Ñ! !

!SequenceTest methodsFor: 'as yet unclassified' stamp: 'len 6/4/2019 18:09:49'!
testBellNumbers
	self assert: (Sequence bellNumbers beginsWith: #(1 1 2 5 15 52 203 877)).
	"The inverse binomial transform is the shift operator for the Bell numbers:"
	self assert: (Sequence bellNumbers binomialInverseTransform beginsWith: #(1 2 5 15 52 203 877)).! !

!SequenceTest methodsFor: 'as yet unclassified' stamp: 'len 12/5/2015 01:13'!
testDirichletConvolution
	self assert: ((Sequence phi dirichlet: Sequence one) beginsWith: #(1 2 3 4 5)).
	self assert: ((Sequence moebius dirichlet: Sequence one) beginsWith: #(1 0 0 0 0))! !

!SequenceTest methodsFor: 'as yet unclassified' stamp: 'len 10/31/2016 04:14'!
testLinearRecursiveSequenceBug
	| F |
	F _ CFiniteSequence fibonacci.
	self assert: ((F - F) at: 1) = 0! !

!SequenceTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testRecursive
	| f g |
	f _ Sequence fibonacci.
	g _ CFiniteSequence to: É evaluating: f maxOrder: 5.
	self assert: (f equals: g upTo: 20).
	self assert: g order = 2.
	self assert: g characteristicPolynomial coefficients asArray = #(-1 -1 1)! !

!SequenceTest methodsFor: 'as yet unclassified' stamp: 'len 10/31/2016 04:13'!
testRecursive2
	| a b c |
	a _ CFiniteSequence fibonacci.
	b _ CFiniteSequence lucasNumbers.
	c _ a + (b*2) - (b+b).
	self assert: a = c! !

!SequenceTest methodsFor: 'as yet unclassified' stamp: 'len 3/7/2017 07:28:24'!
testRecursiveConvolution
	| a b c a2 b2 c2 |
	a _ CFiniteSequence fibonacci.
	b _ CFiniteSequence lucasNumbers.
	a2 _ Sequence evaluating: [:i| a at: i].
	b2 _ Sequence evaluating: [:i| b at: i].

	c _ a convolution: b.
	c2 _ a2 convolution: b2.
	
	self assert: (c equals: c2 upTo: 20)! !

!SequenceTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testRecursiveEquals
	| a b c |
	a _ CFiniteSequence fibonacci.
	b _ CFiniteSequence to: É evaluating: [:i| a at: i] maxOrder: 10.
	c _ CFiniteSequence lucasNumbers.
	self assert: a = b.
	self assert: a ~= c! !

!SequenceTest methodsFor: 'as yet unclassified' stamp: 'len 3/7/2017 07:28:49'!
testRecursiveIndefiniteSumation
	| a c a2 c2 |
	a _ CFiniteSequence fibonacci.
	a2 _ Sequence evaluating: [:i| a at: i].

	c _ a sum.
	c2 _ a2 sum.
	self assert: (c isKindOf: CFiniteSequence).
	self assert: (c equals: c2 upTo: 20)! !

!SequenceTest methodsFor: 'as yet unclassified' stamp: 'len 10/31/2016 04:13'!
testRecursiveMinimal
	| a f |
	a _ CFiniteSequence initialValues: #(0 1 1) coefficients: #(0 1 1).
	f _ CFiniteSequence fibonacci.
	self assert: a isMinimal not.
	self assert: a order = 3.
	self assert: a minimal order = 2.
	self assert: a minimalPolynomial = f characteristicPolynomial! !

!SequenceTest methodsFor: 'as yet unclassified' stamp: 'len 3/7/2017 07:29:10'!
testRecursiveProduct
	| a b c c2 |
	a _ CFiniteSequence fibonacci.
	b _ CFiniteSequence pellNumbers.
	c _ a * b.
	c2 _ Sequence evaluating: [:i| (a at: i) * (b at: i)].
	self assert: (c isKindOf: CFiniteSequence).
	self assert: (c equals: c2 upTo: 20).
	self assert: c order = 4! !

!SequenceTest methodsFor: 'as yet unclassified' stamp: 'len 3/7/2017 07:29:52'!
testRecursiveScalarMultiplication
	| a c a2 c2 |
	a _ CFiniteSequence fibonacci.
	a2 _ Sequence evaluating: [:i| a at: i].

	c _ a * 7.
	c2 _ a2 * 7.
	self assert: (c isKindOf: CFiniteSequence).
	self assert: (c equals: c2 upTo: 20)! !

!SequenceTest methodsFor: 'as yet unclassified' stamp: 'len 3/7/2017 07:30:12'!
testRecursiveShiftLeft
	| a c a2 c2 |
	a _ CFiniteSequence fibonacci.
	a2 _ Sequence evaluating: [:i| a at: i].

	c _ a << 5.
	c2 _ a2 << 5.
	self assert: (c isKindOf: CFiniteSequence).
	self assert: (c equals: c2 upTo: 20)! !

!SequenceTest methodsFor: 'as yet unclassified' stamp: 'len 3/7/2017 07:30:25'!
testRecursiveSum
	| a b c c2 |
	a _ CFiniteSequence fibonacci.
	b _ CFiniteSequence lucasNumbers.
	c _ a + b.
	c2 _ Sequence evaluating: [:i| (a at: i) + (b at: i)].
	self assert: (c isKindOf: CFiniteSequence).
	self assert: (c equals: c2 upTo: 20)! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 2/20/2017 08:36:51'!
test2Sphere
	| X |
	X _ SimplicialComplex sphere: 2.
	self assert: X dimension = 2.
	self assert: X fVector = (1,4,6,4)! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 2/20/2017 08:37:08'!
test5Sphere
	| X |
	X _ SimplicialComplex sphere: 5.
	self assert: X dimension = 5.
	self assert: X fVector = (1,7,21,35,35,21,7)! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 2/19/2017 10:28:26'!
testAlexanderDual
	| X Y |
	X _ SimplicialComplex faces: #((0 1) (1 2) (2 3) (3 0)).
	self assert: X dual dual = X.
	Y _ SimplicialComplex faces: #((1 3) (0 2)).
	self assert: X dual = Y.
	self assert: X dual nonfaces = X complement facets! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:33:01'!
testBettiNumbersCircle
	| X |
	X _ SimplicialComplex sphere: 1.
	self assert: (X chainComplexOver: Ñ) betti = #(1 1)! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:33:01'!
testBettiNumbersKleinBottle
	| X |
	X _ SimplicialComplex kleinBottle.
	self assert: (X chainComplexOver: Ñ) betti = #(1 1 0)! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:33:01'!
testBettiNumbersProjectivePlane
	| X |
	X _ SimplicialComplex realProjectivePlane.
	self assert: (X chainComplexOver: Ñ) betti = #(1 0 0)! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:33:01'!
testBettiNumbersSphere
	| X |
	X _ SimplicialComplex sphere: 2.
	self assert: (X chainComplexOver: Ñ) betti = #(1 0 1)! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:33:01'!
testBettiNumbersTorus
	| X |
	X _ SimplicialComplex torus.
	self assert: (X chainComplexOver: Ñ) betti = #(1 2 1)! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testChainComplex
	"Jeff Erickson, 'Computational Topology', Example 17.7."
	| S2 C |
	S2 _ SimplicialComplex facets: ((Simplex vertices: #(w x y z)) faces: 2).
	C _ S2 chainComplexOver: É.
	self assert: (C cycles: 1) rank = 3.
	self assert: (C boundaries: 0) rank = 3.
	self assert: (C boundaries: 1) = (C cycles: 1).
	self assert: C betti = #(1 0 1)! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 2/20/2017 08:37:27'!
testEulerCharacteristic
	| X |
	X _ SimplicialComplex torus.
	self assert: X euler = 0.
	X _ SimplicialComplex sphere: 2.
	self assert: X euler = 2.
	X _ SimplicialComplex kleinBottle.
	self assert: X euler = 0.
	X _ SimplicialComplex realProjectivePlane.
	self assert: X euler = 1! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 2/19/2017 08:23:09'!
testJoin
	| S X |
	S _ SimplicialComplex faces: #((0) (1)).
	X _ S * S * S * S * S * S * S * S.
	self assert: X vertices size = 16.
	self assert: X facets size = 256
! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 2/19/2017 08:23:15'!
testMinimalNonFaces
	| X |
	X _ SimplicialComplex faces: #((1 3) (1 2)).
	self assert: X nonfaces = {Simplex vertices: #(2 3)} asSet.
	X _ SimplicialComplex faces: #((0 1) (1 2) (2 3) (3 0)).
	self assert: X nonfaces = {Simplex vertices: #(1 3). Simplex vertices: #(0 2)} asSet
! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 2/19/2017 08:23:18'!
testMinimalNonFaces2
	| X MNF |
	X _ SimplicialComplex faces: #((0 1 2) (0 2 3) (2 3 4) (1 2 4) (1 4 5) (0 3 6) (3 6 7) (4 5 7)).
	MNF _ (#((3 4 7) (0 7) (0 4) (0 5) (3 5) (1 7) (2 5) (5 6) (1 3) (4 6) (2 7) (2 6) (1 6)) collect: [:each| Simplex vertices: each]) asSet.
	self assert: X nonfaces = MNF! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 2/19/2017 08:23:21'!
testProduct
	| C T |
	"Circle:"
	C _ SimplicialComplex faces: #((0 1) (1 2) (0 2)).
	"Torus:"
	T _ C ◊ C.
	self assert: T euler = 0.
	self assert: T vertices size = 9.
	self assert: T facets size = 18! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 2/25/2017 10:08:54'!
testSimplex
	| tetrahedron |
	tetrahedron _ Simplex vertices: #(a b c d).
	self assert: tetrahedron dimension = 3.
	self assert: (tetrahedron faces: 2) size = 4.
	self assert: tetrahedron edges size = 6.
	self assert: (tetrahedron faces: 3) size = 1! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 2/19/2017 08:37:30'!
testSimplexComplement
	| V |
	V _ (0 to: 5).
	self assert: ((Simplex vertices: #(1 2 3)) complementIn: V) = (Simplex vertices: #(0 4 5)).
	self assert: ((Simplex vertices: #(0 1 3 4)) complementIn: V) = (Simplex vertices: #(2 5)).
	self assert: ((Simplex vertices: #(0 4 1 3 )) complementIn: V) = (Simplex vertices: #(2 5))! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 3/7/2017 07:30:50'!
testSimplexInclusion
	| S S2 |
	S _ Simplex new: (2 to: 10) atRandom.
	S2 _ Simplex new: (0 to: S dimension) atRandom.
	self assert: S2 <= S! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 2/15/2017 16:21:54'!
testSimplexJoin
	| A B |
	A _ Simplex new: 2.
	B _ Simplex new: 3.
	self assert: A*B ~ (Simplex new: 2+1+3+1-1)
! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:33:01'!
testSimplicialChainsBoundaryMap
	| X C d1 d2 |
	X _ SimplicialComplex sphere: 2.
	C _ X chainComplexOver: Ñ.
	d2 _ C at: 2.
	d1 _ C at: 1.
	self assert: d2 isZero not.
	self assert: d1 isZero not.
	self assert: (d1 ∑ d2) isZero! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 4/21/2020 12:18:08'!
testSimplicialComplex
	| S |
	S _ SimplicialComplex facets: {{1. 2. 3}. {2. 4}. {3. 4}. {5}}.
	self assert: (S faces: 2) asSet size = 1.
	self assert: (S faces: 1) asSet size = 5.
	self assert: (S faces: 0) asSet size = 5! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 2/19/2017 10:00:52'!
testSimplicialComplexExample
	"Example from Herzog, 'Monomial Ideals', pag. 16."
	| X |
	X _ SimplicialComplex on: (1 to: 5) faces: #((1 2 4) (1 2 5) (2 3) (3 4)).
	self assert: X facets = (#((1 2 4) (1 2 5) (2 3) (3 4)) collect: [:each| Simplex vertices: each]) asSet.
	self assert: X nonfaces = (#((1 3) (3 5) (4 5) (2 3 4)) collect: [:each| Simplex vertices: each]) asSet.
	self assert: X fVector = (1,5,7,2).
	self assert: X hVector = (1,2,0,-1)! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 2/20/2017 18:52:39'!
testSimplicialMap
	| S T f |
	S _ SimplicialComplex faces: #((0 2) (1 5) (3 4)).
	T _ SimplicialComplex faces: #((0 2) (1 3)).
	f _ S to: T map: ({0 -> 0. 1 -> 1. 2 -> 2. 3 -> 1. 4 -> 3. 5 -> 3} as: Dictionary).
	self assert: f image = T.
	self assert: f isSurjective.
	self assert: f isInjective not.
	self assert: f isIdentity not! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 2/19/2017 10:49:02'!
testStanleyReisnerIdealAndBack
	| X |
	X _ SimplicialComplex on: (1 to: 5) faces: #((1 2 4) (1 2 5) (2 3) (3 4)).
	self assert: X stanleyReisnerIdeal asSimplicialComplex = X! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 2/19/2017 18:14:18'!
testStanleyReisnerIdealAndBack2
	| X |
	X _ SimplicialComplex on: (1 to: 5) faces: #((1 3 2) (3 4) (2 4) (5)).
	self assert: X stanleyReisnerIdeal asSimplicialComplex = X! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 2/19/2017 10:27:08'!
testStanleyReisnerIdealAndFacetIdealDuality
	| X |
	X _ SimplicialComplex on: (1 to: 5) faces: #((1 2 4) (1 2 5) (2 3) (3 4)).
	self assert: X dual stanleyReisnerIdeal = X complement facetIdeal! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:33:01'!
testStanleyReisnerRing
	| X R |
	X _ SimplicialComplex faces: #((0 1) (1 2) (2 3) (3 0)).
	R _ Ñ polynomialsIn: #(x y z w).
	self assert: X stanleyReisnerRing relations generators asSet = (R generate: [:x :y :z :w| {y*w. x*z}]) asSet! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 2/14/2017 19:45:41'!
testTorus
	| X |
	X _ SimplicialComplex torus.
	self assert: X dimension = 2.
	self assert: X fVector = (1,7,21,14)! !

!TupleTest methodsFor: 'as yet unclassified' stamp: 'len 11/6/2016 11:35'!
testBitTupleBug
	| Z2 |
	Z2 _ PrimeField new: 2.
	self assert: ((1,0,0) % 2 :: sum = Z2 one).
	self assert: ((0,1,0) % 2 :: sum = Z2 one).
	self assert: ((1,1,0) % 2 :: sum = Z2 zero).
	self assert: ((1,1,1) % 2 :: sum = Z2 one)! !

!TupleTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testBitTupleOperations
	| n a b |
	n _ 120 atRandom.
	a _ É atRandomTuple: n bits: n*2.
	b _ É atRandomTuple: n bits: n*2.
	#(+ - ∑ convolution: hadamard:) do: [:op|
		self testTuple: a with: b operation: op modulo: 2].
	#(negated reversed copy sum product) do: [:op|
		self testTuple: a operation: op modulo: 2]! !

!TupleTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testBitTupleReversed
	| v i |
	v _ É / 2 atRandomTuple: 100 atRandom.
	i _ v size atRandom.
	self assert: (v reversed at: i) = (v at: v size - i + 1).
	self assert: v reversed reversed = v! !

!TupleTest methodsFor: 'as yet unclassified' stamp: 'len 5/8/2019 04:24:02'!
testBitTupleSum
	self assert: (BitTuple newFrom: 2r1011101) sum representative = 1.
	self assert: (BitTuple newFrom: 2r10000100100010) sum representative = 0! !

!TupleTest methodsFor: 'as yet unclassified' stamp: 'len 4/11/2018 15:54:46'!
testHomogeneousTuples
	self assert: (1,2,3) ~ (2,4,6).
	self deny: (1,2,3) ~ (-2,4,6)! !

!TupleTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testHomogeneousTuples2
	| P Q |
	P _ (1,2) over: É.
	Q _ (2,4) over: É.
	self assert: P ~ Q.
	P _ (1,2) over: É.
	Q _ (1,0) over: É.
	self deny: P ~ Q! !

!TupleTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:33:01'!
testHomogeneousTuples3
	| R x P Q |
	R _ Ñ polynomials.
	x _ R x.
	P _ R tuple: {x. x^2 + 1}.
	Q _ R tuple: {x^2. x^3 + x}.
	self assert: P ~ Q! !

!TupleTest methodsFor: 'as yet unclassified' stamp: 'len 4/11/2018 17:27:20'!
testHomogeneousTuples4
	| P Q |
	P _ (2,4,1) % 6.
	Q _ (0,1,3) % 6.
	self deny: P ~ Q! !

!TupleTest methodsFor: 'as yet unclassified' stamp: 'len 11/6/2016 11:31'!
testMakeZero: aTuple
	self assert: (aTuple * 0) isZero.
	self assert: (0 * aTuple) isZero.
	self assert: (aTuple + aTuple negated) isZero.
	self assert: (aTuple - aTuple) isZero! !

!TupleTest methodsFor: 'as yet unclassified' stamp: 'len 11/6/2016 11:39'!
testModTupleConcatenation
	self assert: (1,2,3) % 7, ((2,3,4) % 7) = ((1,2,3,2,3,4) % 7)! !

!TupleTest methodsFor: 'as yet unclassified' stamp: 'len 11/6/2016 13:49'!
testModTupleConvolution
	| a b |
	a _ (1,2,3).
	b _ (2,3,4).
	self assert: (a % 7 convolution: b % 7) = ((a convolution: b) % 7)! !

!TupleTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testModTupleOperations
	| a b modulus |
	modulus _ 10 atRandom + 1.
	a _ É atRandomTuple: 5 bits: 30.
	b _ É atRandomTuple: 5 bits: 30.
	#(+ - ∑ convolution: hadamard:) do: [:op|
		self testTuple: a with: b operation: op modulo: modulus].
	#(negated reversed copy sum product) do: [:op|
		self testTuple: a operation: op modulo: modulus].! !

!TupleTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testModTupleSum
	| a b |
	a _ É tuple: ((1 to: 10) collect: [:i| 100 atRandom]).
	b _ a % 7.
	self assert: b sum = (a sum % 7)! !

!TupleTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testModularIntegersTupleAssociateBug
	| R t |
	R _ É/8.
	t _ R tuple: #(3 2).
	self assert: t*5*5 = t.
	self assert: (t*5) normalized = t normalized! !

!TupleTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testModularIntegersTupleAssociateBug1
	| R t |
	R _ É/6.
	t _ R tuple: #(2 3).
	self assert: t*5*5 = t.
	self assert: (t*5) normalized = t normalized! !

!TupleTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testModularIntegersTupleAssociateBug2
	| R t |
	R _ É/6.
	t _ R tuple: #(3 2).
	self assert: t*5*5 = t.
	self assert: (t*5) normalized = t normalized! !

!TupleTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testModularIntegersTupleUnitsAndAssociates
	| R t tt |
	100 timesRepeat:
		[R _ É/64 atRandom.
		t _ R atRandomTuple: 5 atRandom.
		tt _ t normalized.
		self assert: t * t unit inverse = tt.
		R unitsDo: [:u| self assert: (t*u) normalized = tt]]! !

!TupleTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testModularIntegersTupleUnitsAndAssociates2
	"Examples from Magma."
	| R |
	R _ É/6.
	self assert: (R tuple: #(0 2)) normalized = (R tuple: #(0 2)).
	self assert: (R tuple: #(0 4)) normalized = (R tuple: #(0 2)).
	self assert: (R tuple: #(2 3)) normalized = (R tuple: #(2 3)).
	self assert: (R tuple: #(4 3)) normalized = (R tuple: #(2 3)).
	R _ É/8.
	self assert: (R tuple: #(3 2)) normalized = (R tuple: #(1 6)).
	self assert: (R tuple: #(7 2)) normalized = (R tuple: #(1 6)).
	self assert: (R tuple: #(2 3)) normalized = (R tuple: #(2 3)).
	self assert: (R tuple: #(2 7)) normalized = (R tuple: #(2 3))! !

!TupleTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testModularIntegersTupleUnitsAndAssociates3
	"Examples from Magma."
	| R |
	R _ É/6.
	self assert: (R tuple: #(0 4)) ~ (R tuple: #(0 2)).
	self assert: (R tuple: #(4 3)) ~ (R tuple: #(2 3)).
	R _ É/8.
	self assert: (R tuple: #(3 2)) ~ (R tuple: #(1 6)).
	self assert: (R tuple: #(7 2)) ~ (R tuple: #(1 6)).
	self assert: (R tuple: #(2 7)) ~ (R tuple: #(2 3))! !

!TupleTest methodsFor: 'as yet unclassified' stamp: 'len 11/6/2016 14:24'!
testTuple: a operation: aSymbol modulo: modulus
	self assert: (a perform: aSymbol) % modulus = (a % modulus perform: aSymbol)! !

!TupleTest methodsFor: 'as yet unclassified' stamp: 'len 11/6/2016 14:12'!
testTuple: a with: b operation: aSymbol modulo: modulus
	self assert: (a perform: aSymbol with: b) % modulus = (a % modulus perform: aSymbol with: b % modulus)! !

!TupleTest methodsFor: 'as yet unclassified' stamp: 'len 11/6/2016 11:36'!
testTupleSum
	self assert: (1,2,3) sum = (1 + 2 + 3)! !

!Benchmark methodsFor: 'as yet unclassified' stamp: 'len 3/1/2016 04:20'!
run
	| output |
	output _ WriteStream on: (String new: 1000).
	(self class selectors asArray select: [:each|
		(each beginsWith: 'test') and: [each numArgs isZero]]) sort
		do: [:each|
			output nextPutAll: each; tab.
			self setUp.
			Smalltalk garbageCollect.
			[output nextPutAll: [self perform: each] bench] on: Error do: [output nextPutAll: 'FAILED'].
			self tearDown]
		separatedBy: [output newLine].
	^ output contents! !

!Benchmark methodsFor: 'as yet unclassified' stamp: 'len 3/1/2016 04:16'!
setUp
	^ self! !

!Benchmark methodsFor: 'as yet unclassified' stamp: 'len 3/1/2016 04:16'!
tearDown
	^ self! !

!AlgebraicNumbersBenchmark methodsFor: 'as yet unclassified' stamp: 'len 4/29/2018 20:33:55'!
testComplexAlgebraicNumberAddition
	| sqrt2 sqrt3 sqrt5 |
	sqrt2 _ ComplexAlgebraicNumber sqrt: 2.
	sqrt3 _ ComplexAlgebraicNumber sqrt: 3.
	sqrt5 _ ComplexAlgebraicNumber sqrt: 5.
	10 timesRepeat: [sqrt3 + sqrt5 + sqrt2 - sqrt3 - sqrt5]! !

!AlgebraicNumbersBenchmark methodsFor: 'as yet unclassified' stamp: 'len 4/29/2018 20:34:35'!
testComplexAlgebraicNumberDivision
	| sqrt3 sqrt5 |
	sqrt3 _ ComplexAlgebraicNumber sqrt: 3.
	sqrt5 _ ComplexAlgebraicNumber sqrt: 5.
	10 timesRepeat: [sqrt3 / sqrt5 / sqrt3 / sqrt5]! !

!AlgebraicNumbersBenchmark methodsFor: 'as yet unclassified' stamp: 'len 4/29/2018 20:34:48'!
testComplexAlgebraicNumberProduct
	| sqrt3 sqrt5 |
	sqrt3 _ ComplexAlgebraicNumber sqrt: 3.
	sqrt5 _ ComplexAlgebraicNumber sqrt: 5.
	10 timesRepeat: [sqrt3 * sqrt5 * sqrt3 * sqrt5]! !

!AlgebraicNumbersBenchmark methodsFor: 'as yet unclassified' stamp: 'len 4/29/2018 20:33:28'!
testComplexAlgebraicNumberSquare
	| sqrt2 |
	sqrt2 _ ComplexAlgebraicNumber sqrt2.
	10 timesRepeat: [sqrt2 squared]! !

!AlgebraicNumbersBenchmark methodsFor: 'as yet unclassified' stamp: 'len 4/29/2018 20:33:01'!
testRealAlgebraicNumberAddition
	| sqrt2 sqrt3 sqrt5 |
	sqrt2 _ RealAlgebraicNumber sqrt: 2.
	sqrt3 _ RealAlgebraicNumber sqrt: 3.
	sqrt5 _ RealAlgebraicNumber sqrt: 5.
	10 timesRepeat: [sqrt3 + sqrt5 + sqrt2 - sqrt3 - sqrt5]! !

!AlgebraicNumbersBenchmark methodsFor: 'as yet unclassified' stamp: 'len 4/29/2018 20:33:06'!
testRealAlgebraicNumberDivision
	| sqrt3 sqrt5 |
	sqrt3 _ RealAlgebraicNumber sqrt: 3.
	sqrt5 _ RealAlgebraicNumber sqrt: 5.
	10 timesRepeat: [sqrt3 / sqrt5 / sqrt3 / sqrt5]! !

!AlgebraicNumbersBenchmark methodsFor: 'as yet unclassified' stamp: 'len 4/29/2018 20:33:11'!
testRealAlgebraicNumberProduct
	| sqrt3 sqrt5 |
	sqrt3 _ RealAlgebraicNumber sqrt: 3.
	sqrt5 _ RealAlgebraicNumber sqrt: 5.
	10 timesRepeat: [sqrt3 * sqrt5 * sqrt3 * sqrt5]! !

!AlgebraicNumbersBenchmark methodsFor: 'as yet unclassified' stamp: 'len 4/29/2018 20:33:15'!
testRealAlgebraicNumberSquare
	| sqrt2 |
	sqrt2 _ RealAlgebraicNumber sqrt2.
	10 timesRepeat: [sqrt2 squared]! !

!GroebnerBasisBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:33:01'!
testCyclic3
	(Ñ polynomialsIn: 3) cyclicIdeal groebnerBasis! !

!GroebnerBasisBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:33:01'!
testCyclic4
	(Ñ polynomialsIn: 4) cyclicIdeal groebnerBasis! !

!GroebnerBasisBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:33:01'!
testCyclic5
	(Ñ polynomialsIn: 5) cyclicIdeal groebnerBasis! !

!GroebnerBasisBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:33:01'!
testEliminationExample
	| Qx x y z I |
	Qx _ Ñ polynomialsIn: #(x y z).
	x _ Qx x. y _ Qx y. z _ Qx z.
	I _ Qx * {x^2 + y + z - 1. x + (y^2) + z - 1. x + y + (z^2) - 1}.
	I eliminateAll: #(1 2)! !

!GroebnerBasisBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:33:01'!
testKatsura2
	(Ñ polynomialsIn: 2) katsuraIdeal groebnerBasis! !

!GroebnerBasisBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:33:01'!
testKatsura3
	(Ñ polynomialsIn: 3) katsuraIdeal groebnerBasis! !

!GroebnerBasisBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:33:01'!
testKatsura4
	(Ñ polynomialsIn: 4) katsuraIdeal groebnerBasis! !

!GroebnerBasisBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/12/2018 17:03:54'!
testModularCyclic3
	((PrimeField new: 32003) polynomialsIn: 3) cyclicIdeal groebnerBasis! !

!GroebnerBasisBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/5/2019 05:10:15'!
testModularCyclic4
	((PrimeField new: 32003) polynomialsIn: 4) cyclicIdeal groebnerBasis! !

!GroebnerBasisBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/5/2019 05:09:43'!
testModularCyclic5
	((PrimeField new: 32003) polynomialsIn: 5) cyclicIdeal groebnerBasis! !

!GroebnerBasisBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/12/2018 17:15:14'!
testModularKatsura2
	((PrimeField new: 32003) polynomialsIn: 2) katsuraIdeal groebnerBasis! !

!GroebnerBasisBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/12/2018 17:15:31'!
testModularKatsura3
	((PrimeField new: 32003) polynomialsIn: 3) katsuraIdeal groebnerBasis! !

!GroebnerBasisBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/12/2018 17:15:39'!
testModularKatsura4
	((PrimeField new: 32003) polynomialsIn: 4) katsuraIdeal groebnerBasis! !

!GroupBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/15/2016 06:42'!
testJ1Order
	PermutationGroup J1 size! !

!GroupBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/15/2016 06:43'!
testM12Order
	PermutationGroup M12 size! !

!IntegersBenchmark methodsFor: 'as yet unclassified' stamp: 'len 7/3/2016 04:28'!
test1000Factorial
	1000 factorial! !

!ModularMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 6/9/2018 20:09:17'!
field: aField
	field _ aField! !

!ModularMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
setUp
	| random |
	random _ Random seed: 1234.
	field isNil ifTrue: [field _ 	É/32003].
	matrix _ field matrix: 300@300 evaluating: [:i :j| field atRandom: random]! !

!ModularMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/22/2016 11:55:20'!
testAddition
	matrix + matrix! !

!ModularMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 3/1/2017 09:06:54'!
testGaussianElimination
	matrix reduction reduced! !

!ModularMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 3/1/2017 09:33:07'!
testImage
	matrix image! !

!ModularMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 3/1/2017 09:33:01'!
testKernel
	matrix kernel! !

!ModularMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/22/2016 11:54:33'!
testSquared
	matrix squared! !

!ModularMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/22/2016 11:55:03'!
testTransposition
	matrix transposed! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testAdditionOverZ
	| P f g |
	P _ É polynomials.
	f _ P atRandomBits: 100 maxDegree: 50.
	g _ P atRandomBits: 100 maxDegree: 50.
	10000 timesRepeat: [f + g]! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testAdditionOverZ2
	| P f g |
	P _ É / 2 :: polynomials.
	f _ P atRandomDegree: 50.
	g _ P atRandomDegree: 50.
	10000 timesRepeat: [f + g]! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:33:01'!
testDivisionOverQ
	| P x f g |
	P _ Ñ polynomials.
	x _ P x.
	f _ x^2 + x + 1 ^ 10.
	g _ 1 - x ^ 10.
	2000 timesRepeat: [f // g. f \\ g]! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testDivisionOverZ
	| P x f g |
	P _ É polynomials.
	x _ P x.
	f _ x^2 + x + 1 ^ 10.
	g _ 1 - x ^ 10.
	2000 timesRepeat: [f // g. f \\ g]! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testFactorizationOverZ17Degree100
	| n f |
	n _ 100.
	f _ (É/17) polynomials !! [:x| ((1 to: n) sum: [:i| x^i*i]) + 1].
	f factors! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testFactorizationOverZ3Degree11Times20
	| F Fx x one f |
	F _ É / 3.
	Fx _ F polynomials.
	x _ Fx x.
	one _ Fx one.
	f _ x^11 + (x^9 * 2) + (x^8 * 2) + (x^6) + (x^5) + (x^3 * 2) + (x^2 * 2) + one.
	20 timesRepeat: [f factors]! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/26/2018 19:28:38'!
testFiniteField
	"Benchmark Polynomial>>#= and ResidueClass#>>="
	| F |
	F _ GaloisField new: 9.
	((F^3) upTo: 9^3) asSet size = (9^3) ifFalse: [self halt]! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:33:01'!
testGCDOverQ
	| P x f g |
	P _ Ñ polynomials.
	x _ P x.
	f _ x^4 - 1 ^ 5.
	g _ x^6 - 1 ^ 5.
	2000 timesRepeat: [f gcd: g]! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testGCDOverZ
	| P x f g |
	P _ É polynomials.
	x _ P x.
	f _ x^4 - 1 ^ 5.
	g _ x^6 - 1 ^ 5.
	2000 timesRepeat: [f gcd: g]! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testGCDOverZ2
	| P x f g |
	P _ É / 2 :: polynomials.
	x _ P x.
	f _ x^4 - 1 ^ 5.
	g _ x^6 - 1 ^ 5.
	2000 timesRepeat: [f gcd: g]! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testMultiplication2OverZ
	| P f g |
	P _ É polynomials.
	f _ P atRandomBits: 100 maxDegree: 50.
	g _ P atRandomBits: 100 maxDegree: 50.
	100 timesRepeat: [f * g]! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/26/2018 18:13:05'!
testMultiplication2OverZ2
	| P f g |
	P _ PrimeField new: 2 :: polynomials.
	f _ P atRandomBits: 100 maxDegree: 50.
	g _ P atRandomBits: 100 maxDegree: 50.
	100 timesRepeat: [f * g]! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:33:01'!
testMultiplicationOverZ
	| P x f |
	P _ Ñ polynomials.
	x _ P x.
	f _ x - 1.
	1 to: 9 do: [:i| f _ x - i * f * f]! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/26/2018 18:13:19'!
testMultiplicationOverZ2
	| P x f |
	P _ PrimeField new: 2 :: polynomials.
	x _ P x.
	f _ x - (1 % 2).
	1 to: 9 do: [:i| f _ x - (i % 2) * f * f]! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testMultivariatePolynomialAdditionOverZ
	| P f g |
	P _ É polynomialsIn: #(x y z).
	f _ P atRandomBits: 100 maxDegree: 50.
	g _ P atRandomBits: 100 maxDegree: 50.
	10000 timesRepeat: [f + g]! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testPseudoDivision
	| Zx x a b |
	Zx _ É polynomials.
	x _ Zx x.
	a _ x^8 + (x^6) - (3*(x^4)) - (3*(x^3)) + (8*(x^2)) + (2*x) - 5.
	b _ 3*(x^6) + (5*(x^4)) - (4*(x^2)) - (9*x) + 21.
	20 timesRepeat: [(a pseudoDivisionBy: b) quotient]! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
testPseudoRemainder
	| Zx x a b |
	Zx _ É polynomials.
	x _ Zx x.
	a _ x^8 + (x^6) - (3*(x^4)) - (3*(x^3)) + (8*(x^2)) + (2*x) - 5.
	b _ 3*(x^6) + (5*(x^4)) - (4*(x^2)) - (9*x) + 21.
	20 timesRepeat: [a pseudoRem: b]! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:33:01'!
testRealRoots
	| x f |
	x _ Ñ polynomials x.
	f _ (x-(1/2))^2*(x-2)*(x^2 + 1)*(x^2-2).
	20 timesRepeat: [f rootsIn: Ö]! !

!SmallMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
setUp
	integerMatrix _ É ^ (64@64) :: atRandomBits: 10000.
	binaryMatrix _ (PrimeField new: 2) ^ (64@64) :: atRandom.
	modularMatrix _ (PrimeField new: 32003) ^ (64@64) :: atRandom! !

!SmallMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 7/8/2016 02:48'!
testAdditionZ
	integerMatrix + integerMatrix! !

!SmallMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 7/8/2016 02:48'!
testAdditionZ2
	binaryMatrix + binaryMatrix! !

!SmallMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 12/2/2016 09:24:56'!
testAdditionZp
	modularMatrix + modularMatrix! !

!SmallMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 7/8/2016 02:49'!
testCopyZ
	integerMatrix copy! !

!SmallMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 7/8/2016 02:50'!
testCopyZ2
	binaryMatrix copy! !

!SmallMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 12/2/2016 09:24:46'!
testCopyZp
	modularMatrix copy! !

!SmallMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 4/26/2018 20:41:21'!
testImageZ
	integerMatrix image! !

!SmallMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 3/1/2017 09:36:24'!
testImageZ2
	binaryMatrix image! !

!SmallMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 3/1/2017 09:36:52'!
testImageZp
	modularMatrix image! !

!SmallMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 4/26/2018 20:41:50'!
testKernelZ
	integerMatrix kernel! !

!SmallMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 3/1/2017 09:36:17'!
testKernelZ2
	binaryMatrix kernel! !

!SmallMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 3/1/2017 09:36:46'!
testKernelZp
	modularMatrix kernel! !

!SmallMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 7/8/2016 02:49'!
testMultiplicationZ
	integerMatrix * integerMatrix! !

!SmallMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 7/8/2016 02:58'!
testMultiplicationZ2
	binaryMatrix * binaryMatrix! !

!SmallMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 12/2/2016 09:24:37'!
testMultiplicationZp
	modularMatrix * modularMatrix! !

!SmallMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 7/8/2016 02:49'!
testTranspositionZ
	integerMatrix transposed! !

!SmallMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 7/8/2016 02:58'!
testTranspositionZ2
	binaryMatrix transposed! !

!SmallMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 12/2/2016 09:24:25'!
testTranspositionZp
	modularMatrix transposed! !

!SparsePolynomialMultiplicationBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
setUp
	| P x y z |
	P _ É polynomialsIn: #(x y z).
	x _ P x.
	y _ P y.
	z _ P z.
	p _ (1+x+y+z)^20.
	pBigCoefficients _ 10000000001*(1+x+y+z)^20. "big coefficients"
	pBigExponents _ 1 + (x^2147483647) + (y^2147483647) + (z^2147483647) ^ 20. "big exponents"
	pPlusOne _ p + 1.
	pBigCoefficientsPlusOne _ pBigCoefficients + 1.
	pBigExponentsPlusOne _ pBigExponents + 1! !

!SparsePolynomialMultiplicationBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/22/2016 11:48:43'!
testBigCoefficientsProduct
	pBigCoefficients * pBigCoefficientsPlusOne! !

!SparsePolynomialMultiplicationBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/22/2016 11:49:00'!
testBigExponentsProduct
	pBigExponents * pBigExponentsPlusOne! !

!SparsePolynomialMultiplicationBenchmark methodsFor: 'as yet unclassified' stamp: 'len 6/5/2016 08:44'!
testProduct
	p * pPlusOne! !

!TupleConvolutionBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:34:55'!
setUp
	| n R |
	n _ 80.
	R _ É^n.
	a _ R atRandomBits: n*10.
	b _ R atRandomBits: n*10! !

!TupleConvolutionBenchmark methodsFor: 'as yet unclassified' stamp: 'len 6/6/2019 09:31:24'!
testConvolution
	a convolution: b! !

!TupleConvolutionBenchmark methodsFor: 'as yet unclassified' stamp: 'len 6/6/2019 09:31:54'!
testConvolution2
	a convolution2: b! !

!CASBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/19/2016 11:05:43'!
run
	| output |
	output _ WriteStream on: (String new: 1000).
	(self class selectors asArray select: [:each|
		(each beginsWith: 'test') and: [each numArgs isZero]]) sort
		do: [:each|
			output nextPutAll: each; tab.
			"self setUp."
			Smalltalk garbageCollect.
			[output nextPutAll: (self perform: each)] on: Error do: [output nextPutAll: 'FAILED'].
			"self tearDown"]
		separatedBy: [output newLine].
	^ output contents! !

!CASBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/19/2016 18:35:51'!
testConvolution: a with: b into: c modulo: m
	c atAllPut: 0.
	1 to: a size do: [:i|
		1 to: b size do: [:j| | index |
			index _ i+j-1.
			c at: index put: (a at: i) * (b at: j) + (c at: index) \\ m]].
	^ c! !

!CASBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/19/2016 18:02:38'!
testDotProduct: a with: b modulo: m
	| answer |
	answer _ 0.
	1 to: a size do: [:i| answer _ (a at: i) * (b at: i) + answer \\ m].
	^ answer! !

!CASBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/19/2016 17:55:38'!
testEqualsBytes
	| random a b |
	random _ Random seed: 1234.
	a _ ((1 to: 1000) collect: [:each| (random nextInteger: 256) - 1]) asByteArray.
	b _ a copy.
	^ [a = b] bench! !

!CASBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/19/2016 17:57:31'!
testEqualsWords
	| random a b |
	random _ Random seed: 1234.
	a _ ((1 to: 1000) collect: [:each| (random nextInteger: 256) - 1]) asWordArray.
	b _ a copy.
	^ [a = b] bench! !

!CASBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/19/2016 17:57:05'!
testHashBytes
	| random a |
	random _ Random seed: 1234.
	a _ ((1 to: 1000) collect: [:each| (random nextInteger: 256) - 1]) asByteArray.
	^ [a hash] bench! !

!CASBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/19/2016 17:57:21'!
testHashWords
	| random a |
	random _ Random seed: 1234.
	a _ ((1 to: 1000) collect: [:each| (random nextInteger: 256) - 1]) asWordArray.
	^ [a hash] bench! !

!CASBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/19/2016 18:01:16'!
testModularConvolutionBytes
	| random p a b c |
	p _ 251.
	random _ Random seed: 1234.
	a _ ((1 to: 1000) collect: [:each| (random nextInteger: p) - 1]) asByteArray.
	b _ ((1 to: 1000) collect: [:each| (random nextInteger: p) - 1]) asByteArray.
	c _ ByteArray new: 2000.
	^ [self testConvolution: a with: b into: c modulo: p] bench! !

!CASBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/19/2016 17:59:23'!
testModularConvolutionWords
	| random p a b c |
	p _ 32003.
	random _ Random seed: 1234.
	a _ ((1 to: 1000) collect: [:each| (random nextInteger: p) - 1]) asWordArray.
	b _ ((1 to: 1000) collect: [:each| (random nextInteger: p) - 1]) asWordArray.
	c _ WordArray new: 2000.
	^ [self testConvolution: a with: b into: c modulo: p] bench! !

!CASBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/19/2016 18:03:18'!
testModularDotProductBytes
	| random p a b |
	p _ 251.
	random _ Random seed: 1234.
	a _ ((1 to: 1000) collect: [:each| (random nextInteger: p) - 1]) asByteArray.
	b _ ((1 to: 1000) collect: [:each| (random nextInteger: p) - 1]) asByteArray.
	^ [self testDotProduct: a with: b modulo: p] bench! !

!CASBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/19/2016 18:03:50'!
testModularDotProductWords
	| random p a b |
	p _ 32003.
	random _ Random seed: 1234.
	a _ ((1 to: 1000) collect: [:each| (random nextInteger: p) - 1]) asWordArray.
	b _ ((1 to: 1000) collect: [:each| (random nextInteger: p) - 1]) asWordArray.
	^ [self testDotProduct: a with: b modulo: p] bench! !

!CASBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/19/2016 18:01:23'!
testModularSumBytes
	| random p a b c |
	p _ 251.
	random _ Random seed: 1234.
	a _ ((1 to: 1000) collect: [:each| (random nextInteger: p) - 1]) asByteArray.
	b _ ((1 to: 1000) collect: [:each| (random nextInteger: p) - 1]) asByteArray.
	c _ ByteArray new: 1000.
	^ [self testSum: a with: b into: c modulo: p] bench! !

!CASBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/19/2016 17:59:15'!
testModularSumWords
	| random p a b c |
	p _ 32003.
	random _ Random seed: 1234.
	a _ ((1 to: 1000) collect: [:each| (random nextInteger: p) - 1]) asWordArray.
	b _ ((1 to: 1000) collect: [:each| (random nextInteger: p) - 1]) asWordArray.
	c _ WordArray new: 1000.
	^ [self testSum: a with: b into: c modulo: p] bench! !

!CASBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/19/2016 19:09:54'!
testPermutate: a with: b into: c
	1 to: a size do: [:i| c at: i put: (b at: (a at: i))]! !

!CASBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/19/2016 19:08:57'!
testPermutationCompositionArray
	| n a b c |
	n _ 1000.
	a _ (1 to: n) shuffled.
	b _ (1 to: n) shuffled.
	c _ Array new: n.
	^ [self testPermutate: a with: b into: c] bench! !

!CASBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/19/2016 11:11:52'!
testPermutationCompositionWords
	| n a b c |
	n _ 1000.
	a _ (1 to: n) shuffled asWordArray.
	b _ (1 to: n) shuffled asWordArray.
	c _ WordArray new: n.
	^ [self testPermutate: a with: b into: c] bench! !

!CASBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/19/2016 10:57:34'!
testSum: a with: b into: c modulo: m
	1 to: a size do: [:i| c at: i put: (a at: i) + (b at: i) \\ m].
	^ c! !
