'From Cuis 5.0 of 7 November 2016 [latest update: #2974] on 14 February 2017 at 8:20:23 pm'!
'Description Please enter a description for this package'!
!provides: 'MathematicsTests' 1 68!
!classDefinition: #AbelianGroupTest category: #MathematicsTests!
TestCase subclass: #AbelianGroupTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'AbelianGroupTest class' category: #MathematicsTests!
AbelianGroupTest class
	instanceVariableNames: ''!

!classDefinition: #AffineGeometryTest category: #MathematicsTests!
TestCase subclass: #AffineGeometryTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'AffineGeometryTest class' category: #MathematicsTests!
AffineGeometryTest class
	instanceVariableNames: ''!

!classDefinition: #AlgebraicGeometryTest category: #MathematicsTests!
TestCase subclass: #AlgebraicGeometryTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'AlgebraicGeometryTest class' category: #MathematicsTests!
AlgebraicGeometryTest class
	instanceVariableNames: ''!

!classDefinition: #AlgebraicNumbersTest category: #MathematicsTests!
TestCase subclass: #AlgebraicNumbersTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'AlgebraicNumbersTest class' category: #MathematicsTests!
AlgebraicNumbersTest class
	instanceVariableNames: ''!

!classDefinition: #CodesTest category: #MathematicsTests!
TestCase subclass: #CodesTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'CodesTest class' category: #MathematicsTests!
CodesTest class
	instanceVariableNames: ''!

!classDefinition: #CommutativeAlgebraTest category: #MathematicsTests!
TestCase subclass: #CommutativeAlgebraTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'CommutativeAlgebraTest class' category: #MathematicsTests!
CommutativeAlgebraTest class
	instanceVariableNames: ''!

!classDefinition: #EllipticCurvesTest category: #MathematicsTests!
TestCase subclass: #EllipticCurvesTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'EllipticCurvesTest class' category: #MathematicsTests!
EllipticCurvesTest class
	instanceVariableNames: ''!

!classDefinition: #GraphTest category: #MathematicsTests!
TestCase subclass: #GraphTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'GraphTest class' category: #MathematicsTests!
GraphTest class
	instanceVariableNames: ''!

!classDefinition: #GroupTest category: #MathematicsTests!
TestCase subclass: #GroupTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'GroupTest class' category: #MathematicsTests!
GroupTest class
	instanceVariableNames: ''!

!classDefinition: #LinearBasisTest category: #MathematicsTests!
TestCase subclass: #LinearBasisTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'LinearBasisTest class' category: #MathematicsTests!
LinearBasisTest class
	instanceVariableNames: ''!

!classDefinition: #LinearGroupsTest category: #MathematicsTests!
TestCase subclass: #LinearGroupsTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'LinearGroupsTest class' category: #MathematicsTests!
LinearGroupsTest class
	instanceVariableNames: ''!

!classDefinition: #MathematicsTest category: #MathematicsTests!
TestCase subclass: #MathematicsTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'MathematicsTest class' category: #MathematicsTests!
MathematicsTest class
	instanceVariableNames: ''!

!classDefinition: #MatrixTest category: #MathematicsTests!
TestCase subclass: #MatrixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'MatrixTest class' category: #MathematicsTests!
MatrixTest class
	instanceVariableNames: ''!

!classDefinition: #ModularTest category: #MathematicsTests!
TestCase subclass: #ModularTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'ModularTest class' category: #MathematicsTests!
ModularTest class
	instanceVariableNames: ''!

!classDefinition: #ModuleTest category: #MathematicsTests!
TestCase subclass: #ModuleTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'ModuleTest class' category: #MathematicsTests!
ModuleTest class
	instanceVariableNames: ''!

!classDefinition: #MonomialTest category: #MathematicsTests!
TestCase subclass: #MonomialTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'MonomialTest class' category: #MathematicsTests!
MonomialTest class
	instanceVariableNames: ''!

!classDefinition: #NumberFieldTest category: #MathematicsTests!
TestCase subclass: #NumberFieldTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'NumberFieldTest class' category: #MathematicsTests!
NumberFieldTest class
	instanceVariableNames: ''!

!classDefinition: #PAdicsTest category: #MathematicsTests!
TestCase subclass: #PAdicsTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'PAdicsTest class' category: #MathematicsTests!
PAdicsTest class
	instanceVariableNames: ''!

!classDefinition: #PolynomialTest category: #MathematicsTests!
TestCase subclass: #PolynomialTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'PolynomialTest class' category: #MathematicsTests!
PolynomialTest class
	instanceVariableNames: ''!

!classDefinition: #ProjectiveGeometryTest category: #MathematicsTests!
TestCase subclass: #ProjectiveGeometryTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'ProjectiveGeometryTest class' category: #MathematicsTests!
ProjectiveGeometryTest class
	instanceVariableNames: ''!

!classDefinition: #RingTest category: #MathematicsTests!
TestCase subclass: #RingTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'RingTest class' category: #MathematicsTests!
RingTest class
	instanceVariableNames: ''!

!classDefinition: #RootSystemTest category: #MathematicsTests!
TestCase subclass: #RootSystemTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'RootSystemTest class' category: #MathematicsTests!
RootSystemTest class
	instanceVariableNames: ''!

!classDefinition: #SequenceTest category: #MathematicsTests!
TestCase subclass: #SequenceTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'SequenceTest class' category: #MathematicsTests!
SequenceTest class
	instanceVariableNames: ''!

!classDefinition: #SimplicialComplexTest category: #MathematicsTests!
TestCase subclass: #SimplicialComplexTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'SimplicialComplexTest class' category: #MathematicsTests!
SimplicialComplexTest class
	instanceVariableNames: ''!

!classDefinition: #TupleTest category: #MathematicsTests!
TestCase subclass: #TupleTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'TupleTest class' category: #MathematicsTests!
TupleTest class
	instanceVariableNames: ''!

!classDefinition: #Benchmark category: #MathematicsTests!
Object subclass: #Benchmark
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'Benchmark class' category: #MathematicsTests!
Benchmark class
	instanceVariableNames: ''!

!classDefinition: #GroebnerBasisBenchmark category: #MathematicsTests!
Benchmark subclass: #GroebnerBasisBenchmark
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'GroebnerBasisBenchmark class' category: #MathematicsTests!
GroebnerBasisBenchmark class
	instanceVariableNames: ''!

!classDefinition: #GroupBenchmark category: #MathematicsTests!
Benchmark subclass: #GroupBenchmark
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'GroupBenchmark class' category: #MathematicsTests!
GroupBenchmark class
	instanceVariableNames: ''!

!classDefinition: #IntegersBenchmark category: #MathematicsTests!
Benchmark subclass: #IntegersBenchmark
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'IntegersBenchmark class' category: #MathematicsTests!
IntegersBenchmark class
	instanceVariableNames: ''!

!classDefinition: #ModularMatrixBenchmark category: #MathematicsTests!
Benchmark subclass: #ModularMatrixBenchmark
	instanceVariableNames: 'matrix'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'ModularMatrixBenchmark class' category: #MathematicsTests!
ModularMatrixBenchmark class
	instanceVariableNames: ''!

!classDefinition: #PolynomialBenchmark category: #MathematicsTests!
Benchmark subclass: #PolynomialBenchmark
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'PolynomialBenchmark class' category: #MathematicsTests!
PolynomialBenchmark class
	instanceVariableNames: ''!

!classDefinition: #SmallMatrixBenchmark category: #MathematicsTests!
Benchmark subclass: #SmallMatrixBenchmark
	instanceVariableNames: 'integerMatrix binaryMatrix modularMatrix'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'SmallMatrixBenchmark class' category: #MathematicsTests!
SmallMatrixBenchmark class
	instanceVariableNames: ''!

!classDefinition: #SparsePolynomialMultiplicationBenchmark category: #MathematicsTests!
Benchmark subclass: #SparsePolynomialMultiplicationBenchmark
	instanceVariableNames: 'p pPlusOne pBigCoefficients pBigExponents pBigCoefficientsPlusOne pBigExponentsPlusOne'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'SparsePolynomialMultiplicationBenchmark class' category: #MathematicsTests!
SparsePolynomialMultiplicationBenchmark class
	instanceVariableNames: ''!

!classDefinition: #CASBenchmark category: #MathematicsTests!
Object subclass: #CASBenchmark
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'CASBenchmark class' category: #MathematicsTests!
CASBenchmark class
	instanceVariableNames: ''!


!GroebnerBasisBenchmark commentStamp: 'len 1/26/2017 08:31:28' prior: 0!
GroebnerBasisBenchmark new run

testCyclic3	4,400 per second. (optimized GroebnerBasis>>reduce:)
testCyclic4	1,000 per second.
testCyclic5	238 per second.
testCyclic6	58 per second.
testEliminationExample	1,840 per second.
testKatsura2	13,600 per second.
testKatsura3	1,950 per second.
testKatsura4	15.6 per second.
testModularCyclic3	4,270 per second.
testModularKatsura2	12,600 per second.
testModularKatsura3	1,800 per second.
testModularKatsura4	20.6 per second.

testCyclic3	2,260 per second. (modular inversion using extended euclid)
testCyclic4	520 per second.
testCyclic5	124 per second.
testCyclic6	28.9 per second.
testEliminationExample	897 per second.
testKatsura2	6,690 per second.
testKatsura3	869 per second.
testKatsura4	10.6 per second.
testModularCyclic3	2,430 per second.
testModularKatsura2	7,470 per second.
testModularKatsura3	1,050 per second.
testModularKatsura4	15.5 per second.

testCyclic3	2,230 per second. (polynomials as sorted dictionaries monomial -> coefficient)
testCyclic4	512 per second.
testCyclic5	121 per second.
testCyclic6	28.7 per second.
testEliminationExample	867 per second.
testKatsura2	6,700 per second.
testKatsura3	860 per second.
testKatsura4	11 per second.
testModularCyclic3	2,320 per second.
testModularKatsura2	6,960 per second.
testModularKatsura3	858 per second.
testModularKatsura4	12.1 per second.

testCyclic3	2,270 per second. (polynomials as dictionaries monomial -> coefficient)
testCyclic4	511 per second.
testCyclic5	118 per second.
testCyclic6	26.1 per second.
testEliminationExample	816 per second.
testKatsura2	6,750 per second.
testKatsura3	866 per second.
testKatsura4	11.8 per second.
testModularCyclic3	2,410 per second.
testModularKatsura2	6,780 per second.
testModularKatsura3	844 per second.
testModularKatsura4	13.3 per second.

testCyclic3	2,240 per second. (with Groebner bases kept sorted, GroebnerBasis>>initialize)
testCyclic4	520 per second.
testCyclic5	120 per second.
testCyclic6	26 per second.
testEliminationExample	720 per second.
testKatsura2	6,730 per second.
testKatsura3	755 per second.
testKatsura4	34.9 per second.
testModularCyclic3	2,310 per second.
testModularKatsura2	6,720 per second.
testModularKatsura3	727 per second.
testModularKatsura4	33 per second.

testCyclic3	2,140 per second. (reverted Monomial>>hash)
testCyclic4	676 per second.
testCyclic5	112 per second.
testCyclic6	36.2 per second.
testEliminationExample	773 per second.
testKatsura2	6,430 per second.
testKatsura3	821 per second.
testKatsura4	7.72 per second.
testModularCyclic3	2,220 per second.
testModularKatsura2	6,490 per second.
testModularKatsura3	797 per second.
testModularKatsura4	12.6 per second.

testCyclic3	2,240 per second. (defined Monomial>>hash as 'exponents hash')
testCyclic4	682 per second.
testCyclic5	116 per second.
testCyclic6	40.4 per second.
testEliminationExample	827 per second.
testKatsura2	6,650 per second.
testKatsura3	857 per second.
testKatsura4	7.82 per second.
testModularCyclic3	2,370 per second.
testModularKatsura2	6,840 per second.
testModularKatsura3	861 per second.
testModularKatsura4	13.6 per second.

testCyclic3	1,780 per second. (spur 32 bits)
testCyclic4	354 per second.
testCyclic5	26.8 per second.
testCyclic6	12.2 per second.
testEliminationExample	614 per second.
testKatsura2	5,540 per second.
testKatsura3	130 per second.
testKatsura4	10.7 per second.
testModularCyclic3	177 per second.
testModularKatsura2	194 per second.

[self new modularCyclic: 7 :: groebnerBasis] bench
 '3.63 per second.' (spur 32 bits)
 '165 seconds.' 

testCyclic3	1,300 per second.
testCyclic4	264 per second.
testCyclic5	60.1 per second.
testCyclic6	9.7 per second.
testElimination	143 per second.
testKatsura2	4,230 per second.
testKatsura3	407 per second.
testKatsura4	4.06 per second.
testModularCyclic3	175 per second.
testModularKatsura2	194 per second. 

testCyclic3	1,130 per second.
testCyclic4	195 per second.
testCyclic5	48.7 per second.
testCyclic6	9.31 per second.
testElimination	116 per second.
testKatsura2	3,440 per second.
testKatsura3	354 per second.
testKatsura4	2.8 per second.
testModularCyclic3	149 per second.
testModularKatsura2	184 per second.'

'testCyclic3	1,080 per second.
testCyclic4	36.8 per second.
testCyclic5	1.19 per second.
testElimination	77.1 per second.
testKatsura2	3,810 per second.
testKatsura3	26.1 per second.
testModularCyclic3	173 per second.
testModularKatsura2	201 per second.' 

testCyclic3	1,060 per second.
testCyclic4	56.3 per second.
testCyclic5	1.08 per second.
testElimination	241 per second.
testKatsura2	4,790 per second.
testKatsura3	11.5 per second.
testModularCyclic3	173 per second.
testModularKatsura2	200 per second.

testCyclic3	615 per second.
testCyclic4	29.2 per second.
testCyclic5	1.38 per second.
testElimination	43.5 per second.
testKatsura2	2,330 per second.
testKatsura3	7.21 per second.

testCyclic3	632 per second.
testCyclic4	4.34 per second.
testElimination	3.45 per second.
testKatsura2	2,190 per second.
testKatsura3	0.288 per second.

testCyclic3	524 per second.
testCyclic4	4.85 per second.
testElimination	2.82 per second.
testKatsura2	1,950 per second.
testKatsura3	0.251 per second.

testCyclic3	540 per second.
testCyclic4	3.73 per second.
testElimination	2 per second.
testKatsura2	2,130 per second.
testKatsura3	0.257 per second.

testCyclic3	494 per second.
testCyclic4	2.41 per second.
testElimination	1.34 per second.
testKatsura2	1,950 per second.
testKatsura3	5.38 seconds.

testCyclic3	393 per second.
testCyclic4	1.62 per second.
testElimination	1.29 per second.
testKatsura2	1,830 per second.
testKatsura3	6.58 seconds.

old:
testCyclic3	312 per second.
testElimination	0.911 per second.
testKatsura2	1,260 per second.
!

!GroupBenchmark commentStamp: '<historical>' prior: 0!
GroupBenchmark new run

testJ1Order	3.95 per second. (spur 32 bits)
testM12Order	86.7 per second.

testJ1Order	2.39 per second.
testM12Order	57.4 per second.

testJ1Order	2.51 per second.
testM12Order	56.9 per second.
!

!IntegersBenchmark commentStamp: 'len 11/22/2016 11:57:33' prior: 0!
self new run

test1000Factorial	5,620 per second. (spur 32 bits)

test1000Factorial	1,250 per second.
!

!ModularMatrixBenchmark commentStamp: '<historical>' prior: 0!
Some tests on a 300x300 matrix over Z/32003.

self new run

testAddition	387 per second.
testGaussianElimination	1.82 per second.
testSquared	1.43 per second.
testTransposition	89.7 per second.

testAddition	203 per second.
testGaussianElimination	1.81 per second.
testSquared	1.32 per second.
testTransposition	66.9 per second.!

!PolynomialBenchmark commentStamp: 'len 11/28/2016 20:15:00' prior: 0!
PolynomialBenchmark new run

testFiniteField	17.1 per second.
testFiniteFieldPolynomialFactorization	97.8 per second.
testMultivariatePolynomialAdditionOverZ	93.9 per second.
testPolynomialAdditionOverZ	32.6 per second.
testPolynomialAdditionOverZ2	136 per second.
testPolynomialDivisionOverQ	2.63 per second.
testPolynomialDivisionOverZ	2.74 per second.
testPolynomialGCDOverQ	2.88 per second.
testPolynomialGCDOverZ	4.3 per second.
testPolynomialGCDOverZ2	11.3 per second.
testPolynomialMultiplication2OverZ	163 per second.
testPolynomialMultiplication2OverZ2	628 per second.
testPolynomialMultiplicationOverZ	2.7 per second.
testPolynomialMultiplicationOverZ2	3,760 per second.
testPolynomialPseudoDivision	4,110 per second.
testPolynomialPseudoRemainder	4,080 per second.
testPolynomialRealRoots	39.7 per second.
testRealAlgebraicNumberAddition	5.44 seconds.
testRealAlgebraicNumberDivision	154 per second.
testRealAlgebraicNumberProduct	177 per second.
testRealAlgebraicNumberSquare	4,200 per second.

testFiniteField	17.5 per second. (spur 32 bits)
testFiniteFieldPolynomialFactorization	81.3 per second.
testMultivariatePolynomialAdditionOverZ	86.8 per second.
testPolynomialAdditionOverZ	31.2 per second.
testPolynomialAdditionOverZ2	135 per second.
testPolynomialDivisionOverQ	2.57 per second.
testPolynomialDivisionOverZ	2.64 per second.
testPolynomialGCDOverQ	2.44 per second.
testPolynomialGCDOverZ	3.51 per second.
testPolynomialGCDOverZ2	9.86 per second.
testPolynomialMultiplication2OverZ	105 per second.
testPolynomialMultiplication2OverZ2	627 per second.
testPolynomialMultiplicationOverZ	2.72 per second.
testPolynomialMultiplicationOverZ2	3,400 per second.
testPolynomialPseudoDivision	3,660 per second.
testPolynomialPseudoRemainder	3,640 per second.
testPolynomialRealRoots	38.7 per second.
testRealAlgebraicNumberAddition	5.27 seconds.
testRealAlgebraicNumberDivision	148 per second.
testRealAlgebraicNumberProduct	170 per second.
testRealAlgebraicNumberSquare	3,970 per second.

testFiniteField	14.6 per second.
testFiniteFieldPolynomialFactorization	58.4 per second.
testMultivariatePolynomialAdditionOverZ	51.7 per second.
testPolynomialAdditionOverZ	15.8 per second.
testPolynomialAdditionOverZ2	94 per second.
testPolynomialDivisionOverQ	1.66 per second.
testPolynomialDivisionOverZ	1.67 per second.
testPolynomialGCDOverQ	1.54 per second.
testPolynomialGCDOverZ	2.22 per second.
testPolynomialGCDOverZ2	7.01 per second.
testPolynomialMultiplication2OverZ	78 per second.
testPolynomialMultiplication2OverZ2	384 per second.
testPolynomialMultiplicationOverZ	0.598 per second.
testPolynomialMultiplicationOverZ2	2,220 per second.
testPolynomialPseudoDivision	2,300 per second.
testPolynomialPseudoRemainder	2,300 per second.
testPolynomialRealRoots	27.3 per second.
testRealAlgebraicNumberAddition	5.24 seconds.
testRealAlgebraicNumberDivision	110 per second.
testRealAlgebraicNumberProduct	132 per second.
testRealAlgebraicNumberSquare	2,720 per second.

testFiniteField	11.1 per second.
testFiniteFieldPolynomialFactorization	58 per second.
testMultivariatePolynomialAdditionOverZ	FAILED
testPolynomialAdditionOverZ	11.9 per second.
testPolynomialAdditionOverZ2	76.2 per second.
testPolynomialDivisionOverQ	1.23 per second.
testPolynomialDivisionOverZ	1.12 per second.
testPolynomialGCDOverQ	1.16 per second.
testPolynomialGCDOverZ	1.45 per second.
testPolynomialGCDOverZ2	4.64 per second.
testPolynomialMultiplication2OverZ	33.9 per second.
testPolynomialMultiplication2OverZ2	58.4 per second.
testPolynomialMultiplicationOverZ	0.588 per second.
testPolynomialMultiplicationOverZ2	2,260 per second.
testPolynomialPseudoDivision	1,210 per second.
testPolynomialPseudoRemainder	1,220 per second.
testPolynomialRealRoots	22.8 per second.
testRealAlgebraicNumberAddition	5.28 seconds.
testRealAlgebraicNumberDivision	74.1 per second.
testRealAlgebraicNumberProduct	88.6 per second.
testRealAlgebraicNumberSquare	2,020 per second.

testFiniteField	10.8 per second.
testFiniteFieldPolynomialFactorization	55.1 per second.
testMultivariatePolynomialAdditionOverZ	FAILED
testPolynomialAdditionOverZ	11.9 per second.
testPolynomialAdditionOverZ2	69 per second.
testPolynomialDivisionOverQ	1.2 per second.
testPolynomialDivisionOverZ	1.04 per second.
testPolynomialGCDOverQ	1.12 per second.
testPolynomialGCDOverZ	1.38 per second.
testPolynomialGCDOverZ2	4.25 per second.
testPolynomialMultiplication2OverZ	33 per second.
testPolynomialMultiplication2OverZ2	61.4 per second.
testPolynomialMultiplicationOverZ	0.578 per second.
testPolynomialMultiplicationOverZ2	2,220 per second.
testPolynomialPseudoDivision	1,220 per second.
testPolynomialPseudoRemainder	1,220 per second.
testPolynomialRealRoots	23.1 per second.
testRealAlgebraicNumberAddition	6.11 seconds.
testRealAlgebraicNumberDivision	78.2 per second.
testRealAlgebraicNumberProduct	90.3 per second.
testRealAlgebraicNumberSquare	2,020 per second.

testFiniteField	11.3 per second.
testFiniteFieldPolynomialFactorization	54.5 per second.
testPolynomialAdditionOverZ	10.8 per second.
testPolynomialAdditionOverZ2	75 per second.
testPolynomialDivisionOverQ	1.17 per second.
testPolynomialDivisionOverZ	1.06 per second.
testPolynomialGCDOverQ	1.11 per second.
testPolynomialGCDOverZ	1.38 per second.
testPolynomialGCDOverZ2	4.53 per second.
testPolynomialMultiplication2OverZ	32 per second.
testPolynomialMultiplication2OverZ2	58 per second.
testPolynomialMultiplicationOverZ	0.563 per second.
testPolynomialMultiplicationOverZ2	2,120 per second.
testPolynomialPseudoDivision	1,220 per second.
testPolynomialPseudoRemainder	1,190 per second.
testPolynomialRealRoots	23 per second.
testRealAlgebraicNumberAddition	5.96 seconds.
testRealAlgebraicNumberDivision	70.8 per second.
testRealAlgebraicNumberProduct	81.7 per second.
testRealAlgebraicNumberSquare	1,820 per second!

!SmallMatrixBenchmark commentStamp: 'len 12/2/2016 09:27:43' prior: 0!
This benchmark tests some basic operations on 64x64 matrices over Z, Z/2Z, and Z/32003Z.

self new run

testAdditionZ	7,960 per second.
testAdditionZ2	85,700 per second.
testAdditionZp	7,710 per second.
testCopyZ	162,000 per second.
testCopyZ2	477,000 per second.
testCopyZp	181,000 per second.
testMultiplicationZ	174 per second.
testMultiplicationZ2	161 per second.
testMultiplicationZp	130 per second.
testTranspositionZ	4,600 per second.
testTranspositionZ2	1,090 per second.
testTranspositionZp	2,110 per second.

testAdditionZ	7,840 per second. (spur 32 bits)
testAdditionZ2	86,600 per second.
testCopyZ	144,000 per second.
testCopyZ2	471,000 per second.
testMultiplicationZ	171 per second.
testMultiplicationZ2	159 per second.
testTranspositionZ	4,390 per second.
testTranspositionZ2	1,010 per second.

testAdditionZ	5,220 per second.
testAdditionZ2	42,600 per second.
testCopyZ	84,700 per second.
testCopyZ2	210,000 per second.
testMultiplicationZ	122 per second.
testMultiplicationZ2	106 per second.
testTranspositionZ	2,020 per second.
testTranspositionZ2	603 per second.

testAdditionZ	4,500 per second.
testAdditionZ2	33,700 per second.
testCopyZ	58,200 per second.
testCopyZ2	164,000 per second.
testMultiplicationZ	20.1 per second.
testMultiplicationZ2	7.81 per second.
testTranspositionZ	1,580 per second.
testTranspositionZ2	565 per second.
!

!SparsePolynomialMultiplicationBenchmark commentStamp: 'len 11/30/2016 22:00:58' prior: 0!
Timings giving in [1] on computers with 0.8ghz - 1ghz intel cpus: general purpose system 20s-100s, tuned systems 2.3s-10s. For big coefficients: singular 28s, pari 77s.

[1] R.J. Fateman, Comparing the speed of sparse polynomial multiplication.


self new run

testBigCoefficientsProduct	8.39 seconds. (polynomials as sorted dictionaries monomial -> coefficient)
testBigExponentsProduct	9.86 seconds.
testProduct	0.328 per second.

testBigCoefficientsProduct	10.5 seconds. (polynomials as dictionaries monomial -> coefficient)
testBigExponentsProduct	10.2 seconds.
testProduct	0.289 per second.
!

!CASBenchmark commentStamp: '<historical>' prior: 0!
These benchmarks show some of the fundamental bottlenecks for a computational algebra system in pure Smalltalk. Many important algorithms end up doing these operations.

To run the benchmarks, just doIt:
self new run

Cuis 4.5 with Cog 4.5 #9 (r3370, 2015-06-04), 32 bits, Intel i5-3210M @ 2.5Ghz, cache 3072 KB, 4990 bobomips, running inside virtualbox
testEqualsBytes	40,600 per second.
testEqualsWords	36,100 per second.
testHashBytes	245,000 per second.
testHashWords	23,500 per second.
testModularConvolutionBytes	20.6 per second.
testModularConvolutionWords	16.9 per second.
testModularDotProductBytes	36,900 per second.
testModularDotProductWords	30,400 per second.
testModularSumBytes	26,200 per second.
testModularSumWords	21,600 per second.
testPermutationCompositionArray	33,900 per second.
testPermutationCompositionWords	31,400 per second.

Cuis 5.0 with Cog 5.0-201611161032, 32 bits, Intel i5-3210M @ 2.5Ghz, cache 3072 KB, 4990 bobomips, running inside virtualbox
testEqualsBytes	59,900 per second.
testEqualsWords	49,600 per second.
testHashBytes	249,000 per second.
testHashWords	23,000 per second.
testModularConvolutionBytes	27.2 per second.
testModularConvolutionWords	23.9 per second.
testModularDotProductBytes	41,000 per second.
testModularDotProductWords	37,000 per second.
testModularSumBytes	37,900 per second.
testModularSumWords	34,100 per second.
testPermutationCompositionArray	69,100 per second.
testPermutationCompositionWords	51,900 per second.
!

!AbelianGroupTest methodsFor: 'as yet unclassified' stamp: 'len 12/17/2016 22:23:00'!
testAbelianGroup: G
	| zero a b c |
	zero _ G identity.
	a _ G atRandomBits: 100.
	b _ G atRandomBits: 100.
	c _ G atRandomBits: 100.
	self assert: zero + a = a.
	self assert: a + zero = a.
	self assert: a + b = (b + a). "commutativity"
	self assert: (a + b + c) = (a + (b + c)). "associativity"! !

!AbelianGroupTest methodsFor: 'as yet unclassified' stamp: 'len 12/17/2016 22:24:08'!
testAbelianGroupHomomorphism: phi
	| G H a b |
	G _ phi domain.
	H _ phi codomain.
	a _ G atRandomBits: 100.
	b _ G atRandomBits: 100.
	self assert: (phi value: G identity) = H identity.
	self assert: (phi value: a + b) = ((phi value: a) + (phi value: b))! !

!AbelianGroupTest methodsFor: 'as yet unclassified' stamp: 'len 12/17/2016 22:22:20'!
testDirectSum
	| G |
	G _ ZZ asAbelianGroup  (ZZ / (2 to: 10) atRandom) asAbelianGroup.
	self testAbelianGroup: G.
	self testAbelianGroupHomomorphism: (G projection: 2 atRandom).
	self testAbelianGroupHomomorphism: (G embedding: 2 atRandom)! !

!AbelianGroupTest methodsFor: 'as yet unclassified' stamp: 'len 1/22/2017 08:21:55'!
testIntegerTuples
	| M |
	M _ ZZ ^ (1 to: 10) atRandom.
	self testAbelianGroup: M asAbelianGroup.
	self testAbelianGroupHomomorphism: (M projection: (1 to: M rank) atRandom) asAbelianGroupHomomorphism! !

!AbelianGroupTest methodsFor: 'as yet unclassified' stamp: 'len 12/17/2016 22:26:09'!
testIntegers
	self testAbelianGroup: ZZ asAbelianGroup! !

!AbelianGroupTest methodsFor: 'as yet unclassified' stamp: 'len 12/22/2016 22:52:08'!
testModularIntegers
	| R |
	R _ ZZ / (2 to: 10) atRandom.
	self testAbelianGroup: R asAbelianGroup.
	self testAbelianGroupHomomorphism: R projection asAbelianGroupHomomorphism! !

!AffineGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 1/22/2017 08:21:59'!
testAffineHull
	| V v1 v2 H |
	V _ QQ ^ 3.
	v1 _ (1,0,0).
	v2 _ (2,2,2).
	H _ V hull: {v1. v2}.
	self assert: H isLine.
	self assert: (H includes: v1).
	self assert: (H includes: v2)! !

!AffineGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 1/22/2017 08:22:04'!
testAffineMapCollinearity
	"Affine maps preserve collinearity."
	| A f p1 p1` p2 p2` p3 p3` |
	A _ (QQ ^ 3) asAffineSpace.
	f _ A automorphisms atRandomBits: 100.
	"three collinear points:"
	p1 _ (1,2,3) + (1,0,1). p2 _ (2,4,6) + (1,0,1). p3 _ (-1,-2,-3) + (1,0,1).
	self assert: (A span: {p1.p2.p3}) isLine.
	"the imagees of the three collinear points must be collinear:"
	p1` _ f value: p1. p2` _ f value: p2. p3` _ f value: p3.
	self assert: (A span: {p1`.p2`.p3`}) isLine! !

!AffineGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 1/22/2017 08:22:18'!
testAffineMapComposition
	| X Y Z f g x |
	X _ QQ^3 :: asAffineSpace.
	Y _ QQ^5 :: asAffineSpace.
	Z _ QQ^4 :: asAffineSpace.
	f _ (X hom: Y) atRandomBits: 1000.
	g _ (Y hom: Z) atRandomBits: 1000.
	x _ X atRandomBits: 1000.
	self assert: ((X hom: Z) includes: g ” f).
	self assert: (g ” f value: x) = (g value: (f value: x)).
	self should: [f ” g] raise: DomainError! !

!AffineGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 1/22/2017 08:22:25'!
testAffineMapEvaluating
	| V f |
	V _ QQ^3.
	f _ AffineMap from: V asAffineSpace to: V asAffineSpace evaluating: [:p| p*2 - (1,0,0)].
	self assert: (f value: (1,2,3)) = (1,4,6)! !

!AffineGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 1/22/2017 08:22:31'!
testAffineMapInverse
	| A f |
	A _ (QQ^3) asAffineSpace.
	f _ A automorphisms atRandomBits: 1000.
	self assert: (f ” f inverse) isIdentity.
	self assert: (f inverse ” f) isIdentity! !

!AlgebraicGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 10/27/2016 09:23'!
tesRingHomomorphismSpec
	| A B x y phi |
	A _ QQ polynomialsIn: #(x y z).
	B _ QQ polynomialsIn: #(x y).
	x _ B x.
	y _ B y.
	phi _ A to: B evaluating: [:f| f value: {x-y. x. y}].
	self assert: phi spec domain = B spec.
	self assert: phi spec codomain = A spec.
	self assert: phi spec asRingHomomorphism = phi! !

!AlgebraicGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 1/22/2017 08:23:16'!
testAffinePlaneCurveMultiplicity
	| A C |
	A _ AffineSpace new: #(x y) over: QQ.
	C _ A subscheme: (A coordinateRing generate: [:x :y| y^2 - (x^3)]).
	self assert: (C multiplicityAt: (1,1)) = 1.
	self assert: (C multiplicityAt: (0,0)) = 2! !

!AlgebraicGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 2/9/2017 05:17:46'!
testAffineSchemeCartesianProduct
	| X1 X2 P |
	X1 _ Scheme circle.
	X2 _ Scheme romanSurface.
	P _ X1 × X2.
	self assert: X1 dimension + X2 dimension = P dimension.
	self assert: X1 ambient dimension + X2 ambient dimension = P ambient dimension.
	self assert: (X1 pointsCountOver: ZZ/3) * (X2 pointsCountOver: ZZ/3) = (P pointsCountOver: ZZ/3).
	self assert: (P satisfies: (5,2,6,2,6) % 7)! !

!AlgebraicGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 10/12/2016 20:56'!
testAffineSchemeCreation
	| A x y z X Y |
	A _ AffineSpace new: 3 over: QQ.
	x _ A coordinateRing x.
	y _ A coordinateRing y.
	z _ A coordinateRing z.
	X _ A subscheme: x - y.
	Y _ X subscheme: {x^2 - (z^3). y^3 - (z^4)}.
	self assert: X ambient = A.
	"Y is defined as subscheme of X, so it contains the equations of X plus the two new equations, but its ambient space is still A (not X):"
	self assert: Y ambient = A! !

!AlgebraicGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 10/18/2016 20:58'!
testAffineSpace
	| K A |
	K _ PrimeField new: 23.
	A _ AffineSpace new: 3 over: K.
	self assert: A dimension = 3.
	self assert: A scalars = K.
	self assert: A coordinateRing = (K polynomialsIn: 3).
	self assert: A ambient = A.
	self assert: A coordinateRing spec = A! !

!AlgebraicGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 1/12/2017 15:40:09'!
testDifference
	| A x y C X2 D O |
	A _ AffineSpace new: 2 over: QQ.
	x _ A coordinateRing x.
	y _ A coordinateRing y.
	C _ A subscheme: x * y. "union of x-axis and y-axis"
	X2 _ A subscheme: x^2. "y-axis with double multiplicity"
	D _ X2 - C. "y-axis with multiplicity 1"
	self assert: D ideal = (A coordinateRing * x).
	O _ A subscheme: {x. y}.
	D _ C - O.
	self assert: D = C.
	self assert: (C - A) isEmpty "removing the ambient space removes all"! !

!AlgebraicGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 10/25/2016 14:09'!
testEllipticCurvesAreSmooth
	| R x y C |
	R _ QQ polynomialsIn: #(x y z).
	x _ R x.
	y _ R y.
	C _ R / (x^3 - (x*3) + 3 - (y^2) homogenizedIn: 3) :: proj.
	self assert: C isSmooth.
	C _ R / (x^3 + x - (y^2) homogenizedIn: 3) :: proj.
	self assert: C isSmooth.
	C _ R / (x^3 - x - (y^2) homogenizedIn: 3) :: proj.
	self assert: C isSmooth! !

!AlgebraicGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 10/15/2016 09:59'!
testEmpty
	| A X |
	A _ QQ polynomialsIn: #(x y z).
	X _ A / {A continuantOfOrder: 2. A continuantOfOrder: 3} :: spec.
	self assert: X isEmpty! !

!AlgebraicGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 2/4/2017 09:20:21'!
testEqualVarietiesDifferentIdeals
	| A x I I` V V` |
	A _ QQ polynomials.
	x _ A x.
	I _ A * {x}.
	I` _ A * {x^2}.
	V _ I variety.
	V` _ I` variety.
	self assert: V = V`.
	self assert: I ~= I`! !

!AlgebraicGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 10/15/2016 10:06'!
testEqualVarietiesDifferentIdeals2
	| A x y I I` V V` |
	A _ QQ polynomialsIn: #(x y).
	x _ A x.
	y _ A y.
	I _ A * {x. y}.
	I` _ A * {x^2. y}.
	V _ I variety.
	V` _ I` variety.
	self assert: V = V`.
	self assert: I ~= I`! !

!AlgebraicGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 10/15/2016 09:55'!
testFinite
	| A x y X |
	A _ QQ polynomialsIn: #(x y).
	x _ A x.
	y _ A y.
	X _ A / {x*x - 1. y*y - (x*x) - 3} :: spec.
	self assert: X isFinite! !

!AlgebraicGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 1/13/2017 17:28:49'!
testIntersection
	| A x y V V` W |
	A _ QQ polynomialsIn: #(x y).
	x _ A x.
	y _ A y.
	V _ A / {y} :: spec.
	V` _ A / {x*x - 1} :: spec.
	W _ V • V`.
	self assert: (W satisfies: (1, 0)).
	self assert: (W satisfies: (0, 1)) not! !

!AlgebraicGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 1/13/2017 17:29:15'!
testLinearSubspaceAsAlgebraicVariety
	| S V |
	S _ QQ ^ 3 grassmannian: 2 :: atRandomBits: 10.
	V _ S asAlgebraicVariety.
	self assert: V dimension + 1 = S dimension. "because it's projective"
	self assert: (V satisfies: (S e: 1)).
	self assert: (V satisfies: (S e: 2))! !

!AlgebraicGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 2/10/2017 19:10:14'!
testLocalAndGlobalDimension
	"'A Singluar Introduction to Commutative Algebra', Example A.8.4 (local and global dimension)."
	| R I X |
	R _ QQ polynomialsIn: #(x y z).
	I _ R * (R generate: [:x :y :z| {x*z. y*z}]).
	X _ (R / I) spec.
	self assert: X dimension = 2. "global dimension of X"
	self assert: (X !! (0,0,0)) localRing dimension = 2. "dimension of X at (0,0,0)"
	self assert: (X !! (1,0,0)) localRing dimension = 2. "dimension of X at (1,0,0)"
	self assert: (X !! (0,0,1)) localRing dimension = 1. "dimension of X at (0,0,1)"! !

!AlgebraicGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 2/9/2017 11:13:57'!
testMultiplicity
	"Example from Sage documentation."
	| A X q1 q2 |
	A _ AffineSpace new: 4 over: QQ.
	X _ A subscheme: (A coordinateRing !! [:x :y :z :w| {z*y - (x^7). w - (2*z)}]).
	q1 _ X !! (1,(1/3),3,6).
	q2 _ X !! (0,0,0,0).
	self assert: q1 multiplicity = 1.
	self assert: q2 multiplicity = 2! !

!AlgebraicGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 2/9/2017 11:20:49'!
testMultiplicity2
	"Example from Sage documentation."
	| P X q1 q2 q3 |
	P _ ProjectiveSpace new: 4 over: QQ.
	X _ P subscheme: (P coordinateRing !! [:x :y :z :w :t| {y^2 - (x*t). w^7 - (t*w*(x^5)) - (z^7)}]).
	q1 _ X !! (0,0,1,1,1).
	self assert: q1 multiplicity = 1.
	q2 _ X !! (1,0,0,0,0).
	self assert: q2 multiplicity = 3.
	q3 _ X !! (0,0,0,0,1).
	self assert: q3 multiplicity = 7! !

!AlgebraicGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 2/10/2017 07:50:58'!
testMultiplicity3
	"Example from Sage documentation."
	| P X q |
	P _ ProjectiveSpace new: 3 over: CC.
	X _ P subscheme: (P coordinateRing !! [:x :y :z :w| z^5*(x^2)*w - (y^8)]).
	q _ X !! (2,0,0,1).
	self assert: q multiplicity = 5! !

!AlgebraicGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 2/9/2017 10:26:45'!
testMultiplicityAndTangentCone
	"'A Singular Introduction to Commutative Algebra', Example A.8.5."
	| R C T p |
	R _ QQ polynomialsIn: #(x y).
	C _ (R / (R !! [:x :y| x^3 - y squared])) spec.
	p _ C !! (0,0).
	self assert: p multiplicity = 2.
	T _ (R / (R !! [:x :y| y^2])) spec.
	self assert: p tangentCone = T.
"	L _ (R / (R !! [:x :y| 100 atRandom * x + (100 atRandom * y)])) spec
	...
"! !

!AlgebraicGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 10/15/2016 09:57'!
testNotEmpty
	| A x y X |
	A _ QQ polynomialsIn: #(x y).
	x _ A x.
	y _ A y.
	X _ A  / {x*x - 1. y*y - (x*x) - 3} :: spec.
	self assert: X isEmpty not! !

!AlgebraicGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 10/15/2016 09:57'!
testNotFinite
	| A x y X |
	A _ QQ polynomialsIn: #(x y).
	x _ A x.
	y _ A y.
	X _ A / {y*y - (x*x) - 3} :: spec.
	self assert: X isFinite not! !

!AlgebraicGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 1/12/2017 14:44:51'!
testProjectiveClosure
	"From Magma Handbook example Scheme_projective-closure (H118E23)."
	| A1 u v X PX X2 |
	A1 _ AffineSpace new: #(u v) over: ZZ/5.
	u _ A1 coordinateRing x: #u.
	v _ A1 coordinateRing x: #v.
	X _ A1 subscheme: u^2 - (v^5).
	PX _ X projectiveClosure.
	self assert: (PX patch: 3) = X.
	X2 _ PX patch: 2.
	self assert: X2 projectiveClosure = X projectiveClosure! !

!AlgebraicGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 11/1/2016 05:31'!
testProjectiveEmbedding
	| A1 u v X PX affinePointsEmbedded projectivePoints |
	A1 _ AffineSpace new: #(u v) over: ZZ/5.
	u _ A1 coordinateRing x: #u.
	v _ A1 coordinateRing x: #v.
	X _ A1 subscheme: u^2 - (v^5).
	PX _ X projectiveClosure.
	affinePointsEmbedded _ X points asSet apply: X projectiveEmbedding.
	projectivePoints _ PX points asSet.
	self assert: projectivePoints >= affinePointsEmbedded.
	"the projective scheme has one more point at infinity:"
	self assert: affinePointsEmbedded size + 1 = projectivePoints size! !

!AlgebraicGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 12/23/2016 09:27:47'!
testProjectiveLineOverRing
	| P |
	P _ ProjectiveLine over: ZZ/6.
	"P(Z/6Z) has 12 points: [0:1], [1:1], [2:1], [3:1], [4:1], [5:1], [1:2], [3:2], [5:2], [1:3], [2:3] and [1:0] (Henri Cohen, 'A Course in Computational Algebraic Number Theory', 478p)"
	self assert: P points size = 12.
	self assert: (Iterator on: P points performing: #do:) size = 12! !

!AlgebraicGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 2/3/2017 06:59:34'!
testProjectivePlaneCurveArithmeticGenus
	| R f C |
	R _  (ZZ/5) polynomialsIn: 3.
	f _ R !! [:x :y :z| y^2*(z^7) - (x^9) - (x*(z^8))].
	C _ ProjectivePlaneCurve polynomial: f.
	self assert: C arithmeticGenus = 28.
	"self assert: C genus = 4"! !

!AlgebraicGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 12/23/2016 09:30:59'!
testProjectivePlaneOverFiniteField
	| P |
	P _ ProjectiveSpace new: 2 over: ZZ/5.
	self assert: P points size = 31.
	self assert: (Iterator on: P points performing: #do:) size = 31! !

!AlgebraicGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 1/12/2017 14:45:07'!
testProjectiveSchemeAffinePatches
	| E p a |
	E _ EllipticCurve cremona37a.
	p _ E !! (2,-3).
	a _ p dehomogenizedIn: 2.
	"the affine point is in the second standard affine patch:"
	self assert: (E patch: 2) == a codomain.
	"and when we homogenize again, the same projective embedding is used and come back to the same projective point on exactly the same projective curve:"
	self assert: a homogenized = p.
	self assert: a homogenized codomain == E! !

!AlgebraicGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 2/9/2017 10:51:38'!
testProjectiveSchemeDegree
	"Example from Sage documentation."
	| P X |
	P _ ProjectiveSpace new: 5 over: QQ.
	X _ P subscheme: (P coordinateRing !! [:x :y :z :w :t :u| x^7 + (x*y*z*(t^4)) - (u^7)]).
	self assert: X degree = 7! !

!AlgebraicGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 2/9/2017 10:53:18'!
testProjectiveSchemeDegree2
	"Example from Sage documentation."
	| P X |
	P _ ProjectiveSpace new: 3 over: ZZ/13.
	X _ P subscheme: (P coordinateRing !! [:x :y :z :w| {y^3 - (w^3). x + (7*z)}]).
	self assert: X degree = 3! !

!AlgebraicGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 2/9/2017 10:56:06'!
testProjectiveSchemeDegree3
	"Example from Sage documentation."
	| P X |
	P _ ProjectiveSpace new: 4 over: QQ.
	X _ P subscheme: (P coordinateRing !! [:x :y :z :w :u| {x^7 - (y*(z^3)*(w^2)*u). w*(z^2) - (y*(u^2)). z^3 + (y^3)}]).
	self assert: X degree = 63! !

!AlgebraicGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 10/18/2016 20:58'!
testProjectiveSpace
	| K P |
	K _ PrimeField new: 23.
	P _ ProjectiveSpace new: 3 over: K.
	self assert: P dimension = 3.
	self assert: P scalars = K.
	self assert: P coordinateRing = (K polynomialsIn: 4).
	self assert: P ambient = P.
	self assert: P coordinateRing proj = P! !

!AlgebraicGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 10/17/2016 11:30'!
testRationalMap
	"Example from Magma handbook Scheme_map-creation (H118E32)."
	| A1 A2 x y f X |
	A1 _ AffineSpace new: #(t) over: QQ.
	A2 _ AffineSpace new: #(x y) over: QQ.

	f _ A1 to: A2 evaluatingWithArguments: [:t| {t^3 + t. (t^2 - 3)}].

	self assert: f domain = A1.
	self assert: f codomain = A2.

	x _ A2 coordinateRing x.
	y _ A2 coordinateRing y.
	X _ A2 subscheme: {x^2*-1 + (y^3) + (y^2*11) + (y*40) + 48}.
	self assert: f image = X! !

!AlgebraicGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 10/17/2016 10:40'!
testRationalMap2
	"Example from Cox's IVA pag. 234. Parametrization of the tangent surface of the twisted cubic."
	| A2 A3 x y z f X |
	A2 _ AffineSpace new: #(t u) over: QQ.
	A3 _ AffineSpace new: 3 over: QQ.

	f _ A2 to: A3 evaluatingWithArguments: [:t :u| {t + u. t^2 + (t*u*2). t^3 + (t^2*u*3)}].

	x _ A3 coordinateRing x.
	y _ A3 coordinateRing y.
	z _ A3 coordinateRing z.
	X _ A3 subscheme: {x^3*z - (x*y^2*(3/4)) - (x*y*z*(3/2)) + (y^3) + (z^2*(1/4))}.
	self assert: f image = X! !

!AlgebraicGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 12/26/2016 09:15:15'!
testRationalMapAffineExample
	"From lecture notes MIT 18.782 Introduction to Arithmetic Geometry, Lecture #15, Fall 2013, 10/29/2013, Example 15.19."
	| A2 x y X A1 phi phi2 phiInv |
	A2 _ AffineSpace new: 2 over: CC.
	x _ A2 coordinateRing x.
	y _ A2 coordinateRing y.
	X _ A2 subscheme: x^2 + (y^2) - 1.
	A1 _ AffineSpace new: 1 over: CC.
	phi _ X to: A1 evaluatingWithArguments: [:x0 :y0| {y0 / (x0 + 1)}].
	phi2 _ X to: A1 evaluatingWithArguments: [:x0 :y0| {1 - x0 / y0}].
	self assert: phi = phi2.
	phiInv _ A1 to: X evaluatingWithArguments: [:t| {1 - (t^2) / (1 + (t^2)). t*2 / (1 + (t^2))}].
	self assert: (phi ” phiInv) isIdentity.
	self assert: phi isRegular not.
	self assert: phi isDominant.
"	self assert: phi isSurjective."
	self assert: phiInv isRegular not.
	self assert: phiInv isDominant.
"	self assert: phiInv isSurjective not"! !

!AlgebraicGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 1/13/2017 21:19:54'!
testRationalMapImage
	| A X X` f |
	A _ AffineSpace new: #(x y) over: QQ.
	"circle centered at (0,0):"
	X _ A subscheme: (A coordinateRing generate: [:x :y| x^2 + (y^2) - 1]).
	"circle centered at: (1,2):"
	X` _ A subscheme: (A coordinateRing generate: [:x :y| (x-1)^2 + ((y-2)^2) - 1]).
	"translation by (1,2):"
	f _ X to: A evaluatingWithArguments: [:x :y| {x+1. y+2}].
	self assert: f image = X`.
	"global translation by (1,2):"
	f _ A to: A evaluatingWithArguments: [:x :y| {x+1. y+2}].
	self assert: (X apply: f) = X`! !

!AlgebraicGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 11/7/2016 14:00'!
testRationalMapLinearMapConversion
	| A2 A3 V2 V3 f f` p f`` |
	A2 _ AffineSpace new: 2 over: QQ.
	A3 _ AffineSpace new: 3 over: QQ.
	V2 _ QQ^2.
	V3 _ QQ^3.

	f _ V2 hom: V3 :: atRandomBits: 100.
	f` _ f as: (A2 hom: A3).

	p _ V2 atRandomBits: 100.
	self assert: (f value: p) = (f` value: p).

	f`` _ f` as: (V2 hom: V3).
	self assert: f = f``! !

!AlgebraicGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 12/23/2016 09:28:26'!
testRationalPointsOverFiniteField
	| P C |
	P _ ProjectiveSpace new: 2 over: ZZ/7.
	C _ P subscheme: (P coordinateRing evaluating: [:x :y :z| x^3 + (y^3) - (z^3)]).
	self assert: C points size = 9.
	self assert: (Iterator on: C points performing: #do:) size = 9! !

!AlgebraicGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 10/31/2016 11:08'!
testReduced
	| A R x y z X |
	A _ AffineSpace new: 3 over: QQ.
	R _ A coordinateRing.
	x _ R x.
	y _ R y.
	z _ R z.
	X _ A subscheme: {x*(y^3). x^2*z}.
	self assert: X isReduced not.
	self assert: X reduced = (A subscheme: {x*y. x*z})! !

!AlgebraicGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 2/8/2017 07:14:15'!
testSingularCubics
	| R x y C |
	R _ QQ polynomialsIn: #(x y z).
	x _ R x.
	y _ R y.
	C _ R / (x^3 - (y^2) homogenizedIn: 3) :: proj.
	self assert: (C !! (1,1,1)) isSmooth.
	self assert: (C !! (0,0,1)) isSmooth not.
	self assert: C isSingular.
	C _ R / (x^3 + (x^2) - (y^2) homogenizedIn: 3) :: proj.
	self assert: C isSingular! !

!AlgebraicGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 2/8/2017 07:13:41'!
testSmoothness
	| R C |
	R _ QQ polynomialsIn: #(x y).
	"cuspidal curve:"
	C _ (R / (R evaluating: [:x :y| y^2 - (x^3)])) spec.
	self assert: C isSmooth not.
	self assert: C isSingular.
	self assert: (C !! (1,1)) isSmooth.
	self assert: (C !! (0,0)) isSmooth not! !

!AlgebraicGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 11/1/2016 18:50'!
testSmoothnessOverCC
	| P R C |
	P _ ProjectiveSpace new: 2 over: CC.
	R _ P coordinateRing.
	C _ P subscheme: (R evaluating: [:x :y :z| x]).
	self assert: C isSingular not.
	C _ P subscheme: (R evaluating: [:x :y :z| y^2*z - (x^3)]).
	self assert: C isSingular.
	C _ P subscheme: (R evaluating: [:x :y :z| y^2*z - (x^3) + (z^3)]).
	self assert: C isSingular not! !

!AlgebraicGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 11/1/2016 18:50'!
testSmoothnessOverFiniteField
	| P R C |
	P _ ProjectiveSpace new: 2 over: ZZ/19.
	R _ P coordinateRing.
	C _ P subscheme: (R evaluating: [:x :y :z| x^3 + (y^3) + (z^3)]).
	self assert: C isSingular not.
	C _ P subscheme: (R evaluating: [:x :y :z| x^4 - (x*(z^3))]).
	self assert: C isSingular.
	C _ P subscheme: (R evaluating: [:x :y :z| x^5 + (y^5*19) + (z^5)]).
	self assert: C isSingular.
	C _ P subscheme: (R evaluating: [:x :y :z| x^5 + (y^5*9) + (z^5)]).
	self assert: C isSingular not! !

!AlgebraicGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 11/1/2016 18:50'!
testSmoothnessOverQQ
	| P C |
	P _ ProjectiveSpace new: 2 over: QQ.
	C _ P subscheme: (P coordinateRing evaluating: [:x :y :z| x^3 - (y^2*z)]).
	self assert: C isSingular! !

!AlgebraicGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 1/13/2017 20:22:42'!
testSpecZ
	self assert: ZZ spec dimension = 1.
	self assert: ZZ spec isNoetherian.
	self assert: (ZZ spec includes: ZZ*5).
	self deny: (ZZ spec includes: ZZ*6).
	self assert: ZZ spec isInitial not.
	self assert: ZZ spec isTerminal! !

!AlgebraicGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 1/13/2017 20:13:41'!
testSpecZSubschemes
	self assert: ZZ spec >= (ZZ / 2) spec.
	self assert: (ZZ / 10) spec >= (ZZ / 5) spec.
	self deny: (ZZ / 10) spec >= (ZZ / 3) spec.
	self assert: (ZZ / 10) spec • (ZZ / 15) spec = (ZZ / 5) spec.
	self assert: (ZZ / 10) spec – (ZZ / 15) spec = (ZZ / 30) spec! !

!AlgebraicGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 2/6/2017 05:10:26'!
testSturmfelsExample1
	"Bernd Sturmfels, 'Ideals, Varieties and Macaulay 2', 1. A Curve in Affine 3-Space."
	| R x y I C C1 C2 |
	R _ QQ polynomialsIn: #(x y z). "default ordering is trevlex"
	x _ R x.
	y _ R y.
"	z _ R z."
	I _ R * {x^4 - (y^5). x^3 - (y^7)}.
	self assert: I groebnerBasis reduced printString = '{y^5 - x^4. x^4y^2 - x^3. x^8 - x^3y^3}'.
	C _ I variety.
	self assert: C dimension = 1.
	self assert: C codimension = 2.
	"The degree of a curve in complex affine 3-space is the number of intersection points with a general plane. It coincides with the degree of the projective closure of our curve:"
	self assert: C projectiveClosure degree = 28.
	"We first extract the components which are transverse to the plane x = 0:"
	C1 _ C \ (R / R x) spec.
	self assert: C1 = (R / {x*(y^2) - 1. y^5 - (x^4). x^5 - (y^3)}) spec.
	"And next we extract the component which lies in the clane x = 0:"
	C2 _ C - C1. "NOTE: the article uses ideal saturation, and this is colon"
	self assert: C2 = (R / {x^3. y^5}) spec.
	"self deny: C isReduced." "this fails!!!!!!"
	self assert: C1 projectiveClosure degree = 13.
	self assert: C1 isReduced "equivalent to C1 ideal = C1 ideal radical"! !

!AlgebraicGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 2/6/2017 05:24:15'!
testSturmfelsExample2
	"Bernd Sturmfels, 'Ideals, Varieties and Macaulay 2', 2. Intersecting Our Curve With a Surface."
	| R x y z C S theirunion ourpoints |
	R _ QQ polynomialsIn: #(x y z). "default ordering is trevlex"
	x _ R x.
	y _ R y.
	z _ R z.
	C _ (R / {x^4 - (y^5). x^3 - (y^7)}) spec.
	C _ C \ (R / R x) spec. "this is C1 from example1"
	S _ (R / (x^5 + (y^5) + (z^5) - 1)) spec.
	theirunion _ C – S.
	"In this case, the union's ideal coincides with the product of the ideals:"
	self assert: theirunion ideal = (C ideal * S ideal).
	"The intersection of the curve and the surface (whose defining ideal is the sum of the respective ideals):"
	ourpoints _ C • S.
	"We get a finite set of points:"
	self assert: ourpoints dimension = 0.
	"The number of points is 65:"
	self assert: ourpoints projectiveClosure degree = 65.
	"Each of the points is multiplicity-free:"
	self assert: ourpoints isReduced. "equivalent to the original: ourpoints reduced projectiveClosure degree = 65."! !

!AlgebraicGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 2/9/2017 10:27:04'!
testTangentCone
	"'A Singular Introduction to Commutative Algebra', Example 5.5.13."
	| R I J X |
	R _ QQ polynomialsIn: #(x y z).
	I _ R * (R !! [:x :y :z| {y*z + (z^2) + (x^3). y^2 + (x*z) + (y^4)}]).
	X _ (R/I) spec.
	J _ R * (R !! [:x :y :z| {y^2 + (x*z). y*z + (z^2). x*(z^2) - (y*(z^2))}]).
	self assert: (X !! (0,0,0)) tangentCone ideal = J! !

!AlgebraicGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 2/14/2017 16:10:01'!
testTangentCone2
	"M. Kreuzer, 'Computational Commutative Algebra', Example 6.5.27."
	| R J T I |
	R _ QQ polynomialsIn: 4.
	J _ R * (R generate: [:x1 :x2 :x3 :x4| {x1*x2 - (x3^2). x2^2 - (x4^5)}]).
	T _ (R/J) spec tangentConeAt: (0,0,0,0).
	I _ R * (R generate: [:x1 :x2 :x3 :x4| {x1*x2 - (x3^2). x2^2. x2*(x3^2). x3^4}]).
	self assert: T ideal = I! !

!AlgebraicGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 2/9/2017 10:35:41'!
testTangentConeAndTangentSpace
	"Example from https://en.wikipedia.org/wiki/Tangent_cone."
	| A x y S o |
	A _ AffineSpace new: #(x y) over: QQ.
	x _ A coordinateRing x.
	y _ A coordinateRing y.
	"this curve is singular at (0,0):"
	S _ A subscheme: x^2 + (x^3) - (y^2).
	o _ S !! (0,0).
	"the tangent cone is the union of the two lines x = y and x = -y:"
	self assert: o tangentCone = (A subscheme: (x + y) * (x - y)).
	"the tangent space is the whole plane:"
	self assert: o tangentSpace = A! !

!AlgebraicGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 10/25/2016 06:13'!
testTwistedCubic
	| P R M C |
	P _ ProjectiveSpace new: 3 over: QQ.
	R _ P coordinateRing.
	"R indeterminateNames: #(u v w t)"
	M _ R^(2@3) vectorAt: ((1,2,3,2,3,4) collect: [:i| R x: i]).
	C _ P subscheme: (M minors: 2).
	self assert: C dimension = 1.
	self assert: C isSmooth! !

!AlgebraicGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 2/4/2017 07:50:26'!
testTwistedCubicDegree
	"Twisted cubic in P^3 with homogeneous coordinates x,y,w,z."
	| A x y z w X |
	A _ QQ polynomialsIn: #(x y z w).
	x _ A x.
	y _ A y.
	z _ A z.
	w _ A x: #w.
	X _ A / {x^2 - (y*w). x*z - (y^2)} :: proj.
	"At this point X is still reducible, it is the union of a line x=y=0 and the twisted cubic:"
	self assert: X degree = 4.
	"To cut out X, we impose an additional equation x^3 - (z * (w^2)) = 0:"
	X _ A / {x^2 - (y*w). x*z - (y^2). x^3 - (z*(w^2))} :: proj.
	"But we get the twisted cubic (in some sense) 'counted with multiplicity 2', so the degree is 6"
	self assert: X degree = 6! !

!AlgebraicNumbersTest methodsFor: 'as yet unclassified' stamp: 'len 6/4/2016 22:00'!
testArithmetic
	| sqrt2 sqrt3 sqrt5 five sqrt6 |
	sqrt2 _ AlgebraicNumber sqrt2.
	sqrt3 _ AlgebraicNumber sqrt: 3.
	sqrt5 _ AlgebraicNumber sqrt: 5.
	sqrt6 _ AlgebraicNumber sqrt: 6.
	five _ AlgebraicNumber fromRational: 5.
	self assert: sqrt2 squared asRational = 2.
	self assert: (sqrt2 + sqrt3) * sqrt2 = (2 + sqrt6).
	self assert: (sqrt3 / sqrt5) squared reciprocal asRational = (5/3).
"	self assert: (((five root: 3) + sqrt2 - sqrt2) ^ 3) asRational = 5"! !

!AlgebraicNumbersTest methodsFor: 'as yet unclassified' stamp: 'len 6/4/2016 22:00'!
testDivision
	| sqrt3 sqrt5 |
	sqrt3 _ AlgebraicNumber sqrt: 3.
	sqrt5 _ AlgebraicNumber sqrt: 5.
	self assert: (sqrt3 / sqrt5 / sqrt3 / sqrt5) asRational = (1/5)! !

!AlgebraicNumbersTest methodsFor: 'as yet unclassified' stamp: 'len 6/4/2016 22:01'!
testProduct
	| sqrt3 sqrt5 |
	sqrt3 _ AlgebraicNumber sqrt: 3.
	sqrt5 _ AlgebraicNumber sqrt: 5.
	self assert: (sqrt3 * sqrt5 * sqrt3 * sqrt5) asRational = 15! !

!AlgebraicNumbersTest methodsFor: 'as yet unclassified' stamp: 'len 6/4/2016 21:59'!
testRealArithmetic
	| sqrt2 sqrt3 sqrt5 five sqrt6 |
	sqrt2 _ RealAlgebraicNumber sqrt2.
	sqrt3 _ RealAlgebraicNumber sqrt: 3.
	sqrt5 _ RealAlgebraicNumber sqrt: 5.
	sqrt6 _ RealAlgebraicNumber sqrt: 6.
	five _ RealAlgebraicNumber fromRational: 5.
	self assert: sqrt2 squared asRational = 2.
	self assert: (sqrt2 + sqrt3) * sqrt2 = (2 + sqrt6).
	self assert: (sqrt3 / sqrt5) squared reciprocal asRational = (5/3).
"	self assert: (((five root: 3) + sqrt2 - sqrt2) ^ 3) asRational = 5"! !

!AlgebraicNumbersTest methodsFor: 'as yet unclassified' stamp: 'len 6/4/2016 21:59'!
testRealDivision
	| sqrt3 sqrt5 |
	sqrt3 _ RealAlgebraicNumber sqrt: 3.
	sqrt5 _ RealAlgebraicNumber sqrt: 5.
	self assert: (sqrt3 / sqrt5 / sqrt3 / sqrt5) asRational = (1/5)! !

!AlgebraicNumbersTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:55'!
testRealNormalizationBug
	| f interval x |
	x _ QQ polynomials x.
	f _ x^4 * 1576875 - (x^2 * 877250) + 43923.
	interval _ RealInterval open: (-260139/1345600) closed: (81631/134560).
	RealAlgebraicNumber polynomial: f bounds: interval! !

!AlgebraicNumbersTest methodsFor: 'as yet unclassified' stamp: 'len 6/4/2016 21:59'!
testRealProduct
	| sqrt3 sqrt5 |
	sqrt3 _ RealAlgebraicNumber sqrt: 3.
	sqrt5 _ RealAlgebraicNumber sqrt: 5.
	self assert: (sqrt3 * sqrt5 * sqrt3 * sqrt5) asRational = 15! !

!AlgebraicNumbersTest methodsFor: 'as yet unclassified' stamp: 'len 6/4/2016 21:59'!
testRealSquare
	| sqrt2 |
	sqrt2 _ RealAlgebraicNumber sqrt2.
	self assert: sqrt2 squared asRational = 2! !

!AlgebraicNumbersTest methodsFor: 'as yet unclassified' stamp: 'len 6/4/2016 22:00'!
testRealSquareRoot
	| a |
	a _ RealAlgebraicNumber fromRational: 3.
	self assert: a squareRoot squared = a! !

!AlgebraicNumbersTest methodsFor: 'as yet unclassified' stamp: 'len 6/4/2016 22:00'!
testRealSum
	| sqrt2 sqrt3 sqrt5 |
	sqrt2 _ RealAlgebraicNumber sqrt: 2.
	sqrt3 _ RealAlgebraicNumber sqrt: 3.
	sqrt5 _ RealAlgebraicNumber sqrt: 5.
	self assert: sqrt3 + sqrt5 + sqrt2 - sqrt3 - sqrt5 = sqrt2! !

!AlgebraicNumbersTest methodsFor: 'as yet unclassified' stamp: 'len 6/4/2016 22:01'!
testSquare
	| sqrt2 |
	sqrt2 _ AlgebraicNumber sqrt2.
	self assert: sqrt2 squared asRational = 2! !

!AlgebraicNumbersTest methodsFor: 'as yet unclassified' stamp: 'len 6/4/2016 22:01'!
testSquareRoot
	| a |
	a _ AlgebraicNumber fromRational: 3.
	self assert: a squareRoot squared = a! !

!AlgebraicNumbersTest methodsFor: 'as yet unclassified' stamp: 'len 6/4/2016 22:01'!
testSum
	| sqrt2 sqrt3 sqrt5 |
	sqrt2 _ AlgebraicNumber sqrt: 2.
	sqrt3 _ AlgebraicNumber sqrt: 3.
	sqrt5 _ AlgebraicNumber sqrt: 5.
	self assert: sqrt3 + sqrt5 + sqrt2 - sqrt3 - sqrt5 = sqrt2! !

!CodesTest methodsFor: 'as yet unclassified' stamp: 'len 10/18/2016 20:58'!
testDual
	| F C |
	F _ PrimeField new: 2.
	C _ LinearCode subspace: (F^5 span: {(0,0,0,0,0) % 2. (1,1,1,1,1) % 2}).
	self assert: C dual size = (C ambient size / C size).
	C dual do: [:v|
		"check each codeword of the dual has an even number of 1's, because it must be perpendicular to 11111 (and 00000 of course)."
		self assert: (v count: [:each| each = (1 % 2)]) even]
! !

!CodesTest methodsFor: 'as yet unclassified' stamp: 'len 1/23/2017 11:52:38'!
testGolay24
	| C W x y |
	C _ LinearCode G24.
	self assert: C isSelfDual.
	W _ C weightEnumerator.
	x _ W parent x.
	y _ W parent y.
	self assert: W = (x^24 + (x^16*(y^8)*759) + (x^12*(y^12)*2576) + (x^8*(y^16)*759) + (y^24)) "typo in neil's video 22:20"! !

!CodesTest methodsFor: 'as yet unclassified' stamp: 'len 5/12/2016 09:47'!
testHamming743
	| H7 |
	H7 _ LinearCode H7.
	self assert: H7 isCyclic.
	self assert: H7 minimumDistance = 3.
	self assert: H7 weightDistribution = #(0 3 3 3 3 3 3 3 4 4 4 4 4 4 4 7) asBag.
	self assert: H7 dual minimumDistance = 4! !

!CodesTest methodsFor: 'as yet unclassified' stamp: 'len 7/15/2016 18:24'!
testHamming844
	| C P x y |
	C _ LinearCode H8.
	self assert: C isSelfDual.
	self assert: C isSelfOrthogonal.
	self assert: C minimumDistance = 4.
	self assert: C dual minimumDistance = 4.
	P _ ZZ polynomialsIn: 2.
	x _ P x. y _ P y.
	self assert: C weightEnumerator = (x^8 + (x*y^4*14) + (y^8))! !

!CodesTest methodsFor: 'as yet unclassified' stamp: 'len 1/23/2017 11:52:21'!
testMacWilliamsTheorem
	"(MacWilliams, 1962) the theorem relates the weight enumerator of a linear code to the weight enumerator of its dual."
	"From youtube, Neil Sloane 'Error Correcting Codes, Group Theory and Invariant Theory, Part 1' 20:30."
	| C W Wperp x y |
	C _ LinearCode H7.
	W _ C weightEnumerator.
	Wperp _ C dual weightEnumerator.
	x _ Wperp parent x.
	y _ Wperp parent y.
	self assert: Wperp = ((W value: {x+y. x-y}) / C size)! !

!CodesTest methodsFor: 'as yet unclassified' stamp: 'len 5/12/2016 09:57'!
testParityCheckMatrix
	| H7 M |
	H7 _ LinearCode H7.
	M _ H7 parityCheckMatrix.
	self assert: (M * H7 atRandom) isZero! !

!CodesTest methodsFor: 'as yet unclassified' stamp: 'len 10/18/2016 20:58'!
testSelfDual
	| F C |
	F _ PrimeField new: 2.
	"{00,11} is the smallest self-dual code"
	C _ LinearCode subspace: (F^2 span: {(0,0) % 2. (1,1) % 2}).
	self assert: C isSelfDual.
	self assert: C isSelfOrthogonal.
	"TODO: test other examples of self-dual codes: H8, G24"! !

!CodesTest methodsFor: 'as yet unclassified' stamp: 'len 5/12/2016 07:28'!
testSingletonBound: C
	"Any linear [n,k,d] code satisfies k + d <= n + 1."
	| n k d |
	n _ C length.
	k _ C rank.
	d _ C minimumDistance.
	self assert: k + d <= (n + 1).! !

!CodesTest methodsFor: 'as yet unclassified' stamp: 'len 5/12/2016 07:30'!
testSingletonBoundH7
	"Any linear [n,k,d] code satisfies k + d <= n + 1."
	self testSingletonBound: LinearCode H7! !

!CodesTest methodsFor: 'as yet unclassified' stamp: 'len 5/12/2016 07:31'!
testSingletonBoundTrtracode
	"Any linear [n,k,d] code satisfies k + d <= n + 1."
	self testSingletonBound: LinearCode tetracode! !

!CodesTest methodsFor: 'as yet unclassified' stamp: 'len 11/6/2016 10:20'!
testTetracode
	| C P x y |
	C _ LinearCode subspace: (ZZ/3 ^ 4 span: {(1,1,1,0) % 3. (0,1,2,1) % 3}).
	self assert: C isSelfDual.
	self assert: C minimumDistance = 3.
	P _ ZZ polynomialsIn: #(x y).
	x _ P x.
	y _ P y.
	self assert: C weightEnumerator = (x^4 + (x*(y^3)*8))! !

!CodesTest methodsFor: 'as yet unclassified' stamp: 'len 1/23/2017 11:52:08'!
testWeightEnumerator
	"From youtube, Neil Sloane 'error correcting codes, group theory and invariant theory part 1' 19:30."
	| F C w x y |
	F _ PrimeField new: 2.
	C _ LinearCode subspace: (F^5 span: {(0,0,0,0,0) % 2. (1,1,1,1,1) % 2}).
	w _ C weightEnumerator.
	x _ w parent x.
	y _ w parent y.
	self assert: w = (x^5 + (y^5)).
	self assert: C dual weightEnumerator = (x^5 + (x^3*(y^2)*10) + (y^4*x*5))! !

!CommutativeAlgebraTest methodsFor: 'as yet unclassified' stamp: 'len 2/14/2017 08:11:31'!
testAffineRingElementOperations
	"Magma handbook example H105E1."
	| R A x y |
	R _ QQ polynomialsIn: #(x y).
	A _ R / (R generate: [:x1 :y1| {x1^2 - (y1^2) + 2. y1^3 - 5}]).
	x _ A x. y _ A y.
	self assert: x^2 = (y^2 - 2).
	"self assert: x reciprocal = ..."! !

!CommutativeAlgebraTest methodsFor: 'as yet unclassified' stamp: 'len 2/13/2017 20:39:37'!
testAffineRingIdealMembershipAtRandom
	| R f1 f2 J A g I h |
	R _ QQ polynomialsIn: #(x y z).
	[(f1 _ R atRandomBits: 10) isZero] whileTrue.
	[(f2 _ R atRandomBits: 10) isZero] whileTrue.
	J _ R * {f1. f2}.
	A _ R/J.
	g _ A atRandomBits: 10.
	I _ A * g.
	h _ I atRandomBits: 10.
	self assert: (I includes: h)! !

!CommutativeAlgebraTest methodsFor: 'as yet unclassified' stamp: 'len 2/13/2017 08:47:40'!
testAffineRingIdealOperations
	"Magma handbook, example H105E2."
	| R A I J |
	R _ QQ polynomialsIn: #(x y z) "ordering: #lex".
	A _ R / (R generate: [:x :y :z| {x^2 - y + 1. y^3 + z - 1}]).
	I _ A * (A generate: [:x :y :z| x^3*y*(z^2)]).
	self deny: I isRadical.
	J _ A * (A generate: [:x :y :z| {x*(y^2) + (x*y) - (x*z) + x. y*z. z^2 - z}]).
	self assert: I radical = J.
	"... and then some tests of primary decomposition"! !

!CommutativeAlgebraTest methodsFor: 'as yet unclassified' stamp: 'len 2/12/2017 12:36:37'!
testBuchbergerNormalForm
	"A Singular Introduction to Commutative Algebra, Example 1.6.12."
	| R x y z f G h |
	R _ QQ polynomialsIn: #(x y z) ordering: #glex.
	x _ R x. y _ R y. z _ R z.
	f _ x^3 + (y^2) + (z^2*2) + x + y + 1.
	G _ GroebnerBasis new add: R x; add: R y; yourself.
	h _ G reduce: f.
	self assert: h = (z^2*2 + x + y + 1).
	h _ G reduceFull: f.
	self assert: h = (z^2 + (1/2))! !

!CommutativeAlgebraTest methodsFor: 'as yet unclassified' stamp: 'len 7/8/2016 20:11'!
testGroebnerBasis: G ideal: I
	| g |
	self assert: G verify.
	I generators do: [:each| self assert: (G reduces: each)].
	g _ I atRandomBits: 100.
	self assert: (G reduces: g)! !

!CommutativeAlgebraTest methodsFor: 'as yet unclassified' stamp: 'len 7/8/2016 01:48'!
testGroebnerCyclic3
	| I G |
	I _ PolynomialIdeal cyclic: 3.
	G _ I groebnerBasis.
	self testGroebnerBasis: G ideal: I! !

!CommutativeAlgebraTest methodsFor: 'as yet unclassified' stamp: 'len 1/25/2017 09:58:07'!
testGroebnerCyclic3Lexicographic
	| I G |
	I _ (PolynomialIdeal cyclic: 3) orderedBy: #lex.
	G _ GroebnerBasis from: I generators.
	self testGroebnerBasis: G ideal: I! !

!CommutativeAlgebraTest methodsFor: 'as yet unclassified' stamp: 'len 10/18/2016 20:57'!
testGroebnerCyclic3OverZ2
	| I G |
	I _ PolynomialIdeal cyclic: 3 over: (PrimeField new: 2).
	G _ I groebnerBasis.
	self testGroebnerBasis: G ideal: I! !

!CommutativeAlgebraTest methodsFor: 'as yet unclassified' stamp: 'len 2/12/2017 06:05:17'!
testGroebnerCyclic3TotalLexicographic
	| I G |
	I _ (PolynomialIdeal cyclic: 3) orderedBy: #glex.
	G _ GroebnerBasis from: I generators.
	self testGroebnerBasis: G ideal: I! !

!CommutativeAlgebraTest methodsFor: 'as yet unclassified' stamp: 'len 2/12/2017 06:07:32'!
testGroebnerCyclic3TotalReverseLexicographic
	| I G |
	I _ (PolynomialIdeal cyclic: 3) orderedBy: #grevlex.
	G _ GroebnerBasis from: I generators.
	self testGroebnerBasis: G ideal: I! !

!CommutativeAlgebraTest methodsFor: 'as yet unclassified' stamp: 'len 7/8/2016 01:48'!
testGroebnerCyclic4
	| I G |
	I _ PolynomialIdeal cyclic: 4.
	G _ I groebnerBasis.
	self testGroebnerBasis: G ideal: I! !

!CommutativeAlgebraTest methodsFor: 'as yet unclassified' stamp: 'len 1/25/2017 09:58:28'!
testGroebnerExample
	| P x y z F G |
	P _ QQ polynomialsIn: #(x y z) ordering: #lex.
	x _ P x.
	y _ P y.
	z _ P z.
	F _ {x^2 - (y*z). y^2 - (z*x). z^2 - (x*y)}.
	G _ GroebnerBasis from: F :: minimal.
	self assert: G asSet = {x^2 - (y*z). x*z - (y^2). x*y - (z^2). y^3 - (z^3)} asSet! !

!CommutativeAlgebraTest methodsFor: 'as yet unclassified' stamp: 'len 7/8/2016 01:48'!
testGroebnerKatsura2
	| I G |
	I _ PolynomialIdeal katsura2.
	G _ I groebnerBasis.
	self testGroebnerBasis: G ideal: I! !

!CommutativeAlgebraTest methodsFor: 'as yet unclassified' stamp: 'len 7/8/2016 01:48'!
testGroebnerKatsura3
	| I G |
	I _ PolynomialIdeal katsura3.
	G _ I groebnerBasis.
	self testGroebnerBasis: G ideal: I! !

!CommutativeAlgebraTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:56'!
testGroebnerTrivial
	"The 3 polynomials have no common zeroes, the Groebner basis should be {1}."
	| Qx x y I |
	Qx _ QQ polynomialsIn: #(x y) ordering: #lex.
	x _ Qx x.
	y _ Qx y.
	I _ Qx * {x + y. x^2 - 1. y^2 - (x*2)}.
	self assert: I groebnerBasis minimal isTrivial! !

!CommutativeAlgebraTest methodsFor: 'as yet unclassified' stamp: 'len 10/27/2016 18:43'!
testHilbertSeriesOfPolynomialIdeal
	"Derksen, Kemper 'Computational Invariant Theory', Example 1.4.9."
	| t R x y z w I H |
	t _ QQ polynomials fractions x.
	R _ QQ polynomialsIn: #(x y z w) "ordering: #lex".
	x _ R x.
	y _ R y.
	z _ R z.
	w _ R x: 4.
	I _ R * {x*z - (y^2). x*w - (y*z). y*w - (z^2)}.
	H _ I hilbertSeriesAt: t.
	self assert: H = (t^2 * 3 - (t^3 * 2) / ((1 - t) ^ 4))! !

!CommutativeAlgebraTest methodsFor: 'as yet unclassified' stamp: 'len 10/27/2016 18:47'!
testHilbertSeriesOfPolynomialQuotient
	"Derksen, Kemper 'Computational Invariant Theory', Example 1.4.9."
	| t R x y z w I H |
	t _ QQ polynomials fractions x.
	R _ QQ polynomialsIn: #(x y z w) "ordering: #lex".
	x _ R x.
	y _ R y.
	z _ R z.
	w _ R x: 4.
	I _ R * {x*z - (y^2). x*w - (y*z). y*w - (z^2)}.
	H _ (R/I) hilbertSeriesAt: t.
	self assert: H = (1 + (2*t) / (1 - t) squared)! !

!CommutativeAlgebraTest methodsFor: 'as yet unclassified' stamp: 'len 2/4/2017 07:57:44'!
testHilbertSeriesOfPolynomialQuotient2
	"Derksen, Kemper 'Computational Invariant Theory', Example 1.4.9."
	| t R x y z w I H dim deg |
	t _ QQ polynomials fractions x.
	R _ QQ polynomialsIn: #(x y z w).
	x _ R x.
	y _ R y.
	z _ R z.
	w _ R x: 4.
	I _ R * {x*z - (y^2). x*w - (y*z). y*w - (z^2)}.
	H _ (R/I) hilbertSeriesAt: t.
	dim _ (H orderAt: 1) negated.
	self assert: (R/I) dimension = dim.
	deg _ H * ((1 - H numerator parent x) ^ dim) value: 1. "should be limit from below"
	self assert: (R/I) degree = deg! !

!CommutativeAlgebraTest methodsFor: 'as yet unclassified' stamp: 'len 10/27/2016 18:41'!
testHilbertSeriesOfPolynomialRing
	| t R H |
	t _ QQ polynomials fractions x.
	R _ QQ polynomialsIn: 4.
	H _ R hilbertSeriesAt: t.
	self assert: H = ((1 - t) ^ -4)! !

!CommutativeAlgebraTest methodsFor: 'as yet unclassified' stamp: 'len 11/1/2016 05:32'!
testIdealColon
	| R x y z I J |
	R _ QQ polynomialsIn: #(x y z).
	x _ R x.
	y _ R y.
	z _ R z.
	I _ R * {x*y - 1. x^3*(z^2) - (y^2). x*(z^3) - x - 1}.
"	J _ R * {x*y - 1. x^2*z - y. x*(z^3) - x - 1}."
	self assert: (I colon: R asIdeal) = I.
	self assert: (R asIdeal colon: I) = R asIdeal.
	J _ R * {I atRandomBits: 10. I atRandomBits: 10}. "J <= I"
	self assert: (I colon: J) = R asIdeal! !

!CommutativeAlgebraTest methodsFor: 'as yet unclassified' stamp: 'len 12/8/2016 20:27:37'!
testIdealColon2
	"Example from Cox IVA 205p."
	| R x y z I J Q |
	R _ QQ polynomialsIn: #(x y z).
	x _ R x.
	y _ R y.
	z _ R z.
	I _ R * {x*z - (y^2). x^3 - (y*z)}.
	J _ R * {x. y}.
	Q _ I colon: J.
	self assert: Q = ((I colon: R * x) • (I colon: R * y)).
	self assert: Q = (R * {x*z - (y^2). x^3 - (y*z). x^2*y - (z^2)})! !

!CommutativeAlgebraTest methodsFor: 'as yet unclassified' stamp: 'len 2/12/2017 12:50:41'!
testIdealElementOperations
	"Magma handbook example H103E2."
	| R x y z I |
	R _ QQ polynomialsIn: #(x y z) "ordering: #lex".
	x _ R x. y _ R y. z _ R z.
	I _ R * {(x + y)^3. (y - z)^2. y^2*z + z}.
	self assert: (I reduce: (y^2*z + z)) isZero.
	"I basis reduceFull: x^3 = ..."
	"I basis reduce: z^4 + (y^2))"
	self deny: (I includes: x+y).
	self assert: (I radicalContains: x+y).
	self assert: (I radicalContains: (x+y)^2).
	self deny: (I radicalContains: z).
	self assert: (x^4 + y - z s: x^2 + y - z) = (x^2*y negated + (x^2*z) + y - z)! !

!CommutativeAlgebraTest methodsFor: 'as yet unclassified' stamp: 'len 10/30/2016 15:17'!
testIdealElimination
	"Example from Cox IVA 123 p. NOTE: this is a little slow."
	| Qx x y z I |
	Qx _ QQ polynomialsIn: #(x y z).
	x _ Qx x. y _ Qx y. z _ Qx z.
	I _ Qx * {x^2 + y + z - 1. x + (y^2) + z - 1. x + y + (z^2) - 1}.
	self assert: (I eliminateAll: #(1 2)) generator = (z^6 - (z^4*4) + (z^3*4) - (z^2))! !

!CommutativeAlgebraTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:56'!
testIdealHomogenization
	"The homogenization of an ideal can be bigger than the ideal generated by the homogenized generators."
	| Qx x y z f1 f2 I f3 J |
	Qx _ QQ polynomialsIn: #(x y z).
	x _ Qx x.
	y _ Qx y.
	z _ Qx z.
	"Ideal for the twisted cubic:"
	f1 _ y - (x^2).
	f2 _ z - (x^3).
	I _ Qx * {f1. f2}.
	"Now a polynomial in I:"
	f3 _ f2 - (f1*x).
	self assert: (I homogenized includes: f3 homogenized).
	"But it's not in the ideal generated by the homogenized generators:"
	J _ Qx * {f1 homogenized. f2 homogenized}.
	self deny: (J includes: f3 homogenized)! !

!CommutativeAlgebraTest methodsFor: 'as yet unclassified' stamp: 'len 12/8/2016 20:27:42'!
testIdealIntersection
	"Example from Cox IVA 194 p."
	| Qxy x y I J K |
	Qxy _ QQ polynomialsIn: #(x y).
	x _ Qxy x.
	y _ Qxy y.
	I _ Qxy * {x^2 * y}.
	J _ Qxy * {x * (y^2)}.
	K _ Qxy * {x^2*(y^2)}.
	self assert: I • J = K! !

!CommutativeAlgebraTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 19:31'!
testIdealIsPrime
	| R x y I |
	R _ QQ polynomialsIn: #(x y).
	x _ R x: #x.
	y _ R x: #y.
	I _ R * {x^2 - (y^2) - 1}.
	self assert: I isPrime! !

!CommutativeAlgebraTest methodsFor: 'as yet unclassified' stamp: 'len 2/6/2017 09:02:51'!
testIdealIsRadical
	"Becker, Weispfenning, 'Groebner Bases', Exercise 8.21."
	| R x y I |
	R _ QQ polynomialsIn: #(x y).
	x _ R x: #x.
	y _ R x: #y.
	I _ R * {x^2 + y. y^2 + x}.
	self assert: I dimension = 0.
	self assert: I isRadical! !

!CommutativeAlgebraTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:56'!
testIdealMembership
	| Qxy x y f g I J h k |
	Qxy _ QQ polynomialsIn: #(x y).
	x _ Qxy x.
	y _ Qxy y.
	f _ x^2 - y.
	g _ x^3 - x.
	I _ Qxy * {f. g}.
	J _ Qxy * {x^2. y^3}.
	h _ y^2 - y.
	k _ x*y - x.
	self assert: (I includes: h).
	self assert: (I includes: k).
	self assert: (J includes: h) not.
	self assert: (J includes: k) not! !

!CommutativeAlgebraTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:56'!
testIdealMembership2
	| Qxy x y I |
	Qxy _ QQ polynomialsIn: #(x y).
	x _ Qxy x.
	y _ Qxy y.
	I _ Qxy * {x*x. y*2 + x}.
	self assert: (I includes: (x + y) squared)! !

!CommutativeAlgebraTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:56'!
testIdealMembership3
	| Qx x y z w f g I |
	Qx _ QQ polynomialsIn: #(x y z w).
	x _ Qx x.
	y _ Qx y.
	z _ Qx z.
	w _ Qx x: #w.
	f _ x*z-(y^2). "twisted cubic"
	g _ z*(y*w-(z^2)) - (w*(x*w-(y*z))).
	I _ Qx * {f. g}.
	"The twisted cubic C in P^3 is the set-theoretic complete intersection
	of f=0 and g=0, but not a scheme-theoretic or ideal-theoretic complete
	intersection (the ideal is not radical since includes f^2):"
	self assert: (I includes: f^2)! !

!CommutativeAlgebraTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:56'!
testIdealMembershipRandom
	| P f1 f2 f3 I g |
	P _ QQ polynomialsIn: #(x y z).
	[(f1 _ P atRandomBits: 10) isZero] whileTrue.
	[(f2 _ P atRandomBits: 10) isZero] whileTrue.
	[(f3 _ P atRandomBits: 10) isZero] whileTrue.
	I _ P * {f1. f2. f3}.
	g _ I atRandomBits: 100.
	self assert: (I includes: g)! !

!CommutativeAlgebraTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 19:28'!
testIdealRadical
	| R x y I J |
	R _ QQ polynomialsIn: #(x y).
	x _ R x: #x.
	y _ R x: #y.
	I _ R * {x^3. y^2}.
	J _ R * {x. y}.
	self assert: I radical = J! !

!CommutativeAlgebraTest methodsFor: 'as yet unclassified' stamp: 'len 12/2/2016 11:18:14'!
testIdealRadicalZeroDimNotPerfectField
	"Counterexample that shows how Seidenberg algorithm fails over a non-perfect field.
	From Becker and Weispfenning 'Groebner Bases', Springer-Verlag, 1993. Example 8.16."
	| p F R t x y I |
	p _ #(3 5 7 11) atRandom.
	F _ (ZZ / p) polynomialsIn: #(t) :: fractions.
	R _ F polynomialsIn: #(x y).
	t _ F x: #t.
	x _ R x.
	y _ R y.
	I _ R * {x^p - t. y^p - t}.
	self assert: (I includes: x^p - (y^p)).
	self deny: (I includes: x - y).
	self assert: (I radical includes: x - y)! !

!CommutativeAlgebraTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:57'!
testIdealRadicalZeroDimPerfectField
	"Seidenberg algorithm works for 0-dimensional ideals over a perfect field." 
	| R y z I J |
	R _ QQ polynomialsIn: #(y z).
	y _ R x: #y.
	z _ R x: #z.
	I _ R * {y + z. z^2}.
	J _ R * {y. z}.
	self assert: I radical = J! !

!CommutativeAlgebraTest methodsFor: 'as yet unclassified' stamp: 'len 10/23/2016 18:32'!
testIdealSaturation
	"Example from SageMath reference."
	| R x y z I J S |
	R _ QQ polynomialsIn: #(x y z).
	x _ R x.
	y _ R y.
	z _ R z.
	I _ R * {x^5*(z^3). x*y*z. y*(z^4)}.
	J _ R * z.
	S _ R * {y. x^5}.
	self assert: (I saturation: J) = S! !

!CommutativeAlgebraTest methodsFor: 'as yet unclassified' stamp: 'len 10/25/2016 15:02'!
testKrullDimension
	| R I Q |
	R _ QQ polynomialsIn: #(x y).
	self assert: R dimension = 2.
	I _ R * {R x. R y}.
	Q _ R / I.
	self assert: Q dimension = 0.
	I _ R * R zero. "zero ideal"
	Q _ R / I.
	self assert: Q dimension = 2! !

!CommutativeAlgebraTest methodsFor: 'as yet unclassified' stamp: 'len 10/25/2016 16:00'!
testKrullDimension2
	"Example from SageMath."
	| R x y I |
	R _ QQ polynomialsIn: #(x y).
	x _ R x.
	y _ R y.
	I _ R * {x*y. x*y + 1}.
	self assert: (R / I) dimension < 0.
	I _ R * {x*(x*y + 1). y*(x*y + 1)}.
	self assert: (R / I) dimension = 1.
	I _ R * {x^3*y. x*(y^2)}.
	self assert: (R / I) dimension = 1! !

!CommutativeAlgebraTest methodsFor: 'as yet unclassified' stamp: 'len 10/25/2016 15:18'!
testKrullDimensionFiniteField
	"Example from SageMath."
	| R x y I Q |
	R _ ZZ/32003 polynomialsIn: #(x y z).
	self assert: R dimension = 3.
	x _ R x.
	y _ R y.
	I _ R * {x^2 - y. x^3}.
	Q _ R / I.
	self assert: Q dimension = 1! !

!CommutativeAlgebraTest methodsFor: 'as yet unclassified' stamp: 'len 10/25/2016 15:59'!
testKrullDimensionFiniteField2
	"Example from SageMath."
	| R x y I |
	R _ ZZ/2147483659 polynomialsIn: #(x y).
	x _ R x.
	y _ R y.
	I _ R * {x*y. x*y + 1}.
	self assert: (R / I) dimension < 0.
	I _ R * {x*(x*y + 1). y*(x*y + 1)}.
	self assert: (R / I) dimension = 1.
	I _ R * {x^3*y. x*(y^2)}.
	self assert: (R / I) dimension = 1! !

!CommutativeAlgebraTest methodsFor: 'as yet unclassified' stamp: 'len 10/25/2016 15:07'!
testKrullDimensionOverZZ
	| R I Q |
	R _ ZZ polynomialsIn: #(x y).
	self assert: R dimension = 3.
"	I _ R * {R x. R y}.
	Q _ R / I.
	self assert: Q dimension = 0.
"	I _ R * R zero. "zero ideal"
	Q _ R / I.
	self assert: Q dimension = 3! !

!CommutativeAlgebraTest methodsFor: 'as yet unclassified' stamp: 'len 2/12/2017 12:29:28'!
testLocalIdeals
	"Magma handbook, example H104E4."
	| R I J A M |
	self notYetImplemented. "it hangs here"
	R _ QQ polynomialsIn: #(x y z) ordering: #llex.
	I _ R * (R generate: [:x :y :z| {x*y - z. x^3*(z^2) - (y^2). x*(z^3) - x - y}]).
	J _ R * (R generate: [:x :y :z| {x*y - z. x^2*z - y. x*(z^3) - x - y}]).
	A _ R * (R generate: [:x :y :z|
		{x^2 - (y^2) + (2*(x^3)*z).
		x*y + (y^2) - (x^3*z).
		y^3.
		x*z + (y*z).
		y*z.
		z^2}]).
	self assert: I * J = A.
	M _ R * (R generate: [:x :y :z| {x + y. y^2. z}]).
	self assert: I • J = M.
	self deny: A = M.
	self assert: A <= M! !

!CommutativeAlgebraTest methodsFor: 'as yet unclassified' stamp: 'len 2/12/2017 06:02:55'!
testMoraNormalForm
	"A Singular Introduction to Commutative Algebra, Example 1.7.7."
	| R f G h |
	R _ QQ polynomialsIn: #(x y z) ordering: #lgrevlex.
	f _ R !! [:x :y :z| x^2 + (y^2) + (z^3) + (x^4) + (y^5)].
	G _ StandardBasis new add: R x; add: R y; yourself.
	h _ G reduce: f.
	self assert: h = (R !! [:x :y :z| z^3 + (x^4) + (y^5)])! !

!CommutativeAlgebraTest methodsFor: 'as yet unclassified' stamp: 'len 2/12/2017 06:05:21'!
testMultivariateDivisionExample
	| P x y z F f |
	P _ QQ polynomialsIn: #(x y z) ordering: #glex.
	x _ P x.
	y _ P y.
	z _ P z.
	F _ {x^2 - (y*z). y^2 - (z*x). z^2 - (x*y)}.
	f _ x^3 + (y^3 * 3).
	self assert: (f divideBy: F) remainder = (y^3 * 4)! !

!CommutativeAlgebraTest methodsFor: 'as yet unclassified' stamp: 'len 10/23/2016 16:37'!
testPolynomialRingHomomorphismKernel
	| A B x y phi |
	A _ QQ polynomialsIn: #(x y z).
	B _ QQ polynomialsIn: #(x y).
	x _ B x.
	y _ B y.
	phi _ A to: B evaluating: [:f| f value: {x-y. x. y}].
	self assert: phi kernel = (A * (A x - A y + A z)).
	self assert: (phi value: (phi kernel atRandomBits: 15)) isZero! !

!CommutativeAlgebraTest methodsFor: 'as yet unclassified' stamp: 'len 1/26/2017 09:43:00'!
testRadicalMembership
	| R x y z g1 g2 f I |
	R _ QQ polynomialsIn: #(x y z).
	x _ R x.
	y _ R y.
	z _ R z.
	g1 _ x^4*(y^2) + (z^2) - (x*(y^3)*z*4) - (y^5*z*2).
	g2 _ (x + (y^2)) ^ 2.
	f _ y*z - (x^3).
	I _ R * {g1. g2}.
	self assert: (I radicalContains: f)! !

!CommutativeAlgebraTest methodsFor: 'as yet unclassified' stamp: 'len 8/30/2016 07:01'!
testZeroIdeal
	| zero |
	zero _ ZZ * #(). "the zero ideal {0}"
	self assert: zero isZero.
	self assert: (zero includes: 0).
	self deny: (zero includes: 42)! !

!EllipticCurvesTest methodsFor: 'as yet unclassified' stamp: 'len 11/11/2016 10:14'!
testBInvariants
	| W |
	W _ WeierstrassEquation coefficients: (1,2,3,4,5).
	self assert: W b2 = 9.
	self assert: W b4 = 11.
	self assert: W b6 = 29.
	self assert: W b8 = 35! !

!EllipticCurvesTest methodsFor: 'as yet unclassified' stamp: 'len 11/11/2016 10:30'!
testCInvariants
	| W |
	W _ WeierstrassEquation coefficients: (0,-1,1,-10,-20).
	self assert: W c4 = 496.
	self assert: W c6 = 20008! !

!EllipticCurvesTest methodsFor: 'as yet unclassified' stamp: 'len 11/11/2016 08:29'!
testGroupLaw
	| E P Q O |
	E _ EllipticCurve cremona389a1.
	P _ E pointAt: (-1,1).
	Q _ E pointAt: (0,-1).
	O _ E pointAt: (0,1,0).
	self assert: P+Q = (E pointAt: (4,8)).
	self assert: P-Q = (E pointAt: (1,0)).
	self assert: 3*P - (5*Q) = (E pointAt: (328/361,(-2800/6859))).
	self assert: O+P = P.
	self assert: P+O = P.
	self assert: P-P = O! !

!EllipticCurvesTest methodsFor: 'as yet unclassified' stamp: 'len 11/9/2016 07:30'!
testWeierstrassEquationInvariants
	| W |
	W _ WeierstrassEquation coefficients: (ZZ ^ 5 atRandomBits: 100).
	self assert: W b8 * 4 = (W b2 * W b6 - W b4 squared).
	self assert: W discriminant * 1728 = (W c4 ^ 3 - W c6 squared)! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 11/16/2016 10:04'!
testAutomorphismsK3
	"Aut(K3) = Sym(3)"
	| G A |
	G _ Graph K: 3.
	A _ G automorphisms.
	self assert: A = A ambient
! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 11/16/2016 10:08'!
testAutomorphismsP3
	"Aut(P3) = {id, (1 3)}"
	| G A |
	G _ Graph P: 3.
	A _ G automorphisms.
	self assert: A = (PermutationGroup new: 3 generators: {Permutation image: #(3 2 1)})! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 11/16/2016 10:05'!
testCartesianProduct
	| G H |
	G _ Graph unordered addEdge: 1 -> 2; yourself.
	H _ G cartesian: G.
	self assert: H size = 4.
	self assert: H numberOfEdges = 4! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 11/16/2016 10:08'!
testChromaticNumber
	| G |
	G _ Graph unordered add: 1; add: 2; add: 3; yourself. 
	self assert: G chromaticNumber = 1. "edgeless graph"
	self assert: (Graph K: 3) chromaticNumber = 3.
	self assert: (Graph C: 5) chromaticNumber = 3.
	self assert: (Graph C: 6) chromaticNumber = 2.
	self assert: (Graph W: 6) chromaticNumber = 4.
	self assert: (Graph W: 5) chromaticNumber = 3.
	self assert: (Graph S: 6) chromaticNumber = 2! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 11/16/2016 10:05'!
testChromaticPolynomialComplete
	| x |
	x _ ZZ polynomials x.
	self assert: (Graph K: 3) chromaticPolynomial = (x*(x-1)*(x-2))! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 11/16/2016 10:05'!
testChromaticPolynomialCylic
	| x n |
	x _ ZZ polynomials x.
	n _ 4 atRandom.
	self assert: (Graph C: n) chromaticPolynomial = (x-1^n + ((-1)^n * (x-1)))! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 11/16/2016 10:04'!
testChromaticPolynomialPath
	| x n |
	x _ ZZ polynomials x.
	n _ 4 atRandom + 1.
	self assert: (Graph P: n) chromaticPolynomial = (x-1^(n-1)*x)! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 12/8/2016 20:34:11'!
testComplement
	| G H |
	G _ Graph unordered addEdges: {#a -> #b. #b -> #c. #d -> #e}; yourself.
	H _ G complement.
	self assert: (G – H) isComplete.
	self assert: (G • H) isEdgeless.
	self assert: H complement = G! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 11/16/2016 10:08'!
testConnectedComponents
	| G |
	G _ Graph unordered addEdges: {#a -> #b. #b -> #c. #d -> #e}; yourself.
	self assert: G components size = 2.
	self assert: (G components collect: [:each| each order]) = #(2 3) asSet.
	self assert: G components anyOne components size = 1! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 5/25/2016 03:39'!
testDistance
	| G |
	G _ Digraph unordered addEdges: {#a -> #b. #b -> #c. #d -> #e}; yourself.
	self assert: (G distanceFrom: #a to: #c) = 2.
	self assert: (G distanceFrom: #d to: #e) = 1.
	self assert: (G distanceFrom: #b to: #b) = 0.
	self assert: (G distanceFrom: #a to: #e) isInfinite! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 5/25/2016 03:39'!
testEquals
	| G H |
	G _ Digraph ordered addEdges: {#a -> #b. #b -> #c. #c -> #a. #X -> #Y}; yourself.
	H _ Digraph ordered addEdges: {#a -> #b. #b -> #c. #c -> #a}; yourself.
	self assert: G ~= H.
	H addEdge: #X -> #Y.
	self assert: G = H.
	self assert: G hash = H hash! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 5/25/2016 03:15'!
testImplicit
	| G |
	G _ RootedDigraph unordered roots: {2^3} children: [:each| each divisors copyWithout: each].
	self assert: G size = 4.
	self assert: G values asSet = #(1 2 4 8) asSet.
	self assert: G edges size = 6! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 12/8/2016 20:27:53'!
testIntersection
	| G H I |
	G _ Digraph unordered addEdges: {#a -> #b. #b -> #c. #d -> #e. #x -> #b}; yourself.
	H _ Digraph unordered addEdges: {#A -> #B. #b -> #c. #d -> #e. #X -> #X. #b -> #a}; yourself.
	I _ G • H.
	self assert: I numberOfEdges = 2.
	self assert: (I hasEdge: #b -> #c).
	self assert: (I hasEdge: #d -> #e)! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 5/25/2016 03:40'!
testIsComplete
	| G |
	G _ Digraph unordered.
	G addEdges: {#a -> #b. #b -> #a. #b -> #c. #a -> #c. #c -> #a}.
	G _ G reflexive.
	self assert: G isComplete not.
	G addEdge: #c -> #b.
	self assert: G isComplete! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 11/16/2016 10:03'!
testIsConnected
	| G |
	G _ Graph unordered addEdges: {#a -> #b. #b -> #c. #d -> #e}; yourself.
	self assert: G isConnected not.
	G addEdge: #e -> #a.
	self assert: G isConnected! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 5/25/2016 03:39'!
testIsCyclic
	| G |
	G _ Digraph unordered addEdges: {#a -> #b. #b -> #c. #d -> #e}; yourself.
	self assert: G isCyclic not.
	G addEdge: #e -> #a.
	self assert: G isCyclic not.
	G addEdge: #c -> #a.
	self assert: G isCyclic! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 5/25/2016 03:40'!
testIsSimple
	| G |
	G _ Digraph ordered addEdges: {#a -> #b. #b -> #c. #d -> #e}; yourself.
	self assert: G isSimple.
	G addEdge: #c -> #b.
	self assert: G isSimple.
	G addEdge: #c -> #b.
	self assert: G isSimple not! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 5/25/2016 03:41'!
testIsSimple2
	| G |
	G _ Digraph ordered addEdges: {#a -> #b. #b -> #c. #d -> #e}; yourself.
	self assert: G isSimple.
	G addEdge: #c -> #c.
	self assert: G isSimple not "a graph with a loop is not simple"! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 11/16/2016 10:08'!
testIsomorphism
	| G H |
	G _ Graph unordered.
	5 timesRepeat: [G addEdge: 5 atRandom -> 5 atRandom].
	H _ G shuffled.
	self assert: G ~ H.
	G _ Graph C: 5. "pentagon"
	H _ G copy.
	G addEdges: {1 -> 6. 6 -> 2}. "make a little triangle"
	H addEdges: {1 -> 6. 6 -> 3}. "same, but skip vertex 2 in the middle"
	H _ H shuffled.
	self deny: G ~ H! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 11/16/2016 10:04'!
testPetersenGraph
	| G |
	G _ Graph petersen.
	self assert: G nodes size = 10.
	self assert: G edges size = 15.
	self assert: G isCubic.
	self assert: G radius = 2.
	self assert: G diameter = 2.
"	self assert: G girth = 5"! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 5/25/2016 03:41'!
testShortestPath
	| G |
	G _ Digraph unordered.
	G addEdges: {#a -> #b. #b -> #a. #b -> #c. #a -> #c. #c -> #a}.
	self assert: (G shortestPathFrom: #c to: #b) asArray = #(a b).
	G addEdge: #c -> #b.
	self assert: (G shortestPathFrom: #c to: #b) asArray = #(b)! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 5/25/2016 03:39'!
testTransposed
	| G T |
	G _ Digraph unordered addEdges: {#a -> #b. #b -> #c. #d -> #e}; yourself.
	T _ G transposed.
	self assert: (G hasEdge: #b -> #c).
	self assert: (G hasEdge: #c -> #b) not.
	self assert: (T hasEdge: #b -> #c) not.
	self assert: (T hasEdge: #c -> #b)! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 11/16/2016 10:05'!
testTuttePolynomial
	| G P x y T |
	G _ Graph ordered addEdges: {1->2. 2->3. 3->4. 4->1. 1->3}; yourself.
	P _ ZZ polynomialsIn: #(x y).
	x _ P x.
	y _ P y.
	T _ x*(x^2 + (x+y)) + (x^2 + (x+y)) + (x*y + (y^2)).
	self assert: G tuttePolynomial = T! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 11/16/2016 10:05'!
testTuttePolynomial2
	| G P x y T |
	G _ Graph ordered addEdges: {1->2. 2->3. 3->4. 4->1. 1->3}; yourself.
	P _ ZZ polynomialsIn: #(x y).
	x _ P x.
	y _ P y.
	T _ x*(x^2 + (x+y)) + (x^2 + (x+y)) + (x*y + (y^2)).
	self assert: G tuttePolynomial = T! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 11/16/2016 10:08'!
testTuttePolynomialK3
	| G P x y T |
	G _ Graph K: 3.
	P _ ZZ polynomialsIn: #(x y).
	x _ P x.
	y _ P y.
	T _ x^2 + x + y.
	self assert: G tuttePolynomial = T! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 11/16/2016 10:08'!
testTuttePolynomialK4
	| G P x y T |
	G _ Graph K: 4.
	P _ ZZ polynomialsIn: #(x y).
	x _ P x.
	y _ P y.
	T _ x^3 + (x^2*3) + (x*2) + (x*y*4) + (y*2) + (y^2*3) + (y^3).
	self assert: G tuttePolynomial = T! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 11/16/2016 10:08'!
testUndirectedEdgeContraction
	| G |
	G _ Graph ordered addEdges: {1->2. 2->3. 3->4. 4->1. 1->3}; yourself.
	self assert: G edges size = 5.
	self assert: (G / (1->2)) edges size = 4.
	self assert: (G / (1->2) / ((1->2)->3)) edges size = 3! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 12/8/2016 20:34:14'!
testUnion
	| G |
	G _ Digraph unordered addEdges: {#a -> #b. #b -> #c. #d -> #e. #x -> #b}; yourself.
	self assert: (G – G transposed) = G symmetric! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 8/30/2016 20:00'!
smallGroupAtRandom
	^ {[SymmetricGroup new: 3].
	[AlternatingGroup new: 3].
	[PermutationGroup klein].
	[MatrixGroup klein].
	[Group symmetric: (1 to: 4)]} atRandom value! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 6/29/2016 00:37'!
testActionOrbitOf
	| g1 g2 g3 G |
	g1 _ Permutation new: 8 cycles: #((1 3 2) (4 6 5)).
	g2 _ Permutation new: 8 cycles: #((1 2 3) (4 5 6)).
	g3 _ Permutation new: 8 cycles: #((7 8)).
	G _ PermutationGroup on: (1 to: 8) generators: {g1. g2. g3}.
	self assert: (G action orbitOf: 1) = #(1 2 3) asSet.
	self assert: (G action orbitOf: 4) = #(4 6 5) asSet.
	self assert: (G action orbitOf: 7) = #(7 8) asSet! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 11/14/2016 08:44'!
testActionStabilizerOf
	| g1 g2 g3 id G |
	g1 _ Permutation new: 8 cycles: #((1 3 2) (4 6 5)).
	g2 _ Permutation new: 8 cycles: #((1 2 3) (4 5 6)).
	g3 _ Permutation new: 8 cycles: #((7 8)).
	id _ Permutation new: 8.
	G _ PermutationGroup on: (1 to: 8) generators: {g1. g2. g3}.
	self assert: (G action stabilizerOf: 1) asSet = {id. g3} asSet.
	self assert: (G action stabilizerOf: 7) asSet = {id. g1. g2} asSet! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 5/2/2016 02:12'!
testAlternatingIsSymmetricCommutator
	| S A |
	S _ Group symmetric: (1 to: 3).
	A _ Group alternating: (1 to: 3).
	self assert: A = S commutator.
	self assert: (S indexOf: A) = 2! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 5/2/2016 02:12'!
testAlternatingOrder
	| A |
	A _ Group alternating: (1 to: 3).
	self assert: A order = (3 factorial / 2)! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 11/14/2016 09:06'!
testBigOrder1
	"Test fast computation of group order with Schreier-Sims algorithm.
	This is Sym(10), with order 10!!."
	| x y G |
	x _ Permutation transpose: 2 with: 1.
	y _ Permutation image: #(10 1 2 3 4 5 6 7 8 9).
	G _ PermutationGroup new: 10 generators: {x. y}.
	self assert: G order = 10 factorial! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 11/14/2016 09:07'!
testBigOrder2
	"Test fast computation of group order with Schreier-Sims algorithm.
	This is the Mathieu group on 12 points, the second smallest of the 26 sporadic simple groups, with order 95040."
	self assert: PermutationGroup M12 order = 95040! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 10/17/2016 10:55'!
testCauchyFrobeniusLemma
	"Also called Brunside's lemma, Burnside counting theorem, or orbit-counting theorem."
	| X G phi sum |
	X _ 1 to: 3.
	G _ Group alternating: X.
	phi _ GroupAction from: (G, X) to: X evaluatingWithArguments: [:f :x| f value: x].
	sum _ G elements sum: [:g| (phi fixedPointsOf: g) size].
	self assert: phi orbits size * G order = sum! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 11/6/2016 10:04'!
testD3
	| D S A |
	D _ PermutationGroup dihedral: 2*3.
	self testGroup: D.
	S _ SymmetricGroup new: 3.
	self assert: D = S.
	A _ AlternatingGroup new: 3.
	self assert: D commutator = A.
	self assert: D center isTrivial! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 11/6/2016 09:58'!
testDirectProduct
	| S A G g |
	S _ self smallGroupAtRandom.
	A _ self smallGroupAtRandom.
	G _ S × A.
	g _ G atRandom.
	self assert: (G operation value: {g. G inverseMap value: g}) = G identity.
	self testGroup: G.
	self testGroupHomomorphism: (G projection: 1).
	self testGroupHomomorphism: (G projection: 2)! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 11/6/2016 10:02'!
testGroup: G
	| op inv e a b c |
	e _ G identity.
	op _ G operation.
	inv _ G inverseMap.
	a _ G atRandomBits: 100.
	b _ G atRandomBits: 100.
	c _ G atRandomBits: 100.
	self assert: (op value: {e. a}) = a.
	self assert: (op value: {a. e}) = a.
	self assert: (op value: {a. inv value: a}) = e.
	self assert: (op value: {inv value: a. a}) = e.
	self assert: (op value: {op value: {a. b}. c}) = (op value: {a. op value: {b. c}})! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 10/7/2016 06:41'!
testGroupHomomorphism: phi
	| G H a b |
	G _ phi domain.
	H _ phi codomain.
	a _ G atRandomBits: 100.
	b _ G atRandomBits: 100.
	self assert: (phi value: G identity) = H identity.
	self assert: (phi value: (G operation value: {a. b})) = (H operation value: {phi value: a. phi value: b})! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 8/30/2016 19:59'!
testGroupRing
	| G R a a` b b` c c` |
	G _ self smallGroupAtRandom.
	R _ G groupRing.
	a _ G atRandom.
	b _ G atRandom.
	c _ G atRandom.
	a` _ R embed: a.
	b` _ R embed: b.
	c` _ R embed: c.
	self assert: a` * b` = (R embed: a*b).
	self assert: a` * 2 + b` * c` - (a` * c`) - (b` * c`) = (R embed: a*b).
	self assert: (a` + b`) * (a` - b`) = (a` ^ 2 - (b` ^ 2))! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 8/30/2016 19:56'!
testGroupRingIsARing
	| G R a a` b b` c c` e e` |
	G _ self smallGroupAtRandom.
	R _ G groupRing.
	e _ G identity.
	a _ G atRandom.
	b _ G atRandom.
	c _ G atRandom.
	e` _ R embed: e.
	a` _ R embed: a.
	b` _ R embed: b.
	c` _ R embed: c.
	self assert: e` = R one.
	self assert: e` * a` = a`.
	self assert: a` * e` = a`.
	self assert: (a` * b` * c`) = (a` * (b` * c`)).
	G isCommutative ifTrue: [self assert: a` * b` = (b` * a`)].! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 11/6/2016 10:03'!
testHessian
	| H |
	H _ PermutationGroup hessian.
	self assert: H elements size = 216.
	self testGroup: H! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 5/2/2016 02:35'!
testIsSolvable
	| G |
	G _ Group symmetric: (1 to: 3).
	self assert: G isSolvable! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 5/2/2016 02:35'!
testIsSolvableNot
	| G |
	G _ Group alternating: (1 to: 5).
	self assert: G isSolvable not! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 11/6/2016 10:03'!
testKleinFour
	| V S A |
	V _ PermutationGroup klein.
	self testGroup: V.
	S _ SymmetricGroup new: 4.
	self assert: (V isNormalIn: S).
	A _ AlternatingGroup new: 4.
	self assert: (V isNormalIn: A)! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 8/30/2016 19:35'!
testLagrangeTheorem
	"G finite group, H subgroup of G, then |H| divides |G|."
	| G H |
	G _ self smallGroupAtRandom.
	H _ G span: (G random next: 3 atRandom) asSet.
	self assert: H order | G order! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 12/2/2016 11:10:56'!
testModularIntegersUnits
	| m R U |
	m _ (2 to: 100) atRandom.
	R _ ZZ / m.
	U _ R units.
	self assert: U size = (Sequence phi value: m).
"	self testGroup: U"! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 10/17/2016 10:55'!
testOrbitStabilizerTheorem
	| X G phi p |
	X _ 1 to: 4.
	G _ Group alternating: X.
	phi _ GroupAction from: (G, X) to: X evaluatingWithArguments: [:f :x| f value: x].
	p _ X atRandom.
	self assert: (phi stabilizerOf: p) order * (phi orbitOf: p) size = G order! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 12/22/2016 21:40:10'!
testPermutationGroupHomomorphism
	"Magma Handbook, Example H57E2."
	| C15 h im |
	C15 _ PermutationGroup cyclic: 15.
	h _ C15 to: C15 evaluating: [:g| g ^ 3].
	im _ h image.
	self assert: im space size = 15. "a permutation group acting on a set of cardinality 15"
	self assert: im size = 5. "of order 5"
	self assert: im isCyclic! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 11/6/2016 10:02'!
testQuotientGroup
	| G N Q pi h |
	G _ Group integersMod: 6.
	N _ G span: {3 % 6}.
	Q _ G / N.
	self assert: Q size = 3.
	self testGroup: Q.
	pi _ Q projection.
	self assert: (Q includes: (pi value: G atRandom)).
	h _ Q atRandom.
	self assert: (pi value: (pi section value: h)) = h.
	self testGroupHomomorphism: pi! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 5/2/2016 02:36'!
testSymmetricOrder
	| G |
	G _ Group symmetric: (1 to: 4).
	self assert: G order = 4 factorial! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 11/14/2016 08:35'!
testTrivial
	| G |
	G _ PermutationGroup new: 4 generators: #().
	self assert: G size = 1.
	self assert: G isTrivial! !

!LinearBasisTest methodsFor: 'as yet unclassified' stamp: 'len 1/17/2017 08:36:13'!
testCoordinates
	| V B |
	V _ QQ^3.
	B _ LinearBasis on: V generators: {(1,1,1). (1,2,3)}.
	self assert: (B coordinatesOf: (1,1,1)) = (1,0).
	self assert: (B coordinatesOf: (1,2,3)) = (0,1).
	self assert: (B coordinatesOf: (0,1,2)) = (-1,1).
! !

!LinearBasisTest methodsFor: 'as yet unclassified' stamp: 'len 1/17/2017 08:37:05'!
testGenerates
	| V B |
	V _ QQ^3.
	B _ LinearBasis on: V generators: {(1,1,1). (1,2,3)}.
	self assert: (B generates: (1,1,1)).
	self assert: (B generates: (0,1,2)).
	self deny: (B generates: (2,2,3))! !

!LinearGroupsTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:03'!
testGeneralLinearAtRandom
	| V G |
	V _ QQ ^ 3.
	G _ V automorphisms.
	self assert: (G atRandomBits: 100) isInvertible.
	self assert: (G includes: (G atRandomBits: 100))! !

!LinearGroupsTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:03'!
testOrthogonalAtRandom
	| V G |
	V _ QQ ^ 3.
	G _ V automorphisms orthogonal.
	self assert: (G atRandomBits: 100) isOrthogonal.
	self assert: (G includes: (G atRandomBits: 100))! !

!LinearGroupsTest methodsFor: 'as yet unclassified' stamp: 'len 12/8/2016 11:38:49'!
testRotationsBy90Degrees
	"Group of rotations by 90 degrees in the plane, isomorphic to Z/4Z."
	| V G |
	V _ QQ ^ 2.
	G _ (LinearGroup on: V) generators: {V endomorphisms vectorAt: (0, 1, -1, 0)}.
	self assert: G size = 4.
	self assert: G isCyclic.
	self flag: #todo.
	"test invariant ring K[x,y]^G = K[x^2+y^2, x^2y^2, x^3y-xy^3], isomorphic to K[a,b,c]/<c^2-a^2b+4b^2>"
	"test hilbert series is 1-z^8 / ((1-z^2)^2(1-z^4)) = 1 + z^2 + 3z^4 + 3z^6 + ..."! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 11/3/2016 04:39'!
testAlgebraicExtension
	| x E a b |
	x _ QQ polynomials x.
	E _ QQ extension: x^4 - 2.
	a _ E x.
	self assert: (a^4) representative asScalar = 2.
	b _ a^2 + (E embed: 3).
	self assert: b minimalPolynomial = (x^2 - (x*6) + 7)! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 7/2/2016 05:48'!
testBitCount
	| v |
	v _ 1 << 3000 :: atRandom.
	self assert: (v printStringBase: 2 :: count: [:x| x = $1]) = v bitCount! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 7/2/2016 05:48'!
testBitParity
	| v |
	v _ 1 << 3000 :: atRandom.
	self assert: ((v printStringBase: 2 :: count: [:x| x = $1]) bitAnd: 1) = v bitParity! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 2/4/2016 19:50'!
testCRT
	| crt |
	crt _ CRT mod: #(2 5 7).
	self assert: (crt solutionFor: #(0 2 0)) = 42! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/16/2016 13:35:30'!
testCartesianProduct
	| P x |
	P _ CartesianProduct components: {PrimeField new: 3. GaloisField new: 4. SymmetricGroup new: 5}.
	self assert: P elements size = (3*4*5 factorial).
	x _ {(P at: 1) atRandom. (P at: 2) atRandom. (P at: 3) atRandom}.
	self assert: (P elements includes: x)! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/4/2015 01:46'!
testContinuedFractions
	| x |
	x _ ContinuedFraction fromFraction: 415/93.
	self assert: x coefficients = (4, 2, 6, 7).
	self assert: x asFraction = (415/93)! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/4/2015 22:01'!
testContinuedFractions2
	-2 to: 2 by: 1/2 do:
		[:x| self assert: (ContinuedFraction fromFraction: x) asFraction = x]! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 3/27/2016 04:47'!
testContinuedFractionsE
	| x e |
	e _ ContinuedFraction e.
	x _ e convergentAt: 20.
	self assert: (x asFloat - 1 exp) abs < 0.0000001! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 3/27/2016 04:47'!
testContinuedFractionsGoldenRatio
	| x phi |
	phi _ ContinuedFraction phi.
	x _ phi convergentAt: 20.
	self assert: (x asFloat - 1.6180339887) abs < 0.000001! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 07:58'!
testContinuedFractionsGoldenRatio2
	| phi denominators |
	phi _ ContinuedFraction phi.
	denominators _ phi convergents collect: [:each| each denominator].
	self assert: (denominators equals: Sequence fibonacci << 1 upTo: 100)! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/3/2015 02:18'!
testContinuedFractionsNegated
	| x |
	x _ ContinuedFraction fromFraction: 415/93.
	self assert: x negated asFraction = (-415/93)! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/3/2015 02:19'!
testContinuedFractionsReciprocal
	| x |
	x _ ContinuedFraction fromFraction: 415/93.
	self assert: x reciprocal asFraction = (93/415)! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/10/2016 20:30:38'!
testCyclotomicPolynomials
	| P |
	P _ QQ polynomials.
	1 to: 20 do: [:n| self assert: (P cyclotomic: n) degree = n phi]! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/10/2016 20:36:22'!
testCyclotomicPolynomials2
	| P x n |
	P _ QQ polynomials.
	x _ P x.
	n _ 100 atRandom.
	self assert: (n divisors product: [:d| P cyclotomic: d]) = (x^n - 1)! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 3/21/2016 00:12'!
testExtendedEuclid
	| a b euclid |
	a _ -1000 to: 1000 :: atRandom.
	b _ -1000 to: 1000 :: atRandom.
	euclid _ ExtendedEuclid on: {a. b}.
	self assert: euclid gcd | a.
	self assert: euclid gcd | b.
	self assert: (euclid combination * {a. b}) sum = euclid gcd.
	self assert: euclid gcd = (a gcd: b).
	self assert: euclid verify! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:05'!
testFieldAutomorphisms
	self assert: QQ automorphisms isTrivial! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 10/16/2016 13:28'!
testFormalSetEquals
	| A B |
	A _ QQ ^ (10@10) :: asFormalSet.
	B _ (QQ ^ (10@10)) asRing asFormalSet.
	self assert: A = B! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/20/2016 11:48:35'!
testFunctionComposition
	| f g a |
	f _ Function from: ZZ to: ZZ evaluating: [:x| x * 2].
	g _ Function from: ZZ to: ZZ evaluating: [:x| x + 1].
	a _ 1000 atRandom.
	self assert: (f ” g value: a) = (f value: (g value: a)).
	self assert: (g ” f value: a) = (g value: (f value: a))! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/20/2016 11:48:47'!
testFunctionComposition2
	| f g a |
	f _ Function from: ZZ to: QQ evaluating: [:x| x / 2].
	g _ Function from: QQ to: ZZ evaluating: [:x| x numerator].
	a _ 1000 atRandom.
	self assert: (f ” g value: a) = (f value: (g value: a)).
	self assert: (g ” f value: a) = (g value: (f value: a))! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/20/2016 11:48:53'!
testFunctionComposition3
	| f g |
	f _ Function from: ZZ to: QQ evaluating: [:x| x / 2].
	g _ Function from: ZZ to: ZZ evaluating: [:x| x + 1].
	self should: [g ” f] raise: DomainError! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 10/2/2016 09:37'!
testFunctionNewFrom
	| f g |
	f _ QQ^3 :: endomorphisms atRandomBits: 1000. "f is a LinearMap"
	g _ f as: Function. "degrade it to a simple Function, not a LinearMap any more"
	self assert: (g as: LinearMap) = f! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/11/2016 20:01:51'!
testFundamentalDiscriminant
	self assert: ((1 to: 33) select: [:each| each isFundamentalDiscriminant]) =  #(1 5 8 12 13 17 21 24 28 29 33).
	self assert: ((0 to: -31 by: -1) select: [:each| each isFundamentalDiscriminant]) = #(-3 -4 -7 -8 -11 -15 -19 -20 -23 -24 -31) 
! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/16/2016 13:35:43'!
testGaloisFields
	| GF pi x one a |
	GF _ GaloisField new: 3^3.
	self assert: GF isField.
	self assert: GF characteristic = 3.
	pi _ GF projection.
	x _ pi domain x.
	one _ pi domain one.
	a _ pi value: x^2 + one.
	self assert: a * a reciprocal = GF one.
	[(a _ GF atRandom) isZero] whileTrue.
	self assert: a * a reciprocal = GF one! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 6/4/2016 21:56'!
testInfinity
	self assert: Infinity positive > Infinity negative.
	self assert: Infinity positive > 127934879182734.
	self assert: Infinity negative < -198273498712341.
	self assert: Infinity positive >= 127934879182734.
	self assert: Infinity negative <= -198273498712341.
	self assert: -918723948719 > Infinity negative.
	self assert: 91872123948719 < Infinity positive! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 7/8/2016 05:34'!
testInfinityUndeterminates
	self should: [Infinity positive + Infinity negative] raise: Error.
	self should: [Infinity positive * 0] raise: Error.
	self should: [Infinity positive / Infinity positive] raise: Error.
	self should: [Infinity positive ^ 0] raise: Error
! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/13/2015 02:02'!
testIntegerDivisors
	self assert: 12 numberOfDivisors = 6.
	self assert: 12 divisors size = 6! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/2/2016 11:11:24'!
testIteratorCovering
	| F |
	F _ ZZ / 3.
	self assert: (F^3 upTo: 3^3) asSet size = (3^3).
	self assert: (ZZ^3 upTo: 100) asSet size = 100! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/16/2016 13:35:55'!
testIteratorCovering2
	| F |
	F _ GaloisField new: 9.
	self assert: ((F^3) upTo: 9^3) asSet size = (9^3).
	self assert: ((F^3) upTo: 9^3+100) asSet size = (9^3)! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/16/2016 13:36:04'!
testIteratorCovering3
	| F |
	F _ GaloisField new: 3.
	self assert: ((F^4) upTo: 3^4) asSet size = (3^4).
	self assert: ((F^4) upTo: 3^4+100) asSet size = (3^4)! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/26/2016 23:11:25'!
testJacobiAndLegendreSymbols
	| a p |
	10 timesRepeat:
		[p _ (1000 atRandom + 2) nextPrime. "an odd prime"
		a _ 1000 atRandom - 1.
		self assert: (a legendre: p) = (a jacobi: p)]! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/28/2016 08:34:47'!
testKroneckerAndLegendreSymbols
	| a p |
	10 timesRepeat:
		[p _ (1000 atRandom + 2) nextPrime. "an odd prime"
		a _ 1000 atRandom - 1.
		self assert: (a legendre: p) = (a kronecker: p)]! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/28/2016 08:51:30'!
testKroneckerSymbol
	| a b c |
	a _ (-100 to: 100) atRandom.
	b _ (-100 to: 100) atRandom.
	self assert: ((a kronecker: b) = 0) = ((a gcd: b) ~= 1).
	c _ (-100 to: 100) atRandom.
	self assert: (a*b kronecker: c) = ((a kronecker: c) * (b kronecker: c)).
	b*c = 0 ifFalse: [self assert: (a kronecker: b*c) = ((a kronecker: b) * (a kronecker: c))]! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/23/2015 02:56'!
testLLL
	| b1 b2 b3 lll |
	b1 _ (1, 1, 1).
	b2 _ (-1, 0, 2).
	b3 _ (3, 5, 6).
	lll _ LLL basis: { b1. b2. b3 }.
	self assert: lll reducedBasis = {(0,1,0). (1,0,1). (-1,0,2)}! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 4/12/2016 07:35'!
testLatticeAnDual
	| A3 A3Dual |
	A3 _ Lattice A: 3.
	A3Dual _ Lattice Adual: 3.
	self assert: A3 dual = A3Dual.
	self assert: A3 = A3Dual dual! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 4/12/2016 07:36'!
testLatticeD4SelfDual
	| D4 |
	D4 _ Lattice D4.
	self assert: D4 isSelfDual! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/11/2016 08:03:09'!
testLatticeDual
	| V basis lattice dualLattice I |
	V _ QQ ^ 3.
	basis _ LinearBasis on: V generators: {(-1,0,0). (0,1,2). (0,1,1)}.
	lattice _ Lattice basis: basis.
	dualLattice _ lattice dual.
	I _ basis matrix identity.
	self assert: lattice basis span = dualLattice basis span.
	self assert: lattice determinant = (1 / dualLattice determinant).
	self assert: lattice basis matrix * dualLattice basis matrix = I! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 11/3/2016 08:14'!
testLatticeDual2
	| V basis lattice dualLattice |
	V _ QQ ^ 3.
	basis _ LinearBasis on: V generators: {(-1,0,0). (0,1,2)}. "not full rank"
	lattice _ Lattice basis: basis.
	dualLattice _ lattice dual.
	self assert: lattice basis span = dualLattice basis span.
	self assert: lattice determinant = (1 / dualLattice determinant).
	self assert: (lattice basis matrix * dualLattice basis matrix) isIdentity! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/26/2016 23:13:26'!
testLegendreSymbol
	self assert: ((1 to: 10) collect: [:k| k legendre: 43]) = #(1 -1 -1 1 -1 1 -1 -1 1 1)! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/2/2016 11:17:48'!
testModularIntegersField
	| F a b |
	F _ ZZ / 7.
	self assert: F isField.
	self assert: F characteristic = 7.
	a _ F projection value: 3.
	b _ F projection value: 5.
	self assert: a * a reciprocal = F one.
	self assert: a * 7 = F zero.
	self assert: b ^ (F size - 1) = F one "Euler's theorem"! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 7/2/2016 21:04'!
testPartitions
	self assert: 42 partitions size =  53174! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 7/1/2016 09:53'!
testPermutationProduct
	| a b |
	a _ Permutation cycles: #((1 4 5) (2 3)).
	b _ Permutation cycles: #((2 4) (5 1)).
	self assert: a*b = (Permutation cycle: #(1 2 3 4)).
	self assert: a*a = (Permutation cycle: #(1 5 4))! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 7/1/2016 09:53'!
testPermutationProduct2
	| a b |
	a _ Permutation new: 5 cycles: #((1 4 5) (2 3)).
	b _ Permutation new: 5 cycles: #((2 4) (5 1)).
	self assert: a*b = (Permutation cycle: #(1 2 3 4)).
	self assert: a*a = (Permutation cycle: #(1 5 4))! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 7/1/2016 09:53'!
testPermutationProduct3
	| a b |
	a _ Permutation cycles: #((2 3 4)).
	b _ Permutation cycles: #((1 2) (3 4)).
	self assert: a*b = (Permutation cycle: #(1 2 4)).
	self assert: b*a = (Permutation cycle: #(1 3 2))! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 10/22/2016 18:55'!
testPolynomialVectorSpace
	| Qx V S x |
	Qx _ QQ polynomials.
	x _ Qx x.
	V _ Qx filtrationAt: 5.
	S _ V span: {Qx one. x^2. x*2}.
	self assert: (S includes: x^2 + 2).
	self deny: (S includes: x^3 + 2).
	self assert: (S project: x^3 - (x^2) + (x*2) + 3) = ((x^2) negated + (x*2) + 3)! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/13/2015 01:54'!
testPrimeSignature
	self assert: 1 primeSignature = #().
	self assert: 7 primeSignature = #(1).
	self assert: (7*5) primeSignature = #(1 1).
	self assert: 12 primeSignature = #(2 1).
	self assert: 100 primeSignature = #(2 2).
	self assert: 42 primeSignature = #(1 1 1).
	self assert: 16 primeSignature = #(4)! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:05'!
testQuadraticForms
	| V A Q f p |
	V _ QQ ^ (2 to: 5) atRandom.
	[A _ QQ ^ (V dimension @ V dimension) atRandomBits: 100. A isZero] whileTrue.
	A _ A + A transposed. "make it symmetric"
	Q _ QuadraticForm from: V basis matrix: A.
	f _ Q asPolynomial.
	p _ V atRandomBits: 100.
	self assert: (Q value: p) = (f value: p).
	self assert: (f degree = 2 and: [f isHomogeneous])! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/29/2016 07:26:17'!
testQuadraticResiduesModp
	| F |
	F _ PrimeField new: 1000 atRandom nextPrime.
	self assert: F atRandom squared isQuadraticResidue.
	self assert: ((1000 count: [F atRandom isQuadraticResidue]) between: 400 and: 600)! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/21/2016 20:21:11'!
testRadicalAndIsSquareFree
	| n |
	n _ (-1000 to: 1000) atRandom.
	self assert: n isSquareFree = (n radical = n)! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 6/4/2016 21:48'!
testRealIntervalIntersects
	| I J |
	I _ RealInterval open: -1 closed: 0.
	J _ RealInterval open: 0 closed: 1.
	self assert: (I intersects: J) not.
	J _ RealInterval closed: 0 open: 1.
	self assert: (I intersects: J).
	J _ RealInterval closed: -2 closed: -1.
	self assert: (I intersects: J) not! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/29/2016 08:24:12'!
testSquareRootModp
	| F a |
	100 timesRepeat:
		[F _ PrimeField new: (1000 atRandom + 1) nextPrime.
		a _ F atRandom.
		a _ a squared.
		self assert: a squareRoot * a squareRoot = a]! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 3/3/2016 23:22'!
testWord
	| x y |
	x _ Word x: #x.
	y _ Word x: #y.
	self assert: (x*y) * y reciprocal = x.
	self assert: (x*y * (y reciprocal * x reciprocal)) isEmpty.
	self assert: x*y*y * (y reciprocal * y reciprocal * x) = (x^2).
	self assert: x * (y * y * x) = (x * y * (y * x)).
	self assert: (x*y * (x*y) reciprocal) isEmpty! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 03:30'!
testYoungTableauxSemistandard
	| T |
	T _ YoungTableau rows: #((1 1 2 2 3) (2 3 4 4) (4) (5)).
	self assert: T isSemistandard.
	self assert: T shape = #(5 4 1 1)! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 03:30'!
testYoungTableauxStandard
	| T |
	T _ YoungTableau rows: #((1 4 6 8) (2 5 7) (3)).
	self assert: T isStandard.
	self assert: T weight = #(1 1 1 1 1 1 1 1).
	self assert: T shape = #(4 3 1)! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 11/11/2016 09:00'!
testAdjugate
	| A I |
	A _ Matrix rows: { (2,1,1). (-1,0,1). (0,2,1) }.
	I _ A identity.
	self assert: A * A adjugate = (I * A determinant)! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 11/11/2016 09:00'!
testAdjugate2
	| A B |
	A _ Matrix rows: { (-3,2,-5). (-1,0,-2). (3,-4,1) }.
	B _ Matrix rows: { (-8,18,-4). (-5,12,-1). (4,-6,2) }.
	self assert: A adjugate = B! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:05'!
testAdjugateProperties
	| M A B I c |
	M _ QQ ^ (3@3).
	A _ M rows: { (-3,2,-5). (-1,0,-2). (3,-4,1) }.
	B _ M rows: { (-1,2,3). (1,-2,1). (2,2,-1) }.
	c _ 7.
	I _ M identity.
	self assert: I adjugate = I.
	self assert: (A * B) adjugate = (B adjugate * A adjugate).
	self assert: (A*c) adjugate = (A adjugate * (c^(M numberOfRows - 1))).
	self assert: (A^5) adjugate = (A adjugate ^ 5).
	self assert: A transposed adjugate = A adjugate transposed! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:05'!
testCayleyHamiltorTheoremInQ
	| n M A |
	n _ 6 atRandom.
	M _ QQ ^ (n@n).
	A _ M atRandomBits: 100.
	self assert: (A characteristicPolynomial value: A) isZero! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:47'!
testCayleyHamiltorTheoremInZ
	| n M A |
	n _ 6 atRandom.
	M _ ZZ ^ (n@n).
	A _ M atRandomBits: 100.
	self assert: (A characteristicPolynomial value: A) isZero! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 8/25/2016 00:51'!
testCharacteristicMatrixAndPolynomialOverQ
	| n A |
	n _ 5 atRandom.
	A _ QQ ^ (n@n) :: atRandomBits: n*5.
	self assert: A characteristicPolynomial = A characteristicMatrix determinant! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 8/25/2016 06:34'!
testCharacteristicMatrixAndPolynomialOverZ
	| n A |
	n _ 5 atRandom.
	A _ ZZ ^ (n@n) :: atRandomBits: n*5.
	self assert: A characteristicPolynomial = A characteristicMatrix determinant! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:05'!
testCharacteristicPolynomial
	| M A B |
	M _ QQ ^ (5@5).
	A _ M atRandomBits: 100.
	self assert: (A characteristicPolynomial value: A) isZero.
	B _ M atRandomBits: 100.
	self assert: (A*B) characteristicPolynomial = (B*A) characteristicPolynomial! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:05'!
testDeterminant
	| M m |
	M _ QQ ^ (2@2).
	m _ M rows: { (2,1). (-1,0) }.
	self assert: m determinant = 1! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:47'!
testDeterminant2
	| M vandermonde |
	M _ QQ ^ (3@3).
	vandermonde _ M rows: {(1,1,1). (3,5,7). (9,25,49)}.
	self assert: vandermonde determinant = 16.
	M _ ZZ ^ (3@3).
	vandermonde _ M rows: {(1,1,1). (3,5,7). (9,25,49)}.
	self assert: vandermonde determinant = 16! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:47'!
testDeterminant3
	| M A B |
	M _ QQ ^ (3@3).
	A _ M rows: {(1,1,1). (3,5,7). (9,25,49)}.
	B _ M rows: {(1,0,4). (1,1,1). (2,-2,-3)}.
	self assert: A determinant * B determinant = (A * B) determinant.
	M _ ZZ ^ (3@3).
	A _ M rows: {(1,1,1). (3,5,7). (9,25,49)}.
	B _ M rows: {(1,0,4). (1,1,1). (2,-2,-3)}.
	self assert: A determinant * B determinant = (A * B) determinant! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:47'!
testDomainError
	| A B |
	A _ ZZ ^ (4@4) :: identity.
	self should: [A / 2] raise: DomainError.
	B _ QQ ^ (4@4) :: identity.
	self should: [A + B] raise: DomainError.
	self should: [A * B] raise: DomainError! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 7/15/2016 23:53'!
testHermiteNormalForm
	"Example from wikipedia."
	| M A H |
	M _ ZZ ^ (4@4).
	A _ M rows: { (3,3,1,4). (0,1,0,0). (0,0,19,16). (0,0,0,3) }.
	H _ M rows: { (3,0,1,1). (0,1,0,0). (0,0,19,1). (0,0,0,3) }.
	self assert: A HNF = H! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 7/15/2016 23:54'!
testHermiteNormalForm2
	| M A H |
	M _ ZZ ^ (3@3).
	A _ M rows: { (9,-36,30). (-36,192,-180). (30,-180,180) }.
	H _ M rows: { (3,0,30). (0,12,0). (0,0,60) }.
	self assert: A HNF = H! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 7/15/2016 23:54'!
testHermiteNormalForm3
	"Example from wikipedia"
	| M A H |
	M _ ZZ ^ (3@4).
	A _ M rows: { (2,3,6,2). (5,6,1,6). (8,3,1,1) }.
	H _ M rows: { (1,0,50,-11). (0,3,28,-2). (0,0,61,-13) }.
	self assert: A HNF = H! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:05'!
testInverse
	| M A I |
	M _ QQ ^ (3@3).
	A _ M rows: { (2,1,1). (-1,0,1). (0,2,1) }.
	I _ M identity.
	self assert: A inverse * A = I.
	self assert: A * A inverse = I! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:06'!
testInverse2
	| Qx x f A |
	Qx _ QQ polynomials.
	x _ Qx x.
	f _ x^8 + (x^6) - (3*(x^4)) - (3*(x^3)) + (8*(x^2)) + (2*x) - 5.
	A _ f companion.
	self assert: (A * A inverse) isIdentity! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 7/16/2016 00:48'!
testIsHNF
	| M |
	M _ ZZ ^ (4@4) rows: {(2,0,1,11). (0,1,5,12). (0,0,6,12). (0,0,0,33)}.
	self assert: M isHNF.
	self assert: M transposed isHNF not.
	M _ ZZ ^ (5@4) rows: {(2,0,1,11). (0,1,5,12). (0,0,6,12). (0,0,0,33). (0,0,0,0)}.
	self assert: M isHNF.
	M _ ZZ ^ (5@4) rows: {(2,0,1,11). (0,1,5,12). (0,0,6,12). (0,0,0,33). (0,0,0,1)}.
	self assert: M isHNF not! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 1/17/2017 11:15:15'!
testJordanNormalForm
	| M A jordan B |
"	<timeout: 2>"
	M _ QQ ^ (4@4).
	A _ M rows: { (5,4,2,1). (0,1,-1,-1). (-1,-1,3,0). (1,1,-1,2) }.
	jordan _ A jordan.
	self assert: jordan size = 3.
	B _ QQ ^ (1@1) scalar: 1.
	self assert: (jordan includes: B).
	B _ QQ ^ (1@1) scalar: 2.
	self assert: (jordan includes: B).
	B _ QQ ^ (2@2) scalar: 4 :: at: 1@2 put: 1; yourself.
	self assert: (jordan includes: B)! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 11/4/2016 10:26'!
testKernel
	| A S |
	A _ QQ ^ (4@6) rows: {(1, 0, -3, 0, 2, -8). (0, 1, 5, 0, -1, 4). (0, 0, 0, 1, 7, -9). (0, 0, 0, 0, 0, 0)}.
	S _ QQ ^ 6 span: {(3,-5,1,0,0,0). (-2,1,0,-7,1,0). (8,-4,0,9,0,1)}.
	self assert: A kernel = S! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:06'!
testKernelImageTheorem
	| n A |
	n _ 6 atRandom.
	A _ QQ ^ (n @ n) atRandomBits: 100.
	self assert: A kernel dimension + A image dimension = n! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 10/17/2016 16:45'!
testKroneckerProduct
	| A B C |
	A _ ZZ ^ (2@2) elementAt: (1,2,3,4).
	B _ ZZ ^ (2@2) elementAt: (0,5,6,7).
	C _ ZZ ^ (4@4) elementAt: (0, 5, 0, 10, 6, 7, 12, 14, 0, 15, 0, 20, 18, 21, 24, 28).
	self assert: (A kronecker: B) = C! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 8/24/2016 19:23'!
testLeftInverse
	| M A |
	M _ QQ ^ (5@3).
	[A _ M atRandomBits: 1000. A rank = 3] whileFalse.
	self assert: (A leftInverse * A) isIdentity! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:06'!
testMinimalPolynomial
	| M m f |
	M _ QQ ^ (5@5).
	m _ M atRandomBits: 100.
	f _ m minimalPolynomial.
	self assert: f | m characteristicPolynomial.
	self assert: (f value: m) isZero! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 10/17/2016 16:45'!
testMinor
	| M A |
	M _ ZZ ^ (3@3).
	A _ M elementAt: #(1 2 3 4 5 6 7 8 9).
	self assert: (A minor: 2@3) = -6! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 10/17/2016 16:45'!
testMinors
	| A |
	A _ ZZ ^ (2@3) elementAt: (1 to: 6).
	self assert: (A minors: 2) asArray = #(-3 -6 -3)! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 12/18/2016 20:02:55'!
testQRDecomposition
	| n A QR Q R |
	n _ 3.
	[A _ QQ ^ (n@n) :: atRandomBits: n*n. A isFullRank] whileFalse.
	A _ A over: RealAlgebraicNumbersField new.
	QR _ A QR.
	Q _ QR Q.
	R _ QR R.
	self assert: Q * R = A.
	self assert: Q isOrthogonal.
	self assert: R isUpperTriangular! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:48'!
testRank
	| M vandermonde |
	M _ QQ ^ (3@3).
	vandermonde _ M rows: {(1,1,1). (3,5,7). (9,25,49)}.
	self assert: vandermonde rank = 3.
	M _ ZZ ^ (3@3).
	vandermonde _ M rows: {(1,1,1). (3,5,7). (9,25,49)}.
	self assert: vandermonde rank = 3! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:48'!
testRank2
	| M m |
	M _ QQ ^ (3@3).
	m _ M rows: {(1,1,1). (2,2,0). (3,3,1)}.
	self assert: m rank = 2.

	M _ ZZ ^ (3@3).
	m _ M rows: {(1,1,1). (2,2,2). (5,5,5)}.
	self assert: m rank = 1! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:06'!
testRankNullityTheorem
	| n A |
	n _ 6 atRandom.
	A _ QQ ^ (n @ n) atRandomBits: 100.
	self assert: A rank + A nullity = n! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 7/16/2016 03:59'!
testReducerPivots
	| A |
	A _ ZZ ^ (3@3) rows: {(0,-1,-1). (0,-20,1). (0,1,2)}.
	self assert: A reducer pivots asArray = {2@1. 3@2}! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 8/24/2016 19:24'!
testRightInverse
	| M A |
	M _ QQ ^ (3@5).
	[A _ M atRandomBits: 1000. A rank = 3] whileFalse.
	self assert: (A * A rightInverse) isIdentity! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 8/24/2016 19:19'!
testSimilarity
	"Examples from wikipedia article on SNF"
	| M A B C |
	M _ QQ ^ (2@2).
	A _ M rows: {(1,2). (0,1)}.
	B _ M rows: {(3,-4). (1,-1)}.
	C _ M rows: {(1,0). (1,2)}.
	self assert: A ~ B.
	self deny: A ~ C! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 8/24/2016 19:19'!
testSimilarity2
	| n M A B P |
	n _ 5 atRandom.
	M _ QQ ^ (n@n).
	A _ M atRandomBits: 10*n*n.
	[(P _ M atRandomBits: 10*n*n) isSingular] whileTrue.
	B _ M atRandomBits: 10*n*n.
	self assert: A ~ (P inverse * A * P).
	self deny: A ~ B! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 7/15/2016 23:53'!
testSmithNormalForm
	| M A |
	M _ ZZ ^ (3@3).
	A _ M rows: { (2,4,4). (-6,6,12). (10,-4,-16) }.
	self assert: A SNF = (2,6,12)! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 7/15/2016 23:53'!
testSmithNormalForm2
	| M A |
	M _ ZZ ^ (3@3).
	"Reduced Laplacian matrix of K_4:"
	A _ M rows: { (3,-1,-1). (-1,3,-1). (-1,-1,3) }.
	self assert: A SNF = (1,4,4)! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:48'!
testTransposed
	| A |
	A _ ZZ ^ (6 atRandom @ 6 atRandom) :: atRandomBits: 1000.
	self assert: A columns = A transposed rows.
	self assert: A transposed transposed = A! !

!ModularTest methodsFor: 'as yet unclassified' stamp: 'len 12/10/2016 12:56:12'!
testGamma0Index
	self assert: (1 to: 19 :: collect: [:each| Gamma0CongruenceSubgroup new: each :: index]) = #(1 3 4 6 6 12 8 12 12 18 12 24 14 24 24 24 18 36 20).
	self assert: (Gamma0CongruenceSubgroup new: 32041) index = 32220! !

!ModularTest methodsFor: 'as yet unclassified' stamp: 'len 12/10/2016 12:23:06'!
testGamma0NumberOfCusps
	| p |
	self assert: (1 to: 19 :: collect: [:each| Gamma0CongruenceSubgroup new: each :: numberOfCusps]) =  #(1 2 2 3 2 4 2 4 4 4 2 6 2 4 4 6 2 8 2).
	p _ 1.
	100 timesRepeat: [self assert: (Gamma0CongruenceSubgroup new: (p _ p nextPrime)) numberOfCusps = 2]! !

!ModularTest methodsFor: 'as yet unclassified' stamp: 'len 12/15/2016 23:02:48'!
testGammaIndex
	self assert: (1 to: 19 :: collect: [:each| PrincipalCongruenceSubgroup new: each :: index]) =  #(1 6 24 48 120 144 336 384 648 720 1320 1152 2184 2016 2880 3072 4896 3888 6840)! !

!ModularTest methodsFor: 'as yet unclassified' stamp: 'len 12/15/2016 23:16:41'!
testIndexOf
	| G H |
	G _ PrincipalCongruenceSubgroup new: 2.
	H _ PrincipalCongruenceSubgroup new: 8.
	self assert: (G indexOf: H) = 32 "according to GAP manual chap. 2, Gamma(2) has index 12"! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 12/2/2016 11:11:38'!
newFreeModule
	^ self newFreeModuleOver: {ZZ. QQ. ZZ / (10 atRandom + 1)} atRandom! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 12/30/2016 12:19:23'!
newFreeModuleOver: scalars
	| M |
	M _ 2 atRandom = 1 ifTrue: [scalars ^ 4 atRandom] ifFalse: [scalars ^ (4 atRandom @ 4 atRandom)].
	"don't let it get too big, or the test is too slow:"
	(M rank < 5 and: [3 atRandom = 1]) ifTrue: [^ M endomorphisms].
	3 atRandom = 1 ifTrue: [^ M dual].
	^ M! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:57'!
testAnnihilator
	| V v S S0 |
	V _ QQ ^ 3.
	v _ (1,-2,1).
	S _ V span: {v}.
	S0 _ S annihilator.
	self assert: S0 dimension = S codimension.
	S0 basis do: [:f| self assert: (f value: v) isZero]! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 12/8/2016 20:28:03'!
testAnnihilatorProperties
	| V S T |
	V _ QQ ^ 5.
	S _ (V grassmannian: 4) atRandomBits: 100.
	T _ (S grassmannian: 2) atRandomBits: 100.
	T _ V span: T basis. "hack, otherwise T ambient = S"
	self assert: T <= S.
	self assert: T annihilator >= S annihilator. "reverses inclusions"
	self assert: (S + T) annihilator = (S annihilator • T annihilator).
	self assert: S dimension + S annihilator dimension = V dimension.
	self assert: V annihilator isTrivial.
"	self assert: S annihilator annihilator = S dual dual"! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 12/2/2016 11:17:43'!
testAnnihilatorZ2
	| V v S S0 |
	V _ (ZZ / 2) ^ 4.
	[(v _ V atRandom) isZero] whileTrue.
	S _ V span: {v}.
	S0 _ S annihilator.
	self assert: S0 dimension = S codimension.
	S0 basis do: [:f| self assert: (f value: v) isZero]! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 11/2/2016 08:20'!
testCanonicalMorphisms
	| V W |
	V _ QQ^3.
	W _ V span: {(1,2,3)}.
	self assert: (V null  W) isZero. "canonical morphism from initial object"
	self assert: (V  W null) isZero. "canonical morphism to terminal object"
	self assert: ((W  W null) value: (1,2,3)) isZero.
	self assert: (W  V value: (2,4,6)) = (2,4,6). "canonical morphism to overobject"! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 10/16/2016 09:57'!
testDirectSum
	| M N S |
	M _ self newFreeModule.
	N _ self newFreeModuleOver: M scalars.
	S _ M  N.
	self testFreeModule: S.
	self testLinearMap: (S projection: 2 atRandom).
	self testLinearMap: (S embedding: 2 atRandom)! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 11/2/2016 03:59'!
testFirstIsomorphismTheorem
	| V S T f phi |
	V _ QQ ^ 5.
	S _ V grassmannian: (1 to: V dimension) atRandom :: atRandomBits: 50.
	T _ V grassmannian: (1 to: V dimension) atRandom :: atRandomBits: 50.
	f _ S hom: T :: atRandomBits: 50.
	phi _ S / f kernel to: f image evaluating: [:x| f value: x representative].
	self assert: phi isIsomorphism! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 10/17/2016 16:41'!
testFreeModule: M
	| c t v x y |
	x _ M atRandomBits: 10 * M rank.
	self assert: x = (M elementAt: (M coordinatesOf: x)).
	y _ M atRandomBits: 10 * M rank.
	c _ M scalars atRandomBits: 20.
	v _ x * c + y.
	t _ (M coordinatesOf: x) * c + (M coordinatesOf: y).
	self assert: v = (M elementAt: t).
	self testLinearMap: M basis coordinatesMap! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 1/16/2017 22:38:28'!
testFreeZModule
	| A x0 x y0 y |
	A _ FormalSumsModule on: #(a b c) over: ZZ.
	x0 _ (-2,-1,3).
	x _ A elementAt: x0.
	y0 _ (1,1,1).
	y _ A elementAt: y0.
	self assert: x+y = (A elementAt: x0+y0).
	self assert: x*2-y = (A elementAt: x0*2-y0).
	self assert: (x-y-(x-y)) isZero.
	self assert: (A coordinatesOf: x) = x0! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:57'!
testGrassmannian
	| G S |
	G _ QQ^3 grassmannian: 2.
	S _ G atRandomBits: 20.
	self assert: S dimension = 2.
	self assert: (G includes: S).
	self assert: (G dual includes: S perp dual)! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 11/3/2016 08:14'!
testLinearBasisCoordinatesOf
	| V basis c |
	V _ QQ ^ 3.
	basis _ LinearBasis on: V generators: {(-1,0,0). (0,0,2)}.
	c _ basis coordinatesOf: (1,0,4).
	self assert: c = (-1,2)! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 11/3/2016 08:14'!
testLinearBasisCoordinatesOf2
	| V basis c |
	V _ QQ ^ 3.
	basis _ LinearBasis on: V generators: {(-1,0,0). (0,0,2)}.
	c _ basis coordinatesOf: (1,1,4).
	self assert: c isNil! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 11/5/2016 07:17'!
testLinearBasisDual
	| V basis B Bdual I |
	V _ QQ ^ 3.
	basis _ LinearBasis on: V generators: {(-1,0,0). (0,1,2). (0,1,1)}.
	B _ basis matrix.
	Bdual _ basis dual matrix.
	I _ B identity.
	self assert: B determinant = (1 / Bdual determinant).
	self assert: B transposed * Bdual = I! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:57'!
testLinearForm1
	| V f |
	V _ QQ ^ 3.
	f _ LinearForm from: V evaluating: [:v| v x + v y - v z].
	self assert: (f value: (1,1,1)) = 1.
	self assert: (f value: (2,2,1)) = 3.
	self assert: (f value: (3,1, -1)) = 5! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:58'!
testLinearForm2
	| V f |
	V _ QQ ^ 3.
	f _ LinearForm from: V evaluating: [:v| v x + v y - v z].
	self assert: f domain = V.
	self assert: f kernel dimension = 2.
	self assert: f image dimension = 1! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:58'!
testLinearFormAsPolynomial
	| V f x |
	V _ QQ ^ 5 atRandom.
	f _ V dual atRandomBits: 100.
	x _ V atRandomBits: 100.
	self assert: (f value: x) = (f asPolynomial value: x).
	self assert: f asPolynomial asLinearForm = f! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 10/18/2016 21:00'!
testLinearFormZ2
	| V f |
	V _ (PrimeField new: 2) ^ 4.
	f _ LinearForm from: V evaluating: [:v| v sum].
	self assert: f domain = V.
	self assert: f kernel dimension = 3.
	self assert: f image dimension = 1.
	self assert: (f kernel includes: (1,1,1,1) % 2)! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:58'!
testLinearMap
	| V S f |
	V _ QQ ^ 3.
	S _ V span: {(1, 1, 1). (2, 0, -2)}.
	f _ LinearMap projectionOn: S.
	self assert: (f value: (2, 2, 2)) = (2, 2,  2).
	self assert: (f value: (1, 0, -1)) = (1, 0,  -1)! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 10/16/2016 09:17'!
testLinearMap: f
	| a1 a2 b1 b2 x |
	a1 _ f domain atRandomBits: 20.
	a2 _ f domain atRandomBits: 20.
	b1 _ f value: a1.
	b2 _ f value: a2.
	self assert: (f value: f domain zero) isZero.
	x _ f domain scalars atRandomBits: 20.
	self assert: (f value: a1 * x + a2) = (b1 * x + b2)! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 12/20/2016 11:50:13'!
testLinearMapAdjoint
	| V W f f` phi |
	V _ self newFreeModuleOver: QQ.
	W _ self newFreeModuleOver: QQ.
	f _ V hom: W :: atRandomBits: 50.
	f` _ f adjoint.
	self assert: f` domain = f codomain dual.
	self assert: f` codomain = f domain dual.
	phi _ W dual atRandomBits: 20.
	self assert: (f` value: phi) = (phi ” f)! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 12/20/2016 12:05:24'!
testLinearMapComposition
	| X Y Z f g x |
	X _ QQ ^ 3.
	Y _ QQ ^ 5.
	Z _ QQ ^ 4.
	f _ (X hom: Y) atRandomBits: 1000.
	g _ (Y hom: Z) atRandomBits: 1000.
	x _ X atRandomBits: 1000.
	self assert: ((X hom: Z) includes: g ” f).
	self assert: (g ” f value: x) = (g value: (f value: x)).
	self should: [f ” g] raise: DomainError! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 12/20/2016 11:50:35'!
testLinearMapCompositionError
	| X Y Z f g |
	X _ QQ ^ 3.
	Y _ QQ ^ 5.
	Z _ QQ ^ 4.
	f _ (X hom: Y) atRandomBits: 1000.
	g _ (Y hom: Z) atRandomBits: 1000.
	self should: [f ” g] raise: DomainError! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 11/2/2016 04:00'!
testLinearMapFiber
	| f w v |
	f _ (QQ ^ 6 atRandom hom: QQ ^ 6 atRandom) atRandomBits: 100.
	w _ f image atRandomBits: 100.
	v _ (f fiberAt: w) atRandomBits: 100.
"	Transcript show: w; nextPutAll: ' <- '; show: v; newLine."
	self assert: (f value: v) = w! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 11/2/2016 04:00'!
testLinearMapImage
	| V W f image v w |
	V _ QQ ^ 5 atRandom.
	W _ QQ ^ 5 atRandom.
	f _ (V hom: W) atRandomBits: 1000.
	image _ f image.
	v _ V atRandomBits: 100.
	w _ f value: v.
	self assert: (image includes: w)! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:58'!
testLinearMapImage2
	| V S f image |
	V _ QQ ^ 3.
	S _ V span: {(1, 1, 1). (2, 0, -2)}.
	f _ LinearMap projectionOn: S.
	image _ f image.
	self assert: (image includes: (f value: (S atRandomBits: 100))).
	self assert: (image includes: (f value: (V atRandomBits: 100)))! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 12/20/2016 11:50:45'!
testLinearMapInverse
	| V f |
	V _ QQ ^ 3.
	f _ V automorphisms atRandomBits: 1000.
	self assert: (f ” f inverse) isIdentity.
	self assert: (f inverse ” f) isIdentity! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 11/2/2016 04:01'!
testLinearMapKernel
	| V W f kernel v |
	V _ QQ ^ 5 atRandom.
	W _ QQ ^ 5 atRandom.
	f _ (V hom: W) atRandomBits: 1000.
	kernel _ f kernel.
	v _ kernel atRandomBits: 100.
	self assert: (f value: v) isZero! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:58'!
testLinearMapKernel2
	| V S f kernel |
	V _ QQ ^ 3.
	S _ V span: {(1, 1, 1). (2, 0, -2)}.
	f _ LinearMap projectionOn: S.
	kernel _ f kernel.
	self assert: (kernel apply: f) isTrivial.
	self assert: kernel dimension = 1! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 10/18/2016 21:00'!
testLinearMapKernelZ2
	| V f kernel |
	V _ (PrimeField new: 2) ^ 3.
	f _ LinearForm from: V evaluating: [:v| v sum].
	kernel _ f kernel.
	self assert: (kernel apply: f) isTrivial.
	self assert: kernel dimension = 2.
	self assert: (kernel includes: (0,1,1) % 2)! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 12/20/2016 11:50:51'!
testLinearMapLeftInverse
	| V W f |
	V _ QQ ^ 3.
	W _ QQ ^ 5.
	[f _ (V hom: W) atRandomBits: 1000. f rank = 3] whileFalse.
	self assert: (f leftInverse ” f) = V id! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 12/20/2016 11:50:57'!
testLinearMapRightInverse
	| V W f |
	V _ QQ ^ 5.
	W _ QQ ^ 3.
	[f _ (V hom: W) atRandomBits: 1000. f rank = 3] whileFalse.
	self assert: (f ” f rightInverse) = W id! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 11/2/2016 04:01'!
testLinearMapZ2
	| V f kernel v |
	V _ (PrimeField new: 2) ^ (5 atRandom + 1).
	[f _ V endomorphisms atRandom.
	(kernel _ f kernel) isTrivial or: [kernel = V]] whileTrue. "find one with non-trivial kernel"
	[v _ V atRandom. kernel includes: v] whileTrue.
	self assert: (f value: v) isZero not.
	v _ kernel atRandom.
	self assert: (f value: v) isZero! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:58'!
testLinearSystem
	| V  x y z system |
	V _ QQ ^ 3.
	x _ V dual e: 1.
	y _ V dual e: 2.
	z _ V dual e: 3.
	system _ (x*3 + (y*2) - z eq: 1), (x*2 - (y*2) + (z*4) eq: -2), (x*(-1) + (y/2) - z eq: 0).
	self assert: (system isSolution: (1, -2, -2))! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:59'!
testLinearSystemSolver
	| V  x y z system |
	V _ QQ ^ 3.
	x _ V dual e: 1.
	y _ V dual e: 2.
	z _ V dual e: 3.
	system _ (x*3 + (y*2) - z eq: 1), (x*2 - (y*2) + (z*4) eq: -2), (x*(-1) + (y/2) - z eq: 0).
	self assert: (system solutions includes: (1, -2, -2))! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:59'!
testLinearSystemSolver2
	| V  x y z system f1 f2 |
	V _ QQ ^ 3.
	x _ V dual e: 1.
	y _ V dual e: 2.
	z _ V dual e: 3.
	f1 _ x*3 + (y*2) - z.
	f2 _ x*2 - (y*2) + (z*4).
	system _ (f1 eq: 1), (f2 eq: -2), (f1*2 eq: 2).
	self assert: system kernel dimension = 1.
	self assert: (system solutions includes: (1, -2, -2))! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 10/17/2016 16:45'!
testLinearSystemSolver3
	| V  x y z system f1 f2 |
	V _ QQ ^ (2@2).
	x _ V dual e: 1.
	y _ V dual e: 2.
	z _ V dual e: 3.
	f1 _ x*3 + (y*2) - z.
	f2 _ x*2 - (y*2) + (z*4).
	system _ (f1 eq: 1), (f2 eq: -2), (f1*2 eq: 2).
	self assert: system kernel dimension = 2.
	self assert: (system solutions includes: (V elementAt: (1, -2, -2, 0)))! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:59'!
testMatricesQ
	self testFreeModule: (QQ ^ (5 atRandom @ 5 atRandom))! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:46'!
testMatricesZ
	self testFreeModule: (ZZ ^ (5 atRandom @ 5 atRandom))! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 12/2/2016 11:11:58'!
testMatricesZ2
	self testFreeModule: ((ZZ / 2) ^ (5 atRandom @ 5 atRandom))! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 12/2/2016 11:12:02'!
testMatricesZ4
	self testFreeModule: ((ZZ / 4) ^ (5 atRandom @ 5 atRandom))! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:59'!
testMatrixTraceAsLinearMap
	| F f |
	F _ QQ ^ (3@3) :: dual. "linear forms"
	f _ F evaluating: [:x| x trace].
	self assert: f = ((F x: 1) + (F x: 5) + (F x: 9))! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:59'!
testOrthogonalProjection
	| V S p v |
	V _ QQ ^ 3.
	S _ V span: {(1, 1, 0). (1, 0, 0)}.
	p _ S projection.
	v _ (78, 21, 139).
	self assert: (p value: v) = (p value: (p value: v)). "idempotent at v"
	self assert: p isIdempotent.
	self assert: p kernel = S perp.
	self assert: p image = S.
	self assert: (S apply: p) = S! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 11/3/2016 08:14'!
testOrthogonalization
	| V B |
	V _ QQ ^ 3.
	B _ LinearBasis on: V generators: {(1, 1, 0). (1, 0, 0)}.
	self assert: B orthogonalized isOrthogonal.
	self assert: B extended orthogonalized isOrthogonal! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 11/3/2016 08:14'!
testOrthonormalization
	| V B |
	V _ QQ ^ 3.
	B _ LinearBasis on: V generators: {(1, 1, 0). (1, 0, 0)}.
	self assert: B orthonormalized isOrthonormal.
	self assert: B extended orthonormalized isOrthonormal! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:59'!
testPerp
	| V S p perp |
	V _ QQ ^ 3.
	S _ V span: {(1, 1, 1). (2, 0, -2)}.
	perp _ S perp.
	self assert: perp dimension = 1.
	self assert: (V innerProduct value: {perp basis first. S basis first}) isZero.
	self assert: (V innerProduct value: {perp basis first. S basis second}) isZero.
	p _ S projection.
	self assert: p kernel = perp! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 12/8/2016 20:28:10'!
testPerpProperties
	| V S T |
	V _ QQ ^ 3.
	S _ V span: {(1, 1, 1). (2, 0, -2)}.
	T _ V span: {(1, -1, -3)}. "subspace of S"
	self assert: S + S perp = V.
	self assert: T + T perp = V.
	self assert: (S • S perp) isTrivial.
	self assert: S <= S perp perp.
	self assert: S perp < T perp "because S > T"! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 12/2/2016 11:17:38'!
testPerpZ2
	| V S perp |
	V _ (ZZ / 2) ^ 3.
	S _ V span: {(1,1,1) % 2}.
	perp _ S perp.
	self assert: perp dimension = 2.
	self assert: (V innerProduct value: {S basis first. perp basis first}) isZero.
	self assert: (V innerProduct value: {S basis first. perp basis second}) isZero! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 10/16/2016 09:42'!
testQuotient
	| M S Q |
	M _ self newFreeModule.
	S _ M grassmannian: (1 to: M rank) atRandom :: atRandomBits: M rank * 10.
	Q _ M/S.
	self assert: Q rank = (M rank - S rank).
	self assert: (Q includes: S + (M atRandomBits: M rank * 10)).
	self assert: (M / M null) rank = M rank.
	self assert: (M / M) rank = 0! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 10/6/2016 10:36'!
testQuotientMaps
	| V S Q pi v s |
	V _ QQ ^ 5.
	S _ V grassmannian: (1 to: V dimension) atRandom :: atRandomBits: 50.
	Q _ V/S.
	pi _ Q projection.
	v _ V atRandomBits: 100.
	s _ pi value: v.
	self assert: (Q includes: s).
	self assert: (V includes: (pi section value: s)).
	self assert: s = (pi value: (pi section value: s))! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 12/8/2016 20:28:13'!
testSecondIsomorphismTheorem
	| V S T |
	V _ QQ ^ 5.
	S _ V grassmannian: (1 to: V dimension) atRandom :: atRandomBits: 50.
	T _ V grassmannian: (1 to: V dimension) atRandom :: atRandomBits: 50.
	self assert: (S+T)/T ~ (S/(S • T))
"	f _ S -> T :: atRandomBits: 10.
	phi _ S / f kernel -> f image evaluating: [:x| f value: x representative].
	self assert: phi isIsomorphism"! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:02'!
testSubspaceInclusion
	| V S P v w |
	V _ QQ ^ 3.
	[v _ V atRandomBits: 10. v isZero] whileTrue.
	S _ V span: {v}.
	[w _ V atRandomBits: 10. S includes: w] whileTrue.
	P _ V span: {v-w. w}.
	self assert: S < P.
	self assert: P > S.
	self assert: S ~= P.
	self assert: P ~= S.
	self assert: (S > P) not.
	self assert: (P < S) not! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 12/8/2016 20:28:20'!
testSubspaceIntersection
	| V S T T` |
	V _ QQ ^ 3.
	S _ V span: {(1, 1, 1). (2, 0, -2)}.
	self assert: S • V = S.
	self assert: S • S = S.
	T _ V span: {(3,1,-1)}.
	self assert: S • T = T.
	T` _ V span: {(3,1,-1). (0,1,0)}.
	self assert: S • T` = T! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:02'!
testSubspaceOfSubspace
	| V S s T t |
	V _ QQ ^ 3.
	S _ (V grassmannian: 2) atRandomBits: 100.
	T _ (S grassmannian: 1) atRandomBits: 100.
	self assert: S < V.
	self assert: T < S.
	self assert: T < V.
	[s _ S atRandomBits: 100. T includes: s] whileTrue.
	[t _ T atRandomBits: 100. t isZero] whileTrue.
	self assert: (S includes: s).
	self assert: (S includes: t).
	self assert: (T includes: t)! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:02'!
testSubspaceSum
	| V v w S T P |
	V _ QQ ^ 3.
	[v _ V atRandomBits: 10. v isZero not] whileFalse.
	[w _ V atRandomBits: 10. w isZero not and: [v ~= w]] whileFalse.
	S _ V span: {v}.
	T _ V span: {w}.
	P _ V span: {v. w}.
	self assert: S + T = P.
	T _ V span: {v - w. v + w}.
	self assert: S + T = P! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:03'!
testSubspaceSystem
	| V S |
	V _ QQ ^ 3.
	S _ V span: {(1, 1, 1). (2, 0, -2)}.
	self assert: S equations kernel = S! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:03'!
testTensorProductAssociativity
	| V1 V2 V3 |
	V1 _ QQ ^ 2.
	V2 _ QQ ^ 3.
	V3 _ QQ ^ 4.
	self assert: (V1 ’ V2) ’ V3 ~ (V1 ’ (V2 ’ V3))! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:03'!
testTensorProductCommutativity
	| V W |
	V _ QQ ^ 3.
	W _ QQ ^ 4.
	self assert: V ’ W ~ (W ’ V)! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 10/16/2016 08:49'!
testTensorProductOfLinearForms
	| V W f g t v |
	V _ QQ ^ 3.
	W _ V dual.
	f _ W atRandomBits: 10.
	g _ W atRandomBits: 10.
	t _ f ’ g.
	v _ V domain atRandomBits: 10.
	self assert: (t value: v) = ((f value: v) * (g value: v))! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 10/16/2016 09:19'!
testThirdIsomorphismTheorem
	| V S T |
	V _ QQ ^ 5.
	S _ V grassmannian: (1 to: V dimension) atRandom :: atRandomBits: 50.
	T _ S grassmannian: (1 to: S dimension) atRandom :: atRandomBits: 50.
	self assert: (V/T)/(S/T) ~ (V/S)! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:03'!
testTuplesQ
	self testFreeModule: (QQ ^ 5 atRandom)! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:03'!
testTuplesRationalFunctionsQ
	| F |
	F _ QQ polynomials fractions.
	self testFreeModule: (F ^ 3 atRandom)! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:46'!
testTuplesZ
	self testFreeModule: (ZZ ^ 5 atRandom)! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 12/2/2016 11:12:06'!
testTuplesZ2
	self testFreeModule: ((ZZ / 2) ^ 5 atRandom)! !

!ModuleTest methodsFor: 'as yet unclassified' stamp: 'len 12/2/2016 11:12:11'!
testTuplesZ4
	self testFreeModule: ((ZZ / 4) ^ 5 atRandom)! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 2/12/2017 06:02:22'!
testAntigradedLexOrdering
	"Example from 'Using Algebraic Geometry', Cox, Little, O'Shea, Ch. 4, 3.2."
	| M x y |
	M _ MonomialMonoid new: 2 ordering: #lglex. "antigraded lex order"
	x _ M x: 1.
	y _ M x: 2.
	self assert: M identity > x.
	self assert: x > y.
	self assert: x^2 > (x*y).
	self assert: x*y > (y^2).
	self assert: (y^2) > (x^3)! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 2/12/2017 06:20:32'!
testAntigradedRevlexOrdering
	"Example from 'Using Algebraic Geometry', Cox, Little, O'Shea, Ch. 4, 3.3."
	| M x y z ordering |
	"The antigraded revlex order:"
	ordering _ LocalGradedReverseLexicographicOrdering indeterminates: #(3 2 1).
	M _ MonomialMonoid new: 3 ordering: ordering.
	x _ M x: 1.
	y _ M x: 2.
	z _ M x: 3.
	self assert: M identity > x.
	self assert: x > y.
	self assert: y > z.
	self assert: x^2 > (x*y).
	self assert: x*y > (y^2).
	self assert: (x*z) > (y*z).
	self assert: (y*z) > (z^2)! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 11/22/2016 08:31:09'!
testHash
	| m1 m2 |
	m1 _ Monomial exponents: #(1 2 0).
	m2 _ Monomial exponents: #(1 2 0 0 0 0 0).
	self assert: m1 hash = m2 hash! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 2/12/2017 06:03:09'!
testLocalMonomialOrderings
	"Examples from Magma handbook."
	| f |
	f _ ZZ polynomialsIn: #(x y z) ordering: #llex :: generate: [:x :y :z| 1 + x + y + z + (x^7) + (x^8*(y^7)) + (y^5) + (z^10)].
	self assert: f printString = '1 + x + x^7 + y + y^5 + x^8y^7 + z + z^{10}'.
	self assert: (f orderedBy: #lgrevlex) printString = '1 + z + y + x + y^5 + x^7 + z^{10} + x^8y^7'! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 1/14/2017 21:10:56'!
testMonomialDivision
	| M x y |
	M _ MonomialMonoid new: 2.
	x _ M x: 1.
	self assert: x*x = (M x: 1 to: 2).
	y _ M x: 2.
	self assert: x*x*y / (x*y) = x.
	self assert: x*y*x / x = (x*y).
	self assert: x*y*x*y / (x*y) = (x*y)! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 1/14/2017 21:10:57'!
testMonomialGCD
	| M x y a b |
	M _ MonomialMonoid new: 2.
	x _ M x: 1.
	y _ M x: 2.
	a _ x*x*y*y*y.
	b _ x*x*x*y*y.
	self assert: (a gcd: b) = (x*x*y*y)! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 1/14/2017 21:10:53'!
testMonomialLCM
	| M x y a b |
	M _ MonomialMonoid new: 2.
	x _ M x: 1.
	y _ M x: 2.
	a _ x*x.
	b _ x*y*y.
	self assert: (a lcm: b) = (x*x*y*y)! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 2/12/2017 06:04:06'!
testMonomialOrderings
	| P x y z f lex glex grevlex |
	P _ ZZ polynomialsIn: 3.

	x _ P x.
	y _ P y.
	z _ P z.

	f _ 10*x - (7*(y^4)) + (11*(y^3)*z).

	lex _ MonomialOrdering lex: 3.
	glex _ MonomialOrdering glex: 3.
	grevlex _ MonomialOrdering grevlex: 3.

	self assert: (f orderedBy: lex) leadingCoefficient = 10.
	self assert: (f orderedBy: glex) leadingCoefficient = -7.
	self assert: (f orderedBy: grevlex) leadingCoefficient = 11! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 2/12/2017 06:05:34'!
testMonomialOrderings2
	"Examples from Macaulay2 documentation."
	| R a b c d f |
	R _ ZZ polynomialsIn: #(a b c d).
	a _ R x: 1.
	b _ R x: 2.
	c _ R x: 3.
	d _ R x: 4.

	f _ a + (b^100) + (c*d).

	self assert: (f orderedBy: #lex) printString = 'a + b^{100} + cd'.
	self assert: (f orderedBy: #grevlex) printString = 'b^{100} + cd + a'.
	self assert: (f orderedBy: #glex) printString = 'b^{100} + cd + a'! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 2/12/2017 06:05:43'!
testMonomialOrderings3
	"Examples from Derksen, Kemper 'Computational Invariant Theory' 1.1.1."
	| P x1 x2 x3 x4 f |
	P _ ZZ polynomialsIn: 4.
	x1 _ P x: 1.
	x2 _ P x: 2.
	x3 _ P x: 3.
	x4 _ P x: 4.
	f _ x1 + (x2*x4) + (x3^2).
	self assert: (f orderedBy: #lex) leadingTerm = x1.
	self assert: (f orderedBy: #glex) leadingTerm = (x2*x4).
	self assert: (f orderedBy: #grevlex) leadingTerm = (x3^2)! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 2/12/2017 06:06:05'!
testMonomialOrderingsExample
	| a b lex glex grevlex |
	a _ Monomial exponents: #(3 2 8).
	b _ Monomial exponents: #(2 9 2).
	
	lex _ MonomialMonoid new: 3 ordering: #lex.
	glex _ MonomialMonoid new: 3 ordering: #glex.
	grevlex _ MonomialMonoid new: 3 ordering: #grevlex.

	self assert: (a as: lex) > (b as: lex).
	self assert: (a as: glex) > (b as: glex).
	self assert: (a as: grevlex) < (b as: grevlex)! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 2/12/2017 06:04:28'!
testMonomialOrderingsOfIndeterminates
	| M x y z |
	M _ MonomialMonoid new: 3.
	x _ M x: 1.
	y _ M x: 2.
	z _ M x: 3.
	{MonomialOrdering lex: 3.
	MonomialOrdering llex: 3.
	MonomialOrdering glex: 3.
	MonomialOrdering grevlex: 3} do: [:ordering| 
		self assert: (x orderedBy: ordering) > (y orderedBy: ordering).
		self assert: (y orderedBy: ordering) > (z orderedBy: ordering)]! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 1/14/2017 21:10:47'!
testMonomialOrderingsOfIndeterminatesReordered
	| M x y z |
	M _ MonomialMonoid new: 3 ordering: (MonomialOrdering lex: #(2 1 3)).
	x _ M x: 1.
	y _ M x: 2.
	z _ M x: 3.
	self assert: y > x.
	self assert: x > z! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 2/12/2017 06:06:15'!
testMonomialOrderingsSingularExample
	"'A Singular Introduction to Commutative Algebra', Example 1.2.13 (monomial orderings)."
	| f |
	f _ (QQ polynomialsIn: #(x y z)) !! [:x :y :z| x^3*y*z + (x^3) + (x*(y^2)) + (y^5) + (z^4)].
	"Global orderings:"
	self assert: (f orderedBy: #lex) printString =  'x^3yz + x^3 + xy^2 + y^5 + z^4'.
	self assert: (f orderedBy: #grevlex) printString = 'y^5 + x^3yz + z^4 + x^3 + xy^2'.
	self assert: (f orderedBy: #glex) printString = 'x^3yz + y^5 + z^4 + x^3 + xy^2'.
	"TODO: weighted total lexicographic ordering"
	"Local orderings don't match because we implemented them with Magma conventions."
! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 1/14/2017 21:10:51'!
testMonomialProduct
	| M x y |
	M _ MonomialMonoid new: 2.
	x _ M x: 1.
	self assert: x*x = (M x: 1 to: 2).
	y _ M x: 2.
	self assert: x*y = (y*x).
	self assert: x*y*y = (x*(y*y)).
	self assert: ((x*y*y) at: 2) = 2.
	self assert: (x*y*x*x*y) degree = 5! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 2/12/2017 06:04:56'!
testWeightedMonomialOrderings
	| P x y z f lex glex grevlex revlex |
	P _ ZZ polynomialsIn: 3.

	x _ P x.
	y _ P y.
	z _ P z.

	f _ 10*x - (7*(y^4)) + (11*(y^3)*z).

	lex _ WeightedMonomialOrdering lex: (1 to: 3).
	glex _ WeightedMonomialOrdering glex: (1 to: 3).
	grevlex _ WeightedMonomialOrdering grevlex: (1 to: 3).
	revlex _ WeightedMonomialOrdering grevlex: (1 to: 3).

	self assert: (f orderedBy: lex) leadingCoefficient = 10.
	self assert: (f orderedBy: glex) leadingCoefficient = -7.
	self assert: (f orderedBy: grevlex) leadingCoefficient = 11.
	self assert: (f orderedBy: revlex) leadingCoefficient = 11! !

!NumberFieldTest methodsFor: 'as yet unclassified' stamp: 'len 12/10/2016 21:58:12'!
testCyclotomicFieldDiscriminant
	self assert: (CyclotomicField new: 20) discriminant = 4000000.
	self assert: (CyclotomicField new: 18) discriminant = -19683! !

!NumberFieldTest methodsFor: 'as yet unclassified' stamp: 'len 11/3/2016 04:40'!
testQSqrt2
	| E x |
	x _ QQ polynomials x.
	E _ QQ adjoin: RealAlgebraicNumber sqrt2.
	self assert: E x minimalPolynomial = E polynomial.
	self assert: E x squared minimalPolynomial = (x - 2)! !

!NumberFieldTest methodsFor: 'as yet unclassified' stamp: 'len 12/18/2016 20:03:01'!
testQSqrt2RealEmbeddings
	| E embeddings roots |
	E _ QQ adjoin: RealAlgebraicNumber sqrt2.
	embeddings _ E realEmbeddings.
	roots _ (E polynomial rootsIn: RealAlgebraicNumbersField new) asSet.
	self assert: (embeddings collect: [:f| f value: E x]) asSet = roots! !

!NumberFieldTest methodsFor: 'as yet unclassified' stamp: 'len 12/14/2016 14:59:36'!
testQuadraticFieldFundamentalDiscriminant
	self assert: (QuadraticField sqrt: 102) discriminant = 408.
	self assert: (QuadraticField sqrt: 720) discriminant = 5.
	self assert: (QuadraticField sqrt: 2) discriminant = 8! !

!NumberFieldTest methodsFor: 'as yet unclassified' stamp: 'len 12/10/2016 21:40:24'!
testQuadraticFieldSqrt2
	| E x |
	E _ QuadraticField sqrt: 2.
	x _ QQ polynomials x.
	self assert: E x minimalPolynomial = E polynomial.
	self assert: E x squared minimalPolynomial = (x - 2).
	self assert: E discriminant = 8! !

!NumberFieldTest methodsFor: 'as yet unclassified' stamp: 'len 12/10/2016 21:42:04'!
testQuadraticFieldSqrtMinusFive
	| E |
	E _ QuadraticField sqrt: -5.
	self assert: E x minimalPolynomial = E polynomial.
	self assert: E x squared = (E embed: -5).
	self assert: E x ^ 4 = (E embed: 25).
	self assert: E discriminant = -20! !

!NumberFieldTest methodsFor: 'as yet unclassified' stamp: 'len 12/10/2016 22:02:25'!
testSignature
	self assert: (CyclotomicField new: 5) signature = #(0 2).
	self assert: (CyclotomicField new: 2) signature = #(1 0)! !

!NumberFieldTest methodsFor: 'as yet unclassified' stamp: 'len 12/10/2016 21:45:04'!
testTotallyImaginary
	| x E |
	x _ QQ polynomials x.
	E _ NumberField polynomial: x^2 + 2.
	self assert: E isImaginary.
	E _ NumberField polynomial: x^2 - 2.
	self assert: E isImaginary not.
	E _ NumberField polynomial: x^4 - 2.
	self assert: E isImaginary not! !

!NumberFieldTest methodsFor: 'as yet unclassified' stamp: 'len 12/10/2016 21:47:44'!
testTotallyReal
	| x E |
	x _ QQ polynomials x.
	E _ NumberField polynomial: x^2 + 2.
	self assert: E isReal not.
	E _ NumberField polynomial: x^2 - 2.
	self assert: E isReal.
	E _ NumberField polynomial: x^4 - 2.
	self assert: E isReal not! !

!PAdicsTest methodsFor: 'as yet unclassified' stamp: 'len 1/5/2017 16:39:21'!
testPAdicNorm
	| Z7 x |
	Z7 _ PAdicIntegerRing p: 2.
	x _ Z7 embed: 7.
	self assert: x valuation = 0.
	self assert: x norm = 1.
	x _ x * 4.
	self assert: x valuation = 2.
	self assert: x norm = (1/4)! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 1/9/2017 21:38:34'!
testAllMonomialsOfDegree
	| d n |
	n _ 5 atRandom.
	d _ 5 atRandom.
	self assert: (ZZ polynomialsIn: n :: allMonomialsOfDegree: d) size = (n+d-1 choose: d)! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:08'!
testArithmetic
	| x f g |
	x _ QQ polynomials x.
	f _ x^2 + (x*2) - 1.
	g _ x^2 - (x*2) + 1.
	self assert: f+g = (x^2 * 2).
	self assert: f-g = (x*4 - 2).
	self assert: f*g = (x^4 - (x^2 * 4) + (x*4) - 1).
	self assert: f*g // g = f.
	self assert: (f*g \\ g) isZero.
	self assert: (f*g + (x - 1) \\ g) = (x - 1)
! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 12/2/2016 11:17:24'!
testArithmeticZ2
	| x f g |
	x _ ZZ / 2 :: polynomials x.
	f _ x^2 + (x*2) - 1.
	g _ x^2 - (x*2) + 1.
	self assert: f+g = (x^2 * 2).
	self assert: f-g = (x*4 - 2).
	self assert: f*g = (x^4 - (x^2 * 4) + (x*4) - 1).
	self assert: f*g // g = f.
	self assert: (f*g \\ g) isZero.
	self assert: (f*g + (x - 1) \\ g) = (x - 1)
! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 12/2/2016 11:12:40'!
testArithmeticZ3
	| x f g |
	x _ ZZ / 3 :: polynomials x.
	f _ x^2 + (x*2) - 1.
	g _ x^2 - (x*2) + 1.
	self assert: f+g = (x^2 * 2).
	self assert: f-g = (x*4 - 2).
	self assert: f*g = (x^4 - (x^2 * 4) + (x*4) - 1).
	self assert: f*g // g = f.
	self assert: (f*g \\ g) isZero.
	self assert: (f*g + (x - 1) \\ g) = (x - 1)
! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:08'!
testCRT
	| x f1 f2 f3 crt r1 r2 r3 h |
	x _ QQ polynomials x.
	f1 _ x^5 + 1.
	f2 _ x^2 + 1.
	f3 _ x - 1.
	crt _ CRT mod: {f1. f2. f3}.
	r1 _ x-1.
	r2 _ x+1.
	r3 _ x-x. "zero"
	h _ crt solutionFor: {r1. r2. r3}.
	self assert: h \\ f1 = r1.
	self assert: h \\ f2 = r2.
	self assert: h \\ f3 = r3! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:50'!
testCompanionMatrix
	| x p |
	x _ ZZ polynomials x.
	p _ x^2 + (x*2) - 1.
	self assert: p companion characteristicPolynomial = p.
	self assert: p companion minimalPolynomial = p! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:50'!
testContentAndPrimitive
	| Zx Zxy x y f |
	Zx _ ZZ polynomialsIn: #(x).
	Zxy _ Zx polynomialsIn: #(y).
	x _ Zx x.
	y _ Zxy x.
	f _ 2*x*y + (2*(x^2)).
	self assert: f primitive * f content = f! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:50'!
testContentAndPrimitiveAtRandom
	| Zx f |
	Zx _ ZZ polynomials.
	f _ Zx atRandomBits: 100 maxDegree: (1 to: 10) atRandom.
	self assert: f primitive * f content = f! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:50'!
testDiscriminant
	| Zx x f g |
	Zx _ ZZ polynomials.
	x _ Zx x.
	f _ x^2 + x + 1.
	g _ x^3 + 1.
	self assert: (f*g) discriminant = (f discriminant * g discriminant * (f resultant: g) squared)! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 11/28/2016 22:09:14'!
testDiscriminant2
	| Zx x f |
	Zx _ ZZ polynomials.
	x _ Zx x.
	f _ x^2 - x - 36042.
	self assert: f discriminant = 144169 "this is a prime, although looks like a square :)"! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 7/4/2016 04:33'!
testDivision: F
	| Fx f g |
	Fx _ F polynomials.
	f _ Fx atRandomBits: 100 maxDegree: 10 atRandom.
	[g _ Fx atRandomBits: 100 maxDegree: 10 atRandom. g isZero] whileTrue.
	self assert: (f // g) * g + (f \\ g) = f! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:08'!
testDivisionQ
	self testDivision: QQ! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 10/18/2016 21:01'!
testDivisionZ2
	self testDivision: (PrimeField new: 2)! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 10/18/2016 21:01'!
testDivisionZ65535
	self testDivision: (PrimeField new: 2^17 - 1)! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:50'!
testDomainError
	| f g |
	f _ ZZ polynomials atRandomBits: 10.
"	self should: [f / 2] raise: DomainError."
	g _ QQ polynomials atRandomBits: 10.
	self should: [f + g] raise: DomainError.
	self should: [f * g] raise: DomainError! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 11/25/2016 10:33:07'!
testEPRS
	"Example from Zippel."
	| a b eprs |
	a _ ZZ polynomials coefficients: #(1 0 1 0 -3 -3 8 2 -5) reversed.
	b _ ZZ polynomials coefficients: #(3 0 5 0 -4 -9 21) reversed.
	eprs _ a eprs: b :: collect: [:each| each coefficients reversed asArray] :: asArray.
	self assert: eprs = #((1 0 1 0 -3 -3 8 2 -5)
		(3 0 5 0 -4 -9 21)
		(-15 0 3 0 -9) 
		(15795 30375 -59535) 
		(1254542875143750 -1654608338437500) (12593338795500743100931141992187500))! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:50'!
testEvaluationHomomorphism
	| Zx f g a |
	Zx _ ZZ polynomials.
	f _ Zx atRandomBits: 1000 maxDegree: 10.
	g _ Zx atRandomBits: 1000 maxDegree: 10.
	a _ ZZ atRandomBits: 100.
	self assert: (f+g value: a) = ((f value: a) + (g value: a)).
	self assert: (f-g value: a) = ((f value: a) - (g value: a)).
	self assert: (f*g value: a) = ((f value: a) * (g value: a)).
	self assert: (f^3 value: a) = ((f value: a)^3)! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 3/31/2016 06:56'!
testEvaluationHomomorphism: F
	| Fx f g a |
	Fx _ F polynomials.
	f _ Fx atRandomDegree: 10 atRandom.
	g _ Fx atRandomDegree: 10 atRandom.
	a _ F atRandom.
	self assert: (f+g value: a) = ((f value: a) + (g value: a)).
	self assert: (f-g value: a) = ((f value: a) - (g value: a)).
	self assert: (f*g value: a) = ((f value: a) * (g value: a)).
	self assert: (f^3 value: a) = ((f value: a)^3)! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:51'!
testEvaluationHomomorphismMultivariate
	| Zxyz f g a |
	Zxyz _ ZZ polynomialsIn: #(x y z).
	f _ Zxyz atRandomBits: 1000 maxDegree: 10.
	g _ Zxyz atRandomBits: 1000 maxDegree: 10.
	a _ ZZ ^ 3 atRandomBits: 100.
	self assert: (f+g value: a) = ((f value: a) + (g value: a)).
	self assert: (f-g value: a) = ((f value: a) - (g value: a)).
	self assert: (f*g value: a) = ((f value: a) * (g value: a)).
	self assert: (f^3 value: a) = ((f value: a)^3)! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 10/18/2016 21:01'!
testEvaluationHomomorphismZ2
	self testEvaluationHomomorphism: (PrimeField new: 2)! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 12/2/2016 11:13:08'!
testEvaluationHomomorphismZm
	self testEvaluationHomomorphism: ZZ / (2 + 100 atRandom).
	self testEvaluationHomomorphism: ZZ / (2^13 - 2).
	self testEvaluationHomomorphism: ZZ / (2^31 - 2)! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 12/2/2016 11:17:17'!
testEvaluationHomomorphismZp
	self testEvaluationHomomorphism: (PrimeField new: 3).
	self testEvaluationHomomorphism: (PrimeField new: 5).
	self testEvaluationHomomorphism: (PrimeField new: 2^13 - 1).
	self testEvaluationHomomorphism: (PrimeField new: 2^31 - 1)! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:51'!
testEvaluationMultivariate
	| Zxyz f a x y z |
	Zxyz _ ZZ polynomialsIn: #(x y z).
	x _ Zxyz x. y _ Zxyz y. z _ Zxyz z.
	f _ x^2 * y - z.
	a _ ZZ ^ 3 atRandomBits: 100.
	self assert: (f value: a) = ((a at: 1)^2 * (a at: 2) - (a at: 3))! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 2/6/2017 03:09:32'!
testExactDivisionBug
	| Zx x f |
	Zx _ ZZ polynomials.
	x _ Zx x.
	f _ x*2.
	self assert: f /// f = Zx one! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 2/6/2017 03:10:03'!
testExactDivisionMultivariate
	| Qxy x y f g |
	Qxy _ QQ polynomialsIn: #(x y).
	x _ Qxy x.
	y _ Qxy y.
	f _ x-y.
	g _ x+y.
	self assert: f * g /// g = f.
	self assert: f * g /// f = g! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:08'!
testExactDivisionMultivariate2
	| Qxy x y f g |
	Qxy _ QQ polynomialsIn: #(x y).
	x _ Qxy x.
	y _ Qxy y.
	f _ x-y.
	g _ x+y.
	self assert: (f * g divideBy: g) quotient = f.
	self assert: (f * g divideBy: f) quotient = g! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 2/6/2017 03:10:17'!
testExactDivisionOverQ
	| x f g |
	x _ QQ polynomials x.
	f _ x^2 + x + 1.
	g _ 1 - x.
	self assert: f * g /// g = f.
	self assert: f * g /// f = g! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 2/6/2017 03:10:30'!
testExactDivisionOverQRandom
	| Qx f g |
	Qx _ QQ polynomials.
	f _ Qx atRandomBits: 100 maxDegree: (1 to: 10) atRandom.
	g _ Qx atRandomBits: 100 maxDegree: (1 to: 10) atRandom.
	self assert: f * g /// g = f.
	self assert: f * g /// f = g! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 2/6/2017 03:10:42'!
testExactDivisionOverZ
	| x f g |
	x _ ZZ polynomials x.
	f _ x^2 + x + 1.
	g _ 1 - x.
	self assert: f * g /// g = f.
	self assert: f * g /// f = g! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:08'!
testExtendedEuclidBug
	| x f1 f2 |
	x _ QQ polynomials x.
	f1 _ x^2 + 1.
	f2 _ x - 1.
	self assert: (ExtendedEuclid on: {f1. f2}) gcd = (f1 gcd: f2)! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 12/2/2016 11:16:47'!
testFiniteFieldFactorization
	| F Fx x one f factors |
	F _ ZZ / 3.
	Fx _ F polynomials.
	x _ Fx x.
	one _ Fx one.
	f _ x^11 + (x^9 * 2) + (x^8 * 2) + (x^6) + (x^5) + (x^3 * 2) + (x^2 * 2) + one.
	factors _ f factorizer factors.
	self assert: factors size = 8.
	self assert: (factors occurrencesOf: x + (one*2)) = 4.
	self assert: (factors occurrencesOf: x^2 + one) = 3.
	self assert: (factors occurrencesOf: x + one) = 1.
	self assert: (factors inject: Fx one into: [:a :b|a*b]) = f! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 12/2/2016 11:16:50'!
testFiniteFieldFactorization2
	| Z3 x f factors |
	Z3 _ ZZ / 3.
	x _ Z3 polynomials x.
	f _ (x-1)^2*(x-2).
	factors _ f factors.
	self assert: factors size = 3.
	self assert: (factors occurrencesOf: x-1) = 2.
	self assert: (factors occurrencesOf: x-2) = 1! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 12/2/2016 11:13:13'!
testFiniteFieldFactorizationZ2
	| Z2 x f factors |
	Z2 _ ZZ / 2.
	x _ Z2 polynomials x.
	f _ x^24 - 1.
	factors _ f factors.
	self assert: factors size = 16.
	self assert: (factors occurrencesOf: x+1) = 8.
	self assert: (factors occurrencesOf: x^2+x+1) = 8! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 12/2/2016 11:16:43'!
testFiniteFieldIrreduciblePolynomials
	"Z/<3>[x] has 8 irreducible monic polynomials of degree 3, out of 27 monic polynomials of degree 3."
	| F Fx f count |
	F _ ZZ / 3.
	Fx _ F polynomials.
	count _ 0.
	(F ^ 3) do: [:each|
		f _ (Fx coefficients: each, F one).
		f isIrreducible
			ifTrue:
				[count _ count + 1.
				self assert: f factors size = 1]
			ifFalse:
				[self assert: f factors size > 1]].
	self assert: count = 8! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 12/2/2016 11:16:38'!
testFiniteFieldIsIrreducible
	| F Fx x f |
	F _ ZZ / 3.
	Fx _ F polynomials.
	x _ Fx x.
	f _ x^3 + (x*2) + 1.
	self assert: f factors size = 1.
	self assert: f isIrreducible! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 12/2/2016 11:16:34'!
testFiniteFieldRoots
	| Z3 x f roots |
	Z3 _ ZZ / 3.
	x _ Z3 polynomials x.
	f _ (x-1)^2*(x-2).
	roots _ f roots.
	self assert: roots size = 3.
	self assert: (roots occurrencesOf: (Z3 project: 1)) = 2.
	self assert: (roots occurrencesOf: (Z3 project: 2)) = 1! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 12/2/2016 11:16:31'!
testFiniteFieldSFF
	| F Fx x one f factors |
	F _ ZZ / 3.
	Fx _ F polynomials.
	x _ Fx x.
	one _ Fx one.
	f _ x^11 + (x^9 * 2) + (x^8 * 2) + (x^6) + (x^5) + (x^3 * 2) + (x^2 * 2) + one.
	factors _ f factorizer squareFreeFactorization.
	self assert: factors size = 8.
	self assert: (factors occurrencesOf: x + (one*2)) = 4.
	self assert: (factors occurrencesOf: x^2 + one) = 3.
	self assert: (factors occurrencesOf: x + one) = 1! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:09'!
testGCD
	| P x f g |
	P _ QQ polynomials.
	x _ P x.
	f _ x^4 - 1.
	g _ x^6 - 1.
	self assert: (f gcd: g) = (x^2 - 1)! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:52'!
testGCDMultivariate
	| Zxy x y f g |
	Zxy _ ZZ polynomialsIn: #(x y).
	x _ Zxy x.
	y _ Zxy y.
	f _ (x+y)*(y-x).
	g _ (y-x)^2.
	self assert: (f gcd: g) = (y-x)! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:09'!
testGCDMultivariate2
	| P x y f1 f2 f3 f4 f5 f g |
	P _ QQ polynomialsIn: #(x y).
	x _ P x.
	y _ P y.
	f1 _ x^2 + (y^2) + 1.
	f2 _ y - 1.
	f3 _ y^2 + 1.
	f4 _ y^2 + 2.
	f5 _ x^2 + 4.
	f _ f1*f1*f2*f3*f3*f3.
	g _ f1*f1*f4*f5.
	self assert: (f gcd: g) = (f1 * f1)! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:52'!
testGCDOverZ
	| x f g |
	x _ ZZ polynomials x.
	f _ (x^4 - 1)*6.
	g _ (x^6 - 1)*9.
	self assert: (f gcd: g) = ((x^2 - 1)*3)! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:52'!
testGaussLemma
	"Lemma (Gauss): The product of two primitive polynomials is primitive."
	| Zx f g |
	Zx _ ZZ polynomials.
	f _ Zx atRandomBits: 100 maxDegree: (5 to: 10) atRandom.
	g _ Zx atRandomBits: 100 maxDegree: (5 to: 10) atRandom.
	self assert: (f primitive * g primitive) isPrimitive! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:09'!
testInterpolation
	| Qx f |
	Qx _ QQ polynomials.
	f _ Qx interpolate: {1 -> 2. 2 -> 3. 4 -> 5}.
	self assert: (f value: 1) = 2.
	self assert: (f value: 2) = 3.
	self assert: (f value: 4) = 5! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:09'!
testInterpolation2
	| Qx f |
	Qx _ QQ polynomials.
	f _ Qx interpolate: {1 -> 2. 2 -> 4. 3 -> 9}.
	self assert: (f value: 1) = 2.
	self assert: (f value: 2) = 4.
	self assert: (f value: 3) = 9! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 1/24/2017 12:45:48'!
testIsIrreducible
	"The polynomial x^4 + 1 is irreducible in Z[x] and Q[x], and it is reducible Z/p[x] for all prime numbers p."
	| p |
"	self assert: (ZZ polynomials !! [:x| x^4 + 1] :: isIrreducible).
	self assert: (QQ polynomials !! [:x| x^4 + 1] :: isIrreducible)."
	p _ 1000 atRandom nextPrime.
	self deny: (ZZ/p :: polynomials !! [:x| x^4 + 1] :: isIrreducible)! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 11/20/2016 15:21:25'!
testMultivariateDivision
	"Example from Cox IVA 62 p."
	| Zxy x y f f1 f2 division |
	Zxy _ ZZ polynomialsIn: #(x y) ordering: (MonomialOrdering lex: #(2 1)).
	x _ Zxy x.
	y _ Zxy y.
	f _ x*(y^2)+1.
	f1 _ x*y+1.
	f2 _ y+1.
	division _ f divideBy: {f1. f2}.
	self assert: division quotients = {y. y one negated}.
	self assert: division remainder = (y one * 2).
	self assert: division verify! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 11/20/2016 15:21:46'!
testMultivariateDivision2
	"Example from Cox IVA 63 p."
	| Zxy x y f f1 f2 division |
	Zxy _ ZZ polynomialsIn: #(x y) ordering: (MonomialOrdering lex: #(2 1)).
	x _ Zxy x.
	y _ Zxy y.
	f _ x^2*y + (x*(y^2)) + (y^2).
	f1 _ x*y-1.
	f2 _ y^2-1.
	division _ f divideBy: {f1. f2}.
	self assert: division quotients = {x+y. y one}.
	self assert: division remainder = (x+y+1).
	self assert: division verify! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 11/20/2016 15:22:04'!
testMultivariateDivision3
	"Example from Cox IVA 67 p."
	| Zxy x y f f1 f2 division |
	Zxy _ ZZ polynomialsIn: #(x y) ordering: (MonomialOrdering lex: #(2 1)).
	x _ Zxy x.
	y _ Zxy y.
	f _ x^2*y + (x*(y^2)) + (y^2).
	f1 _ x*y-1.
	f2 _ y^2-1.
	division _ f divideBy: {f2. f1}.
	self assert: division quotients = {x+1. x}.
	self assert: division remainder = (x*2+1).
	self assert: division verify! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:09'!
testMultivariateGCDBug
	| x |
	x _ QQ polynomialsIn: 3 :: x.
	self assert: (x^2 gcd: x) = x! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 11/25/2016 10:33:02'!
testPPRS
	"Example from Zippel."
	| a b pprs |
	a _ ZZ polynomials coefficients: #(1 0 1 0 -3 -3 8 2 -5) reversed.
	b _ ZZ polynomials coefficients: #(3 0 5 0 -4 -9 21) reversed.
	pprs _ a pprs: b :: collect: [:each| each coefficients reversed asArray] :: asArray.
	self assert: pprs = #((1 0 1 0 -3 -3 8 2 -5) 
		(3 0 5 0 -4 -9 21)
		(-5 0 1 0 -3)
		(13 25 -49)
		(4663 -6150)
		(1))! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:53'!
testPseudoDivision1
	| Zxy x y division |
	Zxy _ ZZ polynomialsIn: #(x y).
	x _ Zxy x.
	y _ Zxy y.
	division _ x^2 + (y^2) pseudoDivideBy: y - x in: 2.
	self assert: division quotient asMultivariate = (x + y).
	self assert: division remainder asMultivariate = (x^2 * 2).
	self assert: division verify! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:09'!
testPseudoDivision2
	| Zxy x y division |
	Zxy _ QQ polynomialsIn: #(x y).
	x _ Zxy x.
	y _ Zxy y.
	division _ x^2 + (y^2) pseudoDivideBy: (y-x)*2 in: 2.
	self assert: division quotient asMultivariate = ((x+y) * 2).
	self assert: division remainder asMultivariate = (x^2 * 8).
	self assert: division verify! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:53'!
testPseudoDivision3
	| Zxy x y division |
	Zxy _ ZZ polynomialsIn: #(x y).
	x _ Zxy x.
	y _ Zxy y.
	division _ x^2 + (y^2) pseudoDivideBy: y - x in: 2.
	self assert: division quotient asMultivariate = (x + y).
	self assert: division remainder asMultivariate = (x^2 * 2).
	self assert: division verify.

	division _ x^2 + (y^2) pseudoDivideBy: x - y in: 2.
	self assert: division quotient asMultivariate = (x + y) negated.
	self assert: division remainder asMultivariate = (x^2 * 2).
	self assert: division verify! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 7/4/2016 04:35'!
testPseudoDivision: R
	| Rx f g div |
	Rx _ R polynomials.
	f _ Rx atRandomBits: 100 maxDegree: 10 atRandom.
	[g _ Rx atRandomBits: 100 maxDegree: 10 atRandom. g isZero] whileTrue.
	div _ f pseudoDivideBy: g.
	self assert: div verify! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:53'!
testPseudoDivisionUnivariate
	| Zx x division |
	Zx _ ZZ polynomials.
	x _ Zx x.
	division _ x^3 + x + 1 pseudoDivideBy: (x^2 * 3) + x + 1.
	self assert: division quotient = (x*3 - 1).
	self assert: division remainder = (x*7 + 10).
	self assert: division delta = 2.
	self assert: division verify! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:53'!
testPseudoDivisionUnivariate2
	"Example from Zippel book"
	| Zx a b |
	Zx _ ZZ polynomials.
	a _ Zx coefficients: #(1 0 1 0 -3 -3 8 2 -5) reversed.
	b _ Zx coefficients: #(3 0 5 0 -4 -9 21) reversed.
	^ self assert: (a pseudoDivideBy: b) verify! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:53'!
testPseudoDivisionZ
	self testPseudoDivision: ZZ! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 12/2/2016 11:13:22'!
testPseudoDivisionZ6
	self testPseudoDivision: ZZ / 6! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:53'!
testPseudoRemainder
	| Zx x a b r |
	Zx _ ZZ polynomials.
	x _ Zx x.
	a _ x^8 + (x^6) - (3*(x^4)) - (3*(x^3)) + (8*(x^2)) + (2*x) - 5.
	b _ 3*(x^6) + (5*(x^4)) - (4*(x^2)) - (9*x) + 21.
	r _ Zx coefficients: #(-9 0 3 0 -15).
	self assert: (a pseudoRem: b) = r.
	self assert: (a pseudoDivideBy: b) remainder = r! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:10'!
testRationalRoots
	| x f roots |
	x _ QQ polynomials x.
	f _ (x-(1/2))^2*(x-2)*(x^2 + 1)*(x^2-2).
	roots _ f rootsIn: QQ.
	self assert: roots size = 3.
	self assert: (roots occurrencesOf: 1/2) = 2.
	self assert: (roots occurrencesOf: 2) = 1! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:10'!
testRationalRootsBug
	| x f roots |
	x _ QQ polynomials x.
	f _ x^3*-1 + (3*x) + 2.
	roots _ f roots.
	self assert: roots size = 3.
	self assert: (roots occurrencesOf: -1) = 2.
	self assert: (roots occurrencesOf: 2) = 1! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 12/18/2016 20:03:06'!
testRealRoots
	| R x f roots |
	R _ RealAlgebraicNumbersField new.
	x _ QQ polynomials x.
	f _ (x-(1/2))^2*(x-2)*(x^2 + 1)*(x^2-2).
	roots _ f rootsIn: R.
	self assert: roots size = 4.
	self assert: (roots occurrencesOf: 1/2) = 2.
	self assert: (roots occurrencesOf: 2) = 1! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 11/1/2016 04:46'!
testRemainderInconsistency
	"In Sage these two give the same result."
	| x x` |
	x _ ZZ polynomials x.
	x` _ QQ polynomials x.
	self assert: (x \\ (x negated + 1)) leadingCoefficient = (x` \\ (x` negated + 1)) leadingCoefficient! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:53'!
testResultant
	| Zx x f g f` g` h |
	Zx _ ZZ polynomials.
	x _ Zx x.
	f _ x^2 + x + 1.
	f` _ f * (x + 2).
	g _ x^3 + 1.
	g` _ g * (x + 2).
	h _ x^4 + 1.
	self assert: (f resultant: g) isZero not. "not 0 because f and g have no common roots"
	self assert: (f` resultant: g`) isZero. "res(f`,g`) = 0 because f` and g` have a common root -2."
	self assert: (-1)^(f degree * g degree) * (f resultant: g) = (g resultant: f).
	self assert: (f * g resultant: h) = ((f resultant: h) * (g resultant: h))! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:53'!
testResultant2
	| Zx x f g |
	Zx _ ZZ polynomials.
	x _ Zx x.
	f _ 2 * (x - 5) * (x - 11).
	g _ 3 * (x - 7).
	self assert: (f resultant: g) = ((2 ^ 1) * (3^2) * (5 - 7) * (11 - 7))! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 11/25/2016 10:32:56'!
testSPRS
	"Example from Zippel."
	| a b sprs |
	a _ ZZ polynomials coefficients: #(1 0 1 0 -3 -3 8 2 -5) reversed.
	b _ ZZ polynomials coefficients: #(3 0 5 0 -4 -9 21) reversed.
	sprs _ a sprs: b :: collect: [:each| each coefficients reversed asArray] :: asArray.
	self assert: sprs = #((1 0 1 0 -3 -3 8 2 -5)
		#(3 0 5 0 -4 -9 21)
		#(15 0 -3 0 9)
		#(65 125 -245)
		#(9326 -12300)
		#(260708))
! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:53'!
testShift
	| Zx x f |
	Zx _ ZZ polynomials.
	x _ Zx x.
	f _ Zx atRandomBits: 10.
	self assert: (f shift: 10) degree = (f degree + 10).
	self assert: ((f shift: 10) shift: -10) = f.
	self assert: f * (x^3) = (f shift: 3).
	self assert: (f * (x^3) shift: -3) = f! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:10'!
testSquareFree
	| P x f1 f2 f3 f |
	P _ QQ polynomials.
	x _ P x.
	f1 _ x^2 + x + 1.
	f2 _ 1 - x.
	f3 _ x - 2.
	f _ f1*f1*f2*f3*f3*f3.
	self assert: f squareFree = (f1 * f2 * f3)! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:10'!
testSquareFreeMultivariate
	| P x y f1 f2 f |
	P _ QQ polynomialsIn: #(x y).
	x _ P x.
	y _ P y.
	f1 _ x + 1.
	f2 _ y + 1.
	f _ f1*f1*f2*f2.
	self assert: f squareFree = (f1 * f2)! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:54'!
testSubresultant
	"deg(gcd(f,g)) = d iff subresultant(f,g,k) = 0 for all k < d and subresultant(f,g,d) ~= 0, and the d-th subresultant coefficient is in fact a gcd of f and g."
	| x f g |
	x _ ZZ polynomials x.
	f _ (x^4 - 1)*6.
	g _ (x^6 - 1)*9.
	"self assert: (f gcd: g) = ((x^2 - 1)*3)"
	self assert: (f subresultant: 0 with: g) isZero.
	self assert: (f subresultant: 1 with: g) isZero.
	self assert: (f subresultant: 2 with: g) isZero not.
	self assert: (f subresultant: 2 with: g) primitive = (x^2 - 1)! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:54'!
testSubresultant0
	| Zx x f g |
	Zx _ ZZ polynomials.
	x _ Zx x.
	f _ 2 * (x - 5) * (x - 11).
	g _ 3 * (x - 7).
	self assert: (f resultant: g) = (f subresultant: 0 with: g) asScalar! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:10'!
testUnivariateMultivariateConversion
	| Qx x y f |
	Qx _ QQ polynomialsIn: #(x y).
	x _ Qx x.
	y _ Qx y.
	f _ x^2*y.
	self assert: f asUnivariate asMultivariate = f.
"	self assert: (f asUnivariateIn: 1 :: asMultivariate) = f."
	self assert: (f asUnivariateIn: 2 :: asMultivariate) = f! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:10'!
testUnivariateMultivariateConversion2
	| Qx x y f f` x0 y0 |
	Qx _ QQ polynomialsIn: #(x y).
	x _ Qx x.
	y _ Qx y.
	f _ Qx zero.
	10 timesRepeat: [f _ f + (10 atRandom - 5 * (x ^ (3 atRandom - 1) * (y ^ (3 atRandom - 1))))].
	f` _ f asUnivariate.
	self assert: f` asMultivariate = f.
	x0 _ (-100 to: 100) atRandom.
	y0 _ (-100 to: 100) atRandom.
	self assert: ((f` value: y0) value: x0) = (f value: {x0. y0})! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:10'!
testZeroCoefficientBug
	| Qx |
	Qx _ QQ polynomials.
	self assert: (Qx one * 0) isZero! !

!ProjectiveGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 2/4/2017 09:01:51'!
testDesarguesTheorem
	"In a projective space of dimension >= 3, two triangles are in perspective axially iff they are in perspective centrally. In other words, given two triangles {a,b,c} and {A,B,C}, if the lines aA, bB and cC are concurrent (meet at a point), then the points AB /\ ab, AC /\ ac and BC /\ bc are collinear.
	
	Note that we use P(Q^3) which is a projective plane (dimension 2), but in this case the theorem is also valid. In general for dimension 2, the theorem is valid in any projective plane constructed from a 3-dimensional vector space over a skewfield, and these planes are called desarguesian planes."
	| P A B C a b c X Y Z |
	P _ QQ ^ 3 :: projectivized.
	A _ P atRandomBits: 100.
	B _ P atRandomBits: 100.
	C _ P atRandomBits: 100.
	a _ P atRandomBits: 100.
	b _ P atRandomBits: 100.
	c _ P atRandomBits: 100.
	
	X _ A+B • (a+b).
	Y _ A+C • (a+c).
	Z _ B+C • (b+c).
	"aA,bB,cC are not concurrent:"
	self deny: (a+A • (b+B) • (c+C)) isPoint.
	"X,Y,Z are not collinear:"
	self deny: (X+Y+Z) isLine.

	"make the lines concurrent:"
	C _ a+A • (b+B).
	"p1 _ A+B /\ (a+b)."
	Y _ A+C • (a+c).
	Z _ B+C • (b+c).
	"aA,bB,cC are concurrent:"
	self assert: (a+A • (b+B) • (c+C)) isPoint.
	"X,Y,Z are collinear"
	self assert: (X+Y+Z) isLine! !

!ProjectiveGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 10/31/2016 13:13'!
testHomogeneousTuples
	self assert: (1,2,3) asHomogeneousTuple = (2,4,6) asHomogeneousTuple.
	self assert: (1,2,3) asHomogeneousTuple ~= (-2,4,6) asHomogeneousTuple! !

!ProjectiveGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 2/4/2017 09:01:57'!
testPappusHexagonTheorem
	"Given a set of collinear points {A,B,C} and another set of collinear points {a,b,c}, then the intersection points X,Y,Z of line pairs Ab and aB, Ac and aC, Bc and bC are collinear.
	The theorem is true in any projective plane over any field, but fails for projective planes over any skewfield (non-commutative division ring). The projective planes in which the theorem is valid are called pappian planes."
	| P A B C a b c X Y Z |
	P _ QQ ^ 3 :: projectivized.
	A _ P atRandomBits: 100.
	B _ P atRandomBits: 100.
	C _ A+B :: atRandomBits: 100.
	a _ P atRandomBits: 100.
	b _ P atRandomBits: 100.
	c _ a+b :: atRandomBits: 100.
	
	X _ A+b • (a+B).
	Y _ A+c • (a+C).
	Z _ B+c • (b+C).

	"A,B,C are collinear:"
	self assert: (A+B+C) isLine.
	"a,b,c are collinear:"
	self assert: (a+b+c) isLine.
	"X,Y,Z are collinear:"
	self assert: (X+Y+Z) isLine! !

!ProjectiveGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 2/4/2017 09:02:03'!
testProjectiveSpaceBasic
	| V P p0 p1 p2 p3 |
	V _ QQ ^ 3.
	P _ V projectivized.
	p0 _ P project: (1,1,0).
	p1 _ P project: (0,1,1).
	p2 _ P project: (2,0,2).
	p3 _ P pointAt: (-1,-1,0) asHomogeneousTuple.
	self assert: (P coordinatesOf: p2) = (1,0,1) asHomogeneousTuple.
	self assert: p3 = p0.
	self assert: (p0 + p1) dimension = 1! !

!RingTest methodsFor: 'as yet unclassified' stamp: 'len 12/2/2016 11:13:56'!
newQuotientRing
	| R I |
	2 atRandom = 1 ifTrue: [^ ZZ / (2 to: 10) atRandom].
	R _ ZZ polynomials.
	I _ R * (R atRandomBits: 10 maxDegree: 5).
	^ R / I! !

!RingTest methodsFor: 'as yet unclassified' stamp: 'len 12/2/2016 11:14:00'!
newRing
	2 atRandom = 1 ifTrue: [^ {ZZ. QQ. ZZ / (2 to: 10) atRandom} atRandom polynomialsIn: (1 to: 3) atRandom].
	2 atRandom = 1 ifTrue: [^ self newQuotientRing].
	^ ZZ! !

!RingTest methodsFor: 'as yet unclassified' stamp: 'len 11/2/2016 08:18'!
testCanonicalMorphisms
	| R x Q |
	R _ QQ polynomials.
	x _ R x.
	Q _ R / (x^2 + 1).
	self assert: (ZZ  R value: 4) = (R embed: 4). "canonical morphism from initial object"
	self assert: (R  Q value: x^2 + 2) = Q one. "canonical morphism to quotient object"! !

!RingTest methodsFor: 'as yet unclassified' stamp: 'len 10/10/2016 09:58'!
testDirectProduct
	| R S P |
	R _ self newRing.
	S _ self newRing.
	P _ R × S.
	self testRing: P.
	self testRingHomomorphism: (P projection: 2 atRandom)! !

!RingTest methodsFor: 'as yet unclassified' stamp: 'len 10/20/2016 06:06'!
testKrullDimension
	| R I |
	self assert: ZZ dimension = 1.
	self assert: QQ dimension = 0.
	self assert: (ZZ polynomialsIn: 2) dimension = 3.
	R _ QQ polynomialsIn: #(x y).
	I _ R * {R x ^ 2 + (R y ^ 2) - 1}.
	self assert: (R / I) dimension = 1! !

!RingTest methodsFor: 'as yet unclassified' stamp: 'len 10/29/2016 11:17'!
testLocalizationInclusions
	| Z2 Z3 Z6 |
	Z2 _ ZZ localization: 2.
	Z3 _ ZZ localization: 3.
	Z6 _ ZZ localization: 6.
	self assert: Z6 >= Z2.
	self assert: Z6 >= Z3.
	self deny: Z3 >= Z2.
	self deny: Z2 >= Z3.
	self deny: Z2 >= Z6! !

!RingTest methodsFor: 'as yet unclassified' stamp: 'len 10/29/2016 11:20'!
testLocalizationMaximalIdeal
	| Z2 |
	Z2 _ ZZ localization: 2.
	self assert: Z2 maximalIdeal = (Z2 * 2)! !

!RingTest methodsFor: 'as yet unclassified' stamp: 'len 10/29/2016 10:57'!
testLocalizationOfZAwayFrom2
	| L |
	L _ ZZ localization: 2.
	self assert: (L includes: 1/3).
	self assert: (L includes: 3/2) not.
	self assert: (L atRandomBits: 10) denominator odd! !

!RingTest methodsFor: 'as yet unclassified' stamp: 'len 10/6/2016 20:34'!
testMatrixRing
	self testRing: (ZZ ^ (5@5)) asRing! !

!RingTest methodsFor: 'as yet unclassified' stamp: 'len 12/2/2016 11:14:10'!
testModularIntegers
	| Zm |
	Zm _ ZZ / (10 atRandom + 1).
	self testRing: Zm.
	self testRingHomomorphism: Zm projection! !

!RingTest methodsFor: 'as yet unclassified' stamp: 'len 10/7/2016 06:13'!
testMultivariatePolynomialRing
	| R |
	R _ ZZ polynomialsIn: #(x y z).
	self testRing: R.
	self testRingHomomorphism: R embedding! !

!RingTest methodsFor: 'as yet unclassified' stamp: 'len 10/7/2016 06:14'!
testPolynomialRing
	| R |
	R _ ZZ polynomials.
	self testRing: R.
	self testRingHomomorphism: R embedding! !

!RingTest methodsFor: 'as yet unclassified' stamp: 'len 10/6/2016 20:32'!
testQuotientRing
	| Q |
	Q _ self newQuotientRing.
	self testRing: Q.
	self testRingHomomorphism: Q projection! !

!RingTest methodsFor: 'as yet unclassified' stamp: 'len 11/1/2016 01:00'!
testQuotientRing2
	| Q pi f g |
	Q _ self newQuotientRing.
	f _ Q base atRandomBits: 10.
	g _ Q ideal atRandomBits: 10.
	pi _ Q projection.
	self assert: (pi value: g) isZero.
	self assert: (Q includes: (pi value: f)).
	self testRingHomomorphism: pi.
"	self assert: (pi value: f) = (pi value: f + g)."
"	h _ Q atRandomBits: 100.
	self assert: (pi value: (pi section value: h)) = h"! !

!RingTest methodsFor: 'as yet unclassified' stamp: 'len 10/6/2016 20:30'!
testRing: R
	| one zero a b c |
	one _ R one.
	zero _ R zero.
	a _ R atRandomBits: 100.
	b _ R atRandomBits: 100.
	c _ R atRandomBits: 100.
	self assert: a * one = a.
	self assert: one * a = a.
	self assert: zero * a = zero.
	self assert: a * zero = zero.
	self assert: zero + a = a.
	self assert: a + zero = a.
	self assert: a + b = (b + a). "commutativity of addition"
	self assert: (a + b + c) = (a + (b + c)). "associativity of addition"
	self assert: (a * b * c) = (a * (b * c)). "associativity of multiplication"
	R isCommutative ifTrue: [self assert: a * b = (b * a)]. "commutativity of multiplication"! !

!RingTest methodsFor: 'as yet unclassified' stamp: 'len 11/1/2016 00:59'!
testRingHomomorphism: phi
	| R S a b |
	R _ phi domain.
	S _ phi codomain.
	a _ R atRandomBits: 10.
	b _ R atRandomBits: 10.
	self assert: (phi value: R zero) = S zero.
	self assert: (phi value: R one) = S one.
	self assert: (phi value: a + b) = ((phi value: a) + (phi value: b)).
	self assert: (phi value: a * b) = ((phi value: a) * (phi value: b))! !

!RingTest methodsFor: 'as yet unclassified' stamp: 'len 10/6/2016 20:27'!
testZZ
	self testRing: ZZ! !

!RootSystemTest methodsFor: 'as yet unclassified' stamp: 'len 7/15/2016 18:37'!
rootSystem1
	| V roots |
	V _ QQ ^ 3.
	roots _ Set new.
	1 to: 3 do: [:i| 1 to: i-1 do: [:j| |r| roots add: (r _ (V e: i) - (V e: j)); add: r negated]].
	^ RootSystem on: V roots: roots! !

!RootSystemTest methodsFor: 'as yet unclassified' stamp: 'len 7/15/2016 18:37'!
rootSystem2
	| V roots |
	V _ QQ ^ 3.
	roots _ Set new.
	1 to: 3 do: [:i|
		1 to: i-1 do: [:j|
			roots
				add: (V e: i) - (V e: j);
				add: (V e: j) - (V e: i);
				add: (V e: i) + (V e: j);
				add: ((V e: i) + (V e: j)) negated]].
	^ RootSystem on: V roots: roots! !

!RootSystemTest methodsFor: 'as yet unclassified' stamp: 'len 2/23/2016 07:26'!
testBaseSignCondition
	| R |
	R _ self rootSystem1.
	R roots do: [:each| | coordinates |
		coordinates _ R simpleRoots coordinatesOf: each :: asArray.
		self assert: (coordinates allSatisfy: [:xi| xi >= 0]) | (coordinates allSatisfy: [:xi| xi <= 0])]! !

!RootSystemTest methodsFor: 'as yet unclassified' stamp: 'len 6/25/2016 23:09'!
testPositiveRoots
	| V R |
	R _ self rootSystem1.
	V _ R ambient.
	R positiveRoots do: [:each|
		self assert: (V innerProduct value: {each. (1,1,1)}) > 0] "the point must be in the positive Weyl chamber"! !

!RootSystemTest methodsFor: 'as yet unclassified' stamp: 'len 2/11/2016 01:39'!
testWeylGroup
	| R W |
	R _ self rootSystem1.
	W _ R weylGroup.
	"The Weyl group of this root system is isomorphic to Sym(3), so we test some properties of Sym(3):"
	self assert: W order = 6.
	self assert: W center isTrivial.
	self assert: W isSolvable.
	self assert: W isCyclic not! !

!RootSystemTest methodsFor: 'as yet unclassified' stamp: 'len 2/10/2016 22:43'!
testWeylGroup2
	| R W |
	R _ self rootSystem2.
	W _ R weylGroup. "this is an index 2 subgroup of the hyperoctahedral group"
	self assert: W order = 24! !

!RootSystemTest methodsFor: 'as yet unclassified' stamp: 'len 2/10/2016 22:56'!
testWeylGroupAndSimpleRoots
	"For every root, there exists an transformation in the Weyl group that makes it a simple root."
	| R W |
	R _ self rootSystem1.
	W _ R weylGroup.
	R roots do: [:r| self assert: (W anySatisfy: [:w| R simpleRoots includes: (w value: r)])]! !

!SequenceTest methodsFor: 'as yet unclassified' stamp: 'len 8/6/2016 00:54'!
testBellNumbers
	self assert: (Sequence bellNumbers beginsWith: #(1 2 5 15 52 203 877)).
	"The binomial transform is the shift operator for the Bell numbers:"
	self assert: (Sequence bellNumbers binomialTransform2 beginsWith: #(2 5 15 52 203 877)).! !

!SequenceTest methodsFor: 'as yet unclassified' stamp: 'len 12/5/2015 01:13'!
testDirichletConvolution
	self assert: ((Sequence phi dirichlet: Sequence one) beginsWith: #(1 2 3 4 5)).
	self assert: ((Sequence moebius dirichlet: Sequence one) beginsWith: #(1 0 0 0 0))! !

!SequenceTest methodsFor: 'as yet unclassified' stamp: 'len 10/31/2016 04:14'!
testLinearRecursiveSequenceBug
	| F |
	F _ CFiniteSequence fibonacci.
	self assert: ((F - F) at: 1) = 0! !

!SequenceTest methodsFor: 'as yet unclassified' stamp: 'len 12/28/2015 05:56'!
testPowerSeries
	| cos sin |
	sin _ PowerSeries sin.
	cos _ PowerSeries cos.
	self assert: ((cos squared + sin squared) coefficients beginsWith: #(1 0 0 0 0 0 0 0 0))! !

!SequenceTest methodsFor: 'as yet unclassified' stamp: 'len 11/25/2016 10:32:36'!
testRecursive
	| f g |
	f _ Sequence fibonacci.
	g _ CFiniteSequence to: ZZ evaluating: f maxOrder: 5.
	self assert: (f equals: g upTo: 20).
	self assert: g order = 2.
	self assert: g characteristicPolynomial coefficients asArray = #(-1 -1 1)! !

!SequenceTest methodsFor: 'as yet unclassified' stamp: 'len 10/31/2016 04:13'!
testRecursive2
	| a b c |
	a _ CFiniteSequence fibonacci.
	b _ CFiniteSequence lucasNumbers.
	c _ a + (b*2) - (b+b).
	self assert: a = c! !

!SequenceTest methodsFor: 'as yet unclassified' stamp: 'len 10/31/2016 04:13'!
testRecursiveConvolution
	| a b c a` b` c` |
	a _ CFiniteSequence fibonacci.
	b _ CFiniteSequence lucasNumbers.
	a` _ Sequence evaluating: [:i| a at: i].
	b` _ Sequence evaluating: [:i| b at: i].

	c _ a convolution: b.
	c` _ a` convolution: b`.
	
	self assert: (c equals: c` upTo: 20)! !

!SequenceTest methodsFor: 'as yet unclassified' stamp: 'len 10/31/2016 04:14'!
testRecursiveEquals
	| a b c |
	a _ CFiniteSequence fibonacci.
	b _ CFiniteSequence to: ZZ evaluating: [:i| a at: i] maxOrder: 10.
	c _ CFiniteSequence lucasNumbers.
	self assert: a = b.
	self assert: a ~= c! !

!SequenceTest methodsFor: 'as yet unclassified' stamp: 'len 10/31/2016 04:13'!
testRecursiveIndefiniteSumation
	| a c a` c` |
	a _ CFiniteSequence fibonacci.
	a` _ Sequence evaluating: [:i| a at: i].

	c _ a sum.
	c` _ a` sum.
	self assert: (c isKindOf: CFiniteSequence).
	self assert: (c equals: c` upTo: 20)! !

!SequenceTest methodsFor: 'as yet unclassified' stamp: 'len 10/31/2016 04:13'!
testRecursiveMinimal
	| a f |
	a _ CFiniteSequence initialValues: #(0 1 1) coefficients: #(0 1 1).
	f _ CFiniteSequence fibonacci.
	self assert: a isMinimal not.
	self assert: a order = 3.
	self assert: a minimal order = 2.
	self assert: a minimalPolynomial = f characteristicPolynomial! !

!SequenceTest methodsFor: 'as yet unclassified' stamp: 'len 10/31/2016 04:13'!
testRecursiveProduct
	| a b c c` |
	a _ CFiniteSequence fibonacci.
	b _ CFiniteSequence pellNumbers.
	c _ a * b.
	c` _ Sequence evaluating: [:i| (a at: i) * (b at: i)].
	self assert: (c isKindOf: CFiniteSequence).
	self assert: (c equals: c` upTo: 20).
	self assert: c order = 4! !

!SequenceTest methodsFor: 'as yet unclassified' stamp: 'len 10/31/2016 04:13'!
testRecursiveScalarMultiplication
	| a c a` c` |
	a _ CFiniteSequence fibonacci.
	a` _ Sequence evaluating: [:i| a at: i].

	c _ a * 7.
	c` _ a` * 7.
	self assert: (c isKindOf: CFiniteSequence).
	self assert: (c equals: c` upTo: 20)! !

!SequenceTest methodsFor: 'as yet unclassified' stamp: 'len 10/31/2016 04:13'!
testRecursiveShiftLeft
	| a c a` c` |
	a _ CFiniteSequence fibonacci.
	a` _ Sequence evaluating: [:i| a at: i].

	c _ a << 5.
	c` _ a` << 5.
	self assert: (c isKindOf: CFiniteSequence).
	self assert: (c equals: c` upTo: 20)! !

!SequenceTest methodsFor: 'as yet unclassified' stamp: 'len 10/31/2016 04:14'!
testRecursiveSum
	| a b c c` |
	a _ CFiniteSequence fibonacci.
	b _ CFiniteSequence lucasNumbers.
	c _ a + b.
	c` _ Sequence evaluating: [:i| (a at: i) + (b at: i)].
	self assert: (c isKindOf: CFiniteSequence).
	self assert: (c equals: c` upTo: 20)! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 2/14/2017 20:15:10'!
test3Sphere
	| X |
	X _ SimplicialComplex sphere: 3.
	self assert: X dimension = 2.
	self assert: X fVector = (1,4,6,4)! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 2/14/2017 20:14:33'!
test6Sphere
	| X |
	X _ SimplicialComplex sphere: 6.
	self assert: X dimension = 5.
	self assert: X fVector = (1,7,21,35,35,21,7)! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 2/14/2017 20:12:39'!
testEulerCharacteristic
	| X |
	X _ SimplicialComplex torus.
	self assert: X euler = 0.
	X _ SimplicialComplex sphere: 3.
	self assert: X euler = 2.
	X _ SimplicialComplex kleinBottle.
	self assert: X euler = 0.
	X _ SimplicialComplex realProjectivePlane.
	self assert: X euler = 1! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 2/14/2017 19:00:06'!
testSimplecialComplex
	| S |
	S _ SimplicialComplex facets: {{1. 2. 3}. {2. 4}. {3. 4}. {5}}.
	self assert: (S faces: 2) asSet size = 1.
	self assert: (S faces: 1) asSet size = 5.
	self assert: (S faces: 0) asSet size = 5! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 6/18/2016 17:16'!
testSimplex
	| tetrahedron |
	tetrahedron _ Simplex points: {(1,0,0). (0,1,0). (0,0,1). (0,0,0)}.
	self assert: tetrahedron dimension = 3.
	self assert: (tetrahedron faces: 2) size = 4.
	self assert: tetrahedron edges size = 6.
	self assert: (tetrahedron faces: 3) size = 1! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 6/12/2016 21:09'!
testSimplexBoundaryBoundary
	| S |
	S _ Simplex points: #(a b c d).
	self assert: S boundary boundary isZero! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 6/12/2016 21:12'!
testSimplexInclusion
	| S S` |
	S _ Simplex new: (2 to: 10) atRandom.
	S` _ Simplex new: (0 to: S dimension) atRandom.
	self assert: S` <= S! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 6/12/2016 21:09'!
testSimplexNegation
	| S |
	S _ Simplex points: {1. 2. 3. 4}.
	self assert: S negated negated = S.
	self assert: S negated ~= S! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 2/14/2017 19:45:41'!
testTorus
	| X |
	X _ SimplicialComplex torus.
	self assert: X dimension = 2.
	self assert: X fVector = (1,7,21,14)! !

!TupleTest methodsFor: 'as yet unclassified' stamp: 'len 11/6/2016 11:35'!
testBitTupleBug
	| Z2 |
	Z2 _ PrimeField new: 2.
	self assert: ((1,0,0) % 2 :: sum = Z2 one).
	self assert: ((0,1,0) % 2 :: sum = Z2 one).
	self assert: ((1,1,0) % 2 :: sum = Z2 zero).
	self assert: ((1,1,1) % 2 :: sum = Z2 one)! !

!TupleTest methodsFor: 'as yet unclassified' stamp: 'len 11/12/2016 08:48'!
testBitTupleOperations
	| n a b |
	n _ 120 atRandom.
	a _ ZZ^n atRandomBits: n*2.
	b _ ZZ^n atRandomBits: n*2.
	#(+ - convolution: dot: hadamard:) do: [:op|
		self testTuple: a with: b operation: op modulo: 2].
	#(negated reversed copy sum product) do: [:op|
		self testTuple: a operation: op modulo: 2]! !

!TupleTest methodsFor: 'as yet unclassified' stamp: 'len 11/6/2016 11:35'!
testBitTupleReversed
	| v i |
	v _ ZZ / 2 ^ 100 atRandom :: atRandom.
	i _ v size atRandom.
	self assert: (v reversed at: i) = (v at: v size - i + 1).
	self assert: v reversed reversed = v! !

!TupleTest methodsFor: 'as yet unclassified' stamp: 'len 11/6/2016 11:36'!
testBitTupleSum
	self assert: (BitTuple fromInteger: 2r1011101) sum representative = 1.
	self assert: (BitTuple fromInteger: 2r10000100100010) sum representative = 0! !

!TupleTest methodsFor: 'as yet unclassified' stamp: 'len 11/6/2016 11:31'!
testMakeZero: aTuple
	self assert: (aTuple * 0) isZero.
	self assert: (0 * aTuple) isZero.
	self assert: (aTuple + aTuple negated) isZero.
	self assert: (aTuple - aTuple) isZero! !

!TupleTest methodsFor: 'as yet unclassified' stamp: 'len 11/6/2016 11:39'!
testModTupleConcatenation
	self assert: (1,2,3) % 7, ((2,3,4) % 7) = ((1,2,3,2,3,4) % 7)! !

!TupleTest methodsFor: 'as yet unclassified' stamp: 'len 11/6/2016 13:49'!
testModTupleConvolution
	| a b |
	a _ (1,2,3).
	b _ (2,3,4).
	self assert: (a % 7 convolution: b % 7) = ((a convolution: b) % 7)! !

!TupleTest methodsFor: 'as yet unclassified' stamp: 'len 11/12/2016 08:48'!
testModTupleOperations
	| a b modulus |
	modulus _ 10 atRandom + 1.
	a _ ZZ^5 atRandomBits: 30.
	b _ ZZ^5 atRandomBits: 30.
	#(+ - convolution: dot: hadamard:) do: [:op|
		self testTuple: a with: b operation: op modulo: modulus].
	#(negated reversed copy sum product) do: [:op|
		self testTuple: a operation: op modulo: modulus].! !

!TupleTest methodsFor: 'as yet unclassified' stamp: 'len 11/6/2016 11:38'!
testModTupleSum
	| a b |
	a _ ZZ tuple: ((1 to: 10) collect: [:i| 100 atRandom]).
	b _ a % 7.
	self assert: b sum = (a sum % 7)! !

!TupleTest methodsFor: 'as yet unclassified' stamp: 'len 11/6/2016 14:24'!
testTuple: a operation: aSymbol modulo: modulus
	self assert: (a perform: aSymbol) % modulus = (a % modulus perform: aSymbol)! !

!TupleTest methodsFor: 'as yet unclassified' stamp: 'len 11/6/2016 14:12'!
testTuple: a with: b operation: aSymbol modulo: modulus
	self assert: (a perform: aSymbol with: b) % modulus = (a % modulus perform: aSymbol with: b % modulus)! !

!TupleTest methodsFor: 'as yet unclassified' stamp: 'len 11/6/2016 11:36'!
testTupleSum
	self assert: (1,2,3) sum = (1 + 2 + 3)! !

!Benchmark methodsFor: 'as yet unclassified' stamp: 'len 3/1/2016 04:20'!
run
	| output |
	output _ WriteStream on: (String new: 1000).
	(self class selectors asArray select: [:each|
		(each beginsWith: 'test') and: [each numArgs isZero]]) sort
		do: [:each|
			output nextPutAll: each; tab.
			self setUp.
			Smalltalk garbageCollect.
			[output nextPutAll: [self perform: each] bench] on: Error do: [output nextPutAll: 'FAILED'].
			self tearDown]
		separatedBy: [output newLine].
	^ output contents! !

!Benchmark methodsFor: 'as yet unclassified' stamp: 'len 3/1/2016 04:16'!
setUp
	^ self! !

!Benchmark methodsFor: 'as yet unclassified' stamp: 'len 3/1/2016 04:16'!
tearDown
	^ self! !

!GroebnerBasisBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/17/2016 16:44:50'!
binaryCyclic: n
	^ self cyclic: n over: (PrimeField new: 2)! !

!GroebnerBasisBenchmark methodsFor: 'as yet unclassified' stamp: 'len 7/15/2016 18:31'!
cyclic: n
	^ self cyclic: n over: QQ! !

!GroebnerBasisBenchmark methodsFor: 'as yet unclassified' stamp: 'len 7/4/2016 08:36'!
cyclic: n over: scalars
	| P singles generators |
	P _ scalars polynomialsIn: n.
	singles _ (1 to: n) collect: [:i| P x: i].
	generators _ OrderedCollection new.
	1 to: n-1 do: [:k | | f |
		f _ P zero.
		singles combinations: k atATimeDo: [:each| f _ f + each product].
		generators add: f].
	generators add: singles product - 1.
	^ P * generators! !

!GroebnerBasisBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/18/2016 09:37:11'!
katsura2
	^ self katsura2Over: QQ! !

!GroebnerBasisBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/18/2016 09:35:30'!
katsura2Over: aField
	| P x y |
	P _ aField polynomialsIn: #(x y).
	x _ P x.
	y _ P y.
	^ P * {x + (y*2) - 1. x^2 + (y^2 * 2) - x}! !

!GroebnerBasisBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/18/2016 09:37:02'!
katsura3
	^ self katsura3Over: QQ! !

!GroebnerBasisBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/18/2016 09:35:43'!
katsura3Over: aField
	| P x y z |
	P _ aField polynomialsIn: #(x y z).
	x _ P x: #x.
	y _ P x: #y.
	z _ P x: #z.
	^ P * {x + (y*2) + (z*2) - 1. x^2 + (y^2 * 2) + (z^2 * 2) - x. x*y*2 + (y*z*2) - y}! !

!GroebnerBasisBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/18/2016 09:36:51'!
katsura4
	^ self katsura4Over: QQ! !

!GroebnerBasisBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/18/2016 09:35:54'!
katsura4Over: aField
	| P x y z t |
	P _ aField polynomialsIn: #(x y z t).
	x _ P x: #x.
	y _ P x: #y.
	z _ P x: #z.
	t _ P x: #t.
	^ P * {x + (y*2) + (z*2) + (t*2) - 1.
		x^2 + (y^2 * 2) + (z^2 * 2) + (t^2 * 2) - x.
		x*y*2 + (y*z*2) + (z*t*2) - y.
		y^2 + (x*z*2) + (y*t*2) - z}! !

!GroebnerBasisBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/18/2016 09:36:41'!
katsura5
	^ self katsura5Over: QQ! !

!GroebnerBasisBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/18/2016 09:36:02'!
katsura5Over: aField
	| P x y z t u |
	P _ aField polynomialsIn: #(x y z t u).
	x _ P x: #x.
	y _ P x: #y.
	z _ P x: #z.
	t _ P x: #t.
	u _ P x: #u.
	^ P * {x + (y*2) + (z*2) + (t*2) + (u*2) - 1.
		x^2 + (y^2 * 2) + (z^2 * 2) + (t^2 * 2) + (u^2 * 2) - x.
		x*y*2 + (y*z*2) + (z*t*2) + (t*u*2) - y.
		y^2 + (x*z*2) + (y*t*2) + (z*u*2) - z.
		y*z*2 + (x*t*2) + (y*u*2) - t}! !

!GroebnerBasisBenchmark methodsFor: 'as yet unclassified' stamp: 'len 12/1/2016 18:36:52'!
modularCyclic: n
	^ self cyclic: n over: (PrimeField new: 32003)! !

!GroebnerBasisBenchmark methodsFor: 'as yet unclassified' stamp: 'len 12/1/2016 18:36:57'!
modularKatsura2
	^ self katsura2Over: (PrimeField new: 32003)! !

!GroebnerBasisBenchmark methodsFor: 'as yet unclassified' stamp: 'len 12/1/2016 18:37:02'!
modularKatsura3
	^ self katsura3Over: (PrimeField new: 32003)! !

!GroebnerBasisBenchmark methodsFor: 'as yet unclassified' stamp: 'len 12/1/2016 18:37:06'!
modularKatsura4
	^ self katsura4Over: (PrimeField new: 32003)! !

!GroebnerBasisBenchmark methodsFor: 'as yet unclassified' stamp: 'len 7/4/2016 06:32'!
testCyclic3
	self cyclic: 3 :: groebnerBasis! !

!GroebnerBasisBenchmark methodsFor: 'as yet unclassified' stamp: 'len 7/5/2016 17:02'!
testCyclic4
	^ self cyclic: 4 :: groebnerBasis! !

!GroebnerBasisBenchmark methodsFor: 'as yet unclassified' stamp: 'len 7/4/2016 07:25'!
testCyclic5
	self cyclic: 5 :: groebnerBasis! !

!GroebnerBasisBenchmark methodsFor: 'as yet unclassified' stamp: 'len 7/7/2016 23:27'!
testCyclic6
	self cyclic: 6 :: groebnerBasis! !

!GroebnerBasisBenchmark methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:43'!
testEliminationExample
	| Qx x y z I |
	Qx _ QQ polynomialsIn: #(x y z).
	x _ Qx x. y _ Qx y. z _ Qx z.
	I _ Qx * {x^2 + y + z - 1. x + (y^2) + z - 1. x + y + (z^2) - 1}.
	I eliminateAll: #(1 2)! !

!GroebnerBasisBenchmark methodsFor: 'as yet unclassified' stamp: 'len 7/4/2016 06:33'!
testKatsura2
	self katsura2 :: groebnerBasis! !

!GroebnerBasisBenchmark methodsFor: 'as yet unclassified' stamp: 'len 7/4/2016 06:33'!
testKatsura3
	self katsura3 :: groebnerBasis! !

!GroebnerBasisBenchmark methodsFor: 'as yet unclassified' stamp: 'len 7/7/2016 23:26'!
testKatsura4
	self katsura4 :: groebnerBasis! !

!GroebnerBasisBenchmark methodsFor: 'as yet unclassified' stamp: 'len 7/4/2016 08:37'!
testModularCyclic3
	self modularCyclic: 3 :: groebnerBasis! !

!GroebnerBasisBenchmark methodsFor: 'as yet unclassified' stamp: 'len 7/4/2016 08:40'!
testModularKatsura2
	self modularKatsura2 :: groebnerBasis! !

!GroebnerBasisBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/18/2016 09:37:58'!
testModularKatsura3
	self modularKatsura3 :: groebnerBasis! !

!GroebnerBasisBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/18/2016 09:38:01'!
testModularKatsura4
	self modularKatsura4 :: groebnerBasis! !

!GroupBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/15/2016 06:42'!
testJ1Order
	PermutationGroup J1 size! !

!GroupBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/15/2016 06:43'!
testM12Order
	PermutationGroup M12 size! !

!IntegersBenchmark methodsFor: 'as yet unclassified' stamp: 'len 7/3/2016 04:28'!
test1000Factorial
	1000 factorial! !

!ModularMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 12/1/2016 18:30:09'!
setUp
	| random F |
	random _ Random seed: 1234.
	F _ ZZ/32003.
"	F _ SmallPrimeField new: 32003."
	matrix _ F matrix: 300@300 evaluating: [:i :j| F atRandom: random]! !

!ModularMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/22/2016 11:55:20'!
testAddition
	matrix + matrix! !

!ModularMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/17/2016 15:35:23'!
testGaussianElimination
	matrix reducer reduced! !

!ModularMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/22/2016 11:54:33'!
testSquared
	matrix squared! !

!ModularMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/22/2016 11:55:03'!
testTransposition
	matrix transposed! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 12/16/2016 13:36:15'!
testFiniteField
	"Benchmark Polynomial>>#= and Residue#>>="
	| F |
	F _ GaloisField new: 9.
	((F^3) upTo: 9^3) asSet size = (9^3) ifFalse: [self halt]! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 12/2/2016 11:17:35'!
testFiniteFieldPolynomialFactorization
	| F Fx x one f |
	F _ ZZ / 3.
	Fx _ F polynomials.
	x _ Fx x.
	one _ Fx one.
	f _ x^11 + (x^9 * 2) + (x^8 * 2) + (x^6) + (x^5) + (x^3 * 2) + (x^2 * 2) + one.
	20 timesRepeat: [f factorizer factors]! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:49'!
testMultivariatePolynomialAdditionOverZ
	| P f g |
	P _ ZZ polynomialsIn: #(x y z).
	f _ P atRandomBits: 100 maxDegree: 50.
	g _ P atRandomBits: 100 maxDegree: 50.
	10000 timesRepeat: [f + g]! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:49'!
testPolynomialAdditionOverZ
	| P f g |
	P _ ZZ polynomials.
	f _ P atRandomBits: 100 maxDegree: 50.
	g _ P atRandomBits: 100 maxDegree: 50.
	10000 timesRepeat: [f + g]! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 12/2/2016 11:17:31'!
testPolynomialAdditionOverZ2
	| P f g |
	P _ ZZ / 2 :: polynomials.
	f _ P atRandomDegree: 50.
	g _ P atRandomDegree: 50.
	10000 timesRepeat: [f + g]! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:08'!
testPolynomialDivisionOverQ
	| P x f g |
	P _ QQ polynomials.
	x _ P x.
	f _ x^2 + x + 1 ^ 10.
	g _ 1 - x ^ 10.
	2000 timesRepeat: [f // g. f \\ g]! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:49'!
testPolynomialDivisionOverZ
	| P x f g |
	P _ ZZ polynomials.
	x _ P x.
	f _ x^2 + x + 1 ^ 10.
	g _ 1 - x ^ 10.
	2000 timesRepeat: [f // g. f \\ g]! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:08'!
testPolynomialGCDOverQ
	| P x f g |
	P _ QQ polynomials.
	x _ P x.
	f _ x^4 - 1 ^ 5.
	g _ x^6 - 1 ^ 5.
	2000 timesRepeat: [f gcd: g]! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:49'!
testPolynomialGCDOverZ
	| P x f g |
	P _ ZZ polynomials.
	x _ P x.
	f _ x^4 - 1 ^ 5.
	g _ x^6 - 1 ^ 5.
	2000 timesRepeat: [f gcd: g]! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 12/2/2016 11:17:28'!
testPolynomialGCDOverZ2
	| P x f g |
	P _ ZZ / 2 :: polynomials.
	x _ P x.
	f _ x^4 - 1 ^ 5.
	g _ x^6 - 1 ^ 5.
	2000 timesRepeat: [f gcd: g]! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:49'!
testPolynomialMultiplication2OverZ
	| P f g |
	P _ ZZ polynomials.
	f _ P atRandomBits: 100 maxDegree: 50.
	g _ P atRandomBits: 100 maxDegree: 50.
	100 timesRepeat: [f * g]! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 10/18/2016 21:00'!
testPolynomialMultiplication2OverZ2
	| P f g |
	P _ PrimeField new: 2 :: polynomials.
	f _ P atRandomBits: 100 maxDegree: 50.
	g _ P atRandomBits: 100 maxDegree: 50.
	100 timesRepeat: [f * g]! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:08'!
testPolynomialMultiplicationOverZ
	| P x f |
	P _ QQ polynomials.
	x _ P x.
	f _ x - 1.
	1 to: 9 do: [:i| f _ x - i * f * f]! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 10/18/2016 21:01'!
testPolynomialMultiplicationOverZ2
	| P x f |
	P _ PrimeField new: 2 :: polynomials.
	x _ P x.
	f _ x - (1 % 2).
	1 to: 9 do: [:i| f _ x - (i % 2) * f * f]! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:49'!
testPolynomialPseudoDivision
	| Zx x a b |
	Zx _ ZZ polynomials.
	x _ Zx x.
	a _ x^8 + (x^6) - (3*(x^4)) - (3*(x^3)) + (8*(x^2)) + (2*x) - 5.
	b _ 3*(x^6) + (5*(x^4)) - (4*(x^2)) - (9*x) + 21.
	20 timesRepeat: [(a pseudoDivideBy: b) quotient]! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:49'!
testPolynomialPseudoRemainder
	| Zx x a b |
	Zx _ ZZ polynomials.
	x _ Zx x.
	a _ x^8 + (x^6) - (3*(x^4)) - (3*(x^3)) + (8*(x^2)) + (2*x) - 5.
	b _ 3*(x^6) + (5*(x^4)) - (4*(x^2)) - (9*x) + 21.
	20 timesRepeat: [a pseudoRem: b]! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 12/18/2016 20:03:53'!
testPolynomialRealRoots
	| R x f |
	R _ RealAlgebraicNumbersField new.
	x _ QQ polynomials x.
	f _ (x-(1/2))^2*(x-2)*(x^2 + 1)*(x^2-2).
	20 timesRepeat: [f rootsIn: R]! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 3/1/2016 15:55'!
testRealAlgebraicNumberAddition
	| sqrt2 sqrt3 sqrt5 |
	sqrt2 _ RealAlgebraicNumber sqrt: 2.
	sqrt3 _ RealAlgebraicNumber sqrt: 3.
	sqrt5 _ RealAlgebraicNumber sqrt: 5.
	10 timesRepeat: [sqrt3 + sqrt5 + sqrt2 - sqrt3 - sqrt5]! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 3/1/2016 15:56'!
testRealAlgebraicNumberDivision
	| sqrt3 sqrt5 |
	sqrt3 _ RealAlgebraicNumber sqrt: 3.
	sqrt5 _ RealAlgebraicNumber sqrt: 5.
	10 timesRepeat: [sqrt3 / sqrt5 / sqrt3 / sqrt5]! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 3/1/2016 15:56'!
testRealAlgebraicNumberProduct
	| sqrt3 sqrt5 |
	sqrt3 _ RealAlgebraicNumber sqrt: 3.
	sqrt5 _ RealAlgebraicNumber sqrt: 5.
	10 timesRepeat: [sqrt3 * sqrt5 * sqrt3 * sqrt5]! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 3/1/2016 15:57'!
testRealAlgebraicNumberSquare
	| sqrt2 |
	sqrt2 _ RealAlgebraicNumber sqrt2.
	10 timesRepeat: [sqrt2 squared]! !

!SmallMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 12/2/2016 09:23:51'!
setUp
	integerMatrix _ ZZ ^ (64@64) :: atRandomBits: 10000.
	binaryMatrix _ (PrimeField new: 2) ^ (64@64) :: atRandom.
	modularMatrix _ (PrimeField new: 32003) ^ (64@64) :: atRandom! !

!SmallMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 7/8/2016 02:48'!
testAdditionZ
	integerMatrix + integerMatrix! !

!SmallMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 7/8/2016 02:48'!
testAdditionZ2
	binaryMatrix + binaryMatrix! !

!SmallMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 12/2/2016 09:24:56'!
testAdditionZp
	modularMatrix + modularMatrix! !

!SmallMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 7/8/2016 02:49'!
testCopyZ
	integerMatrix copy! !

!SmallMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 7/8/2016 02:50'!
testCopyZ2
	binaryMatrix copy! !

!SmallMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 12/2/2016 09:24:46'!
testCopyZp
	modularMatrix copy! !

!SmallMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 7/8/2016 02:49'!
testMultiplicationZ
	integerMatrix * integerMatrix! !

!SmallMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 7/8/2016 02:58'!
testMultiplicationZ2
	binaryMatrix * binaryMatrix! !

!SmallMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 12/2/2016 09:24:37'!
testMultiplicationZp
	modularMatrix * modularMatrix! !

!SmallMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 7/8/2016 02:49'!
testTranspositionZ
	integerMatrix transposed! !

!SmallMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 7/8/2016 02:58'!
testTranspositionZ2
	binaryMatrix transposed! !

!SmallMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 12/2/2016 09:24:25'!
testTranspositionZp
	modularMatrix transposed! !

!SparsePolynomialMultiplicationBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/22/2016 11:48:08'!
setUp
	| P x y z |
	P _ ZZ polynomialsIn: #(x y z).
	x _ P x.
	y _ P y.
	z _ P z.
	p _ (1+x+y+z)^20.
	pBigCoefficients _ 10000000001*(1+x+y+z)^20. "big coefficients"
	pBigExponents _ 1 + (x^2147483647) + (y^2147483647) + (z^2147483647) ^ 20. "big exponents"
	pPlusOne _ p + 1.
	pBigCoefficientsPlusOne _ pBigCoefficients + 1.
	pBigExponentsPlusOne _ pBigExponents + 1! !

!SparsePolynomialMultiplicationBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/22/2016 11:48:43'!
testBigCoefficientsProduct
	pBigCoefficients * pBigCoefficientsPlusOne! !

!SparsePolynomialMultiplicationBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/22/2016 11:49:00'!
testBigExponentsProduct
	pBigExponents * pBigExponentsPlusOne! !

!SparsePolynomialMultiplicationBenchmark methodsFor: 'as yet unclassified' stamp: 'len 6/5/2016 08:44'!
testProduct
	p * pPlusOne! !

!CASBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/19/2016 11:05:43'!
run
	| output |
	output _ WriteStream on: (String new: 1000).
	(self class selectors asArray select: [:each|
		(each beginsWith: 'test') and: [each numArgs isZero]]) sort
		do: [:each|
			output nextPutAll: each; tab.
			"self setUp."
			Smalltalk garbageCollect.
			[output nextPutAll: (self perform: each)] on: Error do: [output nextPutAll: 'FAILED'].
			"self tearDown"]
		separatedBy: [output newLine].
	^ output contents! !

!CASBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/19/2016 18:35:51'!
testConvolution: a with: b into: c modulo: m
	c atAllPut: 0.
	1 to: a size do: [:i|
		1 to: b size do: [:j| | index |
			index _ i+j-1.
			c at: index put: (a at: i) * (b at: j) + (c at: index) \\ m]].
	^ c! !

!CASBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/19/2016 18:02:38'!
testDotProduct: a with: b modulo: m
	| answer |
	answer _ 0.
	1 to: a size do: [:i| answer _ (a at: i) * (b at: i) + answer \\ m].
	^ answer! !

!CASBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/19/2016 17:55:38'!
testEqualsBytes
	| random a b |
	random _ Random seed: 1234.
	a _ ((1 to: 1000) collect: [:each| (random nextInteger: 256) - 1]) asByteArray.
	b _ a copy.
	^ [a = b] bench! !

!CASBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/19/2016 17:57:31'!
testEqualsWords
	| random a b |
	random _ Random seed: 1234.
	a _ ((1 to: 1000) collect: [:each| (random nextInteger: 256) - 1]) asWordArray.
	b _ a copy.
	^ [a = b] bench! !

!CASBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/19/2016 17:57:05'!
testHashBytes
	| random a |
	random _ Random seed: 1234.
	a _ ((1 to: 1000) collect: [:each| (random nextInteger: 256) - 1]) asByteArray.
	^ [a hash] bench! !

!CASBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/19/2016 17:57:21'!
testHashWords
	| random a |
	random _ Random seed: 1234.
	a _ ((1 to: 1000) collect: [:each| (random nextInteger: 256) - 1]) asWordArray.
	^ [a hash] bench! !

!CASBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/19/2016 18:01:16'!
testModularConvolutionBytes
	| random p a b c |
	p _ 251.
	random _ Random seed: 1234.
	a _ ((1 to: 1000) collect: [:each| (random nextInteger: p) - 1]) asByteArray.
	b _ ((1 to: 1000) collect: [:each| (random nextInteger: p) - 1]) asByteArray.
	c _ ByteArray new: 2000.
	^ [self testConvolution: a with: b into: c modulo: p] bench! !

!CASBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/19/2016 17:59:23'!
testModularConvolutionWords
	| random p a b c |
	p _ 32003.
	random _ Random seed: 1234.
	a _ ((1 to: 1000) collect: [:each| (random nextInteger: p) - 1]) asWordArray.
	b _ ((1 to: 1000) collect: [:each| (random nextInteger: p) - 1]) asWordArray.
	c _ WordArray new: 2000.
	^ [self testConvolution: a with: b into: c modulo: p] bench! !

!CASBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/19/2016 18:03:18'!
testModularDotProductBytes
	| random p a b |
	p _ 251.
	random _ Random seed: 1234.
	a _ ((1 to: 1000) collect: [:each| (random nextInteger: p) - 1]) asByteArray.
	b _ ((1 to: 1000) collect: [:each| (random nextInteger: p) - 1]) asByteArray.
	^ [self testDotProduct: a with: b modulo: p] bench! !

!CASBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/19/2016 18:03:50'!
testModularDotProductWords
	| random p a b |
	p _ 32003.
	random _ Random seed: 1234.
	a _ ((1 to: 1000) collect: [:each| (random nextInteger: p) - 1]) asWordArray.
	b _ ((1 to: 1000) collect: [:each| (random nextInteger: p) - 1]) asWordArray.
	^ [self testDotProduct: a with: b modulo: p] bench! !

!CASBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/19/2016 18:01:23'!
testModularSumBytes
	| random p a b c |
	p _ 251.
	random _ Random seed: 1234.
	a _ ((1 to: 1000) collect: [:each| (random nextInteger: p) - 1]) asByteArray.
	b _ ((1 to: 1000) collect: [:each| (random nextInteger: p) - 1]) asByteArray.
	c _ ByteArray new: 1000.
	^ [self testSum: a with: b into: c modulo: p] bench! !

!CASBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/19/2016 17:59:15'!
testModularSumWords
	| random p a b c |
	p _ 32003.
	random _ Random seed: 1234.
	a _ ((1 to: 1000) collect: [:each| (random nextInteger: p) - 1]) asWordArray.
	b _ ((1 to: 1000) collect: [:each| (random nextInteger: p) - 1]) asWordArray.
	c _ WordArray new: 1000.
	^ [self testSum: a with: b into: c modulo: p] bench! !

!CASBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/19/2016 19:09:54'!
testPermutate: a with: b into: c
	1 to: a size do: [:i| c at: i put: (b at: (a at: i))]! !

!CASBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/19/2016 19:08:57'!
testPermutationCompositionArray
	| n a b c |
	n _ 1000.
	a _ (1 to: n) shuffled.
	b _ (1 to: n) shuffled.
	c _ Array new: n.
	^ [self testPermutate: a with: b into: c] bench! !

!CASBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/19/2016 11:11:52'!
testPermutationCompositionWords
	| n a b c |
	n _ 1000.
	a _ (1 to: n) shuffled asWordArray.
	b _ (1 to: n) shuffled asWordArray.
	c _ WordArray new: n.
	^ [self testPermutate: a with: b into: c] bench! !

!CASBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/19/2016 10:57:34'!
testSum: a with: b into: c modulo: m
	1 to: a size do: [:i| c at: i put: (a at: i) + (b at: i) \\ m].
	^ c! !
