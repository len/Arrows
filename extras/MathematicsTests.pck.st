'From Cuis 5.0 of 7 November 2016 [latest update: #3784] on 10 July 2019 at 4:56:05 pm'!
'Description Please enter a description for this package'!
!provides: 'MathematicsTests' 1 148!
SystemOrganization addCategory: #MathematicsTests!


!classDefinition: #AbelianGroupTest category: #MathematicsTests!
TestCase subclass: #AbelianGroupTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'AbelianGroupTest class' category: #MathematicsTests!
AbelianGroupTest class
	instanceVariableNames: ''!

!classDefinition: #AffineGeometryTest category: #MathematicsTests!
TestCase subclass: #AffineGeometryTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'AffineGeometryTest class' category: #MathematicsTests!
AffineGeometryTest class
	instanceVariableNames: ''!

!classDefinition: #AlgebraicGeometryTest category: #MathematicsTests!
TestCase subclass: #AlgebraicGeometryTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'AlgebraicGeometryTest class' category: #MathematicsTests!
AlgebraicGeometryTest class
	instanceVariableNames: ''!

!classDefinition: #AlgebraicNumbersTest category: #MathematicsTests!
TestCase subclass: #AlgebraicNumbersTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'AlgebraicNumbersTest class' category: #MathematicsTests!
AlgebraicNumbersTest class
	instanceVariableNames: ''!

!classDefinition: #CodesTest category: #MathematicsTests!
TestCase subclass: #CodesTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'CodesTest class' category: #MathematicsTests!
CodesTest class
	instanceVariableNames: ''!

!classDefinition: #CommutativeAlgebraTest category: #MathematicsTests!
TestCase subclass: #CommutativeAlgebraTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'CommutativeAlgebraTest class' category: #MathematicsTests!
CommutativeAlgebraTest class
	instanceVariableNames: ''!

!classDefinition: #EllipticCurvesTest category: #MathematicsTests!
TestCase subclass: #EllipticCurvesTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'EllipticCurvesTest class' category: #MathematicsTests!
EllipticCurvesTest class
	instanceVariableNames: ''!

!classDefinition: #GraphTest category: #MathematicsTests!
TestCase subclass: #GraphTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'GraphTest class' category: #MathematicsTests!
GraphTest class
	instanceVariableNames: ''!

!classDefinition: #GroupTest category: #MathematicsTests!
TestCase subclass: #GroupTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'GroupTest class' category: #MathematicsTests!
GroupTest class
	instanceVariableNames: ''!

!classDefinition: #LatticeTest category: #MathematicsTests!
TestCase subclass: #LatticeTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'LatticeTest class' category: #MathematicsTests!
LatticeTest class
	instanceVariableNames: ''!

!classDefinition: #LinearGroupsTest category: #MathematicsTests!
TestCase subclass: #LinearGroupsTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'LinearGroupsTest class' category: #MathematicsTests!
LinearGroupsTest class
	instanceVariableNames: ''!

!classDefinition: #MathematicsTest category: #MathematicsTests!
TestCase subclass: #MathematicsTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'MathematicsTest class' category: #MathematicsTests!
MathematicsTest class
	instanceVariableNames: ''!

!classDefinition: #MatrixTest category: #MathematicsTests!
TestCase subclass: #MatrixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'MatrixTest class' category: #MathematicsTests!
MatrixTest class
	instanceVariableNames: ''!

!classDefinition: #ModularIntegersTest category: #MathematicsTests!
TestCase subclass: #ModularIntegersTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'ModularIntegersTest class' category: #MathematicsTests!
ModularIntegersTest class
	instanceVariableNames: ''!

!classDefinition: #ModularTest category: #MathematicsTests!
TestCase subclass: #ModularTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'ModularTest class' category: #MathematicsTests!
ModularTest class
	instanceVariableNames: ''!

!classDefinition: #ModuleTest category: #MathematicsTests!
TestCase subclass: #ModuleTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'ModuleTest class' category: #MathematicsTests!
ModuleTest class
	instanceVariableNames: ''!

!classDefinition: #MonomialTest category: #MathematicsTests!
TestCase subclass: #MonomialTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'MonomialTest class' category: #MathematicsTests!
MonomialTest class
	instanceVariableNames: ''!

!classDefinition: #NumberFieldTest category: #MathematicsTests!
TestCase subclass: #NumberFieldTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'NumberFieldTest class' category: #MathematicsTests!
NumberFieldTest class
	instanceVariableNames: ''!

!classDefinition: #PAdicsTest category: #MathematicsTests!
TestCase subclass: #PAdicsTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'PAdicsTest class' category: #MathematicsTests!
PAdicsTest class
	instanceVariableNames: ''!

!classDefinition: #PolynomialTest category: #MathematicsTests!
TestCase subclass: #PolynomialTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'PolynomialTest class' category: #MathematicsTests!
PolynomialTest class
	instanceVariableNames: ''!

!classDefinition: #QuadraticFormTest category: #MathematicsTests!
TestCase subclass: #QuadraticFormTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'QuadraticFormTest class' category: #MathematicsTests!
QuadraticFormTest class
	instanceVariableNames: ''!

!classDefinition: #RingTest category: #MathematicsTests!
TestCase subclass: #RingTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'RingTest class' category: #MathematicsTests!
RingTest class
	instanceVariableNames: ''!

!classDefinition: #RootSystemTest category: #MathematicsTests!
TestCase subclass: #RootSystemTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'RootSystemTest class' category: #MathematicsTests!
RootSystemTest class
	instanceVariableNames: ''!

!classDefinition: #SequenceTest category: #MathematicsTests!
TestCase subclass: #SequenceTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'SequenceTest class' category: #MathematicsTests!
SequenceTest class
	instanceVariableNames: ''!

!classDefinition: #SimplicialComplexTest category: #MathematicsTests!
TestCase subclass: #SimplicialComplexTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'SimplicialComplexTest class' category: #MathematicsTests!
SimplicialComplexTest class
	instanceVariableNames: ''!

!classDefinition: #TupleTest category: #MathematicsTests!
TestCase subclass: #TupleTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'TupleTest class' category: #MathematicsTests!
TupleTest class
	instanceVariableNames: ''!

!classDefinition: #Benchmark category: #MathematicsTests!
Object subclass: #Benchmark
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'Benchmark class' category: #MathematicsTests!
Benchmark class
	instanceVariableNames: ''!

!classDefinition: #AlgebraicNumbersBenchmark category: #MathematicsTests!
Benchmark subclass: #AlgebraicNumbersBenchmark
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'AlgebraicNumbersBenchmark class' category: #MathematicsTests!
AlgebraicNumbersBenchmark class
	instanceVariableNames: ''!

!classDefinition: #GroebnerBasisBenchmark category: #MathematicsTests!
Benchmark subclass: #GroebnerBasisBenchmark
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'GroebnerBasisBenchmark class' category: #MathematicsTests!
GroebnerBasisBenchmark class
	instanceVariableNames: ''!

!classDefinition: #GroupBenchmark category: #MathematicsTests!
Benchmark subclass: #GroupBenchmark
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'GroupBenchmark class' category: #MathematicsTests!
GroupBenchmark class
	instanceVariableNames: ''!

!classDefinition: #IntegersBenchmark category: #MathematicsTests!
Benchmark subclass: #IntegersBenchmark
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'IntegersBenchmark class' category: #MathematicsTests!
IntegersBenchmark class
	instanceVariableNames: ''!

!classDefinition: #ModularMatrixBenchmark category: #MathematicsTests!
Benchmark subclass: #ModularMatrixBenchmark
	instanceVariableNames: 'field matrix'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'ModularMatrixBenchmark class' category: #MathematicsTests!
ModularMatrixBenchmark class
	instanceVariableNames: ''!

!classDefinition: #PolynomialBenchmark category: #MathematicsTests!
Benchmark subclass: #PolynomialBenchmark
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'PolynomialBenchmark class' category: #MathematicsTests!
PolynomialBenchmark class
	instanceVariableNames: ''!

!classDefinition: #SmallMatrixBenchmark category: #MathematicsTests!
Benchmark subclass: #SmallMatrixBenchmark
	instanceVariableNames: 'integerMatrix binaryMatrix modularMatrix'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'SmallMatrixBenchmark class' category: #MathematicsTests!
SmallMatrixBenchmark class
	instanceVariableNames: ''!

!classDefinition: #SparsePolynomialMultiplicationBenchmark category: #MathematicsTests!
Benchmark subclass: #SparsePolynomialMultiplicationBenchmark
	instanceVariableNames: 'p pPlusOne pBigCoefficients pBigExponents pBigCoefficientsPlusOne pBigExponentsPlusOne'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'SparsePolynomialMultiplicationBenchmark class' category: #MathematicsTests!
SparsePolynomialMultiplicationBenchmark class
	instanceVariableNames: ''!

!classDefinition: #TupleConvolutionBenchmark category: #MathematicsTests!
Benchmark subclass: #TupleConvolutionBenchmark
	instanceVariableNames: 'a b'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'TupleConvolutionBenchmark class' category: #MathematicsTests!
TupleConvolutionBenchmark class
	instanceVariableNames: ''!

!classDefinition: #CASBenchmark category: #MathematicsTests!
Object subclass: #CASBenchmark
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MathematicsTests'!
!classDefinition: 'CASBenchmark class' category: #MathematicsTests!
CASBenchmark class
	instanceVariableNames: ''!


!AlgebraicNumbersBenchmark commentStamp: '<historical>' prior: 0!
AlgebraicNumbersBenchmark new run

testComplexAlgebraicNumberAddition	1.1 per second. (25 May 2018)
testComplexAlgebraicNumberDivision	63.9 per second.
testComplexAlgebraicNumberProduct	68.3 per second.
testComplexAlgebraicNumberSquare	2,080 per second.
testRealAlgebraicNumberAddition	0.936 per second.
testRealAlgebraicNumberDivision	61.7 per second.
testRealAlgebraicNumberProduct	67.1 per second.
testRealAlgebraicNumberSquare	2,010 per second.

testComplexAlgebraicNumberAddition	0.907 per second. (18 May 2018)
testComplexAlgebraicNumberDivision	61 per second.
testComplexAlgebraicNumberProduct	64.7 per second.
testComplexAlgebraicNumberSquare	1,760 per second.
testRealAlgebraicNumberAddition	0.997 per second.
testRealAlgebraicNumberDivision	58.2 per second.
testRealAlgebraicNumberProduct	62.6 per second.
testRealAlgebraicNumberSquare	1,730 per second.

testComplexAlgebraicNumberAddition	0.84 per second.
testComplexAlgebraicNumberDivision	58.4 per second.
testComplexAlgebraicNumberProduct	61.6 per second.
testComplexAlgebraicNumberSquare	1,770 per second.
testRealAlgebraicNumberAddition	0.952 per second.
testRealAlgebraicNumberDivision	48.3 per second.
testRealAlgebraicNumberProduct	56.2 per second.
testRealAlgebraicNumberSquare	1,460 per second.

testComplexAlgebraicNumberAddition	1.08 per second. (29 Apr 2018)
testComplexAlgebraicNumberDivision	57.6 per second.
testComplexAlgebraicNumberProduct	61.2 per second.
testComplexAlgebraicNumberSquare	1,660 per second.
testRealAlgebraicNumberAddition	0.78 per second.
testRealAlgebraicNumberDivision	55.8 per second.
testRealAlgebraicNumberProduct	59.1 per second.
testRealAlgebraicNumberSquare	1,610 per second.' 
!

!GroebnerBasisBenchmark commentStamp: 'len 5/12/2018 18:35:32' prior: 0!
GroebnerBasisBenchmark new run

fixed katsura generators:
testCyclic3	10,600 per second.
testCyclic4	1,870 per second.
testCyclic5	6.69 per second.
testEliminationExample	3,280 per second.
testKatsura2	16,400 per second.
testKatsura3	3,990 per second.
testKatsura4	559 per second.
testModularCyclic3	9,680 per second.
testModularKatsura2	14,800 per second.
testModularKatsura3	4,110 per second.
testModularKatsura4	674 per second.

changed Buchberger>>run to do full reductions (calling reduceFull:).
This seems to be slower when the number of variables is low, but starts to pay off for n > 3
testCyclic3	10,200 per second.
testCyclic4	1,810 per second.
testCyclic5	6.56 per second.
testEliminationExample	3,260 per second.
testKatsura2	16,800 per second.
testKatsura3	4,230 per second.
testKatsura4	554 per second.
testModularCyclic3	9,810 per second.
testModularKatsura2	16,000 per second.
testModularKatsura3	4,470 per second.
testModularKatsura4	695 per second.

testCyclic3	14,400 per second. (11 May 2018, Buchberger>>run replaced Set by OrderedCollection)
testCyclic4	1,810 per second.
testCyclic5	3.37 per second.
testEliminationExample	3,950 per second.
testKatsura2	23,600 per second.
testKatsura3	6,120 per second.
testKatsura4	487 per second.
testModularCyclic3	13,300 per second.
testModularKatsura2	22,000 per second.
testModularKatsura3	6,270 per second.
testModularKatsura4	593 per second.

testCyclic3	14,600 per second. (10 May 2018, optimized Buchberger to reduce the polynomials from S before adding them to basis, fixed definition of the ideal of cyclic n-roots)
testCyclic4	1,860 per second.
testCyclic5	2.64 per second.
testEliminationExample	3,920 per second.
testKatsura2	23,900 per second.
testKatsura3	6,400 per second.
testKatsura4	496 per second.
testModularCyclic3	13,900 per second.
testModularKatsura2	22,500 per second.
testModularKatsura3	6,400 per second.
testModularKatsura4	613 per second.' 

testCyclic3	8,190 per second. (9 May 2018, optimized Buchberger>>run, added i0)
testCyclic4	2,920 per second.
testCyclic5	1,060 per second.
testCyclic6	381 per second.
testEliminationExample	2,820 per second.
testKatsura2	16,300 per second.
testKatsura3	3,930 per second.
testKatsura4	42.2 per second.
testModularCyclic3	7,820 per second.
testModularKatsura2	15,200 per second.
testModularKatsura3	3,630 per second.
testModularKatsura4	54.4 per second.

testCyclic3	4,730 per second. (25 Dec 2017, after refactoring MultivariatePolynomial and removing MonomialIndexedTuple)
testCyclic4	1,040 per second.
testCyclic5	258 per second.
testCyclic6	63.5 per second.
testEliminationExample	1,700 per second.
testKatsura2	13,900 per second.
testKatsura3	2,060 per second.
testKatsura4	16.7 per second.
testModularCyclic3	4,480 per second.
testModularKatsura2	12,800 per second.
testModularKatsura3	1,900 per second.
testModularKatsura4	22.3 per second.' 

testCyclic3	4,400 per second. (optimized GroebnerBasis>>reduce:)
testCyclic4	1,000 per second.
testCyclic5	238 per second.
testCyclic6	58 per second.
testEliminationExample	1,840 per second.
testKatsura2	13,600 per second.
testKatsura3	1,950 per second.
testKatsura4	15.6 per second.
testModularCyclic3	4,270 per second.
testModularKatsura2	12,600 per second.
testModularKatsura3	1,800 per second.
testModularKatsura4	20.6 per second.

testCyclic3	2,260 per second. (modular inversion using extended euclid)
testCyclic4	520 per second.
testCyclic5	124 per second.
testCyclic6	28.9 per second.
testEliminationExample	897 per second.
testKatsura2	6,690 per second.
testKatsura3	869 per second.
testKatsura4	10.6 per second.
testModularCyclic3	2,430 per second.
testModularKatsura2	7,470 per second.
testModularKatsura3	1,050 per second.
testModularKatsura4	15.5 per second.

testCyclic3	2,230 per second. (polynomials as sorted dictionaries monomial -> coefficient)
testCyclic4	512 per second.
testCyclic5	121 per second.
testCyclic6	28.7 per second.
testEliminationExample	867 per second.
testKatsura2	6,700 per second.
testKatsura3	860 per second.
testKatsura4	11 per second.
testModularCyclic3	2,320 per second.
testModularKatsura2	6,960 per second.
testModularKatsura3	858 per second.
testModularKatsura4	12.1 per second.

testCyclic3	2,270 per second. (polynomials as dictionaries monomial -> coefficient)
testCyclic4	511 per second.
testCyclic5	118 per second.
testCyclic6	26.1 per second.
testEliminationExample	816 per second.
testKatsura2	6,750 per second.
testKatsura3	866 per second.
testKatsura4	11.8 per second.
testModularCyclic3	2,410 per second.
testModularKatsura2	6,780 per second.
testModularKatsura3	844 per second.
testModularKatsura4	13.3 per second.

testCyclic3	2,240 per second. (with Groebner bases kept sorted, GroebnerBasis>>initialize)
testCyclic4	520 per second.
testCyclic5	120 per second.
testCyclic6	26 per second.
testEliminationExample	720 per second.
testKatsura2	6,730 per second.
testKatsura3	755 per second.
testKatsura4	34.9 per second.
testModularCyclic3	2,310 per second.
testModularKatsura2	6,720 per second.
testModularKatsura3	727 per second.
testModularKatsura4	33 per second.

testCyclic3	2,140 per second. (reverted Monomial>>hash)
testCyclic4	676 per second.
testCyclic5	112 per second.
testCyclic6	36.2 per second.
testEliminationExample	773 per second.
testKatsura2	6,430 per second.
testKatsura3	821 per second.
testKatsura4	7.72 per second.
testModularCyclic3	2,220 per second.
testModularKatsura2	6,490 per second.
testModularKatsura3	797 per second.
testModularKatsura4	12.6 per second.

testCyclic3	2,240 per second. (defined Monomial>>hash as 'exponents hash')
testCyclic4	682 per second.
testCyclic5	116 per second.
testCyclic6	40.4 per second.
testEliminationExample	827 per second.
testKatsura2	6,650 per second.
testKatsura3	857 per second.
testKatsura4	7.82 per second.
testModularCyclic3	2,370 per second.
testModularKatsura2	6,840 per second.
testModularKatsura3	861 per second.
testModularKatsura4	13.6 per second.

testCyclic3	1,780 per second. (spur 32 bits)
testCyclic4	354 per second.
testCyclic5	26.8 per second.
testCyclic6	12.2 per second.
testEliminationExample	614 per second.
testKatsura2	5,540 per second.
testKatsura3	130 per second.
testKatsura4	10.7 per second.
testModularCyclic3	177 per second.
testModularKatsura2	194 per second.

[self new modularCyclic: 7 :: groebnerBasis] bench
 '3.63 per second.' (spur 32 bits)
 '165 seconds.' 

testCyclic3	1,300 per second.
testCyclic4	264 per second.
testCyclic5	60.1 per second.
testCyclic6	9.7 per second.
testElimination	143 per second.
testKatsura2	4,230 per second.
testKatsura3	407 per second.
testKatsura4	4.06 per second.
testModularCyclic3	175 per second.
testModularKatsura2	194 per second. 

testCyclic3	1,130 per second.
testCyclic4	195 per second.
testCyclic5	48.7 per second.
testCyclic6	9.31 per second.
testElimination	116 per second.
testKatsura2	3,440 per second.
testKatsura3	354 per second.
testKatsura4	2.8 per second.
testModularCyclic3	149 per second.
testModularKatsura2	184 per second.'

'testCyclic3	1,080 per second.
testCyclic4	36.8 per second.
testCyclic5	1.19 per second.
testElimination	77.1 per second.
testKatsura2	3,810 per second.
testKatsura3	26.1 per second.
testModularCyclic3	173 per second.
testModularKatsura2	201 per second.' 

testCyclic3	1,060 per second.
testCyclic4	56.3 per second.
testCyclic5	1.08 per second.
testElimination	241 per second.
testKatsura2	4,790 per second.
testKatsura3	11.5 per second.
testModularCyclic3	173 per second.
testModularKatsura2	200 per second.

testCyclic3	615 per second.
testCyclic4	29.2 per second.
testCyclic5	1.38 per second.
testElimination	43.5 per second.
testKatsura2	2,330 per second.
testKatsura3	7.21 per second.

testCyclic3	632 per second.
testCyclic4	4.34 per second.
testElimination	3.45 per second.
testKatsura2	2,190 per second.
testKatsura3	0.288 per second.

testCyclic3	524 per second.
testCyclic4	4.85 per second.
testElimination	2.82 per second.
testKatsura2	1,950 per second.
testKatsura3	0.251 per second.

testCyclic3	540 per second.
testCyclic4	3.73 per second.
testElimination	2 per second.
testKatsura2	2,130 per second.
testKatsura3	0.257 per second.

testCyclic3	494 per second.
testCyclic4	2.41 per second.
testElimination	1.34 per second.
testKatsura2	1,950 per second.
testKatsura3	5.38 seconds.

testCyclic3	393 per second.
testCyclic4	1.62 per second.
testElimination	1.29 per second.
testKatsura2	1,830 per second.
testKatsura3	6.58 seconds.

old:
testCyclic3	312 per second.
testElimination	0.911 per second.
testKatsura2	1,260 per second.
!

!GroupBenchmark commentStamp: '<historical>' prior: 0!
GroupBenchmark new run

testJ1Order	3.95 per second. (spur 32 bits)
testM12Order	86.7 per second.

testJ1Order	2.39 per second.
testM12Order	57.4 per second.

testJ1Order	2.51 per second.
testM12Order	56.9 per second.
!

!IntegersBenchmark commentStamp: 'len 11/22/2016 11:57:33' prior: 0!
self new run

test1000Factorial	5,620 per second. (spur 32 bits)

test1000Factorial	1,250 per second.
!

!ModularMatrixBenchmark commentStamp: '<historical>' prior: 0!
Some tests on a 300x300 matrix over Z/32003.

self new run

testAddition	384 per second.
testGaussianElimination	1.88 per second.
testImage	1.84 per second.
testKernel	0.736 per second.
testSquared	1.39 per second.
testTransposition	89.8 per second.

testAddition	387 per second.
testGaussianElimination	1.82 per second.
testSquared	1.43 per second.
testTransposition	89.7 per second.

testAddition	203 per second.
testGaussianElimination	1.81 per second.
testSquared	1.32 per second.
testTransposition	66.9 per second.!

!PolynomialBenchmark commentStamp: 'len 5/26/2018 19:40:36' prior: 0!
PolynomialBenchmark new run

testAdditionOverZ	25.4 per second.
testAdditionOverZ2	283 per second.
testDivisionOverQ	5.23 per second.
testDivisionOverZ	5.25 per second.
testFactorizationOverZ17	10.2 per second
testFiniteField	20.1 per second.
testFiniteFieldPolynomialFactorization	336 per second.
testGCDOverQ	8.2 per second.
testGCDOverZ	4.81 per second.
testGCDOverZ2	10.3 per second.
testMultiplication2OverZ	154 per second.
testMultiplication2OverZ2	681 per second.
testMultiplicationOverZ	2.7 per second.
testMultiplicationOverZ2	4,060 per second.
testMultivariatePolynomialAdditionOverZ	106 per second.
testPseudoDivision	5,060 per second.
testPseudoRemainder	5,050 per second.
testRealRoots	24.4 per second.

testFiniteField	18.2 per second. (25 Dec 2017, after refactoring MultivariatePolynomial and removing MonomialIndexedTuple)
testFiniteFieldPolynomialFactorization	255 per second.
testMultivariatePolynomialAdditionOverZ	102 per second.
testPolynomialAdditionOverZ	33.4 per second.
testPolynomialAdditionOverZ2	269 per second.
testPolynomialDivisionOverQ	3.32 per second.
testPolynomialDivisionOverZ	2.96 per second.
testPolynomialGCDOverQ	3.56 per second.
testPolynomialGCDOverZ	4.74 per second.
testPolynomialGCDOverZ2	24.6 per second.
testPolynomialMultiplication2OverZ	168 per second.
testPolynomialMultiplication2OverZ2	686 per second.
testPolynomialMultiplicationOverZ	2.72 per second.
testPolynomialMultiplicationOverZ2	4,090 per second.
testPolynomialPseudoDivision	4,840 per second.
testPolynomialPseudoRemainder	4,810 per second.
testPolynomialRealRoots	40.7 per second.
testRealAlgebraicNumberAddition	2.9 per second.
testRealAlgebraicNumberDivision	241 per second.
testRealAlgebraicNumberProduct	308 per second.
testRealAlgebraicNumberSquare	5,630 per second.

testFiniteField	17.1 per second.
testFiniteFieldPolynomialFactorization	97.8 per second.
testMultivariatePolynomialAdditionOverZ	93.9 per second.
testPolynomialAdditionOverZ	32.6 per second.
testPolynomialAdditionOverZ2	136 per second.
testPolynomialDivisionOverQ	2.63 per second.
testPolynomialDivisionOverZ	2.74 per second.
testPolynomialGCDOverQ	2.88 per second.
testPolynomialGCDOverZ	4.3 per second.
testPolynomialGCDOverZ2	11.3 per second.
testPolynomialMultiplication2OverZ	163 per second.
testPolynomialMultiplication2OverZ2	628 per second.
testPolynomialMultiplicationOverZ	2.7 per second.
testPolynomialMultiplicationOverZ2	3,760 per second.
testPolynomialPseudoDivision	4,110 per second.
testPolynomialPseudoRemainder	4,080 per second.
testPolynomialRealRoots	39.7 per second.
testRealAlgebraicNumberAddition	5.44 seconds.
testRealAlgebraicNumberDivision	154 per second.
testRealAlgebraicNumberProduct	177 per second.
testRealAlgebraicNumberSquare	4,200 per second.

testFiniteField	17.5 per second. (spur 32 bits)
testFiniteFieldPolynomialFactorization	81.3 per second.
testMultivariatePolynomialAdditionOverZ	86.8 per second.
testPolynomialAdditionOverZ	31.2 per second.
testPolynomialAdditionOverZ2	135 per second.
testPolynomialDivisionOverQ	2.57 per second.
testPolynomialDivisionOverZ	2.64 per second.
testPolynomialGCDOverQ	2.44 per second.
testPolynomialGCDOverZ	3.51 per second.
testPolynomialGCDOverZ2	9.86 per second.
testPolynomialMultiplication2OverZ	105 per second.
testPolynomialMultiplication2OverZ2	627 per second.
testPolynomialMultiplicationOverZ	2.72 per second.
testPolynomialMultiplicationOverZ2	3,400 per second.
testPolynomialPseudoDivision	3,660 per second.
testPolynomialPseudoRemainder	3,640 per second.
testPolynomialRealRoots	38.7 per second.
testRealAlgebraicNumberAddition	5.27 seconds.
testRealAlgebraicNumberDivision	148 per second.
testRealAlgebraicNumberProduct	170 per second.
testRealAlgebraicNumberSquare	3,970 per second.

testFiniteField	14.6 per second.
testFiniteFieldPolynomialFactorization	58.4 per second.
testMultivariatePolynomialAdditionOverZ	51.7 per second.
testPolynomialAdditionOverZ	15.8 per second.
testPolynomialAdditionOverZ2	94 per second.
testPolynomialDivisionOverQ	1.66 per second.
testPolynomialDivisionOverZ	1.67 per second.
testPolynomialGCDOverQ	1.54 per second.
testPolynomialGCDOverZ	2.22 per second.
testPolynomialGCDOverZ2	7.01 per second.
testPolynomialMultiplication2OverZ	78 per second.
testPolynomialMultiplication2OverZ2	384 per second.
testPolynomialMultiplicationOverZ	0.598 per second.
testPolynomialMultiplicationOverZ2	2,220 per second.
testPolynomialPseudoDivision	2,300 per second.
testPolynomialPseudoRemainder	2,300 per second.
testPolynomialRealRoots	27.3 per second.
testRealAlgebraicNumberAddition	5.24 seconds.
testRealAlgebraicNumberDivision	110 per second.
testRealAlgebraicNumberProduct	132 per second.
testRealAlgebraicNumberSquare	2,720 per second.

testFiniteField	11.1 per second.
testFiniteFieldPolynomialFactorization	58 per second.
testMultivariatePolynomialAdditionOverZ	FAILED
testPolynomialAdditionOverZ	11.9 per second.
testPolynomialAdditionOverZ2	76.2 per second.
testPolynomialDivisionOverQ	1.23 per second.
testPolynomialDivisionOverZ	1.12 per second.
testPolynomialGCDOverQ	1.16 per second.
testPolynomialGCDOverZ	1.45 per second.
testPolynomialGCDOverZ2	4.64 per second.
testPolynomialMultiplication2OverZ	33.9 per second.
testPolynomialMultiplication2OverZ2	58.4 per second.
testPolynomialMultiplicationOverZ	0.588 per second.
testPolynomialMultiplicationOverZ2	2,260 per second.
testPolynomialPseudoDivision	1,210 per second.
testPolynomialPseudoRemainder	1,220 per second.
testPolynomialRealRoots	22.8 per second.
testRealAlgebraicNumberAddition	5.28 seconds.
testRealAlgebraicNumberDivision	74.1 per second.
testRealAlgebraicNumberProduct	88.6 per second.
testRealAlgebraicNumberSquare	2,020 per second.

testFiniteField	10.8 per second.
testFiniteFieldPolynomialFactorization	55.1 per second.
testMultivariatePolynomialAdditionOverZ	FAILED
testPolynomialAdditionOverZ	11.9 per second.
testPolynomialAdditionOverZ2	69 per second.
testPolynomialDivisionOverQ	1.2 per second.
testPolynomialDivisionOverZ	1.04 per second.
testPolynomialGCDOverQ	1.12 per second.
testPolynomialGCDOverZ	1.38 per second.
testPolynomialGCDOverZ2	4.25 per second.
testPolynomialMultiplication2OverZ	33 per second.
testPolynomialMultiplication2OverZ2	61.4 per second.
testPolynomialMultiplicationOverZ	0.578 per second.
testPolynomialMultiplicationOverZ2	2,220 per second.
testPolynomialPseudoDivision	1,220 per second.
testPolynomialPseudoRemainder	1,220 per second.
testPolynomialRealRoots	23.1 per second.
testRealAlgebraicNumberAddition	6.11 seconds.
testRealAlgebraicNumberDivision	78.2 per second.
testRealAlgebraicNumberProduct	90.3 per second.
testRealAlgebraicNumberSquare	2,020 per second.

testFiniteField	11.3 per second.
testFiniteFieldPolynomialFactorization	54.5 per second.
testPolynomialAdditionOverZ	10.8 per second.
testPolynomialAdditionOverZ2	75 per second.
testPolynomialDivisionOverQ	1.17 per second.
testPolynomialDivisionOverZ	1.06 per second.
testPolynomialGCDOverQ	1.11 per second.
testPolynomialGCDOverZ	1.38 per second.
testPolynomialGCDOverZ2	4.53 per second.
testPolynomialMultiplication2OverZ	32 per second.
testPolynomialMultiplication2OverZ2	58 per second.
testPolynomialMultiplicationOverZ	0.563 per second.
testPolynomialMultiplicationOverZ2	2,120 per second.
testPolynomialPseudoDivision	1,220 per second.
testPolynomialPseudoRemainder	1,190 per second.
testPolynomialRealRoots	23 per second.
testRealAlgebraicNumberAddition	5.96 seconds.
testRealAlgebraicNumberDivision	70.8 per second.
testRealAlgebraicNumberProduct	81.7 per second.
testRealAlgebraicNumberSquare	1,820 per second!

!SmallMatrixBenchmark commentStamp: 'len 1/22/2018 20:06:14' prior: 0!
This benchmark tests some basic operations on 64x64 matrices over Z, Z/2Z, and Z/32003Z.

self new run

testAdditionZ	7,830 per second. (23/1/2018)
testAdditionZ2	216,000 per second.
testAdditionZp	8,140 per second.
testCopyZ	158,000 per second.
testCopyZ2	448,000 per second.
testCopyZp	176,000 per second.
testImageZ	FAILED
testImageZ2	35.5 per second.
testImageZp	141 per second.
testKernelZ	FAILED
testKernelZ2	14.4 per second.
testKernelZp	61.5 per second.
testMultiplicationZ	164 per second.
testMultiplicationZ2	171 per second.
testMultiplicationZp	130 per second.
testTranspositionZ	4,520 per second.
testTranspositionZ2	1,400 per second.
testTranspositionZp	1,930 per second.

testAdditionZ	7,770 per second.
testAdditionZ2	88,100 per second.
testAdditionZp	8,140 per second.
testCopyZ	145,000 per second.
testCopyZ2	441,000 per second.
testCopyZp	164,000 per second.
testImageZ	FAILED
testImageZ2	31.2 per second.
testImageZp	133 per second.
testKernelZ	FAILED
testKernelZ2	13.7 per second.
testKernelZp	59.7 per second.
testMultiplicationZ	169 per second.
testMultiplicationZ2	158 per second.
testMultiplicationZp	128 per second.
testTranspositionZ	4,360 per second.
testTranspositionZ2	1,090 per second.
testTranspositionZp	1,960 per second.

testAdditionZ	7,960 per second.
testAdditionZ2	85,700 per second.
testAdditionZp	7,710 per second.
testCopyZ	162,000 per second.
testCopyZ2	477,000 per second.
testCopyZp	181,000 per second.
testMultiplicationZ	174 per second.
testMultiplicationZ2	161 per second.
testMultiplicationZp	130 per second.
testTranspositionZ	4,600 per second.
testTranspositionZ2	1,090 per second.
testTranspositionZp	2,110 per second.

testAdditionZ	7,840 per second. (spur 32 bits)
testAdditionZ2	86,600 per second.
testCopyZ	144,000 per second.
testCopyZ2	471,000 per second.
testMultiplicationZ	171 per second.
testMultiplicationZ2	159 per second.
testTranspositionZ	4,390 per second.
testTranspositionZ2	1,010 per second.

testAdditionZ	5,220 per second.
testAdditionZ2	42,600 per second.
testCopyZ	84,700 per second.
testCopyZ2	210,000 per second.
testMultiplicationZ	122 per second.
testMultiplicationZ2	106 per second.
testTranspositionZ	2,020 per second.
testTranspositionZ2	603 per second.

testAdditionZ	4,500 per second.
testAdditionZ2	33,700 per second.
testCopyZ	58,200 per second.
testCopyZ2	164,000 per second.
testMultiplicationZ	20.1 per second.
testMultiplicationZ2	7.81 per second.
testTranspositionZ	1,580 per second.
testTranspositionZ2	565 per second.
!

!SparsePolynomialMultiplicationBenchmark commentStamp: '<historical>' prior: 0!
Timings giving in [1] on computers with 0.8ghz - 1ghz intel cpus: general purpose system 20s-100s, tuned systems 2.3s-10s. For big coefficients: singular 28s, pari 77s.

[1] R.J. Fateman, Comparing the speed of sparse polynomial multiplication.


self new run

testBigCoefficientsProduct	8.5 seconds. (25 Dec 2017, after refactoring MultivariatePolynomial and removing MonomialIndexedTuple)
testBigExponentsProduct	6.38 seconds.
testProduct	0.295 per second.

testBigCoefficientsProduct	8.39 seconds. (polynomials as sorted dictionaries monomial -> coefficient)
testBigExponentsProduct	9.86 seconds.
testProduct	0.328 per second.

testBigCoefficientsProduct	10.5 seconds. (polynomials as dictionaries monomial -> coefficient)
testBigExponentsProduct	10.2 seconds.
testProduct	0.289 per second.
!

!TupleConvolutionBenchmark commentStamp: 'len 6/6/2019 09:09:54' prior: 0!
self new run



testConvolution	3.02  runs per second!

!CASBenchmark commentStamp: '<historical>' prior: 0!
These benchmarks show some of the fundamental bottlenecks for a computational algebra system in pure Smalltalk. Many important algorithms end up doing these operations.

To run the benchmarks, just doIt:
self new run

Cuis 4.5 with Cog 4.5 #9 (r3370, 2015-06-04), 32 bits, Intel i5-3210M @ 2.5Ghz, cache 3072 KB, 4990 bobomips, running inside virtualbox
testEqualsBytes	40,600 per second.
testEqualsWords	36,100 per second.
testHashBytes	245,000 per second.
testHashWords	23,500 per second.
testModularConvolutionBytes	20.6 per second.
testModularConvolutionWords	16.9 per second.
testModularDotProductBytes	36,900 per second.
testModularDotProductWords	30,400 per second.
testModularSumBytes	26,200 per second.
testModularSumWords	21,600 per second.
testPermutationCompositionArray	33,900 per second.
testPermutationCompositionWords	31,400 per second.

Cuis 5.0 with Cog 5.0-201611161032, 32 bits, Intel i5-3210M @ 2.5Ghz, cache 3072 KB, 4990 bobomips, running inside virtualbox
testEqualsBytes	59,900 per second.
testEqualsWords	49,600 per second.
testHashBytes	249,000 per second.
testHashWords	23,000 per second.
testModularConvolutionBytes	27.2 per second.
testModularConvolutionWords	23.9 per second.
testModularDotProductBytes	41,000 per second.
testModularDotProductWords	37,000 per second.
testModularSumBytes	37,900 per second.
testModularSumWords	34,100 per second.
testPermutationCompositionArray	69,100 per second.
testPermutationCompositionWords	51,900 per second.
!

!AbelianGroupTest methodsFor: 'as yet unclassified' stamp: 'len 5/13/2019 20:38:26'!
testAbelianGroup: G
	| one a b c |
	one _ G identity.
	a _ G atRandomBits: 100.
	b _ G atRandomBits: 100.
	c _ G atRandomBits: 100.
	self assert: one ∑ a = a.
	self assert: a ∑ one = a.
	self assert: a ∑ b = (b ∑ a). "commutativity"
	self assert: (a ∑ b ∑ c) = (a ∑ (b ∑ c)). "associativity"! !

!AbelianGroupTest methodsFor: 'as yet unclassified' stamp: 'len 5/15/2019 00:06:32'!
testAbelianGroupHomomorphism: phi
	| G H a b |
	G _ phi domain.
	H _ phi codomain.
	a _ G atRandomBits: 100.
	b _ G atRandomBits: 100.
	self assert: (phi value: G identity) = H identity.
	self assert: (phi value: a∑b) = ((phi value: a)∑(phi value: b))! !

!AbelianGroupTest methodsFor: 'as yet unclassified' stamp: 'len 5/28/2019 09:47:47'!
testAsPermutationGroup
	| A |
	A _ AbelianGroup orders: #(2 5 4 2).
	self assert: A asPermutationGroup asAbelianGroup invariants = A invariants! !

!AbelianGroupTest methodsFor: 'as yet unclassified' stamp: 'len 5/26/2019 04:25:48'!
testDirectSum
	| A B C |
	A _ ZZ asAbelianGroup.
	B _ (ZZ / (2 to: 10) atRandom) asAbelianGroup.
	C _ A ê B.
	self testAbelianGroup: C.
	self testAbelianGroupHomomorphism: (C -< (A, B)) atRandom.
	self testAbelianGroupHomomorphism: ((A, B) >- C) atRandom! !

!AbelianGroupTest methodsFor: 'as yet unclassified' stamp: 'len 5/26/2019 12:18:23'!
testExponent
	| G |
	G _ AbelianGroup orders: #(2 3 7).
	self assert: G exponent = 42.
	G _ AbelianGroup orders: #(2 4 6).
	self assert: G exponent = 12! !

!AbelianGroupTest methodsFor: 'as yet unclassified' stamp: 'len 5/28/2019 09:10:30'!
testFreeAbelianGroup
	| G |
	G _ AbelianGroup orders: #(0 0).
	self assert: G rank = 2.
	self assert: G invariants = #(0 0).
	self assert: G torsion invariants = #().
	self assert: G torsion isTrivial.
	self assert: G isTorsion not.
	self assert: G isFree.
	self assert: G torsion isTorsion.
	self assert: G torsion isFree "because it's trivial"! !

!AbelianGroupTest methodsFor: 'as yet unclassified' stamp: 'len 9/28/2018 06:50:42'!
testIntegerTuples
	| M |
	M _ ZZ ^ (1 to: 10) atRandom.
	self testAbelianGroup: M asAbelianGroup.
	self testAbelianGroupHomomorphism: (M projection: (1 to: M rank) atRandom) asAbelianGroupMap! !

!AbelianGroupTest methodsFor: 'as yet unclassified' stamp: 'len 5/13/2019 20:42:32'!
testIntegers
	| G x1 x2 g1 g2 |
	G _ ZZ asAbelianGroup.
	self testAbelianGroup: G.
	x1 _ ZZ atRandomBits: 100.
	x2 _ ZZ atRandomBits: 100.
	g1 _ G !! x1.
	g2 _ G !! x2.
	self assert: ZZ !! g1 = x1.
	self assert: ZZ !! G identity = 0.
	self assert: ZZ !! (g1 ∑ g2) = (x1 + x2).
	self assert: ZZ !! g1 inverse = x1 negated.! !

!AbelianGroupTest methodsFor: 'as yet unclassified' stamp: 'len 5/28/2019 09:10:45'!
testInvariants
	self assert: (AbelianGroup orders: #(1 3 5 12)) invariants = #(3 60).
	self assert: (AbelianGroup orders: #(2 3)) invariants = #(6).
	self assert: (AbelianGroup orders: #(6)) invariants = #(6).
	self assert: (AbelianGroup orders: #(2 6)) invariants = #(2 6).
	self assert: (AbelianGroup orders: #(3 4 5)) invariants = #(60).
	self assert: (AbelianGroup orders: #(0 6)) invariants = #(0 6).
! !

!AbelianGroupTest methodsFor: 'as yet unclassified' stamp: 'len 5/29/2019 12:36:50'!
testInvariantsAndPrimaryInvariants
	| invariants primaryInvariants A |
	invariants _ {2^2*3*(5^2). 2^5*(3^3)*(5^2)}.
	primaryInvariants _ {2^2. 2^5. 3. 3^3. 5^2. 5^2} asBag.
	A _ AbelianGroup orders: invariants shuffled.
	self assert: A invariants = invariants.
	self assert: A primaryInvariants = primaryInvariants.
	A _ AbelianGroup orders: primaryInvariants asArray shuffled.
	self assert: A invariants = invariants.
	self assert: A primaryInvariants = primaryInvariants! !

!AbelianGroupTest methodsFor: 'as yet unclassified' stamp: 'len 5/26/2019 12:18:23'!
testIsCyclic
	| G |
	G _ AbelianGroup orders: #(2 3).
	self assert: G isCyclic.
	G _ AbelianGroup orders: #(6).
	self assert: G isCyclic.
	G _ AbelianGroup orders: #(2 2).
	self assert: G isCyclic not.
	G _ AbelianGroup orders: #(2 4).
	self assert: G isCyclic not.
	G _ AbelianGroup orders: #().
	self assert: G isCyclic.
	G _ AbelianGroup orders: #(0).
	self assert: G isCyclic.
	G _ AbelianGroup orders: #(3 4 5).
	self assert: G isCyclic! !

!AbelianGroupTest methodsFor: 'as yet unclassified' stamp: 'len 5/29/2019 12:37:05'!
testMixedAbelianGroup
	| G |
	G _ AbelianGroup orders: #(0 0 2 3).
	self assert: G rank = 2.
	self assert: G primaryInvariants = #(0 0 2 3) asBag.
	self assert: G torsion primaryInvariants = #(2 3) asBag.
	self assert: G isTorsion not.
	self assert: G isFree not.
	self assert: G isMixed.
	self assert: G torsion isTorsion.
	self assert: G torsion isFree not.
	self assert: G torsionFree isFree.
	self assert: G torsionFree rank = 2! !

!AbelianGroupTest methodsFor: 'as yet unclassified' stamp: 'len 9/28/2018 06:50:48'!
testModularIntegers
	| R |
	R _ ZZ / (2 to: 10) atRandom.
	self testAbelianGroup: R asAbelianGroup.
	self testAbelianGroupHomomorphism: R projection asAbelianGroupMap! !

!AbelianGroupTest methodsFor: 'as yet unclassified' stamp: 'len 5/26/2019 12:18:23'!
testOrder
	self assert: (AbelianGroup orders: #(2 3)) size = 6.
	self assert: (AbelianGroup orders: #(0 2 3)) size isInfinite! !

!AbelianGroupTest methodsFor: 'as yet unclassified' stamp: 'len 5/26/2019 12:18:23'!
testOrderOfElements
	| G g |
	G _ AbelianGroup orders: #(2 3 4 5 0).
	g _ G !! [:a :b :c :d :e| a*(b^2)*(d^4)].
	self assert: g order = 30.
	g _ G !! [:a :b :c :d :e| a*e].
	self assert: g order = 0! !

!AbelianGroupTest methodsFor: 'as yet unclassified' stamp: 'len 5/29/2019 12:37:13'!
testTorsionAbelianGroup
	| G |
	G _ AbelianGroup orders: #(2 3).
	self assert: G rank = 0.
	self assert: G primaryInvariants = #(2 3) asBag.
	self assert: G = G torsion.
	self assert: G isTorsion.
	self assert: G isFree not.
	self assert: G isMixed not.
	self assert: G torsionFree isTrivial! !

!AffineGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 1/22/2017 08:21:59'!
testAffineHull
	| V v1 v2 H |
	V _ QQ ^ 3.
	v1 _ (1,0,0).
	v2 _ (2,2,2).
	H _ V hull: {v1. v2}.
	self assert: H isLine.
	self assert: (H includes: v1).
	self assert: (H includes: v2)! !

!AffineGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 12/14/2017 22:45:30'!
testAffineHullEmpty
	| V H |
	V _ QQ ^ 3.
	H _ V hull: {}.
	self assert: H isEmpty.
	self assert: H dimension = -1.
	self assert: H size = 0! !

!AffineGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 9/27/2018 21:14:39'!
testAffineMapCollinearity
	"Affine maps preserve collinearity."
	| A f p1 fp1 p2 fp2 p3 fp3 |
	A _ QQ ^ 3.
	f _ (A automorphisms atRandomBits: 100) + (A atRandomBits: 100).
	"three collinear points:"
	p1 _ (1,2,3) + (1,0,1). p2 _ (2,4,6) + (1,0,1). p3 _ (-1,-2,-3) + (1,0,1).
	self assert: (A hull: {p1.p2.p3}) isLine.
	"the imagees of the three collinear points must be collinear:"
	fp1 _ f value: p1. fp2 _ f value: p2. fp3 _ f value: p3.
	self assert: (A hull: {fp1.fp2.fp3}) isLine! !

!AffineGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 5/5/2019 18:29:09'!
testAffineMapComposition
	| X Y Z f g x |
	X _ QQ^3.
	Y _ QQ^5.
	Z _ QQ^4.
	f _ (X => Y atRandomBits: 1000) + (Y atRandomBits: 100).
	g _ (Y => Z atRandomBits: 1000) + (Z atRandomBits: 100).
	x _ X atRandomBits: 1000.
"	self assert: (X => Z includes: g ∑ f)."
	self assert: (g ∑ f value: x) = (g value: (f value: x)).
	self should: [f ∑ g] raise: DomainError! !

!AffineGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 5/5/2018 19:19:18'!
testAffineMapEvaluating
	| V f |
	V _ QQ^3.
	f _ AffineMap from: V to: V evaluating: [:p| p*2 - (1,0,0)].
	self assert: (f value: (1,2,3)) = (1,4,6)! !

!AffineGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 5/5/2019 18:29:23'!
testAffineMapInverse
	| A f |
	A _ QQ^3.
	f _ (A automorphisms atRandomBits: 1000) + (A atRandomBits: 100).
	self assert: (f ∑ f inverse) isIdentity.
	self assert: (f inverse ∑ f) isIdentity! !

!AffineGeometryTest methodsFor: 'as yet unclassified' stamp: 'len 12/14/2017 22:51:49'!
testAffineSubspaceParallelism
	| V A B C |
	V _ QQ ^ 3.
	A _ (V span: {(1,1,1)}) + (5,0,0).
	B _ (V span: {(1,1,1). (1,0,0)}) + (10,0,0).
	C _ (V span: {(1,1,2). (0,1,0)}) + (10,0,0).
	self assert: A || B.
	self assert: B || A.
	self deny: A || C.
	self deny: B || C! !

!AlgebraicGeometryTest methodsFor: 'affine' stamp: 'len 5/22/2018 22:46:21'!
testAffinePlaneCurveMultiplicity
	| A C |
	A _ AffineSpace new: #(x y) over: QQ.
	C _ A subscheme: A coordinateRing !! [:x :y| y^2 - (x^3)].
	self assert: (C multiplicityAt: (1,1)) = 1.
	self assert: (C multiplicityAt: (0,0)) = 2! !

!AlgebraicGeometryTest methodsFor: 'affine' stamp: 'len 1/5/2018 10:16:11'!
testAffineSchemeCartesianProduct
	| X1 X2 P |
	X1 _ AffineVariety circle.
	X2 _ AffineVariety romanSurface.
	P _ X1 ◊ X2.
	self assert: (P apply: (P ambient projection: 1)) = X1.
	self assert: (P apply: (P ambient projection: 2)) = X2.
	self assert: X1 dimension + X2 dimension = P dimension.
	self assert: X1 ambient dimension + X2 ambient dimension = P ambient dimension.
	self assert: (X1 pointsCountOver: ZZ/3) * (X2 pointsCountOver: ZZ/3) = (P pointsCountOver: ZZ/3).
	self assert: (P satisfies: (5,2,6,2,6) % 7)! !

!AlgebraicGeometryTest methodsFor: 'affine' stamp: 'len 10/12/2016 20:56'!
testAffineSchemeCreation
	| A x y z X Y |
	A _ AffineSpace new: 3 over: QQ.
	x _ A coordinateRing x.
	y _ A coordinateRing y.
	z _ A coordinateRing z.
	X _ A subscheme: x - y.
	Y _ X subscheme: {x^2 - (z^3). y^3 - (z^4)}.
	self assert: X ambient = A.
	"Y is defined as subscheme of X, so it contains the equations of X plus the two new equations, but its ambient space is still A (not X):"
	self assert: Y ambient = A! !

!AlgebraicGeometryTest methodsFor: 'affine' stamp: 'len 10/18/2016 20:58'!
testAffineSpace
	| K A |
	K _ PrimeField new: 23.
	A _ AffineSpace new: 3 over: K.
	self assert: A dimension = 3.
	self assert: A scalars = K.
	self assert: A coordinateRing = (K polynomialsIn: 3).
	self assert: A ambient = A.
	self assert: A coordinateRing spec = A! !

!AlgebraicGeometryTest methodsFor: 'affine' stamp: 'len 1/12/2017 14:44:51'!
testProjectiveClosure
	"From Magma Handbook example Scheme_projective-closure (H118E23)."
	| A1 u v X PX X2 |
	A1 _ AffineSpace new: #(u v) over: ZZ/5.
	u _ A1 coordinateRing x: #u.
	v _ A1 coordinateRing x: #v.
	X _ A1 subscheme: u^2 - (v^5).
	PX _ X projectiveClosure.
	self assert: (PX patch: 3) = X.
	X2 _ PX patch: 2.
	self assert: X2 projectiveClosure = X projectiveClosure! !

!AlgebraicGeometryTest methodsFor: 'affine' stamp: 'len 11/1/2016 05:31'!
testProjectiveEmbedding
	| A1 u v X PX affinePointsEmbedded projectivePoints |
	A1 _ AffineSpace new: #(u v) over: ZZ/5.
	u _ A1 coordinateRing x: #u.
	v _ A1 coordinateRing x: #v.
	X _ A1 subscheme: u^2 - (v^5).
	PX _ X projectiveClosure.
	affinePointsEmbedded _ X points asSet apply: X projectiveEmbedding.
	projectivePoints _ PX points asSet.
	self assert: projectivePoints >= affinePointsEmbedded.
	"the projective scheme has one more point at infinity:"
	self assert: affinePointsEmbedded size + 1 = projectivePoints size! !

!AlgebraicGeometryTest methodsFor: 'conics' stamp: 'len 9/3/2018 21:55:50'!
testConicCoefficients
	self assert: (Conic coefficients: (1,2,3,4,5,6)) coefficients = (1,2,3,4,5,6).
	self assert: (Conic polynomial: (QQ polynomialsIn: 3) !! [:x :y :z| x^2 + (x*y*5) + (y^2) + (z^2)]) coefficients = (1,5,0,1,0,1)! !

!AlgebraicGeometryTest methodsFor: 'conics' stamp: 'len 9/3/2018 21:37:52'!
testConicDeterminant
	self assert: (Conic coefficients: (1,2,3,4,5,6)) determinant = (41/4)! !

!AlgebraicGeometryTest methodsFor: 'conics' stamp: 'len 9/3/2018 20:32:51'!
testConicIsSmooth
	self assert: (Conic coefficients: (1,-1,0)) isSmooth not.
	self assert: (Conic coefficients: (1,1,1,1,1,0) % 2) isSmooth! !

!AlgebraicGeometryTest methodsFor: 'general' stamp: 'len 1/12/2017 15:40:09'!
testDifference
	| A x y C X2 D O |
	A _ AffineSpace new: 2 over: QQ.
	x _ A coordinateRing x.
	y _ A coordinateRing y.
	C _ A subscheme: x * y. "union of x-axis and y-axis"
	X2 _ A subscheme: x^2. "y-axis with double multiplicity"
	D _ X2 - C. "y-axis with multiplicity 1"
	self assert: D ideal = (A coordinateRing * x).
	O _ A subscheme: {x. y}.
	D _ C - O.
	self assert: D = C.
	self assert: (C - A) isEmpty "removing the ambient space removes all"! !

!AlgebraicGeometryTest methodsFor: 'general' stamp: 'len 10/25/2016 14:09'!
testEllipticCurvesAreSmooth
	| R x y C |
	R _ QQ polynomialsIn: #(x y z).
	x _ R x.
	y _ R y.
	C _ R / (x^3 - (x*3) + 3 - (y^2) homogenizedIn: 3) :: proj.
	self assert: C isSmooth.
	C _ R / (x^3 + x - (y^2) homogenizedIn: 3) :: proj.
	self assert: C isSmooth.
	C _ R / (x^3 - x - (y^2) homogenizedIn: 3) :: proj.
	self assert: C isSmooth! !

!AlgebraicGeometryTest methodsFor: 'general' stamp: 'len 10/15/2016 09:59'!
testEmpty
	| A X |
	A _ QQ polynomialsIn: #(x y z).
	X _ A / {A continuantOfOrder: 2. A continuantOfOrder: 3} :: spec.
	self assert: X isEmpty! !

!AlgebraicGeometryTest methodsFor: 'general' stamp: 'len 3/7/2017 07:20:06'!
testEqualVarietiesDifferentIdeals
	| A x I I2 V V2 |
	A _ QQ polynomials.
	x _ A x.
	I _ A * {x}.
	I2 _ A * {x^2}.
	V _ I variety.
	V2 _ I2 variety.
	self assert: V = V2.
	self assert: I ~= I2! !

!AlgebraicGeometryTest methodsFor: 'general' stamp: 'len 3/7/2017 07:20:25'!
testEqualVarietiesDifferentIdeals2
	| A x y I I2 V V2 |
	A _ QQ polynomialsIn: #(x y).
	x _ A x.
	y _ A y.
	I _ A * {x. y}.
	I2 _ A * {x^2. y}.
	V _ I variety.
	V2 _ I2 variety.
	self assert: V = V2.
	self assert: I ~= I2! !

!AlgebraicGeometryTest methodsFor: 'general' stamp: 'len 10/15/2016 09:55'!
testFinite
	| A x y X |
	A _ QQ polynomialsIn: #(x y).
	x _ A x.
	y _ A y.
	X _ A / {x*x - 1. y*y - (x*x) - 3} :: spec.
	self assert: X isFinite! !

!AlgebraicGeometryTest methodsFor: 'general' stamp: 'len 5/10/2019 04:30:34'!
testIntersection
	| A x y V V2 W |
	A _ QQ polynomialsIn: #(x y).
	x _ A x.
	y _ A y.
	V _ A / {y} :: spec.
	V2 _ A / {x*x - 1} :: spec.
	W _ V /\ V2.
	self assert: (W satisfies: (1, 0)).
	self assert: (W satisfies: (0, 1)) not! !

!AlgebraicGeometryTest methodsFor: 'general' stamp: 'len 1/13/2017 17:29:15'!
testLinearSubspaceAsAlgebraicVariety
	| S V |
	S _ QQ ^ 3 grassmannian: 2 :: atRandomBits: 10.
	V _ S asAlgebraicVariety.
	self assert: V dimension + 1 = S dimension. "because it's projective"
	self assert: (V satisfies: (S e: 1)).
	self assert: (V satisfies: (S e: 2))! !

!AlgebraicGeometryTest methodsFor: 'general' stamp: 'len 7/1/2019 09:04:27'!
testLocalAndGlobalDimension
	"'A Singluar Introduction to Commutative Algebra', Example A.8.4 (local and global dimension)."
	| R I X |
	R _ QQ polynomialsIn: #(x y z).
	I _ R * (R generate: [:x :y :z| {x*z. y*z}]).
	X _ (R / I) spec.
	self assert: X dimension = 2. "global dimension of X"
	self assert: (X !! (0,0,0)) stalk dimension = 2. "dimension of X at (0,0,0)"
	self assert: (X !! (1,0,0)) stalk dimension = 2. "dimension of X at (1,0,0)"
	self assert: (X !! (0,0,1)) stalk dimension = 1. "dimension of X at (0,0,1)"! !

!AlgebraicGeometryTest methodsFor: 'general' stamp: 'len 6/10/2019 14:54:26'!
testMorphismsOfProjectiveVarieties
	"'A Singular Introduction To Commutative Algebra', Example A.6.8 (morphisms of projective varieties)."
	| P A x y z X f1 f2 f3 I J Y phi Z |
	P _ ProjectiveSpace new: #(x y z) over: CC. "å^2à"
	A _ P coordinateRing. "à[x,y,z]"
	x _ A x. y _ A y. z _ A z.
	X _ P subscheme: {z^3 - (x*(y^2)) + (y^3)}.
	f1 _ x*z. f2 _ x*y. f3 _ x^2 + (y*z).
	"In order for (f1,f2,f3) to define a projective morphism (not just a rational map) it must never be zero at any point of X, this means the intersection of X with V(J) must be empty:"
	I _ X ideal.
	J _ A * {f1. f2. f3}.
	self assert: (A / (I + J)) dimension = 0.
	Y _ P subscheme: J.
	self assert: (X /\ Y) isEmpty.
	phi _ X to: P representatives: {f1. f2. f3}.
	"The image is a curve of degree 6:"
	Z _ phi image.
	self assert: Z isCurve.
	self assert: Z degree = 6! !

!AlgebraicGeometryTest methodsFor: 'general' stamp: 'len 2/9/2017 11:13:57'!
testMultiplicity
	"Example from Sage documentation."
	| A X q1 q2 |
	A _ AffineSpace new: 4 over: QQ.
	X _ A subscheme: (A coordinateRing !! [:x :y :z :w| {z*y - (x^7). w - (2*z)}]).
	q1 _ X !! (1,(1/3),3,6).
	q2 _ X !! (0,0,0,0).
	self assert: q1 multiplicity = 1.
	self assert: q2 multiplicity = 2! !

!AlgebraicGeometryTest methodsFor: 'general' stamp: 'len 2/9/2017 11:20:49'!
testMultiplicity2
	"Example from Sage documentation."
	| P X q1 q2 q3 |
	P _ ProjectiveSpace new: 4 over: QQ.
	X _ P subscheme: (P coordinateRing !! [:x :y :z :w :t| {y^2 - (x*t). w^7 - (t*w*(x^5)) - (z^7)}]).
	q1 _ X !! (0,0,1,1,1).
	self assert: q1 multiplicity = 1.
	q2 _ X !! (1,0,0,0,0).
	self assert: q2 multiplicity = 3.
	q3 _ X !! (0,0,0,0,1).
	self assert: q3 multiplicity = 7! !

!AlgebraicGeometryTest methodsFor: 'general' stamp: 'len 2/10/2017 07:50:58'!
testMultiplicity3
	"Example from Sage documentation."
	| P X q |
	P _ ProjectiveSpace new: 3 over: CC.
	X _ P subscheme: (P coordinateRing !! [:x :y :z :w| z^5*(x^2)*w - (y^8)]).
	q _ X !! (2,0,0,1).
	self assert: q multiplicity = 5! !

!AlgebraicGeometryTest methodsFor: 'general' stamp: 'len 2/9/2017 10:26:45'!
testMultiplicityAndTangentCone
	"'A Singular Introduction to Commutative Algebra', Example A.8.5."
	| R C T p |
	R _ QQ polynomialsIn: #(x y).
	C _ (R / (R !! [:x :y| x^3 - y squared])) spec.
	p _ C !! (0,0).
	self assert: p multiplicity = 2.
	T _ (R / (R !! [:x :y| y^2])) spec.
	self assert: p tangentCone = T.
"	L _ (R / (R !! [:x :y| 100 atRandom * x + (100 atRandom * y)])) spec
	...
"! !

!AlgebraicGeometryTest methodsFor: 'general' stamp: 'len 10/15/2016 09:57'!
testNotEmpty
	| A x y X |
	A _ QQ polynomialsIn: #(x y).
	x _ A x.
	y _ A y.
	X _ A  / {x*x - 1. y*y - (x*x) - 3} :: spec.
	self assert: X isEmpty not! !

!AlgebraicGeometryTest methodsFor: 'general' stamp: 'len 10/15/2016 09:57'!
testNotFinite
	| A x y X |
	A _ QQ polynomialsIn: #(x y).
	x _ A x.
	y _ A y.
	X _ A / {y*y - (x*x) - 3} :: spec.
	self assert: X isFinite not! !

!AlgebraicGeometryTest methodsFor: 'general' stamp: 'len 10/31/2016 11:08'!
testReduced
	| A R x y z X |
	A _ AffineSpace new: 3 over: QQ.
	R _ A coordinateRing.
	x _ R x.
	y _ R y.
	z _ R z.
	X _ A subscheme: {x*(y^3). x^2*z}.
	self assert: X isReduced not.
	self assert: X reduced = (A subscheme: {x*y. x*z})! !

!AlgebraicGeometryTest methodsFor: 'general' stamp: 'len 9/28/2018 06:52:14'!
testRingHomomorphismSpec
	| A B x y phi |
	A _ QQ polynomialsIn: #(x y z).
	B _ QQ polynomialsIn: #(x y).
	x _ B x.
	y _ B y.
	phi _ A to: B evaluating: [:f| f value: {x-y. x. y}].
	self assert: phi spec domain = B spec.
	self assert: phi spec codomain = A spec.
	self assert: phi spec asRingMap = phi! !

!AlgebraicGeometryTest methodsFor: 'general' stamp: 'len 2/8/2017 07:14:15'!
testSingularCubics
	| R x y C |
	R _ QQ polynomialsIn: #(x y z).
	x _ R x.
	y _ R y.
	C _ R / (x^3 - (y^2) homogenizedIn: 3) :: proj.
	self assert: (C !! (1,1,1)) isSmooth.
	self assert: (C !! (0,0,1)) isSmooth not.
	self assert: C isSingular.
	C _ R / (x^3 + (x^2) - (y^2) homogenizedIn: 3) :: proj.
	self assert: C isSingular! !

!AlgebraicGeometryTest methodsFor: 'general' stamp: 'len 5/22/2018 22:36:55'!
testSmoothness
	| R C |
	R _ QQ polynomialsIn: #(x y).
	"cuspidal curve:"
	C _ (R / (R !! [:x :y| y^2 - (x^3)])) spec.
	self assert: C isSmooth not.
	self assert: C isSingular.
	self assert: (C !! (1,1)) isSmooth.
	self assert: (C !! (0,0)) isSmooth not! !

!AlgebraicGeometryTest methodsFor: 'general' stamp: 'len 5/22/2018 22:37:26'!
testSmoothnessOverCC
	| P R C |
	P _ ProjectiveSpace new: 2 over: CC.
	R _ P coordinateRing.
	C _ P subscheme: R !! [:x :y :z| x].
	self assert: C isSingular not.
	C _ P subscheme: R !! [:x :y :z| y^2*z - (x^3)].
	self assert: C isSingular.
	C _ P subscheme: R !! [:x :y :z| y^2*z - (x^3) + (z^3)].
	self assert: C isSingular not! !

!AlgebraicGeometryTest methodsFor: 'general' stamp: 'len 5/22/2018 22:38:05'!
testSmoothnessOverFiniteField
	| P R C |
	P _ ProjectiveSpace new: 2 over: ZZ/19.
	R _ P coordinateRing.
	C _ P subscheme: R !! [:x :y :z| x^3 + (y^3) + (z^3)].
	self assert: C isSingular not.
	C _ P subscheme: R !! [:x :y :z| x^4 - (x*(z^3))].
	self assert: C isSingular.
	C _ P subscheme: R !! [:x :y :z| x^5 + (y^5*19) + (z^5)].
	self assert: C isSingular.
	C _ P subscheme: R !! [:x :y :z| x^5 + (y^5*9) + (z^5)].
	self assert: C isSingular not! !

!AlgebraicGeometryTest methodsFor: 'general' stamp: 'len 5/22/2018 22:38:23'!
testSmoothnessOverQQ
	| P C |
	P _ ProjectiveSpace new: 2 over: QQ.
	C _ P subscheme: P coordinateRing !! [:x :y :z| x^3 - (y^2*z)].
	self assert: C isSingular! !

!AlgebraicGeometryTest methodsFor: 'general' stamp: 'len 1/13/2017 20:22:42'!
testSpecZ
	self assert: ZZ spec dimension = 1.
	self assert: ZZ spec isNoetherian.
	self assert: (ZZ spec includes: ZZ*5).
	self deny: (ZZ spec includes: ZZ*6).
	self assert: ZZ spec isInitial not.
	self assert: ZZ spec isTerminal! !

!AlgebraicGeometryTest methodsFor: 'general' stamp: 'len 5/10/2019 04:30:49'!
testSpecZSubschemes
	self assert: ZZ spec >= (ZZ / 2) spec.
	self assert: (ZZ / 10) spec >= (ZZ / 5) spec.
	self deny: (ZZ / 10) spec >= (ZZ / 3) spec.
	self assert: (ZZ / 10) spec /\ (ZZ / 15) spec = (ZZ / 5) spec.
	self assert: (ZZ / 10) spec \/ (ZZ / 15) spec = (ZZ / 30) spec! !

!AlgebraicGeometryTest methodsFor: 'finite rings' stamp: 'len 4/8/2018 18:14:45'!
testProjectiveLineOverFiniteRing
	| P |
	P _ ProjectiveLine over: ZZ/6.
	"P(Z/6Z) has 12 points: [0:1], [1:1], [2:1], [3:1], [4:1], [5:1], [1:2], [3:2], [5:2], [1:3], [2:3] and [1:0] (Henri Cohen, 'A Course in Computational Algebraic Number Theory', 478p)"
	self assert: P points size = 12.
	self assert: (Iterator on: P points performing: #do:) size = 12! !

!AlgebraicGeometryTest methodsFor: 'finite rings' stamp: 'len 9/16/2018 23:29:59'!
testProjectiveLineOverFiniteRing2AsDirectProduct
	| P |
	P _ ProjectiveLine over: ZZ/2 ◊ (ZZ/2). "isomorphic to ZZ/2[x]/<x(x+1)>"
	self assert: P points size = 9.
	self assert: (Iterator on: P points performing: #do:) size = 9! !

!AlgebraicGeometryTest methodsFor: 'finite rings' stamp: 'len 9/16/2018 23:30:04'!
testProjectiveLineOverFiniteRing2AsQuotient
	| R P |
	R _ (ZZ/2) polynomials.
	R _ R / (R x * (R x + 1)). "isomorphic to ZZ/2 ◊ (ZZ/2)"
	P _ ProjectiveLine over: R.
	self assert: P points size = 9.
	self assert: (Iterator on: P points performing: #do:) size = 9! !

!AlgebraicGeometryTest methodsFor: 'finite rings' stamp: 'len 4/8/2018 18:20:24'!
testProjectiveLineOverFiniteRing4
	| P |
	P _ ProjectiveLine over: ZZ/4 ◊ (ZZ/4).
	self assert: P points size = 36.
	self assert: (Iterator on: P points performing: #do:) size = 36! !

!AlgebraicGeometryTest methodsFor: 'finite rings' stamp: 'len 4/8/2018 18:50:19'!
testProjectiveLineOverFiniteRing5
	| P |
	P _ ProjectiveLine over: ZZ/2 ◊ (ZZ/2) ◊ (ZZ/2).
	self assert: P points size = 27.
	self assert: (Iterator on: P points performing: #do:) size = 27! !

!AlgebraicGeometryTest methodsFor: 'finite rings' stamp: 'len 5/3/2018 06:12:04'!
testProjectiveLineOverFiniteRing6
	| R P |
	R _ (ZZ/2) polynomials.
	R _ R / (R x^3 - R x).
	P _ ProjectiveLine over: R.
	self assert: P points size = 18.
	self assert: (Iterator on: P points performing: #do:) size = 18! !

!AlgebraicGeometryTest methodsFor: 'projective' stamp: 'len 2/3/2017 06:59:34'!
testProjectivePlaneCurveArithmeticGenus
	| R f C |
	R _  (ZZ/5) polynomialsIn: 3.
	f _ R !! [:x :y :z| y^2*(z^7) - (x^9) - (x*(z^8))].
	C _ ProjectivePlaneCurve polynomial: f.
	self assert: C arithmeticGenus = 28.
	"self assert: C genus = 4"! !

!AlgebraicGeometryTest methodsFor: 'projective' stamp: 'len 12/23/2016 09:30:59'!
testProjectivePlaneOverFiniteField
	| P |
	P _ ProjectiveSpace new: 2 over: ZZ/5.
	self assert: P points size = 31.
	self assert: (Iterator on: P points performing: #do:) size = 31! !

!AlgebraicGeometryTest methodsFor: 'projective' stamp: 'len 5/3/2018 05:26:14'!
testProjectivePlaneOverFiniteRing
	| P |
	P _ ProjectiveSpace new: 2 over: ZZ/4.
	self assert: P points size = 28
	"this plane has 28 points and 28 lines (falling into 7 neighbour classes of size 4), each line has 6 points and each point is on 6 lines"! !

!AlgebraicGeometryTest methodsFor: 'projective' stamp: 'len 1/12/2017 14:45:07'!
testProjectiveSchemeAffinePatches
	| E p a |
	E _ EllipticCurve cremona37a.
	p _ E !! (2,-3).
	a _ p dehomogenizedIn: 2.
	"the affine point is in the second standard affine patch:"
	self assert: (E patch: 2) == a codomain.
	"and when we homogenize again, the same projective embedding is used and come back to the same projective point on exactly the same projective curve:"
	self assert: a homogenized = p.
	self assert: a homogenized codomain == E! !

!AlgebraicGeometryTest methodsFor: 'projective' stamp: 'len 2/9/2017 10:51:38'!
testProjectiveSchemeDegree
	"Example from Sage documentation."
	| P X |
	P _ ProjectiveSpace new: 5 over: QQ.
	X _ P subscheme: (P coordinateRing !! [:x :y :z :w :t :u| x^7 + (x*y*z*(t^4)) - (u^7)]).
	self assert: X degree = 7! !

!AlgebraicGeometryTest methodsFor: 'projective' stamp: 'len 2/9/2017 10:53:18'!
testProjectiveSchemeDegree2
	"Example from Sage documentation."
	| P X |
	P _ ProjectiveSpace new: 3 over: ZZ/13.
	X _ P subscheme: (P coordinateRing !! [:x :y :z :w| {y^3 - (w^3). x + (7*z)}]).
	self assert: X degree = 3! !

!AlgebraicGeometryTest methodsFor: 'projective' stamp: 'len 2/9/2017 10:56:06'!
testProjectiveSchemeDegree3
	"Example from Sage documentation."
	| P X |
	P _ ProjectiveSpace new: 4 over: QQ.
	X _ P subscheme: (P coordinateRing !! [:x :y :z :w :u| {x^7 - (y*(z^3)*(w^2)*u). w*(z^2) - (y*(u^2)). z^3 + (y^3)}]).
	self assert: X degree = 63! !

!AlgebraicGeometryTest methodsFor: 'projective' stamp: 'len 10/18/2016 20:58'!
testProjectiveSpace
	| K P |
	K _ PrimeField new: 23.
	P _ ProjectiveSpace new: 3 over: K.
	self assert: P dimension = 3.
	self assert: P scalars = K.
	self assert: P coordinateRing = (K polynomialsIn: 4).
	self assert: P ambient = P.
	self assert: P coordinateRing proj = P! !

!AlgebraicGeometryTest methodsFor: 'projective' stamp: 'len 4/11/2018 16:40:04'!
testProjectiveSpaceOverFiniteField
	| P S |
	P _ ProjectiveSpace new: 1 over: ZZ/3.
	S _ P points.
	self assert: S size = 4.
	self assert: S asSet size = 4.
	S _ P pointsOver: (ZZ/3 extensionDegree: 2).
	self assert: S size = 10.
	self assert: S asSet size = 10! !

!AlgebraicGeometryTest methodsFor: 'projective' stamp: 'len 7/8/2019 13:37:55'!
testProjectiveSpaceOverModularIntegers
	| N n P numberOfPoints |
	N _ (2 to: 12) atRandom.
	n _ (1 to: 3) atRandom.
	P _ ProjectiveSpace new: n over: ZZ/N.
	"formula from Cohen's 'A course in computational algebraic number theory' page 486:"
	numberOfPoints _ N^n * (N factors asSet product: [:p| (0 to: n) sum: [:i| 1/(p^i)]]).
	self assert: P points asSet size = numberOfPoints.
	self assert: P points size = numberOfPoints! !

!AlgebraicGeometryTest methodsFor: 'rational maps' stamp: 'len 10/17/2016 11:30'!
testRationalMap
	"Example from Magma handbook Scheme_map-creation (H118E32)."
	| A1 A2 x y f X |
	A1 _ AffineSpace new: #(t) over: QQ.
	A2 _ AffineSpace new: #(x y) over: QQ.

	f _ A1 to: A2 evaluatingWithArguments: [:t| {t^3 + t. (t^2 - 3)}].

	self assert: f domain = A1.
	self assert: f codomain = A2.

	x _ A2 coordinateRing x.
	y _ A2 coordinateRing y.
	X _ A2 subscheme: {x^2*-1 + (y^3) + (y^2*11) + (y*40) + 48}.
	self assert: f image = X! !

!AlgebraicGeometryTest methodsFor: 'rational maps' stamp: 'len 10/17/2016 10:40'!
testRationalMap2
	"Example from Cox's IVA pag. 234. Parametrization of the tangent surface of the twisted cubic."
	| A2 A3 x y z f X |
	A2 _ AffineSpace new: #(t u) over: QQ.
	A3 _ AffineSpace new: 3 over: QQ.

	f _ A2 to: A3 evaluatingWithArguments: [:t :u| {t + u. t^2 + (t*u*2). t^3 + (t^2*u*3)}].

	x _ A3 coordinateRing x.
	y _ A3 coordinateRing y.
	z _ A3 coordinateRing z.
	X _ A3 subscheme: {x^3*z - (x*y^2*(3/4)) - (x*y*z*(3/2)) + (y^3) + (z^2*(1/4))}.
	self assert: f image = X! !

!AlgebraicGeometryTest methodsFor: 'rational maps' stamp: 'len 5/5/2019 18:29:43'!
testRationalMapAffineExample
	"From lecture notes MIT 18.782 Introduction to Arithmetic Geometry, Lecture #15, Fall 2013, 10/29/2013, Example 15.19."
	| A2 x y X A1 phi phi2 phiInv |
	A2 _ AffineSpace new: 2 over: CC.
	x _ A2 coordinateRing x.
	y _ A2 coordinateRing y.
	X _ A2 subscheme: x^2 + (y^2) - 1.
	A1 _ AffineSpace new: 1 over: CC.
	phi _ X to: A1 evaluatingWithArguments: [:x0 :y0| {y0 / (x0 + 1)}].
	phi2 _ X to: A1 evaluatingWithArguments: [:x0 :y0| {1 - x0 / y0}].
	self assert: phi = phi2.
	phiInv _ A1 to: X evaluatingWithArguments: [:t| {1 - (t^2) / (1 + (t^2)). t*2 / (1 + (t^2))}].
	self assert: (phi ∑ phiInv) isIdentity.
	self assert: phi isRegular not.
	self assert: phi isDominant.
"	self assert: phi isSurjective."
	self assert: phiInv isRegular not.
	self assert: phiInv isDominant.
"	self assert: phiInv isSurjective not"! !

!AlgebraicGeometryTest methodsFor: 'rational maps' stamp: 'len 5/22/2018 22:48:06'!
testRationalMapImage
	| A X X2 f |
	A _ AffineSpace new: #(x y) over: QQ.
	"circle centered at (0,0):"
	X _ A subscheme: A coordinateRing !! [:x :y| x^2 + (y^2) - 1].
	"circle centered at: (1,2):"
	X2 _ A subscheme: A coordinateRing !! [:x :y| (x-1)^2 + ((y-2)^2) - 1].
	"translation by (1,2):"
	f _ X to: A evaluatingWithArguments: [:x :y| {x+1. y+2}].
	self assert: f image = X2.
	"global translation by (1,2):"
	f _ A to: A evaluatingWithArguments: [:x :y| {x+1. y+2}].
	self assert: (X apply: f) = X2! !

!AlgebraicGeometryTest methodsFor: 'rational maps' stamp: 'len 4/19/2019 04:36:32'!
testRationalMapLinearMapConversion
	| A2 A3 V2 V3 f f2 p f3 |
	A2 _ AffineSpace new: 2 over: QQ.
	A3 _ AffineSpace new: 3 over: QQ.
	V2 _ QQ^2.
	V3 _ QQ^3.

	f _ V2 => V3 atRandomBits: 100.
	f2 _ A2 => A3 !! f.

	p _ V2 atRandomBits: 100.
	self assert: (f value: p) = (f2 value: p).

	f3 _ V2 => V3 !! f2.
	self assert: f = f3! !

!AlgebraicGeometryTest methodsFor: 'rational points' stamp: 'len 5/22/2018 22:36:45'!
testRationalPointsOverFiniteField
	| P C |
	P _ ProjectiveSpace new: 2 over: ZZ/7.
	C _ P subscheme: P coordinateRing !! [:x :y :z| x^3 + (y^3) - (z^3)].
	self assert: C points size = 9.
	self assert: (Iterator on: C points performing: #do:) size = 9! !

!AlgebraicGeometryTest methodsFor: 'rational points' stamp: 'len 5/10/2018 18:17:19'!
testSturmfelsExample1
	"Bernd Sturmfels, 'Ideals, Varieties and Macaulay 2', 1. A Curve in Affine 3-Space."
	| R x y I C C1 C2 |
	R _ QQ polynomialsIn: #(x y z). "default ordering is trevlex"
	x _ R x.
	y _ R y.
"	z _ R z."
	I _ R * {x^4 - (y^5). x^3 - (y^7)}.
	self assert: I groebnerBasis reduced printString = '{x^8 - x^3y^3, x^4y^2 - x^3, y^5 - x^4}'.
	C _ I variety.
	self assert: C dimension = 1.
	self assert: C codimension = 2.
	"The degree of a curve in complex affine 3-space is the number of intersection points with a general plane. It coincides with the degree of the projective closure of our curve:"
	self assert: C projectiveClosure degree = 28.
	"We first extract the components which are transverse to the plane x = 0:"
	C1 _ C \ (R / R x) spec.
	self assert: C1 = (R / {x*(y^2) - 1. y^5 - (x^4). x^5 - (y^3)}) spec.
	"And next we extract the component which lies in the clane x = 0:"
	C2 _ C - C1. "NOTE: the article uses ideal saturation, and this is colon"
	self assert: C2 = (R / {x^3. y^5}) spec.
	"self deny: C isReduced." "this fails!!!!!!"
	self assert: C1 projectiveClosure degree = 13.
	self assert: C1 isReduced "equivalent to C1 ideal = C1 ideal radical"! !

!AlgebraicGeometryTest methodsFor: 'rational points' stamp: 'len 5/10/2019 04:31:01'!
testSturmfelsExample2
	"Bernd Sturmfels, 'Ideals, Varieties and Macaulay 2', 2. Intersecting Our Curve With a Surface."
	| R x y z C S theirunion ourpoints |
	R _ QQ polynomialsIn: #(x y z). "default ordering is trevlex"
	x _ R x.
	y _ R y.
	z _ R z.
	C _ (R / {x^4 - (y^5). x^3 - (y^7)}) spec.
	C _ C \ (R / R x) spec. "this is C1 from example1"
	S _ (R / (x^5 + (y^5) + (z^5) - 1)) spec.
	theirunion _ C \/ S.
	"In this case, the union's ideal coincides with the product of the ideals:"
	self assert: theirunion ideal = (C ideal * S ideal).
	"The intersection of the curve and the surface (whose defining ideal is the sum of the respective ideals):"
	ourpoints _ C /\ S.
	"We get a finite set of points:"
	self assert: ourpoints dimension = 0.
	"The number of points is 65:"
	self assert: ourpoints projectiveClosure degree = 65.
	"Each of the points is multiplicity-free:"
	self assert: ourpoints isReduced. "equivalent to the original: ourpoints reduced projectiveClosure degree = 65."! !

!AlgebraicGeometryTest methodsFor: 'rational points' stamp: 'len 4/10/2018 15:45:55'!
testTwistedCubic
	| P R M C |
	P _ ProjectiveSpace new: 3 over: QQ.
	R _ P coordinateRing.
	"R indeterminateNames: #(u v w t)"
	M _ R matrix: (2@3) coefficients: ((1,2,3,2,3,4) collect: [:i| R x: i]).
	C _ P subscheme: (M minors: 2).
	self assert: C dimension = 1.
	self assert: C isSmooth! !

!AlgebraicGeometryTest methodsFor: 'rational points' stamp: 'len 2/4/2017 07:50:26'!
testTwistedCubicDegree
	"Twisted cubic in P^3 with homogeneous coordinates x,y,w,z."
	| A x y z w X |
	A _ QQ polynomialsIn: #(x y z w).
	x _ A x.
	y _ A y.
	z _ A z.
	w _ A x: #w.
	X _ A / {x^2 - (y*w). x*z - (y^2)} :: proj.
	"At this point X is still reducible, it is the union of a line x=y=0 and the twisted cubic:"
	self assert: X degree = 4.
	"To cut out X, we impose an additional equation x^3 - (z * (w^2)) = 0:"
	X _ A / {x^2 - (y*w). x*z - (y^2). x^3 - (z*(w^2))} :: proj.
	"But we get the twisted cubic (in some sense) 'counted with multiplicity 2', so the degree is 6"
	self assert: X degree = 6! !

!AlgebraicGeometryTest methodsFor: 'tangent cone' stamp: 'len 2/9/2017 10:27:04'!
testTangentCone
	"'A Singular Introduction to Commutative Algebra', Example 5.5.13."
	| R I J X |
	R _ QQ polynomialsIn: #(x y z).
	I _ R * (R !! [:x :y :z| {y*z + (z^2) + (x^3). y^2 + (x*z) + (y^4)}]).
	X _ (R/I) spec.
	J _ R * (R !! [:x :y :z| {y^2 + (x*z). y*z + (z^2). x*(z^2) - (y*(z^2))}]).
	self assert: (X !! (0,0,0)) tangentCone ideal = J! !

!AlgebraicGeometryTest methodsFor: 'tangent cone' stamp: 'len 2/14/2017 16:10:01'!
testTangentCone2
	"M. Kreuzer, 'Computational Commutative Algebra', Example 6.5.27."
	| R J T I |
	R _ QQ polynomialsIn: 4.
	J _ R * (R generate: [:x1 :x2 :x3 :x4| {x1*x2 - (x3^2). x2^2 - (x4^5)}]).
	T _ (R/J) spec tangentConeAt: (0,0,0,0).
	I _ R * (R generate: [:x1 :x2 :x3 :x4| {x1*x2 - (x3^2). x2^2. x2*(x3^2). x3^4}]).
	self assert: T ideal = I! !

!AlgebraicGeometryTest methodsFor: 'tangent cone' stamp: 'len 2/9/2017 10:35:41'!
testTangentConeAndTangentSpace
	"Example from https://en.wikipedia.org/wiki/Tangent_cone."
	| A x y S o |
	A _ AffineSpace new: #(x y) over: QQ.
	x _ A coordinateRing x.
	y _ A coordinateRing y.
	"this curve is singular at (0,0):"
	S _ A subscheme: x^2 + (x^3) - (y^2).
	o _ S !! (0,0).
	"the tangent cone is the union of the two lines x = y and x = -y:"
	self assert: o tangentCone = (A subscheme: (x + y) * (x - y)).
	"the tangent space is the whole plane:"
	self assert: o tangentSpace = A! !

!AlgebraicNumbersTest methodsFor: 'as yet unclassified' stamp: 'len 4/30/2018 05:39:40'!
testArithmetic
	| sqrt2 sqrt3 sqrt5 sqrt6 |
	sqrt2 _ ComplexAlgebraicNumber sqrt2.
	sqrt3 _ ComplexAlgebraicNumber sqrt: 3.
	sqrt5 _ ComplexAlgebraicNumber sqrt: 5.
	sqrt6 _ ComplexAlgebraicNumber sqrt: 6.
	self assert: sqrt2 squared = 2.
	self assert: (sqrt2 + sqrt3) * sqrt2 = (2 + sqrt6).
	self assert: (sqrt3 / sqrt5) squared reciprocal = (5/3).
"	self assert: (((5 root: 3) + sqrt2 - sqrt2) ^ 3) asRational = 5"! !

!AlgebraicNumbersTest methodsFor: 'as yet unclassified' stamp: 'len 4/30/2018 05:39:54'!
testDivision
	| sqrt3 sqrt5 |
	sqrt3 _ ComplexAlgebraicNumber sqrt: 3.
	sqrt5 _ ComplexAlgebraicNumber sqrt: 5.
	self assert: sqrt3 / sqrt5 / sqrt3 / sqrt5 = (1/5)! !

!AlgebraicNumbersTest methodsFor: 'as yet unclassified' stamp: 'len 4/29/2018 23:50:51'!
testMultiplicationByi
	| a |
	a _ ComplexAlgebraicNumber sqrt2.
	self assert: a i i = a negated! !

!AlgebraicNumbersTest methodsFor: 'as yet unclassified' stamp: 'len 4/30/2018 04:54:12'!
testNorm
	| a |
	a _ ComplexAlgebraicNumber phi.
	self assert: a norm = a conjugates product! !

!AlgebraicNumbersTest methodsFor: 'as yet unclassified' stamp: 'len 4/30/2018 05:40:10'!
testProduct
	| sqrt3 sqrt5 |
	sqrt3 _ ComplexAlgebraicNumber sqrt: 3.
	sqrt5 _ ComplexAlgebraicNumber sqrt: 5.
	self assert: sqrt3 * sqrt5 * sqrt3 * sqrt5 = 15! !

!AlgebraicNumbersTest methodsFor: 'as yet unclassified' stamp: 'len 4/29/2018 18:49:57'!
testRealArithmetic
	| sqrt2 sqrt3 sqrt5 sqrt6 |
	sqrt2 _ RealAlgebraicNumber sqrt2.
	sqrt3 _ RealAlgebraicNumber sqrt: 3.
	sqrt5 _ RealAlgebraicNumber sqrt: 5.
	sqrt6 _ RealAlgebraicNumber sqrt: 6.
	self assert: sqrt2 squared asRational = 2.
	self assert: (sqrt2 + sqrt3) * sqrt2 = (2 + sqrt6).
	self assert: (sqrt3 / sqrt5) squared reciprocal = (5/3).
"	self assert: (((five root: 3) + sqrt2 - sqrt2) ^ 3) asRational = 5"! !

!AlgebraicNumbersTest methodsFor: 'as yet unclassified' stamp: 'len 6/4/2016 21:59'!
testRealDivision
	| sqrt3 sqrt5 |
	sqrt3 _ RealAlgebraicNumber sqrt: 3.
	sqrt5 _ RealAlgebraicNumber sqrt: 5.
	self assert: (sqrt3 / sqrt5 / sqrt3 / sqrt5) asRational = (1/5)! !

!AlgebraicNumbersTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:55'!
testRealNormalizationBug
	| f interval x |
	x _ QQ polynomials x.
	f _ x^4 * 1576875 - (x^2 * 877250) + 43923.
	interval _ RealInterval open: (-260139/1345600) closed: (81631/134560).
	RealAlgebraicNumber polynomial: f bounds: interval! !

!AlgebraicNumbersTest methodsFor: 'as yet unclassified' stamp: 'len 6/4/2016 21:59'!
testRealProduct
	| sqrt3 sqrt5 |
	sqrt3 _ RealAlgebraicNumber sqrt: 3.
	sqrt5 _ RealAlgebraicNumber sqrt: 5.
	self assert: (sqrt3 * sqrt5 * sqrt3 * sqrt5) asRational = 15! !

!AlgebraicNumbersTest methodsFor: 'as yet unclassified' stamp: 'len 6/4/2016 21:59'!
testRealSquare
	| sqrt2 |
	sqrt2 _ RealAlgebraicNumber sqrt2.
	self assert: sqrt2 squared asRational = 2! !

!AlgebraicNumbersTest methodsFor: 'as yet unclassified' stamp: 'len 4/29/2018 18:48:17'!
testRealSquareRoot
	| a |
	a _ RealAlgebraicNumber sqrt2.
	self assert: a squareRoot squared = a! !

!AlgebraicNumbersTest methodsFor: 'as yet unclassified' stamp: 'len 6/4/2016 22:00'!
testRealSum
	| sqrt2 sqrt3 sqrt5 |
	sqrt2 _ RealAlgebraicNumber sqrt: 2.
	sqrt3 _ RealAlgebraicNumber sqrt: 3.
	sqrt5 _ RealAlgebraicNumber sqrt: 5.
	self assert: sqrt3 + sqrt5 + sqrt2 - sqrt3 - sqrt5 = sqrt2! !

!AlgebraicNumbersTest methodsFor: 'as yet unclassified' stamp: 'len 4/30/2018 05:40:24'!
testSquare
	| sqrt2 |
	sqrt2 _ ComplexAlgebraicNumber sqrt2.
	self assert: sqrt2 squared = 2! !

!AlgebraicNumbersTest methodsFor: 'as yet unclassified' stamp: 'len 4/29/2018 18:49:16'!
testSquareRoot
	| a |
	a _ ComplexAlgebraicNumber sqrt2.
	self assert: a squareRoot squared = a! !

!AlgebraicNumbersTest methodsFor: 'as yet unclassified' stamp: 'len 1/20/2018 19:18:17'!
testSum
	| sqrt2 sqrt3 sqrt5 |
	sqrt2 _ ComplexAlgebraicNumber sqrt: 2.
	sqrt3 _ ComplexAlgebraicNumber sqrt: 3.
	sqrt5 _ ComplexAlgebraicNumber sqrt: 5.
	self assert: sqrt3 + sqrt5 + sqrt2 - sqrt3 - sqrt5 = sqrt2! !

!AlgebraicNumbersTest methodsFor: 'as yet unclassified' stamp: 'len 4/30/2018 04:53:56'!
testTrace
	| a |
	a _ ComplexAlgebraicNumber phi.
	self assert: a trace = a conjugates sum! !

!CodesTest methodsFor: 'as yet unclassified' stamp: 'len 5/25/2018 18:42:02'!
testDual
	| C |
	C _ LinearCode subspace: (ZZ/2^5 span: {(0,0,0,0,0) % 2. (1,1,1,1,1) % 2}).
	self assert: C dual size = (C ambient size / C size).
	C dual do: [:v|
		"check each codeword of the dual has an even number of 1's, because it must be perpendicular to 11111 (and 00000 of course)."
		self assert: (v count: [:each| each = (1 % 2)]) even]
! !

!CodesTest methodsFor: 'as yet unclassified' stamp: 'len 1/23/2017 11:52:38'!
testGolay24
	| C W x y |
	C _ LinearCode G24.
	self assert: C isSelfDual.
	W _ C weightEnumerator.
	x _ W parent x.
	y _ W parent y.
	self assert: W = (x^24 + (x^16*(y^8)*759) + (x^12*(y^12)*2576) + (x^8*(y^16)*759) + (y^24)) "typo in neil's video 22:20"! !

!CodesTest methodsFor: 'as yet unclassified' stamp: 'len 5/12/2016 09:47'!
testHamming743
	| H7 |
	H7 _ LinearCode H7.
	self assert: H7 isCyclic.
	self assert: H7 minimumDistance = 3.
	self assert: H7 weightDistribution = #(0 3 3 3 3 3 3 3 4 4 4 4 4 4 4 7) asBag.
	self assert: H7 dual minimumDistance = 4! !

!CodesTest methodsFor: 'as yet unclassified' stamp: 'len 7/15/2016 18:24'!
testHamming844
	| C P x y |
	C _ LinearCode H8.
	self assert: C isSelfDual.
	self assert: C isSelfOrthogonal.
	self assert: C minimumDistance = 4.
	self assert: C dual minimumDistance = 4.
	P _ ZZ polynomialsIn: 2.
	x _ P x. y _ P y.
	self assert: C weightEnumerator = (x^8 + (x*y^4*14) + (y^8))! !

!CodesTest methodsFor: 'as yet unclassified' stamp: 'len 1/23/2017 11:52:21'!
testMacWilliamsTheorem
	"(MacWilliams, 1962) the theorem relates the weight enumerator of a linear code to the weight enumerator of its dual."
	"From youtube, Neil Sloane 'Error Correcting Codes, Group Theory and Invariant Theory, Part 1' 20:30."
	| C W Wperp x y |
	C _ LinearCode H7.
	W _ C weightEnumerator.
	Wperp _ C dual weightEnumerator.
	x _ Wperp parent x.
	y _ Wperp parent y.
	self assert: Wperp = ((W value: {x+y. x-y}) / C size)! !

!CodesTest methodsFor: 'as yet unclassified' stamp: 'len 5/12/2016 09:57'!
testParityCheckMatrix
	| H7 M |
	H7 _ LinearCode H7.
	M _ H7 parityCheckMatrix.
	self assert: (M * H7 atRandom) isZero! !

!CodesTest methodsFor: 'as yet unclassified' stamp: 'len 5/25/2018 18:40:58'!
testSelfDual
	| F C |
	F _ ZZ/2.
	"{00,11} is the smallest self-dual code"
	C _ LinearCode subspace: (F^2 span: {(0,0) % 2. (1,1) % 2}).
	self assert: C isSelfDual.
	self assert: C isSelfOrthogonal.
	"TODO: test other examples of self-dual codes: H8, G24"! !

!CodesTest methodsFor: 'as yet unclassified' stamp: 'len 5/12/2016 07:28'!
testSingletonBound: C
	"Any linear [n,k,d] code satisfies k + d <= n + 1."
	| n k d |
	n _ C length.
	k _ C rank.
	d _ C minimumDistance.
	self assert: k + d <= (n + 1).! !

!CodesTest methodsFor: 'as yet unclassified' stamp: 'len 5/12/2016 07:30'!
testSingletonBoundH7
	"Any linear [n,k,d] code satisfies k + d <= n + 1."
	self testSingletonBound: LinearCode H7! !

!CodesTest methodsFor: 'as yet unclassified' stamp: 'len 5/25/2018 18:40:31'!
testSingletonBoundTetracode
	"Any linear [n,k,d] code satisfies k + d <= n + 1."
	self testSingletonBound: LinearCode tetracode! !

!CodesTest methodsFor: 'as yet unclassified' stamp: 'len 11/6/2016 10:20'!
testTetracode
	| C P x y |
	C _ LinearCode subspace: (ZZ/3 ^ 4 span: {(1,1,1,0) % 3. (0,1,2,1) % 3}).
	self assert: C isSelfDual.
	self assert: C minimumDistance = 3.
	P _ ZZ polynomialsIn: #(x y).
	x _ P x.
	y _ P y.
	self assert: C weightEnumerator = (x^4 + (x*(y^3)*8))! !

!CodesTest methodsFor: 'as yet unclassified' stamp: 'len 5/25/2018 18:41:19'!
testWeightEnumerator
	"From youtube, Neil Sloane 'error correcting codes, group theory and invariant theory part 1' 19:30."
	| F C w x y |
	F _ ZZ/2.
	C _ LinearCode subspace: (F^5 span: {(0,0,0,0,0) % 2. (1,1,1,1,1) % 2}).
	w _ C weightEnumerator.
	x _ w parent x.
	y _ w parent y.
	self assert: w = (x^5 + (y^5)).
	self assert: C dual weightEnumerator = (x^5 + (x^3*(y^2)*10) + (y^4*x*5))! !

!CommutativeAlgebraTest methodsFor: 'affine ring' stamp: 'len 2/14/2017 08:11:31'!
testAffineRingElementOperations
	"Magma handbook example H105E1."
	| R A x y |
	R _ QQ polynomialsIn: #(x y).
	A _ R / (R generate: [:x1 :y1| {x1^2 - (y1^2) + 2. y1^3 - 5}]).
	x _ A x. y _ A y.
	self assert: x^2 = (y^2 - 2).
	"self assert: x reciprocal = ..."! !

!CommutativeAlgebraTest methodsFor: 'affine ring' stamp: 'len 2/28/2017 21:00:54'!
testAffineRingIdealIntersectionRandom
	| R f1 f2 J A |
	R _ QQ polynomialsIn: #(x y).
	[(f1 _ R atRandomBits: 10) isZero] whileTrue.
	[(f2 _ R atRandomBits: 10) isZero] whileTrue.
	J _ R * {f1. f2}.
	A _ R/J.
	self testIdealIntersectionRandom: A! !

!CommutativeAlgebraTest methodsFor: 'affine ring' stamp: 'len 2/23/2017 09:09:44'!
testAffineRingIdealMembershipRandom
	| R f1 f2 J A g I h |
	R _ QQ polynomialsIn: #(x y z).
	[(f1 _ R atRandomBits: 10) isZero] whileTrue.
	[(f2 _ R atRandomBits: 10) isZero] whileTrue.
	J _ R * {f1. f2}.
	A _ R/J.
	g _ A atRandomBits: 10.
	I _ A * g.
	h _ I atRandomBits: 10.
	self assert: (I includes: h)! !

!CommutativeAlgebraTest methodsFor: 'affine ring' stamp: 'len 2/23/2017 09:02:17'!
testAffineRingIdealOperations
	"Magma handbook, example H105E2."
	| R A I J |
	R _ QQ polynomialsIn: #(x y z) "ordering: #lex".
	A _ R / (R generate: [:x :y :z| {x^2 - y + 1. y^3 + z - 1}]).
	I _ A * (A generate: [:x :y :z| x^3*y*(z^2)]).
	self deny: I isRadical.
	J _ A * (A generate: [:x :y :z| {x*(y^2) + (x*y) - (x*z) + x. y*z. z^2 - z}]).
	self assert: I radical = J. "this fails probably because PolynomialIdeal>>radical is broken"
	"... and then some tests of primary decomposition"! !

!CommutativeAlgebraTest methodsFor: 'division and normal forms' stamp: 'len 2/12/2017 12:36:37'!
testBuchbergerNormalForm
	"A Singular Introduction to Commutative Algebra, Example 1.6.12."
	| R x y z f G h |
	R _ QQ polynomialsIn: #(x y z) ordering: #glex.
	x _ R x. y _ R y. z _ R z.
	f _ x^3 + (y^2) + (z^2*2) + x + y + 1.
	G _ GroebnerBasis new add: R x; add: R y; yourself.
	h _ G reduce: f.
	self assert: h = (z^2*2 + x + y + 1).
	h _ G reduceFull: f.
	self assert: h = (z^2 + (1/2))! !

!CommutativeAlgebraTest methodsFor: 'division and normal forms' stamp: 'len 2/12/2017 06:02:55'!
testMoraNormalForm
	"A Singular Introduction to Commutative Algebra, Example 1.7.7."
	| R f G h |
	R _ QQ polynomialsIn: #(x y z) ordering: #lgrevlex.
	f _ R !! [:x :y :z| x^2 + (y^2) + (z^3) + (x^4) + (y^5)].
	G _ StandardBasis new add: R x; add: R y; yourself.
	h _ G reduce: f.
	self assert: h = (R !! [:x :y :z| z^3 + (x^4) + (y^5)])! !

!CommutativeAlgebraTest methodsFor: 'division and normal forms' stamp: 'len 4/24/2018 19:38:02'!
testMultivariateDivisionExample
	| P x y z F f |
	P _ QQ polynomialsIn: #(x y z) ordering: #glex.
	x _ P x.
	y _ P y.
	z _ P z.
	F _ {x^2 - (y*z). y^2 - (z*x). z^2 - (x*y)}.
	f _ x^3 + (y^3 * 3).
	self assert: (f divisionBy: F) remainder = (y^3 * 4)! !

!CommutativeAlgebraTest methodsFor: 'division and normal forms' stamp: 'len 5/10/2018 07:34:34'!
testMultivariateDivisionExample2
	| R f f1 f2 |
	R _ QQ polynomialsIn: #(x y z) ordering: #lex.
	f _ R !! [:x :y :z| x^5*(y^3)].
	f1 _ R !! [:x :y :z| x^3*(y^2) - ((y^2)*z)].
	f2 _ R !! [:x :y :z| x*(y^2) - (y*z)].
	self assert: (f divisionBy: {f1. f2}) printString = 'x^5y^3 = (x^2y)(x^3y^2 - y^2z) + (xyz + z^2)(xy^2 - yz) + yz^3'! !

!CommutativeAlgebraTest methodsFor: 'division and normal forms' stamp: 'len 5/10/2018 07:37:43'!
testMultivariateDivisionExample3
	| R f f1 f2 |
	R _ QQ polynomialsIn: #(x y z) ordering: #lex.
	f _ R !! [:x :y :z| x^3*(y^2) + (x*y) + x + 1].
	f1 _ R !! [:x :y :z| x^3 + 1].
	f2 _ R !! [:x :y :z| y^2 + 1].
	self assert: (f divisionBy: {f1. f2}) printString = 'x^3y^2 + xy + x + 1 = (y^2)(x^3 + 1) + (-1)(y^2 + 1) + xy + x + 2'! !

!CommutativeAlgebraTest methodsFor: 'division and normal forms' stamp: 'len 5/10/2018 07:44:11'!
testMultivariateDivisionExample4
	| R f f1 f2 |
	R _ QQ polynomialsIn: #(x y) ordering: #lex.
	f _ R !! [:x :y| x^2*(y^3) - (x*(y^2)*2)].
	f1 _ R !! [:x :y| x^2*y - (x*2)].
	f2 _ R !! [:x :y| y^3 + 4].
	self assert: (f divisionBy: {f1. f2}) printString = 'x^2y^3 - 2xy^2 = (y^2)(x^2y - 2x) + (0)(y^3 + 4) + 0'.
	self assert: (f divisionBy: {f2. f1}) printString = 'x^2y^3 - 2xy^2 = (x^2)(y^3 + 4) + (0)(x^2y - 2x) + -4x^2 - 2xy^2'! !

!CommutativeAlgebraTest methodsFor: 'testing examples' stamp: 'len 5/12/2018 17:05:01'!
testCyclic7Correctness
	"Test correctness of the ideal of cyclic 7-roots checking against one generated by Singular."
	| txt |
	txt _ ((QQ polynomialsIn: 7) cyclicIdeal generators sorted: [:a :b| a leadingMonomial >= b leadingMonomial]) printString.
	#('(' ')' '{' '}' ' ') do: [:each| txt _ txt copyReplaceAll: each with: ''].
	self assert: txt = 'x1x2x3x4x5x6x7-1,x1x2x3x4x5x6+x1x2x3x4x5x7+x1x2x3x4x6x7+x1x2x3x5x6x7+x1x2x4x5x6x7+x1x3x4x5x6x7+x2x3x4x5x6x7,x1x2x3x4x5+x2x3x4x5x6+x1x2x3x4x7+x1x2x3x6x7+x1x2x5x6x7+x1x4x5x6x7+x3x4x5x6x7,x1x2x3x4+x2x3x4x5+x3x4x5x6+x1x2x3x7+x1x2x6x7+x1x5x6x7+x4x5x6x7,x1x2x3+x2x3x4+x3x4x5+x4x5x6+x1x2x7+x1x6x7+x5x6x7,x1x2+x2x3+x3x4+x4x5+x5x6+x1x7+x6x7,x1+x2+x3+x4+x5+x6+x7'! !

!CommutativeAlgebraTest methodsFor: 'testing examples' stamp: 'len 5/12/2018 17:14:04'!
testKatsura7Correctness
	"Test correctness of Katsura-7 ideal checking against one generated by Singular."
	| txt |
	txt _ ((QQ polynomialsIn: 7) katsuraIdeal generators sorted: [:a :b| a leadingMonomial >= b leadingMonomial]) printString.
	#('(' ')' '{' '}' ' ') do: [:each| txt _ txt copyReplaceAll: each with: ''].
	self assert: txt = 'x1^2+2x2^2+2x3^2+2x4^2+2x5^2+2x6^2+2x7^2-x1,2x1x2+2x2x3+2x3x4+2x4x5+2x5x6+2x6x7-x2,x2^2+2x1x3+2x2x4+2x3x5+2x4x6+2x5x7-x3,2x2x3+2x1x4+2x2x5+2x3x6+2x4x7-x4,x3^2+2x2x4+2x1x5+2x2x6+2x3x7-x5,2x3x4+2x2x5+2x1x6+2x2x7-x6,x1+2x2+2x3+2x4+2x5+2x6+2x7-1'! !

!CommutativeAlgebraTest methodsFor: 'algorithms' stamp: 'len 5/12/2018 18:22:29'!
testExtendedBuchberger
	| I algorithm G G2 |
	I _ (QQ polynomialsIn: #(a b c d)) cyclicIdeal.
	I _ I orderedBy: #grevlex.
	G _ (algorithm _ ExtendedBuchberger on: I) basis.
	self assert: algorithm verify.
	self assert: G verify.
	G2 _ (Buchberger on: I) basis.
	self assert: G reduced = G2 reduced.
	self assert: algorithm matrix * (I scalars tuple: I generators) = (I scalars tuple: G)! !

!CommutativeAlgebraTest methodsFor: 'groebner' stamp: 'len 5/10/2018 07:53:18'!
testGroebnerBasis: G ideal: I
	"Test G is a Groebner basis of the ideal I."
	| g division |
	self assert: G verify.
	I generators do: [:each| self assert: (G reduces: each)].
	G do: [:each| self assert: (I includes: each)]. "but this will use Groebner bases.."
	g _ I atRandomBits: 200.
	self assert: (G reduces: g).
	"The leading term of any polynomial in I is divisible by the leading term of some polynomial in G:"
	self assert: (G anySatisfy: [:any| any leadingMonomial | g leadingMonomial]).
	"The multivariate division of any polynomial in I by G gives the remainder 0:"
	division _ g divisionBy: G.
	self assert: division remainder isZero.
	self assert: division verify.
	self assert: G reduced isReduced.
	self assert: G minimal isMinimal! !

!CommutativeAlgebraTest methodsFor: 'groebner' stamp: 'len 5/12/2018 17:05:15'!
testGroebnerCyclic3
	| I G |
	I _ (QQ polynomialsIn: 3) cyclicIdeal.
	G _ I groebnerBasis.
	self testGroebnerBasis: G ideal: I! !

!CommutativeAlgebraTest methodsFor: 'groebner' stamp: 'len 5/12/2018 17:05:49'!
testGroebnerCyclic3Lexicographic
	| I G |
	I _ (QQ polynomialsIn: 3 ordering: #lex) cyclicIdeal.
	G _ I basis.
	self testGroebnerBasis: G ideal: I! !

!CommutativeAlgebraTest methodsFor: 'groebner' stamp: 'len 5/12/2018 17:01:00'!
testGroebnerCyclic3OverZ2
	| I G |
	I _ (ZZ/2 polynomialsIn: 3) cyclicIdeal.
	G _ I groebnerBasis.
	self testGroebnerBasis: G ideal: I! !

!CommutativeAlgebraTest methodsFor: 'groebner' stamp: 'len 5/12/2018 17:06:23'!
testGroebnerCyclic3Reduced
	| I G |
	I _ (QQ polynomialsIn: #(x y z)) cyclicIdeal.
	I _ I orderedBy: #lex.
	G _ I basis reduced.
	self assert: G printString = '{x + y + z, y^2 + yz + z^2, z^3 - 1}' 
! !

!CommutativeAlgebraTest methodsFor: 'groebner' stamp: 'len 5/12/2018 17:06:47'!
testGroebnerCyclic3TotalLexicographic
	| I G |
	I _ (QQ polynomialsIn: 3 ordering: #glex) cyclicIdeal.
	G _ I basis.
	self testGroebnerBasis: G ideal: I! !

!CommutativeAlgebraTest methodsFor: 'groebner' stamp: 'len 5/12/2018 17:07:21'!
testGroebnerCyclic3TotalReverseLexicographic
	| I G |
	I _ (QQ polynomialsIn: 3 ordering: #grevlex) cyclicIdeal.
	G _ I basis.
	self testGroebnerBasis: G ideal: I! !

!CommutativeAlgebraTest methodsFor: 'groebner' stamp: 'len 5/12/2018 17:07:41'!
testGroebnerCyclic4
	| I G |
	I _ (QQ polynomialsIn: 4) cyclicIdeal.
	G _ I groebnerBasis.
	self testGroebnerBasis: G ideal: I! !

!CommutativeAlgebraTest methodsFor: 'groebner' stamp: 'len 5/12/2018 17:01:24'!
testGroebnerCyclic4OverZ127
	| I G |
	I _ (ZZ/127 polynomialsIn: 4) cyclicIdeal.
	G _ I groebnerBasis.
	self testGroebnerBasis: G ideal: I! !

!CommutativeAlgebraTest methodsFor: 'groebner' stamp: 'len 5/12/2018 17:01:54'!
testGroebnerCyclic4OverZ2
	| I G |
	I _ (ZZ/2 polynomialsIn: 4) cyclicIdeal.
	G _ I groebnerBasis.
	self testGroebnerBasis: G ideal: I! !

!CommutativeAlgebraTest methodsFor: 'groebner' stamp: 'len 5/12/2018 17:08:02'!
testGroebnerCyclic5
	| I G |
	I _ (QQ polynomialsIn: 5) cyclicIdeal.
	G _ I groebnerBasis.
	self testGroebnerBasis: G ideal: I! !

!CommutativeAlgebraTest methodsFor: 'groebner' stamp: 'len 5/12/2018 17:02:43'!
testGroebnerCyclic5OverZ127
	| I G |
	I _ (ZZ/127 polynomialsIn: 5) cyclicIdeal.
	G _ I groebnerBasis.
	self testGroebnerBasis: G ideal: I! !

!CommutativeAlgebraTest methodsFor: 'groebner' stamp: 'len 5/12/2018 17:02:57'!
testGroebnerCyclic5OverZ2
	| I G |
	I _ (ZZ/2 polynomialsIn: 5) cyclicIdeal.
	G _ I groebnerBasis.
	self testGroebnerBasis: G ideal: I! !

!CommutativeAlgebraTest methodsFor: 'groebner' stamp: 'len 5/12/2018 17:08:16'!
testGroebnerCyclic5Reduced
	| I G |
	I _ (QQ polynomialsIn: 5) cyclicIdeal.
	G _ I groebnerBasis reduced.
	self assert: G isReduced.
	self testGroebnerBasis: G ideal: I.
	self assert: (I scalars * G) groebnerBasis reduced = G! !

!CommutativeAlgebraTest methodsFor: 'groebner' stamp: 'len 5/8/2018 00:19:11'!
testGroebnerExample
	| P x y z I G |
	P _ QQ polynomialsIn: #(x y z) ordering: #lex.
	x _ P x.
	y _ P y.
	z _ P z.
	I _ P * {x^2 - (y*z). y^2 - (z*x). z^2 - (x*y)}.
	G _ I basis minimal.
	self assert: G asSet = {x^2 - (y*z). x*z - (y^2). x*y - (z^2). y^3 - (z^3)} asSet! !

!CommutativeAlgebraTest methodsFor: 'groebner' stamp: 'len 5/9/2018 19:10:45'!
testGroebnerExample2
	| R x y f1 f2 I G |
	R _ QQ polynomialsIn: #(x y) ordering: #lex.
	x _ R x.
	y _ R y.
	f1 _ (x-1)^2 + (y-2^2) - (3^2).
	f2 _ (x+1)^2 + (y-1^2) - (2^2).
	I _ R * {f1. f2}.
	G _ I basis reduced.
	self assert: G printString = '{x + (1/2)y + (1/2), y^2 - 2y - (11/5)}' ! !

!CommutativeAlgebraTest methodsFor: 'groebner' stamp: 'len 5/10/2018 18:11:03'!
testGroebnerExample3
	"From some question in math.stackexchange.com."
	| R I G |
	R _ QQ polynomialsIn: #(x y) ordering: #glex.
	I _ R * (R !! [:x :y| {x^2*y + x + 1. x*(y^2) + y + 1. x - y}]).
	G _ I basis reduced.
	self assert: G printString = '{y^3 + y + 1, x - y}' "this is as computed by Singular"! !

!CommutativeAlgebraTest methodsFor: 'groebner' stamp: 'len 5/10/2018 17:31:08'!
testGroebnerExample4Minimal
	"Example from Cox, Little, O'Shea, 'Ideals, Varieties and Algorithms', p. 90, continued in p. 93."
	| R I G |
	R _ QQ polynomialsIn: #(x y) ordering: #grevlex.
	I _ R * (R !! [:x :y| {x^3 - (x*y*2). x^2*y - (y^2*2) + x}]).
	G _ I basis minimal.
	self assert: G printString = '{x^2, xy, y^2 - (1/2)x}' 
! !

!CommutativeAlgebraTest methodsFor: 'groebner' stamp: 'len 5/12/2018 17:13:31'!
testGroebnerKatsura2
	| I G |
	I _ (QQ polynomialsIn: 2) katsuraIdeal.
	G _ I groebnerBasis.
	self testGroebnerBasis: G ideal: I! !

!CommutativeAlgebraTest methodsFor: 'groebner' stamp: 'len 5/12/2018 17:13:45'!
testGroebnerKatsura3
	| I G |
	I _ (QQ polynomialsIn: 3) katsuraIdeal.
	G _ I groebnerBasis.
	self testGroebnerBasis: G ideal: I! !

!CommutativeAlgebraTest methodsFor: 'groebner' stamp: 'len 8/26/2016 05:56'!
testGroebnerTrivial
	"The 3 polynomials have no common zeroes, the Groebner basis should be {1}."
	| Qx x y I |
	Qx _ QQ polynomialsIn: #(x y) ordering: #lex.
	x _ Qx x.
	y _ Qx y.
	I _ Qx * {x + y. x^2 - 1. y^2 - (x*2)}.
	self assert: I groebnerBasis minimal isTrivial! !

!CommutativeAlgebraTest methodsFor: 'hilbert series' stamp: 'len 10/27/2016 18:43'!
testHilbertSeriesOfPolynomialIdeal
	"Derksen, Kemper 'Computational Invariant Theory', Example 1.4.9."
	| t R x y z w I H |
	t _ QQ polynomials fractions x.
	R _ QQ polynomialsIn: #(x y z w) "ordering: #lex".
	x _ R x.
	y _ R y.
	z _ R z.
	w _ R x: 4.
	I _ R * {x*z - (y^2). x*w - (y*z). y*w - (z^2)}.
	H _ I hilbertSeriesAt: t.
	self assert: H = (t^2 * 3 - (t^3 * 2) / ((1 - t) ^ 4))! !

!CommutativeAlgebraTest methodsFor: 'hilbert series' stamp: 'len 10/27/2016 18:47'!
testHilbertSeriesOfPolynomialQuotient
	"Derksen, Kemper 'Computational Invariant Theory', Example 1.4.9."
	| t R x y z w I H |
	t _ QQ polynomials fractions x.
	R _ QQ polynomialsIn: #(x y z w) "ordering: #lex".
	x _ R x.
	y _ R y.
	z _ R z.
	w _ R x: 4.
	I _ R * {x*z - (y^2). x*w - (y*z). y*w - (z^2)}.
	H _ (R/I) hilbertSeriesAt: t.
	self assert: H = (1 + (2*t) / (1 - t) squared)! !

!CommutativeAlgebraTest methodsFor: 'hilbert series' stamp: 'len 2/4/2017 07:57:44'!
testHilbertSeriesOfPolynomialQuotient2
	"Derksen, Kemper 'Computational Invariant Theory', Example 1.4.9."
	| t R x y z w I H dim deg |
	t _ QQ polynomials fractions x.
	R _ QQ polynomialsIn: #(x y z w).
	x _ R x.
	y _ R y.
	z _ R z.
	w _ R x: 4.
	I _ R * {x*z - (y^2). x*w - (y*z). y*w - (z^2)}.
	H _ (R/I) hilbertSeriesAt: t.
	dim _ (H orderAt: 1) negated.
	self assert: (R/I) dimension = dim.
	deg _ H * ((1 - H numerator parent x) ^ dim) value: 1. "should be limit from below"
	self assert: (R/I) degree = deg! !

!CommutativeAlgebraTest methodsFor: 'hilbert series' stamp: 'len 10/27/2016 18:41'!
testHilbertSeriesOfPolynomialRing
	| t R H |
	t _ QQ polynomials fractions x.
	R _ QQ polynomialsIn: 4.
	H _ R hilbertSeriesAt: t.
	self assert: H = ((1 - t) ^ -4)! !

!CommutativeAlgebraTest methodsFor: 'ideal operations' stamp: 'len 6/10/2019 13:39:52'!
testIdealColon
	| R x y z I J |
	R _ QQ polynomialsIn: #(x y z).
	x _ R x.
	y _ R y.
	z _ R z.
	I _ R * {x*y - 1. x^3*(z^2) - (y^2). x*(z^3) - x - 1}.
"	J _ R * {x*y - 1. x^2*z - y. x*(z^3) - x - 1}."
	self assert: I : R asIdeal = I.
	self assert: R asIdeal : I = R asIdeal.
	J _ R * {I atRandomBits: 10. I atRandomBits: 10}. "J <= I"
	self assert: I : J = R asIdeal! !

!CommutativeAlgebraTest methodsFor: 'ideal operations' stamp: 'len 6/10/2019 13:40:53'!
testIdealColon2
	"Example from Cox IVA 205p."
	| R x y z I J Q |
	R _ QQ polynomialsIn: #(x y z).
	x _ R x.
	y _ R y.
	z _ R z.
	I _ R * {x*z - (y^2). x^3 - (y*z)}.
	J _ R * {x. y}.
	Q _ I : J.
	self assert: Q = (I : (R * x) /\ (I : (R * y))).
	self assert: Q = (R * {x*z - (y^2). x^3 - (y*z). x^2*y - (z^2)})! !

!CommutativeAlgebraTest methodsFor: 'ideal operations' stamp: 'len 10/30/2016 15:17'!
testIdealElimination
	"Example from Cox IVA 123 p. NOTE: this is a little slow."
	| Qx x y z I |
	Qx _ QQ polynomialsIn: #(x y z).
	x _ Qx x. y _ Qx y. z _ Qx z.
	I _ Qx * {x^2 + y + z - 1. x + (y^2) + z - 1. x + y + (z^2) - 1}.
	self assert: (I eliminateAll: #(1 2)) generator = (z^6 - (z^4*4) + (z^3*4) - (z^2))! !

!CommutativeAlgebraTest methodsFor: 'ideal operations' stamp: 'len 5/9/2018 18:44:12'!
testIdealEqualsUnitIdeal
	| R x y I |
	R _ ZZ/7 polynomialsIn: #(x y) ordering: #glex.
	x _ R x.
	y _ R y.
	I _ R * {x + 1. x - 1. y - 2}.
	self assert: I = R oneIdeal! !

!CommutativeAlgebraTest methodsFor: 'ideal operations' stamp: 'len 8/26/2016 05:56'!
testIdealHomogenization
	"The homogenization of an ideal can be bigger than the ideal generated by the homogenized generators."
	| Qx x y z f1 f2 I f3 J |
	Qx _ QQ polynomialsIn: #(x y z).
	x _ Qx x.
	y _ Qx y.
	z _ Qx z.
	"Ideal for the twisted cubic:"
	f1 _ y - (x^2).
	f2 _ z - (x^3).
	I _ Qx * {f1. f2}.
	"Now a polynomial in I:"
	f3 _ f2 - (f1*x).
	self assert: (I homogenized includes: f3 homogenized).
	"But it's not in the ideal generated by the homogenized generators:"
	J _ Qx * {f1 homogenized. f2 homogenized}.
	self deny: (J includes: f3 homogenized)! !

!CommutativeAlgebraTest methodsFor: 'ideal operations' stamp: 'len 5/10/2019 04:31:24'!
testIdealIntersection
	"Example from Cox IVA 194 p."
	| Qxy x y I J K |
	Qxy _ QQ polynomialsIn: #(x y).
	x _ Qxy x.
	y _ Qxy y.
	I _ Qxy * {x^2 * y}.
	J _ Qxy * {x * (y^2)}.
	K _ Qxy * {x^2*(y^2)}.
	self assert: I /\ J = K! !

!CommutativeAlgebraTest methodsFor: 'ideal operations' stamp: 'len 2/23/2017 09:09:12'!
testIdealIntersectionRandom
	self testIdealIntersectionRandom: (QQ polynomialsIn: #(x y))! !

!CommutativeAlgebraTest methodsFor: 'ideal operations' stamp: 'len 5/10/2019 04:31:29'!
testIdealIntersectionRandom: aRing
	| R f1 f2 g I J K |
	R _ aRing.
	f1 _ R atRandomBits: 10.
	f2 _ R atRandomBits: 10.
	g _ R atRandomBits: 10.
	I _ R * {f1. g}.
	J _ R * {f2. g}.
	K _ R * {g}.
	self assert: I /\ J >= K! !

!CommutativeAlgebraTest methodsFor: 'ideal operations' stamp: 'len 8/26/2016 19:31'!
testIdealIsPrime
	| R x y I |
	R _ QQ polynomialsIn: #(x y).
	x _ R x: #x.
	y _ R x: #y.
	I _ R * {x^2 - (y^2) - 1}.
	self assert: I isPrime! !

!CommutativeAlgebraTest methodsFor: 'ideal operations' stamp: 'len 6/9/2019 12:14:58'!
testIdealIsRadical
	"Becker, Weispfenning, 'Groebner Bases', Exercise 8.21."
	| R x y I |
	R _ QQ polynomialsIn: #(x y).
	x _ R x: #x.
	y _ R x: #y.
	I _ R * {x^2 + y. y^2 + x}.
	self assert: (R / I) dimension = 0.
	self assert: I isRadical! !

!CommutativeAlgebraTest methodsFor: 'ideal operations' stamp: 'len 8/26/2016 05:56'!
testIdealMembership
	| Qxy x y f g I J h k |
	Qxy _ QQ polynomialsIn: #(x y).
	x _ Qxy x.
	y _ Qxy y.
	f _ x^2 - y.
	g _ x^3 - x.
	I _ Qxy * {f. g}.
	J _ Qxy * {x^2. y^3}.
	h _ y^2 - y.
	k _ x*y - x.
	self assert: (I includes: h).
	self assert: (I includes: k).
	self assert: (J includes: h) not.
	self assert: (J includes: k) not! !

!CommutativeAlgebraTest methodsFor: 'ideal operations' stamp: 'len 8/26/2016 05:56'!
testIdealMembership2
	| Qxy x y I |
	Qxy _ QQ polynomialsIn: #(x y).
	x _ Qxy x.
	y _ Qxy y.
	I _ Qxy * {x*x. y*2 + x}.
	self assert: (I includes: (x + y) squared)! !

!CommutativeAlgebraTest methodsFor: 'ideal operations' stamp: 'len 8/26/2016 05:56'!
testIdealMembership3
	| Qx x y z w f g I |
	Qx _ QQ polynomialsIn: #(x y z w).
	x _ Qx x.
	y _ Qx y.
	z _ Qx z.
	w _ Qx x: #w.
	f _ x*z-(y^2). "twisted cubic"
	g _ z*(y*w-(z^2)) - (w*(x*w-(y*z))).
	I _ Qx * {f. g}.
	"The twisted cubic C in P^3 is the set-theoretic complete intersection
	of f=0 and g=0, but not a scheme-theoretic or ideal-theoretic complete
	intersection (the ideal is not radical since includes f^2):"
	self assert: (I includes: f^2)! !

!CommutativeAlgebraTest methodsFor: 'ideal operations' stamp: 'len 5/9/2018 18:40:38'!
testIdealMembership4
	| R x y z I |
	R _ ZZ/127 polynomialsIn: #(x y z) ordering: #glex.
	x _ R x.
	y _ R y.
	z _ R z.
	I _ R * {x*y + z. y^3 + 1. z^2 - (x*5) - 1}.
	self assert: (I includes: (x*y + z) + (y^3 + 1)).
	self assert: (I includes: x*z*(z^2 - (x*5) - 1))! !

!CommutativeAlgebraTest methodsFor: 'ideal operations' stamp: 'len 5/9/2018 18:42:29'!
testIdealMembership5
	| R x y I |
	R _ ZZ/7 polynomialsIn: #(x y) ordering: #glex.
	x _ R x.
	y _ R y.
	I _ R * {x*y + 1. y^2 - 1}.
	self assert: (I includes: x+y)! !

!CommutativeAlgebraTest methodsFor: 'ideal operations' stamp: 'len 2/23/2017 09:09:01'!
testIdealMembershipRandom
	self testIdealMembershipRandom: (QQ polynomialsIn: #(x y z))! !

!CommutativeAlgebraTest methodsFor: 'ideal operations' stamp: 'len 2/23/2017 09:08:24'!
testIdealMembershipRandom: aRing
	| R f1 f2 f3 I g |
	R _ aRing.
	[(f1 _ R atRandomBits: 10) isZero] whileTrue.
	[(f2 _ R atRandomBits: 10) isZero] whileTrue.
	[(f3 _ R atRandomBits: 10) isZero] whileTrue.
	I _ R * {f1. f2. f3}.
	g _ I atRandomBits: 100.
	self assert: (I includes: g)! !

!CommutativeAlgebraTest methodsFor: 'ideal operations' stamp: 'len 8/26/2016 19:28'!
testIdealRadical
	| R x y I J |
	R _ QQ polynomialsIn: #(x y).
	x _ R x: #x.
	y _ R x: #y.
	I _ R * {x^3. y^2}.
	J _ R * {x. y}.
	self assert: I radical = J! !

!CommutativeAlgebraTest methodsFor: 'ideal operations' stamp: 'len 12/2/2016 11:18:14'!
testIdealRadicalZeroDimNotPerfectField
	"Counterexample that shows how Seidenberg algorithm fails over a non-perfect field.
	From Becker and Weispfenning 'Groebner Bases', Springer-Verlag, 1993. Example 8.16."
	| p F R t x y I |
	p _ #(3 5 7 11) atRandom.
	F _ (ZZ / p) polynomialsIn: #(t) :: fractions.
	R _ F polynomialsIn: #(x y).
	t _ F x: #t.
	x _ R x.
	y _ R y.
	I _ R * {x^p - t. y^p - t}.
	self assert: (I includes: x^p - (y^p)).
	self deny: (I includes: x - y).
	self assert: (I radical includes: x - y)! !

!CommutativeAlgebraTest methodsFor: 'ideal operations' stamp: 'len 8/26/2016 05:57'!
testIdealRadicalZeroDimPerfectField
	"Seidenberg algorithm works for 0-dimensional ideals over a perfect field." 
	| R y z I J |
	R _ QQ polynomialsIn: #(y z).
	y _ R x: #y.
	z _ R x: #z.
	I _ R * {y + z. z^2}.
	J _ R * {y. z}.
	self assert: I radical = J! !

!CommutativeAlgebraTest methodsFor: 'ideal operations' stamp: 'len 10/23/2016 18:32'!
testIdealSaturation
	"Example from SageMath reference."
	| R x y z I J S |
	R _ QQ polynomialsIn: #(x y z).
	x _ R x.
	y _ R y.
	z _ R z.
	I _ R * {x^5*(z^3). x*y*z. y*(z^4)}.
	J _ R * z.
	S _ R * {y. x^5}.
	self assert: (I saturation: J) = S! !

!CommutativeAlgebraTest methodsFor: 'ideal operations' stamp: 'len 5/10/2019 04:31:36'!
testLocalIdeals
	"Magma handbook, example H104E4."
	| R I J A M |
	self notYetImplemented.
	R _ QQ polynomialsIn: #(x y z) ordering: #llex.
	I _ R * (R generate: [:x :y :z| {x*y - z. x^3*(z^2) - (y^2). x*(z^3) - x - y}]).
	J _ R * (R generate: [:x :y :z| {x*y - z. x^2*z - y. x*(z^3) - x - y}]).
	A _ R * (R generate: [:x :y :z|
		{x^2 - (y^2) + (2*(x^3)*z).
		x*y + (y^2) - (x^3*z).
		y^3.
		x*z + (y*z).
		y*z.
		z^2}]).
	self assert: I * J = A. "hangs here"
	M _ R * (R generate: [:x :y :z| {x + y. y^2. z}]).
	self assert: I /\ J = M.
	self deny: A = M.
	self assert: A <= M! !

!CommutativeAlgebraTest methodsFor: 'ideal operations' stamp: 'len 10/23/2016 16:37'!
testPolynomialRingHomomorphismKernel
	| A B x y phi |
	A _ QQ polynomialsIn: #(x y z).
	B _ QQ polynomialsIn: #(x y).
	x _ B x.
	y _ B y.
	phi _ A to: B evaluating: [:f| f value: {x-y. x. y}].
	self assert: phi kernel = (A * (A x - A y + A z)).
	self assert: (phi value: (phi kernel atRandomBits: 15)) isZero! !

!CommutativeAlgebraTest methodsFor: 'ideal operations' stamp: 'len 1/26/2017 09:43:00'!
testRadicalMembership
	| R x y z g1 g2 f I |
	R _ QQ polynomialsIn: #(x y z).
	x _ R x.
	y _ R y.
	z _ R z.
	g1 _ x^4*(y^2) + (z^2) - (x*(y^3)*z*4) - (y^5*z*2).
	g2 _ (x + (y^2)) ^ 2.
	f _ y*z - (x^3).
	I _ R * {g1. g2}.
	self assert: (I radicalContains: f)! !

!CommutativeAlgebraTest methodsFor: 'ideal operations' stamp: 'len 2/19/2017 19:30:49'!
testSquarefreeMonomialIdealPrimaryDecomposition
	"Miller, Sturmfels, 'Combinatorial Commutative Algebra', Example 1.8."
	| R a b c d e I |
	R _ QQ polynomialsIn: #(a b c d e).
	a _ R x: 1. b _ R x: 2. c _ R x: 3. d _ R x: 4. e _ R x: 5.
	I _ R * {a*d. a*e. b*c*d. b*e. c*e. d*e}.
	self assert: I primaryDecomposition = {R * {d. e}. R * {a. b. e}. R * {a. c. e}. R * {a. b. c. d}} asSet! !

!CommutativeAlgebraTest methodsFor: 'ideal basics' stamp: 'len 2/12/2017 12:50:41'!
testIdealElementOperations
	"Magma handbook example H103E2."
	| R x y z I |
	R _ QQ polynomialsIn: #(x y z) "ordering: #lex".
	x _ R x. y _ R y. z _ R z.
	I _ R * {(x + y)^3. (y - z)^2. y^2*z + z}.
	self assert: (I reduce: (y^2*z + z)) isZero.
	"I basis reduceFull: x^3 = ..."
	"I basis reduce: z^4 + (y^2))"
	self deny: (I includes: x+y).
	self assert: (I radicalContains: x+y).
	self assert: (I radicalContains: (x+y)^2).
	self deny: (I radicalContains: z).
	self assert: (x^4 + y - z s: x^2 + y - z) = (x^2*y negated + (x^2*z) + y - z)! !

!CommutativeAlgebraTest methodsFor: 'ideal basics' stamp: 'len 6/9/2019 15:57:05'!
testMonomialIdeal
	"Test ideals generated by monomials are automatically created as MonomialIdeal."
	| R f g h |
	R _ QQ polynomialsIn: 3.
	f _ R !! [:x :y :z| x^2 + y].
	g _ R !! [:x :y :z| z^3].
	h _ R !! [:x :y :z| x^2*y].
	self assert: (R * {f. g. h}) class ~= MonomialIdeal.
	self assert: (R * {g. h}) class = MonomialIdeal! !

!CommutativeAlgebraTest methodsFor: 'ideal basics' stamp: 'len 8/30/2016 07:01'!
testZeroIdeal
	| zero |
	zero _ ZZ * #(). "the zero ideal {0}"
	self assert: zero isZero.
	self assert: (zero includes: 0).
	self deny: (zero includes: 42)! !

!CommutativeAlgebraTest methodsFor: 'krull dimension' stamp: 'len 10/25/2016 15:02'!
testKrullDimension
	| R I Q |
	R _ QQ polynomialsIn: #(x y).
	self assert: R dimension = 2.
	I _ R * {R x. R y}.
	Q _ R / I.
	self assert: Q dimension = 0.
	I _ R * R zero. "zero ideal"
	Q _ R / I.
	self assert: Q dimension = 2! !

!CommutativeAlgebraTest methodsFor: 'krull dimension' stamp: 'len 10/25/2016 16:00'!
testKrullDimension2
	"Example from SageMath."
	| R x y I |
	R _ QQ polynomialsIn: #(x y).
	x _ R x.
	y _ R y.
	I _ R * {x*y. x*y + 1}.
	self assert: (R / I) dimension < 0.
	I _ R * {x*(x*y + 1). y*(x*y + 1)}.
	self assert: (R / I) dimension = 1.
	I _ R * {x^3*y. x*(y^2)}.
	self assert: (R / I) dimension = 1! !

!CommutativeAlgebraTest methodsFor: 'krull dimension' stamp: 'len 10/25/2016 15:18'!
testKrullDimensionFiniteField
	"Example from SageMath."
	| R x y I Q |
	R _ ZZ/32003 polynomialsIn: #(x y z).
	self assert: R dimension = 3.
	x _ R x.
	y _ R y.
	I _ R * {x^2 - y. x^3}.
	Q _ R / I.
	self assert: Q dimension = 1! !

!CommutativeAlgebraTest methodsFor: 'krull dimension' stamp: 'len 10/25/2016 15:59'!
testKrullDimensionFiniteField2
	"Example from SageMath."
	| R x y I |
	R _ ZZ/2147483659 polynomialsIn: #(x y).
	x _ R x.
	y _ R y.
	I _ R * {x*y. x*y + 1}.
	self assert: (R / I) dimension < 0.
	I _ R * {x*(x*y + 1). y*(x*y + 1)}.
	self assert: (R / I) dimension = 1.
	I _ R * {x^3*y. x*(y^2)}.
	self assert: (R / I) dimension = 1! !

!CommutativeAlgebraTest methodsFor: 'krull dimension' stamp: 'len 10/25/2016 15:07'!
testKrullDimensionOverZZ
	| R I Q |
	R _ ZZ polynomialsIn: #(x y).
	self assert: R dimension = 3.
"	I _ R * {R x. R y}.
	Q _ R / I.
	self assert: Q dimension = 0.
"	I _ R * R zero. "zero ideal"
	Q _ R / I.
	self assert: Q dimension = 3! !

!EllipticCurvesTest methodsFor: 'as yet unclassified' stamp: 'len 11/11/2016 10:14'!
testBInvariants
	| W |
	W _ WeierstrassEquation coefficients: (1,2,3,4,5).
	self assert: W b2 = 9.
	self assert: W b4 = 11.
	self assert: W b6 = 29.
	self assert: W b8 = 35! !

!EllipticCurvesTest methodsFor: 'as yet unclassified' stamp: 'len 11/11/2016 10:30'!
testCInvariants
	| W |
	W _ WeierstrassEquation coefficients: (0,-1,1,-10,-20).
	self assert: W c4 = 496.
	self assert: W c6 = 20008! !

!EllipticCurvesTest methodsFor: 'as yet unclassified' stamp: 'len 11/11/2016 08:29'!
testGroupLaw
	| E P Q O |
	E _ EllipticCurve cremona389a1.
	P _ E pointAt: (-1,1).
	Q _ E pointAt: (0,-1).
	O _ E pointAt: (0,1,0).
	self assert: P+Q = (E pointAt: (4,8)).
	self assert: P-Q = (E pointAt: (1,0)).
	self assert: 3*P - (5*Q) = (E pointAt: (328/361,(-2800/6859))).
	self assert: O+P = P.
	self assert: P+O = P.
	self assert: P-P = O! !

!EllipticCurvesTest methodsFor: 'as yet unclassified' stamp: 'len 8/27/2018 22:15:43'!
testPointAtX
	| E p |
	E _ EllipticCurve secp256k1.
	p _ E scalars modulus.
	10 count: [(E pointsAtX: p atRandom) allSatisfy: [:each| E satisfies: each coordinates]]! !

!EllipticCurvesTest methodsFor: 'as yet unclassified' stamp: 'len 11/9/2016 07:30'!
testWeierstrassEquationInvariants
	| W |
	W _ WeierstrassEquation coefficients: (ZZ ^ 5 atRandomBits: 100).
	self assert: W b8 * 4 = (W b2 * W b6 - W b4 squared).
	self assert: W discriminant * 1728 = (W c4 ^ 3 - W c6 squared)! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 11/16/2016 10:04'!
testAutomorphismsK3
	"Aut(K3) = Sym(3)"
	| G A |
	G _ Graph K: 3.
	A _ G automorphisms.
	self assert: A = A ambient
! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 4/8/2018 05:49:45'!
testAutomorphismsP3
	"Aut(P3) = {id, (1 3)}"
	| G A |
	G _ Graph P: 3.
	A _ G automorphisms.
	self assert: A = (PermutationGroup on: G values generators: {#((1 3))})! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 12/30/2017 16:17:24'!
testCartesianProduct
	| G H |
	G _ Graph unordered addEdge: 1 -> 2; yourself.
	H _ G ◊ G.
	self assert: H size = 4.
	self assert: H numberOfEdges = 4! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 11/16/2016 10:08'!
testChromaticNumber
	| G |
	G _ Graph unordered add: 1; add: 2; add: 3; yourself. 
	self assert: G chromaticNumber = 1. "edgeless graph"
	self assert: (Graph K: 3) chromaticNumber = 3.
	self assert: (Graph C: 5) chromaticNumber = 3.
	self assert: (Graph C: 6) chromaticNumber = 2.
	self assert: (Graph W: 6) chromaticNumber = 4.
	self assert: (Graph W: 5) chromaticNumber = 3.
	self assert: (Graph S: 6) chromaticNumber = 2! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 11/16/2016 10:05'!
testChromaticPolynomialComplete
	| x |
	x _ ZZ polynomials x.
	self assert: (Graph K: 3) chromaticPolynomial = (x*(x-1)*(x-2))! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 11/16/2016 10:05'!
testChromaticPolynomialCylic
	| x n |
	x _ ZZ polynomials x.
	n _ 4 atRandom.
	self assert: (Graph C: n) chromaticPolynomial = (x-1^n + ((-1)^n * (x-1)))! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 11/16/2016 10:04'!
testChromaticPolynomialPath
	| x n |
	x _ ZZ polynomials x.
	n _ 4 atRandom + 1.
	self assert: (Graph P: n) chromaticPolynomial = (x-1^(n-1)*x)! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 5/10/2019 04:31:47'!
testComplement
	| G H |
	G _ Graph unordered addEdges: {#a -> #b. #b -> #c. #d -> #e}; yourself.
	H _ G complement.
	self assert: (G \/ H) isComplete.
	self assert: (G /\ H) isEdgeless.
	self assert: H complement = G! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 11/16/2016 10:08'!
testConnectedComponents
	| G |
	G _ Graph unordered addEdges: {#a -> #b. #b -> #c. #d -> #e}; yourself.
	self assert: G components size = 2.
	self assert: (G components collect: [:each| each order]) = #(2 3) asSet.
	self assert: G components anyOne components size = 1! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 5/25/2016 03:39'!
testDistance
	| G |
	G _ Digraph unordered addEdges: {#a -> #b. #b -> #c. #d -> #e}; yourself.
	self assert: (G distanceFrom: #a to: #c) = 2.
	self assert: (G distanceFrom: #d to: #e) = 1.
	self assert: (G distanceFrom: #b to: #b) = 0.
	self assert: (G distanceFrom: #a to: #e) isInfinite! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 5/25/2016 03:39'!
testEquals
	| G H |
	G _ Digraph ordered addEdges: {#a -> #b. #b -> #c. #c -> #a. #X -> #Y}; yourself.
	H _ Digraph ordered addEdges: {#a -> #b. #b -> #c. #c -> #a}; yourself.
	self assert: G ~= H.
	H addEdge: #X -> #Y.
	self assert: G = H.
	self assert: G hash = H hash! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 5/25/2016 03:15'!
testImplicit
	| G |
	G _ RootedDigraph unordered roots: {2^3} children: [:each| each divisors copyWithout: each].
	self assert: G size = 4.
	self assert: G values asSet = #(1 2 4 8) asSet.
	self assert: G edges size = 6! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 5/10/2019 04:31:55'!
testIntersection
	| G H I |
	G _ Digraph unordered addEdges: {#a -> #b. #b -> #c. #d -> #e. #x -> #b}; yourself.
	H _ Digraph unordered addEdges: {#A -> #B. #b -> #c. #d -> #e. #X -> #X. #b -> #a}; yourself.
	I _ G /\ H.
	self assert: I numberOfEdges = 2.
	self assert: (I hasEdge: #b -> #c).
	self assert: (I hasEdge: #d -> #e)! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 5/25/2016 03:40'!
testIsComplete
	| G |
	G _ Digraph unordered.
	G addEdges: {#a -> #b. #b -> #a. #b -> #c. #a -> #c. #c -> #a}.
	G _ G reflexive.
	self assert: G isComplete not.
	G addEdge: #c -> #b.
	self assert: G isComplete! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 11/16/2016 10:03'!
testIsConnected
	| G |
	G _ Graph unordered addEdges: {#a -> #b. #b -> #c. #d -> #e}; yourself.
	self assert: G isConnected not.
	G addEdge: #e -> #a.
	self assert: G isConnected! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 5/25/2016 03:39'!
testIsCyclic
	| G |
	G _ Digraph unordered addEdges: {#a -> #b. #b -> #c. #d -> #e}; yourself.
	self assert: G isCyclic not.
	G addEdge: #e -> #a.
	self assert: G isCyclic not.
	G addEdge: #c -> #a.
	self assert: G isCyclic! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 5/25/2016 03:40'!
testIsSimple
	| G |
	G _ Digraph ordered addEdges: {#a -> #b. #b -> #c. #d -> #e}; yourself.
	self assert: G isSimple.
	G addEdge: #c -> #b.
	self assert: G isSimple.
	G addEdge: #c -> #b.
	self assert: G isSimple not! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 5/25/2016 03:41'!
testIsSimple2
	| G |
	G _ Digraph ordered addEdges: {#a -> #b. #b -> #c. #d -> #e}; yourself.
	self assert: G isSimple.
	G addEdge: #c -> #c.
	self assert: G isSimple not "a graph with a loop is not simple"! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 11/16/2016 10:08'!
testIsomorphism
	| G H |
	G _ Graph unordered.
	5 timesRepeat: [G addEdge: 5 atRandom -> 5 atRandom].
	H _ G shuffled.
	self assert: G ~ H.
	G _ Graph C: 5. "pentagon"
	H _ G copy.
	G addEdges: {1 -> 6. 6 -> 2}. "make a little triangle"
	H addEdges: {1 -> 6. 6 -> 3}. "same, but skip vertex 2 in the middle"
	H _ H shuffled.
	self deny: G ~ H! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 11/16/2016 10:04'!
testPetersenGraph
	| G |
	G _ Graph petersen.
	self assert: G nodes size = 10.
	self assert: G edges size = 15.
	self assert: G isCubic.
	self assert: G radius = 2.
	self assert: G diameter = 2.
"	self assert: G girth = 5"! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 5/25/2016 03:41'!
testShortestPath
	| G |
	G _ Digraph unordered.
	G addEdges: {#a -> #b. #b -> #a. #b -> #c. #a -> #c. #c -> #a}.
	self assert: (G shortestPathFrom: #c to: #b) asArray = #(a b).
	G addEdge: #c -> #b.
	self assert: (G shortestPathFrom: #c to: #b) asArray = #(b)! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 5/25/2016 03:39'!
testTransposed
	| G T |
	G _ Digraph unordered addEdges: {#a -> #b. #b -> #c. #d -> #e}; yourself.
	T _ G transposed.
	self assert: (G hasEdge: #b -> #c).
	self assert: (G hasEdge: #c -> #b) not.
	self assert: (T hasEdge: #b -> #c) not.
	self assert: (T hasEdge: #c -> #b)! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 11/16/2016 10:05'!
testTuttePolynomial
	| G P x y T |
	G _ Graph ordered addEdges: {1->2. 2->3. 3->4. 4->1. 1->3}; yourself.
	P _ ZZ polynomialsIn: #(x y).
	x _ P x.
	y _ P y.
	T _ x*(x^2 + (x+y)) + (x^2 + (x+y)) + (x*y + (y^2)).
	self assert: G tuttePolynomial = T! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 11/16/2016 10:05'!
testTuttePolynomial2
	| G P x y T |
	G _ Graph ordered addEdges: {1->2. 2->3. 3->4. 4->1. 1->3}; yourself.
	P _ ZZ polynomialsIn: #(x y).
	x _ P x.
	y _ P y.
	T _ x*(x^2 + (x+y)) + (x^2 + (x+y)) + (x*y + (y^2)).
	self assert: G tuttePolynomial = T! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 11/16/2016 10:08'!
testTuttePolynomialK3
	| G P x y T |
	G _ Graph K: 3.
	P _ ZZ polynomialsIn: #(x y).
	x _ P x.
	y _ P y.
	T _ x^2 + x + y.
	self assert: G tuttePolynomial = T! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 11/16/2016 10:08'!
testTuttePolynomialK4
	| G P x y T |
	G _ Graph K: 4.
	P _ ZZ polynomialsIn: #(x y).
	x _ P x.
	y _ P y.
	T _ x^3 + (x^2*3) + (x*2) + (x*y*4) + (y*2) + (y^2*3) + (y^3).
	self assert: G tuttePolynomial = T! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 11/16/2016 10:08'!
testUndirectedEdgeContraction
	| G |
	G _ Graph ordered addEdges: {1->2. 2->3. 3->4. 4->1. 1->3}; yourself.
	self assert: G edges size = 5.
	self assert: (G / (1->2)) edges size = 4.
	self assert: (G / (1->2) / ((1->2)->3)) edges size = 3! !

!GraphTest methodsFor: 'as yet unclassified' stamp: 'len 5/10/2019 04:36:25'!
testUnion
	| G |
	G _ Digraph unordered addEdges: {#a -> #b. #b -> #c. #d -> #e. #x -> #b}; yourself.
	self assert: (G \/ G transposed) = G symmetric! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 9/26/2018 22:02:46'!
smallGroupAtRandom
	^ {[SymmetricGroup new: 3].
	[AlternatingGroup new: 3].
	[PermutationGroup klein].
	[LinearGroup klein].
	[Group quaternions]} atRandom value! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 2/1/2018 23:02:45'!
testActionOrbitOf
	| G |
	G _ PermutationGroup on: (1 to: 8) generators: {#((1 3 2) (4 6 5)). #((1 2 3) (4 5 6)). #((7 8))}.
	self assert: (G action orbitOf: 1) = #(1 2 3) asSet.
	self assert: (G action orbitOf: 4) = #(4 6 5) asSet.
	self assert: (G action orbitOf: 7) = #(7 8) asSet! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 2/1/2018 23:04:44'!
testActionStabilizerOf
	| G g1 g2 g3 id H |
	G _ SymmetricGroup new: 8.
	g1 _ G !! #((1 3 2) (4 6 5)).
	g2 _ G !! #((1 2 3) (4 5 6)).
	g3 _ G !! #((7 8)).
	id _ G identity.
	H _ G span: {g1. g2. g3}.
	self assert: (H action stabilizerOf: 1) asSet = {id. g3} asSet.
	self assert: (H action stabilizerOf: 7) asSet = {id. g1. g2} asSet! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 4/30/2019 11:51:02'!
testAlternatingIsSymmetricCommutator
	| S A |
	S _ SymmetricGroup new: 3.
	A _ AlternatingGroup new: 3.
	self assert: A = S commutator.
	self assert: (S indexOf: A) = 2! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 4/30/2019 11:51:49'!
testAlternatingOrder
	| A |
	A _ AlternatingGroup new: 3.
	self assert: A order = (3 factorial / 2)! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 2/1/2018 23:07:09'!
testBigOrder1
	"Test fast computation of group order with Schreier-Sims algorithm.
	This is Sym(10), with order 10!!."
	| G |
	G _ PermutationGroup new: 10 generators: {#((1 2)). #(10 1 2 3 4 5 6 7 8 9)}.
	self assert: G order = 10 factorial! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 1/30/2018 21:25:14'!
testBigOrder2
	"Test fast computation of group order with Schreier-Sims algorithm.
	This is the Mathieu group on 12 points, the second smallest of the 26 sporadic simple groups, with order 95040."
	self assert: PermutationGroup M12 order = 95040! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 4/30/2019 11:52:42'!
testCauchyFrobeniusLemma
	"Also called Brunside's lemma, Burnside counting theorem, or orbit-counting theorem."
	| X G phi sum |
	X _ 1 to: 3.
	G _ AlternatingGroup on: X.
	phi _ GroupAction from: (G, X) to: X evaluatingWithArguments: [:f :x| f value: x].
	sum _ G elements sum: [:g| (phi fixedPointsOf: g) size].
	self assert: phi orbits size * G order = sum! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 1/28/2018 08:37:03'!
testConjugacyClasses
	"From wikipedia article on conjugacy classes."
	self assert: (SymmetricGroup new: 3) conjugacyClasses size = 3.
	self assert: (SymmetricGroup new: 4) conjugacyClasses size = 5! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 11/6/2016 10:04'!
testD3
	| D S A |
	D _ PermutationGroup dihedral: 2*3.
	self testGroup: D.
	S _ SymmetricGroup new: 3.
	self assert: D = S.
	A _ AlternatingGroup new: 3.
	self assert: D commutator = A.
	self assert: D center isTrivial! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 5/5/2019 18:13:09'!
testDirectProduct
	| S A G g |
	S _ self smallGroupAtRandom.
	A _ self smallGroupAtRandom.
	G _ S ◊ A.
	g _ G atRandom.
	self assert: g ∑ g inverse = G identity.
	self testGroup: G.
	self testGroupHomomorphism: (G projection: 1).
	self testGroupHomomorphism: (G projection: 2)! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 5/5/2019 18:14:45'!
testGroup: G
	| e a b c |
	e _ G identity.
	a _ G atRandomBits: 100.
	b _ G atRandomBits: 100.
	c _ G atRandomBits: 100.
	self assert: e ∑ a = a.
	self assert: a ∑ e = a.
	self assert: a ∑ a inverse = e.
	self assert: a inverse ∑ a = e.
	self assert: (a ∑ b) ∑ c = (a ∑ (b ∑ c))! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 5/5/2019 18:43:04'!
testGroupAction: phi
	| G X e g h x |
	G _ phi group.
	X _ phi space.
	e _ G identity.
	g _ G atRandomBits: 100.
	h _ G atRandomBits: 100.
	x _ X atRandomBits: 100.
	self assert: (phi value: {e. x}) = x.
	self assert: (phi value: {g. phi value: {h. x}}) = (phi value: {g ∑ h. x})! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 5/26/2019 08:43:33'!
testGroupAlgebra
	| G R a b c xa xb xc |
	G _ self smallGroupAtRandom.
	R _ G groupAlgebra.
	a _ G atRandom.
	b _ G atRandom.
	c _ G atRandom.
	xa _ R embed: a.
	xb _ R embed: b.
	xc _ R embed: c.
	self assert: xa*xb = (R embed: a∑b).
	self assert: xa*2 + xb*xc - (xa*xc) - (xb*xc) = (R embed: a∑c).
	self assert: (xa + xb) * (xa - xb) = (xa^2 - (xb^2) + (xb*xa) - (xa*xb))! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 5/26/2019 08:43:44'!
testGroupAlgebraIsARing
	| G R a a2 b b2 c c2 e e2 |
	G _ self smallGroupAtRandom.
	R _ G groupAlgebra.
	e _ G identity.
	a _ G atRandom.
	b _ G atRandom.
	c _ G atRandom.
	e2 _ R embed: e.
	a2 _ R embed: a.
	b2 _ R embed: b.
	c2 _ R embed: c.
	self assert: e2 = R one.
	self assert: e2 * a2 = a2.
	self assert: a2 * e2 = a2.
	self assert: (a2 * b2 * c2) = (a2 * (b2 * c2)).
	G isCommutative ifTrue: [self assert: a2 * b2 = (b2 * a2)].! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 5/5/2019 18:43:49'!
testGroupHomomorphism: phi
	| G H a b |
	G _ phi domain.
	H _ phi codomain.
	a _ G atRandomBits: 100.
	b _ G atRandomBits: 100.
	self assert: (phi value: G identity) = H identity.
	self assert: (phi value: a ∑ b) = ((phi value: a) ∑ (phi value: b))! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 11/6/2016 10:03'!
testHessian
	| H |
	H _ PermutationGroup hessian.
	self assert: H elements size = 216.
	self testGroup: H! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 4/30/2019 11:51:16'!
testIsSolvable
	| G |
	G _ SymmetricGroup new: 3.
	self assert: G isSolvable! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 4/30/2019 11:52:58'!
testIsSolvableNot
	| G |
	G _ AlternatingGroup new: 5.
	self assert: G isSolvable not! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 11/6/2016 10:03'!
testKleinFour
	| V S A |
	V _ PermutationGroup klein.
	self testGroup: V.
	S _ SymmetricGroup new: 4.
	self assert: (V isNormalIn: S).
	A _ AlternatingGroup new: 4.
	self assert: (V isNormalIn: A)! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 5/25/2019 04:46:36'!
testLagrangeTheorem
	"G finite group, H subgroup of G, then |H| divides |G|."
	| G H |
	G _ self smallGroupAtRandom.
	H _ G span: ((1 to: 3 atRandom) collect: [:i| G atRandom]) asSet.
	self assert: H order | G order! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 12/2/2016 11:10:56'!
testModularIntegersUnits
	| m R U |
	m _ (2 to: 100) atRandom.
	R _ ZZ / m.
	U _ R units.
	self assert: U size = (Sequence phi value: m).
"	self testGroup: U"! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 4/30/2019 11:53:11'!
testOrbitStabilizerTheorem
	| X G phi p |
	X _ 1 to: 4.
	G _ AlternatingGroup on: X.
	phi _ GroupAction from: (G, X) to: X evaluatingWithArguments: [:f :x| f value: x].
	p _ X atRandom.
	self assert: (phi stabilizerOf: p) order * (phi orbitOf: p) size = G order! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 1/30/2018 21:34:39'!
testPermutationGroupAction
	self testGroupAction: (SymmetricGroup new: 10) action.
	self testGroupAction: (PermutationGroup cyclic: 15) action! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 12/22/2016 21:40:10'!
testPermutationGroupHomomorphism
	"Magma Handbook, Example H57E2."
	| C15 h im |
	C15 _ PermutationGroup cyclic: 15.
	h _ C15 to: C15 evaluating: [:g| g ^ 3].
	im _ h image.
	self assert: im space size = 15. "a permutation group acting on a set of cardinality 15"
	self assert: im size = 5. "of order 5"
	self assert: im isCyclic! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 4/30/2019 11:51:29'!
testSymmetricOrder
	| G |
	G _ SymmetricGroup new: 4.
	self assert: G order = 4 factorial! !

!GroupTest methodsFor: 'as yet unclassified' stamp: 'len 11/14/2016 08:35'!
testTrivial
	| G |
	G _ PermutationGroup new: 4 generators: #().
	self assert: G size = 1.
	self assert: G isTrivial! !

!LatticeTest methodsFor: 'as yet unclassified' stamp: 'len 6/2/2018 18:06:30'!
testE8
	| E8 a |
	E8 _ Lattice E8.
	a _ E8 atRandomBits: 100.
	self assert: ((a allSatisfy: [:x| x isInteger]) or: [a allSatisfy: [:x| x isInteger not and: [(x*2) isInteger]]]).
	self assert: (a sum isInteger and: [a sum even]).
	self assert: E8 isIntegral.
	self assert: E8 isUnimodular.
	self assert: E8 isEven.
	self assert: E8 isSelfDual! !

!LatticeTest methodsFor: 'as yet unclassified' stamp: 'len 12/7/2017 20:45:47'!
testLLL
	| b1 b2 b3 lll |
	b1 _ (1, 1, 1).
	b2 _ (-1, 0, 2).
	b3 _ (3, 5, 6).
	lll _ LLL basis: { b1. b2. b3 }.
	self assert: lll reducedBasis = {(0,1,0). (1,0,1). (-1,0,2)}! !

!LatticeTest methodsFor: 'as yet unclassified' stamp: 'len 5/20/2018 15:59:01'!
testLatticeAnDual
	| A3 D |
	A3 _ Lattice A: 3.
	D _ Lattice Adual: 3.
	self assert: A3 reciprocal = D.
	self assert: A3 = D reciprocal! !

!LatticeTest methodsFor: 'as yet unclassified' stamp: 'len 5/20/2018 15:58:52'!
testLatticeD4SelfDual
	| D4 |
	D4 _ Lattice D4.
	self assert: D4 isSelfDual! !

!LatticeTest methodsFor: 'as yet unclassified' stamp: 'len 5/20/2018 15:58:35'!
testLatticeDnDual
	| D R |
	D _ Lattice D: 5.
	R _ Lattice Ddual: 5.
	self assert: D reciprocal = R.
	self assert: D = R reciprocal! !

!LatticeTest methodsFor: 'as yet unclassified' stamp: 'len 5/20/2018 15:58:46'!
testLatticeDual
	| L R I |
	L _ Lattice basis: {(-1,0,0). (0,1,2). (0,1,1)}.
	R _ L reciprocal.
	I _ L matrix identity.
	self assert: (L ambient span: L basis) = (R ambient span: R basis).
	self assert: L determinant = (1 / R determinant).
	self assert: R matrix * L matrix transposed = I! !

!LatticeTest methodsFor: 'as yet unclassified' stamp: 'len 5/20/2018 15:58:41'!
testLatticeDual2
	| L R |
	L _ Lattice basis: {(-1,0,0). (0,1,2)}. "not full rank"
	R _ L reciprocal.
	self assert: (L ambient span: L basis) = (R ambient span: R basis).
	self assert: L determinant = (1 / R determinant).
	self assert: (R matrix * L matrix transposed) isIdentity! !

!LatticeTest methodsFor: 'as yet unclassified' stamp: 'len 5/8/2019 14:58:30'!
testLeech
	| L |
	L _ Lattice leech.
"	a _ L atRandomBits: 100.
	self assert: ((a allSatisfy: [:x| x isInteger]) or: [a allSatisfy: [:x| x isInteger not and: [(x*2) isInteger]]]).
	self assert: (a sum isInteger and: [a sum even])."
	self assert: L determinant = 1.
"	self assert: L kissingNumber = 196560."
"	self assert: L minimalNorm = 4."
	self assert: L isIntegral.
	self assert: L isUnimodular.
	self assert: L isEven! !

!LinearGroupsTest methodsFor: 'as yet unclassified' stamp: 'len 5/16/2019 12:40:05'!
testGeneralLinearAtRandom
	| V G |
	V _ QQ ^ 3.
	G _ V automorphisms.
	self assert: (G atRandomBits: 100) isAutomorphism.
	self assert: (G includes: (G atRandomBits: 100))! !

!LinearGroupsTest methodsFor: 'as yet unclassified' stamp: 'len 9/26/2018 21:54:15'!
testOrthogonalAtRandom
	| V G |
	V _ QQ ^ 3.
	G _ V automorphisms orthogonal.
	self assert: (G atRandomBits: 100) isOrthogonal.
	self assert: (G includes: (G atRandomBits: 100))! !

!LinearGroupsTest methodsFor: 'as yet unclassified' stamp: 'len 9/26/2018 22:03:03'!
testRotationsBy90Degrees
	"Group of rotations by 90 degrees in the plane, isomorphic to Z/4Z."
	| V G |
	V _ QQ ^ 2.
	G _ LinearGroup on: V generators: {V endomorphisms elementAt: (0, 1, -1, 0)}.
	self assert: G size = 4.
	self assert: G isCyclic.
	self flag: #todo.
	"test invariant ring K[x,y]^G = K[x^2+y^2, x^2y^2, x^3y-xy^3], isomorphic to K[a,b,c]/<c^2-a^2b+4b^2>"
	"test hilbert series is 1-z^8 / ((1-z^2)^2(1-z^4)) = 1 + z^2 + 3z^4 + 3z^6 + ..."! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 11/3/2016 04:39'!
testAlgebraicExtension
	| x E a b |
	x _ QQ polynomials x.
	E _ QQ extension: x^4 - 2.
	a _ E x.
	self assert: (a^4) representative asScalar = 2.
	b _ a^2 + (E embed: 3).
	self assert: b minimalPolynomial = (x^2 - (x*6) + 7)! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 7/2/2016 05:48'!
testBitCount
	| v |
	v _ 1 << 3000 :: atRandom.
	self assert: (v printStringBase: 2 :: count: [:x| x = $1]) = v bitCount! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 7/2/2016 05:48'!
testBitParity
	| v |
	v _ 1 << 3000 :: atRandom.
	self assert: ((v printStringBase: 2 :: count: [:x| x = $1]) bitAnd: 1) = v bitParity! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 4/26/2018 08:16:17'!
testCRT
	| crt |
	crt _ CRT mod: #(2 5 7).
	self assert: (crt solve: #(0 2 0)) = 42! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/16/2016 13:35:30'!
testCartesianProduct
	| P x |
	P _ CartesianProduct components: {PrimeField new: 3. GaloisField new: 4. SymmetricGroup new: 5}.
	self assert: P elements size = (3*4*5 factorial).
	x _ {(P at: 1) atRandom. (P at: 2) atRandom. (P at: 3) atRandom}.
	self assert: (P elements includes: x)! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/4/2015 01:46'!
testContinuedFractions
	| x |
	x _ ContinuedFraction fromFraction: 415/93.
	self assert: x coefficients = (4, 2, 6, 7).
	self assert: x asFraction = (415/93)! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/4/2015 22:01'!
testContinuedFractions2
	-2 to: 2 by: 1/2 do:
		[:x| self assert: (ContinuedFraction fromFraction: x) asFraction = x]! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 3/27/2016 04:47'!
testContinuedFractionsE
	| x e |
	e _ ContinuedFraction e.
	x _ e convergentAt: 20.
	self assert: (x asFloat - 1 exp) abs < 0.0000001! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 3/27/2016 04:47'!
testContinuedFractionsGoldenRatio
	| x phi |
	phi _ ContinuedFraction phi.
	x _ phi convergentAt: 20.
	self assert: (x asFloat - 1.6180339887) abs < 0.000001! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 07:58'!
testContinuedFractionsGoldenRatio2
	| phi denominators |
	phi _ ContinuedFraction phi.
	denominators _ phi convergents collect: [:each| each denominator].
	self assert: (denominators equals: Sequence fibonacci << 1 upTo: 100)! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/3/2015 02:18'!
testContinuedFractionsNegated
	| x |
	x _ ContinuedFraction fromFraction: 415/93.
	self assert: x negated asFraction = (-415/93)! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/3/2015 02:19'!
testContinuedFractionsReciprocal
	| x |
	x _ ContinuedFraction fromFraction: 415/93.
	self assert: x reciprocal asFraction = (93/415)! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/10/2016 20:30:38'!
testCyclotomicPolynomials
	| P |
	P _ QQ polynomials.
	1 to: 20 do: [:n| self assert: (P cyclotomic: n) degree = n phi]! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/10/2016 20:36:22'!
testCyclotomicPolynomials2
	| P x n |
	P _ QQ polynomials.
	x _ P x.
	n _ 100 atRandom.
	self assert: (n divisors product: [:d| P cyclotomic: d]) = (x^n - 1)! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 4/18/2018 06:23:55'!
testExtendedEuclid
	| a b euclid |
	a _ -1000 to: 1000 :: atRandom.
	b _ -1000 to: 1000 :: atRandom.
	euclid _ ExtendedEuclid on: {a. b}.
	self assert: euclid gcd | a.
	self assert: euclid gcd | b.
	self assert: (euclid bezout * {a. b}) sum = euclid gcd.
	self assert: euclid gcd = (a gcd: b).
	self assert: euclid verify! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:05'!
testFieldAutomorphisms
	self assert: QQ automorphisms isTrivial! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 1/10/2018 13:11:40'!
testFreeAlgebra
	| A f g h |
	A _ QQ freeAlgebraIn: #(x y z).
	f _ A atRandomBits: 100.
	g _ A atRandomBits: 100.
	h _ A atRandomBits: 100.
	self assert: (f*g)*h = (f*(g*h)). "associativity"
	self assert: (f+g)*h = (f*h + (g*h)). "distributivity"
	self assert: f * A one = f.
	self assert: A one * f = f! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 5/5/2019 18:31:51'!
testFunctionComposition
	| f g a |
	f _ Function from: ZZ to: ZZ evaluating: [:x| x * 2].
	g _ Function from: ZZ to: ZZ evaluating: [:x| x + 1].
	a _ 1000 atRandom.
	self assert: (f ∑ g value: a) = (f value: (g value: a)).
	self assert: (g ∑ f value: a) = (g value: (f value: a))! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 5/5/2019 18:31:56'!
testFunctionComposition2
	| f g a |
	f _ Function from: ZZ to: QQ evaluating: [:x| x / 2].
	g _ Function from: QQ to: ZZ evaluating: [:x| x numerator].
	a _ 1000 atRandom.
	self assert: (f ∑ g value: a) = (f value: (g value: a)).
	self assert: (g ∑ f value: a) = (g value: (f value: a))! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 5/5/2019 18:32:02'!
testFunctionComposition3
	| f g |
	f _ Function from: ZZ to: QQ evaluating: [:x| x / 2].
	g _ Function from: ZZ to: ZZ evaluating: [:x| x + 1].
	self should: [g ∑ f] raise: DomainError! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 5/15/2019 01:49:41'!
testFunctionNewFrom
	| f g |
	f _ (QQ^3) endomorphisms atRandomBits: 1000. "f is a LinearMap"
	g _ f as: Function. "downgrade it to a simple Function, not a LinearMap any more"
	self assert: (g as: FreeModuleMap) = f! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/11/2016 20:01:51'!
testFundamentalDiscriminant
	self assert: ((1 to: 33) select: [:each| each isFundamentalDiscriminant]) =  #(1 5 8 12 13 17 21 24 28 29 33).
	self assert: ((0 to: -31 by: -1) select: [:each| each isFundamentalDiscriminant]) = #(-3 -4 -7 -8 -11 -15 -19 -20 -23 -24 -31) 
! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 6/4/2016 21:56'!
testInfinity
	self assert: Infinity positive > Infinity negative.
	self assert: Infinity positive > 127934879182734.
	self assert: Infinity negative < -198273498712341.
	self assert: Infinity positive >= 127934879182734.
	self assert: Infinity negative <= -198273498712341.
	self assert: -918723948719 > Infinity negative.
	self assert: 91872123948719 < Infinity positive! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 7/8/2016 05:34'!
testInfinityUndeterminates
	self should: [Infinity positive + Infinity negative] raise: Error.
	self should: [Infinity positive * 0] raise: Error.
	self should: [Infinity positive / Infinity positive] raise: Error.
	self should: [Infinity positive ^ 0] raise: Error
! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/13/2015 02:02'!
testIntegerDivisors
	self assert: 12 numberOfDivisors = 6.
	self assert: 12 divisors size = 6! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 2/28/2017 21:25:51'!
testIntegerIdealsPrimePrimarySemiprime
	self assert: (ZZ*5) isPrime.
	self assert: (ZZ*6) isPrime not.
	self assert: (ZZ*25) isPrimary.
	self assert: (ZZ*30) isPrimary not.
	self assert: (ZZ*30) isSemiprime.
	self assert: (ZZ*12) isSemiprime not! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/2/2016 11:11:24'!
testIteratorCovering
	| F |
	F _ ZZ / 3.
	self assert: (F^3 upTo: 3^3) asSet size = (3^3).
	self assert: (ZZ^3 upTo: 100) asSet size = 100! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/16/2016 13:35:55'!
testIteratorCovering2
	| F |
	F _ GaloisField new: 9.
	self assert: ((F^3) upTo: 9^3) asSet size = (9^3).
	self assert: ((F^3) upTo: 9^3+100) asSet size = (9^3)! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/16/2016 13:36:04'!
testIteratorCovering3
	| F |
	F _ GaloisField new: 3.
	self assert: ((F^4) upTo: 3^4) asSet size = (3^4).
	self assert: ((F^4) upTo: 3^4+100) asSet size = (3^4)! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/26/2016 23:11:25'!
testJacobiAndLegendreSymbols
	| a p |
	10 timesRepeat:
		[p _ (1000 atRandom + 2) nextPrime. "an odd prime"
		a _ 1000 atRandom - 1.
		self assert: (a legendre: p) = (a jacobi: p)]! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/28/2016 08:34:47'!
testKroneckerAndLegendreSymbols
	| a p |
	10 timesRepeat:
		[p _ (1000 atRandom + 2) nextPrime. "an odd prime"
		a _ 1000 atRandom - 1.
		self assert: (a legendre: p) = (a kronecker: p)]! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/28/2016 08:51:30'!
testKroneckerSymbol
	| a b c |
	a _ (-100 to: 100) atRandom.
	b _ (-100 to: 100) atRandom.
	self assert: ((a kronecker: b) = 0) = ((a gcd: b) ~= 1).
	c _ (-100 to: 100) atRandom.
	self assert: (a*b kronecker: c) = ((a kronecker: c) * (b kronecker: c)).
	b*c = 0 ifFalse: [self assert: (a kronecker: b*c) = ((a kronecker: b) * (a kronecker: c))]! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/26/2016 23:13:26'!
testLegendreSymbol
	self assert: ((1 to: 10) collect: [:k| k legendre: 43]) = #(1 -1 -1 1 -1 1 -1 -1 1 1)! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 7/2/2016 21:04'!
testPartitions
	self assert: 42 partitions size =  53174! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 2/1/2018 22:41:50'!
testPermutationProduct
	| G a b |
	G _ SymmetricGroup new: 5.
	a _ G !! #((1 4 5) (2 3)).
	b _ G !! #((2 4) (5 1)).
	self assert: b*a = (G !! #((1 2 3 4))).
	self assert: a*a = (G !! #((1 5 4)))! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 2/1/2018 22:42:32'!
testPermutationProduct2
	| G a b |
	G _ SymmetricGroup new: 5.
	a _ G !! #((1 4 5) (2 3)).
	b _ G !! #((2 4) (5 1)).
	self assert: b*a = (G !! #((1 2 3 4))).
	self assert: a*a = (G !! #((1 5 4)))! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 2/1/2018 23:38:29'!
testPermutationProduct3
	| G a b |
	G _ SymmetricGroup new: 4.
	a _ G !! #((2 3 4)).
	b _ G !! #((1 2) (3 4)).
	self assert: b*a = (G !! #((1 2 4))).
	self assert: a*b = (G !! #((1 3 2)))! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/19/2017 19:37:04'!
testPolynomialVectorSpace
	| Qx V S x |
	Qx _ QQ polynomials.
	x _ Qx x.
	V _ Qx filtrationAt: 5.
	S _ V span: {Qx one. x^2. x*2}.
	self assert: (S includes: x^2 + 2).
	self deny: (S includes: x^3 + 2).
	self assert: (S orthogonalProjection value: x^3 - (x^2) + (x*2) + 3) = ((x^2) negated + (x*2) + 3)! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/13/2015 01:54'!
testPrimeSignature
	self assert: 1 primeSignature = #().
	self assert: 7 primeSignature = #(1).
	self assert: (7*5) primeSignature = #(1 1).
	self assert: 12 primeSignature = #(2 1).
	self assert: 100 primeSignature = #(2 2).
	self assert: 42 primeSignature = #(1 1 1).
	self assert: 16 primeSignature = #(4)! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 12/21/2016 20:21:11'!
testRadicalAndIsSquareFree
	| n |
	n _ (-1000 to: 1000) atRandom.
	self assert: n isSquareFree = (n radical = n)! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 6/4/2016 21:48'!
testRealIntervalIntersects
	| I J |
	I _ RealInterval open: -1 closed: 0.
	J _ RealInterval open: 0 closed: 1.
	self assert: (I intersects: J) not.
	J _ RealInterval closed: 0 open: 1.
	self assert: (I intersects: J).
	J _ RealInterval closed: -2 closed: -1.
	self assert: (I intersects: J) not! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 3/3/2016 23:22'!
testWord
	| x y |
	x _ Word x: #x.
	y _ Word x: #y.
	self assert: (x*y) * y reciprocal = x.
	self assert: (x*y * (y reciprocal * x reciprocal)) isEmpty.
	self assert: x*y*y * (y reciprocal * y reciprocal * x) = (x^2).
	self assert: x * (y * y * x) = (x * y * (y * x)).
	self assert: (x*y * (x*y) reciprocal) isEmpty! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 1/10/2018 11:31:05'!
testWordOrdering
	| F p q r |
	F _ FreeMonoid new: 3.
	p _ F atRandomBits: 20 atRandom.
	r _ F atRandomBits: 20 atRandom.
	[p < (q _ F atRandomBits: 20 atRandom)] whileFalse.
	self assert: p*r <= (q*r).
	self assert: r*p <= (r*q).
	p _ q * r.
	self assert: (p > q or: [p = q and: [r isEmpty]]).
	self assert: (p > r or: [p = r and: [q isEmpty]])! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 03:30'!
testYoungTableauxSemistandard
	| T |
	T _ YoungTableau rows: #((1 1 2 2 3) (2 3 4 4) (4) (5)).
	self assert: T isSemistandard.
	self assert: T shape = #(5 4 1 1)! !

!MathematicsTest methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 03:30'!
testYoungTableauxStandard
	| T |
	T _ YoungTableau rows: #((1 4 6 8) (2 5 7) (3)).
	self assert: T isStandard.
	self assert: T weight = #(1 1 1 1 1 1 1 1).
	self assert: T shape = #(4 3 1)! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 3/1/2017 17:10:52'!
newRandomMatrix: dim over: aRing
	| samples |
	2 atRandom = 1 ifTrue: [^ aRing^dim atRandomBits: 100].
	samples _ {aRing zero. aRing one. aRing one negated}.
	^ aRing matrix: dim evaluating: [:i :j| 2 atRandom > 1 ifTrue: [aRing zero] ifFalse: [samples atRandom]]! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 11/11/2016 09:00'!
testAdjugate
	| A I |
	A _ Matrix rows: { (2,1,1). (-1,0,1). (0,2,1) }.
	I _ A identity.
	self assert: A * A adjugate = (I * A determinant)! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 11/11/2016 09:00'!
testAdjugate2
	| A B |
	A _ Matrix rows: { (-3,2,-5). (-1,0,-2). (3,-4,1) }.
	B _ Matrix rows: { (-8,18,-4). (-5,12,-1). (4,-6,2) }.
	self assert: A adjugate = B! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 5/15/2019 13:09:45'!
testAdjugateCramerRule
	| A I |
	A _ QQ^(3@3) atRandomBits: 50.
	I _ A identity.
	self assert: A * A adjugate = (I * A determinant)! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 4/5/2018 15:43:37'!
testAdjugateProperties
	| M A B I c |
	M _ QQ ^ (3@3).
	A _ M rows: { (-3,2,-5). (-1,0,-2). (3,-4,1) }.
	B _ M rows: { (-1,2,3). (1,-2,1). (2,2,-1) }.
	c _ 7.
	I _ M identity.
	self assert: I adjugate = I.
	self assert: (A * B) adjugate = (B adjugate * A adjugate).
	self assert: (A*c) adjugate = (A adjugate * (c^(M height - 1))).
	self assert: (A^5) adjugate = (A adjugate ^ 5).
	self assert: A transposed adjugate = A adjugate transposed! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:05'!
testCayleyHamiltorTheoremInQ
	| n M A |
	n _ 6 atRandom.
	M _ QQ ^ (n@n).
	A _ M atRandomBits: 100.
	self assert: (A characteristicPolynomial value: A) isZero! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:47'!
testCayleyHamiltorTheoremInZ
	| n M A |
	n _ 6 atRandom.
	M _ ZZ ^ (n@n).
	A _ M atRandomBits: 100.
	self assert: (A characteristicPolynomial value: A) isZero! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:47'!
testDomainError
	| A B |
	A _ ZZ ^ (4@4) :: identity.
	self should: [A / 2] raise: DomainError.
	B _ QQ ^ (4@4) :: identity.
	self should: [A + B] raise: DomainError.
	self should: [A * B] raise: DomainError! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 3/1/2017 17:33:10'!
testFundamentalSubspacesDefinitions
	| m n A |
	m _ 6 atRandom.
	n _ 6 atRandom.
	A _ self newRandomMatrix: m@n over: QQ.
	self assert: A rowSpace = (QQ^n span: A rows). "definition"
	self assert: A columnSpace = (QQ^m span: A columns). "definition"
	self assert: A coimage = A transposed image. "definition"
	self assert: A cokernel = A transposed kernel. "definition"
	self assert: A image = A columnSpace. "synonyms"
	self assert: A coimage = A rowSpace. "synonyms"
! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 3/1/2017 17:30:09'!
testFundamentalSubspacesDimensions
	| m n A r |
	m _ 6 atRandom.
	n _ 6 atRandom.
	A _ self newRandomMatrix: m@n over: QQ.
	r _ A rank.
	self assert: A image dimension = r.
	self assert: A kernel dimension = (n - r).
	self assert: A nullity = (n - r). "definition"
	self assert: A coimage dimension = r.
	self assert: A cokernel dimension = (m - r)! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:05'!
testInverse
	| M A I |
	M _ QQ ^ (3@3).
	A _ M rows: { (2,1,1). (-1,0,1). (0,2,1) }.
	I _ M identity.
	self assert: A inverse * A = I.
	self assert: A * A inverse = I! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:06'!
testInverse2
	| Qx x f A |
	Qx _ QQ polynomials.
	x _ Qx x.
	f _ x^8 + (x^6) - (3*(x^4)) - (3*(x^3)) + (8*(x^2)) + (2*x) - 5.
	A _ f companion.
	self assert: (A * A inverse) isIdentity! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 3/1/2017 17:08:29'!
testKernelImageTheorem
	| n A |
	n _ 6 atRandom.
	A _ self newRandomMatrix: n@n over: QQ.
	self assert: A kernel dimension + A image dimension = n! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 10/17/2016 16:45'!
testKroneckerProduct
	| A B C |
	A _ ZZ ^ (2@2) elementAt: (1,2,3,4).
	B _ ZZ ^ (2@2) elementAt: (0,5,6,7).
	C _ ZZ ^ (4@4) elementAt: (0, 5, 0, 10, 6, 7, 12, 14, 0, 15, 0, 20, 18, 21, 24, 28).
	self assert: (A kronecker: B) = C! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 5/16/2019 12:27:03'!
testLeftInverse
	| M A |
	M _ QQ ^ (5@3).
	[A _ M atRandomBits: 1000. A rank = 3] whileFalse.
	self assert: (A retraction * A) isIdentity! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 5/5/2019 10:08:10'!
testLeftRightIdentity
	| A |
	A _ ZZ^(5 atRandom @ 5 atRandom) atRandomBits: 100.
	self assert: A leftIdentity * A = A.
	self assert: A * A rightIdentity = A! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 10/17/2016 16:45'!
testMinor
	| M A |
	M _ ZZ ^ (3@3).
	A _ M elementAt: #(1 2 3 4 5 6 7 8 9).
	self assert: (A minor: 2@3) = -6! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 10/17/2016 16:45'!
testMinors
	| A |
	A _ ZZ ^ (2@3) elementAt: (1 to: 6).
	self assert: (A minors: 2) asArray = #(-3 -6 -3)! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 3/16/2018 20:18:11'!
testQRDecomposition
	| n A QR Q R |
	n _ 3.
	[A _ QQ ^ (n@n) :: atRandomBits: n*n. A isFullRank] whileFalse.
	A _ A over: RR.
	QR _ A QR.
	Q _ QR first.
	R _ QR second.
	self assert: Q * R = A.
	self assert: Q isOrthogonal.
	self assert: R isUpperTriangular! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2018 03:58:33'!
testQRDecomposition2
	"Example from wikipedia:"
	| A Q R |
	A _ RR matrix: 3@3 coefficients: #(12 -51 4 6 167 -68 -4 24 -41).
	Q _ RR matrix: 3@3 coefficients: {6/7. -69/175. -58/175. 3/7. 158/175. 6/175. -2/7. 6/35. -33/35}.
	R _ RR matrix: 3@3 coefficients: #(14 21 -14 0 175 -70 0 0 35).
	self assert: A QR = {Q. R}! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 5/16/2019 12:28:52'!
testRightInverse
	| M A |
	M _ QQ ^ (3@5).
	[A _ M atRandomBits: 1000. A rank = 3] whileFalse.
	self assert: (A * A section) isIdentity! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 8/24/2016 19:19'!
testSimilarity
	"Examples from wikipedia article on SNF"
	| M A B C |
	M _ QQ ^ (2@2).
	A _ M rows: {(1,2). (0,1)}.
	B _ M rows: {(3,-4). (1,-1)}.
	C _ M rows: {(1,0). (1,2)}.
	self assert: A ~ B.
	self deny: A ~ C! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 8/24/2016 19:19'!
testSimilarity2
	| n M A B P |
	n _ 5 atRandom.
	M _ QQ ^ (n@n).
	A _ M atRandomBits: 10*n*n.
	[(P _ M atRandomBits: 10*n*n) isSingular] whileTrue.
	B _ M atRandomBits: 10*n*n.
	self assert: A ~ (P inverse * A * P).
	self deny: A ~ B! !

!MatrixTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:48'!
testTransposed
	| A |
	A _ ZZ ^ (6 atRandom @ 6 atRandom) :: atRandomBits: 1000.
	self assert: A columns = A transposed rows.
	self assert: A transposed transposed = A! !

!MatrixTest methodsFor: 'solving' stamp: 'len 3/5/2017 20:23:05'!
testBacklash
	"Example from Sage documentation. Non-singular and square."
	| A B X |
	A _ QQ matrix: 3 coefficients: #(1 2 4 5 3 1 1 2 -1).
	B _ QQ matrix: 3@2 coefficients: #(1 5 1 2 1 5).
	X _ A \ B.
	self assert: X = (QQ matrix: 3@2 coefficients: {-1/7. -11/7. 4/7. 23/7. 0. 0}).
	self assert: A * X = B! !

!MatrixTest methodsFor: 'solving' stamp: 'len 7/10/2019 10:07:38'!
testBacklashIntegerTuple
	"Example from Sage documentation."
	| A v x |
	A _ ZZ matrix: 2@3 coefficients: #(1 2 3 2 4 6).
	v _ ZZ tuple: #(-1 -2).
	x _ A \ v.
"	self assert: x = (ZZ tuple: #(-1 0 0))."
	self assert: A * x = v! !

!MatrixTest methodsFor: 'solving' stamp: 'len 7/10/2019 10:04:45'!
testBacklashIntegerTuple2
	"Example from GAP manual."
	| A b |
	A _ ZZ matrix: #((1 2 7) (4 5 6) (7 8 9) (10 11 19) (5 7 12)).
	A _ A transposed.
	b _ ZZ tuple: #(95 115 182).
"	x _ ZZ tuple: #(2285 -5854 4888 -1299 0)." "<- GAP comes up with this solution, but this is not very small"
	self assert: A * (A \ b) = b! !

!MatrixTest methodsFor: 'solving' stamp: 'len 7/10/2019 10:07:09'!
testBacklashIntegerTuple3
	| A b |
	A _ ZZ matrix: #((-8 1 -7 -9 -2 -1) (5 -2 3 -3 1 1) (7 0 6 4 -5 -8) (-7 -10 5 9 -4 4) (3 -4 1 -2 3 -8) (-7 3 2 6 7 -1) (4 8 5 1 -8 -9) (9 5 0 -10 -8 8) (-6 2 -6 -9 -5 6)).
	A _ A transposed.
	b _ ZZ tuple: #(3 -1 -1 -7 9 8).
	"x _ ZZ tuple: #(38 25 -6 1 -34 -12 3 -3 -44)." "shortest solution"
	self assert: A * (A \ b) = b! !

!MatrixTest methodsFor: 'solving' stamp: 'len 7/10/2019 10:04:22'!
testBacklashIntegerTupleBug
	| A b x |
	A _ ZZ matrix: 3@3 coefficients: #(1 0 0 0 1 0 0 0 10).
	b _ ZZ tuple: #(0 0 10).
	x _ A \ b.
	self assert: A * x = b! !

!MatrixTest methodsFor: 'solving' stamp: 'len 3/7/2017 08:48:20'!
testBacklashNoSolution
	"Example from Sage documentation."
	| A v |
	A _ QQ matrix: 2@3 coefficients: #(1 2 3 2 4 6).
	v _ (1,1).
	self assert: (A \ v) isNil! !

!MatrixTest methodsFor: 'solving' stamp: 'len 3/5/2017 18:13:12'!
testBacklashNonSquare
	"Example from Sage documentation."
	| A B X |
	A _ QQ matrix: 2@4 coefficients: #(0 -1 1 0 -2 2 1 0).
	B _ QQ matrix: 2@2 coefficients: #(1 0 1 -1).
	X _ A \ B.
	self assert: X = (QQ matrix: 4@2 coefficients: (-3/2, (1/2), -1, 0, 0, 0, 0, 0)).
	self assert: A * X = B! !

!MatrixTest methodsFor: 'solving' stamp: 'len 3/9/2017 08:31:55'!
testBacklashNonSquare2
	| A B X |
	A _ QQ matrix: 2@4 coefficients: #(0 0 -1 1 0 -2 2 1).
	B _ QQ matrix: 2@2 coefficients: #(1 0 1 -1).
	X _ A \ B.
	self assert: A * X = B! !

!MatrixTest methodsFor: 'solving' stamp: 'len 5/15/2019 22:52:22'!
testBacklashPascal3
	"Example from Matlab documentation. Non-singular and square."
	| A u x |
	A _ ZZ matrix: 3 coefficients: #(1 1 1 1 2 3 1 3 6). "pascal(3)"
	u _ ZZ tuple: #(3 1 4).
	x _ A \ u.
	self assert: x = (ZZ tuple: #(10 -12 5)).
	self assert: A * x = u! !

!MatrixTest methodsFor: 'solving' stamp: 'len 5/15/2019 22:52:07'!
testBacklashPascal3Magic3
	"Example from Matlab documentation. Non-singular and square."
	| A B X |
	A _ ZZ matrix: 3 coefficients: #(1 1 1 1 2 3 1 3 6). "pascal(3)"
	B _ ZZ matrix: 3 coefficients: #(8 1 6 3 5 7 4 9 2). "magic(3)"
	X _ A \ B.
	self assert: X = (ZZ matrix: 3 coefficients: #(19 -3 -1 -17 4 13 6 0 -6)).
	self assert: A * X = B! !

!MatrixTest methodsFor: 'solving' stamp: 'len 7/10/2019 10:05:10'!
testBacklashRationalTuple
	"Example from Sage documentation."
	| A v x |
	A _ QQ matrix: 3 coefficients: #(1 2 3 -1 2 5 2 3 1).
	v _ (1,2,3).
	x _ A \ v.
	self assert: x = (-13/12,(23/12),(-7/12)).
	self assert: A * x = v! !

!MatrixTest methodsFor: 'solving' stamp: 'len 7/10/2019 10:05:22'!
testBacklashRationalTuple2
	"Example from GAP manual."
	| A |
	A _ QQ matrix: #((1 2 7) (4 5 6) (7 8 9) (10 11 19) (5 7 12)).
	self assert: A transposed \ (95,115,182) = (47/4,(-17/2),(67/4),0,0) 
! !

!MatrixTest methodsFor: 'solving' stamp: 'len 3/5/2017 18:38:35'!
testBacklashSingular
	"Example from Sage documentation."
	| A B X |
	A _ QQ matrix: 2@3 coefficients: #(1 2 3 2 4 6).
	B _ QQ matrix: 2@2 coefficients: #(6 -6 12 -12).
	X _ A \ B.
	self assert: X = (QQ matrix: 3@2 coefficients: (6, -6, 0, 0, 0, 0)).
	self assert: A * X = B! !

!MatrixTest methodsFor: 'solving' stamp: 'len 3/5/2017 18:30:12'!
testBacklashTupleNonSquare
	"Example from Sage documentation."
	| A v x |
	A _ QQ matrix: 2@3 coefficients: #(1 2 3 2 4 6).
	v _ (-1/2, -1).
	x _ A \ v.
	self assert: x = (-1/2, 0, 0).
	self assert: A * x = v! !

!MatrixTest methodsFor: 'solving' stamp: 'len 4/4/2018 00:29:48'!
testCokernelMatrix
	"From Sage."
	| A B |
	A _ QQ matrix: {(1,2,4,-7,4). (1,1,0,2,-1). (1,0,3,-3,1). (0,-1,-1,3,-2). (0,0,-1,2,-1)}.
	B _ QQ matrix: {(1,0,-1,2,-1). (0,1,-1,1,-4)}.
	self assert: A cokernelMatrix "echelon" = B! !

!MatrixTest methodsFor: 'solving' stamp: 'len 11/4/2016 10:26'!
testKernel
	| A S |
	A _ QQ ^ (4@6) rows: {(1, 0, -3, 0, 2, -8). (0, 1, 5, 0, -1, 4). (0, 0, 0, 1, 7, -9). (0, 0, 0, 0, 0, 0)}.
	S _ QQ ^ 6 span: {(3,-5,1,0,0,0). (-2,1,0,-7,1,0). (8,-4,0,9,0,1)}.
	self assert: A kernel = S! !

!MatrixTest methodsFor: 'solving' stamp: 'len 5/3/2019 12:01:40'!
testKernelInteger
	"Example from GAP manual."
	| A K |
	A _ ZZ matrix: #((1 2 7) (4 5 6) (7 8 9) (10 11 19) (5 7 12)).
	A _ A transposed.
	K _ ZZ matrix: #((1 18 -9 2 -6) (0 24 -13 3 -7)).
	self assert: A kernelMatrix = K! !

!MatrixTest methodsFor: 'solving' stamp: 'len 5/3/2019 12:05:14'!
testKernelRational
	"Example from GAP manual."
	| A K |
	A _ QQ matrix: #((1 2 7) (4 5 6) (7 8 9) (10 11 19) (5 7 12)).
	A _ A transposed.
	K _ QQ matrix: {{-7/4. 9/2. -15/4. 1. 0}. {-3/4. -3/2. 1/4. 0. 1}}.
	self assert: A kernelMatrix = K! !

!MatrixTest methodsFor: 'solving' stamp: 'len 5/15/2019 23:54:17'!
testSlashWithMatrix
	| A B X  |
	A _ QQ matrix: 3 coefficients: #(1 1 3 2 0 4 -1 6 -1).
	B _ QQ matrix: 1@3 coefficients: #(2 19 8).
	X _ B / A.
	self assert: X = (QQ matrix: 1@3 coefficients: #(1 2 3)).
	self assert: X * A = B! !

!MatrixTest methodsFor: 'solving' stamp: 'len 5/15/2019 23:43:56'!
testSlashWithTuple
	| A b x  |
	A _ QQ matrix: 3 coefficients: #(1 1 3 2 0 4 -1 6 -1).
	b _ (2, 19, 8).
	x _ b / A.
	self assert: x = (1, 2, 3).
	self assert: x * A = b! !

!MatrixTest methodsFor: 'invariants' stamp: 'len 5/15/2019 13:04:52'!
testCauchyDeterminantProductFormula
	| M A B |
	M _ QQ ^ (3@3).
	A _ M rows: {(1,1,1). (3,5,7). (9,25,49)}.
	B _ M rows: {(1,0,4). (1,1,1). (2,-2,-3)}.
	self assert: A determinant * B determinant = (A * B) determinant.
	M _ ZZ ^ (3@3).
	A _ M rows: {(1,1,1). (3,5,7). (9,25,49)}.
	B _ M rows: {(1,0,4). (1,1,1). (2,-2,-3)}.
	self assert: A determinant * B determinant = (A * B) determinant! !

!MatrixTest methodsFor: 'invariants' stamp: 'len 5/15/2019 01:50:17'!
testCharacteristicMatrixAndPolynomialOverQ
	| n A |
	n _ 5 atRandom.
	A _ (QQ ^ (n@n)) atRandomBits: n*5.
	self assert: A characteristicPolynomial = A characteristicMatrix determinant! !

!MatrixTest methodsFor: 'invariants' stamp: 'len 5/15/2019 01:50:29'!
testCharacteristicMatrixAndPolynomialOverZ
	| n A |
	n _ 5 atRandom.
	A _ (ZZ ^ (n@n)) atRandomBits: n*5.
	self assert: A characteristicPolynomial = A characteristicMatrix determinant! !

!MatrixTest methodsFor: 'invariants' stamp: 'len 8/26/2016 06:05'!
testCharacteristicPolynomial
	| M A B |
	M _ QQ ^ (5@5).
	A _ M atRandomBits: 100.
	self assert: (A characteristicPolynomial value: A) isZero.
	B _ M atRandomBits: 100.
	self assert: (A*B) characteristicPolynomial = (B*A) characteristicPolynomial! !

!MatrixTest methodsFor: 'invariants' stamp: 'len 8/26/2016 06:05'!
testDeterminant
	| M m |
	M _ QQ ^ (2@2).
	m _ M rows: { (2,1). (-1,0) }.
	self assert: m determinant = 1! !

!MatrixTest methodsFor: 'invariants' stamp: 'len 8/26/2016 05:47'!
testDeterminant2
	| M vandermonde |
	M _ QQ ^ (3@3).
	vandermonde _ M rows: {(1,1,1). (3,5,7). (9,25,49)}.
	self assert: vandermonde determinant = 16.
	M _ ZZ ^ (3@3).
	vandermonde _ M rows: {(1,1,1). (3,5,7). (9,25,49)}.
	self assert: vandermonde determinant = 16! !

!MatrixTest methodsFor: 'invariants' stamp: 'len 8/26/2016 06:06'!
testMinimalPolynomial
	| M m f |
	M _ QQ ^ (5@5).
	m _ M atRandomBits: 100.
	f _ m minimalPolynomial.
	self assert: f | m characteristicPolynomial.
	self assert: (f value: m) isZero! !

!MatrixTest methodsFor: 'invariants' stamp: 'len 5/3/2018 01:25:38'!
testPermanent
	"Example from https://en.wikipedia.org/wiki/Permanent_(mathematics)"
	| A |
	A _ ZZ matrix: 4 coefficients: #(1 1 1 1 2 1 0 0 3 0 1 0 4 0 0 1).
	self assert: A permanent = 10! !

!MatrixTest methodsFor: 'invariants' stamp: 'len 8/26/2016 05:48'!
testRank
	| M vandermonde |
	M _ QQ ^ (3@3).
	vandermonde _ M rows: {(1,1,1). (3,5,7). (9,25,49)}.
	self assert: vandermonde rank = 3.
	M _ ZZ ^ (3@3).
	vandermonde _ M rows: {(1,1,1). (3,5,7). (9,25,49)}.
	self assert: vandermonde rank = 3! !

!MatrixTest methodsFor: 'invariants' stamp: 'len 8/26/2016 05:48'!
testRank2
	| M m |
	M _ QQ ^ (3@3).
	m _ M rows: {(1,1,1). (2,2,0). (3,3,1)}.
	self assert: m rank = 2.

	M _ ZZ ^ (3@3).
	m _ M rows: {(1,1,1). (2,2,2). (5,5,5)}.
	self assert: m rank = 1! !

!MatrixTest methodsFor: 'invariants' stamp: 'len 3/1/2017 17:11:33'!
testRankNullityTheorem
	| n A |
	n _ 6 atRandom.
	A _ self newRandomMatrix: n@n over: QQ.
	self assert: A rank + A nullity = n! !

!MatrixTest methodsFor: 'invariants' stamp: 'len 5/25/2019 09:48:55'!
testRankOverPolynomialsOverZ5
	"Example form Magma handbook (H88E7)."
	| K P x M a |
	K _ ZZ/5.
	P _ K polynomials.
	x _ P x.
	M _ P^(5@5).
	a _ M evaluating: [:i :j| x^i + (x^j)].
	self assert: a rank = 2! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/3/2019 05:00:17'!
testEchelonOverFiniteField
	"From Magma Handbook example H26E10."
	| K w A |
	K _ GaloisField new: 8.
	w _ K x.
	A _ K matrix: 4@3 coefficients: {1. w. w^5. 0. w^3. w^4. w. 1. w^6. w^3. 1. w^4}.
	self assert: A echelon = (K matrix: 4@3 coefficients: {1. 0. 0. 0. 1. 0. 0. 0. 1. 0. 0. 0})! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 12/4/2017 09:25:54'!
testHNFvsCHNF
	| M A |
	M _ ZZ ^ (4@4).
	A _ M atRandomBits: 50.
	self assert: A HNF = A antitransposed CHNF antitransposed! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 7/15/2016 23:53'!
testHermiteNormalForm
	"Example from wikipedia."
	| M A H |
	M _ ZZ ^ (4@4).
	A _ M rows: { (3,3,1,4). (0,1,0,0). (0,0,19,16). (0,0,0,3) }.
	H _ M rows: { (3,0,1,1). (0,1,0,0). (0,0,19,1). (0,0,0,3) }.
	self assert: A HNF = H! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 7/10/2019 15:58:34'!
testHermiteNormalForm10
	"Bug."
	| A H |
	A _ ZZ matrix: #((1 2 3 0) (1 2 3 1)).
	H _ ZZ matrix: #((1 2 3 0) (0 0 0 1)).
	self assert: A HNF = H! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 7/15/2016 23:54'!
testHermiteNormalForm2
	| M A H |
	M _ ZZ ^ (3@3).
	A _ M rows: { (9,-36,30). (-36,192,-180). (30,-180,180) }.
	H _ M rows: { (3,0,30). (0,12,0). (0,0,60) }.
	self assert: A HNF = H! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 7/15/2016 23:54'!
testHermiteNormalForm3
	"Example from wikipedia"
	| M A H |
	M _ ZZ ^ (3@4).
	A _ M rows: { (2,3,6,2). (5,6,1,6). (8,3,1,1) }.
	H _ M rows: { (1,0,50,-11). (0,3,28,-2). (0,0,61,-13) }.
	self assert: A HNF = H! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 4/4/2018 20:49:16'!
testHermiteNormalForm4
	"Example from Sage"
	| A B |
	A _ ZZ matrix: {(1,2,3,4). (5,6,7,8). (9,10,11,12)}.
	B _ ZZ matrix: {(1,2,3,4). (0,4,8,12). (0,0,0,0)}.
	self assert: A HNF = B.
	self assert: A echelon = B "the echelon form of integers matrices is the hermite normal form"! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/3/2019 05:06:02'!
testHermiteNormalForm5
	"From Magma Handbook example H26E10."
	| A H |
	A _ ZZ matrix: #((2 -4 12 7 0) (3 -3 5 -1 4) (2 -1 -4 -5 -12) (0 3 6 -2 0)).
	H _ ZZ matrix: #((1 1 1 6 -164) (0 3 0 16 -348) (0 0 2 13 -200) (0 0 0 19 -316)).
	self assert: A HNF = H! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/30/2019 04:16:51'!
testHermiteNormalForm6
	"From MuPAD documentation."
	| A H |
	A _ ZZ matrix: #(
		(25 -300 1050 -1400 630)
		(-300 4800 -18900 26880 -12600)
		(1050 -18900 79380 -117600 56700)
		(-1400 26880 -117600 179200 -88200)
		(630 -12600 56700 -88200 44100)).
	H _ ZZ matrix: #(
		(5 0 -210 -280 630)
		(0 60 0 0 0)
		(0 0 420 0 0)
		(0 0 0 840 0)
		(0 0 0 0 2520)).
	self assert: A HNF = H "this fails, but it seems to be a bug in MuPAD, because 'H isHermiteNormalForm' answers false"! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/3/2019 12:32:35'!
testHermiteNormalForm7
	"Example from GAP manual."
	| A H |
	A _ ZZ matrix: #((1 15 28) (4 5 6) (7 8 9)).
	H _ ZZ matrix: #((1 0 1) (0 1 1) (0 0 3)).
	self assert: A HNF = H! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/5/2019 07:25:25'!
testHermiteNormalForm8
	"Example from Pernet-Stein 'Fast computation of Hermite normal forms of random integer matrices'."
	| A H |
	A _ ZZ matrix: #((-5 8 -3 -9 5 5) (-2 8 -2 -2 8 5) (7 -5 -8 4 3 -4) (1 -1 6 0 8 -3)).
	H _ ZZ matrix: #((1 0 3 237 -299 90) (0 1 1 103 -130 40) (0 0 4 352 -450 135) (0 0 0 486 -627 188)).
	self assert: A HNF = H! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/5/2019 07:31:17'!
testHermiteNormalForm9
	"Example from Pernet-Stein 'Fast computation of Hermite normal forms of random integer matrices'."
	| A H |
	A _ ZZ matrix: #((-1 2 5 65 2) (4 -1 -3 1 -2) (-1 -2 1 -1 1)).
	H _ ZZ matrix: #((1 0 17 259 7) (0 1 31 453 13) (0 0 40 582 17)).
	self assert: A HNF = H! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/30/2019 04:03:25'!
testHermiteNormalFormOverPolynomials
	"From MuPAD documentation."
	| R x A H |
	R _ QQ polynomials.
	x _ R x.
	A _ R matrix: 2 coefficients: {x^2 + 3. (x*2 - 1)^2. (x + 2)^2. x^2*3 + 5}.
	H _ R matrix: 2 coefficients: {R one. (x^3*4 + (x^2*47) - (x*76) + 20) / 49. R zero. x^4 + (x^3*12) - (x^2*13) - (x*12) - 11}.
	self assert: A HNF = H! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 3/3/2017 16:36:34'!
testIsEchelonForm
	| A E |
	A _ self newRandomMatrix: 6 atRandom @ 6 atRandom over: QQ.
	E _ A echelon.
	self assert: E isEchelonForm.
	self assert: E isReducedEchelonForm! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 3/3/2017 16:33:51'!
testIsHermiteNormalForm
	"Example from wikipedia."
	| M A H |
	M _ ZZ ^ (4@4).
	A _ M rows: { (3,3,1,4). (0,1,0,0). (0,0,19,16). (0,0,0,3) }.
	H _ M rows: { (3,0,1,1). (0,1,0,0). (0,0,19,1). (0,0,0,3) }.
	self assert: A isHermiteNormalForm not.
	self assert: H isHermiteNormalForm! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 3/3/2017 16:35:49'!
testIsHermiteNormalForm2
	| M |
	M _ ZZ ^ (4@4) rows: {(2,0,1,11). (0,1,5,12). (0,0,6,12). (0,0,0,33)}.
	self assert: M isHermiteNormalForm.
	self assert: M transposed isHermiteNormalForm not.
	M _ ZZ ^ (5@4) rows: {(2,0,1,11). (0,1,5,12). (0,0,6,12). (0,0,0,33). (0,0,0,0)}.
	self assert: M isHermiteNormalForm.
	M _ ZZ ^ (5@4) rows: {(2,0,1,11). (0,1,5,12). (0,0,6,12). (0,0,0,33). (0,0,0,1)}.
	self assert: M isHermiteNormalForm not! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 3/25/2018 19:34:46'!
testJordanNormalForm
	| M A jordan B |
"	<timeout: 2>"
	M _ QQ ^ (4@4).
	A _ M rows: { (5,4,2,1). (0,1,-1,-1). (-1,-1,3,0). (1,1,-1,2) }.
	jordan _ A jordan.
	self assert: jordan size = 3.
	B _ QQ ^ (1@1) scalar: 1.
	self assert: (jordan includes: B).
	B _ QQ ^ (1@1) scalar: 2.
	self assert: (jordan includes: B).
	B _ QQ ^ (2@2) scalar: 4 :: at: 1@2 put: 1; yourself.
	self assert: (jordan includes: B)! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/29/2019 12:00:15'!
testRCF
	| A |
	A _ QQ matrix: #((-2 0 0) (-1 -4 -1) (2 4 0)).
	self assert: A RCF = (QQ matrix: #((-2 0 0) (0 0 -4) (0 1 -4)))! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 6/9/2019 11:14:04'!
testRCF2
	"Example from wikipedia:"
	| A C |
	A _ QQ matrix: #(
		(-1 3 -1 0 -2 0 0 -2)
		(-1 -1 1 1 -2 -1 0 -1)
		(-2 -6 4 3 -8 -4 -2 1)
		(-1 8 -3 -1 5 2 3 -3)
		(0 0 0 0 0 0 0 1)
		(0 0 0 0 -1 0 0 0)
		(1 0 0 0 2 0 0 0)
		(0 0 0 0 4 0 1 0)).
	C _ QQ matrix: #(
		(0 1 0 0 0 0 0 0)
		(1 1 0 0 0 0 0 0)
		(0 0 0 0 0 0 0 -1)
		(0 0 1 0 0 0 0 -4)
		(0 0 0 1 0 0 0 -4)
		(0 0 0 0 1 0 0 2)
		(0 0 0 0 0 1 0 4)
		(0 0 0 0 0 0 1 0)).
	self assert: A RCF = C! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 3/3/2017 06:11:28'!
testReducerPivots
	| A |
	A _ ZZ ^ (3@3) rows: {(0,-1,-1). (0,-20,1). (0,1,2)}.
	self assert: A reduction pivots asArray = {1@2. 2@3}! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/28/2019 09:02:44'!
testSmithNormalForm
	| A |
	A _ ZZ^(3@3) rows: { (2,4,4). (-6,6,12). (10,-4,-16) }.
	self assert: A SNF = (ZZ diagonalMatrix: #(2  6 12))! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/28/2019 09:02:29'!
testSmithNormalForm2
	| A |
	"Reduced Laplacian matrix of K_4:"
	A _ ZZ^(3@3) rows: { (3,-1,-1). (-1,3,-1). (-1,-1,3) }.
	self assert: A SNF = (ZZ diagonalMatrix: #(1  4  4))! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/28/2019 09:02:14'!
testSmithNormalForm3
	"Example from Willian Stein, 'Algebraic Number Theory, A Computational Approach'."
	| A |
	A _ ZZ^(3@3) rows: { (1,4,9). (16,25,36). (49,64,81) }.
	self assert: A SNF = (ZZ diagonalMatrix: #(1 3 72))! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/30/2019 03:25:41'!
testSmithNormalForm4
	"Smith form of a 3x3 matrix of rank 2.
	Example from Willian Stein, 'Algebraic Number Theory, A Computational Approach'."
	| A |
	A _ ZZ matrix: #((2 3 4) (5 6 7) (8 9 10)).
	self assert: A SNF = (ZZ diagonalMatrix: #(1 3 0)) "this fails with SNF because Cohen defines SNF only for nonsingular matrices, so use SNF2"! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/30/2019 13:14:46'!
testSmithNormalForm5
	"Example from youtube video: 'Derek Holt: Algorithms for finitely presented groups' @ 25:49."
	| A |
	A _ ZZ matrix: #((1 2 0 -2) (0 2 2 0) (-1 -4 4 2)).
	self assert: A SNF = (ZZ matrix: #((1 0 0 0) (0 2 0 0) (0 0 6 0)))! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/29/2019 16:05:55'!
testSmithNormalForm6
	"From Magma Handbook example H26E10."
	| A |
	A _ ZZ matrix: #((2 -4 12 7 0) (3 -3 5 -1 4) (2 -1 -4 -5 -12) (0 3 6 -2 0)).
	self assert: A elementaryDivisors = #(1 1 1 2)! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/28/2019 09:01:48'!
testSmithNormalForm7
	"From GAP manual."
	| A |
	A _ ZZ matrix: #((1 15 28) (4 5 6) (7 8 9)).
	self assert: A SNF = (ZZ diagonalMatrix: #(1 1 3))! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/30/2019 03:27:17'!
testSmithNormalForm8
	| A |
	A _ ZZ matrix: #((2 1 -3) (3 -2 -1) (1 -3 2)).
	self assert: A SNF = (ZZ diagonalMatrix: #(1 7 0))! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/30/2019 13:19:00'!
testSmithNormalForm9
	| A |
	A _ ZZ matrix: #((1 2 3 4 5 6 7) (1 0 1 0 1 0 1) (2 4 5 6 1 1 1) (1 4 2 5 2 0 0) (0 0 1 1 2 2 3)).
	self assert: A SNF = (ZZ matrix: #((1 0 0 0 0 0 0) (0 1 0 0 0 0 0) (0 0 1 0 0 0 0) (0 0 0 1 0 0 0) (0 0 0 0 2 0 0)))! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/30/2019 03:30:21'!
testSmithNormalFormDiagonal
	| A |
	A _ ZZ matrix: #((2 0 0) (0 1 0) (0 0 0)).
	self assert: A SNF = (ZZ diagonalMatrix: #(1 2 0)).
	A _ ZZ matrix: #((5 0 0) (0 2 0) (0 0 0)).
	self assert: A SNF = (ZZ diagonalMatrix: #(1 10 0))! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 5/28/2019 09:03:19'!
testSmithNormalFormOverPolynomials
	"Example from Sage documentation."
	| R x M A |
	R _ QQ polynomials.
	x _ R x.
	M _ R^(2@2).
	A _ M !! 1 * x - (M !! #(3 -4 1 -1)).
	self assert: A SNF = (R diagonalMatrix: {R one. x^2 - (x*2) + 1})! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 6/9/2019 10:10:02'!
testSmithNormalFormOverPolynomialsOverPrimeField1
	"Example form Magma handbook (H88E7)."
	| K P x M a |
	K _ ZZ/5.
	P _ K polynomials.
	x _ P x.
	M _ P^(5@5).
	a _ M evaluating: [:i :j| x^i + (x^j)].
	self assert: a elementaryDivisors = {x. x^3 + (x^2*3) + x}! !

!MatrixTest methodsFor: 'canonical forms' stamp: 'len 6/9/2019 10:49:39'!
testSmithNormalFormOverPolynomialsOverPrimeField2
	"Example form Magma handbook (H88E7)."
	| K P x a ax |
	K _ ZZ/5.
	P _ K polynomials.
	x _ P x.
	a _ ZZ matrix: 5 coefficients: #(0 2 4 2 0 2 2 2 3 3 3 4 4 1 3 0 0 0 0 1 0 0 0 1 0).
	a _ a over: P.
	ax _ a identity * x - a.
	self assert: ax SNF = (P diagonalMatrix: {P one. P one. x - 1. x^2 - 1. x^2 - 1}).
	self assert: ax elementaryDivisors = {P one. P one. x - 1. x^2 - 1. x^2 - 1}! !

!ModularIntegersTest methodsFor: 'as yet unclassified' stamp: 'len 7/8/2019 02:20:49'!
testGaloisFields
	| GF pi x one a |
	GF _ GaloisField new: 3^3.
	self assert: GF isField.
	self assert: GF characteristic = 3.
	pi _ GF projection.
	x _ pi domain x.
	one _ pi domain one.
	a _ pi value: x^2 + one.
	self assert: a * a reciprocal = GF one.
	[(a _ GF atRandom) isZero] whileTrue.
	self assert: a * a reciprocal = GF one! !

!ModularIntegersTest methodsFor: 'as yet unclassified' stamp: 'len 7/8/2019 02:21:16'!
testModularIntegerLift
	self assert: (2 to: 100 :: allSatisfy: [:m| 1 to: m :: allSatisfy: [:x| x % m :: lift % m = (x % m)]])! !

!ModularIntegersTest methodsFor: 'as yet unclassified' stamp: 'len 7/8/2019 02:21:24'!
testModularIntegersField
	| F a b |
	F _ ZZ / 7.
	self assert: F isField.
	self assert: F characteristic = 7.
	a _ F projection value: 3.
	b _ F projection value: 5.
	self assert: a * a reciprocal = F one.
	self assert: a * 7 = F zero.
	self assert: b ^ (F size - 1) = F one "Euler's theorem"! !

!ModularIntegersTest methodsFor: 'as yet unclassified' stamp: 'len 7/8/2019 02:21:40'!
testQuadraticResiduesModp
	| F |
	F _ PrimeField new: 1000 atRandom nextPrime.
	self assert: F atRandom squared isQuadraticResidue.
	self assert: ((1000 count: [F atRandom isQuadraticResidue]) between: 400 and: 600)! !

!ModularIntegersTest methodsFor: 'as yet unclassified' stamp: 'len 7/8/2019 02:21:54'!
testSmallPrimeField
	| p F E |
	p _ 20 atRandom nextPrime.
	F _ ZZ/p.
	E _ SmallPrimeField new: p.
	F do: [:a|
		F do: [:b| | c d |
			c _ E !! a representative.
			d _ E !! b representative.
			self assert: (a+b) representative = (c+d) representative.
			self assert: (a-b) representative = (c-d) representative.
			self assert: (a*b) representative = (c*d) representative.
			b isZero ifFalse:
				[self assert: (a/b) representative = (c/d) representative.
				self assert: b reciprocal representative = d reciprocal representative]]]! !

!ModularIntegersTest methodsFor: 'as yet unclassified' stamp: 'len 7/8/2019 02:22:01'!
testSmallPrimeFieldTables
	| p F g |
	p _ 20 atRandom nextPrime.
	F _ SmallPrimeField new: p.
	g _ F primitiveRoot.
	1 to: p-1 do: [:n| self assert: (F expTable at: n) = (g^n) representative].
	0 to: p-2 do: [:n| self assert: (F logTable at: (g^n) representative) = n]! !

!ModularIntegersTest methodsFor: 'as yet unclassified' stamp: 'len 7/8/2019 02:29:37'!
testSquareRootModulo2
	| F |
	F _ PrimeField new: 2.
	self assert: F zero squareRoot = F zero.
	self assert: F one squareRoot = F one! !

!ModularIntegersTest methodsFor: 'as yet unclassified' stamp: 'len 7/8/2019 02:26:30'!
testSquareRootModuloPrime
	| F a x |
	100 timesRepeat:
		[F _ PrimeField new: (1000 atRandom + 1) nextPrime.
		a _ F atRandom squared.
		x _ a squareRoot.
		self assert: x squared = a]! !

!ModularIntegersTest methodsFor: 'as yet unclassified' stamp: 'len 7/8/2019 12:54:16'!
testSquareRootModuloPrimePower
	| F a x |
	100 timesRepeat:
		[F _ PrimePowerRing new: 10 atRandom nextPrime to: 3 atRandom.
		a _ F atRandom squared.
		x _ a squareRoot.
		self assert: x squared = a]! !

!ModularIntegersTest methodsFor: 'as yet unclassified' stamp: 'len 7/8/2019 02:22:18'!
testZ6IsNotPID
	self assert: (ZZ/6) isPID not! !

!ModularTest methodsFor: 'as yet unclassified' stamp: 'len 12/10/2016 12:56:12'!
testGamma0Index
	self assert: (1 to: 19 :: collect: [:each| Gamma0CongruenceSubgroup new: each :: index]) = #(1 3 4 6 6 12 8 12 12 18 12 24 14 24 24 24 18 36 20).
	self assert: (Gamma0CongruenceSubgroup new: 32041) index = 32220! !

!ModularTest methodsFor: 'as yet unclassified' stamp: 'len 12/10/2016 12:23:06'!
testGamma0NumberOfCusps
	| p |
	self assert: (1 to: 19 :: collect: [:each| Gamma0CongruenceSubgroup new: each :: numberOfCusps]) =  #(1 2 2 3 2 4 2 4 4 4 2 6 2 4 4 6 2 8 2).
	p _ 1.
	100 timesRepeat: [self assert: (Gamma0CongruenceSubgroup new: (p _ p nextPrime)) numberOfCusps = 2]! !

!ModularTest methodsFor: 'as yet unclassified' stamp: 'len 12/15/2016 23:02:48'!
testGammaIndex
	self assert: (1 to: 19 :: collect: [:each| PrincipalCongruenceSubgroup new: each :: index]) =  #(1 6 24 48 120 144 336 384 648 720 1320 1152 2184 2016 2880 3072 4896 3888 6840)! !

!ModularTest methodsFor: 'as yet unclassified' stamp: 'len 12/15/2016 23:16:41'!
testIndexOf
	| G H |
	G _ PrincipalCongruenceSubgroup new: 2.
	H _ PrincipalCongruenceSubgroup new: 8.
	self assert: (G indexOf: H) = 32 "according to GAP manual chap. 2, Gamma(2) has index 12"! !

!ModuleTest methodsFor: 'private' stamp: 'len 12/2/2016 11:11:38'!
newFreeModule
	^ self newFreeModuleOver: {ZZ. QQ. ZZ / (10 atRandom + 1)} atRandom! !

!ModuleTest methodsFor: 'private' stamp: 'len 5/14/2019 20:46:25'!
newFreeModuleOver: scalars
	| M N |
"	M _ 2 atRandom = 1 ifTrue: [scalars ^ (5 atRandom - 1)] ifFalse: [scalars ^ (5 atRandom - 1 @ (5 atRandom - 1))]."
	M _ 2 atRandom = 1 ifTrue: [scalars ^ 4 atRandom] ifFalse: [scalars ^ (4 atRandom @ 4 atRandom)].
	"don't let it get too big, or the test is too slow:"
	M rank < 4 ifTrue:
		[3 atRandom = 1 ifTrue: [^ M endomorphisms].
		N _ self newFreeModuleOver: scalars.
		N rank < 5 ifFalse: [^ M ê N].
		2 atRandom = 1 ifTrue: [^ M => N].
		2 atRandom = 1 ifTrue: [^ M ë N].
		^ M ê N].
	3 atRandom = 1 ifTrue: [^ M dual].
	^ M! !

!ModuleTest methodsFor: 'private' stamp: 'len 1/16/2018 19:07:14'!
newFreeModuleOverPID
	^ self newFreeModuleOver: {QQ. ZZ/2. ZZ. QQ polynomials} atRandom! !

!ModuleTest methodsFor: 'private' stamp: 'len 4/19/2019 04:41:09'!
newLinearMap
	| K V W |
	K _ {QQ. ZZ / #(2 3 5 7) atRandom} atRandom.
	V _ self newFreeModuleOver: K.
	W _ self newFreeModuleOver: K.
	^ V => W !! (self newMatrix: W rank @ V rank over: K)! !

!ModuleTest methodsFor: 'private' stamp: 'len 3/2/2017 04:43:47'!
newMatrix: dim over: aRing
	| samples |
	2 atRandom = 1 ifTrue: [^ aRing^dim atRandomBits: 100].
	samples _ {aRing zero. aRing one. aRing one negated}.
	^ aRing matrix: dim evaluating: [:i :j| 2 atRandom > 1 ifTrue: [aRing zero] ifFalse: [samples atRandom]]! !

!ModuleTest methodsFor: 'private' stamp: 'len 5/14/2019 20:46:35'!
newSmallFreeModuleOver: scalars
	| M N |
	M _ 2 atRandom = 1 ifTrue: [scalars ^ 3 atRandom] ifFalse: [scalars ^ (3 atRandom @ 3 atRandom)].
	"don't let it get too big, or the test is too slow:"
	M rank < 3 ifTrue:
		[3 atRandom = 1 ifTrue: [^ M endomorphisms].
		N _ self newFreeModuleOver: scalars.
		N rank < 4 ifFalse: [^ M ê N].
		2 atRandom = 1 ifTrue: [^ M => N].
		2 atRandom = 1 ifTrue: [^ M ë N].
		^ M ê N].
	3 atRandom = 1 ifTrue: [^ M dual].
	^ M! !

!ModuleTest methodsFor: 'private' stamp: 'len 9/16/2018 23:30:28'!
newSmallVectorSpace
	^ self newSmallFreeModuleOver: {QQ. ZZ / #(2 3 5 7) atRandom} atRandom! !

!ModuleTest methodsFor: 'private' stamp: 'len 9/27/2018 04:44:48'!
newVectorSpace
	^ self newFreeModuleOver: {QQ. ZZ / #(2 3 5 7) atRandom. QQ polynomials fractions. GaloisField new: 2 to: 2} atRandom! !

!ModuleTest methodsFor: 'other' stamp: 'len 5/28/2019 07:55:20'!
testAdjointMap
	| V W f a |
	V _ QQ ^ (1 to: 3) atRandom.
	W _ QQ ^ (1 to: 5) atRandom.
	f _ V => W atRandomBits: 100.
	a _ f adjoint.
	self assert: a kernel = f image annihilatorSpace.
	self assert: a image = f kernel annihilatorSpace.
	self assert: f isSurjective = a isInjective.
	self assert: f isInjective = a isSurjective! !

!ModuleTest methodsFor: 'other' stamp: 'len 5/5/2019 18:32:28'!
testAdjointProperties
	| V W U f g a |
	V _ QQ ^ (1 to: 4) atRandom.
	W _ QQ ^ (1 to: 4) atRandom.
	f _ V => W atRandomBits: 100.
	g _ V => W atRandomBits: 100.
	a _ QQ atRandomBits: 10.
	self assert: (f + g) adjoint = (f adjoint + g adjoint).
	self assert: (f * a) adjoint = (f adjoint * a).
	U _ QQ ^ (1 to: 4) atRandom.
	f _ U => V atRandomBits: 100.
	self assert: (g ∑ f) adjoint = (f adjoint ∑ g adjoint)! !

!ModuleTest methodsFor: 'other' stamp: 'len 5/28/2019 07:55:33'!
testAnnihilator
	| V v S S0 |
	V _ QQ ^ 3.
	v _ (1,-2,1).
	S _ V span: {v}.
	S0 _ S annihilatorSpace.
	self assert: S0 dimension = S codimension.
	S0 basis do: [:f| self assert: (f value: v) isZero]! !

!ModuleTest methodsFor: 'other' stamp: 'len 5/28/2019 07:56:08'!
testAnnihilatorProperties
	| V S T |
	V _ QQ ^ 5.
	S _ (V grassmannian: 4) atRandomBits: 100.
	T _ (S grassmannian: 2) atRandomBits: 100.
	T _ V span: T basis. "hack, otherwise T ambient = S"
	self assert: T <= S.
	self assert: T annihilatorSpace >= S annihilatorSpace. "reverses inclusions"
	self assert: (S + T) annihilatorSpace = (S annihilatorSpace /\ T annihilatorSpace).
	self assert: S dimension + S annihilatorSpace dimension = V dimension.
	self assert: V annihilatorSpace isTrivial.
"	self assert: S annihilator annihilator = S dual dual"! !

!ModuleTest methodsFor: 'other' stamp: 'len 5/28/2019 07:56:17'!
testAnnihilatorZ2
	| V v S S0 |
	V _ (ZZ / 2) ^ 4.
	[(v _ V atRandom) isZero] whileTrue.
	S _ V span: {v}.
	S0 _ S annihilatorSpace.
	self assert: S0 dimension = S codimension.
	S0 basis do: [:f| self assert: (f value: v) isZero]! !

!ModuleTest methodsFor: 'other' stamp: 'len 4/19/2019 04:53:50'!
testCanonicalMorphisms
	| V W |
	V _ QQ^3.
	W _ V span: {(1,2,3)}.
	self assert: (V null -> W) isZero. "canonical morphism from initial object"
	self assert: (V -> W null) isZero. "canonical morphism to terminal object"
	self assert: ((W -> W null) value: (1,2,3)) isZero.
	self assert: (W -> V value: (2,4,6)) = (2,4,6). "canonical morphism to overobject"! !

!ModuleTest methodsFor: 'other' stamp: 'len 4/23/2019 02:20:30'!
testDirectSum
	| M N S |
	M _ self newFreeModule.
	N _ self newFreeModuleOver: M scalars.
	S _ M ê N.
	self testFreeModule: S.
	self testLinearMap: (S ambient projection: 2 atRandom).
	self testLinearMap: (S ambient coprojection: 2 atRandom)! !

!ModuleTest methodsFor: 'other' stamp: 'len 9/16/2018 23:30:32'!
testDiscriminant
	| M |
	M _ ZZ^3.
	self assert: M discriminant = 1.
	self assert: (M span: {(1,2,3)}) discriminant = 14.
	self assert: (M span: {(1,2,3). (1,1,1)}) discriminant = 6 ! !

!ModuleTest methodsFor: 'other' stamp: 'len 1/21/2018 21:47:53'!
testFreeModule: M
	| c t v x y |
	x _ M atRandomBits: 10 * M rank.
	self assert: x = (M elementAt: (M coordinatesOf: x)).
	y _ M atRandomBits: 10 * M rank.
	c _ M scalars atRandomBits: 20.
	v _ x * c + y.
	t _ (M coordinatesOf: x) * c + (M coordinatesOf: y).
	self assert: v = (M elementAt: t).
"	self testLinearMap: M basis coordinatesMap"! !

!ModuleTest methodsFor: 'other' stamp: 'len 4/3/2018 20:16:34'!
testFreeModuleDiscriminant
	"From Sage documentation of FreeModule."
	| M |
	M _ ZZ^3.
	self assert: M discriminant = 1.
	self assert: (M span: {(1,2,3)}) discriminant = 14.
	self assert: (M span: {(1,2,3). (1,1,1)}) discriminant = 6! !

!ModuleTest methodsFor: 'other' stamp: 'len 5/4/2019 03:49:33'!
testFreeZModule
	| A x0 x y0 y |
	A _ ZZ freeModuleIn: #(a b c).
	x0 _ (-2,-1,3).
	x _ A elementAt: x0.
	y0 _ (1,1,1).
	y _ A elementAt: y0.
	self assert: x+y = (A elementAt: x0+y0).
	self assert: x*2-y = (A elementAt: x0*2-y0).
	self assert: (x-y-(x-y)) isZero.
	self assert: (A coordinatesOf: x) = x0! !

!ModuleTest methodsFor: 'other' stamp: 'len 5/10/2019 04:32:04'!
testGrassmannRelation
	| V S T |
	V _ self newVectorSpace.
	S _ (V grassmannian: V dimension atRandom) atRandomBits: 20.
	T _ (V grassmannian: V dimension atRandom) atRandomBits: 20.
	self assert: S dimension + T dimension = ((S + T) dimension + (S /\ T) dimension)! !

!ModuleTest methodsFor: 'other' stamp: 'len 8/26/2016 05:57'!
testGrassmannian
	| G S |
	G _ QQ^3 grassmannian: 2.
	S _ G atRandomBits: 20.
	self assert: S dimension = 2.
	self assert: (G includes: S).
	self assert: (G dual includes: S perp dual)! !

!ModuleTest methodsFor: 'other' stamp: 'len 4/3/2018 19:47:40'!
testInclusions
	| S |
	self assert: QQ^3 < (CC^3).
	self assert: ZZ^3 < (QQ^3).
	self assert: RR^3 > (QQ^3).
	self assert: CC^3 > (RR^3).
	
	S _ QQ^3 span: {(1,2,3). (1,0,1)}.
	self assert: S < (QQ^3).
	self assert: S < (CC^3).
	self deny: S < (ZZ^3).
	self deny: S > (ZZ^3)! !

!ModuleTest methodsFor: 'other' stamp: 'len 8/26/2016 05:59'!
testMatricesQ
	self testFreeModule: (QQ ^ (5 atRandom @ 5 atRandom))! !

!ModuleTest methodsFor: 'other' stamp: 'len 8/26/2016 05:46'!
testMatricesZ
	self testFreeModule: (ZZ ^ (5 atRandom @ 5 atRandom))! !

!ModuleTest methodsFor: 'other' stamp: 'len 12/2/2016 11:11:58'!
testMatricesZ2
	self testFreeModule: ((ZZ / 2) ^ (5 atRandom @ 5 atRandom))! !

!ModuleTest methodsFor: 'other' stamp: 'len 12/2/2016 11:12:02'!
testMatricesZ4
	self testFreeModule: ((ZZ / 4) ^ (5 atRandom @ 5 atRandom))! !

!ModuleTest methodsFor: 'other' stamp: 'len 8/26/2016 05:59'!
testMatrixTraceAsLinearMap
	| F f |
	F _ QQ ^ (3@3) :: dual. "linear forms"
	f _ F evaluating: [:x| x trace].
	self assert: f = ((F x: 1) + (F x: 5) + (F x: 9))! !

!ModuleTest methodsFor: 'other' stamp: 'len 5/18/2018 19:44:40'!
testOrthogonalProjection
	| V S p v |
	V _ QQ ^ 3.
	S _ V span: {(1, 1, 0). (1, 0, 0)}.
	p _ S orthogonalProjection.
	self testProjection: p.
	v _ (78, 21, 139).
	self assert: (p value: v) = (p value: (p value: v)). "idempotent at v"
	self assert: p isIdempotent.
	self assert: p kernel = S perp.
	self assert: p image = S.
	self assert: (S apply: p) = S! !

!ModuleTest methodsFor: 'other' stamp: 'len 12/15/2017 21:04:12'!
testPerp
	| V S p perp |
	V _ QQ ^ 3.
	S _ V span: {(1, 1, 1). (2, 0, -2)}.
	perp _ S perp.
	self assert: perp dimension = 1.
	self assert: (V innerProduct value: {perp basis first. S basis first}) isZero.
	self assert: (V innerProduct value: {perp basis first. S basis second}) isZero.
	p _ S orthogonalProjection.
	self assert: p kernel = perp! !

!ModuleTest methodsFor: 'other' stamp: 'len 5/10/2019 04:32:12'!
testPerpProperties
	| V S T |
	V _ QQ ^ 3.
	S _ V span: {(1, 1, 1). (2, 0, -2)}.
	T _ V span: {(1, -1, -3)}. "subspace of S"
	self assert: S + S perp = V.
	self assert: T + T perp = V.
	self assert: (S /\ S perp) isTrivial.
	self assert: S <= S perp perp.
	self assert: S perp < T perp "because S > T"! !

!ModuleTest methodsFor: 'other' stamp: 'len 12/2/2016 11:17:38'!
testPerpZ2
	| V S perp |
	V _ (ZZ / 2) ^ 3.
	S _ V span: {(1,1,1) % 2}.
	perp _ S perp.
	self assert: perp dimension = 2.
	self assert: (V innerProduct value: {S basis first. perp basis first}) isZero.
	self assert: (V innerProduct value: {S basis first. perp basis second}) isZero! !

!ModuleTest methodsFor: 'other' stamp: 'len 10/6/2016 10:36'!
testQuotientMaps
	| V S Q pi v s |
	V _ QQ ^ 5.
	S _ V grassmannian: (1 to: V dimension) atRandom :: atRandomBits: 50.
	Q _ V/S.
	pi _ Q projection.
	v _ V atRandomBits: 100.
	s _ pi value: v.
	self assert: (Q includes: s).
	self assert: (V includes: (pi section value: s)).
	self assert: s = (pi value: (pi section value: s))! !

!ModuleTest methodsFor: 'other' stamp: 'len 5/20/2018 18:36:29'!
testQuotientModuleAnnihilator
	"Example from Sage"
	| v1 v2 v3 V W |
	v1 _ (1/2,0,0). v2 _ (3/2,2,1). v3 _ (0,0,1).
	V _ QQ^3 span: {v1. v2. v3} over: ZZ.
	W _ QQ^3 span: {v1 + (v2*2). v1*9 + (v2*2). v3*4} over: ZZ.
	self assert: (V/W) annihilator = (ZZ*16)! !

!ModuleTest methodsFor: 'other' stamp: 'len 5/20/2018 18:36:36'!
testQuotientModuleInvariants
	"Example from Sage"
	| v1 v2 v3 V W |
	v1 _ (1/2,1,1). v2 _ (3/2,2,1). v3 _ (0,0,1).
	V _ QQ^3 span: {v1. v2. v3} over: ZZ.
	W _ QQ^3 span: {v1*2 + (v2*4). v1*9 + (v2*12). v3*4} over: ZZ.
	self assert: (V/W) invariants = #(1 4 12)! !

!ModuleTest methodsFor: 'other' stamp: 'len 5/20/2018 18:36:42'!
testQuotientModuleInvariants2
	"Example from Sage"
	| V W |
	V _ ZZ^3.
	W _ V span: {(1,2,0). (0,1,0). (0,2,0)}.
	self assert: (V/W) invariants = #(1 1 0) "from example in sage fpg_module.py"! !

!ModuleTest methodsFor: 'other' stamp: 'len 5/20/2018 18:39:57'!
testQuotientModuleIsFinite
	"Example from Sage"
	| v1 v2 v3 V W |
	v1 _ (1/2,0,0). v2 _ (3/2,2,1). v3 _ (0,0,1).
	V _ QQ^3 span: {v1. v2. v3} over: ZZ.
	W _ QQ^3 span: {v1 + (v2*2). v1*9 + (v2*2). v3*4} over: ZZ.
	self assert: (V/W) isFinite.
	W _ V null.
	self assert: (V/W) isFinite not! !

!ModuleTest methodsFor: 'other' stamp: 'len 5/2/2019 10:12:41'!
testQuotientSpace
	| M S Q |
	M _ self newVectorSpace.
	S _ M grassmannian: (1 to: M rank) atRandom :: atRandomBits: M rank * 10.
	Q _ M/S.
	self assert: Q rank = (M rank - S rank).
	self assert: (Q includes: S + (M atRandomBits: M rank * 10)).
	self assert: (M / M null) rank = M rank.
	self assert: (M / M) rank = 0! !

!ModuleTest methodsFor: 'other' stamp: 'len 5/19/2018 17:25:25'!
testQuotientSpace2
	| M x |
	M _ QQ^3 / (1,2,3).
	x _ M projection value: (1,2,3).
	self assert: x isZero.
"	self assert: (M lifting value: x) = (0,0,0)"! !

!ModuleTest methodsFor: 'other' stamp: 'len 5/14/2019 18:51:08'!
testSubmoduleInclusionOver: aRing
	| V S P v w |
	V _ aRing^3.
	[v _ V atRandomBits: 10. v isZero] whileTrue.
	S _ V span: {v}.
	[w _ V atRandomBits: 10. S includes: w] whileTrue.
	P _ V span: {w*(V scalars atRandomBits: 10)-v. w}.
	self assert: S < P.
	self assert: P > S.
	self assert: S ~= P.
	self assert: P ~= S.
	self assert: (S > P) not.
	self assert: (P < S) not! !

!ModuleTest methodsFor: 'other' stamp: 'len 5/14/2019 18:52:35'!
testSubmoduleInclusionOverBinaryPolynomials
	self testSubmoduleInclusionOver: (ZZ/2) polynomials! !

!ModuleTest methodsFor: 'other' stamp: 'len 5/14/2019 18:52:18'!
testSubmoduleInclusionOverRationalPolynomials
	self testSubmoduleInclusionOver: QQ polynomials! !

!ModuleTest methodsFor: 'other' stamp: 'len 5/14/2019 18:51:56'!
testSubmoduleInclusionOverZ
	self testSubmoduleInclusionOver: ZZ! !

!ModuleTest methodsFor: 'other' stamp: 'len 7/10/2019 16:45:30'!
testSubmoduleIntersection
	| V S T T2 |
	V _ ZZ ^ 3.
	S _ V span: {(1, 1, 1). (2, 0, -2)}.
"	self assert: S /\ S ambientSpace = S." "intersection with the ambient vector space Q^3"
	self assert: S /\ V = S. "intersection with over lattice Z^3"
	self assert: S /\ S = S.
	T _ V span: {(3,1,-1)}.
	self assert: S /\ T = T.
	T2 _ V span: {(3,1,-1). (0,1,0)}.
	self assert: S /\ T2 = T! !

!ModuleTest methodsFor: 'other' stamp: 'len 7/10/2019 16:45:16'!
testSubmoduleIntersectionWithAmbientSpace
	| V S |
	V _ ZZ ^ 3.
	S _ V span: {(1, 1, 1). (2, 0, -2)}.
	self assert: S /\ S ambientSpace = S "intersection with the ambient vector space Q^3"! !

!ModuleTest methodsFor: 'other' stamp: 'len 4/10/2018 16:32:42'!
testSubmoduleSum
	| V v w S T P |
	V _ ZZ ^ 3.
	[v _ V atRandomBits: 10. v isZero not] whileFalse.
	[w _ V atRandomBits: 10. w isZero not and: [v ~= w]] whileFalse.
	S _ V span: {v}.
	T _ V span: {w}.
	P _ V span: {v. w}.
	self assert: S + T = P.
	self assert: T + S = P.
	T _ V span: {v - w. v + w}.
	self assert: S + T = P! !

!ModuleTest methodsFor: 'other' stamp: 'len 8/26/2016 06:02'!
testSubspaceInclusion
	| V S P v w |
	V _ QQ ^ 3.
	[v _ V atRandomBits: 10. v isZero] whileTrue.
	S _ V span: {v}.
	[w _ V atRandomBits: 10. S includes: w] whileTrue.
	P _ V span: {v-w. w}.
	self assert: S < P.
	self assert: P > S.
	self assert: S ~= P.
	self assert: P ~= S.
	self assert: (S > P) not.
	self assert: (P < S) not! !

!ModuleTest methodsFor: 'other' stamp: 'len 5/10/2019 04:32:46'!
testSubspaceIntersection
	| V S T T2 |
	V _ QQ ^ 3.
	S _ V span: {(1, 1, 1). (2, 0, -2)}.
	self assert: S /\ V = S.
	self assert: S /\ S = S.
	T _ V span: {(3,1,-1)}.
	self assert: S /\ T = T.
	T2 _ V span: {(3,1,-1). (0,1,0)}.
	self assert: S /\ T2 = T! !

!ModuleTest methodsFor: 'other' stamp: 'len 8/26/2016 06:02'!
testSubspaceOfSubspace
	| V S s T t |
	V _ QQ ^ 3.
	S _ (V grassmannian: 2) atRandomBits: 100.
	T _ (S grassmannian: 1) atRandomBits: 100.
	self assert: S < V.
	self assert: T < S.
	self assert: T < V.
	[s _ S atRandomBits: 100. T includes: s] whileTrue.
	[t _ T atRandomBits: 100. t isZero] whileTrue.
	self assert: (S includes: s).
	self assert: (S includes: t).
	self assert: (T includes: t)! !

!ModuleTest methodsFor: 'other' stamp: 'len 4/10/2018 16:31:03'!
testSubspaceSum
	| V v w S T P |
	V _ QQ ^ 3.
	[v _ V atRandomBits: 10. v isZero not] whileFalse.
	[w _ V atRandomBits: 10. w isZero not and: [v ~= w]] whileFalse.
	S _ V span: {v}.
	T _ V span: {w}.
	P _ V span: {v. w}.
	self assert: S + T = P.
	self assert: T + S = P.
	T _ V span: {v - w. v + w}.
	self assert: S + T = P! !

!ModuleTest methodsFor: 'other' stamp: 'len 3/8/2017 10:26:16'!
testSubspaceSumRandom
	| V S T U |
	V _ QQ^5.
	S _ (V grassmannian: (0 to: V dimension) atRandom) atRandomBits: 100.
	T _ (V grassmannian: (0 to: V dimension) atRandom) atRandomBits: 100.
	U _ S + T.
	self assert: S <= U.
	self assert: T <= U! !

!ModuleTest methodsFor: 'other' stamp: 'len 8/26/2016 06:03'!
testTuplesQ
	self testFreeModule: (QQ ^ 5 atRandom)! !

!ModuleTest methodsFor: 'other' stamp: 'len 9/22/2018 19:02:24'!
testTuplesRationalFunctionsQ
	| F |
	F _ QQ polynomials fractions.
	self testFreeModule: F ^ 3 atRandom! !

!ModuleTest methodsFor: 'other' stamp: 'len 8/26/2016 05:46'!
testTuplesZ
	self testFreeModule: (ZZ ^ 5 atRandom)! !

!ModuleTest methodsFor: 'other' stamp: 'len 12/2/2016 11:12:06'!
testTuplesZ2
	self testFreeModule: ((ZZ / 2) ^ 5 atRandom)! !

!ModuleTest methodsFor: 'other' stamp: 'len 12/2/2016 11:12:11'!
testTuplesZ4
	self testFreeModule: ((ZZ / 4) ^ 5 atRandom)! !

!ModuleTest methodsFor: 'isomorphisms' stamp: 'len 4/19/2019 04:41:54'!
testFirstIsomorphismTheorem2
	| V S T f |
	V _ QQ ^ 5.
	S _ V grassmannian: (1 to: V dimension) atRandom :: atRandomBits: 50.
	T _ V grassmannian: (1 to: V dimension) atRandom :: atRandomBits: 50.
	f _ S => T atRandomBits: 50.
	self assert: f domain / f kernel ~ f image! !

!ModuleTest methodsFor: 'isomorphisms' stamp: 'len 4/19/2019 04:42:03'!
testFirstIsomorphismTheorem: M
	| S T f phi |
	S _ M grassmannian: (1 to: M rank) atRandom :: atRandomBits: 50.
	T _ M grassmannian: (1 to: M rank) atRandom :: atRandomBits: 50.
	f _ S => T atRandomBits: 50.
	phi _ S / f kernel to: f image evaluating: [:x| f value: x representative].
	self assert: phi isIsomorphism! !

!ModuleTest methodsFor: 'isomorphisms' stamp: 'len 5/2/2018 17:39:34'!
testFirstIsomorphismTheoremOverCyclotomicField
	self testFirstIsomorphismTheorem: (CyclotomicField new: 7) ^ 5! !

!ModuleTest methodsFor: 'isomorphisms' stamp: 'len 5/2/2018 17:40:49'!
testFirstIsomorphismTheoremOverGaloisField
	self testFirstIsomorphismTheorem: (GaloisField new: 10 atRandom nextPrime to: 3 atRandom + 1) ^ 5! !

!ModuleTest methodsFor: 'isomorphisms' stamp: 'len 9/23/2018 00:56:37'!
testFirstIsomorphismTheoremOverPolynomials
	self testFirstIsomorphismTheorem: QQ polynomials ^ 2! !

!ModuleTest methodsFor: 'isomorphisms' stamp: 'len 5/2/2018 17:36:38'!
testFirstIsomorphismTheoremOverQ
	self testFirstIsomorphismTheorem: QQ ^ 5! !

!ModuleTest methodsFor: 'isomorphisms' stamp: 'len 5/2/2018 17:41:40'!
testFirstIsomorphismTheoremOverQuadraticField
	self testFirstIsomorphismTheorem: (QuadraticField sqrt: -5) ^ 5! !

!ModuleTest methodsFor: 'isomorphisms' stamp: 'len 9/23/2018 00:56:16'!
testFirstIsomorphismTheoremOverZ
	self testFirstIsomorphismTheorem: ZZ^3! !

!ModuleTest methodsFor: 'isomorphisms' stamp: 'len 5/10/2019 04:32:20'!
testSecondIsomorphismTheorem: M
	| S T |
	S _ M grassmannian: (0 to: M rank) atRandom :: atRandomBits: 50.
	T _ M grassmannian: (0 to: M rank) atRandom :: atRandomBits: 50.
	self assert: S+T <= M.
	self assert: S /\ T <= M.
	self assert: (S+T)/T ~ (S/(S /\ T))
"	f _ S -> T :: atRandomBits: 10.
	phi _ S / f kernel -> f image evaluating: [:x| f value: x representative].
	self assert: phi isIsomorphism"! !

!ModuleTest methodsFor: 'isomorphisms' stamp: 'len 5/2/2018 17:43:35'!
testSecondIsomorphismTheoremOverCyclotomicField
	self testSecondIsomorphismTheorem: (CyclotomicField new: 7) ^ 5! !

!ModuleTest methodsFor: 'isomorphisms' stamp: 'len 5/2/2018 17:43:03'!
testSecondIsomorphismTheoremOverGaloisField
	self testSecondIsomorphismTheorem: (GaloisField new: 10 atRandom nextPrime to: 3 atRandom + 1) ^ 5! !

!ModuleTest methodsFor: 'isomorphisms' stamp: 'len 9/23/2018 00:56:47'!
testSecondIsomorphismTheoremOverPolynomials
	self testSecondIsomorphismTheorem: QQ polynomials ^ 2! !

!ModuleTest methodsFor: 'isomorphisms' stamp: 'len 5/2/2018 17:35:46'!
testSecondIsomorphismTheoremOverQ
	self testSecondIsomorphismTheorem: QQ ^ 5! !

!ModuleTest methodsFor: 'isomorphisms' stamp: 'len 5/2/2018 17:42:41'!
testSecondIsomorphismTheoremOverQuadraticField
	self testSecondIsomorphismTheorem: (QuadraticField sqrt: -5) ^ 5! !

!ModuleTest methodsFor: 'isomorphisms' stamp: 'len 9/23/2018 00:57:13'!
testSecondIsomorphismTheoremOverZ
	self testSecondIsomorphismTheorem: ZZ^3! !

!ModuleTest methodsFor: 'isomorphisms' stamp: 'len 5/2/2018 17:33:15'!
testThirdIsomorphismTheorem: M
	| S T |
	S _ M grassmannian: (0 to: M rank) atRandom :: atRandomBits: 50.
	T _ S grassmannian: (0 to: S rank) atRandom :: atRandomBits: 50.
	self assert: S/T <= (M/T).
	self assert: (M/T)/(S/T) ~ (M/S)! !

!ModuleTest methodsFor: 'isomorphisms' stamp: 'len 5/2/2018 17:43:44'!
testThirdIsomorphismTheoremOverCyclotomicField
	self testThirdIsomorphismTheorem: (CyclotomicField new: 7) ^ 5! !

!ModuleTest methodsFor: 'isomorphisms' stamp: 'len 5/2/2018 17:43:16'!
testThirdIsomorphismTheoremOverGaloisField
	self testThirdIsomorphismTheorem: (GaloisField new: 10 atRandom nextPrime to: 3 atRandom + 1) ^ 5! !

!ModuleTest methodsFor: 'isomorphisms' stamp: 'len 9/23/2018 00:56:57'!
testThirdIsomorphismTheoremOverPolynomials
	self testThirdIsomorphismTheorem: QQ polynomials ^ 2! !

!ModuleTest methodsFor: 'isomorphisms' stamp: 'len 5/2/2018 17:33:45'!
testThirdIsomorphismTheoremOverQ
	self testThirdIsomorphismTheorem: QQ ^ 5! !

!ModuleTest methodsFor: 'isomorphisms' stamp: 'len 5/2/2018 17:42:52'!
testThirdIsomorphismTheoremOverQuadraticField
	self testThirdIsomorphismTheorem: (QuadraticField sqrt: -5) ^ 5! !

!ModuleTest methodsFor: 'isomorphisms' stamp: 'len 9/23/2018 00:57:20'!
testThirdIsomorphismTheoremOverZ
	self testThirdIsomorphismTheorem: ZZ^3! !

!ModuleTest methodsFor: 'linear maps' stamp: 'len 1/14/2018 22:24:08'!
testLinearForm1
	| V f |
	V _ QQ ^ 3.
	f _ V dual evaluating: [:v| v x + v y - v z].
	self assert: (f value: (1,1,1)) = 1.
	self assert: (f value: (2,2,1)) = 3.
	self assert: (f value: (3,1, -1)) = 5! !

!ModuleTest methodsFor: 'linear maps' stamp: 'len 1/14/2018 22:24:16'!
testLinearForm2
	| V f |
	V _ QQ ^ 3.
	f _ V dual evaluating: [:v| v x + v y - v z].
	self assert: f domain = V.
	self assert: f kernel dimension = 2.
	self assert: f image dimension = 1! !

!ModuleTest methodsFor: 'linear maps' stamp: 'len 8/26/2016 05:58'!
testLinearFormAsPolynomial
	| V f x |
	V _ QQ ^ 5 atRandom.
	f _ V dual atRandomBits: 100.
	x _ V atRandomBits: 100.
	self assert: (f value: x) = (f asPolynomial value: x).
	self assert: f asPolynomial asLinearForm = f! !

!ModuleTest methodsFor: 'linear maps' stamp: 'len 1/14/2018 22:24:23'!
testLinearFormZ2
	| V f |
	V _ (PrimeField new: 2) ^ 4.
	f _ V dual evaluating: [:v| v sum].
	self assert: f domain = V.
	self assert: f kernel dimension = 3.
	self assert: f image dimension = 1.
	self assert: (f kernel includes: (1,1,1,1) % 2)! !

!ModuleTest methodsFor: 'linear maps' stamp: 'len 3/2/2017 04:46:35'!
testLinearMap
	| f |
	f _ self newLinearMap.
	self testLinearMap: f! !

!ModuleTest methodsFor: 'linear maps' stamp: 'len 10/16/2016 09:17'!
testLinearMap: f
	| a1 a2 b1 b2 x |
	a1 _ f domain atRandomBits: 20.
	a2 _ f domain atRandomBits: 20.
	b1 _ f value: a1.
	b2 _ f value: a2.
	self assert: (f value: f domain zero) isZero.
	x _ f domain scalars atRandomBits: 20.
	self assert: (f value: a1 * x + a2) = (b1 * x + b2)! !

!ModuleTest methodsFor: 'linear maps' stamp: 'len 5/5/2019 18:32:36'!
testLinearMapAdjoint
	| V W f fAdjoint phi |
	V _ self newFreeModuleOver: QQ.
	W _ self newFreeModuleOver: QQ.
	f _ V => W atRandomBits: 50.
	fAdjoint _ f adjoint.
	self assert: fAdjoint domain = f codomain dual.
	self assert: fAdjoint codomain = f domain dual.
	phi _ W dual atRandomBits: 20.
	self assert: (fAdjoint value: phi) = (phi ∑ f)! !

!ModuleTest methodsFor: 'linear maps' stamp: 'len 5/5/2019 18:32:47'!
testLinearMapComposition
	| X Y Z f g x |
	X _ QQ ^ 3.
	Y _ QQ ^ 5.
	Z _ QQ ^ 4.
	f _ X => Y atRandomBits: 1000.
	g _ Y => Z atRandomBits: 1000.
	x _ X atRandomBits: 1000.
	self assert: (X => Z includes: g ∑ f).
	self assert: (g ∑ f value: x) = (g value: (f value: x)).
	self should: [f ∑ g] raise: DomainError! !

!ModuleTest methodsFor: 'linear maps' stamp: 'len 5/5/2019 18:32:52'!
testLinearMapCompositionError
	| X Y Z f g |
	X _ QQ ^ 3.
	Y _ QQ ^ 5.
	Z _ QQ ^ 4.
	f _ X => Y atRandomBits: 1000.
	g _ Y => Z atRandomBits: 1000.
	self should: [f ∑ g] raise: DomainError! !

!ModuleTest methodsFor: 'linear maps' stamp: 'len 3/2/2017 04:53:31'!
testLinearMapImage
	| f image v w |
	f _ self newLinearMap.
	image _ f image.
	v _ f domain atRandomBits: 100.
	w _ f value: v.
	self assert: (image includes: w)! !

!ModuleTest methodsFor: 'linear maps' stamp: 'len 5/5/2019 18:33:02'!
testLinearMapInverse
	| V f |
	V _ QQ ^ 3.
	f _ V automorphisms atRandomBits: 1000.
	self assert: (f ∑ f inverse) isIdentity.
	self assert: (f inverse ∑ f) isIdentity! !

!ModuleTest methodsFor: 'linear maps' stamp: 'len 3/2/2017 04:53:46'!
testLinearMapKernel
	| f kernel v |
	f _ self newLinearMap.
	kernel _ f kernel.
	v _ kernel atRandomBits: 100.
	self assert: (f value: v) isZero! !

!ModuleTest methodsFor: 'linear maps' stamp: 'len 1/14/2018 22:24:29'!
testLinearMapKernelZ2
	| V f kernel |
	V _ (PrimeField new: 2) ^ 3.
	f _ V dual evaluating: [:v| v sum].
	kernel _ f kernel.
	self assert: (kernel apply: f) isTrivial.
	self assert: kernel dimension = 2.
	self assert: (kernel includes: (0,1,1) % 2)! !

!ModuleTest methodsFor: 'linear maps' stamp: 'len 5/16/2019 12:27:12'!
testLinearMapLeftInverse
	| V W f |
	V _ QQ ^ 3.
	W _ QQ ^ 5.
	[f _ V => W atRandomBits: 1000. f rank = 3] whileFalse.
	self assert: f retraction ∑ f = V id! !

!ModuleTest methodsFor: 'linear maps' stamp: 'len 5/27/2019 07:10:28'!
testLinearMapPreimage
	| f w v |
	f _ self newLinearMap.
	w _ f image atRandomBits: 100.
	v _ (f preimage: w) atRandomBits: 100.
	self assert: (f value: v) = w! !

!ModuleTest methodsFor: 'linear maps' stamp: 'len 5/5/2019 18:33:13'!
testLinearMapRetraction
	| V W f r |
	V _ QQ^3.
	W _ QQ^4.
	[f _ V => W atRandomBits: 100. f isInjective] whileFalse.
	r _ f retraction.
	self assert: r isSurjective.
	self assert: r ∑ f = V id! !

!ModuleTest methodsFor: 'linear maps' stamp: 'len 5/16/2019 12:28:58'!
testLinearMapRightInverse
	| V W f |
	V _ QQ ^ 5.
	W _ QQ ^ 3.
	[f _ V => W atRandomBits: 1000. f rank = 3] whileFalse.
	self assert: f ∑ f section = W id! !

!ModuleTest methodsFor: 'linear maps' stamp: 'len 5/5/2019 18:33:22'!
testLinearMapSection
	| V W f s |
	V _ QQ^4.
	W _ QQ^3.
	[f _ V => W atRandomBits: 100. f isSurjective] whileFalse.
	s _ f section.
	self assert: s isInjective.
	self assert: f ∑ s = W id! !

!ModuleTest methodsFor: 'linear maps' stamp: 'len 11/2/2016 04:01'!
testLinearMapZ2
	| V f kernel v |
	V _ (PrimeField new: 2) ^ (5 atRandom + 1).
	[f _ V endomorphisms atRandom.
	(kernel _ f kernel) isTrivial or: [kernel = V]] whileTrue. "find one with non-trivial kernel"
	[v _ V atRandom. kernel includes: v] whileTrue.
	self assert: (f value: v) isZero not.
	v _ kernel atRandom.
	self assert: (f value: v) isZero! !

!ModuleTest methodsFor: 'linear maps' stamp: 'len 5/18/2018 19:43:10'!
testProjection: f
	| v |
	self testLinearMap: f.
	v _ f domain atRandomBits: 20.
	self assert: (f value: v) = (f value: (f value: v)). "idempotent at v"
	self assert: f isIdempotent.
	self assert: (f image apply: f) = f image.
	self assert: (f codomain apply: f) = f image! !

!ModuleTest methodsFor: 'bugs' stamp: 'len 3/13/2018 18:38:37'!
testPIDCoordinatesOfBug
	| M S |
	M _ self newFreeModuleOverPID.
	S _ M grassmannian: (1 to: M rank) atRandom :: atRandomBits: 50.
	self assert: (S generators allSatisfy: [:each| (S coordinatesOf: each) notNil])! !

!ModuleTest methodsFor: 'tensor product' stamp: 'len 5/14/2019 20:46:43'!
testTensorHomAdjunction
	| V W U A B |
	V _ self newSmallVectorSpace.
	W _ self newSmallFreeModuleOver: V scalars.
	U _ self newSmallFreeModuleOver: V scalars.
	A _ VëW => U.
	B _ V => (W => U).
	self assert: A ~ B.
"	phi _ A to: B evaluating: [:f| B evaluating: [:v| (W to: U) evaluating: [:w| f value: víw]]].
	self testLinearMap: phi.
	self assert: phi isIsomorphism"! !

!ModuleTest methodsFor: 'tensor product' stamp: 'len 5/14/2019 20:46:56'!
testTensorProductAssociativity
	| V1 V2 V3 |
	V1 _ QQ ^ 2.
	V2 _ QQ ^ 3.
	V3 _ QQ ^ 4.
	self assert: (V1 ë V2) ë V3 ~ (V1 ë (V2 ë V3))! !

!ModuleTest methodsFor: 'tensor product' stamp: 'len 5/14/2019 20:47:05'!
testTensorProductCommutativity
	| V W |
	V _ QQ ^ 3.
	W _ QQ ^ 4.
	self assert: V ë W ~ (W ë V)! !

!ModuleTest methodsFor: 'tensor product' stamp: 'len 5/14/2019 20:47:13'!
testTensorProductDimension
	| V1 V2 |
	V1 _ QQ ^ 5 atRandom.
	V2 _ QQ ^ 5 atRandom.
	self assert: (V1 ë V2) dimension = (V1 dimension * V2 dimension)! !

!ModuleTest methodsFor: 'tensor product' stamp: 'len 5/14/2019 20:47:21'!
testTensorProductDualHomIsomorphism
	| V W A B |
	V _ self newVectorSpace.
	W _ self newFreeModuleOver: V scalars.
	A _ V dual ë W.
	B _ V => W.
	self assert: A ~ B
"	phi _ A to: B evaluating: [:t| B evaluating: [:v| t second * (t first value: v)]].
	self testLinearMap: phi.
	self assert: phi isIsomorphism"! !

!ModuleTest methodsFor: 'tensor product' stamp: 'len 5/14/2019 20:47:33'!
testTensorProductDualIsomorphism
	| V W A B |
	V _ self newVectorSpace.
	W _ self newFreeModuleOver: V scalars.
	A _ V dual ë W dual.
	B _ (V ë W) dual.
	self assert: A ~ B
"	phi _ A to: B evaluating: [:s| B evaluating: [:t| (s first value: t first) * (s second value: t second)]].
	self testLinearMap: phi.
	self assert: phi isIsomorphism"! !

!ModuleTest methodsFor: 'tensor product' stamp: 'len 5/14/2019 20:47:39'!
testTensorProductOfLinearForms
	| V f g t v w |
	V _ QQ ^ 3.
	f _ V dual atRandomBits: 10.
	g _ V dual atRandomBits: 10.
	t _ f ë g.
	v _ V atRandomBits: 10.
	w _ V atRandomBits: 10.
	self assert: (t value: t domain !! {v. w}) = (t codomain !! {f value: v. g value: w})! !

!ModuleTest methodsFor: 'tensor product' stamp: 'len 5/14/2019 20:47:47'!
testTensorProductRelations
	| V W T v v1 v2 w w1 w2 c |
	V _ self newVectorSpace.
	W _ self newFreeModuleOver: V scalars.
	T _ V ë W.
	v _ V atRandomBits: 40.
	v1 _ V atRandomBits: 40.
	v2 _ V atRandomBits: 40.
	w _ W atRandomBits: 40.
	w1 _ W atRandomBits: 40.
	w2 _ W atRandomBits: 40.
	c _ V scalars atRandomBits: 40.
	self assert: (T !! {v1. w}) + (T !! {v2. w}) = (T !! {v1 + v2. w}).
	self assert: (T !! {v. w1}) + (T !! {v. w2}) = (T !! {v. w1 + w2}).
	self assert: (T !! {v. w})*c = (T !! {v*c. w}).
	self assert: (T !! {v. w})*c = (T !! {v. w*c})! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 2/26/2017 09:25:17'!
testAntigradedLexOrdering
	"Example from 'Using Algebraic Geometry', Cox, Little, O'Shea, Ch. 4, 3.2."
	| M x y |
	M _ FreeAbelianMonoid new: 2 ordering: #lglex. "antigraded lex order"
	x _ M x: 1.
	y _ M x: 2.
	self assert: M identity > x.
	self assert: x > y.
	self assert: x^2 > (x*y).
	self assert: x*y > (y^2).
	self assert: (y^2) > (x^3)! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 2/26/2017 09:25:24'!
testAntigradedRevlexOrdering
	"Example from 'Using Algebraic Geometry', Cox, Little, O'Shea, Ch. 4, 3.3."
	| M x y z ordering |
	"The antigraded revlex order:"
	ordering _ LocalGradedReverseLexicographicOrdering indeterminates: #(3 2 1).
	M _ FreeAbelianMonoid new: 3 ordering: ordering.
	x _ M x: 1.
	y _ M x: 2.
	z _ M x: 3.
	self assert: M identity > x.
	self assert: x > y.
	self assert: y > z.
	self assert: x^2 > (x*y).
	self assert: x*y > (y^2).
	self assert: (x*z) > (y*z).
	self assert: (y*z) > (z^2)! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 11/22/2016 08:31:09'!
testHash
	| m1 m2 |
	m1 _ Monomial exponents: #(1 2 0).
	m2 _ Monomial exponents: #(1 2 0 0 0 0 0).
	self assert: m1 hash = m2 hash! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 2/12/2017 06:03:09'!
testLocalMonomialOrderings
	"Examples from Magma handbook."
	| f |
	f _ ZZ polynomialsIn: #(x y z) ordering: #llex :: generate: [:x :y :z| 1 + x + y + z + (x^7) + (x^8*(y^7)) + (y^5) + (z^10)].
	self assert: f printString = '1 + x + x^7 + y + y^5 + x^8y^7 + z + z^{10}'.
	self assert: (f orderedBy: #lgrevlex) printString = '1 + z + y + x + y^5 + x^7 + z^{10} + x^8y^7'! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 2/26/2017 09:25:19'!
testMonomialDivision
	| M x y |
	M _ FreeAbelianMonoid new: 2.
	x _ M x: 1.
	self assert: x*x = (M x: 1 to: 2).
	y _ M x: 2.
	self assert: x*x*y / (x*y) = x.
	self assert: x*y*x / x = (x*y).
	self assert: x*y*x*y / (x*y) = (x*y)! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 2/26/2017 09:25:22'!
testMonomialGCD
	| M x y a b |
	M _ FreeAbelianMonoid new: 2.
	x _ M x: 1.
	y _ M x: 2.
	a _ x*x*y*y*y.
	b _ x*x*x*y*y.
	self assert: (a gcd: b) = (x*x*y*y)! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 2/26/2017 09:25:12'!
testMonomialLCM
	| M x y a b |
	M _ FreeAbelianMonoid new: 2.
	x _ M x: 1.
	y _ M x: 2.
	a _ x*x.
	b _ x*y*y.
	self assert: (a lcm: b) = (x*x*y*y)! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 1/11/2018 17:31:28'!
testMonomialOrderings
	| P x y z f lex glex grevlex |
	P _ ZZ polynomialsIn: 3.

	x _ P x.
	y _ P y.
	z _ P z.

	f _ 10*x - (7*(y^4)) + (11*(y^3)*z).

	lex _ MonomialOrdering lex: 3.
	glex _ MonomialOrdering glex: 3.
	grevlex _ MonomialOrdering grevlex: 3.

	self assert: (f orderedBy: lex) leadingCoefficient = 10.
	self assert: (f orderedBy: glex) leadingCoefficient = -7.
	self assert: (f orderedBy: grevlex) leadingCoefficient = -7 "this matches the definition in Singular"! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 2/12/2017 06:05:34'!
testMonomialOrderings2
	"Examples from Macaulay2 documentation."
	| R a b c d f |
	R _ ZZ polynomialsIn: #(a b c d).
	a _ R x: 1.
	b _ R x: 2.
	c _ R x: 3.
	d _ R x: 4.

	f _ a + (b^100) + (c*d).

	self assert: (f orderedBy: #lex) printString = 'a + b^{100} + cd'.
	self assert: (f orderedBy: #grevlex) printString = 'b^{100} + cd + a'.
	self assert: (f orderedBy: #glex) printString = 'b^{100} + cd + a'! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 2/12/2017 06:05:43'!
testMonomialOrderings3
	"Examples from Derksen, Kemper 'Computational Invariant Theory' 1.1.1."
	| P x1 x2 x3 x4 f |
	P _ ZZ polynomialsIn: 4.
	x1 _ P x: 1.
	x2 _ P x: 2.
	x3 _ P x: 3.
	x4 _ P x: 4.
	f _ x1 + (x2*x4) + (x3^2).
	self assert: (f orderedBy: #lex) leadingTerm = x1.
	self assert: (f orderedBy: #glex) leadingTerm = (x2*x4).
	self assert: (f orderedBy: #grevlex) leadingTerm = (x3^2)! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 5/10/2018 19:38:00'!
testMonomialOrderings4
	"Examples from en.wikipedia.org/wiki/Monomial_order to illustrate the difference between graded lexicographic and graded reverse lexicographic."
	| M S |
	M _ FreeAbelianMonoid new: 3 ordering: #glex.
	S _ Set new.
	1 to: 3 do: [:i| i to: 3 do: [:j| S add: (M x: i) * (M x: j)]].
	self assert: (S sorted: [:a :b| a > b]) printString = '({x1}^2, {x1}{x2}, {x1}{x3}, {x2}^2, {x2}{x3}, {x3}^2)'.
	M _ M orderedBy: #grevlex.
	S _ S collect: [:each| M !! each].
	self assert: (S sorted: [:a :b| a > b]) printString = '({x1}^2, {x1}{x2}, {x2}^2, {x1}{x3}, {x2}{x3}, {x3}^2)'! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 2/26/2017 09:25:04'!
testMonomialOrderingsExample
	| a b lex glex grevlex |
	a _ Monomial exponents: #(3 2 8).
	b _ Monomial exponents: #(2 9 2).
	
	lex _ FreeAbelianMonoid new: 3 ordering: #lex.
	glex _ FreeAbelianMonoid new: 3 ordering: #glex.
	grevlex _ FreeAbelianMonoid new: 3 ordering: #grevlex.

	self assert: (a as: lex) > (b as: lex).
	self assert: (a as: glex) > (b as: glex).
	self assert: (a as: grevlex) < (b as: grevlex)! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 5/9/2018 18:31:23'!
testMonomialOrderingsExample2
	| a b lex glex |
	a _ Monomial exponents: #(0 2 9).
	b _ Monomial exponents: #(0 5 3).
	
	lex _ FreeAbelianMonoid new: 3 ordering: #lex.
	glex _ FreeAbelianMonoid new: 3 ordering: #glex.
"	grevlex _ FreeAbelianMonoid new: 3 ordering: #grevlex."

	self assert: (b as: lex) > (a as: lex).
	self assert: (a as: glex) > (b as: glex).
"	self assert: (a as: grevlex) < (b as: grevlex)"! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 5/9/2018 18:33:34'!
testMonomialOrderingsExample3
	| a b lex glex grevlex |
	a _ Monomial exponents: #(2 1 2).
	b _ Monomial exponents: #(1 3 1).
	
	lex _ FreeAbelianMonoid new: 3 ordering: #lex.
	glex _ FreeAbelianMonoid new: 3 ordering: #glex.
	grevlex _ FreeAbelianMonoid new: 3 ordering: #grevlex.

	self assert: (a as: lex) > (b as: lex).
	self assert: (a as: glex) > (b as: glex).
	self assert: (a as: grevlex) < (b as: grevlex)! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 2/26/2017 09:25:07'!
testMonomialOrderingsOfIndeterminates
	| M x y z |
	M _ FreeAbelianMonoid new: 3.
	x _ M x: 1.
	y _ M x: 2.
	z _ M x: 3.
	{MonomialOrdering lex: 3.
	MonomialOrdering llex: 3.
	MonomialOrdering glex: 3.
	MonomialOrdering grevlex: 3} do: [:ordering| 
		self assert: (x orderedBy: ordering) > (y orderedBy: ordering).
		self assert: (y orderedBy: ordering) > (z orderedBy: ordering)]! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 2/26/2017 09:25:09'!
testMonomialOrderingsOfIndeterminatesReordered
	| M x y z |
	M _ FreeAbelianMonoid new: 3 ordering: (MonomialOrdering lex: #(2 1 3)).
	x _ M x: 1.
	y _ M x: 2.
	z _ M x: 3.
	self assert: y > x.
	self assert: x > z! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 2/12/2017 06:06:15'!
testMonomialOrderingsSingularExample
	"'A Singular Introduction to Commutative Algebra', Example 1.2.13 (monomial orderings)."
	| f |
	f _ (QQ polynomialsIn: #(x y z)) !! [:x :y :z| x^3*y*z + (x^3) + (x*(y^2)) + (y^5) + (z^4)].
	"Global orderings:"
	self assert: (f orderedBy: #lex) printString =  'x^3yz + x^3 + xy^2 + y^5 + z^4'.
	self assert: (f orderedBy: #grevlex) printString = 'y^5 + x^3yz + z^4 + x^3 + xy^2'.
	self assert: (f orderedBy: #glex) printString = 'x^3yz + y^5 + z^4 + x^3 + xy^2'.
	"TODO: weighted total lexicographic ordering"
	"Local orderings don't match because we implemented them with Magma conventions."
! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 2/26/2017 09:25:14'!
testMonomialProduct
	| M x y |
	M _ FreeAbelianMonoid new: 2.
	x _ M x: 1.
	self assert: x*x = (M x: 1 to: 2).
	y _ M x: 2.
	self assert: x*y = (y*x).
	self assert: x*y*y = (x*(y*y)).
	self assert: ((x*y*y) at: 2) = 2.
	self assert: (x*y*x*x*y) degree = 5! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 2/12/2017 06:04:56'!
testWeightedMonomialOrderings
	| P x y z f lex glex grevlex revlex |
	P _ ZZ polynomialsIn: 3.

	x _ P x.
	y _ P y.
	z _ P z.

	f _ 10*x - (7*(y^4)) + (11*(y^3)*z).

	lex _ WeightedMonomialOrdering lex: (1 to: 3).
	glex _ WeightedMonomialOrdering glex: (1 to: 3).
	grevlex _ WeightedMonomialOrdering grevlex: (1 to: 3).
	revlex _ WeightedMonomialOrdering grevlex: (1 to: 3).

	self assert: (f orderedBy: lex) leadingCoefficient = 10.
	self assert: (f orderedBy: glex) leadingCoefficient = -7.
	self assert: (f orderedBy: grevlex) leadingCoefficient = 11.
	self assert: (f orderedBy: revlex) leadingCoefficient = 11! !

!MonomialTest methodsFor: 'as yet unclassified' stamp: 'len 1/11/2018 17:29:58'!
testWeightedMonomialOrderingsConsistency
	| P x y z f lex glex grevlex revlex |
	P _ ZZ polynomialsIn: 3.

	x _ P x.
	y _ P y.
	z _ P z.

	f _ 10*x - (7*(y^4)) + (11*(y^3)*z).

	lex _ WeightedMonomialOrdering lex: (1 to: 3).
	glex _ WeightedMonomialOrdering glex: (1 to: 3).
	grevlex _ WeightedMonomialOrdering grevlex: (1 to: 3).
	revlex _ WeightedMonomialOrdering grevlex: (1 to: 3).

	self assert: (f orderedBy: lex) monomials asArray = (f orderedBy: #lex) monomials asArray.
	self assert: (f orderedBy: glex) monomials asArray = (f orderedBy: #glex) monomials asArray.
	self assert: (f orderedBy: grevlex) monomials asArray = (f orderedBy: #grevlex) monomials asArray.
	self assert: (f orderedBy: revlex) monomials asArray = (f orderedBy: #revlex) monomials asArray! !

!NumberFieldTest methodsFor: 'as yet unclassified' stamp: 'len 12/10/2016 21:58:12'!
testCyclotomicFieldDiscriminant
	self assert: (CyclotomicField new: 20) discriminant = 4000000.
	self assert: (CyclotomicField new: 18) discriminant = -19683! !

!NumberFieldTest methodsFor: 'as yet unclassified' stamp: 'len 3/24/2018 21:34:06'!
testMinimalPolynomial
	"Example from 'Algebraic Number Theory: A Computational Approach' by William Stein (28 pp)."
	| x K a |
	x _ QQ polynomials x.
	K _ QQ extension: x^2 - 2.
	a _ K x.
	self assert: a minimalPolynomial = (x^2 - 2).
	self assert: (a/2 + 3) minimalPolynomial = (x^2 - (x*6) + (17/2))! !

!NumberFieldTest methodsFor: 'as yet unclassified' stamp: 'len 3/24/2018 21:39:43'!
testMinimalPolynomial2
	"Example from 'Algebraic Number Theory: A Computational Approach' by William Stein (29 pp)."
	| x K a alpha |
	x _ QQ polynomials x.
	K _ QuadraticField sqrt: 5.
	a _ K x.
	self assert: a squared = 5.
	alpha _ (1 + a) / 2.
	self assert: alpha minimalPolynomial = (x^2 - x - 1)! !

!NumberFieldTest methodsFor: 'as yet unclassified' stamp: 'len 3/24/2018 21:41:40'!
testMinimalPolynomial3
	"Example from 'Algebraic Number Theory: A Computational Approach' by William Stein (29 pp)."
	| x alpha |
	x _ QQ polynomials x.
	alpha _ 1 + 5 squareRoot / 2.
	self assert: alpha minimalPolynomial = (x^2 - x - 1)! !

!NumberFieldTest methodsFor: 'as yet unclassified' stamp: 'len 9/27/2018 15:45:38'!
testNormAndTrace
	| F a b |
"	x _ QQ polynomials x.
	F _ QQ extension: x^4 - (x^2*420) + 40000."
	F _ QQ extensionDegree: (2 to: 4) atRandom.
	a _ F atRandomBits: 100.
	b _ F atRandomBits: 100.
	self assert: (a + b) trace = (a trace + b trace).
	self assert: (a * b) norm = (a norm * b norm)! !

!NumberFieldTest methodsFor: 'as yet unclassified' stamp: 'len 9/27/2018 15:44:55'!
testNormOfAlgebraicInteger
	| F a |
	F _ QQ extensionDegree: (2 to: 4) atRandom.
	a _ F integers atRandomBits: 100.
	self assert: a norm isInteger! !

!NumberFieldTest methodsFor: 'as yet unclassified' stamp: 'len 5/4/2018 17:42:44'!
testNormTraceAndMinimalPolynomial
	"Example H38E17 from Magma documentation."
	| x F a |
	x _ QQ polynomials x.
	F _ QQ extension: x^4 - (x^2*420) + 40000.
	a _ F x / 2.
	self assert: a trace = 0.
	self assert: a norm = 2500.
	self assert: a minimalPolynomial = (x^4 - (x^2*105) + 2500)! !

!NumberFieldTest methodsFor: 'as yet unclassified' stamp: 'len 11/3/2016 04:40'!
testQSqrt2
	| E x |
	x _ QQ polynomials x.
	E _ QQ adjoin: RealAlgebraicNumber sqrt2.
	self assert: E x minimalPolynomial = E polynomial.
	self assert: E x squared minimalPolynomial = (x - 2)! !

!NumberFieldTest methodsFor: 'as yet unclassified' stamp: 'len 1/20/2018 19:03:04'!
testQSqrt2RealEmbeddings
	| E embeddings roots |
	E _ QQ adjoin: RealAlgebraicNumber sqrt2.
	embeddings _ E realEmbeddings.
	roots _ (E polynomial rootsIn: RR) asSet.
	self assert: (embeddings collect: [:f| f value: E x]) asSet = roots! !

!NumberFieldTest methodsFor: 'as yet unclassified' stamp: 'len 12/14/2016 14:59:36'!
testQuadraticFieldFundamentalDiscriminant
	self assert: (QuadraticField sqrt: 102) discriminant = 408.
	self assert: (QuadraticField sqrt: 720) discriminant = 5.
	self assert: (QuadraticField sqrt: 2) discriminant = 8! !

!NumberFieldTest methodsFor: 'as yet unclassified' stamp: 'len 12/10/2016 21:40:24'!
testQuadraticFieldSqrt2
	| E x |
	E _ QuadraticField sqrt: 2.
	x _ QQ polynomials x.
	self assert: E x minimalPolynomial = E polynomial.
	self assert: E x squared minimalPolynomial = (x - 2).
	self assert: E discriminant = 8! !

!NumberFieldTest methodsFor: 'as yet unclassified' stamp: 'len 12/10/2016 21:42:04'!
testQuadraticFieldSqrtMinusFive
	| E |
	E _ QuadraticField sqrt: -5.
	self assert: E x minimalPolynomial = E polynomial.
	self assert: E x squared = (E embed: -5).
	self assert: E x ^ 4 = (E embed: 25).
	self assert: E discriminant = -20! !

!NumberFieldTest methodsFor: 'as yet unclassified' stamp: 'len 4/30/2018 17:12:17'!
testSignature
	| x F |
	x _ QQ polynomials x.
	F _ NumberField polynomial: x^2 + 1.
	self assert: F signature = #(0 1).
	F _ NumberField polynomial: x^3 - 2.
	self assert: F signature = #(1 1).
	F _ CyclotomicField new: 5.
	self assert: F signature = #(0 2).
	F _ NumberField polynomial: x^6 + x + 1.
	self assert: F signature = #(0 3).
	F _ NumberField polynomial: x^3 + (x^2) - (x*5) - 1.
	self assert: F signature = #(3 0)! !

!NumberFieldTest methodsFor: 'as yet unclassified' stamp: 'len 12/10/2016 21:45:04'!
testTotallyImaginary
	| x E |
	x _ QQ polynomials x.
	E _ NumberField polynomial: x^2 + 2.
	self assert: E isImaginary.
	E _ NumberField polynomial: x^2 - 2.
	self assert: E isImaginary not.
	E _ NumberField polynomial: x^4 - 2.
	self assert: E isImaginary not! !

!NumberFieldTest methodsFor: 'as yet unclassified' stamp: 'len 12/10/2016 21:47:44'!
testTotallyReal
	| x E |
	x _ QQ polynomials x.
	E _ NumberField polynomial: x^2 + 2.
	self assert: E isReal not.
	E _ NumberField polynomial: x^2 - 2.
	self assert: E isReal.
	E _ NumberField polynomial: x^4 - 2.
	self assert: E isReal not! !

!PAdicsTest methodsFor: 'as yet unclassified' stamp: 'len 6/2/2019 11:17:07'!
testAddition
	| Z7 a b c |
	Z7 _ ZZ adic: 7 precision: 100.
	a _ Z7 !! 676.
	b _ Z7 !! 123.
	c _ Z7 !! (676+123).
	self assert: a+b = c! !

!PAdicsTest methodsFor: 'as yet unclassified' stamp: 'len 6/2/2019 11:17:28'!
testAddition2
	| Z7 a b c |
	Z7 _ ZZ adic: 7 precision: 100.
	a _ Z7 !! -676.
	b _ Z7 !! 123.
	c _ Z7 !! (-676+123).
	self assert: a+b = c! !

!PAdicsTest methodsFor: 'as yet unclassified' stamp: 'len 6/2/2019 11:12:51'!
testFractionsField
	| Z7 Q7 |
	Z7 _ ZZ adic: 7.
	Q7 _ QQ adic: 7.
	self assert: Z7 fractions = Q7! !

!PAdicsTest methodsFor: 'as yet unclassified' stamp: 'len 6/2/2019 11:14:33'!
testLocalProperties
	| Z7 |
	Z7 _ ZZ adic: 7 precision: 100.
	self assert: Z7 isLocal.
	self assert: Z7 maximalIdeal generator = (Z7 !! 7)! !

!PAdicsTest methodsFor: 'as yet unclassified' stamp: 'len 6/2/2019 11:20:00'!
testMultiplication
	| Z7 a b c |
	Z7 _ ZZ adic: 7 precision: 100.
	a _ Z7 !! 676.
	b _ Z7 !! 123.
	c _ Z7 !! (676 * 123).
	self assert: a * b = c! !

!PAdicsTest methodsFor: 'as yet unclassified' stamp: 'len 6/2/2019 11:18:03'!
testNegation
	| Z7 a b |
	Z7 _ ZZ adic: 7 precision: 100.
	a _ Z7 !! -676.
	b _ Z7 !! 676.
	self assert: a = b negated.
	self assert: a negated negated = a! !

!PAdicsTest methodsFor: 'as yet unclassified' stamp: 'len 6/5/2019 13:19:06'!
testNormAndValuation
	| Z7 x |
	Z7 _ ZZ adic: 7.
	x _ Z7 !! 13.
	self assert: x valuation = 0.
	self assert: x abs = 1.
	x _ x * (7*7).
	self assert: x valuation = 2.
	self assert: x abs = (1/(7*7)).
	Z7 _ ZZ adic: 7 precision: 100.
	x _ Z7 !! 0.
	self assert: x valuation = Infinity positive.
	self assert: x abs = 0! !

!PAdicsTest methodsFor: 'as yet unclassified' stamp: 'len 6/5/2019 11:32:10'!
testProjectionToPrimePowerRingAndLifting
	| Z7 a x |
	Z7 _ ZZ adic: 7.
	a _ (-1024 to: 1024) atRandom.
	x _ Z7 !! a.
	self assert: ((ZZ/(7^5)) !! x) lift = a.
	self assert: ((ZZ/(7^(5 to: 10) atRandom)) !! x) lift = a! !

!PAdicsTest methodsFor: 'as yet unclassified' stamp: 'len 6/2/2019 11:18:54'!
testSubstraction
	| Z7 a b c |
	Z7 _ ZZ adic: 7 precision: 100.
	a _ Z7 !! 676.
	b _ Z7 !! 123.
	c _ Z7 !! (676 - 123).
	self assert: a - b = c! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 1/9/2017 21:38:34'!
testAllMonomialsOfDegree
	| d n |
	n _ 5 atRandom.
	d _ 5 atRandom.
	self assert: (ZZ polynomialsIn: n :: allMonomialsOfDegree: d) size = (n+d-1 choose: d)! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 4/25/2018 21:52:52'!
testArithmeticOver: R
	| x f g |
	x _ R polynomials x.
	f _ x^2 + (x*2) - 1.
	g _ x^2 - (x*2) + 1.
	self assert: f+g = (x^2 * 2).
	self assert: f-g = (x*4 - 2).
	self assert: f*g = (x^4 - (x^2 * 4) + (x*4) - 1).
	self assert: f*g // g = f.
	self assert: (f*g \\ g) isZero.
	self assert: (f*g + (x - 1) \\ g) = (x - 1)
! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 4/25/2018 21:53:17'!
testArithmeticQQ
	self testArithmeticOver: QQ! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 4/25/2018 21:53:36'!
testArithmeticZ2
	self testArithmeticOver: ZZ/2! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 4/25/2018 21:53:50'!
testArithmeticZ3
	self testArithmeticOver: ZZ/3! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 4/25/2018 21:57:08'!
testArithmeticZm
	self testArithmeticOver: ZZ/(2 + 100 atRandom)! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 4/26/2018 08:16:24'!
testCRT
	| x f1 f2 f3 crt r1 r2 r3 h |
	x _ QQ polynomials x.
	f1 _ x^5 + 1.
	f2 _ x^2 + 1.
	f3 _ x - 1.
	crt _ CRT mod: {f1. f2. f3}.
	r1 _ x-1.
	r2 _ x+1.
	r3 _ x-x. "zero"
	h _ crt solve: {r1. r2. r3}.
	self assert: h \\ f1 = r1.
	self assert: h \\ f2 = r2.
	self assert: h \\ f3 = r3! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 4/30/2018 17:01:40'!
testCompanionMatrix
	| x p |
	x _ QQ polynomials x.
	p _ x^2 + (x*2) - 1.
	self assert: p companion characteristicPolynomial = p.
	self assert: p companion minimalPolynomial = p! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:50'!
testContentAndPrimitive
	| Zx Zxy x y f |
	Zx _ ZZ polynomialsIn: #(x).
	Zxy _ Zx polynomialsIn: #(y).
	x _ Zx x.
	y _ Zxy x.
	f _ 2*x*y + (2*(x^2)).
	self assert: f primitive * f content = f! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:50'!
testContentAndPrimitiveAtRandom
	| Zx f |
	Zx _ ZZ polynomials.
	f _ Zx atRandomBits: 100 maxDegree: (1 to: 10) atRandom.
	self assert: f primitive * f content = f! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:50'!
testDiscriminant
	| Zx x f g |
	Zx _ ZZ polynomials.
	x _ Zx x.
	f _ x^2 + x + 1.
	g _ x^3 + 1.
	self assert: (f*g) discriminant = (f discriminant * g discriminant * (f resultant: g) squared)! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 11/28/2016 22:09:14'!
testDiscriminant2
	| Zx x f |
	Zx _ ZZ polynomials.
	x _ Zx x.
	f _ x^2 - x - 36042.
	self assert: f discriminant = 144169 "this is a prime, although looks like a square :)"! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 7/4/2016 04:33'!
testDivision: F
	| Fx f g |
	Fx _ F polynomials.
	f _ Fx atRandomBits: 100 maxDegree: 10 atRandom.
	[g _ Fx atRandomBits: 100 maxDegree: 10 atRandom. g isZero] whileTrue.
	self assert: (f // g) * g + (f \\ g) = f! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:08'!
testDivisionQ
	self testDivision: QQ! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 10/18/2016 21:01'!
testDivisionZ2
	self testDivision: (PrimeField new: 2)! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 10/18/2016 21:01'!
testDivisionZ65535
	self testDivision: (PrimeField new: 2^17 - 1)! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 5/18/2018 20:47:02'!
testDomainError
	| f g |
	f _ ZZ polynomials atRandomBits: 10.
	self should: [f / 2] raise: DomainError.
	g _ QQ polynomials atRandomBits: 100 maxDegree: 5. "will have denominators"
	self should: [f + g] raise: DomainError.
	self should: [f * g] raise: DomainError! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 11/25/2016 10:33:07'!
testEPRS
	"Example from Zippel."
	| a b eprs |
	a _ ZZ polynomials coefficients: #(1 0 1 0 -3 -3 8 2 -5) reversed.
	b _ ZZ polynomials coefficients: #(3 0 5 0 -4 -9 21) reversed.
	eprs _ a eprs: b :: collect: [:each| each coefficients reversed asArray] :: asArray.
	self assert: eprs = #((1 0 1 0 -3 -3 8 2 -5)
		(3 0 5 0 -4 -9 21)
		(-15 0 3 0 -9) 
		(15795 30375 -59535) 
		(1254542875143750 -1654608338437500) (12593338795500743100931141992187500))! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:50'!
testEvaluationHomomorphism
	| Zx f g a |
	Zx _ ZZ polynomials.
	f _ Zx atRandomBits: 1000 maxDegree: 10.
	g _ Zx atRandomBits: 1000 maxDegree: 10.
	a _ ZZ atRandomBits: 100.
	self assert: (f+g value: a) = ((f value: a) + (g value: a)).
	self assert: (f-g value: a) = ((f value: a) - (g value: a)).
	self assert: (f*g value: a) = ((f value: a) * (g value: a)).
	self assert: (f^3 value: a) = ((f value: a)^3)! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 3/31/2016 06:56'!
testEvaluationHomomorphism: F
	| Fx f g a |
	Fx _ F polynomials.
	f _ Fx atRandomDegree: 10 atRandom.
	g _ Fx atRandomDegree: 10 atRandom.
	a _ F atRandom.
	self assert: (f+g value: a) = ((f value: a) + (g value: a)).
	self assert: (f-g value: a) = ((f value: a) - (g value: a)).
	self assert: (f*g value: a) = ((f value: a) * (g value: a)).
	self assert: (f^3 value: a) = ((f value: a)^3)! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:51'!
testEvaluationHomomorphismMultivariate
	| Zxyz f g a |
	Zxyz _ ZZ polynomialsIn: #(x y z).
	f _ Zxyz atRandomBits: 1000 maxDegree: 10.
	g _ Zxyz atRandomBits: 1000 maxDegree: 10.
	a _ ZZ ^ 3 atRandomBits: 100.
	self assert: (f+g value: a) = ((f value: a) + (g value: a)).
	self assert: (f-g value: a) = ((f value: a) - (g value: a)).
	self assert: (f*g value: a) = ((f value: a) * (g value: a)).
	self assert: (f^3 value: a) = ((f value: a)^3)! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 10/18/2016 21:01'!
testEvaluationHomomorphismZ2
	self testEvaluationHomomorphism: (PrimeField new: 2)! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 12/2/2016 11:13:08'!
testEvaluationHomomorphismZm
	self testEvaluationHomomorphism: ZZ / (2 + 100 atRandom).
	self testEvaluationHomomorphism: ZZ / (2^13 - 2).
	self testEvaluationHomomorphism: ZZ / (2^31 - 2)! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 12/2/2016 11:17:17'!
testEvaluationHomomorphismZp
	self testEvaluationHomomorphism: (PrimeField new: 3).
	self testEvaluationHomomorphism: (PrimeField new: 5).
	self testEvaluationHomomorphism: (PrimeField new: 2^13 - 1).
	self testEvaluationHomomorphism: (PrimeField new: 2^31 - 1)! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:51'!
testEvaluationMultivariate
	| Zxyz f a x y z |
	Zxyz _ ZZ polynomialsIn: #(x y z).
	x _ Zxyz x. y _ Zxyz y. z _ Zxyz z.
	f _ x^2 * y - z.
	a _ ZZ ^ 3 atRandomBits: 100.
	self assert: (f value: a) = ((a at: 1)^2 * (a at: 2) - (a at: 3))! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 2/6/2017 03:09:32'!
testExactDivisionBug
	| Zx x f |
	Zx _ ZZ polynomials.
	x _ Zx x.
	f _ x*2.
	self assert: f /// f = Zx one! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 2/6/2017 03:10:03'!
testExactDivisionMultivariate
	| Qxy x y f g |
	Qxy _ QQ polynomialsIn: #(x y).
	x _ Qxy x.
	y _ Qxy y.
	f _ x-y.
	g _ x+y.
	self assert: f * g /// g = f.
	self assert: f * g /// f = g! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 4/24/2018 19:38:33'!
testExactDivisionMultivariate2
	| Qxy x y f g |
	Qxy _ QQ polynomialsIn: #(x y).
	x _ Qxy x.
	y _ Qxy y.
	f _ x-y.
	g _ x+y.
	self assert: (f * g divisionBy: g) quotient = f.
	self assert: (f * g divisionBy: f) quotient = g! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 2/6/2017 03:10:17'!
testExactDivisionOverQ
	| x f g |
	x _ QQ polynomials x.
	f _ x^2 + x + 1.
	g _ 1 - x.
	self assert: f * g /// g = f.
	self assert: f * g /// f = g! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 2/6/2017 03:10:30'!
testExactDivisionOverQRandom
	| Qx f g |
	Qx _ QQ polynomials.
	f _ Qx atRandomBits: 100 maxDegree: (1 to: 10) atRandom.
	g _ Qx atRandomBits: 100 maxDegree: (1 to: 10) atRandom.
	self assert: f * g /// g = f.
	self assert: f * g /// f = g! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 2/6/2017 03:10:42'!
testExactDivisionOverZ
	| x f g |
	x _ ZZ polynomials x.
	f _ x^2 + x + 1.
	g _ 1 - x.
	self assert: f * g /// g = f.
	self assert: f * g /// f = g! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:08'!
testExtendedEuclidBug
	| x f1 f2 |
	x _ QQ polynomials x.
	f1 _ x^2 + 1.
	f2 _ x - 1.
	self assert: (ExtendedEuclid on: {f1. f2}) gcd = (f1 gcd: f2)! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 4/9/2018 21:26:43'!
testFiniteFieldFactorization
	| F Fx x one f factors |
	F _ ZZ / 3.
	Fx _ F polynomials.
	x _ Fx x.
	one _ Fx one.
	f _ x^11 + (x^9 * 2) + (x^8 * 2) + (x^6) + (x^5) + (x^3 * 2) + (x^2 * 2) + one.
	factors _ f factors.
	self assert: factors size = 8.
	self assert: (factors occurrencesOf: x + (one*2)) = 4.
	self assert: (factors occurrencesOf: x^2 + one) = 3.
	self assert: (factors occurrencesOf: x + one) = 1.
	self assert: (factors inject: Fx one into: [:a :b| a*b]) = f! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 12/2/2016 11:16:50'!
testFiniteFieldFactorization2
	| Z3 x f factors |
	Z3 _ ZZ / 3.
	x _ Z3 polynomials x.
	f _ (x-1)^2*(x-2).
	factors _ f factors.
	self assert: factors size = 3.
	self assert: (factors occurrencesOf: x-1) = 2.
	self assert: (factors occurrencesOf: x-2) = 1! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 4/9/2018 21:30:09'!
testFiniteFieldFactorization3
	| F9 x f factors |
	F9 _ GaloisField new: (3^2).
	x _ F9 polynomials x.
	f _ (x-1)^2*(x-2).
	factors _ f factors.
	self assert: factors size = 3.
	self assert: (factors occurrencesOf: x-1) = 2.
	self assert: (factors occurrencesOf: x-2) = 1! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 4/10/2018 06:48:53'!
testFiniteFieldFactorization4
	| R x f factors |
	R _ ZZ / 2.
	x _ R polynomials x.
	f _ x^24 - 1.
	factors _ f factors.
	self assert: factors size = 16.
	self assert: (factors occurrencesOf: x+1) = 8.
	self assert: (factors occurrencesOf: x^2+x+1) = 8! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 4/10/2018 06:52:30'!
testFiniteFieldFactorization5
	| R x |
	R _ ZZ / 2.
	x _ R polynomials x.
	self assert: (x^15 - 1) factors = {x + 1. x^2 + x + 1. x^4 + (x^3) + (x^2) + x + 1. x^4 + x + 1. x^4 + (x^3) + 1} asBag! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 12/2/2016 11:16:43'!
testFiniteFieldIrreduciblePolynomials
	"Z/<3>[x] has 8 irreducible monic polynomials of degree 3, out of 27 monic polynomials of degree 3."
	| F Fx f count |
	F _ ZZ / 3.
	Fx _ F polynomials.
	count _ 0.
	(F ^ 3) do: [:each|
		f _ (Fx coefficients: each, F one).
		f isIrreducible
			ifTrue:
				[count _ count + 1.
				self assert: f factors size = 1]
			ifFalse:
				[self assert: f factors size > 1]].
	self assert: count = 8! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 12/2/2016 11:16:38'!
testFiniteFieldIsIrreducible
	| F Fx x f |
	F _ ZZ / 3.
	Fx _ F polynomials.
	x _ Fx x.
	f _ x^3 + (x*2) + 1.
	self assert: f factors size = 1.
	self assert: f isIrreducible! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 3/24/2018 20:33:32'!
testFiniteFieldRoots
	| Z3 x f roots |
	Z3 _ ZZ / 3.
	x _ Z3 polynomials x.
	f _ (x-1)^2*(x-2).
	roots _ f allRoots.
	self assert: roots size = 3.
	self assert: (roots occurrencesOf: (Z3 project: 1)) = 2.
	self assert: (roots occurrencesOf: (Z3 project: 2)) = 1! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 4/24/2018 15:39:00'!
testFiniteFieldSFF
	| F Fx x one f factors |
	F _ ZZ / 3.
	Fx _ F polynomials.
	x _ Fx x.
	one _ Fx one.
	f _ x^11 + (x^9 * 2) + (x^8 * 2) + (x^6) + (x^5) + (x^3 * 2) + (x^2 * 2) + one.
	factors _ f squareFreeFactorization.
	self assert: factors size = 8.
	self assert: (factors occurrencesOf: x + (one*2)) = 4.
	self assert: (factors occurrencesOf: x^2 + one) = 3.
	self assert: (factors occurrencesOf: x + one) = 1! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:09'!
testGCD
	| P x f g |
	P _ QQ polynomials.
	x _ P x.
	f _ x^4 - 1.
	g _ x^6 - 1.
	self assert: (f gcd: g) = (x^2 - 1)! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:52'!
testGCDMultivariate
	| Zxy x y f g |
	Zxy _ ZZ polynomialsIn: #(x y).
	x _ Zxy x.
	y _ Zxy y.
	f _ (x+y)*(y-x).
	g _ (y-x)^2.
	self assert: (f gcd: g) = (y-x)! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 4/25/2018 22:13:05'!
testGCDMultivariate2
	"Example from Sage documentation."
	| R x y f g |
	R _ QQ polynomialsIn: #(x y).
	x _ R x. y _ R y.
	f _ x^2*y*(x+y)*3.
	g _ x*(y^2 - (x^2))*9.
	self assert: (f gcd: g) = (x^2 + (x*y))! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 4/25/2018 18:33:50'!
testGCDMultivariateOverQ
	| R x y f g |
	R _ QQ polynomialsIn: #(x y).
	x _ R x. y _ R y.
	f _ x^2*y*6.
	g _ x*(y^2)*15 + (x^3*(y^2)*21).
	self assert: (f gcd: g) = (x*y)! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 4/25/2018 18:33:41'!
testGCDMultivariateOverZ
	| R x y f g |
	R _ ZZ polynomialsIn: #(x y).
	x _ R x. y _ R y.
	f _ x^2*y*6.
	g _ x*(y^2)*15 + (x^3*(y^2)*21).
	self assert: (f gcd: g) = (x*y*3)! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 4/25/2018 18:37:41'!
testGCDOverRationalFunctions
	| R x y f g |
	R _ QQ polynomialsIn: #(y) :: fractions polynomials.
	x _ R x. y _ R scalars x.
	f _ x^2*y*6.
	g _ x*(y^2)*15 + (x^3*(y^2)*21).
	self assert: (f gcd: g) = x! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:52'!
testGCDOverZ
	| x f g |
	x _ ZZ polynomials x.
	f _ (x^4 - 1)*6.
	g _ (x^6 - 1)*9.
	self assert: (f gcd: g) = ((x^2 - 1)*3)! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 4/25/2018 22:21:04'!
testGCDOverZ2
	| x f g h |
	x _ ZZ/2 :: polynomials x.
	h _ x^3 - x + 1.
	f _ h * (x + 1) * x.
	g _ h * (x + 1) * (x^2 + 1).
	self assert: (f gcd: g) = (h * (x + 1))! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:52'!
testGaussLemma
	"Lemma (Gauss): The product of two primitive polynomials is primitive."
	| Zx f g |
	Zx _ ZZ polynomials.
	f _ Zx atRandomBits: 100 maxDegree: (5 to: 10) atRandom.
	g _ Zx atRandomBits: 100 maxDegree: (5 to: 10) atRandom.
	self assert: (f primitive * g primitive) isPrimitive! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 5/2/2018 16:35:46'!
testHeight
	| x |
	x _ QQ polynomials x.
	self assert: (x * 2 - 5) height =  5.
	self assert: (x * 5 - 2) height =  5! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 9/22/2018 23:41:08'!
testInclusionInFractionField
	| R F |
	R _ QQ polynomials.
	F _ R fractions.
	self assert: R <= F.
	self assert: F >= R.
	self deny: R >= F.
	self deny: F <= R! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 4/25/2018 15:49:59'!
testIntegerFactorization
	| x f factors |
	x _ ZZ polynomials x.
	f _ (x*2-1)^2*(x-2)*(x^2 + 1)*(x^2-2)*18.
	factors _ f factors.
	self assert: factors size = 8.
	self assert: factors asSet size = 6.
	self assert: factors product = f! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:09'!
testInterpolation
	| Qx f |
	Qx _ QQ polynomials.
	f _ Qx interpolate: {1 -> 2. 2 -> 3. 4 -> 5}.
	self assert: (f value: 1) = 2.
	self assert: (f value: 2) = 3.
	self assert: (f value: 4) = 5! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:09'!
testInterpolation2
	| Qx f |
	Qx _ QQ polynomials.
	f _ Qx interpolate: {1 -> 2. 2 -> 4. 3 -> 9}.
	self assert: (f value: 1) = 2.
	self assert: (f value: 2) = 4.
	self assert: (f value: 3) = 9! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 4/25/2018 21:44:25'!
testIsIrreducible
	"The polynomial x^4 + 1 is irreducible in Z[x] and Q[x], and it is reducible Z/p[x] for all prime numbers p."
	| p |
	self assert: (ZZ polynomials !! [:x| x^4 + 1] :: isIrreducible).
	self assert: (QQ polynomials !! [:x| x^4 + 1] :: isIrreducible).
	p _ 1000 atRandom nextPrime.
	self deny: (ZZ/p :: polynomials !! [:x| x^4 + 1] :: isIrreducible)! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 4/25/2018 21:48:05'!
testIsIrreducibleOverQ
	| x f |
	x _ QQ polynomials x.
	f _ x^4 + 1.
	self assert: f isIrreducible.
	self assert: f negated isIrreducible.
	self assert: (f*2) isIrreducible.
	self assert: (f*(x+1)) isIrreducible not! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 4/25/2018 21:47:42'!
testIsIrreducibleOverZ
	| x f |
	x _ ZZ polynomials x.
	f _ x^4 + 1.
	self assert: f isIrreducible.
	self assert: f negated isIrreducible.
	self assert: (f*2) isIrreducible not.
	self assert: (f*(x+1)) isIrreducible not.
! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 6/5/2019 16:14:11'!
testIsNilpotentOverZm
	| m R N U d f k |
	m _ (2 to: 100) atRandom.
	R _ ZZ/m.
	N _ R nilradical asSet.
	U _ R units asSet.
	d _ (1 to: 5) atRandom.
	f _ R polynomials coefficients: ((1 to: d) collect: [:i| N atRandom]).
	self assert: f isNilpotent.
	k _ (1 to: d) atRandom.
	f _ R polynomials coefficients: ((1 to: d) collect: [:i| i=k ifTrue: [U atRandom] ifFalse: [N atRandom]]).
	self assert: f isNilpotent not! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 4/27/2018 21:22:40'!
testIsSeparableNot
	"A tipical example of a polynomial that is NOT separable."
	| p F x Fy y f |
	p _ 5. "any prime p"
	F _ ZZ/p :: polynomials fractions.
	x _ F x.
	Fy _ F polynomialsIn: #(y).
	y _ Fy x.
	f _ y^p - x.
	self assert: f isSeparable not! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 6/5/2019 16:19:04'!
testIsUnitOverZm
	| m R N U d f k |
	m _ (2 to: 100) atRandom.
	R _ ZZ/m.
	N _ R nilradical asSet.
	U _ R units asSet.
	d _ (0 to: 5) atRandom.
	f _ R polynomials coefficients: ({U atRandom}, ((1 to: d) collect: [:i| N atRandom])).
	self assert: f isUnit.
	f _ R polynomials coefficients: ({N atRandom}, ((1 to: d) collect: [:i| N atRandom])).
	self assert: f isUnit not.
	d _ (1 to: 5) atRandom.
	k _ (1 to: d) atRandom.
	f _ R polynomials coefficients: ({U atRandom}, ((1 to: d) collect: [:i| i=k ifTrue: [U atRandom] ifFalse: [N atRandom]])).
	self assert: f isUnit not! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 4/24/2018 19:38:36'!
testMultivariateDivision
	"Example from Cox IVA 62 p."
	| Zxy x y f f1 f2 division |
	Zxy _ ZZ polynomialsIn: #(x y) ordering: (MonomialOrdering lex: #(2 1)).
	x _ Zxy x.
	y _ Zxy y.
	f _ x*(y^2)+1.
	f1 _ x*y+1.
	f2 _ y+1.
	division _ f divisionBy: {f1. f2}.
	self assert: division quotients = {y. y one negated}.
	self assert: division remainder = (y one * 2).
	self assert: division verify! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 4/24/2018 19:38:40'!
testMultivariateDivision2
	"Example from Cox IVA 63 p."
	| Zxy x y f f1 f2 division |
	Zxy _ ZZ polynomialsIn: #(x y) ordering: (MonomialOrdering lex: #(2 1)).
	x _ Zxy x.
	y _ Zxy y.
	f _ x^2*y + (x*(y^2)) + (y^2).
	f1 _ x*y-1.
	f2 _ y^2-1.
	division _ f divisionBy: {f1. f2}.
	self assert: division quotients = {x+y. y one}.
	self assert: division remainder = (x+y+1).
	self assert: division verify! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 4/24/2018 19:38:42'!
testMultivariateDivision3
	"Example from Cox IVA 67 p."
	| Zxy x y f f1 f2 division |
	Zxy _ ZZ polynomialsIn: #(x y) ordering: (MonomialOrdering lex: #(2 1)).
	x _ Zxy x.
	y _ Zxy y.
	f _ x^2*y + (x*(y^2)) + (y^2).
	f1 _ x*y-1.
	f2 _ y^2-1.
	division _ f divisionBy: {f2. f1}.
	self assert: division quotients = {x+1. x}.
	self assert: division remainder = (x*2+1).
	self assert: division verify! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:09'!
testMultivariateGCDBug
	| x |
	x _ QQ polynomialsIn: 3 :: x.
	self assert: (x^2 gcd: x) = x! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 11/25/2016 10:33:02'!
testPPRS
	"Example from Zippel."
	| a b pprs |
	a _ ZZ polynomials coefficients: #(1 0 1 0 -3 -3 8 2 -5) reversed.
	b _ ZZ polynomials coefficients: #(3 0 5 0 -4 -9 21) reversed.
	pprs _ a pprs: b :: collect: [:each| each coefficients reversed asArray] :: asArray.
	self assert: pprs = #((1 0 1 0 -3 -3 8 2 -5) 
		(3 0 5 0 -4 -9 21)
		(-5 0 1 0 -3)
		(13 25 -49)
		(4663 -6150)
		(1))! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 4/24/2018 19:41:39'!
testPseudoDivision1
	| Zxy x y division |
	Zxy _ ZZ polynomialsIn: #(x y).
	x _ Zxy x.
	y _ Zxy y.
	division _ x^2 + (y^2) pseudoDivisionBy: y - x in: 2.
	self assert: division quotient asMultivariate = (x + y).
	self assert: division remainder asMultivariate = (x^2 * 2).
	self assert: division verify! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 4/24/2018 19:41:41'!
testPseudoDivision2
	| Zxy x y division |
	Zxy _ QQ polynomialsIn: #(x y).
	x _ Zxy x.
	y _ Zxy y.
	division _ x^2 + (y^2) pseudoDivisionBy: (y-x)*2 in: 2.
	self assert: division quotient asMultivariate = ((x+y) * 2).
	self assert: division remainder asMultivariate = (x^2 * 8).
	self assert: division verify! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 4/24/2018 19:41:45'!
testPseudoDivision3
	| Zxy x y division |
	Zxy _ ZZ polynomialsIn: #(x y).
	x _ Zxy x.
	y _ Zxy y.
	division _ x^2 + (y^2) pseudoDivisionBy: y - x in: 2.
	self assert: division quotient asMultivariate = (x + y).
	self assert: division remainder asMultivariate = (x^2 * 2).
	self assert: division verify.

	division _ x^2 + (y^2) pseudoDivisionBy: x - y in: 2.
	self assert: division quotient asMultivariate = (x + y) negated.
	self assert: division remainder asMultivariate = (x^2 * 2).
	self assert: division verify! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 4/24/2018 19:40:58'!
testPseudoDivision: R
	| Rx f g div |
	Rx _ R polynomials.
	f _ Rx atRandomBits: 100 maxDegree: 10 atRandom.
	[g _ Rx atRandomBits: 100 maxDegree: 10 atRandom. g isZero] whileTrue.
	div _ f pseudoDivisionBy: g.
	self assert: div verify! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 4/24/2018 19:41:01'!
testPseudoDivisionUnivariate
	| Zx x division |
	Zx _ ZZ polynomials.
	x _ Zx x.
	division _ x^3 + x + 1 pseudoDivisionBy: (x^2 * 3) + x + 1.
	self assert: division quotient = (x*3 - 1).
	self assert: division remainder = (x*7 + 10).
	self assert: division delta = 2.
	self assert: division verify! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 4/24/2018 19:41:02'!
testPseudoDivisionUnivariate2
	"Example from Zippel book"
	| Zx a b |
	Zx _ ZZ polynomials.
	a _ Zx coefficients: #(1 0 1 0 -3 -3 8 2 -5) reversed.
	b _ Zx coefficients: #(3 0 5 0 -4 -9 21) reversed.
	^ self assert: (a pseudoDivisionBy: b) verify! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:53'!
testPseudoDivisionZ
	self testPseudoDivision: ZZ! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 12/2/2016 11:13:22'!
testPseudoDivisionZ6
	self testPseudoDivision: ZZ / 6! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 4/24/2018 19:41:07'!
testPseudoRemainder
	| Zx x a b r |
	Zx _ ZZ polynomials.
	x _ Zx x.
	a _ x^8 + (x^6) - (3*(x^4)) - (3*(x^3)) + (8*(x^2)) + (2*x) - 5.
	b _ 3*(x^6) + (5*(x^4)) - (4*(x^2)) - (9*x) + 21.
	r _ Zx coefficients: #(-9 0 3 0 -15).
	self assert: (a pseudoRem: b) = r.
	self assert: (a pseudoDivisionBy: b) remainder = r! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 5/22/2018 18:26:13'!
testQuotientRingBug
	"This is fixed by making ideals of Z[x] have generators with positive leading coefficient. But it could be still a problem for polynomials over other rings."
	| R f Q pi a b |
	R _ ZZ polynomials.
	f _ R !! [:x| x^2*-1 - 1].
	Q _ R/f.
	pi _ Q projection.
	a _ R x - 1.
	b _ R x^2 + 1.
	self assert: (pi value: a) + (pi value: b) = (pi value: a+b)! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 4/25/2018 15:46:49'!
testRationalFactorization
	| x f factors |
	x _ QQ polynomials x.
	f _ (x-(1/2))^2*(x-2)*(x^2 + 1)*(x^2-2).
	factors _ f factors.
	self assert: factors size = 5.
	self assert: factors asSet size = 4.
	self assert: factors product monic = f monic "up to a unit"! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 4/24/2018 17:32:47'!
testRationalRoots
	| x f roots |
	x _ QQ polynomials x.
	f _ (x-(1/2))^2*(x-2)*(x^2 + 1)*(x^2-2).
	roots _ f allRoots.
	self assert: roots size = 3.
	self assert: (roots occurrencesOf: 1/2) = 2.
	self assert: (roots occurrencesOf: 2) = 1! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 3/24/2018 20:32:28'!
testRationalRootsBug
	| x f roots |
	x _ QQ polynomials x.
	f _ x^3*-1 + (3*x) + 2.
	roots _ f allRoots.
	self assert: roots size = 3.
	self assert: (roots occurrencesOf: -1) = 2.
	self assert: (roots occurrencesOf: 2) = 1! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 4/29/2018 20:30:09'!
testRealRoots
	| x f roots |
	x _ QQ polynomials x.
	f _ (x-(1/2))^2*(x-2)*(x^2 + 1)*(x^2-2).
	roots _ f allRootsIn: RR.
	self assert: roots size = 5.
	self assert: roots asSet size = 4.
	self assert: (roots occurrencesOf: 1/2) = 2.
	self assert: (roots occurrencesOf: 2) = 1! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 5/17/2018 16:04:08'!
testRemainderInconsistency
	"In Sage these two give the same result."
	| X x |
	X _ ZZ polynomials x.
	x _ QQ polynomials x.
	self assert: (x \\ (1 - x)) leadingCoefficient = (X \\ (1 - X)) leadingCoefficient! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 3/7/2017 07:27:20'!
testResultant
	| Zx x f g f2 g2 h |
	Zx _ ZZ polynomials.
	x _ Zx x.
	f _ x^2 + x + 1.
	f2 _ f * (x + 2).
	g _ x^3 + 1.
	g2 _ g * (x + 2).
	h _ x^4 + 1.
	self assert: (f resultant: g) isZero not. "not 0 because f and g have no common roots"
	self assert: (f2 resultant: g2) isZero. "res(f2,g2) = 0 because f2 and g2 have a common root -2."
	self assert: (-1)^(f degree * g degree) * (f resultant: g) = (g resultant: f).
	self assert: (f * g resultant: h) = ((f resultant: h) * (g resultant: h))! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:53'!
testResultant2
	| Zx x f g |
	Zx _ ZZ polynomials.
	x _ Zx x.
	f _ 2 * (x - 5) * (x - 11).
	g _ 3 * (x - 7).
	self assert: (f resultant: g) = ((2 ^ 1) * (3^2) * (5 - 7) * (11 - 7))! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 11/25/2016 10:32:56'!
testSPRS
	"Example from Zippel."
	| a b sprs |
	a _ ZZ polynomials coefficients: #(1 0 1 0 -3 -3 8 2 -5) reversed.
	b _ ZZ polynomials coefficients: #(3 0 5 0 -4 -9 21) reversed.
	sprs _ a sprs: b :: collect: [:each| each coefficients reversed asArray] :: asArray.
	self assert: sprs = #((1 0 1 0 -3 -3 8 2 -5)
		#(3 0 5 0 -4 -9 21)
		#(15 0 -3 0 9)
		#(65 125 -245)
		#(9326 -12300)
		#(260708))
! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:53'!
testShift
	| Zx x f |
	Zx _ ZZ polynomials.
	x _ Zx x.
	f _ Zx atRandomBits: 10.
	self assert: (f shift: 10) degree = (f degree + 10).
	self assert: ((f shift: 10) shift: -10) = f.
	self assert: f * (x^3) = (f shift: 3).
	self assert: (f * (x^3) shift: -3) = f! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:10'!
testSquareFree
	| P x f1 f2 f3 f |
	P _ QQ polynomials.
	x _ P x.
	f1 _ x^2 + x + 1.
	f2 _ 1 - x.
	f3 _ x - 2.
	f _ f1*f1*f2*f3*f3*f3.
	self assert: f squareFree = (f1 * f2 * f3)! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:10'!
testSquareFreeMultivariate
	| P x y f1 f2 f |
	P _ QQ polynomialsIn: #(x y).
	x _ P x.
	y _ P y.
	f1 _ x + 1.
	f2 _ y + 1.
	f _ f1*f1*f2*f2.
	self assert: f squareFree = (f1 * f2)! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:54'!
testSubresultant
	"deg(gcd(f,g)) = d iff subresultant(f,g,k) = 0 for all k < d and subresultant(f,g,d) ~= 0, and the d-th subresultant coefficient is in fact a gcd of f and g."
	| x f g |
	x _ ZZ polynomials x.
	f _ (x^4 - 1)*6.
	g _ (x^6 - 1)*9.
	"self assert: (f gcd: g) = ((x^2 - 1)*3)"
	self assert: (f subresultant: 0 with: g) isZero.
	self assert: (f subresultant: 1 with: g) isZero.
	self assert: (f subresultant: 2 with: g) isZero not.
	self assert: (f subresultant: 2 with: g) primitive = (x^2 - 1)! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:54'!
testSubresultant0
	| Zx x f g |
	Zx _ ZZ polynomials.
	x _ Zx x.
	f _ 2 * (x - 5) * (x - 11).
	g _ 3 * (x - 7).
	self assert: (f resultant: g) = (f subresultant: 0 with: g) asScalar! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:10'!
testUnivariateMultivariateConversion
	| Qx x y f |
	Qx _ QQ polynomialsIn: #(x y).
	x _ Qx x.
	y _ Qx y.
	f _ x^2*y.
	self assert: f asUnivariate asMultivariate = f.
"	self assert: (f asUnivariateIn: 1 :: asMultivariate) = f."
	self assert: (f asUnivariateIn: 2 :: asMultivariate) = f! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 3/7/2017 07:27:48'!
testUnivariateMultivariateConversion2
	| Qx x y f f2 x0 y0 |
	Qx _ QQ polynomialsIn: #(x y).
	x _ Qx x.
	y _ Qx y.
	f _ Qx zero.
	10 timesRepeat: [f _ f + (10 atRandom - 5 * (x ^ (3 atRandom - 1) * (y ^ (3 atRandom - 1))))].
	f2 _ f asUnivariate.
	self assert: f2 asMultivariate = f.
	x0 _ (-100 to: 100) atRandom.
	y0 _ (-100 to: 100) atRandom.
	self assert: ((f2 value: y0) value: x0) = (f value: {x0. y0})! !

!PolynomialTest methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 06:10'!
testZeroCoefficientBug
	| Qx |
	Qx _ QQ polynomials.
	self assert: (Qx one * 0) isZero! !

!QuadraticFormTest methodsFor: 'as yet unclassified' stamp: 'len 3/28/2018 15:13:47'!
newQuadraticForm
	^ self newQuadraticForm: (2 to: 5) atRandom! !

!QuadraticFormTest methodsFor: 'as yet unclassified' stamp: 'len 3/28/2018 15:13:29'!
newQuadraticForm: n
	| V |
	V _ QQ^n.
	^ QuadraticForm from: V coefficients: (QQ^(n + 1 * n / 2) atRandomBits: 100)! !

!QuadraticFormTest methodsFor: 'as yet unclassified' stamp: 'len 3/28/2018 15:17:28'!
testArithmetic
	| n Q1 Q2 p a |
	n _ (1 to: 5) atRandom.
	Q1 _ self newQuadraticForm: n.
	Q2 _ self newQuadraticForm: n.
	p _ Q1 domain atRandomBits: 100.
	a _ QQ atRandomBits: 100.
	self assert: (Q1 value: p) + (Q2 value: p) = (Q1 + Q2 value: p).
	self assert: (Q1 * a value: p) = ((Q1 value: p) * a).
	self assert: Q1 + Q2 + Q2 negated = Q1! !

!QuadraticFormTest methodsFor: 'as yet unclassified' stamp: 'len 3/27/2018 23:52:45'!
testAsPolynomial
	| Q f p |
	Q _ self newQuadraticForm.
	f _ Q asPolynomial.
	p _ Q domain atRandomBits: 100.
	self assert: (Q value: p) = (f value: p).
	self assert: (f degree = 2 and: [f isHomogeneous])! !

!QuadraticFormTest methodsFor: 'as yet unclassified' stamp: 'len 6/3/2018 18:33:33'!
testAssociatedBilinearForm
	"Example from Sage."
	| Q B |
	Q _ QuadraticForm coefficients: ((1,4,0,1,4,1) over: ZZ).
	B _ Q associatedBilinearForm.
	self assert: (B value: {(1,2,0) over: ZZ. (0,1,1) over: ZZ}) = 8! !

!QuadraticFormTest methodsFor: 'as yet unclassified' stamp: 'len 6/3/2018 18:33:42'!
testAssociatedBilinearForm2
	"Example from Sage."
	| Q B |
	Q _ QuadraticForm coefficients: (1/2, 2, 1).
	B _ Q associatedBilinearForm.
	self assert: (B value: {(1,1). (1/2,2)}) = (19/4)! !

!QuadraticFormTest methodsFor: 'as yet unclassified' stamp: 'len 3/27/2018 23:47:33'!
testEvaluation
	"Example from Sage."
	| Q |
	Q _ QuadraticForm from: QQ^3 coefficients: (0 to: 5).
	self assert: (Q value: (1,2,3)) = 89.
	self assert: (Q value: (1,0,0)) = 0.
	self assert: (Q value: (1,1,1)) = 15! !

!RingTest methodsFor: 'private' stamp: 'len 12/2/2016 11:13:56'!
newQuotientRing
	| R I |
	2 atRandom = 1 ifTrue: [^ ZZ / (2 to: 10) atRandom].
	R _ ZZ polynomials.
	I _ R * (R atRandomBits: 10 maxDegree: 5).
	^ R / I! !

!RingTest methodsFor: 'private' stamp: 'len 9/16/2018 23:31:05'!
newRing
	4 atRandom = 1 ifTrue: [^ self newQuotientRing].
	2 atRandom = 1 ifTrue: [^ {ZZ. QQ. ZZ / (2 to: 10) atRandom} atRandom polynomialsIn: (1 to: 3) atRandom].
	^ {ZZ. QQ. ZZ / (2 to: 10) atRandom} atRandom! !

!RingTest methodsFor: 'general' stamp: 'len 4/19/2019 04:55:55'!
testCanonicalMorphisms
	| R x Q |
	R _ QQ polynomials.
	x _ R x.
	Q _ R / (x^2 + 1).
	self assert: (ZZ -> R value: 4) = (R embed: 4). "canonical morphism from initial object"
	self assert: (R -> Q value: x^2 + 2) = Q one. "canonical morphism to quotient object"! !

!RingTest methodsFor: 'general' stamp: 'len 10/20/2016 06:06'!
testKrullDimension
	| R I |
	self assert: ZZ dimension = 1.
	self assert: QQ dimension = 0.
	self assert: (ZZ polynomialsIn: 2) dimension = 3.
	R _ QQ polynomialsIn: #(x y).
	I _ R * {R x ^ 2 + (R y ^ 2) - 1}.
	self assert: (R / I) dimension = 1! !

!RingTest methodsFor: 'general' stamp: 'len 5/4/2018 23:52:20'!
testNilradical
	self assert: ZZ nilradical = (ZZ*0).
	self assert: (ZZ/12) nilradical = (ZZ/12*6)! !

!RingTest methodsFor: 'general' stamp: 'len 9/22/2018 19:03:04'!
testProductRing
	| R S P |
	R _ self newRing.
	S _ self newRing.
	P _ R ◊ S.
	self testRing: P.
	self testRingHomomorphism: (P projection: 2 atRandom)! !

!RingTest methodsFor: 'general' stamp: 'len 10/6/2016 20:30'!
testRing: R
	| one zero a b c |
	one _ R one.
	zero _ R zero.
	a _ R atRandomBits: 100.
	b _ R atRandomBits: 100.
	c _ R atRandomBits: 100.
	self assert: a * one = a.
	self assert: one * a = a.
	self assert: zero * a = zero.
	self assert: a * zero = zero.
	self assert: zero + a = a.
	self assert: a + zero = a.
	self assert: a + b = (b + a). "commutativity of addition"
	self assert: (a + b + c) = (a + (b + c)). "associativity of addition"
	self assert: (a * b * c) = (a * (b * c)). "associativity of multiplication"
	R isCommutative ifTrue: [self assert: a * b = (b * a)]. "commutativity of multiplication"! !

!RingTest methodsFor: 'general' stamp: 'len 3/13/2018 20:15:02'!
testRingHomomorphism: phi
	| R S a b |
	R _ phi domain.
	S _ phi codomain.
	a _ R atRandomBits: 10.
	b _ R atRandomBits: 10.
	self assert: (phi value: R zero) = S zero.
	self assert: (phi value: R one) = S one.
	self assert: (phi value: a + b) = ((phi value: a) + (phi value: b)).
	self assert: (phi value: a * b) = ((phi value: a) * (phi value: b)) "this sometimes fails because f and -f are not equal regular functions, for example"! !

!RingTest methodsFor: 'general' stamp: 'len 10/6/2016 20:27'!
testZZ
	self testRing: ZZ! !

!RingTest methodsFor: 'general' stamp: 'len 10/1/2018 05:41:38'!
testZZIdeals
	self assert: (ZZ * 3 includes: 6).
	self deny: (ZZ * 3 includes: 7).
	self assert: (ZZ * 0) isTrivial.
	self assert: (ZZ * 1) isOne! !

!RingTest methodsFor: 'general' stamp: 'len 5/15/2018 19:17:51'!
testZZPrimeNotMaximalIdeal
	| I |
	I _ ZZ * 0.
	self assert: I isPrime.
	self assert: I isMaximal not! !

!RingTest methodsFor: 'finite rings' stamp: 'len 6/7/2019 04:04:31'!
testFiniteRing
	| R |
	R _ (ZZ/2) polynomials.
	R _ R / (R x^3 - R x).
	self assert: R isField not.
	self assert: R size = 8.
	self assert: R units size = 2.
	self assert: R zeroDivisors size = 6.
	self assert: R radical asSet = {R zero. R x^2 + R x} asSet
	"also, this ring has two maximal ideals, and the Jacobson radical is {0, x^2 + x}"! !

!RingTest methodsFor: 'finite rings' stamp: 'len 5/22/2018 17:52:20'!
testFiniteRing2
	| R |
	R _ (ZZ/2) polynomials.
	R _ R / (R x * (R x + 1)).
	self assert: R isField not.
	self assert: R size = 4.
	self assert: R zeroDivisors size = 3.
	self assert: R characteristic = 2.
	self assert: R isLocal not
	"more about this ring: two maximal (and princial as well) ideals (so not a local ring)"! !

!RingTest methodsFor: 'finite rings' stamp: 'len 5/23/2018 02:14:27'!
testFiniteRing2Alternative
	| R |
	R _ ZZ/2 ◊ (ZZ/2).
	self assert: R isField not.
	self assert: R size = 4.
	self assert: R zeroDivisors size = 3.
	self assert: R characteristic = 2.
	self assert: R isLocal not.
	"more about this ring: two maximal (and principal as well) ideals (so not a local ring)"! !

!RingTest methodsFor: 'finite rings' stamp: 'len 6/7/2019 04:05:37'!
testFiniteRing3
	| R |
	R _ ZZ/4 ◊ (ZZ/4).
	self assert: R characteristic = 4.
	self assert: R isField not.
	self assert: R size = 16.
	self assert: R zeroDivisors size = 12.
	self assert: R units size = 4.
	self assert: R radical isTrivial not
	"more about this ring: two maximal ideals (so not a local ring), and non-trivial jacobson radical"! !

!RingTest methodsFor: 'finite rings' stamp: 'len 6/4/2019 19:01:44'!
testFiniteRingJacobsonRadical
	| R |
	R _ ZZ/12.
	self assert: R radical = (R*6)! !

!RingTest methodsFor: 'finite rings' stamp: 'len 6/7/2019 04:00:10'!
testFiniteRingLocalAndNotLocal
	| R S |
	R _ ZZ/6. "this is not a Galois ring, the zero-divisors dont form an ideal"
	S _ ZZ/8. "this is a Galois ring"
	self assert: R isLocal not.
	self assert: S isLocal! !

!RingTest methodsFor: 'finite rings' stamp: 'len 6/7/2019 04:02:21'!
testFiniteRingsAreArtinian
	| R |
	R _ ZZ/6. "not local"
	self assert: R isArtinian.
	R _ ZZ/8. "local, prime power ring, Galois ring"
	self assert: R isArtinian.
	R _ ZZ/4 ◊ (ZZ/4).
	self assert: R isArtinian.
	R _ GaloisRing new: 3 to: 2 to: 4.
	self assert: R isArtinian! !

!RingTest methodsFor: 'finite rings' stamp: 'len 5/22/2018 03:59:11'!
testGaloisRing
	| R |
	R _ GaloisRing new: 3 to: 3 to: 2.
	self assert: R characteristic = (3^3).
	self assert: R size = (3^3^2).
	self assert: R isLocal.
	self assert: R isEuclidean.
	self testRing: R! !

!RingTest methodsFor: 'finite rings' stamp: 'len 4/19/2019 04:55:59'!
testGaloisRingCanonicalEmbeddingIntoOverring
	"Canonical homomorphism from GR(p^n,m) to GR(p^n,m*k)."
	| p n m k A B phi |
	p _ #(2 3 5) atRandom.
	n _ 3 atRandom.
	m _ 3 atRandom.
	k _ 3 atRandom.
	A _ GaloisRing new: p to: n to: m.
	B _ GaloisRing new: p to: n to: m * k.
	phi _ A -> B.
	self testRingHomomorphism: phi! !

!RingTest methodsFor: 'finite rings' stamp: 'len 5/15/2019 07:04:02'!
testGaloisRingCanonicalProjectionOntoResidueField
	"Canonical homomorphism from GR(p^n,m) to GF(p,m).
	This sends 'a' in Z/(p^n)Z[x]/f to 'a mod p' in Z/pZ[x]/(f mod p) where f mod p means reducing the coefficients mod p."
	| p n m A B phi |
	p _ #(2 3 5) atRandom.
	n _ 3 atRandom.
	m _ 3 atRandom.
	A _ GaloisRing new: p to: n to: m.
	B _ GaloisField new: p to: m.
	phi _ A -> B.
	self testRingHomomorphism: phi! !

!RingTest methodsFor: 'finite rings' stamp: 'len 5/22/2018 03:53:54'!
testGaloisRingNilradical
	| R |
	R _ GaloisRing new: 3 to: 3 to: 2.
	self assert: R nilradical = (R * 3)! !

!RingTest methodsFor: 'finite rings' stamp: 'len 6/4/2019 15:26:00'!
testModularIntegers
	| R |
	R _ ZZ / (10 atRandom + 1).
	self testRing: R.
	self testRingHomomorphism: R projection! !

!RingTest methodsFor: 'finite rings' stamp: 'len 6/20/2019 15:48:10'!
testModularIntegersFactorization
	| R |
	R _ ZZ/(2 to: 1000) atRandom.
	100 timesRepeat:
		[| x factors |
		x _ R atRandom.
		factors _ x factors.
		self assert: (factors asSet allSatisfy: [:each| each isIrreducible]).
		self assert: (x isZero or: [x isUnit or: [x normalized = factors product]])]! !

!RingTest methodsFor: 'finite rings' stamp: 'len 6/20/2019 19:09:29'!
testModularIntegersPrimesExamples
	| R |
	R _ ZZ/6.
	self assert: (R primes asSet collect: [:each| each representative]) = #(2 3 4) asSet.
	R _ ZZ/12.
	self assert: (R primes asSet collect: [:each| each representative]) = #(2 3 9 10) asSet! !

!RingTest methodsFor: 'finite rings' stamp: 'len 6/19/2019 16:11:38'!
testModularIntegersPrimitiveRoots
	| X |
	"number of primitive roots in Z/nZ for n=2 to 17:"
	X _ #(1 1 1 2 1 2 0 2 2 4 0 4 2 0 0 8).
	self assert: ((2 to: 17) collect: [:m| (ZZ/m) count: [:x| x isPrimitiveRoot]]) = X.
	X withIndexDo: [:n :i|
		n > 0
			ifTrue: [self assert: (ZZ/(i+1)) primitiveRoot isPrimitiveRoot]
			ifFalse: [self should: [(ZZ/(i+1)) primitiveRoot] raise: Error]]! !

!RingTest methodsFor: 'finite rings' stamp: 'len 6/4/2019 15:25:01'!
testModularIntegersProperties
	| m R |
	m _ (2 to: 10) atRandom.
	R _ ZZ/m.
	self assert: R isPIR.
	self assert: m isPrime = R isField.
	self assert: m isPrimePower = R isLocal.
	self assert: R isField = R isIntegralDomain.
	self assert: R isField = R isPID! !

!RingTest methodsFor: 'finite rings' stamp: 'len 6/19/2019 15:22:23'!
testModularIntegersTrivial
	| R |
	R _ ZZ/1.
	self assert: R isTrivial.
	self assert: R size = 1.
	self assert: R zero = R one! !

!RingTest methodsFor: 'finite rings' stamp: 'len 6/20/2019 19:01:45'!
testModularIntegersUnitsIrreduciblesAndReducibles
	"From 'A Special Subring Associated with Irreducible Elements in the Ring of Z/nZ', Augustine Musukwa, Khumbo Kumwenda, Journal of Mathematics (2017)."
	| m R factors p |
	m _ (2 to: 100) atRandom.
	R _ ZZ/m.
	self assert: R units asSet size = m phi.
	factors _ m factors.
	self assert: R irreducibles size = (m phi * ((factors asSet select: [:each| (factors occurrencesOf: each) > 1]) sum: [:each| 1/each] ifEmpty: [0])).
	p _ 10 atRandom nextPrime.
	m _ p ^ (2 to: 4) atRandom.
	R _ ZZ/m.
	self assert: R reducibles size = (R irreducibles size / (p - 1) - 1)! !

!RingTest methodsFor: 'finite rings' stamp: 'len 6/20/2019 19:01:27'!
testModularIntegersUnitsIrreduciblesAndReduciblesExamples
	"Examples from 'A Special Subring Associated with Irreducible Elements in the Ring of Z/nZ', Augustine Musukwa, Khumbo Kumwenda, Journal of Mathematics (2017)."
	| R |
	R _ ZZ/8.
	self assert: (R units asSet collect: [:each| each representative]) = #(1 3 5 7) asSet.
	self assert: (R irreducibles asSet collect: [:each| each representative]) = #(2 6) asSet.
	R _ ZZ/36.
	self assert: (R units asSet collect: [:each| each representative]) = #(1 5 7 11 13 17 19 23 25 29 31 35) asSet.
	self assert: (R irreducibles asSet collect: [:each| each representative]) = #(2 3 10 14 15 21 22 26 33 34) asSet.
	R _ ZZ/25.
	self assert: R irreducibles size = 4.
	self assert: R reducibles isEmpty.
	R _ ZZ/32.
	self assert: R irreducibles size = 8.
	self assert: R reducibles size = 7.
	R _ ZZ/343.
	self assert: R irreducibles size = 42.
	self assert: R reducibles size = 6! !

!RingTest methodsFor: 'finite rings' stamp: 'len 6/10/2018 00:39:19'!
testPrimeFieldLogarithm
	| F g a b p |
	p _ 17.
	F _ ZZ/p.
	g _ F primitiveRoot.
	[(a _ F atRandom) isZero] whileTrue.
	[(b _ F atRandom) isZero] whileTrue.
	self assert: g ^ (a log: g) = a.
	self assert: (a log: g) + (b log: g) \\ (p-1) = ((a*b log: g) \\ (p-1)).
	self assert: (a log: g) - (b log: g) \\ (p-1) = ((a/b log: g) \\ (p-1))! !

!RingTest methodsFor: 'finite rings' stamp: 'len 6/11/2018 06:39:22'!
testPrimeFieldPrimitiveRoot
	| p F g i x |
	p _ 100 atRandom nextPrime.
	F _ ZZ/p.
	g _ F primitiveRoot.
	self assert: g multiplicativeOrder = (p-1).
	i _ 1.
	x _ g.
	[x = F one] whileFalse: [x _ x*g. i _ i+1].
	self assert: i = (p-1)! !

!RingTest methodsFor: 'finite rings' stamp: 'len 6/5/2019 14:40:55'!
testPrimePowerRing
	| R |
	R _ PrimePowerRing new: 3 to: 3.
	self assert: R characteristic = (3^3).
	self assert: R size = (3^3).
	self assert: R isLocal.
	self assert: R isEuclidean.
	self assert: R maximalIdeal = (R*3).
	self testRing: R! !

!RingTest methodsFor: 'finite rings' stamp: 'len 6/5/2019 14:25:21'!
testPrimePowerRingCanonicalProjections
	"Canonical homomorphism from ZZ/<p^n> to ZZ/<p^m> with 1 <= m <= n."
	| p n m A B phi a b |
	p _ 100 atRandom nextPrime.
	n _ 4 atRandom.
	A _ ZZ/(p^n).
	m _ n atRandom.
	B _ ZZ/(p^m).
	phi _ A -> B.
	a _ A atRandom.
	b _ phi value: a.
	self assert: (B includes: b).
	self assert: a representative \\ (p^m) = b representative.
	self testRingHomomorphism: phi! !

!RingTest methodsFor: 'finite rings' stamp: 'len 6/5/2019 14:25:29'!
testPrimePowerRingNilradical
	| R |
	R _ PrimePowerRing new: 3 to: 3.
	self assert: R nilradical = (R * 3)! !

!RingTest methodsFor: 'finite rings' stamp: 'len 6/5/2019 17:26:32'!
testPrimePowerRingNilradicalAndUnits
	| p n R |
	p _ 30 atRandom nextPrime.
	n _ 4 atRandom.
	R _ ZZ/(p^n).
	self assert: R units size + R nilradical size = R size! !

!RingTest methodsFor: 'finite rings' stamp: 'len 6/9/2019 12:36:49'!
testPrimePowerRingValuationAndUnit
	| R x |
	R _ PrimePowerRing new: 3 to: 5.
	x _ R !! 5.
	self assert: x valuation = 0.
	self assert: x associatedUnit = x.
	x _ R !! (3*3*5*2).
	self assert: x valuation = 2.
	self assert: x associatedUnit = (R !! 10).
	"this is undefined for an Euclidean valuation, but we define it at 0 to be +infinity in order to make it compatible with the p-adic valuation:"
	x _ R !! 0.
	self assert: x valuation = Infinity positive! !

!RingTest methodsFor: 'finite rings' stamp: 'len 6/9/2019 09:29:08'!
testQuasiGaloisRing1
	| p r n A |
	p _ #(2 3) atRandom.
	r _ 3 atRandom.
	n _ 3 atRandom+1.
	A _ QuasiGaloisRing new: p to: r to: n.
	self assert: A characteristic = p.
	self assert: A size = (p^(r*n)).
	self assert: A isLocal.
	self assert: A isFinite.
	self assert: A isField not! !

!RingTest methodsFor: 'finite rings' stamp: 'len 6/16/2019 13:48:07'!
testZ6PrimeNeedNotBeIrreducible
	| R a |
	R _ ZZ/6.
	a _ R!!2.
	self assert: a isPrime.
	self assert: a isIrreducible not! !

!RingTest methodsFor: 'localizations' stamp: 'len 6/10/2019 14:52:03'!
testLocalizationInclusions
	| Z2 Z3 Z6 |
	Z2 _ ZZ localizationAt: 2.
	Z3 _ ZZ localizationAt: 3.
	Z6 _ ZZ localizationAt: 6. "<- this is not a prime ideal, it shouldn't be allowed"
	self assert: Z6 >= Z2.
	self assert: Z6 >= Z3.
	self deny: Z3 >= Z2.
	self deny: Z2 >= Z3.
	self deny: Z2 >= Z6! !

!RingTest methodsFor: 'localizations' stamp: 'len 6/29/2019 18:20:30'!
testLocalizationMaximalIdeal
	| Z2 |
	Z2 _ ZZ localizationAt: 2.
	self assert: Z2 maximalIdeal = (Z2 * (Z2 !! 2))! !

!RingTest methodsFor: 'localizations' stamp: 'len 7/7/2019 16:16:41'!
testLocalizationOfModularIntegers1
	| R |
	R _ ZZ/60.
	self assert: (R localizationAt: (R*2)) = (ZZ/4).
	self assert: (R localizationAt: (R*3)) = (ZZ/3).
	self assert: (R localizationAt: (R*5)) = (ZZ/5)! !

!RingTest methodsFor: 'localizations' stamp: 'len 7/7/2019 16:20:47'!
testLocalizationOfModularIntegers2
	| R P L phi |
	R _ ZZ/60.
	P _ R*2.
	L _ R localizationAt: P. "the localization is actually the prime power ring Z/4Z"
	"localization map:"
	phi _ R -> L.
	self testRingHomomorphism: phi.
	"everything not in P maps to a unit:"
	R do: [:each| self assert: ((P includes: each) or: [(phi value: each) isUnit])]! !

!RingTest methodsFor: 'localizations' stamp: 'len 7/7/2019 16:20:56'!
testLocalizationOfModularIntegers3
	| R P L phi |
	R _ ZZ/60.
	P _ R*3.
	L _ R localizationAt: P. "the localization is actually the field GF(3)"
	"localization map:"
	phi _ R -> L.
	self testRingHomomorphism: phi.
	"everything not in P maps to a unit:"
	R do: [:each| self assert: ((P includes: each) or: [(phi value: each) isUnit])]! !

!RingTest methodsFor: 'localizations' stamp: 'len 6/29/2019 18:24:23'!
testLocalizationOfZAt2
	| L |
	L _ ZZ localizationAt: 2.
	self assert: (L !! (1/3)) asFraction = (1/3).
	self should: [L !! (3/2)] raise: Error.
	self assert: (L !! 2) asFraction = 2.
	self assert: (L !! 3) asFraction = 3.
	self assert: (L atRandomBits: 10) denominator odd.
	self testRing: L.
	self testRingHomomorphism: ZZ -> L! !

!RingTest methodsFor: 'polynomials' stamp: 'len 5/13/2019 18:12:56'!
testMultivariatePolynomialRing
	| R |
	R _ ZZ polynomialsIn: #(x y z).
	self testRing: R.
	self testRingHomomorphism: ZZ -> R! !

!RingTest methodsFor: 'polynomials' stamp: 'len 5/13/2019 18:13:03'!
testPolynomialRing
	| R |
	R _ ZZ polynomials.
	self testRing: R.
	self testRingHomomorphism: ZZ -> R! !

!RingTest methodsFor: 'polynomials' stamp: 'len 5/15/2018 19:18:02'!
testPolynomialRingPrimeNotMaximalIdeal
	"Z[x]/<x> is isomorphic to Z, which is an integral domain but not a field. So <x> is prime but not maximal."
	| R I |
	R _ ZZ polynomials.
	I _ R * R x.
	self assert: I isPrime.
	self assert: I isMaximal not! !

!RingTest methodsFor: 'polynomials' stamp: 'len 5/15/2018 19:19:26'!
testPolynomialRingPrimeNotMaximalIdeal2
	"Q[x,y]/<x> is isomorphic to Q[y], which is an integral domain but not a field. So <x> is prime but not maximal."
	| R I |
	R _ QQ polynomialsIn: 2.
	I _ R * R x.
	self assert: I isPrime.
	self assert: I isMaximal not! !

!RingTest methodsFor: 'quotients' stamp: 'len 10/6/2016 20:32'!
testQuotientRing
	| Q |
	Q _ self newQuotientRing.
	self testRing: Q.
	self testRingHomomorphism: Q projection! !

!RingTest methodsFor: 'quotients' stamp: 'len 2/27/2017 20:51:24'!
testQuotientRing2
	| Q pi f g |
	Q _ self newQuotientRing.
	f _ Q base atRandomBits: 10.
	g _ Q relations atRandomBits: 10.
	pi _ Q projection.
	self assert: (pi value: g) isZero.
	self assert: (Q includes: (pi value: f)).
	self testRingHomomorphism: pi.
"	self assert: (pi value: f) = (pi value: f + g)."
"	h _ Q atRandomBits: 100.
	self assert: (pi value: (pi section value: h)) = h"! !

!RingTest methodsFor: 'quotients' stamp: 'len 4/8/2018 17:47:19'!
testQuotientRingNotIntegralDomain
	| R |
	R _ QQ polynomials.
	R _ R / (R x^2 - 1).
	self assert: R isField not.
	self assert: R isIntegralDomain not! !

!RingTest methodsFor: 'quotients' stamp: 'len 4/8/2018 17:48:23'!
testQuotientRingWhichIsAField
	| R |
	R _ QQ polynomials.
	R _ R / (R x^2 + (R x * 2) + 2).
	self assert: R isField! !

!RingTest methodsFor: 'local rings' stamp: 'len 6/26/2019 13:00:09'!
testDVR: V
	| a b p |
	self assert: V isLocal.
	self assert: V isIntegralDomain.
	self assert: V isEuclidean.
	self assert: V one valuation = 0.
	p _ V uniformizer.
	self assert: p valuation = 1.
	a _ V atRandomBits: 100.
	self assert: (a*p) valuation = (a valuation + 1).
	b _ V atRandomBits: 100.
	self assert: (a*b) valuation = (a valuation + b valuation)! !

!RingTest methodsFor: 'local rings' stamp: 'len 6/4/2019 18:28:31'!
testLocalHomomorphism
	| f |
	f _ ZZ/4 to: ZZ/2 evaluating: [:x| ZZ/2 !! x representative].
	self assert: f isLocal
! !

!RingTest methodsFor: 'local rings' stamp: 'len 6/29/2019 18:02:28'!
testValuationRing1
	| V |
	V _ ZZ localizationAt: 5.
	self testRing: V.
	self testRingHomomorphism: V -> QQ! !

!RingTest methodsFor: 'local rings' stamp: 'len 6/29/2019 18:02:37'!
testValuationRing2
	| V |
	V _ ZZ localizationAt: 5.
	self testDVR: V! !

!RingTest methodsFor: 'euclidean' stamp: 'len 6/19/2019 01:27:43'!
testCongruenceSolving1
	| R a b solutions |
	R _ ZZ/20.
	a _ R !! 11.
	b _ R !! 15.
	solutions _ a \ b.
	self assert: solutions first = (R !! 5).
	self assert: solutions size = 1! !

!RingTest methodsFor: 'euclidean' stamp: 'len 6/19/2019 01:26:02'!
testCongruenceSolving2
	| R a b solutions |
	R _ ZZ/12167.
	a _ R !! 230.
	b _ R !! 1081.
	solutions _ a \ b.
	self assert: (solutions includes: (R !! 2491)).
	self assert: solutions size = 23.
	self assert: (solutions allSatisfy: [:x| a*x = b])! !

!RingTest methodsFor: 'euclidean' stamp: 'len 6/19/2019 14:12:58'!
testEuclideanRing: R
	"Test division on a pair of elements:"
	| a b q r |
	self assert: R isEuclidean.
	R size < 300 ifTrue: [self testEuclideanRingAll: R].
	100 timesRepeat:
		[a _ R atRandomBits: 30.
		[b _ R atRandomBits: 30. b isZero] whileTrue.
		q _ a // b.
		r _ a \\ b.
		self assert: a = (q * b + r).
		self assert: (r isZero or: [r valuation < b valuation])]! !

!RingTest methodsFor: 'euclidean' stamp: 'len 6/17/2019 15:17:37'!
testEuclideanRingAll: R
	"Test division on all pairs of elements:"
	R do: [:b|
		b isZero ifFalse:
			[R do: [:a|
				| q r |
				q _ a // b.
				r _ a \\ b.
				self assert: a = (q * b + r).
				self assert: (r isZero or: [r valuation < b valuation])]]]! !

!RingTest methodsFor: 'euclidean' stamp: 'len 6/19/2019 14:13:07'!
testGCD: R
	R size < 60 ifTrue: [self testGCDAll: R].
	self testGCDZero: R.
	100 timesRepeat:
		[| a b gcd |
		[(a _ R atRandomBits: 30) isZero] whileTrue.
		[(b _ R atRandomBits: 30) isZero] whileTrue.
		gcd _ a gcd: b.
		self assert: gcd | a.
		self assert: gcd | b.
		self assert: gcd = gcd normalized]! !

!RingTest methodsFor: 'euclidean' stamp: 'len 6/16/2019 17:22:36'!
testGCDAll: R
	R do: [:a|
		a isZero ifFalse:
			[R do: [:b|
				b isZero ifFalse:
					[| gcd |
					gcd _ a gcd: b.
					self assert: gcd | a.
					self assert: gcd | b.
					self assert: gcd = gcd normalized.
					R do: [:c| (c | a and: [c | b]) ifTrue: [self assert: c valuation <= gcd valuation]]]]]]! !

!RingTest methodsFor: 'euclidean' stamp: 'len 6/16/2019 16:43:23'!
testGCDZero: R
	| a gcd |
	a _ R atRandomBits: 100.
	gcd _ a gcd: R zero.
	self assert: gcd = (R zero gcd: a).
	self assert: gcd = a normalized.
	self assert: (R zero gcd: R zero) = R zero! !

!RingTest methodsFor: 'euclidean' stamp: 'len 6/16/2019 17:45:30'!
testGaloisRingIsEuclidean
	| R |
	R _ GaloisRing new: 5 atRandom nextPrime to: 3 atRandom to: 3 atRandom.
	self testEuclideanRing: R! !

!RingTest methodsFor: 'euclidean' stamp: 'len 6/19/2019 14:13:15'!
testLCM: R
	R size < 60 ifTrue: [self testLCMAll: R].
	self testLCMZero: R.
	100 timesRepeat:
		[| a b lcm |
		[(a _ R atRandomBits: 30) isZero] whileTrue.
		[(b _ R atRandomBits: 30) isZero] whileTrue.
		lcm _ a lcm: b.
		self assert: a | lcm.
		self assert: b | lcm.
		self assert: lcm = lcm normalized]! !

!RingTest methodsFor: 'euclidean' stamp: 'len 6/17/2019 04:40:57'!
testLCMAll: R
	R do: [:a|
		a isZero ifFalse:
			[R do: [:b|
				b isZero ifFalse:
					[| lcm |
					lcm _ a lcm: b.
					self assert: a | lcm.
					self assert: b | lcm.
					self assert: lcm = lcm normalized.
					R do: [:c| (c isZero not and: [a | c and: [b | c]]) ifTrue: [self assert: c valuation >= lcm valuation]]]]]]! !

!RingTest methodsFor: 'euclidean' stamp: 'len 6/17/2019 04:37:30'!
testLCMZero: R
	| a lcm |
	a _ R atRandomBits: 100.
	lcm _ a lcm: R zero.
	self assert: lcm = (R zero lcm: a).
	self assert: lcm = R zero.
	self assert: (R zero lcm: R zero) = R zero! !

!RingTest methodsFor: 'euclidean' stamp: 'len 6/17/2019 08:23:46'!
testModularIntegersEuclideanExample
	"Some random example built in Magma online calculator."
	| R a b c |
	R _ ZZ/12.
	a _ R !! 2.
	b _ R !! 9.
	c _ a lcm: b.
	self assert: c = (R !! 6).
	self assert: c // a = (R !! 3).
	self assert: c // b = (R !! 10)! !

!RingTest methodsFor: 'euclidean' stamp: 'len 6/17/2019 08:24:36'!
testModularIntegersEuclideanExample2
	"Some random example built in Magma online calculator."
	| R a b |
	R _ ZZ/39.
	a _ R !! 36.
	b _ R !! 3.
	self assert: a // b = (R !! 12)! !

!RingTest methodsFor: 'euclidean' stamp: 'len 6/17/2019 08:31:49'!
testModularIntegersEuclideanExample3
	"Some random example built in Magma online calculator."
	| R a b |
	R _ ZZ/78.
	a _ R !! 9.
	b _ R !! 39.
	self assert: a // b = (R !! 0)! !

!RingTest methodsFor: 'euclidean' stamp: 'len 6/17/2019 14:24:38'!
testModularIntegersEuclideanExample4
	"Some random example built in Magma online calculator."
	| R a b |
	R _ ZZ/230.
	a _ R !! 205.
	b _ R !! 128.
	self assert: (a gcd: b) = (R !! 1).
	self assert: (a lcm: b) = (R !! 10).! !

!RingTest methodsFor: 'euclidean' stamp: 'len 6/18/2019 03:14:20'!
testModularIntegersEuclideanExample5
	"Some random example built in Magma online calculator."
	| R a b |
	R _ ZZ/10.
	a _ R !! 4.
	b _ R !! 8.
	self assert: b normalized = (R !! 2).
	self assert: b associatedUnit = (R !! 9).
	self assert: (a gcd: b) = (R !! 2).
	self assert: (a lcm: b) = (R !! 2)! !

!RingTest methodsFor: 'euclidean' stamp: 'len 6/17/2019 14:10:09'!
testModularIntegersEuclideanExample6
	"Some random example built in Magma online calculator."
	| R a b |
	R _ ZZ/12.
	a _ R !! 4.
	b _ R !! 8.
	self assert: a // b = (R !! 11).
	self assert: b // a = (R !! 2)! !

!RingTest methodsFor: 'euclidean' stamp: 'len 6/17/2019 14:58:14'!
testModularIntegersEuclideanExample7
	"Some random example built in Magma online calculator."
	| R a b |
	R _ ZZ/6.
	a _ R !! 4.
	b _ R !! 3.
	self assert: (a gcd: b) = (R !! 1).
	self assert: (a lcm: b) = (R !! 0)! !

!RingTest methodsFor: 'euclidean' stamp: 'len 6/17/2019 15:24:17'!
testModularIntegersEuclideanExample8
	"Some random example built in Magma online calculator."
	| R a b |
	R _ ZZ/10.
	a _ R !! 6.
	b _ R !! 4.
	self assert: a // b = (R !! 4).
	self assert: b // a = (R !! 4)! !

!RingTest methodsFor: 'euclidean' stamp: 'len 6/17/2019 15:41:33'!
testModularIntegersEuclideanExample9
	"Some random example built in Magma online calculator."
	| R a b |
	R _ ZZ/10.
	a _ R !! 2.
	b _ R !! 4.
	self assert: a // b = (R !! 8).
	self assert: b // a = (R !! 2)! !

!RingTest methodsFor: 'euclidean' stamp: 'len 6/17/2019 10:16:06'!
testModularIntegersRingGCD
	| R |
	R _ ZZ/(2 to: 256) atRandom.
	self testGCD: R! !

!RingTest methodsFor: 'euclidean' stamp: 'len 6/17/2019 07:56:51'!
testModularIntegersRingIsEuclidean
	| R |
	R _ ZZ/(2 to: 256) atRandom.
	self testEuclideanRing: R! !

!RingTest methodsFor: 'euclidean' stamp: 'len 6/17/2019 10:16:17'!
testModularIntegersRingLCM
	| R |
	R _ ZZ/(2 to: 256) atRandom.
	self testLCM: R! !

!RingTest methodsFor: 'euclidean' stamp: 'len 6/18/2019 03:57:41'!
testModularIntegersRingNormalizedAndAssociatedUnit
	| R |
	R _ ZZ/(2 to: 256) atRandom.
	self testNormalizedAndAssociatedUnit: R! !

!RingTest methodsFor: 'euclidean' stamp: 'len 6/18/2019 03:57:04'!
testNormalizedAndAssociatedUnit: R
	| x |
"	R size < 300 ifTrue: [self testNormalizedAndAssociatedUnitAll: R]."
	100 timesRepeat:
		[x _ R atRandomBits: 100.
		self assert: x normalized * x associatedUnit = x.
		self assert: x associatedUnit isUnit]! !

!RingTest methodsFor: 'euclidean' stamp: 'len 6/17/2019 10:16:32'!
testPolynomialsOverFieldGCD
	| F R |
	F _ 2 atRandom = 1 ifTrue: [QQ] ifFalse: [GaloisField new: 5 atRandom nextPrime to: 3 atRandom].
	R _ F polynomials.
	self testGCD: R! !

!RingTest methodsFor: 'euclidean' stamp: 'len 6/16/2019 17:45:49'!
testPolynomialsOverFieldIsEuclidean
	| F R |
	F _ 2 atRandom = 1 ifTrue: [QQ] ifFalse: [GaloisField new: 5 atRandom nextPrime to: 3 atRandom].
	R _ F polynomials.
	self testEuclideanRing: R! !

!RingTest methodsFor: 'euclidean' stamp: 'len 6/17/2019 10:16:39'!
testPolynomialsOverFieldLCM
	| F R |
	F _ 2 atRandom = 1 ifTrue: [QQ] ifFalse: [GaloisField new: 5 atRandom nextPrime to: 3 atRandom].
	R _ F polynomials.
	self testLCM: R! !

!RingTest methodsFor: 'euclidean' stamp: 'len 6/16/2019 17:46:04'!
testPrimePowerRingIsEuclidean
	| p k R |
	p _ 10 atRandom nextPrime.
	k _ 10 atRandom.
	R _ PrimePowerRing new: p to: k.
	self testEuclideanRing: R! !

!RingTest methodsFor: 'euclidean' stamp: 'len 6/19/2019 14:05:59'!
testProductOfEuclideanRingsIsEuclidean1
	| R |
	R _ ZZ ◊ ZZ.
	self testEuclideanRing: R! !

!RingTest methodsFor: 'euclidean' stamp: 'len 6/19/2019 14:05:40'!
testProductOfEuclideanRingsIsEuclidean2
	| A B R |
	A _ ZZ/(2 to: 32) atRandom.
	B _ ZZ/(2 to: 32) atRandom.
	R _ A ◊ B.
	self testEuclideanRing: R! !

!RingTest methodsFor: 'euclidean' stamp: 'len 6/19/2019 14:06:44'!
testProductOfEuclideanRingsIsEuclidean3
	| A B C R |
	A _ ZZ.
	B _ ZZ/(2 to: 32) atRandom.
	C _ ZZ/(2 to: 32) atRandom.
	R _ A ◊ B ◊ C.
	self testEuclideanRing: R! !

!RingTest methodsFor: 'euclidean' stamp: 'len 6/20/2019 19:30:36'!
testProductRingGCD
	| A B |
	A _ 2 atRandom = 1 ifTrue: [ZZ] ifFalse: [ZZ/(2 to: 256) atRandom].
	B _ 2 atRandom = 1 ifTrue: [ZZ] ifFalse: [ZZ/(2 to: 256) atRandom].
	self testGCD: A ◊ B! !

!RingTest methodsFor: 'euclidean' stamp: 'len 6/20/2019 19:30:46'!
testProductRingLCM
	| A B |
	A _ 2 atRandom = 1 ifTrue: [ZZ] ifFalse: [ZZ/(2 to: 256) atRandom].
	B _ 2 atRandom = 1 ifTrue: [ZZ] ifFalse: [ZZ/(2 to: 256) atRandom].
	self testLCM: A ◊ B! !

!RingTest methodsFor: 'euclidean' stamp: 'len 6/17/2019 10:17:02'!
testRationalIntegerRingGCDAndLCM
	self testGCD: ZZ.
	self testLCM: ZZ! !

!RingTest methodsFor: 'euclidean' stamp: 'len 6/16/2019 17:46:15'!
testRationalIntegerRingIsEuclidean
	self testEuclideanRing: ZZ! !

!RingTest methodsFor: 'euclidean' stamp: 'len 6/29/2019 18:02:47'!
testValuationRingGCD
	| R |
	R _ ZZ localizationAt: 5.
	self testGCD: R! !

!RingTest methodsFor: 'euclidean' stamp: 'len 6/29/2019 18:02:57'!
testValuationRingIsEuclidean
	| R |
	R _ ZZ localizationAt: 5.
	self testEuclideanRing: R! !

!RingTest methodsFor: 'euclidean' stamp: 'len 6/29/2019 18:03:06'!
testValuationRingLCM
	| R |
	R _ ZZ localizationAt: 5.
	self testLCM: R! !

!RootSystemTest methodsFor: 'as yet unclassified' stamp: 'len 7/15/2016 18:37'!
rootSystem1
	| V roots |
	V _ QQ ^ 3.
	roots _ Set new.
	1 to: 3 do: [:i| 1 to: i-1 do: [:j| |r| roots add: (r _ (V e: i) - (V e: j)); add: r negated]].
	^ RootSystem on: V roots: roots! !

!RootSystemTest methodsFor: 'as yet unclassified' stamp: 'len 7/15/2016 18:37'!
rootSystem2
	| V roots |
	V _ QQ ^ 3.
	roots _ Set new.
	1 to: 3 do: [:i|
		1 to: i-1 do: [:j|
			roots
				add: (V e: i) - (V e: j);
				add: (V e: j) - (V e: i);
				add: (V e: i) + (V e: j);
				add: ((V e: i) + (V e: j)) negated]].
	^ RootSystem on: V roots: roots! !

!RootSystemTest methodsFor: 'as yet unclassified' stamp: 'len 2/23/2016 07:26'!
testBaseSignCondition
	| R |
	R _ self rootSystem1.
	R roots do: [:each| | coordinates |
		coordinates _ R simpleRoots coordinatesOf: each :: asArray.
		self assert: (coordinates allSatisfy: [:xi| xi >= 0]) | (coordinates allSatisfy: [:xi| xi <= 0])]! !

!RootSystemTest methodsFor: 'as yet unclassified' stamp: 'len 6/25/2016 23:09'!
testPositiveRoots
	| V R |
	R _ self rootSystem1.
	V _ R ambient.
	R positiveRoots do: [:each|
		self assert: (V innerProduct value: {each. (1,1,1)}) > 0] "the point must be in the positive Weyl chamber"! !

!RootSystemTest methodsFor: 'as yet unclassified' stamp: 'len 2/11/2016 01:39'!
testWeylGroup
	| R W |
	R _ self rootSystem1.
	W _ R weylGroup.
	"The Weyl group of this root system is isomorphic to Sym(3), so we test some properties of Sym(3):"
	self assert: W order = 6.
	self assert: W center isTrivial.
	self assert: W isSolvable.
	self assert: W isCyclic not! !

!RootSystemTest methodsFor: 'as yet unclassified' stamp: 'len 2/10/2016 22:43'!
testWeylGroup2
	| R W |
	R _ self rootSystem2.
	W _ R weylGroup. "this is an index 2 subgroup of the hyperoctahedral group"
	self assert: W order = 24! !

!RootSystemTest methodsFor: 'as yet unclassified' stamp: 'len 2/10/2016 22:56'!
testWeylGroupAndSimpleRoots
	"For every root, there exists an transformation in the Weyl group that makes it a simple root."
	| R W |
	R _ self rootSystem1.
	W _ R weylGroup.
	R roots do: [:r| self assert: (W anySatisfy: [:w| R simpleRoots includes: (w value: r)])]! !

!SequenceTest methodsFor: 'as yet unclassified' stamp: 'len 6/4/2019 18:09:49'!
testBellNumbers
	self assert: (Sequence bellNumbers beginsWith: #(1 1 2 5 15 52 203 877)).
	"The inverse binomial transform is the shift operator for the Bell numbers:"
	self assert: (Sequence bellNumbers binomialInverseTransform beginsWith: #(1 2 5 15 52 203 877)).! !

!SequenceTest methodsFor: 'as yet unclassified' stamp: 'len 12/5/2015 01:13'!
testDirichletConvolution
	self assert: ((Sequence phi dirichlet: Sequence one) beginsWith: #(1 2 3 4 5)).
	self assert: ((Sequence moebius dirichlet: Sequence one) beginsWith: #(1 0 0 0 0))! !

!SequenceTest methodsFor: 'as yet unclassified' stamp: 'len 10/31/2016 04:14'!
testLinearRecursiveSequenceBug
	| F |
	F _ CFiniteSequence fibonacci.
	self assert: ((F - F) at: 1) = 0! !

!SequenceTest methodsFor: 'as yet unclassified' stamp: 'len 6/3/2019 02:31:59'!
testPowerSeries
	| cos sin |
	sin _ PowerSeries sin.
	cos _ PowerSeries cos.
	self assert: ((cos squared + sin squared) coefficients beginsWith: #(1 0 0 0 0 0 0 0 0))! !

!SequenceTest methodsFor: 'as yet unclassified' stamp: 'len 6/5/2019 17:10:44'!
testPowerSeriesReciprocal
	| cos |
	cos _ PowerSeries cos.
	self assert: ((cos * cos reciprocal) coefficients beginsWith: #(1 0 0 0 0 0 0 0 0))! !

!SequenceTest methodsFor: 'as yet unclassified' stamp: 'len 11/25/2016 10:32:36'!
testRecursive
	| f g |
	f _ Sequence fibonacci.
	g _ CFiniteSequence to: ZZ evaluating: f maxOrder: 5.
	self assert: (f equals: g upTo: 20).
	self assert: g order = 2.
	self assert: g characteristicPolynomial coefficients asArray = #(-1 -1 1)! !

!SequenceTest methodsFor: 'as yet unclassified' stamp: 'len 10/31/2016 04:13'!
testRecursive2
	| a b c |
	a _ CFiniteSequence fibonacci.
	b _ CFiniteSequence lucasNumbers.
	c _ a + (b*2) - (b+b).
	self assert: a = c! !

!SequenceTest methodsFor: 'as yet unclassified' stamp: 'len 3/7/2017 07:28:24'!
testRecursiveConvolution
	| a b c a2 b2 c2 |
	a _ CFiniteSequence fibonacci.
	b _ CFiniteSequence lucasNumbers.
	a2 _ Sequence evaluating: [:i| a at: i].
	b2 _ Sequence evaluating: [:i| b at: i].

	c _ a convolution: b.
	c2 _ a2 convolution: b2.
	
	self assert: (c equals: c2 upTo: 20)! !

!SequenceTest methodsFor: 'as yet unclassified' stamp: 'len 10/31/2016 04:14'!
testRecursiveEquals
	| a b c |
	a _ CFiniteSequence fibonacci.
	b _ CFiniteSequence to: ZZ evaluating: [:i| a at: i] maxOrder: 10.
	c _ CFiniteSequence lucasNumbers.
	self assert: a = b.
	self assert: a ~= c! !

!SequenceTest methodsFor: 'as yet unclassified' stamp: 'len 3/7/2017 07:28:49'!
testRecursiveIndefiniteSumation
	| a c a2 c2 |
	a _ CFiniteSequence fibonacci.
	a2 _ Sequence evaluating: [:i| a at: i].

	c _ a sum.
	c2 _ a2 sum.
	self assert: (c isKindOf: CFiniteSequence).
	self assert: (c equals: c2 upTo: 20)! !

!SequenceTest methodsFor: 'as yet unclassified' stamp: 'len 10/31/2016 04:13'!
testRecursiveMinimal
	| a f |
	a _ CFiniteSequence initialValues: #(0 1 1) coefficients: #(0 1 1).
	f _ CFiniteSequence fibonacci.
	self assert: a isMinimal not.
	self assert: a order = 3.
	self assert: a minimal order = 2.
	self assert: a minimalPolynomial = f characteristicPolynomial! !

!SequenceTest methodsFor: 'as yet unclassified' stamp: 'len 3/7/2017 07:29:10'!
testRecursiveProduct
	| a b c c2 |
	a _ CFiniteSequence fibonacci.
	b _ CFiniteSequence pellNumbers.
	c _ a * b.
	c2 _ Sequence evaluating: [:i| (a at: i) * (b at: i)].
	self assert: (c isKindOf: CFiniteSequence).
	self assert: (c equals: c2 upTo: 20).
	self assert: c order = 4! !

!SequenceTest methodsFor: 'as yet unclassified' stamp: 'len 3/7/2017 07:29:52'!
testRecursiveScalarMultiplication
	| a c a2 c2 |
	a _ CFiniteSequence fibonacci.
	a2 _ Sequence evaluating: [:i| a at: i].

	c _ a * 7.
	c2 _ a2 * 7.
	self assert: (c isKindOf: CFiniteSequence).
	self assert: (c equals: c2 upTo: 20)! !

!SequenceTest methodsFor: 'as yet unclassified' stamp: 'len 3/7/2017 07:30:12'!
testRecursiveShiftLeft
	| a c a2 c2 |
	a _ CFiniteSequence fibonacci.
	a2 _ Sequence evaluating: [:i| a at: i].

	c _ a << 5.
	c2 _ a2 << 5.
	self assert: (c isKindOf: CFiniteSequence).
	self assert: (c equals: c2 upTo: 20)! !

!SequenceTest methodsFor: 'as yet unclassified' stamp: 'len 3/7/2017 07:30:25'!
testRecursiveSum
	| a b c c2 |
	a _ CFiniteSequence fibonacci.
	b _ CFiniteSequence lucasNumbers.
	c _ a + b.
	c2 _ Sequence evaluating: [:i| (a at: i) + (b at: i)].
	self assert: (c isKindOf: CFiniteSequence).
	self assert: (c equals: c2 upTo: 20)! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 2/20/2017 08:36:51'!
test2Sphere
	| X |
	X _ SimplicialComplex sphere: 2.
	self assert: X dimension = 2.
	self assert: X fVector = (1,4,6,4)! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 2/20/2017 08:37:08'!
test5Sphere
	| X |
	X _ SimplicialComplex sphere: 5.
	self assert: X dimension = 5.
	self assert: X fVector = (1,7,21,35,35,21,7)! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 2/19/2017 10:28:26'!
testAlexanderDual
	| X Y |
	X _ SimplicialComplex faces: #((0 1) (1 2) (2 3) (3 0)).
	self assert: X dual dual = X.
	Y _ SimplicialComplex faces: #((1 3) (0 2)).
	self assert: X dual = Y.
	self assert: X dual nonfaces = X complement facets! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 2/26/2017 09:03:04'!
testChainComplex
	"Jeff Erickson, 'Computational Topology', Example 17.7."
	| S2 C |
	S2 _ SimplicialComplex facets: ((Simplex vertices: #(w x y z)) faces: 2).
	C _ S2 chainComplexOver: ZZ.
	self assert: (C cycles: 1) rank = 3.
	self assert: (C boundaries: 0) rank = 3.
	self assert: (C boundaries: 1) = (C cycles: 0).
	self assert: C betti = #(1 0 1)! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 2/20/2017 08:37:27'!
testEulerCharacteristic
	| X |
	X _ SimplicialComplex torus.
	self assert: X euler = 0.
	X _ SimplicialComplex sphere: 2.
	self assert: X euler = 2.
	X _ SimplicialComplex kleinBottle.
	self assert: X euler = 0.
	X _ SimplicialComplex realProjectivePlane.
	self assert: X euler = 1! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 2/19/2017 08:23:09'!
testJoin
	| S X |
	S _ SimplicialComplex faces: #((0) (1)).
	X _ S * S * S * S * S * S * S * S.
	self assert: X vertices size = 16.
	self assert: X facets size = 256
! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 2/19/2017 08:23:15'!
testMinimalNonFaces
	| X |
	X _ SimplicialComplex faces: #((1 3) (1 2)).
	self assert: X nonfaces = {Simplex vertices: #(2 3)} asSet.
	X _ SimplicialComplex faces: #((0 1) (1 2) (2 3) (3 0)).
	self assert: X nonfaces = {Simplex vertices: #(1 3). Simplex vertices: #(0 2)} asSet
! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 2/19/2017 08:23:18'!
testMinimalNonFaces2
	| X MNF |
	X _ SimplicialComplex faces: #((0 1 2) (0 2 3) (2 3 4) (1 2 4) (1 4 5) (0 3 6) (3 6 7) (4 5 7)).
	MNF _ (#((3 4 7) (0 7) (0 4) (0 5) (3 5) (1 7) (2 5) (5 6) (1 3) (4 6) (2 7) (2 6) (1 6)) collect: [:each| Simplex vertices: each]) asSet.
	self assert: X nonfaces = MNF! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 2/19/2017 08:23:21'!
testProduct
	| C T |
	"Circle:"
	C _ SimplicialComplex faces: #((0 1) (1 2) (0 2)).
	"Torus:"
	T _ C ◊ C.
	self assert: T euler = 0.
	self assert: T vertices size = 9.
	self assert: T facets size = 18! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 2/14/2017 19:00:06'!
testSimplecialComplex
	| S |
	S _ SimplicialComplex facets: {{1. 2. 3}. {2. 4}. {3. 4}. {5}}.
	self assert: (S faces: 2) asSet size = 1.
	self assert: (S faces: 1) asSet size = 5.
	self assert: (S faces: 0) asSet size = 5! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 2/25/2017 10:08:54'!
testSimplex
	| tetrahedron |
	tetrahedron _ Simplex vertices: #(a b c d).
	self assert: tetrahedron dimension = 3.
	self assert: (tetrahedron faces: 2) size = 4.
	self assert: tetrahedron edges size = 6.
	self assert: (tetrahedron faces: 3) size = 1! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 2/19/2017 08:37:30'!
testSimplexComplement
	| V |
	V _ (0 to: 5).
	self assert: ((Simplex vertices: #(1 2 3)) complementIn: V) = (Simplex vertices: #(0 4 5)).
	self assert: ((Simplex vertices: #(0 1 3 4)) complementIn: V) = (Simplex vertices: #(2 5)).
	self assert: ((Simplex vertices: #(0 4 1 3 )) complementIn: V) = (Simplex vertices: #(2 5))! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 3/7/2017 07:30:50'!
testSimplexInclusion
	| S S2 |
	S _ Simplex new: (2 to: 10) atRandom.
	S2 _ Simplex new: (0 to: S dimension) atRandom.
	self assert: S2 <= S! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 2/15/2017 16:21:54'!
testSimplexJoin
	| A B |
	A _ Simplex new: 2.
	B _ Simplex new: 3.
	self assert: A*B ~ (Simplex new: 2+1+3+1-1)
! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 5/5/2019 18:34:13'!
testSimplicalChainsBoundaryMap
	| X d1 d2 |
	X _ SimplicialComplex sphere: 2.
	d2 _ X boundaryMap: 2 over: QQ.
	d1 _ X boundaryMap: 1 over: QQ.
	self assert: d2 isZero not.
	self assert: d1 isZero not.
	self assert: (d1 ∑ d2) isZero! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 2/19/2017 10:00:52'!
testSimplicialComplexExample
	"Example from Herzog, 'Monomial Ideals', pag. 16."
	| X |
	X _ SimplicialComplex on: (1 to: 5) faces: #((1 2 4) (1 2 5) (2 3) (3 4)).
	self assert: X facets = (#((1 2 4) (1 2 5) (2 3) (3 4)) collect: [:each| Simplex vertices: each]) asSet.
	self assert: X nonfaces = (#((1 3) (3 5) (4 5) (2 3 4)) collect: [:each| Simplex vertices: each]) asSet.
	self assert: X fVector = (1,5,7,2).
	self assert: X hVector = (1,2,0,-1)! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 2/20/2017 18:52:39'!
testSimplicialMap
	| S T f |
	S _ SimplicialComplex faces: #((0 2) (1 5) (3 4)).
	T _ SimplicialComplex faces: #((0 2) (1 3)).
	f _ S to: T map: ({0 -> 0. 1 -> 1. 2 -> 2. 3 -> 1. 4 -> 3. 5 -> 3} as: Dictionary).
	self assert: f image = T.
	self assert: f isSurjective.
	self assert: f isInjective not.
	self assert: f isIdentity not! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 2/19/2017 10:49:02'!
testStanleyReisnerIdealAndBack
	| X |
	X _ SimplicialComplex on: (1 to: 5) faces: #((1 2 4) (1 2 5) (2 3) (3 4)).
	self assert: X stanleyReisnerIdeal asSimplicialComplex = X! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 2/19/2017 18:14:18'!
testStanleyReisnerIdealAndBack2
	| X |
	X _ SimplicialComplex on: (1 to: 5) faces: #((1 3 2) (3 4) (2 4) (5)).
	self assert: X stanleyReisnerIdeal asSimplicialComplex = X! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 2/19/2017 10:27:08'!
testStanleyReisnerIdealAndFacetIdealDuality
	| X |
	X _ SimplicialComplex on: (1 to: 5) faces: #((1 2 4) (1 2 5) (2 3) (3 4)).
	self assert: X dual stanleyReisnerIdeal = X complement facetIdeal! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 2/27/2017 20:46:17'!
testStanleyReisnerRing
	| X R |
	X _ SimplicialComplex faces: #((0 1) (1 2) (2 3) (3 0)).
	R _ QQ polynomialsIn: #(x y z w).
	self assert: X stanleyReisnerRing relations generators asSet = (R generate: [:x :y :z :w| {y*w. x*z}]) asSet! !

!SimplicialComplexTest methodsFor: 'as yet unclassified' stamp: 'len 2/14/2017 19:45:41'!
testTorus
	| X |
	X _ SimplicialComplex torus.
	self assert: X dimension = 2.
	self assert: X fVector = (1,7,21,14)! !

!TupleTest methodsFor: 'as yet unclassified' stamp: 'len 11/6/2016 11:35'!
testBitTupleBug
	| Z2 |
	Z2 _ PrimeField new: 2.
	self assert: ((1,0,0) % 2 :: sum = Z2 one).
	self assert: ((0,1,0) % 2 :: sum = Z2 one).
	self assert: ((1,1,0) % 2 :: sum = Z2 zero).
	self assert: ((1,1,1) % 2 :: sum = Z2 one)! !

!TupleTest methodsFor: 'as yet unclassified' stamp: 'len 4/29/2019 10:22:42'!
testBitTupleOperations
	| n a b |
	n _ 120 atRandom.
	a _ ZZ^n atRandomBits: n*2.
	b _ ZZ^n atRandomBits: n*2.
	#(+ - ∑ convolution: hadamard:) do: [:op|
		self testTuple: a with: b operation: op modulo: 2].
	#(negated reversed copy sum product) do: [:op|
		self testTuple: a operation: op modulo: 2]! !

!TupleTest methodsFor: 'as yet unclassified' stamp: 'len 11/6/2016 11:35'!
testBitTupleReversed
	| v i |
	v _ ZZ / 2 ^ 100 atRandom :: atRandom.
	i _ v size atRandom.
	self assert: (v reversed at: i) = (v at: v size - i + 1).
	self assert: v reversed reversed = v! !

!TupleTest methodsFor: 'as yet unclassified' stamp: 'len 5/8/2019 04:24:02'!
testBitTupleSum
	self assert: (BitTuple newFrom: 2r1011101) sum representative = 1.
	self assert: (BitTuple newFrom: 2r10000100100010) sum representative = 0! !

!TupleTest methodsFor: 'as yet unclassified' stamp: 'len 4/11/2018 15:54:46'!
testHomogeneousTuples
	self assert: (1,2,3) ~ (2,4,6).
	self deny: (1,2,3) ~ (-2,4,6)! !

!TupleTest methodsFor: 'as yet unclassified' stamp: 'len 4/11/2018 17:25:31'!
testHomogeneousTuples2
	| P Q |
	P _ (1,2) over: ZZ.
	Q _ (2,4) over: ZZ.
	self assert: P ~ Q.
	P _ (1,2) over: ZZ.
	Q _ (1,0) over: ZZ.
	self deny: P ~ Q! !

!TupleTest methodsFor: 'as yet unclassified' stamp: 'len 4/11/2018 17:25:53'!
testHomogeneousTuples3
	| R x P Q |
	R _ QQ polynomials.
	x _ R x.
	P _ R tuple: {x. x^2 + 1}.
	Q _ R tuple: {x^2. x^3 + x}.
	self assert: P ~ Q! !

!TupleTest methodsFor: 'as yet unclassified' stamp: 'len 4/11/2018 17:27:20'!
testHomogeneousTuples4
	| P Q |
	P _ (2,4,1) % 6.
	Q _ (0,1,3) % 6.
	self deny: P ~ Q! !

!TupleTest methodsFor: 'as yet unclassified' stamp: 'len 11/6/2016 11:31'!
testMakeZero: aTuple
	self assert: (aTuple * 0) isZero.
	self assert: (0 * aTuple) isZero.
	self assert: (aTuple + aTuple negated) isZero.
	self assert: (aTuple - aTuple) isZero! !

!TupleTest methodsFor: 'as yet unclassified' stamp: 'len 11/6/2016 11:39'!
testModTupleConcatenation
	self assert: (1,2,3) % 7, ((2,3,4) % 7) = ((1,2,3,2,3,4) % 7)! !

!TupleTest methodsFor: 'as yet unclassified' stamp: 'len 11/6/2016 13:49'!
testModTupleConvolution
	| a b |
	a _ (1,2,3).
	b _ (2,3,4).
	self assert: (a % 7 convolution: b % 7) = ((a convolution: b) % 7)! !

!TupleTest methodsFor: 'as yet unclassified' stamp: 'len 4/29/2019 10:22:49'!
testModTupleOperations
	| a b modulus |
	modulus _ 10 atRandom + 1.
	a _ ZZ^5 atRandomBits: 30.
	b _ ZZ^5 atRandomBits: 30.
	#(+ - ∑ convolution: hadamard:) do: [:op|
		self testTuple: a with: b operation: op modulo: modulus].
	#(negated reversed copy sum product) do: [:op|
		self testTuple: a operation: op modulo: modulus].! !

!TupleTest methodsFor: 'as yet unclassified' stamp: 'len 11/6/2016 11:38'!
testModTupleSum
	| a b |
	a _ ZZ tuple: ((1 to: 10) collect: [:i| 100 atRandom]).
	b _ a % 7.
	self assert: b sum = (a sum % 7)! !

!TupleTest methodsFor: 'as yet unclassified' stamp: 'len 11/6/2016 14:24'!
testTuple: a operation: aSymbol modulo: modulus
	self assert: (a perform: aSymbol) % modulus = (a % modulus perform: aSymbol)! !

!TupleTest methodsFor: 'as yet unclassified' stamp: 'len 11/6/2016 14:12'!
testTuple: a with: b operation: aSymbol modulo: modulus
	self assert: (a perform: aSymbol with: b) % modulus = (a % modulus perform: aSymbol with: b % modulus)! !

!TupleTest methodsFor: 'as yet unclassified' stamp: 'len 11/6/2016 11:36'!
testTupleSum
	self assert: (1,2,3) sum = (1 + 2 + 3)! !

!TupleTest methodsFor: 'as yet unclassified' stamp: 'len 2/28/2017 19:36:45'!
testTuplesModuleMembership
	self assert: (QQ^3 includes: (1,2,3)).
	self assert: (QQ^3 includes: (1,2,3,4)) not! !

!Benchmark methodsFor: 'as yet unclassified' stamp: 'len 3/1/2016 04:20'!
run
	| output |
	output _ WriteStream on: (String new: 1000).
	(self class selectors asArray select: [:each|
		(each beginsWith: 'test') and: [each numArgs isZero]]) sort
		do: [:each|
			output nextPutAll: each; tab.
			self setUp.
			Smalltalk garbageCollect.
			[output nextPutAll: [self perform: each] bench] on: Error do: [output nextPutAll: 'FAILED'].
			self tearDown]
		separatedBy: [output newLine].
	^ output contents! !

!Benchmark methodsFor: 'as yet unclassified' stamp: 'len 3/1/2016 04:16'!
setUp
	^ self! !

!Benchmark methodsFor: 'as yet unclassified' stamp: 'len 3/1/2016 04:16'!
tearDown
	^ self! !

!AlgebraicNumbersBenchmark methodsFor: 'as yet unclassified' stamp: 'len 4/29/2018 20:33:55'!
testComplexAlgebraicNumberAddition
	| sqrt2 sqrt3 sqrt5 |
	sqrt2 _ ComplexAlgebraicNumber sqrt: 2.
	sqrt3 _ ComplexAlgebraicNumber sqrt: 3.
	sqrt5 _ ComplexAlgebraicNumber sqrt: 5.
	10 timesRepeat: [sqrt3 + sqrt5 + sqrt2 - sqrt3 - sqrt5]! !

!AlgebraicNumbersBenchmark methodsFor: 'as yet unclassified' stamp: 'len 4/29/2018 20:34:35'!
testComplexAlgebraicNumberDivision
	| sqrt3 sqrt5 |
	sqrt3 _ ComplexAlgebraicNumber sqrt: 3.
	sqrt5 _ ComplexAlgebraicNumber sqrt: 5.
	10 timesRepeat: [sqrt3 / sqrt5 / sqrt3 / sqrt5]! !

!AlgebraicNumbersBenchmark methodsFor: 'as yet unclassified' stamp: 'len 4/29/2018 20:34:48'!
testComplexAlgebraicNumberProduct
	| sqrt3 sqrt5 |
	sqrt3 _ ComplexAlgebraicNumber sqrt: 3.
	sqrt5 _ ComplexAlgebraicNumber sqrt: 5.
	10 timesRepeat: [sqrt3 * sqrt5 * sqrt3 * sqrt5]! !

!AlgebraicNumbersBenchmark methodsFor: 'as yet unclassified' stamp: 'len 4/29/2018 20:33:28'!
testComplexAlgebraicNumberSquare
	| sqrt2 |
	sqrt2 _ ComplexAlgebraicNumber sqrt2.
	10 timesRepeat: [sqrt2 squared]! !

!AlgebraicNumbersBenchmark methodsFor: 'as yet unclassified' stamp: 'len 4/29/2018 20:33:01'!
testRealAlgebraicNumberAddition
	| sqrt2 sqrt3 sqrt5 |
	sqrt2 _ RealAlgebraicNumber sqrt: 2.
	sqrt3 _ RealAlgebraicNumber sqrt: 3.
	sqrt5 _ RealAlgebraicNumber sqrt: 5.
	10 timesRepeat: [sqrt3 + sqrt5 + sqrt2 - sqrt3 - sqrt5]! !

!AlgebraicNumbersBenchmark methodsFor: 'as yet unclassified' stamp: 'len 4/29/2018 20:33:06'!
testRealAlgebraicNumberDivision
	| sqrt3 sqrt5 |
	sqrt3 _ RealAlgebraicNumber sqrt: 3.
	sqrt5 _ RealAlgebraicNumber sqrt: 5.
	10 timesRepeat: [sqrt3 / sqrt5 / sqrt3 / sqrt5]! !

!AlgebraicNumbersBenchmark methodsFor: 'as yet unclassified' stamp: 'len 4/29/2018 20:33:11'!
testRealAlgebraicNumberProduct
	| sqrt3 sqrt5 |
	sqrt3 _ RealAlgebraicNumber sqrt: 3.
	sqrt5 _ RealAlgebraicNumber sqrt: 5.
	10 timesRepeat: [sqrt3 * sqrt5 * sqrt3 * sqrt5]! !

!AlgebraicNumbersBenchmark methodsFor: 'as yet unclassified' stamp: 'len 4/29/2018 20:33:15'!
testRealAlgebraicNumberSquare
	| sqrt2 |
	sqrt2 _ RealAlgebraicNumber sqrt2.
	10 timesRepeat: [sqrt2 squared]! !

!GroebnerBasisBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/12/2018 17:08:54'!
testCyclic3
	(QQ polynomialsIn: 3) cyclicIdeal groebnerBasis! !

!GroebnerBasisBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/12/2018 17:09:07'!
testCyclic4
	(QQ polynomialsIn: 4) cyclicIdeal groebnerBasis! !

!GroebnerBasisBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/12/2018 17:09:15'!
testCyclic5
	(QQ polynomialsIn: 5) cyclicIdeal groebnerBasis! !

!GroebnerBasisBenchmark methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:43'!
testEliminationExample
	| Qx x y z I |
	Qx _ QQ polynomialsIn: #(x y z).
	x _ Qx x. y _ Qx y. z _ Qx z.
	I _ Qx * {x^2 + y + z - 1. x + (y^2) + z - 1. x + y + (z^2) - 1}.
	I eliminateAll: #(1 2)! !

!GroebnerBasisBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/12/2018 17:14:27'!
testKatsura2
	(QQ polynomialsIn: 2) katsuraIdeal groebnerBasis! !

!GroebnerBasisBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/12/2018 17:14:35'!
testKatsura3
	(QQ polynomialsIn: 3) katsuraIdeal groebnerBasis! !

!GroebnerBasisBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/12/2018 17:14:42'!
testKatsura4
	(QQ polynomialsIn: 4) katsuraIdeal groebnerBasis! !

!GroebnerBasisBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/12/2018 17:03:54'!
testModularCyclic3
	((PrimeField new: 32003) polynomialsIn: 3) cyclicIdeal groebnerBasis! !

!GroebnerBasisBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/5/2019 05:10:15'!
testModularCyclic4
	((PrimeField new: 32003) polynomialsIn: 4) cyclicIdeal groebnerBasis! !

!GroebnerBasisBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/5/2019 05:09:43'!
testModularCyclic5
	((PrimeField new: 32003) polynomialsIn: 5) cyclicIdeal groebnerBasis! !

!GroebnerBasisBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/12/2018 17:15:14'!
testModularKatsura2
	((PrimeField new: 32003) polynomialsIn: 2) katsuraIdeal groebnerBasis! !

!GroebnerBasisBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/12/2018 17:15:31'!
testModularKatsura3
	((PrimeField new: 32003) polynomialsIn: 3) katsuraIdeal groebnerBasis! !

!GroebnerBasisBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/12/2018 17:15:39'!
testModularKatsura4
	((PrimeField new: 32003) polynomialsIn: 4) katsuraIdeal groebnerBasis! !

!GroupBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/15/2016 06:42'!
testJ1Order
	PermutationGroup J1 size! !

!GroupBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/15/2016 06:43'!
testM12Order
	PermutationGroup M12 size! !

!IntegersBenchmark methodsFor: 'as yet unclassified' stamp: 'len 7/3/2016 04:28'!
test1000Factorial
	1000 factorial! !

!ModularMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 6/9/2018 20:09:17'!
field: aField
	field _ aField! !

!ModularMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 6/9/2018 20:08:36'!
setUp
	| random |
	random _ Random seed: 1234.
	field isNil ifTrue: [field _ 	ZZ/32003].
	matrix _ field matrix: 300@300 evaluating: [:i :j| field atRandom: random]! !

!ModularMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/22/2016 11:55:20'!
testAddition
	matrix + matrix! !

!ModularMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 3/1/2017 09:06:54'!
testGaussianElimination
	matrix reduction reduced! !

!ModularMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 3/1/2017 09:33:07'!
testImage
	matrix image! !

!ModularMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 3/1/2017 09:33:01'!
testKernel
	matrix kernel! !

!ModularMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/22/2016 11:54:33'!
testSquared
	matrix squared! !

!ModularMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/22/2016 11:55:03'!
testTransposition
	matrix transposed! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/26/2018 18:11:49'!
testAdditionOverZ
	| P f g |
	P _ ZZ polynomials.
	f _ P atRandomBits: 100 maxDegree: 50.
	g _ P atRandomBits: 100 maxDegree: 50.
	10000 timesRepeat: [f + g]! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/26/2018 18:11:56'!
testAdditionOverZ2
	| P f g |
	P _ ZZ / 2 :: polynomials.
	f _ P atRandomDegree: 50.
	g _ P atRandomDegree: 50.
	10000 timesRepeat: [f + g]! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/26/2018 18:12:03'!
testDivisionOverQ
	| P x f g |
	P _ QQ polynomials.
	x _ P x.
	f _ x^2 + x + 1 ^ 10.
	g _ 1 - x ^ 10.
	2000 timesRepeat: [f // g. f \\ g]! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/26/2018 18:12:09'!
testDivisionOverZ
	| P x f g |
	P _ ZZ polynomials.
	x _ P x.
	f _ x^2 + x + 1 ^ 10.
	g _ 1 - x ^ 10.
	2000 timesRepeat: [f // g. f \\ g]! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/26/2018 19:28:17'!
testFactorizationOverZ17Degree100
	| n f |
	n _ 100.
	f _ (ZZ/17) polynomials !! [:x| ((1 to: n) sum: [:i| x^i*i]) + 1].
	f factors! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/26/2018 19:28:02'!
testFactorizationOverZ3Degree11Times20
	| F Fx x one f |
	F _ ZZ / 3.
	Fx _ F polynomials.
	x _ Fx x.
	one _ Fx one.
	f _ x^11 + (x^9 * 2) + (x^8 * 2) + (x^6) + (x^5) + (x^3 * 2) + (x^2 * 2) + one.
	20 timesRepeat: [f factors]! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/26/2018 19:28:38'!
testFiniteField
	"Benchmark Polynomial>>#= and ResidueClass#>>="
	| F |
	F _ GaloisField new: 9.
	((F^3) upTo: 9^3) asSet size = (9^3) ifFalse: [self halt]! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/26/2018 18:12:26'!
testGCDOverQ
	| P x f g |
	P _ QQ polynomials.
	x _ P x.
	f _ x^4 - 1 ^ 5.
	g _ x^6 - 1 ^ 5.
	2000 timesRepeat: [f gcd: g]! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/26/2018 18:12:33'!
testGCDOverZ
	| P x f g |
	P _ ZZ polynomials.
	x _ P x.
	f _ x^4 - 1 ^ 5.
	g _ x^6 - 1 ^ 5.
	2000 timesRepeat: [f gcd: g]! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/26/2018 18:12:39'!
testGCDOverZ2
	| P x f g |
	P _ ZZ / 2 :: polynomials.
	x _ P x.
	f _ x^4 - 1 ^ 5.
	g _ x^6 - 1 ^ 5.
	2000 timesRepeat: [f gcd: g]! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/26/2018 18:12:46'!
testMultiplication2OverZ
	| P f g |
	P _ ZZ polynomials.
	f _ P atRandomBits: 100 maxDegree: 50.
	g _ P atRandomBits: 100 maxDegree: 50.
	100 timesRepeat: [f * g]! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/26/2018 18:13:05'!
testMultiplication2OverZ2
	| P f g |
	P _ PrimeField new: 2 :: polynomials.
	f _ P atRandomBits: 100 maxDegree: 50.
	g _ P atRandomBits: 100 maxDegree: 50.
	100 timesRepeat: [f * g]! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/26/2018 18:13:12'!
testMultiplicationOverZ
	| P x f |
	P _ QQ polynomials.
	x _ P x.
	f _ x - 1.
	1 to: 9 do: [:i| f _ x - i * f * f]! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/26/2018 18:13:19'!
testMultiplicationOverZ2
	| P x f |
	P _ PrimeField new: 2 :: polynomials.
	x _ P x.
	f _ x - (1 % 2).
	1 to: 9 do: [:i| f _ x - (i % 2) * f * f]! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:49'!
testMultivariatePolynomialAdditionOverZ
	| P f g |
	P _ ZZ polynomialsIn: #(x y z).
	f _ P atRandomBits: 100 maxDegree: 50.
	g _ P atRandomBits: 100 maxDegree: 50.
	10000 timesRepeat: [f + g]! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/26/2018 18:13:29'!
testPseudoDivision
	| Zx x a b |
	Zx _ ZZ polynomials.
	x _ Zx x.
	a _ x^8 + (x^6) - (3*(x^4)) - (3*(x^3)) + (8*(x^2)) + (2*x) - 5.
	b _ 3*(x^6) + (5*(x^4)) - (4*(x^2)) - (9*x) + 21.
	20 timesRepeat: [(a pseudoDivisionBy: b) quotient]! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/26/2018 18:13:38'!
testPseudoRemainder
	| Zx x a b |
	Zx _ ZZ polynomials.
	x _ Zx x.
	a _ x^8 + (x^6) - (3*(x^4)) - (3*(x^3)) + (8*(x^2)) + (2*x) - 5.
	b _ 3*(x^6) + (5*(x^4)) - (4*(x^2)) - (9*x) + 21.
	20 timesRepeat: [a pseudoRem: b]! !

!PolynomialBenchmark methodsFor: 'as yet unclassified' stamp: 'len 5/26/2018 18:13:48'!
testRealRoots
	| x f |
	x _ QQ polynomials x.
	f _ (x-(1/2))^2*(x-2)*(x^2 + 1)*(x^2-2).
	20 timesRepeat: [f rootsIn: RR]! !

!SmallMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 12/2/2016 09:23:51'!
setUp
	integerMatrix _ ZZ ^ (64@64) :: atRandomBits: 10000.
	binaryMatrix _ (PrimeField new: 2) ^ (64@64) :: atRandom.
	modularMatrix _ (PrimeField new: 32003) ^ (64@64) :: atRandom! !

!SmallMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 7/8/2016 02:48'!
testAdditionZ
	integerMatrix + integerMatrix! !

!SmallMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 7/8/2016 02:48'!
testAdditionZ2
	binaryMatrix + binaryMatrix! !

!SmallMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 12/2/2016 09:24:56'!
testAdditionZp
	modularMatrix + modularMatrix! !

!SmallMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 7/8/2016 02:49'!
testCopyZ
	integerMatrix copy! !

!SmallMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 7/8/2016 02:50'!
testCopyZ2
	binaryMatrix copy! !

!SmallMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 12/2/2016 09:24:46'!
testCopyZp
	modularMatrix copy! !

!SmallMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 4/26/2018 20:41:21'!
testImageZ
	integerMatrix image! !

!SmallMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 3/1/2017 09:36:24'!
testImageZ2
	binaryMatrix image! !

!SmallMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 3/1/2017 09:36:52'!
testImageZp
	modularMatrix image! !

!SmallMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 4/26/2018 20:41:50'!
testKernelZ
	integerMatrix kernel! !

!SmallMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 3/1/2017 09:36:17'!
testKernelZ2
	binaryMatrix kernel! !

!SmallMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 3/1/2017 09:36:46'!
testKernelZp
	modularMatrix kernel! !

!SmallMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 7/8/2016 02:49'!
testMultiplicationZ
	integerMatrix * integerMatrix! !

!SmallMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 7/8/2016 02:58'!
testMultiplicationZ2
	binaryMatrix * binaryMatrix! !

!SmallMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 12/2/2016 09:24:37'!
testMultiplicationZp
	modularMatrix * modularMatrix! !

!SmallMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 7/8/2016 02:49'!
testTranspositionZ
	integerMatrix transposed! !

!SmallMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 7/8/2016 02:58'!
testTranspositionZ2
	binaryMatrix transposed! !

!SmallMatrixBenchmark methodsFor: 'as yet unclassified' stamp: 'len 12/2/2016 09:24:25'!
testTranspositionZp
	modularMatrix transposed! !

!SparsePolynomialMultiplicationBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/22/2016 11:48:08'!
setUp
	| P x y z |
	P _ ZZ polynomialsIn: #(x y z).
	x _ P x.
	y _ P y.
	z _ P z.
	p _ (1+x+y+z)^20.
	pBigCoefficients _ 10000000001*(1+x+y+z)^20. "big coefficients"
	pBigExponents _ 1 + (x^2147483647) + (y^2147483647) + (z^2147483647) ^ 20. "big exponents"
	pPlusOne _ p + 1.
	pBigCoefficientsPlusOne _ pBigCoefficients + 1.
	pBigExponentsPlusOne _ pBigExponents + 1! !

!SparsePolynomialMultiplicationBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/22/2016 11:48:43'!
testBigCoefficientsProduct
	pBigCoefficients * pBigCoefficientsPlusOne! !

!SparsePolynomialMultiplicationBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/22/2016 11:49:00'!
testBigExponentsProduct
	pBigExponents * pBigExponentsPlusOne! !

!SparsePolynomialMultiplicationBenchmark methodsFor: 'as yet unclassified' stamp: 'len 6/5/2016 08:44'!
testProduct
	p * pPlusOne! !

!TupleConvolutionBenchmark methodsFor: 'as yet unclassified' stamp: 'len 6/6/2019 09:34:36'!
setUp
	| n R |
	n _ 80.
	R _ ZZ^n.
	a _ R atRandomBits: n*10.
	b _ R atRandomBits: n*10! !

!TupleConvolutionBenchmark methodsFor: 'as yet unclassified' stamp: 'len 6/6/2019 09:31:24'!
testConvolution
	a convolution: b! !

!TupleConvolutionBenchmark methodsFor: 'as yet unclassified' stamp: 'len 6/6/2019 09:31:54'!
testConvolution2
	a convolution2: b! !

!CASBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/19/2016 11:05:43'!
run
	| output |
	output _ WriteStream on: (String new: 1000).
	(self class selectors asArray select: [:each|
		(each beginsWith: 'test') and: [each numArgs isZero]]) sort
		do: [:each|
			output nextPutAll: each; tab.
			"self setUp."
			Smalltalk garbageCollect.
			[output nextPutAll: (self perform: each)] on: Error do: [output nextPutAll: 'FAILED'].
			"self tearDown"]
		separatedBy: [output newLine].
	^ output contents! !

!CASBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/19/2016 18:35:51'!
testConvolution: a with: b into: c modulo: m
	c atAllPut: 0.
	1 to: a size do: [:i|
		1 to: b size do: [:j| | index |
			index _ i+j-1.
			c at: index put: (a at: i) * (b at: j) + (c at: index) \\ m]].
	^ c! !

!CASBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/19/2016 18:02:38'!
testDotProduct: a with: b modulo: m
	| answer |
	answer _ 0.
	1 to: a size do: [:i| answer _ (a at: i) * (b at: i) + answer \\ m].
	^ answer! !

!CASBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/19/2016 17:55:38'!
testEqualsBytes
	| random a b |
	random _ Random seed: 1234.
	a _ ((1 to: 1000) collect: [:each| (random nextInteger: 256) - 1]) asByteArray.
	b _ a copy.
	^ [a = b] bench! !

!CASBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/19/2016 17:57:31'!
testEqualsWords
	| random a b |
	random _ Random seed: 1234.
	a _ ((1 to: 1000) collect: [:each| (random nextInteger: 256) - 1]) asWordArray.
	b _ a copy.
	^ [a = b] bench! !

!CASBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/19/2016 17:57:05'!
testHashBytes
	| random a |
	random _ Random seed: 1234.
	a _ ((1 to: 1000) collect: [:each| (random nextInteger: 256) - 1]) asByteArray.
	^ [a hash] bench! !

!CASBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/19/2016 17:57:21'!
testHashWords
	| random a |
	random _ Random seed: 1234.
	a _ ((1 to: 1000) collect: [:each| (random nextInteger: 256) - 1]) asWordArray.
	^ [a hash] bench! !

!CASBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/19/2016 18:01:16'!
testModularConvolutionBytes
	| random p a b c |
	p _ 251.
	random _ Random seed: 1234.
	a _ ((1 to: 1000) collect: [:each| (random nextInteger: p) - 1]) asByteArray.
	b _ ((1 to: 1000) collect: [:each| (random nextInteger: p) - 1]) asByteArray.
	c _ ByteArray new: 2000.
	^ [self testConvolution: a with: b into: c modulo: p] bench! !

!CASBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/19/2016 17:59:23'!
testModularConvolutionWords
	| random p a b c |
	p _ 32003.
	random _ Random seed: 1234.
	a _ ((1 to: 1000) collect: [:each| (random nextInteger: p) - 1]) asWordArray.
	b _ ((1 to: 1000) collect: [:each| (random nextInteger: p) - 1]) asWordArray.
	c _ WordArray new: 2000.
	^ [self testConvolution: a with: b into: c modulo: p] bench! !

!CASBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/19/2016 18:03:18'!
testModularDotProductBytes
	| random p a b |
	p _ 251.
	random _ Random seed: 1234.
	a _ ((1 to: 1000) collect: [:each| (random nextInteger: p) - 1]) asByteArray.
	b _ ((1 to: 1000) collect: [:each| (random nextInteger: p) - 1]) asByteArray.
	^ [self testDotProduct: a with: b modulo: p] bench! !

!CASBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/19/2016 18:03:50'!
testModularDotProductWords
	| random p a b |
	p _ 32003.
	random _ Random seed: 1234.
	a _ ((1 to: 1000) collect: [:each| (random nextInteger: p) - 1]) asWordArray.
	b _ ((1 to: 1000) collect: [:each| (random nextInteger: p) - 1]) asWordArray.
	^ [self testDotProduct: a with: b modulo: p] bench! !

!CASBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/19/2016 18:01:23'!
testModularSumBytes
	| random p a b c |
	p _ 251.
	random _ Random seed: 1234.
	a _ ((1 to: 1000) collect: [:each| (random nextInteger: p) - 1]) asByteArray.
	b _ ((1 to: 1000) collect: [:each| (random nextInteger: p) - 1]) asByteArray.
	c _ ByteArray new: 1000.
	^ [self testSum: a with: b into: c modulo: p] bench! !

!CASBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/19/2016 17:59:15'!
testModularSumWords
	| random p a b c |
	p _ 32003.
	random _ Random seed: 1234.
	a _ ((1 to: 1000) collect: [:each| (random nextInteger: p) - 1]) asWordArray.
	b _ ((1 to: 1000) collect: [:each| (random nextInteger: p) - 1]) asWordArray.
	c _ WordArray new: 1000.
	^ [self testSum: a with: b into: c modulo: p] bench! !

!CASBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/19/2016 19:09:54'!
testPermutate: a with: b into: c
	1 to: a size do: [:i| c at: i put: (b at: (a at: i))]! !

!CASBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/19/2016 19:08:57'!
testPermutationCompositionArray
	| n a b c |
	n _ 1000.
	a _ (1 to: n) shuffled.
	b _ (1 to: n) shuffled.
	c _ Array new: n.
	^ [self testPermutate: a with: b into: c] bench! !

!CASBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/19/2016 11:11:52'!
testPermutationCompositionWords
	| n a b c |
	n _ 1000.
	a _ (1 to: n) shuffled asWordArray.
	b _ (1 to: n) shuffled asWordArray.
	c _ WordArray new: n.
	^ [self testPermutate: a with: b into: c] bench! !

!CASBenchmark methodsFor: 'as yet unclassified' stamp: 'len 11/19/2016 10:57:34'!
testSum: a with: b into: c modulo: m
	1 to: a size do: [:i| c at: i put: (a at: i) + (b at: i) \\ m].
	^ c! !
