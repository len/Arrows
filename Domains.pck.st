'From Cuis 6.0 [latest update: #5053] on 13 April 2022 at 9:05:19 am'!
'Description A computational algebra system in Smalltalk.

References:
[AL94] William W. Adams; Philippe Loustaunau; "An Introduction To Groebner Bases", GSM Vol 3, AMS (1994)
[ADL06] Nadia Ben Atti, Gema M. Diaz-Toca, Henri Lombardi, "The Berlekamp-Massey Algorithm Revisited" (2006)
[BW93] Thomas Becker; Volker Weispfenning; "Groebner Bases: A Computational Approach to Commutative Algebra" (1993)
[BF15] Bini, G.; Flamini, F. "Finite commutative rings and their applications" (2015)
[Coh96] Henri Cohen, "A Course in Computational Algebraic Number Theory" (1996)
[CLO97] David Cox; John Little; Donals O''Shea; "Ideals, Varieties and Algorithms", UTM, Springer, 1997
[DK02] Harm Derksen; Gregor Kemper; "Computational Invariant Theory"
[Dix82] John D. Dixon, "Exact Solution of Linear Equations Using p-Adic Expansions" (1982)
[Eis95] David Eisenbud; "Commutative Algebra With a View Towards Algebraic Geometry", GTM 150, Springer, 1995
[] Claus Flieker, Tommy Hofmann, "Computing in quotients of rings of integers" (2016)
[GM73] Ganske, G.; McDonald, B.R. "Finite local rings". Rocky Mountain J. Math. 3 (1973), no. 4, 521-540
[HH11] Jurgen Herzog, Takayuki Hibi, "Monomial Ideals" (2011)
[] John A. Howell, "Spans in the module (Z/mZ)^s" (1986)
[KSWZ17] Deepak Kapur, Yao Sun, Dingkang Wang, Jie Zhou, "The Generalized Rabinowitsch Trick" (2017)
[Mat11] Keith Matthews, "Solving AX=B using the Hermite normal form" (2011)
[Mis93] Mishra, B; "Algorithmic Algebra", Springer, Monographs in Computer Science, 1993
[Mon04] Michael Monagan; ''Maximal Quotient Rational Reconstruction: An Almost Optimal Algorithm for Rational Reconstructoin'' (2004)
[SY09] Michael Sagraloff, Chee K. Yap, "An Efficient and Exact Subdivision Algorithm for Isolating Complex Roots of a Polynomial and its Complexity Analysis" (2009)
[Sam71] Pierre Samuel, "About Euclidean Rings", J. Algebra, 19:282-301, 1971
[Sto00] Arne Storjohann, "Algorithms for Matrix Canonical Forms" (2000)
[] Arne Storjohann, Thom Mulders, "Fast algorithms for linear algebra modulo N" (1998)
[] Thomas Becker; "Groebner Bases: A Computational Approach"
[] David Cox; John Little; Donals O''Shea; "Using Algebraic Geometry"
[] John Cremona; "Algorithms for Modular Elliptic Curves"
[] David Eisenbud; D. Grayson; M. Stillman; B. Sturmfels; "Computations in Algebraic Geometry with Macaulay 2"
[EH99] David Eisenbud; Joe Harris; "The Geometry of Schemes", GTM 197, Springer, 1999
[] Joachim von zur Gathen; Jurgen Gerhard; "Modern Computer Algebra"
[] Gert-Martin Greuel; Gerhard Pfister; "A Singular Introduction to Commutative Algebra"
[] Robin Hartshorne; "Algebraic Geometry", GTM 52, Springer, 1977
[] Derek F. Holt; B. Eick; E. A. O''Brien; "Handbook of Computational Group Theory"
[] Gregor Kemper; "A Course in Commutative Algebra", GTM 256, Springer, 2011
[] Dimitry Kozlov; "Combinatorial Algebraic Topology"
[] Martin Kreuzer; "Computational Commutative Algebra"
[] Henri Lombardi; Claude Quitte; "Commutative Algebra: Constructive Methods, Finite Projective Modules"
[] Ezra Miller; Bernd Sturmfels; "Combinatorial Commutative Algebra"
[] Qing Liu; "Algebraic Geometry and Arithmetic Curves"
[] Victor Shoup; "A Computational Introduction to Number Theory and Algebra"
[] Joseph. H. Silverman; "The Arithmetic of Elliptic Curves"
'!
!provides: 'Domains' 1 646!
!requires: 'Collections-Graphs' 1 4 nil!
!requires: 'Complex' 1 7 nil!
SystemOrganization addCategory: 'Domains-Kernel'!
SystemOrganization addCategory: 'Domains-Kernel-Support'!
SystemOrganization addCategory: 'Domains-Monoids'!
SystemOrganization addCategory: 'Domains-Monoids-Orderings'!
SystemOrganization addCategory: 'Domains-Groups'!
SystemOrganization addCategory: 'Domains-Groups-Permutations'!
SystemOrganization addCategory: 'Domains-Groups-Linear'!
SystemOrganization addCategory: 'Domains-Groups-Algorithms'!
SystemOrganization addCategory: 'Domains-Modules'!
SystemOrganization addCategory: 'Domains-Modules-Support'!
SystemOrganization addCategory: 'Domains-Modules-Algorithms'!
SystemOrganization addCategory: 'Domains-Complexes'!
SystemOrganization addCategory: 'Domains-Lattices'!
SystemOrganization addCategory: 'Domains-Rings'!
SystemOrganization addCategory: 'Domains-Rings-Finite'!
SystemOrganization addCategory: 'Domains-Algebras-Affine'!
SystemOrganization addCategory: 'Domains-Algebras-Affine-Algorithms'!
SystemOrganization addCategory: 'Domains-Algebras-Associative'!
SystemOrganization addCategory: 'Domains-Algebras-Distributive'!
SystemOrganization addCategory: 'Domains-Fields'!
SystemOrganization addCategory: 'Domains-Fields-Global'!
SystemOrganization addCategory: 'Domains-Fields-Local'!
SystemOrganization addCategory: 'Domains-Schemes'!
SystemOrganization addCategory: 'Domains-Varieties'!
SystemOrganization addCategory: 'Domains-Algorithms'!
SystemOrganization addCategory: 'Domains-Sequences'!
SystemOrganization addCategory: 'Domains-Tableaux'!
SystemOrganization addCategory: 'Domains-Simplicial Complexes'!
SystemOrganization addCategory: 'Domains-Elliptic Curves'!
SystemOrganization addCategory: 'Domains-Etc'!
SystemOrganization addCategory: 'Domains-Etc-Algebras'!
SystemOrganization addCategory: 'Domains-Etc-Lie'!
SystemOrganization addCategory: 'Domains-Etc-Modular Forms'!
SystemOrganization addCategory: 'Domains-Etc-Modular Group'!


!classDefinition: #RealAlgebraicNumber category: 'Domains-Fields'!
Number subclass: #RealAlgebraicNumber
	instanceVariableNames: 'minimalPolynomial bounds rightSign'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Fields'!
!classDefinition: 'RealAlgebraicNumber class' category: 'Domains-Fields'!
RealAlgebraicNumber class
	instanceVariableNames: ''!

!classDefinition: #ContinuedFraction category: 'Domains-Sequences'!
Number subclass: #ContinuedFraction
	instanceVariableNames: 'coefficients'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Sequences'!
!classDefinition: 'ContinuedFraction class' category: 'Domains-Sequences'!
ContinuedFraction class
	instanceVariableNames: ''!

!classDefinition: #Cardinal category: 'Domains-Kernel-Support'!
Magnitude subclass: #Cardinal
	instanceVariableNames: 'order'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Kernel-Support'!
!classDefinition: 'Cardinal class' category: 'Domains-Kernel-Support'!
Cardinal class
	instanceVariableNames: ''!

!classDefinition: #Infinity category: 'Domains-Kernel-Support'!
Magnitude subclass: #Infinity
	instanceVariableNames: 'sign'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Kernel-Support'!
!classDefinition: 'Infinity class' category: 'Domains-Kernel-Support'!
Infinity class
	instanceVariableNames: ''!

!classDefinition: #Ordinal category: 'Domains-Kernel-Support'!
Magnitude subclass: #Ordinal
	instanceVariableNames: 'terms'
	classVariableNames: 'Zero'
	poolDictionaries: ''
	category: 'Domains-Kernel-Support'!
!classDefinition: 'Ordinal class' category: 'Domains-Kernel-Support'!
Ordinal class
	instanceVariableNames: ''!

!classDefinition: #IdentityArray category: 'Domains-Kernel-Support'!
Array variableSubclass: #IdentityArray
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Kernel-Support'!
!classDefinition: 'IdentityArray class' category: 'Domains-Kernel-Support'!
IdentityArray class
	instanceVariableNames: ''!

!classDefinition: #BitArray2 category: 'Domains-Etc'!
ArrayedCollection subclass: #BitArray2
	instanceVariableNames: 'bytes length'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'BitArray2 class' category: 'Domains-Etc'!
BitArray2 class
	instanceVariableNames: ''!

!classDefinition: #StandardBasis category: 'Domains-Etc'!
SequenceableCollection subclass: #StandardBasis
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'StandardBasis class' category: 'Domains-Etc'!
StandardBasis class
	instanceVariableNames: ''!

!classDefinition: #GroebnerBasis category: 'Domains-Etc'!
StandardBasis subclass: #GroebnerBasis
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'GroebnerBasis class' category: 'Domains-Etc'!
GroebnerBasis class
	instanceVariableNames: ''!

!classDefinition: #YoungTableau category: 'Domains-Tableaux'!
Collection subclass: #YoungTableau
	instanceVariableNames: 'rows'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Tableaux'!
!classDefinition: 'YoungTableau class' category: 'Domains-Tableaux'!
YoungTableau class
	instanceVariableNames: ''!

!classDefinition: #Simplex category: 'Domains-Simplicial Complexes'!
Collection subclass: #Simplex
	instanceVariableNames: 'vertices'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Simplicial Complexes'!
!classDefinition: 'Simplex class' category: 'Domains-Simplicial Complexes'!
Simplex class
	instanceVariableNames: ''!

!classDefinition: #InversionError category: 'Domains-Kernel-Support'!
ArithmeticError subclass: #InversionError
	instanceVariableNames: 'element'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Kernel-Support'!
!classDefinition: 'InversionError class' category: 'Domains-Kernel-Support'!
InversionError class
	instanceVariableNames: ''!

!classDefinition: #Domain category: 'Domains-Kernel'!
Object subclass: #Domain
	instanceVariableNames: 'properties'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Kernel'!
!classDefinition: 'Domain class' category: 'Domains-Kernel'!
Domain class
	instanceVariableNames: ''!

!classDefinition: #Structure category: 'Domains-Kernel'!
Domain subclass: #Structure
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Kernel'!
!classDefinition: 'Structure class' category: 'Domains-Kernel'!
Structure class
	instanceVariableNames: ''!

!classDefinition: #CartesianProduct category: 'Domains-Kernel'!
Structure subclass: #CartesianProduct
	instanceVariableNames: 'components'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Kernel'!
!classDefinition: 'CartesianProduct class' category: 'Domains-Kernel'!
CartesianProduct class
	instanceVariableNames: ''!

!classDefinition: #Category category: 'Domains-Kernel'!
Structure subclass: #Category
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Kernel'!
!classDefinition: 'Category class' category: 'Domains-Kernel'!
Category class
	instanceVariableNames: ''!

!classDefinition: #Modules category: 'Domains-Modules'!
Category subclass: #Modules
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules'!
!classDefinition: 'Modules class' category: 'Domains-Modules'!
Modules class
	instanceVariableNames: ''!

!classDefinition: #ChainComplexes category: 'Domains-Complexes'!
Category subclass: #ChainComplexes
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Complexes'!
!classDefinition: 'ChainComplexes class' category: 'Domains-Complexes'!
ChainComplexes class
	instanceVariableNames: ''!

!classDefinition: #CochainComplexes category: 'Domains-Complexes'!
Category subclass: #CochainComplexes
	instanceVariableNames: 'opposite'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Complexes'!
!classDefinition: 'CochainComplexes class' category: 'Domains-Complexes'!
CochainComplexes class
	instanceVariableNames: ''!

!classDefinition: #HomSet category: 'Domains-Kernel'!
Structure subclass: #HomSet
	instanceVariableNames: 'domain codomain'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Kernel'!
!classDefinition: 'HomSet class' category: 'Domains-Kernel'!
HomSet class
	instanceVariableNames: ''!

!classDefinition: #RationalPointSet category: 'Domains-Varieties'!
HomSet subclass: #RationalPointSet
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Varieties'!
!classDefinition: 'RationalPointSet class' category: 'Domains-Varieties'!
RationalPointSet class
	instanceVariableNames: ''!

!classDefinition: #Naturals category: 'Domains-Kernel'!
Structure subclass: #Naturals
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Kernel'!
!classDefinition: 'Naturals class' category: 'Domains-Kernel'!
Naturals class
	instanceVariableNames: ''!

!classDefinition: #Monoid category: 'Domains-Monoids'!
Structure subclass: #Monoid
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Monoids'!
!classDefinition: 'Monoid class' category: 'Domains-Monoids'!
Monoid class
	instanceVariableNames: ''!

!classDefinition: #FreeAbelianMonoid category: 'Domains-Monoids'!
Monoid subclass: #FreeAbelianMonoid
	instanceVariableNames: 'rank ordering'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Monoids'!
!classDefinition: 'FreeAbelianMonoid class' category: 'Domains-Monoids'!
FreeAbelianMonoid class
	instanceVariableNames: ''!

!classDefinition: #FreeMonoid category: 'Domains-Monoids'!
Monoid subclass: #FreeMonoid
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Monoids'!
!classDefinition: 'FreeMonoid class' category: 'Domains-Monoids'!
FreeMonoid class
	instanceVariableNames: ''!

!classDefinition: #Group category: 'Domains-Groups'!
Structure subclass: #Group
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups'!
!classDefinition: 'Group class' category: 'Domains-Groups'!
Group class
	instanceVariableNames: ''!

!classDefinition: #DirectProductGroup category: 'Domains-Groups'!
Group subclass: #DirectProductGroup
	instanceVariableNames: 'components'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups'!
!classDefinition: 'DirectProductGroup class' category: 'Domains-Groups'!
DirectProductGroup class
	instanceVariableNames: ''!

!classDefinition: #FreeGroup category: 'Domains-Groups'!
Group subclass: #FreeGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups'!
!classDefinition: 'FreeGroup class' category: 'Domains-Groups'!
FreeGroup class
	instanceVariableNames: ''!

!classDefinition: #OppositeGroup category: 'Domains-Groups'!
Group subclass: #OppositeGroup
	instanceVariableNames: 'opposite'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups'!
!classDefinition: 'OppositeGroup class' category: 'Domains-Groups'!
OppositeGroup class
	instanceVariableNames: ''!

!classDefinition: #QuotientGroup category: 'Domains-Groups'!
Group subclass: #QuotientGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups'!
!classDefinition: 'QuotientGroup class' category: 'Domains-Groups'!
QuotientGroup class
	instanceVariableNames: ''!

!classDefinition: #FPGroup category: 'Domains-Groups'!
QuotientGroup subclass: #FPGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups'!
!classDefinition: 'FPGroup class' category: 'Domains-Groups'!
FPGroup class
	instanceVariableNames: ''!

!classDefinition: #PermutationGroup category: 'Domains-Groups-Permutations'!
Group subclass: #PermutationGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups-Permutations'!
!classDefinition: 'PermutationGroup class' category: 'Domains-Groups-Permutations'!
PermutationGroup class
	instanceVariableNames: ''!

!classDefinition: #AlternatingGroup category: 'Domains-Groups-Permutations'!
PermutationGroup subclass: #AlternatingGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups-Permutations'!
!classDefinition: 'AlternatingGroup class' category: 'Domains-Groups-Permutations'!
AlternatingGroup class
	instanceVariableNames: ''!

!classDefinition: #SymmetricGroup category: 'Domains-Groups-Permutations'!
PermutationGroup subclass: #SymmetricGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups-Permutations'!
!classDefinition: 'SymmetricGroup class' category: 'Domains-Groups-Permutations'!
SymmetricGroup class
	instanceVariableNames: ''!

!classDefinition: #LinearGroup category: 'Domains-Groups-Linear'!
Group subclass: #LinearGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups-Linear'!
!classDefinition: 'LinearGroup class' category: 'Domains-Groups-Linear'!
LinearGroup class
	instanceVariableNames: ''!

!classDefinition: #GeneralLinearGroup category: 'Domains-Groups-Linear'!
LinearGroup subclass: #GeneralLinearGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups-Linear'!
!classDefinition: 'GeneralLinearGroup class' category: 'Domains-Groups-Linear'!
GeneralLinearGroup class
	instanceVariableNames: ''!

!classDefinition: #OrthogonalGroup category: 'Domains-Groups-Linear'!
LinearGroup subclass: #OrthogonalGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups-Linear'!
!classDefinition: 'OrthogonalGroup class' category: 'Domains-Groups-Linear'!
OrthogonalGroup class
	instanceVariableNames: ''!

!classDefinition: #ScalarGroup category: 'Domains-Groups-Linear'!
LinearGroup subclass: #ScalarGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups-Linear'!
!classDefinition: 'ScalarGroup class' category: 'Domains-Groups-Linear'!
ScalarGroup class
	instanceVariableNames: ''!

!classDefinition: #SpecialLinearGroup category: 'Domains-Groups-Linear'!
LinearGroup subclass: #SpecialLinearGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups-Linear'!
!classDefinition: 'SpecialLinearGroup class' category: 'Domains-Groups-Linear'!
SpecialLinearGroup class
	instanceVariableNames: ''!

!classDefinition: #SpecialOrthogonalGroup category: 'Domains-Groups-Linear'!
LinearGroup subclass: #SpecialOrthogonalGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups-Linear'!
!classDefinition: 'SpecialOrthogonalGroup class' category: 'Domains-Groups-Linear'!
SpecialOrthogonalGroup class
	instanceVariableNames: ''!

!classDefinition: #SpecialScalarGroup category: 'Domains-Groups-Linear'!
LinearGroup subclass: #SpecialScalarGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups-Linear'!
!classDefinition: 'SpecialScalarGroup class' category: 'Domains-Groups-Linear'!
SpecialScalarGroup class
	instanceVariableNames: ''!

!classDefinition: #UnitGroup category: 'Domains-Rings'!
Group subclass: #UnitGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings'!
!classDefinition: 'UnitGroup class' category: 'Domains-Rings'!
UnitGroup class
	instanceVariableNames: ''!

!classDefinition: #ModularIntegerUnitGroup category: 'Domains-Rings-Finite'!
UnitGroup subclass: #ModularIntegerUnitGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings-Finite'!
!classDefinition: 'ModularIntegerUnitGroup class' category: 'Domains-Rings-Finite'!
ModularIntegerUnitGroup class
	instanceVariableNames: ''!

!classDefinition: #EllipticCurveGroup category: 'Domains-Elliptic Curves'!
Group subclass: #EllipticCurveGroup
	instanceVariableNames: 'curve scalars'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Elliptic Curves'!
!classDefinition: 'EllipticCurveGroup class' category: 'Domains-Elliptic Curves'!
EllipticCurveGroup class
	instanceVariableNames: ''!

!classDefinition: #SemidirectProductGroup category: 'Domains-Etc'!
Group subclass: #SemidirectProductGroup
	instanceVariableNames: 'left right action'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'SemidirectProductGroup class' category: 'Domains-Etc'!
SemidirectProductGroup class
	instanceVariableNames: ''!

!classDefinition: #CoxeterGroup category: 'Domains-Etc-Lie'!
Group subclass: #CoxeterGroup
	instanceVariableNames: 'diagram'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc-Lie'!
!classDefinition: 'CoxeterGroup class' category: 'Domains-Etc-Lie'!
CoxeterGroup class
	instanceVariableNames: ''!

!classDefinition: #DirichletGroup category: 'Domains-Etc-Modular Forms'!
Group subclass: #DirichletGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc-Modular Forms'!
!classDefinition: 'DirichletGroup class' category: 'Domains-Etc-Modular Forms'!
DirichletGroup class
	instanceVariableNames: ''!

!classDefinition: #MoebiusGroup category: 'Domains-Etc-Modular Forms'!
Group subclass: #MoebiusGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc-Modular Forms'!
!classDefinition: 'MoebiusGroup class' category: 'Domains-Etc-Modular Forms'!
MoebiusGroup class
	instanceVariableNames: ''!

!classDefinition: #ArithmeticGroup category: 'Domains-Etc-Modular Group'!
Group subclass: #ArithmeticGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc-Modular Group'!
!classDefinition: 'ArithmeticGroup class' category: 'Domains-Etc-Modular Group'!
ArithmeticGroup class
	instanceVariableNames: ''!

!classDefinition: #CongruenceSubgroup category: 'Domains-Etc-Modular Group'!
ArithmeticGroup subclass: #CongruenceSubgroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc-Modular Group'!
!classDefinition: 'CongruenceSubgroup class' category: 'Domains-Etc-Modular Group'!
CongruenceSubgroup class
	instanceVariableNames: ''!

!classDefinition: #Gamma0CongruenceSubgroup category: 'Domains-Etc-Modular Group'!
CongruenceSubgroup subclass: #Gamma0CongruenceSubgroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc-Modular Group'!
!classDefinition: 'Gamma0CongruenceSubgroup class' category: 'Domains-Etc-Modular Group'!
Gamma0CongruenceSubgroup class
	instanceVariableNames: ''!

!classDefinition: #Gamma1CongruenceSubgroup category: 'Domains-Etc-Modular Group'!
CongruenceSubgroup subclass: #Gamma1CongruenceSubgroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc-Modular Group'!
!classDefinition: 'Gamma1CongruenceSubgroup class' category: 'Domains-Etc-Modular Group'!
Gamma1CongruenceSubgroup class
	instanceVariableNames: ''!

!classDefinition: #PrincipalCongruenceSubgroup category: 'Domains-Etc-Modular Group'!
CongruenceSubgroup subclass: #PrincipalCongruenceSubgroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc-Modular Group'!
!classDefinition: 'PrincipalCongruenceSubgroup class' category: 'Domains-Etc-Modular Group'!
PrincipalCongruenceSubgroup class
	instanceVariableNames: ''!

!classDefinition: #ModularGroup category: 'Domains-Etc-Modular Group'!
PrincipalCongruenceSubgroup subclass: #ModularGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc-Modular Group'!
!classDefinition: 'ModularGroup class' category: 'Domains-Etc-Modular Group'!
ModularGroup class
	instanceVariableNames: ''!

!classDefinition: #Module category: 'Domains-Modules'!
Structure subclass: #Module
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules'!
!classDefinition: 'Module class' category: 'Domains-Modules'!
Module class
	instanceVariableNames: ''!

!classDefinition: #FreeModule category: 'Domains-Modules'!
Module subclass: #FreeModule
	instanceVariableNames: 'scalars rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules'!
!classDefinition: 'FreeModule class' category: 'Domains-Modules'!
FreeModule class
	instanceVariableNames: ''!

!classDefinition: #HomModule category: 'Domains-Modules'!
Module subclass: #HomModule
	instanceVariableNames: 'domain codomain'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules'!
!classDefinition: 'HomModule class' category: 'Domains-Modules'!
HomModule class
	instanceVariableNames: ''!

!classDefinition: #MatrixModule category: 'Domains-Modules'!
HomModule subclass: #MatrixModule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules'!
!classDefinition: 'MatrixModule class' category: 'Domains-Modules'!
MatrixModule class
	instanceVariableNames: ''!

!classDefinition: #QuotientModule category: 'Domains-Modules'!
Module subclass: #QuotientModule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules'!
!classDefinition: 'QuotientModule class' category: 'Domains-Modules'!
QuotientModule class
	instanceVariableNames: ''!

!classDefinition: #Ideal category: 'Domains-Rings'!
Module subclass: #Ideal
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings'!
!classDefinition: 'Ideal class' category: 'Domains-Rings'!
Ideal class
	instanceVariableNames: ''!

!classDefinition: #RationalIntegerIdeal category: 'Domains-Rings'!
Ideal subclass: #RationalIntegerIdeal
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings'!
!classDefinition: 'RationalIntegerIdeal class' category: 'Domains-Rings'!
RationalIntegerIdeal class
	instanceVariableNames: ''!

!classDefinition: #PolynomialIdeal category: 'Domains-Algebras-Affine'!
Ideal subclass: #PolynomialIdeal
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algebras-Affine'!
!classDefinition: 'PolynomialIdeal class' category: 'Domains-Algebras-Affine'!
PolynomialIdeal class
	instanceVariableNames: ''!

!classDefinition: #MonomialIdeal category: 'Domains-Algebras-Affine'!
PolynomialIdeal subclass: #MonomialIdeal
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algebras-Affine'!
!classDefinition: 'MonomialIdeal class' category: 'Domains-Algebras-Affine'!
MonomialIdeal class
	instanceVariableNames: ''!

!classDefinition: #DirectSumModule category: 'Domains-Etc'!
Module subclass: #DirectSumModule
	instanceVariableNames: 'components'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'DirectSumModule class' category: 'Domains-Etc'!
DirectSumModule class
	instanceVariableNames: ''!

!classDefinition: #TensorModule category: 'Domains-Etc'!
Module subclass: #TensorModule
	instanceVariableNames: 'components'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'TensorModule class' category: 'Domains-Etc'!
TensorModule class
	instanceVariableNames: ''!

!classDefinition: #Code category: 'Domains-Lattices'!
Structure subclass: #Code
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Lattices'!
!classDefinition: 'Code class' category: 'Domains-Lattices'!
Code class
	instanceVariableNames: ''!

!classDefinition: #PolynomialCode category: 'Domains-Etc'!
Code subclass: #PolynomialCode
	instanceVariableNames: 'generator'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'PolynomialCode class' category: 'Domains-Etc'!
PolynomialCode class
	instanceVariableNames: ''!

!classDefinition: #CyclicCode category: 'Domains-Etc'!
PolynomialCode subclass: #CyclicCode
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'CyclicCode class' category: 'Domains-Etc'!
CyclicCode class
	instanceVariableNames: ''!

!classDefinition: #Lattice category: 'Domains-Lattices'!
Structure subclass: #Lattice
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Lattices'!
!classDefinition: 'Lattice class' category: 'Domains-Lattices'!
Lattice class
	instanceVariableNames: ''!

!classDefinition: #Ring category: 'Domains-Rings'!
Structure subclass: #Ring
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings'!
!classDefinition: 'Ring class' category: 'Domains-Rings'!
Ring class
	instanceVariableNames: ''!

!classDefinition: #FractionRing category: 'Domains-Rings'!
Ring subclass: #FractionRing
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings'!
!classDefinition: 'FractionRing class' category: 'Domains-Rings'!
FractionRing class
	instanceVariableNames: ''!

!classDefinition: #RationalField category: 'Domains-Rings'!
FractionRing subclass: #RationalField
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings'!
!classDefinition: 'RationalField class' category: 'Domains-Rings'!
RationalField class
	instanceVariableNames: ''!

!classDefinition: #RationalFunctionField category: 'Domains-Algebras-Affine'!
FractionRing subclass: #RationalFunctionField
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algebras-Affine'!
!classDefinition: 'RationalFunctionField class' category: 'Domains-Algebras-Affine'!
RationalFunctionField class
	instanceVariableNames: ''!

!classDefinition: #AdicField category: 'Domains-Fields-Local'!
FractionRing subclass: #AdicField
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Fields-Local'!
!classDefinition: 'AdicField class' category: 'Domains-Fields-Local'!
AdicField class
	instanceVariableNames: ''!

!classDefinition: #LaurentSeriesRing category: 'Domains-Fields-Local'!
FractionRing subclass: #LaurentSeriesRing
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Fields-Local'!
!classDefinition: 'LaurentSeriesRing class' category: 'Domains-Fields-Local'!
LaurentSeriesRing class
	instanceVariableNames: ''!

!classDefinition: #LocalRing category: 'Domains-Rings'!
Ring subclass: #LocalRing
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings'!
!classDefinition: 'LocalRing class' category: 'Domains-Rings'!
LocalRing class
	instanceVariableNames: ''!

!classDefinition: #OppositeRing category: 'Domains-Rings'!
Ring subclass: #OppositeRing
	instanceVariableNames: 'opposite'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings'!
!classDefinition: 'OppositeRing class' category: 'Domains-Rings'!
OppositeRing class
	instanceVariableNames: ''!

!classDefinition: #ProductRing category: 'Domains-Rings'!
Ring subclass: #ProductRing
	instanceVariableNames: 'components'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings'!
!classDefinition: 'ProductRing class' category: 'Domains-Rings'!
ProductRing class
	instanceVariableNames: ''!

!classDefinition: #QuotientRing category: 'Domains-Rings'!
Ring subclass: #QuotientRing
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings'!
!classDefinition: 'QuotientRing class' category: 'Domains-Rings'!
QuotientRing class
	instanceVariableNames: ''!

!classDefinition: #ModularIntegerRing category: 'Domains-Rings-Finite'!
QuotientRing subclass: #ModularIntegerRing
	instanceVariableNames: 'modulus'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings-Finite'!
!classDefinition: 'ModularIntegerRing class' category: 'Domains-Rings-Finite'!
ModularIntegerRing class
	instanceVariableNames: ''!

!classDefinition: #PrimePowerRing category: 'Domains-Rings-Finite'!
ModularIntegerRing subclass: #PrimePowerRing
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings-Finite'!
!classDefinition: 'PrimePowerRing class' category: 'Domains-Rings-Finite'!
PrimePowerRing class
	instanceVariableNames: ''!

!classDefinition: #PrimeField category: 'Domains-Rings-Finite'!
PrimePowerRing subclass: #PrimeField
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings-Finite'!
!classDefinition: 'PrimeField class' category: 'Domains-Rings-Finite'!
PrimeField class
	instanceVariableNames: ''!

!classDefinition: #SmallPrimeField category: 'Domains-Etc'!
PrimeField subclass: #SmallPrimeField
	instanceVariableNames: 'expTable logTable'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'SmallPrimeField class' category: 'Domains-Etc'!
SmallPrimeField class
	instanceVariableNames: ''!

!classDefinition: #AffineAlgebra category: 'Domains-Algebras-Affine'!
QuotientRing subclass: #AffineAlgebra
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algebras-Affine'!
!classDefinition: 'AffineAlgebra class' category: 'Domains-Algebras-Affine'!
AffineAlgebra class
	instanceVariableNames: ''!

!classDefinition: #GaloisRing category: 'Domains-Rings-Finite'!
AffineAlgebra subclass: #GaloisRing
	instanceVariableNames: ''
	classVariableNames: 'IrreduciblePolynomialsCache'
	poolDictionaries: ''
	category: 'Domains-Rings-Finite'!
!classDefinition: 'GaloisRing class' category: 'Domains-Rings-Finite'!
GaloisRing class
	instanceVariableNames: ''!

!classDefinition: #GaloisField category: 'Domains-Rings-Finite'!
GaloisRing subclass: #GaloisField
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings-Finite'!
!classDefinition: 'GaloisField class' category: 'Domains-Rings-Finite'!
GaloisField class
	instanceVariableNames: ''!

!classDefinition: #QuasiGaloisRing category: 'Domains-Rings-Finite'!
AffineAlgebra subclass: #QuasiGaloisRing
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings-Finite'!
!classDefinition: 'QuasiGaloisRing class' category: 'Domains-Rings-Finite'!
QuasiGaloisRing class
	instanceVariableNames: ''!

!classDefinition: #LaurentPolynomialRing category: 'Domains-Algebras-Affine'!
AffineAlgebra subclass: #LaurentPolynomialRing
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algebras-Affine'!
!classDefinition: 'LaurentPolynomialRing class' category: 'Domains-Algebras-Affine'!
LaurentPolynomialRing class
	instanceVariableNames: ''!

!classDefinition: #FunctionField category: 'Domains-Fields-Global'!
AffineAlgebra subclass: #FunctionField
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Fields-Global'!
!classDefinition: 'FunctionField class' category: 'Domains-Fields-Global'!
FunctionField class
	instanceVariableNames: ''!

!classDefinition: #NumberField category: 'Domains-Fields-Global'!
AffineAlgebra subclass: #NumberField
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Fields-Global'!
!classDefinition: 'NumberField class' category: 'Domains-Fields-Global'!
NumberField class
	instanceVariableNames: ''!

!classDefinition: #CyclotomicField category: 'Domains-Fields-Global'!
NumberField subclass: #CyclotomicField
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Fields-Global'!
!classDefinition: 'CyclotomicField class' category: 'Domains-Fields-Global'!
CyclotomicField class
	instanceVariableNames: ''!

!classDefinition: #QuadraticField category: 'Domains-Fields-Global'!
NumberField subclass: #QuadraticField
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Fields-Global'!
!classDefinition: 'QuadraticField class' category: 'Domains-Fields-Global'!
QuadraticField class
	instanceVariableNames: ''!

!classDefinition: #GaussianField category: 'Domains-Fields-Global'!
QuadraticField subclass: #GaussianField
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Fields-Global'!
!classDefinition: 'GaussianField class' category: 'Domains-Fields-Global'!
GaussianField class
	instanceVariableNames: ''!

!classDefinition: #RationalIntegerRing category: 'Domains-Rings'!
Ring subclass: #RationalIntegerRing
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings'!
!classDefinition: 'RationalIntegerRing class' category: 'Domains-Rings'!
RationalIntegerRing class
	instanceVariableNames: ''!

!classDefinition: #PolynomialRing category: 'Domains-Algebras-Affine'!
Ring subclass: #PolynomialRing
	instanceVariableNames: 'monomials scalars'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algebras-Affine'!
!classDefinition: 'PolynomialRing class' category: 'Domains-Algebras-Affine'!
PolynomialRing class
	instanceVariableNames: ''!

!classDefinition: #Algebra category: 'Domains-Algebras-Associative'!
Ring subclass: #Algebra
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algebras-Associative'!
!classDefinition: 'Algebra class' category: 'Domains-Algebras-Associative'!
Algebra class
	instanceVariableNames: ''!

!classDefinition: #CliffordAlgebra category: 'Domains-Algebras-Associative'!
Algebra subclass: #CliffordAlgebra
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algebras-Associative'!
!classDefinition: 'CliffordAlgebra class' category: 'Domains-Algebras-Associative'!
CliffordAlgebra class
	instanceVariableNames: ''!

!classDefinition: #EndomorphismAlgebra category: 'Domains-Algebras-Associative'!
Algebra subclass: #EndomorphismAlgebra
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algebras-Associative'!
!classDefinition: 'EndomorphismAlgebra class' category: 'Domains-Algebras-Associative'!
EndomorphismAlgebra class
	instanceVariableNames: ''!

!classDefinition: #MatrixAlgebra category: 'Domains-Algebras-Associative'!
EndomorphismAlgebra subclass: #MatrixAlgebra
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algebras-Associative'!
!classDefinition: 'MatrixAlgebra class' category: 'Domains-Algebras-Associative'!
MatrixAlgebra class
	instanceVariableNames: ''!

!classDefinition: #GroupAlgebra category: 'Domains-Algebras-Associative'!
Algebra subclass: #GroupAlgebra
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algebras-Associative'!
!classDefinition: 'GroupAlgebra class' category: 'Domains-Algebras-Associative'!
GroupAlgebra class
	instanceVariableNames: ''!

!classDefinition: #QuaternionAlgebra category: 'Domains-Algebras-Associative'!
Algebra subclass: #QuaternionAlgebra
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algebras-Associative'!
!classDefinition: 'QuaternionAlgebra class' category: 'Domains-Algebras-Associative'!
QuaternionAlgebra class
	instanceVariableNames: ''!

!classDefinition: #Order category: 'Domains-Fields-Global'!
Algebra subclass: #Order
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Fields-Global'!
!classDefinition: 'Order class' category: 'Domains-Fields-Global'!
Order class
	instanceVariableNames: ''!

!classDefinition: #MaximalOrder category: 'Domains-Fields-Global'!
Order subclass: #MaximalOrder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Fields-Global'!
!classDefinition: 'MaximalOrder class' category: 'Domains-Fields-Global'!
MaximalOrder class
	instanceVariableNames: ''!

!classDefinition: #CyclotomicRing category: 'Domains-Fields-Global'!
MaximalOrder subclass: #CyclotomicRing
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Fields-Global'!
!classDefinition: 'CyclotomicRing class' category: 'Domains-Fields-Global'!
CyclotomicRing class
	instanceVariableNames: ''!

!classDefinition: #QuadraticRing category: 'Domains-Fields-Global'!
MaximalOrder subclass: #QuadraticRing
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Fields-Global'!
!classDefinition: 'QuadraticRing class' category: 'Domains-Fields-Global'!
QuadraticRing class
	instanceVariableNames: ''!

!classDefinition: #GaussianRing category: 'Domains-Fields-Global'!
QuadraticRing subclass: #GaussianRing
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Fields-Global'!
!classDefinition: 'GaussianRing class' category: 'Domains-Fields-Global'!
GaussianRing class
	instanceVariableNames: ''!

!classDefinition: #ComplexField category: 'Domains-Fields'!
Ring subclass: #ComplexField
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Fields'!
!classDefinition: 'ComplexField class' category: 'Domains-Fields'!
ComplexField class
	instanceVariableNames: ''!

!classDefinition: #RealField category: 'Domains-Fields'!
Ring subclass: #RealField
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Fields'!
!classDefinition: 'RealField class' category: 'Domains-Fields'!
RealField class
	instanceVariableNames: ''!

!classDefinition: #AdicRing category: 'Domains-Fields-Local'!
Ring subclass: #AdicRing
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Fields-Local'!
!classDefinition: 'AdicRing class' category: 'Domains-Fields-Local'!
AdicRing class
	instanceVariableNames: ''!

!classDefinition: #PowerSeriesRing category: 'Domains-Fields-Local'!
Ring subclass: #PowerSeriesRing
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Fields-Local'!
!classDefinition: 'PowerSeriesRing class' category: 'Domains-Fields-Local'!
PowerSeriesRing class
	instanceVariableNames: ''!

!classDefinition: #PuiseuxSeriesRing category: 'Domains-Fields-Local'!
Ring subclass: #PuiseuxSeriesRing
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Fields-Local'!
!classDefinition: 'PuiseuxSeriesRing class' category: 'Domains-Fields-Local'!
PuiseuxSeriesRing class
	instanceVariableNames: ''!

!classDefinition: #CompletionRing category: 'Domains-Etc'!
Ring subclass: #CompletionRing
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'CompletionRing class' category: 'Domains-Etc'!
CompletionRing class
	instanceVariableNames: ''!

!classDefinition: #FreeAlgebra category: 'Domains-Etc-Algebras'!
Ring subclass: #FreeAlgebra
	instanceVariableNames: 'scalars words'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc-Algebras'!
!classDefinition: 'FreeAlgebra class' category: 'Domains-Etc-Algebras'!
FreeAlgebra class
	instanceVariableNames: ''!

!classDefinition: #DistributiveAlgebra category: 'Domains-Algebras-Distributive'!
Structure subclass: #DistributiveAlgebra
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algebras-Distributive'!
!classDefinition: 'DistributiveAlgebra class' category: 'Domains-Algebras-Distributive'!
DistributiveAlgebra class
	instanceVariableNames: ''!

!classDefinition: #LieAlgebra category: 'Domains-Algebras-Distributive'!
DistributiveAlgebra subclass: #LieAlgebra
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algebras-Distributive'!
!classDefinition: 'LieAlgebra class' category: 'Domains-Algebras-Distributive'!
LieAlgebra class
	instanceVariableNames: ''!

!classDefinition: #OctonionAlgebra category: 'Domains-Algebras-Distributive'!
DistributiveAlgebra subclass: #OctonionAlgebra
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algebras-Distributive'!
!classDefinition: 'OctonionAlgebra class' category: 'Domains-Algebras-Distributive'!
OctonionAlgebra class
	instanceVariableNames: ''!

!classDefinition: #Scheme category: 'Domains-Schemes'!
Structure subclass: #Scheme
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Schemes'!
!classDefinition: 'Scheme class' category: 'Domains-Schemes'!
Scheme class
	instanceVariableNames: ''!

!classDefinition: #Grassmannian category: 'Domains-Modules-Support'!
Scheme subclass: #Grassmannian
	instanceVariableNames: 'space rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Support'!
!classDefinition: 'Grassmannian class' category: 'Domains-Modules-Support'!
Grassmannian class
	instanceVariableNames: ''!

!classDefinition: #AffineScheme category: 'Domains-Schemes'!
Scheme subclass: #AffineScheme
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Schemes'!
!classDefinition: 'AffineScheme class' category: 'Domains-Schemes'!
AffineScheme class
	instanceVariableNames: ''!

!classDefinition: #AffineVariety category: 'Domains-Varieties'!
AffineScheme subclass: #AffineVariety
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Varieties'!
!classDefinition: 'AffineVariety class' category: 'Domains-Varieties'!
AffineVariety class
	instanceVariableNames: ''!

!classDefinition: #AffineCurve category: 'Domains-Varieties'!
AffineVariety subclass: #AffineCurve
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Varieties'!
!classDefinition: 'AffineCurve class' category: 'Domains-Varieties'!
AffineCurve class
	instanceVariableNames: ''!

!classDefinition: #AffineHypersurface category: 'Domains-Varieties'!
AffineVariety subclass: #AffineHypersurface
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Varieties'!
!classDefinition: 'AffineHypersurface class' category: 'Domains-Varieties'!
AffineHypersurface class
	instanceVariableNames: ''!

!classDefinition: #AffinePlaneCurve category: 'Domains-Varieties'!
AffineHypersurface subclass: #AffinePlaneCurve
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Varieties'!
!classDefinition: 'AffinePlaneCurve class' category: 'Domains-Varieties'!
AffinePlaneCurve class
	instanceVariableNames: ''!

!classDefinition: #AffineSpace category: 'Domains-Varieties'!
AffineVariety subclass: #AffineSpace
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Varieties'!
!classDefinition: 'AffineSpace class' category: 'Domains-Varieties'!
AffineSpace class
	instanceVariableNames: ''!

!classDefinition: #ProjectiveScheme category: 'Domains-Schemes'!
Scheme subclass: #ProjectiveScheme
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Schemes'!
!classDefinition: 'ProjectiveScheme class' category: 'Domains-Schemes'!
ProjectiveScheme class
	instanceVariableNames: ''!

!classDefinition: #ProjectiveVariety category: 'Domains-Varieties'!
ProjectiveScheme subclass: #ProjectiveVariety
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Varieties'!
!classDefinition: 'ProjectiveVariety class' category: 'Domains-Varieties'!
ProjectiveVariety class
	instanceVariableNames: ''!

!classDefinition: #ProjectiveCurve category: 'Domains-Varieties'!
ProjectiveVariety subclass: #ProjectiveCurve
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Varieties'!
!classDefinition: 'ProjectiveCurve class' category: 'Domains-Varieties'!
ProjectiveCurve class
	instanceVariableNames: ''!

!classDefinition: #ProjectiveHypersurface category: 'Domains-Varieties'!
ProjectiveVariety subclass: #ProjectiveHypersurface
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Varieties'!
!classDefinition: 'ProjectiveHypersurface class' category: 'Domains-Varieties'!
ProjectiveHypersurface class
	instanceVariableNames: ''!

!classDefinition: #ProjectivePlaneCurve category: 'Domains-Varieties'!
ProjectiveHypersurface subclass: #ProjectivePlaneCurve
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Varieties'!
!classDefinition: 'ProjectivePlaneCurve class' category: 'Domains-Varieties'!
ProjectivePlaneCurve class
	instanceVariableNames: ''!

!classDefinition: #Conic category: 'Domains-Varieties'!
ProjectivePlaneCurve subclass: #Conic
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Varieties'!
!classDefinition: 'Conic class' category: 'Domains-Varieties'!
Conic class
	instanceVariableNames: ''!

!classDefinition: #RationalCurve category: 'Domains-Varieties'!
ProjectivePlaneCurve subclass: #RationalCurve
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Varieties'!
!classDefinition: 'RationalCurve class' category: 'Domains-Varieties'!
RationalCurve class
	instanceVariableNames: ''!

!classDefinition: #EllipticCurve category: 'Domains-Elliptic Curves'!
ProjectivePlaneCurve subclass: #EllipticCurve
	instanceVariableNames: 'equation'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Elliptic Curves'!
!classDefinition: 'EllipticCurve class' category: 'Domains-Elliptic Curves'!
EllipticCurve class
	instanceVariableNames: ''!

!classDefinition: #ProjectiveSpace category: 'Domains-Varieties'!
ProjectiveVariety subclass: #ProjectiveSpace
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Varieties'!
!classDefinition: 'ProjectiveSpace class' category: 'Domains-Varieties'!
ProjectiveSpace class
	instanceVariableNames: ''!

!classDefinition: #ProjectiveLine category: 'Domains-Varieties'!
ProjectiveSpace subclass: #ProjectiveLine
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Varieties'!
!classDefinition: 'ProjectiveLine class' category: 'Domains-Varieties'!
ProjectiveLine class
	instanceVariableNames: ''!

!classDefinition: #ProjectivePlane category: 'Domains-Varieties'!
ProjectiveSpace subclass: #ProjectivePlane
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Varieties'!
!classDefinition: 'ProjectivePlane class' category: 'Domains-Varieties'!
ProjectivePlane class
	instanceVariableNames: ''!

!classDefinition: #SemistandardTableaux category: 'Domains-Tableaux'!
Structure subclass: #SemistandardTableaux
	instanceVariableNames: 'shape alphabet'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Tableaux'!
!classDefinition: 'SemistandardTableaux class' category: 'Domains-Tableaux'!
SemistandardTableaux class
	instanceVariableNames: ''!

!classDefinition: #StandardTableaux category: 'Domains-Tableaux'!
SemistandardTableaux subclass: #StandardTableaux
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Tableaux'!
!classDefinition: 'StandardTableaux class' category: 'Domains-Tableaux'!
StandardTableaux class
	instanceVariableNames: ''!

!classDefinition: #CellComplex category: 'Domains-Simplicial Complexes'!
Structure subclass: #CellComplex
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Simplicial Complexes'!
!classDefinition: 'CellComplex class' category: 'Domains-Simplicial Complexes'!
CellComplex class
	instanceVariableNames: ''!

!classDefinition: #SimplicialComplex category: 'Domains-Simplicial Complexes'!
CellComplex subclass: #SimplicialComplex
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Simplicial Complexes'!
!classDefinition: 'SimplicialComplex class' category: 'Domains-Simplicial Complexes'!
SimplicialComplex class
	instanceVariableNames: ''!

!classDefinition: #CoxeterSystem category: 'Domains-Etc-Lie'!
Structure subclass: #CoxeterSystem
	instanceVariableNames: 'group generators matrix diagram'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc-Lie'!
!classDefinition: 'CoxeterSystem class' category: 'Domains-Etc-Lie'!
CoxeterSystem class
	instanceVariableNames: ''!

!classDefinition: #UpperHalfPlane category: 'Domains-Etc-Modular Forms'!
Structure subclass: #UpperHalfPlane
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc-Modular Forms'!
!classDefinition: 'UpperHalfPlane class' category: 'Domains-Etc-Modular Forms'!
UpperHalfPlane class
	instanceVariableNames: ''!

!classDefinition: #ChainComplex category: 'Domains-Complexes'!
Domain subclass: #ChainComplex
	instanceVariableNames: 'differentials shift'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Complexes'!
!classDefinition: 'ChainComplex class' category: 'Domains-Complexes'!
ChainComplex class
	instanceVariableNames: ''!

!classDefinition: #Sheaf category: 'Domains-Schemes'!
Domain subclass: #Sheaf
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Schemes'!
!classDefinition: 'Sheaf class' category: 'Domains-Schemes'!
Sheaf class
	instanceVariableNames: ''!

!classDefinition: #HomSheaf category: 'Domains-Schemes'!
Sheaf subclass: #HomSheaf
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Schemes'!
!classDefinition: 'HomSheaf class' category: 'Domains-Schemes'!
HomSheaf class
	instanceVariableNames: ''!

!classDefinition: #Morphism category: 'Domains-Kernel'!
Object subclass: #Morphism
	instanceVariableNames: 'properties'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Kernel'!
!classDefinition: 'Morphism class' category: 'Domains-Kernel'!
Morphism class
	instanceVariableNames: ''!

!classDefinition: #Function category: 'Domains-Kernel'!
Morphism subclass: #Function
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Kernel'!
!classDefinition: 'Function class' category: 'Domains-Kernel'!
Function class
	instanceVariableNames: ''!

!classDefinition: #Functor category: 'Domains-Kernel'!
Function subclass: #Functor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Kernel'!
!classDefinition: 'Functor class' category: 'Domains-Kernel'!
Functor class
	instanceVariableNames: ''!

!classDefinition: #MonoidMap category: 'Domains-Monoids'!
Function subclass: #MonoidMap
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Monoids'!
!classDefinition: 'MonoidMap class' category: 'Domains-Monoids'!
MonoidMap class
	instanceVariableNames: ''!

!classDefinition: #GroupAction category: 'Domains-Groups'!
Function subclass: #GroupAction
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups'!
!classDefinition: 'GroupAction class' category: 'Domains-Groups'!
GroupAction class
	instanceVariableNames: ''!

!classDefinition: #GroupMap category: 'Domains-Groups'!
Function subclass: #GroupMap
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups'!
!classDefinition: 'GroupMap class' category: 'Domains-Groups'!
GroupMap class
	instanceVariableNames: ''!

!classDefinition: #ConjugationMap category: 'Domains-Groups'!
GroupMap subclass: #ConjugationMap
	instanceVariableNames: 'element elementInverse'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups'!
!classDefinition: 'ConjugationMap class' category: 'Domains-Groups'!
ConjugationMap class
	instanceVariableNames: ''!

!classDefinition: #DirichletCharacter category: 'Domains-Etc-Modular Forms'!
GroupMap subclass: #DirichletCharacter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc-Modular Forms'!
!classDefinition: 'DirichletCharacter class' category: 'Domains-Etc-Modular Forms'!
DirichletCharacter class
	instanceVariableNames: ''!

!classDefinition: #BilinearMap category: 'Domains-Modules'!
Function subclass: #BilinearMap
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules'!
!classDefinition: 'BilinearMap class' category: 'Domains-Modules'!
BilinearMap class
	instanceVariableNames: ''!

!classDefinition: #BilinearForm category: 'Domains-Modules'!
BilinearMap subclass: #BilinearForm
	instanceVariableNames: 'space matrix'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules'!
!classDefinition: 'BilinearForm class' category: 'Domains-Modules'!
BilinearForm class
	instanceVariableNames: ''!

!classDefinition: #ModuleMap category: 'Domains-Modules'!
Function subclass: #ModuleMap
	instanceVariableNames: 'domain codomain'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules'!
!classDefinition: 'ModuleMap class' category: 'Domains-Modules'!
ModuleMap class
	instanceVariableNames: ''!

!classDefinition: #Matrix category: 'Domains-Modules'!
ModuleMap subclass: #Matrix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules'!
!classDefinition: 'Matrix class' category: 'Domains-Modules'!
Matrix class
	instanceVariableNames: ''!

!classDefinition: #ColumnMatrix category: 'Domains-Modules-Support'!
Matrix subclass: #ColumnMatrix
	instanceVariableNames: 'columns'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Support'!
!classDefinition: 'ColumnMatrix class' category: 'Domains-Modules-Support'!
ColumnMatrix class
	instanceVariableNames: ''!

!classDefinition: #RowMatrix category: 'Domains-Modules-Support'!
Matrix subclass: #RowMatrix
	instanceVariableNames: 'rows'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Support'!
!classDefinition: 'RowMatrix class' category: 'Domains-Modules-Support'!
RowMatrix class
	instanceVariableNames: ''!

!classDefinition: #RowMajorMatrix category: 'Domains-Etc'!
Matrix subclass: #RowMajorMatrix
	instanceVariableNames: 'coefficients'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'RowMajorMatrix class' category: 'Domains-Etc'!
RowMajorMatrix class
	instanceVariableNames: ''!

!classDefinition: #LatticeMap category: 'Domains-Lattices'!
Function subclass: #LatticeMap
	instanceVariableNames: 'matrix'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Lattices'!
!classDefinition: 'LatticeMap class' category: 'Domains-Lattices'!
LatticeMap class
	instanceVariableNames: ''!

!classDefinition: #QuadraticForm category: 'Domains-Lattices'!
Function subclass: #QuadraticForm
	instanceVariableNames: 'coefficients'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Lattices'!
!classDefinition: 'QuadraticForm class' category: 'Domains-Lattices'!
QuadraticForm class
	instanceVariableNames: ''!

!classDefinition: #RingMap category: 'Domains-Rings'!
Function subclass: #RingMap
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings'!
!classDefinition: 'RingMap class' category: 'Domains-Rings'!
RingMap class
	instanceVariableNames: ''!

!classDefinition: #AffineAlgebraMap category: 'Domains-Algebras-Affine'!
RingMap subclass: #AffineAlgebraMap
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algebras-Affine'!
!classDefinition: 'AffineAlgebraMap class' category: 'Domains-Algebras-Affine'!
AffineAlgebraMap class
	instanceVariableNames: ''!

!classDefinition: #AlgebraMap category: 'Domains-Algebras-Associative'!
RingMap subclass: #AlgebraMap
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algebras-Associative'!
!classDefinition: 'AlgebraMap class' category: 'Domains-Algebras-Associative'!
AlgebraMap class
	instanceVariableNames: ''!

!classDefinition: #DistributiveAlgebraMap category: 'Domains-Algebras-Distributive'!
Function subclass: #DistributiveAlgebraMap
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algebras-Distributive'!
!classDefinition: 'DistributiveAlgebraMap class' category: 'Domains-Algebras-Distributive'!
DistributiveAlgebraMap class
	instanceVariableNames: ''!

!classDefinition: #RationalMap category: 'Domains-Varieties'!
Function subclass: #RationalMap
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Varieties'!
!classDefinition: 'RationalMap class' category: 'Domains-Varieties'!
RationalMap class
	instanceVariableNames: ''!

!classDefinition: #EllipticCurveIsogeny category: 'Domains-Elliptic Curves'!
RationalMap subclass: #EllipticCurveIsogeny
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Elliptic Curves'!
!classDefinition: 'EllipticCurveIsogeny class' category: 'Domains-Elliptic Curves'!
EllipticCurveIsogeny class
	instanceVariableNames: ''!

!classDefinition: #LinearFractionalMap category: 'Domains-Etc-Modular Forms'!
RationalMap subclass: #LinearFractionalMap
	instanceVariableNames: 'a b c d'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc-Modular Forms'!
!classDefinition: 'LinearFractionalMap class' category: 'Domains-Etc-Modular Forms'!
LinearFractionalMap class
	instanceVariableNames: ''!

!classDefinition: #ModularMap category: 'Domains-Etc-Modular Forms'!
LinearFractionalMap subclass: #ModularMap
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc-Modular Forms'!
!classDefinition: 'ModularMap class' category: 'Domains-Etc-Modular Forms'!
ModularMap class
	instanceVariableNames: ''!

!classDefinition: #Sequence category: 'Domains-Sequences'!
Function subclass: #Sequence
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Sequences'!
!classDefinition: 'Sequence class' category: 'Domains-Sequences'!
Sequence class
	instanceVariableNames: ''!

!classDefinition: #CFiniteSequence category: 'Domains-Sequences'!
Sequence subclass: #CFiniteSequence
	instanceVariableNames: 'coefficients initialValues'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Sequences'!
!classDefinition: 'CFiniteSequence class' category: 'Domains-Sequences'!
CFiniteSequence class
	instanceVariableNames: ''!

!classDefinition: #SimplicialMap category: 'Domains-Simplicial Complexes'!
Function subclass: #SimplicialMap
	instanceVariableNames: 'map'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Simplicial Complexes'!
!classDefinition: 'SimplicialMap class' category: 'Domains-Simplicial Complexes'!
SimplicialMap class
	instanceVariableNames: ''!

!classDefinition: #ModularForm category: 'Domains-Etc-Modular Forms'!
Function subclass: #ModularForm
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc-Modular Forms'!
!classDefinition: 'ModularForm class' category: 'Domains-Etc-Modular Forms'!
ModularForm class
	instanceVariableNames: ''!

!classDefinition: #EisensteinSeries category: 'Domains-Etc-Modular Forms'!
ModularForm subclass: #EisensteinSeries
	instanceVariableNames: 'weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc-Modular Forms'!
!classDefinition: 'EisensteinSeries class' category: 'Domains-Etc-Modular Forms'!
EisensteinSeries class
	instanceVariableNames: ''!

!classDefinition: #ChainMap category: 'Domains-Complexes'!
Morphism subclass: #ChainMap
	instanceVariableNames: 'components'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Complexes'!
!classDefinition: 'ChainMap class' category: 'Domains-Complexes'!
ChainMap class
	instanceVariableNames: ''!

!classDefinition: #CochainMap category: 'Domains-Complexes'!
Morphism subclass: #CochainMap
	instanceVariableNames: 'opposite'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Complexes'!
!classDefinition: 'CochainMap class' category: 'Domains-Complexes'!
CochainMap class
	instanceVariableNames: ''!

!classDefinition: #SchemeMorphism category: 'Domains-Schemes'!
Morphism subclass: #SchemeMorphism
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Schemes'!
!classDefinition: 'SchemeMorphism class' category: 'Domains-Schemes'!
SchemeMorphism class
	instanceVariableNames: ''!

!classDefinition: #AffineMorphism category: 'Domains-Schemes'!
SchemeMorphism subclass: #AffineMorphism
	instanceVariableNames: 'adjoint'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Schemes'!
!classDefinition: 'AffineMorphism class' category: 'Domains-Schemes'!
AffineMorphism class
	instanceVariableNames: ''!

!classDefinition: #ProjectiveMorphism category: 'Domains-Schemes'!
SchemeMorphism subclass: #ProjectiveMorphism
	instanceVariableNames: 'adjoint'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Schemes'!
!classDefinition: 'ProjectiveMorphism class' category: 'Domains-Schemes'!
ProjectiveMorphism class
	instanceVariableNames: ''!

!classDefinition: #RationalPoint category: 'Domains-Varieties'!
SchemeMorphism subclass: #RationalPoint
	instanceVariableNames: 'codomain coordinates'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Varieties'!
!classDefinition: 'RationalPoint class' category: 'Domains-Varieties'!
RationalPoint class
	instanceVariableNames: ''!

!classDefinition: #AffinePoint category: 'Domains-Varieties'!
RationalPoint subclass: #AffinePoint
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Varieties'!
!classDefinition: 'AffinePoint class' category: 'Domains-Varieties'!
AffinePoint class
	instanceVariableNames: ''!

!classDefinition: #ProjectivePoint category: 'Domains-Varieties'!
RationalPoint subclass: #ProjectivePoint
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Varieties'!
!classDefinition: 'ProjectivePoint class' category: 'Domains-Varieties'!
ProjectivePoint class
	instanceVariableNames: ''!

!classDefinition: #ProjectiveLinePoint category: 'Domains-Varieties'!
ProjectivePoint subclass: #ProjectiveLinePoint
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Varieties'!
!classDefinition: 'ProjectiveLinePoint class' category: 'Domains-Varieties'!
ProjectiveLinePoint class
	instanceVariableNames: ''!

!classDefinition: #EllipticCurvePoint category: 'Domains-Elliptic Curves'!
ProjectivePoint subclass: #EllipticCurvePoint
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Elliptic Curves'!
!classDefinition: 'EllipticCurvePoint class' category: 'Domains-Elliptic Curves'!
EllipticCurvePoint class
	instanceVariableNames: ''!

!classDefinition: #SheafMap category: 'Domains-Schemes'!
Morphism subclass: #SheafMap
	instanceVariableNames: 'domain codomain moduleMap'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Schemes'!
!classDefinition: 'SheafMap class' category: 'Domains-Schemes'!
SheafMap class
	instanceVariableNames: ''!

!classDefinition: #MonomialOrdering category: 'Domains-Monoids-Orderings'!
Object subclass: #MonomialOrdering
	instanceVariableNames: 'indeterminates'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Monoids-Orderings'!
!classDefinition: 'MonomialOrdering class' category: 'Domains-Monoids-Orderings'!
MonomialOrdering class
	instanceVariableNames: ''!

!classDefinition: #BlockMonomialOrdering category: 'Domains-Monoids-Orderings'!
MonomialOrdering subclass: #BlockMonomialOrdering
	instanceVariableNames: 'blocks'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Monoids-Orderings'!
!classDefinition: 'BlockMonomialOrdering class' category: 'Domains-Monoids-Orderings'!
BlockMonomialOrdering class
	instanceVariableNames: ''!

!classDefinition: #GradedLexicographicOrdering category: 'Domains-Monoids-Orderings'!
MonomialOrdering subclass: #GradedLexicographicOrdering
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Monoids-Orderings'!
!classDefinition: 'GradedLexicographicOrdering class' category: 'Domains-Monoids-Orderings'!
GradedLexicographicOrdering class
	instanceVariableNames: ''!

!classDefinition: #GradedReverseLexicographicOrdering category: 'Domains-Monoids-Orderings'!
MonomialOrdering subclass: #GradedReverseLexicographicOrdering
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Monoids-Orderings'!
!classDefinition: 'GradedReverseLexicographicOrdering class' category: 'Domains-Monoids-Orderings'!
GradedReverseLexicographicOrdering class
	instanceVariableNames: ''!

!classDefinition: #GradedReverseLexicographicWeightedOrdering category: 'Domains-Monoids-Orderings'!
GradedReverseLexicographicOrdering subclass: #GradedReverseLexicographicWeightedOrdering
	instanceVariableNames: 'weights'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Monoids-Orderings'!
!classDefinition: 'GradedReverseLexicographicWeightedOrdering class' category: 'Domains-Monoids-Orderings'!
GradedReverseLexicographicWeightedOrdering class
	instanceVariableNames: ''!

!classDefinition: #LexicographicOrdering category: 'Domains-Monoids-Orderings'!
MonomialOrdering subclass: #LexicographicOrdering
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Monoids-Orderings'!
!classDefinition: 'LexicographicOrdering class' category: 'Domains-Monoids-Orderings'!
LexicographicOrdering class
	instanceVariableNames: ''!

!classDefinition: #LocalGradedLexicographicOrdering category: 'Domains-Monoids-Orderings'!
MonomialOrdering subclass: #LocalGradedLexicographicOrdering
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Monoids-Orderings'!
!classDefinition: 'LocalGradedLexicographicOrdering class' category: 'Domains-Monoids-Orderings'!
LocalGradedLexicographicOrdering class
	instanceVariableNames: ''!

!classDefinition: #LocalGradedReverseLexicographicOrdering category: 'Domains-Monoids-Orderings'!
MonomialOrdering subclass: #LocalGradedReverseLexicographicOrdering
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Monoids-Orderings'!
!classDefinition: 'LocalGradedReverseLexicographicOrdering class' category: 'Domains-Monoids-Orderings'!
LocalGradedReverseLexicographicOrdering class
	instanceVariableNames: ''!

!classDefinition: #LocalLexicographicOrdering category: 'Domains-Monoids-Orderings'!
MonomialOrdering subclass: #LocalLexicographicOrdering
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Monoids-Orderings'!
!classDefinition: 'LocalLexicographicOrdering class' category: 'Domains-Monoids-Orderings'!
LocalLexicographicOrdering class
	instanceVariableNames: ''!

!classDefinition: #WeightedMonomialOrdering category: 'Domains-Monoids-Orderings'!
MonomialOrdering subclass: #WeightedMonomialOrdering
	instanceVariableNames: 'weights'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Monoids-Orderings'!
!classDefinition: 'WeightedMonomialOrdering class' category: 'Domains-Monoids-Orderings'!
WeightedMonomialOrdering class
	instanceVariableNames: ''!

!classDefinition: #GroupElement category: 'Domains-Groups'!
Object subclass: #GroupElement
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups'!
!classDefinition: 'GroupElement class' category: 'Domains-Groups'!
GroupElement class
	instanceVariableNames: ''!

!classDefinition: #Monomial category: 'Domains-Monoids'!
GroupElement subclass: #Monomial
	instanceVariableNames: 'exponents parent degree'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Monoids'!
!classDefinition: 'Monomial class' category: 'Domains-Monoids'!
Monomial class
	instanceVariableNames: ''!

!classDefinition: #Word category: 'Domains-Monoids'!
GroupElement subclass: #Word
	instanceVariableNames: 'syllables parent'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Monoids'!
!classDefinition: 'Word class' category: 'Domains-Monoids'!
Word class
	instanceVariableNames: ''!

!classDefinition: #Coset category: 'Domains-Groups'!
GroupElement subclass: #Coset
	instanceVariableNames: 'representative relations'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups'!
!classDefinition: 'Coset class' category: 'Domains-Groups'!
Coset class
	instanceVariableNames: ''!

!classDefinition: #DirectProductGroupElement category: 'Domains-Groups'!
GroupElement subclass: #DirectProductGroupElement
	instanceVariableNames: 'parent components'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups'!
!classDefinition: 'DirectProductGroupElement class' category: 'Domains-Groups'!
DirectProductGroupElement class
	instanceVariableNames: ''!

!classDefinition: #OppositeGroupElement category: 'Domains-Groups'!
GroupElement subclass: #OppositeGroupElement
	instanceVariableNames: 'opposite'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups'!
!classDefinition: 'OppositeGroupElement class' category: 'Domains-Groups'!
OppositeGroupElement class
	instanceVariableNames: ''!

!classDefinition: #Permutation category: 'Domains-Groups-Permutations'!
GroupElement subclass: #Permutation
	instanceVariableNames: 'images parent'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups-Permutations'!
!classDefinition: 'Permutation class' category: 'Domains-Groups-Permutations'!
Permutation class
	instanceVariableNames: ''!

!classDefinition: #FractionalIdeal category: 'Domains-Fields-Global'!
GroupElement subclass: #FractionalIdeal
	instanceVariableNames: 'numerator denominator'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Fields-Global'!
!classDefinition: 'FractionalIdeal class' category: 'Domains-Fields-Global'!
FractionalIdeal class
	instanceVariableNames: ''!

!classDefinition: #SemidirectProductElement category: 'Domains-Etc'!
GroupElement subclass: #SemidirectProductElement
	instanceVariableNames: 'parent left right'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'SemidirectProductElement class' category: 'Domains-Etc'!
SemidirectProductElement class
	instanceVariableNames: ''!

!classDefinition: #ProductReplacementRandomGenerator category: 'Domains-Groups-Algorithms'!
Object subclass: #ProductReplacementRandomGenerator
	instanceVariableNames: 'generators state'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups-Algorithms'!
!classDefinition: 'ProductReplacementRandomGenerator class' category: 'Domains-Groups-Algorithms'!
ProductReplacementRandomGenerator class
	instanceVariableNames: ''!

!classDefinition: #SchreierSims category: 'Domains-Groups-Algorithms'!
Object subclass: #SchreierSims
	instanceVariableNames: 'action generators base strongGeneratingSet trees order'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups-Algorithms'!
!classDefinition: 'SchreierSims class' category: 'Domains-Groups-Algorithms'!
SchreierSims class
	instanceVariableNames: ''!

!classDefinition: #SchreierTree category: 'Domains-Groups-Algorithms'!
Object subclass: #SchreierTree
	instanceVariableNames: 'root generators action v inverses w orbit'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups-Algorithms'!
!classDefinition: 'SchreierTree class' category: 'Domains-Groups-Algorithms'!
SchreierTree class
	instanceVariableNames: ''!

!classDefinition: #ToddCoxeter category: 'Domains-Groups-Algorithms'!
Object subclass: #ToddCoxeter
	instanceVariableNames: 'group subgroup representatives generators'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups-Algorithms'!
!classDefinition: 'ToddCoxeter class' category: 'Domains-Groups-Algorithms'!
ToddCoxeter class
	instanceVariableNames: ''!

!classDefinition: #ModuleElement category: 'Domains-Modules'!
Object subclass: #ModuleElement
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules'!
!classDefinition: 'ModuleElement class' category: 'Domains-Modules'!
ModuleElement class
	instanceVariableNames: ''!

!classDefinition: #ModuleCoset category: 'Domains-Modules'!
ModuleElement subclass: #ModuleCoset
	instanceVariableNames: 'representative parent'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules'!
!classDefinition: 'ModuleCoset class' category: 'Domains-Modules'!
ModuleCoset class
	instanceVariableNames: ''!

!classDefinition: #Tuple category: 'Domains-Modules'!
ModuleElement subclass: #Tuple
	instanceVariableNames: 'parent'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules'!
!classDefinition: 'Tuple class' category: 'Domains-Modules'!
Tuple class
	instanceVariableNames: ''!

!classDefinition: #DenseTuple category: 'Domains-Modules-Support'!
Tuple subclass: #DenseTuple
	instanceVariableNames: 'components'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Support'!
!classDefinition: 'DenseTuple class' category: 'Domains-Modules-Support'!
DenseTuple class
	instanceVariableNames: ''!

!classDefinition: #MultivariateTuple category: 'Domains-Modules-Support'!
DenseTuple subclass: #MultivariateTuple
	instanceVariableNames: 'leadingMonomial'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Support'!
!classDefinition: 'MultivariateTuple class' category: 'Domains-Modules-Support'!
MultivariateTuple class
	instanceVariableNames: ''!

!classDefinition: #SparseTuple category: 'Domains-Modules-Support'!
Tuple subclass: #SparseTuple
	instanceVariableNames: 'components'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Support'!
!classDefinition: 'SparseTuple class' category: 'Domains-Modules-Support'!
SparseTuple class
	instanceVariableNames: ''!

!classDefinition: #BitTuple category: 'Domains-Rings-Finite'!
Tuple subclass: #BitTuple
	instanceVariableNames: 'bits'
	classVariableNames: 'One Zero'
	poolDictionaries: ''
	category: 'Domains-Rings-Finite'!
!classDefinition: 'BitTuple class' category: 'Domains-Rings-Finite'!
BitTuple class
	instanceVariableNames: ''!

!classDefinition: #ModularTuple category: 'Domains-Rings-Finite'!
Tuple subclass: #ModularTuple
	instanceVariableNames: 'representatives'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings-Finite'!
!classDefinition: 'ModularTuple class' category: 'Domains-Rings-Finite'!
ModularTuple class
	instanceVariableNames: ''!

!classDefinition: #ByteModularTuple category: 'Domains-Rings-Finite'!
ModularTuple subclass: #ByteModularTuple
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings-Finite'!
!classDefinition: 'ByteModularTuple class' category: 'Domains-Rings-Finite'!
ByteModularTuple class
	instanceVariableNames: ''!

!classDefinition: #WordModularTuple category: 'Domains-Rings-Finite'!
ModularTuple subclass: #WordModularTuple
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings-Finite'!
!classDefinition: 'WordModularTuple class' category: 'Domains-Rings-Finite'!
WordModularTuple class
	instanceVariableNames: ''!

!classDefinition: #ModuleTuple category: 'Domains-Etc'!
ModuleElement subclass: #ModuleTuple
	instanceVariableNames: 'parent components'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'ModuleTuple class' category: 'Domains-Etc'!
ModuleTuple class
	instanceVariableNames: ''!

!classDefinition: #Sum category: 'Domains-Etc'!
ModuleElement subclass: #Sum
	instanceVariableNames: 'coefficients parent'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'Sum class' category: 'Domains-Etc'!
Sum class
	instanceVariableNames: ''!

!classDefinition: #Divisor category: 'Domains-Etc'!
Sum subclass: #Divisor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'Divisor class' category: 'Domains-Etc'!
Divisor class
	instanceVariableNames: ''!

!classDefinition: #Tensor2 category: 'Domains-Etc'!
Sum subclass: #Tensor2
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'Tensor2 class' category: 'Domains-Etc'!
Tensor2 class
	instanceVariableNames: ''!

!classDefinition: #Tensor category: 'Domains-Etc'!
ModuleElement subclass: #Tensor
	instanceVariableNames: 'map table'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'Tensor class' category: 'Domains-Etc'!
Tensor class
	instanceVariableNames: ''!

!classDefinition: #TupleMonomial category: 'Domains-Modules-Support'!
Object subclass: #TupleMonomial
	instanceVariableNames: 'ordering monomial position'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Support'!
!classDefinition: 'TupleMonomial class' category: 'Domains-Modules-Support'!
TupleMonomial class
	instanceVariableNames: ''!

!classDefinition: #TupleMonomialOrdering category: 'Domains-Modules-Support'!
Object subclass: #TupleMonomialOrdering
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Support'!
!classDefinition: 'TupleMonomialOrdering class' category: 'Domains-Modules-Support'!
TupleMonomialOrdering class
	instanceVariableNames: ''!

!classDefinition: #POTOrdering category: 'Domains-Modules-Support'!
TupleMonomialOrdering subclass: #POTOrdering
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Support'!
!classDefinition: 'POTOrdering class' category: 'Domains-Modules-Support'!
POTOrdering class
	instanceVariableNames: ''!

!classDefinition: #SchreyerOrdering category: 'Domains-Modules-Support'!
TupleMonomialOrdering subclass: #SchreyerOrdering
	instanceVariableNames: 'weights'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Support'!
!classDefinition: 'SchreyerOrdering class' category: 'Domains-Modules-Support'!
SchreyerOrdering class
	instanceVariableNames: ''!

!classDefinition: #TOPOrdering category: 'Domains-Modules-Support'!
TupleMonomialOrdering subclass: #TOPOrdering
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Support'!
!classDefinition: 'TOPOrdering class' category: 'Domains-Modules-Support'!
TOPOrdering class
	instanceVariableNames: ''!

!classDefinition: #HermiteColumnReduction category: 'Domains-Modules-Algorithms'!
Object subclass: #HermiteColumnReduction
	instanceVariableNames: 'matrix'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Algorithms'!
!classDefinition: 'HermiteColumnReduction class' category: 'Domains-Modules-Algorithms'!
HermiteColumnReduction class
	instanceVariableNames: ''!

!classDefinition: #MatrixReduction category: 'Domains-Modules-Algorithms'!
Object subclass: #MatrixReduction
	instanceVariableNames: 'matrix extension determinantFactor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Algorithms'!
!classDefinition: 'MatrixReduction class' category: 'Domains-Modules-Algorithms'!
MatrixReduction class
	instanceVariableNames: ''!

!classDefinition: #GaussianElimination category: 'Domains-Modules-Algorithms'!
MatrixReduction subclass: #GaussianElimination
	instanceVariableNames: 'pivots currentPivot'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Algorithms'!
!classDefinition: 'GaussianElimination class' category: 'Domains-Modules-Algorithms'!
GaussianElimination class
	instanceVariableNames: ''!

!classDefinition: #EuclideanGaussianElimination category: 'Domains-Modules-Algorithms'!
GaussianElimination subclass: #EuclideanGaussianElimination
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Algorithms'!
!classDefinition: 'EuclideanGaussianElimination class' category: 'Domains-Modules-Algorithms'!
EuclideanGaussianElimination class
	instanceVariableNames: ''!

!classDefinition: #GaussBareiss category: 'Domains-Modules-Algorithms'!
GaussianElimination subclass: #GaussBareiss
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Algorithms'!
!classDefinition: 'GaussBareiss class' category: 'Domains-Modules-Algorithms'!
GaussBareiss class
	instanceVariableNames: ''!

!classDefinition: #HermiteReduction category: 'Domains-Modules-Algorithms'!
MatrixReduction subclass: #HermiteReduction
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Algorithms'!
!classDefinition: 'HermiteReduction class' category: 'Domains-Modules-Algorithms'!
HermiteReduction class
	instanceVariableNames: ''!

!classDefinition: #HowellReduction category: 'Domains-Modules-Algorithms'!
MatrixReduction subclass: #HowellReduction
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Algorithms'!
!classDefinition: 'HowellReduction class' category: 'Domains-Modules-Algorithms'!
HowellReduction class
	instanceVariableNames: ''!

!classDefinition: #CochainComplex category: 'Domains-Complexes'!
Object subclass: #CochainComplex
	instanceVariableNames: 'opposite'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Complexes'!
!classDefinition: 'CochainComplex class' category: 'Domains-Complexes'!
CochainComplex class
	instanceVariableNames: ''!

!classDefinition: #LLL category: 'Domains-Lattices'!
Object subclass: #LLL
	instanceVariableNames: 'basis innerProduct delta orthogonalBasis mu orthogonalBasisNorms'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Lattices'!
!classDefinition: 'LLL class' category: 'Domains-Lattices'!
LLL class
	instanceVariableNames: ''!

!classDefinition: #LatticeElement category: 'Domains-Lattices'!
Object subclass: #LatticeElement
	instanceVariableNames: 'parent coordinates'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Lattices'!
!classDefinition: 'LatticeElement class' category: 'Domains-Lattices'!
LatticeElement class
	instanceVariableNames: ''!

!classDefinition: #Division category: 'Domains-Rings'!
Object subclass: #Division
	instanceVariableNames: 'divisor dividend quotient remainder'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings'!
!classDefinition: 'Division class' category: 'Domains-Rings'!
Division class
	instanceVariableNames: ''!

!classDefinition: #RingElement category: 'Domains-Rings'!
Object subclass: #RingElement
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings'!
!classDefinition: 'RingElement class' category: 'Domains-Rings'!
RingElement class
	instanceVariableNames: ''!

!classDefinition: #OppositeRingElement category: 'Domains-Rings'!
RingElement subclass: #OppositeRingElement
	instanceVariableNames: 'opposite'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings'!
!classDefinition: 'OppositeRingElement class' category: 'Domains-Rings'!
OppositeRingElement class
	instanceVariableNames: ''!

!classDefinition: #ProductRingElement category: 'Domains-Rings'!
RingElement subclass: #ProductRingElement
	instanceVariableNames: 'parent components'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings'!
!classDefinition: 'ProductRingElement class' category: 'Domains-Rings'!
ProductRingElement class
	instanceVariableNames: ''!

!classDefinition: #Ratio category: 'Domains-Rings'!
RingElement subclass: #Ratio
	instanceVariableNames: 'numerator denominator'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings'!
!classDefinition: 'Ratio class' category: 'Domains-Rings'!
Ratio class
	instanceVariableNames: ''!

!classDefinition: #Germ category: 'Domains-Rings'!
Ratio subclass: #Germ
	instanceVariableNames: 'parent'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings'!
!classDefinition: 'Germ class' category: 'Domains-Rings'!
Germ class
	instanceVariableNames: ''!

!classDefinition: #Rational category: 'Domains-Rings'!
Ratio subclass: #Rational
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings'!
!classDefinition: 'Rational class' category: 'Domains-Rings'!
Rational class
	instanceVariableNames: ''!

!classDefinition: #RationalFunction category: 'Domains-Algebras-Affine'!
Ratio subclass: #RationalFunction
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algebras-Affine'!
!classDefinition: 'RationalFunction class' category: 'Domains-Algebras-Affine'!
RationalFunction class
	instanceVariableNames: ''!

!classDefinition: #Residue category: 'Domains-Rings'!
RingElement subclass: #Residue
	instanceVariableNames: 'representative parent'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings'!
!classDefinition: 'Residue class' category: 'Domains-Rings'!
Residue class
	instanceVariableNames: ''!

!classDefinition: #ModularInteger category: 'Domains-Rings-Finite'!
Residue subclass: #ModularInteger
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings-Finite'!
!classDefinition: 'ModularInteger class' category: 'Domains-Rings-Finite'!
ModularInteger class
	instanceVariableNames: ''!

!classDefinition: #PrimePowerResidue category: 'Domains-Rings-Finite'!
ModularInteger subclass: #PrimePowerResidue
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings-Finite'!
!classDefinition: 'PrimePowerResidue class' category: 'Domains-Rings-Finite'!
PrimePowerResidue class
	instanceVariableNames: ''!

!classDefinition: #PrimeResidue category: 'Domains-Rings-Finite'!
PrimePowerResidue subclass: #PrimeResidue
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings-Finite'!
!classDefinition: 'PrimeResidue class' category: 'Domains-Rings-Finite'!
PrimeResidue class
	instanceVariableNames: ''!

!classDefinition: #SmallPrimeResidue category: 'Domains-Etc'!
PrimeResidue subclass: #SmallPrimeResidue
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'SmallPrimeResidue class' category: 'Domains-Etc'!
SmallPrimeResidue class
	instanceVariableNames: ''!

!classDefinition: #RegularFunction category: 'Domains-Algebras-Affine'!
Residue subclass: #RegularFunction
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algebras-Affine'!
!classDefinition: 'RegularFunction class' category: 'Domains-Algebras-Affine'!
RegularFunction class
	instanceVariableNames: ''!

!classDefinition: #GaloisResidue category: 'Domains-Rings-Finite'!
RegularFunction subclass: #GaloisResidue
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings-Finite'!
!classDefinition: 'GaloisResidue class' category: 'Domains-Rings-Finite'!
GaloisResidue class
	instanceVariableNames: ''!

!classDefinition: #LaurentPolynomial category: 'Domains-Algebras-Affine'!
RegularFunction subclass: #LaurentPolynomial
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algebras-Affine'!
!classDefinition: 'LaurentPolynomial class' category: 'Domains-Algebras-Affine'!
LaurentPolynomial class
	instanceVariableNames: ''!

!classDefinition: #GaussianRational category: 'Domains-Fields-Global'!
RegularFunction subclass: #GaussianRational
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Fields-Global'!
!classDefinition: 'GaussianRational class' category: 'Domains-Fields-Global'!
GaussianRational class
	instanceVariableNames: ''!

!classDefinition: #Polynomial category: 'Domains-Algebras-Affine'!
RingElement subclass: #Polynomial
	instanceVariableNames: 'parent'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algebras-Affine'!
!classDefinition: 'Polynomial class' category: 'Domains-Algebras-Affine'!
Polynomial class
	instanceVariableNames: ''!

!classDefinition: #MultivariatePolynomial category: 'Domains-Algebras-Affine'!
Polynomial subclass: #MultivariatePolynomial
	instanceVariableNames: 'parts'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algebras-Affine'!
!classDefinition: 'MultivariatePolynomial class' category: 'Domains-Algebras-Affine'!
MultivariatePolynomial class
	instanceVariableNames: ''!

!classDefinition: #UnivariatePolynomial category: 'Domains-Algebras-Affine'!
Polynomial subclass: #UnivariatePolynomial
	instanceVariableNames: 'coefficients'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algebras-Affine'!
!classDefinition: 'UnivariatePolynomial class' category: 'Domains-Algebras-Affine'!
UnivariatePolynomial class
	instanceVariableNames: ''!

!classDefinition: #AlgebraElement category: 'Domains-Algebras-Associative'!
RingElement subclass: #AlgebraElement
	instanceVariableNames: 'parent moduleElement representation'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algebras-Associative'!
!classDefinition: 'AlgebraElement class' category: 'Domains-Algebras-Associative'!
AlgebraElement class
	instanceVariableNames: ''!

!classDefinition: #GroupAlgebraElement category: 'Domains-Algebras-Associative'!
AlgebraElement subclass: #GroupAlgebraElement
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algebras-Associative'!
!classDefinition: 'GroupAlgebraElement class' category: 'Domains-Algebras-Associative'!
GroupAlgebraElement class
	instanceVariableNames: ''!

!classDefinition: #Multivector category: 'Domains-Algebras-Associative'!
AlgebraElement subclass: #Multivector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algebras-Associative'!
!classDefinition: 'Multivector class' category: 'Domains-Algebras-Associative'!
Multivector class
	instanceVariableNames: ''!

!classDefinition: #Quaternion category: 'Domains-Algebras-Associative'!
AlgebraElement subclass: #Quaternion
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algebras-Associative'!
!classDefinition: 'Quaternion class' category: 'Domains-Algebras-Associative'!
Quaternion class
	instanceVariableNames: ''!

!classDefinition: #AlgebraicInteger category: 'Domains-Fields-Global'!
AlgebraElement subclass: #AlgebraicInteger
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Fields-Global'!
!classDefinition: 'AlgebraicInteger class' category: 'Domains-Fields-Global'!
AlgebraicInteger class
	instanceVariableNames: ''!

!classDefinition: #QuadraticInteger category: 'Domains-Fields-Global'!
AlgebraicInteger subclass: #QuadraticInteger
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Fields-Global'!
!classDefinition: 'QuadraticInteger class' category: 'Domains-Fields-Global'!
QuadraticInteger class
	instanceVariableNames: ''!

!classDefinition: #GaussianInteger category: 'Domains-Fields-Global'!
QuadraticInteger subclass: #GaussianInteger
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Fields-Global'!
!classDefinition: 'GaussianInteger class' category: 'Domains-Fields-Global'!
GaussianInteger class
	instanceVariableNames: ''!

!classDefinition: #AdicInteger category: 'Domains-Fields-Local'!
RingElement subclass: #AdicInteger
	instanceVariableNames: 'parent representative precision'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Fields-Local'!
!classDefinition: 'AdicInteger class' category: 'Domains-Fields-Local'!
AdicInteger class
	instanceVariableNames: ''!

!classDefinition: #AdicNumber category: 'Domains-Fields-Local'!
RingElement subclass: #AdicNumber
	instanceVariableNames: 'valuation unitPart'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Fields-Local'!
!classDefinition: 'AdicNumber class' category: 'Domains-Fields-Local'!
AdicNumber class
	instanceVariableNames: ''!

!classDefinition: #LaurentSeries category: 'Domains-Fields-Local'!
RingElement subclass: #LaurentSeries
	instanceVariableNames: 'valuation unitPart'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Fields-Local'!
!classDefinition: 'LaurentSeries class' category: 'Domains-Fields-Local'!
LaurentSeries class
	instanceVariableNames: ''!

!classDefinition: #PowerSeries category: 'Domains-Fields-Local'!
RingElement subclass: #PowerSeries
	instanceVariableNames: 'parent representative precision'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Fields-Local'!
!classDefinition: 'PowerSeries class' category: 'Domains-Fields-Local'!
PowerSeries class
	instanceVariableNames: ''!

!classDefinition: #PuiseuxSeries category: 'Domains-Fields-Local'!
RingElement subclass: #PuiseuxSeries
	instanceVariableNames: 'denominator'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Fields-Local'!
!classDefinition: 'PuiseuxSeries class' category: 'Domains-Fields-Local'!
PuiseuxSeries class
	instanceVariableNames: ''!

!classDefinition: #RelaxedAdicInteger category: 'Domains-Etc'!
RingElement subclass: #RelaxedAdicInteger
	instanceVariableNames: 'parent digits'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'RelaxedAdicInteger class' category: 'Domains-Etc'!
RelaxedAdicInteger class
	instanceVariableNames: ''!

!classDefinition: #RelaxedAdicNumber category: 'Domains-Etc'!
RingElement subclass: #RelaxedAdicNumber
	instanceVariableNames: 'parent valuation unit precision'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'RelaxedAdicNumber class' category: 'Domains-Etc'!
RelaxedAdicNumber class
	instanceVariableNames: ''!

!classDefinition: #RelaxedPowerSeries category: 'Domains-Etc'!
RingElement subclass: #RelaxedPowerSeries
	instanceVariableNames: 'parent coefficients'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'RelaxedPowerSeries class' category: 'Domains-Etc'!
RelaxedPowerSeries class
	instanceVariableNames: ''!

!classDefinition: #FreePolynomial category: 'Domains-Etc-Algebras'!
RingElement subclass: #FreePolynomial
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc-Algebras'!
!classDefinition: 'FreePolynomial class' category: 'Domains-Etc-Algebras'!
FreePolynomial class
	instanceVariableNames: ''!

!classDefinition: #Buchberger category: 'Domains-Algebras-Affine-Algorithms'!
Object subclass: #Buchberger
	instanceVariableNames: 'matrix basis'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algebras-Affine-Algorithms'!
!classDefinition: 'Buchberger class' category: 'Domains-Algebras-Affine-Algorithms'!
Buchberger class
	instanceVariableNames: ''!

!classDefinition: #ExtendedBuchberger category: 'Domains-Algebras-Affine-Algorithms'!
Buchberger subclass: #ExtendedBuchberger
	instanceVariableNames: 'combinations'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algebras-Affine-Algorithms'!
!classDefinition: 'ExtendedBuchberger class' category: 'Domains-Algebras-Affine-Algorithms'!
ExtendedBuchberger class
	instanceVariableNames: ''!

!classDefinition: #ComplexBox category: 'Domains-Algebras-Affine-Algorithms'!
Object subclass: #ComplexBox
	instanceVariableNames: 'real imaginary'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algebras-Affine-Algorithms'!
!classDefinition: 'ComplexBox class' category: 'Domains-Algebras-Affine-Algorithms'!
ComplexBox class
	instanceVariableNames: ''!

!classDefinition: #ComplexDisk category: 'Domains-Algebras-Affine-Algorithms'!
Object subclass: #ComplexDisk
	instanceVariableNames: 'center radius'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algebras-Affine-Algorithms'!
!classDefinition: 'ComplexDisk class' category: 'Domains-Algebras-Affine-Algorithms'!
ComplexDisk class
	instanceVariableNames: ''!

!classDefinition: #ComplexRootIsolator category: 'Domains-Algebras-Affine-Algorithms'!
Object subclass: #ComplexRootIsolator
	instanceVariableNames: 'polynomial derivatives'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algebras-Affine-Algorithms'!
!classDefinition: 'ComplexRootIsolator class' category: 'Domains-Algebras-Affine-Algorithms'!
ComplexRootIsolator class
	instanceVariableNames: ''!

!classDefinition: #MultivariateDivision category: 'Domains-Algebras-Affine-Algorithms'!
Object subclass: #MultivariateDivision
	instanceVariableNames: 'dividend divisors quotients remainder'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algebras-Affine-Algorithms'!
!classDefinition: 'MultivariateDivision class' category: 'Domains-Algebras-Affine-Algorithms'!
MultivariateDivision class
	instanceVariableNames: ''!

!classDefinition: #NumericalComplexRootIsolator category: 'Domains-Algebras-Affine-Algorithms'!
Object subclass: #NumericalComplexRootIsolator
	instanceVariableNames: 'polynomial tolerance'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algebras-Affine-Algorithms'!
!classDefinition: 'NumericalComplexRootIsolator class' category: 'Domains-Algebras-Affine-Algorithms'!
NumericalComplexRootIsolator class
	instanceVariableNames: ''!

!classDefinition: #PseudoDivision category: 'Domains-Algebras-Affine-Algorithms'!
Object subclass: #PseudoDivision
	instanceVariableNames: 'dividend divisor quotient remainder'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algebras-Affine-Algorithms'!
!classDefinition: 'PseudoDivision class' category: 'Domains-Algebras-Affine-Algorithms'!
PseudoDivision class
	instanceVariableNames: ''!

!classDefinition: #RealBox category: 'Domains-Algebras-Affine-Algorithms'!
Object subclass: #RealBox
	instanceVariableNames: 'components'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algebras-Affine-Algorithms'!
!classDefinition: 'RealBox class' category: 'Domains-Algebras-Affine-Algorithms'!
RealBox class
	instanceVariableNames: ''!

!classDefinition: #RealInterval category: 'Domains-Algebras-Affine-Algorithms'!
Object subclass: #RealInterval
	instanceVariableNames: 'left right rightOpen leftOpen'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algebras-Affine-Algorithms'!
!classDefinition: 'RealInterval class' category: 'Domains-Algebras-Affine-Algorithms'!
RealInterval class
	instanceVariableNames: ''!

!classDefinition: #RealRootIsolator category: 'Domains-Algebras-Affine-Algorithms'!
Object subclass: #RealRootIsolator
	instanceVariableNames: 'polynomial sturm fourier roots'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algebras-Affine-Algorithms'!
!classDefinition: 'RealRootIsolator class' category: 'Domains-Algebras-Affine-Algorithms'!
RealRootIsolator class
	instanceVariableNames: ''!

!classDefinition: #DistributiveAlgebraElement category: 'Domains-Algebras-Distributive'!
Object subclass: #DistributiveAlgebraElement
	instanceVariableNames: 'parent moduleElement representation'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algebras-Distributive'!
!classDefinition: 'DistributiveAlgebraElement class' category: 'Domains-Algebras-Distributive'!
DistributiveAlgebraElement class
	instanceVariableNames: ''!

!classDefinition: #Octonion category: 'Domains-Algebras-Distributive'!
DistributiveAlgebraElement subclass: #Octonion
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algebras-Distributive'!
!classDefinition: 'Octonion class' category: 'Domains-Algebras-Distributive'!
Octonion class
	instanceVariableNames: ''!

!classDefinition: #ComplexAlgebraicNumber category: 'Domains-Fields'!
Object subclass: #ComplexAlgebraicNumber
	instanceVariableNames: 'minimalPolynomial approximation radius'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Fields'!
!classDefinition: 'ComplexAlgebraicNumber class' category: 'Domains-Fields'!
ComplexAlgebraicNumber class
	instanceVariableNames: ''!

!classDefinition: #SchemePoint category: 'Domains-Schemes'!
Object subclass: #SchemePoint
	instanceVariableNames: 'parent ideal'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Schemes'!
!classDefinition: 'SchemePoint class' category: 'Domains-Schemes'!
SchemePoint class
	instanceVariableNames: ''!

!classDefinition: #CRT category: 'Domains-Algorithms'!
Object subclass: #CRT
	instanceVariableNames: 'moduli C'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algorithms'!
!classDefinition: 'CRT class' category: 'Domains-Algorithms'!
CRT class
	instanceVariableNames: ''!

!classDefinition: #DFT category: 'Domains-Algorithms'!
Object subclass: #DFT
	instanceVariableNames: 'ring n alpha'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algorithms'!
!classDefinition: 'DFT class' category: 'Domains-Algorithms'!
DFT class
	instanceVariableNames: ''!

!classDefinition: #ExtendedEuclid category: 'Domains-Algorithms'!
Object subclass: #ExtendedEuclid
	instanceVariableNames: 'elements gcd bezout'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algorithms'!
!classDefinition: 'ExtendedEuclid class' category: 'Domains-Algorithms'!
ExtendedEuclid class
	instanceVariableNames: ''!

!classDefinition: #LagrangeGaussReduction category: 'Domains-Algorithms'!
Object subclass: #LagrangeGaussReduction
	instanceVariableNames: 'vectorSpace v1 v2 shortVector'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algorithms'!
!classDefinition: 'LagrangeGaussReduction class' category: 'Domains-Algorithms'!
LagrangeGaussReduction class
	instanceVariableNames: ''!

!classDefinition: #ModifiedBerlekampMassey category: 'Domains-Algorithms'!
Object subclass: #ModifiedBerlekampMassey
	instanceVariableNames: 'input field minimalPolynomial'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algorithms'!
!classDefinition: 'ModifiedBerlekampMassey class' category: 'Domains-Algorithms'!
ModifiedBerlekampMassey class
	instanceVariableNames: ''!

!classDefinition: #NTT category: 'Domains-Algorithms'!
Object subclass: #NTT
	instanceVariableNames: 'modulus primitive'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algorithms'!
!classDefinition: 'NTT class' category: 'Domains-Algorithms'!
NTT class
	instanceVariableNames: ''!

!classDefinition: #TonelliShanks category: 'Domains-Algorithms'!
Object subclass: #TonelliShanks
	instanceVariableNames: 'p q e z'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algorithms'!
!classDefinition: 'TonelliShanks class' category: 'Domains-Algorithms'!
TonelliShanks class
	instanceVariableNames: ''!

!classDefinition: #DirichletSeries category: 'Domains-Sequences'!
Object subclass: #DirichletSeries
	instanceVariableNames: 'coefficients'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Sequences'!
!classDefinition: 'DirichletSeries class' category: 'Domains-Sequences'!
DirichletSeries class
	instanceVariableNames: ''!

!classDefinition: #YoungDiagram category: 'Domains-Tableaux'!
Object subclass: #YoungDiagram
	instanceVariableNames: 'shape'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Tableaux'!
!classDefinition: 'YoungDiagram class' category: 'Domains-Tableaux'!
YoungDiagram class
	instanceVariableNames: ''!

!classDefinition: #WeierstrassEquation category: 'Domains-Elliptic Curves'!
Object subclass: #WeierstrassEquation
	instanceVariableNames: 'coefficients'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Elliptic Curves'!
!classDefinition: 'WeierstrassEquation class' category: 'Domains-Elliptic Curves'!
WeierstrassEquation class
	instanceVariableNames: ''!

!classDefinition: #BerlekampMassey category: 'Domains-Etc'!
Object subclass: #BerlekampMassey
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'BerlekampMassey class' category: 'Domains-Etc'!
BerlekampMassey class
	instanceVariableNames: ''!

!classDefinition: #ExtendedSmithReduction category: 'Domains-Etc'!
Object subclass: #ExtendedSmithReduction
	instanceVariableNames: 'matrix elementaryDivisors L S R'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'ExtendedSmithReduction class' category: 'Domains-Etc'!
ExtendedSmithReduction class
	instanceVariableNames: ''!

!classDefinition: #ModularHermiteReduction category: 'Domains-Etc'!
Object subclass: #ModularHermiteReduction
	instanceVariableNames: 'matrix HNF'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'ModularHermiteReduction class' category: 'Domains-Etc'!
ModularHermiteReduction class
	instanceVariableNames: ''!

!classDefinition: #MultivariateReducer category: 'Domains-Etc'!
Object subclass: #MultivariateReducer
	instanceVariableNames: 'divisors'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'MultivariateReducer class' category: 'Domains-Etc'!
MultivariateReducer class
	instanceVariableNames: ''!

!classDefinition: #GlobalMultivariateReducer category: 'Domains-Etc'!
MultivariateReducer subclass: #GlobalMultivariateReducer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'GlobalMultivariateReducer class' category: 'Domains-Etc'!
GlobalMultivariateReducer class
	instanceVariableNames: ''!

!classDefinition: #OEIS category: 'Domains-Etc'!
Object subclass: #OEIS
	instanceVariableNames: 'entries'
	classVariableNames: 'Default'
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'OEIS class' category: 'Domains-Etc'!
OEIS class
	instanceVariableNames: ''!

!classDefinition: #SmithReduction category: 'Domains-Etc'!
Object subclass: #SmithReduction
	instanceVariableNames: 'matrix invariants'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'SmithReduction class' category: 'Domains-Etc'!
SmithReduction class
	instanceVariableNames: ''!

!classDefinition: #SturmChain category: 'Domains-Etc'!
Object subclass: #SturmChain
	instanceVariableNames: 'chain'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'SturmChain class' category: 'Domains-Etc'!
SturmChain class
	instanceVariableNames: ''!

!classDefinition: #SubgroupSeries category: 'Domains-Etc'!
Object subclass: #SubgroupSeries
	instanceVariableNames: 'subgroups'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'SubgroupSeries class' category: 'Domains-Etc'!
SubgroupSeries class
	instanceVariableNames: ''!

!classDefinition: #CoxeterDiagram category: 'Domains-Etc-Lie'!
Object subclass: #CoxeterDiagram
	instanceVariableNames: 'matrix'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc-Lie'!
!classDefinition: 'CoxeterDiagram class' category: 'Domains-Etc-Lie'!
CoxeterDiagram class
	instanceVariableNames: ''!

!classDefinition: #RootSystem category: 'Domains-Etc-Lie'!
Object subclass: #RootSystem
	instanceVariableNames: 'roots ambient'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc-Lie'!
!classDefinition: 'RootSystem class' category: 'Domains-Etc-Lie'!
RootSystem class
	instanceVariableNames: ''!

!classDefinition: #RootSystemTest category: 'Domains-Etc-Lie'!
Object subclass: #RootSystemTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc-Lie'!
!classDefinition: 'RootSystemTest class' category: 'Domains-Etc-Lie'!
RootSystemTest class
	instanceVariableNames: ''!

!classDefinition: #ManinSymbol category: 'Domains-Etc-Modular Forms'!
Object subclass: #ManinSymbol
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc-Modular Forms'!
!classDefinition: 'ManinSymbol class' category: 'Domains-Etc-Modular Forms'!
ManinSymbol class
	instanceVariableNames: ''!

!classDefinition: #ModularSymbol category: 'Domains-Etc-Modular Forms'!
Object subclass: #ModularSymbol
	instanceVariableNames: 'alpha beta'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc-Modular Forms'!
!classDefinition: 'ModularSymbol class' category: 'Domains-Etc-Modular Forms'!
ModularSymbol class
	instanceVariableNames: ''!

!classDefinition: #FareySymbol category: 'Domains-Etc-Modular Group'!
Object subclass: #FareySymbol
	instanceVariableNames: 'group fractions pairings'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc-Modular Group'!
!classDefinition: 'FareySymbol class' category: 'Domains-Etc-Modular Group'!
FareySymbol class
	instanceVariableNames: ''!

!classDefinition: #ModularGroupTest category: 'Domains-Etc-Modular Group'!
Object subclass: #ModularGroupTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc-Modular Group'!
!classDefinition: 'ModularGroupTest class' category: 'Domains-Etc-Modular Group'!
ModularGroupTest class
	instanceVariableNames: ''!


!RealAlgebraicNumber commentStamp: '<historical>' prior: 0!
Real algebraic numbers, i.e. real zeros of polynomials with integer (or rational) coefficients, in 'minimal polynomial' representation. See also ComplexAlgebraicNumber.!

!ContinuedFraction commentStamp: '<historical>' prior: 0!
Finite or infinite continued fractions.

The finite case correspondes to rational numbers, for example:
  36/17 as: ContinuedFraction

But continued fractions can be infinite:
  ContinuedFraction e

Given a Float, and assuming the number is actually rational, its continued fraction expansion can be used to guess the rational number by truncating it when the convergents start to get too big (in bitsize terms), or when the coefficients of the continued fraction get too big:
  (2.117647 as: ContinuedFraction) convergents
!

!Cardinal commentStamp: '<historical>' prior: 0!
Aleph numbers, i.e. cardinalities of infinite sets. Aleph-naught is the cardinality of the natural numbers. Assuming the continuum hypothesis, aleph-one is taken to be the cardinality of the real numbers.!

!Infinity commentStamp: '<historical>' prior: 0!
The real +infinity or -infinity.

For some examples try these:
	Infinity positive * Infinity negative.
	Infinity positive * 2.
	Infinity positive - 7811234871239847.
	Infinity negative / -199.
	Infinity positive reciprocal.
	Infinity positive > Infinity negative.
	Infinity negative < -19238479182374598172349871234.
	Infinity negative > 0.
	Infinity negative min: Infinity positive.

The following are examples of undeterminations (they produce an error):
	Infinity positive + Infinity negative.
	Infinity positive * 0.
	Infinity positive / Infinity positive.
	Infinity positive raisedToInteger: 0.
!

!StandardBasis commentStamp: '<historical>' prior: 0!
Standard bases of polynomial ideals. A standard basis is nothing but a special set of generators with the property that the leading monomials generate the leading ideal.

When the choosen monomial ordering is global (a well-ordering), these are Groebner bases and are computed with Buchberger's algorithm. For arbitrary monomial orderings, they are computed using Mora's normal form.

See also Buchberger and ExtendedBuchberger.!

!GroebnerBasis commentStamp: '<historical>' prior: 0!
Groebner bases are a special case of standard bases.

For a fixed global monomial ordering, a subset G = {g1,...,gm} of an ideal I = <f1,...,fm> of a polynomial ring is called a Groebner basis for I if every polynomial f in I is reducible by G, i.e. there exists g in G such that its leading monomial LM(g) divides LM(f).

When all generators {f1,...,fm} are linear, a Groebner basis corresponds to "row echelon form" or "triangular system"; when they are univariate, then a Groebner basis corresponds to gcd(f1,...,fm). In general, a Groebner basis for an ideal I consists of all the "smallest polynomials" in I under the given monomial ordering.

See also Buchberger and ExtendedBuchberger.!

!Simplex commentStamp: '<historical>' prior: 0!
(Abstract) n-simplices.

It is assumed that the vertices are objects that implement a total ordering with #<= (such as integers, strings, monomials), so that they can be ordered to choose an unambiguos orientation.!

!Domain commentStamp: '<historical>' prior: 0!
Objects of a given Category, connected by the corresponding Morphisms. They don't necessarily have an underlying set of elements. Concrete examples are algebraic structures such as Groups, Rings and Modules.

Domains can be derived from other domains, for example by taking products, coproducts, quotients, extensions, localizations, completions, duals, etc.

Domains can have subobjects: groups have subgroups, vector spaces have subspaces, rings have subrings, schemes have subschemes, etc. Subobjects of an ambient domain can be implemented either concretely as subsets of the ambient domain (i.e., their elements are elements of the ambient domain), or more abstractly as isomorphism classes of injective monomorphisms from another domain of the same category into the ambient domain.

Given two domains A and B in the same category, the set Hom(A,B) of morphisms between them is obtained by sending the message 'A hom: B' (see HomSet). The #hom: message is the external Hom(A,-) functor. The internal hom(A,-) functor is implemented as 'A => B'. The identity morphism is returned by the message #id.

Domains can be equipped with canonical and universal morphisms. For example, field extensions and localizations come with embeddings, and quotient objects come with projections. Products have projection maps to their components, and coproducts have coprojection maps from their components.

More generally, canonical and universal morphisms are uniquely determined by their domain and codomain and can be retrieved by sending the message #->. For example, for any ring R, ' -> R' returns the canonical ring homomorphism that sends an integer 'n' to 'n times the unit element of R'. In order for this mechanism to work, subclasses must sometimes extend the messages #to: and #from: to answer canonical and universal morphisms, and #toAll: and #fromAll: to answer projections and coprojections.!

!Structure commentStamp: '<historical>' prior: 0!
Domains with an underlying set of elements (the 'carrier' set). These can be simple sets, or algebraic structures such as Groups, Rings, Modules, etc. In terms of category theory, these are objects of concrete categories, i.e. they are realized as sets of elements endowed with certain algebraic structure, and their morphisms are structure-preserving Maps.

The underlying set of a domain can have finite or infinite cardinality, and whenever it makes sense they implement some *Collection* protocol (such as #do:, #size, #asSet, #atRandom:, etc).

There's also a simple coercion mechanism that allows the conversion of elements from a domain to another via the message #!!. Known canonical morphisms are used for automatic coercion of elements between domains. For example, for any unital ring R there's a canonical ring homomorphism from the ring of rational integers  to R that sends an integer 'n' to 'n times the unit element of R', and this means that coercion of an integer 'n' to an element of R can be performed simply as 'R !! n'. Subclasses can also extend the coercion mechanism by implementing methods for #adapt: and #newFrom:.!

!CartesianProduct commentStamp: '<historical>' prior: 0!
Cartesian products of sets. The elements of the cartesian product of two or more sets are arrays of elements in the sets corresponding to each component of the cartesian product.!

!Category commentStamp: '<historical>' prior: 0!
Categories as defined in the the single-sorted version of category theory. Their elements are Morphisms of a given type, and their morphisms are Functors.

Categories are commonly defined as two sets: a set of objects (Domains) and a set of arrows (Morphisms). However, identifying objects with their identity morphism it is possible to define categories as a single set of morphisms. With this definition, functors are simply functions between two categories that preserve composition of morphisms.

References:
	https://ncatlab.org/nlab/show/single-sorted+definition+of+a+category
!

!HomSet commentStamp: '<historical>' prior: 0!
Hom-Set objects Hom(A,B) for domain A and codomain B, i.e. sets of all morphisms between two Domains. When A = B, this is the set of endomorphisms of A and it's noted End(A).

Given two domains A and B, the Hom-Set can be retrieved with 'A hom: B'. If there's an internal Hom-Set in the category of A and B, it can be retrieved with 'A => B'.!

!RationalPointSet commentStamp: '<historical>' prior: 0!
Sets of K-rational points on a variety X, seen as Hom(Spec(K), X). See also RationalPoint.!

!Naturals commentStamp: '<historical>' prior: 0!
The singleton global instance  is the set of natural numbers 1, 2, 3, ...!

!Monoid commentStamp: '<historical>' prior: 0!
Monoids consist of a set, an associative binary operation and an identity element. They are objects in the category of monoids, with MonoidMaps as their morphisms.
!

!FreeAbelianMonoid commentStamp: '<historical>' prior: 0!
Commutative monoids of monomials in n indeterminates. Elements are instances of Monomial.

The number of indeterminates is called the rank. The indeterminates are referred by index (positive integer numbers), and can be given names that are used when printing.

Monomials have an associated monomial ordering. See MonomialOrdering.

See FreeMonoid for the noncommutative analog.
!

!FreeMonoid commentStamp: '<historical>' prior: 0!
A free monoid is a monoid whose elements are words (see Word) on a finite alphabet or set of indeterminates, together with word concatenation as monoid operation, and empty word as identity element.

See FreeAbelianMonoid for the commutative analog.
!

!Group commentStamp: '<historical>' prior: 0!
Groups consist of a set with an associative binary operation, an inverse map (every element has an inverse), and an identity element. They are objects in the category of groups, with GroupMaps as their morphisms.

Some specific groups (such as permutation groups and matrix groups) can be represented in more efficient ways, and operate with more efficient algorithms. See subclasses.!

!DirectProductGroup commentStamp: '<historical>' prior: 0!
Direct products of groups. Elements are tuples (see DirectProductGroupElement), and the group composition law is defined component-wise.!

!OppositeGroup commentStamp: 'len 5/8/2019 14:55:05' prior: 0!
The opposite group G^op of a group G is a group constructed from the original group G inverting the order of the group operation. This way, it is possible to define a left action as a special case of a right action.

Abelian groups are equal to their opposites. Also, every group is naturally isomorphic to its opposite by the isomorphism that takes an element and sends it to its inverse.

See also OppositeGroupElement.!

!QuotientGroup commentStamp: '<historical>' prior: 0!
Quotient groups (or factor groups) G/N (read "G mod N"), i.e. the quotient of a group G by a normal subgroup N. The elements are the cosets of N (see Coset).!

!PermutationGroup commentStamp: '<historical>' prior: 0!
Permutation groups, i.e. subgroups of the symmetric group Sym(X) of permutations on the elements of a set X (see SymmetricGroup).

The set X is refered to as the 'space' of the group, elements of X are 'points', while the word 'element' is used for elements of the group itself (permutations). The group acts naturally on the space X by the action p^x := p(x).!

!AlternatingGroup commentStamp: 'len 5/22/2018 21:41:36' prior: 0!
The alternating group Alt(X) of even permutations on the elements of a set X (which we call 'space'). This is a subgroup of Sym(X) (see SymmetricGroup).!

!SymmetricGroup commentStamp: 'len 5/22/2018 21:46:32' prior: 0!
The symmetric group Sym(X) of permutations on the elements of a set X (which we call 'space'). This is the ambient of all PermutationGroups.!

!LinearGroup commentStamp: '<historical>' prior: 0!
Groups of automorphisms of a free R-module V over a commutative ring R. They are subgroups of the general linear group GL(V).!

!GeneralLinearGroup commentStamp: '<historical>' prior: 0!
The general linear group GL(V) of automorphisms of a free R-module V. These are the invertible endomorphisms of V, i.e. the endomorphisms whose determinats are units of R.!

!OrthogonalGroup commentStamp: 'len 7/28/2020 10:24:00' prior: 0!
O(Q), the Orthogonal Group of a quadratic space (V,Q) where Q is a nondegenerate quadratic form on V . This is the subgroup of the group of automorphisms GL(V) consisting of all automorphisms of V that preserve the the quadratic form Q.!

!ScalarGroup commentStamp: 'len 9/27/2018 21:49:50' prior: 0!
This is the group of scalar linear maps of a free R-module over a commutative ring R.!

!SpecialLinearGroup commentStamp: 'len 9/27/2018 21:48:40' prior: 0!
SL(V), the Special Linear Group of automorphisms with determinant 1.!

!UnitGroup commentStamp: '<historical>' prior: 0!
Given a ring R, the group of units of R is the set of elements of R that have multiplicative inverse, and they form a group under multiplication. For a field F (or more generally a division ring), the units are all the nonzero elements F \ {0}.

Categorically, this construction is a functor from the cateogory of rings to the category of groups. This functor has a left adjoint which is the integral group ring construction (see GroupAlgebra).!

!ModularIntegerUnitGroup commentStamp: '<historical>' prior: 0!
The group of units of Z/nZ, i.e. the multiplicaive group of units modulo n. This group is cyclic for n = 2, 4, p^k or 2p^k where p is an odd prime number. When the group is cyclic, its generator is called a 'primitive root modulo n'.!

!EllipticCurveGroup commentStamp: '<historical>' prior: 0!
Abelian groups E(K) consisting of the K-rational points of an elliptic curve E.!

!SemidirectProductGroup commentStamp: '<historical>' prior: 0!
Semidirect products of groups.!

!DirichletGroup commentStamp: '<historical>' prior: 0!
Groups of Dirichlet characters modulo n, whose elements are group homomorphisms from (Z/nZ)* to C* (see DirichletCharacter).!

!MoebiusGroup commentStamp: '<historical>' prior: 0!
My instances are groups of Moebius transformations acting on some space, like the Riemann sphere P^1(C) or the upper half plane H or the extended upper half plane H U P^1(Q).!

!ArithmeticGroup commentStamp: '<historical>' prior: 0!
Finite index subgroups of the modular group.!

!CongruenceSubgroup commentStamp: '<historical>' prior: 0!
Congruence subgroups of the modular group SL(2,Z), i.e. subgroups that contain the kernel of SL(2,Z) -> SL(2,Z/nZ) for some positive integer n (which is called the level of the congruence subgroup). See also ModularGroup.!

!Gamma0CongruenceSubgroup commentStamp: '<historical>' prior: 0!
Subgroups of SL(2,Z) associated with matrices of the form:
  [a b]   [* *]
  [c d] = [0 *] (mod n).!

!Gamma1CongruenceSubgroup commentStamp: '<historical>' prior: 0!
Subgroups of SL(2,Z) associated with matrices of the form:
  [a b]   [1 *]
  [c d] = [0 1] (mod n).!

!PrincipalCongruenceSubgroup commentStamp: '<historical>' prior: 0!
Principal congruence subgroups of SL(2,Z), i.e. subgroups of SL(2,Z) associated with matrices of the form:
  [a b]   [1 0]
  [c d] = [0 1] (mod n).

They are the kernel of the quotient projection SL(2,Z) -> SL(2,Z/nZ) for some positive integer n (which is called the level of the congruence subgroup). Since they are kernels, my instances are normal subgroups.!

!ModularGroup commentStamp: '<historical>' prior: 0!
The special linear group SL(2,Z).!

!Module commentStamp: '<historical>' prior: 0!
Finitely-presented right R-modules, for a unital ring R.

The implementation relies on the ability to solve systems of linear equations over the coefficients ring. As long as there are algorithms for solving AX = B and AX = 0 for matrices over R, many important computations with finitely presented R-modules are supported (with the notable exception of isomorphism testing, that requires some kind of matrix normal form algorithm).

See also ModuleMap and HomModule.!

!FreeModule commentStamp: '<historical>' prior: 0!
Finite-rank free R-modules on free generators indexed by integers 1 to n. These are modules of n-tuples with coefficients in R.

See also Tuple and Matrix.!

!HomModule commentStamp: '<historical>' prior: 0!
R-modules of linear maps from a R-module A to another R-module B, for a commutative ring R. They are the internal Hom(A,B) of the category of R-modules. When A = B, it is noted End(A).

Note that Hom(A,B) is an R-module if R is commutative, but otherwise it is just a Z-module (not necessarily finitely generated), or a S-module if R is a S-algebra.

See Module and ModuleMap.!

!MatrixModule commentStamp: '<historical>' prior: 0!
R-modules of matrices with m rows and n columns and cofficients in a commutative ring R, considered as linear maps between free modules of tuples R^n and R^m.

See Matrix and FreeModule.
!

!QuotientModule commentStamp: '<historical>' prior: 0!
Quotient modules M/N (read "M mod N") of a given module M 'modulo' a submodule N, where both M and N are finite-rank free modules.

The elements of a quotient module M/N are cosets N + x with x in M. See ModuleCoset.
!

!Ideal commentStamp: '<historical>' prior: 0!
Finitely-generated right ideals of a ring R, i.e. R-submodules of R.!

!RationalIntegerIdeal commentStamp: '<historical>' prior: 0!
Ideal in the ring of rational integers.

Ideals of the integers are principal (or cyclic), i.e. they are all multiples of a given integer (the generator).!

!PolynomialIdeal commentStamp: '<historical>' prior: 0!
Ideal in a polynomial ring. See PolynomialRing and AffineAlgebra.!

!MonomialIdeal commentStamp: 'len 6/9/2019 15:47:41' prior: 0!
Ideal generated by monomials in a polynomial ring over a field.

With monomial ideals computations are much easier than with general polynomial ideals, and in many cases problems in general polynomial ideals can be reduced to problems in simpler monomial ideals (for example, by using Groebner bases).

Monomial ideals have a rich theory with connections to convex geometry and combinatorics. There's a one-to-one correspondences between:
- Simplicial complexes on {1,2,...,n};
- Squarefree monomial ideals in K[x1,...,xn];
- Unions of coordinate subspaces of K^n.

See also SimplicialComplex.!

!DirectSumModule commentStamp: '<historical>' prior: 0!
Direct sums of modules. Elements are tuples of module elements (see ModuleTuple) where the i-th component corresponds to an element in the i-th module of the direct sum, and multiplication by scalars and addition are defined component wise.!

!TensorModule commentStamp: '<historical>' prior: 0!
Tensor product over R of a list of free R-modules. This is a free R-module with basis given by elementary tensors on the choice of basis of the component modules.

See Tensor.!

!Code commentStamp: '<historical>' prior: 0!
Linear codes over rings or fields.

In coding theory, a linear code is an error-correcting code in which any linear combination of codewords is also a codeword. A linear code of length n over a ring R is a proper subset of the free module R^n that forms a submodule.
!

!PolynomialCode commentStamp: '<historical>' prior: 0!
In coding theory, a polynomial code is a type of linear code whose set of valid codewords consists of those polynomials (usually of some fixed length) that are divisible by some fixed polynomial (of shorter length, called the generator polynomial).

A polynomial code is cyclic if and only if the generator polynomial divides x^n - 1. See CyclicCode.
!

!Lattice commentStamp: '<historical>' prior: 0!
A lattice is the set of integer linear combinations of a basis of a rational or real vector space. This is a discrete subgroup of the ambient vector space (as abelian group) isomorphic to ^n.

More generally, given an integral domain R and a finite dimensional vector space V over its field of fractions, a lattice or R-lattice in V is a finitely generated R-module over R that spans V. In particular, lattices are defined to have full rank in V.

A lattice is defined by giving a basis {v1,...,vn} consisting of linearly independent vectors of the ambient vector space V, and an inner product (a positive definite symmetric bilinear form) or equivalently the Gramian matrix aij := <vi, vj>. The inner product or the Gramian matrix correspond also to the associated quadratic form.!

!Ring commentStamp: '<historical>' prior: 0!
Rings with identity (unital rings). They are associative and contain a multiplicative identity, but they are not necessarily commutative. The initial object is the ring of rational integers  and the terminal object is the trivial ring with 1 = 0.

Rings can be thought as continuous functions on some topological space. In the case of a commutative ring R this space is the prime spectrum Spec(R), the set of prime ideals with the Zariski topology. See AffineScheme.

Rings can be constructed from existing rings for example by taking quotients by a two-sided ideal (see QuotientRing), by direct product (see ProductRing), and in the case of commutative rings by making transcendental extensions (see PolynomialRing), localization (see FractionRing and LocalRing), completion (for example PowerSeriesRing and AdicRing), etc.!

!FractionRing commentStamp: '<historical>' prior: 0!
Total ring of fractions Frac(R) of a commutative ring R, also called the "total quotient ring" of R. The elements are formal fractions a/b with a and b in R and b regular (not a zerodivisor). When the ring R is an integral domain, Frac(R) is a field and it is called the "field of fractions" of R. See Ring>>fractions.

The ring of fractions is a particular case of the more general construction of the localization of a ring or module. The field of fractions of an integral domain is the localization at the zero ideal. See also LocalRing for localizations at prime ideals.!

!RationalField commentStamp: '<historical>' prior: 0!
The singletion global instance  is the field of rational numbers.!

!RationalFunctionField commentStamp: '<historical>' prior: 0!
The field of fractions of a polynomial ring with coefficients over a field.!

!AdicField commentStamp: '<historical>' prior: 0!
Field of p-adic numbers Qp. This is the fraction field of the ring of p-adic integers Zp. Elements are AdicNumbers. See also AdicRing and AdicInteger.!

!LaurentSeriesRing commentStamp: 'len 6/7/2020 17:52:33' prior: 0!
Ring R((x)) of formal Laurent series over a commutative ring R in an indetermiate x. See LaurentSeries.!

!LocalRing commentStamp: '<historical>' prior: 0!
Localization of a commutative ring R at a prime ideal P. The elements are 'germs at P' (see Germ), and can be thought as fractions a/b with a and b in R and b not in P. This is a subring of the total ring of fractions Frac(R) (see FractionRing).

The localization of R at a prime ideal P is the stalk of the structure sheaf of Spec(R) at the point P. As the elements of R are thought as functions on the space Spec(R), the elements of the localization at P are thought as germs of functions, i.e. functions that characterize the local behavior of Spec(R) near P.

The localization of R at the prime ideal P is equipped with a canonical map (the localization map) from the ring of integers R, as well as a canonical embedding into the total ring of fractions Frac(R).

The localization of R at the prime ideal P is a local ring, with maximal ideal equal to the extension of the ideal P by the localization map. The quotient by the maximal ideal is called the 'residue field'.!

!OppositeRing commentStamp: '<historical>' prior: 0!
The opposite ring of a given noncommutative ring.!

!ProductRing commentStamp: '<historical>' prior: 0!
Direct products of rings. Elements are tuples (see ProductRingElement) where the i-th component corresponds to an element in the i-th ring of the direct product, and multiplication and addition are defined component-wise.
!

!QuotientRing commentStamp: '<historical>' prior: 0!
Quotient rings (also called factor rings, difference rings or residue class rings). Their elements are residue classes (see Residue and subclasses).

Given a commutative ring R and an ideal I of R, the quotient ring R/I (read 'R modulo I' or 'R mod I') is the set of cosets (residue clases) of I in R by the equivalence relation a ~ b if a - b is in I. If the ideal is maximal, the resulting quotient ring is a field. If it's only prime, the quotient ring is an integral domain.

The quotient ring R/I is equipped with the projection map that sends elements of R to their residue classes in R/I. The projection map is a canonical homomorphism of rings. See >>project: and >>projection.!

!ModularIntegerRing commentStamp: '<historical>' prior: 0!
Ring Z/mZ of residue classes of integers modulo m. Elements are instances of ModularInteger.!

!PrimePowerRing commentStamp: '<historical>' prior: 0!
Residue class ring Z/(p^n)Z of integers modulo p^n.

These are Euclidean rings, and the simplest examples of Galois rings, GR(p^n,1). They are local rings with maximal ideal <p> and residue field isomorphic to Z/pZ. The maximal ideal <p> is also the set of zero-divisors as well as nilpotent elements. Other Galois rings are constructed by finite algebraic extensions (see GaloisRing).

These are also the simplest examples of 'chain rings', rings whose ideals form a chain under inclusion. A finite-chain ring is a principal ideal ring, and its maximal ideal is the nilradical (the set of nilpotent elements).

There are canonical projections from Z/(p^n)Z to Z/(p^m)Z for any 1 <= m <= n. These projections form a projective system (or inverse system), and the projective limit is the ring of p-adic integers Zp. There is a canonical projection from Zp to Z/(p^n)Z, and in this sense Z/(p^n)Z can be thought of as a truncation or an approximation of precision n of Zp (see AdicRing).!

!PrimeField commentStamp: '<historical>' prior: 0!
Residue class fields Z/pZ of integers modulo a prime p.

These are the simplest examples of Galois fields, GF(p^1). Other Galois fields are constructed by finite algebraic extensions (see GaloisField).!

!SmallPrimeField commentStamp: '<historical>' prior: 0!
Prime fields Z/pZ for small primes p, such that it is feasable to build exponentiation and logarithmic tables and accelerate arithmetic through table lookups.

The initialization of the tables is very fast. The main concern is memory usage. For a field Z/pZ, each of the two tables have p-1 elements. They are WordArrays (32 bits per entry), so a field Z/pZ uses about 8*(p-1) bytes of memory. For example, Z/65537 uses 524K of memory, and Z/1048583 (a 20-bits modulus) uses about 8M.
!

!AffineAlgebra commentStamp: '<historical>' prior: 0!
Finitely-generated commutative (associative) algebras, implemented as quotients of polynomial rings. They are the coordinate rings of affine varieties (closed subschemes of affine space, see AffineVariety). They are also sometimes called the 'rings of regular functions' (on affine varieties).

When the coefficients ring is a field K and the relations ideal I is maximal, the affine algebra K[X]/I is a field. In this way, affine algebras are multivariate generalizations of number fields and algebraic function fields.

See also PolynomialRing.!

!GaloisRing commentStamp: '<historical>' prior: 0!
The Galois ring GR(p^n,m) is a Galois extension of degree m of the prime power ring Z/(p^n)Z of characteristic p^n. This is the unique (up to isomorphism) extension of degree m of the ring Z/(p^n)Z of integers modulo p^n (see PrimePowerRing). When n=1 they are fields (see GaloisField).

Galois rings GR(p^n,m) are local rings with maximal ideal <p>, and <p> is also the set of zero-divisors. They are also Euclidean rings.

The subrings of GR(p^n,m) correspond to the positive divisors of m.

More generally, any finite local ring can be constructed as a finitely-generated GR(p^n,m)-algebra, i.e. a quotient of a polynomial ring (in a number of indeterminates) with coefficients in a Galois ring modulo a primary ideal of the polynomial ring (see AffineRing).

Just as prime power rings (see PrimePowerRing) are approximations of the p-adic integer ring Zp, general Galois rings are approximations of the ring of integers of unramified extensions of the p-adic field Qp generated by a (p^m)-th root of unity z: GR(p^n,m) = Zp[z]/<p^n>.

For reference see [GM73] and [BF15].!

!GaloisField commentStamp: '<historical>' prior: 0!
Finite nonprime fields, i.e. fields GF(p^r) with r>1. These are finite algebraic extensions of prime fields. See also PrimeField.!

!QuasiGaloisRing commentStamp: '<historical>' prior: 0!
The quasi-Galois ring A(p^r,n) is an extension of degree n of the Galois field GF(p^r) isomorphic to GF(p^r)[x]/<x^n>. See also GaloisRing.
!

!FunctionField commentStamp: '<historical>' prior: 0!
Algebraic function fields, i.e. finite field extensions of a rational function field. Function fields can also be viewed as vector spaces over the coefficients field.
!

!NumberField commentStamp: '<historical>' prior: 0!
Algebraic number fields, i.e. finite field extensions of the rational numbers. Number fields can also be viewed as vector spaces over the rational numbers.
!

!CyclotomicField commentStamp: '<historical>' prior: 0!
Cyclotomic fields, i.e. number fields obtained by adjoining a complex primitive root of unity to Q. The n-th cyclotomic field is obtained by adjoining a primitive n-th root of unity to the rational numbers.!

!QuadraticField commentStamp: '<historical>' prior: 0!
Quadratic number fields, i.e. number fields with defining quadratic polynomial of the form x^2 - d, with d a squarefree integer.!

!RationalIntegerRing commentStamp: '<historical>' prior: 0!
The singletion global instance  is the ring of rational integers.!

!PolynomialRing commentStamp: '<historical>' prior: 0!
Polynomial ring R[x1,...,xn] in one or many indeterminates over a commutative ring R. These are the finitely-generated free commutative (associative) R-algebras.

The number of indeterimnates is called the rank of the polynomial ring. The indeterminates are referred by index (positive integer numbers).

Polynomial rings have an associated monoid of monomials (see FreeAbelianMonoid) with a fixed monomial ordering. This ordering definines the leading term of a polynomial and is used for multivariate division (normal form or reduction) and the computation of Groebner bases and standard bases.

See also AffineAlgebraMap, PolynomialIdeal, AffineAlgebra, RationalFunctionField, AffineSpace.
!

!Algebra commentStamp: '<historical>' prior: 0!
Associative unital algebras over a commutative ring R. Since they are implemented in the category of rings they are assumed to be associative and unital, but they don't need to be commutative.

An R-algebra is constructed from a R-module, with multiplication given by an associative and unital R-bilinear map. When the module is free of rank n, the multiplication can be given by n^3 structure constants (elements of R), or equivalently by n matrices of nxn.!

!EndomorphismAlgebra commentStamp: '<historical>' prior: 0!
Algebra of R-module endomorphisms End(M). The underlying module is the homomorphisms module Hom(M,M) for a R-module M, and multiplication is composition of module maps.!

!MatrixAlgebra commentStamp: '<historical>' prior: 0!
Full matrix algebra, i.e. (n^2)-dimensional associative algebra of square n by n matrices over a ring R under matrix multiplication.!

!GroupAlgebra commentStamp: '<historical>' prior: 0!
Group algebra R[G] of a finite group G over a commutative ring R.

Given ring R and a group G, the group ring R[G] can be seen as a ring or as a free R-module with basis one-to-one with G. As a ring, its addition law is that of the free module, and the multiplication extends by linearity from the given group law on the basis.

The elements of the group ring R[G] are finite formal linear combinations of elements of G with coefficients in R, or the finite-support functions from G to R.

When the ring R is commutative, the group ring is also referred to as a group algebra.

Categorically, the group ring construction is left adjoint to the group of units (see UnitGroup). It's also a 'category algebra' analogous to the monoid ring for monoids and incidence algebra for posets.
!

!QuaternionAlgebra commentStamp: 'len 7/15/2020 06:05:17' prior: 0!
The algebra of quaternions over a field with given invariants (a,b). This is the 4-dimensional unital algebra generated by elements i, j such that i^2 = a, j^2 = b and ij = -ji.!

!MaximalOrder commentStamp: '<historical>' prior: 0!
Rings of integers of global fields (i.e. maximal orders). They are the integral closure of the rational integers in a number field or function field. See NumberField and FunctionField.
!

!CyclotomicRing commentStamp: '<historical>' prior: 0!
Rings of integers of cyclotomic number fields. See CyclotomicField.!

!QuadraticRing commentStamp: '<historical>' prior: 0!
Rings of integers of quadratic number fields. See QuadraticField.!

!ComplexField commentStamp: '<historical>' prior: 0!
The singletion global instance  is the field of complex numbers.!

!RealField commentStamp: '<historical>' prior: 0!
The singletion global instance  is the field of real numbers.!

!AdicRing commentStamp: '<historical>' prior: 0!
Ring of p-adic integers Zp. Elements are AdicIntegers. See also AdicField, AdicNumber and PrimePowerRing.

For each prime number p, the ring of p-adic integers Zp is the formal completion of the ring Z at the prime ideal <p>. Geometrically this means that Zp is the ring of functions on a formal neighbourhood of p inside Spec(Z). Algebaically it means that the elements in Zp look like formal power series where the formal variable is the prime number p.!

!PowerSeriesRing commentStamp: 'len 6/7/2020 17:53:32' prior: 0!
Ring R[[x1,...,xn]] of formal power series over a commutative ring R. See PowerSeries.

This is the completion of the polynomial ring R[x1,...,xn] at the maximal ideal <x1,...,xn>.!

!CompletionRing commentStamp: '<historical>' prior: 0!
Completion of a given commutative ring R at a given maximal ideal I. This is the inverse limit of the quotient rings R / I^n.!

!FreeAlgebra commentStamp: '<historical>' prior: 0!
Algebras of noncommutative polynomials in a finite set of indeterminates. These are finitely generated free associative unital algebras, and their elements are FreePolynomials.

This is the noncommutative analogue of a polynomial ring.!

!DistributiveAlgebra commentStamp: '<historical>' prior: 0!
Nonassociative algebras over a commutative ring R.

A distributive algebra is constructed from a R-module, with multiplication given by a R-bilinear map. When the module is free of rank n, the multiplication can be given by n^3 structure constants (elements of R), or equivalently by n matrices of nxn.!

!Scheme commentStamp: '<historical>' prior: 0!
A scheme is a topological space equipped with a sheaf of local rings (which makes it a locally ringed space). Subclasses implement particular types of schemes.

See AffineScheme for schemes corresponding to the spectrum Spec(R) of a commutative ring R, and ProjectiveScheme for Proj(R) of a graded commutative ring R.

For schemes defined by polynomial equations in some ambient space, see subclasses AffineVariety and ProjectiveVariety, which are closed subschemes of affine and projective space respectively.!

!Grassmannian commentStamp: '<historical>' prior: 0!
The Grassmannian Gr(r,V) is the set of r-dimensional subspaces of the vector space V.!

!AffineScheme commentStamp: '<historical>' prior: 0!
The prime spectrum Spec(R) of a commutative ring R, equipped with a sheaf of local rings (which makes it a locally ringed space). As a topological set, its points are identified with the prime ideals of the coordinate ring R.

The ring R should be thought as the ring of regular functions on Spec(R). Concretely, each element f of R defines a function that takes a point p of Spec(R) (i.e., a prime ideal p of R) to the image of f by the canonical map to the residue field at p.

Affine schemes are the fundamental building blocks of general schemes. Any scheme can be constructed by glueing together finitely many affine schemes, and conversely schemes that are not affine can be covered by a finite number of affine patches.
!

!AffineVariety commentStamp: '<historical>' prior: 0!
Closed subschemes of an affine space (see AffineSpace). Their coordinate rings are quotients of multivariate polynomial rings by an ideal (i.e. affine algebras, see AffineAlgebra). Their rational points are AffinePoints.

These are schemes, not classical algebraic varieties. Here the name 'variety' only means that they are defined by polynomial equations. The integral (reduced and irreducible) closed subschemes of affine space over an algebraically closed field correspond to the classical affine algebraic varieties.
!

!AffineCurve commentStamp: '<historical>' prior: 0!
Affine algebraic curves, i.e. schemes of dimension 1 over an affine space.!

!AffineHypersurface commentStamp: '<historical>' prior: 0!
Affine algebraic hypersurfaces, i.e. schemes of codimension 1 over an affine space. They can be defined by a single polynomial (the defining ideal is principal).!

!AffinePlaneCurve commentStamp: '<historical>' prior: 0!
Affine plane algebraic curves, i.e. schemes of dimension 1 over an affine plane.!

!AffineSpace commentStamp: '<historical>' prior: 0!
Affine spaces R^n as schemes, i.e. Spec R[x1,...,xn] for some commutative ring R. They are seen as schemes over Spec R.

Note that affine spaces defined as schemes differ from the classical affine spaces defined as 'vector spaces that have forgotten the origin'. The morphisms of this affine space are morphisms of schemes, not just the classical (linear) affine transformations. Since this is an scheme over Spec R, this means that the morphisms of schemes must commute with Spec R, i.e. they are the opposite of R-algebra homomorphisms (not arbitrary ring maps of R[x1,...,xn] but the ones that restricted to R are the identity).

Note also that the dimension of an affine space as scheme is the Krull dimension of its coordinate ring, and this can be bigger than the number of indeterminates (see >>dimension and >>rank). For affine spaces over fields, the dimension and the rank are equal (because fields have Krull dimension 0).!

!ProjectiveScheme commentStamp: '<historical>' prior: 0!
The projective or homogeneous prime spectrum Proj(R) of a graded commutative ring R, equipped with a sheaf of local rings (what makes it a locally ringed space). As a topological set, its points are identified with the relevant homogeneous prime ideals of the homogeneous coordinate ring R.

Proj(R) is contained in its affine cone Spec(R). See also AffineScheme.!

!ProjectiveVariety commentStamp: '<historical>' prior: 0!
Projective closed subschemes of a projective space (see ProjectiveSpace). Their homogeneous coordinate rings are quotient rings of multivariate polynomial rings by a homogeneous ideal, i.e. graded affine algebras. Their rational points are ProjectivePoints.

These are schemes, and not classical algebraic varieties (they don't need to be reduced, irreducible nor over an algebraically closed field). Here the name 'variety' only means that they are defined by polynomial equations.!

!ProjectiveCurve commentStamp: '<historical>' prior: 0!
Projective algebraic curves, i.e. projective schemes of dimension 1 over a projective space.!

!ProjectiveHypersurface commentStamp: '<historical>' prior: 0!
Projective algebraic hypersurfaces, i.e. schemes of codimension 1 over a projective space. They can be defined by a single homogeneous polynomial (the defining ideal is principal).!

!ProjectivePlaneCurve commentStamp: '<historical>' prior: 0!
Projective plane algebraic curves, i.e. schemes of dimension 1 over a projective plane.!

!Conic commentStamp: '<historical>' prior: 0!
Projective plane curves of genus 0 and degree 2. They are defined by quadratic polynomials.

Conics, together with rational curves (see RationalCurve), are the only curves of genus 0.

As any genus 0 curve, a conic either has no rational points, or it has infinitely many.!

!RationalCurve commentStamp: '<historical>' prior: 0!
Projective plane curves of genus 0 and degree 1. They are defined by linear polynomials.

Rational curves, together with Conics, are the only curves of genus 0.!

!EllipticCurve commentStamp: '<historical>' prior: 0!
Elliptic curves are the projective plane curves of genus 1. They can be defined by a Weierstrass equation (see WeierstrassEquation).

Elliptic curves are abelian varieties, i.e. the sets E(K) of K-rational points are abelian groups. See EllipticCurvePoint and EllipticCurveGroup.
!

!ProjectiveSpace commentStamp: 'len 5/17/2018 19:02:53' prior: 0!
Projective spaces P^nR as schemes, i.e. Proj R[x1,...,xn] for some commutative ring R.
!

!ProjectiveLine commentStamp: '<historical>' prior: 0!
Projective lines are P^1(R) for some commutative ring R. They are essentially the underlying ring R extended with an additional point at infinity. For example, the complex projective line is the Riemann sphere: the extended complex plane that includes the point at infinity. See also ProjectiveLinePoint.!

!CellComplex commentStamp: '<historical>' prior: 0!
Abstract cell complexes. See subclasses.!

!SimplicialComplex commentStamp: '<historical>' prior: 0!
Abstract simplicial complexes. These are combinatorial objects consisting of a collection of simplices (the 'faces' of the simplicial complex) with the following properties:
- every subface of a face is also in the complex;
- the intersection of two faces is either empty or a common face of both simplices, and it is also in the complex.

An abstract simplicial complex can also be seen as a subset of the power set of some set V, often V={1,...,n}, closed under inclusion.

Simplicial complexes form a category with simplicial maps as morphisms. See SimplicialMap.!

!UpperHalfPlane commentStamp: '<historical>' prior: 0!
This is the upper half complex plane H, i.e. the set of complex numbers with imaginary part > 0.

This serves as a model of the hyperbolic plane, defining lines as:
1. the intersection of the half-plane H and Euclidean lines orthogonal to the real axis, or
2. the intersection of the half-plane H and Euclidean half-circles with center on the real axis.

The group of hyperbolic isometries, as well as conformal automorphisms, is the general Moebius group. This is the group of Moebius transformations, i.e. transformations of the form z |-> (az + b) / (cz + d) with ad - cd ~= 0 (or without loss of generality ad - cd = 1).!

!ChainComplex commentStamp: '<historical>' prior: 0!
(Bounded) chain complexes.

A chain complex is a sequence of objects of an abelian category (such as abelian groups, modules or other chain complexes) C(k) (called k-chains) indexed by integers k, with homomorphisms d(k):C(k)->C(k-1) (called boundary operators or differentials) such that the composition between any two consecutive differentials is the trivial map: d(k)d(k+1) = 0.

A bounded chain complex is one where only a finite number of C(k) are not 0.

Chain complexes form an abelian cateogory with chain maps as morphisms. See ChainMap.

See also CochainComplex for the dual notion.!

!Sheaf commentStamp: '<historical>' prior: 0!
Coherent sheaves of R-modules over Proj(R).

See also HomSheaf and SheafMap.!

!Morphism commentStamp: '<historical>' prior: 0!
Morphisms belonging to a given Category. See Map and other subclasses for morphisms of specific categories, and Domain and HomSet.!

!Function commentStamp: '<historical>' prior: 0!
Functions, unlike general Morphisms, can be evaluated at elements of the domain (#value:) and they produce elements of the codomain. An instance of Function is a morphism in the category of sets, while instances of subclasses can be morphisms in other categories with underlying sets.

In general, maps are defined by specifying a domain, a codomain, and an expression that can be evaluated at elements of the domain and produces elements of the codomain. One such expression can be a Smalltalk block, another Map, or more generally any Smalltalk object that admits evaluation (#value:), such as polynomials.!

!Functor commentStamp: '<historical>' prior: 0!
A functor between two categories is a function that preserves composition of morphisms. They are morphisms of categories (see Category).

References:
	https://ncatlab.org/nlab/show/single-sorted+definition+of+a+category
!

!MonoidMap commentStamp: 'len 4/26/2020 08:57:01' prior: 0!
Monoid homomorphisms. They can be defined by an evaluable expression or Smalltalk block, or by images of generators. See Monoid.!

!GroupAction commentStamp: '<historical>' prior: 0!
(Left) group actions.

Given a group G and a set X, a (left) group action phi:GxX -> X is a function that satisfies:
- identity: phi(id,x) = x;
- compatibility: phi(g, phi(h,x)) = phi(g*h, x).

The group G is said to 'act' on X (on the left). The set X is called a (left) G-set (or G-space, G-module, depending on the category of X). Here we just call it 'space'.!

!GroupMap commentStamp: '<historical>' prior: 0!
Group homomorphisms. They can be defined by an evaluable expression or Smalltalk block, or by images of generators. See Group.!

!ConjugationMap commentStamp: '<historical>' prior: 0!
Group homomorphisms defined as conjugation by a given element. These are the inner automorphisms.!

!DirichletCharacter commentStamp: '<historical>' prior: 0!
Characters on the units of Z/nZ, i.e. group homomorphisms (Z/nZ)* -> C* from the unit group of the ring Z/nZ to the multiplicative group of nonzero complex numbers.!

!BilinearMap commentStamp: '<historical>' prior: 0!
BilinearMaps are functions from a cartesian product of two R-modules to (the underlying set of) a R-module, that are linear when fixing one of the arguments.!

!BilinearForm commentStamp: '<historical>' prior: 0!
Bilinear forms are functions from the cartesian square of an R-module to R that are linear when fixing one of the arguments, i.e. that satisfy:
	B(v+cv', w) = B(v, w) + cB(v', w)
	B(v, w+cw') = B(v, w) + cB(v, w')
!

!ModuleMap commentStamp: '<historical>' prior: 0!
Homomorphisms of R-modules. They are internally represented by a matrix (assuming a choice of finite presentations for the domain and codomain, or more concretely a choice of an ordered set of generators).

See Module and HomModule.!

!Matrix commentStamp: '<historical>' prior: 0!
Matrices with coefficients in a ring R.

A matrix A with m rows and n columns is a morphism of free modules of tuples R^n -> R^m following left action convention: A(x) = A*x; and the composition of A with a matrix B with n rows is A*B, and in this way A(B(x)) = A*B*x.

See also MatrixModule, FreeModule and Tuple.!

!ColumnMatrix commentStamp: 'len 3/12/2020 09:40:26' prior: 0!
Matrices with coefficients in a commutative ring, represented as a list of column tuples. Column operations are fast on these matrices.!

!RowMatrix commentStamp: 'len 3/12/2020 09:40:21' prior: 0!
Matrices with coefficients in a commutative ring, represented as a list of row tuples. Row operations are fast on these matrices.!

!QuadraticForm commentStamp: '<historical>' prior: 0!
Quadratic forms as homogeneous quadratic functions M->R from a finite-rank free R-module to R. Given a basis of M, they can be represented as homogeneous quadratic polynomials or as symmetric matrices that define symmetric bilinear forms MxM->R.!

!RingMap commentStamp: '<historical>' prior: 0!
Unital ring homomorphisms.!

!AffineAlgebraMap commentStamp: '<historical>' prior: 0!
Algebra homomorphisms of polynomial rings and their quotients (see PolynomialRing and AffineAlgebra).!

!AlgebraMap commentStamp: '<historical>' prior: 0!
Homomorphisms of associative unital R-algebras over a commutative ring R. These homomorphisms are just module maps of the underlying module that respect the multiplication and (because the algebras are assumed to be unital) send the identity to the identity. See Algebra.

All R-algebra homomorphisms are also ring homomorphisms, but since R-algebras are implemented in the category of rings they also have additional ring homomorphisms that are not R-algebra homomorphisms.!

!RationalMap commentStamp: '<historical>' prior: 0!
Rational maps between varieties (closed subschemes of affine or projective space). They are defined by a tuple of rational functions.

Rational maps are partial functions defined in a dense open subset of the domain. The scheme where a rational map is undefined is called its base scheme (see >>base).

A rational map is called 'regular' if it defines a morphism of varieties (i.e., for affine varieties it is defined by polynomials, and in case of projective varieties it is constant).
A regular map is called 'dominant' if its image is dense in its codomain.

The category of affine varieties or projective varieties with dominant rational maps and the category of function fields are contravariantly equivalent.!

!EllipticCurveIsogeny commentStamp: '<historical>' prior: 0!
Scheme morphisms of elliptic curves E -> E' that send the origin of E to the origin of E'. They are homomorphisms of group schemes.!

!LinearFractionalMap commentStamp: '<historical>' prior: 0!
Transformations of the form
	z |-> az + b / (cz + d)
where ad - cb ~= 0.!

!Sequence commentStamp: '<historical>' prior: 0!
Sequences are functions with domain the natural numbers {1,2,...}. They can be evaluated at an index (#value: and #at:), and can also be iterated over like Smalltalk collections (#do:, #collect:, #select, etc).

Example (the Fibonacci sequence):
	Sequence initialValues: #(0 1) recurrence: [:f :n| (f at: n-1) + (f at: n-2)].

Example (the harmonic numbers):
	Sequence to:  evaluating: [:n| (1 to: n) sum: [:k| 1/k]].

Each sequence has an associated generating series, which is the formal power series with coefficients given by the sequence (see PowerSeries):
	Sequence fibonacci generatingSeries
and Dirichlet series (see DirichletSeries):
	Sequence fibonacci dirichletSeries
!

!CFiniteSequence commentStamp: '<historical>' prior: 0!
Constant-recursive (or C-recursive or C-finite) sequences, i.e. sequences satisfying homogeneous linear recurrences with constant coefficients:
	a(n) = c_1 a(n-1) + ... + c_d a(n-d)

These sequences are closed under:
- addition a(n)+b(n)
- (Hadamard or termwise) multiplication a(n)*b(n)
- convolution (Cauchy multiplication)
- interlacing {a(1),b(1),a(2),b(2),...}
- scalar multiplication a(n)*c
- (left) shift a(n+k), k>0
- indefinite sumation a(1)+a(2)+...+a(n)
- multisection a(mn+r), 0 <= r < m.

Power series whose coefficients are linear recursive sequences are closed under:
- addition
- multiplication
- derivation

Example:
	CFiniteSequence fibonacci.
	CFiniteSequence fibonacci generatingFunction

Example:
	| f |
	f _ CFiniteSequence fibonacci * CFiniteSequence pellNumbers.
	f minimalPolynomial
!

!SimplicialMap commentStamp: '<historical>' prior: 0!
Morphisms of simplicial complexes. See SimplicialComplex.!

!ModularForm commentStamp: '<historical>' prior: 0!
A modular form of weight k is a holomorphic function f:H -> C from the upper half plane to the complex plane, satisfying for a,b,c,d coefficients of a matrix in SL(2,R)
	f((az + b) / (cz + d)) = (cz + d)^k f(z)
where k is a fixed integer or half-integer. Modular forms of weight 0 are called modular functions, and are invariant under the action of SL(2,R). The factor (cz + d)^k, which is 1 in the case of modular functions, is called the automorphic factor.

Modular forms are functions having an infinite group of symmetries and many beautiful properties. They are one of the five basic operations in arithmetic, together with addition, substraction, multiplication and division.

A modular form f(z) can be seen as power series on a new variable q = e^(2 pi i z). This is its Fourier expansion or q-expansion. The coefficients a(n) of the q-expansion are usually interesting arithmetic functions.

Given a group G, the set of modular forms of a given weight k form a finite-dimensional vector space M_k(G). See ModularFormSpace. The set of all modular forms of all weights is noted M_*(G) and it's a ring. All modular functions form a field.!

!ChainMap commentStamp: '<historical>' prior: 0!
A chain map between two chain complexes defined by differentials d(k):C(k)->C(k-1) and d'(k):C'(k)->C'(k-1) is a sequence of homomorphisms f(k):C(k)->C'(k) that commute with the differentials in the two complexes: d'(k) o f(k) = f(k-1) o d(k). They send cycles to cycles and boundaries to boundaries, and this descends to a map in homology f(k)* : H(k) -> H'(k).

Chain maps are morphisms in the category of chain complexes. See ChainComplex.!

!SchemeMorphism commentStamp: '<historical>' prior: 0!
Morphisms of schemes are morphisms of locally ringed spaces.

A scheme is covered by open affine patches, and a morphism of schemes is locally induced by affine morphisms between affine patches (or dually, ring homomorphisms between the coordinate rings of affine patches).!

!AffineMorphism commentStamp: '<historical>' prior: 0!
Scheme morphism between affine schemes Spec A -> Spec B. It is induced by its adjoint map, a ring homomorphism B -> A.!

!ProjectiveMorphism commentStamp: '<historical>' prior: 0!
Scheme morphism between projective schemes Proj A -> Proj B. It is induced by its adjoint map, a graded ring homomorphism B -> A of degree 0.!

!RationalPoint commentStamp: '<historical>' prior: 0!
Abstract superclass for K-rational points on a variety X, seen as morphisms Spec(K) -> X.

See also RationalPointSet.!

!AffinePoint commentStamp: '<historical>' prior: 0!
K-rational points on an affine variety X, seen as morphisms Spec(K) -> X.

See also AffineVariety.!

!ProjectivePoint commentStamp: '<historical>' prior: 0!
K-rational points on a projective variety X, seen as morphisms Spec(K) -> X.

See also ProjectiveVariety.!

!ProjectiveLinePoint commentStamp: '<historical>' prior: 0!
Points on the projective line P^1(R) for some ring R. See also ProjectiveLine.!

!EllipticCurvePoint commentStamp: '<historical>' prior: 0!
K-rational points on an elliptic curve E, seen as morphisms Spec(K) -> E. These objects implement the group law (with additive notation). The identity element (zero, or the point at infinity) is [0:1:0].

Following conventions, a point [a:b:1] is printed '(a,b)', and the point at infinity [0:1:0] is printed 'O'.

See also EllipticCurve.!

!MonomialOrdering commentStamp: '<historical>' prior: 0!
A monomial ordering is a total order on the set of all monomials in n indeterminates, satisfying the properties:
- respects multiplication: if u <= v, then u*w <= v*w for any other monomial w;
- 1 <= u for any monomial u.

Orderings are used in the computation of Groebner bases and more generally standard bases.!

!BlockMonomialOrdering commentStamp: '<historical>' prior: 0!
Block or product monomial orderings. They are used, for example, to define elimination orderings such that a subset of the indeterminates are always greater than the rest of the indeterminates.!

!GradedLexicographicOrdering commentStamp: 'len 2/12/2017 06:08:59' prior: 0!
The graded (or total degree) lexicographic ordering first compares the total degree of the monomials, and takes the monomial with largest total degree. If two monomials have the same total degree, the lexicographic ordering is used to break the tie.

The graded lexicographic ordering has the property that for each subring S[x1..xn] <= R, and each homogeneous polynomial f in R, f is in S iff its leading monomial is in S.

Elimination by the graded lexicographic ordering produces elements of an homogeneous ideal which are free of the first variable.!

!GradedReverseLexicographicOrdering commentStamp: 'len 2/12/2017 06:09:26' prior: 0!
The graded (or total degree) reverse lexicographic ordering first compares the total degree of the monomials, and takes the monomial with largest total degree. If two monomials have the same total degree, the reverse lexicographic ordering is used to break the tie (this is the lexicographic ordering on the reversed list of indeterminates (xn, ..., x1).

The graded reverse lexicographic ordering has the property that for each subring S[x1..xn] <= R, and each homogeneous polynomial f in S[x1..xi], xi divides f iff it divides the leading monomial.

Elimination by the graded reverse lexicographic ordering produces elements of a homogeneous ideal which are divisible by the last variable.!

!LexicographicOrdering commentStamp: '<historical>' prior: 0!
The lexicographic ordering is the 'dictionary' ordering. The first indeterminate is the greatest.

The lexicographic ordering has the property that for each subring S[x1..xn] <= R, and each polynomial f in R, f is in S iff its leading monomial is in S.

The lexicographic ordering is useful for solving systems of algebraic equations. Elimination by the lexicographic ordering produces elements of an ideal which are free of the first variable.!

!LocalGradedLexicographicOrdering commentStamp: 'len 2/12/2017 06:10:10' prior: 0!
The local graded lexicographic order (lglex) is the negation of the global graded lexicographic order (glex).

This is the order called 'lglex' in Magma. What Singular calls 'Ds', on the other hand, is like this but with the indeterminates reversed.!

!LocalGradedReverseLexicographicOrdering commentStamp: 'len 2/12/2017 06:10:33' prior: 0!
The local graded reverse lexicographic order (lgrevlex) is the negation of the global graded reverse lexicographic order (grevlex).

This is the order called 'lgrevlex' in Magma. What Singular calls 'ds', on the other hand, is like this but with the indeterminates reversed.!

!LocalLexicographicOrdering commentStamp: '<historical>' prior: 0!
The local lexicographic order (llex) is the negation of the global lexicographic order.

This is the order called 'llex' in Magma. What Singular calls 'ls', on the other hand, is like this but with the indeterminates reversed.!

!WeightedMonomialOrdering commentStamp: '<historical>' prior: 0!
Monomial orderings defined by weight tuples.

For monomials in n variables, there are n!! (n factorial) orderings. In certain applications such as Groebner bases it's desirable to easily construct new monomial orderings.

ideterminates 		an array with the indeterminates (variables) in order;
weights 				n-tuples with real coefficients.

Suppose you have two monomials:
	a = x1^a1 x2^a2 ... xn^an
	b = x1^b1 x2^b2 ... xn^bn
where some of the ai or bi may be 0. And suppose the variables are ordered x1 < x2 < ... < xn. If we are asked for the truth of a < b, we enumerate the weights and for each one, (w1, w2, ..., wn) we do:
	aSum = a1 w1 + a2 w2 + ... + an wn,
	bSum = b1 w1 + b2 w2 + ... + bn wn;
if aSum < bSum, then a < b; if aSum > bSum, then a > b; if aSum = bSum, we continue with the next weight, until there are no more weights (then, a should equal b...).

Theorem: For any monomial ordering in a finite number of variables, there is a collection of weights that models the ordering. So, with this idea we can contruct any ordering.
!

!GroupElement commentStamp: '<historical>' prior: 0!
Elements of a Group.!

!Monomial commentStamp: '<historical>' prior: 0!
Commutative power products of one or many indeterminates. They form a monoid (see FreeAbelianMonoid). Their formal linear combinations over a ring are Polynomials (see also PolynomialRing).

See also Word for the noncommutative analog.!

!Word commentStamp: '<historical>' prior: 0!
Words are noncommutative formal products on a finite ordered list of indeterminates. They are elements of the FreeMonoid, or the FreeGroup when negative exponents are allowed.

See also Monomial for the commutative analog.!

!Coset commentStamp: '<historical>' prior: 0!
Right cosets of a subgroup H of a group G: {Hg : g in G}. See QuotientGroup.!

!DirectProductGroupElement commentStamp: '<historical>' prior: 0!
Elements of group direct products, i.e. tuples of group elements. See DirectProductGroup.!

!OppositeGroupElement commentStamp: 'len 5/8/2019 14:34:38' prior: 0!
Elements of the opposite group of a given group. See OppositeGroup.!

!Permutation commentStamp: '<historical>' prior: 0!
Permutations can be thought as bijective functions on a finite set. Permutations under composition form groups (see SymmetricGroup and PermutationGroup).!

!FractionalIdeal commentStamp: '<historical>' prior: 0!
Fractional ideals of number rings. In general, for an integral domain R with fraction field K, a fractional ideal of R is an R-submodule of K. When R is a Dedekind domain, the set of fractional ideals forms an abelian group with multiplication. Fractional ideals are represented by a numerator (an integral nonzero ideal of R) and a denominator (an element of R).!

!SemidirectProductElement commentStamp: '<historical>' prior: 0!
Elements of a semidirect product of groups. See SemidirectProductGroup.!

!ProductReplacementRandomGenerator commentStamp: '<historical>' prior: 0!
Product Replacement Algorithm for generating random elements in a group from a set of generators. Essentially, it performs a random walk on a Cayley graph.!

!SchreierTree commentStamp: '<historical>' prior: 0!
Given a finite group G with a generating set S, and an action of G on X, a Schreier tree with root x for S is a representation of the orbit of x: it's a tree rooted at x with the elements of x^G as its vertices, and its edges describing the elements of S needed to get from x to each vertex, i.e. each edge {i,j} in the tree with i closer to the root than j is labeled by a generator s in S moving i to j.

Schreier trees allow for fast computation of stabilizers by Schreier's Lemma: with the notation above, the stabilizer of x is generated by the set of Schreier generators <t(i) * s * t(s(i))^-1> where i runs over the orbit of x, s runs over the generating set S, and t(i) is an element of G moving x to i, i.e. a coset representative of i (see >>trace: and >>traceInverse:).
!

!ModuleElement commentStamp: '<historical>' prior: 0!
Elements of R-modules. See Module.!

!ModuleCoset commentStamp: '<historical>' prior: 0!
Module cosets or affine subspaces contained in a given vector space, i.e. flats, or linear varieties, linear manifolds, or translated subspaces/submodules.

They appear when considering the solutions of non-homogeneous linear systems, or the set of all the vectors in the domain of a linear map that are mapped to a given vector in the codomain of the transformation (the 'fiber' of the vector). They are also the elements of quotient modules. See QuotientModule.
!

!Tuple commentStamp: '<historical>' prior: 0!
R-tuples with coefficients in a ring R, i.e. finite ordered lists of n elements of R indexed by integers 1 to n. They are elements of free modules R^n (see FreeModule).

Some subclasses implement special kinds of tuples for concrete rings, such as /m  and /2. These special tuples have a compact representation that saves memory and allows fast arithmetic. Fundamental parts of the system (such as modules, matrices and univariate polynomials) ultimately rely on tuples.

Three ways to create the 4-tuple (1,2,4,8) with integer coefficients:
	^4 !! #(1 2 4 8).
	^4 filling: [:i| 2^(i-1)].
	(1,2,4,8)
!

!DenseTuple commentStamp: '<historical>' prior: 0!
General n-tuples internally represented as an Array. These are the tuples used by default for an arbitrary ring.!

!MultivariateTuple commentStamp: '<historical>' prior: 0!
R-tuples with coefficients in a polynomial ring R. They are elements of free modules R^n (see FreeModule).
!

!SparseTuple commentStamp: 'len 7/21/2020 17:34:32' prior: 0!
Sparse tuples are tuples that use a Dictionary to store the components, and zero entries are not stored explicitly. This makes them more efficient when most of the entries are zero.!

!BitTuple commentStamp: '<historical>' prior: 0!
Tuples of integer residue classes modulo 2, i.e. binary tuples, bit strings, or tuples of bits. The coefficient field is /2.

Example:
	"A handy way to create a binary tuple:"
	(1,0,1,1,0,1,1,1) % 2
!

!ModularTuple commentStamp: '<historical>' prior: 0!
Tuples with coefficients in an integer residue class ring (or field) /m. See ModularInteger, ModularIntegerRing, PrimeField.

Example:
	"A handy way to create a tuple of integers modulo 3:"
	(1,2,3,4) % 3
!

!ModuleTuple commentStamp: '<historical>' prior: 0!
Elements of direct sums of modules, i.e. tuples of module elements. See DirectSumModule.!

!Sum commentStamp: '<historical>' prior: 0!
Formal sums (or formal linear combinations) of arbitrary symbols with coefficients over a given ring R. They can be thought of as Tuples indexed not by positive integers but by arbitrary symbols. They form free R-modules (see FreeModule).!

!Divisor commentStamp: '<historical>' prior: 0!
Weil divisors, i.e. formal sums (with integer coefficients) of prime divisors (integral closed subschemes of codimension 1) of an integral locally Noetherian scheme.!

!Tensor2 commentStamp: '<historical>' prior: 0!
Elements of tensor product modules (see TensorProductModule).

Tensors are represented as sparse formal sums of formal products of basis elements.!

!TupleMonomial commentStamp: '<historical>' prior: 0!
Monomials of R^n where R is a polynomial ring. They are the formal product of a monomial of R by a basis element.!

!TupleMonomialOrdering commentStamp: '<historical>' prior: 0!
Monomial orderings for R^n where R is a polynomial ring. They extend the monomial ordering of R to R-tuples.!

!POTOrdering commentStamp: '<historical>' prior: 0!
"Position Over Term" ordering.

Given tuple monomials x[i] and y[i], x[i] < y[j] iff i < j or i = j and x < y.

A Grobner basis computed with the POT ordering is analogous to a matrix echelon form.!

!TOPOrdering commentStamp: '<historical>' prior: 0!
"Term Over Position" ordering.

Given tuple monomials x[i] and y[i], x[i] < y[j] iff x < y or x = y and i < j.!

!HermiteColumnReduction commentStamp: '<historical>' prior: 0!
This is the Hermite column reduction algorithm. Given a matrix with coefficients in the rational integers Z, it reduces the matrix to its column-style Hermite normal form.

Reference: Henri Cohen, 'A Course in Computational Algebraic Number Theory', Algorithm 2.4.4.

See HermiteReduction for the algorithm modified to do row reduction instead of column reduction, and generalized to work over any computable Euclidean domain.!

!MatrixReduction commentStamp: '<historical>' prior: 0!
Abstract superclass for matrix (row) echelonization algorithms.!

!GaussianElimination commentStamp: '<historical>' prior: 0!
This is the Gaussian Elimination algorithm.

My instances perform Gaussian reduction on a matrix to compute its echelon form, linear dependency of the columns, rank, determinant, inverse matrix, etc.

Input: a matrix with coefficients in a field;
Output: the reduced echelon form of the matrix, determinant and left inverse.

The algorithm performs O(2n^3/3) field operations for nxn matrices, but due to exponential growth of intermediate coefficients it can be impractical in many situations (for example, with rational coefficients).!

!GaussBareiss commentStamp: '<historical>' prior: 0!
This is the Gauss-Bereiss algorithm, a variant of Gassian elimination. It performs division-free Gaussian elimination on a matrix with coefficients in an integral domain, and computes the echelon form.

Input: a matrix with coefficients in a an integral domain;
Output: the reduced echelon form and the determinant.

The algorithm performs O(n^3) ring operations for nxn matrices. While the standard Gaussian elimination suffers from exponential intermediate coefficients growth, the Gauss-Bareiss algorithm has bit complexity O(n^5).
!

!HermiteReduction commentStamp: '<historical>' prior: 0!
This is the Hermite row reduction algorithm. Given a matrix with coefficients in a computable Euclidean domain, it reduces the matrix to its row-style Hermite normal form.

The algorithm is essentially Algorithm 2.4.4 in [Coh96] but modified to do row reduction instead of column reduction and generalized to Euclidean domains.!

!HowellReduction commentStamp: '<historical>' prior: 0!
This is the Howell row reduction algorithm. Given a matrix with coefficients in a PIR such as Z/mZ, it reduces the matrix to its Howell normal form.

References:
John A. Howell, "Spans in the module (Z/mZ)^s" (1986)
Arne Storjohann, "Algorithms for Matrix Canonical Forms" (2000)
Arne Storjohann, Thom Mulders, "Fast algorithms for linear algebra modulo N" (1998)
Claus Flieker, Tommy Hofmann, "Computing in quotients of rings of integers" (2016)
!

!CochainComplex commentStamp: '<historical>' prior: 0!
(Bounded) cochain complexes.

A cochain complex is a sequence of objects of an abelian category (such as abelian groups, modules or other (co)chain complexes) C(k) (called k-cochains) indexed by integers k, with homomorphisms d(k):C(k)->C(k+1) (called boundary operators or differentials) such that the composition between any two consecutive differentials is the trivial map: d(k)d(k+1) = 0.

A bounded cochain complex is one where only a finite number of C(k) are not 0.

Cochain complexes form an abelian cateogory with cochain maps as morphisms. See CochainMap.

See also ChainComplex for the dual notion.!

!LLL commentStamp: '<historical>' prior: 0!
This is the Lenstra-Lenstra-Lovasz algorithm.

Input: integer lattice of dimension d given by a basis {b1, ..., bd} and an inner product;
Output: an almost H-reduced basis of the lattice.

The algorithm takes at most O(d^6 ln^3(B)), where the input vectors bi all satisfy |bi|^2 <= B. In practice however, this upper bound is quite pessimistic.
!

!Division commentStamp: '<historical>' prior: 0!
This is the output of the division algorithm. The actual algorithm can be implemented in a method somewhere else, or in a subclass.!

!RingElement commentStamp: '<historical>' prior: 0!
Elements of a Ring.!

!OppositeRingElement commentStamp: '<historical>' prior: 0!
Elements of the opposite ring of a given noncommutative ring. See OppositeRing.!

!ProductRingElement commentStamp: '<historical>' prior: 0!
Elements of product rings, i.e. tuples of ring elements. See ProductRing.!

!Ratio commentStamp: '<historical>' prior: 0!
Ordered pairs written a/b, with a and b in a commutative ring R, and satisfying the equivalence relation: a/b = c/d iff a*d = c*b.

They are elements of the fraction field or total ring of fractions Frac(R). See FractionRing.!

!Germ commentStamp: '<historical>' prior: 0!
Elements of localizations of rings at a prime ideal, also called germs. See LocalRing.!

!Rational commentStamp: '<historical>' prior: 0!
Elements of the field of rational numbers. See RationalField.!

!RationalFunction commentStamp: '<historical>' prior: 0!
Rational functions are fractions of polynomials. They are elements of the field of fractions of a polynomial ring over a field (see RationalFunctionField).!

!Residue commentStamp: '<historical>' prior: 0!
Elements of a quotient ring (see QuotientRing). These are residue classes of elements of a ring modulo an ideal.!

!ModularInteger commentStamp: '<historical>' prior: 0!
Residue classes of integers modulo an integer m, i.e. elements of the quotient ring Z/mZ (see ModularIntegerRing).!

!RegularFunction commentStamp: '<historical>' prior: 0!
Elements of an affine algebra (a quotient of a polynomial ring). See AffineAlgebra.!

!GaloisResidue commentStamp: '<historical>' prior: 0!
Elements of Galois rings. See GaloisRing.!

!Polynomial commentStamp: 'len 5/11/2019 08:20:21' prior: 0!
Polynomials in one or many indeterminates, with coefficients in a commutative ring. These are elements of a PolynomialRing.

This is an abstract class. See subclasses MultivariatePolynomial and UnivariatePolynomial for concrete implementations.

See also PolynomialRing, RationalFunction.!

!MultivariatePolynomial commentStamp: '<historical>' prior: 0!
Polynomials in one or more indeterminates, represented in sparse form.

Multivariate polynomials are internally stored as a list of associations 'monomial -> coefficient'. Zero coefficients are excluded, and the list is kept sorted according to the monomial ordering.!

!UnivariatePolynomial commentStamp: '<historical>' prior: 0!
Univariate polynomials, represented in dense form.

They are stored as a Tuple indexed by degree (the first element of the coefficients tuple corresponds to the independent coefficient of the polynomial).!

!AlgebraElement commentStamp: '<historical>' prior: 0!
Elements of (associative unital) algebras over a commutative ring R. See Algebra and AlgebraMap.!

!GroupAlgebraElement commentStamp: '<historical>' prior: 0!
Linear combinations of group elements. These are elements of GroupAlgebras.!

!Multivector commentStamp: 'len 7/15/2020 06:06:04' prior: 0!
Elements of a Clifford algebra or an exterior algebra. See CliffordAlgebra.!

!Quaternion commentStamp: 'len 7/14/2020 21:25:41' prior: 0!
Elements of a quaternion algebra. See QuaternionAlgebra.!

!AlgebraicInteger commentStamp: '<historical>' prior: 0!
Elements of maximal orders in number fields or function fields. See MaximalOrder.!

!LaurentSeries commentStamp: 'len 6/7/2020 17:51:33' prior: 0!
Formal Laurent series with coefficients over a commutative ring. See LaurentSeriesRing.!

!PowerSeries commentStamp: 'len 6/7/2020 17:53:07' prior: 0!
Formal power series with coefficients over a commutative ring. See PowerSeriesRing.!

!RelaxedAdicInteger commentStamp: '<historical>' prior: 0!
Elements of the p-adic ring Zp. See AdicRing.!

!RelaxedAdicNumber commentStamp: '<historical>' prior: 0!
Elements of the p-adic field Qp. See AdicField.

A p-adic number z is represented uniquely by an integer k (the valuation) and a unit u in Zp, such that z = (p^k)*u.!

!RelaxedPowerSeries commentStamp: '<historical>' prior: 0!
Univariate formal power series with coefficients over a commutative ring. See PowerSeriesRing.!

!FreePolynomial commentStamp: '<historical>' prior: 0!
Polynomials in a finite set of noncommuting indeterminates. They are elements of a free associative algebra (FreeAlgebra).

A free polynomial is a formal linear combination of Words, that in turn are formal (noncommutative) products of arbitrary objects (indeterminates).!

!Buchberger commentStamp: 'len 1/12/2022 14:31:46' prior: 0!
This is the Buchberger algorithm.

Input: a matrix over a polynomial ring with a choice of monomial ordering;
Output: a reduced standard basis or a Groebner basis of the module generated by the columns.

When the monomial ordering is global, the algorithm outputs a Groebner basis. In case of a local monomial ordering, the algorithm uses Mora's normal form and outputs a standard basis.
!

!ExtendedBuchberger commentStamp: 'len 1/12/2022 14:30:49' prior: 0!
This is the extended Buchberger algorithm. It keeps track of how the polynomials in the Groebner basis arise as linear combinations of the original generators, and produces a matrix that maps the original generators to the Groebner basis.

Input: a matrix over a polynomial ring with a choice of *global* monomial ordering;
Output: a reduced Groebner basis of the module generated by the columns, and a 'change of basis' matrix that maps the original generators to the Groebner basis.

See Buchberger for a more general algorithm that works with both global and local monomial orderings.!

!ComplexBox commentStamp: '<historical>' prior: 0!
Boxes in the complex plane, defined by two real intervals (for the real and imaginary parts).!

!ComplexDisk commentStamp: '<historical>' prior: 0!
Closed disks in the complex plane, defined by a center point and a radius.!

!ComplexRootIsolator commentStamp: '<historical>' prior: 0!
This is the CEVAL algorithm [1] for isolating the complex roots of a squarefree polynomial.

[SY09] Michael Sagraloff, Chee K. Yap, "An Efficient and Exact Subdivision Algorithm for Isolating Complex Roots of a Polynomial and its Complexity Analysis" (2009)!

!MultivariateDivision commentStamp: '<historical>' prior: 0!
This is the multivariate polynomial division algorithm for polynomials over a field.

Input: dividend f and divisors f1,..,fs in K[x1..xd] with a monomial ordering;
Output: quotients q1,..,qs and remander r in K[x1..xd] such that f = q1*f1 + ... + qs*fs + r, such that:
1. LM(qi*fi) <= LM(f);
2. None of the monomials in r is divisible by any LM(fi).

The algorithm performs O(n^d m^d) operations in the coefficients field K, where n is the total degree of f and m is the maximal total degree of f1..fs.!

!NumericalComplexRootIsolator commentStamp: '<historical>' prior: 0!
This algorithm separates complex roots of polynomials with real or complex coefficients. This is Newton's modified algorithm [1], and the convergence is quadratic. The polynomial is assumed to be squarefree.

Input: a squarefree polynomial of degree n with real or complex coefficients, and a desired minimum absolute error (tolerance);
Output: a collection of the n complex roots of the polynomial.

See [Coh96] Algorithm 3.6.6.!

!PseudoDivision commentStamp: 'len 7/30/2019 03:37:20' prior: 0!
This is the pseudo-division algorithm for univariate polynomials over an arbitrary commutative ring.

Input: dividend and divisor polynomials f,g in R[x], where R is a commutative ring;
Output: quotient and remainder polynomials q,r in R[x], such that b*f = q*g + r, deg(f) = deg(g) + deg(q), deg(r) < deg(g) and b = LC(g)^max(0,deg(f)-deg(g)+1).

The algorithm performs O(n^2) arithmetic operations for dense polynomials of degree n.!

!RealBox commentStamp: '<historical>' prior: 0!
Boxes in R^n built by the cartesian product of one-dimensional intervals (instances of RealInterval).

Example:
	RealBox new
		add: (RealInterval closed: -1 closed: 1);
		add: (RealInterval open: 3 open: 4);
		add: (RealInterval closed: 0 open: Infinity positive);
		yourself.
!

!RealInterval commentStamp: '<historical>' prior: 0!
Real intervals in the real line. Each of my instances can have finite or infinite and open or closed bounds.

For some examples try this:
	RealInterval open: 1 closed: 2.
	RealInterval open: 0 open: Infinity positive.
	RealInterval closed: -1 closed: 1.
	RealInterval open: Infinity negative open: Infinity positive.
!

!ComplexAlgebraicNumber commentStamp: '<historical>' prior: 0!
Complex algebraic numbers, i.e. zeros of polynomials with integer (or rational) coefficients, in 'minimal polynomial' representation. See also RealAlgebraicNumber.!

!SchemePoint commentStamp: '<historical>' prior: 0!
Topological points on a general scheme given by a point on an affine patch.!

!CRT commentStamp: '<historical>' prior: 0!
This is the Chinese Remainder Theorem. My instances find solutions to systems of linear Diophantine equations x = x_i (mod m_i). The algorithm works on any Euclidean domain.

Input: x_1...x_k, k elements in a Euclidean domain, and m_1,...,m_k pairwise coprime, defining the Diophantine system x = x_i (mod m_i);
Output: x such that x = x_i (mod m_i) for 1<=i<=k.
!

!ExtendedEuclid commentStamp: '<historical>' prior: 0!
This is the extended Euclidean algorithm.

Input: an array of two elements {a,b} in a Euclidean ring
Output: the GCD of a with b, and a pair of Bezout coefficients {u. v} such that a*u + b*v = (a,b).

In the case of integers, if |a|<=|b| the output |u| and |v| are unique and satisfy:
	-|a| / d < v*sign(b) <= 0.
	1 <= u*sign(a) <= |b| / d
where d = gcd(a,b).

For integers, the algorithm takes time O(ln^3 N) where |a|,|b| <= N. For polynomials of degree n, it is O(n^3).!

!LagrangeGaussReduction commentStamp: '<historical>' prior: 0!
This is the Lagrange-Gauss reduction algorithm. My instances perform reduction of lattice basis of rank 2, and the algorithm it is essentially Euclid's algorithm.

Input: a vector space V and two independent vectors {v1,v2} that generate a lattice;
Output: a short vector in the lattice.
!

!ModifiedBerlekampMassey commentStamp: '<historical>' prior: 0!
This is a modified [ADL06] Berlekamp-Massey algorithm. This modified version admits lazy evaluation.

Input: a_1..a_{2n} the first 2n coefficients of a linear recursive sequence over a field K of order at most n (the minimal polynomial has degree bound n);
Output: the minimal polynomial of the sequence.
!

!NTT commentStamp: '<historical>' prior: 0!
Number Theoretic Transforms, the analog of DFTs for the field of integers modulo a prime p. Special cases are the Fermat Number Transform (p = 2^k + 1) and the Mersenne Number Transform (p = 2^k - 1).

The (pseudo) number theoretic transform may be meaningful in the ring Z/<m> even when the modulo m is not prime, provided a principal root of order n exists.!

!TonelliShanks commentStamp: '<historical>' prior: 0!
This is the Tonelli-Shanks algorithm for computing square roots in a prime field Z/pZ (with odd p).

See [Coh96] Algorithm 1.5.1.!

!DirichletSeries commentStamp: '<historical>' prior: 0!
Formal Dirichlet series, i.e. formal series in an indeterminate x of the form: sum a(n) * n^{-x} for n >= 1.

Examples:
	DirichletSeries coefficients: Sequence moebius.
	Sequence liouville dirichletSeries.

Structure:
 coefficients	Sequence -- the coefficients of the Dirichlet series
!

!WeierstrassEquation commentStamp: '<historical>' prior: 0!
Weierstrass equations are equations of the form
	y^2 + a1 xy + a3 y = x^3 + a2 x^2 + a4 x + a0
with coefficients (a1,a2,a3,a4,a6) in some field.

When the discriminant is not zero, they define an elliptic curve. See EllipticCurve.!

!BerlekampMassey commentStamp: '<historical>' prior: 0!
This is the Berlekamp-Massey algorithm. The initial purpose of this algorithm was to evaluate Binary BCH codes, but it has found many uses, including inverting matrices of constant diagonal, solving linear recurrences (synthesizing LFSRs with a specified output sequence), etc.

Input: a_1..a_{2n} the first 2n coefficients of a linear recursive sequence over a field K of order at most n (the minimal polynomial has degree bound n);
Output: the minimal polynomial of the sequence.

The algorithm performs O(n^2/2) multiplications; more precisely, at most 2 floor(n^2/4) - n + 1 multiplications.!

!SmithReduction commentStamp: '<historical>' prior: 0!
This is the Smith reduction algorithm. Given a matrix with coefficients in a PID, it reduces the matrix to its Smith normal form.

The Smith normal form is very useful for working with finitely generated modules over a PID, and in particular for deducing the structure of a quotient of a free module.

Reference: Henri Cohen, 'A Course in Computational Algebraic Number Theory', Algorithm 2.4.14.!

!FareySymbol commentStamp: '<historical>' prior: 0!
Farey symbols give information about finite index subgroups of the modular group (such as index, generators, etc) and about the associated modular curve (such as genus and rank of the fundamental group).

References
	R. S. Kulkarni, "An arithmetic-geometric method in the study of the subgroups of the modular group", American Journal of Mathematics 113 (1991), no. 6, 1053-1133.
	Chris A. Kurth, Ling Long, "Computations with finite index subgroups of PSL(2,Z) using Farey symbols".
	John Voight, "Computational methods for modular and Shimura curves", lecture videos in youtube.!

!Cardinal methodsFor: 'printing' stamp: 'len 5/23/2020 07:28:29'!
printOn: aStream
	aStream nextPut: $; nextPutAll: order printString sub! !

!Infinity methodsFor: 'printing' stamp: 'len 5/23/2020 07:36:16'!
printOn: aStream
	self negative ifTrue: [aStream nextPut: $-].
	aStream nextPut: $! !

!Ordinal methodsFor: 'printing' stamp: 'len 12/31/2021 11:26:42'!
printOn: aStream
	self isFinite ifTrue: [aStream print: self asInteger. ^ self].
	terms do: [:each|
		each key isZero
			ifTrue: [aStream print: each value]
			ifFalse:
				[aStream nextPut: $.
				each key isOne ifFalse: [aStream nextPutAll: each key printString super].
				each value > 1 ifTrue: [aStream print: each value]]]
		separatedBy: [aStream nextPut: $+]! !

!BitArray2 methodsFor: 'printing' stamp: 'len 12/21/2015 20:42'!
printOn: aStream
	1 to: self size do: [:i| aStream print: (self at: i)]! !

!StandardBasis methodsFor: 'printing' stamp: 'len 5/7/2018 23:22:28'!
printOn: aStream
	aStream nextPut: ${.
	elements do: [:each| aStream print: each] separatedBy: [aStream nextPutAll: ', '].
	aStream nextPut: $}! !

!YoungTableau methodsFor: 'printing' stamp: 'len 5/17/2020 12:36:42'!
printOn: aStream
	self rows do: [:row|
		aStream nextPut: $[.
		row do: [:each| aStream print: each] separatedBy: [aStream nextPut: $|].
		aStream nextPut: $]] separatedBy: [aStream newLine; space]! !

!Simplex methodsFor: 'printing' stamp: 'len 2/27/2017 08:21:52'!
printOn: aStream
"	self isTrivial ifTrue: [aStream nextPut: Character emptySet. ^ self]."
	aStream nextPut: ${.
	self vertices do: [:each|
		(each isString and: [aStream isText])
			ifTrue: [aStream nextPutAll: each asText]
			ifFalse: [aStream print: each]] separatedBy: [aStream nextPut: $,].
	aStream nextPut: $}! !

!Domain methodsFor: 'accessing' stamp: 'len 7/29/2020 08:34:23'!
category
	^ self propertyAt: #category ifAbsentPut: [self id category]! !

!Structure methodsFor: 'copying' stamp: 'len 3/19/2016 22:41'!
postCopy
	super postCopy.
	properties _ properties copy! !

!Structure methodsFor: 'printing' stamp: 'len 5/1/2020 14:11:05'!
printOn: aStream
	self propertyAt: #elements ifPresent: [:aCollection|
		(aCollection isKindOf: Structure) ifTrue: [aStream print: aCollection. ^ self].
		aStream nextPut: ${. "Wildberger notation for unordered sets: elements separated by spaces"
		aCollection asSet do: [:each| aStream print: each] separatedBy: [aStream nextPutAll: ' '].
		aStream nextPut: $}.
		^ self].
	^ super printOn: aStream! !

!CartesianProduct methodsFor: 'printing' stamp: 'len 5/23/2020 07:18:55'!
printOn: aStream
	components do: [:each| aStream print: each] separatedBy: [aStream nextPut: $]! !

!Category methodsFor: 'accessing' stamp: 'len 4/26/2020 17:30:11'!
name
	^ self propertyAt: #name! !

!Category methodsFor: 'printing' stamp: 'len 4/26/2020 17:31:22'!
printOn: aStream
	aStream nextPutAll: self name! !

!Modules methodsFor: 'accessing' stamp: 'len 10/26/2020 10:41:24'!
name
	^ #Modules! !

!Modules methodsFor: 'printing' stamp: 'len 4/26/2020 17:46:57'!
printOn: aStream
	aStream print: self scalars; nextPut: $-; nextPutAll: self name! !

!ChainComplexes methodsFor: 'accessing' stamp: 'len 10/30/2020 11:02:11'!
name
	^ #ChainComplexes! !

!ChainComplexes methodsFor: 'printing' stamp: 'len 10/26/2020 10:37:03'!
printOn: aStream
	aStream nextPutAll: 'Ch', '' sub; nextPut: $(; print: self chains; nextPut: $)! !

!CochainComplexes methodsFor: 'accessing' stamp: 'len 10/30/2020 11:14:22'!
name
	^ #CochainComplexes! !

!CochainComplexes methodsFor: 'printing' stamp: 'len 10/26/2020 10:42:38'!
printOn: aStream
	aStream nextPutAll: 'Ch', '' super; nextPut: $(; print: self cochains; nextPut: $)! !

!HomSet methodsFor: 'printing' stamp: 'len 12/5/2016 11:56:13'!
printOn: aStream
	self isEndomorphisms
		ifTrue: [aStream nextPutAll: 'End'; nextPut: $(; print: self domain; nextPut: $)]
		ifFalse: [aStream nextPutAll: 'Hom'; nextPut: $(; print: self domain; nextPut: $,; print: self codomain; nextPut: $)]! !

!Naturals methodsFor: 'printing' stamp: 'len 5/23/2020 07:23:35'!
printOn: aStream
	aStream nextPut: $! !

!FreeAbelianMonoid methodsFor: 'printing' stamp: 'len 5/13/2019 12:21:50'!
printOn: aStream
	self isTrivial ifTrue: [aStream nextPut: ${; print: self identity; nextPut: $}. ^ self].
	aStream nextPut: $[.
	self generators do: [:each| aStream print: each] separatedBy: [aStream nextPut: $,].
	aStream nextPutAll: ']*'! !

!FreeMonoid methodsFor: 'printing' stamp: 'len 5/13/2019 11:09:38'!
printOn: aStream
	self isTrivial ifTrue: [aStream nextPut: ${; print: self identity; nextPut: $}. ^ self].
	aStream nextPut: ${.
	self generators do: [:each| aStream print: each] separatedBy: [aStream nextPut: $,].
	aStream nextPutAll: '}*'! !

!Group methodsFor: 'accessing' stamp: 'len 7/26/2021 18:15:53'!
category
	^ Groups! !

!Group methodsFor: 'printing' stamp: 'len 7/11/2021 18:11:17'!
printOn: aStream
	| generators |
	(generators _ self generators) ifNil: [^ super printOn: aStream].
	"use the original printOn for wrapped objects:"
	self propertyAt: #elements ifPresent: [:elements| (elements isKindOf: Structure) ifTrue: [aStream print: elements. ^ self]].
	generators isEmpty ifTrue: [aStream print: 1. ^ self].
	aStream nextPut: $<.
	generators do: [:each| aStream print: each] separatedBy: [aStream nextPutAll: '; '].
	aStream nextPut: $>! !

!DirectProductGroup methodsFor: 'printing' stamp: 'len 5/23/2020 07:19:05'!
printOn: aStream
	components do: [:each| aStream print: each] separatedBy: [aStream nextPut: $]! !

!FreeGroup methodsFor: 'printing' stamp: 'len 10/20/2020 16:39:23'!
printOn: aStream
	self isTrivial ifTrue: [aStream print: 1. ^ self].
	aStream nextPut: $<.
	self generators do: [:each| aStream print: each] separatedBy: [aStream nextPut: $,].
	aStream nextPutAll: '>'! !

!OppositeGroup methodsFor: 'printing' stamp: 'len 5/8/2019 13:52:38'!
printOn: aStream
	aStream print: opposite; nextPutAll: 'op' super! !

!QuotientGroup methodsFor: 'printing' stamp: 'len 10/27/2020 18:27:52'!
printOn: aStream
	self generators isEmpty ifTrue: [aStream print: 1. ^ self].
	(self base printString includes: $/)
		ifTrue: [aStream nextPut: $(; print: self base; nextPut: $)]
		ifFalse: [aStream print: self base].
	aStream nextPut: $/.
	(self relations printString includes: $/)
		ifTrue: [aStream nextPut: $(; print: self relations; nextPut: $)]
		ifFalse: [aStream print: self relations]! !

!FPGroup methodsFor: 'printing' stamp: 'len 10/27/2020 18:43:58'!
printOn: aStream
	aStream nextPut: $<.
	self generators do: [:each| aStream print: each] separatedBy: [aStream nextPut: $,].
	self relators isEmpty
		ifFalse:
			[aStream nextPutAll: ' | '.
			self relators do: [:each| aStream print: each] separatedBy: [aStream nextPut: $,]].
	aStream nextPut: $>! !

!AlternatingGroup methodsFor: 'printing' stamp: 'len 1/31/2018 17:31:29'!
printOn: aStream
	aStream nextPutAll: 'Alt('; print: self space; nextPut: $)! !

!SymmetricGroup methodsFor: 'printing' stamp: 'len 4/30/2019 17:59:53'!
printOn: aStream
	self isStandard
		ifTrue: [aStream nextPutAll: 'S', self degree printText sub]
		ifFalse: [aStream nextPutAll: 'Sym('; print: self space; nextPut: $)]! !

!LinearGroup methodsFor: 'printing' stamp: 'len 3/3/2020 16:11:52'!
printOn: aStream
	self shortName isNil ifTrue: [^ super printOn: aStream].
	aStream isText
		ifTrue:
			[aStream nextPutAll: self shortName; nextPutAll: self degree printString sub; nextPut: $(; print: self scalars; nextPut: $)]
		ifFalse:
			[aStream nextPutAll: self shortName; nextPut: $(; print: self scalars; nextPut: $,; print: self degree; nextPut: $)]! !

!OrthogonalGroup methodsFor: 'printing' stamp: 'len 7/28/2020 09:28:26'!
printOn: aStream
	aStream nextPutAll: 'O('; print: self quadraticForm; nextPut: $)! !

!SpecialOrthogonalGroup methodsFor: 'printing' stamp: 'len 7/28/2020 10:47:08'!
printOn: aStream
	aStream nextPutAll: 'SO('; print: self quadraticForm; nextPut: $)! !

!UnitGroup methodsFor: 'printing' stamp: 'len 5/23/2020 07:19:34'!
printOn: aStream
	aStream print: self space; nextPutAll: '' super ! !

!EllipticCurveGroup methodsFor: 'printing' stamp: 'len 11/10/2016 08:13'!
printOn: aStream
	aStream nextPutAll: 'E('; print: self scalars; nextPut: $)! !

!SemidirectProductGroup methodsFor: 'printing' stamp: 'len 4/21/2016 00:16'!
printOn: aStream
	aStream print: left; nextPutAll: ' X| '; print: right! !

!DirichletGroup methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:13:12'!
printOn: aStream
	aStream nextPut: $(; print: ; nextPut: $/; print: self modulus; nextPutAll: ')', '*' super! !

!Gamma0CongruenceSubgroup methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 07:37:35'!
printOn: aStream
	aStream nextPutAll: '', '0' sub,'('; print: self level; nextPut: $)! !

!Gamma1CongruenceSubgroup methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 07:37:47'!
printOn: aStream
	aStream nextPutAll: '', '1' sub,'('; print: self level; nextPut: $)! !

!PrincipalCongruenceSubgroup methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 07:40:36'!
printOn: aStream
	aStream nextPut: $.
	self level ~= 1 ifTrue: [aStream nextPut: $(; print: self level; nextPut: $)]! !

!ModularGroup methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 07:38:23'!
printOn: aStream
	aStream nextPut: $! !

!Module methodsFor: 'accessing' stamp: 'len 7/26/2021 18:13:56'!
category
	^ self scalars Modules! !

!Module methodsFor: 'printing' stamp: 'len 12/26/2021 11:11:33'!
printOn: aStream
	self isTrivial ifTrue: [aStream print: 0. ^ self].
	self isQuotient ifTrue: [aStream print: self base; nextPut: $/; print: self relations. ^ self].
	aStream nextPut: $<.
	self printGeneratorsOn: aStream.
	aStream nextPut: $>! !

!FreeModule methodsFor: 'printing' stamp: 'len 5/28/2020 17:56:15'!
printOn: aStream
	self isTrivial ifTrue: [^ super printOn: aStream].
	aStream print: self scalars; nextPutAll: self rank printString super! !

!HomModule methodsFor: 'printing' stamp: 'len 7/1/2020 07:52:54'!
printOn: aStream
	self isTrivial ifTrue: [^ super printOn: aStream].
	self isDual ifTrue: [aStream print: self domain; nextPutAll: '*' super. ^ self].
	self isEndomorphisms
		ifTrue:
			[aStream nextPutAll: 'End'; "aStream nextPutAll: self scalars printText sub;" nextPut: $(; print: self domain; nextPut: $)]
		ifFalse: [aStream nextPutAll: 'Hom'; "nextPutAll: self scalars printText sub;" nextPut: $(; print: self domain; nextPut: $,; print: self codomain; nextPut: $)]! !

!MatrixModule methodsFor: 'printing' stamp: 'len 7/16/2020 09:35:55'!
printOn: aStream
	aStream print: self scalars; nextPutAll: (self height printString, '', self width printString) super! !

!Ideal methodsFor: 'printing' stamp: 'len 12/20/2021 17:48:38'!
printOn: aStream
	self isTrivial ifTrue: [^ super printOn: aStream].
	(self scalars isKindOf: ModularIntegerRing)
		ifTrue: [aStream print: self generator; print: self scalars. ^ self].
	self isOne ifTrue: [aStream print: self scalars. ^ self].
	aStream nextPut: $<.
	self printGeneratorsOn: aStream.
	aStream nextPut: $>! !

!RationalIntegerIdeal methodsFor: 'printing' stamp: 'len 12/15/2021 15:26:14'!
printOn: aStream
	(self isTrivial or: [self isAmbient]) ifTrue: [^ super printOn: aStream].
	aStream print: self generator; nextPut: $! !

!DirectSumModule methodsFor: 'printing' stamp: 'len 5/23/2020 07:22:45'!
printOn: aStream
	components do: [:each| aStream print: each] separatedBy: [aStream nextPut: $]! !

!TensorModule methodsFor: 'printing' stamp: 'len 5/23/2020 07:22:26'!
printOn: aStream
	components do: [:each| aStream print: each] separatedBy: [aStream nextPut: $]! !

!Code methodsFor: 'printing' stamp: 'len 7/31/2020 08:46:28'!
printOn: aStream
	aStream nextPut: $[; print: self length; nextPut: $,; print: self rank; nextPut: $,; print: self minimumDistance; nextPut: $].
	aStream isText
		ifTrue: [aStream nextPutAll: self scalars size printString sub]
		ifFalse: [aStream nextPut: $-; print: self scalars size]! !

!Lattice methodsFor: 'printing' stamp: 'len 7/29/2020 06:28:51'!
printOn: aStream
	self isTrivial ifTrue: [aStream print: 0. ^ self].
	aStream nextPut: $<.
	self basis do: [:each| aStream print: each] separatedBy: [aStream nextPutAll: '; '].
	aStream nextPut: $>; nextPutAll: '' sub! !

!Ring methodsFor: 'accessing' stamp: 'len 7/26/2021 18:16:20'!
category
	^ Rings! !

!FractionRing methodsFor: 'printing' stamp: 'len 10/20/2016 11:00'!
printOn: aStream
	aStream nextPutAll: 'Frac('; print: self integers; nextPut: $)! !

!RationalField methodsFor: 'printing' stamp: 'len 5/23/2020 07:41:18'!
printOn: aStream
	aStream nextPut: $! !

!RationalFunctionField methodsFor: 'printing' stamp: 'len 10/28/2016 10:36'!
printOn: aStream
	aStream print: self scalars.
	aStream nextPut: $(.
	self integers printIndeterminatesOn: aStream.
	aStream nextPut: $)! !

!AdicField methodsFor: 'printing' stamp: 'len 5/23/2020 09:11:37'!
printOn: aStream
	aStream print: ; nextPutAll: self p printString sub! !

!LaurentSeriesRing methodsFor: 'printing' stamp: 'len 9/22/2018 19:20:53'!
printOn: aStream
	aStream print: self scalars; nextPutAll: '(('.
	self integers printIndeterminatesOn: aStream.
	aStream nextPutAll: '))'! !

!LocalRing methodsFor: 'printing' stamp: 'len 12/18/2016 21:05:06'!
printOn: aStream
	aStream print: self integers; nextPutAll: self maximalIdeal printString sub! !

!OppositeRing methodsFor: 'printing' stamp: 'len 4/26/2021 11:20:22'!
printOn: aStream
	aStream print: opposite; nextPutAll: 'op' super! !

!ProductRing methodsFor: 'printing' stamp: 'len 5/23/2020 07:19:14'!
printOn: aStream
	components do: [:each| aStream print: each] separatedBy: [aStream nextPut: $]! !

!QuotientRing methodsFor: 'printing' stamp: 'len 7/3/2019 16:51:46'!
printOn: aStream
	self isTrivial ifTrue: [aStream nextPutAll: '{0}'. ^ self].
	(self base printString includes: $/)
		ifTrue: [aStream nextPut: $(; print: self base; nextPut: $)]
		ifFalse: [aStream print: self base].
	aStream nextPut: $/; print: self relations! !

!ModularIntegerRing methodsFor: 'printing' stamp: 'len 7/3/2019 16:51:53'!
printOn: aStream
	self isTrivial ifTrue: [aStream nextPutAll: '{0}'. ^ self].
	aStream print: self base; nextPut: $/; print: self modulus; print: self base! !

!PrimePowerRing methodsFor: 'printing' stamp: 'len 5/21/2018 04:31:00'!
printOn: aStream
	aStream print: self base; nextPut: $/; print: self p; nextPutAll: self exponent printString super; print: self base! !

!PrimeField methodsFor: 'printing' stamp: 'len 5/23/2020 07:40:14'!
printOn: aStream
	aStream nextPut: $F; nextPutAll: self modulus printString sub! !

!AffineAlgebra methodsFor: 'printing' stamp: 'len 7/16/2021 10:10:33'!
printOn: aStream
	self isSimpleExtension
		ifTrue: [aStream print: self scalars; nextPut: $(; print: self modulus; nextPut: $)]
		ifFalse: [super printOn: aStream]! !

!GaloisRing methodsFor: 'printing' stamp: 'len 5/21/2018 07:20:18'!
printOn: aStream
	aStream nextPutAll: 'GR('; print: self scalars p; nextPutAll: self scalars exponent printString super; nextPut: $,; print: self degree; nextPut: $)! !

!GaloisField methodsFor: 'printing' stamp: 'len 5/23/2020 07:36:41'!
printOn: aStream
	aStream nextPut: $F; nextPutAll: self size printString sub
"	aStream nextPutAll: 'GF('; print: self characteristic; nextPutAll: self degree printString super; nextPut: $)"! !

!QuasiGaloisRing methodsFor: 'printing' stamp: 'len 5/9/2019 09:53:57'!
printOn: aStream
	aStream nextPutAll: 'A('; print: self scalars p; nextPutAll: self scalars degree printString super; nextPut: $,; print: self degree; nextPut: $)! !

!LaurentPolynomialRing methodsFor: 'as yet unclassified' stamp: 'len 1/15/2022 17:18:36'!
printOn: aStream
	aStream print: self scalars; nextPut: $[.
	self printIndeterminatesOn: aStream.
	aStream nextPut: $]! !

!CyclotomicField methodsFor: 'printing' stamp: 'len 5/23/2020 07:18:16'!
printOn: aStream
	aStream print: self scalars; nextPut: $(; nextPut: $; nextPutAll: self order printString sub; nextPut: $)! !

!QuadraticField methodsFor: 'printing' stamp: 'len 12/23/2016 16:31:16'!
printOn: aStream
	aStream print: self scalars; nextPut: $(; print: self x; nextPut: $)! !

!RationalIntegerRing methodsFor: 'printing' stamp: 'len 5/23/2020 07:41:41'!
printOn: aStream
	aStream nextPut: $! !

!PolynomialRing methodsFor: 'printing' stamp: 'len 2/12/2017 06:49:02'!
printOn: aStream
	aStream print: self scalars; nextPut: $[.
	self printIndeterminatesOn: aStream.
	aStream nextPut: $].
	self ordering isLocal ifTrue: [aStream nextPutAll: self maximalIdeal printText sub]! !

!Algebra methodsFor: 'printing' stamp: 'len 7/7/2020 06:45:00'!
printOn: aStream
	self isAmbient ifTrue: [aStream print: self asModule. ^ self].
	self isTrivial ifTrue: [aStream print: 0. ^ self].
	aStream nextPut: $<.
	self generators do: [:each| aStream print: each] separatedBy: [aStream nextPutAll: '; '].
	aStream nextPut: $>! !

!CliffordAlgebra methodsFor: 'printing' stamp: 'len 7/28/2020 11:00:38'!
printOn: aStream
	aStream
		nextPutAll: (self isExteriorAlgebra ifTrue: ['/\'] ifFalse: ['Cl']);
		nextPut: $(; print: self space; nextPutAll: ', '; print: self quadraticForm; nextPut: $)! !

!MatrixAlgebra methodsFor: 'printing' stamp: 'len 7/15/2020 06:53:54'!
printOn: aStream
	aStream nextPutAll: 'M', self degree printString sub, '('; print: self scalars; nextPut: $)! !

!GroupAlgebra methodsFor: 'printing' stamp: 'len 8/7/2016 08:38'!
printOn: aStream
	aStream print: self scalars; nextPut: $[; print: self group; nextPut: $]! !

!QuaternionAlgebra methodsFor: 'printing' stamp: 'len 6/11/2020 19:16:16'!
printOn: aStream
	aStream print: self invariants; nextPutAll: self scalars printString sub! !

!MaximalOrder methodsFor: 'printing' stamp: 'len 7/15/2021 16:51:39'!
printOn: aStream
	aStream nextPutAll: 'O' italic; nextPut: $(; print: self fractions; nextPut: $)! !

!CyclotomicRing methodsFor: 'printing' stamp: 'len 7/10/2021 11:36:14'!
printOn: aStream
	aStream print: ; nextPut: $[; print: self fractions x; nextPut: $]! !

!QuadraticRing methodsFor: 'printing' stamp: 'len 7/10/2021 11:37:11'!
printOn: aStream
	| K a |
	K _ self fractions.
	a _ K d \\ 4 = 1 ifTrue: [K x + K one / (K one * 2)] ifFalse: [K x].
	aStream print: ; nextPut: $[; print: a; nextPut: $]! !

!ComplexField methodsFor: 'printing' stamp: 'len 5/23/2020 07:34:10'!
printOn: aStream
	aStream nextPut: $! !

!RealField methodsFor: 'printing' stamp: 'len 5/23/2020 07:41:48'!
printOn: aStream
	aStream nextPut: $! !

!AdicRing methodsFor: 'printing' stamp: 'len 5/23/2020 08:55:51'!
printOn: aStream
	aStream print: ; nextPutAll: self p printString sub! !

!PowerSeriesRing methodsFor: 'printing' stamp: 'len 9/22/2018 19:20:17'!
printOn: aStream
	aStream print: self scalars; nextPutAll: '[['.
	self printIndeterminatesOn: aStream.
	aStream nextPutAll: ']]'! !

!PuiseuxSeriesRing methodsFor: 'as yet unclassified' stamp: 'len 7/10/2021 18:13:49'!
printOn: aStream
	aStream print: self scalars; nextPutAll: '<<'.
	self integers printIndeterminatesOn: aStream.
	aStream nextPutAll: '>>'! !

!FreeAlgebra methodsFor: 'printing' stamp: 'len 1/10/2018 12:24:54'!
printOn: aStream
	aStream print: scalars.
	aStream nextPut: $<.
	self indeterminates
		do: [:i| aStream print: (self x: i)]
		separatedBy: [aStream nextPut: $,].
	aStream nextPut: $>! !

!DistributiveAlgebra methodsFor: 'printing' stamp: 'len 7/19/2021 06:02:11'!
printOn: aStream
	self isAmbient ifTrue: [aStream print: self asModule. ^ self].
	self isTrivial ifTrue: [aStream print: 0. ^ self].
	aStream nextPut: $<.
	self generators do: [:each| aStream print: each] separatedBy: [aStream nextPutAll: '; '].
	aStream nextPut: $>! !

!OctonionAlgebra methodsFor: 'as yet unclassified' stamp: 'len 4/30/2021 12:09:11'!
printOn: aStream
	aStream nextPutAll: 'O('; print: self scalars; nextPut: $)! !

!Grassmannian methodsFor: 'printing' stamp: 'len 11/10/2016 08:45'!
printOn: aStream
	aStream nextPutAll: 'Gr('; print: rank; nextPut: $,; print: space; nextPut: $)! !

!AffineScheme methodsFor: 'printing' stamp: 'len 1/13/2017 16:02:35'!
printOn: aStream
	aStream nextPutAll: 'Spec '; print: self coordinateRing! !

!AffineSpace methodsFor: 'printing' stamp: 'len 1/1/2017 21:29:19'!
printOn: aStream
	aStream print: self scalars; nextPutAll: self rank printString super! !

!ProjectiveScheme methodsFor: 'printing' stamp: 'len 12/20/2021 12:31:33'!
printOn: aStream
	aStream nextPutAll: 'Proj '; print: self coordinateRing! !

!ProjectivePlaneCurve methodsFor: 'printing' stamp: 'len 12/25/2016 11:57:45'!
printOn: aStream
	aStream print: self polynomial; nextPutAll: ' = 0'! !

!EllipticCurve methodsFor: 'printing' stamp: 'len 12/11/2016 20:43:15'!
printOn: aStream
	aStream "nextPutAll: 'E : ';" print: self equation! !

!ProjectiveSpace methodsFor: 'printing' stamp: 'len 5/23/2020 07:23:08'!
printOn: aStream
	aStream nextPut: $; nextPutAll: (self rank - 1) printString super; print: self scalars! !

!CellComplex methodsFor: 'printing' stamp: 'len 2/18/2017 21:21:19'!
printOn: aStream
	aStream nextPut: $<.
	self do: [:each| aStream print: each] separatedBy: [aStream nextPut: $,].
	aStream nextPut: $>! !

!SimplicialComplex methodsFor: 'printing' stamp: 'len 2/18/2017 21:21:41'!
printOn: aStream
	aStream nextPut: $<.
	self facets do: [:each| aStream print: each] separatedBy: [aStream nextPut: $,].
	aStream nextPut: $>! !

!UpperHalfPlane methodsFor: 'printing' stamp: 'len 5/23/2020 07:42:50'!
printOn: aStream
	aStream nextPut: $H! !

!ChainComplex methodsFor: 'operations' stamp: 'len 11/4/2020 12:20:07'!
>> n
	"Answer the complex with degrees shifted by n."
	^ self class differentials: differentials * (-1^n) shift: shift + n! !

!ChainComplex methodsFor: 'printing' stamp: 'len 11/4/2020 12:32:26'!
printOn: aStream
	self isTrivial ifTrue: [aStream print: 0. ^ self].
	aStream print: differentials last codomain.
	differentials reverseDo: [:each| aStream nextPutAll: '  '; print: each domain]! !

!Sheaf methodsFor: 'printing' stamp: 'len 12/13/2021 18:08:57'!
printOn: aStream
	aStream print: self asModule! !

!Morphism methodsFor: 'accessing' stamp: 'len 5/1/2020 18:32:45'!
category
	^ self subclassResponsibility! !

!Morphism methodsFor: 'printing' stamp: 'len 4/22/2020 14:36:36'!
name
	^ self propertyAt: #name ifAbsent: [String streamContents: [:aStream| super printOn: aStream]]! !

!Morphism methodsFor: 'printing' stamp: 'len 5/1/2020 22:17:52'!
printOn: aStream
	(self propertyAt: #isIdentity ifAbsent: [false]) ifTrue: [aStream nextPutAll: 'id'. ^ self].
	aStream nextPutAll: self name; nextPut: $:.
	self arrowPrintOn: aStream! !

!Function methodsFor: 'accessing' stamp: 'len 12/23/2021 13:45:28'!
category
	^ Sets! !

!Function methodsFor: 'printing' stamp: 'len 12/23/2021 15:29:25'!
printOn: aStream
	self propertyAt: #expression ifPresent:
		[:anObject| (anObject isBlock not and: [(anObject isKindOf: Function) not])
			ifTrue: [aStream print: anObject. ^ self]].
	^ super printOn: aStream! !

!Functor methodsFor: 'accessing' stamp: 'len 4/26/2020 17:40:38'!
category
	^ Categories! !

!MonoidMap methodsFor: 'accessing' stamp: 'len 4/26/2020 18:12:50'!
category
	^ Monoids! !

!MonoidMap methodsFor: 'printing' stamp: 'len 1/2/2022 11:23:13'!
printOn: aStream
	aStream nextPut: $(.
	(1 to: self domain rank)
		do: [:i| aStream print: (self value: (self domain x: i))]
		separatedBy: [aStream nextPutAll: ', '].
	aStream nextPut: $)! !

!GroupMap methodsFor: 'accessing' stamp: 'len 4/26/2020 18:08:26'!
category
	^ Groups! !

!BilinearForm methodsFor: 'printing' stamp: 'len 3/18/2018 18:42:28'!
printOn: aStream
	aStream print: self asPolynomial! !

!ModuleMap methodsFor: 'accessing' stamp: 'len 10/26/2020 10:41:24'!
category
	^ self domain scalars Modules! !

!ModuleMap methodsFor: 'printing' stamp: 'len 7/25/2021 12:52:46'!
printOn: aStream
	self isZero ifTrue: [aStream nextPut: $0. ^ self].
	self isIdentity ifTrue: [aStream nextPutAll: 'id'. ^ self].
	self negated isIdentity ifTrue: [aStream nextPutAll: '-id'. ^ self].
	(self isLinearForm and: [self scalars isCommutative]) ifTrue: [aStream print: self asPolynomial. ^ self].
	"If the codomain is tuples, print the linear map as a tuple of linear forms:"
	((self codomain isKindOf: FreeModule) and: [self scalars isCommutative]) ifTrue:
		[aStream nextPut: $(.
		self asMatrix rows
			do: [:each| aStream print: (self domain dual elementAt: each)]
			separatedBy: [aStream nextPutAll: ', '].
		aStream nextPut: $).
		^ self].
	aStream print: self asMatrix
	"Print it as a linear combination of the generators of the codomain:"
"	A _ self domain coordinateRing.
	B _ A polynomialsIn: self codomain coordinates names.
	f _ B zero.
	self asMatrix withIndicesDo: [:each :i :j| f _ (B x: i) * (A x: j) * each + f].
	aStream print: f"! !

!Matrix methodsFor: 'printing' stamp: 'len 8/20/2021 16:01:04'!
printOn: aStream
	| lengths string pad |
	self isTrivial ifTrue: [aStream print: 0. ^ self].
	((self scalars isKindOf: ModularIntegerRing) and: [self scalars modulus <= 16])
		ifTrue: [self rows do: [:each| aStream nextPut: $[; print: each; nextPut: $]] separatedBy: [aStream newLine]. ^ self].
	lengths _ (1 to: self width) collect: [:each| 0].
	self rows do: [:each|
		1 to: each size do: [:i|
			lengths at: i put: ((lengths at: i) max: (each at: i) printText size)]].
	self rows do: [:each|
		aStream nextPut: $[.
		1 to: each size - 1 do: [:i|
			string _ (each at: i) printText.
			pad _ (lengths at: i) - string size.
			pad timesRepeat: [aStream space].
			aStream nextPutAll: string.
			pad + 1 timesRepeat: [aStream space]].
		string _ (each at: each size) printText.
		pad _ (lengths at: each size) - string size.
		pad timesRepeat: [aStream space].
		aStream nextPutAll: string.
		pad timesRepeat: [aStream space].
		aStream nextPut: $]]
			separatedBy: [aStream newLine]! !

!LatticeMap methodsFor: 'accessing' stamp: 'len 7/29/2020 08:36:30'!
category
	^ Lattices! !

!LatticeMap methodsFor: 'printing' stamp: 'len 7/29/2020 08:40:33'!
printOn: aStream
	aStream print: matrix! !

!QuadraticForm methodsFor: 'printing' stamp: 'len 4/21/2016 00:22'!
printOn: aStream
	aStream print: self asPolynomial! !

!RingMap methodsFor: 'accessing' stamp: 'len 4/26/2020 18:13:13'!
category
	^ Rings! !

!AffineAlgebraMap methodsFor: 'printing' stamp: 'len 1/11/2017 07:55:38'!
printOn: aStream
"	self isIdentity ifTrue: [aStream nextPutAll: 'id'. ^ self].
	self negated isIdentity ifTrue: [aStream nextPutAll: '-id'. ^ self].
	self isZero ifTrue: [aStream nextPut: $0. ^ self].
"	aStream nextPut: $(.
	(1 to: self domain rank)
		do: [:i| aStream print: (self value: (self domain x: i))]
		separatedBy: [aStream nextPutAll: ', '].
	aStream nextPut: $)! !

!RationalMap methodsFor: 'printing' stamp: 'len 12/28/2016 21:55:32'!
printOn: aStream 
	self codomain isProjective
		ifTrue:
			[aStream nextPut: $[.
			self representatives do: [:each| aStream print: each] separatedBy: [aStream nextPut: $:].
			aStream nextPut: $]]
		ifFalse:
			[aStream nextPut: $(.
			self representatives do: [:each| aStream print: each] separatedBy: [aStream nextPutAll: ', '].
			aStream nextPut: $)]! !

!LinearFractionalMap methodsFor: 'printing' stamp: 'len 5/23/2020 09:31:47'!
printOn: aStream
	| z denominator numerator |
	z _ ( polynomialsIn: #(z)) x.
	c isZero ifTrue: [aStream print: z * a + b / d. ^ self].
	numerator _ z * a + b.
	(a = 0 or: [b = 0])
		ifTrue: [aStream print: numerator]
		ifFalse: [aStream nextPut: $(; print: numerator; nextPut: $)].
	aStream nextPut: $/.
	denominator _ z * c + d.
	(c = 0 or: [d = 0])
		ifTrue: [aStream print: denominator]
		ifFalse: [aStream nextPut: $(; print: denominator; nextPut: $)]! !

!Sequence methodsFor: 'operations' stamp: 'len 6/3/2019 17:29:54'!
>> anInteger
	^ self species to: self codomain evaluating: [:i| self at: i-anInteger ifAbsent: [self codomain zero]]! !

!Sequence methodsFor: 'printing' stamp: 'len 6/4/2019 05:30:08'!
printOn: aStream
	(1 to: self printLimit) do: [:i| aStream print: (self at: i)] separatedBy: [aStream nextPutAll:', ' ].
	aStream nextPutAll: '...'! !

!CFiniteSequence methodsFor: 'operations' stamp: 'len 6/1/2019 08:30:15'!
>> anInteger
	anInteger > 0 ifTrue: [^ super >> anInteger].
	^ self class to: self codomain evaluating: (super >> anInteger) maxOrder: self order squared! !

!SimplicialMap methodsFor: 'accessing' stamp: 'len 10/26/2020 13:49:33'!
category
	^ SCpx! !

!SimplicialMap methodsFor: 'printing' stamp: 'len 2/20/2017 15:23:39'!
printOn: aStream
	self domain vertices do: [:each| aStream print: each -> (map at: each)] separatedBy: [aStream nextPutAll: ', ']! !

!EisensteinSeries methodsFor: 'as yet unclassified' stamp: 'len 12/6/2016 20:41:01'!
printOn: aStream
	aStream nextPutAll: 'G', weight printString sub! !

!ChainMap methodsFor: 'accessing' stamp: 'len 10/30/2020 11:06:39'!
category
	^ components anyOne category ChainComplexes! !

!ChainMap methodsFor: 'printing' stamp: 'len 4/22/2020 19:20:53'!
printOn: aStream
	self isZero ifTrue: [aStream print: 0. ^ self].
	super printOn: aStream! !

!CochainMap methodsFor: 'accessing' stamp: 'len 10/30/2020 11:28:47'!
category
	^ opposite category opposite! !

!CochainMap methodsFor: 'printing' stamp: 'len 10/30/2020 11:37:20'!
printOn: aStream
	self isZero ifTrue: [aStream print: 0. ^ self].
	super printOn: aStream! !

!AffinePoint methodsFor: 'printing' stamp: 'len 12/30/2016 14:37:32'!
printOn: aStream
	aStream print: self coordinates! !

!ProjectivePoint methodsFor: 'printing' stamp: 'len 2/10/2017 09:55:27'!
printOn: aStream
	aStream nextPut: $[.
	self printInsidesOn: aStream.
	aStream nextPut: $]! !

!ProjectiveLinePoint methodsFor: 'printing' stamp: 'len 5/23/2020 07:40:50'!
printOn: aStream
	self isInfinity
		ifTrue: [aStream nextPut: $]
		ifFalse: [self scalars isField ifTrue: [aStream print: self value] ifFalse: [super printOn: aStream]]! !

!EllipticCurvePoint methodsFor: 'printing' stamp: 'len 11/11/2016 05:21'!
printOn: aStream
	self isZero
		ifTrue: [aStream nextPutAll: 'O' italic]
		ifFalse: [aStream nextPut: $(; print: self x; nextPut: $,; print: self y; nextPut: $)]! !

!SheafMap methodsFor: 'printing' stamp: 'len 12/13/2021 18:14:29'!
printOn: aStream
	aStream print: self asModuleMap! !

!MonomialOrdering methodsFor: 'printing' stamp: 'len 3/6/2021 12:54:01'!
printOn: aStream
	| M |
	self type isNil
		ifTrue: [super printOn: aStream]
		ifFalse: [aStream nextPutAll: self type].
	M _ FreeAbelianMonoid new: indeterminates max.
	aStream nextPut: $[.
	indeterminates do: [:i| aStream print: (M x: i)] separatedBy: [aStream nextPut: $,].
	aStream nextPut: $]! !

!BlockMonomialOrdering methodsFor: 'printing' stamp: 'len 3/4/2021 15:58:54'!
printOn: aStream
	blocks do: [:each| aStream print: each] separatedBy: [aStream nextPutAll: '  ']! !

!WeightedMonomialOrdering methodsFor: 'printing' stamp: 'len 7/4/2016 06:26'!
printOn: aStream
	super printOn: aStream.
	aStream space.
	self weights do: [:each| aStream print: each] separatedBy: [aStream space]! !

!Monomial methodsFor: 'copying' stamp: 'len 11/21/2016 11:07:43'!
postCopy
	exponents _ exponents copy.
	degree _ nil! !

!Monomial methodsFor: 'printing' stamp: 'len 1/15/2022 17:44:04'!
printOn: aStream
	self degree = 0 ifTrue: [aStream print: 1. ^ self].
	(self ordering indeterminates select: [:i| (self at: i) ~= 0])
		do: [:i|
			self printIndeterminate: i on: aStream.
			self printExponent: (self at: i) on: aStream]! !

!Word methodsFor: 'printing' stamp: 'len 5/23/2020 07:43:18'!
printOn: aStream
	self isEmpty ifTrue: [aStream nextPut: $. ^ self].
	self do: [:each :exp|
		exp = 0 ifFalse:
			[| x |
			x _ self parent names ifNil: [each] ifNotNil: [:names| names at: each ifAbsent: [each]].
			self printLetter: x on: aStream.
			self printExponent: exp on: aStream]]! !

!Coset methodsFor: 'printing' stamp: 'len 10/17/2020 20:14:54'!
printOn: aStream
	aStream nextPut: $[; print: representative; nextPut: $]! !

!DirectProductGroupElement methodsFor: 'printing' stamp: 'len 4/25/2020 06:38:47'!
printOn: aStream
	aStream print: components! !

!OppositeGroupElement methodsFor: 'printing' stamp: 'len 5/9/2019 08:05:24'!
printOn: aStream
	opposite printOn: aStream! !

!Permutation methodsFor: 'printing' stamp: 'len 5/1/2019 02:47:04'!
printOn: aStream
	"Print a representation of the receiver on the stream aStream."

	self isIdentity ifTrue: [aStream nextPutAll: 'id'. ^ self].
	self cyclesDo: [:cycle|
		aStream nextPut: $(.
		cycle do: [:i| | element |
			element _ parent indexToSpace at: i.
			element isSymbol
				ifTrue: [aStream nextPutAll: element]
				ifFalse: [aStream print: element]] separatedBy: [aStream space].
		aStream nextPut: $)]! !

!FractionalIdeal methodsFor: 'printing' stamp: 'len 5/3/2020 21:08:33'!
printOn: aStream
	aStream nextPut: $<.
	(self generators asSortedCollection: [:a :b| a printString <= b printString])
		do: [:each| aStream print: each] separatedBy: [aStream nextPutAll: ', '].
	aStream nextPut: $>! !

!SemidirectProductElement methodsFor: 'printing' stamp: 'len 2/12/2016 06:10'!
printOn: aStream
	aStream nextPut: $(; print: left; nextPutAll: ', '; print: right; nextPut: $)! !

!ModuleCoset methodsFor: 'printing' stamp: 'len 3/18/2020 17:22:25'!
printOn: aStream
	aStream print: representative! !

!Tuple methodsFor: 'printing' stamp: 'len 7/24/2020 12:08:54'!
printOn: aStream
"	parent propertyAt: #names ifPresent: [:names| ^ self printOn: aStream withNames: names]."
	aStream nextPut: $(.
	self printCoefficientsOn: aStream.
	aStream nextPut: $)! !

!DenseTuple methodsFor: 'operations' stamp: 'len 7/15/2021 12:42:43'!
>> anInteger
	| newElements zero n |
	anInteger == 0 ifTrue: [^ self].
	newElements _ Array new: self size.
	zero _ (self at: 1) - (self at: 1).
	n _ self size min: anInteger max: self size negated.
	n > 0
		ifTrue:
			[1 to: n do: [:i| newElements at: i put: zero].
			1+n to: self size do: [:i| newElements at: i put: (self at: i-n)]]
		ifFalse:
			[self size + n + 1 to: self size do: [:i| newElements at: i put: zero].
			1 to: self size + n do: [ :i | newElements at: i put: (self at: i-n)]].
	^ self class components: newElements parent: parent! !

!SparseTuple methodsFor: 'copying' stamp: 'len 7/18/2020 06:12:12'!
postCopy
	components _ components copy! !

!BitTuple methodsFor: 'operations' stamp: 'len 7/15/2021 12:42:04'!
>> anInteger
	^ self class bits: (bits bitShift: anInteger) parent: parent! !

!BitTuple methodsFor: 'printing' stamp: 'len 3/28/2016 04:52'!
printOn: aStream
	1 to: self size do: [:i| aStream print: (self at: i)]! !

!ModularTuple methodsFor: 'printing' stamp: 'len 5/18/2020 13:47:12'!
printOn: aStream
	self modulus > 16 ifTrue: [^ super printOn: aStream].
	representatives do: [:each| each printOn: aStream base: 16]! !

!ModuleTuple methodsFor: 'printing' stamp: 'len 4/25/2020 07:18:35'!
printOn: aStream
	aStream print: components! !

!Sum methodsFor: 'copying' stamp: 'len 11/18/2016 17:34:33'!
postCopy
	coefficients _ coefficients copy! !

!Sum methodsFor: 'printing' stamp: 'len 1/10/2018 21:04:41'!
printOn: aStream
	| elements c |
	self isZero ifTrue: [aStream nextPutAll: '0'. ^ self].
	elements _ self keys asSortedCollection: [:a :b| a printString <= b printString].
	c _ self at: elements first.
	c printString first = $-
		ifTrue: [c _ c negated. aStream nextPut: $-].
	c ~= self scalars one ifTrue: [self printCoefficient: c on: aStream].
	self printLiteral: elements first on: aStream.
	elements allButFirst do: [:each|
		c _ self at: each.
		c printString first = $-
			ifTrue: [aStream nextPutAll: ' - '. c _ c negated]
			ifFalse: [aStream nextPutAll: ' + '].
		c ~= c one ifTrue: [self printCoefficient: c on: aStream].
		self printLiteral: each on: aStream]! !

!TupleMonomial methodsFor: 'printing' stamp: 'len 7/27/2021 13:19:23'!
printOn: aStream
	monomial isIdentity ifFalse: [aStream print: monomial].
	aStream nextPutAll: '', position printString sub! !

!POTOrdering methodsFor: 'printing' stamp: 'len 7/28/2021 11:54:21'!
printOn: aStream
	aStream nextPutAll: 'POT'! !

!TOPOrdering methodsFor: 'printing' stamp: 'len 7/28/2021 11:54:12'!
printOn: aStream
	aStream nextPutAll: 'TOP'! !

!CochainComplex methodsFor: 'operations' stamp: 'len 1/3/2022 10:55:07'!
>> n
	"Answer the complex with degrees shifted by n."
	^ (opposite << n) opposite! !

!CochainComplex methodsFor: 'printing' stamp: 'len 11/4/2020 12:32:24'!
printOn: aStream
	self isTrivial ifTrue: [aStream print: 0. ^ self].
	aStream print: opposite differentials first domain.
	opposite differentials do: [:each| aStream nextPutAll: '  '; print: each codomain]! !

!LatticeElement methodsFor: 'printing' stamp: 'len 7/8/2020 19:13:32'!
printOn: aStream
	aStream print: self asVector! !

!Division methodsFor: 'printing' stamp: 'len 5/15/2020 06:12:33'!
printOn: aStream
	aStream
		print: self dividend;
		nextPutAll: ' = ';
		printWithParenthesis: self divisor;
		nextPutAll: '*';
		printWithParenthesis: self quotient;
		nextPutAll: ' + ';
		printWithParenthesis: self remainder.
	self verify ifFalse: [aStream nextPutAll: ' (broken)']! !

!OppositeRingElement methodsFor: 'printing' stamp: 'len 4/26/2021 11:21:47'!
printOn: aStream
	opposite printOn: aStream! !

!ProductRingElement methodsFor: 'printing' stamp: 'len 4/23/2020 01:41:46'!
printOn: aStream
	aStream print: components! !

!Ratio methodsFor: 'printing' stamp: 'len 7/16/2019 16:40:18'!
printOn: aStream
	| string |
	self isIntegral ifTrue: [aStream print: numerator. ^ self].
	aStream print: numerator; nextPutAll: ' / '.
	string _ denominator printString.
	((string includes: $+) or: [string includes: $-])
		ifTrue: [aStream nextPut: $(; print: denominator; nextPut: $)]
		ifFalse: [aStream print: denominator]! !

!Germ methodsFor: 'printing' stamp: 'len 12/27/2021 07:51:55'!
printOn: aStream
	super printOn: aStream
"	| n u |
	(n _ self valuation) isZero ifTrue: [aStream print: fraction. ^ self].
	u _ self unit.
	(u numerator printString first = $-) ifTrue: [u _ u negated. aStream nextPut: $-].
	n ~= 0 ifTrue:
		[aStream print: parent p.
		n ~= 1 ifTrue: [aStream nextPutAll: n printString super].
		u ~= parent fractions one ifTrue: [aStream nextPut: Character dot]].
	u ~= parent fractions one ifTrue:
		[((u numerator printString includesAnyOf: ' +-') and: [(u printString beginsWith: '(') not])
			ifTrue: [aStream nextPut: $(; print: u; nextPut: $)]
			ifFalse: [aStream print: u]]"! !

!Rational methodsFor: 'printing' stamp: 'len 7/20/2019 05:51:00'!
printOn: aStream
	self asFraction printOn: aStream
"	self isIntegral ifTrue: [aStream print: numerator. ^ self].
	aStream nextPutAll: numerator printString super; nextPut: $/; nextPutAll: denominator printString sub"! !

!RationalFunction methodsFor: 'printing' stamp: 'len 4/7/2018 01:08:35'!
printOn: aStream
	denominator = denominator one ifTrue: [aStream print: numerator. ^ self].
	numerator terms size > 1
		ifTrue: [aStream nextPut: $(; print: numerator; nextPut: $)]
		ifFalse: [aStream print: numerator].
	aStream nextPutAll: ' / '.
	denominator terms size > 1
		ifTrue: [aStream nextPut: $(; print: denominator; nextPut: $)]
		ifFalse: [aStream print: denominator]! !

!Residue methodsFor: 'printing' stamp: 'len 5/29/2020 07:56:05'!
printOn: aStream
	aStream nextPutAll: representative printText italic! !

!LaurentPolynomial methodsFor: 'as yet unclassified' stamp: 'len 1/15/2022 18:01:25'!
printOn: aStream
	| monomials leadingMonomial c |
	representative isConstant ifTrue: [aStream print: representative leadingCoefficient. ^ self].
	monomials _ representative monomials asSortedCollection reversed.
	c _ representative at: (leadingMonomial _ monomials first).
	(c printString first = $- or: [c isReal and: [c negative]])
		ifTrue: [c _ c negated. aStream nextPut: $-].
	self printCoefficient: c monomial: leadingMonomial on: aStream.
	monomials allButFirst do: [:m|
		c _ representative at: m.
		(c printString first = $- or: [c isReal and: [c negative]])
			ifTrue: [aStream nextPutAll: ' - '. c _ c negated]
			ifFalse: [aStream nextPutAll: ' + '].
		self printCoefficient: c monomial: m on: aStream]! !

!GaussianRational methodsFor: 'printing' stamp: 'len 1/4/2022 14:51:34'!
printOn: aStream
	(self real ~= 0 or: [self imaginary = 0])
		ifTrue:
			[aStream print: self real.
			self imaginary = 0
				ifFalse:
					[aStream space.
					self imaginary positive
						ifTrue: [aStream nextPut: $+]
						ifFalse: [aStream nextPut: $-].
					aStream space.
					self imaginary abs = 1 ifFalse: [aStream print: self imaginary abs].
					aStream nextPutAll: 'i' italic]]
		ifFalse:
			[self imaginary negative
				ifTrue: [aStream nextPut: $-].
			self imaginary abs = 1 ifFalse: [aStream print: self imaginary abs].
			aStream nextPutAll: 'i' italic]! !

!Polynomial methodsFor: 'printing' stamp: 'len 1/2/2022 10:45:59'!
printOn: aStream
	| monomials leadingMonomial c |
	(self scalars isKindOf: ModularIntegerRing)
		ifTrue: [aStream print: self lift. ^ self].
	self isConstant ifTrue: [aStream print: self leadingCoefficient. ^ self].
	monomials _ self monomials asSortedCollection reversed.
	c _ self at: (leadingMonomial _ monomials first).
	(c printString first = $- or: [c isReal and: [c negative]])
		ifTrue: [c _ c negated. aStream nextPut: $-].
	self printCoefficient: c monomial: leadingMonomial on: aStream.
	monomials allButFirst do: [:m|
		c _ self at: m.
		(c printString first = $- or: [c isReal and: [c negative]])
			ifTrue: [aStream nextPutAll: ' - '. c _ c negated]
			ifFalse: [aStream nextPutAll: ' + '].
		self printCoefficient: c monomial: m on: aStream]! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 7/9/2016 03:05'!
>> anInteger
	^ self << anInteger negated! !

!AlgebraElement methodsFor: 'printing' stamp: 'len 7/14/2020 09:54:14'!
printOn: aStream
	aStream print: moduleElement! !

!Multivector methodsFor: 'printing' stamp: 'len 7/5/2020 08:52:03'!
printOn: aStream
	aStream print: self asPolynomial! !

!Quaternion methodsFor: 'printing' stamp: 'len 7/14/2020 10:04:07'!
printOn: aStream
	| P f |
	P _ self parent scalars polynomialsIn: #(i j k) ordering: #llex.
	f _ P constant: (moduleElement at: 1).
	2 to: 4 do: [:i| f _ (P x: i-1) * (moduleElement at: i) + f].
	f printOn: aStream! !

!AlgebraicInteger methodsFor: 'printing' stamp: 'len 7/10/2021 11:35:53'!
printOn: aStream
	aStream print: parent fractions !! self! !

!AdicInteger methodsFor: 'operations' stamp: 'len 8/11/2019 11:23:32'!
>> anInteger
	anInteger >= 0 ifTrue: [^ parent representative: representative * (parent power: anInteger) precision: precision + anInteger].
	^ parent representative: representative // (parent power: anInteger negated) precision: precision! !

!AdicInteger methodsFor: 'printing' stamp: 'len 8/11/2019 08:45:01'!
printOn: aStream
	self printOn: aStream shifted: 0! !

!AdicNumber methodsFor: 'printing' stamp: 'len 5/8/2020 17:53:47'!
printOn: aStream
	unitPart printOn: aStream shifted: valuation! !

!LaurentSeries methodsFor: 'printing' stamp: 'len 5/8/2020 17:47:59'!
printOn: aStream
	unitPart printOn: aStream shifted: valuation! !

!PowerSeries methodsFor: 'printing' stamp: 'len 7/27/2021 11:36:43'!
printOn: aStream
	aStream print: (parent base orderedBy: #llex) !! representative.
	precision isInfinite ifTrue: [^ self].
	aStream nextPutAll: ' + ', 'O' italic, '('.
	parent isUnivariate
		ifTrue: [aStream print: parent base x ^ precision]
		ifFalse: [aStream print: parent base * parent base generators; nextPutAll: precision printString super].
	aStream nextPut: $)! !

!RelaxedAdicInteger methodsFor: 'accessing' stamp: 'len 6/3/2019 17:28:33'!
>> anInteger
	"Multiply the receiver by p^anInteger shifting the digits by anInteger places."
	^ parent digits: digits >> anInteger! !

!RelaxedAdicInteger methodsFor: 'printing' stamp: 'len 6/2/2019 10:09:25'!
printOn: aStream
	self printOn: aStream withPowersShiftedBy: 0! !

!RelaxedAdicNumber methodsFor: 'printing' stamp: 'len 6/3/2019 18:28:16'!
printOn: aStream
	unit printOn: aStream withPowersShiftedBy: valuation negated! !

!RelaxedPowerSeries methodsFor: 'printing' stamp: 'len 6/6/2019 13:22:39'!
printOn: aStream
	| P f n |
	n _ coefficients printLimit.
	P _ parent base.
	f _ (P coefficients: (coefficients first: n)) orderedBy: #llex.
	aStream print: f; nextPutAll: ' + ', 'O' italic, '('; print: P x ^ (n+1); nextPut: $)! !

!ComplexBox methodsFor: 'printing' stamp: 'len 1/11/2016 02:57'!
printOn: aStream
	aStream print: real; nextPutAll: ' + '; print: imaginary; nextPut: $i! !

!ComplexDisk methodsFor: 'printing' stamp: 'len 6/5/2016 20:42'!
printOn: aStream
	aStream nextPutAll: 'D('; print: self center; nextPut: $,; print: self radius; nextPut: $)! !

!MultivariateDivision methodsFor: 'printing' stamp: 'len 1/24/98 12:49'!
printOn: aStream
	"Print a representation of the receiver on the stream aStream."

	aStream print: self dividend; nextPutAll: ' = '.
	(1 to: self divisors size) do: [ :each |
		aStream
			nextPut: $(; print: (self quotients at: each); nextPut: $);
			nextPut: $(; print: (self divisors at: each); nextPut: $);
			nextPutAll: ' + '].
	aStream print: self remainder! !

!PseudoDivision methodsFor: 'printing' stamp: 'len 7/8/2016 05:47'!
printOn: aStream
	"Print a representation of the receiver on the stream aStream."

	aStream
		print: (self divisor leadingCoefficient ^ self delta);
		nextPut: $(;
		print: self dividend;
		nextPutAll: ') = (';
		print: self quotient;
		nextPutAll: ')(';
		print: self divisor;
		nextPutAll: ') + ';
		print: self remainder! !

!RealBox methodsFor: 'printing' stamp: 'len 5/23/2020 07:19:23'!
printOn: aStream
	components do: [:each| aStream print: each] separatedBy: [aStream nextPut: $]! !

!RealInterval methodsFor: 'printing' stamp: 'len 12/13/97 03:23'!
printOn: aStream
	"Print a representation of the receiver in the stream aStream."

	aStream
		nextPut: (self isLeftOpen ifTrue: [ $( ] ifFalse: [ $[ ]);
		print: self left;
		nextPutAll: ', ';
		print: self right;
		nextPut: (self isRightOpen ifTrue: [ $) ] ifFalse: [ $] ])! !

!DistributiveAlgebraElement methodsFor: 'printing' stamp: 'len 7/19/2021 06:13:00'!
printOn: aStream
	aStream print: moduleElement! !

!ComplexAlgebraicNumber methodsFor: 'printing' stamp: 'len 1/11/2016 06:44'!
printOn: aStream
	self printOn: aStream base: 10! !

!SchemePoint methodsFor: 'as yet unclassified' stamp: 'len 12/21/2021 20:12:54'!
printOn: aStream
	ideal printOn: aStream! !

!ExtendedEuclid methodsFor: 'printing' stamp: 'len 4/18/2018 06:23:18'!
printOn: aStream
	(1 to: elements size)
		do: [:i| aStream print: (elements at: i); nextPut: $*; print: (self bezout at: i)]
		separatedBy: [aStream nextPutAll: ' + '].
	aStream nextPutAll: ' = '; print: self gcd.
	self verify ifFalse: [aStream nextPutAll: ' (broken)'].
	self verifyMinimal ifFalse: [aStream nextPutAll: ' (not minimal)']! !

!DirichletSeries methodsFor: 'printing' stamp: 'len 6/4/2019 05:32:31'!
printOn: aStream
	| c n first |
	first _ true.
	1 to: coefficients printLimit do: [:i|
		c _ coefficients at: i.
		c isZero
			ifFalse:
				[n _ i.
				c printString first = $-
					ifTrue: [first ifFalse: [aStream nextPutAll: ' - '].
								c _ c negated]
					ifFalse: [first ifFalse: [aStream nextPutAll: ' + ']].
				c printOn: aStream. first _ false.
				n > 1 ifTrue: [aStream nextPut: $/; print: n; nextPutAll: 'x' super]]].
	aStream nextPutAll: ' + ...'! !

!YoungDiagram methodsFor: 'as yet unclassified' stamp: 'len 5/17/2020 12:36:48'!
printOn: aStream
	self shape do: [:k|
		aStream nextPut: $[.
		(1 to: k) do: [:ignore| aStream space] separatedBy: [aStream nextPut: $|].
		aStream nextPut: $]] separatedBy: [aStream newLine; space]! !

!WeierstrassEquation methodsFor: 'printing' stamp: 'len 2/12/2017 06:05:00'!
printOn: aStream
	| P x y |
	P _ self scalars polynomialsIn: #(x y) ordering: (MonomialOrdering glex: #(2 1)).
	x _ P x.
	y _ P y.
	aStream print: y^2 + (x*y * self a1) + (y * self a3).
	aStream
		nextPutAll: ' = ';
		print: (x^3) + (x^2 * self a2) + (x * self a4) + self a6! !

!RootSystem methodsFor: 'printing' stamp: 'len 2/11/2016 01:34'!
printOn: aStream
	aStream nextPut: ${.
	roots do: [:each| aStream print: each] separatedBy: [aStream nextPut: $,].
	aStream nextPut: $}! !

!FareySymbol methodsFor: 'as yet unclassified' stamp: 'len 12/20/2016 21:30:43'!
printOn: aStream
	| n |
	n _ self size.
	aStream print: Infinity negative.
	1 to: n do: [:i|
		aStream nextPutAll: ' (', (self pairingAt: i) asString, ') '; print: (self numeratorAt: i); nextPut: $/; print: (self denominatorAt: i)].
	aStream nextPutAll: ' (', (self pairingAt: n+1) asString, ') '; print: Infinity positive! !

!RealAlgebraicNumber methodsFor: 'accessing' stamp: 'len 4/29/2018 18:45:52'!
denominator
	"The denominator of an algebraic number is the smallest positive integer that multiplied by the algebraic number is an algebraic integer."
	^ minimalPolynomial coefficients inject: 1 into: [:result :each| result lcm: each denominator]! !

!RealAlgebraicNumber methodsFor: 'accessing' stamp: 'len 4/29/2018 17:32:57'!
minimalPolynomial
	^ minimalPolynomial! !

!RealAlgebraicNumber methodsFor: 'accessing' stamp: 'len 5/23/2020 09:31:27'!
parent
	^ ! !

!RealAlgebraicNumber methodsFor: 'approximating' stamp: 'len 6/4/2016 22:22'!
absoluteError
	"Answer the maximun current error in the rational approximation of the receiver."
	^ bounds length / 2! !

!RealAlgebraicNumber methodsFor: 'approximating' stamp: 'len 6/4/2016 21:23'!
approximation
	"Answer the current rational approximation of the receiver."
	^ bounds midpoint! !

!RealAlgebraicNumber methodsFor: 'approximating' stamp: 'len 1/16/2016 06:27'!
bounds
	^ bounds! !

!RealAlgebraicNumber methodsFor: 'approximating' stamp: 'len 6/4/2016 23:06'!
refine
	"Refine the rational interval approximation of the receiver."
	self refineAt: self approximation! !

!RealAlgebraicNumber methodsFor: 'approximating' stamp: 'len 4/29/2018 18:37:00'!
refineAt: aFraction
	"Refine the rational interval approximation of the receiver to one of both (leftBound, aFraction] or (aFraction, rightBound]."
	| sign |
	self rightSign = (sign _ (minimalPolynomial value: aFraction) sign)
		ifTrue: [self rightBound: aFraction; rightSign: sign]
		ifFalse: [self leftBound: aFraction].
	sign = 0 ifTrue: [self leftBound: aFraction. self rightBound: aFraction]! !

!RealAlgebraicNumber methodsFor: 'approximating' stamp: 'len 1/16/2016 07:10'!
refineTo: aNumber
	"Refine the receiver up to get an approximation error < aNumber."
	[self absoluteError >= aNumber] whileTrue: [self refine]! !

!RealAlgebraicNumber methodsFor: 'approximating' stamp: 'len 1/17/2016 07:44'!
refineWith: aRealAlgebraicNumber
	"Refine the rational interval approximation of either the receiver or the argument, depending on which is less precise at the moment."
	self relativeError > aRealAlgebraicNumber relativeError
		ifTrue: [self refine]
		ifFalse: [aRealAlgebraicNumber refine]! !

!RealAlgebraicNumber methodsFor: 'approximating' stamp: 'len 6/4/2016 23:10'!
relativeError
	"Answer the relative error in the current rational approximation."
	self isZero ifTrue: [^ 0].
	^ self absoluteError / self approximation abs! !

!RealAlgebraicNumber methodsFor: 'arithmetic' stamp: 'len 1/9/2022 08:34:45'!
* aNumber
	| f b |
	aNumber class = self class
		ifFalse: [^ aNumber adaptToRealAlgebraic: self andSend: #*].
	aNumber isZero ifTrue: [^ aNumber].
	self isZero ifTrue: [^ self].
	f _ RealRootIsolator on:
		(minimalPolynomial zeroProduct: aNumber minimalPolynomial) squarefreePart.
	[b _ self bounds * aNumber bounds.
	f moreThanOneRootBetween: b left and: b right]
		whileTrue:
			[self refineWith: aNumber].
	^ self class polynomial: f polynomial bounds: b! !

!RealAlgebraicNumber methodsFor: 'arithmetic' stamp: 'len 1/9/2022 08:34:48'!
+ aNumber
	| f b |
	aNumber class = self class
		ifFalse: [^ aNumber adaptToRealAlgebraic: self andSend: #+].
	aNumber isZero ifTrue: [^ self].
	self isZero ifTrue: [^ aNumber].
	f _ RealRootIsolator on:
		(minimalPolynomial zeroAddition: aNumber minimalPolynomial) squarefreePart.
	[b _ self bounds + aNumber bounds.
	f moreThanOneRootBetween: b left and: b right]
		whileTrue:
			[self refineWith: aNumber].
	^ self class polynomial: f polynomial bounds: b! !

!RealAlgebraicNumber methodsFor: 'arithmetic' stamp: 'len 11/9/2015 14:28'!
- anObject
	^ self + anObject negated! !

!RealAlgebraicNumber methodsFor: 'arithmetic' stamp: 'len 11/9/2015 14:29'!
/ anObject
	^ self * anObject reciprocal! !

!RealAlgebraicNumber methodsFor: 'arithmetic' stamp: 'len 1/6/2022 19:40:59'!
inverse
	"Answer the multiplicative inverse of the receiver."
	self isZero ifTrue: [^ InversionError signal: self].
	^ self class
		minimalPolynomial: minimalPolynomial zeroReciprocal
		bounds: bounds reciprocal! !

!RealAlgebraicNumber methodsFor: 'arithmetic' stamp: 'len 4/29/2018 17:27:06'!
negated
	"Answer the additive inverse of the receiver."
	self isZero ifTrue: [^ self].
	^ self class
		minimalPolynomial: minimalPolynomial zeroNegation
		bounds: bounds negated! !

!RealAlgebraicNumber methodsFor: 'arithmetic' stamp: 'len 8/12/2019 11:01:53'!
reciprocal
	"Answer the multiplicative inverse of the receiver."
	^ self inverse! !

!RealAlgebraicNumber methodsFor: 'comparing' stamp: 'len 6/4/2016 21:32'!
< anObject
	"Answer whether the receiver is less than the argument."

	anObject class = self class ifFalse: [^ (self - anObject) sign = -1].
	(self = anObject) ifTrue: [^ false].
	[self bounds intersects: anObject bounds] whileTrue: [self refineWith: anObject].
	^ self rightBound < anObject leftBound! !

!RealAlgebraicNumber methodsFor: 'comparing' stamp: 'len 4/29/2018 18:34:58'!
= anObject
	anObject isNumber ifFalse: [^ false].
	self == anObject ifTrue: [^ true].
	anObject class = self class
		ifFalse: [^ anObject adaptToRealAlgebraic: self andSend: #=].
	^ minimalPolynomial = anObject minimalPolynomial and: [bounds intersects: anObject bounds]! !

!RealAlgebraicNumber methodsFor: 'comparing' stamp: 'len 12/13/97 03:56'!
hash
	"Answer the hash value for the receiver."

	^ self truncated hash! !

!RealAlgebraicNumber methodsFor: 'converting' stamp: 'len 4/29/2018 18:39:36'!
adaptToAlgebraic: rcvr andSend: selector
	^ rcvr perform: selector with: (ComplexAlgebraicNumber polynomial: minimalPolynomial approximation: bounds midpoint radius: bounds length / 2)! !

!RealAlgebraicNumber methodsFor: 'converting' stamp: 'len 11/19/2015 21:39'!
adaptToFloat: rcvr andSend: selector
	^ rcvr perform: selector with: self asFloat! !

!RealAlgebraicNumber methodsFor: 'converting' stamp: 'len 11/19/2015 21:40'!
adaptToFraction: rcvr andSend: selector
	^ (self class fromRational: rcvr) perform: selector with: self! !

!RealAlgebraicNumber methodsFor: 'converting' stamp: 'len 3/3/2021 07:32:16'!
adaptToInteger: rcvr andSend: selector
	^ (self class fromRational: rcvr asRational) perform: selector with: self! !

!RealAlgebraicNumber methodsFor: 'converting' stamp: 'len 6/4/2016 23:06'!
asFloat
	"Answer a Float approximation of the receiver."

	self refineTo: 0.000001.
	^ self approximation asFloat! !

!RealAlgebraicNumber methodsFor: 'converting' stamp: 'len 5/23/2020 09:33:01'!
asRational
	"Convert the receiver to Fraction or Integer."
	| alpha |
	self leftBound = self rightBound ifTrue: [^ self leftBound].
	minimalPolynomial degree < 2
		ifTrue:
			[alpha _ minimalPolynomial independentCoefficient negated / minimalPolynomial leadingCoefficient.
			self bounds: (RealInterval open: alpha closed: alpha).
			^ alpha].
	(minimalPolynomial rootsIn: )
		do: [:each|
			(each between: self leftBound and: self rightBound)
				ifTrue: [self bounds: (RealInterval open: each closed: each). ^ each]].
	self error: 'the number is irrational'! !

!RealAlgebraicNumber methodsFor: 'initialization' stamp: 'len 12/17/2021 14:44:26'!
minimalPolynomial: aPolynomial bounds: aRealInterval
	minimalPolynomial _ aPolynomial normalized.
	bounds _ aRealInterval.
	self normalize! !

!RealAlgebraicNumber methodsFor: 'mathematical functions' stamp: 'len 8/8/97 20:54'!
sign
	"Answer 1, -1 or 0, depending on the sign of the receiver."

	^ self leftBound sign! !

!RealAlgebraicNumber methodsFor: 'mathematical functions' stamp: 'len 4/29/2018 18:38:08'!
squareRoot
	self isRational ifFalse: [^ self notYetImplemented].
	self negative ifTrue: [^ self negated squareRoot i].
	self isZero ifTrue: [^ self].
	^ self class
		polynomial: minimalPolynomial zeroSquareRoot "is it minimal?"
 		bounds: (RealInterval open: 0 open: (self asRational max: 1))! !

!RealAlgebraicNumber methodsFor: 'mathematical functions' stamp: 'len 4/29/2018 18:39:12'!
squared
	| x odd even |
	x _ minimalPolynomial parent x.
	odd _ minimalPolynomial odd.
	even _ minimalPolynomial even.
	self flag: #fix.
	^ self class "this could be rational"
		polynomial: odd squared * x - even squared
		bounds: self bounds squared! !

!RealAlgebraicNumber methodsFor: 'printing' stamp: 'len 4/29/2018 18:39:50'!
printOn: aStream base: base
	minimalPolynomial degree < 4 "too slow" ifTrue: [self isRational ifTrue: [self asRational printOn: aStream base: base. ^ self]].
"	polynomial degree = 2 ifTrue: [^ self printQuadraticOn: aStream base: base]."
	(self asFloat roundTo: 0.00001) printOn: aStream base: base.
	aStream nextPutAll: '..'

	"aStream
		nextPutAll: self class name;
		space;
		nextPut: $(;
		print: self polynomial;
		nextPutAll: '; ~ ';
		print: self asFloat;
		nextPut: $)"! !

!RealAlgebraicNumber methodsFor: 'testing' stamp: 'len 12/5/2017 20:12:14'!
isAlgebraic
	^ true! !

!RealAlgebraicNumber methodsFor: 'testing' stamp: 'len 5/27/2016 02:06'!
isAlgebraicInteger
	"An algebraic number is an 'algebraic integer' if it's the root of a monic polynomial in Z[x], in particular if it's minimal polynomial has integer coefficients."
	^ self minimalPolynomial coefficients allSatisfy: [:each| each isInteger]! !

!RealAlgebraicNumber methodsFor: 'testing' stamp: 'len 5/23/2020 09:33:01'!
isRational
	"Answer true if the receiver is a rational number."
	minimalPolynomial degree < 2 ifTrue: [^ true].
	self rightBound = self leftBound ifTrue: [^ true].
	(minimalPolynomial rootsIn: )
		do: [:each|
			(self bounds includes: each)
				ifTrue: [self bounds: (RealInterval closed: each closed: each). ^ true]].
	^ false! !

!RealAlgebraicNumber methodsFor: 'testing' stamp: 'len 11/19/2015 21:33'!
isZero
	^ self leftBound = 0 and: [self rightBound = 0]
"	^ self isRational and: [self asRational = 0]"! !

!RealAlgebraicNumber methodsFor: 'truncation and round off' stamp: 'len 1/17/2016 02:20'!
truncated
	"Answer the integer nearest the receiver toward zero."
	| t |
	self absoluteError truncated > 0 ifTrue: [self refineTo: 9/10].
	^ (t _ self rightBound truncated) = self rightBound
		ifTrue: [self refineAt: t.
				self rightBound truncated]
		ifFalse: [t]! !

!RealAlgebraicNumber methodsFor: 'private' stamp: 'len 1/17/2016 02:57'!
bounds: aRealInterval
	bounds _ aRealInterval.
	rightSign _ nil! !

!RealAlgebraicNumber methodsFor: 'private' stamp: 'len 1/16/2016 06:38'!
leftBound
	^ bounds left! !

!RealAlgebraicNumber methodsFor: 'private' stamp: 'len 1/16/2016 07:05'!
leftBound: aFraction
	bounds _ RealInterval open: aFraction closed: bounds right! !

!RealAlgebraicNumber methodsFor: 'private' stamp: 'len 7/20/2019 09:17:44'!
normalize
	"Change the representation of the receiver such that if the receiver is not 0 then 0 is not in the rational approximation interval."
	| p sign |
	self leftBound sign = self rightBound sign ifTrue: [^ self].
	minimalPolynomial independentCoefficient isZero
		ifTrue: [^ self leftBound: 0; rightBound: 0].
	"for every real root r not 0: |r| > 1 / (1 + f normInfinite), from Cauchy and Landau inequalities"
	p _ 1 / (1 + minimalPolynomial normInfinite asFloat).
	p negated < self leftBound
		ifTrue: [^ self leftBound: p].
	p > self rightBound
		ifTrue: [^ self rightBound: p negated].
	sign _ (minimalPolynomial value: p negated) sign.
	sign ~= (minimalPolynomial value: self leftBound) sign
		ifTrue: [self rightBound: p negated; rightSign: sign]
		ifFalse: [(minimalPolynomial value: p) sign ~= self rightSign
				ifTrue: [self leftBound: p]
				ifFalse: [self leftBound: 0; rightBound: 0]].
	self leftBound > self rightBound ifTrue: [self error: 'interval normalization error']! !

!RealAlgebraicNumber methodsFor: 'private' stamp: 'len 1/16/2016 06:38'!
rightBound
	^ bounds right! !

!RealAlgebraicNumber methodsFor: 'private' stamp: 'len 1/17/2016 02:57'!
rightBound: aFraction
	bounds _ RealInterval open: bounds left closed: aFraction.
	rightSign _ nil! !

!RealAlgebraicNumber methodsFor: 'private' stamp: 'len 4/29/2018 18:37:11'!
rightSign
	rightSign isNil ifTrue: [rightSign _ (minimalPolynomial value: self rightBound) sign].
	^ rightSign! !

!RealAlgebraicNumber methodsFor: 'private' stamp: 'len 1/17/2016 02:59'!
rightSign: anInteger
	rightSign _ anInteger! !

!RealAlgebraicNumber class methodsFor: 'examples' stamp: 'len 5/23/2020 09:33:01'!
phi
	"Answer the Phidias number or Golden Ratio."
	| x |
	x _  polynomials x.
	^ self minimalPolynomial: x^2 - x - 1 bounds: (RealInterval open: 1.0 open: 2.0)! !

!RealAlgebraicNumber class methodsFor: 'examples' stamp: 'len 5/23/2020 09:33:01'!
sqrt2
	"Answer an instance of the receiver representing the square root of 2."
	^ self
		minimalPolynomial:  polynomials x squared - 2
 		bounds: (RealInterval open: 1.0 open: 2.0)! !

!RealAlgebraicNumber class methodsFor: 'examples' stamp: 'len 5/23/2020 09:33:01'!
sqrt: aNumber
	"Answer a square root of the rational argument."
	aNumber positive ifFalse: [^ DomainError signal: 'negative square root'].
	^ self
		minimalPolynomial:  polynomials x squared - aNumber
 		bounds: (RealInterval open: 0.0 open: (aNumber max: 1.0))! !

!RealAlgebraicNumber class methodsFor: 'instance creation' stamp: 'len 5/23/2020 09:33:01'!
fromRational: aRational
	"Answer an instance of the receiver representing the rational number anIntegerOrFraction."
	| x |
	x _  polynomials x.
	^ self
		minimalPolynomial: x * aRational denominator - aRational numerator
 		bounds: (RealInterval open: aRational closed: aRational)! !

!RealAlgebraicNumber class methodsFor: 'instance creation' stamp: 'len 4/29/2018 17:30:10'!
minimalPolynomial: aPolynomial bounds: aRealInterval
	"Answer an instance of the receiver representing the unique zero of aPolynomial in the given rational interval."
	^ self new minimalPolynomial: aPolynomial bounds: aRealInterval! !

!RealAlgebraicNumber class methodsFor: 'instance creation' stamp: 'len 8/5/2021 08:42:43'!
polynomial: aPolynomial bounds: aRealInterval
	"Answer an instance of the receiver representing the unique zero of aPolynomial in the given interval."
	| approximation |
	approximation _ aRealInterval midpoint.
	^ self minimalPolynomial: (aPolynomial factorization detectMin: [:f| (f value: approximation) abs]) bounds: aRealInterval! !

!ContinuedFraction methodsFor: 'accessing' stamp: 'len 12/2/2015 00:07'!
coefficients
	^ coefficients! !

!ContinuedFraction methodsFor: 'accessing' stamp: 'len 5/23/2020 09:31:27'!
parent
	^ ! !

!ContinuedFraction methodsFor: 'arithmetic' stamp: 'len 12/3/2015 02:17'!
negated
	^ self class coefficients: coefficients negated! !

!ContinuedFraction methodsFor: 'arithmetic' stamp: 'len 12/4/2015 01:45'!
reciprocal
	^ (coefficients at: 1) = 0
		ifTrue: [self class coefficients: (coefficients copyFrom: 2 to: coefficients size)]
		ifFalse: [self class coefficients: 0, coefficients]! !

!ContinuedFraction methodsFor: 'convergents' stamp: 'len 3/27/2016 04:46'!
convergentAt: anInteger
	| n x |
	coefficients size > 0 ifFalse: [^ Infinity positive].
	n _ coefficients size min: anInteger.
	x _ coefficients at: n.
	(1 to: n-1) reverseDo: [:i| x _ x reciprocal + (coefficients at: i)].
	^ x! !

!ContinuedFraction methodsFor: 'convergents' stamp: 'len 5/23/2020 09:33:01'!
convergents
	^ Sequence to:  evaluating: [:i| self convergentAt: i]! !

!ContinuedFraction methodsFor: 'convergents' stamp: 'len 3/27/2016 04:51'!
convergentsDo: aBlock
	| p1 p2 q1 q2 |
	p2 _ 0.
	p1 _ 1.
	q2 _ 1.
	q1 _ 0.
	coefficients withIndexDo: [:ai :i| | pi qi | pi _ ai*p1 + p2. qi _ ai*q1 + q2. aBlock value: pi/qi. p2 _ p1. p1 _ pi. q2 _ q1. q1 _ qi]! !

!ContinuedFraction methodsFor: 'convergents' stamp: 'len 3/27/2016 04:43'!
convergentsUpTo: n
	| answer |
	answer _ OrderedCollection new: n.
	self convergentsDo: [:each| answer size < n ifFalse: [^ answer]. answer add: each]! !

!ContinuedFraction methodsFor: 'converting' stamp: 'len 10/18/2016 14:05'!
asFraction
	self isInfinite ifTrue: [self error: 'infinite continued fraction'].
	^ self convergentAt: coefficients size! !

!ContinuedFraction methodsFor: 'initialization' stamp: 'len 5/23/2020 09:34:55'!
coefficients: aSequence
	coefficients _ (aSequence isTuple or: [aSequence isKindOf: Sequence])
		ifTrue: [aSequence]
		ifFalse: [ tuple: aSequence]! !

!ContinuedFraction methodsFor: 'initialization' stamp: 'len 6/1/2020 13:47:40'!
fromFraction: aFraction
	| x a |
	aFraction isInfinity ifTrue: [coefficients _ (^0) zero. ^ self].
	coefficients _ OrderedCollection new.
	x _ aFraction.
	a _ x floor.
	coefficients add: a.
	[x _ x - a.
	x ~= 0]
		whileTrue:
			[x _ x reciprocal.
			a _ x floor.
			coefficients add: a].
	coefficients _ ^coefficients size !! coefficients asArray! !

!ContinuedFraction methodsFor: 'printing' stamp: 'len 10/18/2016 13:49'!
printOn: aStream base: base
	| separator |
	aStream nextPut: $[.
	separator _ $;.
	(1 to: (coefficients size min: 10)) do: [:i| (coefficients at: i) printOn: aStream base: base] separatedBy: [aStream nextPut: separator. separator _ $,].
	coefficients size isInfinite ifTrue: [aStream nextPutAll: '...'].
	aStream nextPut: $]! !

!ContinuedFraction methodsFor: 'testing' stamp: 'len 10/18/2016 14:05'!
isFinite
	^ coefficients size isInfinite not! !

!ContinuedFraction methodsFor: 'testing' stamp: 'len 10/18/2016 13:50'!
isInfinite
	^ self isFinite not! !

!ContinuedFraction class methodsFor: 'examples' stamp: 'len 12/4/2015 22:17'!
e
	^ self coefficients: (Sequence evaluating: [:n| n=1 ifTrue: [2] ifFalse: [n \\ 3 = 0 ifTrue: [2*n/3] ifFalse: [1]]])! !

!ContinuedFraction class methodsFor: 'examples' stamp: 'len 12/4/2015 01:14'!
phi
	"Answer the golden ratio."
	^ self coefficients: (Sequence constant: 1)! !

!ContinuedFraction class methodsFor: 'instance creation' stamp: 'len 12/2/2015 00:10'!
coefficients: anArray
	^ self new coefficients: anArray! !

!ContinuedFraction class methodsFor: 'instance creation' stamp: 'len 3/27/2016 05:07'!
fromFloat: aFloat
	^ self fromFraction: aFloat asFraction! !

!ContinuedFraction class methodsFor: 'instance creation' stamp: 'len 12/1/2015 23:04'!
fromFraction: aFraction
	^ self new fromFraction: aFraction! !

!ContinuedFraction class methodsFor: 'instance creation' stamp: 'len 4/30/2016 04:34'!
newFrom: aNumber
	aNumber isFloat ifTrue: [^ self fromFloat: aNumber].
	aNumber isFraction ifTrue: [^ self fromFraction: aNumber].
	^ super newFrom: aNumber! !

!Cardinal methodsFor: 'accessing' stamp: 'len 4/22/2016 05:06'!
order
	^ order! !

!Cardinal methodsFor: 'arithmetic' stamp: 'len 4/22/2016 02:39'!
* anObject
	anObject = 0 ifTrue: [^ self errorUndetermined].
	^ self max: anObject! !

!Cardinal methodsFor: 'arithmetic' stamp: 'len 1/22/2017 08:12:39'!
^ aNumber
	(aNumber isInteger and: [aNumber > 0]) ifTrue: [^ self].
	DomainError signal: 'only integer positive exponents allowed'! !

!Cardinal methodsFor: 'comparing' stamp: 'len 4/22/2016 05:06'!
< anObject
	anObject class = self class ifTrue: [^ order < anObject order].
	^ false! !

!Cardinal methodsFor: 'comparing' stamp: 'len 4/22/2016 05:06'!
= anObject
	^ self class == anObject class and: [order = anObject order]! !

!Cardinal methodsFor: 'comparing' stamp: 'len 6/28/2016 09:04'!
hash
	^ self class hash + order hash! !

!Cardinal methodsFor: 'converting' stamp: 'len 4/22/2016 05:11'!
adaptToNumber: rcvr andSend: selector
	selector == #+ ifTrue:[^self + rcvr].
	selector == #* ifTrue:[^self * rcvr].
	selector == #/ ifTrue:[^ rcvr isNumber ifTrue: [0] ifFalse: [self errorUndetermined]].
	selector == #> ifTrue:[^false].
	selector == #>= ifTrue:[^false].
	selector == #< ifTrue:[^true].
	selector == #<= ifTrue:[^true].
	^super adaptToNumber: rcvr andSend: selector! !

!Cardinal methodsFor: 'initialization' stamp: 'len 4/22/2016 05:06'!
order: anInteger
	order _ anInteger! !

!Cardinal methodsFor: 'testing' stamp: 'len 4/22/2016 05:06'!
isCountable
	^ order = 0! !

!Cardinal methodsFor: 'testing' stamp: 'len 4/22/2016 04:54'!
isInfinite
	^ true! !

!Cardinal class methodsFor: 'instance creation' stamp: 'len 4/22/2016 02:37'!
new
	^ self new: 0! !

!Cardinal class methodsFor: 'instance creation' stamp: 'len 4/22/2016 05:07'!
new: anInteger
	^ self basicNew order: anInteger! !

!Infinity methodsFor: 'accessing' stamp: 'len 10/9/97 20:17'!
sign
	"Answer the sign of the receiver."

	^ sign! !

!Infinity methodsFor: 'accessing-private' stamp: 'len 10/9/97 20:16'!
sign: anInteger
	sign _ anInteger! !

!Infinity methodsFor: 'arithmetic' stamp: 'len 11/14/97 14:49'!
* anObject
	"Answer the product of the receiver by the argument."

	anObject = 0 ifTrue: [^ self errorUndetermined].
	^ self class sign: self sign * anObject sign! !

!Infinity methodsFor: 'arithmetic' stamp: 'len 12/13/97 02:26'!
+ anObject
	"Answer the sum of the receiver and the argument."

	(anObject isInfinity and: [self sign ~= anObject sign])
		ifTrue: [^ self errorUndetermined].
	^ self! !

!Infinity methodsFor: 'arithmetic' stamp: 'len 11/12/97 21:30'!
- anObject
	"Answer the difference between the receiver and the argument."

	^ self + anObject negated! !

!Infinity methodsFor: 'arithmetic' stamp: 'len 10/9/97 20:24'!
/ anObject
	"Answer the division of the receiver by the argument."

	^ self * anObject reciprocal! !

!Infinity methodsFor: 'arithmetic' stamp: 'len 1/22/2017 08:15:34'!
^ aNumber
	^ self raisedTo: aNumber! !

!Infinity methodsFor: 'arithmetic' stamp: 'len 11/12/97 21:31'!
negated
	"Answer a copy of the receiver with the sign changed."

	^ self class sign: self sign negated! !

!Infinity methodsFor: 'arithmetic' stamp: 'len 1/16/2016 06:08'!
raisedTo: aNumber
	aNumber isInteger ifTrue: [^ self raisedToInteger: aNumber].
	^ DomainError signal! !

!Infinity methodsFor: 'arithmetic' stamp: 'len 11/9/2015 23:18'!
raisedToInteger: anInteger
	anInteger = 0 ifTrue: [^ self errorUndetermined].
	anInteger negative ifTrue: [^ 0].
	^ anInteger odd ifTrue: [self] ifFalse: [self negated]! !

!Infinity methodsFor: 'arithmetic' stamp: 'len 11/12/97 21:32'!
reciprocal
	"Answer zero. (1 / self)"

	^ 0! !

!Infinity methodsFor: 'arithmetic' stamp: 'len 10/17/97 04:09'!
squared
	"Answer the square of the receiver."

	^ self class positive! !

!Infinity methodsFor: 'comparing' stamp: 'len 11/9/2015 15:19'!
< anObject
	anObject isInfinity ifTrue: [^ self sign < anObject sign].
	^ self negative! !

!Infinity methodsFor: 'comparing' stamp: 'len 11/9/2015 15:19'!
<= aMagnitude
	^ self < aMagnitude! !

!Infinity methodsFor: 'comparing' stamp: 'len 11/9/2015 15:19'!
= anObject
	^ self class == anObject class and: [self sign = anObject sign]! !

!Infinity methodsFor: 'comparing' stamp: 'len 11/9/2015 15:19'!
> anObject
	anObject isInfinity ifTrue: [^ self sign > anObject sign].
	^ self positive! !

!Infinity methodsFor: 'comparing' stamp: 'len 11/9/2015 15:19'!
>= aMagnitude
	^ self > aMagnitude! !

!Infinity methodsFor: 'comparing' stamp: 'len 6/28/2016 09:19'!
hash
	^ self sign hash + self class hash! !

!Infinity methodsFor: 'converting' stamp: 'len 11/11/2015 05:00'!
adaptToNumber: rcvr andSend: selector
	selector == #+ ifTrue:[^self + rcvr].
	selector == #* ifTrue:[^self * rcvr].
	selector == #- ifTrue:[^self negated + rcvr].
	selector == #/ ifTrue:[^ rcvr isInfinite ifTrue: [self errorUndetermined] ifFalse: [0]].
	selector == #> ifTrue:[^self < rcvr].
	selector == #>= ifTrue:[^self <= rcvr].
	selector == #< ifTrue:[^self > rcvr].
	selector == #<= ifTrue:[^self >= rcvr].
	^super adaptToNumber: rcvr andSend: selector! !

!Infinity methodsFor: 'testing' stamp: 'len 10/18/2016 14:00'!
isInfinite
	^ true! !

!Infinity methodsFor: 'testing' stamp: 'len 11/19/2015 17:00'!
isInfinity
	^ true! !

!Infinity methodsFor: 'testing' stamp: 'len 12/6/2016 13:19:59'!
isZero
	^ false! !

!Infinity methodsFor: 'testing' stamp: 'len 11/14/97 14:50'!
negative
	"Answer true if the receiver is negative."

	^ self sign negative! !

!Infinity methodsFor: 'testing' stamp: 'len 11/14/97 14:50'!
positive
	"Answer true if the receiver is positive."

	^ self sign positive! !

!Infinity methodsFor: 'testing' stamp: 'len 11/14/97 14:51'!
strictlyPositive
	"Answer true if the receiver is strictly positive."

	^ self positive! !

!Infinity methodsFor: 'private' stamp: 'len 10/9/97 20:29'!
errorUndetermined
	^ self error: 'undetermined'! !

!Infinity class methodsFor: 'instance creation' stamp: 'len 10/17/97 04:07'!
negative
	"Answer a new instance of the receiver representing -infinity."

	^ self sign: -1! !

!Infinity class methodsFor: 'instance creation' stamp: 'len 10/17/97 04:07'!
positive
	"Answer a new instance of the receiver representing +infinity."

	^ self sign: 1! !

!Infinity class methodsFor: 'instance creation' stamp: 'len 11/23/2015 02:41'!
projective
	"Answer a new instance of the receiver representing the projective (unsigned) infinity."

	^ self sign: 0! !

!Infinity class methodsFor: 'instance creation' stamp: 'len 10/9/97 20:27'!
sign: anInteger
	"Answer a new instance of the receiver with sign anInteger."

	^ self new sign: anInteger! !

!Ordinal methodsFor: 'accessing' stamp: 'len 12/31/2021 11:23:44'!
degree
	^ self isZero ifTrue: [self] ifFalse: [terms first key]! !

!Ordinal methodsFor: 'accessing' stamp: 'len 12/29/2021 11:58:21'!
size
	^ self isFinite ifTrue: [self asInteger] ifFalse: [Cardinal new: self]! !

!Ordinal methodsFor: 'comparing' stamp: 'len 12/31/2021 11:23:28'!
< anOrdinal
	1 to: (terms size min: anOrdinal terms size) do: [:i|
		| a b |
		a _ terms at: i.
		b _ anOrdinal terms at: i.
		(a key < b key or: [a key = b key and: [a value < b value]]) ifTrue: [^ true]].
	^ terms size < anOrdinal terms size! !

!Ordinal methodsFor: 'comparing' stamp: 'len 12/31/2021 11:23:34'!
= anOrdinal
	^ self class = anOrdinal class and: [terms = anOrdinal terms]! !

!Ordinal methodsFor: 'comparing' stamp: 'len 12/31/2021 11:23:48'!
hash
	^ terms hash! !

!Ordinal methodsFor: 'converting' stamp: 'len 12/28/2021 12:51:49'!
adaptToInteger: rcvr andSend: selector
	^ rcvr asOrdinal perform: selector with: self! !

!Ordinal methodsFor: 'converting' stamp: 'len 12/31/2021 11:23:39'!
asInteger
	self isZero ifTrue: [^ 0].
	self isFinite ifFalse: [^ self error: 'transfinite ordinal'].
	^ terms first value! !

!Ordinal methodsFor: 'converting' stamp: 'len 1/4/2022 10:55:45'!
asOrdinal
	^ self! !

!Ordinal methodsFor: 'operations' stamp: 'len 12/31/2021 11:22:19'!
* anOrdinal
	"Answer the ordinal product of the receiver and the argument.
	This operation is not commutative."
	self isZero ifTrue: [^ self].
	anOrdinal isInteger ifTrue: [^ self * anOrdinal asOrdinal].
	anOrdinal isLimit ifTrue: [^ self class terms: (anOrdinal terms collect: [:each| self degree + each key -> each value])].
	^ self class terms:
		(anOrdinal terms allButLast collect: [:each| self degree + each key -> each value]),
		{self degree -> (terms first value * anOrdinal terms last value)},
		terms allButFirst

"	anOrdinal isFinite ifTrue: [^ self timesCoefficient: anOrdinal asInteger].
	answer _ 0 asOrdinal.
	anOrdinal parts do: [:each|
		answer _ answer + ((self timesExponent: each key) timesCoefficient: each value)].
	^ answer"! !

!Ordinal methodsFor: 'operations' stamp: 'len 12/31/2021 11:23:07'!
+ anOrdinal
	"Answer the ordinal sum of the receiver and the argument.
	This operation is not commutative."
	| i |
	anOrdinal isInteger ifTrue: [^ self + anOrdinal asOrdinal].
	self isZero ifTrue: [^ anOrdinal].
	anOrdinal isZero ifTrue: [^ self].
	(i _ terms findLast: [:one| one key >= anOrdinal degree]) = 0 ifTrue: [^ anOrdinal].
	^ (terms at: i) key = anOrdinal degree
		ifTrue: [self class terms: (terms first: i-1), {anOrdinal degree -> ((terms at: i) value + anOrdinal terms first value)}, anOrdinal terms allButFirst]
		ifFalse: [self class terms: (terms first: i), anOrdinal terms]

"	(self isFinite and: [anOrdinal isFinite]) ifTrue: [^ (self asInteger + anOrdinal asInteger) asOrdinal].
	^ self class parts: (self truncatedAt: anOrdinal degree) parts, anOrdinal parts"! !

!Ordinal methodsFor: 'operations' stamp: 'len 12/31/2021 11:27:52'!
^ anOrdinal
	anOrdinal isInteger ifTrue: [^ self ^ anOrdinal asOrdinal].
	self isOmega ifTrue: [^ self class terms: {anOrdinal -> 1}].
	^ self notYetImplemented! !

!Ordinal methodsFor: 'operations' stamp: 'len 12/28/2021 12:50:46'!
 anOrdinal
	"Answer the Jacobsthal multiplication of the receiver with the argument."
	anOrdinal isInteger ifTrue: [^ self  anOrdinal asOrdinal].
	^ self notYetImplemented! !

!Ordinal methodsFor: 'operations' stamp: 'len 12/28/2021 12:40:02'!
 anOrdinal
	"Answer the natural (or Hessenberg) addition of the receiver with the argument."
	anOrdinal isInteger ifTrue: [^ self  anOrdinal asOrdinal].
	^ self notYetImplemented! !

!Ordinal methodsFor: 'operations' stamp: 'len 12/28/2021 12:40:15'!
 anOrdinal
	"Answer the natural (or Hessenberg) multiplication of the receiver with the argument."
	anOrdinal isInteger ifTrue: [^ self  anOrdinal asOrdinal].
	^ self notYetImplemented! !

!Ordinal methodsFor: 'operations' stamp: 'len 12/31/2021 11:27:57'!
exp
	^ self class terms: {self -> 1}! !

!Ordinal methodsFor: 'operations' stamp: 'len 12/31/2021 11:26:35'!
log
	(terms size = 1 and: [terms first value = 1]) ifTrue: [^ terms first key].
	^ self notYetImplemented! !

!Ordinal methodsFor: 'operations' stamp: 'len 12/31/2021 11:26:52'!
truncatedAt: anOrdinal
	^ self class terms: (terms first: (terms findLast: [:x| x key >= anOrdinal]))! !

!Ordinal methodsFor: 'testing' stamp: 'len 12/28/2021 12:33:38'!
includes: anObject
	anObject isInteger ifTrue: [^ anObject >= 0 and: [self isFinite not or: [anObject < self asInteger]]].
	^ anObject class = self class and: [anObject < self]! !

!Ordinal methodsFor: 'testing' stamp: 'len 12/31/2021 11:23:58'!
isFinite
	^ terms size = 0 or: [terms size = 1 and: [terms first key isZero]]! !

!Ordinal methodsFor: 'testing' stamp: 'len 12/29/2021 11:12:15'!
isLimit
	^ self isSuccessor not! !

!Ordinal methodsFor: 'testing' stamp: 'len 12/31/2021 11:24:08'!
isOmega
	^ terms size = 1 and: [terms first key isOne and: [terms first value = 1]]! !

!Ordinal methodsFor: 'testing' stamp: 'len 12/31/2021 11:26:16'!
isOne
	^ terms size = 1 and: [terms first key isZero and: [terms first value = 1]]! !

!Ordinal methodsFor: 'testing' stamp: 'len 12/31/2021 11:26:22'!
isSuccessor
	^ self isZero not and: [terms last key isZero]! !

!Ordinal methodsFor: 'testing' stamp: 'len 12/31/2021 11:26:26'!
isZero
	^ terms isEmpty! !

!Ordinal methodsFor: 'private' stamp: 'len 12/31/2021 11:27:28'!
terms
	^ terms! !

!Ordinal methodsFor: 'private' stamp: 'len 12/31/2021 11:27:22'!
terms: anArray
	terms _ anArray! !

!Ordinal methodsFor: 'private' stamp: 'len 12/31/2021 11:27:01'!
verify
	"Verify that the receiver is in Cantor normal form:
		1) exponents in decreasing order,
		2) coefficients > 0 and in increasing order."
	1 to: terms size - 1 do: [:i|
		| a b |
		a _ terms at: i.
		b _ terms at: i+1.
		(a key > b key and: [a value > 0 and: [a value < b value]]) ifFalse: [^ false]].
	^ true! !

!Ordinal class methodsFor: 'instance creation' stamp: 'len 12/31/2021 11:28:03'!
fromInteger: anInteger
	anInteger = 0 ifTrue: [^ Zero].
	anInteger > 0 ifFalse: [^ self error: 'not a positive integer'].
	^ self terms: {Zero -> anInteger}! !

!Ordinal class methodsFor: 'instance creation' stamp: 'len 12/31/2021 11:28:58'!
terms: anArray
	^ self new terms: anArray! !

!Ordinal class methodsFor: 'class initialization' stamp: 'len 12/31/2021 11:28:10'!
initialize
	super initialize.
	Zero _ self terms: #().
	Smalltalk at: # put: Zero exp exp! !

!IdentityArray methodsFor: 'as yet unclassified' stamp: 'len 12/23/2021 15:35:29'!
hasEqualElements: otherCollection
	"Answer whether the receiver's size is the same as otherCollection's
	size, and each of the receiver's elements equal the corresponding 
	element of otherCollection.
	This should probably replace the current definition of #= ."

	| size |
	otherCollection isSequenceable ifFalse: [^ false].
	(size _ self size) = otherCollection size ifFalse: [^ false].
	1 to: size do:
		[:index |
		(self at: index) == (otherCollection at: index) ifFalse: [^ false]].
	^ true! !

!IdentityArray methodsFor: 'as yet unclassified' stamp: 'len 12/23/2021 15:37:27'!
hashQuick
	| hash size step |
	size _ self size.
	hash _ (self species hash + size hash) hashMultiply.
	step _ size < 64 ifTrue: [1] ifFalse: [size//64].
	1 to: size by: step do: [ :i | | elem |
		elem _ self at: i.
		elem == self ifFalse: [
			hash _ (hash + elem identityHash) hashMultiply]].
	^hash! !

!BitArray2 methodsFor: 'accessing' stamp: 'len 12/21/2015 22:30'!
at: anInteger
	^ (bytes at: anInteger - 1 // 8 + 1 ifAbsent: [^ 0]) bitAt: anInteger - 1 \\ 8 + 1! !

!BitArray2 methodsFor: 'accessing' stamp: 'len 12/21/2015 22:07'!
at: anInteger put: aBit
	| i i0 b |
	i _ anInteger - 1 // 8 + 1.
	i0 _ anInteger - 1 \\ 8 + 1.
	b _ bytes at: i.
	(b bitAt: i0) == aBit
		ifFalse: [b _ b bitXor: (1 bitShift: i0-1)].
	bytes at: i put: b.
	^ aBit! !

!BitArray2 methodsFor: 'accessing' stamp: 'len 12/21/2015 22:16'!
byteAt: anInteger
	^ bytes at: anInteger ifAbsent: [0]! !

!BitArray2 methodsFor: 'accessing' stamp: 'len 12/21/2015 22:16'!
byteAt: anInteger put: aByte
	^ bytes at: anInteger put: aByte! !

!BitArray2 methodsFor: 'accessing' stamp: 'len 12/21/2015 20:41'!
size
	^ length! !

!BitArray2 methodsFor: 'arithmetic' stamp: 'len 12/21/2015 22:15'!
* aBitArray
	| answer |
	answer _ self class new: (self size max: aBitArray size).
	1 to: answer byteSize do: [:i|
		answer byteAt: i put: ((self byteAt: i) bitAnd: (aBitArray byteAt: i))].
	^ answer! !

!BitArray2 methodsFor: 'arithmetic' stamp: 'len 12/21/2015 22:14'!
+ aBitArray
	| answer |
	answer _ self class new: (self size max: aBitArray size).
	1 to: answer byteSize do: [:i|
		answer byteAt: i put: ((self byteAt: i) bitXor: (aBitArray byteAt: i))].
	^ answer! !

!BitArray2 methodsFor: 'converting' stamp: 'len 12/21/2015 22:17'!
asByteArray
	^ bytes! !

!BitArray2 methodsFor: 'converting' stamp: 'len 12/21/2015 22:21'!
asInteger
	"Answer the receiver as a possitive integer."
	| answer i |
	answer _ 0.
	i _ 0.
	bytes do: [:each| answer _ answer + (each bitShift: i). i _ i + 8].
	^ answer! !

!BitArray2 methodsFor: 'initialization' stamp: 'len 12/21/2015 20:31'!
bytes: aByteArray length: anInteger
	bytes _ aByteArray.
	length _ anInteger! !

!BitArray2 class methodsFor: 'instance creation' stamp: 'len 12/21/2015 20:41'!
new: anInteger
	^ self new: anInteger bytes: (ByteArray new: (anInteger / 8) ceiling)! !

!BitArray2 class methodsFor: 'instance creation' stamp: 'len 12/21/2015 20:40'!
new: anInteger bytes: aByteArray
	^ self basicNew bytes: aByteArray length: anInteger! !

!BitArray2 class methodsFor: 'instance creation' stamp: 'len 12/21/2015 22:26'!
random: anInteger
	| answer |
	answer _ self new: anInteger.
	1 to: answer size do: [:i| answer at: i put: 2 atRandom - 1].
	^ answer! !

!StandardBasis methodsFor: 'accessing' stamp: 'len 5/7/2018 23:22:50'!
add: aPolynomial
	^ elements add: aPolynomial! !

!StandardBasis methodsFor: 'accessing' stamp: 'len 5/7/2018 23:21:31'!
addAll: aCollection
	^ elements addAll: aCollection! !

!StandardBasis methodsFor: 'accessing' stamp: 'len 5/7/2018 23:22:47'!
at: anInteger
	^ elements at: anInteger! !

!StandardBasis methodsFor: 'accessing' stamp: 'len 11/21/2015 00:10'!
first
	^ self at: 1! !

!StandardBasis methodsFor: 'accessing' stamp: 'len 1/23/2017 11:47:32'!
indeterminates
	^ self anyOne parent indeterminates! !

!StandardBasis methodsFor: 'accessing' stamp: 'len 1/23/2017 11:47:29'!
ordering
	"Answer the monomial ordering of the receiver."
	^ self anyOne parent ordering! !

!StandardBasis methodsFor: 'accessing' stamp: 'len 5/7/2018 23:21:22'!
size
	^ elements size! !

!StandardBasis methodsFor: 'accessing-private' stamp: 'len 5/7/2018 23:23:36'!
elements: aCollection
	elements _ aCollection! !

!StandardBasis methodsFor: 'copying' stamp: 'len 5/10/2018 08:03:11'!
copy
	"Answer a copy of the reciever."
	^ self class new elements: elements copy! !

!StandardBasis methodsFor: 'copying' stamp: 'len 11/20/2016 15:32:11'!
copyEmpty
	^ self class new! !

!StandardBasis methodsFor: 'copying' stamp: 'len 5/7/2018 23:23:29'!
copyWithout: aPolynomial
	^ self class new elements: (elements copyWithout: aPolynomial)! !

!StandardBasis methodsFor: 'enumerating' stamp: 'len 7/8/2016 20:57'!
apply: aMorphism
	| answer |
	answer _ self copyEmpty.
	self do: [:each| answer add: (aMorphism value: each)].
	^ answer! !

!StandardBasis methodsFor: 'enumerating' stamp: 'len 5/7/2018 23:21:19'!
do: aBlock
	elements do: aBlock! !

!StandardBasis methodsFor: 'initialization' stamp: 'len 5/10/2018 08:03:16'!
initialize
"	elements _ SortedCollection sortBlock: [:a :b| a degree <= b degree]."
"	elements _ SortedCollection sortBlock: [:a :b| a leadingMonomial <= b leadingMonomial]."
	elements _ OrderedCollection new! !

!StandardBasis methodsFor: 'operations' stamp: 'len 5/28/2020 17:47:47'!
elementAt: anArray
	^ (1 to: anArray size) sum: [:i| (self at: i) * (anArray at: i)]! !

!StandardBasis methodsFor: 'operations' stamp: 'len 1/26/2017 22:51:21'!
leadingTerms
	"Answer the standard basis made of all leading monomials of polynomials in the receiver."
	| answer |
	answer _ self class new.
	self do: [:each| | lt | lt _ each leadingTerm. (answer reduces: lt) ifFalse: [answer add: lt]].
	^ answer! !

!StandardBasis methodsFor: 'operations' stamp: 'len 1/1/2022 09:37:58'!
macaulayMatrix
	| monomials |
	monomials _ Set new.
	self do: [:each| monomials addAll: each monomials].
	monomials _ monomials asSortedCollection: [:a :b| a >= b].
	^ self anyOne parent scalars matrix: self size @ monomials size filling: [:i :j| (self at: i) at: (monomials at: j)]! !

!StandardBasis methodsFor: 'operations' stamp: 'len 12/17/2021 14:44:42'!
minimal
	"Answer the minimal Groebner basis of the receiver."
	| heads goods answer |
	self isMinimal ifTrue: [^ self].
	heads _ elements collect: [:each| each leadingMonomial].
	goods _ (1 to: heads size) asSet.
	heads withIndexDo: [:head :i|
		(goods anySatisfy: [:one| i ~= one and: [(heads at: one) | head]])
			ifTrue: [goods remove: i]].
	answer _ self class new.
	(goods asSortedCollection: [:a :b| "make it triangular for lex" (elements at: a) leadingMonomial >= (elements at: b) leadingMonomial])
		do: [:i| answer add: (elements at: i) normalized].
	^ answer! !

!StandardBasis methodsFor: 'operations' stamp: 'len 5/10/2019 08:31:13'!
reduce1: aPolynomial 
	"Answer Mora's normal form of aPolynomial with respect to the receiver)."
	| h L M |
	h _ aPolynomial.
	L _ OrderedCollection withAll: self.
	([h isZero or: [(M _ L select: [:g| g leadingMonomial | h leadingMonomial]) isEmpty]])
		whileFalse:
			[| g |
			g _ M detectMin: [:each| each ecart].
			g ecart > h ecart ifTrue: [L add: h].
			h _ h - (g * (h leadingMonomial / g leadingMonomial) * (h leadingCoefficient / g leadingCoefficient))].
	^ h! !

!StandardBasis methodsFor: 'operations' stamp: 'len 7/29/2021 17:12:23'!
reduce: aPolynomial 
	"Answer Mora's normal form of aPolynomial with respect to the receiver."
	| h L lh g ecartg |
	h _ aPolynomial.
	L _ OrderedCollection withAll: self.
	[h isZero ifTrue: [^ h].
	lh _ h leadingMonomial.
	g _ nil.
	ecartg _ -1.
	L do: [:each|
		| ecart |
		(each leadingMonomial | lh and: [ecart _ each ecart. g isNil or: [ecart < ecartg]])
			ifTrue: [g _ each. ecartg _ ecart]].
	g isNil ifTrue: [^ h].
	ecartg > h ecart ifTrue: [L add: h].
	h _ h + (g * (lh / g leadingMonomial) * (h leadingCoefficient negated / g leadingCoefficient))] repeat! !

!StandardBasis methodsFor: 'operations' stamp: 'len 5/11/2018 06:26:35'!
reduceFull: aPolynomial
	"In the general case of standard bases, this is the same as >>reduce:.
	It is reimplemented in GroebnerBasis."
	^ self reduce: aPolynomial! !

!StandardBasis methodsFor: 'operations' stamp: 'len 5/12/2018 17:54:24'!
reduceFull: aPolynomial startingAt: startIndex
	"In the general case of standard bases, this is the same as >>reduce:.
	It is reimplemented in GroebnerBasis."
	^ self reduce: aPolynomial! !

!StandardBasis methodsFor: 'operations' stamp: 'len 12/30/2021 14:30:32'!
reduced
	"Answer a reduced basis for the ideal generated by the receiver.
	Based on [BW93], algorithm REDGROEBNER (p. 216) and REDUCTION (p. 203).
	[BW93] Thomas Becker; Volker Weispfenning; 'Groebner Bases: A Computational Approach to Commutative Algebra' (1993)"
	| G H |
	H _ OrderedCollection new.
	1 to: self size do: [:i| | fi lm |
		fi _ self at: i.
		lm _ fi leadingMonomial.
		(((i+1 to: self size) noneSatisfy: [:j| (self at: j) leadingMonomial | lm])
			and: [H noneSatisfy: [:h| h leadingMonomial | lm]])
				ifTrue: [H add: fi]].
	H _ H asArray.
	G _ self class new.
	1 to: H size do: [:i| | hi r |
		hi _ H at: i.
		(r _ hi \\ (H copyWithoutIndex: i)) isZero ifFalse: [G add: r normalized]].
	G sort: [:a :b| a leadingMonomial >= b leadingMonomial]. "make it triangular for lex"
	^ G! !

!StandardBasis methodsFor: 'sorting' stamp: 'len 5/10/2018 17:52:05'!
sort: aBlock
	elements sort: aBlock! !

!StandardBasis methodsFor: 'testing' stamp: 'len 7/28/2021 15:19:12'!
isMinimal
	"A Groebner basis G of an ideal I is called 'minimal' if the lead terms of the elements in G minimally generate in(I); or equivalently, if for all p in G:
	- LC(p) = 1, and
	- LT(p) is not in <G-{p}> (i.e., leading-term-minimal).
	Note that any leading-term-minimal Groebner basis is also cardinality-minimal."
	self do: [:g| g leadingCoefficient isOne ifFalse: [^ false]].
	self do: [:g|
		self do: [:f|
			(f ~~ g and: [f leadingMonomial | g leadingMonomial]) ifTrue: [^ false]]].
	^ true! !

!StandardBasis methodsFor: 'testing' stamp: 'len 5/10/2018 03:10:42'!
isMinimal2
	"A Groebner basis G is minimal when for all p in G:
	1. LC(p) = 1;
	2. LT(p) is not in <G-{p}>."
	| one |
	one _ self first scalars one.
	"Check all polynomials are monic:"
	self do: [:each| each leadingCoefficient ~= one ifTrue: [^ false]].
	self do: [:each| "Check if the basis without it still generates its leading term:"
		((self copyWithout: each) reduces: each leadingTerm)
				ifTrue: [^ false]].
	^ true! !

!StandardBasis methodsFor: 'testing' stamp: 'len 7/28/2021 15:18:41'!
isReduced
	"A Groebner basis G is called 'reduced' (or 'auto-reduced') if for all p in G:
	- LC(p) = 1, and
	- no monomial of p is in <G-{p}>.
	In particular, a reduced Groebner basis is leading-term-minimal (no leading term of any generator divides any other generator's leading term), and a leading-term-minimal basis is also cardinality-minimal."
	self do: [:g| g leadingCoefficient isOne ifFalse: [^ false]].
	self do: [:g|
		g monomialsDo: [:gi|
			self do: [:f|
				(f ~~ g and: [f leadingMonomial | gi]) ifTrue: [^ false]]]].
	^ true! !

!StandardBasis methodsFor: 'testing' stamp: 'len 5/9/2018 23:21:42'!
isReduced2
	"A Groebner basis G is reduced when for all p in G:
	1. LC(p) = 1;
	2. No monomial of p is contained in <G-{p}>."
	| one subBasis |
	one _ self first scalars one.
	"Check all polynomials are monic:"
	self do: [:each| each leadingCoefficient ~= one ifTrue: [^ false]].
	self do: [:each| "Check if the basis without it still generates its monomials:"
		subBasis _ self copyWithout: each.
		(each terms allSatisfy: [:other| subBasis reduces: other]) ifTrue: [^ false]].
	^ true! !

!StandardBasis methodsFor: 'testing' stamp: 'len 5/7/2018 23:21:47'!
isTrivial
	"Answer true if the basis is {1}."
	^ elements size = 1 and: [elements first isConstant and: [elements first isMonic]]
"	^ elements anySatisfy: [:f| f isConstant]"! !

!StandardBasis methodsFor: 'testing' stamp: 'len 10/29/2016 16:36'!
reduces: aPolynomial
	^ (self reduce: aPolynomial) isZero! !

!StandardBasis methodsFor: 'private' stamp: 'len 3/6/2016 20:37'!
species
	^ Array! !

!StandardBasis methodsFor: 'private' stamp: 'len 5/10/2018 06:27:11'!
verify
	1 to: self size do: [:i| | fi |
		fi _ self at: i.
		i+1 to: self size do: [:j| | fj |
			fj _ self at: j.
			(self reduces: (fi s: fj))
				ifFalse: [^ false]]].
	^ true! !

!GroebnerBasis methodsFor: 'operations' stamp: 'len 7/29/2021 16:58:08'!
reduce: aPolynomial
	"Answer a top-reduced normal form of aPolynomial with respect to the receiver (without doing tail reduction)."
	| h |
	h _ aPolynomial.
	[h isZero]
		whileFalse:
			[| lh lg g |
			lh _ h leadingMonomial.
			g _ elements detect: [:one| (lg _ one leadingMonomial) | lh] ifNone: [^ h].
			h _ h + (g * (lh / lg) * (h leadingCoefficient negated / g leadingCoefficient))].
	^ h! !

!GroebnerBasis methodsFor: 'operations' stamp: 'len 7/29/2021 16:58:21'!
reduce: aPolynomial startingAt: startIndex
	"Answer a top-reduced normal form of aPolynomial with respect to the receiver (without doing tail reduction)."
	| h |
	h _ aPolynomial.
	[h isZero]
		whileFalse:
			[| lh lg g |
			lh _ h leadingMonomial.
			(startIndex to: elements size) detect: [:i| (lg _ (g _ elements at: i) leadingMonomial) | lh] ifNone: [^ h].
			h _ h + (g * (lh / lg) * (h leadingCoefficient negated / g leadingCoefficient))].
	^ h! !

!GroebnerBasis methodsFor: 'operations' stamp: 'len 12/17/2021 14:43:33'!
reduceFull: aPolynomial
	"Answer the tail-reduced normal form of aPolynomial with respect to the receiver (doing full tail reduction)."
	| g h |
	g _ aPolynomial.
	h _ g zero.
	[g isZero]
		whileFalse:
			[g _ self reduce: g.
			g isZero ifFalse: [h _ h + g leadingTerm. g _ g tail]].
	^ h normalized! !

!GroebnerBasis methodsFor: 'operations' stamp: 'len 12/17/2021 14:43:39'!
reduceFull: aPolynomial startingAt: startIndex
	"Answer the tail-reduced normal form of aPolynomial with respect to the receiver (doing full tail reduction)."
	| g h |
	g _ aPolynomial.
	h _ g zero.
	[g isZero]
		whileFalse:
			[g _ self reduce: g startingAt: startIndex.
			g isZero ifFalse: [h _ h + g leadingTerm. g _ g tail]].
	^ h normalized! !

!YoungTableau methodsFor: 'accessing' stamp: 'len 8/1/2016 02:52'!
at: aPoint
	^ (rows at: aPoint x) at: aPoint y! !

!YoungTableau methodsFor: 'accessing' stamp: 'len 8/1/2016 02:52'!
at: aPoint put: anObject
	^ (rows at: aPoint x) at: aPoint y put: anObject! !

!YoungTableau methodsFor: 'accessing' stamp: 'len 8/1/2016 03:19'!
diagram
	^ YoungDiagram shape: self shape! !

!YoungTableau methodsFor: 'accessing' stamp: 'len 4/5/2018 15:20:19'!
height
	^ rows size! !

!YoungTableau methodsFor: 'accessing' stamp: 'len 7/12/2016 00:07'!
rank
	^ rows sum: [:each| each size]! !

!YoungTableau methodsFor: 'accessing' stamp: 'len 7/11/2016 21:47'!
rows
	^ rows! !

!YoungTableau methodsFor: 'accessing' stamp: 'len 7/11/2016 22:34'!
shape
	^ rows collect: [:each| each size]! !

!YoungTableau methodsFor: 'accessing' stamp: 'len 7/12/2016 00:06'!
weight
	| answer |
	answer _ Array new: self rank.
	answer atAllPut: 0.
	self do: [:each| answer at: each put: (answer at: each) + 1].
	^ answer! !

!YoungTableau methodsFor: 'accessing' stamp: 'len 4/5/2018 15:20:10'!
width
	^ rows first size! !

!YoungTableau methodsFor: 'arithmetic' stamp: 'len 4/5/2018 15:43:58'!
negated
	self height = 1 ifTrue: [^ self].
	^ self copy at: 1@1 put: (self at: 1@2); at: 1@2 put: (self at: 1@1); yourself! !

!YoungTableau methodsFor: 'arithmetic' stamp: 'len 7/11/2016 21:56'!
sign
	self notYetImplemented! !

!YoungTableau methodsFor: 'copying' stamp: 'len 7/11/2016 22:07'!
copy
	^ self class rows: (rows collect: [:each| each copy])! !

!YoungTableau methodsFor: 'enumerating' stamp: 'len 7/11/2016 22:11'!
do: aBlock
	rows do: [:each| each do: aBlock]! !

!YoungTableau methodsFor: 'enumerating' stamp: 'len 8/1/2016 02:54'!
withIndexDo: aBlock
	rows withIndexDo: [:row :i| row withIndexDo: [:each :j| aBlock value: each value: i@j]]! !

!YoungTableau methodsFor: 'initialization' stamp: 'len 7/11/2016 21:37'!
rows: anArray
	rows _ anArray! !

!YoungTableau methodsFor: 'testing' stamp: 'len 8/1/2016 02:36'!
isSemistandard
	self withIndexDo: [:each :index|
		(index x > 1 and: [each < (self at: index x - 1 @ index y)])
			ifTrue: [^ false].
		(index y > 1 and: [each < (self at: index x @ (index y - 1))])
			ifTrue: [^ false]].
	^ true! !

!YoungTableau methodsFor: 'testing' stamp: 'len 7/12/2016 00:15'!
isStandard
	"if it is semistandard and content = (1,1,..,1)"
	self withIndexDo: [:each :index|
		(index x > 1 and: [each <= (self at: index x - 1 @ index y)])
			ifTrue: [^ false].
		(index y > 1 and: [each <= (self at: index x @ (index y - 1))])
			ifTrue: [^ false]].
	^ true! !

!YoungTableau class methodsFor: 'instance creation' stamp: 'len 7/11/2016 21:47'!
rows: anArray
	^ self basicNew rows: anArray! !

!YoungTableau class methodsFor: 'instance creation' stamp: 'len 7/11/2016 22:33'!
shape: anArray
	^ self rows: (anArray collect: [:each| Array new: each])! !

!Simplex methodsFor: 'accessing' stamp: 'len 2/15/2017 08:52:17'!
dimension
	^ vertices size - 1! !

!Simplex methodsFor: 'accessing' stamp: 'len 2/23/2017 10:20:17'!
size
	^ vertices size! !

!Simplex methodsFor: 'accessing' stamp: 'len 2/15/2017 08:56:46'!
vertices
	^ vertices! !

!Simplex methodsFor: 'accessing' stamp: 'len 2/23/2016 02:13'!
volume
	^ self notYetImplemented "see wikipedia"! !

!Simplex methodsFor: 'accessing-private' stamp: 'len 2/24/2017 11:32:53'!
vertices: aCollection
	vertices _ aCollection asSortedCollection! !

!Simplex methodsFor: 'comparing' stamp: 'len 6/13/2016 09:34'!
< aSimplex
	"Answer true if the receiver is strictly contained in aSimplex as a face."
	^ aSimplex > self! !

!Simplex methodsFor: 'comparing' stamp: 'len 6/13/2016 09:33'!
<= aSimplex
	"Answer true if the receiver is contained in aSimplex as a face."
	^ aSimplex >= self! !

!Simplex methodsFor: 'comparing' stamp: 'len 4/21/2020 11:16:56'!
= anObject
	^ self class == anObject class and: [self vertices = anObject vertices]

"before we didn't keep vertices sorted, so we could check of two differently oriented simplices were equal:
	| iv v |
	vertices isEmpty ifTrue: [^ aSimplex vertices isEmpty].
	v _ vertices first.
	iv _ aSimplex vertices indexOf: v ifAbsent: [^ false].
	vertices withIndexDo: [:each :i|
		each = (aSimplex vertices atWrap: i+iv-1) ifFalse: [^ false]].
	^ true"! !

!Simplex methodsFor: 'comparing' stamp: 'len 2/15/2017 08:52:49'!
> aSimplex
	"Answer true if the receiver strictly containes aSimplex as a face."
	^ vertices size > aSimplex vertices size and: [vertices includesAllOf: aSimplex vertices]! !

!Simplex methodsFor: 'comparing' stamp: 'len 2/15/2017 08:56:30'!
>= aSimplex
	"Answer true if the receiver containes aSimplex as a face."
	^ vertices size >= aSimplex vertices size and: [vertices includesAllOf: aSimplex vertices]! !

!Simplex methodsFor: 'comparing' stamp: 'len 2/15/2017 08:14:56'!
~ aSimplex
	"Answer true if the receiver and the argument are isomorphic."
	^ self dimension = aSimplex dimension! !

!Simplex methodsFor: 'comparing' stamp: 'len 2/23/2017 19:08:39'!
hash
	^ vertices inject: 0 into: [:sum :each| sum + each hash] "this is independent of orientation"! !

!Simplex methodsFor: 'converting' stamp: 'len 2/14/2017 18:48:50'!
asSkeletonGraph
	| graph F |
	graph _ Graph unordered.
	F _ self faces: self dimension.
	graph addAll: self facets.
	F do: [:x| F do: [:y| graph addEdgeFrom: x to: y]].
	^ graph! !

!Simplex methodsFor: 'enumerating' stamp: 'len 2/24/2017 11:44:43'!
collect: aBlock
	^ self class vertices: (self vertices collect: aBlock) asSet "we don't assume aBlock is injective, so we have to convert to a Set to remove repetitions"! !

!Simplex methodsFor: 'enumerating' stamp: 'len 2/20/2017 18:49:55'!
do: aBlock
	^ self vertices do: aBlock! !

!Simplex methodsFor: 'faces' stamp: 'len 2/23/2016 02:02'!
edges
	^ self faces: 1! !

!Simplex methodsFor: 'faces' stamp: 'len 6/13/2016 00:00'!
faces
	"Answer all faces of the receiver (including the empty set and the receiver)."
	^ Iterator on: [:aBlock| self facesDo: aBlock]! !

!Simplex methodsFor: 'faces' stamp: 'len 2/15/2017 08:09:38'!
faces: n
	"Answer the n-faces of the receiver."
	^ Iterator on: [:aBlock| self faces: n do: aBlock]! !

!Simplex methodsFor: 'faces' stamp: 'len 2/23/2017 18:55:13'!
faces: n do: aBlock
	"Iterate over the n-faces of the receiver."
	n = -1 ifTrue: [^ aBlock value: (self class vertices: #())].
	vertices isEmpty ifTrue: [^ self].
	vertices combinations: n+1 atATimeDo: [:each|
		aBlock value: (self class vertices: each asSet)]! !

!Simplex methodsFor: 'faces' stamp: 'len 6/12/2016 23:59'!
facesDo: aBlock
	"Iterate over all faces of the receiver (including the empty set and the receiver)."
	-1 to: self dimension do: [:i| self faces: i do: aBlock]! !

!Simplex methodsFor: 'faces' stamp: 'len 6/13/2016 00:09'!
facets
	"Answer the boundary faces of the receiver."
	^ self faces: self dimension - 1! !

!Simplex methodsFor: 'faces' stamp: 'len 6/12/2016 23:59'!
properFaces
	"Answer all proper faces of the receiver of any dimension (including the empty set)."
	^ Iterator on: [:aBlock| self properFacesDo: aBlock]! !

!Simplex methodsFor: 'faces' stamp: 'len 6/12/2016 23:59'!
properFacesDo: aBlock
	"Iterate over all proper faces of the receiver (including the empty set)."
	-1 to: self dimension - 1 do: [:i| self faces: i do: aBlock]! !

!Simplex methodsFor: 'faces' stamp: 'len 2/27/2016 08:15'!
ridges
	^ self faces: self dimension - 2! !

!Simplex methodsFor: 'operations' stamp: 'len 2/15/2017 08:55:06'!
* aSimplex
	"Answer the join of the receiver with the argument."
	^ self class vertices: (self vertices collect: [:x| {1. x}]), (aSimplex vertices collect: [:y| {2. y}])! !

!Simplex methodsFor: 'operations' stamp: 'len 5/10/2019 04:33:50'!
/\ aSimplex
	"Answer the face common to the receiver and aSimplex, which could be {}."
	^ self class vertices: self vertices /\ aSimplex vertices! !

!Simplex methodsFor: 'operations' stamp: 'len 2/19/2017 08:24:44'!
closure
	"Answer the simplicial complex with the receiver. By definition of simplicial complex, it also contains all faces of the receiver)."
	^ SimplicialComplex facets: {self}! !

!Simplex methodsFor: 'operations' stamp: 'len 2/19/2017 09:31:02'!
complementIn: aCollection
	"Answer the complement of the receiver in the given vertex set.
	This is the simplex formed by the vertices in aCollection *not* in the receiver."
	^ self class vertices: aCollection \ vertices! !

!Simplex methodsFor: 'testing' stamp: 'len 2/20/2017 18:49:36'!
includes: anObject
	^ vertices includes: anObject! !

!Simplex methodsFor: 'testing' stamp: 'len 2/19/2017 10:39:56'!
intersects: aSimplex
	^ self vertices intersects: aSimplex vertices! !

!Simplex methodsFor: 'testing' stamp: 'len 2/19/2017 18:20:51'!
isTrivial
	"Answer true if this is the empty simplex."
	^ vertices isEmpty! !

!Simplex methodsFor: 'private' stamp: 'len 2/20/2017 19:04:07'!
species
	^ Set! !

!Simplex class methodsFor: 'instance creation' stamp: 'len 2/15/2017 08:54:40'!
new: n
	"Answer the standard n-simplex {1,...,n}."
	^ self vertices: (1 to: n+1)! !

!Simplex class methodsFor: 'instance creation' stamp: 'len 2/15/2017 08:54:35'!
newFrom: aCollection
	^ self vertices: aCollection! !

!Simplex class methodsFor: 'instance creation' stamp: 'len 2/15/2017 08:54:28'!
vertices: aCollection
	^ self new vertices: aCollection! !

!InversionError methodsFor: 'accessing' stamp: 'len 1/6/2022 19:27:38'!
element
	^ element! !

!InversionError methodsFor: 'private' stamp: 'len 1/6/2022 19:27:48'!
element: anElement
	element _ anElement! !

!InversionError class methodsFor: 'signaling' stamp: 'len 1/6/2022 19:37:24'!
signal: anElement
	^ self new element: anElement; signal: 'the element is not invertible'! !

!Domain methodsFor: 'accessing' stamp: 'len 4/22/2020 05:45:14'!
arity
	(self isProduct or: [self isCoproduct]) ifFalse: [^ DomainError signal: 'not a product or coproduct'].
	^ self components size! !

!Domain methodsFor: 'accessing' stamp: 'len 4/22/2020 05:45:41'!
at: anInteger
	(self isProduct or: [self isCoproduct]) ifFalse: [^ DomainError signal: 'not a product or coproduct'].
	^ self components at: anInteger! !

!Domain methodsFor: 'morphisms' stamp: 'len 3/13/2021 09:53:12'!
-< aProduct
	"Answer the canonical projections from the receiver into the components of aProduct.
	See also message >-."
	| components |
	components _ aProduct isArray ifTrue: [aProduct] ifFalse: [aProduct components].
	self propertyAt: #projections ifPresent: [:aDictionary| aDictionary at: components ifPresent: [:anArrayOfMorphisms| ^ anArrayOfMorphisms]].
	^ self toAll: components! !

!Domain methodsFor: 'morphisms' stamp: 'len 12/23/2021 17:37:55'!
-> aCodomain
	"Answer the canonical morphism from the receiver to aCodomain.
	If the argument is a morphism, answer the composition with a canonical morphism to its domain. See also Morphism>>->."
	aCodomain isMorphism ifTrue:
		[self = aCodomain domain ifTrue: [^ aCodomain].
		^ self -> aCodomain domain ifNotNil: [:aMorphism| aCodomain  aMorphism]].
	self propertyAt: #outputs ifPresent: [:aDictionary| aDictionary at: aCodomain ifPresent: [:aMorphism| ^ aMorphism]].
	aCodomain propertyAt: #inputs ifPresent: [:aDictionary| aDictionary at: self ifPresent: [:aMorphism| ^ aMorphism]].
	^ (self to: aCodomain) ifNil: [aCodomain from: self]! !

!Domain methodsFor: 'morphisms' stamp: 'len 12/25/2021 11:54:57'!
=> anObject
	"This is the Hom(A,-) functor, where A is the receiver:
	- if the argument is a domain X, answer Hom(A,X), the morphisms from A to X;
	- if the argument is a morphism g:X->Y, answer the morphism Hom(A,g):Hom(A,X)->Hom(A,Y) that sends the morphism f to gf.
	When appropriate, subclasses can implement #hom: to answer the internal Hom."
	anObject isMorphism ifTrue: [^ self => anObject domain to: self => anObject codomain evaluating: [:f| anObject  f]].
	^ (self propertyAt: #homs ifAbsentPut: [WeakIdentityKeyDictionary new]) at: anObject ifAbsentPut: [self hom: anObject]! !

!Domain methodsFor: 'morphisms' stamp: 'len 3/4/2021 18:06:32'!
>- aCodomain
	"Answer the canonical coprojections from the components of the receiver to the argument.
	See also message -<."
	^ self components >- aCodomain! !

!Domain methodsFor: 'morphisms' stamp: 'len 12/23/2021 19:01:16'!
addCoprojections: anArray
	anArray do: [:each| each codomain == self ifFalse: [^ DomainError signal]].
	^ (self propertyAt: #coprojections ifAbsentPut: [Dictionary new])
		at: (anArray collect: [:each| each domain]) put: anArray! !

!Domain methodsFor: 'morphisms' stamp: 'len 12/25/2021 12:50:42'!
addMap: aMorphism
"	(self category includes: aMorphism) ifFalse: [Error signal: 'not a morphism']."
	aMorphism domain == self
		ifTrue: [^ (self propertyAt: #outputs ifAbsentPut: [WeakIdentityKeyDictionary new]) at: aMorphism codomain put: aMorphism].
	aMorphism codomain == self
		ifTrue: [^ (self propertyAt: #inputs ifAbsentPut: [WeakIdentityKeyDictionary new]) at: aMorphism domain put: aMorphism].
	^ DomainError signal! !

!Domain methodsFor: 'morphisms' stamp: 'len 12/23/2021 19:01:07'!
addProjections: anArray
	anArray do: [:each| each domain == self ifFalse: [^ DomainError signal]].
	^ (self propertyAt: #projections ifAbsentPut: [Dictionary new])
		at: (anArray collect: [:each| each codomain]) put: anArray! !

!Domain methodsFor: 'morphisms' stamp: 'len 7/31/2020 11:49:25'!
automorphisms
	^ self subclassResponsibility! !

!Domain methodsFor: 'morphisms' stamp: 'len 4/22/2020 05:49:13'!
endomorphisms
	^ self => self! !

!Domain methodsFor: 'morphisms' stamp: 'len 12/22/2021 15:13:59'!
from: aDomain
	"Answer the canonical morphism from aDomain to the receiver."
	^ nil! !

!Domain methodsFor: 'morphisms' stamp: 'len 4/22/2020 05:49:26'!
fromAll: anArray
	"Answer the canonical coprojections from the components of anArray to the receiver."
	(self isCoproduct and: [self components = anArray])
		ifTrue: [^ self addCoprojections: ((1 to: self arity) collect: [:i| self coprojection: i])].
	^ nil! !

!Domain methodsFor: 'morphisms' stamp: 'len 12/24/2021 08:26:20'!
hom: aCodomain
	"If the argument is a domain X in the same category, answer Hom(A,X), the morphisms from A to X.
	When appropriate, subclasses can implement #hom: to answer an internal Hom.
	See also >>=>."
	(aCodomain isKindOf: ChainComplex)
		ifTrue: [^ ChainComplex differentials: (aCodomain differentials collect: [:each| self => each]) shift: aCodomain shift].
	^ HomSet from: self to: aCodomain! !

!Domain methodsFor: 'morphisms' stamp: 'len 4/22/2020 05:50:03'!
id
	"Answer the identity morphism."
	^ self subclassResponsibility! !

!Domain methodsFor: 'morphisms' stamp: 'len 12/23/2021 17:55:50'!
to: aCodomain
	"Answer the canonical morphism from the receiver to aCodomain."
	self = aCodomain ifTrue: [^ self id]. "should be =="
	^ nil! !

!Domain methodsFor: 'morphisms' stamp: 'len 12/25/2021 11:12:28'!
to: aCodomain adapting: anObject
	"Answer a morphism from the receiver to aCodomain induced by anObject, or nil."
	^ nil! !

!Domain methodsFor: 'morphisms' stamp: 'len 4/22/2020 07:05:49'!
toAll: anArray
	"Answer the canonical projections from the receiver to the components of anArray."
	(self isProduct and: [anArray = self components])
		ifTrue: [^ self addProjections: ((1 to: self arity) collect: [:i| self projection: i])].
	^ nil! !

!Domain methodsFor: 'properties' stamp: 'len 4/22/2020 05:53:39'!
hasProperty: aSymbol
	^ (properties ifNil: [^ false]) includesKey: aSymbol! !

!Domain methodsFor: 'properties' stamp: 'len 4/22/2020 05:53:56'!
properties
	^ properties ifNil: [properties _ IdentityDictionary new]! !

!Domain methodsFor: 'properties' stamp: 'len 4/22/2020 05:54:02'!
propertyAt: aSymbol
	^ self propertyAt: aSymbol ifAbsent: [self error: 'no such property']! !

!Domain methodsFor: 'properties' stamp: 'len 4/22/2020 05:54:07'!
propertyAt: aSymbol ifAbsent: exceptionBlock
	^ (properties ifNil: [^ exceptionBlock value]) at: aSymbol ifAbsent: exceptionBlock! !

!Domain methodsFor: 'properties' stamp: 'len 4/22/2020 05:54:12'!
propertyAt: aSymbol ifAbsentPut: aBlock
	^ self properties at: aSymbol ifAbsentPut: aBlock! !

!Domain methodsFor: 'properties' stamp: 'len 4/22/2020 05:54:19'!
propertyAt: aSymbol ifPresent: aBlock
	^ (properties ifNil: [^ nil]) at: aSymbol ifPresent: aBlock! !

!Domain methodsFor: 'properties' stamp: 'len 4/22/2020 05:54:25'!
propertyAt: aSymbol put: anObject
	^ self properties at: aSymbol put: anObject! !

!Domain methodsFor: 'testing' stamp: 'len 7/6/2020 14:13:14'!
isCartesianProduct
	^ false! !

!Domain methodsFor: 'testing' stamp: 'len 12/25/2021 12:31:15'!
isCoproduct
	"Answer true if the receiver is a coproduct construction."
	^ false! !

!Domain methodsFor: 'testing' stamp: 'len 12/25/2021 12:31:05'!
isProduct
	"Answer true if the receiver is a product construction."
	^ false! !

!Domain methodsFor: 'testing' stamp: 'len 12/25/2021 12:30:37'!
isQuotient
	"Answer true if the receiver is a quotient construction."
	^ false! !

!Domain methodsFor: 'testing-categories' stamp: 'len 5/2/2020 21:32:39'!
isAbelianGroup
	^ false! !

!Domain methodsFor: 'testing-categories' stamp: 'len 7/15/2020 10:29:37'!
isAgebra
	^ false! !

!Domain methodsFor: 'testing-categories' stamp: 'len 5/2/2020 21:33:10'!
isCategory
	^ false! !

!Domain methodsFor: 'testing-categories' stamp: 'len 5/2/2020 21:32:43'!
isGroup
	^ false! !

!Domain methodsFor: 'testing-categories' stamp: 'len 5/2/2020 21:32:53'!
isModule
	^ false! !

!Domain methodsFor: 'testing-categories' stamp: 'len 5/2/2020 21:32:57'!
isMonoid
	^ false! !

!Domain methodsFor: 'testing-categories' stamp: 'len 5/2/2020 21:33:00'!
isRing
	^ false! !

!Domain methodsFor: 'testing-categories' stamp: 'len 7/31/2020 11:45:28'!
isSet
	^ false! !

!Domain methodsFor: 'testing-categories' stamp: 'len 5/2/2020 21:33:05'!
isVectorSpace
	^ false! !

!Domain class methodsFor: 'examples' stamp: 'len 5/23/2020 09:13:12'!
example1asSet
	"The ring Z/5Z as a Smalltalk Set.
	This is possible because the ring is finite."
	^ (/5) asSet! !

!Domain class methodsFor: 'examples' stamp: 'len 5/23/2020 09:13:12'!
example1atRandom
	"Taking an element at random from the Z-module of rank 10.
	Use 50 bits to generate this element. Essentially, this can return
	at most 2^50 different elements, and their bitsize doesn't exceed 50
	bits (where bitsize is losely defined, in this case it's the sum
	of bitsize of the coefficients of the coordinates)."
	^ ^10 atRandom: (Random seed: 12345) bits: 50! !

!Domain class methodsFor: 'examples' stamp: 'len 5/23/2020 09:11:37'!
example21VectorSpace
	"The vector space of 3-tuples with rational coefficients."
	^  ^ 3! !

!Domain class methodsFor: 'examples' stamp: 'len 4/29/2020 17:29:40'!
example3DirectProductOfGroups
	"The direct product of the group of permutations of
	the symbols {#a, #b, #c} by the group of alternating
	permutations of {1,2,3,4}."
	^ (SymmetricGroup on: #(a b c))  (AlternatingGroup new: 4)! !

!Domain class methodsFor: 'examples' stamp: 'len 5/23/2020 09:13:12'!
example41Polynomials
	"Polynomials in two variables with integer coefficients."
	^  polynomialsIn: #(a b)! !

!Domain class methodsFor: 'examples' stamp: 'len 5/23/2020 09:03:31'!
example42AffineRing
	"The quotient of a polynomial ring by an ideal.
	This is an affine ring, in particular it is the coordinate ring of the twisted cubic."
	| R x y z I |
	R _  polynomialsIn: #(x y z).
	x _ R x: 1.
	y _ R x: 2.
	z _ R x: 3.
	I _ R * {(x^2) - y. (x^3) - z}.
	^ R / I! !

!Domain class methodsFor: 'examples' stamp: 'len 5/23/2020 09:03:36'!
example43AffineVariety
	"This is the twisted cubic affine variety, parameterized by (x, x^2, x^3) in C^3."
	| R x y z I |
	R _  polynomialsIn: #(x y z).
	x _ R x: 1.
	y _ R x: 2.
	z _ R x: 3.
	I _ R * {(x^2) - y. (x^3) - z}.
	^ (R / I) spec! !

!Domain class methodsFor: 'examples' stamp: 'len 5/23/2020 09:11:37'!
example5GL
	"The group GL(Q^3) of invertible linear maps
	on the vector space of 3-tuples with rational coefficients.
	This is the automorphisms group of the vector space, and
	its elements are linear maps, not matrices."
	^ ( ^ 3) automorphisms! !

!Domain class methodsFor: 'initialization' stamp: 'len 12/29/2021 14:06:39'!
initializeAll
	"First initialize all Domains, set globals like , , etc:"
	Domain withAllSubclassesDo: [:each| (each class selectors includes: #initialize) ifTrue: [each initialize]].
	"Then initialize all Morphisms, set globals for categories like Sets, Groups, etc:"
	Morphism withAllSubclassesDo: [:each| (each class selectors includes: #initialize) ifTrue: [each initialize]].
	"And finally initialize any other classes that need initialization:"
	BitTuple initialize.
	Ordinal initialize! !

!Structure methodsFor: 'accessing' stamp: 'len 4/22/2020 07:02:11'!
ambient
	"Domains can be subobjects of other domains, for example subspeces are subobjects of vector spaces.
	Answer the ambient domain of which the receiver is a subobject."
	^ self propertyAt: #ambient ifAbsent: [self]! !

!Structure methodsFor: 'accessing' stamp: 'len 10/17/2020 20:11:19'!
carrier
	"Answer the carrier set of the receiver. This is the forgetful functor to the category of sets."
	self isSet ifTrue: [^ self].
	^ self propertyAt: #carrier ifAbsentPut: [Structure newFrom: self]! !

!Structure methodsFor: 'accessing' stamp: 'len 12/28/2016 11:23:04'!
elements
	self propertyAt: #elements ifPresent: [:aCollectionOrDomain| ^ aCollectionOrDomain].
	^ Iterator on: self performing: #do:! !

!Structure methodsFor: 'accessing' stamp: 'len 10/6/2016 10:26'!
generator
	self generators size = 1 ifFalse: [self error: 'more than one generator'].
	^ self generators anyOne! !

!Structure methodsFor: 'accessing' stamp: 'len 10/17/2016 18:53'!
generator: anElement
	self generators: {anElement}! !

!Structure methodsFor: 'accessing' stamp: 'len 12/22/2021 14:10:56'!
generatorNamed: anObject
	"Answer the generator indexed or named by anObject."
	^ self generators at: (self names indexOf: anObject)! !

!Structure methodsFor: 'accessing' stamp: 'len 12/28/2016 11:22:22'!
generators
	"Subclases can use this or reimplement it when it makes sense."
	^ self propertyAt: #generators ifAbsent: []! !

!Structure methodsFor: 'accessing' stamp: 'len 12/28/2016 11:19:29'!
generators: aCollection
	"Subclases can use this or reimplement it when it makes sense."
	self propertyAt: #generators put: aCollection asArray! !

!Structure methodsFor: 'accessing' stamp: 'len 7/24/2020 08:02:16'!
names
	"Answer a list of symbolic names for the generators."
	^ self propertyAt: #names ifAbsentPut: [self generators size = 1 ifTrue: [#(x)] ifFalse: [(1 to: self generators size) collect: [:i| 'x', i printString sub]]]! !

!Structure methodsFor: 'accessing' stamp: 'len 12/25/2021 11:45:10'!
null
	"Answer the null or zero object in the category of the receiver, i.e. an object that is both intial and terminal. For example {id} in the case of groups (the trivial group)."
	"The null object in the category of sets is the empty set."
	^ self propertyAt: #null ifAbsent: [self species newFrom: (Set new: 0)]! !

!Structure methodsFor: 'accessing' stamp: 'len 6/5/2019 19:55:56'!
size
	^ self propertyAt: #size ifAbsentPut: [self elements size]! !

!Structure methodsFor: 'comparing' stamp: 'len 4/19/2020 07:04:52'!
< aDomain
	"Answer true if the receiver is a proper subset of aDomain (strict inclusion)."
	aDomain isFinite ifTrue: [^ self size < aDomain size and: [self allSatisfy: [:each| aDomain includes: each]]].
	self isFinite ifTrue: [^ self allSatisfy: [:each| aDomain includes: each]].
	^ self subclassResponsibility! !

!Structure methodsFor: 'comparing' stamp: 'len 6/22/2019 02:56:21'!
<= aDomain
	"Answer true if the receiver is a subset of aDomain (inclusion)."
	^ self = aDomain or: [self < aDomain]! !

!Structure methodsFor: 'comparing' stamp: 'len 3/26/2021 17:20:28'!
= aDomain
	self == aDomain ifTrue: [^ true].
	self propertyAt: #elements ifPresent: [:aCollectionOrDomain| ^ aDomain = aCollectionOrDomain].
	aDomain propertyAt: #elements ifPresent: [:aCollectionOrDomain| ^ self = aCollectionOrDomain].
	self size = aDomain size ifFalse: [^ false].
	self isFinite ifTrue: [^ self asSet = aDomain asSet].
	^ super = aDomain! !

!Structure methodsFor: 'comparing' stamp: 'len 6/22/2019 02:56:33'!
> aDomain
	"Answer true if aDomain is a proper subset of the receiver (strict inclusion)."
	^ aDomain < self! !

!Structure methodsFor: 'comparing' stamp: 'len 6/22/2019 02:56:41'!
>= aDomain
	"Answer true if aDomain is a subset of the receiver (inclusion)."
	^ aDomain <= self! !

!Structure methodsFor: 'comparing' stamp: 'len 7/31/2020 11:53:56'!
~ aDomain
	"Answer true if the receiver is isomorphic to the argument."
	(self isSet and: [aDomain isSet]) ifFalse: [^ self subclassResponsibility].
	^ self size = aDomain size! !

!Structure methodsFor: 'comparing' stamp: 'len 4/23/2016 00:41'!
hash
	^ self isFinite ifTrue: [self size hash] ifFalse: [super hash]! !

!Structure methodsFor: 'converting' stamp: 'len 4/19/2020 07:08:55'!
asArray
	^ self elements asArray! !

!Structure methodsFor: 'converting' stamp: 'len 10/17/2020 20:05:43'!
asCartesianProduct
	^ self propertyAt: #asCartesianProduct ifAbsentPut: [CartesianProduct components: self components]! !

!Structure methodsFor: 'converting' stamp: 'len 4/19/2020 07:09:10'!
asSet
	^ self elements asSet! !

!Structure methodsFor: 'elements' stamp: 'len 7/23/2021 10:38:25'!
!! anObject
	"Coerce anObject to an element of the receiver."
	(self includes: anObject) ifTrue: [^ anObject].
	anObject isElement ifTrue: [(self adapt: anObject) ifNotNil: [:anElement| ^ anElement]].
	anObject isArray ifTrue: [self carrier propertyAt: #inputs ifPresent: [:aDictionary| aDictionary keysAndValuesDo: [:domain :map| (domain includes: anObject) ifTrue: [^ map value: anObject]]]].
	(self newFrom: anObject) ifNotNil: [:anElement| ^ anElement].
	(anObject isBlock and: [self generators notNil and: [anObject numArgs = self generators size]]) ifTrue: [^ self generate: anObject].
	^ DomainError signal: 'coercion failed'! !

!Structure methodsFor: 'elements' stamp: 'len 7/19/2021 17:25:52'!
adapt: anElement
	"Coerce anElement *not* in the receiver to an element of the receiver. Subclasses should extend."
	self isAmbient ifFalse: [(self ambient adapt: anElement) ifNotNil: [:coerced| (self contains: coerced) ifTrue: [^ coerced]]].
	self category = anElement parent category ifTrue: [anElement parent -> self ifNotNil: [:aMorphism| ^ aMorphism value: anElement]].
"	self propertyAt: #inputCoercions ifPresent: [:aDictionary| aDictionary at: anElement parent ifPresent: [:aMorphism| ^ aMorphism]].
	anElement parent propertyAt: #outputCoercions ifPresent: [:aDictionary| aDictionary at: self ifPresent: [:aMorphism| ^ aMorphism]]."
	anElement parent carrier -> self carrier ifNotNil: [:aMorphism| ^ aMorphism value: anElement].
	^ nil! !

!Structure methodsFor: 'elements' stamp: 'len 7/22/2021 18:47:03'!
addCoercionFrom: aDomain evaluating: aBlock
	^ self carrier addMap: (aDomain carrier to: self carrier evaluating: aBlock)! !

!Structure methodsFor: 'elements' stamp: 'len 7/22/2021 18:46:57'!
addCoercionFrom: aCartesianProduct evaluatingWithArguments: aBlock
	^ self carrier addMap: (aCartesianProduct to: self carrier evaluatingWithArguments: aBlock)! !

!Structure methodsFor: 'elements' stamp: 'len 7/22/2021 18:46:50'!
addCoercionTo: aDomain evaluating: aBlock
	^ self carrier addMap: (self carrier to: aDomain carrier evaluating: aBlock)! !

!Structure methodsFor: 'elements' stamp: 'len 12/26/2016 11:31:05'!
generate: aBlock
	"Answer the result of evaluating aBlock on the generators of the receiver."
	^ aBlock valueWithArguments: self generators asArray! !

!Structure methodsFor: 'elements' stamp: 'len 5/10/2020 16:24:03'!
newFrom: anObject
	((self isProduct or: [self isCoproduct]) and: [anObject isSequenceable and: [anObject size = self arity]])
		ifTrue: [^ self compose: (self components with: anObject collect: [:eachDomain :eachElement| eachDomain !! eachElement])].
	^ nil! !

!Structure methodsFor: 'elements' stamp: 'len 5/13/2019 14:18:36'!
x: anInteger
	"Answer the anInteger-th generator of the receiver."
	^ self generators at: anInteger! !

!Structure methodsFor: 'enumerating' stamp: 'len 5/1/2016 23:22'!
allSatisfy: aBlock
	self do: [:each| (aBlock value: each) ifFalse: [^ false]].
	^ true! !

!Structure methodsFor: 'enumerating' stamp: 'len 5/1/2016 23:21'!
anySatisfy: aBlock
	self do: [:each| (aBlock value: each) ifTrue: [^ true]].
	^ false! !

!Structure methodsFor: 'enumerating' stamp: 'len 5/10/2020 23:06:40'!
collect: aBlock
	| elements |
	elements _ self propertyAt: #elements ifAbsent: [self].
	^ Iterator on: [:iteratorBlock|
		| visited image |
		visited _ Set new.
		elements do: [:each| visited add: (image _ aBlock value: each) ifAbsent: [iteratorBlock value: image]]]! !

!Structure methodsFor: 'enumerating' stamp: 'len 9/16/2018 16:11:56'!
count: aBlock
	| answer |
	answer _ 0.
	self do: [:each| (aBlock value: each) ifTrue: [answer _ answer + 1]].
	^ answer! !

!Structure methodsFor: 'enumerating' stamp: 'len 7/29/2016 06:45'!
detect: aBlock
	"Evaluate aBlock with each of the receiver's elements as the argument. 
	Answer the first element for which aBlock evaluates to true."

	^ self detect: aBlock ifNone: [self error: 'Element is not in the domain']! !

!Structure methodsFor: 'enumerating' stamp: 'len 9/3/2016 07:19'!
detect: aBlock ifNone: exceptionBlock
	"Evaluate aBlock with each of the receiver's elements as the argument. 
	Answer the first element for which aBlock evaluates to true. If none 
	evaluate to true, then evaluate the argument, exceptionBlock."

	self do: [:each | (aBlock value: each) ifTrue: [^each]].
	^ exceptionBlock value! !

!Structure methodsFor: 'enumerating' stamp: 'len 12/28/2016 11:21:06'!
do: aBlock
	(self propertyAt: #elements ifAbsent: [self subclassResponsibility]) do: aBlock! !

!Structure methodsFor: 'enumerating' stamp: 'len 4/25/2016 09:44'!
do: elementBlock separatedBy: separatorBlock
	| beforeFirst | 
	"Evaluate the elementBlock for all elements in the receiver,
	and evaluate the separatorBlock between."

	beforeFirst _ true.
	self do: [ :element |
		beforeFirst
			ifTrue: [beforeFirst _ false]
			ifFalse: [separatorBlock value].
		elementBlock value: element]! !

!Structure methodsFor: 'enumerating' stamp: 'len 2/15/2017 11:26:26'!
max: aBlock
	^ self elements max: aBlock! !

!Structure methodsFor: 'enumerating' stamp: 'len 2/15/2017 11:26:35'!
min: aBlock
	^ self elements min: aBlock! !

!Structure methodsFor: 'enumerating' stamp: 'len 4/28/2018 05:05:39'!
noneSatisfy: aBlock
	self do: [:each| (aBlock value: each) ifTrue: [^ false]].
	^ true! !

!Structure methodsFor: 'enumerating' stamp: 'len 5/3/2018 01:29:25'!
product: aBlock
	^ self elements product: aBlock! !

!Structure methodsFor: 'enumerating' stamp: 'len 5/10/2020 23:07:16'!
reject: aBlock
	| elements |
	elements _ self propertyAt: #elements ifAbsent: [self].
	^ Iterator on: [:iteratorBlock| elements do: [:each| (aBlock value: each) ifFalse: [iteratorBlock value: each]]]! !

!Structure methodsFor: 'enumerating' stamp: 'len 5/10/2020 23:07:40'!
select: aBlock
	| elements |
	elements _ self propertyAt: #elements ifAbsent: [self].
	^ Iterator on: [:iteratorBlock| elements do: [:each| (aBlock value: each) ifTrue: [iteratorBlock value: each]]]! !

!Structure methodsFor: 'enumerating' stamp: 'len 5/3/2018 01:29:16'!
sum: aBlock
	^ self elements sum: aBlock! !

!Structure methodsFor: 'enumerating' stamp: 'len 3/17/2021 14:24:58'!
tuples: n do: aBlock
	"Iterate over n-tuples without repetitions.
	The receiver can have infinite size, in which case this never ends. However, following the ordering of the iteration on single elements implemented in #do:, it is guaramteed that at some point in finite time all tuples of elements < to a given element will have been covered."
	self tuples: n upTo: self size do: aBlock! !

!Structure methodsFor: 'enumerating' stamp: 'len 5/28/2020 18:01:41'!
tuples: n upTo: max do: aBlock
	"Iterate over the n-tuples up to max elements."
	| k |
	n = 0 ifTrue: [^ aBlock value: #()].
	k _ 1.
	self upTo: max do: [:s|
		self  tuples: n-1 upTo: k do: [:p|
			aBlock value: (p copyWith: s).
			(p includes: s) ifTrue: [self upTo: k-1 do: [:t| aBlock value: (p copyWith: t)]]].
		k _ k + 1]! !

!Structure methodsFor: 'enumerating' stamp: 'len 8/1/2016 03:53'!
upTo: maximumNumberOfElements
	| answer |
	answer _ OrderedCollection new.
	self do: [:each|
		answer size >= maximumNumberOfElements ifTrue: [^ answer].
		answer add: each].
	^ answer! !

!Structure methodsFor: 'enumerating' stamp: 'len 7/25/2016 23:46'!
upTo: max do: aBlock
	"Iterate over the elements of the receiver, just like #do:, but stop after max elements."
	| k |
	k _ 1.
	self do: [:each|
		k > max ifTrue: [^ self].
		aBlock value: each.
		k _ k+1]! !

!Structure methodsFor: 'morphisms' stamp: 'len 5/13/2019 17:12:18'!
apply: aMorphism
	"Answer the homomorphic image of the receiver."
	^ (aMorphism isBlock ifTrue: [self] ifFalse: [aMorphism codomain]) span: ((self generators ifNil: [^ self collect: aMorphism]) apply: aMorphism)! !

!Structure methodsFor: 'morphisms' stamp: 'len 7/31/2020 11:49:07'!
automorphisms
	self isSet ifFalse: [^ super automorphisms].
	^ SymmetricGroup on: self! !

!Structure methodsFor: 'morphisms' stamp: 'len 7/9/2021 06:39:32'!
id
	"Answer the identity morphism."
	^ self propertyAt: #id ifAbsentPut:
		[| answer |
		answer _ self to: self evaluating: [:x| x].
		answer properties
			at: #isIdentity put: true;
			at: #retraction put: answer;
			at: #section put: answer;
			at: #image put: self.
		answer]! !

!Structure methodsFor: 'morphisms' stamp: 'len 5/27/2018 03:49:31'!
into: aCodomain evaluating: aBlock
	"Answer an embedding (an injective morphism) into the specified codomain (in the same category), evaluating as the given block."
	^ self to: aCodomain evaluating: aBlock! !

!Structure methodsFor: 'morphisms' stamp: 'len 5/24/2019 10:47:21'!
into: aCodomain mapping: aBlock
	^ self to: aCodomain mapping: aBlock! !

!Structure methodsFor: 'morphisms' stamp: 'len 5/27/2018 03:49:05'!
onto: aCodomain evaluating: aBlock
	"Answer a projection (a surjective morphism) onto the specified codomain (in the same category), evaluating as the given block."
	^ self to: aCodomain evaluating: aBlock! !

!Structure methodsFor: 'morphisms' stamp: 'len 5/24/2019 10:47:30'!
onto: aCodomain mapping: aBlock
	^ self to: aCodomain mapping: aBlock! !

!Structure methodsFor: 'morphisms' stamp: 'len 12/22/2021 15:12:32'!
to: aCodomain
	"Answer the canonical morphism from the receiver to aCodomain."
	self ambient = aCodomain ifTrue: [^ self into: aCodomain evaluating: [:x| x]].
	self isAmbient ifFalse: [self ambient -> aCodomain ifNotNil: [:aMorphism| ^ self -> self ambient -> aMorphism]].
	(self ambient = aCodomain ambient and: [self <= aCodomain]) ifTrue: [^ self to: aCodomain evaluating: [:x| x]].
	^ super to: aCodomain! !

!Structure methodsFor: 'morphisms' stamp: 'len 12/23/2021 15:29:25'!
to: aCodomain evaluating: aBlock
	"Answer a morphism to the specified codomain (in the same category), evaluating as the given block."
	(self isSet and: [aCodomain isSet]) ifFalse: [^ self subclassResponsibility].
	^ Function from: self to: aCodomain evaluating: aBlock! !

!Structure methodsFor: 'morphisms' stamp: 'len 5/23/2020 09:51:43'!
to: aCodomain evaluatingWithArguments: aBlock
	"When the receiver is N-ary, this method allows to define morphisms by N-ary blocks.
	Example:    to:  evaluatingWithArguments: [:a :b| a * b]."
	^ self to: aCodomain evaluating: [:each| aBlock valueWithArguments: each asArray]! !

!Structure methodsFor: 'morphisms' stamp: 'len 5/24/2019 10:46:58'!
to: aCodomain mapping: aBlock
	"Answer a morphism defined by images of generators.
	aBlock takes indices i and evaluates to the image of the i-th generator."
	^ self subclassResponsibility! !

!Structure methodsFor: 'morphisms' stamp: 'len 7/8/2020 12:04:45'!
toAll: anArray
	"Answer the canonical projections from the receiver to the components of anArray."
	(self isProduct and: [anArray = self components])
		ifTrue: [^ self addProjections: ((1 to: self arity) collect: [:i| self projection: i])].
	self isAmbient ifFalse: [(self ambient toAll: anArray) ifNotNil: [:anArrayOfMorphisms| ^ anArrayOfMorphisms collect: [:each| self -> self ambient -> each]]].
	^ nil! !

!Structure methodsFor: 'operations' stamp: 'len 12/30/2017 15:19:47'!
, aDomain
	"Answer the cartesian set product of the receiver with the argument."
	^ CartesianProduct components: {self. aDomain}! !

!Structure methodsFor: 'operations' stamp: 'len 7/31/2020 11:56:22'!
/\ aDomain
	"Answer the intersection of the receiver and the argument."
	self isSet ifFalse: [^ self subclassResponsibility].
	^ self select: [:each| aDomain includes: each]! !

!Structure methodsFor: 'operations' stamp: 'len 12/23/2021 13:40:34'!
^ anInteger
	^ CartesianProduct components: (Array new: anInteger withAll: self carrier)! !

!Structure methodsFor: 'operations' stamp: 'len 12/30/2017 16:36:36'!
 aDomain
	"This is a convenience method for doing categorical products. Subclasses can reimplement it to mean something different from the categorical product in order to match customary notation."
	^ self  aDomain! !

!Structure methodsFor: 'operations' stamp: 'len 7/31/2020 11:50:45'!
 aDomain
	"Answer the categorical product of the receiver with the argument."
	"The product in the category of sets is the cartesian product. Subclasses can redefine."
	self isSet ifFalse: [^ self subclassResponsibility].
	^ self, aDomain! !

!Structure methodsFor: 'operations' stamp: 'len 5/3/2021 10:38:56'!
 aDomain
	"Answer the categorical product of the receiver with the argument."
	"The product in the category of sets is the cartesian product. Subclasses can redefine."
	self isSet ifFalse: [^ self subclassResponsibility].
	^ self, aDomain! !

!Structure methodsFor: 'operations' stamp: 'len 5/3/2021 10:40:41'!
 aDomain
	"Answer the categorical coproduct of the receiver with the argument."
	"The coproduct in the category of sets is the disjoint union. Subclasses can redefine."
	^ self notYetImplemented! !

!Structure methodsFor: 'random' stamp: 'len 3/11/2021 16:38:02'!
atRandom
	"Answer an element in the receiver choosen at random. This will fail if the receiver is not finite."
	^ self atRandom: self newRandom! !

!Structure methodsFor: 'random' stamp: 'len 4/19/2020 07:12:07'!
atRandom: aRandom
	"Answer an element in the receiver choosen at random. This will fail if the receiver is not finite."
	self propertyAt: #elements ifPresent: [:aCollectionOrDomain| ^ aCollectionOrDomain atRandom: aRandom].
	^ self atRandom: aRandom bits: Infinity positive! !

!Structure methodsFor: 'random' stamp: 'len 5/25/2020 07:55:53'!
atRandom: aRandom bits: bitSize
	"Answer an element of the receiver of at most n bits (as measured by #bitSize). The total number of elements that could be returned shouldn't exceed 2^n."
	self propertyAt: #elements ifPresent: [:aCollectionOrDomain| ^ aCollectionOrDomain atRandom: aRandom bits: bitSize].
	^ self elements asSet atRandom: aRandom! !

!Structure methodsFor: 'random' stamp: 'len 3/11/2021 16:39:29'!
atRandomBits: bitSize
	"Answer an element of the receiver of at most n bits (as measured by #bitSize). The total number of elements that could be returned shouldn't exceed 2^n."
	^ self atRandom: self newRandom bits: bitSize! !

!Structure methodsFor: 'random' stamp: 'len 12/25/2021 11:39:44'!
to: aCodomain atRandom: aRandom
	"Answer a morphism from the receiver to aCodomain choosen at random."
	self flag: #fix. "this doesnt always make sense, it works for free structures"
	^ self to: aCodomain mapping: [:i| aCodomain atRandom: aRandom]! !

!Structure methodsFor: 'random' stamp: 'len 12/25/2021 11:41:40'!
to: aCodomain atRandom: aRandom bits: bitSize
	"Answer a morphism from the receiver to aCodomain choosen at random of at most n bits (as measured by #bitSize). The total number of morphisms that could be returned shouldn't exceed 2^n."
	| n |
	self flag: #fix. "this doesnt always make sense, it works for free objects"
	n _ bitSize / (aCodomain generators size max: 1).
	^ self to: aCodomain mapping: [:i| aCodomain atRandom: aRandom bits: n]! !

!Structure methodsFor: 'testing' stamp: 'len 4/19/2019 07:15:03'!
contains: anElement
	"Answer true if the receiver contains the given element of its ambient.
	This is similar to >>includes: but less checks are needed, because the element is not an arbitrary object."
	self isAmbient ifTrue: [^ true].
	^ self elements includes: anElement! !

!Structure methodsFor: 'testing' stamp: 'len 12/13/2016 07:34:43'!
containsAllOf: aCollection 
	"Answer whether all the elements of aCollection are in the receiver."
	aCollection do: [:each| (self contains: each) ifFalse: [^ false]].
	^ true! !

!Structure methodsFor: 'testing' stamp: 'len 6/23/2016 07:04'!
includes: anElement
	^ self elements includes: anElement! !

!Structure methodsFor: 'testing' stamp: 'len 6/24/2016 05:59'!
includesAllOf: aCollection 
	"Answer whether all the elements of aCollection are in the receiver."
	aCollection do: [:each| (self includes: each) ifFalse: [^ false]].
	^ true! !

!Structure methodsFor: 'testing' stamp: 'len 4/29/2020 21:16:49'!
isAmbient
	^ self ambient == self! !

!Structure methodsFor: 'testing' stamp: 'len 11/2/2016 08:54'!
isEmpty
	^ self size = 0! !

!Structure methodsFor: 'testing' stamp: 'len 12/28/2016 11:23:17'!
isFinite
	^ self propertyAt: #isFinite ifAbsent: [self size isInfinite not]! !

!Structure methodsFor: 'testing' stamp: 'len 6/17/2016 22:20'!
isInfinite
	^ self isFinite not! !

!Structure methodsFor: 'testing-categories' stamp: 'len 7/31/2020 11:45:53'!
isSet
	^ self species = Structure! !

!Structure methodsFor: 'private' stamp: 'len 4/22/2020 07:06:13'!
ambient: aDomain
	self propertyAt: #ambient put: aDomain! !

!Structure methodsFor: 'private' stamp: 'len 12/28/2016 11:20:10'!
elements: aCollection
	self propertyAt: #elements put: aCollection! !

!Structure methodsFor: 'private' stamp: 'len 3/11/2021 16:38:21'!
newRandom
	^ Random seed: (Random withDefaultDo: [:aRandom| aRandom nextChunkBits])! !

!Structure methodsFor: 'private' stamp: 'len 7/31/2020 11:34:56'!
species
	^ Structure! !

!Structure class methodsFor: 'instance creation' stamp: 'len 4/23/2016 03:40'!
newFrom: anObject
	^ self new elements: anObject! !

!CartesianProduct methodsFor: 'accessing' stamp: 'len 11/10/2015 22:13'!
components
	^ components! !

!CartesianProduct methodsFor: 'accessing' stamp: 'len 2/26/2017 09:47:17'!
size
	^ components product: [:each| each size]! !

!CartesianProduct methodsFor: 'comparing' stamp: 'len 9/16/2018 16:11:29'!
= anObject
	^ (anObject isKindOf: CartesianProduct) and: [components = anObject components]! !

!CartesianProduct methodsFor: 'comparing' stamp: 'len 11/10/2015 23:19'!
hash
	^ components hash! !

!CartesianProduct methodsFor: 'elements' stamp: 'len 5/10/2020 16:25:06'!
compose: anArray
	^ anArray asArray! !

!CartesianProduct methodsFor: 'enumerating' stamp: 'len 7/29/2016 06:53'!
do: aBlock
	(self components allSatisfy: [:each| each isFinite])
		ifFalse: [^ self upTo: self size rank: self arity do: aBlock].
	self upToComponent: self arity do: aBlock! !

!CartesianProduct methodsFor: 'enumerating' stamp: 'len 11/5/2016 10:29'!
upTo: max rank: n do: aBlock
	| k |
	self notYetImplemented.
	n = 0 ifTrue: [^ aBlock value: #()].
	k _ 1.
	(self at: n) upTo: max do: [:s|
		self upTo: k rank: n-1 do: [:p|
			aBlock value: {p. s}.
			"(self at: n) upTo: k-1 do: [:t| (p includes: s) ifTrue: [aBlock value: (p,t)]]"].
		k _ k + 1]! !

!CartesianProduct methodsFor: 'enumerating' stamp: 'len 3/17/2021 14:29:36'!
upToComponent: k do: aBlock
	k = 0 ifTrue: [aBlock value: #(). ^ self].
	self upToComponent: k-1 do: [:each| (self components at: k) do: [:last| aBlock value: (each copyWith: last)]]! !

!CartesianProduct methodsFor: 'morphisms' stamp: 'len 12/22/2021 15:04:08'!
from: aDomain
	aDomain -< self ifNotNil: [:anArray| ^ aDomain carrier to: self evaluating: [:x| anArray collect: [:|  value: x]]].
	^ super from: aDomain! !

!CartesianProduct methodsFor: 'morphisms' stamp: 'len 5/23/2020 07:29:42'!
projection: i
	^ (self to: (self at: i) evaluating: [:x| x at: i]) name: '', i printText sub! !

!CartesianProduct methodsFor: 'operations' stamp: 'len 12/30/2017 15:19:20'!
, aDomain
	^ aDomain class == self class
		ifTrue: [self class components: components, aDomain components]
		ifFalse: [self class components: (components copyWith: aDomain)]! !

!CartesianProduct methodsFor: 'random' stamp: 'len 4/19/2016 20:28'!
atRandom: aRandom
	^ components collect: [:each| each atRandom: aRandom]! !

!CartesianProduct methodsFor: 'random' stamp: 'len 4/19/2016 20:28'!
atRandom: aRandom bits: bitSize
	| n |
	n _ bitSize / components size.
	^ components collect: [:each| each atRandom: aRandom bits: n]! !

!CartesianProduct methodsFor: 'testing' stamp: 'len 4/21/2020 15:16:12'!
includes: anObject
	anObject isSequenceable ifFalse: [^ false].
	components size = anObject size ifFalse: [^ false].
	components with: anObject do: [:X :x| (X includes: x) ifFalse: [^ false]].
	^ true! !

!CartesianProduct methodsFor: 'testing' stamp: 'len 7/6/2020 14:13:25'!
isCartesianProduct
	^ true! !

!CartesianProduct methodsFor: 'testing' stamp: 'len 4/14/2020 21:09:33'!
isProduct
	^ true! !

!CartesianProduct methodsFor: 'private' stamp: 'len 11/5/2016 06:40'!
components: anArray
	components _ anArray! !

!CartesianProduct class methodsFor: 'examples' stamp: 'len 5/23/2020 08:59:16'!
example
	"The cartesian product of the ring of rational integers
	and the field of rational numbers (as sets).
	An element of this cartesian product is an array with an
	integer in the first component and a rational number
	in the second component."
	^ (, )
! !

!CartesianProduct class methodsFor: 'instance creation' stamp: 'len 11/10/2015 22:17'!
components: anArray
	^ self new components: anArray! !

!Category methodsFor: 'comparing' stamp: 'len 4/26/2020 17:31:03'!
= anObject
	^ self class = anObject class and: [self name = anObject name]! !

!Category methodsFor: 'comparing' stamp: 'len 4/26/2020 17:31:07'!
hash
	^ self name hash! !

!Category methodsFor: 'morphisms' stamp: 'len 5/2/2020 21:09:51'!
to: aCodomain evaluating: aBlock
	aCodomain isCategory ifFalse: [^ DomainError signal].
	^ Functor from: self to: aCodomain evaluating: aBlock! !

!Category methodsFor: 'testing' stamp: 'len 4/26/2020 19:01:25'!
includes: aMorphism
	^ aMorphism category = self! !

!Category methodsFor: 'testing' stamp: 'len 10/30/2020 11:10:58'!
isAbelian
	^ false! !

!Category methodsFor: 'testing-categories' stamp: 'len 5/2/2020 21:33:26'!
isCategory
	^ true! !

!Category methodsFor: 'private' stamp: 'len 4/26/2020 17:40:03'!
name: aString
	self propertyAt: #name put: aString asSymbol! !

!Category methodsFor: 'private' stamp: 'len 5/2/2020 05:07:09'!
species
	^ Category! !

!Category methodsFor: 'as yet unclassified' stamp: 'len 10/30/2020 11:12:02'!
ChainComplexes
	self isAbelian ifFalse: [DomainError signal: 'not an abelian category'].
	^ self propertyAt: #ChainComplexes ifAbsentPut: [ChainComplexes over: self]! !

!Category methodsFor: 'as yet unclassified' stamp: 'len 10/30/2020 11:11:34'!
CochainComplexes
	^ self ChainComplexes opposite! !

!Modules methodsFor: 'accessing' stamp: 'len 4/26/2020 17:46:06'!
scalars
	^ self propertyAt: #scalars! !

!Modules methodsFor: 'accessing' stamp: 'len 4/8/2021 12:22:45'!
unit
	^ self scalars asIdeal! !

!Modules methodsFor: 'comparing' stamp: 'len 4/26/2020 17:52:29'!
= anObject
	^ self class = anObject class and: [self scalars = anObject scalars]! !

!Modules methodsFor: 'comparing' stamp: 'len 4/26/2020 17:52:39'!
hash
	^ self scalars hash! !

!Modules methodsFor: 'testing' stamp: 'len 10/30/2020 11:21:04'!
isAbelian
	^ true! !

!Modules methodsFor: 'private' stamp: 'len 4/26/2020 17:46:15'!
scalars: aRing
	self propertyAt: #scalars put: aRing! !

!Modules class methodsFor: 'instance creation' stamp: 'len 6/20/2020 12:39:11'!
over: aRing
	^ self new scalars: aRing! !

!ChainComplexes methodsFor: 'accessing' stamp: 'len 4/26/2020 17:43:12'!
chains
	^ self propertyAt: #chains! !

!ChainComplexes methodsFor: 'accessing' stamp: 'len 10/30/2020 11:13:18'!
opposite
	^ self propertyAt: #opposite ifAbsentPut: [CochainComplexes opposite: self]! !

!ChainComplexes methodsFor: 'initialization' stamp: 'len 4/26/2020 17:43:27'!
chains: anAbelianCategory
	self propertyAt: #chains put: anAbelianCategory! !

!ChainComplexes methodsFor: 'testing' stamp: 'len 10/30/2020 11:21:35'!
isAbelian
	^ true! !

!ChainComplexes class methodsFor: 'instance creation' stamp: 'len 6/20/2020 12:40:03'!
over: anAbelianCategory
	^ self new chains: anAbelianCategory! !

!CochainComplexes methodsFor: 'accessing' stamp: 'len 10/30/2020 11:13:38'!
cochains
	^ opposite chains! !

!CochainComplexes methodsFor: 'accessing' stamp: 'len 10/30/2020 11:09:39'!
opposite
	^ opposite! !

!CochainComplexes methodsFor: 'initialization' stamp: 'len 10/30/2020 11:15:00'!
opposite: aChainComplexes
	opposite _ aChainComplexes! !

!CochainComplexes methodsFor: 'testing' stamp: 'len 10/30/2020 11:22:24'!
isAbelian
	^ true! !

!CochainComplexes class methodsFor: 'as yet unclassified' stamp: 'len 10/30/2020 11:14:44'!
opposite: aChainComplexes
	^ self new opposite: aChainComplexes! !

!HomSet methodsFor: 'accessing' stamp: 'len 3/11/2020 11:21:36'!
codomain
	^ codomain! !

!HomSet methodsFor: 'accessing' stamp: 'len 3/11/2020 11:21:42'!
domain
	^ domain! !

!HomSet methodsFor: 'comparing' stamp: 'len 4/30/2020 09:13:30'!
= anObject
	^ self class == anObject class and: [self domain = anObject domain and: [self codomain = anObject codomain]]! !

!HomSet methodsFor: 'comparing' stamp: 'len 4/30/2020 09:14:39'!
hash
	^ self domain hash hashMultiply + self codomain hash! !

!HomSet methodsFor: 'elements' stamp: 'len 12/25/2021 11:06:08'!
adapt: anElement
	^ (super adapt: anElement) ifNil: [self domain to: self codomain adapting: anElement]! !

!HomSet methodsFor: 'elements' stamp: 'len 8/31/2016 03:37'!
evaluating: aBlock
	^ self domain to: self codomain evaluating: aBlock! !

!HomSet methodsFor: 'elements' stamp: 'len 5/24/2019 11:28:29'!
mapping: aBlock
	"Answer a morphism defined by images of generators.
	aBlock takes indices i and evaluates to the image of the i-th generator."
	^ self domain to: self codomain mapping: aBlock! !

!HomSet methodsFor: 'elements' stamp: 'len 4/9/2020 07:20:29'!
newFrom: anObject
	anObject isEvaluable ifTrue: [^ self evaluating: anObject].
	^ super newFrom: anObject! !

!HomSet methodsFor: 'random' stamp: 'len 12/25/2021 10:20:09'!
atRandom: aRandom
	^ self domain to: self codomain atRandom: aRandom! !

!HomSet methodsFor: 'random' stamp: 'len 12/25/2021 10:20:32'!
atRandom: aRandom bits: bitSize
	^ self domain to: self codomain atRandom: aRandom bits: bitSize! !

!HomSet methodsFor: 'testing' stamp: 'len 5/8/2020 15:46:16'!
includes: anObject
	^ anObject isMorphism and: [anObject domain = self domain and: [anObject codomain = self codomain]]! !

!HomSet methodsFor: 'testing' stamp: 'len 4/19/2016 04:53'!
isEndomorphisms
	^ self domain = self codomain! !

!HomSet methodsFor: 'private' stamp: 'len 3/11/2020 11:22:05'!
codomain: aDomain
	codomain _ aDomain! !

!HomSet methodsFor: 'private' stamp: 'len 3/11/2020 11:21:58'!
domain: aDomain
	domain _ aDomain! !

!HomSet class methodsFor: 'examples' stamp: 'len 12/23/2021 19:37:12'!
example1
	"The set Hom(N,Z), the functions from the natural numbers to the integers.
	This is the space of sequences. (See class Sequence)."
	^  =>  carrier! !

!HomSet class methodsFor: 'examples' stamp: 'len 5/23/2020 09:13:12'!
example2
	"The endomorphisms of the rational integers Z.
	This is Hom(Z,Z), the set of ring homomorphisms from Z to itself."
	^  endomorphisms! !

!HomSet class methodsFor: 'examples' stamp: 'len 5/23/2020 09:11:37'!
example3
	"In some categories the Hom-Set has actually richer structure,
	and can be seen as an object of the category.
	Here's the vector space of linear maps from the Q^3 to Q^5.
	This is the internal hom(Q^3,Q^5), and it is a vector space itself.
	(It is not an instance of HomSet.)"
	^ (^3) => (^5)! !

!HomSet class methodsFor: 'instance creation' stamp: 'len 8/7/2020 15:07:48'!
from: aDomain to: aCodomain
	^ self new domain: aDomain; codomain: aCodomain! !

!RationalPointSet methodsFor: 'accessing' stamp: 'len 11/7/2016 16:25'!
scalars
	^ self domain coordinateRing! !

!RationalPointSet methodsFor: 'accessing' stamp: 'len 12/28/2016 11:24:20'!
size
	^ self propertyAt: #size ifAbsentPut: [self codomain pointsCountOver: self scalars]! !

!RationalPointSet methodsFor: 'enumerating' stamp: 'len 11/7/2016 16:25'!
do: aBlock
	self codomain pointsOver: self scalars do: aBlock! !

!Naturals methodsFor: 'accessing' stamp: 'len 2/13/2016 20:41'!
identity
	^ 1! !

!Naturals methodsFor: 'accessing' stamp: 'len 12/29/2021 11:55:57'!
size
	^ Cardinal new! !

!Naturals methodsFor: 'comparing' stamp: 'len 12/14/2015 01:55'!
= anObject
	^ self class == anObject class! !

!Naturals methodsFor: 'comparing' stamp: 'len 12/14/2015 01:55'!
hash
	^ self class hash! !

!Naturals methodsFor: 'enumerating' stamp: 'len 12/3/2015 20:12'!
do: aBlock
	| n |
	n _ 1.
	[aBlock value: n. n _ n + 1] repeat! !

!Naturals methodsFor: 'morphisms' stamp: 'len 7/30/2020 20:38:12'!
to: aCodomain evaluating: aBlock
	"Answer a sequence with values in aCodomain."
	"aCodomain isSet ifFalse: [^ DomainError signal]."
	^ Sequence to: aCodomain evaluating: aBlock! !

!Naturals methodsFor: 'random' stamp: 'len 6/30/2016 00:34'!
atRandom: aRandom bits: bitSize
	^ (aRandom nextBits: bitSize truncated) + 1! !

!Naturals methodsFor: 'testing' stamp: 'len 12/5/2015 02:09'!
isFinite
	^ false! !

!Naturals methodsFor: 'testing' stamp: 'len 2/11/2016 22:19'!
isReal
	^ true! !

!Naturals class methodsFor: 'initialization' stamp: 'len 5/23/2020 08:50:31'!
initialize
	super initialize.
	Smalltalk at: # put: self new! !

!Monoid methodsFor: 'accessing' stamp: 'len 5/1/2020 15:38:48'!
identity
	self isAmbient ifFalse: [^ self ambient identity].
	^ self propertyAt: #identity ifAbsent: [self do: [:each| ^ self propertyAt: #identity put: each  each inverse]]! !

!Monoid methodsFor: 'morphisms' stamp: 'len 12/22/2021 15:05:45'!
from: aDomain
	aDomain isCartesianProduct
		ifTrue: [aDomain >- self ifNotNil: [:anArray| ^ aDomain to: self carrier evaluating: [:x| (1 to: anArray size) inject: self identity into: [:result :i| result  ((anArray at: i) value: (x at: i))]]]].
	^ super from: aDomain! !

!Monoid methodsFor: 'morphisms' stamp: 'len 5/2/2020 21:12:35'!
to: aMonoid evaluating: aBlock
	aMonoid isMonoid ifFalse: [^ DomainError signal].
	^ MonoidMap from: self to: aMonoid evaluating: aBlock! !

!Monoid methodsFor: 'morphisms' stamp: 'len 3/13/2021 10:09:37'!
to: aMonoid mapping: aBlock
	"Answer a morphism defined by images of generators.
	aBlock takes indices i and evaluates to the image of the i-th generator."
	aMonoid isMonoid ifFalse: [^ DomainError signal].
	^ MonoidMap from: self to: aMonoid mapping: aBlock! !

!Monoid methodsFor: 'testing' stamp: 'len 4/26/2020 06:13:34'!
isCommutative
	| X |
	self propertyAt: #isCommutative ifPresent: [:aBoolean| ^ aBoolean].
	X _ self generators ifNil: [self].
	X do: [:x| X do: [:y| x  y = (y  x) ifFalse: [^ false]]].
	^ true! !

!Monoid methodsFor: 'testing' stamp: 'len 2/14/2016 18:08'!
isMonoid
	^ true! !

!Monoid methodsFor: 'testing' stamp: 'len 5/13/2019 12:29:33'!
isTrivial
	"Answer true if the receiver is the trivial monoid {id}."
	| generators |
	self propertyAt: #elements ifPresent: [:aCollection| ^ aCollection size = 1].
	generators _ self generators ifNil: [^ self size = 1].
	^ generators allSatisfy: [:each| each = self identity]! !

!Monoid methodsFor: 'private' stamp: 'len 5/2/2020 05:14:38'!
species
	^ Monoid! !

!FreeAbelianMonoid methodsFor: 'accessing' stamp: 'len 5/13/2019 12:26:39'!
generators
	^ self propertyAt: #generators ifAbsentPut: [(1 to: rank) collect: [:i| self x: i to: 1]]! !

!FreeAbelianMonoid methodsFor: 'accessing' stamp: 'len 5/13/2019 11:53:52'!
identity
	^ self propertyAt: #identity ifAbsentPut: [(Monomial new: rank) parent: self]! !

!FreeAbelianMonoid methodsFor: 'accessing' stamp: 'len 2/27/2017 07:37:47'!
names: anArray
	"Set indeterminate names to use when printing monomials."
	self propertyAt: #names put: anArray! !

!FreeAbelianMonoid methodsFor: 'accessing' stamp: 'len 11/20/2016 11:03:52'!
ordering
	^ ordering! !

!FreeAbelianMonoid methodsFor: 'accessing' stamp: 'len 6/28/2016 23:37'!
rank
	^ rank! !

!FreeAbelianMonoid methodsFor: 'accessing' stamp: 'len 12/29/2021 11:55:57'!
size
	^ self rank > 0 ifTrue: [Cardinal new] ifFalse: [1]! !

!FreeAbelianMonoid methodsFor: 'comparing' stamp: 'len 1/14/2022 11:58:10'!
= anObject
	self == anObject ifTrue: [^ true].
	^ self class == anObject class and: [rank = anObject rank and: [ordering = anObject ordering]]! !

!FreeAbelianMonoid methodsFor: 'comparing' stamp: 'len 3/3/2021 12:37:23'!
hash
	^ self rank hash + self ordering hash! !

!FreeAbelianMonoid methodsFor: 'elements' stamp: 'len 7/31/2021 12:35:52'!
\ aMonomial
	"Answer the argument expressed as a word on the generators."
	^ aMonomial! !

!FreeAbelianMonoid methodsFor: 'elements' stamp: 'len 4/9/2020 18:09:17'!
adapt: anElement
	anElement class == Monomial ifTrue: [^ self newFrom: anElement exponents].
	^ super adapt: anElement! !

!FreeAbelianMonoid methodsFor: 'elements' stamp: 'len 2/27/2017 07:52:27'!
exponents: anArray
	anArray size = rank ifFalse: [self error: 'exponents size doesn''t match rank'].
	^ (Monomial exponents: anArray) parent: self! !

!FreeAbelianMonoid methodsFor: 'elements' stamp: 'len 4/9/2020 07:10:24'!
newFrom: anObject
	| exponents n |
	anObject isSequenceable ifFalse: [^ super newFrom: anObject].
	exponents _ anObject.
	(n _ exponents size) = rank
		ifFalse:
			[n > rank
				ifTrue: [exponents _ exponents copyFrom: 1 to: rank]
				ifFalse: [exponents _ exponents, (ByteArray new: rank - n) "hack"]].
	^ (Monomial exponents: exponents) parent: self! !

!FreeAbelianMonoid methodsFor: 'elements' stamp: 'len 11/24/2016 10:59:05'!
x: anInteger to: exponent
	^ (Monomial new: rank x: anInteger to: exponent) parent: self! !

!FreeAbelianMonoid methodsFor: 'enumerating' stamp: 'len 2/21/2017 18:57:11'!
allMonomialsOfDegree: anInteger
	| answer |
	answer _ Set new.
	anInteger partitionsDo: [:partition|
		partition size <= self rank
			ifTrue:
				[(1 to: self rank) combinations: partition size atATimeDo: [:variables|
					partition permutationsDo: [:exponents|
						| monomial |
						monomial _ self identity.
						variables with: exponents do: [:i :r| monomial _ monomial * (self x: i to: r)].
						answer add: monomial]]]].
	^ answer asArray sort reverse! !

!FreeAbelianMonoid methodsFor: 'enumerating' stamp: 'len 4/28/2021 10:50:53'!
allMonomialsUpToDegree: anInteger
	^ self notYetImplemented! !

!FreeAbelianMonoid methodsFor: 'enumerating' stamp: 'len 5/23/2020 09:04:52'!
do: aBlock
	 ^ self rank do: [:each| aBlock value: self !! (each asArray collect: [:x| x - 1])]! !

!FreeAbelianMonoid methodsFor: 'operations' stamp: 'len 8/8/2019 11:13:43'!
 aMonoid
	"Answer the direct product (or direct sum) of the receiver and the argument."
	(aMonoid isKindOf: FreeAbelianMonoid) ifTrue: [^ self  aMonoid].
	^ super  aMonoid! !

!FreeAbelianMonoid methodsFor: 'operations' stamp: 'len 7/6/2021 14:07:36'!
 aMonoid
	"Answer the direct sum of the receiver and the argument as a monoid."
	| answer n n0 m0 |
	(aMonoid isKindOf: FreeAbelianMonoid) ifFalse: [^ super  aMonoid].
	answer _ self class new: self rank + aMonoid rank ordering: self ordering  aMonoid ordering.
	(self names notNil and: [aMonoid names notNil])
		ifTrue:
			[| names xi |
			names _ self names asOrderedCollection.
			aMonoid names do: [:each|
				xi _ each.
				[names includes: xi] whileTrue: [xi _ xi, ''''].
				names add: xi].
			answer names: names].
	n _ self rank.
	m0 _ (1 to: aMonoid rank) collect: [:i| 0].
	n0 _ (1 to: n) collect: [:i| 0].
	^ answer
		addCoprojections:
			{self into: answer evaluating: [:x| answer exponents: x exponents, m0].
			aMonoid into: answer evaluating: [:x| answer exponents: n0, x exponents]};
		addProjections:
			{answer onto: self evaluating: [:x| self exponents: (x exponents copyFrom: 1 to: n)].
			answer onto: aMonoid evaluating: [:x| aMonoid exponents: (x exponents copyFrom: n+1 to: x exponents size)]};
		yourself! !

!FreeAbelianMonoid methodsFor: 'operations' stamp: 'len 5/13/2019 22:15:42'!
orderedBy: aMonomialOrdering
	| answer |
	answer _ self class new: self rank ordering: aMonomialOrdering.
	self names ifNotNil: [:aCollection| answer names: aCollection].
	^ answer! !

!FreeAbelianMonoid methodsFor: 'operations' stamp: 'len 3/6/2021 13:59:01'!
slice: anArray
	"Answer the submonoid corresponding to a subset of the indeterminates."
	| answer |
	answer _ self class new: (self names ifNil: [anArray size] ifNotNil: [:names| anArray collect: [:i| names at: i]]) ordering: (self ordering slice: anArray).
	answer addMap: (answer to: self mapping: [:i| self x: (anArray at: i)]).
	^ answer! !

!FreeAbelianMonoid methodsFor: 'random' stamp: 'len 5/23/2020 09:05:01'!
atRandom: aRandom bits: bitSize
	^ self !! (( ^ self rank atRandom: aRandom bits: bitSize) asArray collect: [:x| x - 1])! !

!FreeAbelianMonoid methodsFor: 'testing' stamp: 'len 4/25/2020 10:00:13'!
includes: anObject
	^ anObject parent == self! !

!FreeAbelianMonoid methodsFor: 'testing' stamp: 'len 6/30/2016 00:36'!
isCommutative
	^ true! !

!FreeAbelianMonoid methodsFor: 'private' stamp: 'len 1/28/2017 12:07:17'!
ordering: aMonomialOrdering
	ordering _ aMonomialOrdering isSymbol
		ifTrue: [MonomialOrdering perform: (aMonomialOrdering,':') asSymbol with: (1 to: self rank)]
		ifFalse: [aMonomialOrdering]! !

!FreeAbelianMonoid methodsFor: 'private' stamp: 'len 6/28/2016 23:37'!
rank: anInteger
	rank _ anInteger! !

!FreeAbelianMonoid class methodsFor: 'examples' stamp: 'len 5/22/2018 22:14:02'!
example1
	"The free abelian monoid in 3 indeterminates:"
	^ FreeAbelianMonoid new: 3! !

!FreeAbelianMonoid class methodsFor: 'examples' stamp: 'len 5/22/2018 22:16:05'!
example2
	"The free abelian monoid in 3 indeterminates with lexicographic monomial ordering:"
	^ FreeAbelianMonoid new: 3 ordering: #lex! !

!FreeAbelianMonoid class methodsFor: 'instance creation' stamp: 'len 5/23/2019 17:07:28'!
new: anIntegerOrCollection
	^ self new: anIntegerOrCollection ordering: #grevlex! !

!FreeAbelianMonoid class methodsFor: 'instance creation' stamp: 'len 5/23/2019 17:08:49'!
new: anIntegerOrCollection ordering: aMonomialOrdering
	^ (anIntegerOrCollection isInteger
		ifTrue: [self new rank: anIntegerOrCollection] 
		ifFalse: [self new rank: anIntegerOrCollection size; names: anIntegerOrCollection asArray]) ordering: aMonomialOrdering! !

!FreeMonoid methodsFor: 'accessing' stamp: 'len 5/13/2019 11:05:39'!
generators
	^ self propertyAt: #generators ifAbsentPut: ((1 to: self rank) collect: [:i| (Word x: i) parent: self])! !

!FreeMonoid methodsFor: 'accessing' stamp: 'len 5/13/2019 11:04:05'!
identity
	^ self propertyAt: #identity ifAbsentPut: [Word empty parent: self]! !

!FreeMonoid methodsFor: 'accessing' stamp: 'len 5/13/2019 12:59:52'!
names: anArray
	"Set indeterminate names to use when printing words."
	self propertyAt: #names put: anArray! !

!FreeMonoid methodsFor: 'accessing' stamp: 'len 5/10/2019 18:31:21'!
rank
	^ self propertyAt: #rank! !

!FreeMonoid methodsFor: 'accessing' stamp: 'len 12/29/2021 11:55:57'!
size
	^ self rank > 0 ifTrue: [Cardinal new] ifFalse: [1]! !

!FreeMonoid methodsFor: 'elements' stamp: 'len 7/31/2021 12:36:16'!
\ aWord
	"Answer the argument expressed as a word on the generators."
	^ aWord! !

!FreeMonoid methodsFor: 'elements' stamp: 'len 7/31/2021 12:26:44'!
syllables: anArray
	^ (Word syllables: anArray) parent: self! !

!FreeMonoid methodsFor: 'elements' stamp: 'len 5/10/2019 17:15:50'!
x: anInteger to: anotherInteger
	^ (Word x: anInteger to: anotherInteger) parent: self! !

!FreeMonoid methodsFor: 'random' stamp: 'len 5/10/2019 18:32:23'!
atRandom: aRandom bits: bitSize
	| answer n |
	answer _ self identity.
	n _ self rank.
	bitSize // n highBit
		timesRepeat:
			[((n + 1) atRandom: aRandom) = 1
				ifFalse: [answer _ (self x: (self rank atRandom: aRandom)) * answer]].
	^ answer! !

!FreeMonoid methodsFor: 'testing' stamp: 'len 5/10/2019 18:32:59'!
contains: aWord
	aWord do: [:i :exp| (self rank <= i and: [exp >= 0]) ifFalse: [^ false]].
	^ true! !

!FreeMonoid methodsFor: 'testing' stamp: 'len 4/22/2020 06:10:40'!
includes: anObject
	^ anObject parent == self! !

!FreeMonoid methodsFor: 'testing' stamp: 'len 5/10/2019 15:15:33'!
isCommutative
	^ self rank <= 1! !

!FreeMonoid methodsFor: 'private' stamp: 'len 5/10/2019 18:31:10'!
rank: anInteger
	self propertyAt: #rank put: anInteger! !

!FreeMonoid class methodsFor: 'instance creation' stamp: 'len 5/23/2019 17:06:53'!
new: anIntegerOrCollection
	^ anIntegerOrCollection isInteger
		ifTrue: [self new rank: anIntegerOrCollection] 
		ifFalse: [self new rank: anIntegerOrCollection size; names: anIntegerOrCollection asArray]! !

!Group methodsFor: 'accessing' stamp: 'len 12/28/2016 11:27:45'!
exponent
	"Answer the exponent of the receiver, i.e. the maximum order of an element."
	^ self propertyAt: #exponent ifAbsentPut: [self computeExponent]! !

!Group methodsFor: 'accessing' stamp: 'len 12/28/2016 11:28:19'!
generators
	self propertyAt: #generators ifPresent: [:aCollection| ^ aCollection].
	^ self propertyAt: #generators put: (self computeGenerators ifNil: [^ nil])! !

!Group methodsFor: 'accessing' stamp: 'len 5/1/2020 15:38:44'!
identity
	"Answer the identity element of the receiver."
	self isAmbient ifFalse: [^ self ambient identity].
	^ self propertyAt: #identity ifAbsent: [self do: [:each| ^ self propertyAt: #identity put: each  each inverse]]! !

!Group methodsFor: 'accessing' stamp: 'len 10/26/2020 14:33:24'!
null
	"Answer the trivial subgroup, i.e. the zero object in the category of groups."
	^ self ambient span: #()! !

!Group methodsFor: 'accessing' stamp: 'len 10/20/2020 15:42:17'!
order
	"Synonym for size."
	^ self size! !

!Group methodsFor: 'converting' stamp: 'len 8/5/2021 08:39:21'!
asAbelianGroup
	| generators elementaryDivisors G H |
	self isTrivial ifTrue: [^ ^0].
	generators _ self generators.
	elementaryDivisors _ OrderedCollection new.
	G _ self.
	H _ G commutator.
	G size factorization asSet do: [:p| | ranks powers K r |
		ranks _ OrderedCollection new.
		[powers _ OrderedCollection new.
		generators do: [:g| | x |
			x _ g^p.
			(H contains: x) ifFalse: [powers add: x]].
		K _ powers isEmpty ifTrue: [H] ifFalse: [H ambient span: H generators, powers].
		r _ G size // K size.
		G _ K.
		generators _ powers.
		r = 1] whileFalse: [ranks add: (r factorization occurrencesOf: p)].
		ranks isEmpty ifFalse:
			[powers _ (Array new: ranks first) atAllPut: 1.
			ranks do: [:i| 1 to: i do: [:j| powers at: j put: (powers at: j) * p]].
			elementaryDivisors addAll: powers]].
	^ ((^elementaryDivisors size) endomorphisms diagonal: elementaryDivisors sorted) cokernel! !

!Group methodsFor: 'converting' stamp: 'len 5/8/2020 15:53:24'!
asMonoid
	"Forgetful functor to the category of monoids."
	^ self propertyAt: #asMonoid ifAbsentPut: [Monoid newFrom: (self propertyAt: #elements ifAbsent: [self])]! !

!Group methodsFor: 'enumerating' stamp: 'len 5/5/2019 18:40:47'!
do: aBlock
	| generators current previous |
	self propertyAt: #elements ifPresent: [:aCollection| aCollection do: aBlock. ^ self].
	"iterate all elements from the generators:"
	self flag: #fix. "this is too expensive"
	generators _ self generators.
	current _ generators asSet.
	current do: aBlock.
	current add: self identity ifAbsent: [aBlock value: self identity].
	[previous _ current.
	current _ current copy.
	previous do: [:x|
		generators do: [:y|
			| xy |
			xy _ x  y.
			current add: xy ifAbsent: [aBlock value: xy]]].
	previous size < current size] whileTrue.
	self propertyAt: #elements put: current! !

!Group methodsFor: 'graphs' stamp: 'len 5/5/2019 18:37:46'!
cayleyGraph: generators
	"Answer the 'colored' Cayley graph of the receiver for the given set of generators.
	The set of generators is usually assumed to be symmetric (contains all inverses too) and to not contain the identity."
	| G |
	self isFinite ifFalse: [^ self error: 'not a finite group'].
	G _ Digraph unorderedLabeled.
	self do: [:g|
		generators do: [:x|
			G addEdgeFrom: g to: g  x label: x]].
	^ G! !

!Group methodsFor: 'graphs' stamp: 'len 5/5/2019 18:39:32'!
cycleGraph
	| G elements id |
	self isFinite ifFalse: [^ self error: 'not a finite group'].
	G _ Graph unordered.
	id _ self identity.
	elements _ self elements asSet copyWithout: id.
	[elements isEmpty]
		whileFalse:
			[| e g |
			e _ elements anyOne.
			g _ id.
			[| g2 |
			g2 _ g  e.
			(G hasEdgeFrom: g to: g2) ifFalse: [G addEdgeFrom: g to: g2].
			(g _ g2) = id] whileFalse: [elements remove: g ifAbsent: []]].
	^ G! !

!Group methodsFor: 'graphs' stamp: 'len 5/5/2019 18:39:53'!
cycleGraph2
	| G elements id |
	self flag: #fix. "incorrect, test dihedral 4, 5.."
	self isFinite ifFalse: [^ self error: 'not a finite group'].
	G _ Graph unordered.
	id _ self identity.
	elements _ self elements asSet copyWithout: id.
	[elements isEmpty]
		whileFalse:
			[| e g |
			e _ elements remove: elements anyOne.
			g _ id.
			[| g2 |
			g2 _ g  e.
			G addEdgeFrom: g to: g2.
			(g _ g2) = id] whileFalse].
	^ G! !

!Group methodsFor: 'morphisms' stamp: 'len 5/6/2019 05:00:35'!
adjointAction
	^ GroupAction from: (self, self) to: self evaluatingWithArguments: [:g :x| g inverse  x  g]! !

!Group methodsFor: 'morphisms' stamp: 'len 5/6/2019 05:00:47'!
conjugation
	^ GroupAction from: (self, self) to: self evaluatingWithArguments: [:g :x| g  x  g inverse]! !

!Group methodsFor: 'morphisms' stamp: 'len 12/22/2021 14:56:57'!
from: aDomain
	aDomain isCartesianProduct
		ifTrue: [aDomain >- self ifNotNil: [:anArray| ^ aDomain to: self carrier evaluating: [:x| (1 to: anArray size) inject: self identity into: [:result :i| result  ((anArray at: i) value: (x at: i))]]]].
	^ super from: aDomain! !

!Group methodsFor: 'morphisms' stamp: 'len 5/13/2019 15:50:17'!
innerAutomorphisms
	^ Group new elements: (self elements collect: [:a| ConjugationMap by: a in: self])! !

!Group methodsFor: 'morphisms' stamp: 'len 1/6/2016 05:51'!
outerAutomorphisms
	^ self automorphisms / self innerAutomorphisms! !

!Group methodsFor: 'morphisms' stamp: 'len 12/22/2021 14:56:37'!
to: aCodomain
	(aCodomain isGroup and: [self isTrivial or: [aCodomain isTrivial]])
		ifTrue: [^ self to: aCodomain evaluating: [:x| aCodomain identity]].
	^ super to: aCodomain! !

!Group methodsFor: 'morphisms' stamp: 'len 5/2/2020 21:10:07'!
to: aGroup evaluating: aBlock
	aGroup isGroup ifFalse: [^ DomainError signal].
	^ GroupMap from: self to: aGroup evaluating: aBlock! !

!Group methodsFor: 'morphisms' stamp: 'len 3/13/2021 10:09:29'!
to: aGroup mapping: aBlock
	"Answer a morphism defined by images of generators.
	aBlock takes indices i and evaluates to the image of the i-th generator."
	aGroup isGroup ifFalse: [^ DomainError signal].
	^ GroupMap from: self to: aGroup mapping: aBlock! !

!Group methodsFor: 'operations' stamp: 'len 4/19/2020 06:27:44'!
* anElementOrGroup
	(anElementOrGroup isKindOf: Group) ifTrue: [^ self notYetImplemented]. "free product"
	^ Coset representative: anElementOrGroup relations: self! !

!Group methodsFor: 'operations' stamp: 'len 10/10/2018 06:29:35'!
/ aSubgroup
	"Answer the quotient group (or factor group) of the receiver by the argument.
	Assume aSubgroup is normal in the receiver, otherwise this is just the set of right cosets."
	^ QuotientGroup on: self by: aSubgroup

	"Answer the right factor group (or right quotient group) of the receiver by the argument.
	If aSubgroup is not normal in the receiver, this is just the set of left cosets."
"	^ self collect: [:each| LeftCoset on: aSubgroup representative: each]"! !

!Group methodsFor: 'operations' stamp: 'len 5/9/2019 11:24:55'!
// aSubgroup
	"Answer the set of right cosets of the receiver by aSubgroup."
	| answer |
	answer _ Set new.
	self do: [:each| answer add: (Coset representative: each relations: aSubgroup)].
	^ answer! !

!Group methodsFor: 'operations' stamp: 'len 5/10/2019 04:27:41'!
/\ aGroup
	"Answer the intersection of the receiver and the argument."
	self ambient = aGroup ambient ifFalse: [^ DomainError signal: 'groups in different ambients'].
	^ self select: [:each| aGroup includes: each]! !

!Group methodsFor: 'operations' stamp: 'len 4/25/2020 08:21:21'!
 aGroup
	(aGroup isKindOf: Group) ifFalse: [^ super  aGroup].
	^ DirectProductGroup components: {self. aGroup}

" aGroupOrAction
	(aGroupOrAction isKindOf: GroupAction)
		ifTrue: [^ SemidirectProductGroup left: self right: aGroupOrAction group action: aGroupOrAction].
	^ DirectProductGroup components: {self. aGroupOrAction}
"
! !

!Group methodsFor: 'operations' stamp: 'len 2/20/2017 22:13:29'!
 aGroup
	"Answer the direct sum of the receiver and the argument."
	^ self  aGroup "finite direct sums of groups are the same as direct products"! !

!Group methodsFor: 'operations' stamp: 'len 5/3/2021 10:42:18'!
 aGroup
	"The product in the category of groups is the direct product of groups."
	^ self  aGroup! !

!Group methodsFor: 'operations' stamp: 'len 5/3/2021 10:42:41'!
 aGroup
	"The coproduct in the category of groups is the free product of groups."
	^ self * aGroup! !

!Group methodsFor: 'operations' stamp: 'len 12/28/2016 12:19:53'!
abelianization
	"Answer the receiver 'made abelian'."
	^ (self / self commutator)
		propertyAt: #isCommutative put: true;
		yourself! !

!Group methodsFor: 'operations' stamp: 'len 6/29/2020 09:55:24'!
center
	"Answer the subgroup whose memebers are the elements that commute with all the other elements."
	^ self centralizerOf: self! !

!Group methodsFor: 'operations' stamp: 'len 5/10/2020 09:50:58'!
centralizerOf: aCollection
	^ self span: (self select: [:x| aCollection allSatisfy: [:y| x  y = (y  x)]])! !

!Group methodsFor: 'operations' stamp: 'len 3/6/2017 16:33:57'!
commutator
	"Answer the commutator group [G,G] of the receiver G, also called the derived group and noted G'.
	This is the smallest normal subgroup of G such that the quotient G / [G,G] is commutative."
	^ self commutator: self! !

!Group methodsFor: 'operations' stamp: 'len 5/2/2020 17:44:09'!
commutator: aGroup
	"Answer the commutator group [G,H] of the receiver G with the argument H."
	| generators |
	generators _ Set new.
	self generators do: [:x|
		| xInv |
		xInv _ x inverse.
		aGroup generators do: [:y| generators add: x  y  xInv  y inverse]].
	^ (self span: self generators, aGroup generators) normalClosureOf: generators! !

!Group methodsFor: 'operations' stamp: 'len 7/27/2016 07:17'!
conjugacyClassOf: anElement
	^ self conjugation orbitOf: anElement! !

!Group methodsFor: 'operations' stamp: 'len 7/27/2016 07:11'!
conjugacyClasses
	^ self conjugation orbits! !

!Group methodsFor: 'operations' stamp: 'len 5/23/2020 09:13:12'!
groupAlgebra
	^ self groupAlgebraOver: ! !

!Group methodsFor: 'operations' stamp: 'len 5/26/2019 08:45:21'!
groupAlgebraOver: aRing
	^ GroupAlgebra on: self over: aRing! !

!Group methodsFor: 'operations' stamp: 'len 5/1/2016 22:59'!
hypoabelianization
	^ self / self perfectCore! !

!Group methodsFor: 'operations' stamp: 'len 12/9/2016 22:44:53'!
index
	"Answer the index of the receiver in its ambient group."
	^ self ambient indexOf: self! !

!Group methodsFor: 'operations' stamp: 'len 2/16/2016 05:21'!
indexOf: aSubgroup
	^ (self / aSubgroup) size! !

!Group methodsFor: 'operations' stamp: 'len 6/20/2020 21:22:53'!
normalClosureOf: aSubset
	"From Handbook of Computational Group Theory (Holt) 74p.
	The normal closure of A <= G in G (denoted A^G) is the smallest normal subgroup of G that contains A, i.e. the intersection of all normal subgroups that contain A. Equivalently, it is the set A^G := {g^-1 * a * g | g in G, a in A}."
	| X Y Z random N |
	self flag: #fix. "test and fix"
	X _ self generators.
	Y _ aSubset.
	Z _ Y.
	random _ Random new.
	N _ self span: Z.
	["test whether <Z> = <Y>^<X>"
	X allSatisfy: [:g| Z allSatisfy: [:h| N includes: g  h  g inverse]]]
		whileFalse:
			["add some new random conjugates to Z"
			10 timesRepeat:
				[| h g hg |
				g _ self atRandom: random.
				h _ N atRandom: random.
				hg _ g  h  g inverse. "h^g"
				(N includes: hg) ifFalse: [Z add: hg. N _ self span: Z]]].
	^ N! !

!Group methodsFor: 'operations' stamp: 'len 5/8/2019 14:35:27'!
opposite
	^ self propertyAt: #opposite ifAbsentPut: [OppositeGroup opposite: self]! !

!Group methodsFor: 'operations' stamp: 'len 8/5/2021 08:39:32'!
orderOf: anElement
	"Answer the order of the argument in the receiver, i.e. the minimum e such that g^e = 1.
	COHEN Algorithm 1.4.3 (Order of an Element)."
	| h factors id e g1 |
	h _ self size.
	factors _ self propertyAt: #orderFactorization ifAbsentPut: [h factorization].
	e _ h.
	id _ self identity.
	factors asSet do: [:p|
		e _ e / (p ^ (factors occurrencesOf: p)).
		g1 _ anElement ^ e.
		[g1 = id] whileFalse: [g1 _ g1 ^ p. e _ e * p]].
	^ e! !

!Group methodsFor: 'operations' stamp: 'len 8/5/2021 08:39:38'!
orderOf: anElement boundedBy: n
	"Alternative to orderOf:, from Handbook of Computational Group Theory (Holt), 73p. Runs in time at most O(log(n)^3)."
	| id |
	n = 1 ifTrue: [^ 1].
	id _ self identity.
	n factorization asSet do: [:p| (self raise: anElement to: n/p) = id ifTrue: [^ self orderOf: anElement boundedBy: n/p]].
	^ n! !

!Group methodsFor: 'operations' stamp: 'len 5/1/2016 22:59'!
perfectCore
	| answer |
	self derivedSeriesDo: [:each| answer _ each].
	^ answer! !

!Group methodsFor: 'operations' stamp: 'len 5/10/2020 11:48:59'!
span: aCollection
	"Answer the subgroup generated by the argument."
	self isAmbient ifFalse: [^ self ambient span: aCollection].
	^ self species new ambient: self; generators: (aCollection collect: [:each| self !! each])! !

!Group methodsFor: 'random' stamp: 'len 5/25/2019 04:43:18'!
atRandom: aRandom
	self propertyAt: #elements ifPresent: [:aCollection| ^ aCollection atRandom: aRandom].
	^ (self propertyAt: #randomGenerator ifAbsentPut: [ProductReplacementRandomGenerator new generators: self generators]) atRandom: aRandom! !

!Group methodsFor: 'random' stamp: 'len 5/25/2019 04:41:49'!
atRandom: aRandom bits: bitSize
	self propertyAt: #elements ifPresent: [:aCollection| ^ aCollection atRandom: aRandom bits: bitSize].
	^ self atRandom: aRandom "assume it's finite"! !

!Group methodsFor: 'series' stamp: 'len 10/20/2020 15:39:07'!
derivedSeriesDo: aBlock
	"For finite groups the derived series terminates in a perfect group (called the perfect core), which may or may not be trivial."
	| G H |
	G _ self.
	[H _ G commutator.
	aBlock value: H.
	G size = H size ifTrue: [^ self].
	G _ H] repeat! !

!Group methodsFor: 'series' stamp: 'len 10/20/2020 15:39:15'!
lowerCentralSeriesDo: aBlock
	| G H |
	G _ self.
	[H _ G commutator: self.
	aBlock value: H.
	G size = H size ifTrue: [^ self].
	G _ H] repeat! !

!Group methodsFor: 'series' stamp: 'len 10/20/2020 15:39:20'!
upperCentralSeriesDo: aBlock
	| Z |
	Z _ self null.
	[Z _ self select: [:x| self allSatisfy: [:y| Z includes: x  y  x inverse]].
	aBlock value: Z.
	Z size = self size] whileFalse! !

!Group methodsFor: 'series' stamp: 'len 10/1/2018 04:38:20'!
upperCentralSeriesQuotientsDo: aBlock
	| Z1 |
	Z1 _ self null.
	self upperCentralSeriesDo: [:Z| aBlock value: Z / Z1. Z1 _ Z]! !

!Group methodsFor: 'testing' stamp: 'len 5/1/2020 15:45:26'!
isCommutative
	| X |
	self propertyAt: #isCommutative ifPresent: [:aBoolean| ^ aBoolean].
	X _ self generators ifNil: [self].
	X do: [:x| X do: [:y| x  y = (y  x) ifFalse: [^ false]]].
	^ true! !

!Group methodsFor: 'testing' stamp: 'len 5/28/2019 04:51:53'!
isCyclic
	"Answer true if the receiver is generated by one element."
	self isTrivial ifTrue: [^ true].
	self generators ifNotNil: [:aCollection| aCollection size <= 1 ifTrue: [^ true]].
	self do: [:each| (self span: {each}) size = self size ifTrue: [^ true]].
	^ false! !

!Group methodsFor: 'testing' stamp: 'len 5/2/2016 02:32'!
isHypoabelian
	^ self perfectCore isTrivial! !

!Group methodsFor: 'testing' stamp: 'len 5/2/2016 02:32'!
isNilpotent
	| termination |
	self lowerCentralSeriesDo: [:each| termination _ each].
	^ termination isTrivial! !

!Group methodsFor: 'testing' stamp: 'len 12/10/2016 12:52:18'!
isNormal
	"Answer true if the receiver is normal in its ambient overgroup."
	^ self isNormalIn: self ambient! !

!Group methodsFor: 'testing' stamp: 'len 5/5/2019 18:05:33'!
isNormalIn: anOvergroup
	"Answer true if the receiver is normal as subgroup of aGroup, i.e. if it is a subgroup invariant under conjugation."
	| X Y |
	X _ self generators ifNil: [self].
	Y _ anOvergroup generators ifNil: [anOvergroup].
	X do: [:x|
		Y do: [:y|
			| yInv |
			yInv _ y inverse.
			(self includes: y  x  yInv)
				ifFalse: [^ false]]].
	^ true! !

!Group methodsFor: 'testing' stamp: 'len 7/27/2016 07:53'!
isPerfect
	^ self isTrivial not and: [self = self commutator]! !

!Group methodsFor: 'testing' stamp: 'len 3/6/2017 16:37:20'!
isSolvable
	^ self perfectCore isTrivial

"
alternative implementations:
	| G G' |
	G _ self.
	[G isCyclic ifTrue: [^ true].
	G isTrivial ifTrue: [^ false].
	G' _ G commutator.
	G' order = G order ifTrue: [^ false].
	G _ G'] repeat

or:
	| G G' |
	G _ self.
	[G isTrivial ifTrue: [^ true].
	G' _ G commutator.
	G' order = G order ifTrue: [^ false].
	G _ G'] repeat"
! !

!Group methodsFor: 'testing' stamp: 'len 5/1/2020 15:44:22'!
isTrivial
	"Answer true if the receiver is the trivial group {id}."
	| generators |
	self propertyAt: #elements ifPresent: [:aCollection| ^ aCollection size = 1].
	generators _ self generators ifNil: [^ self size = 1].
	^ generators allSatisfy: [:each| each = self identity]! !

!Group methodsFor: 'testing-categories' stamp: 'len 10/26/2020 21:15:52'!
isFPGroup
	^ false! !

!Group methodsFor: 'testing-categories' stamp: 'len 11/7/2015 22:01'!
isGroup
	^ true! !

!Group methodsFor: 'private' stamp: 'len 1/28/2018 08:23:20'!
computeExponent
	| answer |
	answer _ 1.
	self do: [:each| answer _ answer lcm: (self orderOf: each)].
	^ answer! !

!Group methodsFor: 'private' stamp: 'len 5/5/2019 18:39:00'!
computeGenerators
	"The receiver is a finite group represented explicitly as a set of its elements. This method computes a set of generators."
	| n generators elements |
	(self hasProperty: #elements) ifFalse: [^ nil].
	n _ self size.
	n isInfinite ifTrue: [^ nil].
	generators _ OrderedCollection new.
	elements _ Set with: self identity.
	self elements do: [:g|
		elements size = n ifTrue: [^ generators].
		(elements includes: g)
			ifFalse:
				[| previous |
				generators add: g.
				[(previous _ elements copy) do: [:x|
					generators do: [:y|
						elements add: x  y]].
				previous size = elements size] whileFalse]].
	^ generators! !

!Group methodsFor: 'private' stamp: 'len 5/10/2020 11:48:31'!
generators: aCollection
	^ super generators: (aCollection asSet reject: [:each| each isIdentity])! !

!Group methodsFor: 'private' stamp: 'len 5/5/2019 17:57:19'!
raise: anElement to: anInteger
	anInteger = 1 ifTrue: [^ anElement].
	anInteger = 0 ifTrue: [^ self identity].
	anInteger < 0 ifTrue: [^ self raise: anElement inverse to: anInteger negated].
	^ (self raise: anElement  anElement to: anInteger // 2)  (self raise: anElement to: anInteger \\ 2)! !

!Group methodsFor: 'private' stamp: 'len 5/1/2016 23:40'!
species
	^ Group! !

!Group methodsFor: 'as yet unclassified' stamp: 'len 7/31/2021 12:29:42'!
elementAt: aWord
	| answer |
	answer _ self identity.
	aWord syllables do: [:each| answer _ answer * ((self x: each key) ^ each value)].
	^ answer! !

!Group class methodsFor: 'examples' stamp: 'len 10/26/2020 21:28:52'!
D
	"Answer the infinite dihedral group as a finitely presented group."
	| F |
	F _ FreeGroup new: #(r f).
	^ F / (F !! [:r :f| {f^2. (rf)^2}])! !

!Group class methodsFor: 'examples' stamp: 'len 10/26/2020 21:28:52'!
GL2Z
	"Answer GL(2,Z) as a finitely presented group."
	| F |
	F _ FreeGroup new: #(a b j).
	^ F / (F !! [:a :b :j| {aba eq: bab. (aba)^4. j^2. (ja)^2. (jb)^2}])! !

!Group class methodsFor: 'examples' stamp: 'len 10/26/2020 21:28:52'!
PSL2Z
	"Answer PSL(2,Z) (the modular group) as a finitely presented group."
	| F |
	F _ FreeGroup new: #(a b).
	^ F / (F !! [:a :b| {a^2. b^3}])! !

!Group class methodsFor: 'examples' stamp: 'len 10/26/2020 21:28:52'!
SL2Z
	"Answer SL(2,Z) as a finitely presented group."
	| F |
	F _ FreeGroup new: #(a b).
	^ F / (F !! [:a :b| {aba eq: bab. (aba)^4}])! !

!Group class methodsFor: 'examples' stamp: 'len 10/26/2020 21:28:52'!
braid: n
	"Answer the braid group on n strands as a finitely presented group."
	| F relators |
	F _ FreeGroup new: n-1.
	relators _ OrderedCollection new.
	1 to: n-1 do: [:i|
		1 to: n-1 do: [:j| (i-1 = j or: [i+1 = j]) ifFalse: [relators add: ((F x: i) commutator: (F x: j))]].
		i < n-1 ifTrue: [relators add: ((F x: i)(F x: i+1))^3]].
	^ F / relators! !

!Group class methodsFor: 'examples' stamp: 'len 10/26/2020 21:28:52'!
cyclic: n
	"Answer the cyclic group of order n as a finitely presented group."
	| F |
	F _ FreeGroup new: 1.
	^ F / (F !! [:x| x^n])! !

!Group class methodsFor: 'examples' stamp: 'len 10/26/2020 21:28:52'!
dicyclic: n
	"Answer the infinite dihedral group as a finitely presented group."
	| F |
	F _ FreeGroup new: #(r f).
	^ F / (F !! [:r :f| {r^(2*n). r^n(f^-2). rfrf inverse}])! !

!Group class methodsFor: 'examples' stamp: 'len 10/26/2020 21:28:52'!
dihedral: order
	"Answer the dihedral group of order 2n as a finitely presented group."
	| n F |
	order even ifFalse: [self error: 'order should be even'].
	n _ order // 2.
	F _ FreeGroup new: #(r f).
	^ F / (F !! [:r :f| {r^n. f^2. (rf)^2}])! !

!Group class methodsFor: 'examples' stamp: 'len 10/26/2020 21:28:52'!
icosahedral
	"Answer the icosahedral group (ismorphic to A5) as a finitely presented group."
	| F |
	F _ FreeGroup new: #(s t).
	^ F / (F !! [:s :t| {s^2. t^3. (st)^5}])! !

!Group class methodsFor: 'examples' stamp: 'len 10/26/2020 21:28:52'!
octahedral
	"Answer the octahedral group (ismorphic to S4) as a finitely presented group."
	| F |
	F _ FreeGroup new: #(s t).
	^ F / (F !! [:s :t| {s^2. t^3. (st)^4}])! !

!Group class methodsFor: 'examples' stamp: 'len 10/26/2020 21:28:52'!
quaternion
	"Answer the quaternion group as a finitely presented group."
	| F |
	F _ FreeGroup new: #(i j).
	^ F / (F !! [:i :j| {jiji inverse. ijij inverse}])! !

!Group class methodsFor: 'examples' stamp: 'len 8/3/2019 09:01:40'!
schnorr: q
	"Answer a Schnorr group of the given prime order q.
	This is a subgroup of the  group of (units of) integers modulo p
	for some prime p (with order p-1)."
	| p r h g |
	r _ 1.
	[(p _ q*r + 1) isPrime] whileFalse: [r _ r + 1].
	[h _ (1 to: p) atRandom.
	(g _ h raisedTo: r modulo: p) = 1] whileTrue.
	^ Group new generator: (PrimeField new: p) !! g! !

!Group class methodsFor: 'examples' stamp: 'len 10/26/2020 21:28:52'!
symmetric: n
	"Answer the symmetric group on n symbols as a finitely presented group."
	| F relators |
	F _ FreeGroup new: n-1.
	relators _ OrderedCollection new.
	1 to: n-1 do: [:i|
		relators add: (F x: i)^2.
		1 to: n-1 do: [:j| (i-1 = j or: [i+1 = j]) ifFalse: [relators add: ((F x: i) commutator: (F x: j))]].
		i < n-1 ifTrue: [relators add: ((F x: i)(F x: i+1))^3]].
	^ F / relators! !

!Group class methodsFor: 'examples' stamp: 'len 10/26/2020 21:28:52'!
tetrahedral
	"Answer the tetrahedral group (ismorphic to A4) as a finitely presented group."
	| F |
	F _ FreeGroup new: #(s t).
	^ F / (F !! [:s :t| {s^2. t^3. (st)^3}])! !

!DirectProductGroup methodsFor: 'accessing' stamp: 'len 4/19/2019 07:14:28'!
ambient
	^ self propertyAt: #ambient ifAbsentPut: [(components allSatisfy: [:each| each isAmbient]) ifTrue: [self] ifFalse: [self class components: (components collect: [:each| each ambient])]]! !

!DirectProductGroup methodsFor: 'accessing' stamp: 'len 2/12/2016 20:00'!
components
	^ components! !

!DirectProductGroup methodsFor: 'accessing' stamp: 'len 4/25/2020 07:46:26'!
identity
	^ self compose: (components collect: [:each| each identity])! !

!DirectProductGroup methodsFor: 'accessing' stamp: 'len 2/12/2016 20:10'!
size
	^ components product: [:each| each size]! !

!DirectProductGroup methodsFor: 'comparing' stamp: 'len 2/12/2016 20:05'!
= anObject
	^ (anObject isKindOf: DirectProductGroup) and: [anObject components = components]! !

!DirectProductGroup methodsFor: 'comparing' stamp: 'len 2/12/2016 20:05'!
hash
	^ components hash! !

!DirectProductGroup methodsFor: 'elements' stamp: 'len 12/18/2021 06:53:27'!
compose: anArray
	^ DirectProductGroupElement new parent: self; components: anArray asArray! !

!DirectProductGroup methodsFor: 'enumerating' stamp: 'len 10/17/2020 19:59:54'!
do: aBlock
	self asCartesianProduct do: [:each| aBlock value: (self compose: each)]! !

!DirectProductGroup methodsFor: 'morphisms' stamp: 'len 4/25/2020 06:55:32'!
coprojection: i
	^ ((self at: i) to: self evaluating: [:x| self compose: (components withIndexCollect: [:each :k| k = i ifTrue: [x] ifFalse: [each identity]])]) name: 'i', i printText sub! !

!DirectProductGroup methodsFor: 'morphisms' stamp: 'len 5/23/2020 07:30:26'!
projection: i
	^ (self to: (self at: i) evaluating: [:x| x at: i]) name: '', i printText sub! !

!DirectProductGroup methodsFor: 'random' stamp: 'len 10/17/2020 19:59:29'!
atRandom: aRandom
	^ self compose: (self asCartesianProduct atRandom: aRandom)! !

!DirectProductGroup methodsFor: 'random' stamp: 'len 10/17/2020 19:59:42'!
atRandom: aRandom bits: bits
	^ self compose: (self asCartesianProduct atRandom: aRandom bits: bits)! !

!DirectProductGroup methodsFor: 'testing' stamp: 'len 4/25/2020 06:54:01'!
includes: anObject
	^ anObject parent = self! !

!DirectProductGroup methodsFor: 'testing' stamp: 'len 4/14/2020 21:09:53'!
isCoproduct
	^ true! !

!DirectProductGroup methodsFor: 'testing' stamp: 'len 4/14/2020 21:09:49'!
isProduct
	^ true! !

!DirectProductGroup methodsFor: 'private' stamp: 'len 11/5/2016 06:40'!
components: anArray
	components _ anArray! !

!DirectProductGroup methodsFor: 'private' stamp: 'len 12/30/2017 15:11:22'!
computeGenerators
	| answer |
	answer _ OrderedCollection new.
	1 to: self arity do: [:i|
		| p |
		p _ self projection: i.
		(self at: i) generators do: [:each| answer add: (p value: each)]].
	^ answer! !

!DirectProductGroup class methodsFor: 'instance creation' stamp: 'len 2/12/2016 20:02'!
components: anArray
	^ self new components: anArray! !

!FreeGroup methodsFor: 'accessing' stamp: 'len 5/14/2019 07:07:10'!
base
	^ self! !

!FreeGroup methodsFor: 'accessing' stamp: 'len 5/13/2019 11:07:43'!
generators
	^ self propertyAt: #generators ifAbsentPut: ((1 to: self rank) collect: [:i| (Word x: i) parent: self])! !

!FreeGroup methodsFor: 'accessing' stamp: 'len 5/13/2019 11:07:55'!
identity
	^ self propertyAt: #identity ifAbsentPut: [Word empty parent: self]! !

!FreeGroup methodsFor: 'accessing' stamp: 'len 8/2/2020 19:27:29'!
names
	"Answer a list of symbolic names for the generators."
	^ self propertyAt: #names ifAbsent: []! !

!FreeGroup methodsFor: 'accessing' stamp: 'len 5/13/2019 13:01:18'!
names: anArray
	"Set indeterminate names to use when printing words."
	self propertyAt: #names put: anArray! !

!FreeGroup methodsFor: 'accessing' stamp: 'len 5/13/2019 11:07:22'!
rank
	^ self propertyAt: #rank! !

!FreeGroup methodsFor: 'accessing' stamp: 'len 5/14/2019 07:07:06'!
relators
	^ #()! !

!FreeGroup methodsFor: 'accessing' stamp: 'len 12/29/2021 11:55:57'!
size
	^ self rank > 0 ifTrue: [Cardinal new] ifFalse: [1]! !

!FreeGroup methodsFor: 'comparing' stamp: 'len 10/26/2020 20:57:39'!
= anObject
	^ self class = anObject class and: [self rank = anObject rank]! !

!FreeGroup methodsFor: 'comparing' stamp: 'len 10/26/2020 20:57:55'!
hash
	^ self rank! !

!FreeGroup methodsFor: 'elements' stamp: 'len 7/31/2021 12:36:05'!
\ aWord
	"Answer the argument expressed as a word on the generators."
	^ aWord! !

!FreeGroup methodsFor: 'elements' stamp: 'len 7/31/2021 12:27:07'!
syllables: anArray
	^ (Word syllables: anArray) parent: self! !

!FreeGroup methodsFor: 'elements' stamp: 'len 7/31/2021 12:21:06'!
x: anInteger to: anotherInteger
	^ (Word x: anInteger to: anotherInteger) parent: self! !

!FreeGroup methodsFor: 'morphisms' stamp: 'len 10/28/2020 14:38:48'!
coprojection: anIntegerOrList
	| list |
	list _ anIntegerOrList isInteger ifTrue: [{anIntegerOrList}] ifFalse: [anIntegerOrList].
	^ ((self class new: list size) into: self mapping: [:i| self x: (list at: i)])
		name: 'i', anIntegerOrList printString sub! !

!FreeGroup methodsFor: 'morphisms' stamp: 'len 10/28/2020 13:57:38'!
fromAll: anArray
	"Answer the canonical coprojections from the components of anArray to the receiver."
	| i |
	(anArray allSatisfy: [:each| each class = self class]) ifFalse: [^ super fromAll: anArray].
	(anArray sum: [:each| each rank]) = self rank ifFalse: [^ super fromAll: anArray].
	i _ 1.
	^ anArray collect: [:each| self coprojection: (i to: (i _ i + each rank)-1)]! !

!FreeGroup methodsFor: 'morphisms' stamp: 'len 10/28/2020 14:36:05'!
projection: anIntegerOrList
	| list F |
	list _ anIntegerOrList isInteger ifTrue: [{anIntegerOrList}] ifFalse: [anIntegerOrList].
	F _ self scalars ^ list size.
	^ (self onto: F mapping: [:i| | j | (j _ list indexOf: i) = 0 ifTrue: [F identity] ifFalse: [F x: j]])
		name: '', anIntegerOrList printString sub! !

!FreeGroup methodsFor: 'morphisms' stamp: 'len 10/28/2020 13:56:27'!
toAll: anArray
	"Answer the canonical projections from the receiver to the components of anArray."
	| i |
	(anArray allSatisfy: [:each| each class = self class]) ifFalse: [^ super toAll: anArray].
	(anArray sum: [:each| each rank]) = self rank ifFalse: [^ super toAll: anArray].
	i _ 1.
	^ anArray collect: [:each| self projection: (i to: (i _ i + each rank)-1)]! !

!FreeGroup methodsFor: 'operations' stamp: 'len 12/23/2021 15:44:15'!
* aGroup
	"Answer the free product of the receiver with the argument.
	This is the coproduct in the category of groups."
	| F |
	aGroup isFPGroup ifFalse: [^ super * aGroup].
	(aGroup isKindOf: FreeGroup)
		ifTrue: [^ self class new: self rank + aGroup rank].
	F _ self * aGroup base.
	^ F / (aGroup relators apply: ({self. aGroup base} >- F) second)! !

!FreeGroup methodsFor: 'operations' stamp: 'len 10/27/2020 18:39:28'!
/ anObject
	| newRelators answer |
	newRelators _ Set new.
	(self includes: anObject)
		ifTrue: [newRelators add: anObject]
		ifFalse:
			[anObject isCollection
				ifTrue: [newRelators addAll: anObject]
				ifFalse: [^ self notYetImplemented "subgroup?"]].
	answer _ FPGroup on: self relators: newRelators.
"	answer addMap: (self onto: answer mapping: [:i| answer x: i])."
	^ answer! !

!FreeGroup methodsFor: 'operations' stamp: 'len 12/23/2021 15:44:30'!
 aGroup
	"Answer the direct product of the receiver with the argument."
	| F coprojections relators |
	aGroup isFPGroup ifFalse: [^ super  aGroup].
	self flag: #fix. "duplicated code from FPGroup>>"
	F _ self * aGroup base.
	relators _ OrderedCollection new.
	1 to: self rank do: [:i|
		1 to: aGroup base rank do: [:j|
			relators add: ((F x: i) commutator: (F x: self base rank + j))]].
	coprojections _ {self base. aGroup base} >- F.
	relators addAll: (aGroup relators apply: coprojections second).
	^ F / relators! !

!FreeGroup methodsFor: 'operations' stamp: 'len 10/20/2020 19:26:27'!
abelianization
	| answer |
	answer _ ^self rank.
	answer addMap: (self to: answer mapping: [:i| answer x: i]).
	^ answer! !

!FreeGroup methodsFor: 'operations' stamp: 'len 10/27/2020 18:41:39'!
normalClosureOf: aSubset
	^ self shouldNotImplement! !

!FreeGroup methodsFor: 'random' stamp: 'len 10/28/2020 14:42:24'!
atRandom: aRandom bits: bitSize
	| answer |
	answer _ self identity.
	bitSize = 0 ifTrue: [^ answer].
	bitSize // self rank highBit + 1
		timesRepeat:
			[answer _ (self generators atRandom: aRandom)^(#(-1 1) atRandom: aRandom) * answer].
	^ answer! !

!FreeGroup methodsFor: 'testing' stamp: 'len 4/25/2020 10:02:16'!
includes: anObject
	^ anObject parent == self! !

!FreeGroup methodsFor: 'testing' stamp: 'len 5/13/2019 11:08:09'!
isCommutative
	^ self rank <= 1! !

!FreeGroup methodsFor: 'testing' stamp: 'len 10/26/2020 21:16:15'!
isFPGroup
	^ true! !

!FreeGroup methodsFor: 'testing' stamp: 'len 10/28/2020 08:49:59'!
isNilpotent
	^ self isCommutative! !

!FreeGroup methodsFor: 'testing' stamp: 'len 10/28/2020 08:50:25'!
isSolvable
	^ self isCommutative! !

!FreeGroup methodsFor: 'private' stamp: 'len 5/13/2019 11:21:51'!
rank: anInteger
	self propertyAt: #rank put: anInteger! !

!FreeGroup class methodsFor: 'instance creation' stamp: 'len 5/23/2019 17:11:34'!
new: anIntegerOrCollection
	^ anIntegerOrCollection isInteger
		ifTrue: [self new rank: anIntegerOrCollection] 
		ifFalse: [self new rank: anIntegerOrCollection size; names: anIntegerOrCollection asArray]! !

!OppositeGroup methodsFor: 'accessing' stamp: 'len 5/8/2019 14:22:26'!
generators
	^ opposite generators collect: [:each| self !! each]! !

!OppositeGroup methodsFor: 'accessing' stamp: 'len 5/8/2019 14:22:12'!
identity
	^ self !! opposite identity! !

!OppositeGroup methodsFor: 'elements' stamp: 'len 4/9/2020 18:13:17'!
adapt: anElement
	(opposite includes: anElement) ifTrue: [^ OppositeGroupElement opposite: anElement inverse].
	^ super adapt: anElement! !

!OppositeGroup methodsFor: 'morphisms' stamp: 'len 12/22/2021 15:00:19'!
from: aDomain
	aDomain = opposite ifTrue: [^ aDomain to: self evaluating: [:x| self adapt: x]].
	^ super from: aDomain! !

!OppositeGroup methodsFor: 'morphisms' stamp: 'len 12/22/2021 14:59:45'!
to: aCodomain
	aCodomain = opposite ifTrue: [^ self to: aCodomain evaluating: [:x| x opposite inverse]].
	^ super to: aCodomain! !

!OppositeGroup methodsFor: 'operations' stamp: 'len 5/8/2019 13:41:23'!
opposite
	^ opposite! !

!OppositeGroup methodsFor: 'private' stamp: 'len 5/8/2019 13:41:37'!
opposite: aGroup
	opposite _ aGroup! !

!OppositeGroup class methodsFor: 'instance creation' stamp: 'len 5/8/2019 13:54:20'!
opposite: aGroup
	^ self new opposite: aGroup! !

!QuotientGroup methodsFor: 'accessing' stamp: 'len 12/28/2016 11:31:59'!
base
	^ self propertyAt: #base! !

!QuotientGroup methodsFor: 'accessing' stamp: 'len 10/27/2020 13:49:38'!
generators
	^ self propertyAt: #generators ifAbsentPut: [self base generators collect: [:each| self project: each]]! !

!QuotientGroup methodsFor: 'accessing' stamp: 'len 12/22/2016 21:16:13'!
identity
	^ self project: self base identity! !

!QuotientGroup methodsFor: 'accessing' stamp: 'len 10/27/2020 18:46:15'!
relations
	"Answer the relations subgroup, i.e. the normal subgroup by which we quotient."
	^ self propertyAt: #relations ifAbsentPut: [self base span: self relators]
"
		^ self propertyAt: #relations ifAbsentPut: [self base normalClosureOf: self relators]
"! !

!QuotientGroup methodsFor: 'accessing' stamp: 'len 10/26/2020 21:04:25'!
relators
	^ self propertyAt: #relators ifAbsent: [self relations generators]! !

!QuotientGroup methodsFor: 'accessing' stamp: 'len 5/2/2016 02:14'!
size
	^ super size
"	^ properties at: #size ifAbsentPut: [base indexOf: subgroup]"! !

!QuotientGroup methodsFor: 'enumerating' stamp: 'len 12/22/2016 21:17:54'!
do: aBlock
	| visited |
	visited _ Set new.
	self base do: [:each| | x |
		visited add: (x _ self project: each) ifAbsent: [aBlock value: x]]! !

!QuotientGroup methodsFor: 'morphisms' stamp: 'len 12/22/2021 15:06:41'!
from: aDomain
	aDomain = self base ifTrue: [^ self projection].
	aDomain -> self base ifNotNil: [:aMorphism| ^ aMorphism -> self].
	^ super from: aDomain! !

!QuotientGroup methodsFor: 'morphisms' stamp: 'len 5/9/2019 11:25:08'!
project: anElement
	^ Coset representative: anElement relations: self relations! !

!QuotientGroup methodsFor: 'morphisms' stamp: 'len 4/4/2021 10:06:32'!
projection
	"Answer the natural projection, or quotient map, or canonical homomorphism from the base group.
	This takes elements from the base group to the corresponding coset in the quotient group."
	^ self propertyAt: #projection ifAbsentPut:
		[(self base onto: self evaluating: [:each| self project: each])
			name: '';
			propertyAt: #kernel put: self relations;
			propertyAt: #image put: self;
			yourself]! !

!QuotientGroup methodsFor: 'random' stamp: 'len 10/27/2020 18:26:56'!
atRandom: aRandom bits: bitSize
	^ self project: (self base atRandom: aRandom bits: bitSize)! !

!QuotientGroup methodsFor: 'testing' stamp: 'len 10/13/2020 09:49:49'!
isCommutative
	^ self base isCommutative or: [super isCommutative]! !

!QuotientGroup methodsFor: 'testing' stamp: 'len 10/13/2020 09:51:26'!
isCyclic
	^ self base isCyclic or: [super isCyclic]! !

!QuotientGroup methodsFor: 'testing' stamp: 'len 10/13/2020 09:50:33'!
isNilpotent
	^ self base isNilpotent or: [super isNilpotent]! !

!QuotientGroup methodsFor: 'testing' stamp: 'len 12/25/2021 12:32:33'!
isQuotient
	^ true! !

!QuotientGroup methodsFor: 'testing' stamp: 'len 10/13/2020 09:50:56'!
isSolvable
	^ self base isSolvable or: [super isSolvable]! !

!QuotientGroup methodsFor: 'private' stamp: 'len 12/28/2016 11:31:54'!
base: aGroup
	self propertyAt: #base put: aGroup! !

!QuotientGroup methodsFor: 'private' stamp: 'len 2/28/2017 10:15:24'!
relations: aNormalSubgroup
	self propertyAt: #relations put: aNormalSubgroup! !

!QuotientGroup methodsFor: 'private' stamp: 'len 10/26/2020 21:01:48'!
relators: aCollection
	self propertyAt: #relators put: aCollection! !

!QuotientGroup class methodsFor: 'instance creation' stamp: 'len 2/28/2017 10:14:58'!
on: aGroup by: aNormalSubgroup
	^ self new base: aGroup; relations: aNormalSubgroup! !

!QuotientGroup class methodsFor: 'instance creation' stamp: 'len 10/26/2020 21:01:21'!
on: aGroup relators: aCollection
	^ self new base: aGroup; relators: aCollection! !

!FPGroup methodsFor: 'accessing' stamp: 'len 10/27/2020 18:44:29'!
names
	^ self base names! !

!FPGroup methodsFor: 'morphisms' stamp: 'len 10/27/2020 18:31:09'!
project: anElement
	^ anElement copy parent: self! !

!FPGroup methodsFor: 'operations' stamp: 'len 12/23/2021 15:43:29'!
* aGroup
	"Answer the free product of the receiver with the argument."
	| F coprojections |
	aGroup isFPGroup ifFalse: [^ super * aGroup].
	F _ self base * aGroup base.
	coprojections _ {self base. aGroup base} >- F.
	^ F / ((self relators apply: coprojections first), (aGroup relators apply: coprojections second))! !

!FPGroup methodsFor: 'operations' stamp: 'len 10/27/2020 18:25:46'!
/ anObject
	| newRelators answer |
	newRelators _ Set new addAll: self relators; yourself.
	(self includes: anObject)
		ifTrue: [newRelators add: anObject]
		ifFalse:
			[anObject isCollection
				ifTrue: [newRelators addAll: anObject]
				ifFalse: [^ self notYetImplemented "subgroup?"]].
	^ (answer _ self base / newRelators)
		addMap: (self onto: answer mapping: [:i| answer x: i]);
		yourself! !

!FPGroup methodsFor: 'operations' stamp: 'len 12/23/2021 15:43:43'!
 aGroup
	"Answer the direct product of the receiver with the argument."
	| F coprojections relators |
	aGroup isFPGroup ifFalse: [^ super  aGroup].
	F _ self base * aGroup base.
	relators _ OrderedCollection new.
	1 to: self base rank do: [:i|
		1 to: aGroup base rank do: [:j|
			relators add: ((F x: i) commutator: (F x: self base rank + j))]].
	coprojections _ {self base. aGroup base} >- F.
	relators addAll: (self relators apply: coprojections first).
	relators addAll: (aGroup relators apply: coprojections second).
	^ F / relators! !

!FPGroup methodsFor: 'testing-categories' stamp: 'len 10/27/2020 18:29:24'!
isFPGroup
	^ true! !

!FPGroup methodsFor: 'elements' stamp: 'len 7/31/2021 12:35:39'!
\ aWord
	"Answer the argument expressed as a word on the generators."
	^ aWord! !

!PermutationGroup methodsFor: 'accessing' stamp: 'len 1/31/2018 18:40:20'!
action
	"Answer the natural action that sends (s, x) to s(x)."
	^ GroupAction from: (self, self space) to: self space evaluatingWithArguments: [:s :x| s value: x]! !

!PermutationGroup methodsFor: 'accessing' stamp: 'len 2/16/2016 05:48'!
degree
	^ self space size! !

!PermutationGroup methodsFor: 'accessing' stamp: 'len 1/28/2018 18:27:42'!
polynomialActionOn: aPolynomialRing
	"Answer the action that permutes the indeterminates."
	^ GroupAction from: (self, aPolynomialRing) to: aPolynomialRing evaluatingWithArguments: [:s :f| f permutedBy: s]! !

!PermutationGroup methodsFor: 'accessing' stamp: 'len 1/28/2018 18:31:26'!
polynomialActionOver: aRing
	"Answer the action that permutes the indeterminates on a polynomial ring."
	| R |
	R _ aRing polynomialsIn: self degree.
	^ GroupAction from: (self, R) to: R evaluatingWithArguments: [:s :f| f permutedBy: s]! !

!PermutationGroup methodsFor: 'accessing' stamp: 'len 12/28/2016 11:29:34'!
size
	self propertyAt: #elements ifPresent: [:aCollection| ^ aCollection size].
	^ self propertyAt: #size ifAbsentPut: [self computeSize]! !

!PermutationGroup methodsFor: 'accessing' stamp: 'len 5/18/2018 19:01:32'!
space
	^ self ambient space! !

!PermutationGroup methodsFor: 'comparing' stamp: 'len 12/13/2016 07:35:29'!
= anObject
	self == anObject ifTrue: [^ true].
	(anObject isKindOf: self species)
		ifFalse: [^ super = anObject].
	self generators ifNotNil: [:g1| anObject generators ifNotNil: [:g2| g1 asSet = g2 asSet ifTrue: [^ true]]].
	self size = anObject size ifFalse: [^ false].
	anObject generators ifNotNil: [:generators| ^ self containsAllOf: generators].
	self generators ifNotNil: [:generators| ^ anObject containsAllOf: generators].
	^ super = anObject! !

!PermutationGroup methodsFor: 'converting' stamp: 'len 4/1/2021 12:19:33'!
asLinearGroup
	"Return a matrix group isomorphic to the receiver.
	Assume the space of the receiver is an interval (1 to: n)."
	| M generators |
	M _ (^self degree) endomorphisms.
	generators _ self generators collect: [:g| M filling: [:i :j| (g at: i) = j ifTrue: [1] ifFalse: [0]]].
	^ LinearGroup generators: generators! !

!PermutationGroup methodsFor: 'operations' stamp: 'len 4/18/2020 18:23:32'!
 aGroup
	"Answer the direct product of the receiver and the argument."
	| S n m G1 G2 k answer |
	(aGroup isKindOf: PermutationGroup) ifFalse: [^ super  aGroup].
	n _ self degree.
	m _ aGroup degree.
	S _ SymmetricGroup new: n + m.
	G1 _ self generators collect: [:g| S !! (g asArray, (n+1 to: n+m))].
	G2 _ aGroup generators collect: [:g| S !! ((1 to: n), (g asArray collect: [:i| i+n]))].
	k _ G1 size.
	^ (answer _ S span: G1, G2) "<- assumes the order of the generators is kept"
		addCoprojections:
			{self into: answer mapping: [:i| answer x: i].
			aGroup into: answer mapping: [:i| answer x: i+k]};
		addProjections:
			{answer onto: self mapping: [:i| i <= k ifTrue: [self x: i] ifFalse: [self identity]].
			answer onto: aGroup mapping: [:i| i > k ifTrue: [aGroup x: i-k] ifFalse: [aGroup identity]]};
		yourself! !

!PermutationGroup methodsFor: 'operations' stamp: 'len 5/26/2019 11:26:50'!
reduced
	"Answer a permutation group isomorphic to the receiver but acting on a smaller space (if possible)."
"	support _ Set new.
	self generators do: [:each| support add: each support].
"
	self notYetImplemented! !

!PermutationGroup methodsFor: 'testing' stamp: 'len 1/31/2018 18:41:29'!
includes: aPermutation
	^ (self ambient includes: aPermutation) and: [self contains: aPermutation]! !

!PermutationGroup methodsFor: 'testing' stamp: 'len 2/1/2018 23:13:17'!
isStandard
	"Answer true if the domain of the receiver is an interval [1..n]."
	^ self ambient isStandard! !

!PermutationGroup methodsFor: 'testing' stamp: 'len 5/25/2019 04:47:19'!
isSubgroupOfAn
	"Monte Carlo test."
	| random |
	self flag: #fix.
	self isTransitive ifFalse: [^ false].
	random _ Random new.
	20 timesRepeat: [(self atRandom: random) isPurple ifTrue: [^ true]].
	^ false! !

!PermutationGroup methodsFor: 'private' stamp: 'len 1/31/2018 18:39:54'!
computeSize
	"Schreier-Sims algorithm."
	| G answer |
	G _ self.
	answer _ 1.
	self space do: [:b| | tree |
		G isTrivial ifTrue: [^ answer].
		tree _ SchreierTree root: b generators: G generators action: G action.
		answer _ answer * tree orbit size.
		G _ tree stabilizer].
	self error: 'what?'.
	^ answer! !

!PermutationGroup methodsFor: 'private' stamp: 'len 3/4/2016 20:36'!
species
	^ PermutationGroup! !

!PermutationGroup class methodsFor: 'examples' stamp: 'len 2/1/2018 23:25:24'!
Co3
	"Conway group Co3. This group has order 495766656000."
	| x y |
	x _ #(245 42 112 15 131 7 188 75 132 10 11 187 186 265 22 159 256 43 101 123 134 4 32 209 238 35 45 235 126 5 19 60 66 80 154 251 117 206 71 118 93 87 167 271 221 261 182 155 47 230 172 236 109 191 76 156 73 116 147 23 127 231 38 53 122 210 24 68 86 255 196 139 149 21 111 203 252 72 262 114 214 9 181 174 85 95 2 250 257 243 90 158 170 148 69 105 249 263 16 54 31 115 51 104 125 219 92 46 64 204 8 266 225 34 175 145 161 180 237 241 224 169 269 12 96 129 189 190 29 17 30 82 143 74 168 13 227 217 78 258 220 178 228 146 58 254 273 215 57 106 77 110 50 26 248 260 274 107 99 253 37 25 272 44 52 119 18 201 65 41 233 103 246 200 102 160 198 207 157 40 223 49 267 79 1 136 124 6 61 268 100 70 98 171 121 39 62 211 208 84 135 97 55 152 141 63 142 259 67 33 177 173 14 242 94 113 240 264 150 205 27 183 83 195 216 163 247 133 36 153 197 140 194 120 270 165 166 162 218 138 234 81 91 89 185 212 137 48 202 276 229 151 176 144 192 130 244 232 199 56 108 184 193 239 213 3 222 128 20 28 164 226 59 179 275 88).
	y _ #(204 203 33 236 5 172 77 76 47 146 133 224 229 53 84 16 223 228 130 131 252 190 13 263 242 10 32 196 199 65 246 209 40 99 241 198 269 251 75 118 176 271 183 116 197 238 22 29 178 26 174 129 2 153 272 257 41 12 59 20 27 175 106 159 218 259 137 258 261 164 262 189 45 177 260 85 25 15 226 96 24 1 274 148 264 132 48 117 36 60 171 201 101 253 95 120 142 213 165 51 115 44 103 167 243 66 141 108 88 97 276 30 139 222 166 173 231 3 73 239 56 170 82 162 163 207 145 128 52 104 90 216 220 155 74 237 28 4 113 273 230 270 248 180 206 50 250 78 127 150 54 232 217 121 69 156 6 125 210 86 89 46 184 211 265 93 19 138 23 126 43 188 102 244 219 192 256 83 58 144 181 187 91 158 205 235 147 157 114 9 152 57 39 64 143 67 119 161 87 200 111 79 14 123 21 149 122 191 61 194 266 225 31 81 62 160 151 112 215 254 234 72 17 179 105 267 227 18 169 249 109 208 275 68 233 168 55 124 80 240 35 7 212 100 245 98 195 247 107 182 42 185 94 11 255 135 154 221 63 193 134 71 214 8 34 70 202 268 37 110 38 136 140 49 186 92).
	^ PermutationGroup new: 276 generators: {x. y}! !

!PermutationGroup class methodsFor: 'examples' stamp: 'len 2/1/2018 23:25:36'!
J1
	"Janko group J1. This group has order 175560."
	| x y |
	x _ #(262 107 21 213 191 22 133 234 232 151 139 176 202 253 222 16 195 206 68 55 3 6 179 217 216 256 87 70 131 44 105 170 77 104 198 137 243 56 124 223 134 42 174 30 45 51 128 94 250 264 46 183 231 115 20 38 85 233 261 95 235 177 249 91 247 155 67 19 219 28 237 211 84 192 130 251 33 78 260 112 193 156 242 73 57 238 27 143 168 148 64 119 212 48 60 150 199 140 189 180 147 111 159 34 31 162 2 194 166 200 102 80 120 141 54 182 181 225 92 113 254 125 146 39 122 208 221 47 210 75 29 255 7 41 135 175 36 207 11 98 114 240 88 172 185 123 101 90 224 96 10 169 241 190 66 82 214 161 103 236 158 106 239 229 230 109 188 89 152 32 258 144 186 43 136 12 62 245 23 100 117 116 52 205 145 173 228 167 99 154 5 74 81 108 17 196 203 35 97 110 252 13 197 204 184 18 138 126 248 129 72 93 4 157 259 25 24 246 69 227 127 15 40 149 118 226 220 187 164 165 53 9 58 8 61 160 71 86 163 142 153 83 37 244 178 218 65 209 63 49 76 201 14 121 132 26 263 171 215 79 59 1 257 50 266 265).
	y _ #(146 132 3 156 242 107 125 245 174 241 264 248 36 116 47 178 170 197 233 121 1 228 48 201 15 136 212 6 175 77 237 30 226 31 129 44 161 232 219 78 139 9 211 13 222 97 25 173 70 153 186 29 203 35 169 140 260 91 199 108 208 206 11 55 103 65 95 73 151 131 41 221 225 18 143 7 32 159 217 93 181 2 258 163 154 182 38 133 117 33 243 191 122 27 205 20 135 98 229 138 61 194 66 104 149 62 28 164 123 17 137 16 69 37 238 128 247 57 167 134 96 80 193 185 76 83 218 14 54 8 49 82 215 189 46 190 183 188 71 230 231 239 202 224 158 21 119 214 184 250 113 72 200 213 22 166 102 220 40 92 114 257 177 60 179 4 147 168 64 110 171 148 23 42 52 195 84 112 246 19 252 196 111 105 265 209 24 100 120 26 160 39 109 157 266 86 74 204 227 50 187 75 216 207 67 106 198 101 51 141 251 94 85 172 88 53 254 261 192 145 152 240 262 249 68 90 59 155 263 56 210 87 180 12 115 142 34 235 236 45 244 253 58 10 130 165 89 234 144 259 43 81 5 79 223 162 256 126 150 118 127 255 99 63 124 176).
	^ PermutationGroup new: 266 generators: {x. y}! !

!PermutationGroup class methodsFor: 'examples' stamp: 'len 2/1/2018 23:27:01'!
M11
	"The Mathieu group on 11 points. With order 7920, this is the smallest of the 26 sporadic simple groups."
	"ALTERNATIVELY: #((1 2 3 4 5 6 7 8 9 10 11)), #((3 7 11 8) (4 10 5 6)).
	"
	^ self new: 11 generators: {#((1 10) (2 8) (3 11) (5 7)). #((1 4 7 6) (2 11 10 9))}! !

!PermutationGroup class methodsFor: 'examples' stamp: 'len 2/1/2018 23:27:42'!
M12
	"The Mathieu group on 12 points, the second smallest of the 26 sporadic simple groups, with order 95040."
	^ self new: 12 generators: {#((1 2 3 4 5 6 7 8 9 10 11)). #((3 7 11 8) (4 10 5 6)). #((1 12) (2 11) (3 6) (4 8) (5 9) (7 10))}! !

!PermutationGroup class methodsFor: 'examples' stamp: 'len 2/1/2018 23:28:00'!
McL
	"McLaughlin group. This group has order 898128000."
	| x y |
	x _ #(191 182 3 81 55 60 7 66 272 177 192 163 13 242 133 107 17 267 108 218 198 185 211 82 204 195 132 253 207 59 179 154 264 152 92 189 217 197 85 156 41 184 102 50 216 99 181 48 199 44 111 52 158 236 5 210 57 103 30 6 263 62 119 138 127 8 105 137 69 125 144 219 261 74 175 76 269 237 268 80 4 24 232 256 39 104 95 88 234 233 140 35 93 149 87 96 173 160 46 112 123 43 58 86 67 221 16 19 131 176 51 100 262 257 201 116 260 238 63 275 214 225 101 246 70 170 65 128 141 130 109 27 15 196 167 136 68 64 139 91 129 235 224 71 205 249 147 226 94 243 151 34 193 32 228 40 157 53 159 98 231 162 12 215 180 166 135 222 270 126 241 259 97 212 75 110 10 188 31 165 47 2 266 42 22 203 187 178 36 250 1 11 153 194 26 134 38 21 49 200 115 247 186 25 145 206 29 255 251 56 23 174 252 121 164 45 37 20 72 220 106 168 271 143 122 148 274 155 229 240 161 83 90 89 142 54 78 118 254 230 171 14 150 244 258 124 202 248 146 190 209 213 28 239 208 84 114 245 172 117 73 113 61 33 273 183 18 79 77 169 223 9 265 227 120).
	y _ #(24 28 67 168 118 274 98 209 266 271 247 13 71 7 218 170 100 26 223 128 264 116 179 204 40 198 64 272 56 132 255 148 61 241 89 239 54 20 126 177 35 248 139 172 234 214 140 55 134 213 22 107 101 99 113 135 221 57 252 84 163 47 94 162 171 192 142 195 167 145 10 152 14 206 73 91 17 2 245 203 63 205 38 188 191 215 115 52 82 227 180 155 169 173 181 265 250 75 249 4 51 207 156 70 267 273 262 256 97 66 117 76 220 49 158 53 105 19 44 144 269 127 141 185 119 189 102 159 58 50 225 42 164 32 68 230 79 121 193 268 259 31 106 96 9 30 184 114 143 103 150 197 125 186 1 160 147 178 83 151 120 21 90 196 78 59 190 77 110 182 16 153 210 62 200 37 85 240 244 238 34 65 36 108 18 219 251 208 136 46 25 93 8 236 29 15 217 124 111 123 60 130 23 92 41 154 246 201 43 81 5 45 224 69 231 166 254 133 74 235 261 232 211 202 86 88 33 237 228 39 131 212 95 222 48 187 253 112 275 87 233 149 263 80 6 122 138 146 176 243 258 260 270 72 3 157 183 194 175 216 129 226 109 27 161 104 199 174 11 229 12 165 242 137 257).
	^ PermutationGroup new: 275 generators: {x. y}! !

!PermutationGroup class methodsFor: 'examples' stamp: 'len 5/15/2019 01:39:38'!
cyclic: n
	"Answer the cyclic group of order n as a permutation group."
	^ self new: n generators: {{(1 to: n)}}! !

!PermutationGroup class methodsFor: 'examples' stamp: 'len 4/22/2020 06:27:58'!
dihedral: order
	"Answer the dihedral group of order 2n as a permutation group."
	| n G s r |
	order even ifFalse: [self error: 'order should be even'].
	n _ order // 2.
	G _ SymmetricGroup new: n.
	r _ G !! {(1 to: n)}.
	s _ G !! [:i| n - i + 1].
	^ G span: {s. r}! !

!PermutationGroup class methodsFor: 'examples' stamp: 'len 2/1/2018 23:28:37'!
hessian
	"The Hessian group, a finite group of order 216 introduced by Jordan and named after Otto Hesse."
	^ self new: 9 generators: {#((1 2 4) (5 6 8) (3 9 7)). #((4 5 6) (7 9 8))}! !

!PermutationGroup class methodsFor: 'examples' stamp: 'len 2/1/2018 23:29:18'!
klein
	"The Klein four-group (or Vierergruppe) as a permutation group."
	^ self new: 4 generators: {#(2 1 4 3). #(3 4 1 2) ". #(4 3 2 1)"}! !

!PermutationGroup class methodsFor: 'instance creation' stamp: 'len 1/31/2018 21:30:04'!
new: n generators: aCollection
	^ (SymmetricGroup new: n) span: aCollection! !

!PermutationGroup class methodsFor: 'instance creation' stamp: 'len 2/1/2018 23:24:53'!
on: aCollection generators: anotherCollection
	^ (SymmetricGroup on: aCollection) span: anotherCollection! !

!AlternatingGroup methodsFor: 'accessing' stamp: 'len 2/16/2016 05:49'!
size
	^ self degree factorial / 2! !

!AlternatingGroup methodsFor: 'enumerating' stamp: 'len 1/31/2018 21:16:14'!
do: aBlock
	self ambient do: [:each| each even ifTrue: [aBlock value: each]]! !

!AlternatingGroup methodsFor: 'random' stamp: 'len 6/28/2016 08:48'!
atRandom: aRandom bits: bitSize
	| S answer |
	S _ self ambient.
	[(answer _ S atRandom: aRandom bits: bitSize) even] whileFalse.
	^ answer! !

!AlternatingGroup methodsFor: 'testing' stamp: 'len 12/13/2016 07:31:33'!
contains: aPermutation
	"Answer true if the receiver contains the given element of its ambient."
	^ aPermutation even! !

!AlternatingGroup methodsFor: 'testing' stamp: 'len 5/29/2019 04:12:09'!
isSimple
	"A group is 'simple' if the only normal subgroups are the trivial group and itself."
	^ self degree >= 5! !

!AlternatingGroup methodsFor: 'private' stamp: 'len 5/18/2018 19:02:46'!
computeGenerators
	| X |
	X _ self space asArray.
	^ (1 to: self degree - 2) collect: [:i| self ambient cycle: {X at: i. X at: i+1. X at: i+2}]! !

!AlternatingGroup class methodsFor: 'examples' stamp: 'len 5/22/2018 21:40:59'!
example1
	"The group of even permutations on the set of 3 elements {1,2,3}."
	^ AlternatingGroup new: 3! !

!AlternatingGroup class methodsFor: 'examples' stamp: 'len 5/22/2018 21:42:51'!
example2
	"The group of even permutations on the set {a,b,c}."
	^ AlternatingGroup on: #(a b c).! !

!AlternatingGroup class methodsFor: 'instance creation' stamp: 'len 2/1/2018 23:51:38'!
new: anInteger
	^ self new ambient: (SymmetricGroup new: anInteger)! !

!AlternatingGroup class methodsFor: 'instance creation' stamp: 'len 2/1/2018 23:51:52'!
on: aCollection
	^ self new ambient: (SymmetricGroup on: aCollection)! !

!SymmetricGroup methodsFor: 'accessing' stamp: 'len 4/25/2020 08:55:49'!
alternatingSubgroup
	^ AlternatingGroup new ambient: self! !

!SymmetricGroup methodsFor: 'accessing' stamp: 'len 6/24/2016 08:44'!
ambient
	^ self! !

!SymmetricGroup methodsFor: 'accessing' stamp: 'len 2/1/2018 22:21:22'!
degree
	^ self space size! !

!SymmetricGroup methodsFor: 'accessing' stamp: 'len 2/16/2016 05:50'!
size
	^ self degree factorial! !

!SymmetricGroup methodsFor: 'accessing' stamp: 'len 2/1/2018 23:18:36'!
space
	^ self propertyAt: #space! !

!SymmetricGroup methodsFor: 'comparing' stamp: 'len 4/25/2020 07:43:59'!
= anObject
	(anObject isKindOf: SymmetricGroup) ifFalse: [^ super = anObject].
	^ self space = anObject space! !

!SymmetricGroup methodsFor: 'comparing' stamp: 'len 5/1/2016 06:32'!
>= anObject
	(anObject isKindOf: PermutationGroup)
		ifTrue: [^ self space >= anObject space].
	^ super >= anObject! !

!SymmetricGroup methodsFor: 'elements' stamp: 'len 7/31/2021 12:36:59'!
\ aPermutation
	"Answer the argument expressed as a word on the generators."
	| F f |
	F _ FreeGroup new: self degree - 1.
	f _ F identity.
	aPermutation transpositions do: [:each|
		| i j g |
		i _ each aChange.
		j _ each at: i.
		i > j ifTrue: [| t | t _ i. i _ j. j _ t].
		g _ i = 1 ifTrue: [F x: j-1] ifFalse: [(F x: i-1) * (F x: j-1) * (F x: i-1)].
		f _ f * g].
	^ F syllables: (f syllables collect: [:each| Association key: each key value: each value \\ 2])! !

!SymmetricGroup methodsFor: 'elements' stamp: 'len 5/25/2019 06:25:31'!
cycle: anArray
	| map first last |
	anArray size > 1 ifFalse: [^ self identity].
	map _ (1 to: self degree) asArray.
	anArray do: [:each| | i |
		i _ self spaceToIndex at: each.
		first isNil
			ifTrue: [first _ i]
			ifFalse: [map at: last put: i].
		last _ i].
	map at: last put: first.
	^ self images: map! !

!SymmetricGroup methodsFor: 'elements' stamp: 'len 4/30/2019 18:07:59'!
cycles: anArray
	^ anArray inject: self identity into: [:answer :each| answer * (self cycle: each)]! !

!SymmetricGroup methodsFor: 'elements' stamp: 'len 5/25/2019 06:26:00'!
evaluating: aBlock
	^ self images: (self indexToSpace collect: [:each| self spaceToIndex at: (aBlock value: each)])! !

!SymmetricGroup methodsFor: 'elements' stamp: 'len 5/25/2019 06:26:05'!
identity
	^ self propertyAt: #identity ifAbsentPut: [self images: (1 to: self degree) asArray]! !

!SymmetricGroup methodsFor: 'elements' stamp: 'len 5/25/2019 06:26:14'!
images: anArray
	^ Permutation new parent: self; images: anArray! !

!SymmetricGroup methodsFor: 'elements' stamp: 'len 4/9/2020 07:26:40'!
newFrom: anObject
	anObject isEvaluable ifTrue: [^ self evaluating: anObject].
	anObject isSequenceable ifFalse: [^ super newFrom: anObject].
	(anObject allSatisfy: [:each| each isSequenceable and: [self space includesAllOf: each]]) "cycles"
		ifTrue: [^ self cycles: anObject].
	(self space includesAllOf: anObject)
		ifTrue: [^ self images: (anObject asArray collect: [:each| self spaceToIndex at: each])].
	^ super newFrom: anObject! !

!SymmetricGroup methodsFor: 'elements' stamp: 'len 4/30/2019 18:16:46'!
transposing: anObject with: anotherObject
	"Answer the tranposition of anObject with anotherObject."
	^ self cycle: {anObject. anotherObject}! !

!SymmetricGroup methodsFor: 'enumerating' stamp: 'len 7/22/2021 18:28:33'!
do: aBlock
	self degree = 0 ifTrue: [aBlock value: self identity. ^ self].
	(1 to: self degree) permutationsDo: [:each| aBlock value: (self images: each copy)]! !

!SymmetricGroup methodsFor: 'operations' stamp: 'len 4/25/2020 08:57:00'!
commutator
	^ self alternatingSubgroup! !

!SymmetricGroup methodsFor: 'random' stamp: 'len 5/25/2019 06:25:25'!
atRandom: aRandom
	^ self images: ((1 to: self degree) asArray shuffledBy: aRandom)! !

!SymmetricGroup methodsFor: 'random' stamp: 'len 4/19/2016 22:45'!
atRandom: aRandom bits: bits
	^ self atRandom: aRandom! !

!SymmetricGroup methodsFor: 'testing' stamp: 'len 12/13/2016 07:31:06'!
contains: aPermutation
	"Answer true if the receiver contains the given element of its ambient."
	^ true! !

!SymmetricGroup methodsFor: 'testing' stamp: 'len 4/22/2020 06:36:05'!
includes: anObject
	^ anObject parent == self! !

!SymmetricGroup methodsFor: 'testing' stamp: 'len 2/16/2016 05:55'!
isAlmostSimple
	^ self degree >= 5! !

!SymmetricGroup methodsFor: 'testing' stamp: 'len 5/8/2019 13:53:47'!
isStandard
	"Answer true if the domain of the receiver is an interval [1..n]."
	^ self propertyAt: #isStandard ifAbsentPut: [self space = (1 to: self degree) asArray]! !

!SymmetricGroup methodsFor: 'testing' stamp: 'len 7/22/2021 18:27:37'!
isTrivial
	^ self degree <= 1! !

!SymmetricGroup methodsFor: 'private' stamp: 'len 7/31/2021 11:14:28'!
computeGenerators
	| X |
	X _ self indexToSpace.
	X isEmpty ifTrue: [^ #()].
	^ (2 to: X size) collect: [:i| self transposing: X first with: (X at: i)]
"alternatively: Coxeter generators, the set of (i,i+1) all the adjacent transpositions"! !

!SymmetricGroup methodsFor: 'private' stamp: 'len 5/1/2019 02:14:06'!
degree: anInteger
	| space |
	space _ (1 to: anInteger) asArray.
	self propertyAt: #space put: space; propertyAt: #spaceToIndex put: space; propertyAt: #indexToSpace put: space! !

!SymmetricGroup methodsFor: 'private' stamp: 'len 4/30/2019 12:18:10'!
indexToSpace
	^ self propertyAt: #indexToSpace ifAbsentPut: [self space asArray]! !

!SymmetricGroup methodsFor: 'private' stamp: 'len 2/1/2018 23:18:55'!
space: aCollection
	self propertyAt: #space put: aCollection! !

!SymmetricGroup methodsFor: 'private' stamp: 'len 4/30/2019 12:23:20'!
spaceToIndex
	^ self propertyAt: #spaceToIndex ifAbsentPut:
		[| answer |
		answer _ Dictionary new: self degree.
		self indexToSpace withIndexDo: [:x :i| answer at: x put: i].
		answer]! !

!SymmetricGroup class methodsFor: 'examples' stamp: 'len 2/27/2017 08:36:17'!
example1
	"The group of permutations on the set of 3 elements {1,2,3}."
	^ SymmetricGroup new: 3! !

!SymmetricGroup class methodsFor: 'examples' stamp: 'len 2/27/2017 08:36:50'!
example2
	"The group of permutations on the set {a,b,c}."
	^ SymmetricGroup on: #(a b c).! !

!SymmetricGroup class methodsFor: 'instance creation' stamp: 'len 5/1/2019 02:12:05'!
new: anInteger
	^ self new degree: anInteger! !

!SymmetricGroup class methodsFor: 'instance creation' stamp: 'len 2/1/2018 22:24:13'!
on: aCollection
	^ self new space: aCollection! !

!LinearGroup methodsFor: 'printing' stamp: 'len 12/8/2016 08:58:51'!
shortName
	^ nil! !

!LinearGroup methodsFor: 'accessing' stamp: 'len 9/27/2018 20:58:08'!
action
	"Answer the natural action that sends (f, x) to f(x)."
	^ GroupAction from: (self, self space) to: self space evaluatingWithArguments: [:f :x| f value: x]! !

!LinearGroup methodsFor: 'accessing' stamp: 'len 9/25/2018 17:07:47'!
degree
	^ self space rank! !

!LinearGroup methodsFor: 'accessing' stamp: 'len 9/27/2018 20:58:41'!
identity
	^ self space id! !

!LinearGroup methodsFor: 'accessing' stamp: 'len 4/1/2021 06:35:26'!
polynomialAction
	"Answer the action of the receiver on the polynomial ring K[x1...xn]."
	| R X |
	R _ self space coordinateRing.
	X _ R^R rank filling: [:i| R x: i].
	^ GroupAction from: (self, R) to: R evaluatingWithArguments: [:a :f| f value: (a asMatrix over: R) * X]! !

!LinearGroup methodsFor: 'accessing' stamp: 'len 9/25/2018 17:07:38'!
scalars
	^ self space scalars! !

!LinearGroup methodsFor: 'accessing' stamp: 'len 6/7/2020 06:24:21'!
space
	^ self ambient space! !

!LinearGroup methodsFor: 'invariants' stamp: 'len 5/3/2020 14:07:42'!
hilbertSeries
	"Answer the Hilbert series of the invariant ring of the receiver.
	This is the sum of dim(S_d ^G z^d for d>=0 (by Molien's formula, 1897), i.e. it counts the homogeneous polynomials of a given degree d that are invariants for the group."
	| order R |
	order _ self size.
	R _ self scalars polynomials fractions.
	^ (self elements sum: [:g| (R !! g characteristicPolynomial) reciprocal]) * (self scalars !! order) inverse! !

!LinearGroup methodsFor: 'invariants' stamp: 'len 11/29/2016 10:56:28'!
reynolds
	"Answer the Reynolds operator. Properties:
	- K-linear map S -> S^G;
	- restricts to the identity on S^G;
	- it's an S^G-module homomorphisms: R(p*q) = p*R(q) for all invariants p in S^G."
	| order action |
	order _ self size.
	action _ self polynomialAction.
	^ self space coordinateRing to: self invariantsRing evaluating: [:p| (self sum: [:g| action value: {g. p}]) / order]! !

!LinearGroup methodsFor: 'testing' stamp: 'len 9/27/2018 21:01:22'!
includes: anObject
	^ (self ambient includes: anObject) and: [self contains: anObject]! !

!LinearGroup methodsFor: 'testing' stamp: 'len 2/22/2016 00:27'!
isFinite
	^ self scalars isFinite or: [super isFinite]! !

!LinearGroup methodsFor: 'private' stamp: 'len 12/22/2016 21:52:52'!
computeSize
	"Schreier-Sims algorithm."
	| G answer |
	G _ self.
	answer _ 1.
	self space do: [:b| | tree |
		G isTrivial ifTrue: [^ answer].
		tree _ SchreierTree root: b generators: G generators action: G action.
		answer _ answer * tree orbit size.
		G _ tree stabilizer].
	self error: 'what?'.
	^ answer! !

!LinearGroup methodsFor: 'private' stamp: 'len 4/1/2021 12:19:16'!
species
	^ LinearGroup! !

!LinearGroup class methodsFor: 'examples' stamp: 'len 5/23/2020 09:13:12'!
C3
	"Cyclic matrix group of order 3."
	^ (/5 ^ 2) automorphisms span: #((0 1 -1 -1))! !

!LinearGroup class methodsFor: 'examples' stamp: 'len 5/23/2020 09:13:12'!
C4
	"Cyclic matrix group of order 4."
	^ (/7 ^ 2) automorphisms span: #((0 -1 1 0))! !

!LinearGroup class methodsFor: 'examples' stamp: 'len 5/23/2020 09:13:12'!
D8
	"Dihedral group of order 8."
	^ (/3 ^ 2) automorphisms span: #((0 1 2 0) (1 0 0 2))! !

!LinearGroup class methodsFor: 'examples' stamp: 'len 5/23/2020 09:11:37'!
GL
	"The general linear group of 3x3 invertible matrices with rational coefficients."
	^ (^3) automorphisms! !

!LinearGroup class methodsFor: 'examples' stamp: 'len 5/23/2020 09:13:12'!
klein
	"The Klein four-group (or Vierergruppe) as a linear group."
	^ (^2) automorphisms span: #((1 0 0 -1) (-1 0 0 1))! !

!LinearGroup class methodsFor: 'instance creation' stamp: 'len 6/7/2020 06:28:47'!
new: anInteger over: aRing
	^ self new ambient: (GeneralLinearGroup new: anInteger over: aRing)! !

!LinearGroup class methodsFor: 'instance creation' stamp: 'len 9/26/2018 22:23:58'!
on: aFreeModule generators: aCollection
	^ (GeneralLinearGroup on: aFreeModule) span: aCollection! !

!GeneralLinearGroup methodsFor: 'accessing' stamp: 'len 6/24/2016 08:44'!
ambient
	^ self! !

!GeneralLinearGroup methodsFor: 'accessing' stamp: 'len 9/27/2018 20:51:34'!
size
	| q n |
	(self scalars isField and: [self scalars isFinite])
		ifFalse: [^ super size].
	q _ self scalars size.
	n _ self dimension .
	^ q ^ (n*(n-1)/2) * ((1 to: n) inject: 1 into: [:x :k| q^k - 1 * x])! !

!GeneralLinearGroup methodsFor: 'accessing' stamp: 'len 6/7/2020 06:24:12'!
space
	^ self propertyAt: #space! !

!GeneralLinearGroup methodsFor: 'comparing' stamp: 'len 7/28/2020 09:24:27'!
= anObject
	(anObject isKindOf: GeneralLinearGroup) ifFalse: [^ super = anObject].
	^ self space = anObject space! !

!GeneralLinearGroup methodsFor: 'comparing' stamp: 'len 4/1/2021 12:19:16'!
>= anObject
	(anObject isKindOf: LinearGroup) ifFalse: [^ super >= anObject].
	^ self scalars >= anObject scalars and: [self degree = anObject degree]! !

!GeneralLinearGroup methodsFor: 'converting' stamp: 'len 6/1/2020 13:07:40'!
asAlgebraicVariety
	| n P det V endos |
	self scalars isField ifFalse: [self notYetImplemented].
	n _ self degree.
	P _ self scalars polynomialsIn: n squared + 1.
	endos _ (P^n) endomorphisms.
	det _ (endos !! P generators) determinant.
	V _ (P * (det * (P x: n squared + 1) - P one)) variety.
	V carrier
		addMap: (self carrier to: V carrier evaluating: [:M| V !! (M asTuple, M determinant inverse)]);
		addMap: (V carrier to: self carrier evaluating: [:p| endos !! p allButLast]).
	^ V! !

!GeneralLinearGroup methodsFor: 'elements' stamp: 'len 4/9/2020 18:10:41'!
adapt: anElement
	^ (self space endomorphisms adapt: anElement) ifNil: [^ super adapt: anElement]! !

!GeneralLinearGroup methodsFor: 'elements' stamp: 'len 6/1/2020 12:36:50'!
newFrom: anObject
	(anObject isKindOf: SequenceableCollection)
		ifTrue: [^ self space endomorphisms !! anObject].
	^ super newFrom: anObject! !

!GeneralLinearGroup methodsFor: 'enumerating' stamp: 'len 5/16/2019 12:41:22'!
do: aBlock
	((self hasProperty: #elements) or: [self hasProperty: #generators])
		ifTrue: [^ super do: aBlock].
	self space endomorphisms do: [:each| each isIsomorphism ifTrue: [aBlock value: each]]! !

!GeneralLinearGroup methodsFor: 'operations' stamp: 'len 9/26/2018 23:00:56'!
center
	^ ScalarGroup on: self space! !

!GeneralLinearGroup methodsFor: 'operations' stamp: 'len 9/26/2018 23:01:03'!
commutator
	(self degree = 2 and: [self scalars size = 2])
		ifFalse: [^ SpecialLinearGroup on: self space].
	^ self propertyAt: #commutator! !

!GeneralLinearGroup methodsFor: 'operations' stamp: 'len 9/26/2018 23:01:08'!
special
	"Answer the special linear group SL(n) which is a subgroup of the receiver."
	^ SpecialLinearGroup on: self space! !

!GeneralLinearGroup methodsFor: 'printing' stamp: 'len 2/11/2016 05:04'!
shortName
	^ 'GL'! !

!GeneralLinearGroup methodsFor: 'random' stamp: 'len 5/16/2019 12:41:45'!
atRandom: aRandom
	| answer |
	[(answer _ self space endomorphisms atRandom: aRandom) isIsomorphism] whileFalse.
	^ answer! !

!GeneralLinearGroup methodsFor: 'random' stamp: 'len 5/16/2019 12:41:35'!
atRandom: aRandom bits: bitSize
	| answer |
	[(answer _ self space endomorphisms atRandom: aRandom bits: bitSize) isIsomorphism] whileFalse.
	^ answer! !

!GeneralLinearGroup methodsFor: 'testing' stamp: 'len 9/27/2018 20:55:25'!
contains: anElement
	^ true! !

!GeneralLinearGroup methodsFor: 'testing' stamp: 'len 5/29/2020 14:18:10'!
includes: anObject
	^ anObject isMatrix and: [anObject domain = self space and: [anObject isAutomorphism]]! !

!GeneralLinearGroup methodsFor: 'private' stamp: 'len 6/7/2020 06:24:39'!
space: aFreeModule
	self propertyAt: #space put: aFreeModule! !

!GeneralLinearGroup class methodsFor: 'instance creation' stamp: 'len 6/7/2020 06:27:48'!
new: anInteger over: aRing
	^ self on: aRing ^ anInteger! !

!GeneralLinearGroup class methodsFor: 'instance creation' stamp: 'len 6/7/2020 06:27:38'!
on: aFreeModule
	^ self new space: aFreeModule! !

!OrthogonalGroup methodsFor: 'printing' stamp: 'len 2/11/2016 05:14'!
shortName
	^ 'O'! !

!OrthogonalGroup methodsFor: 'accessing' stamp: 'len 7/28/2020 09:39:51'!
bilinearForm
	^ self quadraticForm polarization! !

!OrthogonalGroup methodsFor: 'accessing' stamp: 'len 7/28/2020 09:28:38'!
quadraticForm
	^ self propertyAt: #quadraticForm! !

!OrthogonalGroup methodsFor: 'elements' stamp: 'len 7/28/2020 09:39:39'!
reflectionAt: aVector
	"Answer the orthogonal reflection with mirror hyperplane perpendicular to aVector."

	^ self space endomorphisms
		evaluating: [:v| v - (aVector * ((self bilinearForm value: {v. aVector}) * 2 / (self bilinearForm value: {aVector. aVector})))]! !

!OrthogonalGroup methodsFor: 'operations' stamp: 'len 7/28/2020 09:29:03'!
special
	^ SpecialOrthogonalGroup on: self quadraticForm! !

!OrthogonalGroup methodsFor: 'random' stamp: 'len 7/28/2020 10:30:25'!
atRandom: aRandom
	| answer v |
	answer _ self identity.
	self space rank "heuristic"
		timesRepeat:
			[[(v _ self space atRandom: aRandom) isZero] whileTrue.
			answer _ answer * (self reflectionAt: v)].
	^ answer! !

!OrthogonalGroup methodsFor: 'random' stamp: 'len 6/7/2020 06:29:48'!
atRandom: aRandom bits: bitSize
	| answer v |
	answer _ self identity.
	self space rank "heuristic"
		timesRepeat:
			[[(v _ self space atRandom: aRandom bits: bitSize // self space rank) isZero] whileTrue.
			answer _ answer  (self reflectionAt: v)].
	^ answer! !

!OrthogonalGroup methodsFor: 'testing' stamp: 'len 8/9/2020 07:56:08'!
contains: aMatrix
	"Answer true if the receiver contains the given element of its ambient."
	| A |
	A _ self bilinearForm matrix.
	^ aMatrix transpose * A * aMatrix = A! !

!OrthogonalGroup methodsFor: 'initialization' stamp: 'len 7/28/2020 09:22:51'!
quadraticForm: aQuadraticForm
	self propertyAt: #quadraticForm put: aQuadraticForm.
	self ambient: aQuadraticForm domain automorphisms! !

!OrthogonalGroup methodsFor: 'etc' stamp: 'len 6/3/2020 05:32:04'!
affine
	self notYetImplemented
	"^ EuclideanGroup on: self space"! !

!OrthogonalGroup class methodsFor: 'instance creation' stamp: 'len 7/28/2020 09:18:30'!
on: aQuadraticForm
	^ self new quadraticForm: aQuadraticForm! !

!ScalarGroup methodsFor: 'accessing' stamp: 'len 2/12/2016 02:18'!
dimension
	^ 1! !

!ScalarGroup methodsFor: 'enumerating' stamp: 'len 6/1/2020 12:14:07'!
do: aBlock
	self scalars do: [:each| each isZero ifFalse: [aBlock value: (self space endomorphisms scalar: each)]]! !

!ScalarGroup methodsFor: 'operations' stamp: 'len 9/25/2018 17:17:22'!
special
	^ SpecialScalarGroup on: self space! !

!ScalarGroup methodsFor: 'printing' stamp: 'len 2/11/2016 05:21'!
shortName
	^ 'Z'! !

!ScalarGroup methodsFor: 'random' stamp: 'len 9/27/2018 21:05:06'!
atRandom: aRandom
	| a |
	[a _ self scalars atRandom: aRandom. a isZero] whileTrue.
	^ self identity * a! !

!ScalarGroup methodsFor: 'random' stamp: 'len 9/27/2018 21:06:01'!
atRandom: aRandom bits: bitSize
	| a |
	[a _ self scalars atRandom: aRandom bits: bitSize. a isZero] whileTrue.
	^ self identity * a! !

!ScalarGroup methodsFor: 'testing' stamp: 'len 7/28/2020 11:05:25'!
contains: aMatrix
	"Answer true if the receiver contains the given element of its ambient."
	^ aMatrix isScalar! !

!ScalarGroup methodsFor: 'testing' stamp: 'len 12/8/2016 11:16:42'!
isCommutative
	^ self scalars isCommutative! !

!SpecialLinearGroup methodsFor: 'operations' stamp: 'len 12/18/2021 20:31:25'!
asAlgebraicVariety
	| n P det |
	n _ self degree.
	P _ self scalars polynomialsIn: n squared.
	det _ (P matrix: n filling: [:i :j| P x: i - 1 * n + j]) determinant.
	^ (P * (det - self scalars one)) variety! !

!SpecialLinearGroup methodsFor: 'operations' stamp: 'len 9/25/2018 17:17:31'!
center
	^ SpecialScalarGroup on: self space! !

!SpecialLinearGroup methodsFor: 'printing' stamp: 'len 2/11/2016 05:20'!
shortName
	^ 'SL'! !

!SpecialLinearGroup methodsFor: 'testing' stamp: 'len 7/28/2020 11:05:34'!
contains: aMatrix
	"Answer true if the receiver contains the given element of its ambient."
	^ aMatrix determinant = self scalars one! !

!SpecialOrthogonalGroup methodsFor: 'printing' stamp: 'len 2/11/2016 05:20'!
shortName
	^ 'SO'! !

!SpecialOrthogonalGroup methodsFor: 'as yet unclassified' stamp: 'len 6/3/2020 05:32:12'!
affine
	^ self notYetImplemented
"	^ SpecialEuclideanGroup on: self space affine"! !

!SpecialOrthogonalGroup methodsFor: 'testing' stamp: 'len 8/9/2020 07:56:48'!
contains: aMatrix
	"Answer true if the receiver contains the given element of its ambient."
	| A |
	A _ self bilinearForm matrix.
	^ aMatrix transpose * A * aMatrix = A and: [aMatrix determinant = self scalars one]! !

!SpecialOrthogonalGroup methodsFor: 'initialization' stamp: 'len 7/28/2020 10:46:06'!
quadraticForm: aQuadraticForm
	self propertyAt: #quadraticForm put: aQuadraticForm.
	self ambient: aQuadraticForm domain automorphisms! !

!SpecialOrthogonalGroup methodsFor: 'accessing' stamp: 'len 7/28/2020 10:46:35'!
bilinearForm
	^ self quadraticForm polarization! !

!SpecialOrthogonalGroup methodsFor: 'accessing' stamp: 'len 7/28/2020 10:46:45'!
quadraticForm
	^ self propertyAt: #quadraticForm! !

!SpecialOrthogonalGroup class methodsFor: 'instance creation' stamp: 'len 7/28/2020 10:45:30'!
on: aQuadraticForm
	^ self new quadraticForm: aQuadraticForm! !

!SpecialScalarGroup methodsFor: 'printing' stamp: 'len 2/11/2016 05:38'!
shortName
	^ 'SZ'! !

!SpecialScalarGroup methodsFor: 'testing' stamp: 'len 7/28/2020 11:05:03'!
contains: aMatrix
	"Answer true if the receiver contains the given element of its ambient."
	^ aMatrix isScalar and: [aMatrix determinant = self scalars one]! !

!SpecialScalarGroup methodsFor: 'testing' stamp: 'len 12/8/2016 11:17:14'!
isCommutative
	^ self scalars isCommutative! !

!UnitGroup methodsFor: 'accessing' stamp: 'len 5/6/2019 02:38:25'!
action
	"Answer the natural action that sends (u, x) to x*u, i.e. multiplies ring elements by units."
	^ GroupAction from: (self, self space) to: self space evaluatingWithArguments: [:u :x| x*u]! !

!UnitGroup methodsFor: 'accessing' stamp: 'len 5/6/2019 02:41:34'!
identity
	^ self space one! !

!UnitGroup methodsFor: 'accessing' stamp: 'len 5/6/2019 02:38:35'!
space
	^ self propertyAt: #space! !

!UnitGroup methodsFor: 'enumerating' stamp: 'len 5/6/2019 02:41:07'!
do: aBlock
	self space unitsDo: aBlock! !

!UnitGroup methodsFor: 'random' stamp: 'len 7/30/2021 10:54:52'!
atRandom: aRandom
	^ (self space atRandom: aRandom) normalization! !

!UnitGroup methodsFor: 'random' stamp: 'len 7/30/2021 10:54:59'!
atRandom: aRandom bits: bitSize
	^ (self space atRandom: aRandom bits: bitSize) normalization! !

!UnitGroup methodsFor: 'testing' stamp: 'len 5/4/2020 10:09:03'!
contains: anElement
	^ anElement isUnit! !

!UnitGroup methodsFor: 'testing' stamp: 'len 5/4/2020 10:09:22'!
includes: anElement
	^ (self space includes: anElement) and: [anElement isUnit]! !

!UnitGroup methodsFor: 'private' stamp: 'len 5/6/2019 02:38:58'!
space: aRing
	self propertyAt: #space put: aRing! !

!UnitGroup class methodsFor: 'instance creation' stamp: 'len 5/6/2019 02:39:49'!
on: aRing
	^ self new space: aRing! !

!ModularIntegerUnitGroup methodsFor: 'accessing' stamp: 'len 5/10/2020 11:04:55'!
generators
	self propertyAt: #generators ifPresent: [:aCollection| ^ aCollection].
	self isCyclic ifTrue: [^ self propertyAt: #generators put: {self space primitiveRoot}].
	^ super generators! !

!ModularIntegerUnitGroup methodsFor: 'accessing' stamp: 'len 5/6/2019 02:41:40'!
modulus
	^ self space modulus! !

!ModularIntegerUnitGroup methodsFor: 'accessing' stamp: 'len 12/28/2016 11:31:26'!
size
	^ self propertyAt: #size ifAbsentPut: [self modulus phi]! !

!ModularIntegerUnitGroup methodsFor: 'testing' stamp: 'len 5/4/2020 10:48:53'!
isCyclic
	"The group of units of Z/nZ is cyclic iff n = 1, 2, 4, or 2p^k for odd prime p."
	| factors n |
	n _ self modulus.
	(n = 1 or: [n = 2 or: [n = 4]]) ifTrue: [^ true].
	n even ifTrue: [n _ n // 2].
	n even ifTrue: [^ false].
	"we mihgt be unnecessarily factorizing the modulus:"
	factors _ self space modulusFactors.
	(factors occurrencesOf: 2) > 1 ifTrue: [^ false].
	^ (factors asSet copyWithout: 2) size = 1! !

!EllipticCurveGroup methodsFor: 'accessing' stamp: 'len 9/28/2018 06:40:54'!
ambient
	^ self! !

!EllipticCurveGroup methodsFor: 'accessing' stamp: 'len 11/10/2016 08:06'!
curve
	^ curve! !

!EllipticCurveGroup methodsFor: 'accessing' stamp: 'len 12/14/2016 22:09:37'!
identity
	"This is the point at infinity."
	^ curve pointAt: (scalars tuple: {scalars zero. scalars one. scalars zero})! !

!EllipticCurveGroup methodsFor: 'accessing' stamp: 'len 11/10/2016 08:06'!
scalars
	^ scalars! !

!EllipticCurveGroup methodsFor: 'accessing' stamp: 'len 4/2/2017 10:31:48'!
torsion
	"Answer the torsion subgroup of the receiver."
	"Henri Cohen, 'A Course in Computational Algebraic Number Theory', Algorithm 7.5.5."
"	| E b2 b4 b6 b8 discriminant |
	E _ self curve equation.
	b2 _ E b2.
	b4 _ E b4.
	b6 _ E b6.
	b8 _ E b8.
	discriminant _ E discriminant.
	points add: self identity.
	..."
	self notYetImplemented! !

!EllipticCurveGroup methodsFor: 'accessing-private' stamp: 'len 11/10/2016 08:11'!
curve: anEllipticCurve
	curve _ anEllipticCurve! !

!EllipticCurveGroup methodsFor: 'accessing-private' stamp: 'len 11/10/2016 08:11'!
scalars: aField
	scalars _ aField! !

!EllipticCurveGroup methodsFor: 'enumerating' stamp: 'len 11/10/2016 08:10'!
do: aBlock
	self curve pointsOver: self scalars do: aBlock! !

!EllipticCurveGroup methodsFor: 'random' stamp: 'len 8/27/2018 22:24:49'!
atRandom: aRandom
	^ curve pointAtRandom: aRandom! !

!EllipticCurveGroup class methodsFor: 'instance creation' stamp: 'len 11/10/2016 08:11'!
on: anEllipticCurve over: aField
	^ self new curve: anEllipticCurve; scalars: aField! !

!SemidirectProductGroup methodsFor: 'accessing' stamp: 'len 2/12/2016 06:15'!
action
	^ action! !

!SemidirectProductGroup methodsFor: 'accessing' stamp: 'len 2/16/2016 07:30'!
arity
	^ 2! !

!SemidirectProductGroup methodsFor: 'accessing' stamp: 'len 4/22/2016 20:49'!
identity
	^ self project: {left identity. right identity}! !

!SemidirectProductGroup methodsFor: 'accessing' stamp: 'len 2/12/2016 06:16'!
left
	^ left! !

!SemidirectProductGroup methodsFor: 'accessing' stamp: 'len 2/12/2016 06:16'!
right
	^ right! !

!SemidirectProductGroup methodsFor: 'accessing' stamp: 'len 2/12/2016 06:55'!
size
	^ left size * right size! !

!SemidirectProductGroup methodsFor: 'converting' stamp: 'len 4/19/2016 20:55'!
asCartesianProduct
	^ (left, right)! !

!SemidirectProductGroup methodsFor: 'enumerating' stamp: 'len 2/12/2016 06:57'!
do: aBlock
	left do: [:g| right do: [:h| aBlock value: (self project: {g.h})]]! !

!SemidirectProductGroup methodsFor: 'morphisms' stamp: 'len 10/6/2016 15:35'!
project: anArray
	"Project a cartesian product of two elements to their semidirect product."
	^ SemidirectProductElement new
		parent: self;
		left: (anArray at: 1);
		right: (anArray at: 2)! !

!SemidirectProductGroup methodsFor: 'morphisms' stamp: 'len 5/23/2020 07:33:35'!
projection
	"Answer the projection from the cartesian product of two groups to their semidirect product."
	^ ((left, right) to: self evaluating: [:each| self project: each]) name: ''! !

!SemidirectProductGroup methodsFor: 'random' stamp: 'len 4/19/2016 20:52'!
atRandom: aRandom
	^ self project: (self asCartesianProduct atRandom: aRandom)! !

!SemidirectProductGroup methodsFor: 'random' stamp: 'len 4/19/2016 20:52'!
atRandom: aRandom bits: bitSize
	^ self project: (self asCartesianProduct atRandom: aRandom bits: bitSize)! !

!SemidirectProductGroup methodsFor: 'private' stamp: 'len 2/12/2016 06:17'!
action: anAction
	action _ anAction! !

!SemidirectProductGroup methodsFor: 'private' stamp: 'len 2/12/2016 06:17'!
left: aGroup
	left _ aGroup! !

!SemidirectProductGroup methodsFor: 'private' stamp: 'len 2/12/2016 06:17'!
right: aGroup
	right _ aGroup! !

!SemidirectProductGroup class methodsFor: 'instance creation' stamp: 'len 2/12/2016 06:16'!
left: aGroup right: anotherGroup action: anAction
	^ self new left: aGroup; right: anotherGroup; action: anAction! !

!CoxeterGroup methodsFor: 'as yet unclassified' stamp: 'len 4/18/2016 01:25'!
diagram
	^ diagram! !

!CoxeterGroup methodsFor: 'as yet unclassified' stamp: 'len 4/18/2016 01:24'!
diagram: aGraph
	diagram _ aGraph! !

!CoxeterGroup methodsFor: 'as yet unclassified' stamp: 'len 4/18/2016 01:39'!
gramMatrix
	^ self matrix collect: [:x| -2 * (Float pi / x) cos]! !

!CoxeterGroup methodsFor: 'as yet unclassified' stamp: 'len 4/18/2016 01:39'!
isHyperbolic
	^ (self gramMatrix spectrum count: [:each| each negative]) = 1! !

!CoxeterGroup methodsFor: 'as yet unclassified' stamp: 'len 5/10/2019 09:57:34'!
presentation
	self notYetImplemented
"	| generators relators |
	generators _ diagram values collect: [:each| Word x: each].
	relators _ OrderedCollection new.
	diagram edgesAndLabelsDo: [:each :label|
		label isInfinity
			ifFalse: [relators add: (Word x: each key) * (Word x: each value) ^ (label ifNil: [3])]].
	^ GroupPresentation generators: generators relators: relators"! !

!CoxeterGroup class methodsFor: 'as yet unclassified' stamp: 'len 4/18/2016 01:25'!
diagram: aGraph
	^ self new diagram: aGraph! !

!CoxeterGroup class methodsFor: 'as yet unclassified' stamp: 'len 4/5/2018 15:26:58'!
matrix: aMatrix
	| n graph |
	n _ aMatrix width.
	graph _ Graph unorderedLabeled.
	graph addAll: (1 to: n).
	1 to: n do: [:i|
		1 to: n do: [:j|
			| m |
			m _ aMatrix at: i@j.
			m = 3 ifTrue: [graph addEdgeFrom: i to: j label: nil].
			m > 3 ifTrue: [graph addEdgeFrom: i to: j label: m]]].
	^ self diagram: graph! !

!DirichletGroup methodsFor: 'as yet unclassified' stamp: 'len 12/28/2016 11:30:39'!
codomain
	"Answer the codomain of the characters."
	^ self propertyAt: #codomain ifAbsentPut: [CyclotomicField new: self domain exponent]! !

!DirichletGroup methodsFor: 'as yet unclassified' stamp: 'len 12/28/2016 11:30:49'!
codomain: aCodomain
	self propertyAt: #codomain put: aCodomain! !

!DirichletGroup methodsFor: 'as yet unclassified' stamp: 'len 8/5/2021 08:38:30'!
decomposition
	| answer |
	answer _ OrderedCollection new.
	self modulus factorization withOccurrencesDo:
		[:p :e| answer add: (self class new: p^e to: self codomain)].
	^ answer! !

!DirichletGroup methodsFor: 'as yet unclassified' stamp: 'len 12/28/2016 11:30:54'!
domain
	^ self propertyAt: #domain! !

!DirichletGroup methodsFor: 'as yet unclassified' stamp: 'len 12/10/2016 13:34:31'!
hash
	^ self domain hash hashMultiply + self codomain hash! !

!DirichletGroup methodsFor: 'as yet unclassified' stamp: 'len 12/9/2016 15:49:11'!
modulus
	^ self domain modulus! !

!DirichletGroup methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:13:12'!
modulus: anInteger
	self propertyAt: #domain put: ( / anInteger) units! !

!DirichletGroup class methodsFor: 'instance creation' stamp: 'len 12/9/2016 15:51:30'!
new: anInteger
	^ self new modulus: anInteger! !

!DirichletGroup class methodsFor: 'instance creation' stamp: 'len 12/10/2016 13:26:28'!
new: anInteger to: aCodomain
	^ self new modulus: anInteger; codomain: aCodomain! !

!ArithmeticGroup methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:03:47'!
action
	^ GroupAction from: (self, ) to:  evaluatingWithArguments: [:f :z| f value: z]! !

!ArithmeticGroup methodsFor: 'as yet unclassified' stamp: 'len 12/20/2016 12:20:53'!
ambient
	^ ModularGroup new! !

!ArithmeticGroup methodsFor: 'as yet unclassified' stamp: 'len 12/21/2016 16:04:00'!
identity
	^ ModularMap I! !

!ArithmeticGroup methodsFor: 'as yet unclassified' stamp: 'len 12/21/2016 16:02:29'!
orderOf: aModularMap
	| trace |
	aModularMap isIdentity ifTrue: [^ 1].
	"aModularMap negated isIdentity ifTrue: [^ 2]."
	trace _ aModularMap trace.
	(trace <= -2 or: [trace >= 2]) ifTrue: [^ Infinity positive].
	trace == 1 ifTrue: [^ 6].
	trace == -1 ifTrue: [^ 3].
	"trace == 0"
	^ 4! !

!ArithmeticGroup methodsFor: 'as yet unclassified' stamp: 'len 12/29/2021 11:55:57'!
size
	^ Cardinal new! !

!ArithmeticGroup methodsFor: 'as yet unclassified' stamp: 'len 12/21/2016 16:01:59'!
upperHalfPlaneAction
	^ GroupAction from: (self, HH) to: HH evaluating: [:f :z| f value: z]! !

!CongruenceSubgroup methodsFor: 'accessing' stamp: 'len 12/28/2016 11:29:40'!
level
	^ self propertyAt: #level! !

!CongruenceSubgroup methodsFor: 'accessing-private' stamp: 'len 12/28/2016 11:29:48'!
level: anInteger
	self propertyAt: #level put: anInteger! !

!CongruenceSubgroup methodsFor: 'as yet unclassified' stamp: 'len 12/15/2016 23:14:57'!
indexOf: aSubgroup
	^ (aSubgroup isKindOf: CongruenceSubgroup) ifTrue: [aSubgroup index / self index] ifFalse: [super indexOf: aSubgroup]! !

!CongruenceSubgroup methodsFor: 'operations' stamp: 'len 12/11/2016 07:51:01'!
curve
	"Answer the modular curve associated to the receiver. This is the orbit space of H/G (the upper half plane modulo the receiver) compactified canonically by adding the cusps."
	^ self notYetImplemented! !

!CongruenceSubgroup methodsFor: 'operations' stamp: 'len 12/7/2016 12:06:58'!
cusps
	"Answer the set of cusps of the receiver, i.e. the set of orbits of P^1(Q) under the action of the group. This set is finite."
	^ self notYetImplemented! !

!CongruenceSubgroup methodsFor: 'operations' stamp: 'len 12/11/2016 07:51:21'!
genus
	^ self curve genus
"(1 + projectiveIndex) / 12 - nu2 / 4 - nu3 / 4 - ncusps/2"! !

!CongruenceSubgroup methodsFor: 'operations' stamp: 'len 6/1/2020 15:10:39'!
widthOf: aCusp
	"Algorithm 1.19 (Width of a cusp) in Stein's 'Modular Forms, A Computational Approach'."
	| gamma |
	aCusp isInfinite
		ifTrue:
			[gamma _ self identity]
		ifFalse:
			[| a b xgcd |
			a _ aCusp numerator.
			b _ aCusp denominator.
			xgcd _ a xgcd: b.
			gamma _ Matrix rows: {(a, b). ((xgcd at: 2), (xgcd at: 3))}].
	"..."! !

!CongruenceSubgroup methodsFor: 'testing' stamp: 'len 6/2/2018 17:59:42'!
isEven
	self flag: #fix. "this makes sense for the homogeneous group only, ~ SL(2,Z)"
	^ self includes: self identity negated! !

!CongruenceSubgroup methodsFor: 'testing' stamp: 'len 6/2/2018 17:59:51'!
isOdd
	self flag: #fix. "this makes sense for the homogeneous group only, ~ SL(2,Z)"
	^ self even not! !

!CongruenceSubgroup class methodsFor: 'instance creation' stamp: 'len 12/7/2016 11:56:57'!
new: anInteger
	^ self new level: anInteger! !

!Gamma0CongruenceSubgroup methodsFor: 'as yet unclassified' stamp: 'len 12/10/2016 12:24:21'!
even
	^ true! !

!Gamma0CongruenceSubgroup methodsFor: 'as yet unclassified' stamp: 'len 8/5/2021 08:38:59'!
index
	"Answer the index of the receiver in the modular group."
	| answer |
	answer _ 1.
	self level factorization withOccurrencesDo: [:p :e| answer _ answer * (p ^ e + (p ^ (e - 1)))].
	^ answer
	! !

!Gamma0CongruenceSubgroup methodsFor: 'as yet unclassified' stamp: 'len 12/10/2016 12:19:31'!
numberOfCusps
	| n |
	n _ self level.
	^ n divisors sum: [:d| (d gcd: n // d) phi]! !

!Gamma1CongruenceSubgroup methodsFor: 'as yet unclassified' stamp: 'len 12/10/2016 12:28:30'!
even
	^ self level = 1 or: [self level = 2]! !

!PrincipalCongruenceSubgroup methodsFor: 'as yet unclassified' stamp: 'len 12/15/2016 23:02:54'!
* aGroup
	(aGroup isKindOf: PrincipalCongruenceSubgroup)
		ifFalse: [^ super * aGroup].
	^ self class new: (self level gcd: aGroup level)! !

!PrincipalCongruenceSubgroup methodsFor: 'as yet unclassified' stamp: 'len 5/10/2019 04:33:25'!
/\ aGroup
	"Answer the intersection of the receiver and the argument."
	(aGroup isKindOf: PrincipalCongruenceSubgroup)
		ifFalse: [^ super /\ aGroup].
	^ self class new: (self level lcm: aGroup level)! !

!PrincipalCongruenceSubgroup methodsFor: 'as yet unclassified' stamp: 'len 8/5/2021 08:42:28'!
index
	"Answer the index of the receiver in the modular group."
	| answer |
	answer _ 1.
	self level factorization withOccurrencesDo: [:p :e| answer _ answer * (p ^ (e*3 - 2) * (p*p - 1))].
	^ answer! !

!PrincipalCongruenceSubgroup methodsFor: 'as yet unclassified' stamp: 'len 8/5/2021 08:42:32'!
numberOfCusps
	| count |
	self level = 1 ifTrue: [^ 1].
	self level = 2 ifTrue: [^ 3].
	count _ 1.
	self level factorization withOccurrencesDo: [:p :e| count _ count * (p ^ (e*2) - (p ^ (e*2 - 2)))].
	^ count // 2! !

!PrincipalCongruenceSubgroup methodsFor: 'as yet unclassified' stamp: 'len 12/10/2016 11:34:29'!
numberOfIrregularCusps
	^ 0! !

!ModularGroup methodsFor: 'as yet unclassified' stamp: 'len 12/24/2016 12:06:20'!
S
	^ ModularMap S! !

!ModularGroup methodsFor: 'as yet unclassified' stamp: 'len 12/24/2016 12:06:24'!
T
	^ ModularMap T! !

!ModularGroup methodsFor: 'as yet unclassified' stamp: 'len 12/24/2016 12:08:05'!
T: n
	^ ModularMap a: 1 b: n c: 0 d: 1! !

!ModularGroup methodsFor: 'as yet unclassified' stamp: 'len 12/21/2016 16:06:26'!
generators
	^ {ModularMap T. ModularMap S}! !

!ModularGroup methodsFor: 'as yet unclassified' stamp: 'len 12/11/2016 07:53:49'!
level
	^ 1! !

!ModularGroup methodsFor: 'as yet unclassified' stamp: 'len 12/11/2016 07:53:46'!
level: anInteger
	^ self shouldNotImplement! !

!ModularGroup methodsFor: 'as yet unclassified' stamp: 'len 8/9/2020 07:46:51'!
reduce: aPoint
	"Given a point in the upper half plane, return an element of the receiver that maps the point to a representative in the standard fundamental domain.
	Reference: Henri Cohen, 'A Course in Computational Algebraic Number Theory', Algorithm 7.4.2."
	| tau A n m |
	tau _ aPoint.
	A _ self identity.
	[n _ tau real rounded.
	tau _ tau - n.
	A _ (self T: n negated)  A.
	m _ tau * tau conjugate.
	m >= 1 ifTrue: [^ {tau. A}].
	tau _ tau conjugate negated / m.
	A _ self S  A] repeat! !

!Module methodsFor: 'accessing' stamp: 'len 12/26/2021 11:14:08'!
base
	^ self propertyAt: #base ifAbsentPut: [self ambient base span: (self generators collect: [:each| each representative])]! !

!Module methodsFor: 'accessing' stamp: 'len 1/13/2022 11:48:12'!
basis
	^ self propertyAt: #basis ifAbsentPut: [self basisMatrix columns collect: [:each| self ambient elementAt: each]]! !

!Module methodsFor: 'accessing' stamp: 'len 1/13/2022 11:59:03'!
basisMatrix
"	(self isFreelyGenerated and: [self scalars isPID]) ifTrue: [^ self generatorMatrix]."
	^ self propertyAt: #basisMatrix ifAbsentPut: [self generatorMatrix basis]! !

!Module methodsFor: 'accessing' stamp: 'len 10/25/2020 08:25:08'!
coordinateRing
	^ self coordinates coordinateRing! !

!Module methodsFor: 'accessing' stamp: 'len 3/13/2021 08:49:08'!
coordinates
	^ self generatorMatrix domain! !

!Module methodsFor: 'accessing' stamp: 'len 3/14/2020 17:35:03'!
corank
	^ self ambient rank - self rank! !

!Module methodsFor: 'accessing' stamp: 'len 3/5/2020 17:48:49'!
degree
	"Answer the degree of this free module.
	This is the rank of the ambient module."
	^ self ambient rank! !

!Module methodsFor: 'accessing' stamp: 'len 3/11/2020 18:55:41'!
discriminant
	^ self gramian determinant
	
"sage defines it like this for free quadratic modules:
	^ (self rank // 2) even ifTrue: [self gramian determinant] ifFalse: [self gramian determinant negated]
"! !

!Module methodsFor: 'accessing' stamp: 'len 10/20/2020 18:48:32'!
exponent
	"Answer the exponent of the receiver, i.e. the maximum order of an element."
	self isAbelianGroup ifFalse: [^ DomainError signal: 'not an abelian group'].
	^ self invariants inject: 1 into: [:answer :each| answer lcm: each]! !

!Module methodsFor: 'accessing' stamp: 'len 3/13/2021 12:17:45'!
generator
	self isTrivial ifTrue: [^ self zero].
	^ super generator! !

!Module methodsFor: 'accessing' stamp: 'len 10/26/2020 15:26:48'!
generatorMatrix
	^ self propertyAt: #generatorMatrix! !

!Module methodsFor: 'accessing' stamp: 'len 3/10/2021 18:01:02'!
generators
	^ self propertyAt: #generators ifAbsentPut: [self generatorMatrix columns collect: [:each| self ambient elementAt: each]]! !

!Module methodsFor: 'accessing' stamp: 'len 1/25/2022 11:09:21'!
genericRank
	self scalars isIntegralDomain ifFalse: [^ self error: 'not over integral domain'].
	^ (self over: self scalars fractions) rank! !

!Module methodsFor: 'accessing' stamp: 'len 8/10/2020 08:07:46'!
gramian
	"Answer the Gramian of the receiver, or Gram matrix.
	If M is the generator matrix of the receiver, and the inner product of the receiver is the dot product, then the Gramian is M transposed * M."
	| M |
	M _ self generatorMatrix.
	^ M transpose * self ambient innerProduct matrix * M

"	^ self matrix * self ambient innerProduct matrix * self matrix transposed"
"	| f |
	f _ self ambient innerProduct.
	^ self ambient scalars
		matrix: self rank
		evaluating:
			[:i :j| f value: {(self basis at: i). (self basis at: j)}]"! !

!Module methodsFor: 'accessing' stamp: 'len 10/20/2020 15:30:29'!
identity
	^ self zero! !

!Module methodsFor: 'accessing' stamp: 'len 10/19/2020 21:57:40'!
invariants
	"Answer the Smith normal form abelian invariants of the reciever, each dividing the next.
	Each infinite cylic factor is represented by 0."
	^ self propertyAt: #invariants ifAbsentPut:
		[| M elementaryDivisors |
		M _ self presentationMatrix.
		elementaryDivisors _ M elementaryDivisors.
		((elementaryDivisors size + 1 to: M height) collect: [:each| self scalars zero]), (elementaryDivisors copyWithout: self scalars one)]! !

!Module methodsFor: 'accessing' stamp: 'len 10/25/2020 10:14:35'!
length
	self isVectorSpace ifTrue: [^ self rank].
	self isTrivial ifTrue: [^ 0].
	^ self notYetImplemented "^ self base length - self relations length ? or should we compute it as the length of the composition series?"! !

!Module methodsFor: 'accessing' stamp: 'len 4/3/2018 06:34:35'!
null
	"Answer the trivial submodule, i.e. the zero object in the category of R-modules."
	^ self ambient span: #()! !

!Module methodsFor: 'accessing' stamp: 'len 7/10/2021 05:38:28'!
presentationMatrix
	^ self propertyAt: #presentationMatrix ifAbsentPut:
		[self isAmbient ifTrue: [^ self subclassResponsibility].
		self generatorMatrix syzygiesModulo: self ambient presentationMatrix]! !

!Module methodsFor: 'accessing' stamp: 'len 10/20/2020 18:51:17'!
primaryBasis
	"Answer a list of generators whose orders are the primary invariants of the receiver.
	See >>primaryInvariants."
	self notYetImplemented! !

!Module methodsFor: 'accessing' stamp: 'len 8/5/2021 08:40:39'!
primaryInvariants
	"Answer the primary abelian invariants of the receiver, consisting of prime powers q(i) such that the torsion subgroup of the receiver is isomorphic to the direct sum of all the Z/q(i)Z. Each infinite cyclic factor is represented by 0."
	| answer |
	self propertyAt: #primaryInvariants ifPresent: [:aBag| ^ aBag].
	answer _ Bag new.
	"this can be improved because each invariant divides the next:"
	self invariants do: [:each|
		each isZero
			ifTrue: [answer add: each]
			ifFalse: [each factorization withOccurrencesDo: [:p :k| answer add: p^k]]].
	^ self propertyAt: #primaryInvariants put: answer! !

!Module methodsFor: 'accessing' stamp: 'len 5/3/2021 11:22:54'!
rank
	self isTrivial ifTrue: [^ 0].
	self isFreelyGenerated ifTrue: [^ self coordinates rank].
	self scalars isPID ifTrue: [^ self invariants count: [:each| each isZero]].
	^ self notYetImplemented! !

!Module methodsFor: 'accessing' stamp: 'len 12/26/2021 11:15:24'!
relations
	self isAmbient ifFalse: [^ self ambient relations].
	^ self subclassResponsibility! !

!Module methodsFor: 'accessing' stamp: 'len 3/10/2021 17:55:09'!
resolution
	"Answer a free resolution of the receiver."
	| differentials M |
	differentials _ OrderedCollection new.
	differentials add: self ambient -> self ambient null.
	differentials add: self -> self ambient.
	M _ self.
	[M syzygies isTrivial]
		whileFalse:
			[
			differentials add: M syzygies coordinates -> M coordinates. "presentation matrix?"
			M _ M syzygies].
	differentials add: differentials last domain null -> differentials last domain.
	^ ChainComplex differentials: differentials reversed! !

!Module methodsFor: 'accessing' stamp: 'len 12/25/2021 08:38:20'!
scalars
	^ self coordinates scalars! !

!Module methodsFor: 'accessing' stamp: 'len 12/29/2021 11:55:57'!
size
	self isTrivial ifTrue: [^ 1].
	self isAbelianGroup ifTrue: [^ (self invariants includes: 0) ifTrue: [Cardinal new] ifFalse: [self invariants product]].
	self isFree ifTrue: [^ self scalars size ^ self rank].
	^ super size! !

!Module methodsFor: 'accessing' stamp: 'len 3/10/2021 17:50:20'!
syzygies
	"Answer the first syzygies module of the generators of the receiver.
	If the receiver is a module generated by n generators {f1,...,fn}, the syzygies module is the submodule of R^n whose elements are all the n-tuples (a1,...,an) with a1*f1 + ... + an*fn = 0."
	^ self presentationMatrix image! !

!Module methodsFor: 'accessing' stamp: 'len 8/10/2021 17:43:52'!
torsion
	"Answer the torsion submodule of the receiver, i.e. the set of elements e such that there is a non-zerodivisor scalar r with e*r = 0. For an abelian group, this is the submodule of elements of finite order."
	self isAbelianGroup ifFalse: [^ self notYetImplemented].
	self isFinite ifTrue: [^ self].
	self flag: #fix. "should answer a submodule:"
	^ self invariants inject: ^0 into: [:sum :each| each > 1 ifTrue: [sum  (/each) asAbelianGroup] ifFalse: [sum]]! !

!Module methodsFor: 'accessing' stamp: 'len 10/25/2020 09:02:20'!
torsionFree
	"Answer the torsion-free subgroup, i.e. the subgroup of elements of infinite order (plus the identity)."
	self isAbelianGroup ifFalse: [^ Domain signal: 'not a Z-module'].
	self isFinite ifTrue: [^ self null].
	self flag: #fix. "should answer a submodule:"
	^ ^self rank! !

!Module methodsFor: 'accessing' stamp: 'len 5/14/2019 18:29:23'!
zero
	^ self propertyAt: #zero ifAbsentPut: [self isAmbient ifTrue: [self generators anyOne * self scalars zero] ifFalse: [self ambient zero]]! !

!Module methodsFor: 'printing' stamp: 'len 12/20/2021 17:50:52'!
printGeneratorsOn: aStream
	self isTrivial ifTrue: [aStream print: self zero. ^ self].
	self generators do: [:each| aStream print: each] separatedBy: [aStream nextPutAll: '; ']! !

!Module methodsFor: 'comparing' stamp: 'len 1/9/2022 09:51:49'!
< aModule
	"Answer true if the receiver is a proper submodule of the argument."
	^ self ~= aModule and: [self <= aModule]! !

!Module methodsFor: 'comparing' stamp: 'len 1/9/2022 09:52:00'!
<= aModule
	"Answer true if the receiver a submodule of the argument."
	self == aModule ifTrue: [^ true].
	self ambient = aModule ifTrue: [^ true].
	self ambient = aModule ambient ifFalse: [^ false].
	^ self generators allSatisfy: [:each| aModule contains: each]! !

!Module methodsFor: 'comparing' stamp: 'len 1/9/2022 09:50:13'!
= anObject
	self == anObject ifTrue: [^ true].
	(anObject isKindOf: Module) ifFalse: [^ false].
	self ambient = anObject ambient ifFalse: [^ false].
	self scalars hasEchelonization ifTrue: [^ self generatorMatrix = anObject generatorMatrix].
"	self scalars hasCanonicalBases ifTrue: [^ self basis = anObject basis]."
	self generators = anObject generators ifTrue: [^ true].
	self flag: #fix. "reimplement, see Module>>#span:"
	^ (self generators allSatisfy: [:each| anObject contains: each])
		and: [anObject generators allSatisfy: [:each| self contains: each]]! !

!Module methodsFor: 'comparing' stamp: 'len 12/17/2021 15:45:28'!
~ aModule
	"Answer true if the receiver is isomorphic to the argument."
	self = aModule ifTrue: [^ true].
	self scalars = aModule scalars ifFalse: [^ false].
	self presentationMatrix = aModule presentationMatrix ifTrue: [^ true].
	self scalars isPID ifTrue: [^ self invariants = aModule invariants].
	self notYetImplemented! !

!Module methodsFor: 'comparing' stamp: 'len 1/13/2018 22:42:28'!
hash
	^ self scalars hash! !

!Module methodsFor: 'converting' stamp: 'len 10/25/2020 08:16:00'!
asAbelianGroup
	self isAbelianGroup ifTrue: [^ self].
	^ self notYetImplemented "should implement for Z/m-modules."! !

!Module methodsFor: 'converting' stamp: 'len 4/1/2021 06:35:40'!
asAlgebraicVariety
	| R generators |
	R _ self scalars polynomialsIn: self ambient rank.
	generators _ R tuple: R generators.
	^ (R * (self annihilatorSpace basis asArray collect: [:each| (each asMatrix over: R) * generators at: 1])) variety! !

!Module methodsFor: 'converting' stamp: 'len 4/22/2020 17:56:50'!
asChainComplex
	^ ChainComplex differentials: {self null -> self. self -> self null}! !

!Module methodsFor: 'converting' stamp: 'len 10/26/2020 12:08:11'!
asCochainComplex
	^ self asChainComplex dual! !

!Module methodsFor: 'converting' stamp: 'len 10/19/2020 13:28:39'!
asElementaryAbelianGroup
	(self scalars isKindOf: PrimeField) ifFalse: [^ DomainError signal].
	^ self asAbelianGroup! !

!Module methodsFor: 'converting' stamp: 'len 10/25/2020 10:28:29'!
asFPGroup
	| F relators answer |
	self isAbelianGroup ifFalse: [DomainError signal: 'not a Z-module'].
	F _ FreeGroup new: self invariants size.
	relators _ OrderedCollection new.
	self orders withIndexDo: [:k :i| k ~= 0 ifTrue: [relators add: (F x: i)^k]].
	1 to: F rank do: [:i| 1 to: F rank do: [:j| i ~= j ifTrue: [relators add: ((F x: i) commutator: (F x: j))]]].
	^ (answer _ F / relators)
		addMap: (self to: answer mapping: [:i| answer x: i]);
		addMap: (answer to: self mapping: [:i| self x: i]);
		yourself! !

!Module methodsFor: 'converting' stamp: 'len 10/20/2020 18:32:27'!
asPermutationGroup
	| answer |
	self isTorsion ifFalse: [self error: 'infinite abelian groups are not isomorphic to finite permutation groups'].
	answer _ SymmetricGroup new: 0.
	self invariants do: [:each| answer _ answer  (PermutationGroup cyclic: each)].
	"TODO: add isomorphisms"
	^ answer! !

!Module methodsFor: 'converting' stamp: 'len 12/18/2016 12:41:32'!
over: aRing
	"Answer the change of base ring of the receiver."
	self notYetImplemented! !

!Module methodsFor: 'copying' stamp: 'len 10/25/2020 10:12:56'!
copy
	"Answer an isomorphic copy of the receiver."
	^ self presentationMatrix cokernel! !

!Module methodsFor: 'elements' stamp: 'len 4/26/2021 11:35:47'!
\ anElement
	"Answer coordinates of anElement expressed as a linear combination of the elements of the distinguished generating set of the receiver. Answer nil if anElement is not in the receiver."
	anElement isZero ifTrue: [^ self coordinates zero].
	self isTrivial ifTrue: [^ nil].
	^ (self generatorMatrix lift: (self ambient \ anElement) asMatrix modulo: self ambient presentationMatrix) ifNotNil: [:answer| answer asTuple]

"
	^ self matrix transposed \ (self ambient coordinatesOf: anElement)
alternative 1:
	answer _ self matrix leftInverse * (ambient coordinatesOf: anElement).
	^ answer isZero ifFalse: [answer]"
"alternative 2:
	m _ self matrix rowAugmented: (ambient coordinatesOf: anElement).
	reducer _ m transposed reducer.
	coords _ reducer reduced lastColumn.
	^ reducer rank > self size
		ifFalse:
			[answer _ self coordinates zero copy.
			reducer pivots do: [:each| answer at: each x put: (coords at: each y)].
			answer]"! !

!Module methodsFor: 'elements' stamp: 'len 5/28/2020 17:46:59'!
elementAt: anArray
	(self isTrivial or: [anArray isEmpty]) ifTrue: [^ self zero].
	^ (1 to: anArray size) sum: [:i| (self x: i) * (anArray at: i)]! !

!Module methodsFor: 'elements' stamp: 'len 4/9/2020 07:21:20'!
newFrom: anObject
	(anObject isSequenceable and: [anObject size = self generators size])
		ifTrue: [^ self elementAt: (self scalars tuple: anObject)].
	^ super newFrom: anObject! !

!Module methodsFor: 'elements-testing' stamp: 'len 1/25/2022 11:19:23'!
isZerodivisor: aScalar
	"Answer true if there exists a nonzero element that multiplied by the argument is zero.
	A Singular Introduction to Commutative Algebra, 2.8.5 Radical and Zerodivisors of Modules."
	^ (self endomorphisms evaluating: [:x| x*aScalar]) kernel isTrivial not

"slow alternative for finite rings:
	^ self anySatisfy: [:any| any isZero not and: [(any * aNumber) isZero]]
"! !

!Module methodsFor: 'enumerating' stamp: 'len 7/24/2020 06:36:26'!
do: aBlock
	| visited |
	self isTrivial ifTrue: [aBlock value: self zero. ^ self].
	visited _ Set new.
	self scalars tuples: self generators size do: [:each|
		| x |
		x _ self zero.
		each with: self generators do: [:ai :xi| x _ xi * ai + x].
		visited add: x ifAbsent: [aBlock value: x]]! !

!Module methodsFor: 'morphisms' stamp: 'len 12/23/2021 15:28:13'!
apply: aMorphism
	"Answer the homomorphic image of the receiver."
	aMorphism isBlock ifTrue: [^ self ambient span: (self generators collect: aMorphism)].
	aMorphism domain == self ifTrue: [^ aMorphism image].
"	aMorphism domain == self ambient ifTrue: [^ (self -> self ambient -> aMorphism) image]."
	^ aMorphism codomain ambient span: (self generators collect: aMorphism)! !

!Module methodsFor: 'morphisms' stamp: 'len 12/22/2021 14:59:25'!
from: aDomain
	aDomain isCartesianProduct
		ifTrue: [aDomain >- self ifNotNil: [:anArray| ^ aDomain to: self carrier evaluating: [:x| (1 to: anArray size) inject: self zero into: [:result :i| result + ((anArray at: i) value: (x at: i))]]]].
	^ super from: aDomain! !

!Module methodsFor: 'morphisms' stamp: 'len 12/25/2021 10:01:37'!
hom: aCodomain
	"Answer the module of homomorphisms from the receiver to aCodomain. This is the internal hom."
	aCodomain isModule ifFalse: [^ super hom: aCodomain].
	self scalars = aCodomain scalars ifFalse: [DomainError signal: 'scalars don''t match'].
	(self scalars isCommutative "or: [self scalars isInvolutive]") ifTrue: [^ HomModule from: self to: aCodomain].
	"TODO: if scalars are an R-algebra, answer an R-module"
	^ super hom: aCodomain! !

!Module methodsFor: 'morphisms' stamp: 'len 4/26/2021 11:57:03'!
id
	"Answer the identity morphism"
	^ self propertyAt: #id ifAbsentPut: [self to: self validMatrix: self coordinates id]! !

!Module methodsFor: 'morphisms' stamp: 'len 10/25/2020 10:15:19'!
orthogonalProjection
	"Answer an orthogonal projection onto the receiver (with respect to the standard inner product)."
	| F T |
	self isTrivial ifTrue: [^ self ambient endomorphisms zero].
	F _ self generatorMatrix.
	T _ F transpose.
	^ self ambient endomorphisms !! (F * (T * F) inverse * T)

"	F _ (self base -> self ambient) matrix.
	^ self ambient endomorphisms !! (F * F retraction)"

"	^ self propertyAt: #orthogonalProjection ifAbsentPut:
		[| F T |
		F _ self base -> self ambient.
		T _ F transposed.
		T -> F -> (F -> T) leftInverse -> T]
"
"	| answer A T |
	self propertyAt: #orthogonalProjection ifPresent: [:aLinearMap| ^ aLinearMap].
	self isTrivial ifTrue: [^ self ambient endomorphisms zero].
	A _ self matrix.
	T _ A transposed.
	answer _ self ambient endomorphisms !! (T * (A * T) inverse * A).
	self propertyAt: #orthogonalProjection put: answer.
	^ answer"! !

!Module methodsFor: 'morphisms' stamp: 'len 5/3/2021 10:58:17'!
projection
	"Answer a projection from the ambient onto the receiver.
	This is an idempotent endomorphism of the ambient that restricts to the identity on the receiver."
	| G A B |
	self scalars isReal ifTrue: [^ self orthogonalProjection].
	self isTrivial ifTrue: [^ self ambient endomorphisms zero].
	"Embedding:"
	G _ self generatorMatrix.
	"Extended to full rank:"
	A _ G columnExtended transpose.
	B _ G  (self scalars ^ (A width - G width) => G codomain) zero.
	^ self ambient endomorphisms !! (A \ B transpose) transpose
	
"alternatively:
	E _ G columnExtended.
	I _ self base id  (self scalars ^ (E width - F width)) endomorphisms zero.
	^ self ambient endomorphisms !! (E * I * E inverse)"! !

!Module methodsFor: 'morphisms' stamp: 'len 12/22/2021 14:59:11'!
to: aCodomain
	((aCodomain isModule or: [self isAbelianGroup and: [aCodomain isGroup]]) and: [self isTrivial or: [aCodomain isTrivial]])
		ifTrue: [^ self to: aCodomain evaluating: [:x| aCodomain identity]].
	^ super to: aCodomain! !

!Module methodsFor: 'morphisms' stamp: 'len 12/25/2021 11:10:59'!
to: aCodomain adapting: anObject
	(anObject isMatrix and: [anObject domain = self coordinates and: [anObject codomain = aCodomain coordinates]]) ifTrue: [^ self to: aCodomain matrix: anObject].
	^ super to: aCodomain adapting: anObject! !

!Module methodsFor: 'morphisms' stamp: 'len 4/26/2021 11:41:33'!
to: aCodomain evaluating: aBlock
	(aCodomain isModule and: [aCodomain scalars = self scalars])
		ifTrue: [^ self to: aCodomain matrix: (self coordinates to: aCodomain coordinates mapping: [:i| aCodomain \ (aCodomain !! (aBlock value: (self generators at: i)))])].
	(self isAbelianGroup and: [aCodomain isGroup])
		ifTrue: [^ GroupMap from: self to: aCodomain mapping: aBlock].
	^ DomainError signal! !

!Module methodsFor: 'morphisms' stamp: 'len 4/26/2021 11:41:52'!
to: aCodomain mapping: aBlock
	"Answer a morphism defined by images of generators.
	aBlock takes indices i and evaluates to the image of the i-th generator."
	(aCodomain isModule and: [aCodomain scalars = self scalars])
		ifTrue: [^ self to: aCodomain matrix: (self coordinates to: aCodomain coordinates mapping: [:i| aCodomain \ (aCodomain !! (aBlock value: i))])].
	(self isAbelianGroup and: [aCodomain isGroup])
		ifTrue: [^ GroupMap from: self to: aCodomain mapping: aBlock].
	^ DomainError signal! !

!Module methodsFor: 'morphisms' stamp: 'len 3/22/2021 11:32:44'!
to: aModule matrix: aMatrix
	^ self to: aModule matrix: aMatrix ifInvalid: [DomainError signal: 'invalid morphism']! !

!Module methodsFor: 'morphisms' stamp: 'len 4/6/2021 14:26:58'!
to: aModule matrix: aMatrix ifInvalid: exceptionBlock
	(aModule isModule and: [self scalars = aModule scalars]) ifFalse: [^ DomainError signal].
	"A matrix induces a valid module homomorphism iff it sends syzygies to syzygies:"
"	(self syzygies generators allSatisfy: [:each| (aModule elementAt: aMatrix * each) isZero]) ifFalse: [^ exceptionBlock value]."
	(aMatrix * self presentationMatrix) image <= aModule presentationMatrix image ifFalse: [^ exceptionBlock value].
	^ self to: aModule validMatrix: aMatrix! !

!Module methodsFor: 'morphisms' stamp: 'len 4/6/2021 14:27:23'!
to: aModule validMatrix: aMatrix
	^ ModuleMap from: self to: aModule matrix: aMatrix! !

!Module methodsFor: 'operations' stamp: 'len 3/5/2020 17:35:47'!
* anIdeal
	| newGenerators |
	"If it's not an ideal, it must be a scalar:"
	(anIdeal isKindOf: Ideal) ifFalse: [^ self * (self scalars * anIdeal)].
	anIdeal isZero ifTrue: [^ self null].
	anIdeal scalars = self scalars ifFalse: [^ DomainError signal: 'scalars don''t match'].
	self isVectorSpace ifTrue: [^ self].
	anIdeal isOne ifTrue: [^ self].
	"This is wrong, only works for finitely generated modules without relations:"
	newGenerators _ Set new.
	self generators do: [:a| anIdeal generators do: [:b| newGenerators add: a*b]].
	^ self ambient span: newGenerators! !

!Module methodsFor: 'operations' stamp: 'len 5/3/2021 10:58:03'!
+ aSubmodule
	(aSubmodule isModule and: [self ambient = aSubmodule ambient])
		ifFalse: [^ super + aSubmodule].
	self isTrivial ifTrue: [^ aSubmodule].
	aSubmodule isTrivial ifTrue: [^ self].
	^ self ambient span: self generatorMatrix  aSubmodule generatorMatrix! !

!Module methodsFor: 'operations' stamp: 'len 12/26/2021 11:18:45'!
/ aSubmodule
	"Answer the quotient of the receiver by aSubmodule,
	i.e. the module obtained by 'collapsing' the submodule to zero.
	Alternatively, if the argument is a scalar, scale down the receiver by it."
	(self scalars includes: aSubmodule) ifTrue: [^ self * aSubmodule inverse].
	aSubmodule isCollection ifTrue: [^ self / (self ambient span: aSubmodule)].
	self assert: (self ambient = aSubmodule ambient and: [self >= aSubmodule]).
	self isAmbient ifFalse: [^ self apply: self ambient -> (self ambient / aSubmodule)].
	aSubmodule isTrivial ifTrue: [^ self].
	aSubmodule = self ifTrue: [^ self null].
	(self isVectorSpace and: [self scalars isReal])
		ifTrue:
			"Return the complement equipped with orthogonal projection.
			This is not canonical unless we're in an inner product space:"
			[| p answer |
			answer _ aSubmodule complement.
			p _ answer orthogonalProjection.
			answer addMap: (self onto: answer evaluating: [:x| p value: x]).
			^ answer].
	^ QuotientModule relations: aSubmodule

	"Answer the subquotient module."
	"Given modules M1 and M2 (presented by matrices M1 and M2).
	The subquotient module (M1+M2)/M2, written shorthand as M1/M2, is computed like this:
	- compute a basis B of M2;
	- reduce M1 modulo B and get N;
	- the syzygy matrix S of M modulo N is the desired presentation.
	See GAP4 homalg SubfactorModule(M1,M2)."

"	| answer |
	(self scalars includes: aSubmodule) ifTrue: [^ self * aSubmodule inverse].
	aSubmodule isCollection ifTrue: [^ self / (self ambient span: aSubmodule)].
	(self ambient = aSubmodule ambient and: [self >= aSubmodule])
		ifFalse: [^ DomainError signal].
	self isAmbient ifFalse: [^ self apply: self ambient -> (self ambient / aSubmodule)].
	aSubmodule isTrivial ifTrue: [^ self].
	aSubmodule = self ifTrue: [^ self null].
""	^ (aSubmodule -> self) cokernel""
	^ (answer _ self coordinates / (aSubmodule generators collect: [:each| self coordinatesOf: each]))
""		addMap: self -> self base -> answer;""
		yourself
"

"	self isVectorSpace ifTrue:
		[| perp answer projection |
		perp _ aSubmodule complement.
		answer _ self scalars ^ (self rank - aSubmodule rank).
		projection _ self onto: answer evaluating: [:each| perp coordinatesOf: (aSubmodule reduce: each)].
		projection propertyAt: #section put: (answer into: self evaluating: [:each| perp elementAt: each]).
		answer addMap: projection.
		^ answer].
	self notYetImplemented"

"alternatively, could return an abstract vector space:
	self isVectorSpace
		ifTrue:
			[| complement p answer |
			complement _ aSubmodule complement.
			p _ complement orthogonalProjection.
			^ (answer _ self scalars ^ complement rank)
				addMap: (self onto: answer evaluating: [:x| complement coordinatesOf: (p value: x)]);
				yourself].
"! !

!Module methodsFor: 'operations' stamp: 'len 12/23/2021 15:41:27'!
/\ aSubmodule
	"Answer the intersection of the receiver and the argument."
	(aSubmodule isModule and: [self ambient = aSubmodule ambient])
		ifFalse: [^ super /\ aSubmodule].
	self isAmbient ifTrue: [^ aSubmodule].
	aSubmodule isAmbient ifTrue: [^ self].
	self isTrivial ifTrue: [^ self].
	aSubmodule isTrivial ifTrue: [^ aSubmodule].
	^ ((self -> self ambient /\ (aSubmodule -> self ambient) -< {self. aSubmodule}) first -> self ambient) image! !

!Module methodsFor: 'operations' stamp: 'len 8/14/2019 17:42:10'!
: aModuleOrIdeal
	"For the receiver N and the argument P two submodules of an R-module M, answer the colon quotient N : P defined as the ideal {a in R | aP is contained in N}.
	For the receiver N, a submodule of an R-module M, and the argument I, an ideal of R, answer the colon quotient N : I defined as the submodule {m in M | I * m is containted in N}."
	self notYetImplemented! !

!Module methodsFor: 'operations' stamp: 'len 1/7/2022 20:48:32'!
@ aPrimeIdeal
	"Answer the localization of the receiver at aPrimeIdeal."
	^ self over: self scalars @ aPrimeIdeal! !

!Module methodsFor: 'operations' stamp: 'len 3/5/2020 17:40:26'!
 aModule
	"Answer the categorical product, i.e. direct sum of the receiver and the argument."
	^ (aModule isModule and: [aModule scalars = self scalars])
		ifTrue: [self  aModule]
		ifFalse: [super  aModule]! !

!Module methodsFor: 'operations' stamp: 'len 7/19/2021 05:47:52'!
 aModule
	"Answer the direct sum of the receiver and the argument."
	| answer n |
	(aModule isModule and: [aModule scalars = self scalars]) ifFalse: [^ DomainError signal].
	answer _ (self isFreelyGenerated and: [aModule isFreelyGenerated])
		ifTrue: [self coordinates  aModule coordinates]
		ifFalse: [(self presentationMatrix  aModule presentationMatrix) cokernel].
	n _ self generators size.
	answer
		addCoprojections:
			{self into: answer mapping: [:i| answer generators at: i].
			aModule into: answer mapping: [:i| answer generators at: i+n]};
		addProjections:
			{answer onto: self mapping: [:i| i <= n ifTrue: [self generators at: i] ifFalse: [self zero]].
			answer onto: aModule mapping: [:i| i > n ifTrue: [aModule generators at: i-n] ifFalse: [aModule zero]]}.
	^ answer! !

!Module methodsFor: 'operations' stamp: 'len 1/25/2022 11:15:28'!
 aModule
	"Answer the tensor product of the receiver with the argument."
	| answer M N |
	self scalars = aModule scalars ifFalse: [self error: 'scalars don''t match'].
	self scalars isCommutative ifFalse: [^ self notYetImplemented].
"	(self isProjective and: [aModule isProjective]) ifTrue:"
	(self isFreelyGenerated and: [aModule isFreelyGenerated]) ifTrue:
		[answer _ aModule dual => self.
		answer addCoercionFrom: (self, aModule) evaluatingWithArguments: [:f :g| answer evaluating: [:h| f * (h value: g)]].
		^ answer].
	M _ self presentationMatrix.
	N _ aModule presentationMatrix.
	"TODO: add composition"
	^ (M  N codomain id  (M codomain id  N)) cokernel! !

!Module methodsFor: 'operations' stamp: 'len 5/3/2021 10:44:36'!
 aModule
	"The (finite) product in the category of R-modules is the direct sum."
	^ self  aModule! !

!Module methodsFor: 'operations' stamp: 'len 5/3/2021 10:44:12'!
 aModule
	"The coproduct in the category of R-modules is the direct sum."
	^ self  aModule! !

!Module methodsFor: 'operations' stamp: 'len 4/12/2021 14:32:35'!
annihilator
	"Answer the ideal of elements of the scalar ring that annihilate all the elements in the receiver.
	For an R-module M, Ann(M) is the kernel of the natural map R -> End(M), and can also be computed as the colon quotient {0} : M."
	self scalars isPID ifTrue:
		[self isFinite ifFalse: [^ self scalars asIdeal null].
		^ self scalars * (self invariants inject: self scalars one into: [:result :each| result lcm: each])].
	^ self null : self! !

!Module methodsFor: 'operations' stamp: 'len 10/26/2020 16:55:15'!
annihilatorSpace
	"Answer the space of all linear forms that are 0 at all vectors in the receiver.
	See also >>complement."
	^ (self -> self ambient) adjoint kernel! !

!Module methodsFor: 'operations' stamp: 'len 10/26/2020 16:52:32'!
complement
	"Answer the complement of the receiver in its ambient with respect to the standard inner product (i.e., the dot product). See also >>annihilatorSpace.
	This is the subspace of all vectors in the ambient that have dot product zero (are orthogonal to) all vectors in the receiver."
	^ (self -> self ambient) transpose kernel

"
if we're in a vector space over the reals or complex numbers, we can get an orthogonal basis:
	((self scalars isKindOf: RealField) or: [self scalars isKindOf: ComplexField])
		ifTrue: [^ self ambient span: (self matrix extended orthogonalized copyFromRow: self rank + 1 to: self degree)].

alternative 2:
	| k n |
	k _ self dimension.
	n _ self ambient dimension.
	^ (self basis extended orthogonalized copyFrom: k + 1 to: n) span

alternative 2':
	^ self orthogonalProjection kernel

alternative 3:?
	^ basis dual asArray inject: self space into: [:answer :each| answer intersection: each kernel]	

alternative 4:
	^ self ambient span: (self annihilator basis collect: [:f| f asVector])
"! !

!Module methodsFor: 'operations' stamp: 'len 7/17/2020 10:34:24'!
decomposition
	"Answer a list of idecomposable submodules whose direct sum is isomorphic to the receiver, together with projection maps."
	^ self notYetImplemented! !

!Module methodsFor: 'operations' stamp: 'len 4/8/2021 12:22:28'!
dual
	^ self => self scalars asIdeal! !

!Module methodsFor: 'operations' stamp: 'len 7/27/2021 08:28:24'!
eliminate: anIndeterminate
	"Answer the elimination submodule computed by eliminating anIndeterminate."
	^ self eliminateAll: {anIndeterminate}! !

!Module methodsFor: 'operations' stamp: 'len 7/27/2021 08:27:56'!
eliminateAllBut: anIndeterminate
	"Answer the submodule with only the given indeterminate."
	^ self eliminateAll: (self scalars indeterminates select: [:each| each ~= anIndeterminate])! !

!Module methodsFor: 'operations' stamp: 'len 12/23/2021 14:34:16'!
endomorphisms
	^ self scalars isCommutative ifTrue: [(self => self) asAlgebra] ifFalse: [self => self]! !

!Module methodsFor: 'operations' stamp: 'len 5/1/2021 11:27:42'!
exteriorAlgebra
	| T |
	T _ self tensorAlgebra.
	^ T / (T generators collect: [:each| each squared])! !

!Module methodsFor: 'operations' stamp: 'len 3/15/2020 16:57:32'!
grassmannian: r
	"Answer the set of r-dimensional subspaces of the receiver."
"	self isVectorSpace ifFalse: [DomainError signal: 'not a vector space']."
	self scalars isPID ifFalse: [^ DomainError signal: 'not a module over a PID'].
	self assert: (r <= self rank and: [r >= 0]).
	^ Grassmannian new: r over: self! !

!Module methodsFor: 'operations' stamp: 'len 1/13/2022 10:31:20'!
leadingSubmodule
	"Answer the initial submodule. This is the submodule of all leading terms of the receiver."
	| leadingTerms |
	leadingTerms _ OrderedCollection new.
	self basis do: [:each| | t | t _ each leadingTerm. (t \\ leadingTerms) isZero ifFalse: [leadingTerms add: t]].
	^ self ambient span: leadingTerms! !

!Module methodsFor: 'operations' stamp: 'len 8/5/2021 08:40:36'!
orderOf: anElement
	"Answer the order of the argument in the receiver, i.e. the minimum e such that x*e = 0."
	| h factors id e g1 |
	self isFinite ifFalse:
		[(self torsionFree !! anElement) isZero ifFalse: [^ Infinity positive].
		^ self torsion orderOf: self torsion !! anElement].
	"[Coh96] Algorithm 1.4.3 (Order of an Element):"
	h _ self size.
	factors _ self propertyAt: #orderFactorization ifAbsentPut: [h factorization].
	e _ h.
	id _ self identity.
	factors asSet do: [:p|
		e _ e / (p ^ (factors occurrencesOf: p)).
		g1 _ anElement * e.
		[g1 = id] whileFalse: [g1 _ g1 * p. e _ e * p]].
	^ e! !

!Module methodsFor: 'operations' stamp: 'len 3/6/2020 11:23:01'!
radical
	^ self /\ self complement! !

!Module methodsFor: 'operations' stamp: 'len 1/14/2022 12:44:03'!
reduce: anElement
	"Answer zero if anElement is in the receiver, and otherwise answer some representative of the coset 'anElement + self' (not necessarily a normal form).
	It is required that:
		(M reduce: x) = (M reduce: y) <=> x - y is in M, and
		x - (M reduce: x) is in M for all x, y in M."
	self isAmbient ifTrue: [^ self zero].
	self isTrivial ifTrue: [^ anElement].
	^ self ambient elementAt: (self generatorMatrix reduce: (self ambient \ anElement) asMatrix modulo: self ambient presentationMatrix) asTuple! !

!Module methodsFor: 'operations' stamp: 'len 1/7/2022 20:36:20'!
span: aCollectionOrMatrix
	"Answer the submodule spanned by the argument (either a Collection of elements or a generator matrix relative to the receiver's presentation)."
	| generators G |
	aCollectionOrMatrix isMatrix
		ifTrue:
			[self isAmbient ifFalse: [^ self ambient span: self generatorMatrix * aCollectionOrMatrix].
			G _ aCollectionOrMatrix copyWithoutZeroColumns]
		ifFalse:
			[self isAmbient ifFalse: [^ self ambient span: aCollectionOrMatrix].
			generators _ (aCollectionOrMatrix asArray collect: [:each| self !! each]) select: [:each| each isZero not].
			G _ Matrix to: self coordinates columns: (generators collect: [:each| self \ each])].
	self isFreelyGenerated ifFalse: [G _ (self presentationMatrix reduce: G) 	copyWithoutZeroColumns].
	self scalars hasEchelonization
		ifTrue: [G _ G coechelon copyWithoutZeroColumns].
"		ifFalse: [G _ Matrix to: self coordinates columns: (G columns collect: [:each| each normalized])]."
	G isIdentity ifTrue: [^ self]. "<- this is not enough, should check if it lifts the identity, also implement Module>>= like this"
	^ self species new ambient: self; generatorMatrix: G! !

!Module methodsFor: 'operations' stamp: 'len 4/13/2021 10:24:17'!
support
	"The support of an R-module M over a commutative ring R is the set of prime ideals p of R such that the localization of M at p is not the trivial module.
	By definition, the support is a subset of Spec(R)."
	^ (self scalars / self annihilator) spec

"This is not very useful, just works with small finite rings:
	^ self scalars spectrum reject: [:each| (self localizationAt: each) isTrivial]"! !

!Module methodsFor: 'operations' stamp: 'len 5/1/2021 11:25:16'!
symmetricAlgebra
	^ self propertyAt: #symmetricAlgebra ifAbsentPut: [self scalars polynomialsIn: (self coordinateNames ifNil: [self rank])]! !

!Module methodsFor: 'operations' stamp: 'len 5/1/2021 11:25:59'!
tensorAlgebra
	^ self propertyAt: #tensorAlgebra ifAbsentPut: [self scalars freeAlgebraIn: (self coordinateNames ifNil: [self rank])]! !

!Module methodsFor: 'operations' stamp: 'len 8/4/2020 14:25:07'!
transversal
	^ self complement generators! !

!Module methodsFor: 'random' stamp: 'len 7/26/2021 09:57:22'!
atRandom: aRandom
	^ self elementAt: (self coordinates atRandom: aRandom)! !

!Module methodsFor: 'random' stamp: 'len 7/26/2021 09:56:57'!
atRandom: aRandom bits: bitSize
	^ self elementAt: (self coordinates atRandom: aRandom bits: bitSize)! !

!Module methodsFor: 'testing' stamp: 'len 1/3/2022 20:58:43'!
contains: anElement
	self isAmbient ifTrue: [^ true].
	self isTrivial ifTrue: [^ anElement isZero].
	^ (self reduce: anElement) isZero! !

!Module methodsFor: 'testing' stamp: 'len 4/22/2020 06:11:40'!
includes: anObject
	self isAmbient ifTrue: [^ anObject parent = self].
	^ (self ambient includes: anObject) and: [self contains: anObject]! !

!Module methodsFor: 'testing' stamp: 'len 3/21/2021 15:14:23'!
isArtinian
	"A module is called Artinian if it satisfies the descending chain condition."
	(self isAmbient not and: [self ambient isArtinian]) ifTrue: [^ true].
	^ self scalars isArtinian "because the receiver is finitely generated"! !

!Module methodsFor: 'testing' stamp: 'len 4/21/2021 12:16:03'!
isCyclic
	self generators size = 1 ifTrue: [^ true].
	self isAbelianGroup ifTrue: [^ self invariants size <= 1].
	(self isFreelyGenerated or: [self scalars isPID]) ifTrue: [^ self rank = 1].
	^ self notYetImplemented! !

!Module methodsFor: 'testing' stamp: 'len 7/17/2020 10:34:42'!
isDecomposable
	^self decomposition size > 1! !

!Module methodsFor: 'testing' stamp: 'len 3/15/2020 16:55:43'!
isDual
	"Answer true if the receiver is the module of linear forms Hom(M,R) for an R-module M."
	^ false! !

!Module methodsFor: 'testing' stamp: 'len 10/20/2020 18:42:22'!
isElementaryAbelian
	"Answer true if the receiver is isomorphic to a direct sum of n copies of a cyclic group of prime order, i.e. isomorphic to (Z/pZ)^n for some prime p and natural number n."
	self notYetImplemented! !

!Module methodsFor: 'testing' stamp: 'len 4/27/2020 01:48:43'!
isFaithful
	"A module is called 'faithful' if its annihilator is trivial."
	^ self annihilator isTrivial! !

!Module methodsFor: 'testing' stamp: 'len 4/1/2021 10:07:58'!
isFinite
	self isAbelianGroup ifTrue: [^ (self invariants includes: 0) not].
	self isFreelyGenerated ifTrue: [^ self generators isEmpty or: [self scalars isFinite]].
	^ self notYetImplemented! !

!Module methodsFor: 'testing' stamp: 'len 4/1/2021 10:20:23'!
isFree
	"Answer true if the receiver is a free module."
	self isFreelyGenerated ifTrue: [^ true].
	self isAbelianGroup ifTrue: [^ false]. "not freely generated f.g. abelian group is not free"
	(self isAmbient not and: [self ambient isFree and: [self scalars isPID]]) ifTrue: [^ true].
	^ self notYetImplemented! !

!Module methodsFor: 'testing' stamp: 'len 12/30/2021 13:13:14'!
isFreelyGenerated
	"Answer true if the receiver is free on free generators."
"	self isTrivial ifTrue: [^ true]."
	(self isAmbient not and: [self ambient isFreelyGenerated and: [self scalars isPID]]) ifTrue: [^ true].
	^ self presentationMatrix isTrivial! !

!Module methodsFor: 'testing' stamp: 'len 3/6/2020 20:16:10'!
isFullRank
	^ self rank = self degree! !

!Module methodsFor: 'testing' stamp: 'len 1/14/2022 11:02:31'!
isHomogeneous
	^ self generators allSatisfy: [:each| each isHomogeneous]! !

!Module methodsFor: 'testing' stamp: 'len 1/23/2018 21:56:53'!
isLocal
	^ self scalars isLocal! !

!Module methodsFor: 'testing' stamp: 'len 10/20/2020 18:49:36'!
isMixed
	"An abelian group is mixed if it is nother a torsion group nor free."
	^ self isTorsion not and: [self isFree not]! !

!Module methodsFor: 'testing' stamp: 'len 7/26/2021 15:23:04'!
isMonomial
	"Answer true if the receiver is generated by monomials."
	^ self scalars scalars isField and: [self generators allSatisfy: [:each| each isMonomial]]! !

!Module methodsFor: 'testing' stamp: 'len 3/21/2021 16:56:55'!
isNoetherian
	"A module is called Noetherian if every submodule is finitely generated.
	This is equivalent to the module satisfying the ascending chain condition (every ascending chain of submodules is finite), and it is also equivalent to the condition that any set of submodules contains a maximal element."
	(self isAmbient not and: [self ambient isNoetherian]) ifTrue: [^ true].
	"A ring R is Noetherian if and only if every finitely generated R-module is a Noetherian module:"
	^ self scalars isNoetherian "because the receiver is finitely generated"! !

!Module methodsFor: 'testing' stamp: 'len 3/11/2020 18:57:48'!
isNonDegenerate
	^ self radical isTrivial! !

!Module methodsFor: 'testing' stamp: 'len 3/3/2021 12:10:44'!
isProjective
	"Answer true if the receiver is a projective module."
	self isFree ifTrue: [^ true]. "every free module is projective"
	self scalars isPID ifTrue: [^ false]. "Quillen-Suslin theorem: every projective module over a PID is free"
	self scalars isLocal ifTrue: [^ false]. "Kaplansky's theorem"
	self scalars isDedekindDomain ifTrue: [^ self isTorsionFree].
	^ self notYetImplemented! !

!Module methodsFor: 'testing' stamp: 'len 12/26/2021 11:12:23'!
isQuotient
	^ self isAmbient not and: [self ambient isQuotient]! !

!Module methodsFor: 'testing' stamp: 'len 7/18/2020 08:37:53'!
isSemisimple
	"A module over a (not necessarily commutative) unital ring is said to be 'semisimple' (or 'completely reducible') if it is the direct sum of simple (irreducible) submodules."
	(self isAmbient not and: [self ambient isSemisimple]) ifTrue: [^ true].
	self isVectorSpace ifTrue: [^ true].
	^ self isArtinian and: [self radical isTrivial] "because the receiver is finitely generated"! !

!Module methodsFor: 'testing' stamp: 'len 1/2/2022 10:12:50'!
isSimple
	"A module is 'simple' if it is nontrivial and has no nontrivial proper submodules. An abelian group is 'simple' if the only normal subgroups are the trivial group and itself."
	self isAbelianGroup ifTrue: [^ self isTorsion and: [self isCyclic and: [self size isPrime]]].
	^ self length = 1! !

!Module methodsFor: 'testing' stamp: 'len 10/20/2020 19:35:18'!
isTorsion
	"Answer true if the receiver is a torsion module.
	An abelian group is called 'torsion' or 'periodic' if every element has finite order."
	self isAbelianGroup ifTrue: [^ self invariants noneSatisfy: [:each| each = 0]].
	^ self torsion = self! !

!Module methodsFor: 'testing' stamp: 'len 1/2/2022 10:04:23'!
isTorsionFree
	"Answer true if the receiver is a torsion-free module.
	An abelian group is called 'torsion-free' if every nonzero element has infinite order."
	^ self torsion isTrivial! !

!Module methodsFor: 'testing' stamp: 'len 4/1/2021 12:49:40'!
isTrivial
	"Answer true if the receiver is the trivial submodule {0}."
	^ self generatorMatrix isZero
"	^ self propertyAt: #isTrivial ifAbsentPut: [(self ambient presentationMatrix \ self generatorMatrix) notNil]"! !

!Module methodsFor: 'testing-categories' stamp: 'len 4/26/2021 10:54:20'!
isAbelianGroup
	^ self scalars == ! !

!Module methodsFor: 'testing-categories' stamp: 'len 10/20/2020 18:37:14'!
isGroup
	^ self isAbelianGroup! !

!Module methodsFor: 'testing-categories' stamp: 'len 1/11/2018 18:43:33'!
isModule
	^ true! !

!Module methodsFor: 'testing-categories' stamp: 'len 3/5/2020 17:45:29'!
isVectorSpace
	^ self scalars isField or: [self isTrivial]! !

!Module methodsFor: 'private' stamp: 'len 10/26/2020 16:25:33'!
generatorMatrix: aMatrix
	self propertyAt: #generatorMatrix put: aMatrix! !

!Module methodsFor: 'private' stamp: 'len 5/2/2020 05:14:06'!
species
	^ Module! !

!Module class methodsFor: 'examples' stamp: 'len 5/23/2020 09:13:12'!
example1
	"The Z-module Z^3."
	^ ^3! !

!Module class methodsFor: 'examples' stamp: 'len 8/7/2020 20:53:56'!
example2Dual
	"The module Hom(Z^3, Z), i.e. the Z-module of linear forms in Z^3."
	^ (^3) dual! !

!Module class methodsFor: 'examples' stamp: 'len 5/23/2020 09:11:37'!
example3HomSpace
	"The vector space of linear maps from Q^3 to Q^2."
	^ ^3 => (^2)! !

!Module class methodsFor: 'examples' stamp: 'len 5/23/2020 09:13:12'!
example4Quotient
	"The quotient module Z^3 / <(1,2,3), (2,2,2)>."
	^ ^3 / {(1,2,3). (2,2,2)}! !

!Module class methodsFor: 'examples' stamp: 'len 5/23/2020 09:13:12'!
example5QuotientInvariants
	"Invariants of the Z-module Z^3 / <(1,2,3), (2,2,2)>."
	^ (^3 / {(1,2,3). (2,2,2)}) invariants! !

!FreeModule methodsFor: 'accessing' stamp: 'len 3/19/2020 19:03:02'!
ambient
	^ self! !

!FreeModule methodsFor: 'accessing' stamp: 'len 5/31/2020 10:52:37'!
arity
	^ rank! !

!FreeModule methodsFor: 'accessing' stamp: 'len 4/8/2021 12:20:37'!
at: anInteger
	(anInteger between: 1 and: rank) ifFalse: [^ self error: 'index out of range'].
	^ self scalars asIdeal! !

!FreeModule methodsFor: 'accessing' stamp: 'len 8/7/2020 21:17:31'!
basis
	^ self generators! !

!FreeModule methodsFor: 'accessing' stamp: 'len 4/8/2021 12:20:46'!
components
	^ self propertyAt: #components ifAbsentPut: [(Array new: rank) atAllPut: self scalars asIdeal]! !

!FreeModule methodsFor: 'accessing' stamp: 'len 12/28/2016 12:07:59'!
coordinateNames
	^ self propertyAt: #coordinateNames ifAbsent: []! !

!FreeModule methodsFor: 'accessing' stamp: 'len 8/13/2019 17:46:02'!
coordinateRing
	"The coordinate ring of a free R-module of rank n (or K-vector space of dimension n) is the polynomial ring R[x1..xn] (or K[x1..xn])."
	^ self propertyAt: #coordinateRing ifAbsentPut: [self scalars polynomialsIn: (self coordinateNames ifNil: [self rank])]! !

!FreeModule methodsFor: 'accessing' stamp: 'len 3/10/2021 17:47:41'!
coordinates
	^ self! !

!FreeModule methodsFor: 'accessing' stamp: 'len 10/25/2020 10:57:45'!
generatorMatrix
	^ self id! !

!FreeModule methodsFor: 'accessing' stamp: 'len 12/22/2021 14:13:13'!
generatorNamed: anObject
	"Answer the generator indexed or named by anObject."
	^ self generators at: ((self propertyAt: #nameToIndex) at: anObject)! !

!FreeModule methodsFor: 'accessing' stamp: 'len 5/28/2020 17:54:03'!
generators
	^ self propertyAt: #generators ifAbsentPut:
		[(1 to: rank) collect: [:i| self elementAt: ((1 to: rank) collect: [:j| i=j ifTrue: [scalars one] ifFalse: [scalars zero]])]]! !

!FreeModule methodsFor: 'accessing' stamp: 'len 4/26/2021 11:40:06'!
innerProduct
	"Answer the bilinear form defining the Euclidean inner product."
	^ self propertyAt: #innerProduct ifAbsentPut:
		[BilinearForm
			on: self
			evaluatingWithArguments: [:x :y| (self \ x)  (self \ y)]]! !

!FreeModule methodsFor: 'accessing' stamp: 'len 7/24/2020 08:51:53'!
keys
	"The tuple module R^n is indexed by integers 1 to n."
	^ 1 to: rank! !

!FreeModule methodsFor: 'accessing' stamp: 'len 7/24/2020 16:03:33'!
names
	"Answer a list of symbolic names for the generators."
	^ self propertyAt: #names ifAbsent: [(1 to: rank) collect: [:i| 'e', i printString sub]]! !

!FreeModule methodsFor: 'accessing' stamp: 'len 12/22/2021 14:12:44'!
names: anArray
	"Set a list of symbolic names for the generators."
	self propertyAt: #names put: anArray.
	self propertyAt: #nameToIndex put: (Dictionary accumulate: [:aBlock| anArray withIndexDo: [:each :i| aBlock value: (Association key: each value: i)]])! !

!FreeModule methodsFor: 'accessing' stamp: 'len 10/12/2020 12:17:51'!
presentationMatrix
	^ self propertyAt: #presentationMatrix ifAbsentPut: [scalars^0 -> self]! !

!FreeModule methodsFor: 'accessing' stamp: 'len 3/3/2020 15:53:00'!
rank
	^ rank! !

!FreeModule methodsFor: 'accessing' stamp: 'len 3/1/2020 18:30:46'!
scalars
	^ scalars! !

!FreeModule methodsFor: 'accessing' stamp: 'len 5/28/2020 14:55:13'!
zero
	^ scalars tupleClass components: ((1 to: rank) collect: [:each| scalars zero]) parent: self! !

!FreeModule methodsFor: 'accessing-multivariate' stamp: 'len 7/28/2021 11:07:17'!
orderedBy: aTupleMonomialOrdering
	^ self class new: self rank over: self scalars ordering: aTupleMonomialOrdering! !

!FreeModule methodsFor: 'accessing-multivariate' stamp: 'len 7/27/2021 13:29:58'!
ordering
	"Answer the module monomial ordering of the receiver."
	^ self propertyAt: #ordering ifAbsentPut: [TupleMonomialOrdering top]! !

!FreeModule methodsFor: 'accessing-multivariate' stamp: 'len 7/28/2021 11:52:52'!
ordering: aTupleMonomialOrdering
	self propertyAt: #ordering put:
		(aTupleMonomialOrdering isSymbol
			ifTrue: [TupleMonomialOrdering perform: aTupleMonomialOrdering]
			ifFalse: [aTupleMonomialOrdering])! !

!FreeModule methodsFor: 'comparing' stamp: 'len 7/27/2021 11:37:50'!
= anObject
	^ self == anObject or: [self class = anObject class and: [scalars = anObject scalars and: [rank = anObject rank and: [scalars isMultivariate not or: [self ordering = anObject ordering]]]]]! !

!FreeModule methodsFor: 'converting' stamp: 'len 3/1/2017 08:53:02'!
asVectorSpace
	self scalars isField ifTrue: [^ self].
	self scalars isIntegralDomain ifTrue: [^ self over: self scalars fractions].
	^ DomainError signal: 'not over an integral domain'! !

!FreeModule methodsFor: 'converting' stamp: 'len 4/4/2021 07:55:25'!
lift
	^ self propertyAt: #lift ifAbsentPut: [self class new: rank over: scalars base]! !

!FreeModule methodsFor: 'converting' stamp: 'len 3/3/2020 16:03:58'!
over: aRing
	^ self class new: rank over: aRing! !

!FreeModule methodsFor: 'copying' stamp: 'len 4/15/2020 00:37:28'!
copy
	"Answer an isomorphic copy of the receiver."
	^ self scalars ^ self rank! !

!FreeModule methodsFor: 'copying' stamp: 'len 5/29/2020 08:58:37'!
copyFrom: start to: end
	^ self scalars ^ (end - start + 1)! !

!FreeModule methodsFor: 'elements' stamp: 'len 4/26/2021 11:36:37'!
\ anElement
	"Answer coordinates of anElement expressed as a linear combination of the elements of the distinguished generating set of the receiver. Answer nil if anElement is not in the receiver."
	^ anElement! !

!FreeModule methodsFor: 'elements' stamp: 'len 5/28/2020 17:52:20'!
adapt: anElement
	(rank = 1 and: [scalars includes: anElement])
		ifTrue: [^ self elementAt: {anElement}].
	^ super adapt: anElement! !

!FreeModule methodsFor: 'elements' stamp: 'len 7/26/2020 13:22:31'!
elementAt: anArray
	"Answer the element with the given coordinates."
	(anArray size = rank or: [rank isInfinite]) ifFalse: [^ super elementAt: anArray].
	(anArray isTuple and: [anArray parent == self]) ifTrue: [^ anArray].
	^ scalars tupleClass components: (anArray asArray collect: [:each| scalars !! each]) parent: self! !

!FreeModule methodsFor: 'elements' stamp: 'len 5/29/2020 07:44:45'!
filling: aBlock
	^ scalars tupleClass components: ((1 to: rank) collect: [:i| scalars !! (aBlock value: i)]) parent: self! !

!FreeModule methodsFor: 'elements' stamp: 'len 7/24/2020 12:05:01'!
newFrom: anObject
	(anObject isSequenceable and: [anObject size = rank])
		ifTrue: [^ self elementAt: anObject].
	anObject isBlock ifTrue: [^ self filling: anObject].
	^ super newFrom: anObject! !

!FreeModule methodsFor: 'elements' stamp: 'len 7/30/2021 09:16:59'!
x: anInteger monomial: aMonomial
	^ self filling: [:i| i = anInteger ifTrue: [scalars monomial: aMonomial] ifFalse: [scalars zero]]! !

!FreeModule methodsFor: 'enumerating' stamp: 'len 3/11/2020 16:56:12'!
do: aBlock
	scalars tuples: rank do: [:each| aBlock value: (self elementAt: each)]! !

!FreeModule methodsFor: 'initialization' stamp: 'len 3/1/2020 18:31:01'!
rank: n
	rank _ n! !

!FreeModule methodsFor: 'initialization' stamp: 'len 3/1/2020 18:31:06'!
scalars: aRing
	scalars _ aRing! !

!FreeModule methodsFor: 'morphisms' stamp: 'len 9/25/2018 17:14:33'!
automorphisms
	^ GeneralLinearGroup on: self! !

!FreeModule methodsFor: 'morphisms' stamp: 'len 4/8/2021 12:20:53'!
coprojection: anIntegerOrList
	anIntegerOrList isInteger
		ifTrue: [^ (self scalars asIdeal into: self mapping: [:i| self x: anIntegerOrList]) name: 'i', anIntegerOrList printString sub].
	^ self scalars ^ anIntegerOrList size into: self mapping: [:i| self x: (anIntegerOrList at: i)]! !

!FreeModule methodsFor: 'morphisms' stamp: 'len 10/28/2020 13:56:35'!
fromAll: anArray
	"Answer the canonical coprojections from the components of anArray to the receiver."
	| i |
	(anArray allSatisfy: [:each| each class = self class and: [each scalars = self scalars]]) ifFalse: [^ super fromAll: anArray].
	(anArray sum: [:each| each rank]) = rank ifFalse: [^ super fromAll: anArray].
	i _ 1.
	^ anArray collect: [:each| self coprojection: (i to: (i _ i + each rank)-1)]! !

!FreeModule methodsFor: 'morphisms' stamp: 'len 1/2/2022 18:11:04'!
id
	"Answer the identity morphism."
	^ self propertyAt: #id ifAbsentPut:
		[| one zero |
		one _ self scalars one.
		zero _ self scalars zero.
		self to: self filling: [:i :j| i=j ifTrue: [one] ifFalse: [zero]]]! !

!FreeModule methodsFor: 'morphisms' stamp: 'len 4/8/2021 12:21:01'!
projection: anIntegerOrList
	anIntegerOrList isInteger
		ifTrue: [^ (self onto: self scalars asIdeal evaluating: [:x| x at: anIntegerOrList]) name: '', anIntegerOrList printString sub].
	^ self onto: self scalars ^ anIntegerOrList size evaluating: [:x| anIntegerOrList collect: [:i| x at: i]]! !

!FreeModule methodsFor: 'morphisms' stamp: 'len 9/25/2018 17:17:02'!
rotations
	^ SpecialOrthogonalGroup on: self! !

!FreeModule methodsFor: 'morphisms' stamp: 'len 12/22/2021 14:55:32'!
to: aCodomain
	(aCodomain isDual and: [aCodomain domain = self])
		ifTrue: [^ self to: aCodomain evaluating: [:x| aCodomain evaluating: [:y| self innerProduct value: x value: y]]].
	^ super to: aCodomain! !

!FreeModule methodsFor: 'morphisms' stamp: 'len 5/31/2020 20:06:58'!
to: aModule filling: aBlock
	(aModule class = self class and: [aModule scalars = self scalars]) ifFalse: [^ DomainError signal].
	^ Matrix from: self to: aModule filling: aBlock! !

!FreeModule methodsFor: 'morphisms' stamp: 'len 12/25/2021 11:02:06'!
to: aModule mapping: aBlock
	"Answer a morphism defined by images of generators.
	aBlock takes indices i and evaluates to the image of the i-th generator."
	((aModule isKindOf: FreeModule) and: [aModule scalars = self scalars])
		ifFalse: [^ super to: aModule mapping: aBlock].
	^ Matrix from: self to: aModule columns: ((1 to: self generators size) collect: [:i| aModule \ (aModule !! (aBlock value: i))])! !

!FreeModule methodsFor: 'morphisms' stamp: 'len 5/31/2020 11:33:58'!
to: aModule matrix: aMatrix
	(aModule class = self class and: [self scalars = aModule scalars]) ifTrue: [^ Matrix from: self to: aModule rows: aMatrix rows].
	^ super to: aModule matrix: aMatrix! !

!FreeModule methodsFor: 'morphisms' stamp: 'len 4/6/2021 14:45:23'!
to: aModule matrix: aMatrix ifInvalid: exceptionBlock
	(aModule class = self class and: [self scalars = aModule scalars]) ifTrue: [^ Matrix from: self to: aModule rows: aMatrix rows].
	^ super to: aModule matrix: aMatrix ifInvalid: exceptionBlock! !

!FreeModule methodsFor: 'morphisms' stamp: 'len 4/6/2021 14:28:50'!
to: aModule validMatrix: aMatrix
	(aModule class = self class and: [self scalars = aModule scalars]) ifTrue: [^ Matrix from: self to: aModule rows: aMatrix rows].
	^ super to: aModule validMatrix: aMatrix! !

!FreeModule methodsFor: 'morphisms' stamp: 'len 10/28/2020 12:14:05'!
toAll: anArray
	"Answer the canonical projections from the receiver to the components of anArray."
	| i |
	(anArray allSatisfy: [:each| each class = self class and: [each scalars = self scalars]]) ifFalse: [^ super toAll: anArray].
	(anArray sum: [:each| each rank]) = rank ifFalse: [^ super toAll: anArray].
	i _ 1.
	^ anArray collect: [:each| self projection: (i to: (i _ i + each rank)-1)]! !

!FreeModule methodsFor: 'operations' stamp: 'len 10/28/2020 13:32:25'!
 aModule
	"Answer the direct sum of the receiver and the argument."
	(aModule isKindOf: FreeModule) ifFalse: [^ super  aModule].
	scalars = aModule scalars ifFalse: [DomainError signal: 'scalars don''t match'].
	^ scalars ^ (rank + aModule rank)! !

!FreeModule methodsFor: 'operations' stamp: 'len 12/24/2021 08:27:08'!
hom: aCodomain
	"Answer the module of homomorphisms from the receiver to aCodomain. This is the internal hom."
	(aCodomain isKindOf: FreeModule) ifFalse: [^ super hom: aCodomain].
	scalars = aCodomain scalars ifFalse: [DomainError signal: 'scalars don''t match'].
	^ MatrixModule from: self to: aCodomain! !

!FreeModule methodsFor: 'random' stamp: 'len 5/28/2020 17:55:29'!
atRandom: aRandom
	self isTrivial ifTrue: [^ self zero].
	^ self elementAt: ((1 to: rank) collect: [:i| scalars atRandom: aRandom])! !

!FreeModule methodsFor: 'random' stamp: 'len 7/26/2021 09:54:06'!
atRandom: aRandom bits: bitSize
	| n k |
	self isTrivial ifTrue: [^ self zero].
	n _ rank isFinite ifTrue: [rank] ifFalse: [bitSize truncated atRandom: aRandom].
	k _ bitSize / n.
	^ self elementAt: ((1 to: n) collect: [:i| scalars atRandom: aRandom bits: k])! !

!FreeModule methodsFor: 'testing' stamp: 'len 8/3/2020 06:39:56'!
includes: anObject
	^ anObject parent = self! !

!FreeModule methodsFor: 'testing' stamp: 'len 5/31/2020 10:40:45'!
isCoproduct
	^ true! !

!FreeModule methodsFor: 'testing' stamp: 'len 3/16/2021 16:22:58'!
isFreelyGenerated
	"Answer true if the receiver is free on free generators."
	^ true! !

!FreeModule methodsFor: 'testing' stamp: 'len 5/31/2020 10:40:37'!
isProduct
	^ true! !

!FreeModule methodsFor: 'testing' stamp: 'len 3/7/2020 18:07:16'!
isTrivial
	^ rank = 0 or: [scalars isTrivial]! !

!FreeModule methodsFor: 'testing' stamp: 'len 12/18/2016 11:13:59'!
torsion
	^ self null! !

!FreeModule class methodsFor: 'instance creation' stamp: 'len 7/26/2020 13:11:35'!
new: anIntegerOrCollection over: aRing
	^ (anIntegerOrCollection isInteger or: [anIntegerOrCollection = Infinity positive])
		ifTrue: [self new rank: anIntegerOrCollection; scalars: aRing]
		ifFalse: [self new rank: anIntegerOrCollection size; names: anIntegerOrCollection asArray; scalars: aRing]! !

!FreeModule class methodsFor: 'instance creation' stamp: 'len 5/18/2020 19:12:01'!
new: anIntegerOrCollection over: aRing ordering: aModuleMonomialOrdering
	^ (self new: anIntegerOrCollection over: aRing) ordering: aModuleMonomialOrdering! !

!HomModule methodsFor: 'accessing' stamp: 'len 3/4/2020 18:44:10'!
ambient
	^ self! !

!HomModule methodsFor: 'accessing' stamp: 'len 12/24/2021 08:14:34'!
carrier
	^ self propertyAt: #carrier ifAbsentPut: [HomSet from: domain to: codomain]! !

!HomModule methodsFor: 'accessing' stamp: 'len 10/2/2018 01:15:09'!
codomain
	^ codomain! !

!HomModule methodsFor: 'accessing' stamp: 'len 10/2/2018 01:15:31'!
domain
	^ domain! !

!HomModule methodsFor: 'accessing' stamp: 'len 3/13/2021 08:47:33'!
generatorMatrix
	^ self presentationMatrix codomain id! !

!HomModule methodsFor: 'accessing' stamp: 'len 7/17/2021 12:30:21'!
generators
	self propertyAt: #generators ifPresent: [:anArray| ^ anArray].
	self computePresentationAndGenerators.
	^ self propertyAt: #generators! !

!HomModule methodsFor: 'accessing' stamp: 'len 7/17/2021 12:29:46'!
presentationMatrix
	self propertyAt: #presentationMatrix ifPresent: [:aMatrix| ^ aMatrix].
	self computePresentationAndGenerators.
	^ self propertyAt: #presentationMatrix! !

!HomModule methodsFor: 'accessing' stamp: 'len 4/1/2021 10:05:43'!
rank
	self isFreelyGenerated ifTrue: [^ self domain rank * self codomain rank].
	^ self notYetImplemented! !

!HomModule methodsFor: 'accessing' stamp: 'len 12/25/2021 08:42:07'!
scalars
	self flag: #fix. "not correct over noncommutative rings"
	^ domain scalars! !

!HomModule methodsFor: 'accessing' stamp: 'len 3/6/2020 21:05:29'!
zero
	^ self evaluating: [:x| codomain zero]! !

!HomModule methodsFor: 'comparing' stamp: 'len 8/14/2020 17:06:01'!
= anObject
	^ self == anObject or: [self class = anObject class and: [domain = anObject domain and: [codomain = anObject codomain]]]! !

!HomModule methodsFor: 'converting' stamp: 'len 7/18/2021 13:16:43'!
asAlgebra
	self isEndomorphisms ifFalse: [^ DomainError signal: 'not an endomorphism module'].
	^ EndomorphismAlgebra on: self! !

!HomModule methodsFor: 'converting' stamp: 'len 4/4/2021 07:56:15'!
over: aRing
	"Answer the change of base ring of the receiver."
	^ self class from: (domain over: aRing) to: (codomain over: aRing)! !

!HomModule methodsFor: 'elements' stamp: 'len 4/26/2021 11:36:51'!
\ anElement
	"Answer coordinates of anElement expressed as a linear combination of the elements of the distinguished generating set of the receiver. Answer nil if anElement is not in the receiver."
	self isTrivial ifTrue: [^ anElement isZero ifTrue: [self coordinates zero]].
	^ anElement asMatrix asTuple! !

!HomModule methodsFor: 'elements' stamp: 'len 4/26/2021 11:40:23'!
adapt: anElement
	(self scalars includes: anElement) ifTrue: [^ self scalar: anElement].
	anElement isInteger ifTrue: [^ self scalar: self scalars !! anElement].
	(self isDual and: [anElement isKindOf: Polynomial]) ifTrue: [^ self evaluating: [:x| anElement value: (self domain \ x)]].
	^ super adapt: anElement! !

!HomModule methodsFor: 'elements' stamp: 'len 6/1/2020 11:54:45'!
diagonal: anArray
	^ domain to: codomain mapping: [:i| (codomain x: i) * (anArray at: i)]! !

!HomModule methodsFor: 'elements' stamp: 'len 10/2/2018 01:17:40'!
evaluating: aBlock
	^ domain to: codomain evaluating: aBlock! !

!HomModule methodsFor: 'elements' stamp: 'len 4/25/2019 16:18:38'!
evaluatingWithArguments: aBlock
	^ domain to: codomain evaluatingWithArguments: aBlock! !

!HomModule methodsFor: 'elements' stamp: 'len 7/22/2020 07:43:48'!
mapping: aBlock
	^ domain to: codomain mapping: aBlock! !

!HomModule methodsFor: 'elements' stamp: 'len 3/3/2020 16:39:37'!
matrix: aMatrix
	^ domain to: codomain matrix: aMatrix! !

!HomModule methodsFor: 'elements' stamp: 'len 4/9/2020 07:21:00'!
newFrom: anObject
	anObject isMatrix ifTrue: [^ self matrix: anObject].
	anObject isEvaluable ifTrue: [^ self evaluating: anObject].
	^ super newFrom: anObject! !

!HomModule methodsFor: 'elements' stamp: 'len 10/2/2018 01:18:14'!
scalar: aNumber
	^ self evaluating: [:x| x * aNumber]! !

!HomModule methodsFor: 'morphisms' stamp: 'len 12/22/2021 14:57:57'!
from: aDomain
	self isEndomorphisms ifTrue:
		[aDomain = self scalars asIdeal ifTrue: [^ self addMap: (aDomain to: self evaluating: [:x| self scalar: x])]. "inclusion of scalars"
		"aDomain -> self scalars asIdeal ifNotNil: [:aMorphism| ^ aMorphism -> self]"].
	(self isDual and: [self domain isDual and: [self domain domain == aDomain]])
		ifTrue: [^ self addMap: (aDomain to: self mapping: [:i| self x: i])].
	^ super from: aDomain! !

!HomModule methodsFor: 'morphisms' stamp: 'len 12/23/2021 19:01:46'!
to: aCodomain
	self isEndomorphisms ifTrue:
		[aCodomain = self scalars asIdeal ifTrue: [^ self addMap: (self to: aCodomain evaluating: [:f| f trace])].
		"self scalars asIdeal -> aCodomain ifNotNil: [:aMorphism| ^ self -> aMorphism]"].
	(self isDual and: [self domain isDual and: [self domain domain = aCodomain]])
		ifTrue: [^ self addMap: (self to: aCodomain mapping: [:i| self domain domain x: i])].
	^ super to: aCodomain! !

!HomModule methodsFor: 'operations' stamp: 'len 12/26/2021 11:08:22'!
 aModule
	| answer |
	self scalars isCommutative ifFalse: [^ super  aModule].
	((aModule isKindOf: HomModule) and: [aModule scalars = self scalars and: [self isFreelyGenerated and: [aModule isFreelyGenerated]]]) ifFalse: [^ super  aModule].
	answer _ self domain  aModule domain => (self codomain  aModule codomain).
	answer addCoercionFrom: (self, aModule) evaluatingWithArguments: [:f :g| f  g].
	^ answer! !

!HomModule methodsFor: 'testing' stamp: 'len 3/6/2020 21:04:55'!
includes: anObject
	^ (anObject isKindOf: ModuleMap) and: [anObject domain = domain and: [anObject codomain = codomain]]! !

!HomModule methodsFor: 'testing' stamp: 'len 4/8/2021 12:49:26'!
isDual
	"Answer true if the receiver is the module of linear forms Hom(M,R) for an R-module M."
	^ codomain = self scalars asIdeal! !

!HomModule methodsFor: 'testing' stamp: 'len 10/2/2018 01:20:27'!
isEndomorphisms
	^ domain = codomain! !

!HomModule methodsFor: 'testing' stamp: 'len 7/26/2021 10:44:09'!
isFreelyGenerated
	"Answer true if the receiver is free on free generators."
	^ (domain isFreelyGenerated and: [codomain isFreelyGenerated]) or: [super isFreelyGenerated]! !

!HomModule methodsFor: 'testing' stamp: 'len 7/25/2021 12:41:17'!
isTrivial
	"Answer true if the receiver is the trivial submodule {0}."
	^ domain isTrivial or: [codomain isTrivial or: [super isTrivial]]! !

!HomModule methodsFor: 'private' stamp: 'len 10/2/2018 01:16:42'!
codomain: aModule
	codomain _ aModule! !

!HomModule methodsFor: 'private' stamp: 'len 7/17/2021 13:18:33'!
computeFreeGenerators
	self propertyAt: #generators put: ((domain coordinates => codomain coordinates) generators collect: [:each| domain to: codomain matrix: each])! !

!HomModule methodsFor: 'private' stamp: 'len 7/17/2021 13:12:31'!
computeGeneratorsFromMatrixCoordinates: anArray
	| H |
	H _ domain coordinates => codomain coordinates.
	self propertyAt: #generators ifAbsentPut: [(anArray collect: [:x| domain to: codomain matrix: (H elementAt: x)])]! !

!HomModule methodsFor: 'private' stamp: 'len 7/17/2021 13:18:14'!
computePresentationAndGenerators
	"From 'A Singular Introduction to Commutative Algebra', pag 124, example 2.1.26 (computation of Hom)."
	| M N B C D E F |
	(self domain isFreelyGenerated and: [self codomain isFreelyGenerated])
		ifTrue:
			[self computeFreeGenerators.
			self propertyAt: #presentationMatrix put: self scalars^0 -> (self scalars^(self domain rank * self codomain rank)).
			^ self].
	M _ self domain presentationMatrix.
	N _ self codomain presentationMatrix.
	C _ (M codomain => N) asMatrix.
	self domain isFreelyGenerated
		ifTrue:
			[self computeFreeGenerators.
			self propertyAt: #presentationMatrix put: C syzygies.
			^ self].
	B _ (M domain => N) asMatrix.
	F _ (M => N codomain) asMatrix.
	D _ F syzygiesModulo: B.
	self computeGeneratorsFromMatrixCoordinates: D columns.
	E _ D syzygiesModulo: C.
	self propertyAt: #presentationMatrix put: E! !

!HomModule methodsFor: 'private' stamp: 'len 10/2/2018 01:16:14'!
domain: aModule
	domain _ aModule! !

!HomModule class methodsFor: 'instance creation' stamp: 'len 10/2/2018 01:14:35'!
from: aModule to: anotherModule
	^ self new
		domain: aModule;
		codomain: anotherModule! !

!MatrixModule methodsFor: 'accessing' stamp: 'len 12/25/2021 08:50:22'!
generators
	^ self propertyAt: #generators ifAbsentPut:
		[| n m B one zero |
		n _ codomain rank.
		m _ domain rank.
		B _ OrderedCollection new: n*m.
		one _ domain scalars one.
		zero _ domain scalars zero.
		1 to: n do: [:i0|
			1 to: m do: [:j0|
				B add: (self filling: [:i :j| (i=i0 and: [j=j0]) ifTrue: [one] ifFalse: [zero]])]].
		B asArray]! !

!MatrixModule methodsFor: 'accessing' stamp: 'len 7/16/2020 09:43:34'!
height
	^ self codomain rank! !

!MatrixModule methodsFor: 'accessing' stamp: 'len 7/24/2020 08:10:15'!
names
	"Answer a list of symbolic names for the generators."
	^ self propertyAt: #names ifAbsentPut: [(1 to: self rank) collect: [:each| 'e', ((each - 1 // self width + 1) printString, ',', (each - 1 \\ self width + 1) printString) sub]]! !

!MatrixModule methodsFor: 'accessing' stamp: 'len 3/10/2021 16:51:04'!
presentationMatrix
	^ self propertyAt: #presentationMatrix ifAbsentPut: [self scalars^0 -> (self scalars^(self domain rank * self codomain rank))]! !

!MatrixModule methodsFor: 'accessing' stamp: 'len 7/16/2020 09:43:28'!
width
	^ self domain rank! !

!MatrixModule methodsFor: 'converting' stamp: 'len 7/18/2021 13:17:07'!
asAlgebra
	self isEndomorphisms ifFalse: [^ DomainError signal: 'not a module of square matrices'].
	^ MatrixAlgebra on: self! !

!MatrixModule methodsFor: 'elements' stamp: 'len 7/22/2020 07:32:37'!
columns: anArray
	^ self filling: [:i :j| (anArray at: j) at: i]! !

!MatrixModule methodsFor: 'elements' stamp: 'len 7/16/2020 09:40:15'!
filling: aBlock
	^ domain to: codomain filling: aBlock! !

!MatrixModule methodsFor: 'elements' stamp: 'len 7/22/2020 07:32:48'!
rows: anArray
	^ self filling: [:i :j| (anArray at: i) at: j]! !

!MatrixModule methodsFor: 'random' stamp: 'len 12/25/2021 08:51:30'!
atRandom: aRandom
	| R |
	R _ self domain scalars.
	^ self filling: [:i :j| R atRandom: aRandom]! !

!MatrixModule methodsFor: 'random' stamp: 'len 12/25/2021 08:51:22'!
atRandom: aRandom bits: bitSize
	| R k |
	self isTrivial ifTrue: [^ self zero].
	R _ self domain scalars.
	k _ bitSize / self rank.
	^ self filling: [:i :j| R atRandom: aRandom bits: k]! !

!MatrixModule methodsFor: 'testing' stamp: 'len 3/11/2021 13:11:24'!
isTrivial
	"Answer true if the receiver is the trivial submodule {0}."
	^ domain isTrivial or: [codomain isTrivial]! !

!QuotientModule methodsFor: 'accessing' stamp: 'len 3/19/2020 20:30:28'!
ambient
	^ self! !

!QuotientModule methodsFor: 'accessing' stamp: 'len 3/19/2020 20:30:47'!
base
	^ self relations ambient! !

!QuotientModule methodsFor: 'accessing' stamp: 'len 10/26/2020 15:05:40'!
generatorMatrix
	^ self base generatorMatrix! !

!QuotientModule methodsFor: 'accessing' stamp: 'len 4/22/2020 21:22:31'!
generators
	^ self propertyAt: #generators ifAbsentPut: [self base generators collect: [:each| self project: each]]! !

!QuotientModule methodsFor: 'accessing' stamp: 'len 5/3/2021 10:58:39'!
presentationMatrix
	^ self base presentationMatrix  self relations generatorMatrix! !

!QuotientModule methodsFor: 'accessing' stamp: 'len 2/27/2017 21:31:05'!
relations
	^ self propertyAt: #relations! !

!QuotientModule methodsFor: 'accessing' stamp: 'len 1/9/2018 21:57:47'!
relators
	^ self relations generators! !

!QuotientModule methodsFor: 'accessing' stamp: 'len 2/27/2017 21:32:55'!
scalars
	^ self relations scalars! !

!QuotientModule methodsFor: 'accessing' stamp: 'len 3/18/2020 17:45:19'!
zero
	^ self representative: self base zero! !

!QuotientModule methodsFor: 'comparing' stamp: 'len 8/14/2020 17:05:34'!
= anObject
	^ self == anObject or: [self class = anObject class and: [self relations = anObject relations]]! !

!QuotientModule methodsFor: 'elements' stamp: 'len 4/26/2021 11:37:11'!
\ anElement
	"Answer coordinates of anElement expressed as a linear combination of the elements of the distinguished generating set of the receiver. Answer nil if anElement is not in the receiver."
	^ self base \ anElement representative! !

!QuotientModule methodsFor: 'elements' stamp: 'len 3/18/2020 17:42:46'!
representative: anElement
	"Answer the coset corresponding to the given representative (which is already reduced)."
	^ ModuleCoset new parent: self; representative: anElement! !

!QuotientModule methodsFor: 'morphisms' stamp: 'len 12/22/2021 15:06:55'!
from: aDomain
	aDomain = self base ifTrue: [^ self projection].
	aDomain -> self base ifNotNil: [:aMorphism| ^ aMorphism -> self].
	(aDomain class = self class and: [aDomain relations <= self relations])
		ifTrue: [^ aDomain to: self evaluating: [:x| self project: x representative]].
	^ super from: aDomain! !

!QuotientModule methodsFor: 'morphisms' stamp: 'len 3/18/2020 17:43:28'!
project: anElement
	^ self representative: (self relations reduce: anElement)! !

!QuotientModule methodsFor: 'morphisms' stamp: 'len 4/4/2021 10:06:46'!
projection
	"Answer the natural projection, or quotient map, or canonical homomorphism from the base module.
	This takes elements from the base module or vector space to the corresponding coset (an affine subspace) in the quotient."
	^ self propertyAt: #projection ifAbsentPut:
		[(self base onto: self evaluating: [:each| self project: each])
			name: '';
			propertyAt: #kernel put: self relations;
			propertyAt: #image put: self;
			"propertyAt: #section put: (self to: self base evaluating: [:each| each representative]);"
			yourself]! !

!QuotientModule methodsFor: 'operations' stamp: 'len 7/6/2021 09:13:58'!
/ aSubmodule
	(aSubmodule isKindOf: Module) ifFalse: [^ super / aSubmodule].
	self assert: self = aSubmodule ambient.
	^ self base / (self relations + (self base span: (aSubmodule generators collect: [:each| each representative])))! !

!QuotientModule methodsFor: 'testing' stamp: 'len 4/22/2020 06:12:03'!
includes: anObject
	^ anObject parent = self! !

!QuotientModule methodsFor: 'testing' stamp: 'len 5/20/2018 13:37:28'!
isNoetherian
	"A module is called Noetherian if every submodule is finitely generated."
	^ self base isNoetherian! !

!QuotientModule methodsFor: 'testing' stamp: 'len 12/25/2021 12:32:19'!
isQuotient
	^ true! !

!QuotientModule methodsFor: 'testing' stamp: 'len 7/18/2020 08:41:09'!
isSemisimple
	"A module over a (not necessarily commutative) unital ring is said to be 'semisimple' (or 'completely reducible') if it is the direct sum of simple (irreducible) submodules."
	^ self base isSemisimple or: [super isSemisimple]! !

!QuotientModule methodsFor: 'private' stamp: 'len 2/27/2017 21:31:18'!
relations: aSubmodule
	self propertyAt: #relations put: aSubmodule! !

!QuotientModule class methodsFor: 'instance creation' stamp: 'len 7/31/2019 08:22:19'!
relations: aSubmodule
	^ self new relations: aSubmodule! !

!Ideal methodsFor: 'printing' stamp: 'len 12/20/2021 17:49:33'!
printGeneratorsOn: aStream
	self isTrivial ifTrue: [aStream print: self zero. ^ self].
	(self generators asSortedCollection: [:a :b| a printString <= b printString])
		do: [:each| aStream print: each] separatedBy: [aStream nextPutAll: ', ']! !

!Ideal methodsFor: 'accessing' stamp: 'len 12/15/2021 15:17:28'!
generators
	^ self propertyAt: #generators ifAbsentPut: [self generatorMatrix asTuple asArray]! !

!Ideal methodsFor: 'accessing' stamp: 'len 12/22/2021 14:18:14'!
height
	"Answer the height (or codimension, or rank) of the receiver.
	This is the length of the longest ascending chain of prime ideals containing it.
	The height of a prime ideal is also the Krull dimension of the ring localization at that ideal."
	self isPrime ifFalse: [^ self notYetImplemented].
	^ (self scalars @ self) dimension! !

!Ideal methodsFor: 'accessing' stamp: 'len 12/25/2021 12:44:56'!
norm
	"Answer the ideal norm of the receiver, i.e. the order of the quotient ring."
	^ (self scalars / self) size! !

!Ideal methodsFor: 'accessing' stamp: 'len 8/3/2021 14:55:43'!
ordering
	^ self scalars ordering! !

!Ideal methodsFor: 'accessing' stamp: 'len 12/15/2021 15:14:04'!
presentationMatrix
	self isAmbient ifTrue: [^ self propertyAt: #presentationMatrix ifAbsentPut: [self scalars^0 -> self generatorMatrix domain]].
	^ super presentationMatrix! !

!Ideal methodsFor: 'accessing' stamp: 'len 4/4/2021 09:57:27'!
representative
	"If the receiver is an ideal I of a quotient ring A/J, return a lifting of I to A."
	^ self propertyAt: #representative ifAbsentPut: [self scalars base * (self generators collect: [:each| each representative]) + self scalars relations]! !

!Ideal methodsFor: 'comparing' stamp: 'len 12/15/2021 16:25:32'!
= anObject
	((anObject isKindOf: Ideal) and: [self scalars = anObject scalars]) ifFalse: [^ false].
	self isAmbient ifTrue: [^ anObject isOne].
	anObject isAmbient ifTrue: [^ self isOne].
	^ super = anObject! !

!Ideal methodsFor: 'converting' stamp: 'len 12/15/2021 14:41:58'!
asAlgebra
	self isOne ifFalse: [self error: 'not unit ideal'].
	^ self propertyAt: #asAlgebra ifAbsentPut: [Algebra multiplication: (BilinearMap from: self, self to: self evaluatingWithArguments: [:x :y| x*y])]! !

!Ideal methodsFor: 'converting' stamp: 'len 10/23/2016 21:09'!
asIdeal
	^ self! !

!Ideal methodsFor: 'converting' stamp: 'len 8/3/2021 14:48:38'!
orderedBy: aMonomialOrdering
	^ (self scalars orderedBy: aMonomialOrdering) !! self! !

!Ideal methodsFor: 'converting' stamp: 'len 8/12/2019 19:05:33'!
over: aRing
	^ self apply: (self scalars -> aRing ifNil: [^ self error: 'coercion failed'])! !

!Ideal methodsFor: 'copying' stamp: 'len 4/8/2021 12:25:11'!
copy
	"Answer a copy of the receiver."
	^ self class new generatorMatrix: self generatorMatrix copy! !

!Ideal methodsFor: 'elements' stamp: 'len 12/15/2021 15:20:13'!
\ anElement
	"Answer coordinates of anElement expressed as a linear combination of the elements of the distinguished generating set of the receiver. Answer nil if anElement is not in the receiver."
	self isAmbient ifTrue: [^ self coordinates elementAt: {anElement}].
	^ super \ anElement! !

!Ideal methodsFor: 'elements-operations' stamp: 'len 1/14/2022 12:47:20'!
reduce: anElement
	"Answer zero if anElement is in the receiver, and otherwise answer some representative of the coset 'anElement + self' (not necessarily a normal form).
	It is required that:
		(I reduce: x) = (I reduce: y) <=> x - y is in I, and
		x - (I reduce: x) is in I for all x, y in I.
	Subclasses should override."
	self isAmbient ifTrue: [^ self zero].
	self isTrivial ifTrue: [^ anElement].
"	self scalars isQuotient ifTrue: [^ self scalars project: (self representative reduce: anElement representative)]."
	self scalars isEuclidean ifTrue: [^ anElement \\ self generator].
	^ super reduce: anElement! !

!Ideal methodsFor: 'morphisms' stamp: 'len 12/15/2021 21:05:37'!
apply: aMorphism
	"Answer the homomorphic image of the receiver."
	aMorphism isBlock
		ifTrue: [^ self scalars * (self generators collect: aMorphism)].
	aMorphism domain = self scalars
		ifTrue: [^ aMorphism codomain * (self generators collect: aMorphism)].
	aMorphism domain = self ambient
		ifTrue: [^ aMorphism codomain span: (self generators collect: aMorphism)].
	^ super apply: aMorphism! !

!Ideal methodsFor: 'operations' stamp: 'len 4/26/2019 14:09:25'!
* anElementOrIdeal
	"The product is included in the intersection: I*J <= I /\ J.
	When the ideals are comaximal, the equality holds."
	^ super * anElementOrIdeal! !

!Ideal methodsFor: 'operations' stamp: 'len 1/7/2022 14:14:15'!
/\ anIdeal
	"Answer the intersection of the receiver and the argument."
	self isAmbient ifTrue: [^ anIdeal].
	anIdeal isAmbient ifTrue: [^ self].
	self scalars isEuclidean ifTrue: [^ self scalars * (self generator lcm: anIdeal generator)].
	^super /\ anIdeal! !

!Ideal methodsFor: 'operations' stamp: 'len 12/15/2021 16:15:30'!
: anIdeal
	"Answer the colon quotient I:J of the receiver I with the argument J.
	This is defined as I:J := {r in R | rJ <= I} and it is isomorphic to Hom(R/I, R/J)."
	self isAmbient ifTrue: [^ self].
	self scalars isQuotient ifTrue: [^ self representative : anIdeal representative apply: self scalars projection].
	^ super : anIdeal! !

!Ideal methodsFor: 'operations' stamp: 'len 3/6/2020 11:21:10'!
^ anInteger
	"Answer the receiver raised to the power anInteger."
	anInteger <= 0 ifTrue: [self error: 'exponent is not positive'].
	anInteger = 1 ifTrue: [^ self].
"	anInteger = 0 ifTrue: [^ self scalars oneIdeal].
	anInteger < 0 ifTrue: [^ (self ^ anInteger negated) reciprocal]."
	^ anInteger even ifTrue: [self squared ^ (anInteger // 2)] ifFalse: [self squared ^ (anInteger // 2) * self]! !

!Ideal methodsFor: 'operations' stamp: 'len 12/15/2021 14:35:31'!
adapt: anElement
	^ (super adapt: anElement) ifNil: [self scalars adapt: anElement]! !

!Ideal methodsFor: 'operations' stamp: 'len 4/12/2021 14:56:44'!
radical
	self scalars isQuotient ifTrue: [^ self representative radical apply: self scalars projection].
	^ self subclassResponsibility! !

!Ideal methodsFor: 'operations' stamp: 'len 2/14/2017 10:24:02'!
saturation
	"Answer the saturation ideal I:I^infinity of the receiver I."
	^ self saturation: self! !

!Ideal methodsFor: 'operations' stamp: 'len 7/10/2021 05:35:03'!
saturation: anIdeal
	"Answer the saturation ideal I:J^infinity of the receiver I with the argument J."
	^ self subclassResponsibility! !

!Ideal methodsFor: 'operations' stamp: 'len 1/7/2022 20:20:48'!
span: aCollection
"	| generators |
	self flag: #fix. ""not sure where to put this, it should happen automatically in Module>>span: by echelonization""
	aCollection isCollection ifFalse: [^ super span: aCollection].
	generators _ Set new: aCollection size.
	aCollection do: [:each| each isZero ifFalse: [generators add: each normalized]].
	(generators size > 1 and: [self scalars isEuclidean])
		ifTrue:
			[| generator |
			generators do: [:each| generator _ generator isNil ifTrue: [each] ifFalse: [generator gcd: each]].
			generators _ {generator}].
	(generators anySatisfy: [:any| any isUnit]) ifTrue: [^ self ambient]."
	^ super span: aCollection! !

!Ideal methodsFor: 'operations' stamp: 'len 6/6/2019 12:04:50'!
squared
	^ self * self! !

!Ideal methodsFor: 'operations' stamp: 'len 1/9/2022 08:33:09'!
squarefreePart
	^ self scalars * (self generators collect: [:each| each squarefreePart])! !

!Ideal methodsFor: 'testing' stamp: 'len 3/28/2018 19:49:45'!
| anIdeal
	"Answer true if the receiver divides anIdeal."
	^ self >= anIdeal! !

!Ideal methodsFor: 'testing' stamp: 'len 12/15/2021 20:55:08'!
contains: anElement
	^ self isAmbient or: [(self reduce: anElement) isZero]! !

!Ideal methodsFor: 'testing' stamp: 'len 12/15/2021 14:52:19'!
includes: anObject
	^ (self scalars includes: anObject) and: [self contains: anObject]! !

!Ideal methodsFor: 'testing' stamp: 'len 8/9/2019 12:08:37'!
isComaximalWith: anIdeal
	"Two ideals I and J in a commutative ring R are called coprime or comaximal when I + J = R."
	^ (self + anIdeal) isOne! !

!Ideal methodsFor: 'testing' stamp: 'len 1/6/2022 09:25:35'!
isFree
	"Answer true if the receiver is a free module.
	An ideal is a free module iff it is principal and generated by a non-zerodivisor."
	^ self isPrincipal and: [self generator isZerodivisor not]! !

!Ideal methodsFor: 'testing' stamp: 'len 5/5/2018 18:59:14'!
isIntegral
	"This is an integral ideal (not a fractional ideal)."
	^ true! !

!Ideal methodsFor: 'testing' stamp: 'len 1/12/2022 18:19:02'!
isMaximal
	"An ideal I of R is called 'maximal' if it is not contained in any other ideal but R itself.
	I is maximal iff the quotient ring R/I is a field.
	Every maximal ideal is prime, and in a PID every nonzero prime ideal is maximal."
	self scalars isQuotient ifTrue: [^ self representative isMaximal].
	self scalars isPID ifTrue:
		[self scalars isField ifTrue: [^ self isZero].
		^ self isZero not and: [self isPrime]].
	self scalars isArtinian ifTrue: [^ self isPrime].
	self isPrime ifFalse: [^ false].
	^ false "undefined"! !

!Ideal methodsFor: 'testing' stamp: 'len 7/5/2019 05:29:17'!
isMinimalPrime
	self scalars isIntegralDomain ifTrue: [^ self isZero].
	self scalars isArtinian ifTrue: [^ self isMaximal].
	self notYetImplemented! !

!Ideal methodsFor: 'testing' stamp: 'len 7/30/2019 05:29:37'!
isNilIdeal
	"An ideal is called nil-ideal if all its elements are nilpotent."
	^ self generators allSatisfy: [:each| each isNilpotent]! !

!Ideal methodsFor: 'testing' stamp: 'len 5/8/2020 15:30:19'!
isNilpotent
	"An ideal I is called nilpotent if there is an integer n >= 1 such that I^n = 0."
	self generators size = 1 ifTrue: [^ self generator isNilpotent].
	^ self notYetImplemented! !

!Ideal methodsFor: 'testing' stamp: 'len 8/3/2021 14:57:25'!
isOne
	"Answer true if the receiver is the unit ideal <1> (the whole ring)."
	^ self contains: self scalars one! !

!Ideal methodsFor: 'testing' stamp: 'len 1/12/2022 17:57:52'!
isPrime
	"An ideal I of R is prime iff R/I is an integral domain.
	Every maximal ideal is prime, and in a PID every nonzero prime ideal is maximal."
	"This method only works for zero ideals or ideals given by one generator; subclasses should reimplement."
	self scalars isQuotient ifTrue: [^ self representative isPrime].
	(self scalars isIntegralDomain and: [self isZero]) ifTrue: [^ true].
	(self scalars isUFD and: [self isPrincipal]) ifTrue: [^ self generator isIrreducible].
	self flag: #fix.
	^ false "undefined"! !

!Ideal methodsFor: 'testing' stamp: 'len 1/4/2022 08:52:45'!
isPrincipal
	"Answer true if the receiver is generated by a single element."
	self generators size <= 1 ifTrue: [^ true].
	self scalars isPIR ifTrue: [^ true].
	self scalars isQuotient ifTrue: [^ self representative isPrincipal].
	^ self propertyAt: #isPrincipal! !

!Ideal methodsFor: 'testing' stamp: 'len 1/16/2018 16:09:50'!
isProper
	^ self isZero not and: [self isOne not]! !

!Ideal methodsFor: 'testing' stamp: 'len 2/13/2017 08:38:58'!
isRadical
	^ self = self radical! !

!Ideal methodsFor: 'testing' stamp: 'len 2/14/2017 10:24:17'!
isSaturated
	^ self = self saturation! !

!Ideal methodsFor: 'testing' stamp: 'len 1/9/2022 08:34:02'!
isSquarefree
	^ self = self squarefreePart! !

!Ideal methodsFor: 'testing' stamp: 'len 6/4/2019 07:48:40'!
isZero
	"Answer true if the receiver is the zero ideal {0}."
	^ self isTrivial! !

!Ideal methodsFor: 'testing' stamp: 'len 7/10/2021 06:13:21'!
radicalContains: anElement
	"(Radical Membership Problem)
	Answer true if the radical of the receiver includes anElement."
	^ self radical contains: anElement! !

!Ideal methodsFor: 'private' stamp: 'len 7/15/2021 12:09:46'!
species
	^ self scalars idealClass! !

!Ideal class methodsFor: 'examples' stamp: 'len 5/23/2020 09:13:12'!
example1
	"Creating an ideal of Z:"
	^  * {12. 18. 60}! !

!Ideal class methodsFor: 'examples' stamp: 'len 5/23/2020 09:13:12'!
example2
	"Creating an ideal in Z/3Z[x,y,z]:"
	| R x y z |
	R _ /3 polynomialsIn: #(x y z).
	x _ R x.
	y _ R y.
	z _ R z.
	^ R * {x^2 + (y^2). x*y + (y^2) + (y*z). y^2 + (z^2) + z}! !

!RationalIntegerIdeal methodsFor: 'accessing' stamp: 'len 3/16/2021 16:16:20'!
height
	"Answer the height (or codimension, or rank) of the receiver.
	This is the length of the longest ascending chain of prime ideals containing it.
	The height of a prime ideal is also the Krull dimension of the ring localization at that ideal."
	^ self isTrivial ifTrue: [0] ifFalse: [1]! !

!RationalIntegerIdeal methodsFor: 'operations' stamp: 'len 5/4/2018 23:46:45'!
radical
	^ self scalars * self generator radical! !

!RationalIntegerIdeal methodsFor: 'testing' stamp: 'len 8/5/2021 08:40:01'!
isPrimary
	"An ideal I of a commutative ring is called 'primary' if for all x*y in I, x or y^n (n>0) is also in I."
	^ self propertyAt: #isPrimary ifAbsentPut: [self isZero or: [self generator factorization asSet size = 1]]! !

!RationalIntegerIdeal methodsFor: 'testing' stamp: 'len 1/9/2022 08:32:40'!
isSemiprime
	"An ideal I of a commutative ring is called 'semiprime' if for all x^k (k>0) in I, also x is in I.
	Equivalently, for all y not in I, y^k (k>0) is also not in I."
	^ self propertyAt: #isSemiprime ifAbsentPut: [self isZero or: [self generator isSquarefree]]! !

!PolynomialIdeal methodsFor: 'accessing' stamp: 'len 1/13/2022 10:31:49'!
degree
	"Answer the degree of the ideal, i.e. the number of monomials that are not multiple of any leading monomial in the Groebner basis."
	| G count leadingMonomials |
	leadingMonomials _ Set new.
	G _ self basis "minimal".
	G do: [:each| leadingMonomials add: each leadingMonomial].
	count _ 0.
	G do: [:each|
		each monomialsDo: [:monomial|
			(leadingMonomials noneSatisfy: [:lm| lm | monomial])
					ifTrue: [count _ count + 1]]].
	^ count! !

!PolynomialIdeal methodsFor: 'accessing' stamp: 'len 1/13/2022 10:31:58'!
generator
	| G |
	self isTrivial ifTrue: [^ self scalars zero].
	self generators size = 1 ifTrue: [^ self generators first].
	(G _ self basis "reduced") size = 1 ifTrue: [^ G first].
	^ super generator! !

!PolynomialIdeal methodsFor: 'accessing' stamp: 'len 4/6/2021 13:14:53'!
minimalMonomialGeneratingSet
	^ self propertyAt: #minimalMonomialGeneratingSet ifAbsentPut:
		[| answer |
		answer _ Set new.
		(self generators asSortedCollection: [:a :b| a degree <= b degree])
			do: [:each|
				"make sure the generating set is minimal (and thus unique):"
				(answer anySatisfy: [:any| any | each]) ifFalse: [answer add: each].
		answer]]! !

!PolynomialIdeal methodsFor: 'accessing' stamp: 'len 7/30/2021 12:35:23'!
univariateExponent
	"Answer the univariate exponent of the receiver.
	See [BW93], Definition 8.24."
	| answer |
	answer _ 1.
	self scalars indeterminates do: [:i| | f mu |
		f _ (self eliminateAllBut: i) generator.
		mu _ 1.
		f factorizationDo: [:p :s| mu _ mu max: s].
		answer _ answer + (mu - 1)].
	^ answer! !

!PolynomialIdeal methodsFor: 'accessing' stamp: 'len 1/15/2018 18:57:42'!
variety
	"Answer the algebraic variety that is the set of zeroes of all polynomials in the receiver."
	^ self isHomogeneous ifTrue: [(self scalars / self radical) proj] ifFalse: [(self scalars / self radical) spec]! !

!PolynomialIdeal methodsFor: 'elements-operations' stamp: 'len 1/23/2022 08:40:49'!
reduce: aPolynomial
	"Answer the normal form of anElement with respect to the receiver."
	| f |
	f _ aPolynomial.
	self flag: #fix.
	f parent == self scalars ifFalse: [f _ self scalars !! f]. "<- should remove this"
	(f isZero or: [self isZero]) ifTrue: [^ f].
	"in some cases we can divide even if the ring is not euclidean, for example by a monic polynomial:"
	(self scalars isEuclidean or: [self generators size = 1 and: [self generator isMonic]]) ifTrue: [^ f \\ self generator].
"	self scalars scalars isField ifFalse: [^ super reduce: aPolynomial]."
	^ f reductionBy: self basis! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 7/30/2021 12:33:47'!
/\ anIdeal
	| R S t |
	self scalars = anIdeal scalars ifFalse: [DomainError signal: 'rings don''t match'].
	self isTrivial ifTrue: [^ self].
	anIdeal isTrivial ifTrue: [^ anIdeal].
	(self isMonomial and: [anIdeal isMonomial])
		ifTrue: "[HH11] Proposition 1.2.1."
			[| generators |
			generators _ Set new.
			self minimalMonomialGeneratingSet do: [:each|
				anIdeal minimalMonomialGeneratingSet do: [:other| generators add: (each lcm: other)]].
			^ self scalars * generators].
	"To compute the intersection we introduce a new variable t, then eliminate it from the ideal I*t + J*(1-t):"
	R _ self scalars.
	S _ R scalars polynomialsIn: R rank + 1.
	t _ S x: S rank.
	^ R !! (S !! self * t + (S !! anIdeal * (t - S one)) eliminate: S rank)! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 1/13/2022 10:31:39'!
: anIdeal
	"Answer the colon quotient I:J of the receiver I with the argument J.
	This is defined as I:J := {r in R | rJ <= I}."
	"See [CLO97] pag. 205, [DK02] pag. 16, [HH11] Proposition 1.2.2."
	| R answer |
	R _ self scalars.
	R isIntegralDomain ifFalse: [^ super : anIdeal].
	answer _ R asIdeal. "<1>"
	(self isMonomial and: [anIdeal isMonomial])
		ifTrue:
			[anIdeal minimalMonomialGeneratingSet do: [:g|
				answer _ answer /\ (R * (self minimalMonomialGeneratingSet collect: [:each| each / (each gcd: g)]))]]
		ifFalse:
			[anIdeal generators do: [:g|
				answer _ answer /\ (R * ((R * g /\ self) basis apply: [:h| h / g]))]].
	^ answer! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 4/6/2021 12:48:38'!
alexanderDual
	"Answer the Alexander dual of the receiver.
	If I is the Stanley-Reisner ideal of a simplicial complex S, the Alexander dual of I is defined as the Stanley-Reisner ideal of the dual of S."
	^ self asSimplicialComplex dual stanleyReisnerIdealIn: self scalars! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 1/9/2022 08:32:25'!
asSimplicialComplex
	"Answer the Stanley-Reisner simplicial complex associated to the receiver.
	This is the simplicial complex formed by the support of all squarefree monomials not in this ideal.
	Fail if this ideal is not squarefree."
	self isMonomial ifFalse: [^ self error: 'not a monomial ideal'].
	self isSquarefree ifFalse: [^ self error: 'not squarefree'].
	^ (SimplicialComplex on: self scalars indeterminates facets: (self minimalMonomialGeneratingSet collect: [:each| each indeterminates])) complement dual! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 3/6/2021 14:04:35'!
dehomogenizedIn: anIndeterminate
	"Answer the dehomogenization of the receiver removing the given indeterminate."
	| R S |
	R _ self scalars.
	S _ R slice: (R indeterminates select: [:i| i ~= anIndeterminate]).
	^ S * (self generators collect: [:each| S !! (each dehomogenizedIn: anIndeterminate)])! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 1/13/2022 10:27:18'!
eliminateAll: aCollection
	"Answer the elimination ideal for the indeterminates in aCollection = {xi}, i.e. the subideal of polynomials without indeterminates {xi}."
	| freeIndeterminates G newGenerators |
	freeIndeterminates _ self scalars ordering indeterminates reject: [:each| aCollection includes: each].
	self scalars ordering isGlobal ifFalse: [self notYetImplemented].
	"if the ideal is homogeneous, should we use use glex?"
	G _ (self orderedBy: (MonomialOrdering lex: aCollection), (MonomialOrdering grevlex: freeIndeterminates)) basis "minimal".
	newGenerators _ G asArray select: [:each| (aCollection noneSatisfy: [:none| each has: none])].
	^ self scalars * (newGenerators collect: [:each| self scalars !! each])! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 8/3/2021 14:43:11'!
highestCorner
	"Answer the highest corner of the receiver I.
	This is the unique monomial m such that:
		1) m is not in the leading ideal of I;
		2) if m' < m, then m' is in the leading ideal of I."
	self scalars ordering isGlobal
		ifTrue: [^ self isProper ifTrue: [self scalars monomials identity]].
	"TODO: compute it combinatorially from a standard basis"
	self notYetImplemented! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 5/23/2020 09:10:45'!
hilbertSeries
	"Answer the Hilbert series of the receiver expressed as a rational function in Q(t)."
	^ self hilbertSeriesAt: ( polynomialsIn: #(t)) fractions x! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 12/30/2021 17:28:21'!
hilbertSeriesAt: t
	"Answer the Hilbert series corresponding to the quotient by the receiver."
	| R n m J int |
	self isZero ifTrue: [^ t zero].
	self isMonomial ifFalse: 
		[self isHomogeneous ifFalse: [^ self notYetImplemented].
		^ self leadingIdeal hilbertSeriesAt: t].
	"For monomial ideals:"
	R _ self scalars.
	n _ R rank.
	m _ self generators asArray last.
	J _ R * (self generators copyWithout: m).
	int _ R * (J generators collect: [:each| each lcm: m]).
	^ t ^ m degree / ((1 to: n) product: [:i| 1 - (t ^ (R gradings at: i))])
		+ (J hilbertSeriesAt: t)
		- (int hilbertSeriesAt: t)! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 1/13/2022 10:27:00'!
homogenized
	"Answer the homogenization of the receiver introducing a new indeterminate."
	| R S G |
	R _ self scalars.
	S _ R scalars polynomialsIn: R rank + 1.
	"Must use a graded monomial ordering such as glex or grevlex:"
	G _ (self orderedBy: (MonomialOrdering grevlex: R rank)) basis.
	^ S * (G collect: [:each| S !! each homogenizedIn: S rank])! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 7/27/2021 11:31:32'!
leadingIdeal
	"Answer the initial ideal. This is the ideal of all leading terms of the receiver."
	^ self leadingSubmodule! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 1/14/2022 11:49:43'!
localization
	"Answer the localization of the receiver at <x1,...,xn>. This is achieved by choosing a local ordering.
	Objects defined in this localization contain geometric information (usually only) about a Zariski neighbourhood of 0 in K^n, while objects in the global ring contain geometric information whish is valid in the whole affine space K^n."
	self scalars ordering isGlobal ifFalse: [self error: 'not a global ordering'].
	^ self orderedBy: #lglex! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 4/6/2021 12:52:17'!
polarization
	"Answer the polarization of the receiver.
	The polarization is a deformation that assigns to an arbitrary monomial ideal a squarefree monomial ideal in a new set of variables."
	self isMonomial ifFalse: [^ self error: 'not a monomial ideal'].
	self notYetImplemented	! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 12/17/2021 14:44:19'!
predecomposition
	"See [BW93], Table 8.1, Algorithm PREDEC."
	| R answer |
	R _ self scalars.
	answer _ Set with: self.
	R indeterminates do: [:i| | previous |
		previous _ answer.
		answer _ Set new.
		(self eliminateAllBut: i) generator normalized factorizationDo: [:p :s|
			previous do: [:G| | H | (H _ G + (p^s)) isProper ifTrue: [answer add: H]]]].
	^ answer! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 1/9/2022 08:32:35'!
primaryDecomposition
	"Answer the standard primary decomposition of the receiver.
	This is the unique primary decomposition obtained from an irredundant intersection of irreducible ideals."
	(self isMonomial and: [self isSquarefree]) ifFalse: [^ super primaryDecomposition].
	^ self asSimplicialComplex facets collect: [:each|
		self scalars * (self scalars indeterminates \ each vertices collect: [:i| self scalars x: i])]! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 1/9/2022 08:34:25'!
radical
	self isMonomial ifTrue: [^ self squarefreePart]. "[HH11] Proposition 1.2.4"
	self flag: #fix. "this is not right, maybe only works for Q[x1..xn] and monomial ideals"
	^ self squarefreePart! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 7/30/2021 12:31:29'!
saturation: anIdeal
	"Answer the saturation ideal I:J^infinity of the receiver I with the argument J."
	"See [CLO97] pag. 205, [DK02] pag. 16."
	| P t J |
	P _ self scalars scalars polynomialsIn: self scalars rank + 1.
	t _ P x: P rank.
	J _ P !! self.
	anIdeal generators do: [:each|
		J _ J + (P * (t * (P !! each) - P one)).
		J _ J eliminate: P rank].
	^ self scalars * (J generators collect: [:each| self scalars !! each])! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 12/18/2021 20:30:15'!
singular
	"Answer the singular locus of the receiver (or more precisely of the quotient by the receiver). The singular locus is defined as:
		Sing(A) := {P in Spec(A) | the localization of A at P is not regular}.
	If the receiver is not equidimensional, its lower-dimensional components will be contained in the answer whether they are singular or not.
	(See [Eis95] Ch. 20, re Fitting ideal.)"
	| R generators n d jacobian J |
	self flag: #fix. "TODO: implement singular locus in general, from 'A Singular Introduction to Commutative Algebra', Algorithm 5.7.8"
	R _ self scalars.
	generators _  self generators asArray.
	n _ R rank.
	d _ (R/self) dimension.
	jacobian _ R matrix: n @ generators size filling: [:i :j| (generators at: j) derivativeIn: i].
	J _ self scalars * (jacobian minors: n - d).
	^ self + J
"before I did:
	J _ R matrix: n @ generators size evaluating: [:i :j| (generators at: j) derivativeIn: i].
	^ self scalars * ((J minors: n - d) collect: [:each| self reduce: each])
but that seems to be wrong"! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 1/9/2022 08:34:28'!
zeroDimensionalRadical
	"Answer the radical of the receiver, assuming it is zero-dimensional.
	See [BW93] Table 8.3, Algorithm ZRADICAL."
	self dimension = 0 ifFalse: [self error: 'not zero-dimensional'].
	^ self scalars * (self scalars indeterminates collect: [:i| (self eliminateAllBut: i) generator squarefreePart])! !

!PolynomialIdeal methodsFor: 'testing' stamp: 'len 4/6/2021 13:16:45'!
isIrreducible
	"Irreducible monomial ideals are those generated by powers of some of the variables."
	self isMonomial ifTrue: [^ self minimalMonomialGeneratingSet allSatisfy: [:each| each monomials anyOne support size = 1]].
	^ super isIrreducible! !

!PolynomialIdeal methodsFor: 'testing' stamp: 'len 5/1/2021 12:25:46'!
isPrimary
	"An ideal I of a commutative ring is called 'primary' if for all x*y in I, x or y^n (n>0) is also in I."
	"Primary monomial ideals are those containing powers of each of a certain subset of the variables, and generated by elements involving no further variables."
	^ self notYetImplemented! !

!PolynomialIdeal methodsFor: 'testing' stamp: 'len 4/6/2021 15:26:02'!
isPrime
	"Prime monomial ideals are those generated by subsets of the variables."
	self isMonomial ifTrue: [^ self minimalMonomialGeneratingSet allSatisfy: [:each| each degree = 1 and: [each monomials anyOne support size = 1]]].
	^ super isPrime! !

!PolynomialIdeal methodsFor: 'testing' stamp: 'len 1/13/2022 10:32:14'!
isPrincipal
	"Answer true if the receiver is generated by a single polynomial."
	^ self scalars isPIR or: [self generators size = 1 or: [self basis "reduced" size <= 1]]! !

!PolynomialIdeal methodsFor: 'testing' stamp: 'len 1/9/2022 08:32:30'!
isRadical
"	self quotientRing isZeroDimensional ifTrue: [^ self isZeroDimensionalRadical]."
	self isMonomial ifTrue: [^ self isSquarefree].
	^ super isRadical! !

!PolynomialIdeal methodsFor: 'testing' stamp: 'len 7/30/2021 12:34:27'!
isRadicalZeroDimensional
	"Answer true if the receiver is radical, assuming its quotient is zero-dimensional.
	See [BW93], Table 8.2, Algorithm ZRADICALTEST."
	self scalars indeterminates do: [:i| | f |
		f _ (self eliminateAllBut: i) generator.
		(f gcd: (f derivativeIn: i)) isConstant ifFalse: [^ false]].
	^ true! !

!PolynomialIdeal methodsFor: 'testing' stamp: 'len 1/9/2022 08:31:18'!
isSquarefree
	"A monomial ideal is squarefree iff each generator in the minimal generating set is squarefree."
	self isMonomial ifTrue: [^ self generators allSatisfy: [:each| each isSquarefree]].
	^ super isSquarefree! !

!PolynomialIdeal methodsFor: 'testing' stamp: 'len 3/4/2021 13:43:02'!
radicalContains: aPolynomial
	"(Radical Membership Problem)
	Answer true if the radical of the receiver includes aPolynomial.
	Use Rabinowitsch's trick introducing a new indeterminate."
	| R S t X |
	R _ self scalars.
	S _ R scalars polynomialsIn: R rank + 1.
	t _ S x: R rank + 1.
	X _ OrderedCollection new.
	self generators do: [:g| X add: S !! g].
	X add: S !! aPolynomial * t - S one.
	^ (S * X) isOne! !

!PolynomialIdeal methodsFor: 'printing' stamp: 'len 1/13/2022 10:32:19'!
printStaircase
	| w h matrix |
	w _ self generators max: [:each| (each degreeIn: 1) + 1].
	h _ self generators max: [:each| (each degreeIn: 2) + 1].
	matrix _ (1 to: h) collect: [:x| (1 to: w) collect: [:y| ' ']].
	self basis do: [:each| | x y |
		x _ each degreeIn: 1.
		y _ each degreeIn: 2.
		(matrix at: h-y) at: x+1 put: 'X'].
	^ String streamContents: [:aStream| matrix do: [:line| line do: [:dot| aStream nextPutAll: dot]] separatedBy: [aStream lf]]! !

!PolynomialIdeal methodsFor: 'deprecated' stamp: 'len 10/31/2016 03:27'!
eliminate: anIndeterminate
	"Answer the elimination ideal computed by eliminating anIndeterminate."
	^ self eliminateAll: {anIndeterminate}

"Alternative algorithm to compute eliminants:
input: ideal I in K[x1..xn] and indet xi
output: univariate eliminant g(xi) or there's no eliminant
1. compute groebner basis G of I in any monomial ordering
2. if no initial term of any element of G is a pure power of xi, then halt, no eliminant
3. compute the sequence 1 mod G, xi mod G, xi^2 mod G, ... until a linear dependence is found
  anxi^n+...+a1xi+a0 mod G = 0
where n is minimal, then output eliminant g(xi) = sum akxi^k
"! !

!PolynomialIdeal methodsFor: 'deprecated' stamp: 'len 1/15/2018 18:55:06'!
eliminateAllBut: anIndeterminate
	"Answer the subideal of polynomials with only the given indeterminate."
	^ self eliminateAll: (self scalars indeterminates select: [:each| each ~= anIndeterminate])! !

!PolynomialIdeal methodsFor: 'deprecated' stamp: 'len 1/13/2022 10:32:04'!
isOne
	"Answer true if the receiver is the unit ideal <1> (the whole ring)."
	(self generators anySatisfy: [:g| g isUnit]) ifTrue: [^ true].
	"If the receiver is principal and the generator is not a unit, or if the receiver is trivial (no generators), then it's not <1>:"
	self generators size <= 1 ifTrue: [^ false].
	^ self basis anySatisfy: [:g| g isUnit]! !

!PolynomialIdeal class methodsFor: 'examples' stamp: 'len 5/23/2020 09:11:37'!
cyclic3
	"The ideal of cyclic 3-roots."
	^ ( polynomialsIn: #(x y z)) cyclicIdeal! !

!PolynomialIdeal class methodsFor: 'examples' stamp: 'len 5/23/2020 09:11:37'!
katsura3
	"The Katsura ideal in 3 variables with rational coefficients."
	^ ( polynomialsIn: #(a b c)) katsuraIdeal! !

!MonomialIdeal methodsFor: 'accessing' stamp: 'len 2/19/2017 09:27:47'!
generatingMonomials
	"Answer the set of monomials corresponding to the polynomials that generate the receiver."
	^ self generators collect: [:each| each monomials anyOne]! !

!MonomialIdeal methodsFor: 'operations' stamp: 'len 4/6/2021 10:21:53'!
/\ anIdeal
	"Answer the intersection of the receiver and the argument."
	"J. Herzog, 'Monomial Ideals', Proposition 1.2.1."
	| intersection |
	(anIdeal isKindOf: MonomialIdeal)
		ifFalse: [^ super /\ anIdeal].
	self scalars = anIdeal scalars ifFalse: [DomainError signal: 'rings don''t match'].
	intersection _ Set new.
	self generators do: [:each|
		anIdeal generators do: [:other| intersection add: (each lcm: other)]].
	^ self scalars * intersection! !

!MonomialIdeal methodsFor: 'operations' stamp: 'len 1/9/2022 08:11:04'!
: anIdeal
	"Answer the colon quotient I:J of the receiver I with the argument J.
	This is defined as I:J := {r in R | rJ <= I}.
	J. Herzog, 'Monomial Ideals', Proposition 1.2.2."
	| R answer |
	(anIdeal isKindOf: MonomialIdeal)
		ifFalse: [^ super : anIdeal].
	R _ self scalars.
	R isIntegralDomain ifFalse: [^ super : anIdeal]. "is this needed?"
	answer _ R asIdeal. "<1>"
	anIdeal generators do: [:g|
		answer _ answer /\ (R * (self generators collect: [:each| each / (each gcd: g)]))].
	^ answer! !

!MonomialIdeal methodsFor: 'operations' stamp: 'len 4/14/2020 03:28:19'!
alexanderDual
	"Answer the Alexander dual of the receiver.
	If I is the Stanley-Reisner ideal of a simplicial complex S, the Alexander dual of I is defined as the Stanley-Reisner ideal of the dual of S."
	^ self asSimplicialComplex dual stanleyReisnerIdealIn: self scalars! !

!MonomialIdeal methodsFor: 'operations' stamp: 'len 1/9/2022 08:32:02'!
asSimplicialComplex
	"Answer the Stanley-Reisner simplicial complex associated to the receiver.
	This is the simplicial complex formed by the support of all squarefree monomials not in this ideal.
	Fail if this ideal is not squarefree."
	self isSquarefree ifFalse: [^ self error: 'not squarefree'].
	^ (SimplicialComplex on: self scalars indeterminates facets: (self generatingMonomials collect: [:each| each indeterminates])) complement dual! !

!MonomialIdeal methodsFor: 'operations' stamp: 'len 4/6/2021 10:23:08'!
hilbertSeriesAt: t
	"Answer the Hilbert series corresponding to the quotient by the receiver."
	| R n m J int |
	self isZero ifTrue: [^ t zero].
	R _ self scalars.
	n _ R rank.
	m _ self generators asArray last.
	J _ R * (self generators copyWithout: m).
	int _ R * (J generators collect: [:each| each lcm: m]).
	^ t ^ m degree / ((1 to: n) product: [:i| 1 - (t ^ (R gradings at: i))])
		+ (J hilbertSeriesAt: t)
		- (int hilbertSeriesAt: t)! !

!MonomialIdeal methodsFor: 'operations' stamp: 'len 2/19/2017 10:37:52'!
polarization
	"Answer the polarization of the receiver.
	The polarization is a deformation that assigns to an arbitrary monomial ideal a squarefree monomial ideal in a new set of variables."
	self notYetImplemented	! !

!MonomialIdeal methodsFor: 'operations' stamp: 'len 1/9/2022 08:32:19'!
primaryDecomposition
	"Answer the standard primary decomposition of the receiver.
	This is the unique primary decomposition obtained from an irredundant intersection of irreducible ideals."
	self isSquarefree ifFalse: [^ super primaryDecomposition].
	^ self asSimplicialComplex facets collect: [:each|
		self scalars * (self scalars indeterminates \ each vertices collect: [:i| self scalars x: i])]! !

!MonomialIdeal methodsFor: 'operations' stamp: 'len 1/9/2022 08:34:19'!
radical
	"J. Herzog, 'Monomial Ideals', Proposition 1.2.4."
	^ self squarefreePart! !

!MonomialIdeal methodsFor: 'operations' stamp: 'len 1/7/2022 20:25:59'!
span: aCollection
	| generators |
	aCollection isCollection ifFalse: [^ super span: aCollection].
	generators _ OrderedCollection new: aCollection size.
	(aCollection asSortedCollection: [:a :b| a degree <= b degree])
		do: [:each|
			"make sure the generating set is minimal (and thus unique):"
			(generators anySatisfy: [:any| any | each]) ifFalse: [generators add: each]].
	^ super span: generators! !

!MonomialIdeal methodsFor: 'printing' stamp: 'len 1/13/2022 10:31:28'!
printStaircase
	| w h matrix |
	w _ self generators max: [:each| (each degreeIn: 1) + 1].
	h _ self generators max: [:each| (each degreeIn: 2) + 1].
	matrix _ (1 to: h) collect: [:x| (1 to: w) collect: [:y| ' ']].
	self basis do: [:each| | x y |
		x _ each degreeIn: 1.
		y _ each degreeIn: 2.
		(matrix at: h-y) at: x+1 put: 'X'].
	^ String streamContents: [:aStream| matrix do: [:line| line do: [:dot| aStream nextPutAll: dot]] separatedBy: [aStream lf]]! !

!MonomialIdeal methodsFor: 'testing' stamp: 'len 2/20/2017 07:46:57'!
isIrreducible
	"Irreducible monomial ideals are those generated by powers of some of the variables."
	^ self generatingMonomials allSatisfy: [:each| each support size = 1]! !

!MonomialIdeal methodsFor: 'testing' stamp: 'len 5/1/2021 12:25:41'!
isPrimary
	"An ideal I of a commutative ring is called 'primary' if for all x*y in I, x or y^n (n>0) is also in I."
	"Primary monomial ideals are those containing powers of each of a certain subset of the variables, and generated by elements involving no further variables."
	^ self notYetImplemented! !

!MonomialIdeal methodsFor: 'testing' stamp: 'len 2/20/2017 07:47:09'!
isPrime
	"Prime monomial ideals are those generated by subsets of the variables."
	^ self generatingMonomials allSatisfy: [:each| each degree = 1 and: [each support size = 1]]! !

!MonomialIdeal methodsFor: 'testing' stamp: 'len 1/9/2022 08:32:09'!
isRadical
	^ self isSquarefree! !

!MonomialIdeal methodsFor: 'testing' stamp: 'len 1/9/2022 08:30:30'!
isSquarefree
	"A monomial ideal is squarefree iff each generator in the minimal generating set is squarefree."
	^ self generators allSatisfy: [:each| each isSquarefree]! !

!MonomialIdeal methodsFor: 'private' stamp: 'len 7/7/2016 07:39'!
species
	^ PolynomialIdeal! !

!DirectSumModule methodsFor: 'accessing' stamp: 'len 4/25/2020 07:00:24'!
components
	^ components! !

!DirectSumModule methodsFor: 'accessing' stamp: 'len 7/10/2021 05:40:52'!
generatorMatrix
	^ self propertyAt: #generatorMatrix ifAbsentPut:
		[components inject: (self scalars^0) id into: [:answer :each| answer  each coordinates id]]! !

!DirectSumModule methodsFor: 'accessing' stamp: 'len 7/6/2021 09:56:40'!
generators
	^ self propertyAt: #generators ifAbsentPut:
		[| generators |
		generators _ OrderedCollection new: (components product: [:each| each generators size]).
		1 to: components size do: [:i|
			(components at: i) generators do: [:each|
				generators add: (self compose: (components withIndexCollect: [:eachModule :j| i=j ifTrue: [each] ifFalse: [eachModule zero]]))]].
		generators asArray]! !

!DirectSumModule methodsFor: 'accessing' stamp: 'len 7/10/2021 05:40:02'!
presentationMatrix
	^ self propertyAt: #presentationMatrix ifAbsentPut:
		[components inject: (self scalars^0) id into: [:answer :each| answer  each presentationMatrix]]! !

!DirectSumModule methodsFor: 'accessing' stamp: 'len 4/25/2020 09:24:37'!
scalars
	^ components first scalars! !

!DirectSumModule methodsFor: 'accessing' stamp: 'len 4/25/2020 07:00:35'!
size
	^ components product: [:each| each size]! !

!DirectSumModule methodsFor: 'accessing' stamp: 'len 4/25/2020 07:02:42'!
zero
	^ self compose: (components collect: [:each| each zero])! !

!DirectSumModule methodsFor: 'comparing' stamp: 'len 4/25/2020 07:01:13'!
= anObject
	^ self == anObject or: [self class == anObject class and: [components = anObject components]]! !

!DirectSumModule methodsFor: 'comparing' stamp: 'len 4/25/2020 07:01:17'!
hash
	^ components hash! !

!DirectSumModule methodsFor: 'elements' stamp: 'len 5/3/2021 11:24:54'!
\ anElement
	"Answer coordinates of anElement expressed as a linear combination of the elements of the distinguished generating set of the receiver. Answer nil if anElement is not in the receiver."
	^ (1 to: components size) inject: (self scalars^0) zero into: [:answer :i| answer, ((components at: i) \ (anElement at: i))]! !

!DirectSumModule methodsFor: 'elements' stamp: 'len 7/6/2021 08:47:47'!
compose: anArray
	^ ModuleTuple new parent: self; components: anArray asArray! !

!DirectSumModule methodsFor: 'enumerating' stamp: 'len 10/17/2020 20:00:00'!
do: aBlock
	self asCartesianProduct do: [:each| aBlock value: (self compose: each)]! !

!DirectSumModule methodsFor: 'morphisms' stamp: 'len 4/25/2020 07:04:35'!
coprojection: i
	^ ((self at: i) to: self evaluating: [:x| self compose: (components withIndexCollect: [:each :k| k = i ifTrue: [x] ifFalse: [each zero]])]) name: 'i', i printText sub! !

!DirectSumModule methodsFor: 'morphisms' stamp: 'len 5/23/2020 07:30:35'!
projection: i
	"Answer the canonical projection to the i-th component."
	^ (self to: (self components at: i) evaluating: [:x| x at: i]) name: '', i printText sub! !

!DirectSumModule methodsFor: 'testing' stamp: 'len 4/25/2020 07:04:03'!
includes: anObject
	^ anObject parent = self! !

!DirectSumModule methodsFor: 'testing' stamp: 'len 4/25/2020 07:04:49'!
isCoproduct
	^ true! !

!DirectSumModule methodsFor: 'testing' stamp: 'len 5/3/2021 11:19:54'!
isFreelyGenerated
	"Answer true if the receiver is free on free generators."
	^ components allSatisfy: [:each| each isFreelyGenerated]! !

!DirectSumModule methodsFor: 'testing' stamp: 'len 4/25/2020 07:04:53'!
isProduct
	^ true! !

!DirectSumModule methodsFor: 'private' stamp: 'len 4/25/2020 07:03:54'!
components: anArray
	components _ anArray! !

!DirectSumModule class methodsFor: 'instance creation' stamp: 'len 4/25/2020 07:13:51'!
components: anArray
	^ self new components: anArray! !

!TensorModule methodsFor: 'accessing' stamp: 'len 6/3/2018 20:15:48'!
at: anInteger
	^ components at: anInteger! !

!TensorModule methodsFor: 'accessing' stamp: 'len 6/3/2018 20:15:26'!
components
	^ components! !

!TensorModule methodsFor: 'accessing' stamp: 'len 9/16/2018 16:18:35'!
indices
	^ self propertyAt: #indices ifAbsentPut: [self computeIndices]! !

!TensorModule methodsFor: 'accessing' stamp: 'len 9/16/2018 16:18:48'!
scalars
	components do: [:any| ^ any scalars].
	^ nil! !

!TensorModule methodsFor: 'accessing' stamp: 'len 9/16/2018 16:18:53'!
type
	"Tensor products of n copies of a vector space and m copies of its dual are of type (n,m)."
	self propertyAt: #type ifAbsentPut: [self computeType]! !

!TensorModule methodsFor: 'basis' stamp: 'len 4/26/2021 11:37:27'!
\ anElement
	"Answer coordinates of anElement expressed as a linear combination of the elements of the distinguished generating set of the receiver. Answer nil if anElement is not in the receiver."
	^ self scalars tuple: (self indices collect: [:each| anElement at: each])! !

!TensorModule methodsFor: 'basis' stamp: 'len 7/13/2020 07:24:11'!
basis
	^ self propertyAt: #basis ifAbsentPut: [self indices collect: [:each| Tensor2 new parent: self; at: each put: self scalars one; yourself]]! !

!TensorModule methodsFor: 'basis' stamp: 'len 6/3/2018 20:18:15'!
rank
	^ components product: [:each| each rank]! !

!TensorModule methodsFor: 'converting' stamp: 'len 9/15/2018 17:06:12'!
over: aRing
	"Answer the change of base ring of the receiver."
	^ self class components: (components collect: [:each| each over: aRing])! !

!TensorModule methodsFor: 'elements' stamp: 'len 9/16/2018 16:17:45'!
!! anObject
	(anObject isSequenceable and: [anObject size = self arity and: [(1 to: self arity) allSatisfy: [:i| (self at: i) includes: (anObject at: i)]]])
		ifTrue: [^ self compose: anObject].
	^ super !! anObject! !

!TensorModule methodsFor: 'elements' stamp: 'len 7/13/2020 07:24:11'!
evaluating: aBlock
	| answer |
	answer _ Tensor2 new parent: self.
	self indices do: [:each| answer at: each put: (aBlock value: each)].
	^ answer! !

!TensorModule methodsFor: 'morphisms' stamp: 'len 4/26/2021 11:44:13'!
compose: anArray
	| coordinates answer |
	anArray size = self arity ifFalse: [DomainError signal].
	coordinates _ anArray withIndexCollect: [:each :i| (self at: i) \ each].
	answer _ Tensor2 new parent: self.
	self indices do: [:each|
		answer at: each put: ((1 to: coordinates size) inject: self scalars one into: [:product :i| product * ((coordinates at: i) at: (each at: i))])].
	^ answer! !

!TensorModule methodsFor: 'morphisms' stamp: 'len 6/29/2020 12:47:04'!
composition
	"This is the product of tensors. This is a multilinear map."
	^ (self carrier to: self evaluating: [:each| self compose: each]) name: ''! !

!TensorModule methodsFor: 'testing' stamp: 'len 4/22/2020 06:12:53'!
includes: anObject
	^ anObject parent = self! !

!TensorModule methodsFor: 'private' stamp: 'len 9/16/2018 16:17:53'!
components: anArray
	components _ anArray

"	| algebra indeterminates |
	components _ anArray.
	indeterminates _ OrderedCollection new.
	anArray withIndexDo: [:each :i| 1 to: each rank do: [:j| indeterminates add: 'x', (i printString, ',' j printString) sub]].
	algebra _ components anyOne scalars freeAlgebraIn: indeterminates.
	self propertyAt: #ambientAlgebra put: algebra"! !

!TensorModule methodsFor: 'private' stamp: 'len 9/16/2018 16:18:10'!
computeIndices
	| indices |
	indices _ OrderedCollection with: {}.
	components do: [:X| | newIndices |
		newIndices _ OrderedCollection new.
		indices do: [:each| 1 to: X rank do: [:i| newIndices add: each, {i}]].
		indices _ newIndices].
	^ indices! !

!TensorModule methodsFor: 'private' stamp: 'len 9/16/2018 16:18:14'!
computeType
	| V W i n |
	V _ components first.
	i _ components findFirst: [:each| each ~= V].
	i = 0 ifTrue: [^ {self arity. 0}].
	W _ components at: i.
	W = V dual ifFalse: [^ nil].
	n _ components findLast: [:each| each ~= W].
	i-1 = n ifFalse: [^ nil].
	^ {n. self arity - n}! !

!TensorModule class methodsFor: 'instance creation' stamp: 'len 6/3/2018 20:18:41'!
components: anArray
	^ self new components: anArray! !

!Code methodsFor: 'accessing' stamp: 'len 7/31/2020 08:43:47'!
completeWeightEnumerator
	"Answer the complete weight enumerator polynomial."
	| F P |
	F _ self scalars elements asArray.
	P _  polynomialsIn: F size.
	^ self elements sum: [:each| P monomial: (P monomials exponents: (F collect: [:i| each occurrencesOf: i]))]! !

!Code methodsFor: 'accessing' stamp: 'len 8/2/2020 17:34:11'!
diameter
	"Answer the maximum weight of the codewords of the receiver."
	^ self max: [:each| each weight]! !

!Code methodsFor: 'accessing' stamp: 'len 5/12/2016 07:19'!
dimension
	^ self rank! !

!Code methodsFor: 'accessing' stamp: 'len 8/10/2020 06:39:38'!
generatorMatrix
	"Answer a generator matrix of the receiver.
	Note that the code is the span of the columns of the generator matrix, contrary to the more common convention to define it as the span of the rows. This is in order to be consistent with modules and matrix left action on tuples."
	^ self asModule generatorMatrix! !

!Code methodsFor: 'accessing' stamp: 'len 8/2/2020 18:11:45'!
generatorPolynomial
	"If the receiver is a cyclic code, answer the generator polynomial."
	^ self propertyAt: #generatorPolynomial ifAbsentPut: [self computeGeneratorPolynomial]! !

!Code methodsFor: 'accessing' stamp: 'len 8/2/2020 18:13:34'!
length
	"Answer the length of a codeword."
	^ self space rank! !

!Code methodsFor: 'accessing' stamp: 'len 12/28/2016 11:32:15'!
minimumDistance
	"Answer the minimum Hamming distance between codewords.
	If the minimum distance is d, the code can correct (d-1)/2 errors."
	^ self propertyAt: #minimumDistance ifAbsentPut: [self computeMinimumDistance]! !

!Code methodsFor: 'accessing' stamp: 'len 8/10/2020 06:41:49'!
parityCheckMatrix
	"Answer a parity check matrix for the receiver. This is a matrix P such that P*x = 0 iff x is a word of the receiver, i.e. the receiver as module is the kernel of a matrix."
	^ self dual generatorMatrix transpose! !

!Code methodsFor: 'accessing' stamp: 'len 8/3/2020 07:14:56'!
parityCheckPolynomial
	"If the receiver is a cyclic code, answer the parity check polynomial.
	If the generator polynomial of the receiver is g, the parity check polynomial is a polynomial h such that gh = x^n - 1."
	| g |
	g _ self generatorPolynomial.
	^ g parent x ^ self length - 1 / g! !

!Code methodsFor: 'accessing' stamp: 'len 8/2/2020 12:12:12'!
rank
	^ self asModule rank! !

!Code methodsFor: 'accessing' stamp: 'len 4/3/2016 23:08'!
rate
	^ (self size log: 2) / self length! !

!Code methodsFor: 'accessing' stamp: 'len 2/15/2016 20:33'!
relativeDistance
	^ self minimumDistance / self length! !

!Code methodsFor: 'accessing' stamp: 'len 8/2/2020 18:13:48'!
scalars
	^ self space scalars! !

!Code methodsFor: 'accessing' stamp: 'len 8/2/2020 12:10:21'!
size
	"Answer the number of codewords."
	^ self asModule size! !

!Code methodsFor: 'accessing' stamp: 'len 8/2/2020 12:10:11'!
space
	"Answer the ambient vector space or free module."
	^ self asModule ambient! !

!Code methodsFor: 'accessing' stamp: 'len 8/2/2020 17:15:05'!
weightDistribution
	| answer |
	answer _ Bag new.
	self do: [:each| answer add: each weight].
	^ answer! !

!Code methodsFor: 'accessing' stamp: 'len 1/1/2016 00:06'!
weightDistribution: aCodeword
	"Answer the weight distribution wrt aCodeword."
	self notYetImplemented! !

!Code methodsFor: 'accessing' stamp: 'len 7/31/2020 08:47:05'!
weightEnumerator
	"Answer the Hamming weight enumerator polynomial."
	| P x y weights answer n |
	P _  polynomialsIn: #(x y).
	x _ P x.
	y _ P y.
	answer _ P zero.
	n _ self length.
	weights _ self weightDistribution.
	weights asSet do: [:i| answer _ x ^ (n - i) * (y ^ i) * (weights occurrencesOf: i) + answer].
	^ answer! !

!Code methodsFor: 'comparing' stamp: 'len 8/2/2020 22:28:28'!
<= aCode
	^ self asModule <= aCode asModule! !

!Code methodsFor: 'comparing' stamp: 'len 8/2/2020 18:35:34'!
= anObject
	^ (anObject isKindOf: Code) and: [self asModule = anObject asModule]! !

!Code methodsFor: 'comparing' stamp: 'len 8/2/2020 12:11:54'!
hash
	^ self asModule hash! !

!Code methodsFor: 'converting' stamp: 'len 8/3/2020 07:16:22'!
asIdeal
	"A linear code is cyclic if and only if it is an ideal in R[x]/<x^n - 1>."
	| g |
	g _ self generatorPolynomial.
	^ g parent / {g parent x ^ self length - 1} * g! !

!Code methodsFor: 'converting' stamp: 'len 5/3/2021 10:56:58'!
asLattice
	"A linear code in a finite field or ring can be lifted to a lattice.
	This is called the Construction A lifting."
	| B E H |
	B _ self generatorMatrix lift.
	E _ B  (B codomain endomorphisms scalar: self scalars characteristic).
	H _ E transpose HNF over: .
	^ Lattice on: H domain innerProduct basis: (H rows select: [:each| each isZero not])! !

!Code methodsFor: 'converting' stamp: 'len 8/2/2020 12:08:46'!
asModule
	^ self propertyAt: #asModule! !

!Code methodsFor: 'converting' stamp: 'len 8/2/2020 12:06:21'!
asVectorSpace
	self scalars isField ifFalse: [^ DomainError signal].
	^ self asModule! !

!Code methodsFor: 'enumerating' stamp: 'len 8/2/2020 12:11:08'!
do: aBlock
	self asModule do: aBlock! !

!Code methodsFor: 'graphs' stamp: 'len 8/2/2020 17:17:21'!
distanceGraph: d
	"Answer the graph of the codewords of the receiver, with two codewords adjacent if their Hamming distance is d."
	| G |
	G _ Graph unordered.
	self elements do: [:x|
		self elements do: [:y|
			(x-y) weight = d ifTrue: [G addEdgeFrom: x to: y]]].
	^ G! !

!Code methodsFor: 'graphs' stamp: 'len 4/5/2018 15:27:59'!
tannerGraph
	| matrix G |
	matrix _ self parityCheckMatrix.
	G _ Graph unordered.
	1 to: matrix height do: [:i|
		1 to: matrix width do: [:j|
			(matrix at: i@j) isZero not
				ifTrue:
					[| subcode digit |
					subcode _ matrix rowAt: i.
					digit _ matrix columnAt: j.
					G addEdgeFrom: subcode to: digit]]].
	^ G! !

!Code methodsFor: 'initialization' stamp: 'len 8/2/2020 12:24:36'!
submodule: aModule
	self propertyAt: #asModule put: aModule! !

!Code methodsFor: 'morphisms' stamp: 'len 4/20/2016 20:56'!
automorphisms
	"Answer the subgroup of Perm(F^k) (permutation of coordinates) that leave the receiver invariant.
	The automorphisms of a code and it's dual are the same."
	self notYetImplemented! !

!Code methodsFor: 'morphisms' stamp: 'len 2/15/2016 20:26'!
isometries
	"Answer the subgroup of Iso(F^k) that leave the receiver invariant."
	self notYetImplemented! !

!Code methodsFor: 'operations' stamp: 'len 8/2/2020 22:28:01'!
+ aCode
	^ self class on: self asModule + aCode asModule! !

!Code methodsFor: 'operations' stamp: 'len 8/2/2020 22:28:10'!
/\ aCode
	^ self class on: self asModule /\ aCode asModule! !

!Code methodsFor: 'operations' stamp: 'len 8/3/2020 20:35:51'!
 aCode
	"Answer the direct product of the receiver and the argument."
	^ self class generatorMatrix: self generatorMatrix  aCode generatorMatrix! !

!Code methodsFor: 'operations' stamp: 'len 8/3/2020 20:35:57'!
 aCode
	"Answer the direct sum of the receiver and the argument."
	^ self class generatorMatrix: self generatorMatrix  aCode generatorMatrix! !

!Code methodsFor: 'operations' stamp: 'len 8/3/2020 09:46:45'!
augmented
	"Answer a code like the receiver but including the all-ones vector amoung its codewords."
	| ones |
	ones _ self space filling: [:i| self scalars one].
	(self includes: ones) ifTrue: [^ self].
	^ self class on: self asModule + (self space span: {ones})! !

!Code methodsFor: 'operations' stamp: 'len 8/2/2020 17:59:32'!
complement
	"If the receiver is a subcode C1 <= C, answer C2 such that C = C1 + C2."
	self notYetImplemented! !

!Code methodsFor: 'operations' stamp: 'len 8/2/2020 18:35:34'!
dual
	"Answer the dual or orthogonal code of the receiver."
	^ Code on: self asModule complement! !

!Code methodsFor: 'operations' stamp: 'len 8/11/2020 08:42:37'!
extended
	^ self class on: (self space scalars ^ (self length + 1) span: (self asModule generators collect: [:each| each, each sum negated]))! !

!Code methodsFor: 'operations' stamp: 'len 8/2/2020 17:07:18'!
hull
	"The hull of a linear code is the intersection of the code with its dual."
	^ self /\ self dual! !

!Code methodsFor: 'operations' stamp: 'len 8/2/2020 18:35:34'!
span: aCollection
	"Answer the subcode spanned by the elements in aCollection."
	^ (Code on: (self asModule span: aCollection)) ambient: self! !

!Code methodsFor: 'random' stamp: 'len 8/2/2020 12:11:03'!
atRandom: aRandom bits: bitSize
	^ self asModule atRandom: aRandom bits: bitSize! !

!Code methodsFor: 'testing' stamp: 'len 8/2/2020 12:11:59'!
includes: aCodeword
	^ self asModule includes: aCodeword! !

!Code methodsFor: 'testing' stamp: 'len 8/3/2020 07:15:40'!
includesPolynomial: aPolynomial
	| g |
	g _ self generatorPolynomial.
	^ (self parityCheckPolynomial * aPolynomial \\ (g parent x ^ self length - 1)) isZero! !

!Code methodsFor: 'testing' stamp: 'len 8/2/2020 18:33:25'!
isCyclic
	"A code is called a cylic code if for each codeword (c1,...,cn) it also contains the cyclic right shifted word (cn,c1,c2,...,cn-1), i.e. the code is invariant under cylic shifts."
	self asModule generators do: [:each| (self includes: (each wrap: 1)) ifFalse: [^ false]].
	^ true

"alternative for polynomial codes:
	| g n x |
	n _ self length.
	g _ self generatorPolynomial.
	x _ g parent x.
	^ g | (x ^ n - x parent one)
"! !

!Code methodsFor: 'testing' stamp: 'len 8/2/2020 17:10:57'!
isDoublyEven
	^ self allSatisfy: [:each| each weight \\ 4 = 0]! !

!Code methodsFor: 'testing' stamp: 'len 8/2/2020 17:27:32'!
isEquidistant
	| distance |
	self do: [:x|
		self do: [:y|
			| d |
			x ~= y ifTrue: [d _ (x-y) weight. (distance ifNil: [distance _ d]) = d ifFalse: [^ false]]]].
	^ true! !

!Code methodsFor: 'testing' stamp: 'len 8/2/2020 17:10:15'!
isEven
	^ self allSatisfy: [:each| each weight even]! !

!Code methodsFor: 'testing' stamp: 'len 5/12/2016 07:30'!
isMaximumDistanceSeparable
	"Any linear [n,k,d] code satisfies k + d <= n + 1 (Singleton bound). If a code satisfies k + d = n + 1 it's called Maximum Distance Separable (MDS)."
	| n k d |
	n _ self length.
	k _ self rank.
	d _ self minimumDistance.
	^ k + d = (n + 1)! !

!Code methodsFor: 'testing' stamp: 'len 7/31/2020 08:46:03'!
isSelfDual
	self length even ifFalse: [^ false].
	self dimension = (self length / 2) ifFalse: [^ false].
	^ self = self dual! !

!Code methodsFor: 'testing' stamp: 'len 8/2/2020 12:12:06'!
isSelfOrthogonal
	^ self asModule <= self dual asModule! !

!Code methodsFor: 'testing' stamp: 'len 8/2/2020 12:05:56'!
isTrivial
	^ self asModule isTrivial! !

!Code methodsFor: 'private' stamp: 'len 8/2/2020 17:14:44'!
computeMinimumDistance
	| answer |
	answer _ Infinity positive.
	self do: [:each| each isZero ifFalse: [answer _ answer min: each weight]].
	^ answer! !

!Code class methodsFor: 'examples' stamp: 'len 8/10/2020 06:27:00'!
G11
	"Answer the perfect ternary Golay code [11,6,5]."
	^ self generatorMatrix:
		(Matrix columns: {
			(1,0,0,0,0,0, 1,1,1,1,1) % 3.
			(0,1,0,0,0,0, 0,1,2,2,1) % 3.
			(0,0,1,0,0,0, 1,0,1,2,2) % 3.
			(0,0,0,1,0,0, 2,1,0,1,2) % 3.
			(0,0,0,0,1,0, 2,2,1,0,1) % 3.
			(0,0,0,0,0,1, 1,2,2,1,0) % 3})! !

!Code class methodsFor: 'examples' stamp: 'len 8/10/2020 06:26:55'!
G12
	"Answer the extended ternary Golay code [12,6,6]."
	^ self generatorMatrix:
		(Matrix columns: {
			(1,0,0,0,0,0, 0,1,1,1,1,1) % 3.
			(0,1,0,0,0,0, 1,0,1,2,2,1) % 3.
			(0,0,1,0,0,0, 1,1,0,1,2,2) % 3.
			(0,0,0,1,0,0, 1,2,1,0,1,2) % 3.
			(0,0,0,0,1,0, 1,2,2,1,0,1) % 3.
			(0,0,0,0,0,1, 1,1,2,2,1,0) % 3})! !

!Code class methodsFor: 'examples' stamp: 'len 8/2/2020 18:29:21'!
G23
	"Answer the perfect binary Golay code [23,12,7]."
	| g |
	g _ (/2) polynomials !! [:x| x^11 + (x^10) + (x^6) + (x^5) + (x^4) + (x^2) + 1].
	^ self new: 23 generatorPolynomial: g! !

!Code class methodsFor: 'examples' stamp: 'len 5/3/2021 10:49:28'!
G24
	"Answer the extended binary Golay code [24,12,8].
	Its generator matrix is I|A, where I is the 12x12 identity matrix and A is the complement of the adjacency matrix of the icosahedron."
	| F A |
	F _ /2.
	A _ Graph icosahedron adjacencyMatrix: (1 to: 12).
	A _ (A collect: [:each| each = 0 ifTrue: [1] ifFalse: [0]]) apply:  -> F.
	^ self generatorMatrix: A identity  A! !

!Code class methodsFor: 'examples' stamp: 'len 8/10/2020 06:26:04'!
H7
	"Answer the [7,4,3] Hamming code, which is the binary cyclic code of length 7 with generator polynomial 1 + x + x^3."
	| generators c |
	generators _ OrderedCollection with: (c _ (1,1,0,1,0,0,0) % 2).
	3 timesRepeat: [generators add: (c _ c >> 1)].
	^ self generatorMatrix: (Matrix columns: generators)! !

!Code class methodsFor: 'examples' stamp: 'len 8/2/2020 18:28:58'!
H7p
	"Answer the Hamming code [7,4,3], from a generator polynomial."
	^ self new: 7 generatorPolynomial: (/2) polynomials !! [:x| x^3 + x + 1]! !

!Code class methodsFor: 'examples' stamp: 'len 8/10/2020 06:25:55'!
H8
	"Answer the extended Hamming code [8,4,4]."
	^ self generatorMatrix:
		(Matrix columns: {
			(1,0,0,0, 0,1,1,1) % 2.
			(0,1,0,0, 1,0,1,1) % 2.
			(0,0,1,0, 1,1,0,1) % 2.
			(0,0,0,1, 1,1,1,0) % 2})! !

!Code class methodsFor: 'examples' stamp: 'len 8/3/2020 06:53:28'!
RM: parameters
	"Answer the Reed-Muller code RM(r, m).
	First we build the 2^m Sierpinski matrix by taking the m-fold Kronecher product of the 2x2 matrix
		[1 0]
		[1 1]
	over Z/2Z. Then we construct the RM(r,m) code as the span of the rows with Hamming weight >= 2^(m-r)."
	| r m F S d |
	r _ parameters at: 1.
	m _ parameters at: 2.
	F _ (/2^2) endomorphisms !! #(1 0 1 1).
	S _ (/2^0) endomorphisms zero.
	m timesRepeat: [S _ S  F].
	d _ 2^(m-r).
	^ self on: (S domain span: (S rows select: [:each| each weight >= d]))! !

!Code class methodsFor: 'examples' stamp: 'len 8/10/2020 06:25:49'!
hadamard8
	"Answer the [8,3,4] Hadamard code."
	^ self generatorMatrix:
		(Matrix columns: {
			(0,0,0,0,1,1,1,1) % 2.
			(0,0,1,1,0,0,1,1) % 2.
			(0,1,0,1,0,1,0,1) % 2})! !

!Code class methodsFor: 'examples' stamp: 'len 8/10/2020 06:25:43'!
simplex
	"Answer the [7,3,4] simplex code, which is the dual code of the Hamming code."
	^ self generatorMatrix:
		(Matrix columns: {
			(0,0,0,1,1,1,1) % 2.
			(0,1,1,0,0,1,1) % 2.
			(1,0,1,0,1,0,1) % 2})! !

!Code class methodsFor: 'examples' stamp: 'len 8/2/2020 12:25:10'!
tetracode
	"Answer the tetracode, a self dual code of minimum distance 3."
	^ self on: ((/3)^4 span: {(1,1,1,0) % 3. (0,1,2,1) % 3})! !

!Code class methodsFor: 'instance creation' stamp: 'len 8/10/2020 06:39:05'!
generatorMatrix: aMatrix
	"Answer a linear code with generator matrix aMatrix.
	Note that the code is the span of the columns of the generator matrix, contrary to the more common convention to define it as the span of the rows. This is in order to be consistent with modules and matrix left action on tuples."
	^ self on: aMatrix image! !

!Code class methodsFor: 'instance creation' stamp: 'len 8/2/2020 18:27:51'!
generatorPolynomial: aPolynomial
	^ self new: aPolynomial degree generatorPolynomial: aPolynomial! !

!Code class methodsFor: 'instance creation' stamp: 'len 8/2/2020 18:31:06'!
new: n generatorPolynomial: aPolynomial
	| V W subspace |
	V _ aPolynomial parent filtrationAt: n - 1.
	W _ aPolynomial parent filtrationAt: n - aPolynomial degree - 1.
	subspace _ V span: (W asArray collect: [:f| aPolynomial * f]).
	^ (self on: subspace)
		propertyAt: #generatorPolynomial put: aPolynomial;
		yourself! !

!Code class methodsFor: 'instance creation' stamp: 'len 8/2/2020 12:25:23'!
on: aModule
	^ self new submodule: aModule! !

!PolynomialCode methodsFor: 'accessing' stamp: 'len 4/4/2016 20:19'!
generator
	^ generator! !

!PolynomialCode methodsFor: 'accessing' stamp: 'len 5/12/2016 07:20'!
rank
	^ self length - generator degree! !

!PolynomialCode methodsFor: 'accessing' stamp: 'len 1/23/2017 11:44:09'!
size
	^ generator parent scalars size ^ (self length - generator degree)! !

!PolynomialCode methodsFor: 'converting' stamp: 'len 7/31/2020 10:28:26'!
asIdeal
	^ generator parent * generator! !

!PolynomialCode methodsFor: 'encoding/decoding' stamp: 'len 5/12/2016 09:33'!
decode: aPolynomial
	self flag: #fix. "add error-detection and correction"
	^ aPolynomial // generator! !

!PolynomialCode methodsFor: 'encoding/decoding' stamp: 'len 7/15/2021 12:38:39'!
encode: aPolynomial
	| f |
	f _ aPolynomial << generator degree.
	^ f - (f \\ generator)! !

!PolynomialCode methodsFor: 'enumerating' stamp: 'len 7/31/2020 10:31:23'!
do: aBlock
	self asIdeal do: aBlock! !

!PolynomialCode methodsFor: 'initialization' stamp: 'len 4/4/2016 20:19'!
generator: aPolynomial
	generator _ aPolynomial! !

!PolynomialCode methodsFor: 'testing' stamp: 'len 5/12/2016 07:17'!
includes: aCodeword
	^ aCodeword | generator! !

!PolynomialCode methodsFor: 'testing' stamp: 'len 1/23/2017 11:44:04'!
isCyclic
	| n x |
	n _ self length.
	x _ generator parent x.
	^ generator | (x ^ n - x parent one)! !

!PolynomialCode class methodsFor: 'examples' stamp: 'len 5/23/2020 09:13:12'!
G23
	"Answer the perfect binary Golay code [23,12,7]."
	| g |
	g _ (/2) polynomials !! [:x| x^11 + (x^10) + (x^6) + (x^5) + (x^4) + (x^2) + 1].
	^ self new: 23 generator: g! !

!PolynomialCode class methodsFor: 'examples' stamp: 'len 5/23/2020 09:13:12'!
H7
	"Answer the Hamming code [7,4,3]."
	^ self new: 7 generator: (/2) polynomials !! [:x| x^3 + x + 1]! !

!PolynomialCode class methodsFor: 'instance creation' stamp: 'len 5/12/2016 07:42'!
generator: aPolynomial
	^ self new: aPolynomial degree generator: aPolynomial! !

!PolynomialCode class methodsFor: 'instance creation' stamp: 'len 8/2/2020 12:23:40'!
new: n generator: aPolynomial
	| V W subspace |
	V _ aPolynomial parent filtrationAt: n - 1.
	W _ aPolynomial parent filtrationAt: n - aPolynomial degree - 1.
	subspace _ V span: (W asArray collect: [:f| aPolynomial * f]).
	^ (self on: subspace) generator: aPolynomial! !

!CyclicCode methodsFor: 'accessing' stamp: 'len 1/23/2017 11:31:24'!
checkPolynomial
	| x one |
	x _ generator parent x.
	one _ generator parent one.
	^ x ^ self length - one / generator! !

!CyclicCode methodsFor: 'accessing' stamp: 'len 7/31/2020 10:30:03'!
dimension
	^ self length - generator degree! !

!CyclicCode methodsFor: 'operations' stamp: 'len 6/29/2016 22:18'!
dual
	^ self class new: self length generator: self generator reversed! !

!CyclicCode methodsFor: 'testing' stamp: 'len 5/15/2019 01:42:35'!
includes: aCodeword
	| x |
	x _ generator parent x.
	^ (self checkPolynomial * aCodeword \\ (x ^ self length - x one)) isZero! !

!CyclicCode methodsFor: 'testing' stamp: 'len 6/29/2016 22:18'!
isIrreducible
	^ generator isIrreducible! !

!Lattice methodsFor: 'accessing' stamp: 'len 7/8/2020 08:36:35'!
basis
	^ self propertyAt: #basis! !

!Lattice methodsFor: 'accessing' stamp: 'len 7/29/2020 07:02:20'!
content
	"Answer the largest rational number c such that the inner products (u, v) is in c*Z for all u and v in the lattice."
	^ self gramian denominator! !

!Lattice methodsFor: 'accessing' stamp: 'len 7/30/2020 19:57:59'!
coordinateLattice
	"Answer the coordinate lattice of the receiver."
	^ self class gramian: self gramian! !

!Lattice methodsFor: 'accessing' stamp: 'len 7/29/2020 06:53:30'!
degree
	^ self space rank! !

!Lattice methodsFor: 'accessing' stamp: 'len 4/26/2021 11:40:29'!
generatorMatrix
	^ self propertyAt: #generatorMatrix ifAbsentPut: [Matrix to: self space coordinates columns: (self basis collect: [:each| self space \ each])]! !

!Lattice methodsFor: 'accessing' stamp: 'len 7/29/2020 06:35:41'!
generators
	^ self propertyAt: #generators ifAbsentPut: [self asModule generators collect: [:each| self elementAt: each]]! !

!Lattice methodsFor: 'accessing' stamp: 'len 7/10/2020 12:41:19'!
gramian
	^ self innerProduct gramianOf: self basis! !

!Lattice methodsFor: 'accessing' stamp: 'len 7/8/2020 08:17:07'!
innerProduct
	^ self propertyAt: #innerProduct! !

!Lattice methodsFor: 'accessing' stamp: 'len 7/29/2020 07:04:05'!
level
	"Answer the smallest integer k such that k * norm(v) is in 2*Z for all v in the lattice (assuming the receiver is an integral lattice)."
	^ self gramian denominator! !

!Lattice methodsFor: 'accessing' stamp: 'len 7/29/2020 06:29:24'!
rank
	^ self basis size! !

!Lattice methodsFor: 'accessing' stamp: 'len 7/8/2020 08:26:43'!
reducedBasis
	^ self propertyAt: #reducedBasis ifAbsentPut: [(LLL basis: self basis innerProduct: self innerProduct) reducedBasis]! !

!Lattice methodsFor: 'accessing' stamp: 'len 3/28/2018 05:05:34'!
shortVector
	^ self reducedBasis first! !

!Lattice methodsFor: 'accessing' stamp: 'len 7/28/2020 19:32:24'!
space
	"Answer the ambient space of the receiver."
	^ self innerProduct space! !

!Lattice methodsFor: 'accessing' stamp: 'len 7/8/2020 08:35:58'!
zero
	^ self space zero! !

!Lattice methodsFor: 'comparing' stamp: 'len 8/11/2020 08:01:46'!
= anObject
	^ self class = anObject class and: [self innerProduct = anObject innerProduct and: [self generatorMatrix transpose HNF = anObject generatorMatrix transpose HNF]]! !

!Lattice methodsFor: 'comparing' stamp: 'len 8/11/2020 08:02:25'!
hash
	^ self generatorMatrix transpose HNF hash! !

!Lattice methodsFor: 'converting' stamp: 'len 10/20/2020 19:04:14'!
asAbelianGroup
	^ self asModule! !

!Lattice methodsFor: 'converting' stamp: 'len 7/22/2021 18:48:04'!
asModule
	^ self propertyAt: #asModule ifAbsentPut:
		[| answer |
		answer _ ^self rank.
		self addCoercionTo: answer evaluating: [:each| each coordinates].
		self addCoercionFrom: answer evaluating: [:each| self elementAt: each].
		answer]! !

!Lattice methodsFor: 'elements' stamp: 'len 7/28/2020 19:57:44'!
elementAt: anArray
	"Answer the element with the given coordinates."
	^ LatticeElement coordinates: self asModule !! anArray parent: self! !

!Lattice methodsFor: 'elements' stamp: 'len 7/29/2020 06:44:50'!
newFrom: anObject
"	(anObject isSequenceable and: [anObject size = self rank])
		ifTrue: [^ self elementAt: (self scalars tuple: anObject)]."
	^ super newFrom: anObject! !

!Lattice methodsFor: 'initialization' stamp: 'len 7/22/2021 18:48:14'!
basis: aCollection innerProduct: aBilinearForm
	(aBilinearForm space scalars =  or: [aBilinearForm space scalars isKindOf: RealField]) ifFalse: [^ self error: 'the ambient vector space of a lattice must be real or rational'].
	self propertyAt: #basis put: aCollection; propertyAt: #innerProduct put: aBilinearForm.
	self addCoercionTo: self space evaluating: [:each| each asVector]! !

!Lattice methodsFor: 'invariants' stamp: 'len 12/8/2017 18:41:52'!
coveringNormalizedThinkness
	"Answer the normalized thickness (or central density) of the covering."
	^ self coveringRadius ^ self rank / self fundamentalVolume! !

!Lattice methodsFor: 'invariants' stamp: 'len 12/28/2016 11:30:25'!
coveringRadius
	^ self propertyAt: #coveringRadius! !

!Lattice methodsFor: 'invariants' stamp: 'len 12/8/2017 18:42:18'!
coveringSphereVolume
	| n Vn pi p |
	pi _ Float pi.
	n _ self rank.
	Vn _ n even
		ifTrue: [pi ^ (n/2) / (n/2) factorial]
		ifFalse: [2^n * pi ^ ((n-1)/2) * ((n-1)/2) factorial / n factorial].
	p _ self coveringRadius.
	^ p ^ n * Vn! !

!Lattice methodsFor: 'invariants' stamp: 'len 12/8/2017 18:42:49'!
coveringThickness
	"Answer the thickness of the covering, i.e. the average number of spheres that contain a point of space. The thickness is also called the density or the sparsity of the covering."
	^ self coveringSphereVolume / self fundamentalVolume! !

!Lattice methodsFor: 'invariants' stamp: 'len 8/11/2020 08:01:58'!
determinant
	"The determinant det(L) of a lattice L is defined as the volume of its fundamental parallelepiped."
	self generatorMatrix isSquare ifTrue: [^ self generatorMatrix determinant abs].
	^ self gramian determinant sqrt! !

!Lattice methodsFor: 'invariants' stamp: 'len 8/11/2020 08:02:07'!
determinant2
	"The determinant det(L) of a lattice L is defined as the volume of its fundamental paralleleliped."
	| B |
	B _ self generatorMatrix.
	"B square means the lattice is full-rank:"
	^ B isSquare ifTrue: [B determinant abs] ifFalse: [(B transpose * B) determinant sqrt]! !

!Lattice methodsFor: 'invariants' stamp: 'len 12/10/2015 01:00'!
fundamentalParallelepiped
	^ self notYetImplemented! !

!Lattice methodsFor: 'invariants' stamp: 'len 3/19/2018 15:29:23'!
fundamentalVolume
	"Answer the volume of the fundamental region."
	^ self determinant sqrt! !

!Lattice methodsFor: 'invariants' stamp: 'len 12/8/2017 18:44:28'!
packingCenterDensity
	^ self packingRadius ^ self rank / self fundamentalVolume! !

!Lattice methodsFor: 'invariants' stamp: 'len 12/8/2017 18:44:07'!
packingDensity
	"Answer the density of the lattice packing, i.e. the volume of a sphere / the volume of the fundamental region."
	^ self packingSphereVolume / self fundamentalVolume! !

!Lattice methodsFor: 'invariants' stamp: 'len 12/28/2016 11:30:14'!
packingRadius
	^ self propertyAt: #packingRadius! !

!Lattice methodsFor: 'invariants' stamp: 'len 12/8/2017 18:43:48'!
packingSphereVolume
	| n Vn pi p |
	pi _ Float pi.
	n _ self rank.
	Vn _ n even
		ifTrue: [pi ^ (n/2) / (n/2) factorial]
		ifFalse: [2^n * pi ^ ((n-1)/2) * ((n-1)/2) factorial / n factorial].
	p _ self packingRadius.
	^ p ^ n * Vn! !

!Lattice methodsFor: 'morphisms' stamp: 'len 12/15/2021 13:01:24'!
to: aLattice evaluating: aBlock
	^ LatticeMap from: self to: aLattice matrix: (self asModule to: aLattice asModule evaluating: aBlock)! !

!Lattice methodsFor: 'operations' stamp: 'len 8/3/2020 07:30:24'!
* aScalar
	^ self class on: self innerProduct basis: self basis * (self space scalars !! aScalar)

"	^ self class gramian: self gramian * aScalar"! !

!Lattice methodsFor: 'operations' stamp: 'len 8/1/2020 21:34:57'!
+ aLattice
	"Answer the sum of the receiver and the argument, assuming they are compatible."
	^ self notYetImplemented! !

!Lattice methodsFor: 'operations' stamp: 'len 8/1/2020 21:34:30'!
/\ aLattice
	"Answer the intersection of the receiver and the argument, assuming they are compatible."
	^ self notYetImplemented! !

!Lattice methodsFor: 'operations' stamp: 'len 8/1/2020 19:08:46'!
 aLattice
	self notYetImplemented! !

!Lattice methodsFor: 'operations' stamp: 'len 8/1/2020 19:08:50'!
 aLattice
	self notYetImplemented! !

!Lattice methodsFor: 'operations' stamp: 'len 3/14/2021 12:47:15'!
dual
	"Answer the dual lattice of the receiver (or reciprocal lattice, or polar lattice).
	Given a lattice L, the dual lattice L* is defined as the lattice of vectors having integral inner product with all vectors of L."
	| B G |
	B _ self generatorMatrix.
	G _ self gramian.
	^ self class on: self innerProduct basis: ((B * G inverse) columns collect: [:each| self space elementAt: each])! !

!Lattice methodsFor: 'random' stamp: 'len 7/29/2020 06:21:59'!
atRandom: aRandom bits: bitSize
	^ self !! (self asModule atRandom: aRandom bits: bitSize)! !

!Lattice methodsFor: 'testing' stamp: 'len 7/29/2020 06:38:35'!
includes: anObject
	^ anObject parent == self! !

!Lattice methodsFor: 'testing' stamp: 'len 8/2/2020 17:11:36'!
isDoublyEven
	^ self isIntegral and: [self gramian diagonal allSatisfy: [:each| each asInteger \\ 4 = 0]]! !

!Lattice methodsFor: 'testing' stamp: 'len 7/17/2019 16:22:19'!
isEven
	^ self isIntegral and: [self gramian diagonal allSatisfy: [:each| each asInteger even]]! !

!Lattice methodsFor: 'testing' stamp: 'len 8/1/2020 10:19:33'!
isFullRank
	^ self rank = self length! !

!Lattice methodsFor: 'testing' stamp: 'len 8/1/2020 07:46:24'!
isIntegral
	"Answer true if the receiver is integral, i.e. if the inner product of any two lattice vectors is an integer. This is true iff the Gram matrix contains only integer entries. Equivalently, a lattice L is integral if and only if it is contained in its dual (or reciprocal) lattice L*: L <= L*. Also, an integral lattice L has the property: L <= L* <= L / det(L)."
	self gramian do: [:each| each isIntegral ifFalse: [^ false]].
	^ true! !

!Lattice methodsFor: 'testing' stamp: 'len 8/1/2020 08:06:40'!
isPositiveDefinite
	"Answer true if all x in the receiver L satisfy: <x,x> > 0."
	^ self innerProduct isPositiveDefinite "<- is this right? if is positive definite in the lattice it is always positive definite in the ambient vector space? also, aren't we defining all lattices as positive definite?"! !

!Lattice methodsFor: 'testing' stamp: 'len 12/8/2017 18:29:34'!
isRootLattice
	self isIntegral ifFalse: [^ false].
	self basis do: [:v| (self innerProduct value: v value: v) = 2 ifFalse: [^ false]].
	^ true! !

!Lattice methodsFor: 'testing' stamp: 'len 7/6/2021 14:04:41'!
isSelfDual
	"A self-dual lattice is a lattice L that equals its dual (or reciprocal) lattice L*: L = L*.
	A (integral) lattice is self-dual iff it is unimodular."
	^ self = self dual

"alternative:
	^ self isUnimodular
"! !

!Lattice methodsFor: 'testing' stamp: 'len 7/8/2020 08:41:48'!
isTrivial
	^ self basis isEmpty! !

!Lattice methodsFor: 'testing' stamp: 'len 8/1/2020 08:15:57'!
isTypeI
	^ self isUnimodular and: [self isEven not]! !

!Lattice methodsFor: 'testing' stamp: 'len 8/1/2020 08:15:46'!
isTypeII
	^ self isUnimodular and: [self isEven]! !

!Lattice methodsFor: 'testing' stamp: 'len 12/30/2015 21:51'!
isUnimodular
	^ self isIntegral and: [self determinant abs = 1]! !

!Lattice methodsFor: 'private' stamp: 'len 7/31/2020 11:42:31'!
species
	^ Lattice! !

!Lattice class methodsFor: 'examples' stamp: 'len 5/31/2020 20:34:03'!
A: n
	"Answer the lattice A_n = {(x0,...,xn) in Z^{n+1} : x0 + ... + xn = 0}."
	| V t B |
	V _ ^(n+1).
	t _ (V x: 2) - (V x: 1).
	B _ OrderedCollection new.
	n timesRepeat: [B add: t. t _ t >> 1].
	^ self basis: B! !

!Lattice class methodsFor: 'examples' stamp: 'len 7/8/2020 08:44:10'!
Adual: n
	"Answer the dual of A_n."
	| V B |
	V _ ^(n+1).
	B _ OrderedCollection new.
	1 to: n do: [:i| B add: (V x: 1) - (V x: i+1)].
	B add: (V filling: [:i| i=1 ifTrue: [n negated / (n+1)] ifFalse: [1 / (n+1)]]).
	^ self basis: B! !

!Lattice class methodsFor: 'examples' stamp: 'len 8/1/2020 19:06:12'!
D4
	"Another basis for the D4 lattice."
	| V |
	V _ ^4.
	^ self basis: {V !! (1,0,0,0). V !! (0,1,0,0). V !! (0,0,1,0). V !! (1,1,1,1) / 2}! !

!Lattice class methodsFor: 'examples' stamp: 'len 5/31/2020 20:35:11'!
D: n
	"Answer the checkboard lattice D_n = {(x1,...,xn) in Z^n : x0 + ... + xn is even}."
	| V t0 t B |
	V _ ^n.
	B _ OrderedCollection new.
	t0 _ ((V x: 1) + (V x: 2)) negated.
	B add: t0.
	t _ (V x: 1) - (V x: 2).
	n-1 timesRepeat: [B add: t. t _ t >> 1].
	^ self basis: B! !

!Lattice class methodsFor: 'examples' stamp: 'len 5/31/2020 20:35:48'!
Ddual: n
	"Answer the dual of D_n."
	| V B |
	V _ ^n.
	B _ OrderedCollection new.
	1 to: n-1 do: [:i| B add: (V x: i)].
	B add: (V filling: [:i| 1/2]).
	^ self basis: B! !

!Lattice class methodsFor: 'examples' stamp: 'len 5/31/2020 20:36:26'!
E8
	| V t0 t B answer |
	V _ ^8.
	B _ OrderedCollection new.
	t0 _ (V x: 1) * 2.
	B add: t0.
	t _ (V x: 2) - (V x: 1).
	6 timesRepeat: [B add: t. t _ t >> 1].
	B add: (V filling: [:i| 1/2]).
	answer _ self basis: B.
	answer properties
		at: #minimalNorm put: 2;
		at: #kissingNumber put: 240;
		at: #CoxeterNumber put: 30;
		at: #packingRadius put: 1/2 sqrt;
		at: #density put: Float pi ^ 4 / 384;
		at: #thickness put: Float pi ^ 4 / 24.
	^ answer! !

!Lattice class methodsFor: 'examples' stamp: 'len 5/23/2020 09:11:37'!
Z: n
	"Answer the n-dimensional cubic or integer lattice Z^n."
	^ self basis: ( ^ n) basis! !

!Lattice class methodsFor: 'examples' stamp: 'len 7/30/2020 18:18:23'!
bcc
	"Answer the body-centered cubic lattice (bcc).
	D*_3 is equivalent to bcc."
	| V |
	V _ ^3.
	^ self basis: {V !! (2,0,0). V !! (0,2,0). V !! (1,1,1)}! !

!Lattice class methodsFor: 'examples' stamp: 'len 7/30/2020 18:18:06'!
fcc
	"Answer the face-centered cubic lattice (fcc).
	Both A_3 and D_3 are equivalent to the fcc."
	| V |
	V _ ^3.
	^ self basis: {V !! (-1,-1,0). V !! (1,-1,0). V !! (0,1,-1)}! !

!Lattice class methodsFor: 'examples' stamp: 'len 6/1/2020 12:37:32'!
leech
	"The Leech lattice is the unique even unimodular lattice in R^24 with with no norm 2 vectors."
	| G answer |
	G _ (^24) endomorphisms !!
#(8 4 4 4 4 4 4 2 4 4 4 2 4 2 2 2 4 2 2 2 0 0 0 -3
 4 4 2 2 2 2 2 2 2 2 2 2 2 2 1 1 2 1 1 2 1 0 0 -1
 4 2 4 2 2 2 2 2 2 2 2 2 2 1 2 1 2 2 1 1 1 0 0 -1
 4 2 2 4 2 2 2 2 2 2 2 2 2 1 1 2 2 1 2 1 1 0 0 -1
 4 2 2 2 4 2 2 2 2 2 2 1 2 2 2 2 2 2 2 2 1 0 0 -1
 4 2 2 2 2 4 2 2 2 2 2 1 2 2 1 1 2 1 2 1 0 0 0 -1
 4 2 2 2 2 2 4 2 2 2 2 1 2 1 2 1 2 1 1 2 0 0 0 -1
 2 2 2 2 2 2 2 4 1 1 1 2 1 2 2 2 1 2 2 2 2 0 0 1
 4 2 2 2 2 2 2 1 4 2 2 2 2 2 2 2 2 2 2 2 1 1 1 -1
 4 2 2 2 2 2 2 1 2 4 2 2 2 2 1 1 2 2 1 1 0 1 0 -1
 4 2 2 2 2 2 2 1 2 2 4 2 2 1 2 1 2 1 2 1 0 0 1 -1
 2 2 2 2 1 1 1 2 2 2 2 4 1 2 2 2 1 2 2 2 2 1 1 1
 4 2 2 2 2 2 2 1 2 2 2 1 4 2 2 2 2 1 1 1 1 1 1 -1
 2 2 1 1 2 2 1 2 2 2 1 2 2 4 2 2 1 2 2 2 2 2 1 1
 2 1 2 1 2 1 2 2 2 1 2 2 2 2 4 2 1 2 2 2 2 1 2 1
 2 1 1 2 2 1 1 2 2 1 1 2 2 2 2 4 1 2 2 2 2 1 1 1
 4 2 2 2 2 2 2 1 2 2 2 1 2 1 1 1 4 2 2 2 1 1 1 -1
 2 1 2 1 2 1 1 2 2 2 1 2 1 2 2 2 2 4 2 2 2 2 1 1
 2 1 1 2 2 2 1 2 2 1 2 2 1 2 2 2 2 2 4 2 2 1 2 1
 2 2 1 1 2 1 2 2 2 1 1 2 1 2 2 2 2 2 2 4 2 1 1 1
 0 1 1 1 1 0 0 2 1 0 0 2 1 2 2 2 1 2 2 2 4 2 2 2
 0 0 0 0 0 0 0 0 1 1 0 1 1 2 1 1 1 2 1 1 2 4 2 2
 0 0 0 0 0 0 0 0 1 0 1 1 1 1 2 1 1 1 2 1 2 2 4 2
 -3 -1 -1 -1 -1 -1 -1 1 -1 -1 -1 1 -1 1 1 1 -1 1 1 1 2 2 2 4).
	answer _ self gramian: G.
	answer properties
		at: #minimalNorm put: 4;
		at: #kissingNumber put: 196560;
		at: #coveringRadius put: 2 sqrt.
	^ answer! !

!Lattice class methodsFor: 'examples' stamp: 'len 6/1/2020 12:37:55'!
leech2
	"Another version of the Leech lattice."
	| G answer |
	G _ (^24) endomorphisms !!
#(4 -2 -2 2 2 2 -1 -1 2 2 -2 2 -2 1 -1 1 1 2 0 -1 0 -2 -2 2
-2 4 0 0 -2 0 -1 2 0 0 2 -1 1 1 -1 1 -2 -2 -1 1 1 2 1 -2
-2 0 4 0 0 -2 0 0 0 0 2 0 0 -2 1 -1 -1 -1 1 -1 -1 1 0 -1
2 0 0 4 0 0 -2 -1 2 2 0 2 -2 1 0 2 -1 0 -1 0 1 -1 -1 0
2 -2 0 0 4 0 -1 -1 1 1 -1 1 -1 0 0 -1 0 2 0 -2 -2 -1 -2 2
2 0 -2 0 0 4 0 0 1 1 -1 1 -1 1 -1 1 1 0 1 0 1 0 -1 1
-1 -1 0 -2 -1 0 4 1 -1 -1 0 -2 2 0 0 0 2 -1 0 0 -1 1 2 -1
-1 2 0 -1 -1 0 1 4 1 1 2 -1 1 0 -1 1 -1 -1 -1 -1 -1 1 1 -1
2 0 0 2 1 1 -1 1 4 2 0 2 -2 1 0 1 -1 0 -1 -2 0 -1 -1 0
2 0 0 2 1 1 -1 1 2 4 0 1 -2 0 -1 1 -1 1 0 -1 -1 -1 -1 1
-2 2 2 0 -1 -1 0 2 0 0 4 0 1 -1 0 1 -1 -2 0 0 0 2 1 -2
2 -1 0 2 1 1 -2 -1 2 1 0 4 -2 0 1 0 0 1 0 -1 1 -2 -2 1
-2 1 0 -2 -1 -1 2 1 -2 -2 1 -2 4 0 -1 0 1 -1 -1 1 0 2 2 -2
1 1 -2 1 0 1 0 0 1 0 -1 0 0 4 -1 1 0 -1 -2 0 0 0 0 0
-1 -1 1 0 0 -1 0 -1 0 -1 0 1 -1 -1 4 -1 -1 0 0 0 0 -1 0 0
1 1 -1 2 -1 1 0 1 1 1 1 0 0 1 -1 4 0 -1 -1 0 1 1 0 -1
1 -2 -1 -1 0 1 2 -1 -1 -1 -1 0 1 0 -1 0 4 1 1 0 0 0 0 0
2 -2 -1 0 2 0 -1 -1 0 1 -2 1 -1 -1 0 -1 1 4 1 -1 -1 -2 -2 2
0 -1 1 -1 0 1 0 -1 -1 0 0 0 -1 -2 0 -1 1 1 4 0 0 0 -1 1
-1 1 -1 0 -2 0 0 -1 -2 -1 0 -1 1 0 0 0 0 -1 0 4 2 0 2 -1
0 1 -1 1 -2 1 -1 -1 0 -1 0 1 0 0 0 1 0 -1 0 2 4 0 1 -1
-2 2 1 -1 -1 0 1 1 -1 -1 2 -2 2 0 -1 1 0 -2 0 0 0 4 1 -2
-2 1 0 -1 -2 -1 2 1 -1 -1 1 -2 2 0 0 0 0 -2 -1 2 1 1 4 -2
2 -2 -1 0 2 1 -1 -1 0 1 -2 1 -2 0 0 -1 0 2 1 -1 -1 -2 -2 4).
	answer _ self gramian: G.
	answer properties
		at: #minimalNorm put: 4;
		at: #kissingNumber put: 196560;
		at: #coveringRadius put: 2 sqrt.
	^ answer! !

!Lattice class methodsFor: 'instance creation' stamp: 'len 3/21/2021 14:55:54'!
basis: aCollection
	^ self on: aCollection first parent innerProduct basis: aCollection! !

!Lattice class methodsFor: 'instance creation' stamp: 'len 8/1/2020 08:18:05'!
gramian: aMatrix
	"Answer the lattice with the given Gram matrix."
	| B |
	B _ BilinearForm on: aMatrix domain matrix: aMatrix.
	^ self on: B basis: B space basis! !

!Lattice class methodsFor: 'instance creation' stamp: 'len 7/28/2020 19:29:35'!
on: aBilinearForm basis: aCollection
	^ self new basis: aCollection innerProduct: aBilinearForm! !

!Ring methodsFor: 'accessing' stamp: 'len 4/26/2020 08:00:29'!
characteristic
	^ self propertyAt: #characteristic! !

!Ring methodsFor: 'accessing' stamp: 'len 3/16/2021 16:13:34'!
dimension
	"Answer the Krull dimension of the receiver.
	This is the length of the longest ascending chain of prime ideals."
	self isField ifTrue: [^ 0].
	self isPID ifTrue: [^ 1].
	self isIntegralDomain ifTrue: [^ 1].
	self isDedekindDomain ifTrue: [^ 1]. "<- because it's not a field"
	self isTrivial ifTrue: [^ -1].
	self isFinite ifTrue: [^ 0].
	^ self propertyAt: #dimension! !

!Ring methodsFor: 'accessing' stamp: 'len 5/23/2020 09:11:37'!
hilbertSeries
	"Answer the Hilbert series of the receiver expressed as a rational function in Q(t)."
	^ self hilbertSeriesAt: ( polynomialsIn: #(t)) fractions x! !

!Ring methodsFor: 'accessing' stamp: 'len 4/8/2021 12:38:55'!
maximalIdeal
	"If the receiver is a local ring, answer the unique maximal ideal."
	self isDivisionRing ifTrue: [^ self asIdeal null].
	self subclassResponsibility! !

!Ring methodsFor: 'accessing' stamp: 'len 3/19/2021 11:07:35'!
one
	^ self propertyAt: #one! !

!Ring methodsFor: 'accessing' stamp: 'len 5/23/2020 09:13:12'!
scalars
	"Because the ring of rational integers is the initial object in the category of rings.
	Subclasses can override."
	^ ! !

!Ring methodsFor: 'accessing' stamp: 'len 1/2/2022 10:10:03'!
uniformizer
	"If the receiver is a DVR, answer the uniformizer.
	A uniformizer (or uniformizing parameter, uniformizer element or prime element) is any irreducible element of a DVR, or equivalently a generator of the maximal ideal. All nonzero ideals are generated by some power of the uniformizer."
	self isDVR ifFalse: [^ self error: 'not a DVR'].
	^ self propertyAt: #uniformizer ifAbsentPut: [self maximalIdeal generator normalized]! !

!Ring methodsFor: 'accessing' stamp: 'len 4/26/2020 07:59:55'!
zero
	^ self propertyAt: #zero ifAbsentPut: [self one - self one]! !

!Ring methodsFor: 'categories' stamp: 'len 10/26/2020 10:41:24'!
Modules
	^ self propertyAt: #Modules ifAbsentPut: [Modules over: self]! !

!Ring methodsFor: 'comparing' stamp: 'len 8/10/2019 09:23:45'!
< aRing
	aRing isRing ifFalse: [^ false].
	(aRing isLocalization and: [self <= aRing integers]) ifTrue: [^ true].
	(aRing isCompletion and: [self <= aRing base]) ifTrue: [^ true].
	^ aRing scalars ~= aRing and: [self <= aRing scalars]! !

!Ring methodsFor: 'comparing' stamp: 'len 6/22/2019 03:36:22'!
<= aRing
	self = aRing ifTrue: [^ true].
	^ self < aRing! !

!Ring methodsFor: 'computing-matrices' stamp: 'len 1/7/2022 14:27:38'!
basisAndTransformationOf: aMatrix
	| E T |
	self hasEchelonization ifFalse: [^ self subclassResponsibility].
	T _ aMatrix coechelonization.
	E _ aMatrix coechelon copyWithoutZeroColumns.
	^ {E. T copyFromRow: 1 to: E width}! !

!Ring methodsFor: 'computing-matrices' stamp: 'len 1/13/2022 11:58:15'!
basisOf: aMatrix
	self hasEchelonization ifFalse: [^ self subclassResponsibility].
	^ aMatrix coechelon copyWithoutZeroColumns! !

!Ring methodsFor: 'computing-matrices' stamp: 'len 12/31/2021 08:20:36'!
cosyzygiesOf: aMatrix
	"Answer a matrix whose columns span the cokernel or left nullspace of the given matrix.
	For a matrix A, the output is X with XA = 0."
	self isCommutative ifTrue: [^ (self syzygiesOf: aMatrix transpose) transpose].
	self isInvolutive ifTrue: [^ (self syzygiesOf: aMatrix conjugate) conjugate].
	^ self subclassResponsibility! !

!Ring methodsFor: 'computing-matrices' stamp: 'len 12/30/2021 12:29:19'!
echelonOf: aMatrix
	| algorithmClass |
	algorithmClass _ self isField
		ifTrue: [GaussianElimination]
		ifFalse: [self isEuclideanDomain
			ifTrue: [HermiteReduction]
			ifFalse: ["self isIntegralDomain
				ifTrue: [GaussBareiss]
				ifFalse: ["self isPIR
					ifTrue: [HowellReduction]
					ifFalse: [^ self subclassResponsibility]]].
	^ (algorithmClass on: aMatrix) reduced! !

!Ring methodsFor: 'computing-matrices' stamp: 'len 12/31/2021 09:26:31'!
echelonizationOf: aMatrix
	| algorithmClass algorithm |
	algorithmClass _ self isField
		ifTrue: [GaussianElimination]
		ifFalse: [self isEuclideanDomain
			ifTrue: [HermiteReduction]
			ifFalse: ["self isIntegralDomain
				ifTrue: [GaussBareiss]
				ifFalse: ["self isPIR
					ifTrue: [HowellReduction]
					ifFalse: [^ self subclassResponsibility]]].
	algorithm _ algorithmClass on: aMatrix extension: aMatrix codomain id.
	^ {algorithm reduced. algorithm extension}! !

!Ring methodsFor: 'computing-matrices' stamp: 'len 1/1/2022 10:29:38'!
matrix: B codivisionBy: A
	"Answer N and X such that XA + N = B, satisfying that if the i-th row of B is a linear combination of the rows of A then the i-th row of N is zero."
	self isCommutative ifTrue: [^ (B transpose divisionBy: A transpose) collect: [:each| each transpose]].
	self isInvolutive ifTrue: [^ (B conjugate divisionBy: A conjugate) collect: [:each| each conjugate]].
	^ self subclassResponsibility! !

!Ring methodsFor: 'computing-matrices' stamp: 'len 12/31/2021 09:13:29'!
matrix: B divisionBy: A
	"Answer X and N such that AX + N = B, satisfying that if the i-th column of B is a linear combination of the columns of A then the i-th column of N is zero."
	"TODO: solve over localizations of euclidean domains"
	self isField ifTrue: [^ self matrixOverField: B divisionBy: A].
	self isEuclideanDomain ifTrue: [^ self matrixOverEuclideanDomain: B divisionBy: A].
	^ self subclassResponsibility! !

!Ring methodsFor: 'computing-matrices' stamp: 'len 1/6/2022 18:23:06'!
syzygiesOf: aMatrix
	"Answer a matrix whose rows span the kernel of the given matrix.
	For a matrix A, the output is X with AX = 0."
	self isLocalization ifTrue: [^ aMatrix numerator syzygies over: self].
	self isEuclideanDomain ifTrue: [^ self syzygiesOverEuclideanDomainOf: aMatrix].
	^ self subclassResponsibility! !

!Ring methodsFor: 'computing-matrices-private' stamp: 'len 1/7/2022 14:28:13'!
matrixOverEuclideanDomain: B divisionBy: A
	"Answer X and N such that AX + N = B, satisfying that if the i-th column of B is a linear combination of the columns of A then the i-th column of N is zero.
	This is based on [Mat11] but extended to work over any Euclidean domain and also to cover the case of B having more than 1 column.
	[Mat11] Keith Matthews, 'Solving AX=B using the Hermite normal form' (2011)"
	| X E T |
	X _ self^0 -> A domain.
	T _ A coechelonization.
	E _ A coechelon.
	B columnsDo: [:b| | G P n |
		G _ E  b.
		G _ G  (G domain x: G width).
		P _ G coechelonization.
		n _ P lastRow pivot.
		X _ X  (T * ((P columnAt: n) copyFrom: 1 to: A width) negated)].
	^ {X. B - (A*X)}

"I tried to solve the whole B at once but couldn't get it to work:
	G _ (A transpose - B transpose) - ((B domain => A domain) zero - B domain id).
	P _ G HNFAndTransformation second.
	n _ (P lastColumn findFirst: [:each| each isZero not]) - B width + 1.
	X _ (P copyFrom: n @ 1 to: n + B width - 1 @ A width) transpose negated.
	^ {A*X - B. X}"! !

!Ring methodsFor: 'computing-matrices-private' stamp: 'len 12/31/2021 14:11:12'!
matrixOverField: B divisionBy: A
	"Answer X and N such that AX + N = B, satisfying that if the i-th column of B is a linear combination of the columns of A then the i-th column of N is zero.
	The algorithm performs gaussian elimination in essentially O(n^3) scalar operations.
	It is can produce coefficient explosion unless the scalar field is finite."
"	| T E X |
	T _ A coechelonization.
	E _ A coechelon.
	X _ Matrix to: A domain columns: (B columns collect: [:each| T * (T domain !! (each // E columns))]).
	^ {X. B - (A*X)}
"
	| E X n |
"	A isSquare ifTrue: [	X _ A coechelonization * B. ^ {X. B - (A*X)}]."
	E _ (A  B) echelon.
	n _ A width.
	X _ B domain -> (self^0).
	E pivotsDo: [:each|
		each y <= n ifTrue:
			[each y - 1 - X height timesRepeat: [X _ X  B domain zero].
			X _ X  ((E rowAt: each x) copyFrom: n+1 to: E width)]].
	A width - X height timesRepeat: [X _ X  B domain zero].
	^ {X. B - (A*X)}


"alternative:
	| reduction rows X |
	reduction _ A reductionWith: B.
	rows _ OrderedCollection new.
	reduction independentColumns withIndexDo: [:column :i|
		column - 1 - rows size timesRepeat: [rows add: B domain zero].
		rows add: (reduction extension rowAt: i)].
	A width - rows size timesRepeat: [rows add: B domain zero].
	X _ Matrix from: B domain rows: rows.
	^ {A*X - B. X}"! !

!Ring methodsFor: 'computing-matrices-private' stamp: 'len 1/7/2022 14:28:21'!
syzygiesOverEuclideanDomainOf: aMatrix
	| E T |
	T _ aMatrix coechelonization.
	E _ aMatrix coechelon.
	^ Matrix to: aMatrix domain columns: (((1 to: E width) select: [:i| (E columnAt: i) isZero]) collect: [:i| T columnAt: i])

"alternative:
	""Reduce the augmented matrix [A^t | I], then a linear basis of the kernel is given by the rows of the extension corresponding to zero rows in the reduced matrix.""
	| n E |
	n _ aMatrix height.
	E _ (aMatrix transpose  aMatrix domain id) echelon.
	^ Matrix to: aMatrix domain columns: (E rows select: [:each| each isZeroFrom: 1 to: n]  thenCollect: [:each| aMatrix domain filling: [:i| each at: n+i]])
"

"alternative2:
	reduction _ aMatrix transpose reductionWith: aMatrix domain id.
	kernel _ OrderedCollection new.
	reduction reduced rows withIndexDo: [:row :i|
		row isZero ifTrue: [kernel add: (reduction extension rowAt: i)]].
	^ Matrix to: aMatrix domain columns: kernel"! !

!Ring methodsFor: 'computing-polynomials' stamp: 'len 8/5/2021 08:42:54'!
allRootsOf: aPolynomial
	"Answer the roots (counted with multiplicity) of aPolynomial in the receiver."
	| answer |
	self isUFD ifFalse: [^ self subclassResponsibility].
	answer _ Bag new.
	(aPolynomial over: self) factorization withOccurrencesDo: [:f :e|
			f degree = 1 ifTrue: [answer add: (f independentCoefficient negated / f leadingCoefficient) withOccurrences: e]].
	^ answer! !

!Ring methodsFor: 'computing-polynomials' stamp: 'len 7/13/2021 14:52:21'!
anyRootOf: aPolynomial
	^ (self rootsOf: aPolynomial) anyOne! !

!Ring methodsFor: 'computing-polynomials' stamp: 'len 7/15/2021 16:05:26'!
factorizationOf: aPolynomial
	self isFiniteField ifTrue: [^ self factorizationOverFiniteFieldOf: aPolynomial].
	^ self subclassResponsibility! !

!Ring methodsFor: 'computing-polynomials' stamp: 'len 7/13/2021 14:54:05'!
rootsOf: aPolynomial
	"Answer the distinct roots (not counted with multiplicity) of aPolynomial in the receiver."
	^ (self allRootsOf: aPolynomial) asSet! !

!Ring methodsFor: 'computing-polynomials' stamp: 'len 1/9/2022 08:37:27'!
squarefreeFactorizationOf: aPolynomial
	self isFiniteField ifTrue: [^ aPolynomial squarefreeFactorizationFiniteField].
	self characteristic > 0 "finite ring" ifTrue: [^ self notYetImplemented].
	self isField ifTrue: [^ aPolynomial squarefreeFactorizationYun].
	self isUFD ifFalse: [^ self notYetImplemented].
	^ (aPolynomial primitivePart over: self fractions) squarefreeFactorizationYun apply: [:each| aPolynomial parent !! each integerPrimitivePart]! !

!Ring methodsFor: 'computing-polynomials-private' stamp: 'len 1/9/2022 08:36:02'!
factorizationOverFiniteFieldOf: aPolynomial
	| answer |
	answer _ Bag new.
	aPolynomial normalized squarefreeFactorization withOccurrencesDo: [:f :r|
		f distinctDegreeFactorization keysAndValuesDo: [:d :g|
			(g equalDegreeFactorization: d) do: [:each| answer add: each withOccurrences: r]]].
	^ answer! !

!Ring methodsFor: 'converting' stamp: 'len 4/30/2021 13:13:58'!
asAbelianGroup
	"Answer the receiver as a -module."
	self scalars =  ifFalse: [^ DomainError signal].
	^ self asModule! !

!Ring methodsFor: 'converting' stamp: 'len 12/15/2021 15:22:26'!
asIdeal
	"Answer the receiver R viewed as R-module (as the unit ideal)."
	^ self propertyAt: #asIdeal ifAbsentPut: [self idealClass new generatorMatrix: (self^1) id]! !

!Ring methodsFor: 'converting' stamp: 'len 4/30/2021 13:11:38'!
asModule
	^ self subclassResponsibility! !

!Ring methodsFor: 'converting' stamp: 'len 4/30/2021 13:09:12'!
asVectorSpace
	self scalars isField ifFalse: [^ DomainError signal].
	^ self asModule! !

!Ring methodsFor: 'elements' stamp: 'len 8/7/2019 17:49:30'!
!! anObject
	(anObject isKindOf: Ideal) ifTrue: [^ self * (anObject generators collect: [:each| self !! each])].
	^ super !! anObject! !

!Ring methodsFor: 'elements' stamp: 'len 3/4/2021 18:16:10'!
adapt: anElement
	anElement isInteger ifTrue: [^ self one * anElement].
	anElement isFraction ifTrue:
		[anElement isIntegral ifTrue: [^ self one * anElement asInteger].
		(self isField and: [self characteristic = 0])
			ifTrue: [^ (self one * anElement numerator) / (self one * anElement denominator)]].
	^ super adapt: anElement! !

!Ring methodsFor: 'elements' stamp: 'len 4/4/2018 00:03:12'!
matrix: aCollection
	^ Matrix rows: (aCollection collect: [:each| self tuple: each])! !

!Ring methodsFor: 'elements' stamp: 'len 12/18/2021 20:26:52'!
matrix: shape filling: aBlock
	| n m |
	shape isInteger ifTrue: [n _ m _ shape] ifFalse: [n _ shape x. m _ shape y].
	^ self^m to: self^n filling: aBlock! !

!Ring methodsFor: 'elements' stamp: 'len 5/3/2020 07:42:35'!
newFrom: anObject
	anObject isFraction ifTrue: [^ (self one * anObject numerator) * (self one * anObject denominator) inverse].
	^ super newFrom: anObject! !

!Ring methodsFor: 'elements' stamp: 'len 5/28/2020 18:19:10'!
tuple: anArray
	(anArray isTuple and: [anArray scalars == self]) ifTrue: [^ anArray].
	^ (self ^ anArray size) elementAt: anArray! !

!Ring methodsFor: 'enumerating' stamp: 'len 9/22/2018 18:58:55'!
idealsDo: aBlock
	^ self subclassResponsibility! !

!Ring methodsFor: 'enumerating' stamp: 'len 4/8/2021 12:39:23'!
primeIdealsDo: aBlock
	self isField ifTrue: [aBlock value: self asIdeal null. ^ self].
	self isDVR ifTrue: [aBlock value: self asIdeal null; value: self maximalIdeal. ^ self].
	self idealsDo: [:each| each isPrime ifTrue: [aBlock value: each]]! !

!Ring methodsFor: 'enumerating' stamp: 'len 5/4/2020 10:08:39'!
unitsDo: aBlock
	self do: [:each| each isUnit ifTrue: [aBlock value: each]]! !

!Ring methodsFor: 'morphisms' stamp: 'len 10/18/2016 19:49'!
conjugation
	"Answer the companion automorphism of the receiver."
	^ self id! !

!Ring methodsFor: 'morphisms' stamp: 'len 4/26/2021 10:37:55'!
frobenius
	"Answer the Frobenius endomorphism, assuming the receiver is of characteristic p prime."
	^ self to: self evaluating: self polynomials x ^ self characteristic! !

!Ring methodsFor: 'morphisms' stamp: 'len 12/22/2021 15:02:47'!
to: aCodomain
	(aCodomain isRing and: [aCodomain isTrivial]) ifTrue: [^ self to: aCodomain evaluating: [:x| aCodomain zero]].
	^ super to: aCodomain! !

!Ring methodsFor: 'morphisms' stamp: 'len 7/5/2021 12:55:21'!
to: aRing evaluating: aBlock
	aRing isRing ifFalse: [^ DomainError signal].
"	(self isTrivial or: [(self characteristic = 0 and: [aRing characteristic = 0]) or: [aRing characteristic | self characteristic]]) ifFalse: [DomainError signal]."
	^ RingMap from: self to: aRing evaluating: aBlock! !

!Ring methodsFor: 'operations' stamp: 'len 12/25/2021 12:42:23'!
* anObject
	"If the argument is an element or a collection of elements, answer the ideal generated by the argument. Note that in the case of noncommutative rings the notation is backwards because it answers a right ideal.
	If the argument is an algebra, answer the free product of the receiver with the argument (this is the coproduct in the category of R-algebras)."
	(anObject isKindOf: Ring) ifTrue: [^ self notYetImplemented]. "free product"
	(self includes: anObject)
		ifTrue: [^ self asIdeal span: {anObject}].
	anObject isCollection
		ifTrue: [^ self asIdeal span: anObject].
	^ self * (self !! anObject)! !

!Ring methodsFor: 'operations' stamp: 'len 12/19/2021 20:08:12'!
/ anIdeal
	"Answer the quotient by the given ideal.
	For convenience, the argument can be a single element or a collection of elements as well."
	(anIdeal isKindOf: Ideal) ifFalse: [^ self / (self * anIdeal)].
	self isCommutative ifFalse: [^ self subclassResponsibility].
	self assert: self = anIdeal scalars.
	anIdeal isTrivial ifTrue: [^ self].
	^ QuotientRing relations: anIdeal! !

!Ring methodsFor: 'operations' stamp: 'len 12/22/2021 14:16:10'!
@ aPrimeIdeal
	"Answer the localization of the receiver at aPrimeIdeal."
	| P |
	self isCommutative ifFalse: [^ self error: 'not a commutative ring'].
	P _ (aPrimeIdeal isKindOf: Ideal)
		ifTrue:
			[self = aPrimeIdeal scalars ifFalse: [self error: 'ideal belongs to a different ring'].
			aPrimeIdeal]
		ifFalse:
			[self * aPrimeIdeal].
	(P isTrivial and: [self isIntegralDomain]) ifTrue: [^ self fractions].
	^ LocalRing at: P! !

!Ring methodsFor: 'operations' stamp: 'len 12/25/2021 10:13:02'!
^ anIntegerOrCollection
	^ FreeModule new: anIntegerOrCollection over: self
"
	^ (self propertyAt: #freeModules ifAbsentPut: [Dictionary new])
		at: anIntegerOrCollection ifAbsentPut: [FreeModule new: anIntegerOrCollection over: self]"! !

!Ring methodsFor: 'operations' stamp: 'len 7/5/2021 13:02:03'!
 aRing
	self assert: aRing isRing.
	^ ProductRing components: {self. aRing}! !

!Ring methodsFor: 'operations' stamp: 'len 7/6/2021 14:08:40'!
 aRing
	"Answer the direct sum of the receiver with the argument."
	^ self  aRing! !

!Ring methodsFor: 'operations' stamp: 'len 1/12/2022 18:04:41'!
algebraicClosure
	self isAlgebraicallyClosed ifTrue: [^ self].
	^ self subclassResponsibility! !

!Ring methodsFor: 'operations' stamp: 'len 5/1/2021 11:46:02'!
center
	"Answer the subalgebra whose memebers are the elements that commute and associate with all the other elements."
	^ self centralizerOf: self! !

!Ring methodsFor: 'operations' stamp: 'len 12/18/2021 11:45:36'!
completion
	"If the receiver is a local ring A with maximal ideal I, answer the I-adic completion of A, i.e. the inverse limit of A / I^n."
	self assert: self isLocal.
	self isField ifTrue: [^ self]. "because the maximal ideal is {0}"
	^ self completionAt: self maximalIdeal! !

!Ring methodsFor: 'operations' stamp: 'len 12/18/2021 11:41:16'!
completionAt: aMaximalIdeal
	"If the receiver is a commutative ring A and the argument is the maximal ideal I, answer the I-adic completion of A, i.e. the inverse limit of A / I^n."
	| P |
	P _ (self polynomialsIn: aMaximalIdeal generators size) completion.
	^ P / (aMaximalIdeal generators withIndexCollect: [:each :i| (P x: i) - each])! !

!Ring methodsFor: 'operations' stamp: 'len 12/2/2016 11:13:43'!
cyclotomicRing: n
	"Answer the n-th cyclotomic ring on the receiver."
	| Fx phi |
	Fx _ self polynomials.
	phi _ Fx cyclotomic: n. "cyclotomic polynomial of order n"
	^ Fx / phi "answer the quotient ring modulo <phi>"! !

!Ring methodsFor: 'operations' stamp: 'len 7/16/2021 11:20:13'!
extension: aPolynomial
	"Answer the algebraic extension of the receiver defined by the given irreducible polynomial."
	aPolynomial scalars = self ifFalse: [self error: 'polynomial coefficients not from this ring'].
	aPolynomial parent isUnivariate ifFalse: [DomainError signal: 'not univariate poylnomial'].
	^ self extensionClass modulus: aPolynomial! !

!Ring methodsFor: 'operations' stamp: 'len 10/31/2016 05:46'!
extensionDegree: anInteger
	"Answer the algebraic extension of the receiver of the given degree. Choose any irreducible polynomial."
	^ self extension: (self polynomials findIrreducibleOfDegree: anInteger)! !

!Ring methodsFor: 'operations' stamp: 'len 1/2/2022 10:15:58'!
fractions
	"Answer the total ring of fractions of the receiver. If the receiver is an integral domain, the fraction ring will be a field. If the receiver is a finite rings, it is its own total ring of fractions, because an element in a finite ring is either a zerodivisor or a unit."
	^ self propertyAt: #fractions ifAbsentPut:
		[self isCommutative ifFalse: [^ self error: 'not a commutative ring'].
		(self isField or: [self isFinite]) ifTrue: [self] ifFalse: [FractionRing on: self]]! !

!Ring methodsFor: 'operations' stamp: 'len 1/20/2016 13:42'!
freeAlgebra
	^ FreeAlgebra over: self! !

!Ring methodsFor: 'operations' stamp: 'len 5/11/2019 02:42:50'!
freeAlgebraIn: anIntegerOrCollection
	"Answer the free algebra in the given indeterminates over the receiver."
	anIntegerOrCollection isInteger ifTrue: [^ FreeAlgebra new: anIntegerOrCollection over: self].
	^ (FreeAlgebra new: anIntegerOrCollection size over: self) names: anIntegerOrCollection! !

!Ring methodsFor: 'operations' stamp: 'len 4/30/2019 04:17:37'!
ideals
	^ Iterator on: self performing: #idealsDo:! !

!Ring methodsFor: 'operations' stamp: 'len 5/10/2020 10:13:24'!
irreducibles
	^ self select: [:each| each isIrreducible]! !

!Ring methodsFor: 'operations' stamp: 'len 8/4/2019 12:19:31'!
localizationAwayFrom: aPrimeElement
	"Answer the localization of the receiver away from aPrimeElement, i.e. a new ring where aPrimeElement is invertible."
	| P L |
	P _ self polynomials.
	L _ P / (P x * aPrimeElement - P one).
	"F _ self fractions.
	L addMap: (L into: F evaluating: [:f| F numerator: f numerator denominator: f denominator])." "<- add also retraction"
	^ L! !

!Ring methodsFor: 'operations' stamp: 'len 4/8/2021 12:39:09'!
nilradical
	"Answer the ideal consisting of all nilpotent elements, i.e. all x such that there exists some n with x^n = 0. It is the intersection of all prime ideals. (See also >>radical.)"
	^ self asIdeal null radical
	
"alternative:
	| answer |
	answer _ self oneIdeal.
	self primeIdealsDo: [:each| answer _ answer /\ each].
	^ answer"! !

!Ring methodsFor: 'operations' stamp: 'len 12/20/2021 12:02:03'!
opposite
	(self isCommutative or: [self isInvolutive]) ifTrue: [^ self].
	^ self propertyAt: #opposite ifAbsentPut: [OppositeRing opposite: self]! !

!Ring methodsFor: 'operations' stamp: 'len 5/15/2019 01:11:18'!
polynomials
	^ self polynomialsIn: #(x)! !

!Ring methodsFor: 'operations' stamp: 'len 2/12/2017 06:07:46'!
polynomialsIn: anIntegerOrCollection
	"Answer the ring of multivariate polynomials over the receiver in the given indeterminates."
	^ self polynomialsIn: anIntegerOrCollection ordering: #grevlex! !

!Ring methodsFor: 'operations' stamp: 'len 7/23/2021 10:49:12'!
polynomialsIn: anIntegerOrCollection ordering: aMonomialOrdering
	"Answer the ring of multivariate polynomials over the receiver over the given indeterminates."
	self isCommutative ifFalse: [^ self error: 'not a commutative ring'].
	anIntegerOrCollection isInteger
		ifTrue: [^ PolynomialRing new: anIntegerOrCollection over: self ordering: aMonomialOrdering].
	^ (PolynomialRing new: anIntegerOrCollection size over: self ordering: aMonomialOrdering) names: anIntegerOrCollection! !

!Ring methodsFor: 'operations' stamp: 'len 6/2/2019 16:57:27'!
powerSeries
	^ self polynomials completion! !

!Ring methodsFor: 'operations' stamp: 'len 8/9/2019 11:52:35'!
powerSeriesIn: anIntegerOrCollection
	"Answer the ring of multivariate formal power series over the receiver in the given indeterminates."
	^ (self polynomialsIn: anIntegerOrCollection) completion! !

!Ring methodsFor: 'operations' stamp: 'len 7/5/2019 15:22:18'!
primeIdeals
	^ Iterator on: self performing: #primeIdealsDo:! !

!Ring methodsFor: 'operations' stamp: 'len 5/10/2020 10:13:57'!
primes
	^ self select: [:each| each isPrime]! !

!Ring methodsFor: 'operations' stamp: 'len 12/20/2021 13:48:25'!
proj
	"This is the Proj functor. Answer the homogeneous prime spectrum of the receiver as a scheme."
	self assert: self isCommutative.
	^ self propertyAt: #proj ifAbsentPut: [ProjectiveScheme coordinateRing: self]! !

!Ring methodsFor: 'operations' stamp: 'len 7/5/2021 13:00:20'!
radical
	"Answer the Jacobson radical J(R) of the receiver R. This is the ideal consisting of all elements that annihilate all simple R-modules. It is the intersection of all maximal ideals. In a local ring, it is equal to the set of non-invertible elements, i.e. the maximal ideal. (See also >>nilradical.)"
	| generators one |
	self isLocal ifTrue: [^ self maximalIdeal].
	self isFinite ifFalse: [^ self notYetImplemented].
	generators _ Set new.
	one _ self one.
	self do: [:x| (self allSatisfy: [:y| (one - (x*y)) isUnit]) ifTrue: [generators add: x]].
	^ self * generators

"alternative:
	| answer |
	answer _ self oneIdeal.
	self maximalIdealsDo: [:each| answer _ answer /\ each].
	^ answer"! !

!Ring methodsFor: 'operations' stamp: 'len 6/27/2019 11:14:42'!
reduced
	"Answer the associated reduced ring. This is the quotient by the ideal of all nilpotent elements (the nilradical)."
	^ self / self nilradical! !

!Ring methodsFor: 'operations' stamp: 'len 5/10/2020 10:14:32'!
reducibles
	^ self select: [:each| each isReducible]! !

!Ring methodsFor: 'operations' stamp: 'len 12/19/2021 19:52:34'!
residueField
	"If the receiver is a local ring R with unique maximal ideal M, this returns R/M."
	^ self / self maximalIdeal! !

!Ring methodsFor: 'operations' stamp: 'len 12/11/2021 19:12:19'!
spec
	"This is the Spec functor. Answer the spectrum of the receiver as an affine scheme."
	self assert: self isCommutative.
	^ self propertyAt: #spec ifAbsentPut: [AffineScheme coordinateRing: self]! !

!Ring methodsFor: 'operations' stamp: 'len 5/2/2019 08:03:00'!
units
	"Answer the multiplicative group of units of the receiver (i.e., elements that have multiplicative inverse).
	This is the natural functor from the cateogry of rings to the category of groups which sends each ring R to its group of units U(R) and each ring homomorphism to the restriction to U(R). This functor has a left adjoint which sends each group G to the integral group ring Z[G]."
	^ UnitGroup on: self! !

!Ring methodsFor: 'operations' stamp: 'len 1/6/2022 09:26:01'!
zerodivisors
	^ self select: [:each| each isZerodivisor]! !

!Ring methodsFor: 'random' stamp: 'len 5/1/2021 12:28:28'!
atRandom: aRandom modulo: anIdeal
	^self subclassResponsibility! !

!Ring methodsFor: 'testing' stamp: 'len 12/30/2021 11:48:03'!
hasCanonicalAssociates
	"Answer true if this ring is equipped with an algorithm to make a canonical choice of associate for each element.
	See RingElement>>#normalized."
	^ self isPID! !

!Ring methodsFor: 'testing' stamp: 'len 1/9/2022 09:46:34'!
hasCanonicalBases
	"Answer true if there's an algorithm to compute canonical bases for modules over the receiver."
	^ self hasEchelonization! !

!Ring methodsFor: 'testing' stamp: 'len 12/31/2021 11:53:39'!
hasEchelonization
	"Answer true if matrices over the receiver can be put into echelon form or an analoge normal form."
	^ self isField or: [self isPID "should be isPIR" and: [self isEuclidean]]! !

!Ring methodsFor: 'testing' stamp: 'len 1/12/2022 18:06:48'!
isAlgebraicallyClosed
	^ false "undefined"! !

!Ring methodsFor: 'testing' stamp: 'len 5/3/2021 18:37:05'!
isAlternative
	^ self subclassResponsibility! !

!Ring methodsFor: 'testing' stamp: 'len 4/21/2021 12:42:25'!
isApproximate
	"Answer true if the receiver is not exact, i.e. the elements of the receiver are represented as approximations with limited precision.
	Examples of approximate rings include completions such as the real numbers (see RealField), power series (see PowerSeriesRing and LaurentSeriesRing) and p-adic numbers (see AdicRing and AdicField)."
	^ false! !

!Ring methodsFor: 'testing' stamp: 'len 1/2/2022 10:14:15'!
isArtinian
	"A ring is called Artinian if it satisfies the descending chain condition on ideals.
	In the noncommutative case, one should talk about 'left Artinian' or 'right Artinian' rings."
	self isFinite ifTrue: [^ true].
	self isIntegralDomain ifTrue: [^ self isField].
	^ self isNoetherian and: [self dimension = 0]! !

!Ring methodsFor: 'testing' stamp: 'len 1/12/2022 17:54:14'!
isBezout
	"Answer true if the receiver is a Bezout ring, i.e. every finitely generated ideal is principal."
	self isEuclidean ifTrue: [^ true]. "every Euclidean ring is PIR, i.e. it is Bezout and Noetherian"
"	self isPIR ifTrue: [^ true]. <- could be recursive"
	^ false "undefined"! !

!Ring methodsFor: 'testing' stamp: 'len 6/4/2019 15:27:20'!
isBezoutDomain
	"An integral domain is Bezout if any finitely generated ideal is principal.
	This is the constructive algebra approximation to PID, adding 'finitely generated'.
	1) Any Bezout domain is coherent;
	2) A Bezout domain is strongly discrete iff we can decide divisibility."
	self isEuclideanDomain ifTrue: [^ true].
	^ self isIntegralDomain and: [self isBezout]! !

!Ring methodsFor: 'testing' stamp: 'len 4/27/2021 15:49:27'!
isCommutative
	^ self subclassResponsibility! !

!Ring methodsFor: 'testing' stamp: 'len 6/22/2019 03:11:32'!
isCompletion
	^ false! !

!Ring methodsFor: 'testing' stamp: 'len 5/2/2020 21:31:42'!
isComplex
	^ false! !

!Ring methodsFor: 'testing' stamp: 'len 5/2/2021 11:29:36'!
isCompositionAlgebra
	"A 'composition algebra' is a not necessarily associative algebra together with a nondegenerate quadratic form N (the 'norm') that satisfies N(xy) = N(x)N(y). A composition algebra is also an involutive algebra and comes with an involution (called 'conjugation') where N(x) is the product of x by its conjugate."
	^ self subclassResponsibility! !

!Ring methodsFor: 'testing' stamp: 'len 8/7/2019 12:33:03'!
isDVR
	"Answer true if the receiver is a discrete valuation ring, i.e. a local PID that is not a field.
	Equivalently, a DVR is a Noetherian local domain whose maximal ideal is principal and different from {0}."
	^ self isLocal and: [self isPID and: [self isField not]]! !

!Ring methodsFor: 'testing' stamp: 'len 1/12/2022 17:54:34'!
isDedekindDomain
	"A Dedekind domain is an integral domain in which every nonzero proper ideal factors into a product of prime ideals."
	self isPID ifTrue: [^ true].
	^ false "undefined"! !

!Ring methodsFor: 'testing' stamp: 'len 1/12/2022 18:07:56'!
isDivisionRing
	"A division ring, or skewfield, is a ring where division is possible, i.e. every nonzero element has a multiplicative inverse. The only difference with a field is that a division ring is not requiered to be commutative."
	self isField ifTrue: [^ true].
	^ false "undefined"! !

!Ring methodsFor: 'testing' stamp: 'len 1/12/2022 18:08:27'!
isEuclidean
	"Answer true if the receiver is a Euclidean ring, i.e. it has Euclidean division with remainder."
	self isField ifTrue: [^ true].
	^ false "undefined"! !

!Ring methodsFor: 'testing' stamp: 'len 5/8/2020 18:21:38'!
isEuclideanDomain
	"Answer true if the receiver is a Euclidean domain, i.e. an integral domain that has division with remainder."
	^ self isIntegralDomain and: [self isEuclidean]! !

!Ring methodsFor: 'testing' stamp: 'len 1/12/2022 18:09:02'!
isField
	^ false "undefined"! !

!Ring methodsFor: 'testing' stamp: 'len 7/15/2021 16:07:41'!
isFiniteField
	^ self isFinite and: [self isField]! !

!Ring methodsFor: 'testing' stamp: 'len 9/19/2018 07:15:55'!
isGaloisRing
	^ false! !

!Ring methodsFor: 'testing' stamp: 'len 1/26/2018 18:58:30'!
isGlobalField
	^ false! !

!Ring methodsFor: 'testing' stamp: 'len 1/6/2022 09:23:36'!
isIntegralDomain
	"A ring is an integral domain if the product of any two nonzero elements is nonzero."
	self propertyAt: #isIntegralDomain ifPresent: [:aBoolean| ^ aBoolean].
	self isCommutative ifFalse: [^ false].
	self isFinite ifTrue: [^ self propertyAt: #isIntegralDomain put: (self zerodivisors allSatisfy: [:each| each isZero])].
	^ self isField! !

!Ring methodsFor: 'testing' stamp: 'len 1/12/2022 18:09:28'!
isIntegrallyClosedDomain
	"A ring is an integrally closed domain if it is an integral domain whose integral closure in its field of fractions is the ring itself."
	self isUFD ifTrue: [^ true].
	^ false "undefined"! !

!Ring methodsFor: 'testing' stamp: 'len 7/25/2021 10:08:44'!
isInvolutive
	"Answer true if the receiver is a *-ring (or involutive ring), i.e. it has an involution that is an antiautomorphism.
	Elements of involutive rings must implement the involution with the message #conjugate."
	^ false! !

!Ring methodsFor: 'testing' stamp: 'len 5/20/2018 21:57:40'!
isLocal
	"Answer true if the receiver is a local ring. Subclasses should reimplement."
	^ self isDivisionRing! !

!Ring methodsFor: 'testing' stamp: 'len 1/26/2018 18:58:19'!
isLocalField
	^ false! !

!Ring methodsFor: 'testing' stamp: 'len 8/6/2019 18:08:24'!
isLocalization
	"Answer true if the receiver is a localization of a ring (a ring of fractions, a localization at a prime ideal, etc).
	This means that elements of the receiver are formal fractions."
	^ false! !

!Ring methodsFor: 'testing' stamp: 'len 7/27/2021 11:38:22'!
isMultivariate
	^ false! !

!Ring methodsFor: 'testing' stamp: 'len 1/12/2022 17:54:03'!
isNoetherian
	"A ring is called Noetherian if every ideal is finitely generated.
	This is equivalent to the ring satisfying the ascending chain condition (every ascending chain of ideals is finite), and it is also equivalent to the condition that any set of ideals contains a maximal element."
	self isFinite ifTrue: [^ true].
"	self isField ifTrue: [^ true]. already included in isPID"
	self isEuclidean ifTrue: [^ true]. "every Euclidean ring is PIR, i.e. it is Bezout and Noetherian"
	self isPID ifTrue: [^ true].
	self isDedekindDomain ifTrue: [^ true].
	^ false "undefined"! !

!Ring methodsFor: 'testing' stamp: 'len 1/12/2022 18:10:10'!
isPID
	"A principal ideal domain (PID) is an integral domain in which every ideal is principal, i.e. can be generated by a single element.
	PIDs are Noetherian, integrally closed, and they are UFDs and Dedekind domains.
	All Euclidean domains and all fields are PIDs."
	self isEuclideanDomain ifTrue: [^ true].
	self isIntegralDomain ifFalse: [^ false].
	^ false "undefined"! !

!Ring methodsFor: 'testing' stamp: 'len 6/16/2019 14:05:16'!
isPIR
	"A principal ideal ring (PIR) is a ring in which every ideal is principal, i.e. can be generated by a single element.
	In a PIR any two nonzero elements have a well-defined GCD."
	"Principal ideal rings are exactly the rings that are both Bezout and Noetherian:"
	^ self isBezout and: [self isNoetherian]! !

!Ring methodsFor: 'testing' stamp: 'len 1/12/2022 17:54:50'!
isPerfectField
	"A field is perfect if either it has characteristic 0 or has characteristic p and every element in the field has a p-th root in the field."
	self isField ifFalse: [^ false].
	(self characteristic = 0 or: [self isFinite]) ifTrue: [^ true].
	self isAlgebraicallyClosed ifTrue: [^ true].
	^ false "undefined"! !

!Ring methodsFor: 'testing' stamp: 'len 4/12/2021 14:53:51'!
isQuotient
	"Answer true if the receiver is a quotient ring R/I."
	^ false! !

!Ring methodsFor: 'testing' stamp: 'len 8/9/2020 07:59:51'!
isReal
	"Answer true if the receiver is a subring of the real field."
	^ false! !

!Ring methodsFor: 'testing' stamp: 'len 1/2/2022 10:09:45'!
isReduced
	"A ring is called 'reduced' if it has no nonzero nilpotents, i.e. if r^n = 0 for some n >> 0, then r = 0. In other words, its nilradical is trivial."
	self isIntegralDomain ifTrue: [^ true].
	^ self noneSatisfy: [:any| any squared isZero and: [any isZero not]]
	
"alternatively:
	^ self nilradical isZero"! !

!Ring methodsFor: 'testing' stamp: 'len 7/5/2021 12:16:28'!
isRing
	^ true! !

!Ring methodsFor: 'testing' stamp: 'len 1/12/2022 17:55:07'!
isSemilocal
	"A ring is called 'semilocal' if it contains a finite number of maximal ideals."
	self isFinite ifTrue: [^ true]. "Finite rings are semilocal."
	self isLocal ifTrue: [^ true]. "Local rings have 1 maximal ideal"
	^ false "undefined"! !

!Ring methodsFor: 'testing' stamp: 'len 11/2/2016 03:36'!
isTrivial
	"The trivial ring is the zero ring with a single element 0 = 1."
	^ self size = 1! !

!Ring methodsFor: 'testing' stamp: 'len 1/12/2022 17:55:19'!
isUFD
	"A unique factorization domain (UFD) is a commutative ring in which every nonzero nonunit element can be written as a product of prime elements (or irreducible elements), uniquely up to order and units."
	self isPID ifTrue: [^ true].
	self isIntegralDomain ifFalse: [^ false].
	^ false "undefined"! !

!Ring methodsFor: 'private' stamp: 'len 7/16/2021 11:14:25'!
extensionClass
	^ AffineAlgebra! !

!Ring methodsFor: 'private' stamp: 'len 4/6/2021 13:28:11'!
idealClass
	^ Ideal! !

!Ring methodsFor: 'private' stamp: 'len 7/5/2021 12:03:04'!
species
	^ Ring! !

!Ring methodsFor: 'private' stamp: 'len 7/18/2020 04:55:48'!
tupleClass
	^ DenseTuple! !

!FractionRing methodsFor: 'accessing' stamp: 'len 6/21/2019 17:59:07'!
characteristic
	^ self integers characteristic! !

!FractionRing methodsFor: 'accessing' stamp: 'len 6/21/2019 17:59:25'!
integers
	^ self propertyAt: #integers! !

!FractionRing methodsFor: 'accessing' stamp: 'len 6/21/2019 17:59:38'!
one
	^ self embed: self integers one! !

!FractionRing methodsFor: 'accessing' stamp: 'len 8/11/2019 07:58:07'!
scalars
	^ self integers scalars! !

!FractionRing methodsFor: 'accessing' stamp: 'len 4/13/2020 04:59:38'!
size
	self integers isFinite ifFalse: [^ self integers size].
	^ super size! !

!FractionRing methodsFor: 'accessing' stamp: 'len 1/2/2022 09:57:29'!
uniformizer
	"A uniformizer (or uniformizing parameter, uniformizer element or prime element) is any irreducible element of a DVR, or equivalently a generator of the maximal ideal. All nonzero ideals are generated by some power of the uniformizer."
	^ self embed: self integers uniformizer! !

!FractionRing methodsFor: 'accessing' stamp: 'len 6/21/2019 17:59:43'!
zero
	^ self embed: self integers zero! !

!FractionRing methodsFor: 'comparing' stamp: 'len 10/31/2016 15:20'!
= anObject
	self == anObject ifTrue: [^ true].
	^ (anObject isKindOf: FractionRing) and: [anObject integers = self integers]! !

!FractionRing methodsFor: 'comparing' stamp: 'len 6/21/2019 18:00:11'!
hash
	^ self integers hash! !

!FractionRing methodsFor: 'converting' stamp: 'len 1/20/2017 09:07:54'!
over: aRing
	"Change the base ring."
	^ self class on: (self integers over: aRing)! !

!FractionRing methodsFor: 'elements' stamp: 'len 4/9/2020 18:15:59'!
adapt: anElement
	(self integers includes: anElement) ifTrue: [^ self embed: anElement].
	(self integers adapt: anElement) ifNotNil: [:integerElement| ^ self embed: integerElement].
	^ super adapt: anElement! !

!FractionRing methodsFor: 'elements' stamp: 'len 12/29/2021 14:05:14'!
numerator: anElement denominator: anotherElement
	^ (self reducedNumerator: anElement denominator: anotherElement) reduce! !

!FractionRing methodsFor: 'elements' stamp: 'len 1/6/2022 19:46:56'!
reducedNumerator: anElement denominator: anotherElement
	"anotherElement isZerodivisor ifTrue: [^ self error: 'denominator cannot be a zerodivisor']."
	self assert: ((self integers includes: anElement) and: [self integers includes: anotherElement]).
	^ Ratio reducedNumerator: anElement denominator: anElement one! !

!FractionRing methodsFor: 'elements' stamp: 'len 3/21/2021 13:28:22'!
x
	^ self x: 1! !

!FractionRing methodsFor: 'elements' stamp: 'len 3/21/2021 13:28:00'!
x: anInteger
	^ self embed: (self integers x: anInteger)! !

!FractionRing methodsFor: 'morphisms' stamp: 'len 12/29/2021 14:00:44'!
embed: anElement
	^ self reducedNumerator: anElement denominator: anElement one! !

!FractionRing methodsFor: 'morphisms' stamp: 'len 12/22/2021 15:05:29'!
from: aDomain
	aDomain = self integers ifTrue: [^ self addMap: ((self integers to: self evaluating: [:x| self embed: x]) name: 'i')].
	aDomain -> self integers ifNotNil: [:aMorphism| ^ aMorphism -> self].
	"aDomain class = self class ifTrue: [aDomain integers -> self integers ifNotNil: [:aMorphism| ^ self to: aDomain evaluating: [:each| (aMorphism value: each numerator) / (aMorphism value: each denominator)]]]."
	^ super from: aDomain! !

!FractionRing methodsFor: 'operations' stamp: 'len 2/28/2017 19:59:48'!
fractions
	^ self! !

!FractionRing methodsFor: 'random' stamp: 'len 1/6/2022 09:25:12'!
atRandom: aRandom
	| a b |
	a _ self integers atRandom: aRandom.
	[(b _ self integers atRandom: aRandom) isZerodivisor] whileTrue.
	^ (self embed: a) / (self embed: b)! !

!FractionRing methodsFor: 'random' stamp: 'len 1/6/2022 09:25:20'!
atRandom: aRandom bits: bitSize
	| a b |
	bitSize < 2 ifTrue: [^ self embed: (self integers atRandom: aRandom bits: bitSize)].
	a _ self integers atRandom: aRandom bits: bitSize/2.
	[(b _ self integers atRandom: aRandom bits: bitSize/2) isZerodivisor] whileTrue.
	^ (self embed: a) / (self embed: b)! !

!FractionRing methodsFor: 'testing' stamp: 'len 4/25/2020 09:57:00'!
includes: anObject
	^ anObject parent = self! !

!FractionRing methodsFor: 'testing' stamp: 'len 4/28/2021 09:33:18'!
isCommutative
	^ true! !

!FractionRing methodsFor: 'testing' stamp: 'len 6/21/2019 18:05:49'!
isDedekindDomain
	"A localization of a Dedekind domain at any multiplicative set is also a Dedekind domain."
	self integers isDedekindDomain ifTrue: [^ true].
	^ super isDedekindDomain! !

!FractionRing methodsFor: 'testing' stamp: 'len 10/31/2016 15:21'!
isField
	^ self integers isIntegralDomain! !

!FractionRing methodsFor: 'testing' stamp: 'len 8/6/2019 18:08:14'!
isLocalization
	"Answer true if the receiver is a localization of a ring (a ring of fractions, a localization at a prime ideal, etc).
	This means that elements of the receiver are formal fractions."
	^ true! !

!FractionRing methodsFor: 'testing' stamp: 'len 3/21/2021 13:29:56'!
isMultivariate
	^ self integers isMultivariate! !

!FractionRing methodsFor: 'testing' stamp: 'len 3/21/2021 15:11:25'!
isNoetherian
	"A ring is called Noetherian if every ideal is finitely generated."
	^ self integers isNoetherian or: [super isNoetherian]! !

!FractionRing methodsFor: 'testing' stamp: 'len 1/14/2022 12:45:09'!
isPIR
	"Answer true if the receiver is a principal ideal ring, i.e. all ideals are principal (but it is not necessarily a PID, i.e. it is not necessarily an integral domain)."
	"A localization of a PIR at any multiplicative subset is again a PIR."
	self integers isPIR ifTrue: [^ true].
	^ super isPIR! !

!FractionRing methodsFor: 'testing' stamp: 'len 1/2/2022 09:57:19'!
isReduced
	"Answer true if the receiver has no nonzero nilpotent elements, or equivalently if it has no nonzero elements with square zero, i.e. x^2 = 0 implies x = 0."
	^ self integers isReduced! !

!FractionRing methodsFor: 'testing' stamp: 'len 6/21/2019 18:07:59'!
isTrivial
	^ self integers isTrivial! !

!FractionRing methodsFor: 'testing' stamp: 'len 3/21/2021 13:30:08'!
isUnivariate
	^ self integers isUnivariate! !

!FractionRing methodsFor: 'private' stamp: 'len 6/21/2019 17:35:53'!
integers: aRing
	self propertyAt: #integers put: aRing! !

!FractionRing class methodsFor: 'examples' stamp: 'len 5/23/2020 09:13:12'!
example1
	"The ring of fractions of the rational integers is the field of rational numbers:"
	^  fractions
! !

!FractionRing class methodsFor: 'instance creation' stamp: 'len 6/21/2019 17:36:14'!
on: aRing
	^ self new integers: aRing! !

!RationalField methodsFor: 'accessing' stamp: 'len 9/22/2018 18:58:22'!
degree
	"Answer the degree of the receiver as an algebraic extension (as a number field)."
	^ 1! !

!RationalField methodsFor: 'accessing' stamp: 'len 5/23/2020 09:13:12'!
integers
	^ ! !

!RationalField methodsFor: 'accessing' stamp: 'len 12/29/2021 11:55:57'!
size
	^ Cardinal new! !

!RationalField methodsFor: 'comparing' stamp: 'len 11/10/2015 23:14'!
= anObject
	^ anObject class == self class! !

!RationalField methodsFor: 'comparing' stamp: 'len 6/28/2016 09:27'!
hash
	^ self class hash! !

!RationalField methodsFor: 'computing-polynomials' stamp: 'len 7/15/2021 12:39:08'!
allRootsOf: aPolynomial
	"Answer the (real) rational roots of the polynomial."
	| roots f n k tau visited fourier |
	roots _ Bag new.
	f _ aPolynomial integerPrimitivePart over: .
	n _ f degree.
	(k _ f order) > 0 ifTrue: [roots add: 0 withOccurrences: k. f _ f >> k].
	f isConstant ifTrue: [^ roots].
	visited _ Set new.
	fourier _ OrderedCollection with: f.
	f independentCoefficient divisorsDo: [:each|
		f leadingCoefficient divisorsDo: [:one|
			tau _ each / one.
			visited add: tau ifAbsent:
					[(f value: tau) isZero
						ifTrue: [roots add: tau withOccurrences: (self multiplicityAt: tau fourier: fourier). roots size = n ifTrue: [^ roots]].
					tau _ tau negated.
					(f value: tau) isZero
						ifTrue: [roots add: tau withOccurrences: (self multiplicityAt: tau fourier: fourier). roots size = n ifTrue: [^ roots]]]]].
	^ roots! !

!RationalField methodsFor: 'computing-polynomials' stamp: 'len 8/5/2021 08:42:41'!
factorizationOf: aPolynomial
	^ (aPolynomial integerPrimitivePart over: ) factorization apply: [:each| aPolynomial parent !! each]! !

!RationalField methodsFor: 'computing-polynomials-private' stamp: 'len 7/13/2021 15:03:04'!
multiplicityAt: aRoot fourier: fourier
	| count |
	count _ 0.
	fourier do: [:each| (each value: aRoot) isZero ifFalse: [^ count]. count _ count + 1].
	[fourier last isConstant]
		whileFalse:
			[((fourier add: fourier last derivative) value: aRoot) isZero ifFalse: [^ count]. count _ count + 1].
	^ count! !

!RationalField methodsFor: 'elements' stamp: 'len 7/14/2021 09:50:04'!
reducedNumerator: anInteger denominator: anotherInteger
	self assert: (anInteger isInteger and: [anotherInteger isInteger]).
	^ Rational reducedNumerator: anInteger denominator: anotherInteger! !

!RationalField methodsFor: 'enumerating' stamp: 'len 7/16/2019 16:29:51'!
do: aBlock
	"Iterate over the rational numbers by breadth-first traversal of the Calkin-Wilf tree. This is an extension of the Calkin-Wilf sequence to include 0 and the negative numbers."
	aBlock value: self zero.
	self positiveDo: [:each| aBlock value: each; value: each negated]! !

!RationalField methodsFor: 'enumerating' stamp: 'len 7/30/2019 02:08:58'!
positiveDo: aBlock
	"Iterate over the rational numbers by breadth-first traversal of the Calkin-Wilf tree.
	The nodes of the Calkin-Wilf tree of any given depth level have height strictly greater than the height of their parents."
	| q |
	q _ 1.
	[aBlock value: q. q _ 1 / (2 * q floor - q + 1)] repeat! !

!RationalField methodsFor: 'morphisms' stamp: 'len 5/6/2019 03:35:14'!
automorphisms
	^ Group new elements: {self id}! !

!RationalField methodsFor: 'morphisms' stamp: 'len 7/14/2021 09:44:41'!
embed: anInteger
	^ self reducedNumerator: anInteger denominator: 1! !

!RationalField methodsFor: 'morphisms' stamp: 'len 12/22/2021 15:01:56'!
to: aCodomain
	"Answer the canonical morphism from the receiver to aCodomain."
"	(aCodomain isRing and: [aCodomain characteristic = 0])
		ifTrue: [^ self to: aCodomain evaluating: [:x| aCodomain one * x numerator / (aCodomain one * x denominator)]]."
	^ super to: aCodomain! !

!RationalField methodsFor: 'operations' stamp: 'len 9/23/2018 01:37:20'!
adic: aPrime
	^ (self integers adic: aPrime) fractions! !

!RationalField methodsFor: 'operations' stamp: 'len 6/2/2019 05:00:13'!
adic: aPrime precision: anInteger
	^ (self integers adic: aPrime precision: anInteger) fractions! !

!RationalField methodsFor: 'operations' stamp: 'len 5/18/2016 22:22'!
adjoin: anAlgebraicNumber
	^ NumberField adjoint: anAlgebraicNumber! !

!RationalField methodsFor: 'operations' stamp: 'len 5/23/2020 09:03:52'!
algebraicClosure
	^ ! !

!RationalField methodsFor: 'operations' stamp: 'len 5/23/2020 09:04:18'!
realClosure
	^ ! !

!RationalField methodsFor: 'testing' stamp: 'len 5/10/2020 09:37:11'!
includes: anObject
	^ anObject isMemberOf: Rational! !

!RationalField methodsFor: 'testing' stamp: 'len 1/8/2017 07:50:01'!
isField
	^ true! !

!RationalField methodsFor: 'testing' stamp: 'len 11/7/2015 22:05'!
isFinite
	^ false! !

!RationalField methodsFor: 'testing' stamp: 'len 10/2/2018 01:52:47'!
isOrdered
	^ true! !

!RationalField methodsFor: 'testing' stamp: 'len 2/8/2016 20:26'!
isPrime
	"Q is a prime field (it has no proper subfields)."
	^ true! !

!RationalField methodsFor: 'testing' stamp: 'len 8/9/2020 08:00:03'!
isReal
	"Answer true if the receiver is a subring of the real field."
	^ true! !

!RationalField methodsFor: 'private' stamp: 'len 7/15/2021 19:10:23'!
extensionClass
	^ NumberField! !

!RationalField class methodsFor: 'initialization' stamp: 'len 5/23/2020 08:51:27'!
initialize
	super initialize.
	Smalltalk at: # put: self new! !

!RationalFunctionField methodsFor: 'elements' stamp: 'len 7/14/2021 09:51:43'!
reducedNumerator: aPolynomial denominator: anotherPolynomial
	self assert: ((self integers includes: aPolynomial) and: [self integers includes: anotherPolynomial]).
	^ RationalFunction reducedNumerator: aPolynomial denominator: anotherPolynomial! !

!RationalFunctionField methodsFor: 'private' stamp: 'len 7/15/2021 19:09:28'!
extensionClass
	^ FunctionField! !

!RationalFunctionField class methodsFor: 'examples' stamp: 'len 5/23/2020 09:11:37'!
example1
	"The field of rational functions in two indeterminates over the rationals:"
	^ ( polynomialsIn: #(x y)) fractions! !

!RationalFunctionField class methodsFor: 'examples' stamp: 'len 5/23/2020 09:11:37'!
example2
	"x / y in Q(x,y):"
	| F |
	F _ ( polynomialsIn: #(x y)) fractions.
	^ (F x: 1) / (F x: 2)! !

!RationalFunctionField class methodsFor: 'instance creation' stamp: 'len 1/5/2017 09:51:56'!
new: anInteger over: aRing
	^ self over: (aRing polynomialsIn: anInteger)! !

!RationalFunctionField class methodsFor: 'instance creation' stamp: 'len 4/27/2021 15:46:56'!
on: aPolynomialRing
	| R |
	R _ (aPolynomialRing isKindOf: PolynomialRing) ifTrue: [aPolynomialRing] ifFalse: [aPolynomialRing polynomials].
"	R _ R ordering isLocal
		ifTrue: [aPolynomialRing]
		ifFalse: [aPolynomialRing orderedBy: #llex]."
	^ super on: R! !

!AdicField methodsFor: 'accessing' stamp: 'len 12/17/2016 20:30:57'!
p
	^ self integers p! !

!AdicField methodsFor: 'accessing' stamp: 'len 6/7/2019 17:10:44'!
power: anInteger
	^ self integers power: anInteger! !

!AdicField methodsFor: 'accessing' stamp: 'len 6/2/2019 05:24:21'!
primeSubfield
	^ self! !

!AdicField methodsFor: 'morphisms' stamp: 'len 7/30/2021 10:42:18'!
embed: anAdicInteger
	| v |
	self assert: (self integers includes: anAdicInteger).
	v _ anAdicInteger valuation.
	^ AdicNumber new valuation: v unit: anAdicInteger normalizationInverse! !

!AdicField methodsFor: 'testing' stamp: 'len 5/8/2020 17:54:13'!
includes: anElement
	^ (anElement isKindOf: AdicNumber) and: [self integers includes: anElement unitPart]! !

!AdicField methodsFor: 'testing' stamp: 'len 8/7/2019 07:48:23'!
isApproximate
	^ true! !

!AdicField methodsFor: 'testing' stamp: 'len 8/7/2019 09:48:30'!
isField
	^ true! !

!AdicField methodsFor: 'testing' stamp: 'len 6/4/2019 04:52:35'!
isLocalField
	^ true! !

!LaurentSeriesRing methodsFor: 'morphisms' stamp: 'len 7/30/2021 10:45:35'!
embed: aPowerSeries
	| v |
	self assert: (self integers includes: aPowerSeries).
	v _ aPowerSeries valuation.
	^ LaurentSeries new valuation: v unit: aPowerSeries normalizationInverse! !

!LaurentSeriesRing methodsFor: 'operations' stamp: 'len 7/10/2021 18:27:54'!
algebraicClosure
	(self isUnivariate and: [self scalars characteristic = 0]) ifTrue: [^ PuiseuxSeriesRing over: self scalars algebraicClosure].
	^ self notYetImplemented! !

!LaurentSeriesRing methodsFor: 'testing' stamp: 'len 6/7/2020 15:11:05'!
includes: anElement
	^ (anElement isKindOf: LaurentSeries) and: [self integers includes: anElement unitPart]! !

!LaurentSeriesRing methodsFor: 'testing' stamp: 'len 8/7/2019 07:53:39'!
isApproximate
	^ true! !

!LaurentSeriesRing methodsFor: 'testing' stamp: 'len 7/15/2021 16:05:06'!
isLocalField
	^ self scalars isFiniteField! !

!LocalRing methodsFor: 'accessing' stamp: 'len 10/28/2016 16:37'!
characteristic
	^ self integers characteristic! !

!LocalRing methodsFor: 'accessing' stamp: 'len 6/6/2019 11:09:02'!
integers
	^ self localizationIdeal scalars! !

!LocalRing methodsFor: 'accessing' stamp: 'len 6/6/2019 11:09:55'!
maximalIdeal
	"Answer the unique maximal ideal in the receiver."
	^ self * (self localizationIdeal generators collect: [:each| self embed: each])! !

!LocalRing methodsFor: 'accessing' stamp: 'len 10/28/2016 16:39'!
one
	^ self embed: self integers one! !

!LocalRing methodsFor: 'accessing' stamp: 'len 4/14/2020 08:31:57'!
p
	^ self localizationIdeal generator! !

!LocalRing methodsFor: 'accessing' stamp: 'len 3/21/2021 13:44:50'!
scalars
	^ self integers scalars! !

!LocalRing methodsFor: 'accessing' stamp: 'len 4/13/2020 04:59:56'!
size
	self integers isFinite ifFalse: [^ self integers size].
	^ super size! !

!LocalRing methodsFor: 'accessing' stamp: 'len 1/9/2022 21:39:40'!
uniformizer
	"A uniformizer (or uniformizing parameter, uniformizer element or prime element) is any irreducible element of a DVR, or equivalently a generator of the maximal ideal. All nonzero ideals are generated by some power of the uniformizer."
	self isDVR ifFalse: [^ self error: 'not a DVR'].
	^ self maximalIdeal generator! !

!LocalRing methodsFor: 'accessing' stamp: 'len 10/28/2016 16:39'!
zero
	^ self embed: self integers zero! !

!LocalRing methodsFor: 'comparing' stamp: 'len 12/22/2021 13:53:22'!
< aRing
	"Answer true if the receiver is included in the argument."
	super < aRing ifTrue: [^ true].
	(aRing isKindOf: FractionRing) ifTrue: [^ self integers <= aRing integers].
	(aRing isKindOf: LocalRing) ifTrue: [^ self integers <= aRing integers and: [self localizationIdeal >= aRing localizationIdeal]].
	^ false! !

!LocalRing methodsFor: 'comparing' stamp: 'len 12/22/2021 13:53:22'!
= anObject
	self == anObject ifTrue: [^ true].
	^ (anObject isKindOf: LocalRing) and: [self localizationIdeal = anObject localizationIdeal]! !

!LocalRing methodsFor: 'comparing' stamp: 'len 6/22/2019 03:30:45'!
hash
	^ self localizationIdeal hash! !

!LocalRing methodsFor: 'converting' stamp: 'len 8/12/2019 19:01:33'!
over: aRing
	"Change the base ring."
	^ self class at: (self localizationIdeal over: (self base over: aRing))! !

!LocalRing methodsFor: 'elements' stamp: 'len 3/3/2021 14:47:55'!
adapt: anObject
	(self fractions includes: anObject) ifTrue:
		[(self localizationIdeal includes: anObject denominator)
			ifTrue: [DomainError signal].
		^ self reducedNumerator: anObject numerator denominator: anObject denominator].
	(self integers includes: anObject) ifTrue:
		[^ self embed: anObject].
	^ super adapt: anObject! !

!LocalRing methodsFor: 'elements' stamp: 'len 12/29/2021 14:14:18'!
numerator: anElement denominator: anotherElement
	^ (self reducedNumerator: anElement denominator: anotherElement) reduce! !

!LocalRing methodsFor: 'elements' stamp: 'len 12/18/2021 06:56:13'!
reducedNumerator: anElement denominator: anotherElement
	^ Germ new parent: self; setNumerator: anElement denominator: anotherElement! !

!LocalRing methodsFor: 'enumerating' stamp: 'len 7/5/2019 14:22:20'!
do: aBlock
	| visited |
	visited _ Set new.
	(self integers, self integers) do: [:each|
		(self localizationIdeal includes: each second) ifFalse:
			[| x |
			x _ (self !! each first) / (self !! each second).
			visited add: x ifAbsent: [aBlock value: x]]]! !

!LocalRing methodsFor: 'enumerating' stamp: 'len 4/8/2021 12:37:53'!
primeIdealsDo: aBlock
	| embedding P |
	self isField ifTrue: [aBlock value: self asIdeal null. ^ self].
	self isDVR ifTrue: [aBlock value: self asIdeal null; value: self maximalIdeal. ^ self].
	"The prime ideals of the localization of R at a prime ideal P are in one-to-one correspondence with the prime ideals I of R that satisfy I <= P:"
	embedding _ self integers -> self.
	P _ self localizationIdeal.
	self integers primeIdealsDo: [:each| each <= P ifTrue: [aBlock value: (each apply: embedding)]]! !

!LocalRing methodsFor: 'morphisms' stamp: 'len 3/3/2021 14:48:06'!
embed: anObject
	^ self reducedNumerator: self integers !! anObject denominator: self integers one! !

!LocalRing methodsFor: 'morphisms' stamp: 'len 12/22/2021 14:58:30'!
from: aDomain
	aDomain = self integers ifTrue: [^ self addMap: ((self integers to: self evaluating: [:x| self embed: x]) name: 'i')].
	aDomain -> self integers ifNotNil: [:aMorphism| ^ aMorphism -> self].
	^ super from: aDomain! !

!LocalRing methodsFor: 'morphisms' stamp: 'len 12/22/2021 14:58:17'!
to: aCodomain
	aCodomain = self fractions ifTrue: [^ self addMap: ((self onto: self fractions evaluating: [:each| (self fractions !! each numerator) / (self fractions !! each denominator)]) name: 'i')].
	((aCodomain isKindOf: LocalRing) and: [aCodomain localizationIdeal <= self localizationIdeal]) ifTrue: [^ self to: aCodomain evaluating: [:each| each copy parent: aCodomain]].
	^ super to: aCodomain! !

!LocalRing methodsFor: 'operations' stamp: 'len 12/18/2021 11:36:53'!
completion
	self integers ==  ifTrue: [^ self integers adic: self localizationIdeal generator].
	^ super completion! !

!LocalRing methodsFor: 'operations' stamp: 'len 1/19/2017 07:19:45'!
fractions
	^ self integers fractions! !

!LocalRing methodsFor: 'random' stamp: 'len 6/6/2019 11:06:59'!
atRandom: aRandom
	| a b |
	a _ self integers atRandom: aRandom.
	[b _ self integers atRandom: aRandom. self localizationIdeal includes: b] whileTrue.
	^ (self embed: a) / (self embed: b)! !

!LocalRing methodsFor: 'random' stamp: 'len 6/29/2019 18:16:11'!
atRandom: aRandom bits: bitSize
	| a b |
	bitSize < 2 ifTrue: [^ self !! (self integers atRandom: aRandom bits: bitSize)].
	a _ self integers atRandom: aRandom bits: bitSize/2.
	[b _ self integers atRandom: aRandom bits: bitSize/2. self localizationIdeal includes: b] whileTrue.
	^ self !! ((self fractions !! a) / (self fractions !! b))! !

!LocalRing methodsFor: 'testing' stamp: 'len 4/22/2020 06:11:00'!
includes: anObject
	^ anObject parent == self! !

!LocalRing methodsFor: 'testing' stamp: 'len 3/21/2021 15:15:04'!
isArtinian
	"A ring is called Artinian if it satisfies the descending chain condition on ideals."
	^ self integers isArtinian or: [super isArtinian]! !

!LocalRing methodsFor: 'testing' stamp: 'len 4/28/2021 09:34:59'!
isCommutative
	^ true! !

!LocalRing methodsFor: 'testing' stamp: 'len 1/2/2022 09:57:57'!
isDVR
	"Answer true if the receiver is a discrete valuation ring, i.e. a local PID that is not a field."
	"The localization of a Dedekind domain at a nonzero prime ideal is a DVR."
	^ self integers isDedekindDomain and: [self localizationIdeal isTrivial not]! !

!LocalRing methodsFor: 'testing' stamp: 'len 6/4/2019 07:42:45'!
isDedekindDomain
	"A localization of a Dedekind domain at any multiplicative set is also a Dedekind domain."
	self integers isDedekindDomain ifTrue: [^ true].
	^ super isDedekindDomain! !

!LocalRing methodsFor: 'testing' stamp: 'len 12/31/2021 11:51:43'!
isEuclidean
	"Answer true if the receiver is a Euclidean ring, i.e. it has Euclidean division with remainder."
	self integers isEuclidean ifTrue: [^ true].
	^ super isEuclidean! !

!LocalRing methodsFor: 'testing' stamp: 'len 6/6/2019 11:09:20'!
isField
	^ self integers isIntegralDomain and: [self localizationIdeal isZero]! !

!LocalRing methodsFor: 'testing' stamp: 'len 7/31/2019 05:30:49'!
isIntegralDomain
	"The localization of an integral domain at a prime ideal (or even at a multiplicative closed set not containing zero) continues to be an integral domain."
	self integers isIntegralDomain ifTrue: [^ true].
	^ super isIntegralDomain! !

!LocalRing methodsFor: 'testing' stamp: 'len 10/28/2016 16:06'!
isLocal
	^ true! !

!LocalRing methodsFor: 'testing' stamp: 'len 8/6/2019 18:08:20'!
isLocalization
	"Answer true if the receiver is a localization of a ring (a ring of fractions, a localization at a prime ideal, etc).
	This means that elements of the receiver are formal fractions."
	^ true! !

!LocalRing methodsFor: 'testing' stamp: 'len 3/21/2021 15:11:20'!
isNoetherian
	"A ring is called Noetherian if every ideal is finitely generated."
	^ self integers isNoetherian or: [super isNoetherian]! !

!LocalRing methodsFor: 'testing' stamp: 'len 1/14/2022 12:45:24'!
isPIR
	"Answer true if the receiver is a principal ideal ring, i.e. all ideals are principal (but it is not necessarily a PID, i.e. it is not necessarily an integral domain)."
	"A localization of a PIR at any multiplicative subset is again a PIR."
	self integers isPIR ifTrue: [^ true].
	^ super isPIR! !

!LocalRing methodsFor: 'testing' stamp: 'len 1/2/2022 10:01:02'!
isReduced
	"Answer true if the receiver has no nonzero nilpotent elements, or equivalently if it has no nonzero elements with square zero, i.e. x^2 = 0 implies x = 0."
	self integers isReduced ifTrue: [^ true]. "is it iff?"
	^ super isReduced! !

!LocalRing methodsFor: 'testing' stamp: 'len 9/16/2018 18:16:41'!
isTrivial
	^ self integers isTrivial "or: [self maximalIdeal includes: self zero]"! !

!LocalRing methodsFor: 'private' stamp: 'len 6/6/2019 11:08:37'!
localizationIdeal
	^ self propertyAt: #localizationIdeal! !

!LocalRing methodsFor: 'private' stamp: 'len 6/6/2019 11:07:48'!
localizationIdeal: anIdeal
	self propertyAt: #localizationIdeal put: anIdeal! !

!LocalRing class methodsFor: 'examples' stamp: 'len 12/22/2021 14:18:48'!
exampleZZLocalizedAt2
	"Answer the local ring of the integers at <2>.
	This is the ring of fractions with odd denominator."
	^  @ 2! !

!LocalRing class methodsFor: 'instance creation' stamp: 'len 6/6/2019 11:10:47'!
at: anIdeal
	^ self new localizationIdeal: anIdeal! !

!OppositeRing methodsFor: 'accessing' stamp: 'len 4/26/2021 11:19:58'!
generators
	^ opposite generators collect: [:each| self !! each]! !

!OppositeRing methodsFor: 'accessing' stamp: 'len 4/26/2021 11:20:11'!
one
	^ self !! opposite one! !

!OppositeRing methodsFor: 'accessing' stamp: 'len 4/30/2021 13:18:39'!
scalars
	^ opposite scalars! !

!OppositeRing methodsFor: 'accessing' stamp: 'len 4/26/2021 11:20:15'!
zero
	^ self !! opposite zero! !

!OppositeRing methodsFor: 'comparing' stamp: 'len 12/20/2021 13:33:08'!
= anObject
	^ (anObject isKindOf: OppositeRing) and: [opposite = anObject opposite]! !

!OppositeRing methodsFor: 'comparing' stamp: 'len 12/20/2021 13:33:14'!
hash
	^ opposite hash! !

!OppositeRing methodsFor: 'computing-matrices' stamp: 'len 12/19/2021 20:21:05'!
cosyzygiesOf: aMatrix
	"Answer a matrix whose rows span the kernel of the given matrix.
	For a matrix A, the output is X such that A*X = 0."
	^ (aMatrix transpose over: opposite) syzygies over: self! !

!OppositeRing methodsFor: 'computing-matrices' stamp: 'len 12/31/2021 08:19:01'!
syzygiesOf: aMatrix
	"Answer a matrix whose rows span the kernel of the given matrix.
	For a matrix A, the output is X with AX = 0."
	^ (aMatrix transpose over: opposite) cosyzygies over: self! !

!OppositeRing methodsFor: 'converting' stamp: 'len 4/30/2021 13:18:34'!
asModule
	^ opposite asModule! !

!OppositeRing methodsFor: 'elements' stamp: 'len 7/5/2021 12:06:29'!
adapt: anElement
	(opposite includes: anElement) ifTrue: [^ OppositeRingElement opposite: anElement].
	^ super adapt: anElement! !

!OppositeRing methodsFor: 'operations' stamp: 'len 4/26/2021 11:23:35'!
opposite
	^ opposite! !

!OppositeRing methodsFor: 'testing' stamp: 'len 12/20/2021 13:32:09'!
~ aRing
	"Answer true if the receiver is isomorphic to aRing."
	(aRing isKindOf: OppositeRing) ifTrue: [^ opposite ~ aRing opposite].
	^ super ~ aRing! !

!OppositeRing methodsFor: 'testing' stamp: 'len 12/20/2021 12:12:45'!
isCommutative
	^ false "his class should never be instantiated if the ring is commutative or involutive"! !

!OppositeRing methodsFor: 'testing' stamp: 'len 12/20/2021 13:34:09'!
isDivisionRing
	^ opposite isDivisionRing! !

!OppositeRing methodsFor: 'private' stamp: 'len 12/15/2021 20:39:36'!
opposite: aRing
	opposite _ aRing! !

!OppositeRing class methodsFor: 'instance creation' stamp: 'len 12/15/2021 20:39:46'!
opposite: aRing
	^ self new opposite: aRing! !

!ProductRing methodsFor: 'accessing' stamp: 'len 5/3/2018 01:54:47'!
characteristic
	^ components inject: 1 into: [:result :each| result lcm: each characteristic]! !

!ProductRing methodsFor: 'accessing' stamp: 'len 8/29/2016 04:10'!
components
	^ components! !

!ProductRing methodsFor: 'accessing' stamp: 'len 6/23/2019 04:21:21'!
dimension
	"Answer the Krull dimension of the receiver. This is the length of the longest ascending chain of prime ideals."
	^ (components ifEmpty: [^ -1]) max: [:each| each dimension]! !

!ProductRing methodsFor: 'accessing' stamp: 'len 9/16/2018 16:15:47'!
one
	^ self compose: (components collect: [:each| each one])! !

!ProductRing methodsFor: 'accessing' stamp: 'len 2/26/2017 09:47:23'!
size
	^ components product: [:each| each size]! !

!ProductRing methodsFor: 'accessing' stamp: 'len 9/16/2018 16:15:52'!
zero
	^ self compose: (components collect: [:each| each zero])! !

!ProductRing methodsFor: 'comparing' stamp: 'len 5/3/2021 17:50:59'!
= anObject
	^ (anObject isKindOf: ProductRing) and: [components = anObject components]! !

!ProductRing methodsFor: 'comparing' stamp: 'len 8/29/2016 04:13'!
hash
	^ components hash! !

!ProductRing methodsFor: 'computing-matrices' stamp: 'len 12/31/2021 08:20:31'!
cosyzygiesOf: aMatrix
	"Answer a matrix whose columns span the cokernel or left nullspace of the given matrix.
	For a matrix A, the output is X with XA = 0."
	| results |
	results _ self -< self components collect: [:p| (aMatrix apply: p) cosyzygies].
	^ self matrix:  (results max: [:each| each height]) @ aMatrix height filling: [:i :j| self compose: (results withIndexCollect: [:each :k| each at: i@j ifAbsent: [(self components at: k) zero]])]	! !

!ProductRing methodsFor: 'computing-matrices' stamp: 'len 1/1/2022 10:29:46'!
matrix: B codivisionBy: A
	"Answer N and X such that XA + N = B, satisfying that if the i-th row of B is a linear combination of the rows of A then the i-th row of N is zero.
	The algorithm solves the system for each projection and then composes back to the product ring."
	| results N X |
	results _ self -< self components collect: [:p| (B apply: p) codivisionBy: (A apply: p)].
	X _ self matrix: B height @ A height filling: [:i :j| self compose: (results collect: [:each| each first at: i@j])].
	N _ self matrix: B height @ B width filling: [:i :j| self compose: (results collect: [:each| each second at: i@j])].
	^ {X. N}! !

!ProductRing methodsFor: 'computing-matrices' stamp: 'len 12/31/2021 09:39:58'!
matrix: B divisionBy: A
	"Answer X and N such that AX + N = B, satisfying that if the i-th column of B is a linear combination of the columns of A then the i-th column of N is zero.
	The algorithm solves the system for each projection and then composes back to the product ring."
	| results N X |
	results _ self -< self components collect: [:p| (B apply: p) divisionBy: (A apply: p)].
	X _ self matrix: A width @ B width filling: [:i :j| self compose: (results collect: [:each| each first at: i@j])].
	N _ self matrix: B height @ B width filling: [:i :j| self compose: (results collect: [:each| each second at: i@j])].
	^ {X. N}! !

!ProductRing methodsFor: 'computing-matrices' stamp: 'len 12/31/2021 08:19:13'!
syzygiesOf: aMatrix
	"Answer a matrix whose rows span the kernel of the given matrix.
	For a matrix A, the output is X with AX = 0.
	The algorithm computes the kernel for each projection and then composes back to the product ring."
	| results |
	results _ self -< self components collect: [:p| (aMatrix apply: p) syzygies].
	^ self matrix: aMatrix width @ (results max: [:each| each width]) filling: [:i :j| self compose: (results withIndexCollect: [:each :k| each at: i@j ifAbsent: [(self components at: k) zero]])]! !

!ProductRing methodsFor: 'converting' stamp: 'len 4/30/2021 13:15:51'!
asModule
	^ self components inject: ^0 into: [:sum :each| sum  each asModule]
"
	  (/3)  (/4) :: asAbelianGroup
"! !

!ProductRing methodsFor: 'elements' stamp: 'len 12/15/2021 16:38:38'!
compose: anArray
	^ ProductRingElement new parent: self; components: anArray asArray! !

!ProductRing methodsFor: 'enumerating' stamp: 'len 10/17/2020 20:06:58'!
do: aBlock
	self asCartesianProduct do: [:each| aBlock value: (self !! each)]! !

!ProductRing methodsFor: 'enumerating' stamp: 'len 6/23/2019 04:29:12'!
primeIdealsDo: aBlock
	"TODO: the prime ideals of a product ring R x S is of the form I x S for I a prime ideal of R or R x I for I a prime ideal of S."
	^ super primeIdealsDo: aBlock! !

!ProductRing methodsFor: 'morphisms' stamp: 'len 5/23/2020 07:32:15'!
projection: i
	"Answer the canonical projection to the i-th component."
	^ (self to: (self components at: i) evaluating: [:x| x at: i]) name: '', i printText sub! !

!ProductRing methodsFor: 'random' stamp: 'len 10/17/2020 20:07:07'!
atRandom: aRandom
	^ self compose: (self asCartesianProduct atRandom: aRandom)! !

!ProductRing methodsFor: 'random' stamp: 'len 10/17/2020 20:07:16'!
atRandom: aRandom bits: bits
	^ self compose: (self asCartesianProduct atRandom: aRandom bits: bits)! !

!ProductRing methodsFor: 'testing' stamp: 'len 12/26/2021 12:21:48'!
hasCanonicalAssociates
	^ self components allSatisfy: [:each| each hasCanonicalAssociates]! !

!ProductRing methodsFor: 'testing' stamp: 'len 4/25/2020 06:08:33'!
includes: anObject
	^ anObject parent = self! !

!ProductRing methodsFor: 'testing' stamp: 'len 6/4/2019 15:39:05'!
isBezout
	"Answer true if the receiver is a Bezout ring, i.e. every finitely generated ideal is principal."
	"Bezout rings (like PIRs) are closed under products:"
	^ (components allSatisfy: [:each| each isBezout]) or: [super isBezout]! !

!ProductRing methodsFor: 'testing' stamp: 'len 4/27/2021 15:32:19'!
isCommutative
	^ components allSatisfy: [:each| each isCommutative]! !

!ProductRing methodsFor: 'testing' stamp: 'len 1/4/2022 19:00:21'!
isEuclidean
	"Answer true if the receiver is a Euclidean ring, i.e. it has Euclidean division with remainder."
	^ components allSatisfy: [:each| each isEuclidean]! !

!ProductRing methodsFor: 'testing' stamp: 'len 1/2/2022 10:13:55'!
isIntegralDomain
	"The product of two or more nontrivial rings always has nontrivial zerodivisors."
	| count |
	count _ 0.
	components do: [:each| each isTrivial ifFalse: [(count _ count + 1) > 1 ifTrue: [^ false]]].
	^ true! !

!ProductRing methodsFor: 'testing' stamp: 'len 12/20/2021 12:10:20'!
isInvolutive
	^ components allSatisfy: [:each| each isInvolutive]! !

!ProductRing methodsFor: 'testing' stamp: 'len 1/14/2022 12:45:43'!
isPIR
	"Answer true if the receiver is a principal ideal ring, i.e. all ideals are principal (but it is not necessarily a PID, i.e. it is not necessarily an integral domain)."
	"A product ring is a PIR if and only if all its components are PIRs."
	^ components allSatisfy: [:each| each isPIR]! !

!ProductRing methodsFor: 'testing' stamp: 'len 4/14/2020 21:19:45'!
isProduct
	^ true! !

!ProductRing methodsFor: 'testing' stamp: 'len 1/2/2022 10:08:41'!
isReduced
	"Answer true if the receiver has no nonzero nilpotent elements, or equivalently if it has no nonzero elements with square zero, i.e. x^2 = 0 implies x = 0."
	(components allSatisfy: [:each| each isReduced]) ifTrue: [^ true]. "is it iff?"
	^ super isReduced! !

!ProductRing methodsFor: 'testing' stamp: 'len 12/20/2021 12:11:31'!
isTrivial
	^ components allSatisfy: [:each| each isTrivial]! !

!ProductRing methodsFor: 'private' stamp: 'len 11/5/2016 06:41'!
components: anArray
	components _ anArray! !

!ProductRing class methodsFor: 'examples' stamp: 'len 5/23/2020 09:13:12'!
example1
	"The product ring of two finite rings. This is a ring of order 4,
	with 3 zero-divisors and 1 unit, characteristic 2, and two maximal
	(and principal) ideals (so it's not a local ring)."
	^ /2  (/2)! !

!ProductRing class methodsFor: 'examples' stamp: 'len 5/23/2020 09:13:12'!
example2
	"The canonical projection to the second component:"
	^ /2  (/2) projection: 2! !

!ProductRing class methodsFor: 'instance creation' stamp: 'len 8/29/2016 04:09'!
components: anArray
	^ self new components: anArray! !

!QuotientRing methodsFor: 'accessing' stamp: 'len 1/15/2018 19:04:16'!
base
	^ self relations scalars! !

!QuotientRing methodsFor: 'accessing' stamp: 'len 2/5/2017 06:36:12'!
codimension
	"Answer the Krull codimension of the receiver."
	^ self base dimension - self dimension! !

!QuotientRing methodsFor: 'accessing' stamp: 'len 5/20/2018 22:39:51'!
maximalIdeal
	"If the receiver is a local ring, answer the unique maximal ideal."
	self base isLocal ifTrue: [^ self base maximalIdeal apply: self projection].
	^ super maximalIdeal! !

!QuotientRing methodsFor: 'accessing' stamp: 'len 2/27/2017 20:53:04'!
modulus
	^ self relations generator! !

!QuotientRing methodsFor: 'accessing' stamp: 'len 3/19/2021 11:05:18'!
one
	^ self propertyAt: #one ifAbsentPut: [self project: self base one]! !

!QuotientRing methodsFor: 'accessing' stamp: 'len 2/27/2017 20:46:50'!
relations
	^ self propertyAt: #relations! !

!QuotientRing methodsFor: 'accessing' stamp: 'len 1/9/2018 21:58:01'!
relators
	^ self relations generators! !

!QuotientRing methodsFor: 'accessing' stamp: 'len 3/21/2021 13:42:55'!
scalars
	^ self base scalars! !

!QuotientRing methodsFor: 'accessing' stamp: 'len 6/19/2019 15:19:04'!
zero
	^ self propertyAt: #zero ifAbsentPut: [self representative: self base zero]! !

!QuotientRing methodsFor: 'comparing' stamp: 'len 7/5/2021 12:06:09'!
= anObject
	self == anObject ifTrue: [^ true].
	(anObject isKindOf: QuotientRing) ifFalse: [^ false].
	^ self relations = anObject relations! !

!QuotientRing methodsFor: 'comparing' stamp: 'len 2/27/2017 20:53:58'!
hash
	^ self relations hash! !

!QuotientRing methodsFor: 'computing-matrices' stamp: 'len 12/31/2021 09:45:22'!
matrix: B divisionBy: A
	"Answer X and N such that AX + N = B, satisfying that if the i-th column of B is a linear combination of the columns of A then the i-th column of N is zero."
	| L |
	L _ self relators
		inject: A codomain lift -> (self base^0)
		into: [:matrix :each| matrix  (A codomain lift endomorphisms scalar: each)].
	^ (B lift divisionBy: A lift modulo: L) collect: [:each| each apply: self projection]! !

!QuotientRing methodsFor: 'computing-matrices' stamp: 'len 12/31/2021 08:19:19'!
syzygiesOf: aMatrix
	"Answer a matrix whose rows span the kernel of the given matrix.
	For a matrix A, the output is X with AX = 0."
	| N |
	N _ self relators
		inject: aMatrix codomain lift -> (self base^0)
		into: [:matrix :each| matrix  (aMatrix codomain lift endomorphisms scalar: each)].
	^ (aMatrix lift syzygiesModulo: N) apply: self projection! !

!QuotientRing methodsFor: 'converting' stamp: 'len 12/25/2021 12:44:40'!
over: aRing
	| R |
	R _ self base over: aRing.
	^ R / (self relations over: R)! !

!QuotientRing methodsFor: 'elements' stamp: 'len 6/8/2019 12:07:39'!
representative: anElement
	"Answer the residue class corresponding to the given representative (which is already reduced)."
	^ self elementClass new parent: self; representative: anElement! !

!QuotientRing methodsFor: 'enumerating' stamp: 'len 6/5/2019 19:57:24'!
do: aBlock
	| visited |
	self flag: #fix. "does this work in any ring? depends on the implementation of do: in the base ring"
	visited _ Set new.
	self base do: [:each|
		| q |
		visited add: (q _ self project: each) ifPresent: [^ self].
		aBlock value: q]! !

!QuotientRing methodsFor: 'enumerating' stamp: 'len 4/8/2021 12:38:37'!
primeIdealsDo: aBlock
	| projection I |
	self isField ifTrue: [aBlock value: self asIdeal null. ^ self].
	"The prime ideals of R/I are in one-to-one correspondence with the prime ideals P in R that satisfy I <= P:"
	projection _ self base -> self.
	I _ self relations.
	self base primeIdealsDo: [:each| each >= I ifTrue: [aBlock value: (each apply: projection)]]! !

!QuotientRing methodsFor: 'morphisms' stamp: 'len 2/5/2016 19:52'!
conjugation
	"Answer the companion automorphism of the receiver, i.e. the Frobenius automorphism."
	^ self frobenius! !

!QuotientRing methodsFor: 'morphisms' stamp: 'len 12/22/2021 15:07:10'!
from: aDomain
	aDomain = self base ifTrue: [^ self projection].
	aDomain -> self base ifNotNil: [:aMorphism| ^ aMorphism -> self].
	(aDomain class = self class and: [aDomain relations <= self relations])
		ifTrue: [^ aDomain to: self evaluating: [:x| self project: x representative]].
	^ super from: aDomain! !

!QuotientRing methodsFor: 'morphisms' stamp: 'len 2/27/2017 20:53:22'!
project: anElement
	^ self representative: (self relations reduce: anElement)! !

!QuotientRing methodsFor: 'morphisms' stamp: 'len 4/4/2021 10:06:18'!
projection
	"Answer the natural projection, or quotient map, or canonical homomorphism from the base ring.
	This takes elements from the base ring to the corresponding residue class in the quotient ring."
	^ self propertyAt: #projection ifAbsentPut:
		[(self base onto: self evaluating: [:each| self project: each])
			name: '';
			propertyAt: #kernel put: self relations;
			propertyAt: #image put: self;
			yourself]! !

!QuotientRing methodsFor: 'operations' stamp: 'len 8/2/2021 12:19:38'!
/ anIdeal
	"Answer the quotient by the given ideal.
	For convenience, the argument can be a single element or a collection of elements as well."
	| answer I |
	I _ (anIdeal isKindOf: Ideal)
		ifTrue: [anIdeal scalars = self ifTrue: [anIdeal] ifFalse: [anIdeal scalars = self base ifTrue: [anIdeal apply: self projection] ifFalse: [^ DomainError signal]]]
		ifFalse: [self * anIdeal].
	answer _ self base / (self relations + I representative).
	answer addMap:
		((self onto: answer evaluating: [:each| answer project: each representative])
			name: '';
			propertyAt: #kernel put: I;
			propertyAt: #image put: answer;
			yourself).
	^ answer! !

!QuotientRing methodsFor: 'random' stamp: 'len 5/1/2021 12:30:10'!
atRandom: aRandom
	^ self project: (self base atRandom: aRandom modulo: self relations)
"	^ self project: (self base atRandom: aRandom)"! !

!QuotientRing methodsFor: 'random' stamp: 'len 7/26/2021 09:58:17'!
atRandom: aRandom bits: bitSize
	^ self project: (self base atRandom: aRandom bits: bitSize)! !

!QuotientRing methodsFor: 'testing' stamp: 'len 7/16/2021 11:11:52'!
hasCanonicalReduction
	^ false! !

!QuotientRing methodsFor: 'testing' stamp: 'len 4/22/2020 06:12:13'!
includes: anObject
	^ anObject parent = self! !

!QuotientRing methodsFor: 'testing' stamp: 'len 12/18/2021 20:02:45'!
isApproximate
	^ self base isApproximate! !

!QuotientRing methodsFor: 'testing' stamp: 'len 3/21/2021 15:14:47'!
isArtinian
	"A ring is called Artinian if it satisfies the descending chain condition on ideals."
	^ self base isArtinian or: [super isArtinian]! !

!QuotientRing methodsFor: 'testing' stamp: 'len 6/4/2019 15:38:15'!
isBezout
	"Answer true if the receiver is a Bezout ring, i.e. every finitely generated ideal is principal."
	"Bezout rings (like PIRs) are closed under quotients:"
	^ self base isBezout or: [super isBezout]! !

!QuotientRing methodsFor: 'testing' stamp: 'len 4/27/2021 15:53:04'!
isCommutative
	^ self base isCommutative or: [super isCommutative]! !

!QuotientRing methodsFor: 'testing' stamp: 'len 1/8/2022 10:40:03'!
isEuclidean
	"Answer true if the receiver is a Euclidean ring, i.e. it has Euclidean division with remainder."
	^ self base isEuclidean! !

!QuotientRing methodsFor: 'testing' stamp: 'len 6/7/2020 13:49:22'!
isField
	^ self base isTrivial not and: [self relations isMaximal]! !

!QuotientRing methodsFor: 'testing' stamp: 'len 6/7/2020 13:49:07'!
isIntegralDomain
	^ self base isTrivial not and: [self relations isPrime]! !

!QuotientRing methodsFor: 'testing' stamp: 'len 5/20/2018 21:59:53'!
isLocal
	^ self base isLocal or: [super isLocal]! !

!QuotientRing methodsFor: 'testing' stamp: 'len 3/21/2021 15:10:53'!
isNoetherian
	"A ring is called Noetherian if every ideal is finitely generated."
	^ self base isNoetherian or: [super isNoetherian]! !

!QuotientRing methodsFor: 'testing' stamp: 'len 1/14/2022 12:45:51'!
isPIR
	"Answer true if the receiver is a principal ideal ring, i.e. all ideals are principal (but it is not necessarily a PID, i.e. it is not necessarily an integral domain)."
	"Any quotient of a PIR is again a PIR:"
	^ self base isPIR or: [super isPIR]! !

!QuotientRing methodsFor: 'testing' stamp: 'len 4/12/2021 14:54:10'!
isQuotient
	"Answer true if the receiver is a quotient ring R/I."
	^ true! !

!QuotientRing methodsFor: 'testing' stamp: 'len 1/2/2022 10:08:49'!
isReduced
	"Answer true if the receiver has no nonzero nilpotent elements, or equivalently if it has no nonzero elements with square zero, i.e. x^2 = 0 implies x = 0.
	A quotient ring is reduced iff the relations ideal is radical."
	^ self relations isRadical! !

!QuotientRing methodsFor: 'testing' stamp: 'len 2/27/2017 20:53:34'!
isTrivial
	"The trivial ring is the zero ring with a single element 0 = 1."
	^ self relations isOne! !

!QuotientRing methodsFor: 'private' stamp: 'len 4/24/2019 11:50:53'!
elementClass
	^ Residue! !

!QuotientRing methodsFor: 'private' stamp: 'len 2/27/2017 20:48:00'!
relations: anIdeal
	self propertyAt: #relations put: anIdeal! !

!QuotientRing class methodsFor: 'examples' stamp: 'len 5/23/2020 09:13:12'!
exampleZ6
	"The quotient ring of residue classes of integers modulo 6."
	| I |
	I _  * 6.
	^ /I "alternatively, you can just write /6 or  mod: 6."! !

!QuotientRing class methodsFor: 'examples' stamp: 'len 5/23/2020 09:13:12'!
exampleZ6Elements
	"The elements of the quotient ring of residue classes of integers modulo 6."
	^ (/6) elements! !

!QuotientRing class methodsFor: 'examples' stamp: 'len 5/23/2020 09:13:12'!
exampleZ6Projection
	"The canonical projection from the integers ring Z
	to the quotient ring of residue classes modulo 6."
	^ (/6) projection! !

!QuotientRing class methodsFor: 'instance creation' stamp: 'len 7/16/2021 10:24:11'!
modulus: anElement
	^ self relations: anElement parent * anElement! !

!QuotientRing class methodsFor: 'instance creation' stamp: 'len 7/31/2019 08:22:46'!
relations: anIdeal
	^ self new relations: anIdeal! !

!ModularIntegerRing methodsFor: 'accessing' stamp: 'len 5/23/2020 09:13:12'!
base
	^ ! !

!ModularIntegerRing methodsFor: 'accessing' stamp: 'len 4/25/2016 00:26'!
characteristic
	^ self modulus! !

!ModularIntegerRing methodsFor: 'accessing' stamp: 'len 9/23/2018 01:58:30'!
dimension
	"Answer the Krull dimension of the receiver."
	^ 0! !

!ModularIntegerRing methodsFor: 'accessing' stamp: 'len 11/29/2016 21:41:18'!
modulus
	^ modulus! !

!ModularIntegerRing methodsFor: 'accessing' stamp: 'len 6/19/2019 15:47:01'!
phi
	"Answer the order of the units group. This is Euler's totient function."
	^ modulus phi! !

!ModularIntegerRing methodsFor: 'accessing' stamp: 'len 8/5/2021 08:40:33'!
primitiveRoot
	| order powers |
	self propertyAt: #primitiveRoot ifPresent: [:anElement| ^ anElement].
	modulus <= 2 ifTrue: [^ self one].
	order _ self phi.
	powers _ order factorization asSet asArray collect: [:p| order / p].
	self unitsDo: [:x|
		(powers anySatisfy: [:n| (x^n) representative = 1])
			ifFalse: [^ self propertyAt: #primitiveRoot put: x]].
	^ self error: 'no primitive element'! !

!ModularIntegerRing methodsFor: 'accessing' stamp: 'len 5/23/2020 09:13:12'!
relations
	^ self propertyAt: #relations ifAbsentPut: [ * modulus]! !

!ModularIntegerRing methodsFor: 'accessing' stamp: 'len 4/25/2016 00:27'!
size
	^ self modulus! !

!ModularIntegerRing methodsFor: 'comparing' stamp: 'len 4/26/2018 20:11:02'!
= anObject
	self == anObject ifTrue: [^ true].
	(anObject isKindOf: ModularIntegerRing) ifFalse: [^ false].
	^ self modulus = anObject modulus! !

!ModularIntegerRing methodsFor: 'comparing' stamp: 'len 4/26/2018 20:11:10'!
hash
	^ self modulus hash! !

!ModularIntegerRing methodsFor: 'converting' stamp: 'len 7/22/2021 18:55:25'!
asModule
	"Answer the receiver as a -module."
	^ self propertyAt: #asModule ifAbsentPut:
		[| answer |
		(answer _ self base asModule / {self modulus})
			addCoercionFrom: self evaluating: [:each| answer !! {each representative}];
			addCoercionTo: self evaluating: [:each| self !! (each representative at: 1)];
			yourself]! !

!ModularIntegerRing methodsFor: 'enumerating' stamp: 'len 4/14/2020 13:34:12'!
do: aBlock
	0 to: self modulus - 1 do: [:i| aBlock value: (self representative: i)]! !

!ModularIntegerRing methodsFor: 'enumerating' stamp: 'len 6/20/2019 16:37:09'!
primeIdealsDo: aBlock
	self modulusPrimes do: [:p| aBlock value: self * (self project: p)]

"	| p |
	p _ 2.
	[p > modulus]
		whileFalse:
			[p | modulus ifTrue: [aBlock value: self * (self project: p)].
			p _ p nextPrime]"! !

!ModularIntegerRing methodsFor: 'morphisms' stamp: 'len 11/30/2016 18:48:51'!
project: anInteger
	^ self representative: anInteger \\ modulus! !

!ModularIntegerRing methodsFor: 'morphisms' stamp: 'len 12/22/2021 14:58:50'!
to: aCodomain
	"Ring homomorphisms from Z/mZ are canonical: they are determined by the image of 1, and the image of 1 must be 1 in order to make it a ring homomorphism."
	(aCodomain characteristic > 0 and: [aCodomain characteristic | self characteristic])
		ifTrue: [^ self to: aCodomain evaluating: [:x| aCodomain one * x representative]].
	^ super to: aCodomain! !

!ModularIntegerRing methodsFor: 'operations' stamp: 'len 12/22/2021 14:16:53'!
@ aPrimeIdeal
	"Answer the localization of the receiver at aPrimeIdeal."
	| p |
	(aPrimeIdeal isTrivial and: [self isIntegralDomain]) ifTrue: [^ self fractions].
	p _ aPrimeIdeal generator representative.
	^ PrimePowerRing new: p to: (self modulus valuation: p)! !

!ModularIntegerRing methodsFor: 'operations' stamp: 'len 5/3/2021 17:50:59'!
decomposition
	"Answer the decomposition of the receiver as product of prime power rings."
	^ self propertyAt: #decomposition ifAbsentPut:
		[| components answer crt |
		components _ OrderedCollection new.
		self modulusFactors withOccurrencesDo: [:p :k| components add: (PrimePowerRing new: p to: k)].
		components _ components asArray.
		crt _ CRT moduli: (components collect: [:each| each modulus]).
		(answer _ ProductRing components: components)
			addMap: (answer to: self evaluating: [:x| self project: (crt solve: (x components collect: [:each| each representative]))]);
			addMap: (self to: answer evaluating: [:x| answer compose: (components collect: [:each| each project: x representative])]);
			yourself]! !

!ModularIntegerRing methodsFor: 'operations' stamp: 'len 6/19/2019 14:53:21'!
units
	"Answer the multiplicative group of units of the receiver (i.e., elements that have multiplicative inverse)."
	^ self propertyAt: #units ifAbsentPut: [ModularIntegerUnitGroup on: self]! !

!ModularIntegerRing methodsFor: 'random' stamp: 'len 4/25/2016 00:26'!
atRandom: aRandom
	^ self project: (self modulus atRandom: aRandom) - 1! !

!ModularIntegerRing methodsFor: 'random' stamp: 'len 4/19/2016 22:14'!
atRandom: aRandom bits: bitSize
	^ self atRandom: aRandom! !

!ModularIntegerRing methodsFor: 'testing' stamp: 'len 4/22/2020 06:11:16'!
includes: anObject
	^ anObject parent = self! !

!ModularIntegerRing methodsFor: 'testing' stamp: 'len 12/31/2021 11:51:36'!
isEuclidean
	"Answer true if the receiver is a Euclidean ring, i.e. it has Euclidean division with remainder."
	^ true! !

!ModularIntegerRing methodsFor: 'testing' stamp: 'len 12/28/2016 12:13:20'!
isField
	^ self propertyAt: #isField ifAbsentPut: [self modulus isPrime]! !

!ModularIntegerRing methodsFor: 'testing' stamp: 'len 5/21/2018 05:09:16'!
isFinite
	^ true! !

!ModularIntegerRing methodsFor: 'testing' stamp: 'len 1/19/2018 22:33:59'!
isIntegralDomain
	^ self isField! !

!ModularIntegerRing methodsFor: 'testing' stamp: 'len 6/4/2019 18:39:42'!
isLocal
	"Z/mZ is local if and only if m is a prime power. See PrimePowerRing."
	^ self modulusFactors asSet size = 1! !

!ModularIntegerRing methodsFor: 'testing' stamp: 'len 9/27/2018 21:29:36'!
isPID
	^ self isIntegralDomain! !

!ModularIntegerRing methodsFor: 'testing' stamp: 'len 1/14/2022 12:45:34'!
isPIR
	"Answer true if the receiver is a principal ideal ring, i.e. all ideals are principal (but it is not necessarily a PID, i.e. it is not necessarily an integral domain)."
	^ true! !

!ModularIntegerRing methodsFor: 'testing' stamp: 'len 1/14/2022 12:04:52'!
isReduced
	"Answer true if the receiver has no nonzero nilpotent elements, or equivalently if it has no nonzero elements with square zero, i.e. x^2 = 0 implies x = 0.
	This is true if the modulus is squarefree."
	modulus = 0 ifTrue: [^ true].
	self modulusFactors withOccurrencesDo: [:p :e| e > 1 ifTrue: [^ false]].
	^ true

"	^ modulus = 0 or: [modulus isSquarefree]"! !

!ModularIntegerRing methodsFor: 'private' stamp: 'len 1/5/2017 08:14:58'!
elementClass
	^ ModularInteger! !

!ModularIntegerRing methodsFor: 'private' stamp: 'len 11/29/2016 21:47:19'!
modulus: anInteger
	modulus _ anInteger! !

!ModularIntegerRing methodsFor: 'private' stamp: 'len 8/5/2021 08:40:30'!
modulusFactors
	^ self propertyAt: #modulusFactors ifAbsentPut: [self modulus factorization]! !

!ModularIntegerRing methodsFor: 'private' stamp: 'len 7/31/2019 08:17:57'!
modulusFactors: aBag
	self propertyAt: #modulusFactors put: aBag! !

!ModularIntegerRing methodsFor: 'private' stamp: 'len 6/16/2019 12:57:35'!
modulusPrimes
	^ self propertyAt: #modulusPrimes ifAbsentPut: [self modulusFactors asSet asArray sort]! !

!ModularIntegerRing methodsFor: 'private' stamp: 'len 2/27/2017 20:48:23'!
relations: anIdeal
	super relations: anIdeal.
	self modulus: anIdeal generator! !

!ModularIntegerRing methodsFor: 'private' stamp: 'len 3/25/2021 14:48:47'!
tupleClass
	modulus = 2 ifTrue: [^ BitTuple].
	modulus <= 256 ifTrue: [^ ByteModularTuple].
	modulus <= 16r100000000 ifTrue: [^ WordModularTuple].
	^ ModularTuple! !

!ModularIntegerRing class methodsFor: 'instance creation' stamp: 'len 11/29/2016 21:46:49'!
new: anInteger
	^ self new modulus: anInteger! !

!PrimePowerRing methodsFor: 'accessing' stamp: 'len 9/22/2018 18:56:21'!
degree
	"Answer the degree of the receiver as an algebraic extension (as a Galois ring)."
	^ 1! !

!PrimePowerRing methodsFor: 'accessing' stamp: 'len 5/21/2018 04:19:07'!
exponent
	^ self propertyAt: #exponent ifAbsentPut: [self modulusFactors size]! !

!PrimePowerRing methodsFor: 'accessing' stamp: 'len 5/21/2018 04:13:20'!
maximalIdeal
	^ self * self p! !

!PrimePowerRing methodsFor: 'accessing' stamp: 'len 5/21/2018 04:18:30'!
p
	^ self propertyAt: #p ifAbsentPut: [self modulusFactors anyOne]! !

!PrimePowerRing methodsFor: 'accessing' stamp: 'len 6/25/2019 03:57:04'!
primeSubfield
	^ self residueField! !

!PrimePowerRing methodsFor: 'accessing' stamp: 'len 8/7/2019 07:13:36'!
residueField
	"Answer the prime field Z/pZ isomorphic to the residue field of the receiver, equipped with the canonical projection."
	^ self propertyAt: #residueField ifAbsentPut:
		[| answer |
		(answer _ PrimeField new: self p)
			addMap: (self onto: answer evaluating: [:x| answer !! x representative]); "TODO: add kernel and section"
			yourself]! !

!PrimePowerRing methodsFor: 'enumerating' stamp: 'len 9/22/2018 18:56:26'!
idealsDo: aBlock
	"The ideals of Z/(p^n)Z are {0} and <p^i> for 0 <= i < n-1."
	| a |
	aBlock value: self * 0.
	a _ self one.
	self exponent timesRepeat:
		[aBlock value: self * a.
		a _ a * self p]! !

!PrimePowerRing methodsFor: 'morphisms' stamp: 'len 12/22/2021 15:01:29'!
from: aDomain
	((aDomain isKindOf: AdicRing) and: [aDomain p = self p])
		ifTrue: [^ (aDomain onto: self evaluating: [:x| self projectAdicInteger: x]) name: '', self exponent asString sub].
	((aDomain isKindOf: ModularIntegerRing) and: [self modulus | aDomain modulus and: [(self modulus * self p | aDomain modulus) not]]) "localization map"
		ifTrue: [^ aDomain onto: self evaluating: [:x| self project: x lift]]. 
	^ super from: aDomain! !

!PrimePowerRing methodsFor: 'morphisms' stamp: 'len 8/9/2019 04:42:39'!
projectAdicInteger: anAdicInteger
	| p x digits |
	p _ self p.
	digits _ anAdicInteger coefficients.
	x _ 0.
	self exponent to: 1 by: -1 do: [:i| x _ x*p + (digits at: i)].
	^ self project: x! !

!PrimePowerRing methodsFor: 'morphisms' stamp: 'len 8/4/2019 09:36:00'!
quadraticLiftingsDo: aBlock
	self exponent > 1 ifTrue:
		[| R |
		self exponent odd ifTrue: [^ self error: 'odd exponent'].
		R _ PrimePowerRing new: self p to: self exponent // 2.
		R quadraticLiftingsDo: aBlock.
		aBlock value: (R to: self evaluating: [:x| self project: x lift])]! !

!PrimePowerRing methodsFor: 'morphisms' stamp: 'len 12/22/2021 15:01:16'!
to: aCodomain
	"Cannonical projection from Z/(p^n)Z to Z/(p^m)Z, 1 <= m <= n."
	((aCodomain isKindOf: PrimePowerRing) and: [aCodomain p = self p and: [aCodomain exponent < self exponent]])
		ifTrue: [^ (self onto: aCodomain evaluating: [:x| aCodomain project: x representative]) name: ''].
	^ super to: aCodomain! !

!PrimePowerRing methodsFor: 'operations' stamp: 'len 5/21/2018 15:42:20'!
nilradical
	"Answer the ideal consisting of all nilpotent elements, i.e. all x such that there exists some n with x^n = 0. It is the intersection of all prime ideals.
	A finite ring is a Galois ring iff its nilradical is of the form <p> for some prime p. This is also the unique maximal ideal."
	^ self maximalIdeal! !

!PrimePowerRing methodsFor: 'operations' stamp: 'len 1/6/2022 09:24:27'!
zerodivisors
	"The zero-divisors of a Galois ring Z/<p^k> constitute the unique maximal ideal <p>."
	^ self maximalIdeal! !

!PrimePowerRing methodsFor: 'testing' stamp: 'len 6/25/2019 02:19:48'!
isChainRing
	"A chain ring is a ring whose ideals form a chain under inclusion.
	Prime power rings, and more generally Galois rings, are chain rings."
	^ true! !

!PrimePowerRing methodsFor: 'testing' stamp: 'len 12/31/2021 11:51:22'!
isEuclidean
	"Answer true if the receiver is a Euclidean ring, i.e. it has Euclidean division with remainder."
	"Galois rings are euclidean."
	^ true! !

!PrimePowerRing methodsFor: 'testing' stamp: 'len 5/21/2018 04:26:10'!
isField
	^ self exponent = 1! !

!PrimePowerRing methodsFor: 'testing' stamp: 'len 9/22/2018 18:56:29'!
isGaloisRing
	^ true! !

!PrimePowerRing methodsFor: 'testing' stamp: 'len 5/21/2018 04:12:49'!
isLocal
	^ true! !

!PrimePowerRing methodsFor: 'testing' stamp: 'len 9/22/2018 18:57:35'!
isPIR
	"All nontrivial ideals are of the form <p^i>."
	^ true! !

!PrimePowerRing methodsFor: 'private' stamp: 'len 6/8/2019 12:34:31'!
elementClass
	^ PrimePowerResidue! !

!PrimePowerRing methodsFor: 'private' stamp: 'len 7/15/2021 19:11:10'!
extensionClass
	^ GaloisRing! !

!PrimePowerRing methodsFor: 'private' stamp: 'len 9/22/2018 18:56:42'!
p: aPrime to: anInteger
	self modulus: aPrime^anInteger.
	self propertyAt: #modulusFactors put: (Bag new add: aPrime withOccurrences: anInteger; yourself)! !

!PrimePowerRing class methodsFor: 'examples' stamp: 'len 5/15/2019 06:45:14'!
example1
	"The Galois ring Z/<5^3>:"
	^ PrimePowerRing new: 5 to: 3! !

!PrimePowerRing class methodsFor: 'examples' stamp: 'len 5/23/2020 09:13:12'!
example2
	"Another way to create the Galois ring Z/<5^3>.
	This is less efficient because internally it performs a factorization."
	^ /(5^3)! !

!PrimePowerRing class methodsFor: 'examples' stamp: 'len 5/23/2020 09:13:12'!
example3
	"The canonical ring homomorphism from a prime ring Z/(p^n)Z to Z/pZ:"
	^ /(5^3) -> (/5)! !

!PrimePowerRing class methodsFor: 'instance creation' stamp: 'len 5/21/2018 16:28:00'!
new: p to: n
	n = 1 ifTrue: [^ PrimeField new: p].
	^ self new p: p to: n! !

!PrimeField methodsFor: 'accessing' stamp: 'len 6/19/2019 14:27:56'!
exponent
	^ 1! !

!PrimeField methodsFor: 'accessing' stamp: 'len 6/19/2019 14:26:59'!
p
	^ self modulus! !

!PrimeField methodsFor: 'accessing' stamp: 'len 6/19/2019 15:47:17'!
phi
	"Answer the order of the units group. This is Euler's totient function."
	^ modulus - 1! !

!PrimeField methodsFor: 'accessing' stamp: 'len 9/22/2018 18:56:03'!
primeSubfield
	^ self! !

!PrimeField methodsFor: 'accessing-private' stamp: 'len 6/19/2019 14:24:13'!
modulus: anInteger
	self propertyAt: #modulusFactors put: (Bag with: anInteger).
"	self propertyAt: #p put: anInteger."
	super modulus: anInteger! !

!PrimeField methodsFor: 'accessing-private' stamp: 'len 5/21/2018 04:28:02'!
p: aPrime to: anInteger
	anInteger = 1 ifFalse: [^ self error: 'exponent must be 1'].
	super p: aPrime to: anInteger! !

!PrimeField methodsFor: 'comparing' stamp: 'len 9/22/2018 18:56:11'!
~ aRing
	"Any two finite fields of the same cardinality are isomorphic."
	^ aRing isField and: [self size = aRing size]! !

!PrimeField methodsFor: 'computing-matrices' stamp: 'len 12/31/2021 09:18:06'!
matrix: B divisionBy: A
	"Answer X and N such that AX + N = B, satisfying that if the i-th column of B is a linear combination of the columns of A then the i-th column of N is zero."
	^ self matrixOverField: B divisionBy: A! !

!PrimeField methodsFor: 'computing-matrices' stamp: 'len 12/31/2021 14:19:52'!
syzygiesOf: aMatrix
	"Answer a matrix whose rows span the kernel of the given matrix.
	For a matrix A, the output is X with AX = 0."
	^ self syzygiesOverEuclideanDomainOf: aMatrix! !

!PrimeField methodsFor: 'enumerating' stamp: 'len 4/8/2021 12:38:17'!
primeIdealsDo: aBlock
	aBlock value: self asIdeal null! !

!PrimeField methodsFor: 'enumerating' stamp: 'len 6/19/2019 16:09:42'!
unitsDo: aBlock
	1 to: modulus - 1 do: [:each| aBlock value: (self representative: each)]! !

!PrimeField methodsFor: 'operations' stamp: 'len 1/6/2022 09:24:13'!
zerodivisors
	^ {self zero}! !

!PrimeField methodsFor: 'testing' stamp: 'len 10/18/2016 20:46'!
isField
	^ true! !

!PrimeField methodsFor: 'testing' stamp: 'len 7/15/2021 16:07:32'!
isFiniteField
	^ true! !

!PrimeField methodsFor: 'private' stamp: 'len 6/8/2019 12:43:54'!
elementClass
	^ PrimeResidue! !

!PrimeField methodsFor: 'private' stamp: 'len 7/15/2021 19:11:34'!
extensionClass
	^ GaloisField! !

!PrimeField methodsFor: 'private' stamp: 'len 11/30/2016 19:12:00'!
inverseOfRepresentative: anInteger
	| result |
	anInteger == 0 ifTrue: [^ nil].
	anInteger == 1 ifTrue: [^ 1].
	result _ anInteger xgcd: modulus.
	^ (result at: 2) \\ modulus! !

!PrimeField methodsFor: 'private' stamp: 'len 7/8/2019 02:32:52'!
squareRootOfRepresentative: anInteger
	| algorithm |
	modulus = 2 ifTrue: [^ anInteger].
	algorithm _ self propertyAt: #squareRootAlgorithm ifAbsentPut: [TonelliShanks new modulus: self modulus].
	^ algorithm squareRootOf: anInteger! !

!SmallPrimeField methodsFor: 'accessing' stamp: 'len 6/9/2018 20:23:46'!
expTable
	^ expTable! !

!SmallPrimeField methodsFor: 'accessing' stamp: 'len 6/9/2018 20:23:52'!
logTable
	^ logTable! !

!SmallPrimeField methodsFor: 'accessing-private' stamp: 'len 11/30/2016 09:43:55'!
modulus: anInteger
	super modulus: anInteger.
	self computeTables! !

!SmallPrimeField methodsFor: 'private' stamp: 'len 9/2/2018 21:27:06'!
computeTables
	| g x |
	expTable _ WordArray new: modulus - 1. "n -> g^n"
	logTable _ WordArray new: modulus - 1. "g^n -> n"
	g _ self primitiveRoot representative.
	x _ 1.
	1 to: modulus - 1 do: [:i|
		"g^n -> n:"
		logTable at: x put: i - 1.
		x _ x * g \\ modulus.
		"n -> g^n:"
		expTable at: i put: x]! !

!SmallPrimeField methodsFor: 'private' stamp: 'len 6/8/2019 12:35:48'!
elementClass
	^ SmallPrimeResidue! !

!SmallPrimeField methodsFor: 'private' stamp: 'len 11/30/2016 19:12:33'!
inverseOfRepresentative: anInteger
	anInteger == 0 ifTrue: [^ nil].
	anInteger == 1 ifTrue: [^ 1].
	^ expTable at: modulus - 1 - (logTable at: anInteger)! !

!AffineAlgebra methodsFor: 'accessing' stamp: 'len 1/13/2022 10:30:08'!
basis
	"Answer a basis of the receiver as vector space."
	| G leadingMonomials maxExponents answer |
	self propertyAt: #basis ifPresent: [:anArray| ^ anArray].
	"If the receiver is a simple algebraic field extension, answer the power basis of the receiver.
	The coordinates of an element correspond to coefficients of the polynomial representing the element."
	self isSimpleExtension ifTrue: [^ self propertyAt: #basis put: ((0 to: self degree - 1) collect: [:k| self x ^ k])].
	self isTrivial ifTrue: [^ self propertyAt: #basis put: #()].
	"For the general case use a Groebner basis."
	G _ self ordering isGraded
		ifTrue: [self relations basis]
		ifFalse: [(self relations orderedBy: #grevlex) basis].
	G _ G minimal. "is this necesary?"
	leadingMonomials _ Set new.
	G do: [:each| leadingMonomials add: each leadingMonomial].
	maxExponents _ (Array new: self rank) atAllPut: Infinity positive.
	leadingMonomials do: [:g| g isPurePower ifTrue: [| i | i _ g lastIndeterminate. maxExponents at: (i _ g lastIndeterminate) put: ((maxExponents at: i) min: (g at: i))]].
	answer _ OrderedCollection new.
	self monomialsBelow: maxExponents do: [:f|
		(leadingMonomials anySatisfy: [:g| g | f]) ifFalse: [answer add: f]].
	^ self propertyAt: #basis put: (answer sorted collect: [:each| self !! each])! !

!AffineAlgebra methodsFor: 'accessing' stamp: 'len 11/3/2016 04:30'!
characteristic
	^ self base characteristic! !

!AffineAlgebra methodsFor: 'accessing' stamp: 'len 7/16/2021 10:15:55'!
degree
	"If the receiver is a field extension, answer the degree [E:F] of the relative extension E/F."
	^ self modulus degree! !

!AffineAlgebra methodsFor: 'accessing' stamp: 'len 7/16/2021 10:16:37'!
degreeOver: aSubfield
	"If the receiver is a simple extension, answer the degree [E:F] of the relative extension E/F."
	self = aSubfield ifTrue: [^ 1].
	self scalars = aSubfield ifTrue: [^ self degree].
	^ self degree * (self scalars degreeOver: aSubfield)! !

!AffineAlgebra methodsFor: 'accessing' stamp: 'len 8/3/2021 14:14:59'!
dimension
	"Answer the Krull dimension of the receiver. Seen as a field extension, this is its transcendence degree."
	"Derksen, Kemper, 'Computational Invariant Theory', 2002, Algorithm 1.2.4 (Dimension of an ideal)."
	self relations isZero ifTrue: [^ self base dimension].
	self isTrivial ifTrue: [^ -1]. "i.e., the ideal is the whole polynomial ring"
	self scalars isField ifTrue: [^ self maximallyIndependentIndeterminates size].
	^ super dimension! !

!AffineAlgebra methodsFor: 'accessing' stamp: 'len 3/19/2021 16:16:54'!
generators
	"Answer the generators of the receiver as an algebra over the coefficients ring."
	^ self propertyAt: #generators ifAbsentPut: [(self base generators ifNil: [^ nil]) apply: self projection]! !

!AffineAlgebra methodsFor: 'accessing' stamp: 'len 10/20/2016 10:51'!
indeterminates
	^ self base indeterminates! !

!AffineAlgebra methodsFor: 'accessing' stamp: 'len 1/13/2022 11:55:25'!
maximallyIndependentIndeterminates
	"Answer a maximimally independent set of indeterminates.
	A set of indeterminats Y is called independent modulo I if the canonical map K[Y] -> P/I is injective.
	The size of a maximally independent set is called the 'combinatorial dimension' of the ideal, and it is actually equal to the Krull dimension of the quotient ring P/I defined by the ideal. Seeing the quotient ring as a field extension, the Krull dimension is its transcendence degree."
	"See [DK02], Algorithm 1.2.4 (Dimension of an ideal)."
	| G leadingMonomials indeterminates |
	self relations isTrivial ifTrue: [^ #()].
"	self isTrivial ifTrue: [^ self error: 'trivial quotient']."
	G _ self ordering isGraded
		ifTrue: [self relations basis]
		ifFalse: [(self relations orderedBy: #grevlex) basis].
	"G _ G minimal." "is this necesary?"
	leadingMonomials _ Set new.
	G do: [:each| leadingMonomials add: each leadingMonomial].
	indeterminates _ self indeterminates.
	1 to: indeterminates size do: [:k|
		indeterminates combinations: k atATimeDo: [:combination|
			(leadingMonomials allSatisfy: [:monomial| combination includesAnyOf: monomial indeterminates])
				ifTrue: [^ indeterminates reject: [:any| combination includes: any]]]].
	^ indeterminates! !

!AffineAlgebra methodsFor: 'accessing' stamp: 'len 12/28/2017 14:50:03'!
monomials
	"Answer the monoid of monomials of the receiver."
	^ self base monomials! !

!AffineAlgebra methodsFor: 'accessing' stamp: 'len 1/5/2017 08:49:59'!
ordering
	^ self base ordering! !

!AffineAlgebra methodsFor: 'accessing' stamp: 'len 12/30/2016 09:47:01'!
rank
	"Answer the number of indeterminates in the receiver."
	^ self base rank! !

!AffineAlgebra methodsFor: 'accessing' stamp: 'len 7/16/2021 10:15:09'!
size
	self isSimpleExtension ifTrue: [^ self scalars size ^ self degree].
	^ super size! !

!AffineAlgebra methodsFor: 'accessing' stamp: 'len 8/12/2019 09:14:52'!
vectorSpaceDimension
	"Answer the dimension of the receiver as vector space over the coefficients field."
	self scalars isField ifFalse: [DomainError signal: 'not over a field'].
	self dimension = 0 ifFalse: [^ Infinity positive].
	^ self hilbertSeries numerator coefficients sum! !

!AffineAlgebra methodsFor: 'computing-polynomials' stamp: 'len 7/16/2021 10:19:31'!
factorizationOf: aPolynomial
	self isGlobalField ifTrue: [^ self factorizationOverGlobalFieldOf: aPolynomial].
	^ super factorizationOf: aPolynomial! !

!AffineAlgebra methodsFor: 'computing-polynomials-private' stamp: 'len 1/9/2022 08:31:33'!
factorizationOverGlobalFieldOf: aPolynomial
	"See [Coh96, Algorithm 3.6.4 (Polynomial Factorization over Number Fields)]."
	| u v S x y g k N answer |
	"1. Reduce to squarefree:"
	u _ aPolynomial / (v _ aPolynomial gcd: aPolynomial derivative).
	"2. Initialize search:"
	S _ self scalars polynomialsIn: 2. x _ S x. y _ S y.
	g _ S zero.
	u coefficients withIndexDo: [:ui :i| g _ (ui representative value: y) * (x^(i-1)) + g].
	"3. Search for squarefree norm polynomial:"
	k _ 0.
	[N _ ((self modulus value: y) asUnivariateIn: 2) resultant: ((g value: {x - (y*k). y}) asUnivariateIn: 2).
	N isSquarefree] whileFalse: [k _ k + 1].
	"4 and 5. Factor norm polynomial and find factors over the number field:"
	answer _ Bag new.
	N factorization withOccurrencesDo: [:f :e|
		answer add: (u gcd: (f value: (u parent x + (k*self x)))) withOccurrences: e].
	"Count multiplicities in the original polynomial (that was not necessarily squarefree):"
	v order > 0 ifTrue: [answer add: v parent x withOccurrences: v order. v _ v >> v order].
	[v isConstant] whileFalse: [v _ v / (answer add: (answer detect: [:one| one | v]))].
	answer add: v * aPolynomial leadingCoefficient.
	^ answer! !

!AffineAlgebra methodsFor: 'converting' stamp: 'len 7/22/2021 18:47:25'!
asModule
	| answer |
	self propertyAt: #asModule ifPresent: [:aModule| ^ aModule].
	self isSimpleExtension ifFalse: [^ self notYetImplemented].
	(answer _ self scalars ^ self degree)
		addCoercionFrom: self evaluating: [:a| answer elementAt: a representative coefficients];
		addCoercionTo: self evaluating: [:v| (1 to: answer rank) sum: [:i| self x ^ (i-1) * (v at: i)]].
	^ self propertyAt: #asModule put: answer

"
	 extension:  polynomials x^4 - 2 :: asVectorSpace
"! !

!AffineAlgebra methodsFor: 'elements' stamp: 'len 7/19/2021 20:26:32'!
adapt: anElement
	(self scalars includes: anElement)
		ifTrue: [^ self project: (self base constant: anElement)].
	(self monomials includes: anElement)
		ifTrue: [^ self project: (self base monomial: anElement)].
	^ super adapt: anElement! !

!AffineAlgebra methodsFor: 'elements' stamp: 'len 10/20/2016 10:50'!
x
	^ self x: 1! !

!AffineAlgebra methodsFor: 'elements' stamp: 'len 10/20/2016 10:50'!
x: anInteger
	^ self project: (self base x: anInteger)! !

!AffineAlgebra methodsFor: 'elements' stamp: 'len 10/20/2016 10:50'!
y
	^ self x: 2! !

!AffineAlgebra methodsFor: 'elements' stamp: 'len 10/20/2016 10:50'!
z
	^ self x: 3! !

!AffineAlgebra methodsFor: 'morphisms' stamp: 'len 7/16/2021 10:19:03'!
automorphisms
	"Answer the Galous group of the receiver (assuming the receiver is a Galois extension)."
	self isSimpleExtension ifFalse: [self notYetImplemented].
	self isFinite ifTrue: [^ Group new generators: {self frobenius}].
	self flag: #fix. "This is actually isomorphic to the Galois group, not the actual Galois group, it should act on elements of the extension and it's not the full symmetric group."
	^ SymmetricGroup on: (self embeddings collect: [:each| each value: self x])! !

!AffineAlgebra methodsFor: 'morphisms' stamp: 'len 3/18/2021 15:13:56'!
embed: anElement
	"Answer the embedding of an element of the coefficients ring into the receiver."
	^ self project: (self base embed: anElement)! !

!AffineAlgebra methodsFor: 'morphisms' stamp: 'len 7/16/2021 10:17:38'!
embeddings
	"Answer the n distinct embeddings of the receiver in the algebraic closure of the base field, where n is the degree of the receiver. In the case of number fields, the embeddings go to the complex algebraic numbers.
	When the receiver is a Galois extension, the embeddings send each element to one of its conjugates, and their images are the same."
	^ self propertyAt: #embeddings ifAbsentPut:
		[self isSimpleExtension ifFalse: [^ self error: 'not a simple field extension'].
		self embeddingsIn: self scalars algebraicClosure]! !

!AffineAlgebra methodsFor: 'morphisms' stamp: 'len 7/16/2021 10:18:11'!
embeddingsIn: aField
	^ (self modulus rootsIn: aField) asArray
		collect: [:x| self to: aField evaluating: [:alpha| alpha representative value: x]]! !

!AffineAlgebra methodsFor: 'morphisms' stamp: 'len 12/23/2021 19:24:21'!
from: aDomain
	aDomain == self scalars ifTrue: [^ self addMap: ((self scalars to: self evaluating: [:x| self embed: x]) name: 'i')].
	aDomain -> self scalars ifNotNil: [:aMorphism| ^ aMorphism -> self].
	^ super from: aDomain! !

!AffineAlgebra methodsFor: 'morphisms' stamp: 'len 7/9/2021 06:47:00'!
id
	"Answer the identity morphism."
	^ self propertyAt: #id ifAbsentPut: [self to: self mapping: [:i| self x: i]]! !

!AffineAlgebra methodsFor: 'morphisms' stamp: 'len 12/15/2021 11:42:40'!
to: aRing mapping: aBlock
	^ AffineAlgebraMap from: self to: aRing mapping: aBlock! !

!AffineAlgebra methodsFor: 'operations' stamp: 'len 7/22/2021 18:49:33'!
 aRing
	"Answer the tensor product of the receiver with the argument.
	This is the coproduct in the category of commutative R-algebras."
	| R relations answer i1 i2 |
	(aRing isKindOf: AffineAlgebra) ifFalse: [^ super  aRing].
	R _ self base  aRing base.
	relations _ OrderedCollection new.
	self relations generators do: [:f| relations add: R !! f].
	aRing relations generators do: [:g| relations add: (R !! g substitute: [:i| i + self base rank])].
	answer _ R / relations.
	i1 _ self into: answer mapping: [:i| answer x: i].
	i2 _ aRing into: answer mapping: [:i| answer x: self rank+i].
	answer addCoprojections: {i1. i2}.
	answer addCoercionFrom: (self, aRing) evaluatingWithArguments: [:f :g| (i1 value: f) * (i2 value: g)].
	^ answer! !

!AffineAlgebra methodsFor: 'operations' stamp: 'len 8/3/2021 14:15:06'!
fractions
	"Answer the total ring of fractions of the receiver, with the receiver an affine ring R = K[x1,...,xn]/I over a field K. The ring of fractions is constructed as an affine ring over the rational function field whose indeterminates correspond to maximally independent indeterminates of R."
	| K independentIndeterminates dependentIndeterminates F E images k localizationMap |
	K _ self scalars.
	K isField ifFalse:
		[K isIntegralDomain ifFalse: [^ super fractions].
		^ (self over: K fractions) fractions].
	independentIndeterminates _ self maximallyIndependentIndeterminates.
	independentIndeterminates isEmpty ifTrue: [^ self]. "is this correct? is it a field?"
	dependentIndeterminates _ (1 to: self rank) reject: [:i| independentIndeterminates includes: i].
	F _ (K polynomialsIn: (independentIndeterminates collect: [:i| self base names at: i])) fractions.
	E _ F polynomialsIn: (dependentIndeterminates collect: [:i| self base names at: i]).
	images _ Array new: self rank.
	k _ 0.
	independentIndeterminates do: [:i| images at: i put: (E constant: (F x: (k _ k + 1)))].
	k _ 0.
	dependentIndeterminates do: [:i| images at: i put: (E x: (k _ k + 1))].
	E addMap: (localizationMap _ self base to: E evaluating: [:f| f value: images]).
	^ E / (self relations apply: localizationMap)! !

!AffineAlgebra methodsFor: 'operations' stamp: 'len 2/27/2017 20:57:29'!
hilbertSeriesAt: t
	"Answer the Hilbert series of the receiver."
	^ (self base hilbertSeriesAt: t) - (self relations hilbertSeriesAt: t)! !

!AffineAlgebra methodsFor: 'operations' stamp: 'len 1/14/2022 11:48:15'!
localization
	"Answer the localization of the receiver at <x1,...,xn>. This is achieved by choosing a local ordering.
	Objects defined in this localization contain geometric information (usually only) about a Zariski neighbourhood of 0 in K^n, while objects in the global ring contain geometric information whish is valid in the whole affine space K^n."
	self ordering isGlobal ifFalse: [self error: 'not a global ordering'].
	^ self orderedBy: #lglex! !

!AffineAlgebra methodsFor: 'operations' stamp: 'len 7/31/2019 08:21:30'!
orderedBy: aMonomialOrdering
	^ self class relations: (self relations orderedBy: aMonomialOrdering)! !

!AffineAlgebra methodsFor: 'operations' stamp: 'len 12/11/2021 19:19:03'!
proj
	"This is the Proj functor. Answer the subscheme of projective space with homogeneous coordinate ring the receiver."
	self relations isHomogeneous ifFalse: [^ DomainError signal: 'not a quotient by a homogeneous ideal, not properly graded'].
	^ self propertyAt: #proj ifAbsentPut: [ProjectiveVariety coordinateRing: self]! !

!AffineAlgebra methodsFor: 'operations' stamp: 'len 12/11/2021 19:15:21'!
spec
	"This is the Spec functor. Answer the spectrum of the receiver as a subscheme of affine space."
	^ self propertyAt: #spec ifAbsentPut: [AffineVariety coordinateRing: self]! !

!AffineAlgebra methodsFor: 'testing' stamp: 'len 7/27/2021 08:49:46'!
hasEchelonization
	^ false! !

!AffineAlgebra methodsFor: 'testing' stamp: 'len 3/21/2021 15:15:16'!
isArtinian
	"A ring is called Artinian if it satisfies the descending chain condition on ideals.
	Given an affine K-algebra A, the following are equivalent:
	- the Krull dimension of A is 0;
	- A is algebraic over K;
	- dimension of A as a K-vector space is finite;
	- A is Artinian."
	self scalars isField ifTrue: [^ self dimension = 0].
	^ super isArtinian! !

!AffineAlgebra methodsFor: 'testing' stamp: 'len 2/27/2017 20:57:34'!
isGraded
	^ self base isGraded and: [self relations isHomogeneous]! !

!AffineAlgebra methodsFor: 'testing' stamp: 'len 1/7/2018 17:28:33'!
isMultivariate
	^ self base isMultivariate! !

!AffineAlgebra methodsFor: 'testing' stamp: 'len 7/16/2021 11:18:07'!
isSimpleExtension
	^ self base isUnivariate and: [self generators size = 1 and: [self modulus isIrreducible]]! !

!AffineAlgebra methodsFor: 'testing' stamp: 'len 4/8/2018 18:45:19'!
isUnivariate
	^ self base isUnivariate! !

!AffineAlgebra methodsFor: 'testing' stamp: 'len 1/2/2022 09:55:36'!
isZeroDimensional
	"Answer true if the receiver is zero-dimensional (Krull dimension 0). Being zero-dimensional means that it has nonzero finite dimension as vector space over the coefficients field."
	^ self dimension = 0! !

!AffineAlgebra methodsFor: 'private' stamp: 'len 3/6/2021 06:05:59'!
elementClass
	^ RegularFunction! !

!AffineAlgebra methodsFor: 'private' stamp: 'len 7/19/2021 20:21:38'!
monomialsBelow: exponents do: aBlock
	exponents isEmpty ifTrue: [^ aBlock value: self monomials identity].
	self monomialsBelow: exponents allButLast do: [:each|
		0 to: exponents last - 1 do: [:i| aBlock value: each*(self monomials x: exponents size to: i)]]! !

!GaloisRing methodsFor: 'accessing' stamp: 'len 5/9/2019 09:25:41'!
exponent
	^ self scalars exponent! !

!GaloisRing methodsFor: 'accessing' stamp: 'len 5/21/2018 16:59:28'!
maximalIdeal
	^ self * self scalars p! !

!GaloisRing methodsFor: 'accessing' stamp: 'len 5/22/2018 04:08:03'!
p
	^ self scalars p! !

!GaloisRing methodsFor: 'accessing' stamp: 'len 9/22/2018 18:54:23'!
primitiveRoot
	"Answer a primitive root (or basic primitive element) of the receiver.
	For GR(p^n,r), a basic primitive element is an element of multiplicative order p^r - 1, which is a root of a basic primitive polynomial of degree r over Z/(p^n)Z and dividing x^(p^r - 1) - 1 in Z/(p^n)Z[x]. Powers of this element form a Teichmuller set."
	^ self notYetImplemented! !

!GaloisRing methodsFor: 'accessing' stamp: 'len 7/16/2021 11:06:57'!
residueField
	"Answer the Galois field GF(p,r) isomorphic to the residue field of the receiver, equipped with the canonical projection."
	^ self propertyAt: #residueField ifAbsentPut:
		[GaloisField modulus: (self modulus apply: self scalars -> self scalars residueField)]! !

!GaloisRing methodsFor: 'accessing' stamp: 'len 9/22/2018 18:54:27'!
teichmuller
	"Answer a Teichmuller set of the receiver.
	Any element of GR(p^n,r) can be written as a polynomial in p with coefficients in the Teichmuller set."
	| answer w |
	answer _ OrderedCollection new: self characteristic.
	answer add: self zero; add: self one.
	w _ self primitiveRoot.
	self characteristic - 2 timesRepeat: [answer add: (answer last * w)].
	^ answer! !

!GaloisRing methodsFor: 'enumerating' stamp: 'len 9/22/2018 18:53:46'!
idealsDo: aBlock
	| a |
	aBlock value: self * 0.
	a _ self one.
	self exponent timesRepeat:
		[aBlock value: self * a.
		a _ a * self p]! !

!GaloisRing methodsFor: 'morphisms' stamp: 'len 1/9/2022 20:52:58'!
project: anElement
	^ self representative: anElement \\ self modulus! !

!GaloisRing methodsFor: 'morphisms' stamp: 'len 1/2/2022 18:04:42'!
to: aCodomain
	aCodomain isGaloisRing ifFalse: [^ nil].
	"The subrings of GR(p^n,r) correspond to the positive divisors of r. If aCodomain is a suitable overring, answer an embedding of the receiver into the overring.
	Note that currently this is not canonical, embeddings are not made compatible."
	self flag: #fix.
	(self ~= aCodomain and: [self characteristic = aCodomain characteristic and: [self degree | aCodomain degree]])
		ifTrue: [^ self into: aCodomain evaluating: [:x| aCodomain project: (x representative ^ (self p ^ (aCodomain degree / self degree)))]].
	"Given GR(p^n,r), there's a projection to GR(p^m,r) for all m<=n, with kernel <p^m>. This accounts for all ideals."
	(self p = aCodomain p and: [self degree = aCodomain degree])
		ifTrue: [self scalars -> aCodomain scalars ifNotNil: [:aMorphism| ^ self to: aCodomain evaluating: [:x| aCodomain project: (x representative apply: aMorphism)]]].
	^ super to: aCodomain! !

!GaloisRing methodsFor: 'operations' stamp: 'len 5/21/2018 15:42:01'!
nilradical
	"Answer the ideal consisting of all nilpotent elements, i.e. all x such that there exists some n with x^n = 0. It is the intersection of all prime ideals.
	A finite ring is a Galois ring iff its nilradical is of the form <p> for some prime p. This is also the unique maximal ideal."
	^ self maximalIdeal! !

!GaloisRing methodsFor: 'operations' stamp: 'len 1/6/2022 09:23:25'!
zerodivisors
	^ self maximalIdeal! !

!GaloisRing methodsFor: 'testing' stamp: 'len 7/16/2021 11:13:25'!
hasCanonicalReduction
	^ true! !

!GaloisRing methodsFor: 'testing' stamp: 'len 1/2/2022 09:57:36'!
isBezout
	"Answer true if the receiver is a Bezout ring, i.e. every finitely generated ideal is principal."
	"All nonzero ideals are of the form <p^i>."
	^ true! !

!GaloisRing methodsFor: 'testing' stamp: 'len 9/16/2018 23:15:40'!
isChainRing
	"A chain ring is a ring whose ideals form a chain under inclusion.
	Galois rings are chain rings."
	^ true! !

!GaloisRing methodsFor: 'testing' stamp: 'len 12/31/2021 11:51:50'!
isEuclidean
	"Answer true if the receiver is a Euclidean ring, i.e. it has Euclidean division with remainder."
	"Galois rings are Euclidean."
	^ true! !

!GaloisRing methodsFor: 'testing' stamp: 'len 3/25/2021 15:04:26'!
isField
	^ self exponent = 1! !

!GaloisRing methodsFor: 'testing' stamp: 'len 5/21/2018 05:07:00'!
isFinite
	^ true! !

!GaloisRing methodsFor: 'testing' stamp: 'len 5/21/2018 05:06:26'!
isGaloisExtension
	^ true! !

!GaloisRing methodsFor: 'testing' stamp: 'len 9/22/2018 18:54:20'!
isGaloisRing
	^ true! !

!GaloisRing methodsFor: 'testing' stamp: 'len 7/16/2021 10:08:25'!
isIntegralDomain
	^ self isField! !

!GaloisRing methodsFor: 'testing' stamp: 'len 5/21/2018 16:54:03'!
isLocal
	^ true! !

!GaloisRing methodsFor: 'testing' stamp: 'len 7/16/2021 11:18:33'!
isSimpleExtension
	^ true! !

!GaloisRing methodsFor: 'private' stamp: 'len 3/6/2021 06:01:00'!
elementClass
	^ GaloisResidue! !

!GaloisRing class methodsFor: 'class initialization' stamp: 'len 5/15/2019 10:35:45'!
initialize
	super initialize.
	IrreduciblePolynomialsCache _ WeakValueDictionary new! !

!GaloisRing class methodsFor: 'examples' stamp: 'len 5/21/2018 07:19:51'!
example1
	"The Galois ring of characteristic 2^3 and order 2^6."
	^ GaloisRing new: 2 to: 3 to: 6! !

!GaloisRing class methodsFor: 'instance creation' stamp: 'len 8/5/2021 08:38:55'!
new: q to: m
	"Answer the Galois ring of characteristic q and order q^m."
	| factors n p |
	factors _ q factorization.
	factors asSet size = 1 ifFalse: [^ self error: 'not power of a prime'].
	n _ factors size.
	p _ factors anyOne.
	^ self new: p to: n to: m! !

!GaloisRing class methodsFor: 'instance creation' stamp: 'len 7/16/2021 10:25:36'!
new: p to: n to: m
	"Answer the Galois ring of characteristic p^n and order p^(n*m)."
	| F f |
	n = 1 ifTrue: [^ GaloisField new: p to: m].
	F _ PrimePowerRing new: p to: n.
	m = 1 ifTrue: [^ F].
	f _ self irreduciblePolynomialOfDegree: m mod: p.
	"Hensel lift to F"
	f _ f lift apply: F projection.
	^ self modulus: f! !

!GaloisRing class methodsFor: 'private' stamp: 'len 5/15/2019 10:41:16'!
irreduciblePolynomialOfDegree: m mod: p
	^ (IrreduciblePolynomialsCache at: {p. m} ifAbsent: []) ifNil: [IrreduciblePolynomialsCache at: {p. m} put: ((PrimeField new: p) polynomials findIrreducibleOfDegree: m)]! !

!GaloisField methodsFor: 'accessing' stamp: 'len 5/23/2020 09:13:12'!
universalPolynomial
	"Answer the universal polynomial of which all elements of the receiver are roots."
	^  polynomials !! [:x| x^self size - x]! !

!GaloisField methodsFor: 'comparing' stamp: 'len 9/22/2018 18:53:34'!
~ aRing
	"Any two finite fields of the same cardinality are isomorphic."
	^ aRing isField and: [self size = aRing size]! !

!GaloisField methodsFor: 'computing-matrices' stamp: 'len 12/31/2021 09:17:11'!
matrix: B divisionBy: A
	"Answer X and N such that AX + N = B, satisfying that if the i-th column of B is a linear combination of the columns of A then the i-th column of N is zero."
	^ self matrixOverField: B divisionBy: A! !

!GaloisField methodsFor: 'computing-matrices' stamp: 'len 12/31/2021 08:18:56'!
syzygiesOf: aMatrix
	"Answer a matrix whose rows span the kernel of the given matrix.
	For a matrix A, the output is X with AX = 0."
	^ self syzygiesOverEuclideanDomainOf: aMatrix! !

!GaloisField methodsFor: 'morphisms' stamp: 'len 7/13/2021 14:36:18'!
automorphisms
	"Answer the Galous group of the receiver, i.e. the gruop of endomorphisms fixing the scalar field Z/pZ."
	^ Group new generators: {self frobenius}! !

!GaloisField methodsFor: 'testing' stamp: 'len 7/27/2021 08:48:56'!
hasEchelonization
	^ true! !

!GaloisField methodsFor: 'testing' stamp: 'len 12/14/2016 10:15:29'!
isAbelianExtension
	"Galois fields are Abelian extensions."
	^ true! !

!GaloisField methodsFor: 'testing' stamp: 'len 6/9/2019 09:35:56'!
isField
	^ true! !

!GaloisField methodsFor: 'testing' stamp: 'len 7/15/2021 16:07:16'!
isFiniteField
	^ true! !

!GaloisField class methodsFor: 'examples' stamp: 'len 5/21/2018 06:46:16'!
example1
	"The Galois field of order 2^3."
	^ GaloisField new: 8! !

!GaloisField class methodsFor: 'examples' stamp: 'len 5/21/2018 06:46:33'!
example2
	"The Galois field of order 5^3."
	^ GaloisField new: 5 to: 3! !

!GaloisField class methodsFor: 'instance creation' stamp: 'len 8/5/2021 08:38:46'!
new: q
	"Answer the Galois field of order q = p^n."
	| factors n p |
	factors _ q factorization.
	factors asSet size = 1 ifFalse: [^ self error: 'not power of a prime'].
	n _ factors size.
	p _ factors anyOne.
	^ self new: p to: n! !

!GaloisField class methodsFor: 'instance creation' stamp: 'len 7/16/2021 10:25:18'!
new: p to: n
	"Answer the Galois field of order q = p^n."
	n = 1 ifTrue: [^ PrimeField new: p].
	^ self modulus: (self irreduciblePolynomialOfDegree: n mod: p)! !

!QuasiGaloisRing methodsFor: 'testing' stamp: 'len 7/16/2021 11:14:09'!
hasCanonicalReduction
	^ true! !

!QuasiGaloisRing methodsFor: 'testing' stamp: 'len 5/9/2019 09:48:43'!
isFinite
	^ true! !

!QuasiGaloisRing methodsFor: 'testing' stamp: 'len 5/9/2019 09:54:52'!
isIntegralDomain
	^ false! !

!QuasiGaloisRing methodsFor: 'testing' stamp: 'len 5/9/2019 09:48:39'!
isLocal
	^ true! !

!QuasiGaloisRing methodsFor: 'testing' stamp: 'len 7/16/2021 11:18:50'!
isSimpleExtension
	^ true! !

!QuasiGaloisRing class methodsFor: 'instance creation' stamp: 'len 7/15/2021 19:18:19'!
new: p to: r to: n
	"Answer the quasi-Galois ring of characteristic p and order p^(r*n)."
	| F f |
	F _ GaloisField new: p to: r.
	n = 1 ifTrue: [^ F].
	f _ F polynomials x: 1 to: n.
	^ self relations: f parent * f! !

!LaurentPolynomialRing methodsFor: 'as yet unclassified' stamp: 'len 1/15/2022 17:59:24'!
elementClass
	^ LaurentPolynomial! !

!LaurentPolynomialRing methodsFor: 'as yet unclassified' stamp: 'len 1/15/2022 17:21:38'!
printIndeterminatesOn: aStream
	self indeterminates
		do: [:i| aStream print: (self x: i)]
		separatedBy: [aStream nextPut: $,]! !

!LaurentPolynomialRing class methodsFor: 'as yet unclassified' stamp: 'len 1/15/2022 17:58:08'!
monomials: aFreeAbelianMonoid over: aRing
	| h R |
	aFreeAbelianMonoid rank even ifFalse: [^ self error: 'should have an even number of indeterminates'].
	h _ aFreeAbelianMonoid rank / 2.
	R _ PolynomialRing monomials: aFreeAbelianMonoid over: aRing.
	^ self relations: R * ((1 to: h) collect: [:i| (R x: i) * (R x: i+h) - 1])! !

!LaurentPolynomialRing class methodsFor: 'as yet unclassified' stamp: 'len 1/15/2022 18:02:14'!
new: anInteger over: aRing
	^ self monomials: (FreeAbelianMonoid new: anInteger*2) over: aRing! !

!LaurentPolynomialRing class methodsFor: 'as yet unclassified' stamp: 'len 1/15/2022 18:02:43'!
new: anInteger over: aRing ordering: aMonomialOrdering
	^ self monomials: (FreeAbelianMonoid new: anInteger*2 ordering: aMonomialOrdering) over: aRing! !

!FunctionField methodsFor: 'accessing' stamp: 'len 1/5/2017 19:50:45'!
genus
	^ self notYetImplemented! !

!FunctionField methodsFor: 'morphisms' stamp: 'len 1/4/2022 09:12:32'!
project: anElement
	^ self representative: anElement \\ self modulus! !

!FunctionField methodsFor: 'testing' stamp: 'len 7/16/2021 11:13:14'!
hasCanonicalReduction
	^ true! !

!FunctionField methodsFor: 'testing' stamp: 'len 7/27/2021 08:48:44'!
hasEchelonization
	^ true! !

!FunctionField methodsFor: 'testing' stamp: 'len 6/9/2019 09:35:47'!
isField
	^ true! !

!FunctionField methodsFor: 'testing' stamp: 'len 7/15/2021 16:04:56'!
isGlobalField
	^ self scalars isFiniteField! !

!FunctionField methodsFor: 'testing' stamp: 'len 7/16/2021 10:08:10'!
isIntegralDomain
	^ true! !

!FunctionField methodsFor: 'testing' stamp: 'len 1/5/2017 18:55:12'!
isPerfectField
	"A field is perfect if either it has characteristic 0 or has characteristic p and every element in the field has a p-th root in the field."
	^ self characteristic = 0! !

!FunctionField methodsFor: 'testing' stamp: 'len 7/16/2021 11:18:25'!
isSimpleExtension
	^ true! !

!FunctionField methodsFor: 'private' stamp: 'len 7/15/2021 19:12:04'!
extensionClass
	^ FunctionField! !

!NumberField methodsFor: 'accessing' stamp: 'len 7/16/2021 11:07:47'!
adjoint
	^ self propertyAt: #adjoint ifAbsentPut: [self modulus anyRootIn: ]! !

!NumberField methodsFor: 'accessing' stamp: 'len 7/12/2021 13:17:44'!
classNumber
	^ self propertyAt: #classNumber! !

!NumberField methodsFor: 'accessing' stamp: 'len 7/15/2021 20:10:22'!
discriminant
	"The discriminant of an integral basis is independent of the choice of basis and it's called the discriminant of the field K and denoted d(K)."
	^ self propertyAt: #discriminant ifAbsentPut:
		[| B |
		B _ self integralBasis.
		(self asVectorSpace endomorphisms filling: [:i :j| ((B at: i) * (B at: j)) trace]) determinant]! !

!NumberField methodsFor: 'accessing' stamp: 'len 7/15/2021 16:52:28'!
integers
	"Answer the ring of integers of the receiver."
	^ self propertyAt: #integers ifAbsentPut: [MaximalOrder on: self]! !

!NumberField methodsFor: 'accessing' stamp: 'len 1/11/2016 03:48'!
integralBasis
	^ self notYetImplemented "COHEN 6.1.8"! !

!NumberField methodsFor: 'accessing' stamp: 'len 7/10/2021 11:56:01'!
integralBasisMatrix
	"Answer the matrix that sends power basis coordinates to integral basis coordinates."
	^ self propertyAt: #integralBasisMatrix ifAbsentPut: [self asVectorSpace endomorphisms columns: (self integralBasis collect: [:each| self asVectorSpace !! each])]! !

!NumberField methodsFor: 'accessing' stamp: 'len 7/16/2021 11:08:15'!
signature
	"Answer the signature (r1,r2) of the receiver, i.e. r1 the number of embeddings whose image is real, and 2*r2 the number of non-real complex embeddings."
	^ self modulus signature! !

!NumberField methodsFor: 'elements' stamp: 'len 7/11/2021 11:16:06'!
adapt: anElement
	((anElement isKindOf: AlgebraicInteger) and: [anElement parent fractions = self])
		ifTrue: [^ self representative: (self base coefficients: self integralBasisMatrix * anElement asModuleElement)].
	^ super adapt: anElement! !

!NumberField methodsFor: 'morphisms' stamp: 'len 7/16/2021 11:07:36'!
<-> aNumberField
	"Field Isomorphism Problem. Answer an isomorphism to aNumberField if there's any, or nil.
	Reference: Henri Cohen, 'A Course In Computational Algebraic Number Theory', Algorithm 4.5.5 and 4.5.6."
	(self modulus isIrreducible and: [self modulus isPrimitive])
		ifFalse: [^ self error: 'not irreducible and primitive defining polynomial'].
	(aNumberField modulus isIrreducible and: [aNumberField modulus isPrimitive])
		ifFalse: [^ self error: 'not irreducible and primitive defining polynomial'].
	self modulus degree = aNumberField modulus degree
		ifFalse: [^ nil].
	"..."
	self notYetImplemented! !

!NumberField methodsFor: 'morphisms' stamp: 'len 11/12/2016 07:14'!
preferedEmbedding
	^ self embeddings detect: [:one| (one value: self x) = self adjoint]! !

!NumberField methodsFor: 'morphisms' stamp: 'len 1/4/2022 09:12:17'!
project: anElement
	^ self representative: anElement \\ self modulus! !

!NumberField methodsFor: 'morphisms' stamp: 'len 5/23/2020 09:04:21'!
realEmbeddings
	^ self embeddingsIn: ! !

!NumberField methodsFor: 'operations' stamp: 'len 1/10/2016 22:34'!
archimedeanPlaces
	^ self notYetImplemented! !

!NumberField methodsFor: 'operations' stamp: 'len 1/10/2016 22:34'!
nonArchimedeanPlaces
	^ self notYetImplemented! !

!NumberField methodsFor: 'operations' stamp: 'len 1/11/2016 03:53'!
regulator
	^ self notYetImplemented! !

!NumberField methodsFor: 'testing' stamp: 'len 7/16/2021 11:13:37'!
hasCanonicalReduction
	^ true! !

!NumberField methodsFor: 'testing' stamp: 'len 7/27/2021 08:49:22'!
hasEchelonization
	^ true! !

!NumberField methodsFor: 'testing' stamp: 'len 6/9/2019 09:36:07'!
isField
	^ true! !

!NumberField methodsFor: 'testing' stamp: 'len 7/16/2021 11:07:54'!
isGaloisExtension
	self degree = 3 ifTrue: [^ self modulus discriminant isPerfectSquare].
	self notYetImplemented! !

!NumberField methodsFor: 'testing' stamp: 'len 1/26/2018 18:59:52'!
isGlobalField
	^ true! !

!NumberField methodsFor: 'testing' stamp: 'len 12/10/2016 21:44:21'!
isImaginary
	"Answer true if no embedding into the complex numbers has image contained in the real numbers."
	^ self signature first = 0! !

!NumberField methodsFor: 'testing' stamp: 'len 7/16/2021 10:08:38'!
isIntegralDomain
	^ true! !

!NumberField methodsFor: 'testing' stamp: 'len 12/28/2016 12:13:05'!
isMonogenic
	^ self propertyAt: #isMonogenic! !

!NumberField methodsFor: 'testing' stamp: 'len 12/10/2016 21:44:39'!
isReal
	"Answer true if every embedding into the complex numbers has image contained in the real numbers."
	^ self signature second = 0! !

!NumberField methodsFor: 'testing' stamp: 'len 7/16/2021 11:18:41'!
isSimpleExtension
	^ true! !

!NumberField methodsFor: 'private' stamp: 'len 7/15/2021 19:12:19'!
extensionClass
	^ NumberField! !

!NumberField class methodsFor: 'examples' stamp: 'len 5/23/2020 09:11:37'!
example
	^  adjoin: RealAlgebraicNumber sqrt2! !

!NumberField class methodsFor: 'instance creation' stamp: 'len 7/16/2021 10:29:58'!
adjoint: anAlgebraicNumber
	^ (self modulus: anAlgebraicNumber minimalPolynomial)
		propertyAt: #adjoint put: anAlgebraicNumber;
		yourself! !

!CyclotomicField methodsFor: 'accessing' stamp: 'len 7/12/2021 13:17:27'!
classNumber
	self order <= 22 ifTrue: [^ 1].
	self order = 23 ifTrue: [^ 3].
	self order <= 28 ifTrue: [^ 1].
	^ super classNumber! !

!CyclotomicField methodsFor: 'accessing' stamp: 'len 8/5/2021 08:37:32'!
discriminant
	| n phi |
	n _ self order.
	phi _ n phi.
	^ -1 ^ (phi / 2) * (n ^ phi) / (n factorization asSet product: [:p| p ^ (phi / (p - 1))])! !

!CyclotomicField methodsFor: 'accessing' stamp: 'len 7/10/2021 11:48:12'!
integers
	"Answer the ring of integers of the receiver."
	^ self propertyAt: #integers ifAbsentPut: [CyclotomicRing on: self]! !

!CyclotomicField methodsFor: 'accessing' stamp: 'len 7/10/2021 12:10:16'!
integralBasis
	^ self basis! !

!CyclotomicField methodsFor: 'accessing' stamp: 'len 12/28/2016 12:13:09'!
order
	^ self propertyAt: #order! !

!CyclotomicField methodsFor: 'morphisms' stamp: 'len 7/14/2021 09:19:20'!
automorphisms
	"Answer the Galois group of the receiver, i.e. the group of endomorphisms fixing the rationals."
	^ (/self order) units "TODO: add coercion map to hom-set"! !

!CyclotomicField methodsFor: 'testing' stamp: 'len 12/10/2016 20:13:22'!
isAbelianExtension
	"Cyclotomic fields are Abelian extensions."
	^ true! !

!CyclotomicField methodsFor: 'testing' stamp: 'len 12/10/2016 20:16:17'!
isGaloisExtension
	^ true! !

!CyclotomicField methodsFor: 'testing' stamp: 'len 12/18/2016 21:54:02'!
isMonogenic
	^ true! !

!CyclotomicField class methodsFor: 'examples' stamp: 'len 12/12/2016 17:12:54'!
example
	^ CyclotomicField new: 7! !

!CyclotomicField class methodsFor: 'instance creation' stamp: 'len 7/16/2021 10:24:27'!
new: anInteger
	anInteger > 2 ifFalse: [^ self error: 'the order of a cyclotomic field must be > 2'].
	^ (self modulus: (( polynomialsIn: {'', anInteger printString sub}) cyclotomic: anInteger))
		propertyAt: #order put: anInteger;
		yourself! !

!QuadraticField methodsFor: 'accessing' stamp: 'len 12/10/2016 21:33:00'!
discriminant
	| d |
	^ (d _ self d) \\ 4 = 1 ifTrue: [d] ifFalse: [d*4]! !

!QuadraticField methodsFor: 'accessing' stamp: 'len 7/10/2021 11:48:27'!
integers
	"Answer the ring of integers of the receiver."
	^ self propertyAt: #integers ifAbsentPut: [QuadraticRing on: self]! !

!QuadraticField methodsFor: 'accessing' stamp: 'len 12/17/2021 14:24:58'!
integralBasis
	^ {self one. self d \\ 4 = 1 ifTrue: [self one + self x / 2] ifFalse: [self x]}! !

!QuadraticField methodsFor: 'testing' stamp: 'len 12/18/2016 21:54:14'!
isMonogenic
	^ true! !

!QuadraticField methodsFor: 'private' stamp: 'len 7/16/2021 11:08:48'!
d
	^ self modulus independentCoefficient asInteger negated! !

!QuadraticField class methodsFor: 'examples' stamp: 'len 1/4/2022 12:28:41'!
example
	"The Gaussian numbers, i.e. complex numbers with real and imaginary parts both rational."
	^ QuadraticField sqrt: -1! !

!QuadraticField class methodsFor: 'instance creation' stamp: 'len 1/9/2022 08:34:39'!
sqrt: anInteger
	| P d |
	d _ anInteger squarefreePart.
	(d == 0 or: [d == 1]) ifTrue: [DomainError signal: 'not a quadratic field'].
	P _  polynomialsIn: {d == -1 ifTrue: ['i' italic] ifFalse: ['', d printString]}.
	^ self modulus: P x squared - d! !

!GaussianField methodsFor: 'accessing' stamp: 'len 1/4/2022 14:59:24'!
integers
	"Answer the ring of integers of the receiver."
	^ self propertyAt: #integers ifAbsentPut: [GaussianRing on: self]! !

!GaussianField methodsFor: 'elements' stamp: 'len 1/4/2022 14:57:27'!
i
	^ self x! !

!GaussianField methodsFor: 'elements' stamp: 'len 1/4/2022 15:24:48'!
real: aRational imaginary: anotherRational
	^ self i * anotherRational + aRational! !

!GaussianField methodsFor: 'testing' stamp: 'len 1/4/2022 15:10:53'!
isInvolutive
	^ true! !

!GaussianField methodsFor: 'private' stamp: 'len 1/4/2022 18:16:19'!
elementClass
	^ GaussianRational! !

!GaussianField class methodsFor: 'instance creation' stamp: 'len 1/4/2022 15:04:43'!
new
	| P |
	P _  polynomialsIn: {'i' italic}.
	^ super new relations: P * (P x squared + 1)! !

!RationalIntegerRing methodsFor: 'accessing' stamp: 'len 11/5/2015 17:34'!
characteristic
	^ 0! !

!RationalIntegerRing methodsFor: 'accessing' stamp: 'len 10/20/2016 03:32'!
dimension
	"Answer the Krull dimension of the receiver."
	^ 1! !

!RationalIntegerRing methodsFor: 'accessing' stamp: 'len 11/5/2015 19:19'!
one
	^ 1! !

!RationalIntegerRing methodsFor: 'accessing' stamp: 'len 5/10/2020 08:45:11'!
primes
	^ Iterator on: [:aBlock| | p |
		p _ 2.
		[aBlock value: p.
		p _ p nextPrime] repeat]! !

!RationalIntegerRing methodsFor: 'accessing' stamp: 'len 12/29/2021 11:55:57'!
size
	^ Cardinal new! !

!RationalIntegerRing methodsFor: 'accessing' stamp: 'len 11/3/2015 20:50'!
zero
	^ 0! !

!RationalIntegerRing methodsFor: 'comparing' stamp: 'len 6/22/2019 03:32:02'!
< aDomain
	^ aDomain isRing! !

!RationalIntegerRing methodsFor: 'comparing' stamp: 'len 11/10/2015 23:14'!
= anObject
	^ anObject class == self class! !

!RationalIntegerRing methodsFor: 'comparing' stamp: 'len 12/14/2015 01:59'!
hash
	^ self class hash! !

!RationalIntegerRing methodsFor: 'computing-matrices' stamp: 'len 12/31/2021 09:18:39'!
matrix: B divisionBy: A
	"Answer X and N such that AX + N = B, satisfying that if the i-th column of B is a linear combination of the columns of A then the i-th column of N is zero.
	Attempt to use Dixon's p-adic method [Dix82] for non-singular square matrices, and fallback to the general method for Euclidean domains if this fails."
	| p C lengths   m M T X |
	(A isSquare and: [B width > 0]) ifFalse: [^ self matrixOverEuclideanDomain: B divisionBy: A].
"	 _ 2.
	A do: [:each|  _  max: each abs].
	B do: [:each|  _  max: each abs].
	p _ ( min: 16rFFFFFFFF) atRandom nextPrime."
	p _ 16rFFFFFFFF atRandom nextPrime.
	C _ (A over: (PrimeField new: p)) inverse. "this can fail if p divides det(A)"
	C isNil ifTrue: [^ self matrixOverEuclideanDomain: B divisionBy: A].
	lengths _ OrderedCollection new: A width + 1.
	lengths add: (B columns max: [:b| b length]).
	A columnsDo: [:each| lengths add: each length].
	 _ lengths sorted allButFirst product.
	 _ 0.6180339887498949. "root of x^2 + x - 1"
	m _ (( / ) log / p log * 2) ceiling.
	M _ (PrimePowerRing new: p to: m)^B height.
	T _ (M scalars modulus // 2) sqrtFloor.
	X _ Matrix from: B domain to: A domain columns:
		(B columns collect: [:b|
			| xx bb x reconstruction |
			xx _ OrderedCollection new: m.
			bb _ b.
			m timesRepeat:
				[xx add: (C*bb) lift.
				bb _ bb - (A*xx last) // p].
			x _ (0 to: m - 1) sum: [:i| M !! (xx at: i+1) * (p^i)].
			"self assert: (A over: M scalars) * x = (B over: M scalars) asTuple."
			reconstruction _ x asArray collect: [:each| each asRational: T].
			(reconstruction allSatisfy: [:each| each notNil and: [each isIntegral]])
				ifTrue: [M lift filling: [:i| reconstruction at: i]]
				ifFalse: [M lift zero]]).
	^ {X. B - (A*X)}! !

!RationalIntegerRing methodsFor: 'computing-polynomials' stamp: 'len 1/9/2022 08:18:48'!
factorizationOf2: aPolynomial
	| answer f g |
	answer _ Bag new.
	aPolynomial content factorizationDo: [:p :e| answer add: (aPolynomial parent constant: p) withOccurrences: e].
	g _ aPolynomial gcd: aPolynomial derivative.
	f _ aPolynomial / g.
	"TODO: if the receiver is not squarefree, we're missing powers of factors"
	(f / (f content * f sign)) factorizationZassenhauss
		withOccurrencesDo: [:each :k|
			answer add: each withOccurrences: k].
	^ answer! !

!RationalIntegerRing methodsFor: 'computing-polynomials' stamp: 'len 1/9/2022 08:35:58'!
factorizationOf: aPolynomial
	| answer content |
	answer _ Bag new.
	(content _ aPolynomial content) factorizationDo: [:p :e| answer add: (aPolynomial parent constant: p) withOccurrences: e].
	(aPolynomial // (content * aPolynomial sign)) squarefreeFactorization withOccurrencesDo: [:f :r|
		f factorizationZassenhauss do: [:each| answer add: each withOccurrences: r]].
	^ answer! !

!RationalIntegerRing methodsFor: 'converting' stamp: 'len 4/30/2021 13:12:57'!
asModule
	^ self asIdeal! !

!RationalIntegerRing methodsFor: 'enumerating' stamp: 'len 11/10/2015 17:57'!
do: aBlock
	| i |
	aBlock value: 0.
	i _ 1.
	[ aBlock value: i; value: i negated. i _ i + 1 ] repeat! !

!RationalIntegerRing methodsFor: 'enumerating' stamp: 'len 5/4/2018 19:42:06'!
primeIdealsDo: aBlock
	| p |
	p _ 0.
	[aBlock value: self * p.
	p _ p nextPrime] repeat! !

!RationalIntegerRing methodsFor: 'enumerating' stamp: 'len 9/22/2018 18:58:29'!
unitsDo: aBlock
	aBlock value: 1; value: -1! !

!RationalIntegerRing methodsFor: 'morphisms' stamp: 'len 12/22/2021 15:02:27'!
to: aCodomain
	aCodomain isRing ifTrue: [^ aCodomain addMap: (self to: aCodomain evaluating: [:x| aCodomain one * x])].
	^ super to: aCodomain! !

!RationalIntegerRing methodsFor: 'operations' stamp: 'len 1/9/2022 21:00:29'!
/ anInteger
	anInteger isInteger ifTrue:
		[| factors |
		factors _ anInteger factorization.
		factors asSet size = 1 ifTrue:
			[^ PrimePowerRing new: factors anyOne to: factors size].
		^ (ModularIntegerRing new: anInteger) modulusFactors: factors].
	(anInteger isKindOf: Ideal) ifFalse: [^ self / (self * anInteger)].
	self = anInteger scalars ifFalse: [^ self error: 'ideal belongs to a different ring'].
	^ self / anInteger generator! !

!RationalIntegerRing methodsFor: 'operations' stamp: 'len 8/6/2019 17:33:17'!
adic: aPrime
	^ AdicRing at: aPrime! !

!RationalIntegerRing methodsFor: 'operations' stamp: 'len 8/6/2019 17:33:17'!
adic: aPrime precision: anInteger
	^ AdicRing at: aPrime precision: anInteger! !

!RationalIntegerRing methodsFor: 'operations' stamp: 'len 5/23/2020 09:11:37'!
fractions
	^ ! !

!RationalIntegerRing methodsFor: 'operations' stamp: 'len 4/8/2021 12:38:46'!
radical
	"Answer the Jacobson radical J(R) of the receiver R. This is the ideal consisting of all elements that annihilate all simple R-modules. It is the intersection of all maximal ideals."
	^ self asIdeal null! !

!RationalIntegerRing methodsFor: 'operations' stamp: 'len 6/19/2019 14:53:51'!
units
	"Answer the multiplicative group of units of the receiver (i.e., elements that have multiplicative inverse)."
	^ (UnitGroup on: self) elements: {1. -1}! !

!RationalIntegerRing methodsFor: 'operations' stamp: 'len 1/6/2022 09:24:37'!
zerodivisors
	^ #(0)! !

!RationalIntegerRing methodsFor: 'random' stamp: 'len 7/14/2020 17:33:43'!
atRandom: aRandom bits: bitSize
	| n |
	bitSize isInfinite ifTrue: [^ self error: 'infinite bitsize'].
	bitSize < 0 ifTrue: [^ self error: 'negative bitsize'].
	bitSize = 0 ifTrue: [^ 0].
	bitSize < 1 ifTrue: [^ ((2/bitSize) truncated atRandom: aRandom) = 1 ifTrue: [(-1 to: 1) atRandom: aRandom] ifFalse: [0]].
	n _ 2^(bitSize truncated - 1).
	^ (0-n to: n) atRandom: aRandom! !

!RationalIntegerRing methodsFor: 'random' stamp: 'len 5/1/2021 12:31:05'!
atRandom: aRandom modulo: anIdeal
	^ (anIdeal generator abs atRandom: aRandom) - 1! !

!RationalIntegerRing methodsFor: 'testing' stamp: 'len 11/23/2015 02:37'!
includes: anObject
	^ anObject isInteger! !

!RationalIntegerRing methodsFor: 'testing' stamp: 'len 6/4/2019 16:15:35'!
isBezout
	"Answer true if the receiver is a Bezout ring, i.e. every finitely generated ideal is principal."
	^ true! !

!RationalIntegerRing methodsFor: 'testing' stamp: 'len 4/28/2021 09:35:15'!
isCommutative
	^ true! !

!RationalIntegerRing methodsFor: 'testing' stamp: 'len 1/2/2022 10:08:56'!
isDedekindDomain
	"A Dedekind domain is an integral domain in which every nonzero proper ideal factors into a product of prime ideals."
	^ true! !

!RationalIntegerRing methodsFor: 'testing' stamp: 'len 12/31/2021 11:50:30'!
isEuclidean
	"Answer true if the receiver is a Euclidean ring, i.e. it has Euclidean division with remainder."
	^ true! !

!RationalIntegerRing methodsFor: 'testing' stamp: 'len 11/7/2015 21:58'!
isFinite
	^ false! !

!RationalIntegerRing methodsFor: 'testing' stamp: 'len 1/8/2017 07:49:36'!
isIntegralDomain
	^ true! !

!RationalIntegerRing methodsFor: 'testing' stamp: 'len 3/21/2021 15:10:44'!
isNoetherian
	"A ring is called Noetherian if every ideal is finitely generated."
	^ true! !

!RationalIntegerRing methodsFor: 'testing' stamp: 'len 10/2/2018 01:52:16'!
isOrdered
	^ true! !

!RationalIntegerRing methodsFor: 'testing' stamp: 'len 8/9/2020 08:00:07'!
isReal
	"Answer true if the receiver is a subring of the real field."
	^ true! !

!RationalIntegerRing methodsFor: 'testing' stamp: 'len 1/2/2022 10:09:04'!
isReduced
	"Answer true if the receiver has no nonzero nilpotent elements, or equivalently if it has no nonzero elements with square zero, i.e. x^2 = 0 implies x = 0."
	^ true! !

!RationalIntegerRing methodsFor: 'private' stamp: 'len 12/15/2021 15:21:39'!
idealClass
	^ RationalIntegerIdeal! !

!RationalIntegerRing class methodsFor: 'initialization' stamp: 'len 5/23/2020 08:50:48'!
initialize
	super initialize.
	Smalltalk at: # put: self new! !

!PolynomialRing methodsFor: 'printing' stamp: 'len 7/27/2021 12:58:30'!
printIndeterminatesOn: aStream
	self indeterminates
		do: [:i| aStream print: (self x: i)]
		separatedBy: [aStream nextPut: $,]! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 1/2/2017 10:08:58'!
characteristic
	^ scalars characteristic! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 1/14/2022 11:50:24'!
dimension
	"Answer the Krull dimension of the receiver."
	self ordering isLocal ifTrue: [^ -1].
	self ordering isGlobal ifFalse: [^ self error: 'not a global ring'].
	self scalars isNoetherian ifTrue: [^ self scalars dimension + self rank].
	^ super dimension! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 3/19/2021 16:17:21'!
generators
	"Answer the generators of the receiver as an algebra over the coefficients ring."
	^ (1 to: self rank) collect: [:i| self x: i]! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 7/31/2021 10:56:04'!
gradings
	"Answer the degrees of the indeterminates of the receiver."
	^ self ordering isGradedWeighted ifTrue: [self ordering weights] ifFalse: [(1 to: self rank) collect: [:i| 1]]! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 6/4/2016 05:12'!
indeterminate
	"Answer the univariate indeterminate."
	^ 1! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 10/22/2016 18:16'!
indeterminates
	^ 1 to: self rank! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 1/14/2022 11:54:36'!
maximalIdeal
	"If the receiver is a local ring, answer the unique maximal ideal."
	self isLocal ifFalse: [self error: 'the ring is not local'].
	^ self * self generators! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 11/20/2016 14:15:52'!
monomials
	"Answer the monoid of monomials of the receiver."
	^ monomials! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 2/27/2017 07:41:18'!
names
	"Answer the indeterminate names to use when printing polynomials."
	^ monomials names! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 7/26/2020 13:13:46'!
names: anArray
	"Set indeterminate names to use when printing polynomials."
	monomials names: anArray! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 1/22/2017 20:42:36'!
one
	^ self propertyAt: #one ifAbsentPut: [self constant: self scalars one]! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 11/20/2016 12:07:07'!
ordering
	^ monomials ordering! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 1/2/2017 10:08:31'!
rank
	"The rank of a polynomial ring is the number of indeterminates. Univariate polynomials have rank 1."
	^ monomials rank! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 1/2/2017 10:08:53'!
scalars
	^ scalars! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 12/29/2021 11:55:57'!
size
	^ Cardinal new * self scalars size! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 1/22/2017 20:42:15'!
zero
	^ self propertyAt: #zero ifAbsentPut: [self constant: self scalars zero]! !

!PolynomialRing methodsFor: 'comparing' stamp: 'len 1/14/2022 11:58:39'!
= anObject
	self == anObject ifTrue: [^ true].
	^ self class == anObject class and: [scalars = anObject scalars and: [monomials = anObject monomials]]! !

!PolynomialRing methodsFor: 'comparing' stamp: 'len 8/30/2016 07:09'!
~ aPolynomialRing
	"Answer true if the receiver is canonically isomorphic to the argument."
	"R[x][y] ~ R[x,y]"
	self notYetImplemented! !

!PolynomialRing methodsFor: 'comparing' stamp: 'len 8/8/2019 05:43:35'!
hash
	^ self scalars hash + self rank! !

!PolynomialRing methodsFor: 'computing-matrices' stamp: 'len 1/13/2022 11:49:46'!
basisAndTransformationOf: aMatrix
	"Andswer a standard basis of the module generated by the columns of aMatrix and a transformation matrix that maps the original generators to the basis."
	| buchberger |
	buchberger _ ExtendedBuchberger new matrix: aMatrix; run.
	^ {buchberger basisMatrix. buchberger transformation}! !

!PolynomialRing methodsFor: 'computing-matrices' stamp: 'len 1/13/2022 11:49:25'!
basisOf: aMatrix
	"Compute a standard basis from the columns of aMatrix with the specified ordering.
	When the monomial ordering is global, the algorithm outputs a Groebner basis. In case of a local monomial ordering, the algorithm uses Mora's normal form and outputs a standard basis."
	^ Buchberger new matrix: aMatrix; run; basisMatrix! !

!PolynomialRing methodsFor: 'computing-matrices' stamp: 'len 1/14/2022 09:49:04'!
matrix: B divisionBy: A
	"Answer X and N such that AX + N = B, satisfying that if the i-th column of B is a linear combination of the columns of A then the i-th column of N is zero."
	| basisAndTransformation G T C basis X |
	self isEuclideanDomain ifTrue: [^ self matrixOverEuclideanDomain: B divisionBy: A].
	basisAndTransformation _ A basisAndTransformation.
	G _ basisAndTransformation first.
	T _ basisAndTransformation second.
	A height = 1
		ifTrue: [C _ B asTuple asArray. basis _ G asTuple asArray]
		ifFalse: [C _ B columns. basis _ G columns].
	X _ Matrix to: A domain columns: (C collect: [:each| T  * (T domain !! (each // basis))]).
	^ {X. B - (A*X)}! !

!PolynomialRing methodsFor: 'computing-matrices' stamp: 'len 1/14/2022 11:34:26'!
syzygiesOf: aMatrix
	"Answer a matrix whose rows span the kernel of the given matrix.
	For a matrix A, the output is X with AX = 0."
	| basisAndTransformation G T S syzygies |
	self isEuclideanDomain ifTrue: [^ self syzygiesOverEuclideanDomainOf: aMatrix].
	basisAndTransformation _ aMatrix basisAndTransformation.
	G _ basisAndTransformation first.
	T _ basisAndTransformation second.
	self assert: aMatrix*T = G.
	syzygies _ OrderedCollection new.
	1 to: G width - 1 do: [:i|
		| gi hi |
		gi _ G columnAt: i.
		hi _ gi leadingMonomial.
		i+1 to: G width do: [:j|
			| gj hj q s |
			gj _ G columnAt: j.
			hj _ gj leadingMonomial.
			(hi lcm: hj) ifNotNil: [:lcm|
				| ri rj |
				ri _ lcm / hi.
				rj _ lcm / hj.
				q _ G domain !! (gi * ri - (gj * rj) // G columns).
				s _ (G domain x: i monomial: ri) - (G domain x: j monomial: rj) - q.
				s _ T * s.
				s isZero ifFalse: [syzygies add: s]]]].
	S _ Matrix to: G domain columns: (aMatrix columns collect: [:each| G domain !! (each // G columns)]).
	self assert: G*S = aMatrix.
	^ Matrix to: aMatrix domain columns: syzygies, ((aMatrix domain id - (T*S)) columns select: [:each| each isZero not])! !

!PolynomialRing methodsFor: 'converting' stamp: 'len 4/27/2021 15:46:56'!
asMultivariate
	"If the receiver is a univariate polynomial ring with coefficients in a polynomial ring R[x1..xn][y], answer a new multivariate polynomial ring R[x1,...,xn,y]."
	| answer |
	self isUnivariate ifFalse: [^ self].
	(self scalars isKindOf: PolynomialRing) ifFalse: [^ self].
	self propertyAt: #asMultivariate ifPresent: [:aPolynomialRing| ^ aPolynomialRing].
	answer _ self class monomials: self scalars monomials  self monomials over: self scalars scalars.
	answer propertyAt: #asUnivariate put: self.
	^ self propertyAt: #asMultivariate put: answer! !

!PolynomialRing methodsFor: 'converting' stamp: 'len 3/6/2021 15:24:13'!
asUnivariate
	self isUnivariate ifTrue: [^ self].
	^ self propertyAt: #asUnivariate ifAbsentPut: [self asUnivariateIn: self rank]! !

!PolynomialRing methodsFor: 'converting' stamp: 'len 4/28/2021 14:49:51'!
asUnivariateIn: anIndeterminate
	| answer |
	(anIndeterminate > 0 and: [anIndeterminate <= self rank]) ifFalse: [^ self error: 'undefined undeterminate'].
	answer _ self extract: {anIndeterminate}.
	answer propertyAt: #asMultivariate put: self.
	^ answer! !

!PolynomialRing methodsFor: 'converting' stamp: 'len 4/4/2021 08:06:10'!
lift
	^ self propertyAt: #lift ifAbsentPut: [self class monomials: monomials over: scalars base]! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 1/2/2022 11:43:14'!
adapt: anElement
	| f parts |
	(anElement isInteger or: [anElement isFraction])
		ifTrue: [^ self constant: scalars !! anElement].
	(scalars includes: anElement)
		ifTrue: [^ self constant: anElement].
	(monomials includes: anElement)
		ifTrue: [^ self monomial: anElement].
	(super adapt: anElement) ifNotNil: [:aPolynomial| ^ aPolynomial].
	(anElement isKindOf: Polynomial) ifFalse: [^ nil].
	f _ anElement.
	f parent scalars = scalars ifFalse: [f _ f over: scalars].
	(f indeterminates allSatisfy: [:each| each <= self rank]) ifFalse: [^ nil]. "unknown indeterminates present"
	(f isKindOf: UnivariatePolynomial)
		ifTrue:
			[self isUnivariate ifTrue: [^ self coefficients: f coefficients].
			parts _ OrderedCollection new: f coefficients size.
			f coefficients withIndexDo: [:coefficient :i|
				coefficient isZero ifFalse: [parts add: (monomials x: 1 to: i-1) -> coefficient]]]
		ifFalse:
			[parts _ f parts collect: [:each| each copy key: monomials !! each key]].
	parts sort.
	^ self parts: parts! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 7/9/2016 03:28'!
coefficient: aNumber degree: anInteger
	^ self coefficients: (self scalars tuple: {aNumber}) >>> anInteger! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 6/1/2020 13:26:10'!
coefficient: aNumber monomial: aMonomial
	^ self isUnivariate
		ifTrue:
			[| n zero coefficients |
			n _ aMonomial degree + 1.
			zero _ aNumber zero.
			coefficients _ self scalars^n filling: [:i| i=n ifTrue: [aNumber] ifFalse: [zero]].
			(UnivariatePolynomial coefficients: coefficients) parent: self]
		ifFalse:
			[| parts |
			parts _ aNumber isZero ifTrue: [OrderedCollection new] ifFalse: [OrderedCollection with: aMonomial -> aNumber].
			(MultivariatePolynomial parts: parts) parent: self]! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 2/27/2017 07:42:04'!
coefficient: aNumber x: anIndeterminate to: anInteger
	| i |
	i _ anIndeterminate isInteger
		ifTrue: [anIndeterminate]
		ifFalse: [self names indexOf: anIndeterminate ifAbsent: [^ self error: 'unknown indeterminate']].
	^ self coefficient: aNumber monomial: (monomials x: i to: anInteger)! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 3/9/2020 20:02:46'!
coefficients: aTuple
	| coefficients |
	self isUnivariate ifFalse: [^ self error: 'not univariate ring'].
	coefficients _ scalars tuple: aTuple.
	^ (UnivariatePolynomial coefficients: coefficients) parent: self! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 11/20/2016 13:51:14'!
constant: aNumber
	self isUnivariate ifTrue: [^ self coefficients: (self scalars tuple: {aNumber})].
	^ self coefficient: aNumber monomial: monomials identity! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 5/14/2019 12:35:37'!
evaluating: aBlock
	^ self generate: aBlock! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 5/15/2019 07:38:21'!
findIrreducibleOfDegree: n
	| one x p random |
	one _ self scalars one.
	x _ self x.
	1 to: n-1 do: [:k|
		p _ x^n + (x^k) + one.
		p isIrreducible ifTrue: [^ p]].
	"self error: 'irreducible polynomial not found'"
	random _ Random new.
	[p _ (self atRandom: random maxDegree: n-1) + (x^n).
	p isIrreducible] whileFalse.
	^ p! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 12/19/2015 03:38'!
interpolate: aCollection
	"Answer a polynomial f that for each pair k -> v of the argument evaluates to f(k) = v.
	(Lagrange polynomials.)"
	| answer x |
	self isUnivariate ifFalse: [^ self error: 'not yet implemented'].
	x _ self x.
	answer _ self zero.
	aCollection do: [:a| | p |
		p _ self one.
		aCollection do: [:b|
			a ~~ b ifTrue: [p _ p * ((x - b key) / (a key - b key))]].
		answer _ p * a value + answer].
	^ answer! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 6/26/2016 01:42'!
monomial: aMonomial
	^ self coefficient: self scalars one monomial: aMonomial! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 4/9/2020 07:22:03'!
newFrom: anObject
	anObject isEvaluable ifTrue: [^ self evaluating: anObject].
	^ super newFrom: anObject! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 5/31/2020 20:39:02'!
parts: aCollection
	self isUnivariate
		ifTrue:
			[| n coefficients |
			n _ 0.
			aCollection do: [:each| n _ n max: each key degree].
			coefficients _ (self scalars^(n+1)) zero.
			aCollection do: [:each| coefficients at: each key degree + 1 put: each value].
			^ self coefficients: coefficients].
	^ (MultivariatePolynomial parts: aCollection) parent: self! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 5/20/2016 03:34'!
x
	^ self x: self indeterminates first! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 3/21/2021 13:26:32'!
x: anInteger
	^ self x: anInteger to: 1! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 10/22/2016 18:12'!
x: anIndeterminate to: n
	^ self coefficient: self scalars one x: anIndeterminate to: n! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 5/20/2016 03:34'!
y
	^ self x: self indeterminates second! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 5/20/2016 03:34'!
z
	^ self x: self indeterminates third! !

!PolynomialRing methodsFor: 'enumerating' stamp: 'len 5/28/2020 18:10:35'!
do: aBlock
	| k |
	self scalars isFinite ifFalse: [^ self notYetImplemented].
	self isUnivariate ifFalse: [^ self notYetImplemented].
	aBlock value: self zero.
	k _ 1.
	[self scalars ^ k do: [:t| t last isZero ifFalse: [aBlock value: (self coefficients: t)]].
	k _ k + 1] repeat! !

!PolynomialRing methodsFor: 'enumerating' stamp: 'len 1/1/2022 19:24:41'!
unitsDo: aBlock
	self scalars isIntegralDomain ifTrue:
		[self scalars do: [:each| each isZero ifFalse: [aBlock value: (self constant: each)]].
		^ self].
	super unitsDo: aBlock! !

!PolynomialRing methodsFor: 'examples' stamp: 'len 10/22/2016 18:12'!
chebyshevOfOrder: n
	"Answer the n-th Chebyshev polynomial."

	| answer c m k |
	n <= 0 ifTrue: [^ self one].
	c _ (1 bitShift: n - 1).
	m _ 4.
	k _ n - 1.
	answer _ self coefficient: self scalars one * c degree: n.
	n - 1 to: 1 by: -2 do: [ :each |
		c _ ((c * (each + 1) * each) / (k * m)) negated.
		m _ m + 4.
		k _ k - 1.
		c = 0 ifFalse: [answer _ answer + (self coefficient: self scalars one * c degree: each - 1)]].
	^ answer! !

!PolynomialRing methodsFor: 'examples' stamp: 'len 5/23/2020 10:07:53'!
continuantOfOrder: n
	"Answer the continuant polynomial of order n."
	"( polynomialsIn: #(x y z)) continuantOfOrder: 3"

	n = 0 ifTrue: [^ self one].
	n = 1 ifTrue: [^ self x: 1].
	^ (self continuantOfOrder: n - 1) * (self x: n) + (self continuantOfOrder: n - 2)! !

!PolynomialRing methodsFor: 'examples' stamp: 'len 5/12/2018 17:00:02'!
cyclicIdeal
	"Answer the ideal of cyclic n-roots, used for benchmarks."
	| generators |
	generators _ OrderedCollection new.
	0 to: self rank - 2 do: [:j|
		| g |
		g _ (1 to: self rank) sum: [:i| (i to: i+j) product: [:k| self x: k-1 \\ self rank + 1]].
		generators add: g].
	generators add: self generators product - 1.
	^ self * generators! !

!PolynomialRing methodsFor: 'examples' stamp: 'len 12/10/2016 20:28:19'!
cyclotomic: n
	"Answer the n-th cyclotomic polynomial."
	| one x answer "numerator denominator" product |
	one _ self one.
	x _ self x.
	n = 1 ifTrue: [^ x - one].
	n isPrime
		ifTrue: [answer _ one. n-1 timesRepeat: [answer _ answer * x + one]. ^ answer].
"	numerator _ one.
	denominator _ one.
	n divisorsDo: [:d| | mu |
		mu _ (n/d) moebius.
		mu = 1 ifTrue: [numerator _ numerator * (x^d - one)].
		mu = -1 ifTrue: [denominator _ denominator * (x^d - one)]].
	^ numerator // denominator"
	product _ self one.
	n divisors do: [:each| each = n ifFalse: [product _ product * (self cyclotomic: each)]].
	^ x^n - one // product! !

!PolynomialRing methodsFor: 'examples' stamp: 'len 5/23/2020 10:08:03'!
determinantOfOrder: n
	"Answer the determinant polynomial of order n."
	" polynomials determinantOfOrder: 3"

	n = 0 ifTrue: [^ self zero].
	^ (self ^ (n@n) evaluating: [:i :j| self x: n * (j - 1) + i]) determinant! !

!PolynomialRing methodsFor: 'examples' stamp: 'len 5/23/2020 10:08:09'!
fibonacciOfOrder: n
	"Answer the n-th Fibonacci polynomial."
	" polynomials fibonacciOfOrder: 3"

	n negative ifTrue: [^ self notYetImplemented].
	n = 0 ifTrue: [^ self zero].
	n = 1 ifTrue: [^ self one].
	^ (self fibonacciOfOrder: n - 1) - (self x * (self fibonacciOfOrder: n - 2))! !

!PolynomialRing methodsFor: 'examples' stamp: 'len 5/12/2018 16:58:57'!
katsuraIdeal
	"Answer the Katsura ideal, used for benchmarks."
	| n f generators |
	n _ self rank.
	generators _ OrderedCollection new.
	f _ self !! -1.
	1-n to: n-1 do: [:i| f _ (self x: i abs + 1) + f].
	generators add: f.
	0 to: n-2 do: [:i|
		f _ (self x: i+1) * -1.
		1-n to: n-1 do: [:j| | k |
			k _ (i-j) abs + 1.
			k <= n ifTrue: [f _ (self x: j abs + 1) * (self x: k) + f]].
		generators add: f].
	^ self * generators! !

!PolynomialRing methodsFor: 'examples' stamp: 'len 2/21/2017 18:58:57'!
symmetric: r
	"Answer the r-th symmetric polynomial whose terms are all monomials formed by the product of r distinct indeterminates."
	| answer |
	answer _ self zero.
	(1 to: self rank) combinations: r atATimeDo: [:each| answer _ answer + (each product: [:i| self x: i])].
	^ answer! !

!PolynomialRing methodsFor: 'morphisms' stamp: 'len 1/2/2016 04:13'!
embed: aScalar
	^ self constant: aScalar! !

!PolynomialRing methodsFor: 'morphisms' stamp: 'len 12/22/2021 15:06:05'!
from: aDomain
	aDomain = self scalars ifTrue: [^ self addMap: ((self scalars to: self evaluating: [:x| self constant: x]) name: 'i')].
	aDomain -> self scalars ifNotNil: [:aMorphism| ^ aMorphism -> self].
	(aDomain isKindOf: PolynomialRing)
		ifTrue: [aDomain scalars -> self scalars ifNotNil: [:aRingMap|
				aDomain monomials -> self monomials ifNotNil: [:aMonoidMap|
					^ aDomain to: self evaluating: [:f|
						| answer |
						answer _ self zero.
						f parts do: [:each| answer _ answer + (self coefficient: (aRingMap value: each value) monomial: (aMonoidMap value: each key))].
						answer]]]].
	^ super from: aDomain! !

!PolynomialRing methodsFor: 'morphisms' stamp: 'len 7/9/2021 06:43:16'!
id
	"Answer the identity morphism."
	^ self propertyAt: #id ifAbsentPut: [self to: self mapping: [:i| self x: i]]! !

!PolynomialRing methodsFor: 'morphisms' stamp: 'len 12/15/2021 11:42:40'!
to: aRing mapping: aBlock
	^ AffineAlgebraMap from: self to: aRing mapping: aBlock! !

!PolynomialRing methodsFor: 'operations' stamp: 'len 12/19/2021 19:50:16'!
/ anIdeal
	"Answer the quotient by the given ideal.
	For convenience, the argument can be a single element or a collection of elements as well."
	(anIdeal isKindOf: Ideal) ifFalse: [^ self / (self * anIdeal)].
	self assert: self = anIdeal scalars.
	anIdeal isTrivial ifTrue: [^ self].
	^ AffineAlgebra relations: anIdeal! !

!PolynomialRing methodsFor: 'operations' stamp: 'len 7/22/2021 18:50:08'!
 aRing
	"Answer the tensor product (over the scalars of the receiver) of the receiver with the argument.
	This is the coproduct in the category of commutative R-algebras."
	| answer i1 i2 |
	aRing = self scalars ifTrue: [^ self].
	(aRing isKindOf: PolynomialRing) ifFalse:
		[self scalars -> aRing ifNotNil: [^ self over: aRing].
		^ super  aRing].
	aRing scalars = self scalars ifFalse:
		[self scalars -> aRing scalars ifNotNil: [^ (self over: aRing scalars)  aRing].
		aRing scalars -> self scalars ifNotNil: [^ self  (aRing over: self scalars)].
		^ super  aRing].
	answer _ self class monomials: self monomials  aRing monomials over: self scalars.
	i1 _ self into: answer mapping: [:i| answer x: i].
	i2 _ aRing into: answer mapping: [:i| answer x: self rank+i].
	answer addCoprojections: {i1. i2}.
	answer addCoercionFrom: (self, aRing) evaluatingWithArguments: [:f :g| (i1 value: f) * (i2 value: g)].
	^ answer! !

!PolynomialRing methodsFor: 'operations' stamp: 'len 4/14/2020 18:46:10'!
completion
	"Answer the ring of power series, i.e. the completion of the receiver at 0."
	^ PowerSeriesRing on: self! !

!PolynomialRing methodsFor: 'operations' stamp: 'len 3/6/2021 20:35:58'!
extract: anArray
	"Given a subset Y of the indeterminates of the receiver R[X], answer R[X\Y][Y] equipped with coercion maps."
	| complement F E |
	complement _ self indeterminates reject: [:i| anArray includes: i].
	F _ self class monomials: (monomials slice: complement) over: self scalars.
	E _ self class monomials: (monomials slice: anArray) over: F.
	E addMap: (E to: self mapping: [:i| self x: (anArray at: i)]).
	E addMap: (self to: E mapping: [:i|
		| k |
		(k _ complement indexOf: i) > 0
			ifTrue: [E constant: (F x: k)] ifFalse: [E x: (anArray indexOf: i)]]).
	^ E! !

!PolynomialRing methodsFor: 'operations' stamp: 'len 7/22/2021 18:48:59'!
filtrationAt: anInteger
	"Answer the submodule of polynomials of degree <= anInteger."
	| answer basis |
	self isUnivariate ifTrue:
		[^ (answer _ self scalars ^ (anInteger + 1))
			addCoercionFrom: self evaluating: [:f| answer elementAt: (f coefficients extendedTo: 	anInteger+1)];
			addCoercionTo: self evaluating: [:v| self coefficients: v];
			yourself].
	basis _ self monomials allMonomialsUpToDegree: anInteger.
	^ (answer _ self scalars ^ basis size)
		addCoercionFrom: self evaluating: [:f| answer elementAt: (basis collect: [:each| f at: each])];
		addCoercionTo: self evaluating: [:v| (1 to: basis size) sum: [:i| self coefficient: (v at: i) monomial: (basis at: i)]];
		yourself! !

!PolynomialRing methodsFor: 'operations' stamp: 'len 3/3/2021 13:03:29'!
fractions
	"Answer the field of rational functions, i.e. the localization of the receiver at 0."
	^ self propertyAt: #fractions ifAbsentPut:
		[self scalars isField
			ifTrue: [RationalFunctionField on: self]
			ifFalse: [self scalars isIntegralDomain
				ifTrue: [RationalFunctionField on: (self over: self scalars fractions)]
				ifFalse: [^ super fractions]]]! !

!PolynomialRing methodsFor: 'operations' stamp: 'len 1/1/2022 09:37:13'!
gradingAt: anInteger
	"Answer the submodule of homogeneous polynomials of degree anInteger."
	| answer monomialBasis |
	monomialBasis _ self monomials allMonomialsOfDegree: anInteger.
	^ (answer _ self scalars ^ monomialBasis size)
		addCoercionFrom: self evaluating: [:f| answer !! (monomialBasis collect: [:each| f at: each])];
		addCoercionTo: self evaluating: [:v| | f | f _ self zero. v with: monomialBasis do: [:coefficient :monomial| f _ (self coefficient: coefficient monomial: monomial) + f]. f];
		yourself! !

!PolynomialRing methodsFor: 'operations' stamp: 'len 10/27/2016 18:32'!
hilbertSeriesAt: t
	^ (self gradings product: [:d| 1 - (t ^ d)]) reciprocal! !

!PolynomialRing methodsFor: 'operations' stamp: 'len 1/14/2022 11:50:59'!
localization
	"Answer the localization of the receiver at <x1,...,xn>. This is achieved by choosing a local ordering.
	Objects defined in this localization contain geometric information (usually only) about a Zariski neighbourhood of 0 in K^n, while objects in the global ring contain geometric information valid in the whole affine space K^n."
	self ordering isGlobal ifFalse: [self error: 'not a global ordering'].
	^ self orderedBy: #lglex! !

!PolynomialRing methodsFor: 'operations' stamp: 'len 5/13/2019 22:13:37'!
orderedBy: aMonomialOrdering
	^ self class monomials: (self monomials orderedBy: aMonomialOrdering) over: self scalars! !

!PolynomialRing methodsFor: 'operations' stamp: 'len 5/13/2019 22:13:23'!
over: aRing
	^ self class monomials: self monomials over: aRing! !

!PolynomialRing methodsFor: 'operations' stamp: 'len 12/11/2021 19:19:48'!
proj
	"This is the Proj functor. Answer the projective space with homogeneous coordinate ring the receiver."
	^ ProjectiveSpace coordinateRing: self! !

!PolynomialRing methodsFor: 'operations' stamp: 'len 5/10/2020 12:12:23'!
radical
	"Answer the Jacobson radical J(R) of the receiver R. This is the ideal consisting of all elements that annihilate all simple R-modules. It is the intersection of all maximal ideals. In a polynomial ring, it is the same as the nilradical."
	^ self nilradical! !

!PolynomialRing methodsFor: 'operations' stamp: 'len 3/5/2021 17:58:04'!
slice: anArray
	"Given a subset Y of the indeterminates of the receiver R[X], answer the subring R[Y] equipped with the embedding map."
	^ self class monomials: (monomials slice: anArray) over: self scalars! !

!PolynomialRing methodsFor: 'operations' stamp: 'len 12/11/2021 19:13:41'!
spec
	"This is the Spec functor. Answer the spectrum of the receiver as an affine scheme, i.e. affine space with coordinate ring the receiver."
	^ self propertyAt: #spec ifAbsentPut: [AffineSpace coordinateRing: self]! !

!PolynomialRing methodsFor: 'random' stamp: 'len 6/16/2019 17:51:45'!
atRandom: aRandom bits: bitSize
	^ self atRandom: aRandom bits: bitSize maxDegree: ((bitSize raisedTo: 1/(self rank+1)) min: bitSize - 1) truncated! !

!PolynomialRing methodsFor: 'random' stamp: 'len 8/10/2019 09:26:07'!
atRandom: aRandom bits: bitSize maxDegree: d
	^ self atRandom: aRandom bits: bitSize maxDegree: d maxTerms: 2 ^ self rank! !

!PolynomialRing methodsFor: 'random' stamp: 'len 4/15/2021 07:41:51'!
atRandom: aRandom bits: bitSize maxDegree: d maxTerms: n
	| answer term |
	d = 0 ifTrue: [^ self constant: (self scalars atRandom: aRandom bits: bitSize)].
	self isUnivariate ifTrue: [^ self coefficients: (self scalars^(d+1) atRandom: aRandom bits: bitSize)].
	answer _ self zero.
	(n atRandom: aRandom) timesRepeat:
		[term _ self one.
		((0 to: d) atRandom: aRandom) timesRepeat: [term _ term * (self generators atRandom: aRandom)].
		term _ term * (self scalars atRandom: aRandom bits: bitSize/(self rank*d)).
		answer _ answer + term].
	^ answer! !

!PolynomialRing methodsFor: 'random' stamp: 'len 6/1/2020 13:28:03'!
atRandom: aRandom maxDegree: d
	self isUnivariate ifFalse: [^ self notYetImplemented].
	^ self coefficients: (self scalars^(d+1) atRandom: aRandom)! !

!PolynomialRing methodsFor: 'random' stamp: 'len 5/1/2021 12:29:19'!
atRandom: aRandom modulo: anIdeal
	anIdeal isPrincipal ifFalse: [^ self error: 'not yet implemented'].
	self isUnivariate ifFalse: [^ self error: 'not yet implemented'].
	^ self coefficients: ((0 to: self generator degree - 1) collect: [:i| self scalars atRandom: aRandom])! !

!PolynomialRing methodsFor: 'random' stamp: 'len 3/11/2021 16:39:15'!
atRandomBits: bitSize maxDegree: d
	^ self atRandom: self newRandom bits: bitSize maxDegree: d! !

!PolynomialRing methodsFor: 'random' stamp: 'len 6/1/2020 13:29:30'!
atRandomDegree: d
	"Answer a polynomial of degree d choosen at random with a uniform distribution."
	self isUnivariate ifFalse: [^ self notYetImplemented].
	^ self coefficients: (self scalars^d) atRandom, self scalars one! !

!PolynomialRing methodsFor: 'random' stamp: 'len 6/1/2020 13:29:46'!
atRandomMaxDegree: d
	"Answer a polynomial of degree at most d choosen at random with a uniform distribution."
	self isUnivariate ifFalse: [^ self notYetImplemented].
	^ self coefficients: (self scalars^(d+1)) atRandom! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 6/4/2016 05:13'!
has: anIndeterminate
	^ self indeterminates includes: anIndeterminate! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 12/30/2021 11:48:38'!
hasCanonicalAssociates
	^ self scalars isIntegralDomain! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 1/9/2022 09:48:03'!
hasCanonicalBases
	"Answer true if there's an algorithm to compute canonical bases for modules over the receiver."
	^ self scalars isField! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 4/25/2020 10:05:43'!
includes: anObject
	^ anObject parent = self! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 5/18/2020 07:29:09'!
isBezout
	"Answer true if the receiver is a Bezout ring, i.e. every finitely generated ideal is principal."
	^ self isEuclidean! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 4/28/2021 09:37:55'!
isCommutative
	^ true! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 1/12/2022 18:24:50'!
isEuclidean
	"Answer true if the receiver is a Euclidean ring, i.e. it has Euclidean division with remainder."
	self isUnivariate ifFalse: [^ false].
	self scalars isField ifTrue: [^ true].
	"TODO: Z/6Z[x] is a PIR (and thus Euclidean), Z/8Z is not a PIR. For R a finite commutative ring, the polynomial ring R[x] is a PIR iff R is a direct product of finite fields. Also R[x] is a PIR iff it is isomorphic to a direct product of PIDs."
	^ false "undefined"! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 2/12/2017 06:13:48'!
isGraded
	"Answer true if this polynomial ring is graded, i.e. it uses a graded monomial ordering."
	^ self ordering isGraded! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 4/27/2018 06:16:03'!
isIntegralDomain
	^ self scalars isIntegralDomain! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 2/12/2017 05:48:39'!
isLocal
	"Answer true if this polynomial ring is local, i.e. it uses a local monomial ordering."
	^ self ordering isLocal! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 7/27/2021 11:38:09'!
isMultivariate
	^ true! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 3/21/2021 15:11:06'!
isNoetherian
	"A ring is called Noetherian if every ideal is finitely generated."
	self scalars isNoetherian ifTrue: [^ true]. "Hilber's basis theorem"
	^ super isNoetherian! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 10/22/2016 18:09'!
isPID
	"Univariate polynomials over a field are principal ideal domains."
	^ self scalars isField and: [self isUnivariate]! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 5/18/2020 09:59:42'!
isPIR
	"A principal ideal ring (PIR) is a ring in which every ideal is principal, i.e. can be generated by a single element.
	In a PIR any two nonzero elements have a well-defined GCD."
	"Principal ideal rings are exactly the rings that are both Bezout and Noetherian:"
	self isUnivariate ifFalse: [^ false].
	self scalars isField ifTrue: [^ true].
	"TODO: Z/6Z[x] is a PIR (and thus Euclidean), Z/8Z is not a PIR. For R a finite commutative ring, the polynomial ring R[x] is a PIR iff R is a direct product of finite fields. Also R[x] is a PIR iff it is isomorphic to a direct product of PIDs."
	(self scalars isKindOf: ModularIntegerRing) ifTrue: [^ self scalars isReduced].
	(self scalars isKindOf: GaloisRing) ifTrue: [^ self scalars exponent = 1].
	^ super isPIR! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 3/4/2021 18:23:48'!
isTrivial
	"The trivial ring is the zero ring with a single element 0 = 1."
	^ self scalars isTrivial! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 10/22/2016 18:11'!
isUFD
	self scalars isUFD ifTrue: [^ true]. "proof based on Gauss lemma"
	^ super isUFD! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 10/22/2016 18:16'!
isUnivariate
	^ self rank = 1! !

!PolynomialRing methodsFor: 'private' stamp: 'len 4/6/2021 13:24:56'!
idealClass
	^ PolynomialIdeal! !

!PolynomialRing methodsFor: 'private' stamp: 'len 2/26/2017 10:37:19'!
monomials: aFreeAbelianMonoid
	monomials _ aFreeAbelianMonoid! !

!PolynomialRing methodsFor: 'private' stamp: 'len 11/20/2016 12:06:41'!
ordering: aMonomialOrdering
	monomials ordering: aMonomialOrdering! !

!PolynomialRing methodsFor: 'private' stamp: 'len 1/2/2017 10:10:53'!
scalars: aRing
	scalars _ aRing! !

!PolynomialRing methodsFor: 'private' stamp: 'len 1/14/2022 09:42:23'!
tupleClass
	^ MultivariateTuple! !

!PolynomialRing class methodsFor: 'examples' stamp: 'len 5/23/2020 09:13:12'!
example11
	"Creating a polynomial in Z[x]."
	| R x |
	R _  polynomials.
	x _ R x.
	^ x^2 - x + 3! !

!PolynomialRing class methodsFor: 'examples' stamp: 'len 5/23/2020 09:13:12'!
example12
	"Creating a polynomial in Z[x] from a tuple of coefficients."
	^  polynomials coefficients: #(3 -1 1)! !

!PolynomialRing class methodsFor: 'examples' stamp: 'len 5/23/2020 09:13:12'!
example13
	"Creating a polynomial in Z[x] from a block."
	^  polynomials !! [:x| x^2 - x + 3]! !

!PolynomialRing class methodsFor: 'examples' stamp: 'len 5/23/2020 09:13:12'!
example21
	"Creating a polynomial in Q[x,y]."
	| R x y |
	R _  polynomialsIn: #(x y). "these are just names for printing"
	x _ R x: 1.
	y _ R x: 2.
	^ x^2 - (x*y) + 1! !

!PolynomialRing class methodsFor: 'examples' stamp: 'len 5/23/2020 09:13:12'!
example22
	"A more compact way to create a polynomial in Q[x,y]."
	^ ( polynomialsIn: #(x y)) !! [:x :y| x^2 - (x*y) + 1]! !

!PolynomialRing class methodsFor: 'examples' stamp: 'len 5/23/2020 09:13:12'!
example23
	"Creating a polynomial in Q[x,y] with local graded lexicographic ordering."
	| R x y |
	R _  polynomialsIn: #(x y) ordering: #lglex.
	x _ R x: 1.
	y _ R x: 2.
	^ x^2 - (x*y) + 1! !

!PolynomialRing class methodsFor: 'instance creation' stamp: 'len 5/13/2019 22:12:50'!
monomials: aFreeAbelianMonoid over: aRing
	^ self new monomials: aFreeAbelianMonoid; scalars: aRing! !

!PolynomialRing class methodsFor: 'instance creation' stamp: 'len 5/13/2019 22:12:02'!
new: anInteger over: aRing
	^ self monomials: (FreeAbelianMonoid new: anInteger) over: aRing! !

!PolynomialRing class methodsFor: 'instance creation' stamp: 'len 5/13/2019 22:12:22'!
new: anInteger over: aRing ordering: aMonomialOrdering
	^ self monomials: (FreeAbelianMonoid new: anInteger ordering: aMonomialOrdering) over: aRing! !

!Algebra methodsFor: 'accessing' stamp: 'len 6/17/2020 14:40:28'!
basis
	^ self propertyAt: #basis ifAbsentPut: [self asModule basis collect: [:each| self !! each]]! !

!Algebra methodsFor: 'accessing' stamp: 'len 7/11/2021 19:12:40'!
characteristic
	| P |
	self asModule isFree ifTrue: [^ self scalars characteristic].
	^ (P _ self primeSubring) isFinite ifTrue: [P size] ifFalse: [0]! !

!Algebra methodsFor: 'accessing' stamp: 'len 3/18/2021 15:22:29'!
generators
	"Note: a basis is not necessarily a minimal set of generators (as algebra)."
	^ self propertyAt: #generators ifAbsent: [self basis]! !

!Algebra methodsFor: 'accessing' stamp: 'len 7/14/2020 09:35:58'!
multiplication
	"Answer the multiplication as a bilinear map on the underlying module."
	^ self propertyAt: #multiplication ifAbsentPut: [BilinearMap from: self asModule, self asModule to: self asModule evaluatingWithArguments: [:x :y| (self !! x) * (self !! y)]]! !

!Algebra methodsFor: 'accessing' stamp: 'len 7/14/2021 16:54:27'!
rank
	^ self asModule rank! !

!Algebra methodsFor: 'accessing' stamp: 'len 6/11/2020 06:39:27'!
scalars
	^ self asModule scalars! !

!Algebra methodsFor: 'accessing' stamp: 'len 6/27/2020 09:07:47'!
size
	^ self asModule size! !

!Algebra methodsFor: 'accessing' stamp: 'len 6/17/2020 14:43:06'!
zero
	^ self !! self asModule zero! !

!Algebra methodsFor: 'comparing' stamp: 'len 3/22/2021 10:05:56'!
< anAlgebra
	"Answer true if the receiver is strictly included in the argument."
	^ self asModule < anAlgebra asModule! !

!Algebra methodsFor: 'comparing' stamp: 'len 3/22/2021 10:05:18'!
<= anAlgebra
	"Answer true if the receiver is included in the argument."
	^ self asModule <= anAlgebra asModule! !

!Algebra methodsFor: 'comparing' stamp: 'len 7/18/2021 12:55:58'!
= anObject
	^ (anObject isKindOf: Algebra) and: [self ambient asModule = anObject ambient asModule and: [self asModule = anObject asModule]]! !

!Algebra methodsFor: 'computing-matrices' stamp: 'len 7/14/2021 16:52:26'!
collapseMatrix: aMatrix
	| d |
	d _ self rank.
	^ self^(aMatrix width / d) => (self^(aMatrix height / d)) filling: [:i :j|
		(self asModule endomorphisms filling: [:i0 :j0| aMatrix at: (i-1*d+i0) @ (j-1*d+j0)]) * (self one asModuleElement)]! !

!Algebra methodsFor: 'computing-matrices' stamp: 'len 7/25/2021 09:29:15'!
expandMatrix: aMatrix
	| R d answer |
	R _ self scalars.
	d _ self rank.
	answer _ R^(aMatrix width*d) -> (R^0).
	1 to: aMatrix height do: [:i|
		| a |
		a _ R^0 -> (R^d).
		1 to: aMatrix width do: [:j| a _ a  (aMatrix at: i@j) representation asMatrix].
		answer _ answer  a].
	^ answer! !

!Algebra methodsFor: 'computing-matrices' stamp: 'len 12/31/2021 09:34:47'!
matrix: B divisionBy: A
	"Answer X and N such that AX + N = B, satisfying that if the i-th column of B is a linear combination of the columns of A then the i-th column of N is zero."
	^ ((self expandMatrix: B) divisionBy: (self expandMatrix: A)) collect: [:each| self collapseMatrix: each]! !

!Algebra methodsFor: 'computing-matrices' stamp: 'len 12/31/2021 08:18:48'!
syzygiesOf: aMatrix
	"Answer a matrix whose rows span the kernel of the given matrix.
	For a matrix A, the output is X with AX = 0."
	| X d |
	aMatrix isZero ifTrue: [^ aMatrix domain id].
	X _ (self expandMatrix: aMatrix) syzygies.
	d _ self rank.
	^ self^X width => (self^(X height / d)) filling: [:i :j|
		self fromModuleElement: (self asModule elementAt: ((1 to: d) collect: [:k| X at: (i-1*d+k) @ j]))]! !

!Algebra methodsFor: 'converting' stamp: 'len 6/11/2020 11:38:33'!
asModule
	^ self propertyAt: #asModule! !

!Algebra methodsFor: 'elements' stamp: 'len 4/23/2021 12:55:37'!
adapt: anElement
	self isAmbient ifFalse: [^ super adapt: anElement].
	(self asModule includes: anElement) ifTrue: [^ self fromModuleElement: anElement].
	^ super adapt: anElement! !

!Algebra methodsFor: 'elements' stamp: 'len 7/16/2020 09:29:19'!
elementAt: anArray
	"Answer the element with the given coordinates."
	^ self fromModuleElement: (self asModule elementAt: anArray)! !

!Algebra methodsFor: 'elements' stamp: 'len 7/18/2021 12:56:27'!
fromModuleElement: anElement
	^ AlgebraElement parent: self moduleElement: anElement! !

!Algebra methodsFor: 'elements' stamp: 'len 7/14/2021 16:52:43'!
newFrom: anObject
	(anObject isSequenceable and: [anObject size = self rank])
		ifTrue: [^ self elementAt: anObject].
	^ super newFrom: anObject! !

!Algebra methodsFor: 'enumerating' stamp: 'len 10/19/2020 08:32:00'!
do: aBlock
	self asModule do: [:each| aBlock value: self !! each]! !

!Algebra methodsFor: 'initialization' stamp: 'len 7/7/2020 06:42:38'!
module: aModule
	self propertyAt: #asModule put: aModule! !

!Algebra methodsFor: 'initialization' stamp: 'len 7/22/2021 18:47:39'!
multiplication: aBilinearMap
	| V |
	V _ aBilinearMap domain at: 1.
	self propertyAt: #asModule put: V.
	self propertyAt: #multiplication put: aBilinearMap.
	self addCoercionTo: V evaluating: [:each| each asModuleElement]! !

!Algebra methodsFor: 'morphisms' stamp: 'len 12/23/2021 19:24:33'!
from: aDomain
	aDomain == self scalars ifTrue: [^ self addMap: ((self scalars to: self evaluating: [:x| self one * x]) name: 'i')].
	aDomain -> self scalars ifNotNil: [:aMorphism| ^ aMorphism -> self].
	^ super from: aDomain! !

!Algebra methodsFor: 'morphisms' stamp: 'len 7/9/2021 06:41:01'!
id
	"Answer the identity morphism."
	^ self propertyAt: #id ifAbsentPut: [self to: self moduleMap: self asModule id]! !

!Algebra methodsFor: 'morphisms' stamp: 'len 12/22/2021 14:53:43'!
to: aCodomain
	aCodomain = self asModule endomorphisms ifTrue: [^ self addMap: (self to: aCodomain evaluating: [:x| x representation])].
	^ super to: aCodomain! !

!Algebra methodsFor: 'morphisms' stamp: 'len 7/18/2021 12:55:58'!
to: aRing evaluating: aBlock
	((aRing isKindOf: Algebra) and: [self scalars = aRing scalars]) ifTrue: [^ self to: aRing moduleMap: (self asModule to: aRing asModule evaluating: [:x| (aBlock value: self !! x) asModuleElement])].
	^ super to: aRing evaluating: aBlock! !

!Algebra methodsFor: 'morphisms' stamp: 'len 7/18/2021 12:55:58'!
to: anAlgebra mapping: aBlock
	"Answer a morphism defined by images of generators.
	aBlock takes indices i and evaluates to the image of the i-th generator."
	((anAlgebra isKindOf: Algebra) and: [anAlgebra scalars = self scalars]) ifFalse: [^ super to: anAlgebra mapping: aBlock].
	^ self to: anAlgebra moduleMap: (self asModule to: anAlgebra asModule mapping: [:i| (aBlock value: i) asModuleElement])! !

!Algebra methodsFor: 'morphisms' stamp: 'len 7/18/2021 12:55:58'!
to: anAlgebra moduleMap: aModuleMap
	((anAlgebra isKindOf: Algebra) and: [self scalars = anAlgebra scalars]) ifFalse: [^ DomainError signal].
	^ AlgebraMap from: self to: anAlgebra moduleMap: aModuleMap! !

!Algebra methodsFor: 'operations' stamp: 'len 12/19/2021 19:51:04'!
/ anIdeal
	"Answer the quotient by the given two-sided ideal.
	For convenience, the argument can be a single element or a collection of elements as well."
	| Q  answer |
	(anIdeal isKindOf: Ideal) ifFalse: [^ self / (self * anIdeal)].
	self assert: self = anIdeal scalars.
	anIdeal isTrivial ifTrue: [^ self].
	Q _ self asModule / (self asModule span: anIdeal generators).
	 _ self asModule -> Q.
	^ (answer _ self species multiplication: (BilinearMap from: Q, Q to: Q evaluatingWithArguments: [:x :y| (self !! x) * (self !! y)]))
		addMap: (self to: answer evaluating: [:x| answer !! ( value: x asModuleElement)]);
		yourself! !

!Algebra methodsFor: 'operations' stamp: 'len 7/18/2021 12:55:58'!
/\ aSubalgebra
	"Answer the intersection of the receiver and the argument."
	((aSubalgebra isKindOf: Algebra) and: [self ambient = aSubalgebra ambient])
		ifFalse: [^ super /\ aSubalgebra].
	^ self ambient span: self asModule /\ aSubalgebra asModule! !

!Algebra methodsFor: 'operations' stamp: 'len 7/18/2021 12:55:58'!
 anAlgebra
	"Answer the direct product of the receiver with the argument."
	((anAlgebra isKindOf: Algebra) and: [self scalars = anAlgebra scalars]) ifTrue: [^ self  anAlgebra].
	^ super  anAlgebra! !

!Algebra methodsFor: 'operations' stamp: 'len 12/23/2021 15:40:39'!
 anAlgebra
	"Answer the direct sum of the receiver with the argument."
	| answer coprojections projections |
	((anAlgebra isKindOf: Algebra) and: [self scalars = anAlgebra scalars]) ifFalse: [^ super  anAlgebra].
	answer _ self species multiplication: self multiplication  anAlgebra multiplication.
	projections _ answer asModule -< {self asModule. anAlgebra asModule}.
	coprojections _ {self asModule. anAlgebra asModule} >- answer asModule.
	answer
		addProjections: (projections with: {self. anAlgebra} collect: [: :codomain| answer => codomain !! ]);
		addCoprojections: (coprojections with: {self. anAlgebra} collect: [:i :domain| domain => answer !! i]).
	^ answer! !

!Algebra methodsFor: 'operations' stamp: 'len 7/14/2021 16:52:08'!
centralizerOf: aSubalgebra
	| rows |
	rows _ OrderedCollection new: self rank squared.
	self basis do: [:x|
		aSubalgebra basis do: [:y|
			rows add: self asModule \ (x*y - (y*x)) asModuleElement]].
	^ self span: ((Matrix rows: rows) kernel generators collect: [:each| self !! each])! !

!Algebra methodsFor: 'operations' stamp: 'len 7/6/2021 14:43:18'!
centroid
	"Answer the centroid of the receiver as a subalgebra of the algebra of endomorphisms."
	^ self notYetImplemented! !

!Algebra methodsFor: 'operations' stamp: 'len 7/18/2021 13:03:22'!
commutatorIdealWith: anAlgebra
	| commutators |
	self ambient = anAlgebra ambient ifFalse: [^ DomainError signal].
	commutators _ OrderedCollection new.
	self basis do: [:x| anAlgebra basis do: [:y| commutators add: (x, y)]].
	^ self ambient * commutators! !

!Algebra methodsFor: 'operations' stamp: 'len 7/18/2021 13:03:48'!
commutatorModuleWith: anAlgebra
	| commutators |
	self ambient = anAlgebra ambient ifFalse: [^ DomainError signal].
	commutators _ OrderedCollection new.
	self basis do: [:x| anAlgebra basis do: [:y| commutators add: (x, y)]].
	^ self ambient asModule span: commutators! !

!Algebra methodsFor: 'operations' stamp: 'len 7/8/2021 15:08:33'!
decomposition
	"Answer a list of idecomposable two-sided ideals whose direct sum is isomorphic to the receiver, equipped with projection maps."
	^ self notYetImplemented! !

!Algebra methodsFor: 'operations' stamp: 'len 1/30/2022 05:37:57'!
derivations
	"Answer the derivation algebra of the receiver as a Lie subalgebra of the algebra of endomorphisms."
	^ self notYetImplemented! !

!Algebra methodsFor: 'operations' stamp: 'len 7/5/2021 12:26:41'!
idealizerOf: aSubalgebra
	self notYetImplemented! !

!Algebra methodsFor: 'operations' stamp: 'len 12/20/2021 13:05:17'!
opposite
	(self isCommutative or: [self isInvolutive]) ifTrue: [^ self].
	^ self propertyAt: #opposite ifAbsentPut: [(self species multiplication: (BilinearMap on: self asModule evaluatingWithArguments: [:x :y| self multiplication value: y value: x])) propertyAt: #opposite put: self; yourself]! !

!Algebra methodsFor: 'operations' stamp: 'len 7/5/2021 12:27:37'!
radical
	"Answer the Jacobson radical of the receiver. This is the largest nilpotent ideal."
	^ self notYetImplemented! !

!Algebra methodsFor: 'operations' stamp: 'len 7/19/2020 20:14:09'!
span: aCollection
	"Answer the subalgebra spanned by the elements in aCollection."
	self isAmbient ifFalse: [^ self ambient span: aCollection].
	((aCollection isKindOf: Module) and: [aCollection ambient = self asModule])
		ifTrue: [^ self species new ambient: self; module: aCollection].
	^ self species new ambient: self; module: (self asModule span: (aCollection collect: [:each| each asModuleElement]))! !

!Algebra methodsFor: 'random' stamp: 'len 6/17/2020 14:40:18'!
atRandom: aRandom
	^ self !! (self asModule atRandom: aRandom)! !

!Algebra methodsFor: 'random' stamp: 'len 6/17/2020 14:40:22'!
atRandom: aRandom bits: bitSize
	^ self !! (self asModule atRandom: aRandom bits: bitSize)! !

!Algebra methodsFor: 'testing' stamp: 'len 7/7/2020 07:32:23'!
contains: anElement
	self isAmbient ifTrue: [^ true].
	^ self asModule contains: anElement asModuleElement! !

!Algebra methodsFor: 'testing' stamp: 'len 7/7/2020 07:31:51'!
includes: anObject
	self isAmbient ifTrue: [^ anObject parent = self].
	^ (self ambient includes: anObject) and: [self contains: anObject]! !

!Algebra methodsFor: 'testing' stamp: 'len 7/5/2021 12:26:58'!
isAlternative
	"All associative algebras are alternative."
	^ true! !

!Algebra methodsFor: 'testing' stamp: 'len 7/5/2021 12:19:28'!
isAnticommutative
	(self isAmbient not and: [self ambient isAnticommutative]) ifTrue: [^ true].
	self propertyAt: #isAnticommutative ifPresent: [:aBoolean| ^ aBoolean].
	self basis do: [:x|
		self basis do: [:y|
			x*y = (y*x) negated ifFalse: [^ self propertyAt: #isAnticommutative put: false]]].
	^ self propertyAt: #isAnticommutative put: true

"alternative:
	table _ self multiplicationTable.
	1 to: self dimension do: [:i|
		1 to: self dimension do: [:j|
			(i ~= j and: [((table at: i) at: j) ~= ((table at: j) at: i)])
				ifTrue: [^ self propertyAt: #isCommutative put: false]]]."! !

!Algebra methodsFor: 'testing' stamp: 'len 7/11/2021 10:37:01'!
isCentral
	^ self center = (self span: {self one})! !

!Algebra methodsFor: 'testing' stamp: 'len 7/5/2021 12:17:34'!
isCommutative
	(self isAmbient not and: [self ambient isCommutative]) ifTrue: [^ true].
	self propertyAt: #isCommutative ifPresent: [:aBoolean| ^ aBoolean].
	self basis do: [:x|
		self basis do: [:y|
			x*y = (y*x) ifFalse: [^ self propertyAt: #isCommutative put: false]]].
	^ self propertyAt: #isCommutative put: true

"alternative:
	table _ self multiplicationTable.
	1 to: self dimension do: [:i|
		1 to: self dimension do: [:j|
			(i ~= j and: [((table at: i) at: j) ~= ((table at: j) at: i)])
				ifTrue: [^ self propertyAt: #isCommutative put: false]]]."! !

!Algebra methodsFor: 'testing' stamp: 'len 7/5/2021 12:27:08'!
isDecomposable
	^self decomposition size > 1! !

!Algebra methodsFor: 'testing' stamp: 'len 7/6/2021 10:49:15'!
isDivisionAlgebra
	"An algebra is called a 'division algebra' if ax=b and xa=b have unique solutions for nonzero a.
	If the algebra is unital, this condition implies that each nonzero element has a left inverse and a right inverse. If the algebra is associative, the left and right inverse coincide.
	For finite dimensional algebra, a division algebra can be defined by the following condition: ab=0 implies a=0 or b=0."
	^ false "it might be a division algebra, we just don't know, should implement an algorithm to determine it"! !

!Algebra methodsFor: 'testing' stamp: 'len 1/2/2022 09:55:44'!
isDivisionRing
	"A division ring, or skewfield, is a ring where division is possible, i.e. every nonzero element has a multiplicative inverse. The only difference with a field is that a division ring is not requiered to be commutative."
	^ self isDivisionAlgebra! !

!Algebra methodsFor: 'testing' stamp: 'len 7/6/2021 08:44:21'!
isField
	self isFinite ifFalse: [^ super isField].
	"the following only works for finite rings:"
	^ self propertyAt: #isField
		ifAbsentPut:
		[self isCommutative and: [self characteristic isPrime and: [(self to: self mapping: [:i| (self x: i)^self characteristic]) isInjective]]]! !

!Algebra methodsFor: 'testing' stamp: 'len 7/16/2020 19:16:51'!
isJordan
	"Answer true if the receiver satisfies the Jordan identity."
	(self isAmbient not and: [self ambient isJordan]) ifTrue: [^ true].
	self propertyAt: #isJordan ifPresent: [:aBoolean| ^ aBoolean].
	self basis do: [:x|
		| xx |
		xx _ x * x.
		self basis do: [:y|
				x*y*xx = (x*(y*xx)) ifFalse: [^ self propertyAt: #isJordan put: false]]].
	^ self propertyAt: #isJordan put: true! !

!Algebra methodsFor: 'testing' stamp: 'len 5/4/2021 11:14:14'!
isNoetherian
	"Finite algebras are Noetherian because they are finitely-generated as modules."
	^ true! !

!Algebra methodsFor: 'testing' stamp: 'len 6/11/2020 12:19:44'!
isSemisimple
	^ self radical isTrivial! !

!Algebra methodsFor: 'testing' stamp: 'len 6/11/2020 12:19:24'!
isSimple
	self compositionFactorsDo: [:each| each isTrivial ifFalse: [^ false]].
	^ true! !

!Algebra methodsFor: 'testing' stamp: 'len 6/11/2020 12:20:40'!
isTrivial
	^ self asModule isTrivial! !

!Algebra methodsFor: 'private' stamp: 'len 7/18/2021 12:55:58'!
species
	^ Algebra! !

!Algebra class methodsFor: 'instance creation' stamp: 'len 7/7/2020 06:19:20'!
multiplication: aBilinearMap
	^ self new multiplication: aBilinearMap! !

!Algebra class methodsFor: 'instance creation' stamp: 'len 7/14/2020 09:34:56'!
over: aRing table: anArray
	^ self multiplication: (BilinearMap on: aRing^anArray size table: anArray)! !

!CliffordAlgebra methodsFor: 'accessing' stamp: 'len 7/5/2020 09:59:31'!
degree
	^ self space rank! !

!CliffordAlgebra methodsFor: 'accessing' stamp: 'len 7/14/2021 16:51:09'!
evenSubalgebra
	"Answer the subalgebra of the receiver spanned by the product of an even number of basis elements of the receiver. This are the fixed points of the main involution."
	^ self span: (((1 to: self rank) select: [:i| (i-1) bitParity = 0]) collect: [:i| self basis at: i])! !

!CliffordAlgebra methodsFor: 'accessing' stamp: 'len 7/7/2020 10:44:05'!
generators
	^ self propertyAt: #generators ifAbsentPut: [(0 to: self degree - 1) collect: [:i| self basis at: 1 << i + 1]]! !

!CliffordAlgebra methodsFor: 'accessing' stamp: 'len 7/14/2021 16:51:15'!
grade: anInteger
	"Answer the subalgebra of grade anInteger."
	^ self span: (((1 to: self rank) select: [:i| (i - 1) bitCount = anInteger]) collect: [:i| self basis at: i])! !

!CliffordAlgebra methodsFor: 'accessing' stamp: 'len 7/5/2020 10:18:39'!
one
	^ self basis at: 1! !

!CliffordAlgebra methodsFor: 'accessing' stamp: 'len 7/22/2020 13:18:15'!
orthogonalBasis
	"Answer an orthogonal basis of the vector space V that the receiver acts on.
	The embedding of V in the receiver is built such that the i-th element of the orthogonal basis is sent to the (2^(i-1) + 1)-th element of the basis of the receiver."
	^ self propertyAt: #orthogonalBasis! !

!CliffordAlgebra methodsFor: 'accessing' stamp: 'len 7/19/2020 20:14:50'!
pseudoscalar
	"Answer the unit pseudoscalar."
	^ self basis last! !

!CliffordAlgebra methodsFor: 'accessing' stamp: 'len 7/20/2020 06:33:54'!
pseudoscalarInverse
	^ self propertyAt: #pseudoscalarInverse ifAbsentPut: [self pseudoscalar inverse]! !

!CliffordAlgebra methodsFor: 'accessing' stamp: 'len 7/28/2020 11:00:15'!
quadraticForm
	"Answer the quadratic form associated to the receiver."
	^ self propertyAt: #quadraticForm! !

!CliffordAlgebra methodsFor: 'accessing' stamp: 'len 7/28/2020 11:00:59'!
space
	"Answer the space this Clifford algebra acts on."
	^ self quadraticForm domain! !

!CliffordAlgebra methodsFor: 'elements' stamp: 'len 7/21/2020 18:38:43'!
adapt: anElement
	(self space includes: anElement) ifTrue: [^ self fromModuleElement: self asModule !! anElement].
	^ super adapt: anElement! !

!CliffordAlgebra methodsFor: 'elements' stamp: 'len 7/16/2020 09:30:59'!
fromModuleElement: anElement
	^ Multivector parent: self moduleElement: anElement! !

!CliffordAlgebra methodsFor: 'initialization' stamp: 'len 7/14/2021 16:51:29'!
quadraticForm: aQuadraticForm
	| V n basis C T table |
	V _ aQuadraticForm domain.
	n _ V rank.
	basis _ aQuadraticForm polarization orthogonalizationOf: V basis.
	self propertyAt: #orthogonalBasis put: basis.
	C _ V scalars ^ (2 ^ n).
	C addMap: ((V scalars asIdeal to: C mapping: [:i| C basis at: 1]) name: 'i').
	"The embedding of V in the receiver is built such that the i-th element of the computed orthogonal basis is sent to the (2^(i-1) + 1)-th element of the basis of the receiver:"
	T _ (V endomorphisms mapping: [:i| basis at: i]) inverse.
	C addMap: (T -> (V to: C mapping: [:i| C basis at: 1 << (i-1) + 1]) name: 'i').
	self propertyAt: #asModule put: C; propertyAt: #quadraticForm put: aQuadraticForm.
	"Compute the multiplication table of the basis elements:"
	table _ (0 to: self rank - 1) collect: [:x|
		(0 to: self rank - 1) collect: [:y|
			| scalar index |
			scalar _ self scalars one.
			index _ x.
			1 to: self degree do: [:i|
				(y bitAt: i) = 1 ifTrue:
					[(index >> i) bitParity = 1 ifTrue: [scalar _ scalar negated].
					(index bitAt: i) = 1 ifTrue: [scalar _ scalar * (aQuadraticForm value: (basis at: i))].
					index _ index bitXor: 1 << (i - 1)]].
			{index + 1. scalar}]].
	self propertyAt: #basisMultiplicationTable put: table! !

!CliffordAlgebra methodsFor: 'morphisms' stamp: 'len 7/21/2020 18:56:44'!
antiautomorphism
	"Answer the main antiautomorphism of the receiver. This is the map that reverses the multiplication."
	^ self to: self evaluating: [:x| x transpose]! !

!CliffordAlgebra methodsFor: 'morphisms' stamp: 'len 7/21/2020 18:56:27'!
involution
	"Answer the main involution of the receiver. This is an automorphism J such that J(u) = u if u is in the even subalgebra, and J(u) = -u if u is in the odd subspace."
	^ self to: self evaluating: [:x| x reflection]! !

!CliffordAlgebra methodsFor: 'testing' stamp: 'len 7/7/2020 19:48:03'!
isCommutative
	^ self space rank < 2! !

!CliffordAlgebra methodsFor: 'testing' stamp: 'len 7/28/2020 11:00:32'!
isExteriorAlgebra
	^ self quadraticForm isZero! !

!CliffordAlgebra methodsFor: 'testing' stamp: 'len 7/21/2021 16:01:40'!
isInvolutive
	^ true! !

!CliffordAlgebra class methodsFor: 'instance creation' stamp: 'len 7/28/2020 10:59:55'!
on: aQuadraticForm
	^ self new quadraticForm: aQuadraticForm! !

!EndomorphismAlgebra methodsFor: 'accessing' stamp: 'len 7/16/2020 09:14:47'!
codomain
	^ self domain! !

!EndomorphismAlgebra methodsFor: 'accessing' stamp: 'len 7/16/2020 09:14:39'!
domain
	^ self asModule domain! !

!EndomorphismAlgebra methodsFor: 'accessing' stamp: 'len 7/17/2020 13:44:11'!
one
	^ self identity! !

!EndomorphismAlgebra methodsFor: 'accessing' stamp: 'len 7/17/2020 13:46:35'!
space
	"Answer the space this endomorphism algebra acts on."
	^ self domain! !

!EndomorphismAlgebra methodsFor: 'comparing' stamp: 'len 7/17/2020 13:52:05'!
= anObject
	^ self class = anObject class and: [self asModule = anObject asModule]! !

!EndomorphismAlgebra methodsFor: 'comparing' stamp: 'len 7/17/2020 13:52:15'!
hash
	^ self asModule hash! !

!EndomorphismAlgebra methodsFor: 'elements' stamp: 'len 7/16/2020 10:40:48'!
diagonal: anArray
	^ self asModule diagonal: anArray! !

!EndomorphismAlgebra methodsFor: 'elements' stamp: 'len 7/16/2020 09:42:01'!
evaluating: aBlock
	^ self asModule evaluating: aBlock! !

!EndomorphismAlgebra methodsFor: 'elements' stamp: 'len 7/16/2020 09:42:13'!
evaluatingWithArguments: aBlock
	^ self asModule evaluatingWithArguments: aBlock! !

!EndomorphismAlgebra methodsFor: 'elements' stamp: 'len 7/16/2020 09:32:41'!
fromModuleElement: aModuleMap
	^ aModuleMap! !

!EndomorphismAlgebra methodsFor: 'elements' stamp: 'len 10/20/2020 15:20:31'!
identity
	^ self evaluating: [:x| x]! !

!EndomorphismAlgebra methodsFor: 'elements' stamp: 'len 7/22/2020 07:42:58'!
mapping: aBlock
	^ self asModule mapping: aBlock! !

!EndomorphismAlgebra methodsFor: 'elements' stamp: 'len 3/26/2021 17:17:14'!
newFrom: anObject
	anObject isMatrix ifTrue: [^ self asModule matrix: anObject].
	anObject isEvaluable ifTrue: [^ self evaluating: anObject].
	^ super newFrom: anObject! !

!EndomorphismAlgebra methodsFor: 'elements' stamp: 'len 3/18/2021 15:28:15'!
scalar: anElement
	^ self one * anElement! !

!EndomorphismAlgebra methodsFor: 'operations' stamp: 'len 4/25/2021 18:55:47'!
units
	"Answer the multiplicative group of units of the receiver (i.e., elements that have multiplicative inverse).
	This is the natural functor from the cateogry of unital algebras to the category of groups which sends each algebra A to its group of units U(A) and each algebra homomorphism to the restriction to U(A). This functor has a left adjoint which sends each group G to the integral group algebra Z[G]."
	^ self space automorphisms! !

!EndomorphismAlgebra methodsFor: 'testing' stamp: 'len 7/16/2020 09:15:45'!
includes: anObject
	^ self asModule includes: anObject! !

!EndomorphismAlgebra class methodsFor: 'instance creation' stamp: 'len 7/16/2020 09:44:40'!
on: aHomModule
	^ self new module: aHomModule! !

!MatrixAlgebra methodsFor: 'accessing' stamp: 'len 7/17/2020 13:46:49'!
degree
	^ self space rank! !

!MatrixAlgebra methodsFor: 'computing-matrices' stamp: 'len 7/25/2021 09:27:26'!
collapseMatrix2: aMatrix
	| d |
	d _ self domain rank.
	^ self^(aMatrix width / d) => (self^(aMatrix height / d)) filling: [:i :j|
		(self asModule filling: [:i0 :j0| aMatrix at: (i-1*d+i0) @ (j-1*d+j0)])]! !

!MatrixAlgebra methodsFor: 'computing-matrices' stamp: 'len 7/25/2021 09:27:35'!
expandMatrix2: aMatrix
	| R d answer |
	R _ self scalars.
	d _ self domain rank.
	answer _ R^(aMatrix width*d) -> (R^0).
	1 to: aMatrix height do: [:i|
		| a |
		a _ R^0 -> (R^d).
		1 to: aMatrix width do: [:j| a _ a  (aMatrix at: i@j)].
		answer _ answer  a].
	^ answer! !

!MatrixAlgebra methodsFor: 'computing-matrices' stamp: 'len 12/31/2021 09:39:20'!
matrix: B divisionBy: A
	"Answer X and N such that AX + N = B, satisfying that if the i-th column of B is a linear combination of the columns of A then the i-th column of N is zero."
	(A isZero or: [B isZero]) ifTrue: [^ {(B domain => A domain) zero. B}].
	^ ((self expandMatrix2: B) divisionBy: (self expandMatrix2: A)) collect: [:each| self collapseMatrix2: each]! !

!MatrixAlgebra methodsFor: 'elements' stamp: 'len 7/22/2020 07:33:09'!
columns: anArray
	^ self asModule columns: anArray! !

!MatrixAlgebra methodsFor: 'elements' stamp: 'len 7/16/2020 09:41:20'!
filling: aBlock
	^ self asModule filling: aBlock! !

!MatrixAlgebra methodsFor: 'elements' stamp: 'len 7/22/2020 07:33:19'!
rows: anArray
	^ self asModule rows: anArray! !

!MatrixAlgebra methodsFor: 'testing' stamp: 'len 12/26/2021 12:19:17'!
hasCanonicalAssociates
	^ self scalars isPID! !

!MatrixAlgebra methodsFor: 'testing' stamp: 'len 10/3/2018 03:05:18'!
isCommutative
	^ self degree = 1 and: [self scalars isCommutative]! !

!MatrixAlgebra methodsFor: 'testing' stamp: 'len 8/22/2021 17:08:56'!
isField
	^ false
"	^ self space rank = 1 and: [self scalars isField]"! !

!MatrixAlgebra methodsFor: 'testing' stamp: 'len 7/21/2021 17:28:35'!
isInvolutive
	^ true! !

!MatrixAlgebra methodsFor: 'testing' stamp: 'len 8/22/2021 17:08:47'!
isPID
	^ false
"	^ self space rank = 1 and: [self scalars isPID]"! !

!MatrixAlgebra class methodsFor: 'instance creation' stamp: 'len 7/16/2020 09:45:40'!
new: anInteger over: aRing
	^ (aRing ^ anInteger) endomorphisms! !

!MatrixAlgebra class methodsFor: 'instance creation' stamp: 'len 7/16/2020 09:45:11'!
on: aMatrixModule
	^ self new module: aMatrixModule! !

!GroupAlgebra methodsFor: 'accessing' stamp: 'len 1/10/2018 22:36:35'!
augmentationIdeal
	^ self augmentation kernel! !

!GroupAlgebra methodsFor: 'accessing' stamp: 'len 7/14/2020 16:47:06'!
eta
	| one |
	one _ self scalars one.
	^ self asModule filling: [:i| one]! !

!GroupAlgebra methodsFor: 'accessing' stamp: 'len 7/14/2020 11:46:46'!
generators
	^ (self group generators ifNil: [^ nil]) collect: [:each| self !! each]! !

!GroupAlgebra methodsFor: 'accessing' stamp: 'len 7/14/2020 11:38:18'!
group
	^ self propertyAt: #group! !

!GroupAlgebra methodsFor: 'accessing' stamp: 'len 7/14/2020 11:46:00'!
one
	^ self !! self group identity! !

!GroupAlgebra methodsFor: 'elements' stamp: 'len 12/22/2021 14:11:49'!
adapt: anElement
	(self group includes: anElement)
		ifTrue: [^ self !! (self asModule generatorNamed: anElement)].
	(self scalars includes: anElement)
		ifTrue: [^ self one * anElement].
	^ super adapt: anElement! !

!GroupAlgebra methodsFor: 'elements' stamp: 'len 7/25/2021 10:20:09'!
fromModuleElement: anElement
	^ GroupAlgebraElement parent: self moduleElement: anElement! !

!GroupAlgebra methodsFor: 'initialization' stamp: 'len 10/28/2020 13:33:27'!
group: aGroup scalars: aRing
	| indexToGroupElement groupElementToIndex V |
	aGroup isFinite ifFalse: [^ self notYetImplemented].
	self propertyAt: #group put: aGroup.
	indexToGroupElement _ aGroup asArray.
	"make sure the identity element is at the first index:"
	indexToGroupElement swap: 1 with: (indexToGroupElement indexOf: aGroup identity).
	groupElementToIndex _ Dictionary new.
	indexToGroupElement withIndexDo: [:g :i| groupElementToIndex at: g put: i].
	V _ aRing^indexToGroupElement.
	self module: V.
	self propertyAt: #indexToGroupElement put: indexToGroupElement.
	self propertyAt: #groupElementToIndex put: groupElementToIndex.
	"this bilinear map is just 1s and 0s, it is too slow to use this for multiplication, should implement a custom multiplication :
	self multiplication: (BilinearMap on: V mapping: [:i :j| V x: (indices at: (groupElements at: i) * (groupElements at: j))])"! !

!GroupAlgebra methodsFor: 'morphisms' stamp: 'len 4/8/2021 12:21:07'!
augmentation
	"Answer the augmentation map, an algebra homomorphism (an epimorphism) from the receiver to the ring of scalars."
	^ self onto: self scalars asIdeal asAlgebra evaluating: [:f| f augmentation]! !

!GroupAlgebra methodsFor: 'morphisms' stamp: 'len 7/14/2020 21:12:31'!
involution
	^ self to: self mapping: [:i| self !! (self indexToGroupElement at: i) inverse]! !

!GroupAlgebra methodsFor: 'testing' stamp: 'len 7/14/2020 11:27:08'!
isCommutative
	^ self group isCommutative! !

!GroupAlgebra methodsFor: 'testing' stamp: 'len 7/31/2021 12:44:56'!
isField
	^ self scalars isField and: [self group isTrivial] "??? is this right?"! !

!GroupAlgebra methodsFor: 'testing' stamp: 'len 7/21/2021 16:26:50'!
isInvolutive
	^ true! !

!GroupAlgebra class methodsFor: 'instance creation' stamp: 'len 7/14/2020 11:43:10'!
on: aGroup over: aRing
	^ self new group: aGroup scalars: aRing! !

!QuaternionAlgebra methodsFor: 'accessing' stamp: 'len 7/2/2020 13:06:25'!
generators
	^ self propertyAt: #generators ifAbsentPut: [{self i. self j}]! !

!QuaternionAlgebra methodsFor: 'accessing' stamp: 'len 7/2/2020 13:05:58'!
i
	^ self basis at: 2! !

!QuaternionAlgebra methodsFor: 'accessing' stamp: 'len 7/14/2020 10:08:51'!
invariants
	"Answer the invariants a,b of this quaternion algebra."
	^ self propertyAt: #invariants ifAbsentPut: [{self i squared asScalar. self j squared asScalar}]! !

!QuaternionAlgebra methodsFor: 'accessing' stamp: 'len 7/2/2020 13:06:04'!
j
	^ self basis at: 3! !

!QuaternionAlgebra methodsFor: 'accessing' stamp: 'len 7/2/2020 13:06:12'!
k
	^ self basis at: 4! !

!QuaternionAlgebra methodsFor: 'accessing' stamp: 'len 6/17/2020 14:18:04'!
one
	^ self basis first! !

!QuaternionAlgebra methodsFor: 'elements' stamp: 'len 7/16/2020 09:31:53'!
fromModuleElement: anElement
	^ Quaternion parent: self moduleElement: anElement! !

!QuaternionAlgebra methodsFor: 'testing' stamp: 'len 6/11/2020 19:36:38'!
isCentral
	^ true! !

!QuaternionAlgebra methodsFor: 'testing' stamp: 'len 6/11/2020 19:30:56'!
isCommutative
	"Quaternion algebras are always noncommutative."
	^ false! !

!QuaternionAlgebra methodsFor: 'testing' stamp: 'len 5/2/2021 11:21:22'!
isDivisionAlgebra
	"An algebra is called a 'division algebra' if ax=b and xa=b have unique solutions for nonzero a.
	If the receiver is not a division algebra, it is isomorphic to the algebra of 2x2 matrices."
	self scalars =  ifTrue: [^ self discriminant ~= self scalars one].
	^ super isDivisionAlgebra! !

!QuaternionAlgebra methodsFor: 'testing' stamp: 'len 7/21/2021 16:01:23'!
isInvolutive
	^ true! !

!QuaternionAlgebra methodsFor: 'testing' stamp: 'len 6/11/2020 19:36:34'!
isSimple
	^ true! !

!QuaternionAlgebra class methodsFor: 'instance creation' stamp: 'len 7/22/2021 10:50:10'!
over: aField invariants: anArray
	"Given invariants a and b, answer the quaternion algebra over aField (of characteristic not 2) generated by i and j such that:
		i^2 = a,
		j^2 = b,
		ji = -ij."
	| a b V u i j k |
	(anArray size ~= 2 or: [(a _ anArray at: 1) isZero or: [(b _ anArray at: 2) isZero]])
		ifTrue: [^ DomainError signal].
	V _ aField^4.
	u _ V x: 1.
	i _ V x: 2.
	j _ V x: 3.
	k _ V x: 4.
	^ super multiplication: (BilinearMap on: V table:
		{
		{u. i. j. k}.
		{i. u*a. k. j*a}.
		{j. k*-1. u*b. i*b*-1}.
		{k. j*a*-1.  i*b. u*a*b*-1}})! !

!Order methodsFor: 'morphisms' stamp: 'len 12/22/2021 15:00:35'!
to: aCodomain
	aCodomain = self ambient fractions ifTrue: [^ self addMap: (self to: aCodomain evaluating: [:x| aCodomain !! x])].
	^ super to: aCodomain! !

!Order methodsFor: 'testing' stamp: 'len 7/15/2021 16:31:59'!
isField
	^ false! !

!Order methodsFor: 'testing' stamp: 'len 1/1/2022 11:50:53'!
isIntegralDomain
	^ true! !

!Order methodsFor: 'testing' stamp: 'len 7/15/2021 16:31:42'!
isIntegrallyClosedDomain
	^ true! !

!Order methodsFor: 'private' stamp: 'len 7/15/2021 15:44:21'!
species
	^ Order! !

!MaximalOrder methodsFor: 'accessing' stamp: 'len 7/10/2021 11:37:20'!
degree
	^ self fractions degree! !

!MaximalOrder methodsFor: 'accessing' stamp: 'len 7/15/2021 16:51:47'!
one
	^ self !! self fractions one! !

!MaximalOrder methodsFor: 'elements' stamp: 'len 7/10/2021 11:58:01'!
adapt: anElement
	(self fractions includes: anElement) ifTrue: [^ self fromModuleElement: (self asModule elementAt: self fractions integralBasisMatrix \ (self fractions asVectorSpace !! anElement))].
	^ super adapt: anElement! !

!MaximalOrder methodsFor: 'elements' stamp: 'len 7/15/2021 16:51:25'!
fromModuleElement: anElement
	^ AlgebraicInteger parent: self moduleElement: anElement! !

!MaximalOrder methodsFor: 'operations' stamp: 'len 7/10/2021 11:37:54'!
fractions
	"Answer the abient number field.
	NOTE: Magma does this differently, the fractions field of a number ring is not its ambient field but an isomorphic field made of formal fractions with denominator a rational integer."
	^ self propertyAt: #fractions! !

!MaximalOrder methodsFor: 'testing' stamp: 'len 7/15/2021 16:51:30'!
isDedekindDomain
	"Rings of integers of number fields or function fields are Dedekind domains."
	^ true! !

!MaximalOrder methodsFor: 'testing' stamp: 'len 1/4/2022 15:11:18'!
isInvolutive
	^ self fractions isInvolutive! !

!MaximalOrder methodsFor: 'testing' stamp: 'len 12/23/2021 19:18:20'!
isPID
	"A Dedekind domain is a UFD iff it is a PID."
	self flag: #fix. "for now ignore the PID structure"
	^ super isPID
"	^ self fractions classNumber = 1"! !

!MaximalOrder methodsFor: 'testing' stamp: 'len 7/12/2021 13:19:16'!
isPIR
	^ self isPID! !

!MaximalOrder methodsFor: 'testing' stamp: 'len 12/18/2016 15:03:20'!
isUFD
	"A Dedekind domain is a UFD iff it is a PID."
	^ self isPID! !

!MaximalOrder methodsFor: 'private' stamp: 'len 7/11/2021 11:17:49'!
fractions: aNumberField
	| M B |
	self propertyAt: #fractions put: aNumberField.
	self propertyAt: #asModule put: (M _ aNumberField scalars integers ^ aNumberField degree).
	B _ aNumberField integralBasisMatrix.
	self multiplication:
		(BilinearMap from: M, M to: M evaluatingWithArguments: [:x :y|
			(self !! ((aNumberField !! (B * x)) * (aNumberField !! (B * y)))) asModuleElement])! !

!MaximalOrder class methodsFor: 'instance creation' stamp: 'len 7/10/2021 11:38:54'!
on: aNumberField
	^ self new fractions: aNumberField! !

!QuadraticRing methodsFor: 'elements' stamp: 'len 1/4/2022 12:25:51'!
fromModuleElement: anElement
	^ QuadraticInteger parent: self moduleElement: anElement! !

!QuadraticRing methodsFor: 'testing' stamp: 'len 12/31/2021 11:51:12'!
isEuclidean
	"Answer true if the receiver is a Euclidean ring, i.e. it has Euclidean division with remainder."
"	self fractions d negative ifFalse: [self notYetImplemented].
	(#(-11 -7 -3 -2 -1) includes: self fractions d) ifFalse: [^ false].
	self notYetImplemented"
	^ super isEuclidean! !

!QuadraticRing methodsFor: 'testing' stamp: 'len 12/23/2016 16:47:35'!
isIntegralDomain
	^ true! !

!QuadraticRing methodsFor: 'testing' stamp: 'len 7/10/2021 11:36:41'!
isNormEuclidean
	^ #(-11 -7 -3 -2 -1 2 3 5 6 7 11 13 17 19 21 29 33 37 41 57 73) includes: self fractions d! !

!QuadraticRing methodsFor: 'testing' stamp: 'len 12/23/2021 19:19:56'!
isPID
	self flag: #fix. "for now ignore the PID structure of some quadratic rings"
"	self fractions d negative ifTrue: [^ #(-1 -2 -3 -7 -11 -19 -43 -67 -163) includes: self fractions d]."
	^ false! !

!GaussianRing methodsFor: 'elements' stamp: 'len 1/4/2022 12:25:38'!
fromModuleElement: anElement
	^ GaussianInteger parent: self moduleElement: anElement! !

!GaussianRing methodsFor: 'elements' stamp: 'len 1/4/2022 14:52:19'!
i
	^ self real: 0 imaginary: 1! !

!GaussianRing methodsFor: 'elements' stamp: 'len 1/4/2022 14:48:59'!
real: anInteger imaginary: anotherInteger
	^ self fromModuleElement: (self asModule elementAt: {anInteger. anotherInteger})! !

!GaussianRing methodsFor: 'elements' stamp: 'len 1/4/2022 14:53:49'!
unitsDo: aBlock
	aBlock value: self one; value: self one negated; value: self i; value: self i negated! !

!GaussianRing methodsFor: 'testing' stamp: 'len 1/4/2022 18:52:12'!
isEuclidean
	^ true! !

!GaussianRing methodsFor: 'testing' stamp: 'len 1/4/2022 18:54:42'!
isPID
	^ true! !

!ComplexField methodsFor: 'accessing' stamp: 'len 8/6/2016 03:44'!
characteristic
	^ 0! !

!ComplexField methodsFor: 'accessing' stamp: 'len 8/6/2016 03:45'!
one
	^ 1! !

!ComplexField methodsFor: 'accessing' stamp: 'len 12/29/2021 11:55:57'!
size
	^ Cardinal new: 1! !

!ComplexField methodsFor: 'accessing' stamp: 'len 8/6/2016 03:45'!
zero
	^ 0! !

!ComplexField methodsFor: 'comparing' stamp: 'len 1/20/2018 19:06:56'!
= anObject
	^ anObject class == self class! !

!ComplexField methodsFor: 'comparing' stamp: 'len 1/20/2018 19:07:25'!
hash
	^ self class hash! !

!ComplexField methodsFor: 'computing-polynomials' stamp: 'len 8/5/2021 08:37:21'!
allRootsOf: aPolynomial
	| answer |
	answer _ Bag new.
	aPolynomial integerPrimitivePart factorization withOccurrencesDo: [:f :e|
		f degree = 1
			ifTrue:
				[answer add: (f independentCoefficient negated / f leadingCoefficient) withOccurrences: e]
			ifFalse:
				[(ComplexRootIsolator on: f) roots do: [:each|
	 				answer add: (ComplexAlgebraicNumber minimalPolynomial: f approximation: each center radius: each radius) withOccurrences: e]]].
	^ answer! !

!ComplexField methodsFor: 'enumerating' stamp: 'len 8/6/2016 03:50'!
do: aBlock
	^ self shouldNotImplement! !

!ComplexField methodsFor: 'testing' stamp: 'len 8/5/2016 21:50'!
includes: anObject
	^ anObject isComplex! !

!ComplexField methodsFor: 'testing' stamp: 'len 8/12/2016 04:48'!
isAlgebraicallyClosed
	^ true! !

!ComplexField methodsFor: 'testing' stamp: 'len 8/7/2019 07:45:58'!
isApproximate
	^ true! !

!ComplexField methodsFor: 'testing' stamp: 'len 4/28/2021 09:37:09'!
isCommutative
	^ true! !

!ComplexField methodsFor: 'testing' stamp: 'len 8/5/2016 21:55'!
isComplex
	^ true! !

!ComplexField methodsFor: 'testing' stamp: 'len 10/18/2016 20:43'!
isField
	^ true! !

!ComplexField methodsFor: 'testing' stamp: 'len 7/21/2021 15:43:40'!
isInvolutive
	^ true! !

!ComplexField methodsFor: 'testing' stamp: 'len 1/26/2018 18:57:44'!
isLocalField
	^ true! !

!ComplexField class methodsFor: 'initialization' stamp: 'len 5/23/2020 08:51:01'!
initialize
	super initialize.
	Smalltalk at: # put: self new! !

!RealField methodsFor: 'accessing' stamp: 'len 8/6/2016 03:45'!
characteristic
	^ 0! !

!RealField methodsFor: 'accessing' stamp: 'len 1/19/2017 16:29:14'!
one
	^ 1! !

!RealField methodsFor: 'accessing' stamp: 'len 12/29/2021 11:55:57'!
size
	^ Cardinal new: 1! !

!RealField methodsFor: 'accessing' stamp: 'len 1/19/2017 16:29:18'!
zero
	^ 0! !

!RealField methodsFor: 'comparing' stamp: 'len 6/22/2019 03:33:36'!
< aDomain
	^ super < aDomain or: [aDomain isKindOf: ComplexField]! !

!RealField methodsFor: 'comparing' stamp: 'len 1/20/2018 18:59:57'!
= anObject
	^ anObject class == self class! !

!RealField methodsFor: 'comparing' stamp: 'len 1/20/2018 19:00:05'!
hash
	^ self class hash! !

!RealField methodsFor: 'computing-polynomials' stamp: 'len 8/5/2021 08:42:49'!
allRootsOf: aPolynomial
	| answer |
	answer _ Bag new.
	aPolynomial integerPrimitivePart factorization withOccurrencesDo: [:f :e|
		f degree = 1
			ifTrue:
				[answer add: (f independentCoefficient negated / f leadingCoefficient) withOccurrences: e]
			ifFalse:
				[(RealRootIsolator on: f) roots do: [:each|
	 				answer add: (RealAlgebraicNumber minimalPolynomial: f bounds: each) withOccurrences: e]]].
	^ answer! !

!RealField methodsFor: 'enumerating' stamp: 'len 8/6/2016 03:50'!
do: aBlock
	^ self shouldNotImplement! !

!RealField methodsFor: 'morphisms' stamp: 'len 3/25/2018 19:32:22'!
embed: anObject
	(anObject isInteger or: [anObject isFraction]) ifTrue: [^ anObject].
	^ super embed: anObject! !

!RealField methodsFor: 'operations' stamp: 'len 5/23/2020 09:04:02'!
algebraicClosure
	^ ! !

!RealField methodsFor: 'testing' stamp: 'len 8/5/2016 21:50'!
includes: anObject
	^ anObject isReal! !

!RealField methodsFor: 'testing' stamp: 'len 8/7/2019 07:45:43'!
isApproximate
	^ true! !

!RealField methodsFor: 'testing' stamp: 'len 4/28/2021 09:39:21'!
isCommutative
	^ true! !

!RealField methodsFor: 'testing' stamp: 'len 10/18/2016 20:44'!
isField
	^ true! !

!RealField methodsFor: 'testing' stamp: 'len 1/20/2018 19:01:50'!
isFinite
	^ false! !

!RealField methodsFor: 'testing' stamp: 'len 1/26/2018 18:57:34'!
isLocalField
	^ true! !

!RealField methodsFor: 'testing' stamp: 'len 10/2/2018 01:52:57'!
isOrdered
	^ true! !

!RealField methodsFor: 'testing' stamp: 'len 8/9/2020 08:00:00'!
isReal
	"Answer true if the receiver is a subring of the real field."
	^ true! !

!RealField class methodsFor: 'initialization' stamp: 'len 5/23/2020 08:51:12'!
initialize
	super initialize.
	Smalltalk at: # put: self new! !

!AdicRing methodsFor: 'accessing' stamp: 'len 12/17/2016 20:31:49'!
characteristic
	^ 0! !

!AdicRing methodsFor: 'accessing' stamp: 'len 8/11/2019 11:56:56'!
defaultPrecision
	"Answer the default precision used when coercing integers or rationals into the receiver."
	^ self propertyAt: #defaultPrecision ifAbsent: [20]! !

!AdicRing methodsFor: 'accessing' stamp: 'len 6/28/2019 10:07:18'!
fractions
	^ self propertyAt: #fractions ifAbsentPut: [AdicField on: self]! !

!AdicRing methodsFor: 'accessing' stamp: 'len 8/11/2019 11:41:41'!
maximalIdeal
	"Answer the unique maximal ideal in the receiver."
	^ self * self uniformizer! !

!AdicRing methodsFor: 'accessing' stamp: 'len 8/11/2019 11:18:48'!
one
	^ self embed: 1! !

!AdicRing methodsFor: 'accessing' stamp: 'len 8/10/2019 04:30:34'!
p
	^ self propertyAt: #p! !

!AdicRing methodsFor: 'accessing' stamp: 'len 8/11/2019 11:50:43'!
precision
	"Answer the precision bound for the receiver."
	^ self propertyAt: #precision ifAbsent: [Infinity positive]! !

!AdicRing methodsFor: 'accessing' stamp: 'len 6/2/2019 05:24:00'!
primeSubring
	^ self! !

!AdicRing methodsFor: 'accessing' stamp: 'len 8/7/2019 07:12:34'!
residueField
	"Answer the prime field Z/pZ isomorphic to the residue field of the receiver, equipped with the canonical projection."
	^ self propertyAt: #residueField ifAbsentPut:
		[| answer |
		(answer _ PrimeField new: self p)
			addMap: (self onto: answer evaluating: [:x| answer !! (x at: 0)]); "TODO: add kernel and section"
			yourself]! !

!AdicRing methodsFor: 'accessing' stamp: 'len 12/29/2021 11:55:57'!
size
	^ Cardinal new! !

!AdicRing methodsFor: 'accessing' stamp: 'len 1/2/2022 09:55:27'!
uniformizer
	"A uniformizer (or uniformizing parameter, uniformizer element or prime element) is any irreducible element of a DVR, or equivalently a generator of the maximal ideal. All nonzero ideals are generated by some power of the uniformizer."
	^ self !! self p! !

!AdicRing methodsFor: 'accessing' stamp: 'len 8/11/2019 11:18:51'!
zero
	^ self embed: 0! !

!AdicRing methodsFor: 'comparing' stamp: 'len 8/11/2019 04:28:10'!
= anObject
	^ self == anObject or: [self class = anObject class and: [self p = anObject p and: [self precision = anObject precision]]]! !

!AdicRing methodsFor: 'comparing' stamp: 'len 8/11/2019 04:27:13'!
hash
	^ self p hash! !

!AdicRing methodsFor: 'elements' stamp: 'len 4/9/2020 18:02:57'!
adapt: anElement
	anElement isInteger ifTrue: [^ self embed: anElement].
	anElement isFraction ifTrue: [^ (self embed: anElement numerator) / (self embed: anElement denominator)]. "fix: only germs with valuation >= 0"
	^ super adapt: anElement! !

!AdicRing methodsFor: 'elements' stamp: 'len 8/11/2019 11:54:11'!
embed: anInteger
	^ self project: anInteger precision: self defaultPrecision! !

!AdicRing methodsFor: 'elements' stamp: 'len 8/11/2019 09:55:11'!
project: anInteger precision: N
	^ self representative: anInteger \\ (self power: N) precision: N! !

!AdicRing methodsFor: 'elements' stamp: 'len 8/12/2019 16:58:04'!
representative: anInteger precision: N
	N < 0 ifTrue: [^ self error: 'negative precision is not allowed'].
	^ AdicInteger new parent: self representative: anInteger precision: N! !

!AdicRing methodsFor: 'operations' stamp: 'len 6/6/2019 12:05:52'!
jet: anInteger
	"Answer the anInteger-th jet of the receiver, that is the quotient ring isomorphic to the anInteger-th truncation of the receiver."
	^ PrimePowerRing new: self p to: anInteger! !

!AdicRing methodsFor: 'random' stamp: 'len 8/12/2019 16:12:48'!
atRandom: aRandom
	^ self atRandom: aRandom bits: (self p log: 2) * self defaultPrecision! !

!AdicRing methodsFor: 'random' stamp: 'len 5/23/2020 08:55:40'!
atRandom: aRandom bits: bitSize
	| n |
	n _  atRandom: aRandom bits: bitSize.
	n = 0 ifTrue: [n _ 1].
	^ self !! n! !

!AdicRing methodsFor: 'testing' stamp: 'len 4/25/2020 09:54:31'!
includes: anObject
	^ anObject parent == self! !

!AdicRing methodsFor: 'testing' stamp: 'len 8/7/2019 07:48:32'!
isApproximate
	^ true! !

!AdicRing methodsFor: 'testing' stamp: 'len 6/2/2019 05:03:27'!
isBounded
	"Answer true if the precision of the receiver is bounded."
	^ self precision isFinite! !

!AdicRing methodsFor: 'testing' stamp: 'len 4/28/2021 09:36:13'!
isCommutative
	^ true! !

!AdicRing methodsFor: 'testing' stamp: 'len 6/4/2019 17:48:35'!
isDVR
	"Answer true if the receiver is a discrete valuation ring, i.e. a local PID that is not a field."
	^ true! !

!AdicRing methodsFor: 'testing' stamp: 'len 12/31/2021 11:52:00'!
isEuclidean
	"Answer true if the receiver is a Euclidean ring, i.e. it has Euclidean division with remainder."
	^ true! !

!AdicRing methodsFor: 'testing' stamp: 'len 12/7/2015 01:29'!
isIntegralDomain
	^ true! !

!AdicRing methodsFor: 'testing' stamp: 'len 8/11/2019 11:40:53'!
isLocal
	^ true! !

!AdicRing methodsFor: 'testing' stamp: 'len 8/10/2019 04:52:48'!
isPID
	^ true! !

!AdicRing methodsFor: 'testing' stamp: 'len 6/2/2019 05:03:44'!
isUnbounded
	"Answer true if the precision of the receiver is unbounded."
	^ self precision isInfinite! !

!AdicRing methodsFor: 'private' stamp: 'len 8/11/2019 11:53:23'!
defaultPrecision: anInteger
	self precision isFinite ifTrue: [self error: 'precision is already bounded'].
	self propertyAt: #defaultPrecision put: anInteger! !

!AdicRing methodsFor: 'private' stamp: 'len 8/10/2019 04:29:33'!
p: aPrime
	self propertyAt: #p put: aPrime! !

!AdicRing methodsFor: 'private' stamp: 'len 5/14/2020 05:19:12'!
power: anInteger
	self flag: #fix. "optimize, cache p^(2^n) and multiply"
	^ self p ^ anInteger! !

!AdicRing methodsFor: 'private' stamp: 'len 8/11/2019 11:54:54'!
precision: anInteger
	self defaultPrecision: anInteger.
	self propertyAt: #precision put: anInteger! !

!AdicRing class methodsFor: 'instance creation' stamp: 'len 8/10/2019 04:30:13'!
at: aPrime
	^ self new p: aPrime! !

!AdicRing class methodsFor: 'instance creation' stamp: 'len 6/6/2019 12:03:02'!
at: aPrime precision: anInteger
	^ (self at: aPrime) precision: anInteger! !

!PowerSeriesRing methodsFor: 'printing' stamp: 'len 6/6/2019 13:22:18'!
printIndeterminatesOn: aStream
	self base printIndeterminatesOn: aStream! !

!PowerSeriesRing methodsFor: 'accessing' stamp: 'len 8/9/2019 11:32:16'!
base
	^ self propertyAt: #base! !

!PowerSeriesRing methodsFor: 'accessing' stamp: 'len 10/28/2016 14:17'!
characteristic
	^ self scalars characteristic! !

!PowerSeriesRing methodsFor: 'accessing' stamp: 'len 8/11/2019 11:57:37'!
defaultPrecision
	"Answer the default precision used when coercing elements from other rings (such as polynomials or rational functions) into the receiver."
	^ self propertyAt: #defaultPrecision ifAbsent: [20]! !

!PowerSeriesRing methodsFor: 'accessing' stamp: 'len 3/21/2021 13:10:25'!
dimension
	"Answer the Krull dimension of the receiver. This is the length of the longest ascending chain of prime ideals."
	self scalars isNoetherian ifTrue: [^ self scalars dimension + self base rank].
	^ super dimension! !

!PowerSeriesRing methodsFor: 'accessing' stamp: 'len 8/9/2019 11:36:48'!
jet: anInteger
	"Answer the anInteger-th jet of the receiver, that is the quotient ring isomorphic to the anInteger-th truncation of the receiver."
	| R answer |
	anInteger > 0 ifFalse: [^ self error: 'jet degree must be >= 1'].
	R _ self base.
	^ (answer _ R / (R * R generators ^ anInteger))
		addMap: (self onto: answer evaluating: [:f| answer project: f representative]);
		yourself! !

!PowerSeriesRing methodsFor: 'accessing' stamp: 'len 3/21/2021 13:11:18'!
maximalIdeal
	self scalars isField ifTrue: [^ self * self base generators].
	^ self * self base generators + self scalars maximalIdeal! !

!PowerSeriesRing methodsFor: 'accessing' stamp: 'len 3/21/2021 13:11:28'!
one
	^ self embed: self base one! !

!PowerSeriesRing methodsFor: 'accessing' stamp: 'len 8/11/2019 11:57:48'!
precision
	"Answer the precision bound for the receiver."
	^ self propertyAt: #precision ifAbsent: [Infinity positive]! !

!PowerSeriesRing methodsFor: 'accessing' stamp: 'len 8/9/2019 11:40:05'!
residueField
	"Answer the coefficients field, isomorphic to the residue field of the receiver, equipped with the canonical projection."
	^ self scalars residueField! !

!PowerSeriesRing methodsFor: 'accessing' stamp: 'len 6/6/2019 13:20:12'!
scalars
	^ self base scalars! !

!PowerSeriesRing methodsFor: 'accessing' stamp: 'len 12/29/2021 11:55:57'!
size
	^ Cardinal new: 1! !

!PowerSeriesRing methodsFor: 'accessing' stamp: 'len 1/2/2022 10:08:34'!
uniformizer
	"A uniformizer (or uniformizing parameter, uniformizer element or prime element) is any irreducible element of a DVR, or equivalently a generator of the maximal ideal. All nonzero ideals are generated by some power of the uniformizer."
	self isDVR ifFalse: [DomainError signal: 'not a DVR'].
	^ self x! !

!PowerSeriesRing methodsFor: 'accessing' stamp: 'len 3/21/2021 13:12:00'!
zero
	^ self embed: self base zero! !

!PowerSeriesRing methodsFor: 'comparing' stamp: 'len 8/11/2019 12:15:45'!
= anObject
	^ self == anObject or: [self class = anObject class and: [self base = anObject base and: [self precision = anObject precision]]]! !

!PowerSeriesRing methodsFor: 'comparing' stamp: 'len 8/11/2019 12:15:55'!
hash
	^ self base hash! !

!PowerSeriesRing methodsFor: 'elements' stamp: 'len 8/9/2019 13:57:34'!
O: anInteger
	anInteger > 0 ifFalse: [self error: 'precision must be positive'].
	^ self representative: self base zero precision: anInteger! !

!PowerSeriesRing methodsFor: 'elements' stamp: 'len 4/9/2020 18:13:56'!
adapt: anElement
	(self base includes: anElement) ifTrue: [^ self embed: anElement].
	(self scalars includes: anElement) ifTrue: [^ self  embed: (self base constant: anElement)].
	^ super adapt: anElement! !

!PowerSeriesRing methodsFor: 'elements' stamp: 'len 8/11/2019 12:12:37'!
coefficients: aSequence
	self isUnivariate ifFalse: [^ self error: 'not univariate'].
	^ self embed: (self base coefficients: (aSequence first: self defaultPrecision))! !

!PowerSeriesRing methodsFor: 'elements' stamp: 'len 8/12/2019 16:58:13'!
representative: aPolynomial precision: anInteger
	anInteger < 0 ifTrue: [^ self error: 'negative precision is not allowed'].
	^ PowerSeries new parent: self; representative: aPolynomial; precision: anInteger! !

!PowerSeriesRing methodsFor: 'elements' stamp: 'len 3/21/2021 13:33:25'!
x
	^ self x: 1! !

!PowerSeriesRing methodsFor: 'elements' stamp: 'len 3/21/2021 13:07:59'!
x: anInteger
	^ self embed: (self base x: anInteger)! !

!PowerSeriesRing methodsFor: 'morphisms' stamp: 'len 8/11/2019 11:59:10'!
embed: aPolynomial
	^ self representative: aPolynomial precision: self defaultPrecision! !

!PowerSeriesRing methodsFor: 'morphisms' stamp: 'len 12/22/2021 15:00:56'!
to: aCodomain
	aCodomain = self residueField ifTrue: [^ self addMap: ((self onto: aCodomain evaluating: [:f| aCodomain !! (f coefficients at: 1)]) name: '')].
	^ super to: aCodomain! !

!PowerSeriesRing methodsFor: 'operations' stamp: 'len 3/1/2021 13:59:11'!
fractions
	^ self propertyAt: #fractions ifAbsentPut:
		[self scalars isField
			ifTrue: [LaurentSeriesRing on: self]
			ifFalse: [LaurentSeriesRing on: (self over: self scalars fractions)]]! !

!PowerSeriesRing methodsFor: 'operations' stamp: 'len 8/9/2019 13:48:28'!
over: aRing
	^ self class on: (self base over: aRing)! !

!PowerSeriesRing methodsFor: 'random' stamp: 'len 3/21/2021 13:13:20'!
atRandom: aRandom bits: bitSize
	^ self embed: (self base atRandom: aRandom bits: bitSize maxDegree: self defaultPrecision - 1)! !

!PowerSeriesRing methodsFor: 'testing' stamp: 'len 12/26/2021 12:21:13'!
hasCanonicalAssociates
	^ self base hasCanonicalAssociates! !

!PowerSeriesRing methodsFor: 'testing' stamp: 'len 4/25/2020 10:06:21'!
includes: anObject
	^ anObject parent = self! !

!PowerSeriesRing methodsFor: 'testing' stamp: 'len 8/7/2019 07:49:08'!
isApproximate
	^ true! !

!PowerSeriesRing methodsFor: 'testing' stamp: 'len 4/28/2021 09:38:26'!
isCommutative
	^ true! !

!PowerSeriesRing methodsFor: 'testing' stamp: 'len 8/10/2019 04:05:53'!
isDVR
	"Answer true if the receiver is a discrete valuation ring, i.e. a local PID that is not a field."
	^ self scalars isField and: [self isUnivariate]! !

!PowerSeriesRing methodsFor: 'testing' stamp: 'len 6/6/2019 13:20:16'!
isIntegralDomain
	^ self base isIntegralDomain! !

!PowerSeriesRing methodsFor: 'testing' stamp: 'len 8/9/2019 11:49:32'!
isLocal
	^ self scalars isLocal! !

!PowerSeriesRing methodsFor: 'testing' stamp: 'len 6/6/2019 13:22:14'!
isMultivariate
	^ self base isMultivariate! !

!PowerSeriesRing methodsFor: 'testing' stamp: 'len 3/21/2021 15:11:00'!
isNoetherian
	"A ring is called Noetherian if every ideal is finitely generated."
	^ self scalars isNoetherian or: [super isNoetherian]! !

!PowerSeriesRing methodsFor: 'testing' stamp: 'len 8/10/2019 05:02:00'!
isPID
	^ self base isPID! !

!PowerSeriesRing methodsFor: 'testing' stamp: 'len 6/7/2020 15:18:22'!
isTrivial
	^ self base isTrivial! !

!PowerSeriesRing methodsFor: 'testing' stamp: 'len 8/9/2019 12:43:57'!
isUnivariate
	^ self base isUnivariate! !

!PowerSeriesRing methodsFor: 'private' stamp: 'len 8/9/2019 11:32:07'!
base: aPolynomialRing
	self propertyAt: #base put: aPolynomialRing! !

!PowerSeriesRing methodsFor: 'private' stamp: 'len 8/11/2019 11:58:03'!
defaultPrecision: anInteger
	self precision isFinite ifTrue: [self error: 'precision is already bounded'].
	self propertyAt: #defaultPrecision put: anInteger! !

!PowerSeriesRing methodsFor: 'private' stamp: 'len 8/11/2019 11:57:58'!
precision: anInteger
	self defaultPrecision: anInteger.
	self propertyAt: #precision put: anInteger! !

!PowerSeriesRing class methodsFor: 'instance creation' stamp: 'len 3/10/2020 09:43:30'!
on: aPolynomialRing
	^ self new base: aPolynomialRing! !

!CompletionRing methodsFor: 'accessing' stamp: 'len 6/6/2019 11:56:17'!
base
	^ self completionIdeal scalars! !

!CompletionRing methodsFor: 'accessing' stamp: 'len 6/6/2019 11:11:18'!
completionIdeal
	^ self propertyAt: #completionIdeal! !

!CompletionRing methodsFor: 'accessing' stamp: 'len 6/6/2019 18:52:55'!
dimension
	"Answer the Krull dimension of the receiver."
	(self base isNoetherian and: [self base isLocal])
		ifTrue: [^ self base dimension].
	^ super dimension! !

!CompletionRing methodsFor: 'accessing' stamp: 'len 6/6/2019 10:56:36'!
maximalIdeal
	"Answer the unique maximal ideal in the receiver."
	^ self * (self completionIdeal generators collect: [:each| self embed: each])! !

!CompletionRing methodsFor: 'accessing' stamp: 'len 6/6/2019 16:52:57'!
one
	^ self embed: self base one! !

!CompletionRing methodsFor: 'accessing' stamp: 'len 6/6/2019 16:53:02'!
zero
	^ self embed: self base zero! !

!CompletionRing methodsFor: 'as yet unclassified' stamp: 'len 6/22/2019 03:13:21'!
> aRing
	self base > aRing ifTrue: [^ true].
	^ super > aRing! !

!CompletionRing methodsFor: 'as yet unclassified' stamp: 'len 6/22/2019 03:14:37'!
>= aRing
	super >= aRing ifTrue: [^ true].
	self base >= aRing ifTrue: [^ true].
	^ false! !

!CompletionRing methodsFor: 'as yet unclassified' stamp: 'len 6/6/2019 18:58:05'!
hilbertSeriesAt: t
	"Answer the Hilbert series of the receiver."
	(self base isNoetherian and: [self base isLocal]) ifTrue: [^ self base hilbertSeriesAt: t].
	^ super hilbertSeriesAt: t! !

!CompletionRing methodsFor: 'comparing' stamp: 'len 6/6/2019 17:06:14'!
= anObject
	self == anObject ifTrue: [^ true].
	^ (anObject isKindOf: CompletionRing) and: [anObject completionIdeal = self completionIdeal]! !

!CompletionRing methodsFor: 'comparing' stamp: 'len 6/6/2019 17:06:28'!
hash
	^ self completionIdeal hash + self base hash! !

!CompletionRing methodsFor: 'morphisms' stamp: 'len 12/22/2021 15:04:23'!
from: aDomain
	aDomain = self base ifTrue: [^ self addMap: ((self base into: self evaluating: [:x| self embed: x]) name: 'i')].
	^ super from: aDomain! !

!CompletionRing methodsFor: 'operations' stamp: 'len 6/6/2019 11:59:39'!
jet: anInteger
	"Answer the anInteger-th jet of the receiver, that is the quotient ring isomorphic to the anInteger-th truncation of the receiver."
	^ self base / (self completionIdeal ^ anInteger)! !

!CompletionRing methodsFor: 'testing' stamp: 'len 6/22/2019 03:11:07'!
isCompletion
	^ true! !

!CompletionRing methodsFor: 'testing' stamp: 'len 6/6/2019 10:55:42'!
isLocal
	^ true! !

!CompletionRing methodsFor: 'private' stamp: 'len 6/6/2019 11:11:28'!
completionIdeal: anIdeal
	self propertyAt: #completionIdeal put: anIdeal! !

!CompletionRing class methodsFor: 'instance creation' stamp: 'len 6/6/2019 12:04:12'!
at: anIdeal
	^ self new completionIdeal: anIdeal! !

!FreeAlgebra methodsFor: 'accessing' stamp: 'len 8/25/2016 08:22'!
indeterminates
	^ words symbols! !

!FreeAlgebra methodsFor: 'accessing' stamp: 'len 1/20/2016 14:06'!
one
	^ self constant: scalars one! !

!FreeAlgebra methodsFor: 'accessing' stamp: 'len 1/23/2022 08:42:36'!
rank
	^ self indeterminates size! !

!FreeAlgebra methodsFor: 'accessing' stamp: 'len 1/20/2016 14:58'!
scalars
	^ scalars! !

!FreeAlgebra methodsFor: 'accessing' stamp: 'len 8/25/2016 08:27'!
words
	^ words! !

!FreeAlgebra methodsFor: 'accessing' stamp: 'len 1/10/2018 21:46:27'!
zero
	^ self coefficients: (Dictionary new: 0)! !

!FreeAlgebra methodsFor: 'accessing-private' stamp: 'len 1/20/2016 13:39'!
scalars: aCommutativeRing
	scalars _ aCommutativeRing! !

!FreeAlgebra methodsFor: 'accessing-private' stamp: 'len 8/25/2016 08:24'!
words: aMonoid
	words _ aMonoid! !

!FreeAlgebra methodsFor: 'comparing' stamp: 'len 8/25/2016 08:22'!
= anObject
	self == anObject ifTrue: [^ true].
	^ (anObject isKindOf: FreeAlgebra) and: [anObject scalars = scalars and: [anObject words = words]]! !

!FreeAlgebra methodsFor: 'comparing' stamp: 'len 8/25/2016 08:21'!
hash
	^ scalars hash + words hash hashMultiply! !

!FreeAlgebra methodsFor: 'elements' stamp: 'len 1/10/2018 21:45:38'!
coefficient: aNumber word: aWord
	aNumber isZero ifTrue: [^ self zero].
	^ self coefficients: ((Dictionary new: 1) at: aWord put: aNumber; yourself)! !

!FreeAlgebra methodsFor: 'elements' stamp: 'len 1/10/2018 21:47:02'!
coefficients: aDictionary
	^ (FreePolynomial coefficients: aDictionary) parent: self! !

!FreeAlgebra methodsFor: 'elements' stamp: 'len 1/10/2018 21:45:59'!
constant: aNumber
	^ self coefficient: aNumber word: words identity! !

!FreeAlgebra methodsFor: 'elements' stamp: 'len 8/25/2016 08:21'!
x
	^ self x: self indeterminates first! !

!FreeAlgebra methodsFor: 'elements' stamp: 'len 1/10/2018 12:58:14'!
x: anIndeterminate
	^ self coefficient: scalars one word: (words x: anIndeterminate)! !

!FreeAlgebra methodsFor: 'elements' stamp: 'len 1/10/2018 13:22:40'!
x: anIndeterminate to: anInteger
	^ self coefficient: scalars one word: (words x: anIndeterminate to: anInteger)! !

!FreeAlgebra methodsFor: 'elements' stamp: 'len 8/25/2016 08:22'!
y
	^ self x: self indeterminates second! !

!FreeAlgebra methodsFor: 'elements' stamp: 'len 8/25/2016 08:21'!
z
	^ self x: self indeterminates third! !

!FreeAlgebra methodsFor: 'random' stamp: 'len 3/25/2018 19:36:09'!
atRandom: aRandom bits: bitSize
	^ self atRandom: aRandom bits: bitSize maxDegree: ((bitSize raisedTo: (1/self rank)) min: bitSize - 1) truncated! !

!FreeAlgebra methodsFor: 'random' stamp: 'len 1/10/2018 13:21:35'!
atRandom: aRandom bits: bitSize maxDegree: d
	| answer n term |
	answer _ self zero.
	n _ 2 ^ self rank.
	n timesRepeat:
		[term _ ((1 to: d) product: [:i| self x: (self rank atRandom: aRandom) to: (2 atRandom: aRandom) - 1]) * (self scalars atRandom: aRandom bits: bitSize/(self rank*d)).
		answer _ answer + term].
	^ answer! !

!FreeAlgebra methodsFor: 'testing' stamp: 'len 4/25/2020 10:02:08'!
includes: anObject
	^ anObject parent == self! !

!FreeAlgebra methodsFor: 'testing' stamp: 'len 8/25/2016 08:29'!
isCommutative
	^ words isCommutative and: [scalars isCommutative]! !

!FreeAlgebra methodsFor: 'testing' stamp: 'len 8/25/2016 08:30'!
isFinite
	^ words isFinite and: [scalars isFinite]! !

!FreeAlgebra methodsFor: 'as yet unclassified' stamp: 'len 4/28/2021 13:38:01'!
names: anArray
	"Set indeterminate names to use when printing polynomials."
	words names: anArray! !

!FreeAlgebra class methodsFor: 'instance creation' stamp: 'len 5/11/2019 02:43:48'!
new: aCollection over: aRing
	^ self words: (FreeMonoid new: aCollection) over: aRing! !

!FreeAlgebra class methodsFor: 'instance creation' stamp: 'len 1/20/2016 13:38'!
over: aRing
	^ self new: 1 over: aRing! !

!FreeAlgebra class methodsFor: 'instance creation' stamp: 'len 8/25/2016 08:24'!
words: aMonoid over: aRing
	^ self new words: aMonoid; scalars: aRing! !

!DistributiveAlgebra methodsFor: 'accessing' stamp: 'len 7/19/2021 05:59:20'!
basis
	^ self propertyAt: #basis ifAbsentPut: [self asModule basis collect: [:each| self !! each]]! !

!DistributiveAlgebra methodsFor: 'accessing' stamp: 'len 7/19/2021 06:00:12'!
generators
	"Note: a basis is not necessarily a minimal set of generators (as algebra)."
	^ self propertyAt: #generators ifAbsent: [self basis]! !

!DistributiveAlgebra methodsFor: 'accessing' stamp: 'len 7/19/2021 06:01:45'!
multiplication
	"Answer the multiplication as a bilinear map on the underlying module."
	^ self propertyAt: #multiplication ifAbsentPut: [BilinearMap from: self asModule, self asModule to: self asModule evaluatingWithArguments: [:x :y| (self !! x) * (self !! y)]]! !

!DistributiveAlgebra methodsFor: 'accessing' stamp: 'len 7/19/2021 11:55:22'!
null
	"Answer the trivial subalgebra, i.e. the zero object in the category of R-algebras."
	^ self ambient span: #()! !

!DistributiveAlgebra methodsFor: 'accessing' stamp: 'len 7/19/2021 06:02:23'!
rank
	^ self asModule rank! !

!DistributiveAlgebra methodsFor: 'accessing' stamp: 'len 7/19/2021 06:02:28'!
scalars
	^ self asModule scalars! !

!DistributiveAlgebra methodsFor: 'accessing' stamp: 'len 7/19/2021 06:02:33'!
size
	^ self asModule size! !

!DistributiveAlgebra methodsFor: 'accessing' stamp: 'len 7/19/2021 06:05:21'!
zero
	^ self !! self asModule zero! !

!DistributiveAlgebra methodsFor: 'comparing' stamp: 'len 7/19/2021 05:58:05'!
< anAlgebra
	"Answer true if the receiver is strictly included in the argument."
	^ self asModule < anAlgebra asModule! !

!DistributiveAlgebra methodsFor: 'comparing' stamp: 'len 7/19/2021 05:58:10'!
<= anAlgebra
	"Answer true if the receiver is included in the argument."
	^ self asModule <= anAlgebra asModule! !

!DistributiveAlgebra methodsFor: 'comparing' stamp: 'len 7/19/2021 05:58:27'!
= anObject
	^ (anObject isKindOf: DistributiveAlgebra) and: [self ambient asModule = anObject ambient asModule and: [self asModule = anObject asModule]]! !

!DistributiveAlgebra methodsFor: 'converting' stamp: 'len 7/19/2021 05:59:06'!
asModule
	^ self propertyAt: #asModule! !

!DistributiveAlgebra methodsFor: 'elements' stamp: 'len 7/19/2021 05:59:01'!
adapt: anElement
	self isAmbient ifFalse: [^ super adapt: anElement].
	(self asModule includes: anElement) ifTrue: [^ self fromModuleElement: anElement].
	^ super adapt: anElement! !

!DistributiveAlgebra methodsFor: 'elements' stamp: 'len 7/19/2021 05:59:53'!
elementAt: anArray
	"Answer the element with the given coordinates."
	^ self fromModuleElement: (self asModule elementAt: anArray)! !

!DistributiveAlgebra methodsFor: 'elements' stamp: 'len 7/19/2021 06:00:06'!
fromModuleElement: anElement
	^ DistributiveAlgebraElement parent: self moduleElement: anElement! !

!DistributiveAlgebra methodsFor: 'elements' stamp: 'len 7/19/2021 06:01:59'!
newFrom: anObject
	(anObject isSequenceable and: [anObject size = self rank])
		ifTrue: [^ self elementAt: anObject].
	^ super newFrom: anObject! !

!DistributiveAlgebra methodsFor: 'enumerating' stamp: 'len 7/19/2021 05:59:48'!
do: aBlock
	self asModule do: [:each| aBlock value: self !! each]! !

!DistributiveAlgebra methodsFor: 'morphisms' stamp: 'len 7/19/2021 06:00:26'!
id
	"Answer the identity morphism."
	^ self propertyAt: #id ifAbsentPut: [self to: self moduleMap: self asModule id]! !

!DistributiveAlgebra methodsFor: 'morphisms' stamp: 'len 12/22/2021 14:55:08'!
to: aCodomain
	(aCodomain isDistributiveAlgebra and: [self isTrivial or: [aCodomain isTrivial]])
		ifTrue: [^ self to: aCodomain evaluating: [:x| aCodomain zero]].
	^ super to: aCodomain! !

!DistributiveAlgebra methodsFor: 'morphisms' stamp: 'len 7/19/2021 06:04:54'!
to: anAlgebra evaluating: aBlock
	((anAlgebra isKindOf: DistributiveAlgebra) and: [anAlgebra scalars = self scalars]) ifFalse: [^ super to: anAlgebra mapping: aBlock].
	^ self to: anAlgebra moduleMap: (self asModule to: anAlgebra asModule evaluating: [:x| (aBlock value: self !! x) asModuleElement])! !

!DistributiveAlgebra methodsFor: 'morphisms' stamp: 'len 7/19/2021 06:04:34'!
to: anAlgebra mapping: aBlock
	"Answer a morphism defined by images of generators.
	aBlock takes indices i and evaluates to the image of the i-th generator."
	((anAlgebra isKindOf: DistributiveAlgebra) and: [anAlgebra scalars = self scalars]) ifFalse: [^ super to: anAlgebra mapping: aBlock].
	^ self to: anAlgebra moduleMap: (self asModule to: anAlgebra asModule mapping: [:i| (aBlock value: i) asModuleElement])! !

!DistributiveAlgebra methodsFor: 'morphisms' stamp: 'len 7/19/2021 06:05:15'!
to: anAlgebra moduleMap: aModuleMap
	((anAlgebra isKindOf: DistributiveAlgebra) and: [self scalars = anAlgebra scalars]) ifFalse: [^ DomainError signal].
	^ DistributiveAlgebraMap from: self to: anAlgebra moduleMap: aModuleMap! !

!DistributiveAlgebra methodsFor: 'operations' stamp: 'len 7/19/2021 05:57:41'!
/\ aSubalgebra
	"Answer the intersection of the receiver and the argument."
	((aSubalgebra isKindOf: DistributiveAlgebra) and: [self ambient = aSubalgebra ambient])
		ifFalse: [^ super /\ aSubalgebra].
	^ self ambient span: self asModule /\ aSubalgebra asModule! !

!DistributiveAlgebra methodsFor: 'operations' stamp: 'len 7/19/2021 05:58:34'!
 anAlgebra
	"Answer the direct product of the receiver with the argument."
	((anAlgebra isKindOf: Algebra) and: [self scalars = anAlgebra scalars]) ifTrue: [^ self  anAlgebra].
	^ super  anAlgebra! !

!DistributiveAlgebra methodsFor: 'operations' stamp: 'len 12/23/2021 15:41:02'!
 anAlgebra
	"Answer the direct sum of the receiver with the argument."
	| answer coprojections projections |
	((anAlgebra isKindOf: Algebra) and: [self scalars = anAlgebra scalars]) ifFalse: [^ super  anAlgebra].
	answer _ self species multiplication: self multiplication  anAlgebra multiplication.
	projections _ answer asModule -< {self asModule. anAlgebra asModule}.
	coprojections _ {self asModule. anAlgebra asModule} >- answer asModule.
	answer
		addProjections: (projections with: {self. anAlgebra} collect: [: :codomain| answer => codomain !! ]);
		addCoprojections: (coprojections with: {self. anAlgebra} collect: [:i :domain| domain => answer !! i]).
	^ answer! !

!DistributiveAlgebra methodsFor: 'operations' stamp: 'len 12/20/2021 13:05:00'!
opposite
	^ self propertyAt: #opposite ifAbsentPut: [(self species multiplication: (BilinearMap on: self asModule evaluatingWithArguments: [:x :y| self multiplication value: y value: x])) propertyAt: #opposite put: self; yourself]! !

!DistributiveAlgebra methodsFor: 'operations' stamp: 'len 7/19/2021 06:02:50'!
span: aCollection
	"Answer the subalgebra spanned by the elements in aCollection."
	self isAmbient ifFalse: [^ self ambient span: aCollection].
	((aCollection isKindOf: Module) and: [aCollection ambient = self asModule])
		ifTrue: [^ self species new ambient: self; module: aCollection].
	^ self species new ambient: self; module: (self asModule span: (aCollection collect: [:each| each asModuleElement]))! !

!DistributiveAlgebra methodsFor: 'random' stamp: 'len 7/19/2021 05:59:10'!
atRandom: aRandom
	^ self !! (self asModule atRandom: aRandom)! !

!DistributiveAlgebra methodsFor: 'random' stamp: 'len 7/19/2021 05:59:15'!
atRandom: aRandom bits: bitSize
	^ self !! (self asModule atRandom: aRandom bits: bitSize)! !

!DistributiveAlgebra methodsFor: 'testing' stamp: 'len 7/19/2021 05:59:36'!
contains: anElement
	self isAmbient ifTrue: [^ true].
	^ self asModule contains: anElement asModuleElement! !

!DistributiveAlgebra methodsFor: 'testing' stamp: 'len 7/19/2021 06:00:35'!
includes: anObject
	self isAmbient ifTrue: [^ anObject parent = self].
	^ (self ambient includes: anObject) and: [self contains: anObject]! !

!DistributiveAlgebra methodsFor: 'testing' stamp: 'len 12/15/2021 19:42:49'!
isAssociative
	^ self notYetImplemented! !

!DistributiveAlgebra methodsFor: 'testing' stamp: 'len 7/18/2021 13:14:30'!
isLieAlgebra
	"Answer true if the receiver satisfies the axioms of a Lie algebra."
	self basis do: [:x|
		(x*x) isZero ifFalse: [^ false].
		self basis do: [:y|
			| xy |
			xy _ x*y.
			(xy + (y*x)) isZero ifFalse: [^ false].
			self basis do: [:z|
				"Jacobi identity:"
				(x*(y*z) + (y*(z*x)) + (z*xy)) isZero ifFalse: [^ false]]]].
	^ true! !

!DistributiveAlgebra methodsFor: 'testing' stamp: 'len 7/19/2021 06:01:07'!
isTrivial
	^ self asModule isTrivial! !

!DistributiveAlgebra methodsFor: 'private' stamp: 'len 7/19/2021 06:01:40'!
module: aModule
	self propertyAt: #asModule put: aModule! !

!DistributiveAlgebra methodsFor: 'private' stamp: 'len 7/22/2021 18:47:50'!
multiplication: aBilinearMap
	| V |
	V _ aBilinearMap domain at: 1.
	self propertyAt: #asModule put: V.
	self propertyAt: #multiplication put: aBilinearMap.
	self addCoercionTo: V evaluating: [:each| each asModuleElement]! !

!DistributiveAlgebra methodsFor: 'private' stamp: 'len 7/19/2021 06:03:01'!
species
	^ DistributiveAlgebra! !

!DistributiveAlgebra class methodsFor: 'instance creation' stamp: 'len 7/19/2021 06:09:11'!
multiplication: aBilinearMap
	^ self new multiplication: aBilinearMap! !

!DistributiveAlgebra class methodsFor: 'instance creation' stamp: 'len 7/19/2021 06:09:06'!
over: aRing table: anArray
	^ self multiplication: (BilinearMap on: aRing^anArray size table: anArray)! !

!LieAlgebra methodsFor: 'as yet unclassified' stamp: 'len 7/14/2021 16:53:29'!
center
	| rows |
	rows _ OrderedCollection new: self rank squared.
	self basis do: [:each| rows addAll: each representation rows].
	^ self span: (Matrix rows: rows) kernel generators! !

!LieAlgebra methodsFor: 'as yet unclassified' stamp: 'len 7/15/2020 07:01:51'!
isUnital
	"Lie algebras are never unital."
	^ false! !

!OctonionAlgebra methodsFor: 'as yet unclassified' stamp: 'len 4/30/2021 12:36:17'!
fromModuleElement: anElement
	^ Octonion parent: self moduleElement: anElement! !

!OctonionAlgebra methodsFor: 'as yet unclassified' stamp: 'len 4/30/2021 12:07:45'!
isCommutative
	^ false! !

!OctonionAlgebra methodsFor: 'as yet unclassified' stamp: 'len 4/30/2021 12:07:28'!
isUnital
	^ true! !

!OctonionAlgebra methodsFor: 'as yet unclassified' stamp: 'len 4/30/2021 12:07:56'!
one
	^ self basis first! !

!OctonionAlgebra class methodsFor: 'as yet unclassified' stamp: 'len 4/30/2021 12:35:47'!
over: aField
	| V  |
	V _ aField^8.
	 _ {#(2 3) -> 4. #(2 5) -> 6.  #(2 8) -> 7. #(3 5) -> 7. #(4 5) -> 8. #(4 7) -> 6} asDictionary.
	^ super multiplication: (BilinearMap on: V mapping: [:i :j|
		i=1 ifTrue: [V x: j] ifFalse:
			[j=1 ifTrue: [V x: i] ifFalse:
				[i=j ifTrue: [(V x: 1) negated] ifFalse: [V x: ( at: {i. j})]]]])! !

!Scheme methodsFor: 'accessing' stamp: 'len 12/22/2021 14:17:49'!
@ aPoint
	"Answer the local ring corresponding to the stalk of the structure sheaf at aPoint."
	^ aPoint localRing! !

!Scheme methodsFor: 'accessing' stamp: 'len 3/15/2021 10:08:44'!
base
	"Answer the base scheme of the receiver."
	^  spec! !

!Scheme methodsFor: 'accessing' stamp: 'len 10/4/2016 09:19'!
codimension
	^ self ambient dimension - self dimension! !

!Scheme methodsFor: 'accessing' stamp: 'len 12/13/2021 17:17:22'!
dimension
	"Answer the dimension of the highest dimensional component of the receiver."
	^ self decomposition max: [:each| each dimension]! !

!Scheme methodsFor: 'accessing' stamp: 'len 12/21/2021 20:05:04'!
functionField
	"Answer the function field (or field of rational functions) of the receiver.
	If the receiver is integral, this is the local ring at the generic point, or equivalently the function field of any nonempty affine open subscheme."
	^ self patches anyOne functionField! !

!Scheme methodsFor: 'accessing' stamp: 'len 1/12/2017 20:38:56'!
genus
	"Answer the geometric genus of the receiver."
	^ self subclassResponsibility! !

!Scheme methodsFor: 'accessing' stamp: 'len 12/15/2021 12:49:15'!
patches
	"Answer an affine cover of the receiver."
	^ self propertyAt: #patches! !

!Scheme methodsFor: 'morphisms' stamp: 'len 12/22/2021 15:07:24'!
from: aDomain
	aDomain ~~ self ifTrue: [self patches do: [:each| each == aDomain ifTrue: [^ self addMap: ((aDomain to: self evaluating: [:x| SchemePoint new parent: self; patch: aDomain; patchPoint: x]) name: 'i')]]].
	^ super from: aDomain! !

!Scheme methodsFor: 'operations' stamp: 'len 3/13/2020 09:43:58'!
apply: aMorphism
	"Answer the homomorphic image of the receiver."
	"This is the image of aMorphism applied to the receiver, assuming the receiver is a subscheme of the domain of aMorphism."
	^ (self -> aMorphism) image! !

!Scheme methodsFor: 'operations' stamp: 'len 7/31/2021 15:44:44'!
subscheme: anObject
	"Answer the subscheme defined by anObject, as subscheme of the ambient space.
	This makes sense, for example, for closed subschemes of affine or projective space, and anObject can be an element or an ideal of the coordinate ring."
	self isAmbient ifTrue: [^ self subclassResponsibility].
	^ self /\ (self ambient subscheme: anObject)! !

!Scheme methodsFor: 'testing' stamp: 'len 12/21/2021 21:02:33'!
includes: aPoint
	^ (aPoint isKindOf: SchemePoint) and: [aPoint parent = self]! !

!Scheme methodsFor: 'testing' stamp: 'len 12/17/2021 11:56:22'!
isAffine
	^ self notYetImplemented! !

!Scheme methodsFor: 'testing' stamp: 'len 3/15/2021 13:49:38'!
isConnected
	"A scheme is called 'connected' if its underlying topological space is connected, i.e. it is not empty and the only subsets that are both open and closed and only itself and the empty set.
	A connected scheme is also irreducible, but not the other way around.
	Examples:
		Spec(K[x]/<x^2>) is irreducible but not reduced;
		Spec(K[x,y]/<x,y>) is reducible and reduced;
		Spec(K[x]/<x^2 - x>) is not connected and it is reduced."
	^ self subclassResponsibility! !

!Scheme methodsFor: 'testing' stamp: 'len 12/30/2016 15:06:11'!
isCurve
	^ self dimension = 1! !

!Scheme methodsFor: 'testing' stamp: 'len 12/20/2021 18:11:06'!
isEmpty
	^ self patches allSatisfy: [:each| each isEmpty]! !

!Scheme methodsFor: 'testing' stamp: 'len 10/13/2016 19:22'!
isHypersurface
	^ self codimension = 1! !

!Scheme methodsFor: 'testing' stamp: 'len 3/15/2021 13:38:07'!
isIntegral
	"A scheme is called 'integral' if it is reduced and irreducible."
	^ self isReduced and: [self isIrreducible]! !

!Scheme methodsFor: 'testing' stamp: 'len 3/15/2021 13:48:58'!
isIrreducible
	"A scheme is called 'irreducible' if its underlying topological space is irreducible, i.e. it is not empty and it is not the union of two proper closed subsets.
	Examples:
		Spec(K[x]/<x^2>) is irreducible but not reduced;
		Spec(K[x,y]/<x,y>) is reducible and reduced;
		Spec(K[x]/<x^2 - x>) is not connected and it is reduced."
	^ self subclassResponsibility! !

!Scheme methodsFor: 'testing' stamp: 'len 12/15/2021 19:33:20'!
isNoetherian
	^ self patches allSatisfy: [:each| each isNoetherian]! !

!Scheme methodsFor: 'testing' stamp: 'len 10/12/2016 19:32'!
isPlanar
	^ self ambient dimension = 2! !

!Scheme methodsFor: 'testing' stamp: 'len 1/13/2017 16:30:59'!
isProjective
	^ false! !

!Scheme methodsFor: 'testing' stamp: 'len 12/15/2021 19:29:06'!
isReduced
	"A scheme is called 'reduced' if all its stalks are reduced (i.e., their nilradicals are 0).
	This is a local property, i.e. the following are equivalent:
	1) S is reduced;
	2) The stalk at P is reduced for all P;
	3) Every open affine subscheme of S is reduced;
	4) S has a cover by reduced open affine subschemes.
	Examples:
		Spec(K[x]/<x^2>) is irreducible but not reduced;
		Spec(K[x,y]/<x,y>) is reducible and reduced;
		Spec(K[x]/<x^2 - x>) is not connected and it is reduced."
	^ self patches allSatisfy: [:each| each isReduced]! !

!Scheme methodsFor: 'testing' stamp: 'len 12/20/2021 18:20:01'!
isSingular
	"Answer true if the receiver has a singular point or fails to be equidimensional over an algebraic closure of its base field."
	^ self isSmooth not! !

!Scheme methodsFor: 'testing' stamp: 'len 12/15/2021 19:31:12'!
isSmooth
	"Answer true if the receiver is nonsingular."
	^ self patches allSatisfy: [:each| each isSmooth]! !

!Scheme methodsFor: 'testing' stamp: 'len 1/9/2017 16:28:50'!
isSurface
	^ self dimension = 2! !

!Scheme methodsFor: 'private' stamp: 'len 12/13/2021 17:20:19'!
species
	^ Scheme! !

!Grassmannian methodsFor: 'accessing' stamp: 'len 9/16/2018 16:13:19'!
dimension
	^ rank * (space rank - rank)! !

!Grassmannian methodsFor: 'accessing' stamp: 'len 4/21/2016 16:58'!
rank
	^ rank! !

!Grassmannian methodsFor: 'accessing' stamp: 'len 3/14/2020 17:32:50'!
size
	space isFinite ifFalse: [^ space size].
	^ space rank choose: rank q: space scalars size! !

!Grassmannian methodsFor: 'accessing' stamp: 'len 4/20/2016 23:55'!
space
	^ space! !

!Grassmannian methodsFor: 'comparing' stamp: 'len 4/20/2016 23:55'!
= aGrassmannian
	^ (aGrassmannian isKindOf: Grassmannian) and: [aGrassmannian space = self space]! !

!Grassmannian methodsFor: 'morphisms' stamp: 'len 3/14/2020 17:32:30'!
dual
	^ space dual grassmannian: space rank - rank! !

!Grassmannian methodsFor: 'morphisms' stamp: 'len 6/28/2016 23:34'!
pluckerEmbedding
	"Answer the Plucker embedding, a natural embedding of the Grassmannian into a projective space."
	^ self notYetImplemented "need to implement the wedge product"! !

!Grassmannian methodsFor: 'random' stamp: 'len 5/4/2019 08:59:09'!
atRandom: aRandom bits: bits
	| S n |
	S _ space null.
	[S rank < rank]
		whileTrue:
			[| v |
			n _ bits / rank.
			[v _ space atRandom: aRandom bits: n.
			S contains: v] whileTrue: [n _ n * 1.5]. "increase bits until we find a new vector"
			S _ S + (space span: {v})].
	^ S! !

!Grassmannian methodsFor: 'testing' stamp: 'len 5/7/2018 17:55:47'!
contains: aSubspace
	^ space >= aSubspace and: [aSubspace rank = rank]! !

!Grassmannian methodsFor: 'testing' stamp: 'len 4/1/2021 10:16:57'!
includes: anObject
	^ (anObject isKindOf: Module) and: [anObject ambient = space ambient and: [self contains: anObject]]! !

!Grassmannian methodsFor: 'private' stamp: 'len 4/21/2016 16:59'!
rank: anInteger
	rank _ anInteger! !

!Grassmannian methodsFor: 'private' stamp: 'len 4/20/2016 23:56'!
space: aVectorSpace
	space _ aVectorSpace! !

!Grassmannian class methodsFor: 'instance creation' stamp: 'len 4/21/2016 17:01'!
new: anInteger over: aSpace
	^ self new space: aSpace; rank: anInteger! !

!AffineScheme methodsFor: 'accessing' stamp: 'len 12/22/2021 14:17:19'!
@ aPoint
	"Answer the local ring corresponding to the stalk of the structure sheaf at aPoint.
	For Spec(R) aPoint is a prime ideal of R."
	^ self coordinateRing @ aPoint! !

!AffineScheme methodsFor: 'accessing' stamp: 'len 4/12/2021 14:54:46'!
ambient
	^ self propertyAt: #ambient ifAbsent: [self coordinateRing isQuotient ifTrue: [self coordinateRing base spec] ifFalse: [self]]! !

!AffineScheme methodsFor: 'accessing' stamp: 'len 7/9/2019 08:17:49'!
base
	"Answer the base scheme of the receiver."
	^ self scalars spec! !

!AffineScheme methodsFor: 'accessing' stamp: 'len 1/13/2017 16:59:19'!
coordinateRing
	"Answer the affine coordinate ring."
	^ self propertyAt: #coordinateRing! !

!AffineScheme methodsFor: 'accessing' stamp: 'len 1/13/2017 16:01:28'!
dimension
	"Answer the dimension of the highest dimensional component of the receiver.
	This is the Krull dimension of the coordinate ring."
	^ self coordinateRing dimension! !

!AffineScheme methodsFor: 'accessing' stamp: 'len 1/2/2022 10:11:15'!
functionField
	"Answer the function field (or field of rational functions) of the receiver. This is the fractions field of the coordinate ring and it's noted K(V) (analogous to the coordinate ring noted K[V]).
	This assumes the receiver is reduced. The definition of function field can be extended to the case of nonreduced schemes as Frac(R/N) where N is the nilradical of R."
	^ self coordinateRing fractions! !

!AffineScheme methodsFor: 'accessing' stamp: 'len 12/20/2021 18:16:30'!
genericPoint
	"If the receiver is an integral scheme, answer the generic point."
	self isIntegral ifTrue: [^ self coordinateRing * 0].
	^ self error: 'not integral scheme'! !

!AffineScheme methodsFor: 'accessing' stamp: 'len 12/15/2021 12:49:42'!
patches
	"Answer an affine cover of the receiver."
	^ {self}! !

!AffineScheme methodsFor: 'accessing' stamp: 'len 7/9/2019 08:18:31'!
scalars
	^ self coordinateRing scalars! !

!AffineScheme methodsFor: 'comparing' stamp: 'len 12/15/2021 11:57:12'!
< aScheme
	^ self asIdeal > aScheme asIdeal! !

!AffineScheme methodsFor: 'comparing' stamp: 'len 12/15/2021 11:57:22'!
<= aScheme
	^ self asIdeal >= aScheme asIdeal! !

!AffineScheme methodsFor: 'comparing' stamp: 'len 1/13/2017 16:32:32'!
= anObject
	^ (anObject isKindOf: self species) and: [self coordinateRing = anObject coordinateRing]! !

!AffineScheme methodsFor: 'comparing' stamp: 'len 1/13/2017 16:32:38'!
hash
	^ self coordinateRing hash! !

!AffineScheme methodsFor: 'converting' stamp: 'len 12/20/2021 12:30:19'!
asIdeal
	"Answer the defining ideal of the receiver. This is an ideal of the ambient coordinate ring."
	^ self coordinateRing isQuotient ifTrue: [self coordinateRing relations] ifFalse: [self coordinateRing asIdeal null]! !

!AffineScheme methodsFor: 'converting' stamp: 'len 5/2/2021 11:58:21'!
asRing
	^ self coordinateRing! !

!AffineScheme methodsFor: 'converting' stamp: 'len 1/13/2017 16:10:18'!
over: aRing
	^ self class coordinateRing: (self coordinateRing over: aRing)! !

!AffineScheme methodsFor: 'enumerating' stamp: 'len 5/4/2018 19:34:21'!
do: aBlock
	self coordinateRing primeIdealsDo: aBlock! !

!AffineScheme methodsFor: 'morphisms' stamp: 'len 12/22/2021 14:52:18'!
from: aCodomain
	(aCodomain isKindOf: AffineScheme) ifTrue:
		[self coordinateRing -> aCodomain coordinateRing ifNotNil: [:aMorphism| aMorphism spec]].
	^ super from: aCodomain! !

!AffineScheme methodsFor: 'morphisms' stamp: 'len 3/4/2021 18:03:57'!
fromAll: anArray
	(anArray allSatisfy: [:each| each isKindOf: AffineScheme]) ifTrue:
		[(self coordinateRing -< (anArray collect: [:each| each coordinateRing])) ifNotNil: [:anArrayOfMorphisms| ^ anArrayOfMorphisms collect: [:each| each spec]]].
	^ super fromAll: anArray! !

!AffineScheme methodsFor: 'morphisms' stamp: 'len 12/22/2021 14:51:31'!
to: aCodomain
	(aCodomain isKindOf: AffineScheme) ifTrue:
		[aCodomain coordinateRing -> self coordinateRing ifNotNil: [:aMorphism| aMorphism spec]].
	^ super to: aCodomain! !

!AffineScheme methodsFor: 'morphisms' stamp: 'len 3/4/2021 18:07:09'!
toAll: anArray
	(anArray allSatisfy: [:each| each isKindOf: AffineScheme]) ifTrue:
		[((anArray collect: [:each| each coordinateRing]) >- self coordinateRing) ifNotNil: [:anArrayOfMorphisms| ^ anArrayOfMorphisms collect: [:each| each spec]]].
	^ super toAll: anArray! !

!AffineScheme methodsFor: 'operations' stamp: 'len 12/15/2021 11:57:02'!
/\ aScheme
	"Answer the intersection of the receiver and the argument."
	self ambient = aScheme ambient ifFalse: [^ DomainError signal: 'ambients don''t match'].
	^ self ambient subscheme: self asIdeal + aScheme asIdeal! !

!AffineScheme methodsFor: 'operations' stamp: 'len 12/15/2021 11:57:31'!
\/ aScheme
	"Answer the union of the receiver and the argument."
	self ambient = aScheme ambient ifFalse: [^ DomainError signal: 'ambients don''t match'].
	^ self ambient subscheme: self asIdeal /\ aScheme asIdeal

"alternatively:
	^ self class on: self ambient ideal: ideal * aScheme ideal
although the intersection is harder to compute, it behaves better with radicalization, because the intersection of two radical ideals is radical and we don't need to compute radicals again"! !

!AffineScheme methodsFor: 'operations' stamp: 'len 12/15/2021 11:57:37'!
decomposition
	"Answer the irreducible components of the receiver."
	^ self asIdeal associatedPrimes collect: [:each| self subscheme: each]! !

!AffineScheme methodsFor: 'operations' stamp: 'len 12/17/2021 12:08:58'!
reduced
	"Answer the reduced subscheme of the receiver."
	^ self propertyAt: #reducedSubscheme ifAbsentPut: [self ambient subscheme: self asIdeal radical]! !

!AffineScheme methodsFor: 'operations' stamp: 'len 8/1/2021 10:49:51'!
subscheme: anObject
	| I |
	I _ (anObject isKindOf: Ideal) ifTrue: [anObject] ifFalse: [self coordinateRing * anObject].
	^ (self coordinateRing / I) spec! !

!AffineScheme methodsFor: 'testing' stamp: 'len 1/13/2017 20:20:05'!
contains: anIdeal
	"Answer true if the receiver contains the given point (a prime ideal of its coordinate ring)."
	^ true! !

!AffineScheme methodsFor: 'testing' stamp: 'len 1/15/2018 18:45:05'!
includes: anObject
	^ (anObject isKindOf: Ideal) and: [anObject scalars = self coordinateRing and: [anObject isPrime]]! !

!AffineScheme methodsFor: 'testing' stamp: 'len 1/13/2017 16:02:42'!
isAffine
	^ true! !

!AffineScheme methodsFor: 'testing' stamp: 'len 3/15/2021 14:01:49'!
isConnected
	"A scheme is called 'connected' if its underlying topological space is connected, i.e. it is not empty and the only subsets that are both open and closed and only itself and the empty set.
	A connected scheme is also irreducible, but not the other way around.
	An affine scheme Spec(R) is connected iff R is nontrivial and has no idempotents (elements with x^2 = x) other than 0 and 1."
	^ self subclassResponsibility! !

!AffineScheme methodsFor: 'testing' stamp: 'len 12/20/2021 18:12:27'!
isEmpty
	^ self coordinateRing isTrivial! !

!AffineScheme methodsFor: 'testing' stamp: 'len 3/15/2021 14:05:54'!
isIntegral
	"A scheme is called 'integral' if it is reduced and irreducible.
	An affine scheme Spec(R) is integral iff R is an integral domain."
	^ self coordinateRing isIntegralDomain! !

!AffineScheme methodsFor: 'testing' stamp: 'len 3/15/2021 14:15:13'!
isIrreducible
	"A scheme is called 'irreducible' if its underlying topological space is irreducible, i.e. it is not empty and it is not the union of two proper closed subsets."
	self isIntegral ifTrue: [^ true].
	"If the R has nilpotents, Spec(R) might not be irreducible even if R is an integral domain."
	^ super isIrreducible! !

!AffineScheme methodsFor: 'testing' stamp: 'len 1/13/2017 16:57:08'!
isNoetherian
	^ self coordinateRing isNoetherian! !

!AffineScheme methodsFor: 'testing' stamp: 'len 3/15/2021 13:38:32'!
isReduced
	"A scheme is called 'reduced' if all its stalks are reduced (i.e., their nilradicals are 0)."
	^ self coordinateRing isReduced! !

!AffineScheme methodsFor: 'private' stamp: 'len 5/26/2020 10:37:19'!
coordinateRing: aRing
	self propertyAt: #coordinateRing put: aRing! !

!AffineScheme methodsFor: 'private' stamp: 'len 2/13/2017 07:44:36'!
species
	^ AffineScheme! !

!AffineScheme class methodsFor: 'examples' stamp: 'len 5/23/2020 08:55:54'!
example1
	"Spec(Z), the prime spectrum of the rational integers.
	This is the initial object in the category of schemes."	
	^  spec! !

!AffineScheme class methodsFor: 'examples' stamp: 'len 5/23/2020 08:55:57'!
example2
	"Spec(Z/6Z), the prime spectrum of the residue class ring
	of integers modulo 6, as a set it is the set of prime
	ideals of Z/6Z:"
	^ (/6) spec asSet! !

!AffineScheme class methodsFor: 'instance creation' stamp: 'len 5/26/2020 10:37:07'!
coordinateRing: aRing
	^ self new coordinateRing: aRing! !

!AffineVariety methodsFor: 'accessing' stamp: 'len 12/15/2021 11:56:02'!
asIdeal
	"Answer the defining ideal of the receiver."
	^ self coordinateRing relations! !

!AffineVariety methodsFor: 'comparing' stamp: 'len 12/15/2021 11:58:11'!
= anObject
	^ (anObject isKindOf: AffineVariety) and: [self asIdeal = anObject asIdeal]! !

!AffineVariety methodsFor: 'comparing' stamp: 'len 12/15/2021 11:58:32'!
hash
	^ self asIdeal hash! !

!AffineVariety methodsFor: 'converting' stamp: 'len 2/22/2017 07:52:56'!
asCurve
	^ self ambient isPlane
		ifTrue: [self as: AffinePlaneCurve]
		ifFalse: [self as: AffineCurve]! !

!AffineVariety methodsFor: 'converting' stamp: 'len 2/22/2017 07:53:40'!
asHypersurface
	^ self ambient isPlane
		ifTrue: [self as: AffinePlaneCurve]
		ifFalse: [self as: AffineHypersurface]! !

!AffineVariety methodsFor: 'elements' stamp: 'len 12/13/2021 17:18:10'!
!! anObject
	anObject isTuple ifTrue: [^ self pointAt: anObject].
	(anObject isKindOf: RationalPoint) ifTrue: [^ self pointAt: anObject coordinates].
	^ super !! anObject! !

!AffineVariety methodsFor: 'morphisms' stamp: 'len 1/14/2022 10:58:32'!
projectiveEmbedding
	"Answer the map that sends the receiver to its projective closure.
	If the receiver was originally constructed as an affine patch of a projective scheme, answer the map to the original projective scheme. Otherwise, the projective closure will be constructed as a projective scheme over the projective closure of the ambient space of the receiver, and the receiver will be its last affine patch."
	| I P map patches |
	self propertyAt: #projectiveEmbedding ifPresent: [:aRationalMap| ^ aRationalMap].
	I _ self asIdeal homogenized.
	P _ (I scalars / I) proj.
	map _ RationalMap from: self to: P evaluating: [:x| x homogenizedAt: P ambient rank].
	patches _ Array new: P ambient rank.
	patches at: patches size put: self.
	P propertyAt: #patches put: patches.
	^ self propertyAt: #projectiveEmbedding put: map! !

!AffineVariety methodsFor: 'operations' stamp: 'len 12/15/2021 11:57:51'!
+ aTuple
	"Answer a new affine varieity that is the translation of the receiver by aTuple.
	The origin is mappet to aTuple (any point p on the receiver is mapped to p + aTuple)."
	| dx |
	dx _ self ambient coordinateRing generators - aTuple.
	^ self ambient subscheme: (self asIdeal apply: [:f| f value: dx])! !

!AffineVariety methodsFor: 'operations' stamp: 'len 12/15/2021 11:58:01'!
- aScheme
	"Answer the difference of the receiver with the argument, whose associated ideal is the ideal (colon) quotient of the respective ideals.
	This is the closure of the result of removing from the receiver the points in the intersection with the argument, counted with multiplicity. (See also the 'complement' >>\)."
	aScheme isTuple ifTrue: [^ self + aScheme negated].
	self ambient = aScheme ambient ifFalse: [^ DomainError signal: 'ambients don''t match'].
	^ self ambient subscheme: self asIdeal : aScheme asIdeal! !

!AffineVariety methodsFor: 'operations' stamp: 'len 12/15/2021 11:58:21'!
\ aScheme
	"Answer the (closure of the) complement of the argument in the receiver.
	This is the closure of the result of removing from the receiver *all* points in the intersection with the argument, irrespective of multiplicity. (See also the 'difference' >>-)."
	self ambient = aScheme ambient ifFalse: [^ DomainError signal: 'ambients don''t match'].
	^ self ambient subscheme: (self asIdeal saturation: aScheme asIdeal)! !

!AffineVariety methodsFor: 'operations' stamp: 'len 4/18/2020 22:59:49'!
 anAffineVariety
	"Answer the cartesian product of the receiver and the argument."
	self scalars = anAffineVariety scalars ifFalse: [^ DomainError signal: 'scalars don''t match'].
	(anAffineVariety isKindOf: AffineVariety) ifFalse: [self notYetImplemented].
	^ (self coordinateRing  anAffineVariety coordinateRing) spec! !

!AffineVariety methodsFor: 'operations' stamp: 'len 1/13/2022 10:30:44'!
multiplicityAt: aTuple
	"Answer the multiplicity at the given point."
	^ ((self - aTuple) asIdeal orderedBy: #lglex) basis max: [:each| each order]! !

!AffineVariety methodsFor: 'operations' stamp: 'len 12/15/2021 11:59:01'!
primaryComponents
	"Answer the irredundant primary components of the receiver."
	^ self asIdeal primaryComponents collect: [:each| self subscheme: each]! !

!AffineVariety methodsFor: 'operations' stamp: 'len 12/15/2021 11:59:07'!
primeComponents
	"Answer the irredundant prime components of the receiver."
	^ self asIdeal primeComponents collect: [:each| self subscheme: each]! !

!AffineVariety methodsFor: 'operations' stamp: 'len 12/15/2021 11:59:12'!
project: anIndeterminate
	"Answer the projection of the receiver by eliminating the given indeterminate.
	This is the intersection of the receiver with a linear subspace {xi = 0}."
	^ self ambient subscheme: (self asIdeal eliminate: anIndeterminate)! !

!AffineVariety methodsFor: 'operations' stamp: 'len 10/31/2016 13:15'!
projectiveClosure
	"Answer the projective closure of the receiver. If the receiver is an affine patch of a projective scheme, answer the original projective scheme. Otherwise the projective closure will be a projective scheme over the projective closure of the ambient space of the receiver, and the receiver will be the last affine patch."
	^ self projectiveEmbedding codomain! !

!AffineVariety methodsFor: 'operations' stamp: 'len 2/4/2017 09:05:48'!
projectivized
	"Answer the projectivization of the receiver."
	^ self coordinateRing proj! !

!AffineVariety methodsFor: 'operations' stamp: 'len 12/15/2021 11:59:40'!
singular
	"Answer the subscheme defined by the appropriately sized minors of the jacobian matrix of the receiver.
	If the receiver is not equidimensional, its lower-dimensional components will be contained in this scheme whether they are singular or not.
	(See Eisenbud 'Commutative Algebra' Ch. 20, re Fitting ideal.)"
	^ self propertyAt: #singularSubscheme ifAbsentPut: [self subscheme: self asIdeal singular]! !

!AffineVariety methodsFor: 'operations' stamp: 'len 1/13/2022 10:30:49'!
tangentConeAt: aTuple
	"Answer the affine tangent cone at the given point."
	| R I |
	R _ self ambient coordinateRing.
	I _ (self - aTuple) asIdeal.
	^ (self ambient subscheme: ((I orderedBy: #lglex) basis collect: [:each| R !! each initialForm])) + aTuple! !

!AffineVariety methodsFor: 'operations' stamp: 'len 12/15/2021 11:59:52'!
tangentSpaceAt: aTuple
	"Answer the affine tangent space at the given point."
	| R I |
	R _ self ambient coordinateRing.
	I _ (self - aTuple) asIdeal.
	^ (self ambient subscheme: (I generators collect: [:f| (1 to: R rank) sum: [:i| (R x: i) * (f derivativeIn: i) independentCoefficient]])) + aTuple! !

!AffineVariety methodsFor: 'points' stamp: 'len 7/4/2019 03:48:14'!
pointAt: aTuple
	^ AffinePoint on: self coordinates: aTuple! !

!AffineVariety methodsFor: 'points' stamp: 'len 12/13/2021 17:11:35'!
points
	"Answer the rational points of the receiver."
	^ self pointsOver: self scalars! !

!AffineVariety methodsFor: 'points' stamp: 'len 12/13/2021 17:15:58'!
pointsCountOver: aRing
	"Naive count of rational points on the receiver."
	| answer |
	answer _ 0.
	self pointsOver: aRing do: [:each| answer _ answer + 1].
	^ answer! !

!AffineVariety methodsFor: 'points' stamp: 'len 12/13/2021 17:14:43'!
pointsOver: aRing
	"Answer the K-rational points on the receiver, where K is aRing."
	^ RationalPointSet from: aRing spec to: self! !

!AffineVariety methodsFor: 'points' stamp: 'len 12/13/2021 17:15:04'!
pointsOver: aRing do: aBlock
	"Naive enumeration of rational points on the receiver."
	self ambient pointsOver: aRing do: [:each| (self satisfies: each coordinates) ifTrue: [aBlock value: (self pointAt: each coordinates)]]! !

!AffineVariety methodsFor: 'testing' stamp: 'len 12/15/2021 11:58:26'!
contains: anIdeal
	"Answer true if the receiver contains the given point (a prime ideal)."
	^ self asIdeal >= anIdeal! !

!AffineVariety methodsFor: 'testing' stamp: 'len 1/9/2017 16:35:09'!
isComplete
	^ self isFinite! !

!AffineVariety methodsFor: 'testing' stamp: 'len 1/24/2017 11:58:07'!
isEquidimensional
	"Answer true if the receiver is pure dimensional or equidimensional, i.e. if the dimension of the local ring at p is independent of p."
	^ self singular dimension < 0! !

!AffineVariety methodsFor: 'testing' stamp: 'len 1/13/2022 10:30:24'!
isFinite
	"This works for any Groebner basis, no matter the ordering."
	"Does this work for non integral schemes?"
	self asIdeal scalars indeterminates do: [:x|
		(self asIdeal basis anySatisfy: [:f| | d m | m _ f leadingMonomial. d _ m degree. d > 0 and: [d = (m degreeIn: x)]])
			ifFalse: [^ false]].
	^ true! !

!AffineVariety methodsFor: 'testing' stamp: 'len 12/15/2021 11:58:52'!
isLinear
	^ self reduced asIdeal generators allSatisfy: [:each| each isLinear]! !

!AffineVariety methodsFor: 'testing' stamp: 'len 12/15/2021 19:30:29'!
isSmooth
	"Answer true if the receiver is nonsingular."
	^ self propertyAt: #isSmooth ifAbsentPut: [self singular dimension < 0]! !

!AffineVariety methodsFor: 'testing' stamp: 'len 12/15/2021 11:59:34'!
satisfies: aTuple
	"Answer true if the defining equations of the receiver satisfy the argument, assuming it's the coordinates of a rational point in the ambient space."
	^ self asIdeal generators allSatisfy: [:each| (each value: aTuple) isZero]! !

!AffineVariety methodsFor: 'private' stamp: 'len 2/13/2017 07:33:08'!
species
	^ AffineVariety! !

!AffineVariety class methodsFor: 'examples' stamp: 'len 5/23/2020 09:11:37'!
circle
	"The unit circle in the rational affine plane:"
	| R x y I |
	R _  polynomialsIn: #(x y).
	x _ R x.
	y _ R y.
	I _ R * (x^2 + (y^2) - 1).
	^ (R / I) spec! !

!AffineVariety class methodsFor: 'examples' stamp: 'len 5/23/2020 09:11:37'!
clebschCubic
	"The Clebsch cubic as affine scheme in Q^3.
	This is the unique cubic surface that has Sym(5) as symmetry group."
	| A x y z f |
	A _ AffineSpace new: #(x y z) over: .
	x _ A coordinateRing x.
	y _ A coordinateRing y.
	z _ A coordinateRing z.
	f _ x^3 + (y^3) + (z^3) * 81
			+ (x^2*y + (x^2*z) + (x*(y^2)) + (x*(z^2)) + (y^2*z) + (y*(z^2)) * -189)
			+ (x*y*z * 54)
			+ (x*y + (x*z) + (y*z) * 126)
			+ (x^2 + (y^2) + (z^2) * -9)
			+ 1.
	^ A subscheme: f! !

!AffineVariety class methodsFor: 'examples' stamp: 'len 5/23/2020 09:11:37'!
romanSurface
	"The Roman surface or Steiner surface.
	This is a self-intersecting mapping of the real projective plane into affine 3-space.
	It was discovered by Jakob Steiner when he was in Rome in 1844."
	| A r |
	A _ AffineSpace new: #(x y z) over: .
	r _ 1.
	^ A subscheme: A coordinateRing !! [:x :y :z| x*y^2 + (y*z^2) + (z*x^2) - (x*y*z*r squared)]! !

!AffineVariety class methodsFor: 'examples' stamp: 'len 5/23/2020 09:11:37'!
twistedCubic
	"This is the twisted cubic affine variety, parameterized by (x, x^2, x^3) in C^3."
	| A x y z |
	A _ AffineSpace new: #(x y z) over:  algebraicClosure.
	x _ A coordinateRing x.
	y _ A coordinateRing y.
	z _ A coordinateRing z.
	^ A subscheme: {y - (x^2). z - (x^3)}! !

!AffineVariety class methodsFor: 'examples' stamp: 'len 5/23/2020 09:11:37'!
whitneyUmbrella
	"This is Whitney's umbrella in affine space Q^3."
	| A |
	A _ AffineSpace new: #(x y z) over: .
	^ A subscheme: A coordinateRing !! [:x :y :z| x^2*y - (z^2)]! !

!AffineVariety class methodsFor: 'instance creation' stamp: 'len 5/26/2020 10:36:23'!
coordinateRing: anAffineRing
	self == AffineVariety ifFalse: [^ super coordinateRing: anAffineRing].
	(anAffineRing relators size = 1 and: [anAffineRing relators anyOne degree > 0]) ifTrue:
		[anAffineRing rank = 2 ifTrue: [^ AffinePlaneCurve coordinateRing: anAffineRing].
		^ AffineHypersurface coordinateRing: anAffineRing].
	^ super coordinateRing: anAffineRing! !

!AffineVariety class methodsFor: 'instance creation' stamp: 'len 2/13/2017 07:33:50'!
newFrom: anObject
	(anObject isKindOf: AffineVariety) ifTrue: [^ self coordinateRing: anObject coordinateRing].
	^ super newFrom: anObject! !

!AffineCurve methodsFor: 'accessing' stamp: 'len 10/24/2016 18:34'!
dimension
	^ 1! !

!AffineHypersurface methodsFor: 'accessing' stamp: 'len 1/8/2017 17:48:10'!
degree
	"The degree of a hypersurface is the total degree of the defining polynomial."
	^ self polynomial degree! !

!AffineHypersurface methodsFor: 'accessing' stamp: 'len 1/8/2017 17:17:24'!
dimension
	^ self ambient dimension - 1! !

!AffineHypersurface methodsFor: 'accessing' stamp: 'len 12/15/2021 11:56:51'!
polynomial
	^ self asIdeal generator! !

!AffineHypersurface methodsFor: 'operations' stamp: 'len 5/20/2018 16:18:41'!
multiplicityAt: aTuple
	self scalars isField ifFalse: [DomainError signal: 'not over a field'].
	^ (self - aTuple) polynomial order! !

!AffineHypersurface class methodsFor: 'instance creation' stamp: 'len 1/23/2017 11:30:29'!
polynomial: aPolynomial
	^ self coordinateRing: aPolynomial parent / aPolynomial! !

!AffinePlaneCurve methodsFor: 'operations' stamp: 'len 5/20/2018 16:19:29'!
tangentsAt: aTuple
	| f r derivatives |
	f _ (self - aTuple) polynomial.
	r _ f order. "multiplicity at the point"
	derivatives _ (0 to: r) collect: [:k| (f derivative: k in: 1) derivative: r-k in: 2].
	^ (self ambient subscheme: ((0 to: r) sum: [:k| (r choose: k) * (derivatives at: k+1) * (f parent x: 1 to: k) * (f parent x: 2 to: r-k)])) + aTuple! !

!AffinePlaneCurve class methodsFor: 'examples' stamp: 'len 5/23/2020 09:11:37'!
descartesFolium
	"This is the 'Descartes folium'."
	^ AffinePlaneCurve polynomial: ( polynomialsIn: #(x y)) !! [:x :y| x^3 + (y^3) - (3*x*y)]! !

!AffinePlaneCurve class methodsFor: 'examples' stamp: 'len 5/23/2020 09:11:37'!
iminus
	^ AffinePlaneCurve polynomial: ( polynomialsIn: #(x y)) !! [:x :y| x^3 + (y^3) - x - (2*y) - 1]! !

!AffineSpace methodsFor: 'accessing' stamp: 'len 8/27/2016 19:03'!
ambient
	^ self! !

!AffineSpace methodsFor: 'accessing' stamp: 'len 12/15/2021 11:55:33'!
asIdeal
	"Answer the defining ideal of the receiver, considered as a subscheme of itself."
	^ self coordinateRing asIdeal null! !

!AffineSpace methodsFor: 'accessing' stamp: 'len 10/20/2016 03:43'!
rank
	"Answer the number of affine coordinates, i.e. the number of indeterminates of the coordinate ring. This can be different from the Krull dimension, for example Spec Z[x] has rank 1 and Krull dimension 2."
	^ self coordinateRing rank! !

!AffineSpace methodsFor: 'morphisms' stamp: 'len 1/14/2022 10:58:14'!
projectiveEmbedding
	| P map patches |
	self propertyAt: #projectiveEmbedding ifPresent: [:aRationalMap| ^ aRationalMap].
	P _ ProjectiveSpace new: self rank over: self scalars.
	map _ RationalMap from: self to: P evaluating: [:x| x homogenizedAt: P rank].
	patches _ Array new: P ambient rank.
	patches at: patches size put: self.
	P propertyAt: #patches put: patches.
	^ self propertyAt: #projectiveEmbedding put: map! !

!AffineSpace methodsFor: 'points' stamp: 'len 5/28/2020 14:53:40'!
origin
	^ self pointAt: (self scalars^self rank) zero! !

!AffineSpace methodsFor: 'points' stamp: 'len 1/22/2017 08:22:56'!
pointsCountOver: aRing
	^ aRing size ^ self rank! !

!AffineSpace methodsFor: 'points' stamp: 'len 5/28/2020 18:03:10'!
pointsOver: aRing do: aBlock
	^ aRing ^ self rank do: [:each| aBlock value: (self pointAt: each)]! !

!AffineSpace methodsFor: 'testing' stamp: 'len 2/22/2017 07:54:37'!
isPlane
	^ self rank = 2! !

!AffineSpace methodsFor: 'testing' stamp: 'len 1/13/2017 17:07:13'!
satisfies: aTuple
	^ true! !

!AffineSpace class methodsFor: 'examples' stamp: 'len 5/23/2020 09:11:37'!
example1
	"The rational affine plane:"
	^ AffineSpace new: 2 over: ! !

!AffineSpace class methodsFor: 'examples' stamp: 'len 5/23/2020 09:11:37'!
example2
	"Or assigning names to the indeterminates of the coordinate ring:"
	^ AffineSpace new: #(x y) over: ! !

!AffineSpace class methodsFor: 'examples' stamp: 'len 5/23/2020 09:11:37'!
example3
	"And equivalently:"
	^ ( polynomialsIn: #(x y)) spec! !

!AffineSpace class methodsFor: 'examples' stamp: 'len 5/23/2020 09:11:37'!
example4
	"Product of affine spaces:"
	^ (AffineSpace new: #(x y z) over: )  (AffineSpace new: #(a b) over: )! !

!AffineSpace class methodsFor: 'instance creation' stamp: 'len 10/28/2016 10:39'!
new: rank over: aRing
	^ self coordinateRing: (aRing polynomialsIn: rank)! !

!ProjectiveScheme methodsFor: 'accessing' stamp: 'len 12/22/2021 14:17:33'!
@ aPoint
	"Answer the local ring corresponding to the stalk of the structure sheaf at aPoint.
	For the Proj(R) aPoint is a relevant homogeneous prime ideal of R,
	which is also a point of the affine cone Spec(R)."
	^ self notYetImplemented! !

!ProjectiveScheme methodsFor: 'accessing' stamp: 'len 12/20/2021 12:29:51'!
ambient
	^ self propertyAt: #ambient ifAbsent: [self coordinateRing isQuotient ifTrue: [self coordinateRing base proj] ifFalse: [self]]! !

!ProjectiveScheme methodsFor: 'accessing' stamp: 'len 12/20/2021 12:47:23'!
base
	"Answer the base scheme of the receiver."
	^ self scalars spec! !

!ProjectiveScheme methodsFor: 'accessing' stamp: 'len 12/20/2021 12:37:10'!
coordinateRing
	"Answer the homogeneous coordinate ring."
	^ self propertyAt: #coordinateRing! !

!ProjectiveScheme methodsFor: 'accessing' stamp: 'len 12/20/2021 12:47:35'!
scalars
	^ self coordinateRing scalars! !

!ProjectiveScheme methodsFor: 'comparing' stamp: 'len 12/20/2021 12:34:17'!
= anObject
	^ (anObject isKindOf: self species) and: [self saturated coordinateRing = anObject saturated coordinateRing]! !

!ProjectiveScheme methodsFor: 'comparing' stamp: 'len 12/20/2021 12:38:27'!
hash
	^ self saturated coordinateRing hash! !

!ProjectiveScheme methodsFor: 'converting' stamp: 'len 12/20/2021 12:30:14'!
asIdeal
	"Answer the defining ideal of the receiver. This is an ideal of the ambient coordinate ring."
	^ self coordinateRing isQuotient ifTrue: [self coordinateRing relations] ifFalse: [self coordinateRing asIdeal null]! !

!ProjectiveScheme methodsFor: 'converting' stamp: 'len 12/20/2021 12:30:44'!
over: aRing
	^ self class coordinateRing: (self coordinateRing over: aRing)! !

!ProjectiveScheme methodsFor: 'enumerating' stamp: 'len 12/20/2021 12:38:03'!
do: aBlock
	self coordinateRing relevantHomogeneousPrimeIdealsDo: aBlock! !

!ProjectiveScheme methodsFor: 'operations' stamp: 'len 12/20/2021 12:33:41'!
/\ aScheme
	"Answer the intersection of the receiver and the argument."
	self ambient = aScheme ambient ifFalse: [^ DomainError signal: 'ambients don''t match'].
	^ self ambient subscheme: self asIdeal + aScheme asIdeal! !

!ProjectiveScheme methodsFor: 'operations' stamp: 'len 12/20/2021 12:34:51'!
\/ aScheme
	"Answer the union of the receiver and the argument."
	self ambient = aScheme ambient ifFalse: [^ DomainError signal: 'ambients don''t match'].
	^ self ambient subscheme: self asIdeal /\ aScheme asIdeal

"alternatively:
	^ self class on: self ambient ideal: ideal * aScheme ideal
although the intersection is harder to compute, it behaves better with radicalization, because the intersection of two radical ideals is radical and we don't need to compute radicals again"! !

!ProjectiveScheme methodsFor: 'operations' stamp: 'len 12/20/2021 12:35:38'!
affineCone
	"If the receiver is defined by an homogeneous ideal I, the affine cone is the affine variety defined by I."
	^ self coordinateRing spec! !

!ProjectiveScheme methodsFor: 'operations' stamp: 'len 12/20/2021 12:40:22'!
reduced
	"Answer the reduced subscheme of the receiver."
	^ self propertyAt: #reducedSubscheme ifAbsentPut: [self ambient subscheme: self asIdeal radical]! !

!ProjectiveScheme methodsFor: 'operations' stamp: 'len 12/20/2021 12:41:21'!
saturated
	"Ensure the defining ideal of the receiver is saturated.
	This is important for some operations with projective schemes because projective schemes are not in correspondence with homogeneous ideals (like affine schemes), but they are in correspondence with saturated homogeneous ideals."
	(self propertyAt: #isSaturated ifAbsent: [false]) ifTrue: [^ self].
	self coordinateRing: self ambient coordinateRing / self asIdeal saturation.
	self propertyAt: #isSaturated put: true! !

!ProjectiveScheme methodsFor: 'testing' stamp: 'len 12/21/2021 21:00:33'!
contains: anIdeal
	"Answer true if the receiver contains the given point (a prime homogeneous relevant ideal of its coordinate ring)."
	^ true! !

!ProjectiveScheme methodsFor: 'testing' stamp: 'len 12/21/2021 20:59:59'!
includes: anObject
	^ (anObject isKindOf: Ideal) and: [anObject scalars = self coordinateRing and: [anObject isHomogeneous and: [anObject isReelevant] and: [anObject isPrime]]]! !

!ProjectiveScheme methodsFor: 'testing' stamp: 'len 12/20/2021 12:39:35'!
isIntegral
	"A scheme is called 'integral' if it is reduced and irreducible."
	^ self coordinateRing isIntegralDomain "is this correct for Proj?"! !

!ProjectiveScheme methodsFor: 'testing' stamp: 'len 12/20/2021 12:39:19'!
isIrreducible
	"A scheme is called 'irreducible' if its underlying topological space is irreducible, i.e. it is not empty and it is not the union of two proper closed subsets."
	self isIntegral ifTrue: [^ true].
	^ super isIrreducible! !

!ProjectiveScheme methodsFor: 'testing' stamp: 'len 12/20/2021 12:39:05'!
isReduced
	"A scheme is called 'reduced' if all its stalks are reduced (i.e., their nilradicals are 0)."
	^ self coordinateRing isReduced! !

!ProjectiveScheme methodsFor: 'private' stamp: 'len 12/20/2021 12:52:14'!
coordinateRing: aGradedRing
	self propertyAt: #coordinateRing put: aGradedRing! !

!ProjectiveScheme methodsFor: 'private' stamp: 'len 12/20/2021 12:32:29'!
species
	^ ProjectiveScheme! !

!ProjectiveScheme class methodsFor: 'instance creation' stamp: 'len 12/20/2021 12:28:12'!
coordinateRing: aGradedRing
	^ self new coordinateRing: aGradedRing! !

!ProjectiveVariety methodsFor: 'accessing' stamp: 'len 1/10/2017 21:15:14'!
arithmeticGenus
	"Answer the arithmetic genus of the receiver."
	self ambient isOrdinaryProjectiveSpace ifFalse: [^ self error: 'not ordinary projective space'].
	self notYetImplemented! !

!ProjectiveVariety methodsFor: 'accessing' stamp: 'len 5/23/2020 09:11:37'!
degree
	| t H |
	t _  polynomials fractions x.
	H _ self coordinateRing hilbertSeriesAt: t.
	^ (1 - t) ^ (H orderAt: 1) negated * H value: 1! !

!ProjectiveVariety methodsFor: 'accessing' stamp: 'len 5/23/2020 09:11:37'!
degree2
	| t H |
	t _  polynomials fractions x.
	H _ self coordinateRing hilbertSeriesAt: t.
	^ (1 - t) ^ self coordinateRing dimension * H value: 1! !

!ProjectiveVariety methodsFor: 'accessing' stamp: 'len 10/20/2016 15:25'!
dimension
	self flag: #fix. "is this right for projective schemes or should use the Hilbert series?"
	^ self coordinateRing dimension - 1! !

!ProjectiveVariety methodsFor: 'accessing' stamp: 'len 12/21/2021 20:04:49'!
functionField
	"If K(X) is the function field of the affine cone, the function field of the projective variety is the subfield of K(X) of homogeneous elements of degree 0 (the grading at degree 0), that is {f/g | f,g in K(X) and g not zero}.
	This is isomorphic to the function field of any affine patch."
	^ (self patch: self ambient rank) functionField! !

!ProjectiveVariety methodsFor: 'accessing' stamp: 'len 1/14/2022 10:59:23'!
patch: i
	"Answer the i-th affine patch of the receiver."
	| patches answer map |
	patches _ self propertyAt: #patches ifAbsentPut: [Array new: self ambient rank].
	(patches at: i) ifNotNil: [:anAffineVariety| ^ anAffineVariety].
	answer _ self newPatch: i.
	map _ RationalMap from: answer to: self evaluating: [:x| x homogenizedAt: i].
	answer propertyAt: #projectiveEmbedding put: map.
	^ patches at: i put: answer! !

!ProjectiveVariety methodsFor: 'accessing' stamp: 'len 1/12/2017 14:44:25'!
patches
	"Answer all the standard affine patches of the receiver."
	^ (1 to: self ambient rank) collect: [:i| self patch: i]! !

!ProjectiveVariety methodsFor: 'converting' stamp: 'len 2/22/2017 07:56:24'!
asCurve
	^ self ambient isPlane
		ifTrue: [self as: ProjectivePlaneCurve]
		ifFalse: [self as: ProjectiveCurve]! !

!ProjectiveVariety methodsFor: 'converting' stamp: 'len 2/22/2017 07:56:46'!
asHypersurface
	^ self ambient isPlane
		ifTrue: [self as: ProjectivePlaneCurve]
		ifFalse: [self as: ProjectiveHypersurface]! !

!ProjectiveVariety methodsFor: 'elements' stamp: 'len 12/13/2021 17:18:27'!
!! anObject
	anObject isTuple ifTrue: [^ self pointAt: anObject].
	(anObject isKindOf: RationalPoint) ifTrue: [^ self pointAt: anObject coordinates].
	^ super !! anObject! !

!ProjectiveVariety methodsFor: 'operations' stamp: 'len 5/14/2019 20:48:10'!
 aProjectiveVariety
	"Answer the cartesian product of the receiver and the argument."
	self scalars = aProjectiveVariety scalars ifFalse: [self error: 'scalars don''t match'].
	(aProjectiveVariety isKindOf: ProjectiveVariety) ifFalse: [self notYetImplemented].
	^ (self coordinateRing  aProjectiveVariety coordinateRing) proj
		propertyAt: #ambient put: self ambient  aProjectiveVariety ambient;
		yourself! !

!ProjectiveVariety methodsFor: 'operations' stamp: 'len 12/15/2021 12:01:06'!
decomposition
	"Answer the irreducible components of the receiver."
	| primes |
	primes _ self asIdeal associatedPrimes.
	"Since the scheme is projective, remove the primes containing the irrelevant ideal:"
	primes _ primes reject: [:each| self ambient coordinateRing generators anySatisfy: [:xi| each includes: xi]].
	^ primes collect: [:each| self subscheme: each]! !

!ProjectiveVariety methodsFor: 'operations' stamp: 'len 2/10/2017 08:23:03'!
dual
	"Answer the projective dual of the receiver."
	self notYetImplemented! !

!ProjectiveVariety methodsFor: 'operations' stamp: 'len 12/15/2021 12:01:37'!
singular
	"Answer the subscheme defined by the appropriately sized minors of the jacobian matrix of the receiver.
	If the receiver is not equidimensional, its lower-dimensional components will be contained in this scheme whether they are singular or not.
	(See Eisenbud 'Commutative Algebra' Ch. 20, re Fitting ideal.)"
	^ self propertyAt: #singularSubscheme ifAbsentPut: [self subscheme: self asIdeal singular]! !

!ProjectiveVariety methodsFor: 'operations' stamp: 'len 12/15/2021 12:01:42'!
tangentSpaceAt: aTuple
	"Answer the projective tangent space of the receiver at the given point."
	| R |
	self flag: #fix. "this might be wrong, The Geometry of Schemes pag 105"
	R _ self ambient coordinateRing.
	^ self ambient subscheme: (self asIdeal generators collect: [:f| (1 to: R rank) sum: [:i| (R x: i) * ((f derivativeIn: i) value: aTuple)]])! !

!ProjectiveVariety methodsFor: 'points' stamp: 'len 7/4/2019 03:48:24'!
pointAt: aTuple
	^ ProjectivePoint on: self coordinates: aTuple! !

!ProjectiveVariety methodsFor: 'points' stamp: 'len 12/13/2021 17:13:11'!
points
	"Answer the rational points of the receiver."
	^ self pointsOver: self scalars! !

!ProjectiveVariety methodsFor: 'points' stamp: 'len 12/13/2021 17:15:48'!
pointsCountOver: aRing
	"Naive count of rational points on the receiver."
	| answer |
	answer _ 0.
	self pointsOver: aRing do: [:each| answer _ answer + 1].
	^ answer! !

!ProjectiveVariety methodsFor: 'points' stamp: 'len 12/13/2021 17:14:32'!
pointsOver: aRing
	"Answer the K-rational points on the receiver, where K is aRing."
	^ RationalPointSet from: aRing spec to: self! !

!ProjectiveVariety methodsFor: 'points' stamp: 'len 12/13/2021 17:15:11'!
pointsOver: aRing do: aBlock
	"Naive enumeration of rational points on the receiver."
	self ambient pointsOver: aRing do: [:each| (self satisfies: each coordinates) ifTrue: [aBlock value: (self pointAt: each coordinates)]]! !

!ProjectiveVariety methodsFor: 'testing' stamp: 'len 1/9/2017 16:34:57'!
isComplete
	^ true! !

!ProjectiveVariety methodsFor: 'testing' stamp: 'len 5/17/2018 16:30:03'!
isEmpty
	"Answer true if the receiver has no points over any algebraic closure of its base field."
	^ self dimension = -1! !

!ProjectiveVariety methodsFor: 'testing' stamp: 'len 10/20/2016 15:21'!
isProjective
	^ true! !

!ProjectiveVariety methodsFor: 'testing' stamp: 'len 12/15/2021 19:30:53'!
isSmooth
	"Answer true if the receiver is nonsingular."
	^ self propertyAt: #isSmooth ifAbsentPut: [self singular dimension < 0]! !

!ProjectiveVariety methodsFor: 'testing' stamp: 'len 12/15/2021 12:01:25'!
satisfies: aTuple
	"Answer true if the defining equations of the receiver satisfy the argument, assuming it's the coordinates of a rational point in the ambient space."
	^ self asIdeal generators allSatisfy: [:each| (each value: aTuple) isZero]! !

!ProjectiveVariety methodsFor: 'private' stamp: 'len 12/15/2021 12:01:13'!
newPatch: i
	^ (self ambient patch: i) subscheme: (self asIdeal dehomogenizedIn: i)! !

!ProjectiveVariety methodsFor: 'private' stamp: 'len 2/13/2017 07:38:51'!
species
	^ ProjectiveVariety! !

!ProjectiveVariety class methodsFor: 'examples' stamp: 'len 5/23/2020 09:11:37'!
cayleyCubic
	"The Cayley cubic as projective surface.
	This is the unique cubic surface that has 4 ordinary nodes.
	It is a degeneration of the Clebsh cubic and has Sym(4) as its symmetry group."
	| P |
	P _ ProjectiveSpace new: #(x y z w) over: .
	^ P subscheme: P coordinateRing !! [:x :y :z :w| x*y*z + (x*y*w) + (x*z*w) + (y*z*w)]! !

!ProjectiveVariety class methodsFor: 'examples' stamp: 'len 5/23/2020 09:11:37'!
fermat4
	"The 4th Fermat curve."
	| P |
	P _ ProjectiveSpace new: #(x y z) over: .
	^ P subscheme: P coordinateRing !! [:x :y :z| x^4 + (y^4) - (z^4)]! !

!ProjectiveVariety class methodsFor: 'examples' stamp: 'len 5/23/2020 09:11:37'!
fermat: n
	"The n-th Fermat curve."
	| P |
	P _ ProjectiveSpace new: #(x y z) over: .
	^ P subscheme: (P coordinateRing generate: [:x :y :z| x^n + (y^n) - (z^n)])! !

!ProjectiveVariety class methodsFor: 'examples' stamp: 'len 5/23/2020 09:11:37'!
kleinQuartic
	"This is a projective variety, a curve in P^2(C)."
	| P x y z |
	P _ ProjectiveSpace new: 2 over: .
	x _ P coordinateRing x.
	y _ P coordinateRing y.
	z _ P coordinateRing z.
	^ P subscheme: {x^3*y + (y^3*z) + (z^3*x)}! !

!ProjectiveVariety class methodsFor: 'instance creation' stamp: 'len 8/27/2018 21:57:50'!
coordinateRing: anAffineRing
	self == ProjectiveVariety ifFalse: [^ self new coordinateRing: anAffineRing].
	anAffineRing relators size = 1 ifTrue:
		[| f |
		f _ anAffineRing relators anyOne.
		f degree > 0 ifTrue:
			[anAffineRing rank = 3 ifTrue:
				[f degree = 1 ifTrue: [^ RationalCurve coordinateRing: anAffineRing].
				f degree = 2 ifTrue: [^ Conic coordinateRing: anAffineRing].
				f degree = 3 ifTrue: ["elliptic curve"].
				^ ProjectivePlaneCurve coordinateRing: anAffineRing].
			^ ProjectiveHypersurface coordinateRing: anAffineRing]].
	^ self new coordinateRing: anAffineRing! !

!ProjectiveVariety class methodsFor: 'instance creation' stamp: 'len 2/13/2017 07:39:23'!
newFrom: anObject
	(anObject isKindOf: ProjectiveVariety) ifTrue: [^ self coordinateRing: anObject coordinateRing].
	^ super newFrom: anObject! !

!ProjectiveCurve methodsFor: 'accessing' stamp: 'len 12/15/2021 12:00:37'!
arithmeticGenus
	self isIrreducible ifFalse: [^ self error: 'not irreducible'].
	^ 1 - (self asIdeal hilbertPolynomial value: 0)! !

!ProjectiveCurve methodsFor: 'accessing' stamp: 'len 10/13/2016 13:38'!
dimension
	^ 1! !

!ProjectiveCurve methodsFor: 'as yet unclassified' stamp: 'len 4/30/2018 19:16:28'!
divisorOf: aRationalFunction
	"Answer div(f), the divisor with coefficient ord(f,p) for each point p of its support, where ord(f,p) is the order of a point p as zero or pole of the rational function f."
	self notYetImplemented! !

!ProjectiveHypersurface methodsFor: 'accessing' stamp: 'len 1/8/2017 17:39:24'!
degree
	"The degree of a projective hypersurface is the degree of the defining homogeneous polynomial."
	^ self polynomial degree! !

!ProjectiveHypersurface methodsFor: 'accessing' stamp: 'len 1/8/2017 17:21:47'!
dimension
	^ self ambient dimension - 1! !

!ProjectiveHypersurface methodsFor: 'accessing' stamp: 'len 2/10/2017 08:22:53'!
dual
	"Answer the projective dual of the receiver."
	self notYetImplemented! !

!ProjectiveHypersurface methodsFor: 'accessing' stamp: 'len 12/15/2021 12:00:42'!
polynomial
	^ self asIdeal generator! !

!ProjectiveHypersurface methodsFor: 'as yet unclassified' stamp: 'len 1/11/2017 20:55:49'!
gradient
	| f F |
	f _ self polynomial.
	F _ self ambient functionField.
	"actually should go to the dual projective space"
	^ RationalMap from: self to: self ambient representatives: ((1 to: F rank) collect: [:i| F !! (f derivativeIn: i)])! !

!ProjectiveHypersurface class methodsFor: 'instance creation' stamp: 'len 1/8/2017 17:20:38'!
polynomial: aPolynomial
	^ self coordinateRing: aPolynomial parent / aPolynomial! !

!ProjectivePlaneCurve methodsFor: 'accessing' stamp: 'len 1/10/2018 13:52:10'!
arithmeticGenus
	| n |
	self isIrreducible ifFalse: [^ self notYetImplemented].
	n _ self polynomial degree.
	^ n - 1 * (n - 2) / 2! !

!ProjectivePlaneCurve methodsFor: 'operations' stamp: 'len 5/10/2019 04:33:29'!
flexes
	"This is the subscheme of flexes of the receiver.
	In classic algebraic geometry, a point in a nonsingular plane curve over the complex numbers is a 'flex' if its tangent line has contact of order >= 3 with the curve."
	^ self /\ self hessian! !

!ProjectivePlaneCurve methodsFor: 'operations' stamp: 'len 1/11/2017 13:24:29'!
hessian
	"Answer the Hessian curve associated to the receiver.
	Over an algebraically closed field, the intersection of a plane curve and its Hessian is the subvariety of flexes."
	^ self ambient subscheme: self polynomial hessian determinant! !

!Conic methodsFor: 'accessing' stamp: 'len 5/28/2020 18:19:49'!
coefficients
	^ self propertyAt: #coefficients ifAbsentPut:
		[| f |
		f _ self polynomial orderedBy: #lex.
		(f parent gradingAt: 2) !! f]! !

!Conic methodsFor: 'accessing' stamp: 'len 9/3/2018 21:10:30'!
determinant
	^ self matrix determinant! !

!Conic methodsFor: 'accessing' stamp: 'len 12/25/2016 12:14:47'!
genus
	"Answer the geometric genus of the receiver."
	^ 0! !

!Conic methodsFor: 'accessing' stamp: 'len 9/13/2018 05:48:34'!
matrix
	"Answer the matrix M such that the defining polynomial of this conic is (x,y,z)*M*(x,y,z)^t. The matrix is upper-triangular over characteristic 2, and symmetric otherwise."
	self scalars characteristic = 2
		ifTrue: [^ self upperTriangularMatrix].
	^ self symmetricMatrix! !

!Conic methodsFor: 'accessing' stamp: 'len 12/31/2016 10:07:42'!
parametrization
	"Answer a parametrization of the receiver as a regular map from the projective line."
	| point P1 |
	self scalars isField ifFalse: [^ self error: 'not over a field'].
	self isSmooth ifFalse: [^ self error: 'the conic is not smooth'].
	point _ self anyPoint.
	P1 _ ProjectiveLine over: self scalars.
	"..."! !

!Conic methodsFor: 'morphisms' stamp: 'len 1/7/2017 21:44:28'!
toDiagonal
	"Answer an isomorphism between the receiver and its diagonal form."
	self notYetImplemented! !

!Conic methodsFor: 'points' stamp: 'len 9/4/2018 14:16:51'!
pointAtRandom: aRandom
	"Answer randomly a point of the receiver. Assume the scalars are a finite field."
	| f |
	f _ self parametrization.
	^ f value: (f domain pointAtRandom: aRandom)! !

!Conic methodsFor: 'points' stamp: 'len 1/7/2017 21:28:07'!
pointsCountOver: aRing
	"The number of Z/pZ-rational points of a curve of genus 0 is always p + 1."
	(aRing isKindOf: PrimeField) ifTrue: [^ aRing characteristic + 1].
	^ super pointsCountOver: aRing! !

!Conic methodsFor: 'testing' stamp: 'len 9/4/2018 13:56:26'!
isDiagonal
	"Answer true if the reciever is in diagonal form, i.e. it is defined by a polynomial of the form ax^2 + by^2 + cz^2."
	| coefficients |
	coefficients _ self coefficients.
	^ (coefficients at: 2) isZero and: [(coefficients at: 3) isZero and: [(coefficients at: 5) isZero]]! !

!Conic methodsFor: 'testing' stamp: 'len 1/7/2017 21:48:12'!
isIrreducible
	"In characteristic not 2, this is equivalent to the diagonal form having coefficients a,b,c all not 0."
	^ super isIrreducible! !

!Conic methodsFor: 'testing' stamp: 'len 9/3/2018 20:29:09'!
isSmooth
	"Answer true if the receiver is nonsingular."
	| coefficients p |
	self scalars characteristic = 2 ifFalse: [^ self determinant isZero not].
	coefficients _ self coefficients.
	p _ #(5 3 2) collect: [:i| coefficients at: i].
	(p allSatisfy: [:each| each isZero]) ifTrue: [^ false].
	^ (self polynomial value: p) isZero not! !

!Conic methodsFor: 'private' stamp: 'len 12/26/2016 11:28:39'!
solve: d n: n
	(d < 0 and: [n < 0]) ifTrue: [^ nil].
	d abs > n abs ifTrue: [^ self solve: n n: d].
	d = 1 ifTrue: [^ #(1 1 0)].
	n = 1 ifTrue: [^ #(1 0 1)].
	d = n negated ifTrue: [^ #(0 1 1)].
	d = n ifTrue: [^ (self solve: -1 n: d) ifNotNil: [:xyz| [:x :y :z| {d*z. x. y}] valueWithArguments: xyz]].
	(d isQuadraticResidueModulo: n) ifFalse: [^ nil].
	"... last two steps"! !

!Conic methodsFor: 'private' stamp: 'len 8/9/2020 07:50:51'!
symmetricMatrix
	| T |
	self scalars characteristic = 2
		ifTrue:
			[self isDiagonal ifFalse: [self error: 'not symmetric matrix defined for non-diagonal conic over field of characteristic 2'].
			^ self upperTriangularMatrix].
	T _ self upperTriangularMatrix.
	^ T + T transpose / (self scalars !! 2)! !

!Conic methodsFor: 'private' stamp: 'len 7/13/2020 11:55:39'!
upperTriangularMatrix
	| stream |
	stream _ self coefficients readStream.
	^ (self scalars^3) endomorphisms filling: [:i :j| i > j ifTrue: [self scalars zero] ifFalse: [stream next]]! !

!Conic class methodsFor: 'instance creation' stamp: 'len 9/4/2018 13:55:14'!
coefficients: aTuple
	| R x y z |
	R _ aTuple scalars polynomialsIn: #(x y z).
	x _ R x.
	y _ R y.
	z _ R z.
	aTuple size = 3
		ifTrue: [^ self polynomial: x^2 * (aTuple at: 1) + (y^2 * (aTuple at: 2)) + (z^2 * (aTuple at: 3))].
	aTuple size = 6
		ifTrue: [^ self polynomial: x^2*(aTuple at: 1) + (x*y*(aTuple at: 2)) + (x*z*(aTuple at: 3)) + (y^2*(aTuple at: 4)) + (y*z*(aTuple at: 5)) + (z^2*(aTuple at: 6))].
	^ self error: '3 or 6 coefficients expected'! !

!RationalCurve methodsFor: 'as yet unclassified' stamp: 'len 12/25/2016 12:14:55'!
genus
	"Answer the geometric genus of the receiver."
	^ 0! !

!RationalCurve methodsFor: 'as yet unclassified' stamp: 'len 1/7/2017 21:28:19'!
pointsCountOver: aRing
	"The number of Z/pZ-rational points of a curve of genus 0 is always p + 1."
	(aRing isKindOf: PrimeField) ifTrue: [^ aRing characteristic + 1].
	^ super pointsCountOver: aRing! !

!EllipticCurve methodsFor: 'accessing' stamp: 'len 11/9/2016 13:11'!
equation
	^ equation! !

!EllipticCurve methodsFor: 'accessing' stamp: 'len 11/10/2016 08:03'!
genus
	"Answer the geometric genus of the receiver."
	^ 1! !

!EllipticCurve methodsFor: 'accessing-private' stamp: 'len 7/31/2020 10:24:36'!
equation: aWeierstrassEquation
	| f |
	equation _ aWeierstrassEquation.
	f _ equation homogeneousPolynomial.
	self coordinateRing: f parent / f! !

!EllipticCurve methodsFor: 'converting' stamp: 'len 5/2/2021 11:19:44'!
% anInteger
	"Answer the reduction of the receiver modulo anInteger."
	self scalars =  ifFalse: [^ DomainError signal: 'not over the rationals'].
	^ self over:  / anInteger! !

!EllipticCurve methodsFor: 'converting' stamp: 'len 1/20/2017 09:37:28'!
over: aRing
	^ self class equation: (self equation over: aRing)! !

!EllipticCurve methodsFor: 'operations' stamp: 'len 8/5/2021 08:38:35'!
badPrimes
	"Answer the set of primes for which the receiver doesn't have 'good reduction'."
	^ self discriminant factorization asSet! !

!EllipticCurve methodsFor: 'operations' stamp: 'len 11/11/2016 10:02'!
discriminant
	^ self equation discriminant! !

!EllipticCurve methodsFor: 'operations' stamp: 'len 11/10/2016 09:43'!
divisionPolynomial: n
	"Answer the n-th division polynomial."
	^ self divisionPolynomial: n at: self scalars polynomials x! !

!EllipticCurve methodsFor: 'operations' stamp: 'len 12/28/2016 09:23:12'!
divisionPolynomial: n at: x
	"Answer the n-th division polynomial of the receiver evaluated at x."
	^ self notYetImplemented! !

!EllipticCurve methodsFor: 'operations' stamp: 'len 5/23/2020 09:13:12'!
divisionPolynomialNew: n
	"Answer the n-th division polynomial."
	| R w x y |
	R _  polynomialsIn: #(x y).
	n == 1 ifTrue: [^ R one].
	w _ self equation.
	x _ R x.
	y _ R y.
	n == 2 ifTrue: [^ y*2 + (w a1 * x) + w a3].
	n == 3 ifTrue: [^ x^4 * 3 + (x^3 * w b2) + (x^2 * 3 * w b4) + (x * 3 * w b6) + w b8].
	n == 4 ifTrue: [^ (self divisionPolynomial: 2) * (x^6 * 2 + (x^5 * w b2) + (x^4 * w b4 * 5) + (x^3 * 10 * w b6) + (x^2 * 10 * w b8) + (x * (w b2 * w b8 - (w b4 * w b6))) + (w b4 * w b8 - w b6 squared))].
"	n odd ifTrue: [
		m _ n - 1 // 2.
		^ (self divisionPolynomial: m+2) * ((self divisionPolynomial: m) ^ 3) - (self divisionPolynomial"! !

!EllipticCurve methodsFor: 'operations' stamp: 'len 1/8/2017 20:55:09'!
divisionPolynomials
	"Answer the sequence of division polynomials.
	Reference: Silverman, 'The Arithmetic of Elliptic Curves', Exercise 3.7, pag. 105."
	| R x y phi1 phi2 phi3 phi4 a1 a3 b2 b4 b6 b8 |
	R _ self scalars polynomialsIn: #(x y). x _ R x. y _ R y.
	a1 _ self equation a1.
	a3 _ self equation a3.
	b2 _ self equation b2.
	b4 _ self equation b4.
	b6 _ self equation b6.
	b8 _ self equation b8.
	phi1 _ R one.
	phi2 _ y*2 + (a1 * x) + a3.
	phi3 _ x^4 * 3 + (x^3 * b2) + (x^2 * 3 * b4) + (x * 3 * b6) + b8.
	phi4 _ phi2 * (x^6 * 2 + (x^5 * b2) + (x^4 * b4 * 5) + (x^3 * 10 * b6) + (x^2 * 10 * b8) + (x * (b2 * b8 - (b4 * b6))) + (b4 * b8 - b6 squared)).
	^ Sequence to: R initialValues: {phi1. phi2. phi3. phi4} recurrence: [:phi :n|
		| m |
		n odd
			ifTrue:
				[m _ n - 1 // 2.
				(phi at: m+2) * ((phi at: m) ^ 3) - ((phi at: m - 1) * ((phi at: m + 1) ^ 3))]
			ifFalse:
				[m _ n // 2.
				(phi at: m-1) squared * (phi at: m) * (phi at: m+2) - ((phi at: m-2) * (phi at: m) * (phi at: m+1) squared // phi2)]]! !

!EllipticCurve methodsFor: 'operations' stamp: 'len 1/8/2017 21:07:11'!
multiplicationBy: m
	| F f omega phi psi x |
	psi _ self divisionPolynomials.
	f _ psi at: m.
	x _ psi codomain x.
"	y _ psi codomain y."
	F _ self ambient functionField.
	phi _ x * f squared - ((psi at: m+1) * (psi at: m-1)).
	omega _ (psi at: m+2) * (psi at: m-1) squared - ((psi at: m-2) * (psi at: m+1) squared).
	f _ f value: {F x. F y}.
	omega _ (omega value: {F x. F y}) / (F y * 4).
	phi _ phi value: {F x. F y}.
	^ "self from: self to: self representatives:" {phi / f squared. omega / (f^3). F z}! !

!EllipticCurve methodsFor: 'points' stamp: 'len 7/4/2019 03:48:39'!
pointAt: aTuple
	aTuple size = 2 ifTrue: [^ EllipticCurvePoint on: self coordinates: (aTuple copyWith: aTuple scalars one)].
	^ EllipticCurvePoint on: self coordinates: aTuple! !

!EllipticCurve methodsFor: 'points' stamp: 'len 8/27/2018 22:25:47'!
pointAtRandom: aRandom
	"Answer randomly a point of the receiver. Assume the scalars are a finite field."
	| points |
	[(points _ self pointsAtX: (self scalars atRandom: aRandom)) isEmpty] whileTrue.
	^ points atRandom: aRandom! !

!EllipticCurve methodsFor: 'points' stamp: 'len 7/30/2019 04:38:31'!
pointsAtX: x
	"Answer the points with x coordinate as given by the argument."
	| P |
	P _ self scalars polynomials.
	^ (self polynomial value: {P !! x. P x. P one}) roots collect: [:y| self pointAt: (self scalars !! x, y)]! !

!EllipticCurve methodsFor: 'points' stamp: 'len 12/22/2016 23:19:49'!
pointsOver: aField
	"Answer the group of K-rational points on the receiver."
	^ EllipticCurveGroup on: self over: aField! !

!EllipticCurve methodsFor: 'testing' stamp: 'len 10/25/2016 14:11'!
isSmooth
	^ self discriminant isZero not! !

!EllipticCurve methodsFor: 'private' stamp: 'len 11/10/2016 09:45'!
divisionPolynomial0: n at: x
	"Answer the n-th division polynomial, without the 2-torsion factor if n is even, evaluated at x."
	n = -2 ifTrue: [^ (self divisionPolynomial: -1 at: x) squared].
	n = -1 ifTrue: [^ x^3 * 4 + (x^2 * equation b2) + (x * equation b4 * 2) + equation b6].
	n <= 0 ifTrue: [DomainError signal].
	(n = 1 or: [n = 2]) ifTrue: [^ x one].
	n = 3 ifTrue: [^ x^4 + (x^3 * equation b2) + (x^2 * equation b4 * 3) + (x * equation b6 * 3) + equation b8].
	n = 4 ifTrue: [^ (x^2 * 6 + (x * equation b2) + equation b4) * (self divisionPolynomial: 3 at: x) + (self divisionPolynomial: -2 at: x)].
	^ n even
		ifTrue:
			[| m |
			m _ n - 2 // 2.
			(self divisionPolynomial: m+1 at: x) *
			((self divisionPolynomial: m at: x)^2 * (self divisionPolynomial: m+3 at: x) -
			((self divisionPolynomial: m+2 at: x)^2 * (self divisionPolynomial: m-1 at: x)))]
		ifFalse:
			[| m |
			m _ n - 1 // 2.
			m even
				ifTrue: [(self divisionPolynomial: m at: x)^3 * (self divisionPolynomial: -2 at: x) * (self divisionPolynomial: m+2 at: x) - ((self divisionPolynomial: m+1 at: x)^3 * (self divisionPolynomial: m-1 at: x))]
				ifFalse: [(self divisionPolynomial: m at: x)^3 * (self divisionPolynomial: m+2 at: x) - ((self divisionPolynomial: m+1 at: x)^3 * (self divisionPolynomial: m-1 at: x) * (self divisionPolynomial: -2 at: x))]]! !

!EllipticCurve class methodsFor: 'examples' stamp: 'len 5/23/2020 09:11:37'!
cremona11a1
	"Elliptic curve 11a1, first curve in the Cremona database."
	^ EllipticCurve coefficients: ((0,-1,1,-10,-20) over: )! !

!EllipticCurve class methodsFor: 'examples' stamp: 'len 5/23/2020 09:11:37'!
cremona11a2
	"Elliptic curve 11a2 from the Cremona database."
	^ EllipticCurve coefficients: ((0,-1,1,-7820,-263580) over: )! !

!EllipticCurve class methodsFor: 'examples' stamp: 'len 5/23/2020 09:11:37'!
cremona11a3
	"Elliptic curve 11a3 from the Cremona database."
	^ EllipticCurve coefficients: ((0,-1,1,0,0) over: )! !

!EllipticCurve class methodsFor: 'examples' stamp: 'len 5/23/2020 09:11:37'!
cremona37a
	"Elliptic curve 37a from the Cremona database.
	This is the elliptic curve of rank 1 with smallest conductor."
	^ EllipticCurve coefficients: ((0,0,1,-1,0) over: )! !

!EllipticCurve class methodsFor: 'examples' stamp: 'len 5/23/2020 09:11:37'!
cremona389a1
	"Elliptic curve 389a1 from the Cremona database."
	^ EllipticCurve coefficients: ((0,1,1,-2,0) over: )! !

!EllipticCurve class methodsFor: 'examples' stamp: 'len 8/24/2018 20:06:52'!
secp256k1
	"Answer the SECP256K1 elliptic curve, used by Bitcoin.
	The group of this curve has order 115792089237316195423570985008687907852837564279074904382605163141518161494337."
	| F |
	F _ PrimeField new: 16rFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F.
	^ self coefficients: ((0,0,0,0,7) over: F)! !

!EllipticCurve class methodsFor: 'instance creation' stamp: 'len 11/9/2016 15:12'!
coefficients: aTuple
	^ self equation: (WeierstrassEquation coefficients: aTuple)! !

!EllipticCurve class methodsFor: 'instance creation' stamp: 'len 11/9/2016 13:10'!
equation: aWeierstrassEquation
	^ self new equation: aWeierstrassEquation! !

!ProjectiveSpace methodsFor: 'accessing' stamp: 'len 8/27/2016 19:03'!
ambient
	^ self! !

!ProjectiveSpace methodsFor: 'accessing' stamp: 'len 12/15/2021 11:56:23'!
asIdeal
	"Answer the defining ideal of the receiver, considered as a subscheme of itself."
	^ self coordinateRing asIdeal null! !

!ProjectiveSpace methodsFor: 'accessing' stamp: 'len 10/20/2016 04:11'!
dimension
	^ self coordinateRing dimension - 1! !

!ProjectiveSpace methodsFor: 'accessing' stamp: 'len 1/5/2017 07:58:07'!
gradings
	"Answer the gradings of the coordinate ring of the receiver.
	When all the gradings are 1 this is ordinary projective space, otherwise it is a weighted (or graded) projective space."
	^ self coordinateRing gradings! !

!ProjectiveSpace methodsFor: 'accessing' stamp: 'len 10/20/2016 16:19'!
rank
	^ self coordinateRing rank! !

!ProjectiveSpace methodsFor: 'morphisms' stamp: 'len 12/30/2016 20:22:12'!
automorphisms
	"Answer the group of automorphisms PGL(P), i.e. the linear automorphisms. These are the only regular automorphisms.
	Note that there are more rational automorphisms, the Cremona maps, but they are not included in this group. In the projective plane, the group of birational automorphisms is generated by the linear automorphisms plus the standard quadratic transformation (that takes each coordinate to its reciprocal xi -> 1/xi)."
	self notYetImplemented! !

!ProjectiveSpace methodsFor: 'morphisms' stamp: 'len 12/15/2021 12:57:58'!
quadraticMap
	"Answer the standard quadratic map that takes each coordinate to its inverse.
	This is a birational automorphism. In the projective plane, this automorphism together with the linear automorphisms of PGL generate the group of birational automorphisms."
	^ RationalMap from: self to: self evaluating: [:x| x apply: [:each| each inverse]]! !

!ProjectiveSpace methodsFor: 'morphisms' stamp: 'len 4/28/2021 10:53:06'!
veronese: degree
	"Answer the Veronese map of the given degree from the receiver."
	| F monomials |
	F _ self functionField.
	monomials _ (F integers monomials allMonomialsOfDegree: degree) collect: [:each| F embed: F integers !! each].
	^ RationalMap from: self to: (ProjectiveSpace new: monomials size - 1 over: self scalars) representatives: monomials! !

!ProjectiveSpace methodsFor: 'operations' stamp: 'len 7/31/2021 15:44:15'!
subscheme: anObject
	| I |
	I _ (anObject isKindOf: Ideal) ifTrue: [anObject] ifFalse: [self coordinateRing * anObject].
	^ (self coordinateRing / I) proj! !

!ProjectiveSpace methodsFor: 'points' stamp: 'len 8/5/2021 08:42:36'!
pointsCountOver: aRing
	aRing isField ifTrue: [^ aRing isFinite ifTrue: [^ self rank choose: 1 q: aRing size] ifFalse: [aRing size]].
	aRing isFinite ifFalse: [^ aRing size].
	(aRing isKindOf: ModularIntegerRing)
		ifTrue:
			[^ aRing modulus ^ (self rank - 1) * (aRing modulus factorization asSet product: [:p| (0 to: self rank - 1) sum: [:i| 1 / (p^i)]])].
	^ super pointsCountOver: aRing! !

!ProjectiveSpace methodsFor: 'points' stamp: 'len 4/26/2021 10:53:26'!
pointsOver: aRing do: aBlock
	aRing isField ifTrue: [^ self pointsOverField: aRing do: aBlock].
	aRing ==  ifTrue: [^ self pointsOverIntegersDo: aBlock].
	self pointsOverRing: aRing do: aBlock! !

!ProjectiveSpace methodsFor: 'points-private' stamp: 'len 5/31/2020 17:02:32'!
pointsOverField: aRing do: aBlock
	| one zero V |
	one _ aRing one.
	zero _ aRing zero.
	V _ aRing ^ self rank.
	aRing tuples: self rank - 1 do: [:each| | d |
		((d _ each findLast: [:x| x isZero not]) > 0 and: [(each at: d) = one])
			ifTrue: [aBlock value: (self pointAt: V !! (each copyWith: zero))].
		aBlock value: (self pointAt: V !! (each copyWith: one))]! !

!ProjectiveSpace methodsFor: 'points-private' stamp: 'len 5/28/2020 18:08:49'!
pointsOverIntegersDo: aBlock
	 ^ self rank do: [:each| | d |
		((d _ each depth) > 0 and: [(each at: d) > 0 and: [each content = 1]])
			ifTrue: [aBlock value: each]]! !

!ProjectiveSpace methodsFor: 'points-private' stamp: 'len 5/28/2020 18:09:02'!
pointsOverRing: aRing do: aBlock
	| visited point |
	visited _ Set new.
	aRing ^ self rank do: [:each|
		each isUnimodular
			ifTrue: [visited add: (point _ self pointAt: each) ifAbsent: [aBlock value: point]]]! !

!ProjectiveSpace methodsFor: 'testing' stamp: 'len 1/5/2017 07:59:24'!
isOrdinaryProjectiveSpace
	"Answer true if the receiver is the ordinary projective space, which means that it's not weighted (or that all weights or gradings are 1)."
	^ self coordinateRing gradings allSatisfy: [:each| each = 1]! !

!ProjectiveSpace methodsFor: 'testing' stamp: 'len 2/22/2017 07:55:14'!
isPlane
	^ self rank = 3! !

!ProjectiveSpace methodsFor: 'testing' stamp: 'len 1/13/2017 17:07:33'!
satisfies: aTuple
	^ true! !

!ProjectiveSpace methodsFor: 'private' stamp: 'len 3/6/2021 14:05:36'!
newPatch: i
	^ (self coordinateRing slice: (self coordinateRing indeterminates select: [:each| each ~= i])) spec! !

!ProjectiveSpace methodsFor: 'private' stamp: 'len 1/13/2017 17:23:38'!
saturated
	^ self! !

!ProjectiveSpace class methodsFor: 'examples' stamp: 'len 5/23/2020 09:11:37'!
example1
	"The rational projective plane:"
	^ ProjectiveSpace new: 2 over: ! !

!ProjectiveSpace class methodsFor: 'examples' stamp: 'len 5/23/2020 09:11:37'!
example2
	"Or assigning names to the indeterminates of the homogeneous coordinate ring:"
	^ ProjectiveSpace new: #(x y z) over: ! !

!ProjectiveSpace class methodsFor: 'examples' stamp: 'len 5/23/2020 09:11:37'!
example3
	"And equivalently:"
	^ ( polynomialsIn: #(x y z)) proj! !

!ProjectiveSpace class methodsFor: 'instance creation' stamp: 'len 1/12/2017 14:39:20'!
coordinateRing: aPolynomialRing
	^ (aPolynomialRing rank = 1 ifTrue: [ProjectiveLine] ifFalse: [self]) new coordinateRing: aPolynomialRing! !

!ProjectiveSpace class methodsFor: 'instance creation' stamp: 'len 10/31/2016 13:27'!
new: rank over: aRing
	^ self coordinateRing:
		(rank isInteger
			ifTrue: [aRing polynomialsIn: rank+1]
			ifFalse: [aRing polynomialsIn: rank])! !

!ProjectiveLine methodsFor: 'accessing' stamp: 'len 12/4/2016 22:26:45'!
infinity
	| R |
	R _ self scalars.
	^ self pointAt: (R tuple: {R one. R zero})! !

!ProjectiveLine methodsFor: 'accessing' stamp: 'len 12/4/2016 22:26:35'!
one
	| R |
	R _ self scalars.
	^ self pointAt: (R tuple: {R one. R one})! !

!ProjectiveLine methodsFor: 'accessing' stamp: 'len 12/4/2016 22:26:25'!
zero
	| R |
	R _ self scalars.
	^ self pointAt: (R tuple: {R zero. R one})! !

!ProjectiveLine methodsFor: 'elements' stamp: 'len 4/9/2020 18:14:26'!
adapt: anElement
	(self scalars includes: anElement) ifTrue: [^ self embed: anElement].
	^ super adapt: anElement! !

!ProjectiveLine methodsFor: 'morphisms' stamp: 'len 12/5/2016 10:27:31'!
embed: anElement
	^ self pointAt: (self scalars tuple: {anElement. self scalars one})! !

!ProjectiveLine methodsFor: 'morphisms' stamp: 'len 12/22/2021 15:06:23'!
from: aDomain
	aDomain = self scalars ifTrue: [^ self addMap: (self scalars to: self evaluating: [:each| self embed: each])].
	aDomain -> self scalars ifNotNil: [:aMorphism| ^ aMorphism -> self].
	^ super from: aDomain! !

!ProjectiveLine methodsFor: 'points' stamp: 'len 7/4/2019 03:48:51'!
pointAt: aTuple
	^ ProjectiveLinePoint on: self coordinates: aTuple! !

!ProjectiveLine methodsFor: 'points-private' stamp: 'len 5/4/2020 10:06:40'!
pointsOverRing: aRing do: aBlock
	| visited |
	visited _ Set new.
	aRing do: [:a|
		aRing do: [:b|
			| point |
			(aRing anySatisfy: [:c| aRing anySatisfy: [:d| (a*d - (c*b)) isUnit]])
				ifTrue: [visited add: (point _ self pointAt: (aRing tuple: {a. b})) ifAbsent: [aBlock value: point]]]]! !

!ProjectiveLine class methodsFor: 'instance creation' stamp: 'len 12/4/2016 22:07:23'!
over: aRing
	^ self coordinateRing: (aRing polynomialsIn: #(x y))! !

!ProjectivePlane methodsFor: 'accessing' stamp: 'len 7/15/2021 16:05:18'!
order
	self scalars isFiniteField ifTrue: [^ self scalars degree].
	^ self notYetImplemented! !

!ProjectivePlane class methodsFor: 'instance creation' stamp: 'len 9/16/2018 16:07:45'!
over: aRing
	^ self coordinateRing: (aRing polynomialsIn: #(x y z))! !

!SemistandardTableaux methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 02:31'!
alphabet
	^ alphabet! !

!SemistandardTableaux methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 02:32'!
alphabet: anArray
	alphabet _ anArray! !

!SemistandardTableaux methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 03:25'!
diagram
	^ YoungDiagram shape: shape! !

!SemistandardTableaux methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 03:29'!
shape
	^ shape! !

!SemistandardTableaux methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 03:29'!
shape: aPartition
	shape _ aPartition! !

!SemistandardTableaux class methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 03:28'!
alphabet: anArray shape: aPartition
	^ self new alphabet: anArray; shape: aPartition! !

!SemistandardTableaux class methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 03:28'!
new: anInteger shape: aPartition
	^ self alphabet: (1 to: anInteger) shape: aPartition! !

!StandardTableaux methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 03:24'!
size
	| answer Y |
	answer _ alphabet size factorial.
	Y _ self diagram.
	Y do: [:each|
		answer _ answer / (Y hookLengthAt: each)].
	^ answer
! !

!CellComplex methodsFor: 'accessing' stamp: 'len 2/15/2017 07:32:58'!
cells: n
	"Answer the set of n-cells of the receiver."
	^ Set accumulate: [:aBlock| self cells: n do: aBlock]! !

!CellComplex methodsFor: 'accessing' stamp: 'len 2/17/2017 16:51:20'!
vertices
	| answer |
	self propertyAt: #vertices ifPresent: [:aSet| ^ aSet].
	answer _ Set new.
	self facets do: [:each| answer addAll: each vertices].
	^ self propertyAt: #vertices put: answer! !

!CellComplex methodsFor: 'enumerating' stamp: 'len 2/15/2017 07:51:33'!
cells: n do: aBlock
	"Iterate over the n-cells of the receiver, possibly with repretitions.
	Subclasses should reimplement."
	^ self do: [:each| each dimension = n ifTrue: [aBlock value: each]]! !

!CellComplex methodsFor: 'homology' stamp: 'len 2/24/2017 12:53:20'!
boundaryMap: k over: aRing
	"The k-th boundary map or differential d(k) goes from C(k) to C(k-1).
	Its image is the group of (k-1)-boundaries B(k-1), a subgroup of C(k-1).
	Its kernel is the group of k-cycles Z(k), a subgroup of C(k)."
	^ (self chains: k over: aRing) to: (self chains: k-1 over: aRing) evaluating: [:x| x boundary]! !

!CellComplex methodsFor: 'homology' stamp: 'len 2/25/2017 07:13:30'!
chainComplexOver: aRing
	^ ChainComplex differentials: ((self dimension+1 to: 0 by: -1) collect: [:i| self boundaryMap: i over: aRing])! !

!CellComplex methodsFor: 'homology' stamp: 'len 4/21/2020 10:57:15'!
chains: k over: aRing
	"Answer the free module of k-chains over the given ring."
	k < 0 ifTrue: [^ aRing ^ #()].
	^ aRing ^ (self cells: k)! !

!CellComplex methodsFor: 'invariants' stamp: 'len 2/19/2017 18:25:22'!
dimension
	self isVoid ifTrue: [^ Infinity negative].
	^ self max: [:each| each dimension]! !

!CellComplex methodsFor: 'invariants' stamp: 'len 2/15/2017 07:37:12'!
euler
	"Answer the Euler characteristic of the receiver."
	^ (0 to: self dimension) sum: [:p| -1^p * (self cells: p) size]! !

!CellComplex methodsFor: 'invariants' stamp: 'len 5/23/2020 08:59:21'!
fPolynomial
	"Answer the f-polynomial of this cell complex. This is the univariate polynomial with coefficients given by the f-vector (in decreasing order of exponents)."
	^  polynomials coefficients: self fVector reversed! !

!CellComplex methodsFor: 'invariants' stamp: 'len 6/1/2020 13:09:21'!
fVector
	"Answer the f-vector of this cell complex. This is a tuple of integers that count the number of cells of each dimension."
	^ ^(self dimension + 2) filling: [:i| (self cells: i-2) size]! !

!CellComplex methodsFor: 'invariants' stamp: 'len 6/1/2020 13:09:38'!
gVector
	"Answer the g-vector of this cell complex."
	| h |
	h _ self hVector.
	^ ^(h size // 2 + 1) filling: [:i| i == 1 ifTrue: [1] ifFalse: [(h at: i) - (h at: i-1)]]! !

!CellComplex methodsFor: 'invariants' stamp: 'len 9/7/2019 10:19:29'!
hPolynomial
	"Answer the h-polynomial of this cell complex. This is the result of composing the f-polynomial with 'x - 1'."
	| f x |
	f _ self fPolynomial.
	x _ f parent x.
	^ f   (x - 1)! !

!CellComplex methodsFor: 'invariants' stamp: 'len 2/15/2017 15:48:22'!
hVector
	"Answer the h-vector of this cell complex. This is the tuple of coefficients of the h-polynomial (in decreasing order of exponents)."
	^ self hPolynomial coefficients reversed! !

!CellComplex methodsFor: 'testing' stamp: 'len 2/25/2017 15:10:35'!
isTrivial
	"Answer true if this is the trivial complex, with only the empty cell."
	^ self size = 1! !

!CellComplex methodsFor: 'testing' stamp: 'len 2/25/2017 15:10:11'!
isVoid
	"Answer true if this is the void complex, that has no cells."
	^ self size = 0! !

!SimplicialComplex methodsFor: 'accessing' stamp: 'len 4/21/2016 04:37'!
edges
	^ self faces: 1! !

!SimplicialComplex methodsFor: 'accessing' stamp: 'len 11/30/2016 14:45:09'!
faces: m
	^ Set accumulate: [:aBlock| self faces: m do: aBlock]! !

!SimplicialComplex methodsFor: 'accessing' stamp: 'len 2/15/2017 08:29:11'!
facets
	"Answer the maximal faces of the receiver."
	^ self propertyAt: #facets! !

!SimplicialComplex methodsFor: 'accessing' stamp: 'len 2/19/2017 08:14:18'!
labelling
	"Answer a dictionary that associates a positive integer number to each vertex.
	For a simplicial complex with n vertices, the labels are 1,2,...,n."
	| V labelling |
	self propertyAt: #labelling ifPresent: [:aDictionary| ^ aDictionary].
	V _ self vertices.
	(V allSatisfy: [:each| each isInteger])
		ifTrue: [V _ V asSortedCollection]
		ifFalse: [V _ V asSortedCollection: [:a :b| a printString <= b printString]].
	labelling _ Dictionary new.
	1 to: V size do: [:each| labelling at: (V at: each) put: each].
	^ self propertyAt: #labelling put: labelling! !

!SimplicialComplex methodsFor: 'accessing' stamp: 'len 2/21/2017 18:59:14'!
nonfaces
	"Answer the set of minimal nonfaces, i.e. simpleces on the vertex set of the receiver which are not faces of the receiver."
	| answer V F |
	self isVoid ifTrue: [Set with: (Simplex vertices: #())].
	answer _ Set new.
	V _ self vertices asArray.
"	1 to: self vertices size do: [:k|"
	1 to: self dimension + 2 do: [:k|
		V combinations: k atATimeDo: [:combination|
			F _ Simplex vertices: combination copy.
			((self contains: F) not and: [answer noneSatisfy: [:none| F >= none]])
				ifTrue: [answer add: F]]].
	^ answer! !

!SimplicialComplex methodsFor: 'accessing' stamp: 'len 4/21/2016 04:38'!
ridges
	^ self faces: self dimension - 2! !

!SimplicialComplex methodsFor: 'accessing' stamp: 'len 2/20/2017 18:52:16'!
support
	"Answer the collection of vertices that belong to any face in the receiver."
	^ self vertices select: [:each| self facets anySatisfy: [:any| any includes: each]]! !

!SimplicialComplex methodsFor: 'enumerating' stamp: 'len 2/15/2017 11:20:19'!
cells: n do: aBlock
	"Iterate over the n-cells of the receiver, possibly with repetitions."
	^ self faces: n do: aBlock! !

!SimplicialComplex methodsFor: 'enumerating' stamp: 'len 2/19/2017 08:22:20'!
collect: aBlock
	^ self species faces: (self elements collect: aBlock)! !

!SimplicialComplex methodsFor: 'enumerating' stamp: 'len 2/14/2017 20:00:17'!
do: aBlock
	-1 to: self dimension do: [:each| (self faces: each) do: aBlock]! !

!SimplicialComplex methodsFor: 'enumerating' stamp: 'len 2/15/2017 07:53:57'!
faces: n do: aBlock
	"Iterate over the n-cells of the receiver, possibly with repetitions."
	self facets do: [:each| each faces: n do: [:face| aBlock value: face]]! !

!SimplicialComplex methodsFor: 'enumerating' stamp: 'len 2/19/2017 10:19:29'!
select: aBlock
	^ self species on: self vertices faces: (self elements select: aBlock)! !

!SimplicialComplex methodsFor: 'homology' stamp: 'len 12/22/2021 14:09:58'!
chainComplexOver: aRing
	"The k-th boundary map or differential d(k) goes from C(k) to C(k-1).
	Its image is the group of (k-1)-boundaries B(k-1), a subgroup of C(k-1).
	Its kernel is the group of k-cycles Z(k), a subgroup of C(k)."

	"The boundary of a chain is the linear combination of the boundary of the simplices in the chain. The boundary of a k-chain is a (k-1)-chain."

	| differentials domain codomain |
	domain _ self chains: -1 over: aRing.
	differentials _ (0 to: self dimension+1) collect: [:k|
		codomain _ domain.
		domain _ self chains: k over: aRing.
		k = 0
			ifTrue: [(domain => codomain) zero]
			ifFalse:
				[domain to: codomain evaluating: [:x|
					| answer |
					answer _ codomain zero.
					x withNamesDo: [:value :key|
						| V |
						V _ key vertices asArray.
						1 to: V size do: [:i| | F f |
							"F is the facet opposite the i-th vertex:"
							F _ Simplex vertices: (V copyWithoutIndex: i).
							f _ (codomain generatorNamed: F) * value.
							i odd ifTrue: [answer _ answer + f] ifFalse: [answer _ answer - f]]].
					answer]]].
	^ ChainComplex differentials: differentials reversed! !

!SimplicialComplex methodsFor: 'invariants' stamp: 'len 2/19/2017 18:24:25'!
dimension
	self isVoid ifTrue: [^ Infinity negative].
	^ self facets max: [:each| each dimension]! !

!SimplicialComplex methodsFor: 'morphisms' stamp: 'len 12/15/2021 21:04:10'!
apply: aMorphism
	"Answer the homomorphic image of the receiver."
	^ self species faces: (self facets collect: aMorphism)! !

!SimplicialComplex methodsFor: 'morphisms' stamp: 'len 5/2/2020 21:19:33'!
to: aSimplicialComplex evaluating: aBlock
	(aSimplicialComplex isKindOf: SimplicialComplex) ifFalse: [^ DomainError signal].
	^ SimplicialMap from: self to: aSimplicialComplex evaluating: aBlock! !

!SimplicialComplex methodsFor: 'morphisms' stamp: 'len 5/2/2020 21:19:41'!
to: aSimplicialComplex map: aDictionary
	"Answer a simplicial map that maps vertices by aDictionary."
	(aSimplicialComplex isKindOf: SimplicialComplex) ifFalse: [^ DomainError signal].
	^ SimplicialMap from: self to: aSimplicialComplex map: aDictionary! !

!SimplicialComplex methodsFor: 'morphisms' stamp: 'len 5/2/2020 21:19:45'!
to: aSimplicialComplex mapping: aBlock
	"Answer a simplicial map that maps vertices by aBlock."
	(aSimplicialComplex isKindOf: SimplicialComplex) ifFalse: [^ DomainError signal].
	^ SimplicialMap from: self to: aSimplicialComplex mapping: aBlock! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 2/19/2017 08:20:23'!
* aSimplicialComplex
	"Answer the join of the receiver with the argument."
	| join |
	join _ Set new.
	self facets do: [:each|
		aSimplicialComplex facets do: [:other| join add: each * other]].
	^ self species facets: join! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 7/6/2020 14:27:27'!
+ aSimplicialComplex
	^ self species faces: self facets, aSimplicialComplex facets! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 2/15/2017 11:15:20'!
- aFace
	"Answer the deletion of a aFace, i.e. the simplicial complex obtained by removing aFace."
	^ self select: [:each| (each <= aFace) not]! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 2/15/2017 11:15:36'!
/ aFace
	"Answer the link of aFace. This is the complex of all faces of simplices in the star that do not intersect aFace."
	^ self notYetImplemented! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 7/6/2020 14:27:52'!
\/ aSimplicialComplex
	"Answer the wedge sum (one-point union) of the receiver with the argument."
	| v0 w0 facets |
	v0 _ self support anyOne.
	w0 _ aSimplicialComplex support anyOne.
	facets _ Set new.
	self facets do: [:each| facets add: (each collect: [:v| v = v0 ifTrue: [{0. 0}] ifFalse: [{1. v}]])].
	aSimplicialComplex facets do: [:each| facets add: (each collect: [:w| w = w0 ifTrue: [{0. 0}] ifFalse: [{2. w}]])].
	^ self species "on: vertices" facets: facets! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 12/29/2017 09:46:31'!
 aSimplicialComplex
	"Answer the direct product of the receiver and the argument."
	| product |
	product _ Set new.
	self facets do: [:each|
		aSimplicialComplex facets do: [:other|
			self pathsFrom: each vertices to: other vertices do: [:path|
				product add: (Simplex vertices: path)]]].
	^ self species faces: product! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 2/19/2017 10:23:45'!
complement
	| V |
	V _ self vertices.
	^ self species on: V facets: (self facets collect: [:each| each complementIn: V])! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 2/15/2017 11:24:20'!
cone
	"Answer the join of the receiver with a new one-vertex simplicial complex."
	^ self * (self species facets: #((0)))! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 2/29/2016 08:25'!
coskeleton: n
	"Answer the n-coskeleton of the receiver."
	^ self notYetImplemented! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 2/19/2017 10:24:04'!
dual
	"Answer the Alexander dual of the receiver.
	This is the simplicial complex made of the complement of all faces *not* in the receiver, and it is generated by the complements of the minimal nonfaces."
	| V |
	V _ self vertices.
	^ self species on: V facets: (self nonfaces collect: [:each| each complementIn: V])! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 5/23/2020 09:11:37'!
facetIdeal
	"Answer the facet ideal of this simplicial complex.
	This is the ideal generated by those squarefree monomials associated to the maximal faces (facets) of the simplicial complex."
	^ self facetIdealIn: ( polynomialsIn: self vertices size)! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 2/19/2017 10:13:47'!
facetIdealIn: aRing
	"Answer the facet ideal of this simplicial complex in the given polynomial ring.
	This is the ideal generated by those squarefree monomials associated to the maximal faces (facets) of the simplicial complex."
	| labelling |
	labelling _ self labelling.
	^ aRing * (self facets collect: [:each|
		each vertices inject: aRing one into: [:g :v| g * (aRing x: (labelling at: v))]])! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 1/14/2022 12:45:57'!
openStarOf: aCollection
	"Answer the open star in the receiver of the simplices in aCollection.
	This is just a set of simplices, and not necessarily forms a complex."
	| answer |
	answer _ Set new.
	aCollection do: [:each|
		self do: [:other| (each intersects: other) ifTrue: [answer add: other]]].
	^ answer! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 2/15/2017 11:23:53'!
skeleton: n
	"Answer the n-skeleton of the receiver."
	^ self collect: [:each| each dimension <= n]! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 5/23/2020 09:11:37'!
stanleyReisnerIdeal
	"Answer the Stanley-Reisner ideal of this simplicial complex.
	This is the ideal generated by those squarefree monomials associated to nonfaces of the simplicial complex."
	^ self stanleyReisnerIdealIn: ( polynomialsIn: self vertices size)! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 2/19/2017 10:14:20'!
stanleyReisnerIdealIn: aRing
	"Answer the Stanley-Reisner ideal of this simplicial complex in the given polynomial ring.
	This is the ideal generated by those squarefree monomials associated to nonfaces of the simplicial complex."
	| labelling |
	labelling _ self labelling.
	^ aRing * (self nonfaces collect: [:each|
		each vertices inject: aRing one into: [:g :v| g * (aRing x: (labelling at: v))]])! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 5/23/2020 09:11:37'!
stanleyReisnerRing
	^ self stanleyReisnerRingOver: ! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 12/25/2021 12:44:07'!
stanleyReisnerRingOver: aRing
	| R |
	R _  aRing polynomialsIn: self vertices size.
	^ R / (self stanleyReisnerIdealIn: R)! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 2/19/2017 10:19:06'!
starOf: aCollection
	"Answer the (closed) star in the receiver of the simplices in aCollection.
	This is the closure of the open star."
	^ self species on: self vertices faces: (self openStarOf: aCollection)! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 2/21/2017 11:57:55'!
suspension
	^ self * (self class sphere: 0)! !

!SimplicialComplex methodsFor: 'testing' stamp: 'len 2/15/2017 08:24:23'!
contains: aSimplex
	^ self facets anySatisfy: [:one| one >= aSimplex]! !

!SimplicialComplex methodsFor: 'testing' stamp: 'len 2/15/2017 08:23:17'!
includes: aSimplex
	^ (aSimplex isKindOf: Simplex) and: [self contains: aSimplex]! !

!SimplicialComplex methodsFor: 'testing' stamp: 'len 6/13/2016 16:29'!
isConnected
	^ (self skeleton: 1) asGraph isConnected! !

!SimplicialComplex methodsFor: 'testing' stamp: 'len 2/19/2017 18:22:52'!
isPure
	| d |
	d _ self dimension.
	^ self facets allSatisfy: [:each| each dimension = d]! !

!SimplicialComplex methodsFor: 'testing' stamp: 'len 2/25/2017 15:13:47'!
isTrivial
	"Answer true if this is the trivial complex, with only one face (the empty simplex)."
	^ self facets size = 1 and: [self facets allSatisfy: [:each| each isTrivial]]! !

!SimplicialComplex methodsFor: 'testing' stamp: 'len 2/19/2017 18:23:52'!
isVoid
	"Answer true if this is the void complex, that has no faces."
	^ self facets isEmpty! !

!SimplicialComplex methodsFor: 'private' stamp: 'len 2/15/2017 16:10:03'!
facets: aCollection
	self propertyAt: #facets put: aCollection! !

!SimplicialComplex methodsFor: 'private' stamp: 'len 4/19/2020 01:28:53'!
pathsFrom: A to: B do: aBlock
	| x |
	A isEmpty ifTrue: [^ aBlock value: A].
	B isEmpty ifTrue: [^ aBlock value: B].
	A size = 1 ifTrue:
		[| v |
		v _ A at: 1.
		^ aBlock value: (B collect: [:w| {v. w}])].
	B size = 1 ifTrue:
		[| w |
		w _ B at: 1.
		^ aBlock value: (A collect: [:v| {v. w}])].
	x _ {A last. B last}.
	self pathsFrom: A allButLast to: B do: [:each| aBlock value: (each copyWith: x)].
	self pathsFrom: A to: B allButLast do: [:each| aBlock value: (each copyWith: x)]! !

!SimplicialComplex methodsFor: 'private' stamp: 'len 2/15/2017 11:20:53'!
species
	^ SimplicialComplex! !

!SimplicialComplex methodsFor: 'private' stamp: 'len 2/24/2017 11:38:54'!
vertices: aCollection
	self propertyAt: #vertices put: aCollection asSet! !

!SimplicialComplex class methodsFor: 'examples' stamp: 'len 2/14/2017 20:39:44'!
kleinBottle
	"A minimal triangulation of the Klein bottle."
	^ self facets: #((2 3 7) (1 2 3) (1 3 5) (1 5 7) (1 4 7) (2 4 6) (1 2 6) (1 6 0) (1 4 0) (2 4 0) (3 4 7) (3 4 6) (3 5 6) (5 6 0) (2 5 0) (2 5 7))! !

!SimplicialComplex class methodsFor: 'examples' stamp: 'len 2/14/2017 20:39:57'!
realProjectivePlane
	"A minimal triangulation of the real projective plane."
	^ self facets: #((0 1 2) (0 2 3) (0 1 5) (0 4 5) (0 3 4) (1 2 4) (1 3 4) (1 3 5) (2 3 5) (2 4 5))! !

!SimplicialComplex class methodsFor: 'examples' stamp: 'len 2/20/2017 08:37:36'!
sphere: n
	"A minimal triangulation of the n-sphere."
	^ self facets: ((Simplex new: n+1) faces: n)! !

!SimplicialComplex class methodsFor: 'examples' stamp: 'len 2/14/2017 20:40:24'!
torus
	"A minimal triangulation of the torus."
	^ self facets: #((0 1 2) (1 2 4) (1 3 4) (1 3 6) (0 1 5) (1 5 6) (2 3 5) (2 4 5) (2 3 6) (0 2 6) (0 3 4) (0 3 5) (4 5 6) (0 4 6))! !

!SimplicialComplex class methodsFor: 'instance creation' stamp: 'len 2/19/2017 08:21:09'!
faces: aCollection
	"Answer a new simplicial complex with the given collection of simplices as faces.
	The faces in aCollection are not assumed to be maximal, so we compute a subset of maximal faces (facets)."
	| faces maximalFaces |
	faces _ Set new: aCollection size.
	aCollection do: [:each|
		(each isKindOf: Simplex)
			ifTrue: [faces add: each]
			ifFalse: [faces add: (each as: Simplex)]].
	faces _ faces asSortedCollection: [:a :b| a dimension <= b dimension].
	maximalFaces _ Set new.
	1 to: faces size do: [:i| | face |
		face _ faces at: i.
		((i+1 to: faces size) anySatisfy: [:j| face <= (faces at: j)])
			ifFalse: [maximalFaces add: face]].
	^ self facets: maximalFaces! !

!SimplicialComplex class methodsFor: 'instance creation' stamp: 'len 2/15/2017 16:10:24'!
facets: aCollection
	"Answer a new simplicial complex with the given collection of simplices as facets.
	The faces in aCollection are assumed to be maximal."
	| facets |
	facets _ Set new: aCollection size.
	aCollection do: [:each|
		(each isKindOf: Simplex)
			ifTrue: [facets add: each]
			ifFalse: [facets add: (each as: Simplex)]].
	^ self new facets: facets! !

!SimplicialComplex class methodsFor: 'instance creation' stamp: 'len 2/24/2017 11:47:54'!
on: aVertexSet faces: aCollection
	"Answer a new simplicial complex with the given collection of simplices as faces.
	The faces in aCollection are not assumed to be maximal, so we compute a subset of maximal faces (facets)."
	^ (self faces: aCollection) vertices: aVertexSet! !

!SimplicialComplex class methodsFor: 'instance creation' stamp: 'len 2/24/2017 11:48:00'!
on: aVertexSet facets: aCollection
	"Answer a new simplicial complex with the given collection of simplices as facets.
	The faces in aCollection are assumed to be maximal."
	^ (self facets: aCollection) vertices: aVertexSet! !

!CoxeterSystem methodsFor: 'as yet unclassified' stamp: 'len 4/5/2018 15:27:04'!
computeDiagram
	| n graph |
	n _ matrix width.
	graph _ Graph unorderedLabeled.
	graph addAll: (1 to: n).
	1 to: n do: [:i|
		1 to: n do: [:j|
			| m |
			m _ matrix at: i@j.
			m = 3 ifTrue: [graph addEdgeFrom: i to: j label: nil].
			m > 3 ifTrue: [graph addEdgeFrom: i to: j label: m]]].
	^ graph! !

!CoxeterSystem methodsFor: 'as yet unclassified' stamp: 'len 4/18/2016 07:54'!
diagram
	^ diagram ifNil: [diagram _ self computeDiagram]! !

!CoxeterSystem methodsFor: 'as yet unclassified' stamp: 'len 4/18/2016 07:57'!
diagram: aGraph
	diagram _ aGraph! !

!CoxeterSystem methodsFor: 'as yet unclassified' stamp: 'len 4/18/2016 07:55'!
matrix
	^ matrix ifNil: [matrix _ self computeMatrix]! !

!CoxeterSystem methodsFor: 'as yet unclassified' stamp: 'len 4/18/2016 07:57'!
matrix: aMatrix
	matrix _ aMatrix! !

!CoxeterSystem methodsFor: 'as yet unclassified' stamp: 'len 5/10/2019 09:57:21'!
presentation
	self notYetImplemented
"	| generators relators |
	generators _ self diagram values collect: [:each| Word x: each].
	relators _ OrderedCollection new.
	self diagram edgesAndLabelsDo: [:each :label|
		label isInfinity
			ifFalse: [relators add: (Word x: each key) * (Word x: each value) ^ (label ifNil: [3])]].
	^ GroupPresentation generators: generators relators: relators"! !

!CoxeterSystem methodsFor: 'as yet unclassified' stamp: 'len 4/18/2016 03:17'!
reflections
	"Answer the conjugates of the generators."
	^ self notYetImplemented! !

!CoxeterSystem methodsFor: 'as yet unclassified' stamp: 'len 4/18/2016 08:02'!
schlafliMatrix
	^ self matrix collect: [:x| -2 * (Float pi / x) cos]! !

!CoxeterSystem methodsFor: 'as yet unclassified' stamp: 'len 4/18/2016 03:28'!
simpleReflections
	^ generators! !

!UpperHalfPlane methodsFor: 'testing' stamp: 'len 12/7/2016 12:11:09'!
includes: anObject
	^ anObject isComplex and: [anObject imaginary > 0]! !

!UpperHalfPlane class methodsFor: 'initialization' stamp: 'len 12/6/2016 22:07:33'!
initialize
	super initialize.
	Smalltalk at: #HH put: self new! !

!ChainComplex methodsFor: 'operations' stamp: 'len 11/4/2020 12:21:37'!
/ aSubcomplex
	"Answer the quotient of the receiver by the argument, equipped with the quotient map."
	^ self class differentials: (differentials with: aSubcomplex differentials collect: [:f :g| (f domain -> (f domain / g domain)) section -> (f codomain / g codomain)]) shift: shift "assuming they are the same degree and length"! !

!ChainComplex methodsFor: 'operations' stamp: 'len 5/14/2019 16:44:49'!
<< n
	"Answer the complex with degrees shifted by n."
	^ self >> n negated! !

!ChainComplex methodsFor: 'operations' stamp: 'len 1/3/2022 10:52:46'!
@ aPrimeIdeal
	"Answer the localization of the receiver at aPrimeIdeal."
	^ self class differentials: (differentials collect: [:each| each @ aPrimeIdeal]) shift: shift! !

!ChainComplex methodsFor: 'operations' stamp: 'len 11/4/2020 12:20:25'!
 aChainComplex
	"Answer the cartesian product (direct sum) of the receiver with the argument."
	^ self class differentials: (differentials with: aChainComplex differentials collect: [:f :g| f  g]) shift: shift "assuming they are the same shift and length"! !

!ChainComplex methodsFor: 'operations' stamp: 'len 11/4/2020 12:20:43'!
 aChainComplex
	"Answer the tensor product of the receiver with the argument."
	^ self class differentials: (differentials with: aChainComplex differentials collect: [:f :g| f  g]) shift: shift "assuming they are the same degree and length"! !

!ChainComplex methodsFor: 'operations' stamp: 'len 11/4/2020 12:20:59'!
dual
	"Answer the dual of the receiver. This is the cochain complex, taking dual in all objects and arrows reversed."
	^ (self class differentials: (self differentials reversed collect: [:each| each adjoint]) shift: shift) opposite! !

!ChainComplex methodsFor: 'operations' stamp: 'len 12/24/2021 08:25:54'!
hom: aCodomain
	^ self class differentials: (differentials collect: [:each| each => aCodomain]) reversed shift: shift! !

!ChainComplex methodsFor: 'operations' stamp: 'len 4/26/2020 04:01:30'!
stupidTruncationAbove: n
	"The 'stupid' truncation above is the subcomplex obtained by making 0 the i-th chain for all i > n."
	^ self notYetImplemented! !

!ChainComplex methodsFor: 'operations' stamp: 'len 4/26/2020 04:01:37'!
stupidTruncationBelow: n
	"The 'stupid' truncation below is the quotient complex obtained by making 0 the i-th chain for all i < n."
	^ self notYetImplemented! !

!ChainComplex methodsFor: 'operations' stamp: 'len 4/26/2020 04:01:58'!
truncationAbove: n
	"The 'stupid' truncation above is the complex obtained by making 0 the i-th chain for all i > n, and replacing the n-th chain with the kernel of the n-th differential.
	This complex has the property that the i-th homology group equals that of the original complex for i >= n and it is 0 for i < n."
	^ self notYetImplemented! !

!ChainComplex methodsFor: 'operations' stamp: 'len 4/26/2020 04:01:52'!
truncationBelow: n
	"The canonical truncation below is the complex obtained by making 0 the i-th chain for all i < n, and replacing the n-th chain with the cokernel of the (n+1)-th differential.
	This complex has the property that the i-th homology group equals that of the original complex for i <= n and it is 0 for i > n."
	^ self notYetImplemented! !

!ChainComplex methodsFor: 'accessing' stamp: 'len 11/4/2020 12:24:50'!
at: k
	"Answer the k-th differential or boundary map d(k):C(k)->C(k-1)."
	^ differentials at: differentials size - k + shift ifAbsent: [(self chains: k) -> (self chains: k-1)]! !

!ChainComplex methodsFor: 'accessing' stamp: 'len 4/22/2020 22:47:36'!
chains
	^ Iterator on: self performing: #chainsDo:! !

!ChainComplex methodsFor: 'accessing' stamp: 'len 11/4/2020 12:24:59'!
chains: k
	| i |
	i _ differentials size - k + shift.
	i < 1 ifTrue: [^ differentials first domain null].
	i = (differentials size + 1) ifTrue: [^ differentials last codomain].
	i > differentials size ifTrue: [^ differentials last codomain null].
	^ (differentials at: i) domain! !

!ChainComplex methodsFor: 'accessing' stamp: 'len 11/4/2020 12:25:07'!
indices
	^ differentials size + shift - 1 to: shift by: -1! !

!ChainComplex methodsFor: 'accessing' stamp: 'len 11/4/2020 12:25:44'!
maxDegree
	^ differentials size - 2 + shift! !

!ChainComplex methodsFor: 'accessing' stamp: 'len 11/4/2020 12:25:37'!
minDegree
	^ shift! !

!ChainComplex methodsFor: 'accessing' stamp: 'len 11/4/2020 12:27:42'!
null
	^ (self chains: self minDegree) null asChainComplex! !

!ChainComplex methodsFor: 'accessing' stamp: 'len 10/30/2020 11:18:14'!
opposite
	^ self propertyAt: #opposite ifAbsentPut: [CochainComplex opposite: self]! !

!ChainComplex methodsFor: 'accessing' stamp: 'len 5/14/2019 16:38:03'!
scalars
	^ differentials anyOne domain scalars! !

!ChainComplex methodsFor: 'comparing' stamp: 'len 11/4/2020 12:17:28'!
= anObject
	self == anObject ifTrue: [^ true].
	(anObject isKindOf: ChainComplex) ifFalse:  [^ super = anObject].
	(self minDegree min: anObject minDegree)
		to: (self maxDegree max: anObject maxDegree)
		do: [:i| (self at: i) = (anObject at: i) ifFalse: [^ false]].
	^ true! !

!ChainComplex methodsFor: 'comparing' stamp: 'len 4/22/2020 18:00:00'!
~ aChainComplex
	"Answer true if the receiver is isomorphic to the argument."
	^ self notYetImplemented "or should it be 'homotopy equivalent'?"! !

!ChainComplex methodsFor: 'comparing' stamp: 'len 4/22/2020 22:05:16'!
hash
	| answer |
	answer _ 0.
	differentials do: [:each| each isZero ifFalse: [answer _ answer hashMultiply + each hash]].
	^ answer! !

!ChainComplex methodsFor: 'enumerating' stamp: 'len 4/22/2020 22:47:53'!
chainsDo: aBlock
	differentials do: [:each| aBlock value: each domain].
	aBlock value: differentials last codomain! !

!ChainComplex methodsFor: 'homology' stamp: 'len 11/4/2020 12:27:09'!
betti
	^ (self minDegree to: self maxDegree) collect: [:i| self betti: i]! !

!ChainComplex methodsFor: 'homology' stamp: 'len 2/25/2017 07:17:45'!
betti: k
	"Answer the k-th Betti number.
	This is the rank of the k-th homology group.
	For singular homology this gives a measure of the number of k-dimensional holes."
	^ (self homology: k) rank! !

!ChainComplex methodsFor: 'homology' stamp: 'len 4/22/2020 14:15:25'!
boundaries: k
	"Answer the group of k-boundaries B(k), a subgroup of the group of k-chains C(k).
	This is the image of the k+1-th differential d(k+1)."
	^ (self at: k+1) image! !

!ChainComplex methodsFor: 'homology' stamp: 'len 4/22/2020 14:15:37'!
cycles: k
	"Answer the group of k-cycles Z(k), a subgroup of the group of k-chains C(k).
	This is the kernel of the k-th differential d(k)."
	^ (self at: k) kernel! !

!ChainComplex methodsFor: 'homology' stamp: 'len 2/24/2017 19:00:35'!
homology: k
	"Answer the k-th homology group H(k).
	This is the quotient of the k-cycles Z(k) modulo the k-boundaries B(k)."
	^ (self cycles: k) / (self boundaries: k)! !

!ChainComplex methodsFor: 'morphisms' stamp: 'len 7/29/2020 08:33:12'!
id
	"Answer the identity morphism."
	^ self propertyAt: #id ifAbsentPut: [ChainMap from: self to: self components: (self chains collect: [:each| each id])]! !

!ChainComplex methodsFor: 'morphisms' stamp: 'len 12/22/2021 14:54:44'!
to: aCodomain
"	((aCodomain isKindOf: ChainComplex) and: [self scalars = aCodomain scalars])
		ifFalse: [^ nil].
	..."
	^ super to: aCodomain! !

!ChainComplex methodsFor: 'testing' stamp: 'len 11/4/2020 12:27:18'!
isExact
	self minDegree to: self maxDegree do: [:i| (self isExactAt: i) ifFalse: [^ false]].
	^ true! !

!ChainComplex methodsFor: 'testing' stamp: 'len 4/29/2020 12:39:17'!
isExactAt: anInteger
	^ (self at: anInteger) image = (self at: anInteger-1) kernel! !

!ChainComplex methodsFor: 'testing' stamp: 'len 4/22/2020 22:47:01'!
isTrivial
	^ self chains allSatisfy: [:each| each isTrivial]! !

!ChainComplex methodsFor: 'private' stamp: 'len 4/28/2019 07:03:42'!
differentials
	"Answer the differentials, ordered as d(n) -> ... -> d(1) -> d(0)."
	^ differentials! !

!ChainComplex methodsFor: 'private' stamp: 'len 11/4/2020 12:24:18'!
differentials: anArray shift: anInteger
	differentials _ anArray.
	shift _ anInteger! !

!ChainComplex methodsFor: 'private' stamp: 'len 11/4/2020 12:26:45'!
shift
	^ shift! !

!ChainComplex methodsFor: 'private' stamp: 'len 11/4/2020 12:28:18'!
verify
	| n |
	n _ self maxDegree.
	(self at: n+1) kernel isTrivial ifFalse: [^ false halt].
	(self at: self minDegree) image isTrivial ifFalse: [^ false halt].
	n+1 to: self minDegree + 1 by: -1 do: [:i|
		(self at: i) codomain = (self at: i-1) domain ifFalse: [^ false halt].
		(self at: i) image <= (self at: i-1) kernel ifFalse: [^ false halt]].
	^ true! !

!ChainComplex class methodsFor: 'examples' stamp: 'len 5/23/2020 08:59:30'!
kleinBottle
	"The chain complex associated to a triangulation of the Klein bottle:"
	^ SimplicialComplex kleinBottle chainComplexOver: ! !

!ChainComplex class methodsFor: 'instance creation' stamp: 'len 11/4/2020 12:19:26'!
differentials: anArray
	^ self differentials: anArray shift: 0! !

!ChainComplex class methodsFor: 'instance creation' stamp: 'len 11/4/2020 12:21:24'!
differentials: anArray shift: anInteger
	^ self new differentials: anArray shift: anInteger! !

!Sheaf methodsFor: 'accessing' stamp: 'len 12/23/2021 14:56:44'!
@ aPoint
	"Answer the module corresponding to the stalk at aPoint."
	^ self asModule over: (self space at: aPoint)! !

!Sheaf methodsFor: 'accessing' stamp: 'len 12/13/2021 18:07:52'!
space
	^ self propertyAt: #space! !

!Sheaf methodsFor: 'converting' stamp: 'len 12/13/2021 18:07:32'!
asModule
	^ self propertyAt: #module! !

!Sheaf methodsFor: 'morphisms' stamp: 'len 12/24/2021 08:29:16'!
hom: aSheaf
	self assert: ((aSheaf isKindOf: Sheaf) and: [aSheaf space = self space]).
	^ HomSheaf from: self to: aSheaf! !

!Sheaf methodsFor: 'operations' stamp: 'len 12/13/2021 18:10:51'!
 aSheaf
	self assert: ((aSheaf isKindOf: Sheaf) and: [aSheaf space = self space]).
	^ Sheaf module: self asModule  aSheaf asModule on: self space! !

!Sheaf methodsFor: 'operations' stamp: 'len 12/13/2021 18:11:29'!
 aSheaf
	self assert: ((aSheaf isKindOf: Sheaf) and: [aSheaf space = self space]).
	^ Sheaf module: self asModule  aSheaf asModule on: self space! !

!Sheaf methodsFor: 'operations' stamp: 'len 12/13/2021 18:11:07'!
dual
	^ Sheaf module: self asModule dual space: self space! !

!Sheaf methodsFor: 'testing' stamp: 'len 12/13/2021 18:12:04'!
isTrivial
	^ self asModule isTrivial! !

!Sheaf methodsFor: 'private' stamp: 'len 12/21/2021 20:46:17'!
module: aGradedModule
	self propertyAt: #module put: aGradedModule! !

!Sheaf methodsFor: 'private' stamp: 'len 12/21/2021 20:46:31'!
space: aScheme
	self propertyAt: #space put: aScheme! !

!Sheaf methodsFor: 'private' stamp: 'len 12/27/2021 08:18:16'!
species
	^ Sheaf! !

!Sheaf class methodsFor: 'as yet unclassified' stamp: 'len 12/21/2021 20:45:36'!
module: aGradedModule on: aScheme
	^ self new module: aGradedModule; space: aScheme! !

!HomSheaf methodsFor: 'accessing' stamp: 'len 12/21/2021 20:32:43'!
codomain
	^ self propertyAt: #codomain! !

!HomSheaf methodsFor: 'accessing' stamp: 'len 12/21/2021 20:32:38'!
domain
	^ self propertyAt: #domain! !

!HomSheaf methodsFor: 'accessing' stamp: 'len 12/13/2021 18:08:01'!
space
	^ self domain space! !

!HomSheaf methodsFor: 'converting' stamp: 'len 12/13/2021 18:08:22'!
asModule
	^ self domain asModule => self codomain asModule! !

!HomSheaf methodsFor: 'private' stamp: 'len 12/21/2021 20:40:44'!
codomain: aSheaf
	self propertyAt: #codomain put: aSheaf! !

!HomSheaf methodsFor: 'private' stamp: 'len 12/21/2021 20:40:39'!
domain: aSheaf
	self propertyAt: #domain put: aSheaf! !

!HomSheaf class methodsFor: 'instance creation' stamp: 'len 12/21/2021 20:31:53'!
from: aDomain to: aCodomain
	^ self new domain: aDomain; codomain: aCodomain; module: aDomain asModule => aCodomain asModule! !

!Morphism methodsFor: 'accessing' stamp: 'len 4/22/2020 14:43:39'!
codomain
	^ self propertyAt: #codomain! !

!Morphism methodsFor: 'accessing' stamp: 'len 4/22/2020 14:43:43'!
domain
	^ self propertyAt: #domain! !

!Morphism methodsFor: 'accessing' stamp: 'len 5/29/2020 10:16:04'!
identity
	self isEndomorphism ifFalse: [^ DomainError signal: 'not an endomorphism'].
	^ self domain id! !

!Morphism methodsFor: 'accessing' stamp: 'len 12/24/2021 08:16:27'!
parent
	"A morphism f:A->B belongs to Hom(A,B)."
	^ self domain => self codomain! !

!Morphism methodsFor: 'printing' stamp: 'len 5/2/2020 09:34:13'!
arrow
	^ Text streamContents: [:s | self arrowPrintOn: s]! !

!Morphism methodsFor: 'printing' stamp: 'len 4/22/2020 14:37:56'!
arrowPrintOn: aStream
	aStream
		print: self domain;
		nextPut:
			((self propertyAt: #inverse ifAbsent: []) notNil
				ifTrue: [$]
				ifFalse:
					[(self propertyAt: #retraction ifAbsent: []) notNil
						ifTrue: [$]
						ifFalse:
							[(self propertyAt: #section ifAbsent: []) notNil
								ifTrue: [$]
								ifFalse: [$]]]);
		print: self codomain! !

!Morphism methodsFor: 'printing' stamp: 'len 4/22/2020 14:36:41'!
name: aString
	self propertyAt: #name put: aString! !

!Morphism methodsFor: 'comparing' stamp: 'len 4/22/2020 14:43:11'!
hash
	^ self domain hash hashMultiply + self codomain hash! !

!Morphism methodsFor: 'operations' stamp: 'len 3/13/2020 06:18:07'!
-> aCodomain
	"Answer the composition with the canonical morphism from the codomain of the receiver to aCodomain. See also Domain>>->."
	^ self codomain -> aCodomain ifNotNil: [:aMorphism| aMorphism  self]! !

!Morphism methodsFor: 'operations' stamp: 'len 12/25/2021 11:56:21'!
=> aCodomain
	"This is the Hom(-,B) functor, where B is the argument.
	If the receiver is a morphism g:X->Y, answer the morphism Hom(g,B):Hom(Y,B)->Hom(X,B) that sends a morphism f to f composed with g.
	This is a contravariant functor, and it is often called the 'functor of points' of B."
	^ self codomain => aCodomain to: self domain => aCodomain evaluating: [:f| f  self]! !

!Morphism methodsFor: 'operations' stamp: 'len 8/11/2020 08:47:16'!
^ anInteger
	"Answer the receiver composed with itself anInteger times.
	If the argument is another morphism, answer the conjugation."
	anInteger isInteger ifFalse: [^ anInteger inverse  self  anInteger].
	anInteger = 1 ifTrue: [^ self].
	anInteger = 0 ifTrue: [^ self identity].
	anInteger < 0 ifTrue: [^ self inverse ^ anInteger negated].
	^ anInteger even ifTrue: [self  self ^ (anInteger // 2)] ifFalse: [self  self ^ (anInteger // 2)  self]! !

!Morphism methodsFor: 'operations' stamp: 'len 3/13/2020 06:12:50'!
 aMorphism
	"Answer the composition of the receiver with the argument.
	Given the argument f:X -> Y and the receiver g:Y -> Z, answer gf:X -> Z."
	^ self subclassResponsibility! !

!Morphism methodsFor: 'operations' stamp: 'len 8/8/2016 06:42'!
coimage
	^ self domain / self kernel! !

!Morphism methodsFor: 'operations' stamp: 'len 8/9/2020 19:49:42'!
coimageMap
	^ self domain -> self coimage! !

!Morphism methodsFor: 'operations' stamp: 'len 8/8/2016 06:42'!
cokernel
	^ self codomain / self image! !

!Morphism methodsFor: 'operations' stamp: 'len 8/9/2020 19:50:56'!
cokernelMap
	^ self codomain -> self cokernel! !

!Morphism methodsFor: 'operations' stamp: 'len 5/3/2020 10:06:33'!
commutator: aMorphism
	^ self inverse  aMorphism inverse  self  aMorphism! !

!Morphism methodsFor: 'operations' stamp: 'len 4/22/2020 14:39:46'!
image
	^ self propertyAt: #image ifAbsent: [self domain apply: self]! !

!Morphism methodsFor: 'operations' stamp: 'len 8/11/2020 19:52:51'!
imageMap
	^ self image -> self codomain! !

!Morphism methodsFor: 'operations' stamp: 'len 4/22/2020 14:39:01'!
inverse
	"Answer a two-sided inverse of the receiver (i.e., a morphism that is both a retraction and a section) or nil."
	^ self propertyAt: #inverse! !

!Morphism methodsFor: 'operations' stamp: 'len 8/11/2020 19:53:19'!
kernelMap
	^ self kernel -> self domain! !

!Morphism methodsFor: 'operations' stamp: 'len 4/22/2020 14:39:16'!
retraction
	"Answer a left inverse of the receiver or nil."
	^ self propertyAt: #retraction ifAbsent: [self inverse]! !

!Morphism methodsFor: 'operations' stamp: 'len 4/22/2020 14:39:33'!
section
	"Answer a right inverse of the receiver or nil."
	^ self propertyAt: #section ifAbsent: [self inverse]! !

!Morphism methodsFor: 'properties' stamp: 'len 4/22/2020 14:34:34'!
hasProperty: aSymbol
	^ (properties ifNil: [^ false]) includesKey: aSymbol! !

!Morphism methodsFor: 'properties' stamp: 'len 4/22/2020 14:34:48'!
properties
	^ properties ifNil: [properties _ IdentityDictionary new]! !

!Morphism methodsFor: 'properties' stamp: 'len 4/22/2020 14:34:53'!
propertyAt: aSymbol
	^ self propertyAt: aSymbol ifAbsent: [self error: 'no such property']! !

!Morphism methodsFor: 'properties' stamp: 'len 4/22/2020 14:34:57'!
propertyAt: aSymbol ifAbsent: exceptionBlock
	^ (properties ifNil: [^ exceptionBlock value]) at: aSymbol ifAbsent: exceptionBlock! !

!Morphism methodsFor: 'properties' stamp: 'len 4/22/2020 14:35:01'!
propertyAt: aSymbol ifAbsentPut: aBlock
	^ self properties at: aSymbol ifAbsentPut: aBlock! !

!Morphism methodsFor: 'properties' stamp: 'len 4/22/2020 14:35:06'!
propertyAt: aSymbol ifPresent: aBlock
	^ (properties ifNil: [^ nil]) at: aSymbol ifPresent: aBlock! !

!Morphism methodsFor: 'properties' stamp: 'len 4/22/2020 14:35:11'!
propertyAt: aSymbol put: anObject
	^ self properties at: aSymbol put: anObject! !

!Morphism methodsFor: 'testing' stamp: 'len 8/8/2016 06:02'!
isAutomorphism
	^ self isEndomorphism and: [self isIsomorphism]! !

!Morphism methodsFor: 'testing' stamp: 'len 4/22/2020 06:00:10'!
isElement
	"Answer true if the receiver is an element of a Domain, i.e. if it understands the message #parent and answers its parent Domain.
	The parent of a morphism is a hom set."
	^ true! !

!Morphism methodsFor: 'testing' stamp: 'len 8/8/2016 06:02'!
isEndomorphism
	^ self domain = self codomain! !

!Morphism methodsFor: 'testing' stamp: 'len 12/25/2021 12:01:21'!
isEpimorphism
	"Answer true if the receiver is right cancelable: a morphism f:A->B is an epimorphism if, for any pair of morphisms g:B->C, h:B->C, gf = hf implies g = h."
	^ self subclassResponsibility! !

!Morphism methodsFor: 'testing' stamp: 'len 3/13/2020 06:18:30'!
isIdempotent
	^ self isEndomorphism and: [self  self = self]! !

!Morphism methodsFor: 'testing' stamp: 'len 11/16/2016 08:33'!
isIdentity
	^ self = self domain id! !

!Morphism methodsFor: 'testing' stamp: 'len 5/16/2019 12:42:32'!
isIsomorphism
	^ self inverse notNil! !

!Morphism methodsFor: 'testing' stamp: 'len 12/25/2021 12:01:52'!
isMonomorphism
	"Answer true if the receiver is left cancelable: a morphism f:A->B is a monomorphism if, for any pair of morphisms g:C->A, h:C->A, fg = fh implies g = h."
	^ self subclassResponsibility! !

!Morphism methodsFor: 'testing' stamp: 'len 5/8/2020 17:57:22'!
isMorphism
	^ true! !

!Morphism methodsFor: 'testing' stamp: 'len 12/25/2021 12:15:27'!
isRetraction
	"A split epimorphism is a morphism that has a section (a right inverse).
	Dualy, a split epimorphism is a morphism that *is* a retraction (a left inverse)."
	^ self section notNil! !

!Morphism methodsFor: 'testing' stamp: 'len 12/25/2021 12:15:43'!
isSection
	"A split monomorphism is a morphism that has a retraction (a left inverse).
	Dualy, a split monomorphism is a morphism that *is* a section (a right inverse)."
	^ self retraction notNil! !

!Morphism methodsFor: 'testing' stamp: 'len 12/10/2016 12:59:06'!
isTrivial
	^ self kernel = self domain! !

!Morphism methodsFor: 'private' stamp: 'len 4/22/2020 14:44:26'!
codomain: aDomain
"	(aDomain isKindOf: Domain) ifFalse: [^ DomainError signal: 'not a Domain']."
	self propertyAt: #codomain put: aDomain! !

!Morphism methodsFor: 'private' stamp: 'len 4/22/2020 14:44:20'!
domain: aDomain
"	(aDomain isKindOf: Domain) ifFalse: [^ DomainError signal: 'not a Domain']."
	self propertyAt: #domain put: aDomain! !

!Morphism class methodsFor: 'examples' stamp: 'len 8/11/2020 08:50:51'!
example1Embedding
	"Here we construct Q[x], the ring of univariate polynomials over the rational numbers.
	It comes equipped with a canonical embedding from the rational numbers to the constant polynomials."
	| R phi F psi |
	R _  polynomials.
	phi _  -> R.
	"Then we construct its field of fractions Q(x) (the rational functions),
	that comes with a cannonical embedding from the polynomial ring to the rational functions with denominator 1 (the localization map)."
	F _ R fractions.
	psi _ R -> F.
	"If we compose them we get an embedding from the rational numbers Q to the field of univariate rational functions Q(x), that sends a number to a constant rational function."
	^ psi  phi! !

!Morphism class methodsFor: 'examples' stamp: 'len 8/11/2020 08:50:57'!
example2EasierEmbedding
	"Another way to obtain the canonical embedding from Q to the rational functions over Q."
	^  ->  polynomials fractions! !

!Morphism class methodsFor: 'examples' stamp: 'len 5/23/2020 09:34:55'!
example3CanonicalMorphism
	"Canonical morphisms can be retrieved through the message #->.
	More specific messages #>-> and #->> are also available
	(for monomorphisms and epimorphisms respectively). 
	For example, Z (the ring of integers) is the initial object in
	the category of commutative rings with unit, i.e. there's
	a canonical morphism from Z to any commutative ring:"
	^  -> ( polynomialsIn: #(x y z))! !

!Morphism class methodsFor: 'examples' stamp: 'len 5/23/2020 09:33:01'!
example4CanonicalMorphism
	"The quotient map from a polynomial ring R to a quotient by
	one of its ideals R/I is another example of canonical morphism."
	| R x I |
	R _  polynomials.
	x _ R x.
	I _ R * (x squared + 1).
	^ R -> (R / I)! !

!Morphism class methodsFor: 'examples' stamp: 'len 5/23/2020 09:34:55'!
example5CanonicalMorphism
	"The message #-> can be sent to a Morphism with a Domain as
	argument, or to a Domain with a Morphism as argument.
	This yields canonical constructions.
	For example, given an arbitrary ring homomorphism,
	we can send it *canonically* to a quotient of its codomain."
	| R phi x I |
	R _ (/5) polynomials. "univariate polynomials over Z/<5>"
	phi _ R frobenius. "the Frobenius endomorphism"
	x _ R x.
	I _ R * (x squared + 1).
	^ phi -> (R / I)! !

!Morphism class methodsFor: 'examples' stamp: 'len 12/23/2021 15:42:14'!
example6Projections
	"Algebraic structures often come equipped with some canonical morphisms.
	Here we construct the direct product of the ring of rational integers
	with the field of rational numbers, and get the projections to each component."
	^    -< {. }! !

!Morphism class methodsFor: 'examples' stamp: 'len 12/23/2021 15:47:09'!
example7Embeddings
	"Algebraic structures often come equipped with some canonical morphisms.
	Here we construct the direct sum of two vector spaces,
	and get the embedding from the first component."
	| V W |
	V _ ^3.
	W _ ^2.
	^ {V. W} >- (V  W) at: 1! !

!Morphism class methodsFor: 'examples' stamp: 'len 8/11/2020 08:59:12'!
example8GLAsGroupAction
	"The action of the group GL(3,Q) on the vector space of dimension 3 over the rationals.
	The action is evaluation of a linear map at a vector."
	^ (^3) automorphisms action! !

!Function methodsFor: 'comparing' stamp: 'len 12/23/2021 15:29:25'!
= anObject
	self == anObject ifTrue: [^ true].
	(anObject isKindOf: Function) ifFalse: [^ false].
	(self domain = anObject domain and: [self codomain = anObject codomain]) ifFalse: [^ false].
	self domain isFinite ifFalse: [^ self error: 'infinite domain'].
	self domain do: [:each| (self value: each) = (anObject value: each) ifFalse: [^ false]].
	^ true! !

!Function methodsFor: 'converting' stamp: 'len 12/23/2021 15:29:25'!
asFunction
	self class = Function ifTrue: [^ self].
	^ self domain carrier to: self codomain carrier evaluating: self! !

!Function methodsFor: 'operations' stamp: 'len 5/1/2020 17:11:54'!
, aFunction
	"Answer the cartesian product of the receiver with the argument."
	^ (self domain, aFunction domain)
		to: (self codomain, aFunction codomain)
		evaluating: [:each| {self value: (each at: 1). aFunction value: (each at: 2)}]! !

!Function methodsFor: 'operations' stamp: 'len 5/1/2020 22:11:12'!
 aFunction
	"Answer the composition of the receiver with the argument.
	Given the argument f:X -> Y and the receiver g:Y -> Z, answer gf:X -> Z.
	This is, (gf)(x) = g(f(x))."
	self domain = aFunction codomain ifFalse: [^ DomainError signal: 'domains don''t match'].
	"self category = aFunction category ifFalse: [^ DomainError signal: 'categories don''t match']."
	^ aFunction domain to: self codomain evaluating: [:x| self value: (aFunction value: x)]! !

!Function methodsFor: 'operations' stamp: 'len 12/23/2021 15:29:05'!
 aFunction
	"Answer the product of the receiver with the argument."
	^ self, aFunction! !

!Function methodsFor: 'operations' stamp: 'len 3/3/2021 07:30:54'!
value: anElement
	^ (self propertyAt: #expression) value: anElement
"	^ self codomain !! ((self propertyAt: #expression) value: self domain !! anElement)"! !

!Function methodsFor: 'operations' stamp: 'len 11/5/2016 09:33'!
valueWithArguments: anArray
	^ self value: (self domain scalars tuple: anArray)! !

!Function methodsFor: 'testing' stamp: 'len 7/5/2021 12:49:55'!
imageContains: anElement
	^ self image contains: anElement! !

!Function methodsFor: 'testing' stamp: 'len 5/10/2019 07:30:02'!
isAbelianGroupHomomorphism
	(self domain isAbelianGroup and: [self codomain isAbelianGroup]) ifFalse: [^ false].
	self domain isFinite ifFalse: [^ self error: 'infinite domain'].
	^ self domain allSatisfy: [:x|
		self domain allSatisfy: [:y|
			(self value: x) + (self value: y) = (self value: x + y)]]! !

!Function methodsFor: 'testing' stamp: 'len 8/9/2019 13:25:28'!
isAlgebraHomomorphism
	"Answer true if the receiver is a (unital) K-algebra homomorphism,
	i.e. a ring homomorphism that satisfies f(ka) = kf(a)."
	| K codomainOne domainOne |
	self isRingHomomorphism ifFalse: [^ false].
	(K _ self domain scalars) = self codomain scalars ifFalse: [^ false].
	K isFinite ifFalse: [^ self error: 'infinite domain'].
	domainOne _ self domain one.
	codomainOne _ self codomain one.
	^ K allSatisfy: [:each| (self value: domainOne * each) = (codomainOne * each)]! !

!Function methodsFor: 'testing' stamp: 'len 4/16/2016 18:53'!
isBiyective
	^ self isInjective and: [self isSurjective]! !

!Function methodsFor: 'testing' stamp: 'len 12/25/2021 12:02:44'!
isEpimorphism
	"Answer true if the receiver is right cancelable: a morphism f:A->B is an epimorphism if, for any pair of morphisms g:B->C, h:B->C, gf = hf implies g = h.
	In the category of sets epimorphisms are surjections." 
	^ self isSurjective! !

!Function methodsFor: 'testing' stamp: 'len 5/19/2018 17:54:16'!
isEvaluable
	^ true! !

!Function methodsFor: 'testing' stamp: 'len 5/10/2019 07:29:16'!
isGroupHomomorphism
	(self domain isGroup and: [self codomain isGroup]) ifFalse: [^ false].
	self domain isFinite ifFalse: [^ self error: 'infinite domain'].
	^ self domain allSatisfy: [:x|
		self domain allSatisfy: [:y|
			(self value: x)(self value: y) = (self value: xy)]]! !

!Function methodsFor: 'testing' stamp: 'len 12/28/2016 11:10:18'!
isIdentity
	^ self propertyAt: #isIdentity ifAbsentPut: [self = self domain id]! !

!Function methodsFor: 'testing' stamp: 'len 5/16/2019 12:14:30'!
isInjective
	^ self retraction notNil! !

!Function methodsFor: 'testing' stamp: 'len 5/10/2019 07:38:30'!
isModuleHomomorphism
	(self domain isModule and: [self codomain isModule]) ifFalse: [^ false].
	self domain scalars = self codomain scalars ifFalse: [^ false].
	self domain isFinite ifFalse: [^ self error: 'infinite domain'].
	^ self domain allSatisfy: [:x|
		self domain allSatisfy: [:y|
			| z |
			(z _ self value: x) + (self value: y) = (self value: x + y) and:
				[self domain scalars allSatisfy: [:r| z * r = (self value: x * r)]]]]! !

!Function methodsFor: 'testing' stamp: 'len 4/26/2020 08:16:22'!
isMonoidHomomorphism
	(self domain isMonoid and: [self codomain isMonoid]) ifFalse: [^ false].
	self domain isFinite ifFalse: [^ self error: 'infinite domain'].
	^ self domain allSatisfy: [:x|
		self domain allSatisfy: [:y|
			(self value: x)(self value: y) = (self value: xy)]]! !

!Function methodsFor: 'testing' stamp: 'len 12/25/2021 12:03:05'!
isMonomorphism
	"Answer true if the receiver is left cancelable: a morphism f:A->B is a monomorphism if, for any pair of morphisms g:C->A, h:C->A, fg = fh implies g = h.
	In the category of sets monomorphisms are injections." 
	^ self isInjective! !

!Function methodsFor: 'testing' stamp: 'len 5/10/2019 07:34:08'!
isRingHomomorphism
	(self domain isRing and: [self codomain isRing]) ifFalse: [^ false].
	self domain isFinite ifFalse: [^ self error: 'infinite domain'].
	(self value: self domain one) = self codomain one ifFalse: [^ false].
	^ self domain allSatisfy: [:x|
		self domain allSatisfy: [:y|
			(self value: x) + (self value: y) = (self value: x + y) and:
				[(self value: x) * (self value: y) = (self value: x * y)]]]! !

!Function methodsFor: 'testing' stamp: 'len 5/16/2019 12:16:02'!
isSurjective
	^ self section notNil! !

!Function methodsFor: 'private' stamp: 'len 12/23/2021 15:29:25'!
expression: anObject
	self propertyAt: #expression put: ((anObject isKindOf: Function) ifTrue: [anObject propertyAt: #expression ifAbsent: [anObject]] ifFalse: [anObject])! !

!Function class methodsFor: 'class initialization' stamp: 'len 12/23/2021 13:47:29'!
initialize
	super initialize.
	Smalltalk at: #Sets put: (Category new name: #Sets)! !

!Function class methodsFor: 'examples' stamp: 'len 5/23/2020 09:34:55'!
example1Function1
	" is the ring of rational integers, and it has an underying set of elements (rational integers), that can be accessed by sending the message #carrier. We can use this to create a function on the set of integers:"
	 carrier to:  carrier evaluating: [:x| x squared + 1]! !

!Function class methodsFor: 'examples' stamp: 'len 5/23/2020 09:30:27'!
example1Function2
	"The function 'x^2 + 1' on the set of natural numbers.
	This is a Sequence, i.e. function with domain the natural numbers."
	^  to:  evaluating: [:x| x squared + 1]! !

!Function class methodsFor: 'examples' stamp: 'len 5/23/2020 09:33:01'!
example2Morphism1
	"This is the most common way to define morphisms.
	^3 is the vector space of 3-tuples with rational coefficients,
	and this defines a linear map on it (an endomorphism)
	by sending the message #to:evaluating: to the vector space.
	This creates an instance of ModuleMap."
	^ ^3 to: ^3 evaluating: [:v| (v x - v y, v x, v z)]! !

!Function class methodsFor: 'examples' stamp: 'len 5/23/2020 09:33:01'!
example2Morphism12
	"This, on the other hand, is a function on the underlying set of
	^3. Is is a morphism in the category of sets, but is not a morphism
	of vector spaces. This creates an instance of Function."
	^ (^3) carrier to: (^3) carrier evaluating: [:v| (v x - v y, v x, v z)]! !

!Function class methodsFor: 'examples' stamp: 'len 5/23/2020 09:33:01'!
example2Morphism2
	"Here's another way to define the same morphism,
	by creating vector space Hom(Q^3, Q^3) of linear maps
	and sending the message #evaluating: to it."
	^ ^3 => (^3) evaluating: [:v| (v x - v y, v x, v z)]! !

!Function class methodsFor: 'examples' stamp: 'len 5/23/2020 09:33:01'!
example2Morphism22
	"Or equivalently, creating Hom(Q^3, Q^3) and coercing
	a Smalltalk block into an element of the Hom vector space."
	^ ^3 => (^3) !! [:v| (v x - v y, v x, v z)]! !

!Function class methodsFor: 'examples' stamp: 'len 5/23/2020 09:33:01'!
example2Morphism3
	"And yet another way. Here Hom(Q^3, Q^3) is created
	by sending the message #endomorphisms to the vector space."
	^ (^3) endomorphisms !! [:v| (v x - v y, v x, v z)]! !

!Function class methodsFor: 'examples' stamp: 'len 5/23/2020 09:34:55'!
example3Frobenius1
	"One way to define the Frobenius ring homomorphism."
	^ ( / 6) endomorphisms !! [:x| x^6]! !

!Function class methodsFor: 'examples' stamp: 'len 5/23/2020 09:34:55'!
example3Frobenius2
	"The Frobenius ring homomorphism defined by a polynomial."
	| R x |
	R _  / 6.
	x _ R polynomials x.
	^ R endomorphisms evaluating: x ^ 6! !

!Function class methodsFor: 'instance creation' stamp: 'len 7/7/2020 09:15:30'!
from: aDomain to: aCodomain evaluating: anExpression
	^ self new domain: aDomain; codomain: aCodomain; expression: anExpression! !

!Function class methodsFor: 'instance creation' stamp: 'len 10/17/2016 10:43'!
from: aDomain to: aCodomain evaluatingWithArguments: aBlock
	^ self from: aDomain to: aCodomain evaluating: [:each| aBlock valueWithArguments: each asArray]! !

!Functor class methodsFor: 'class initialization' stamp: 'len 4/26/2020 17:41:52'!
initialize
	super initialize.
	Smalltalk at: #Categories put: (Category new name: #Categories)! !

!MonoidMap methodsFor: 'operations' stamp: 'len 7/31/2021 12:35:01'!
value: anElement
	| answer images |
	self propertyAt: #expression ifPresent: [:anObject| ^ anObject value: anElement].
	answer _ self codomain identity.
	images _ self images.
	self domain \ anElement do: [:i :exponent| answer _ answer  ((images at: i) ^ exponent)].
	^ answer! !

!MonoidMap methodsFor: 'testing' stamp: 'len 4/26/2020 06:34:36'!
isContinuous
	"Answer true if the receiver is continuous (also called non-erasing)."
	^ self domain generators noneSatisfy: [:each| (self value: each) = self codomain identity]! !

!MonoidMap methodsFor: 'testing' stamp: 'len 12/25/2021 12:12:18'!
isEpimorphism
	"Answer true if the receiver is right cancelable: a morphism f:A->B is an epimorphism if, for any pair of morphisms g:B->C, h:B->C, gf = hf implies g = h.
	In the category of monoids not all epimorphisms are surjective."
	self isSurjective ifTrue: [^ true].
	^ self notYetImplemented! !

!MonoidMap methodsFor: 'testing' stamp: 'len 4/26/2020 08:16:41'!
isMonoidHomomorphism
	^ true! !

!MonoidMap methodsFor: 'testing' stamp: 'len 4/26/2020 06:33:06'!
isTrivial
	^ self domain generators allSatisfy: [:each| (self value: each) = self codomain identity]! !

!MonoidMap methodsFor: 'private' stamp: 'len 4/26/2020 08:16:53'!
images
	^ self propertyAt: #images! !

!MonoidMap methodsFor: 'private' stamp: 'len 4/26/2020 08:16:47'!
images: anArray
	self propertyAt: #images put: anArray! !

!MonoidMap methodsFor: 'private' stamp: 'len 4/26/2020 08:14:10'!
species
	^ MonoidMap! !

!MonoidMap methodsFor: 'private' stamp: 'len 4/26/2020 08:16:33'!
verify
	^ super isMonoidHomomorphism! !

!MonoidMap class methodsFor: 'initialization' stamp: 'len 4/26/2020 17:55:12'!
initialize
	super initialize.
	Smalltalk at: #Monoids put: (Category new name: #Monoids)! !

!MonoidMap class methodsFor: 'instance creation' stamp: 'len 8/7/2020 15:06:35'!
from: aDomain to: aCodomain mapping: aBlock
	^ self new domain: aDomain; codomain: aCodomain; images: ((1 to: aDomain generators size) collect: [:i| aBlock value: i])! !

!GroupAction methodsFor: 'accessing' stamp: 'len 6/29/2016 08:46'!
degree
	^ self space size! !

!GroupAction methodsFor: 'accessing' stamp: 'len 2/13/2016 06:31'!
fixedPoints
	^ self space select: [:each| self isFixedPoint: each]! !

!GroupAction methodsFor: 'accessing' stamp: 'len 6/22/2016 07:36'!
fixedPointsOf: anElement
	"Dual idea to the stabilizer. The fixed points are the orbits of size 1."
	^ self space select: [:each| (self value: {anElement. each}) = each]! !

!GroupAction methodsFor: 'accessing' stamp: 'len 2/13/2016 08:02'!
group
	^ self domain at: 1! !

!GroupAction methodsFor: 'accessing' stamp: 'len 7/27/2016 07:31'!
kernel
	"This is also the intersection of all the stabilizers."
	^ self group select: [:g| self space allSatisfy: [:x| (self value: {g.x}) = x]]
	"^ self asPermutationRepresentation kernel"! !

!GroupAction methodsFor: 'accessing' stamp: 'len 1/28/2018 22:44:43'!
orbitOf: aPoint
	"Answer the set of points to which aPoint can be 'moved' by elements of the group G.
	All the orbits form a partition of the underlying set (space) X, and it's written X/G and called the quotient of the action. In geometric situations it may be called the orbit space, and in algebraic situations it is called the space of coinvariants (in contrast with the space of invariants, that are the fixed points)."
	| answer |
	self group generators
		ifNotNil: [:S| ^ (SchreierTree root: aPoint generators: S action: self) orbit].
	answer _ Set new.
	self group do: [:each| answer add: (self value: {each. aPoint})].
	^ answer! !

!GroupAction methodsFor: 'accessing' stamp: 'len 5/16/2016 05:28'!
orbits
	"Answer the quotient of the action, also called space of orbits in geometric situations and space of coinvariants in algebraic situations."
	| answer |
	answer _ Set new.
	self space do: [:each| answer add: (self orbitOf: each)].
	^ answer! !

!GroupAction methodsFor: 'accessing' stamp: 'len 1/28/2018 18:00:45'!
reynolds
	"Answer the Reynolds operator, assuming the group acts on a polynomial ring S.
	Properties:
	- K-linear map S -> S^G (it's the G-invariant projection from S to S^G;
	- restricts to the identity on S^G;
	- it's an S^G-module homomorphisms: R(p*q) = p*R(q) for all invariants p in S^G."
	| order |
	order _ self group size.
	^ self space to: self space evaluating: [:p| (self group elements sum: [:g| self value: {g. p}]) / order]! !

!GroupAction methodsFor: 'accessing' stamp: 'len 2/16/2016 04:29'!
space
	"Answer the underlying set X of the action G x X -> X."
	^ self codomain! !

!GroupAction methodsFor: 'accessing' stamp: 'len 11/14/2016 09:30'!
stabilizerOf: aPoint
	"Answer the stabilizer subgroup (or isotropy group or little group) of aPoint, defined as the set of elements that 'fix' aPoint. The stabilizer of fixed points is the whole group, and the kernel of the action homomorphism G -> Sym(X) is the intersection of all stabilizers."
	self group generators
		ifNotNil: [:S| ^ (SchreierTree root: aPoint generators: S action: self) stabilizer].
	^ self group select: [:each| (self value: {each. aPoint}) = aPoint]! !

!GroupAction methodsFor: 'converting' stamp: 'len 5/13/2019 15:48:43'!
asPermutationRepresentation
	| S |
	S _ SymmetricGroup on: self space.
	^ self group to: S evaluating: [:g| S evaluating: [:x| self value: {g.x}]]! !

!GroupAction methodsFor: 'converting' stamp: 'len 5/13/2019 15:49:02'!
asRepresentation
	^ self group
		to: self space automorphisms
		evaluating: [:g| self space to: self space evaluating: [:x| self value: {g.x}]]! !

!GroupAction methodsFor: 'graphs' stamp: 'len 3/24/2021 09:25:28'!
actionGraph
	"Answer the action diagram with respect to the group generators.
	This is similar to a Cayley diagram.
	The connected components of the action diagram are the orbits of the action."
	^ self actionGraph: self group generators! !

!GroupAction methodsFor: 'graphs' stamp: 'len 5/25/2016 03:45'!
actionGraph: groupGenerators
	"Answer the action diagram with respect to the given group generators.
	This is similar to a Cayley diagram.
	The connected components of the action diagram are the orbits of the action."
	| G |
	self space isFinite ifFalse: [^ self error: 'not a finite space'].
	G _ Digraph unorderedLabeled.
	groupGenerators do: [:g|
		self space do: [:x|
			G addEdgeFrom: x to: (self value: {g.x}) label: g]].
	^ G! !

!GroupAction methodsFor: 'testing' stamp: 'len 12/28/2016 11:12:53'!
isFaithful
	"A group action G x X -> X is faithful (or effective) if the homomorphism G -> Sym(X) has trivial kernel {id}."
	^ self propertyAt: #isFaithful ifAbsentPut: [self kernel isTrivial]! !

!GroupAction methodsFor: 'testing' stamp: 'len 2/13/2016 08:02'!
isFixedPoint: aPoint
	"Answer true if the argument is a fixed point of the receiver."
	self group do: [:each| (self value: {each. aPoint}) = aPoint ifFalse: [^ false]].
	^ true! !

!GroupAction methodsFor: 'testing' stamp: 'len 7/27/2016 07:34'!
isImprimitive
	^ self isPrimitive not! !

!GroupAction methodsFor: 'testing' stamp: 'len 7/27/2016 07:36'!
isPrimitive
	^ self orbits allSatisfy: [:each| each size = 1 or: [each size = self space size]]! !

!GroupAction methodsFor: 'testing' stamp: 'len 7/27/2016 07:30'!
isRegular
	^ self isTransitive and: [(self stabilizerOf: self space anyOne) isTrivial]! !

!GroupAction methodsFor: 'testing' stamp: 'len 7/27/2016 07:28'!
isTransitive
	^ self orbits size = 1! !

!GroupMap methodsFor: 'accessing' stamp: 'len 5/13/2019 15:45:17'!
action
	"If the receiver is a representation (i.e., a group homomorphism to the automorphisms group of some space), answer the associated group action on the representation space."
	^ GroupAction from: (self domain, self space) to: self space evaluatingWithArguments: [:x :y| (self value: x) value: y]! !

!GroupMap methodsFor: 'accessing' stamp: 'len 5/1/2020 19:43:18'!
character
	"If the receiver is a linear representation (i.e., a group homomorphism to the general linear group), answer the character of the receiver."
	"This is a class function, i.e. it's constant on conjugacy classes, because similar matrices (or linear maps) have the same trace."
	self space isModule ifFalse: [^ self error: 'not a linear representation'].
	^ self domain to: self space scalars units evaluating: [:g| (self value: g) trace]
	
"	^ self domain carrier to: self space scalars carrier evaluating: [:g| (self value: g) trace]"! !

!GroupMap methodsFor: 'accessing' stamp: 'len 5/13/2019 15:45:33'!
space
	"If the receiver is a representation (i.e., a group homomorphism to the automorphisms group of some space), answer the representation space."
	^ self codomain space! !

!GroupMap methodsFor: 'comparing' stamp: 'len 5/13/2019 16:32:40'!
= anObject
	((anObject isKindOf: GroupMap) and: [self domain generators notNil])
		ifFalse: [^ super = anObject].
	(anObject domain = self domain and: [anObject codomain = self codomain])
		ifFalse: [^ false].
	^ self domain generators allSatisfy: [:each| (self value: each) = (anObject value: each)]! !

!GroupMap methodsFor: 'converting' stamp: 'len 5/8/2020 15:58:22'!
asMonoidMap
	"Forgetful functor to the category of monoids."
	^ self domain asMonoid to: self codomain asMonoid evaluating: self! !

!GroupMap methodsFor: 'operations' stamp: 'len 5/13/2019 16:38:15'!
image
	^ self codomain span: ((self domain generators ifNil: [^ super image]) apply: self)! !

!GroupMap methodsFor: 'operations' stamp: 'len 10/10/2016 20:03'!
inverse
	"Answer the compositional inverse of the receiver."
	^ self class
		from: self codomain to: self domain
		evaluating: [:each| self domain detect: [:one| (self value: one) = each]]! !

!GroupMap methodsFor: 'operations' stamp: 'len 8/18/2020 18:58:38'!
kernel
	^ self propertyAt: #kernel ifAbsent:
		[self computeImageAndKernel.
		self propertyAt: #kernel]! !

!GroupMap methodsFor: 'operations' stamp: 'len 3/11/2020 12:37:42'!
preimage: anObject
	"When anObject is an element of the codomain, answer a preimage (a single element in the preimage) or nil if anObject is not in the image of the receiver.
	If anObject is a subgroup of the codomain, answer the preimage as a subgroup of the domain."
	(self codomain ambient includes: anObject)
		ifTrue: [^ self preimageRepresentative: anObject].
	^ self domain ambient span: (anObject generators collect: [:each| self preimageRepresentative: each])! !

!GroupMap methodsFor: 'operations' stamp: 'len 3/11/2020 12:35:29'!
preimageRepresentative: anElement
	"Answer a representative of the preimage of anElement.
	Answer nil if anElement is not in the image of the receiver."
	^ self domain detect: [:one| (self value: one) = anElement] ifNone: []! !

!GroupMap methodsFor: 'operations' stamp: 'len 7/31/2021 12:34:42'!
value: anElement
	| answer images |
	self propertyAt: #expression ifPresent: [:anObject| ^ anObject value: anElement].
	answer _ self codomain identity.
	images _ self images.
	self domain \ anElement do: [:i :exponent| answer _ answer  ((images at: i) ^ exponent)].
	^ answer! !

!GroupMap methodsFor: 'testing' stamp: 'len 5/10/2019 07:40:55'!
isGroupHomomorphism
	^ true! !

!GroupMap methodsFor: 'testing' stamp: 'len 11/7/2015 16:46'!
isInjective
	^ self kernel isTrivial! !

!GroupMap methodsFor: 'testing' stamp: 'len 11/7/2015 16:49'!
isSurjective
	^ self image = self codomain! !

!GroupMap methodsFor: 'testing' stamp: 'len 4/26/2020 08:22:14'!
isTrivial
	^ self domain generators allSatisfy: [:each| (self value: each) = self codomain identity]! !

!GroupMap methodsFor: 'private' stamp: 'len 10/20/2020 15:40:27'!
computeImageAndKernel
	"'Handbook of Computational Group Theory', 3.4.2, algorithm IMAGEKERNEL, page 76."
	| image kernel random |
	random _ Random new.
	kernel _ self domain null.
	image _ self codomain null.
	[kernel size * image size < self domain size]
		whileTrue:
			[| g h |
			g _ self domain atRandom: random.
			h _ self value: g.
			(image includes: h)
				ifFalse: [image _ self codomain span: (image generators copyWith: h)]
				ifTrue:
					[| k |
					k _ g  (self preimage: h) inverse.
					(kernel includes: k) ifFalse: [kernel _ self domain span: (kernel generators copyWith: k)]]].
	self propertyAt: #image put: image.
	self propertyAt: #kernel put: kernel! !

!GroupMap methodsFor: 'private' stamp: 'len 5/25/2019 08:13:13'!
images
	^ self propertyAt: #images! !

!GroupMap methodsFor: 'private' stamp: 'len 5/25/2019 08:13:18'!
images: anArray
	self propertyAt: #images put: anArray! !

!GroupMap methodsFor: 'private' stamp: 'len 1/11/2018 18:20:41'!
species
	^ GroupMap! !

!GroupMap methodsFor: 'private' stamp: 'len 5/15/2019 08:00:38'!
verify
	^ super isGroupHomomorphism! !

!GroupMap class methodsFor: 'initialization' stamp: 'len 4/26/2020 17:55:38'!
initialize
	super initialize.
	Smalltalk at: #Groups put: (Category new name: #Groups)! !

!GroupMap class methodsFor: 'instance creation' stamp: 'len 5/25/2019 08:15:12'!
from: aGroup to: anotherGroup mapping: aBlock
	^ self new domain: aGroup; codomain: anotherGroup; images: ((1 to: aGroup generators size) collect: [:i| aBlock value: i])! !

!ConjugationMap methodsFor: 'accessing' stamp: 'len 2/12/2016 06:37'!
image
	^ self codomain! !

!ConjugationMap methodsFor: 'accessing' stamp: 'len 2/12/2016 06:37'!
kernel
	^ self domain null! !

!ConjugationMap methodsFor: 'accessing-private' stamp: 'len 5/2/2016 09:31'!
element
	^ element! !

!ConjugationMap methodsFor: 'accessing-private' stamp: 'len 5/5/2019 17:58:52'!
element: anElement
	element _ anElement.
	elementInverse _ element inverse! !

!ConjugationMap methodsFor: 'arithmetic' stamp: 'len 2/12/2016 06:42'!
inverse
	^ self class by: elementInverse in: self domain! !

!ConjugationMap methodsFor: 'comparing' stamp: 'len 5/13/2019 15:50:17'!
= anObject
	(anObject isKindOf: ConjugationMap) ifFalse: [^ super = anObject].
	^ anObject domain = self domain and: [anObject codomain = self codomain and: [self element = anObject element]]! !

!ConjugationMap methodsFor: 'comparing' stamp: 'len 5/2/2016 09:31'!
hash
	^ element hash! !

!ConjugationMap methodsFor: 'operations' stamp: 'len 5/5/2019 18:37:19'!
value: anElement
	^ element  anElement  elementInverse! !

!ConjugationMap class methodsFor: 'instance creation' stamp: 'len 5/12/2016 10:06'!
by: anElement in: aGroup
	^ self new domain: aGroup; codomain: aGroup; element: anElement! !

!DirichletCharacter methodsFor: 'as yet unclassified' stamp: 'len 8/5/2021 08:38:19'!
conductor
	| factors p answer |
	(self modulus = 1 or: [self isTrivial]) ifTrue: [^ 1].
	(factors _ self modulus factorization) asSet size > 1
		ifTrue: [^ self decomposition product: [:each| each conductor]].
	p _ factors anyOne.
"	e _ factors size."
	answer _ p ^ ((self size abs: p) + 1).
"	p = 2 and: [e > 2 and: [ ..."
	^ answer! !

!DirichletCharacter methodsFor: 'as yet unclassified' stamp: 'len 8/3/2019 08:58:00'!
even
	^ (self value: self domain !! -1) = self codomain one! !

!DirichletCharacter methodsFor: 'as yet unclassified' stamp: 'len 12/9/2016 12:28:30'!
isPrimitive
	^ self conductor = self modulus! !

!DirichletCharacter methodsFor: 'as yet unclassified' stamp: 'len 12/9/2016 12:21:35'!
modulus
	^ self domain modulus! !

!DirichletCharacter methodsFor: 'as yet unclassified' stamp: 'len 8/3/2019 08:58:14'!
odd
	^ (self value: self domain !! -1) = self codomain one negated! !

!BilinearMap methodsFor: 'as yet unclassified' stamp: 'len 7/8/2021 15:02:06'!
 aBilinearMap
	"Answer the direct sum of the receiver and the argument."
	^ self class
		from: (self domain at: 1)  (aBilinearMap domain at: 1), ((self domain at: 2)  (aBilinearMap domain at: 2))
		to: self codomain  aBilinearMap codomain
		evaluatingWithArguments: [:x :y| self notYetImplemented]! !

!BilinearMap methodsFor: 'as yet unclassified' stamp: 'len 7/8/2021 14:58:34'!
left
	"Answer the linear map that fixes the first argument."
	| X Y Z |
	X _ self domain at: 1.
	Y _ self domain at: 2.
	Z _ self codomain.
	^ X to: Y => Z evaluating: [:x| Y to: Z evaluating: [:y| self value: x value: y]]! !

!BilinearMap methodsFor: 'as yet unclassified' stamp: 'len 7/8/2021 14:59:06'!
right
	"Answer the linear map that fixes the second argument."
	| X Y Z |
	X _ self domain at: 1.
	Y _ self domain at: 2.
	Z _ self codomain.
	^ Y to: X => Z evaluating: [:y| X to: Z evaluating: [:x| self value: x value: y]]! !

!BilinearMap methodsFor: 'as yet unclassified' stamp: 'len 7/14/2020 07:31:45'!
table
	^ self propertyAt: #table! !

!BilinearMap methodsFor: 'as yet unclassified' stamp: 'len 7/14/2020 07:31:36'!
table: anArray
	self propertyAt: #table put: anArray! !

!BilinearMap methodsFor: 'as yet unclassified' stamp: 'len 7/14/2020 07:01:41'!
value: anArray
	self assert: anArray size = 2.
	^ self value: anArray first value: anArray second! !

!BilinearMap methodsFor: 'as yet unclassified' stamp: 'len 4/26/2021 11:39:30'!
value: anElement value: anotherElement
	| v w t |
	v _ (self domain at: 1) \ anElement.
	w _ (self domain at: 2) \ anotherElement. 
	t _ self codomain coordinates zero.
	self table withIndexDo: [:ai :i|
		ai withIndexDo: [:aij :j|
			t _ (aij collect: [:each| (v at: i) * each * (w at: j)]) + t]].
	^ self codomain elementAt: t! !

!BilinearMap class methodsFor: 'instance creation' stamp: 'len 7/7/2020 09:18:44'!
from: aDomain to: aCodomain evaluating: aBlock
	^ self from: aDomain to: aCodomain evaluatingWithArguments: [:x :y| aBlock value: {x. y}]! !

!BilinearMap class methodsFor: 'instance creation' stamp: 'len 4/26/2021 11:39:37'!
from: aDomain to: aCodomain evaluatingWithArguments: aBlock
	| table |
	table _ aDomain components first generators collect: [:x| aDomain components second generators collect: [:y| aCodomain \ (aBlock value: x value: y)]].
	^ self from: aDomain to: aCodomain table: table! !

!BilinearMap class methodsFor: 'instance creation' stamp: 'len 4/26/2021 11:39:43'!
from: aDomain to: aCodomain mapping: aBlock
	| table |
	table _ (1 to: (aDomain at: 1) generators size) collect: [:i|
		(1 to: (aDomain at: 2) generators size) collect: [:j|
			aCodomain \ (aBlock value: i value: j)]].
	^ self from: aDomain to: aCodomain table: table! !

!BilinearMap class methodsFor: 'instance creation' stamp: 'len 7/14/2020 07:31:21'!
from: aDomain to: aCodomain table: anArray
	^ self new domain: aDomain; codomain: aCodomain; table: anArray! !

!BilinearMap class methodsFor: 'instance creation' stamp: 'len 7/7/2020 09:32:03'!
on: aModule evaluating: aBlock
	^ self on: aModule evaluatingWithArguments: [:x :y| aBlock value: {x. y}]! !

!BilinearMap class methodsFor: 'instance creation' stamp: 'len 7/7/2020 09:31:30'!
on: aModule evaluatingWithArguments: aBlock
	^ self from: (aModule, aModule) to: aModule evaluatingWithArguments: aBlock! !

!BilinearMap class methodsFor: 'instance creation' stamp: 'len 7/14/2020 17:13:29'!
on: aModule mapping: aBlock
	^ self from: (aModule, aModule) to: aModule mapping: aBlock! !

!BilinearMap class methodsFor: 'instance creation' stamp: 'len 7/14/2020 07:35:34'!
on: aModule table: anArray
	^ self from: (aModule, aModule) to: aModule table: anArray! !

!BilinearForm methodsFor: 'accessing' stamp: 'len 12/28/2015 21:09'!
bitSize
	^ matrix bitSize! !

!BilinearForm methodsFor: 'accessing' stamp: 'len 1/8/2016 06:36'!
codomain
	^ self scalars! !

!BilinearForm methodsFor: 'accessing' stamp: 'len 7/28/2020 19:33:01'!
domain
	^ (space, space)! !

!BilinearForm methodsFor: 'accessing' stamp: 'len 11/7/2015 23:26'!
matrix
	^ matrix! !

!BilinearForm methodsFor: 'accessing' stamp: 'len 7/28/2020 19:33:13'!
scalars
	^ space scalars! !

!BilinearForm methodsFor: 'accessing' stamp: 'len 7/29/2020 06:30:58'!
space
	^ space! !

!BilinearForm methodsFor: 'comparing' stamp: 'len 7/28/2020 19:32:00'!
= anObject
	^ self class = anObject class and: [space = anObject space and: [matrix = anObject matrix]]! !

!BilinearForm methodsFor: 'comparing' stamp: 'len 7/27/2020 19:20:48'!
hash
	^ matrix hash! !

!BilinearForm methodsFor: 'converting' stamp: 'len 5/29/2020 15:20:02'!
asPolynomial
	| n P x y |
	n _ matrix height.
	P _ self scalars polynomialsIn: ((1 to: n) collect: [:i| 'x' asText, i printString sub]), ((1 to: n) collect: [:i| 'y' asText, i printString sub]).
	x _ P^n filling: [:i| P x: i].
	y _ P^n filling: [:i| P x: n+i].
	^ x  ((matrix over: P) * y)! !

!BilinearForm methodsFor: 'converting' stamp: 'len 7/28/2020 19:32:47'!
depolarization
	"Answer the associated quadratic form Q(v) := B(v,v)."
	^ QuadraticForm from: space gramian: matrix! !

!BilinearForm methodsFor: 'initialization' stamp: 'len 8/23/97 15:35'!
matrix: aMatrix
	matrix _ aMatrix! !

!BilinearForm methodsFor: 'initialization' stamp: 'len 7/28/2020 19:33:47'!
space: aFreeModule
	space _ aFreeModule! !

!BilinearForm methodsFor: 'operations' stamp: 'len 7/28/2020 19:32:35'!
* anObject
	^ self class on: space matrix: matrix * anObject! !

!BilinearForm methodsFor: 'operations' stamp: 'len 7/28/2020 19:35:54'!
+ aBilinearForm
	space == aBilinearForm space ifTrue: [^ self class on: space matrix: matrix + aBilinearForm matrix].
	space = aBilinearForm space ifFalse: [^ self error: 'domains don''t match'].
	^ self class on: space evaluating: [:each| (self value: each) + (aBilinearForm value: each)]! !

!BilinearForm methodsFor: 'operations' stamp: 'len 7/28/2020 19:32:18'!
 anObject
	(anObject isKindOf: BilinearForm)
		ifTrue: [^ self class on: space  anObject space matrix: matrix  anObject matrix].
	(anObject isKindOf: QuadraticForm)
		ifTrue: [^ (self  anObject polarization) depolarization].
	^ DomainError signal! !

!BilinearForm methodsFor: 'operations' stamp: 'len 5/3/2021 11:00:44'!
 aBilinearForm
	"Answer the orthogonal sum of the receiver and the argument."
	^ self class on: space  aBilinearForm space matrix: matrix  aBilinearForm matrix! !

!BilinearForm methodsFor: 'operations' stamp: 'len 7/28/2020 09:38:10'!
automorphisms
	"Answer the orthogonal group consisting of the self-isometries with respect to the receiver."
	^ self depolarization automorphisms! !

!BilinearForm methodsFor: 'operations' stamp: 'len 7/10/2020 08:42:17'!
gramianOf: anArray
	"Answer the Gramian matrix of the vectors in anArray."
	^ (self scalars^anArray size) endomorphisms filling: [:i :j| self value: (anArray at: i) value: (anArray at: j)]! !

!BilinearForm methodsFor: 'operations' stamp: 'len 7/28/2020 20:08:32'!
left
	"Answer the linear map from the space to its dual that fixes the right argument. If the bilinear form is non-degenerate, this map is an isomorphism."
	| V L |
	V _ self domain at: 1.
	L _ V dual.
	^ V to: L evaluating: [:v| L evaluating: [:w| self value: w value: v]]! !

!BilinearForm methodsFor: 'operations' stamp: 'len 1/8/2016 06:06'!
leftRadical
	^ self left kernel! !

!BilinearForm methodsFor: 'operations' stamp: 'len 7/28/2020 19:33:08'!
negated
	^ self class on: space matrix: matrix negated! !

!BilinearForm methodsFor: 'operations' stamp: 'len 7/21/2020 18:37:25'!
orthogonalizationOf: aCollection
	"Answer an orthogonalization of the given basis.
	Perform the Gram-Schmidt orthogonalization process."
	| answer norms u uv |
	answer _ OrderedCollection new: aCollection size.
	norms _ OrderedCollection new: aCollection size.
	aCollection do: [:each|
		u _ each.
		answer with: norms do: [:v :vv|
			uv _ self value: u value: v.
			u _ u - (v * uv / vv)].
		answer add: u.
		norms add: (self value: u value: u)].
	^ answer! !

!BilinearForm methodsFor: 'operations' stamp: 'len 7/6/2020 11:36:32'!
radical
	"Assuming the receiver is symmetric, answer the radical subspace."
	^ self leftRadical! !

!BilinearForm methodsFor: 'operations' stamp: 'len 1/8/2016 06:29'!
rank
	^ matrix rank! !

!BilinearForm methodsFor: 'operations' stamp: 'len 7/6/2020 08:14:12'!
right
	"Answer the linear map from the domain to its dual that fixes the left argument. If the bilinear form is non-degenerate, this map is an isomorphism."
	| V L |
	V _ self domain at: 2.
	L _ V dual.
	^ V to: L evaluating: [:v| L evaluating: [:w| self value: v value: w]]! !

!BilinearForm methodsFor: 'operations' stamp: 'len 1/8/2016 06:06'!
rightRadical
	^ self right kernel! !

!BilinearForm methodsFor: 'operations' stamp: 'len 8/9/2020 07:50:29'!
skewSymmetricPart
	| two |
	two _ self scalars one * 2.
	^ self class
		on: space
		matrix: matrix - matrix transpose / two! !

!BilinearForm methodsFor: 'operations' stamp: 'len 8/9/2020 07:50:34'!
symmetricPart
	| two |
	two _ self scalars one * 2.
	^ self class
		on: space
		matrix: matrix + matrix transpose / two! !

!BilinearForm methodsFor: 'operations' stamp: 'len 8/9/2020 07:48:52'!
transpose
	"The transpose of a bilinear form B(x,y) is B(y,x)."
	^ self class on: space matrix: matrix transpose! !

!BilinearForm methodsFor: 'operations' stamp: 'len 4/26/2021 11:39:17'!
value: anElement value: anotherElement
	^ space \ anElement  (matrix * (space \ anotherElement))! !

!BilinearForm methodsFor: 'testing' stamp: 'len 1/8/2016 06:30'!
isAlternating
	"A bilinear form B is called 'alternating' if B(v,v) = 0 for all v."
	matrix isSkewSymmetric ifFalse: [^ false].
	matrix diagonalDo: [:each| each isZero ifFalse: [^ false]].
	^ true! !

!BilinearForm methodsFor: 'testing' stamp: 'len 1/8/2016 06:25'!
isNonDegenerate
	"A bilinear form B is called 'non-degenerate' if B(v,w) = 0 for all w implies v = 0.
	B is non-degenerate iff the left and right radicals are trivial."
	^ self rank = self domain dimension! !

!BilinearForm methodsFor: 'testing' stamp: 'len 7/10/2020 07:46:31'!
isPositiveDefinite
	"A bilinear form B over the real or complex number is called 'positive definite' if B(v,v) > 0 for all v."
	^ matrix isPositiveDefinite! !

!BilinearForm methodsFor: 'testing' stamp: 'len 1/7/2016 23:40'!
isReflexive
	"A bilinear form B is called 'reflexive' if B(v,w) = 0 implies B(w,v) = 0 for all v,w."
	^ self isSymmetric or: [self isAlternating]! !

!BilinearForm methodsFor: 'testing' stamp: 'len 7/27/2020 19:06:58'!
isSkewSymmetric
	"A bilinear form B is called 'skew-symmetric' (or 'anti-symmetric') if B(v,w) = -B(w,v) for all v,w."
	^ matrix isSkewSymmetric! !

!BilinearForm methodsFor: 'testing' stamp: 'len 7/28/2020 10:27:27'!
isStandardDotProduct
	"Answer true if the receiver is the standard dot product."
	^ matrix isIdentity! !

!BilinearForm methodsFor: 'testing' stamp: 'len 1/8/2016 06:30'!
isSymmetric
	"A bilinear form B is called 'symmetric' if B(v,w) = B(w,v) for all v,w."
	^ matrix isSymmetric! !

!BilinearForm class methodsFor: 'instance creation' stamp: 'len 7/14/2020 07:37:24'!
from: aDomain to: aCodomain table: anArray
	^ self on: (aDomain at: 1) matrix: (anArray at: 1)! !

!BilinearForm class methodsFor: 'instance creation' stamp: 'len 10/25/2020 10:10:31'!
on: aModule evaluatingWithArguments: aBlock
	| generators matrix |
	generators _ aModule generators.
	matrix _ aModule coordinates endomorphisms filling: [:i :j| aBlock value: (generators at: i) value: (generators at: j)].
	^ self on: aModule matrix: matrix! !

!BilinearForm class methodsFor: 'instance creation' stamp: 'len 7/28/2020 19:33:55'!
on: aFreeModule matrix: aMatrix
	"Answer a new instance of the receiver representing the bilinear form associated to aMatrix in the given bases."
	^ self new space: aFreeModule; matrix: aMatrix! !

!ModuleMap methodsFor: 'accessing' stamp: 'len 4/1/2021 06:41:51'!
bitSize
	^ self asMatrix bitSize! !

!ModuleMap methodsFor: 'accessing' stamp: 'len 5/16/2019 20:40:32'!
codomain
	^ codomain! !

!ModuleMap methodsFor: 'accessing' stamp: 'len 4/1/2021 06:41:57'!
denominator
	^ self asMatrix denominator! !

!ModuleMap methodsFor: 'accessing' stamp: 'len 5/16/2019 20:40:36'!
domain
	^ domain! !

!ModuleMap methodsFor: 'accessing' stamp: 'len 5/29/2020 10:16:57'!
one
	^ self identity! !

!ModuleMap methodsFor: 'accessing' stamp: 'len 3/10/2020 17:55:07'!
parent
	"A module homomorphism f:A->B belongs to Hom(A,B)."
	^ self domain => self codomain! !

!ModuleMap methodsFor: 'accessing' stamp: 'len 7/25/2021 09:17:45'!
representation
	self assert: self isEndomorphism.
	^ self parent endomorphisms evaluating: [:x| self * x]! !

!ModuleMap methodsFor: 'accessing' stamp: 'len 5/28/2020 09:52:20'!
scalars
	^ self domain scalars! !

!ModuleMap methodsFor: 'accessing' stamp: 'len 5/29/2020 10:06:34'!
zero
	^ self domain to: self codomain evaluating: [:x| self codomain zero]! !

!ModuleMap methodsFor: 'comparing' stamp: 'len 3/13/2021 13:45:24'!
= anObject
	self == anObject ifTrue: [^ true].
	(anObject isKindOf: ModuleMap) ifFalse: [^ super = anObject].
	^ domain = anObject domain and: [codomain = anObject codomain and: [(self - anObject) isZero]]! !

!ModuleMap methodsFor: 'converting' stamp: 'len 4/26/2021 10:54:13'!
asAbelianGroupMap
	self scalars ==  ifFalse: [^ DomainError signal].
	^ self! !

!ModuleMap methodsFor: 'converting' stamp: 'len 4/1/2021 06:34:04'!
asMatrix
	"Answer the matrix corresponding to the receiver with respect to the fixed list of generators of its domain and codomain."
	^ self propertyAt: #matrix! !

!ModuleMap methodsFor: 'converting' stamp: 'len 7/16/2020 10:39:14'!
asModuleElement
	^ self! !

!ModuleMap methodsFor: 'converting' stamp: 'len 4/1/2021 06:41:44'!
asPolynomial
	"If the receiver is a linear form, answer the receiver as a polynomial in the coordinate ring of the domain."
	| P |
	self isLinearForm ifFalse: [DomainError signal: 'not a linear form'].
	P _ self domain coordinateRing.
	^ (P^P rank filling: [:i| P x: i])  (self asMatrix asTuple over: P)! !

!ModuleMap methodsFor: 'operations' stamp: 'len 7/25/2021 12:32:13'!
* anObject
	((self scalars includes: anObject) not and: [anObject isKindOf: ModuleMap]) ifTrue: [^ self  anObject].
	^ domain to: codomain validMatrix: self asMatrix * anObject! !

!ModuleMap methodsFor: 'operations' stamp: 'len 4/6/2021 14:23:00'!
+ anObject
	(anObject isKindOf: ModuleMap) ifFalse: [^ super + anObject].
	(self domain == anObject domain and: [self codomain == anObject codomain])
			ifTrue: [^ domain to: codomain validMatrix: self asMatrix + anObject asMatrix].
	(self domain = anObject domain and: [self codomain = anObject codomain])
			ifTrue: [^ domain to: codomain evaluating: [:v| (self value: v) + (anObject value: v)]].
	^ DomainError signal: 'domains don''t match'! !

!ModuleMap methodsFor: 'operations' stamp: 'len 5/7/2019 08:47:03'!
- aModuleMap
	^ self + aModuleMap negated! !

!ModuleMap methodsFor: 'operations' stamp: 'len 8/1/2021 12:38:05'!
/ anObject
	"If the argument is a monomorphism i:A->X, and the receiver is f:A->Y, answer f':X->Y such that the diagram commutes. This is a 'colift (or extension) of f along i' and it is noted f/i."
	| M |
	(anObject isKindOf: ModuleMap) ifFalse: [^ self * (self domain scalars !! anObject) inverse].
	self domain = anObject domain ifFalse: [^ DomainError signal: 'domains don''t match'].
	self domain presentationMatrix = anObject domain presentationMatrix ifFalse: [^ self notYetImplemented].
	M _ self domain isFreelyGenerated
		ifTrue: [self asMatrix / anObject asMatrix]
		ifFalse: [anObject asMatrix colift: self asMatrix modulo: self domain presentationMatrix].
	^ M ifNotNil: [anObject codomain to: codomain matrix: M]! !

!ModuleMap methodsFor: 'operations' stamp: 'len 12/23/2021 15:41:48'!
/\ aModuleMap
	"Answer the pullback (or fibered product, cartesian square) of the receiver and the argument. The pullback is the limit of a cospan Y -> X <- Z and it is the categorical dual of the pushout (see >>\/).
	The pullback of a morphism f and a monomorphism g can be thought of as the 'preimage' under f of the subobject specified by g. Similarly, pullbacks of two monomorphisms can be thought of as the 'intersection' of the two subobjects."
	| coproduct answer |
	coproduct _ self  aModuleMap negated.
	answer _ coproduct kernel.
	answer addProjections: (coproduct domain -< {self domain. aModuleMap domain} collect: [:each| answer -> each]).
	^ answer! !

!ModuleMap methodsFor: 'operations' stamp: 'len 1/3/2022 10:50:09'!
@ aPrimeIdeal
	"Answer the localization of the receiver at aPrimeIdeal."
	^ self domain @ aPrimeIdeal to: self codomain @ aPrimeIdeal matrix: self matrix @ aPrimeIdeal! !

!ModuleMap methodsFor: 'operations' stamp: 'len 4/19/2021 10:56:45'!
\ aModuleMap
	"If the receiver is an epimorphism p:X->B, and the argument is f:Y->B, answer f':Y->X such that the diagram commutes. This is a 'lift of f along p' and it is noted p\f."
	| M |
	self codomain = aModuleMap codomain ifFalse: [^ DomainError signal: 'codomains don''t match'].
	self codomain presentationMatrix = aModuleMap codomain presentationMatrix ifFalse: [^ self notYetImplemented].
	M _ self codomain isFreelyGenerated
		ifTrue: [self asMatrix \ aModuleMap asMatrix]
		ifFalse: [self asMatrix lift: aModuleMap asMatrix modulo: self codomain presentationMatrix].
	^ M ifNotNil: [aModuleMap domain to: domain matrix: M]! !

!ModuleMap methodsFor: 'operations' stamp: 'len 12/23/2021 15:46:19'!
\/ aModuleMap
	"Answer the pushout (or fibered coproduct, fibered sum, cocartesian square, amalgamated sum) of the receiver and the argument. The pushout is the colimit of a span Y <- X -> Z, and it is the categorical dual of the pullback (see >>/\)."
	| answer product |
	product _ self  aModuleMap negated.
	answer _ product cokernel.
	answer addCoprojections: ({self codomain. aModuleMap codomain} >- product codomain collect: [:each| each -> answer]).
	^ answer! !

!ModuleMap methodsFor: 'operations' stamp: 'len 4/6/2021 14:24:37'!
 aModuleMap
	"Answer the composition of the receiver with the argument."
	self species = aModuleMap species ifFalse: [^ super  aModuleMap].
	domain == aModuleMap codomain
		ifTrue: [^ aModuleMap domain to: codomain validMatrix: self asMatrix  aModuleMap asMatrix].
	domain >= aModuleMap codomain
		ifTrue: [^ aModuleMap domain to: codomain evaluating: [:each| self value: (aModuleMap value: each)]].
	^ DomainError signal: 'domains don''t match'! !

!ModuleMap methodsFor: 'operations' stamp: 'len 4/6/2021 14:24:52'!
 aModuleMap
	"Answer the direct sum of the receiver and the argument."
	^ domain  aModuleMap domain to: codomain  aModuleMap codomain validMatrix: self asMatrix  aModuleMap asMatrix! !

!ModuleMap methodsFor: 'operations' stamp: 'len 4/28/2021 11:29:01'!
 aModuleMap
	"Answer the tensor product of the receiver with the argument."
	(aModuleMap isKindOf: ModuleMap) ifFalse: [^ self notYetImplemented].
	^ domain  aModuleMap domain to: codomain  aModuleMap codomain validMatrix: self asMatrix  aModuleMap asMatrix! !

!ModuleMap methodsFor: 'operations' stamp: 'len 5/3/2021 10:47:10'!
 aModuleMap
	"Answer the product morphism of the receiver and the argument."
	domain = aModuleMap domain ifFalse: [DomainError signal: 'domains don''t match'].
	^ domain to: codomain  aModuleMap codomain validMatrix: self asMatrix  aModuleMap asMatrix! !

!ModuleMap methodsFor: 'operations' stamp: 'len 5/3/2021 10:47:32'!
 aModuleMap
	"Answer the coproduct morphism of the receiver and the argument."
	codomain = aModuleMap codomain ifFalse: [DomainError signal: 'codomains don''t match'].
	^ domain  aModuleMap domain to: codomain validMatrix: self asMatrix  aModuleMap asMatrix! !

!ModuleMap methodsFor: 'operations' stamp: 'len 8/1/2021 10:46:10'!
adjoint
	"Answer the transpose (or dual, or adjoint) of the receiver.
	The assignment of a linear map f:V->W to its dual f*:W*->V* produces an injective linear map between Hom(V,W) and Hom(W*,V*).
	This is the 'operator adjoint', not to be confused with the 'Hilbert adjoint' that is defined for an operator in an inner product space."
	(self scalars isCommutative or: [self scalars isInvolutive]) ifFalse: [^ self notYetImplemented].
	^ codomain dual to: domain dual matrix: self asMatrix transpose! !

!ModuleMap methodsFor: 'operations' stamp: 'len 12/15/2021 19:51:16'!
characteristicPolynomial
	^ self asMatrix characteristicPolynomial! !

!ModuleMap methodsFor: 'operations' stamp: 'len 3/26/2021 15:07:14'!
coequalizer: aModuleMap
	^ (self - aModuleMap) cokernel! !

!ModuleMap methodsFor: 'operations' stamp: 'len 3/26/2021 15:07:06'!
equalizer: aModuleMap
	^ (self - aModuleMap) kernel! !

!ModuleMap methodsFor: 'operations' stamp: 'len 4/1/2021 06:42:03'!
image
	^ self propertyAt: #image ifAbsentPut: [codomain span: self asMatrix]! !

!ModuleMap methodsFor: 'operations' stamp: 'len 7/17/2021 13:44:40'!
inverse
	"Answer a two-sided inverse of the receiver (i.e., a morphism that is both a retraction and a section) or nil."
	^ self isSurjective ifTrue: [^ self section]! !

!ModuleMap methodsFor: 'operations' stamp: 'len 4/6/2021 11:02:38'!
kernel
	^ self propertyAt: #kernel ifAbsentPut: [self domain span: (self asMatrix syzygiesModulo: self codomain presentationMatrix)]! !

!ModuleMap methodsFor: 'operations' stamp: 'len 12/15/2021 19:50:51'!
minimalPolynomial
	^ self asMatrix minimalPolynomial! !

!ModuleMap methodsFor: 'operations' stamp: 'len 4/6/2021 14:26:04'!
negated
	^ domain to: codomain validMatrix: self asMatrix negated! !

!ModuleMap methodsFor: 'operations' stamp: 'len 7/18/2021 07:40:10'!
norm
	^ self asMatrix determinant! !

!ModuleMap methodsFor: 'operations' stamp: 'len 12/10/2021 19:25:03'!
normalization
	"Answer a unit u such that 'self * u' is a unique choice of associate. See >>normalized."
	self isEndomorphism ifFalse: [^ self error: 'not an endomorphism'].
	^ self notYetImplemented! !

!ModuleMap methodsFor: 'operations' stamp: 'len 12/10/2021 19:24:00'!
normalized
	"Answer a unique choice of associate. See >>normalization."
	^ self * self normalization! !

!ModuleMap methodsFor: 'operations' stamp: 'len 4/13/2020 16:40:54'!
preimage: anObject
	"When anObject is an element of the codomain, answer a preimage (a single element in the preimage) or nil if anObject is not in the image of the receiver.
	If anObject is a submodule of the codomain, answer the preimage as a submodule of the domain."
	(self codomain ambient includes: anObject)
		ifTrue: [^ self preimageRepresentative: anObject].
	(anObject isKindOf: Module) ifFalse: [^ DomainError signal].
	^ self domain ambient span: (anObject generators collect: [:each| self preimageRepresentative: each])! !

!ModuleMap methodsFor: 'operations' stamp: 'len 4/26/2021 11:42:19'!
preimageRepresentative: anElement
	"Answer a representative of the preimage of anElement.
	Answer nil if anElement is not in the image of the receiver."
	^ domain elementAt: ((self asMatrix lift: (codomain \ anElement) asMatrix modulo: self codomain presentationMatrix) ifNil: [^ nil]) asTuple! !

!ModuleMap methodsFor: 'operations' stamp: 'len 3/14/2021 10:38:40'!
retraction
	"Answer a left inverse (or retraction) of the receiver, or nil."
	^ self propertyAt: #retraction ifAbsentPut: [self domain id / self]! !

!ModuleMap methodsFor: 'operations' stamp: 'len 3/14/2021 10:39:20'!
section
	"Answer a right inverse (or section) of the receiver, or nil."
	^ self propertyAt: #section ifAbsentPut: [self \ self codomain id]! !

!ModuleMap methodsFor: 'operations' stamp: 'len 4/1/2021 06:43:21'!
trace
	^ self asMatrix trace! !

!ModuleMap methodsFor: 'operations' stamp: 'len 4/1/2021 06:43:27'!
transpose
	"The kernel of this map is the complement of the image of the receiver (the orthogonal complement with respect to the standard inner product defined or dot product).
	See also >>adjoint."
	^ codomain to: domain matrix: self asMatrix transpose! !

!ModuleMap methodsFor: 'operations' stamp: 'len 7/6/2021 14:32:15'!
value: anElement
"	(domain isTrivial or: [codomain isTrivial])
		ifTrue: [^ codomain ambient zero]."
	^ codomain elementAt: self asMatrix * (domain \ anElement)

"	^ codomain elementAt: self asMatrix * (domain \ (domain !! anElement))"! !

!ModuleMap methodsFor: 'testing' stamp: 'len 3/17/2021 14:38:35'!
isAutomorphism
	"A surjective endomorphism of a finitely generated module is an automorphism (i.e., it's not necessary to check it is injective)."
	^ self isEndomorphism and: [self isSurjective]! !

!ModuleMap methodsFor: 'testing' stamp: 'len 3/11/2020 18:49:29'!
isConstant
	^ self isZero! !

!ModuleMap methodsFor: 'testing' stamp: 'len 3/12/2020 16:14:11'!
isIdentity
	self isEndomorphism ifFalse: [^ false].
	^ self domain generators allSatisfy: [:each| (self value: each) = each]! !

!ModuleMap methodsFor: 'testing' stamp: 'len 5/16/2019 20:42:56'!
isInjective
	^ self kernel isTrivial! !

!ModuleMap methodsFor: 'testing' stamp: 'len 4/8/2021 12:49:58'!
isLinearForm
	"Answer true if the receiver is a linear form (or linear functional, one-form, covector)."
	^ self codomain = self scalars asIdeal! !

!ModuleMap methodsFor: 'testing' stamp: 'len 5/10/2019 07:41:27'!
isModuleHomomorphism
	^ true! !

!ModuleMap methodsFor: 'testing' stamp: 'len 7/16/2020 10:36:53'!
isOne
	^ self isIdentity! !

!ModuleMap methodsFor: 'testing' stamp: 'len 1/13/2018 21:54:27'!
isProjection
	^ self isIdempotent! !

!ModuleMap methodsFor: 'testing' stamp: 'len 3/14/2021 04:40:46'!
isSurjective
	^ self image = self codomain

"alternatively:
	^ self cokernel isTrivial"! !

!ModuleMap methodsFor: 'testing' stamp: 'len 1/13/2018 21:53:54'!
isTrivial
	^ self isZero! !

!ModuleMap methodsFor: 'testing' stamp: 'len 3/13/2021 13:36:11'!
isZero
	^ self image isTrivial! !

!ModuleMap methodsFor: 'private' stamp: 'len 5/16/2019 20:40:52'!
codomain: aModule
	codomain _ aModule! !

!ModuleMap methodsFor: 'private' stamp: 'len 5/16/2019 20:40:56'!
domain: aModule
	domain _ aModule! !

!ModuleMap methodsFor: 'private' stamp: 'len 5/29/2020 10:58:40'!
matrix: aMatrix
	self propertyAt: #matrix put: aMatrix! !

!ModuleMap methodsFor: 'private' stamp: 'len 1/11/2018 18:20:06'!
species
	^ ModuleMap! !

!ModuleMap methodsFor: 'private' stamp: 'len 4/1/2021 06:43:36'!
validate
	self asMatrix width = self domain generators size ifFalse: [^ false].
	self asMatrix height = self codomain generators size ifFalse: [^ false].
	^ super validate! !

!ModuleMap methodsFor: 'private' stamp: 'len 5/15/2019 08:02:02'!
verify
	^ super isModuleHomomorphism! !

!ModuleMap class methodsFor: 'instance creation' stamp: 'len 5/29/2020 10:48:01'!
from: aDomain to: aCodomain evaluating: aBlock
	"Answer a new instance of the receiver using the one argument block aBlock for evaluating each vector in the domain basis."
	
	self shouldNotImplement
"	| matrix |
	matrix _ Matrix rows: (aDomain generators collect: [:each| aCodomain coordinatesOf: aCodomain !! (aBlock value: each)]).
	^ self from: aDomain to: aCodomain matrix: matrix transposed"! !

!ModuleMap class methodsFor: 'instance creation' stamp: 'len 5/29/2020 10:46:33'!
from: aDomain to: aCodomain matrix: aMatrix
	^ self new
		domain: aDomain;
		codomain: aCodomain;
		matrix: aMatrix! !

!Matrix methodsFor: 'accessing' stamp: 'len 12/20/2021 13:26:46'!
at: aPoint
	"Answer the coefficient at i@j (row i, column j)."
	^ self atRow: aPoint x column: aPoint y! !

!Matrix methodsFor: 'accessing' stamp: 'len 3/2/2017 19:57:13'!
at: aPoint add: anObject
	self at: aPoint put: (self at: aPoint) + anObject! !

!Matrix methodsFor: 'accessing' stamp: 'len 12/20/2021 13:27:45'!
at: aPoint ifAbsent: exceptionBlock
	"Answer the coefficient at i@j (row i, column j), and evaluate aBlock if the indices are out of bounds."
	^ self atRow: aPoint x column: aPoint y ifAbsent: exceptionBlock! !

!Matrix methodsFor: 'accessing' stamp: 'len 12/20/2021 13:28:06'!
at: aPoint put: anObject
	"Answer the coefficient at i@j (row i, column j)."
	^ self atRow: aPoint x column: aPoint y put: anObject! !

!Matrix methodsFor: 'accessing' stamp: 'len 5/29/2020 04:56:59'!
bitSize
	| answer |
	answer _ 0.
	self do: [:each| answer _ answer + each bitSize].
	^ answer! !

!Matrix methodsFor: 'accessing' stamp: 'len 5/29/2020 06:13:37'!
columnAt: j
	^ codomain filling: [:i| self at: i@j]! !

!Matrix methodsFor: 'accessing' stamp: 'len 5/29/2020 06:14:11'!
columnAt: j put: aTuple
	aTuple withIndexDo: [:each :i| self at: i@j put: each]! !

!Matrix methodsFor: 'accessing' stamp: 'len 5/29/2020 06:55:40'!
columns
	^ (Iterator on: self performing: #columnsDo:) asArray! !

!Matrix methodsFor: 'accessing' stamp: 'len 1/28/2018 22:23:15'!
denominator
	| answer |
	self scalars isLocalization ifFalse: [^ self scalars one].
	answer _ self scalars integers one.
	self do: [:each| answer _ each denominator lcm: answer].
	^ answer! !

!Matrix methodsFor: 'accessing' stamp: 'len 5/29/2020 07:26:49'!
diagonal
	^ (Iterator on: self performing: #diagonalDo:) asArray! !

!Matrix methodsFor: 'accessing' stamp: 'len 4/7/2018 06:20:08'!
extent
	^ self height @ self width! !

!Matrix methodsFor: 'accessing' stamp: 'len 5/29/2020 06:32:28'!
height
	^ codomain rank! !

!Matrix methodsFor: 'accessing' stamp: 'len 4/5/2018 15:32:32'!
lastColumn
	^ self columnAt: self width! !

!Matrix methodsFor: 'accessing' stamp: 'len 1/6/2022 17:03:55'!
lastRow
	^ self rowAt: self height! !

!Matrix methodsFor: 'accessing' stamp: 'len 12/20/2021 13:27:00'!
lift
	"If the coefficients ring is a quotient R/I, answer a representative of the receiver over R. See >>%."
	^ self class from: domain lift to: codomain lift filling: [:i :j| (self atRow: i column: j) lift]! !

!Matrix methodsFor: 'accessing' stamp: 'len 7/17/2019 16:19:09'!
numerator
	self scalars isLocalization ifFalse: [^ self].
	^ self * (self scalars !! self denominator) over: self scalars integers! !

!Matrix methodsFor: 'accessing' stamp: 'len 12/20/2021 13:27:20'!
representative
	"If the coefficients ring is a quotient R/I, answer a representative of the receiver over R. See >>%."
	^ self class from: domain lift to: codomain lift filling: [:i :j| (self atRow: i column: j) representative]! !

!Matrix methodsFor: 'accessing' stamp: 'len 5/29/2020 06:13:12'!
rowAt: i
	^ domain filling: [:j| self at: i@j]! !

!Matrix methodsFor: 'accessing' stamp: 'len 5/29/2020 06:14:33'!
rowAt: i put: aTuple
	aTuple withIndexDo: [:each :j| self at: i@j put: each]! !

!Matrix methodsFor: 'accessing' stamp: 'len 5/29/2020 06:55:51'!
rows
	^ (Iterator on: self performing: #rowsDo:) asArray! !

!Matrix methodsFor: 'accessing' stamp: 'len 5/29/2020 04:58:46'!
width
	^ domain rank! !

!Matrix methodsFor: 'comparing' stamp: 'len 5/15/2019 23:48:39'!
= anObject
	anObject isMatrix ifFalse: [^ false].
	self height = anObject height ifFalse: [^ false].
	self width = anObject width ifFalse: [^ false].
	1 to: self height do: [:i|
		1 to: self width do: [:j|
			(self at: i@j) = (anObject at: i@j) ifFalse: [^ false]]].
	^ true! !

!Matrix methodsFor: 'comparing' stamp: 'len 3/13/2021 12:29:55'!
~ aMatrix
	"Answer true if the receiver is similar to aMatrix.
	Two matrices A and B are 'similar' if there exists an invertible matrix P such that B = P^-1 * A * P. This is the conjugacy equivalence relation in GL."
	^ self characteristicMatrix SNF diagonal = aMatrix characteristicMatrix SNF diagonal! !

!Matrix methodsFor: 'comparing' stamp: 'len 4/5/2018 15:31:22'!
hash
	| answer |
	answer _ 0.
	1 to: self height do: [:i|
		1 to: self width do: [:j|
			answer _ answer hashMultiply + (self at: i@j) hash]].
	^ answer! !

!Matrix methodsFor: 'constants' stamp: 'len 5/30/2020 16:08:45'!
zero
	| zero |
	zero _ self scalars zero.
	^ self class from: domain to: codomain filling: [:i :j| zero]! !

!Matrix methodsFor: 'converting' stamp: 'len 4/1/2021 06:34:34'!
asMatrix
	^ self! !

!Matrix methodsFor: 'converting' stamp: 'len 5/29/2020 15:24:59'!
asPolynomial
	"If the receiver is a linear form, answer the receiver as a polynomial in the coordinate ring of the domain."
	| P |
	self isLinearForm ifFalse: [DomainError signal: 'not a linear form'].
	P _ self domain coordinateRing.
	^ (P^P rank filling: [:i| P x: i])  (self asTuple over: P)! !

!Matrix methodsFor: 'converting' stamp: 'len 6/7/2020 13:03:40'!
asRationalMap
	| P polynomials |
	P _ self domain coordinateRing.
	polynomials _ (self over: P) * (P^P rank filling: [:i| P x: i]).
	^ RationalMap from: P spec to: self codomain coordinateRing spec representatives: polynomials! !

!Matrix methodsFor: 'converting' stamp: 'len 5/29/2020 10:59:00'!
asTensor
	"Answer the tensor expansion of the receiver."
	^ self domain dual  self codomain evaluating: [:indices| self at: indices second @ indices first]! !

!Matrix methodsFor: 'converting' stamp: 'len 7/30/2021 14:17:59'!
asTuple
	"Answer the receiver converted to Tuple by concatenating its rows (which is also the coordinates of the receiver in the canonical basis)."
	| answer |
	answer _ (self scalars^0) zero.
	self rowsDo: [:each| answer _ answer, each].
	^ answer! !

!Matrix methodsFor: 'copying' stamp: 'len 5/30/2020 14:20:22'!
coproject: aList
	^ self class from: (self  scalars ^ aList size) to: self codomain columns: (aList collect: [:j| self columnAt: j])! !

!Matrix methodsFor: 'copying' stamp: 'len 5/29/2020 09:32:24'!
copyFrom: aPoint to: anotherPoint
	"Answer the submatrix of the receiver from aPoint to anotherPoint."

	| start |
	start _ aPoint - (1@1).
	^ self class
		from: (domain copyFrom: aPoint y to: anotherPoint y)
		to: (codomain copyFrom: aPoint x to: anotherPoint x)
		filling: [:i :j| self at: start + (i@j)]! !

!Matrix methodsFor: 'copying' stamp: 'len 5/29/2020 09:07:35'!
copyFromColumn: start to: end
	^ self class from: (domain copyFrom: start to: end) to: codomain columns: ((start to: end) collect: [:each| self columnAt: each])! !

!Matrix methodsFor: 'copying' stamp: 'len 5/29/2020 09:07:53'!
copyFromRow: start to: end
	^ self class from: domain to: (codomain copyFrom: start to: end) rows: ((start to: end) collect: [:each| self rowAt: each])! !

!Matrix methodsFor: 'copying' stamp: 'len 4/2/2021 09:10:57'!
copyWithoutZeroColumns
	^ Matrix to: self codomain columns: (self columns select: [:each| each isZero not])! !

!Matrix methodsFor: 'copying' stamp: 'len 4/2/2021 09:10:29'!
copyWithoutZeroRows
	^ Matrix from: self domain rows: (self rows select: [:each| each isZero not])! !

!Matrix methodsFor: 'copying' stamp: 'len 5/30/2020 14:20:45'!
project: aList
	^ self class from: self domain to: (self scalars ^ aList size) rows: (aList collect: [:i| self rowAt: i])! !

!Matrix methodsFor: 'enumerating' stamp: 'len 3/24/2018 19:27:46'!
allSatisfy: aBlock
	self do: [:each| (aBlock value: each) ifFalse: [^ false]].
	^ true! !

!Matrix methodsFor: 'enumerating' stamp: 'len 7/13/2020 12:01:10'!
collect: aBlock
	^ self class from: self domain to: self codomain filling: [:i :j| aBlock value: (self at: i@j)]! !

!Matrix methodsFor: 'enumerating' stamp: 'len 4/5/2018 15:28:54'!
columnsDo: aBlock
	1 to: self width do: [:i| aBlock value: (self columnAt: i)]! !

!Matrix methodsFor: 'enumerating' stamp: 'len 1/6/2022 11:28:41'!
copivotsDo: aBlock
	"Enumerate the column-style pivot indices. These are the pairs i@j corresponding to the first nonzero entry of each column."
	| j |
	j _ 1.
	self columnsDo: [:each| | i |
		(i _ each pivot) ifNotNil: [aBlock value: i@j].
		j _ j + 1]! !

!Matrix methodsFor: 'enumerating' stamp: 'len 5/29/2020 13:07:39'!
diagonalDo: aBlock
	1 to: (self width min: self height) do: [:i| aBlock value: (self at: i@i)]! !

!Matrix methodsFor: 'enumerating' stamp: 'len 4/5/2018 15:29:50'!
do: aBlock
	1 to: self height do: [:i|
		1 to: self width do: [:j|
			aBlock value: (self at: i@j)]]! !

!Matrix methodsFor: 'enumerating' stamp: 'len 7/14/2019 15:19:46'!
inject: thisValue into: binaryBlock 
	| nextValue |
	nextValue _ thisValue.
	self do: [:each | nextValue _ binaryBlock value: nextValue value: each].
	^ nextValue! !

!Matrix methodsFor: 'enumerating' stamp: 'len 1/6/2022 11:29:18'!
pivotsDo: aBlock
	"Enumerate the row-style pivot indices. These are the pairs i@j corresponding to the first nonzero entry of each row."
	| i |
	i _ 1.
	self rowsDo: [:each| | j |
		(j _ each pivot) ifNotNil: [aBlock value: i@j].
		i _ i + 1]! !

!Matrix methodsFor: 'enumerating' stamp: 'len 4/5/2018 15:43:00'!
rowsDo: aBlock
	1 to: self height do: [:i| aBlock value: (self rowAt: i)]! !

!Matrix methodsFor: 'operations' stamp: 'len 4/26/2021 10:55:09'!
% anInteger
	self scalars ==  ifFalse: [DomainError signal].
	^ self apply: (self scalars / anInteger) projection! !

!Matrix methodsFor: 'operations' stamp: 'len 7/24/2021 14:20:31'!
* anObject
	((self scalars includes: anObject) or: [anObject isInteger]) ifTrue: [^ self collect: [:each| each * anObject]].
	anObject isMatrix ifTrue: [^ self  anObject].
	anObject isTuple ifTrue: [^ self value: anObject].
	(anObject isKindOf: ModuleMap) ifTrue: [^ self  anObject].
	^ DomainError signal! !

!Matrix methodsFor: 'operations' stamp: 'len 5/29/2020 05:57:41'!
+ aMatrix
	aMatrix isMatrix ifFalse: [^ self adapt: aMatrix andSend: #+].
	(self domain = aMatrix domain and: [self codomain = aMatrix codomain])
			ifFalse: [^ DomainError signal: 'domains don''t match'].
	^ self class from: domain to: codomain filling: [:i :j| (self at: i@j) + (aMatrix at: i@j)]! !

!Matrix methodsFor: 'operations' stamp: 'len 3/23/2016 00:21'!
- aMatrix
	^ self + aMatrix negated! !

!Matrix methodsFor: 'operations' stamp: 'len 8/28/2021 10:55:50'!
/ anObject
	"Answer X such that XA = B, where B is self and A is the argument. X is called a colift (or extension) of B along A and it is noted B/A.
	If the argument is a scalar, just divide each element of the matrix by the scalar."
	(anObject isMatrix and: [self scalars = anObject scalars]) ifTrue: [^ anObject colift: self].
	^ super / anObject! !

!Matrix methodsFor: 'operations' stamp: 'len 1/3/2022 10:51:25'!
@ aPrimeIdeal
	"Answer the localization of the receiver at aPrimeIdeal."
	^ self apply: self scalars -> (self scalars @ aPrimeIdeal)! !

!Matrix methodsFor: 'operations' stamp: 'len 8/28/2021 10:57:03'!
\ aMatrix
	"Answer X such that AX = B, where A is self and B is aMatrix. X is called a lift of B along A and it is noted A\B.
	The argument can also be a tuple, in which case it is considered as a column matrix and the returned value is also a tuple.
	Answer nil if there's no solution.
	This is the 'backslash' operator, as implemented in MATLAB, Octave and Sage."
	(aMatrix isMatrix and: [self scalars = aMatrix scalars]) ifTrue: [^ self lift: aMatrix].
	(aMatrix isTuple and: [self scalars = aMatrix scalars]) ifTrue: [^ (self lift: aMatrix asMatrix) ifNotNil: [:answer| answer asTuple]].
	^ super \ aMatrix! !

!Matrix methodsFor: 'operations' stamp: 'len 5/9/2020 19:06:10'!
^ anInteger
	"Answer the receiver raised to the power anInteger."
	anInteger = 1 ifTrue: [^ self].
	anInteger = 0 ifTrue: [^ self identity].
	anInteger < 0 ifTrue: [^ self inverse ^ anInteger negated].
	^ anInteger even ifTrue: [self squared ^ (anInteger // 2)] ifFalse: [self squared ^ (anInteger // 2) * self]! !

!Matrix methodsFor: 'operations' stamp: 'len 5/31/2020 06:35:21'!
 aMatrix
	| rows columns |
	aMatrix isMatrix ifFalse: [^ super  aMatrix].
	self domain = aMatrix codomain ifFalse: [^ DomainError signal: 'domains don''t match'].
	rows _ self rows asArray.
	columns _ aMatrix columns asArray.
	^ self class from: aMatrix domain to: self codomain filling: [:i :j| (rows at: i)  (columns at: j)]! !

!Matrix methodsFor: 'operations' stamp: 'len 3/24/2021 09:07:39'!
 aMatrix
	"Answer the block sum of the receiver and the argument.
	If the receiver is A and the argument is B, output a matrix of the form:
	  [A 0]
	  [0 B]"
	aMatrix isMatrix ifFalse: [^ super  aMatrix].
	^ self class from: domain  aMatrix domain to: codomain  aMatrix codomain filling: [:i :j| self at: i@j ifAbsent: [aMatrix at: i-self height@(j - self width) ifAbsent: [self scalars zero]]]! !

!Matrix methodsFor: 'operations' stamp: 'len 4/28/2021 11:37:22'!
 aMatrix
	"Answer the Kronecker product of the receiver by the argument."
	| m n p q |
	aMatrix isTuple ifTrue: [^ self  aMatrix asMatrix].
	aMatrix isMatrix ifFalse: [^ super  aMatrix].
	self checkScalarsMatch: aMatrix.
	m _ self height.
	n _ self width.
	p _ aMatrix height.
	q _ aMatrix width.
	^ self scalars^(n*q)
		to: self scalars^(m*p)
		filling: [:i :j|
			(self at: (i-1)*m//(m*p)+1 @ ((j-1)*n//(n*q)+1)) *
			(aMatrix at: (i-1)\\p+1 @ ((j-1)\\q+1))]! !

!Matrix methodsFor: 'operations' stamp: 'len 1/3/2022 20:47:39'!
 aMatrix
	"Answer the product morphism of the receiver and the argument.
	This is the row-augmented matrix with the receiver stacked on top of the argument.
	If the receiver is A and the argument is B, output a matrix of the form:
	  [A]
	  [B]"
	aMatrix isTuple ifTrue: [^ self  aMatrix asRowMatrix].
	aMatrix isMatrix ifFalse: [^ super  aMatrix].
	domain = aMatrix domain ifFalse: [DomainError signal: 'domains don''t match'].
	"aMatrix isEmpty ifTrue: [^ self].
	self isEmpty ifTrue: [^ aMatrix]."
	^ self class from: domain to: codomain  aMatrix codomain rows: self rows, aMatrix rows! !

!Matrix methodsFor: 'operations' stamp: 'len 1/3/2022 20:47:46'!
 aMatrix
	"Answer the coproduct morphism of the receiver and the argument.
	This is the column-augmented matrix with the receiver concatenated with the argument.
	If the receiver is A and the argument is B, output a matrix of the form:
	  [A B]"
	aMatrix isTuple ifTrue: [^ self  aMatrix asMatrix].
	aMatrix isMatrix ifFalse: [^ super  aMatrix].
	codomain = aMatrix codomain ifFalse: [DomainError signal: 'codomains don''t match'].
	"aMatrix isEmpty ifTrue: [^ self].
	self isEmpty ifTrue: [^ aMatrix]."
	^ self class from: domain  aMatrix domain to: codomain columns: self columns, aMatrix columns! !

!Matrix methodsFor: 'operations' stamp: 'len 7/15/2021 12:37:58'!
adjugate
	"Answer the adjugate matrix (or classical adjoint matrix) of the receiver. This is the matrix such that multiplicated at the left by the receiver equals the scalar matrix with the determinant of the receiver in the diagonal."
	| f |
	f _ self characteristicPolynomial >> 1.
	^ (self height odd ifTrue: [f] ifFalse: [f negated]) value: self! !

!Matrix methodsFor: 'operations' stamp: 'len 8/10/2020 05:34:21'!
antitranspose
	^ self class from: codomain to: domain rows: (self columns reversed collect: [:each| each reversed])! !

!Matrix methodsFor: 'operations' stamp: 'len 12/18/2021 20:27:41'!
apply: aMorphism
	"Apply a homomorphism to the coefficients of the receiver."
	^ aMorphism codomain matrix: self extent filling: [:i :j| aMorphism value: (self at: i@j)]! !

!Matrix methodsFor: 'operations' stamp: 'len 1/1/2022 21:10:51'!
berkowitz
	"Answer the coefficients of the characteristic polynomial of the receiver.
	It's computed by the Berkowitz division-free algorithm and works over any commutative ring.
	It uses small space in comparision with classic gaussian elimination and performs O(n^4) scalar operations."
	| v C Ar R S Q one |
	self isSquare ifFalse: [^ self error: 'not square'].
	one _ self scalars one.
	self height = 0 ifTrue: [^ self scalars tuple: {one}].
	self height = 1 ifTrue: [^ self scalars tuple: {one. (self at: 1@1) negated}].
	self height = 2 ifTrue:
			[^ self scalars tuple:
				{one.
				((self at: 1@1) + (self at: 2@2)) negated.
				(self at: 1@1) * (self at: 2@2) - ((self at: 1@2) * (self at: 2@1))}].

	v _ self scalars tuple:
		{one.
		(self at: 2@2) negated - (self at: 1@1).
		(self at: 2@2) * (self at: 1@1) - ((self at: 1@2) * (self at: 2@1))}.

	3 to: self height do: [:r|
		C _ (self scalars^r => (self scalars^(r+1))) zero.
		Ar _ self copyFrom: 1@1 to: r-1 @ (r-1).

		R _ (self rowAt: r) copyFrom: 1 to: r-1.
		S _ (self columnAt: r) copyFrom: 1 to: r-1.

		C at: 1@1 put: one negated.
		C at: 2@1 put: (self at: r@r).
		C at: 3@1 put: (R  S).

		Q _ Ar * S.

		C at: 4@1 put: (R  Q).

		3 to: r-1 do: [:i|
			Q _ Ar * Q.
			C at: i+2 @ 1 put: (R  Q)].

		2 to: r do: [ :i |
			0 to: r+1-i do: [ :j |
				C at: i+j @ i put: (C at: j+1 @ 1)]].

		v _ C * v].

	^ self height even ifTrue: [v] ifFalse: [v negated]! !

!Matrix methodsFor: 'operations' stamp: 'len 1/1/2022 11:25:39'!
characteristicMatrix
	"Answer the characteristic matrix I*x - A."
	| P x |
	P _ self scalars polynomials.
	x _ P x.
	^ P^self width to: P^self height filling: [:i :j|
		i = j
			ifTrue: [x - (P constant: (self at: i @ j))]
			ifFalse: [P constant: (self at: i @ j) negated]]! !

!Matrix methodsFor: 'operations' stamp: 'len 1/1/2022 19:56:27'!
characteristicPolynomial
	^ self scalars polynomials coefficients: self berkowitz reversed

"TODO: best algorithms choices are:
	- for Z use modular algorithm: compute modulo p for many primes p, then CRT;
	- for finite fields (fields with no coefficient explosion) use Hessenberg form with O(n^3);
	- for general ring, use Berkowitz"
! !

!Matrix methodsFor: 'operations' stamp: 'len 7/31/2021 16:12:04'!
characteristicPolynomial3
	"COHEN Algorithm 2.2.7. (Characteristic Polynomial and Adjoint Matrix) O(n^4).
	This is the Faddeev-Leverrier algorithm and works over a commutative ring of characteristic 0 or characteristic coprime to 1..n. It also computes the determinant as a side product."
	| n i I C a |
	n _ self height.
	i _ 0. I _ self identity. C _ I. a _ OrderedCollection new: n+1.
	a add: self scalars one.
	[(i _ i + 1) = n
		ifTrue:
			[a add: (self * C) trace negated / n.
			^ self scalars polynomials coefficients: a reversed. "adj _ (-1)^(n-1) * C"].
	C _ self * C.
	a add: C trace negated / i.
	C _ C + (I * a last)] repeat! !

!Matrix methodsFor: 'operations' stamp: 'len 7/31/2021 16:25:07'!
characteristicPolynomial4
	"This is the Faddeev-Leverrier algorithm to compute the characteristic polynomial, adjoint matrix and determinant of a matrix. It works over a commutative ring of characteristic 0 or characteristic coprime to 1..n. It runs in O(n^4)."
	| n p I B |
	n _ self height.
	p _ Array new: n+1.
	p at: n+1 put: self scalars one.
	I _ self identity.
	B _ I.
	1 to: n-1 do: [:k|
		B _ self*B.
		B _ B + (I*(p at: n-k+1 put: B trace negated / k))].
	p at: 1 put: (self*B) trace negated / n.
	^ self scalars polynomials coefficients: p! !

!Matrix methodsFor: 'operations' stamp: 'len 4/5/2018 15:40:42'!
characteristicPolynomialAndAdjoint
	"COHEN Algorithm 2.2.7. (Characteristic Polynomial and Adjoint Matrix) O(n^4)."
	| n i I C a |
	n _ self height.
	i _ 0. I _ self identity. C _ I. a _ OrderedCollection new: n.
	a add: self scalars one.
	[(i _ i + 1) = n
		ifTrue:
			[a add: (self * C) trace negated / n.
			^ {self scalars polynomials coefficients: a reversed. (-1)^(n-1) * C}].
	C _ self * C.
	a add: C trace negated / i.
	C _ C + (I * a last)] repeat! !

!Matrix methodsFor: 'operations' stamp: 'len 10/13/2016 14:00'!
cofactor: aPoint
	"Answer the cofactor i@j of the receiver."

	^ (aPoint x + aPoint y) even
		ifTrue: [self minor: aPoint]
		ifFalse: [(self minor: aPoint) negated]! !

!Matrix methodsFor: 'operations' stamp: 'len 5/3/2021 10:57:09'!
columnExtended
	"Answer a square full rank matrix, adding columns if needed."
	| M |
	(self isSquare and: [self isFullRank]) ifTrue: [^ self].
	M _ self  self codomain id.
	^ Matrix from: self codomain to: self codomain columns: (M independentColumns collect: [:i| M columnAt: i])! !

!Matrix methodsFor: 'operations' stamp: 'len 8/9/2020 07:53:30'!
comatrix
	"Answer the co-matrix (or cofactor matrix) of the receiver, i.e. the matrix '(a{ij})' where 'a{ij}' is the cofactor 'ij'."
	^ self adjugate transpose! !

!Matrix methodsFor: 'operations' stamp: 'len 7/21/2021 18:09:56'!
conjugate
	"Answer the conjugate of the receiver. This is the involution of the matrix algebra."
	^ self scalars isInvolutive ifTrue: [self transpose collect: [:each| each conjugate]] ifFalse: [self transpose]! !

!Matrix methodsFor: 'operations' stamp: 'len 7/17/2019 11:00:49'!
content
	"Answer the GCD of the coefficients of the receiver."
	| answer |
	self isZero ifTrue: [^ self scalars zero].
	self scalars isField ifTrue: [^ self scalars one].
	answer _ self scalars zero.
	self do: [:each| answer _ answer gcd: each].
	^ answer! !

!Matrix methodsFor: 'operations' stamp: 'len 1/1/2022 21:12:12'!
determinant
	| a0 |
	self isSquare ifFalse: [self error: 'not square matrix'].
	self isEmpty ifTrue: [^ self scalars one].
	self scalars isField ifTrue: [^ (GaussianElimination on: self) determinant].
	a0 _ self characteristicPolynomial independentCoefficient.
	^ self height even ifTrue: [a0] ifFalse: [a0 negated]! !

!Matrix methodsFor: 'operations' stamp: 'len 7/12/2019 04:58:17'!
determinant1
	| a0 |
	a0 _ self characteristicPolynomial independentCoefficient.
	^ self height even ifTrue: [a0] ifFalse: [a0 negated]! !

!Matrix methodsFor: 'operations' stamp: 'len 4/5/2018 15:41:59'!
determinant2
	"COHEN Algorithm 2.2.6. (Determinant using Gauss-Bareiss). O(n^3)"
	| n M k c s p i t |
	self assert: self scalars isIntegralDomain.
	self assert: self isSquare.
	n _ self height.
	M _ self copy.
	k _ 0. c _ self scalars one. s _ self scalars one.
	[k _ k + 1.
	k = n ifTrue: [^ s * (M at: n@n)].
	p _ M at: k@k. i _ k.
	p isZero ifTrue: [i _ (k+1 to: n) detect: [:j| (M at: j@k) isZero not] ifNone: [^ self scalars zero]].
	k to: n do: [:j| t _ M at: i@j. M at: i@j put: (M at: k@j). M at: k@j put: t].
	s _ s negated.
	p _ M at: k@k.
	"the division t/c is exact, must use Euclidean division and discard the remainder"
	c | t ifFalse: [self halt].
	k+1 to: n do: [:j| t _ p * (M at: i@j) - ((M at: i@k) * (M at: k@j)). M at: i@j put: t/c].
	c _ p] repeat! !

!Matrix methodsFor: 'operations' stamp: 'len 1/1/2022 19:51:07'!
determinant3
	self isSquare ifFalse: [self error: 'not square matrix'].
	self isEmpty ifTrue: [^ self scalars one].
	^ (1 to: self height) sum: [:i| (self at: i@1) * (self cofactor: i@1)]! !

!Matrix methodsFor: 'operations' stamp: 'len 7/27/2020 14:31:31'!
determinantModular
	| B C n r moduli determinants |
	B _ 0.
	self do: [:each| B _ B max: each abs].
	n _ self width.
	C _ (n^n) sqrt * (B^n).
	r _ (C log: 2) ceiling.
	moduli _ OrderedCollection new: r.
	moduli add: 2.
	r - 1 timesRepeat: [moduli add: moduli last nextPrime].
	determinants _ moduli collect: [:each| (self % each) determinant].
	^ determinants "(CRT solve: determinants) lift"! !

!Matrix methodsFor: 'operations' stamp: 'len 4/5/2018 15:29:05'!
determinantx
	(self height = 2 and: [self width = 2])
		ifTrue: [^ (self at: 1@1) * (self at: 2@2) - ((self at: 2@1) * (self at: 1@2))].
	^ self determinant! !

!Matrix methodsFor: 'operations' stamp: 'len 5/29/2020 15:17:41'!
hadamard: aMatrix
	"Answer the entrywise product of the receiver with the argument (also called Hadamard produect or Schur product)."
	self checkDimensionMatch: aMatrix.
	self checkScalarsMatch: aMatrix.
	^ self class from: domain to: codomain filling: [:i :j| (self at: i@j) * (aMatrix at: i@j)]! !

!Matrix methodsFor: 'operations' stamp: 'len 5/29/2020 13:40:04'!
index
	"Answer the index of the receiver, assuming it is an endomorphism.
	This is precisely the Euler characteristic of the 2-term complex 0 -> domain -> codomain -> 0."
	^ self kernel rank - self cokernel rank! !

!Matrix methodsFor: 'operations' stamp: 'len 1/7/2022 14:24:56'!
minimalPolynomial
	| P n answer |
	self isSquare ifFalse: [DomainError signal: 'not a square matrix'].
	self scalars isIntegralDomain ifFalse: [DomainError signal: 'not over an integral domain'].
	P _ self scalars polynomials.
	n _ self width.
	answer _ P one.
	self codomain basis do: [:ei| "It's not necessary to iterate over the whole basis"
		| v L K s |
		v _ ei.
		L _ OrderedCollection new: n + 1.
		L add: v.
		[v _ self * v.
		L add: v.
		K _ (Matrix columns: L) syzygies.
		K isZero] whileTrue.
		K _ K coechelon.
		s _ K columns first.
		answer _ answer lcm: (P coefficients: s / s last).
		answer degree = n ifTrue: [^ answer]].
	^ answer! !

!Matrix methodsFor: 'operations' stamp: 'len 12/18/2021 20:28:04'!
minor: aPoint
	"Answer the i@j-minor, i.e. the determinant of the matrix obtained by removing row i and column j from the receiver."
	^ (self scalars
		matrix: self height - 1 @ (self width - 1)
		filling: [:i :j|
			| x y |
			i < aPoint x ifTrue: [x _ i] ifFalse: [x _ i + 1].
			j < aPoint y ifTrue: [y _ j] ifFalse: [y _ j + 1].
			self at: x@y]) determinant! !

!Matrix methodsFor: 'operations' stamp: 'len 12/18/2021 20:29:38'!
minors: k
	"Answer the list of all the k-minors of the receiver, i.e. the determinants of all matrices obtained by deleting m - k rows and n - k columns."
	| answer |
	answer _ OrderedCollection new.
	(1 to: self height) combinations: k atATimeDo: [:rows|
		(1 to: self width) combinations: k atATimeDo: [:columns|
			answer add: (self scalars matrix: k@k filling: [:i :j| self at: (rows at: i) @ (columns at: j)]) determinant]].
	^ answer! !

!Matrix methodsFor: 'operations' stamp: 'len 3/23/2016 00:23'!
negated
	^ self collect: [:each| each negated]! !

!Matrix methodsFor: 'operations' stamp: 'len 1/7/2022 14:25:59'!
normalization
	"Answer a unit u such that 'self * u' is a unique choice of associate. See >>normalized."
	self isSquare ifFalse: [^ self error: 'not square'].
	self scalars isPID ifFalse: [^ self].
	^ self coechelonization! !

!Matrix methodsFor: 'operations' stamp: 'len 1/7/2022 14:23:27'!
normalized
	"Answer a unique choice of associate. See >>normalization."
	self isSquare ifFalse: [^ self error: 'not square'].
	self scalars isPID ifFalse: [^ self].
	^ self coechelon! !

!Matrix methodsFor: 'operations' stamp: 'len 4/5/2018 15:33:02'!
nullity
	^ self width - self rank! !

!Matrix methodsFor: 'operations' stamp: 'len 12/20/2021 13:27:10'!
permanent
	| n |
	self isSquare ifFalse: [DomainError signal: 'not a square matrix'].
	n _ self width.
	^ (SymmetricGroup new: n)
			sum: [:aPermutation| (1 to: n) product: [:i| self atRow: i column: (aPermutation value: i)]]! !

!Matrix methodsFor: 'operations' stamp: 'len 12/11/2015 00:14'!
pseudoInverse
	"Answer the Moore-Penrose pseudoinverse matrix of the receiver."
	^ self notYetImplemented! !

!Matrix methodsFor: 'operations' stamp: 'len 3/28/2021 15:12:00'!
rank
	^ self echelon rows count: [:each| each isZero not]! !

!Matrix methodsFor: 'operations' stamp: 'len 3/31/2021 09:42:21'!
rowExtended
	"Answer a square full rank matrix, adding rows if needed."
	^ self transpose columnExtended transpose! !

!Matrix methodsFor: 'operations' stamp: 'len 11/3/2015 20:35'!
squared
	^ self * self! !

!Matrix methodsFor: 'operations' stamp: 'len 4/5/2018 15:43:14'!
trace
	| answer |
	self isSquare ifFalse: [^ DomainError signal: 'not a square matrix'].
	answer _ self scalars zero.
	1 to: self height do: [:i| answer _ answer + (self at: i@i)].
	^ answer! !

!Matrix methodsFor: 'operations' stamp: 'len 8/9/2020 07:50:20'!
transpose
	^ self class from: codomain to: domain filling: [:i :j| self at: j@i]! !

!Matrix methodsFor: 'operations' stamp: 'len 5/31/2020 16:54:22'!
value: aTuple
"	(self domain includes: aTuple) ifFalse: [^ DomainError signal]."
	^ self codomain filling: [:i| (self rowAt: i)  aTuple]
"	self isEmpty ifTrue: [^ aTuple scalars tuple: #()].
	(self height = 0 or: [self width = aTuple size])
		ifFalse: [^ DomainError signal: 'dimensions don''t match'].
	self scalars >= aTuple scalars
		ifTrue: [^ self codomain filling: [:i| (self rowAt: i)  aTuple]].
	self scalars <= aTuple scalars
		ifTrue: [^ (self codomain over: aTuple scalars) filling: [:i| (self rowAt: i)  aTuple]].
	^ DomainError signal: 'base rings don''t match'"! !

!Matrix methodsFor: 'reduction' stamp: 'len 4/26/2021 10:54:56'!
CHNF
	"Answer the column-style Hermite normal form of the receiver."
	| D |
	self isEmpty ifTrue: [^ self].
	self scalars ==  ifTrue: [^ (HermiteColumnReduction on: self) reduced].
	self scalars ==  ifFalse: [^ DomainError signal: 'nonrational coefficients'].
	D _ self denominator.
	^ (HermiteColumnReduction on: self * D) reduced / D! !

!Matrix methodsFor: 'reduction' stamp: 'len 12/26/2021 12:33:11'!
HNF
	"Answer the (row-style) Hermite normal form of the receiver."
	self isEmpty ifTrue: [^ self].
	self scalars isLocalization ifTrue: [^ (self numerator HNF over: self scalars) / self denominator].
	^ (HermiteReduction on: self) reduced
"
alternative:
	^ self antitransposed CHNF antitransposed
"! !

!Matrix methodsFor: 'reduction' stamp: 'len 12/23/2021 17:50:05'!
HNFAndTransformation
	"Answer the (row-style) Hermite normal form H of the receiver A and the unique unimodular matrix T such that T*A = H."
	| reduction |
	self scalars isLocalization ifTrue:
		[| HT |
		HT _ self numerator HNFAndTransformation.
		^ {(HT first over: self scalars) / self denominator. HT second over: self scalars}].
	reduction _ HermiteReduction on: self extension: self codomain id.
	^ {reduction reduced. reduction extension}! !

!Matrix methodsFor: 'reduction' stamp: 'len 8/10/2020 05:28:40'!
LLL
	"Answer the LLL reduced form of the receiver."
	^ Matrix columns: (LLL basis: self columns innerProduct: self codomain innerProduct) reducedBasis! !

!Matrix methodsFor: 'reduction' stamp: 'len 5/29/2020 15:05:40'!
PRCF
	"Answer the primary rational canonical form of the receiver, assuming it's a square matrix over a field.
	The PRCF reflects a decomposition of the vector space into a maximal number of cyclic subspaces. Unlike the RCF, finding this form requires factorization of polynomials over the coefficients field, and as a consequence the primary rational canonical form may change when the same matrix is considered over an extension field of the coefficients field."
	^ self primaryInvariantFactors inject: (self scalars^0) id into: [:result :each| result  each companion]! !

!Matrix methodsFor: 'reduction' stamp: 'len 5/29/2020 15:06:07'!
RCF
	"Answer the Frobenius normal form (or rational canonical form) of the receiver, assuming it's a square matrix over a field.
	The RCF of a matrix A reflects a minimal decomposition of the vector space into subspaces that are cyclic for A (i.e., spanned by some vector and its repeated images under A). A matrix B is similar to A iff it has the same rational canonical form as A. Unlike the PRCF, finding this form doesn't require factorization of polynomials or any operation that might change when extending the coefficients field (hence the 'rational'), showing that matrix similarity does not change upon field extensions."
	^ self invariantFactors inject: (self scalars^0) id into: [:result :each| result  each companion]! !

!Matrix methodsFor: 'reduction' stamp: 'len 12/20/2021 13:25:43'!
SNF
	"Given a matrix with coefficients in a PID, answer the Smith normal form of the receiver.
	The Smith normal form is very useful for working with finitely generated modules over a PID, and in particular for deducing the structure of a quotient of a free module.
	This is a naive implementation of Kannan-Bachem algorithm."
	| S a n |
	self isEmpty ifTrue: [^ self].
	"Repeatedly compute the Hermite normal form and transpose until a diagonal form is obtained:"
	S _ self HNF.
	[S isDiagonal] whileFalse: [S _ S transpose HNF transpose HNF].
	"Once in diagonal form, substitute neighboring diagonal elements by their GCD and LCM"
	n _ ((S width min: S height) to: 2 by: -1) detect: [:i| (S atRow: i column: i) isZero not] ifNone: [^ S].
	[a _ S atRow: 1 column: 1.
	2 to: n do: [:i| | b gcd |
		b _ S atRow: i column: i.
		S atRow: i-1 column: i-1 put: (gcd _ a gcd: b). "GCD"
		S atRow: i column: i put: (a _ a // gcd * b) "LCM"].
	S isSmithNormalForm] whileFalse.
	^ S! !

!Matrix methodsFor: 'reduction' stamp: 'len 5/31/2020 20:24:20'!
SNF2
	"Answer the Smith normal form of the receiver. Perform first a HNF reduction."
	| H n |
	H _ self HNF.
	n _ H diagonal findLast: [:each| each isZero not].
	^ (H copyFrom: 1@1 to: n@n) SNF  (self scalars ^ ((H width max: H height) - n)) endomorphisms zero! !

!Matrix methodsFor: 'reduction' stamp: 'len 5/31/2020 20:24:46'!
SNFAfterHNF
	"Answer the Smith normal form of the receiver. Perform first a HNF reduction."
	| H n |
	H _ self HNF.
	n _ H diagonal findLast: [:each| each isZero not].
	^ (H copyFrom: 1@1 to: n@n) SNF  (self scalars^((H width max: H height) - n)) endomorphisms zero! !

!Matrix methodsFor: 'reduction' stamp: 'len 12/23/2021 17:50:15'!
SNFAndTransformations
	"Answer the Smith normal form S of the receiver A and the unique unimodular matrices P and Q such that P*A*Q = S.
	This is a naive implementation of Kannan-Bachem algorithm."
	| HT S a n P Q |
	"Repeatedly compute the Hermite normal form and transpose until a diagonal form is obtained:"
	P _ self codomain id.
	Q _ self domain id.
	HT _ self HNFAndTransformation.
	S _ HT first. P _ HT second.
	[S isDiagonal] whileFalse:
		[HT _ S transpose HNFAndTransformation.
		Q _ HT second transpose * Q.
		HT _ HT first transpose HNFAndTransformation.
		S _ HT first. P _ P * HT second].
	"Once in diagonal form, substitute neighboring diagonal elements by their GCD and LCM"
	n _ ((S width min: S height) to: 2 by: -1) detect: [:i| (S atRow: i column: i) isZero not] ifNone: [^ S].
	"TODO: update P and Q"
	[a _ S atRow: 1 column: 1.
	2 to: n do: [:i| | b gcd |
		b _ S atRow: i column: i.
		S atRow: i-1 column: i-1 put: (gcd _ a gcd: b). "GCD"
		S atRow: i column: i put: (a _ a // gcd * b) "LCM"].
	S isSmithNormalForm] whileFalse.
	^ {S. P. Q}! !

!Matrix methodsFor: 'reduction' stamp: 'len 1/2/2022 10:01:17'!
SNFOneStep
	| L S R zero one j k |
	L _ self codomain id.
	R _ self domain id.
	(self isEmpty or: [self isZero]) ifTrue: [^ {L. self. R}].
	S _ self copy.
	zero _ self scalars zero.
	one _ self scalars one.

	"put a nonzero column as first column"
	j _ 1.
	[(S columnAt: j) isZero] whileTrue: [j _ j + 1].
	j > 1 ifTrue: [R at: 1@1 put: zero; at: j@j put: zero; at: 1@j put: one; at: j@1 put: one negated. S _ S * R].

	self assert: self * R = S.

	"put a nonzero value at 1@1:"
	k _ 1.
	[(S at: k@1) isZero] whileTrue: [k _ k + 1].
	k > 1 ifTrue: [L at: 1@1 put: zero; at: k@k put: zero; at: 1@k put: one; at: k@1 put: one negated. S _ L * S].

	self assert: L * self * R = S.

	2 to: S height do: [:i| | a1 ai euclid c d e f M |
		a1 _ S at: 1@1.
		ai _ S at: i@1.
		ai | a1 ifFalse:
			[euclid _ ExtendedEuclid on: {a1. ai}.
			c _ euclid bezout at: 1.
			d _ (euclid bezout at: 2) negated.
			self assert: a1*c - (ai*d) = euclid gcd.
			e _ ai negated / euclid gcd.
			f _ a1 / euclid gcd.
			self assert: d*e + (c*f) = self scalars one.
			M _ S codomain id.
			M at: 1@1 put: c; at: 1@i put: d negated; at: i@1 put: e; at: i@i put: f.
			self assert: M determinant = self scalars one.
			S _ M * S.
			L _ M * L.
			self assert: L * self * R = S]].

	"now everything in column 1 is divisible by the pivot at 1@1:"
	2 to: S height do: [:i| | x |
		x _ (S at: i@1) negated / (S at: 1@1).
		S addRow: 1 times: x toRow: i.
		L addRow: 1 times: x toRow: i].

	self assert: L * self * R = S.

	"if anything at the right of the pivot in the first row is not zero, we recurse
	(the algorithm must termiate if the cofficients ring is Noetherian)"
	((j+1 to: self width) allSatisfy: [:jj| (S at: 1@jj) isZero])
		ifFalse:
			[| result |
			result _ S transpose SNFOneStep.
			L _ (result at: 3) * L.
			S _ (result at: 2) transpose.
			R _ R * (result at: 1) transpose].

	^ {L. S. R}! !

!Matrix methodsFor: 'reduction' stamp: 'len 12/23/2021 17:50:35'!
SNFRecursive
	| L S R LL SS RR I result |
	L _ self codomain id.
	R _ self domain id.
	(self isEmpty or: [self isZero]) ifTrue: [^ {L. self. R}].

	result _ self SNFOneStep.
	L _ result at: 1.
	S _ result at: 2.
	R _ result at: 3.
	result _ (S copyFrom: 2@2 to: S extent) SNFRecursive.
	LL _ result at: 1.
	SS _ result at: 2.
	RR _ result at: 3.
	
	I _ (self scalars^1) id.
	L _ I  LL * L.
	S _ (I * (S at: 1@1))  SS.
	R _ R * (I  RR).

	"TODO: fix diagonal"
	
	^ {L. S. R}! !

!Matrix methodsFor: 'reduction' stamp: 'len 1/9/2022 13:13:14'!
basis
	self propertyAt: #basisAndTransformation ifPresent: [:anArray| anArray first].
	^ self propertyAt: #basis ifAbsentPut: [self scalars basisOf: self]! !

!Matrix methodsFor: 'reduction' stamp: 'len 1/9/2022 13:13:24'!
basisAndTransformation
	^ self propertyAt: #basisAndTransformation ifAbsentPut: [self scalars basisAndTransformationOf: self]! !

!Matrix methodsFor: 'reduction' stamp: 'len 1/6/2022 18:28:18'!
coechelon
	"Answer the column echelon form of the receiver."
	self propertyAt: #coechelonAndTransformation ifPresent: [:anArray| ^ anArray first].
	^ self propertyAt: #coechelon ifAbsentPut: [(self scalars echelonOf: self transpose) transpose]! !

!Matrix methodsFor: 'reduction' stamp: 'len 1/6/2022 18:28:49'!
coechelonization
	"Answer the transformation to column echelon form."
	^ (self propertyAt: #coechelonAndTransformation ifAbsentPut: [(self scalars echelonizationOf: self transpose) collect: [:each| each transpose]]) second! !

!Matrix methodsFor: 'reduction' stamp: 'len 12/31/2021 17:03:30'!
copivots
	"Answer the collection of column-style pivot indices. These are the pairs i@j corresponding to the first nonzero entry of each column."
	^ Iterator on: self performing: #copivotsDo:! !

!Matrix methodsFor: 'reduction' stamp: 'len 4/10/2021 12:28:33'!
dependentColumns
	"Answer the collection of indices of linearly dependent columns."
	| independent d answer |
	independent _ self independentColumns.
	d _ 1.
	answer _ OrderedCollection new: self width - independent size.
	independent do: [:i| answer addAll: (d to: i-1). d _ i+1].
	answer addAll: (d to: self width).
	^ answer! !

!Matrix methodsFor: 'reduction' stamp: 'len 1/6/2022 18:29:19'!
echelon
	"Answer the row echelon form of the receiver."
	self propertyAt: #echelonAndTransformation ifPresent: [:anArray| ^ anArray first].
	^ self propertyAt: #echelon ifAbsentPut: [self scalars echelonOf: self]! !

!Matrix methodsFor: 'reduction' stamp: 'len 1/6/2022 18:29:49'!
echelonization
	"Answer the transformation to row echelon form."
	^ (self propertyAt: #echelonAndTransformation ifAbsentPut: [self scalars echelonizationOf: self]) second! !

!Matrix methodsFor: 'reduction' stamp: 'len 6/9/2019 10:08:46'!
elementaryDivisors
	"Answer the diagonal of the Smith normal form."
	self isEmpty ifTrue: [^ #()].
	self scalars isField ifTrue: [^ (1 to: self rank) collect: [:each| self scalars one]].
	^ self SNF diagonal asArray select: [:each| each isZero not]! !

!Matrix methodsFor: 'reduction' stamp: 'len 7/13/2019 04:31:49'!
hessenberg
	"Answer the matrix similar to the receiver but in upper Hessenberg form (zeroes below the first subdiagonal)."
	^ self notYetImplemented! !

!Matrix methodsFor: 'reduction' stamp: 'len 4/10/2021 12:28:27'!
independentColumns
	"Answer the collection of indices of linearly independent columns."
	^ self echelon pivots collect: [:each| each y]! !

!Matrix methodsFor: 'reduction' stamp: 'len 3/8/2020 19:24:46'!
invariantFactors
	"Answer the invariant factors of the receiver, corresponding to the Frobenius normal form (or rational canonical form), assuming it's a square matrix over a field."
	| R P A AX x |
	R _ self scalars.
	P _ R polynomials.
	x _ P x.
	A _ self over: P.
	AX _ A identity * x - A.
	^ AX elementaryDivisors select: [:each| each degree > 0]! !

!Matrix methodsFor: 'reduction' stamp: 'len 5/31/2020 20:03:40'!
jordan
	"Answer the Jordan blocks of the receiver's Jordan normal form."
	| spectrum blocks one zero |
	spectrum _ self spectrum.
	spectrum size = self height ifFalse: [^ self error: 'the characteristic polynomial doesn''t split'].
"	I _ matrix species identity."
	blocks _ Bag new.
	one _ self scalars one.
	zero _ self scalars zero.
	spectrum asSet do: [:eigenvalue|
		| multiplicity dimensions X T count |
		multiplicity _ spectrum occurrencesOf: eigenvalue.
		dimensions _ OrderedCollection new.
		X _ self - (self parent scalar: eigenvalue).
		T _ X.
		[(dimensions add: T nullity) < multiplicity] whileTrue: [T _ T * X].
		count _ 0.
		dimensions size to: 1 by: -1 do: [:n| | k block |
			k _ (dimensions at: n) - (dimensions at: n-1 ifAbsent: [0]).
			block _ (self scalars^n) endomorphisms filling: [:i :j| i=j ifTrue: [eigenvalue] ifFalse: [j-1=i ifTrue: [one] ifFalse: [zero]]].
			blocks add: block withOccurrences: k - count.
			count _ count + k]].
	^ blocks! !

!Matrix methodsFor: 'reduction' stamp: 'len 8/10/2020 05:25:58'!
orthogonalized
	"Perform the Gram-Schmidt orthogonalization process on the columns of the receiver."
	| orthogonalVectors orthogonalVectorsNorms2 u uv |
	orthogonalVectors _ OrderedCollection new: self width.
	orthogonalVectorsNorms2 _ OrderedCollection new: self width.
	self columns do: [:each|
		u _ each.
		orthogonalVectors with: orthogonalVectorsNorms2 do: [:v :vv|
			uv _ u  v.
			u _ u - (v * uv / vv)].
		orthogonalVectors add: u.
		orthogonalVectorsNorms2 add: u  u].
	^ self class from: domain to: codomain columns: orthogonalVectors! !

!Matrix methodsFor: 'reduction' stamp: 'len 3/7/2017 08:34:26'!
pivots
	"Answer the collection of row-style pivot indices. These are the pairs i@j corresponding to the first nonzero entry of each row."
	^ Iterator on: self performing: #pivotsDo:! !

!Matrix methodsFor: 'reduction' stamp: 'len 8/5/2021 08:40:26'!
primaryInvariantFactors
	^ self characteristicPolynomial factorization! !

!Matrix methodsFor: 'solving' stamp: 'len 12/31/2021 09:30:48'!
codivisionBy: aMatrix
	"Answer X and N such that XA + N = B, where B is self and A is aMatrix, satisfying that if the i-th column of B is a linear combination of the columns of A then the i-th column of N is zero."
	self width = aMatrix width ifFalse: [^ DomainError signal: 'matrix shapes don''t match'].
	^ self scalars matrix: self codivisionBy: aMatrix! !

!Matrix methodsFor: 'solving' stamp: 'len 12/31/2021 09:15:01'!
colift: aMatrix
	"Answer X such that XA = B, where A is self and B is aMatrix. X is called a colift (or extension) of B along A.
	Answer nil if there's no solution."
	^ (self scalars matrix: aMatrix codivisionBy: self) ifNotNil: [:anArray| anArray second isZero ifTrue: [anArray first]]! !

!Matrix methodsFor: 'solving' stamp: 'len 1/4/2022 09:01:04'!
colift: aMatrix modulo: aRelationsMatrix
	"Answer X such that XA = B modulo L, i.e. X such that there exists Y with XA + YL = B, where A is self, B is aMatrix and L is aRelationsMatrix."
	aRelationsMatrix isZero ifTrue: [^ self colift: aMatrix].
	^ (self  aRelationsMatrix transpose colift: aMatrix) ifNotNil: [:X| X copyFromColumn: 1 to: self height]! !

!Matrix methodsFor: 'solving' stamp: 'len 1/14/2022 14:03:11'!
divisionBy: aMatrix
	"Answer X and N such that AX + N = B, where B is self and A is aMatrix, satisfying that if the i-th column of B is a linear combination of the columns of A then the i-th column of N is zero."
	self height = aMatrix height ifFalse: [^ self error: 'matrix shapes don''t match'].
	^ self scalars matrix: self divisionBy: aMatrix! !

!Matrix methodsFor: 'solving' stamp: 'len 1/4/2022 09:00:46'!
divisionBy: aMatrix modulo: aRelationsMatrix
	"Answer X and N such that AX + N = B modulo L, i.e. X and N such that there exists Y with AX + LY + N = B, where B is self, A is aMatrix and L is aRelationsMatrix, satisfying that if the i-th column of B is a linear combination of the columns of A modulo L then the i-th column of N is zero."
	aRelationsMatrix isZero ifTrue: [^ self divisionBy: aMatrix].
	^ (self divisionBy: aMatrix  aRelationsMatrix)
		ifNotNil: [:anArray| {anArray first copyFromRow: 1 to: aMatrix width. anArray second}]! !

!Matrix methodsFor: 'solving' stamp: 'len 12/31/2021 09:38:05'!
lift: aMatrix
	"Answer X such that AX = B, where B is self and A is aMatrix. X is called a lift of B along A.
	Answer nil if there's no solution."
	^ (aMatrix divisionBy: self) ifNotNil: [:anArray| anArray second isZero ifTrue: [anArray first]]! !

!Matrix methodsFor: 'solving' stamp: 'len 1/4/2022 09:01:24'!
lift: aMatrix modulo: aRelationsMatrix
	"Answer X such that AX = B modulo L, i.e. X such that there exists Y with AX + LY = B, where A is self, B is aMatrix and aRelationsMatrix is L."
	aRelationsMatrix isZero ifTrue: [^ self lift: aMatrix].
	^ (self  aRelationsMatrix lift: aMatrix) ifNotNil: [:X| X copyFromRow: 1 to: self width]! !

!Matrix methodsFor: 'solving' stamp: 'len 12/31/2021 09:38:35'!
reduce: aMatrix
	"Answer N with AX + N = B. See >>divisionBy:."
	^ (aMatrix divisionBy: self) second! !

!Matrix methodsFor: 'solving' stamp: 'len 12/31/2021 09:44:29'!
reduce: aMatrix modulo: aRelationsMatrix
	"Answer N with AX + N = B modulo L. See >>divisionBy:modulo:."
	^ (aMatrix divisionBy: self modulo: aRelationsMatrix) second! !

!Matrix methodsFor: 'spectrum' stamp: 'len 5/29/2020 05:03:52'!
eigenspaceAt: anEigenvalue
	^ (self - (self identity * anEigenvalue)) kernel! !

!Matrix methodsFor: 'spectrum' stamp: 'len 2/6/2016 19:39'!
eigenvalues
	^ self spectrum asSet! !

!Matrix methodsFor: 'spectrum' stamp: 'len 2/22/2017 08:46:13'!
spectralRadius
	(self scalars isReal or: [self scalars isComplex])
		ifFalse: [^ DomainError signal: 'spectral radius is only defined for matrices with complex scalars'].
	^ self spectrum max: [:each| each abs]! !

!Matrix methodsFor: 'spectrum' stamp: 'len 3/27/2018 16:26:17'!
spectrum
	^ self characteristicPolynomial allRoots! !

!Matrix methodsFor: 'subobjects' stamp: 'len 12/30/2021 09:26:16'!
cosyzygies
	"Answer a matrix whose columns span the cokernel or left nullspace of the receiver.
	For a matrix A, the output is X such that X*A = 0."
	^ self scalars cosyzygiesOf: self! !

!Matrix methodsFor: 'subobjects' stamp: 'len 4/6/2021 11:06:49'!
kernel
	^ self syzygies image! !

!Matrix methodsFor: 'subobjects' stamp: 'len 12/30/2021 09:25:59'!
syzygies
	"Answer a matrix whose columns span the (right) kernel or nullspace of the receiver.
	For a matrix A, the output is X such that A*X = 0."
	^ self scalars syzygiesOf: self! !

!Matrix methodsFor: 'subobjects' stamp: 'len 1/15/2022 17:15:31'!
syzygiesModulo: aMatrix
	aMatrix isZero ifTrue: [^ self syzygies].
	^ (self  aMatrix) syzygies copyFromRow: 1 to: self width! !

!Matrix methodsFor: 'testing' stamp: 'len 5/30/2019 04:43:29'!
isDiagonal
	^ self isLowerTriangular and: [self isUpperTriangular]! !

!Matrix methodsFor: 'testing' stamp: 'len 12/30/2021 12:16:02'!
isEchelon
	"Answer true if the receiver is in (row) echelon form.
	It must satisfy the following conditions:
	1. All nonzero rows are above any rows of all zeros;
	2. The leading coefficient (or pivot) of each nonzero row is always strictly to the right of the pivot of the row above it."
	| lastPivot |
	lastPivot _ 0@0.
	self pivotsDo: [:each|
		(each y > lastPivot y and: [each x - lastPivot x = 1])
			ifFalse: [^ false].
		lastPivot _ each].
	^ true! !

!Matrix methodsFor: 'testing' stamp: 'len 5/29/2020 06:32:04'!
isEmpty
	^ self width = 0 or: [self height = 0]! !

!Matrix methodsFor: 'testing' stamp: 'len 3/17/2021 14:40:31'!
isEndomorphism
	^ self isSquare! !

!Matrix methodsFor: 'testing' stamp: 'len 4/5/2018 15:31:35'!
isFullRank
	^ self rank = (self width min: self height)! !

!Matrix methodsFor: 'testing' stamp: 'len 5/30/2019 04:10:55'!
isHermiteNormalForm
	"Answer true if the receiver is in (row) Hermite normal form.
	It must satisfy the following conditions:
	1. It is upper triangular;
	2. The leading coefficient (or pivot) of a nonzero row is always strictly to the right of the leading coefficient of the row above it, and it is positive;
	3. And the elements below pivots are zero and elements above pivots are nonnegative and strictly smaller than the pivot."
	| lastPivot |
	lastPivot _ 0@0.
	self pivotsDo: [:each| | coefficient |
		(each x <= each y and: [each y > lastPivot y and: [each x - lastPivot x = 1]])
			ifFalse: [^ false].
		coefficient _ self at: each.
		coefficient > 0 ifFalse: [^ false].
		1 to: each x - 1 do: [:i| | v |
			((v _ self at: i@each y) >= 0 and: [v < coefficient])
				ifFalse: [^ false]].
		each x + 1 to: self height do: [:i|
			(self at: i@each y) = 0
				ifFalse: [^ false]].
		lastPivot _ each].
	^ true! !

!Matrix methodsFor: 'testing' stamp: 'len 7/22/2021 18:53:41'!
isHermitian
	"Answer true if the receiver is Hermitian (or self-adjoint)."
	^ self = self conjugate! !

!Matrix methodsFor: 'testing' stamp: 'len 8/14/2020 17:13:22'!
isIdentity
	^ self isSquare and: [self = self identity]! !

!Matrix methodsFor: 'testing' stamp: 'len 8/25/2021 18:28:29'!
isIsomorphism
	^ self isUnimodular! !

!Matrix methodsFor: 'testing' stamp: 'len 12/30/2021 09:22:59'!
isLowerTriangular
	1 to: (self width min: self height) do: [:i|
		i+1 to: self width do: [:j| (self isZeroAt: i@j) ifFalse: [^ false]]].
	^ true! !

!Matrix methodsFor: 'testing' stamp: 'len 4/2/2018 05:16:26'!
isMatrix
	^ true! !

!Matrix methodsFor: 'testing' stamp: 'len 1/12/2022 14:21:22'!
isMinimalStandardBasis
	"A Groebner basis G of an ideal I is called 'minimal' if the lead terms of the elements in G minimally generate in(I); or equivalently, if for all p in G:
	- LC(p) = 1, and
	- LT(p) is not in <G-{p}> (i.e., leading-term-minimal).
	Note that any leading-term-minimal Groebner basis is also cardinality-minimal."
	self isStandardBasis ifFalse: [^ false].
	self columnsDo: [:g| g leadingCoefficient isOne ifFalse: [^ false]].
	1 to: self width do: [:i|
		| m |
		m _ (self columnAt: i) leadingMonomial.
		1 to: self width do: [:j|
			(i ~~ j and: [(self columnAt: j) leadingMonomial | m]) ifTrue: [^ false]]].
	^ true! !

!Matrix methodsFor: 'testing' stamp: 'len 1/2/2022 10:01:23'!
isMonomial
	"A matrix is called a 'monomial matrix' if it has exactly one nonzero entry in each column and each row."
	self rowsDo: [:row| (row count: [:each| each isZero not]) = 1 ifFalse: [^ false]].
	self columnsDo: [:column| (column count: [:each| each isZero not]) = 1 ifFalse: [^ false]].
	^ true! !

!Matrix methodsFor: 'testing' stamp: 'len 7/10/2020 07:48:20'!
isNegativeDefinite
	self isSquare ifFalse: [^ DomainError signal: 'not a square matrix'].
	self scalars isReal ifFalse: [^ DomainError signal: 'not a real matrix'].
	self flag: #fix. "define this for complex matrices too"
	^ (1 to: self width) allSatisfy: [:i| (self copyFrom: 1@1 to: i@i) determinant < 0]! !

!Matrix methodsFor: 'testing' stamp: 'len 5/29/2020 05:03:24'!
isNilpotent
	"Answer true if self^n = 0 for some integer n >= 1."
	"This only works for real or complex matrices."
	^ self trace isZero and: [self determinant isZero]! !

!Matrix methodsFor: 'testing' stamp: 'len 7/22/2021 18:53:54'!
isNormal
	^ self conjugate * self = (self * self conjugate)! !

!Matrix methodsFor: 'testing' stamp: 'len 8/9/2020 07:53:38'!
isOrthogonal
	"A real square matrix Q is orthogonal if Q^t * Q = I (the transposed is the inverse).
	Equivalently:
		- Q has orthonormal columns and rows;
		- For all v, ||Qv|| = ||v|| (the matrix preserves the Euclidean norm defined by the standard dot product)."
	^ self isSquare and: [(self * self transpose) isIdentity]! !

!Matrix methodsFor: 'testing' stamp: 'len 7/10/2020 08:13:18'!
isPositiveDefinite
	self isSquare ifFalse: [^ DomainError signal: 'not a square matrix'].
	"TODO: extend this to the hermitian matrices over the complex numbers, use the indefinite factorization algorithm as Sage"
	self scalars isComplex
		ifTrue:
			[self isHermitian ifFalse: [^ false].
			self notYetImplemented].
	self scalars isReal
		ifTrue:
			[self isSymmetric ifFalse: [^ false].
			^ (1 to: self width) allSatisfy: [:i| (self copyFrom: 1@1 to: i@i) determinant > 0]].
	^ DomainError signal: 'not a real or complex matrix'! !

!Matrix methodsFor: 'testing' stamp: 'len 5/23/2016 19:55'!
isRankDeficient
	^ self isFullRank not! !

!Matrix methodsFor: 'testing' stamp: 'len 12/30/2021 12:15:52'!
isReducedEchelon
	"Answer true if the receiver is in reduced (row) echelon form.
	It must satisfy the following conditions:
	1. It is in row echelon form;
	2. And every leading coefficient is 1 and is the only nonzero entry in its column."
	| lastPivot one |
	lastPivot _ 0@0.
	one _ self scalars one.
	self pivotsDo: [:each|
		(each y > lastPivot y and: [each x - lastPivot x = 1])
			ifFalse: [^ false].
		(self at: each) = one ifFalse: [^ false].
		1 to: self height do: [:j|
			(j = each x or: [(self at: j @ each y) isZero]) ifFalse: [^ false]].
		lastPivot _ each].
	^ true! !

!Matrix methodsFor: 'testing' stamp: 'len 1/12/2022 14:07:28'!
isReducedStandardBasis
	"A Groebner basis G is called 'reduced' (or 'auto-reduced') if for all p in G:
	- LC(p) = 1, and
	- no monomial of p is in <G-{p}>.
	In particular, a reduced Groebner basis is leading-term-minimal (no leading term of any generator divides any other generator's leading term), and a leading-term-minimal basis is also cardinality-minimal."
	self isStandardBasis ifFalse: [^ false].
	self columnsDo: [:g| g leadingCoefficient isOne ifFalse: [^ false]].
	1 to: self width do: [:i|
		(self columnAt: i) monomialsDo: [:m|
			1 to: self width do: [:j|
				(i ~~ j and: [(self columnAt: j) leadingMonomial | m]) ifTrue: [^ false halt]]]].
	^ true! !

!Matrix methodsFor: 'testing' stamp: 'len 4/5/2018 15:42:21'!
isScalar
	self isDiagonal ifFalse: [^ false].
	2 to: self height do: [:i|
		(self at: i@i) = (self at: 1@1) ifFalse: [^ false]].
	^ true! !

!Matrix methodsFor: 'testing' stamp: 'len 1/9/2022 08:31:55'!
isSemisimple
	^ self minimalPolynomial isSquarefree! !

!Matrix methodsFor: 'testing' stamp: 'len 5/3/2021 10:57:24'!
isSimplectic
	| M  |
	(self isSquare and: [self width even]) ifFalse: [^ false].
	M _ (self scalars^(self width/2)) endomorphisms.
	 _ M zero  M identity  (M identity negated  M zero).
	^ self transpose *  * self = ! !

!Matrix methodsFor: 'testing' stamp: 'len 12/31/2015 05:53'!
isSingular
	"Answer true if the receiver is a singular matrix."
	^ self determinant isZero! !

!Matrix methodsFor: 'testing' stamp: 'len 7/22/2021 18:54:00'!
isSkewHermitian
	"Answer true if the receiver is skew-Hermitian (or antihermitian)."
	^ self = self conjugate negated! !

!Matrix methodsFor: 'testing' stamp: 'len 8/9/2020 07:53:41'!
isSkewSymmetric
	"Answer true if the receiver is a skew-symmetric (or anti-symmetric) matrix."
	^ self negated = self transpose! !

!Matrix methodsFor: 'testing' stamp: 'len 5/29/2020 07:30:05'!
isSmithNormalForm
	"Answer true if the receiver is in Smith normal form."
	| diagonal previousEntry n0 |
	self isDiagonal ifFalse: [^ false].
	self isEmpty ifTrue: [^ true].
	diagonal _ self diagonal.
	previousEntry _ diagonal first.
	n0 _ diagonal findLast: [:each| each isZero not].
	2 to: n0 do: [:i| | thisEntry |
		thisEntry _ diagonal at: i.
		previousEntry | thisEntry ifFalse: [^ false].
		previousEntry _ thisEntry].
	n0+1 to: diagonal size do: [:i|
		(diagonal at: i) isZero ifFalse: [^ false]].
	^ true! !

!Matrix methodsFor: 'testing' stamp: 'len 4/5/2018 15:31:59'!
isSquare
	^ self height = self width! !

!Matrix methodsFor: 'testing' stamp: 'len 1/11/2022 13:07:12'!
isStandardBasis
	1 to: self width do: [:i| | fi |
		fi _ self columnAt: i.
		i+1 to: self width do: [:j| | fj |
			fj _ self columnAt: j.
			((fi s: fj) \\ self columns) isZero
				ifFalse: [^ false]]].
	^ true! !

!Matrix methodsFor: 'testing' stamp: 'len 8/9/2020 07:53:44'!
isSymmetric
	^ self = self transpose! !

!Matrix methodsFor: 'testing' stamp: 'len 3/2/2017 19:36:13'!
isTriangular
	^ self isLowerTriangular or: [self isUpperTriangular]! !

!Matrix methodsFor: 'testing' stamp: 'len 5/4/2020 10:04:50'!
isUnimodular
	^ self determinant isUnit! !

!Matrix methodsFor: 'testing' stamp: 'len 7/22/2021 18:54:06'!
isUnitary
	"A complex square matrix U is unitary if U* * U = I (the adjoint is the inverse).
	Equivalently:
		- U has orthonormal columns and rows;
		- For all v, ||Uv|| = ||v||."
	^ self isSquare and: [(self * self conjugate) isIdentity]! !

!Matrix methodsFor: 'testing' stamp: 'len 8/9/2020 07:53:48'!
isUpperTriangular
	^ self transpose isLowerTriangular! !

!Matrix methodsFor: 'testing' stamp: 'len 3/23/2016 00:27'!
isZero
	self do: [:each| each isZero ifFalse: [^ false]].
	^ true! !

!Matrix methodsFor: 'testing' stamp: 'len 12/1/2016 17:03:47'!
isZeroAt: aPoint
	^ (self at: aPoint) isZero! !

!Matrix methodsFor: 'private' stamp: 'len 4/7/2018 06:24:49'!
checkDimensionMatch: aMatrix
	(self width = aMatrix width and: [self height = aMatrix height])
		ifFalse: [^ DomainError signal: 'matrix sizes don''t match']! !

!Matrix methodsFor: 'private' stamp: 'len 3/13/2021 12:32:27'!
checkScalarsMatch: aMatrix
	self scalars = aMatrix scalars ifFalse: [^ DomainError signal: 'base rings don''t match']! !

!Matrix methodsFor: 'private' stamp: 'len 12/13/2016 09:51:35'!
hadamardBound
	"Answer a bound N on the determinant of the receiver such that |det A| < 2^N.
	Assume the coefficients are real."
	^ (self rows sum: [:row| (row sum: [:each| each squared])]) log2 min: (self columns sum: [:column| (column sum: [:each| each squared])]) log2! !

!Matrix methodsFor: 'private' stamp: 'len 5/31/2020 12:16:31'!
validate
	(self allSatisfy: [:each| self scalars includes: each]) ifFalse: [^ false].
	^ super validate! !

!Matrix class methodsFor: 'instance creation' stamp: 'len 10/26/2020 16:29:36'!
columns: anArray
	^ self to: anArray first parent columns: anArray! !

!Matrix class methodsFor: 'instance creation' stamp: 'len 10/26/2020 16:28:07'!
from: aDomain rows: anArray
	| codomain |
	codomain _ aDomain scalars ^ anArray size.
	^ self from: aDomain to: codomain rows: anArray! !

!Matrix class methodsFor: 'instance creation' stamp: 'len 5/29/2020 07:20:42'!
from: aDomain to: aCodomain columns: anArray
	^ ColumnMatrix from: aDomain to: aCodomain columns: anArray! !

!Matrix class methodsFor: 'instance creation' stamp: 'len 5/31/2020 07:03:58'!
from: aDomain to: aCodomain filling: aBlock
	^ self from: aDomain to: aCodomain rows: ((1 to: aCodomain rank) collect: [:i| aDomain filling: [:j| aBlock value: i value: j]])! !

!Matrix class methodsFor: 'instance creation' stamp: 'len 5/29/2020 10:47:04'!
from: aDomain to: aCodomain matrix: aMatrix
	^ self shouldNotImplement! !

!Matrix class methodsFor: 'instance creation' stamp: 'len 5/29/2020 07:20:54'!
from: aDomain to: aCodomain rows: anArray
	^ RowMatrix from: aDomain to: aCodomain rows: anArray! !

!Matrix class methodsFor: 'instance creation' stamp: 'len 10/26/2020 16:28:36'!
rows: anArray
	^ self from: anArray first parent rows: anArray! !

!Matrix class methodsFor: 'instance creation' stamp: 'len 10/26/2020 16:29:00'!
to: aCodomain columns: anArray
	| domain |
	domain _ aCodomain scalars ^ anArray size.
	^ self from: domain to: aCodomain columns: anArray! !

!ColumnMatrix methodsFor: 'accessing' stamp: 'len 12/20/2021 13:24:06'!
atRow: i column: j
	^ (columns at: j) at: i! !

!ColumnMatrix methodsFor: 'accessing' stamp: 'len 12/20/2021 13:24:26'!
atRow: i column: j ifAbsent: exceptionBlock
	^ (columns at: j ifAbsent: [^ exceptionBlock value]) at: i ifAbsent: exceptionBlock! !

!ColumnMatrix methodsFor: 'accessing' stamp: 'len 12/20/2021 13:24:40'!
atRow: i column: j put: anObject
	^ (columns at: j) at: i put: anObject! !

!ColumnMatrix methodsFor: 'accessing' stamp: 'len 3/23/2016 02:53'!
columnAt: j
	^ columns at: j! !

!ColumnMatrix methodsFor: 'accessing' stamp: 'len 3/23/2016 02:54'!
columnAt: i put: aTuple
	^ columns at: i put: aTuple! !

!ColumnMatrix methodsFor: 'accessing' stamp: 'len 3/23/2016 02:55'!
columns
	^ columns! !

!ColumnMatrix methodsFor: 'accessing' stamp: 'len 3/23/2016 02:56'!
columns: anArray
	columns _ anArray! !

!ColumnMatrix methodsFor: 'accessing' stamp: 'len 4/23/2018 21:09:52'!
denominator
	| answer |
	self scalars isLocalization ifFalse: [^ self scalars one].
	answer _ self scalars integers one.
	columns do: [:each| answer _ each denominator lcm: answer].
	^ answer! !

!ColumnMatrix methodsFor: 'accessing' stamp: 'len 5/29/2020 05:47:14'!
lift
	"If the coefficients ring is a quotient R/I, answer a representative of the receiver over R. See >>%."
	^ self class from: domain lift to: codomain lift columns: (columns collect: [:each| each lift])! !

!ColumnMatrix methodsFor: 'accessing' stamp: 'len 5/29/2020 05:48:17'!
representative
	"If the coefficients ring is a quotient R/I, answer a representative of the receiver over R. See >>%."
	^ self class from: domain lift to: codomain lift columns: (columns collect: [:each| each representative])! !

!ColumnMatrix methodsFor: 'accessing' stamp: 'len 5/29/2020 16:35:32'!
rowAt: i
	^ domain filling: [:j| (columns at: j) at: i]! !

!ColumnMatrix methodsFor: 'converting' stamp: 'len 7/30/2021 14:27:52'!
asTuple
	"Answer the receiver converted to Tuple by concatenating its rows (which is also the coordinates of the receiver in the canonical basis)."
	^ columns size = 1 ifTrue: [columns first] ifFalse: [super asTuple]! !

!ColumnMatrix methodsFor: 'converting' stamp: 'len 5/29/2020 08:52:58'!
over: aRing
	| newCodomain |
	self scalars = aRing ifTrue: [^ self].
	^ self class from: (self domain over: aRing) to: (newCodomain _ self codomain over: aRing) columns: (columns collect: [:each| newCodomain !! each])! !

!ColumnMatrix methodsFor: 'copying' stamp: 'len 5/29/2020 05:46:48'!
copy
	^ self class from: domain to: codomain columns: (columns collect: [:each| each copy])! !

!ColumnMatrix methodsFor: 'enumerating' stamp: 'len 3/24/2018 19:28:43'!
allSatisfy: aBlock
	^ columns allSatisfy: [:each| each allSatisfy: aBlock]! !

!ColumnMatrix methodsFor: 'enumerating' stamp: 'len 5/29/2020 05:46:38'!
collect: aBlock
	^ self class from: domain to: codomain columns: (columns collect: [:each| each collect: aBlock])! !

!ColumnMatrix methodsFor: 'enumerating' stamp: 'len 3/23/2016 02:57'!
columnsDo: aBlock
	columns do: aBlock! !

!ColumnMatrix methodsFor: 'enumerating' stamp: 'len 7/14/2019 15:20:19'!
do: aBlock
	columns do: [:each| each do: aBlock]! !

!ColumnMatrix methodsFor: 'enumerating' stamp: 'len 7/16/2021 22:24:56'!
withIndicesDo: aBlock
	columns withIndexDo: [:column :j| column withIndexDo: [:each :i| aBlock value: each value: i value: j]]! !

!ColumnMatrix methodsFor: 'operations' stamp: 'len 5/29/2020 05:46:08'!
+ aMatrix
	self checkDimensionMatch: aMatrix.
	self checkScalarsMatch: aMatrix.
	^ self class from: domain to: codomain columns: columns + aMatrix columns! !

!ColumnMatrix methodsFor: 'operations' stamp: 'len 5/29/2020 05:46:21'!
- aMatrix
	self checkDimensionMatch: aMatrix.
	self checkScalarsMatch: aMatrix.
	^ self class from: domain to: codomain columns: columns - aMatrix columns! !

!ColumnMatrix methodsFor: 'operations' stamp: 'len 5/29/2020 05:47:22'!
negated
	^ self class from: domain to: codomain columns: columns negated! !

!ColumnMatrix methodsFor: 'operations' stamp: 'len 8/9/2020 07:49:04'!
transpose
	^ Matrix from: codomain to: domain rows: columns! !

!ColumnMatrix methodsFor: 'reduction-operations' stamp: 'len 5/30/2019 07:11:23'!
addColumn: src times: aNumber toColumn: dst
	self addColumn: src times: aNumber toColumn: dst startingAt: 1! !

!ColumnMatrix methodsFor: 'reduction-operations' stamp: 'len 5/30/2019 07:11:05'!
addColumn: src times: aNumber toColumn: dst startingAt: columnIndex
	(columns at: dst) add: (columns at: src) times: aNumber startingAt: columnIndex! !

!ColumnMatrix methodsFor: 'reduction-operations' stamp: 'len 5/30/2019 07:18:45'!
addRow: i times: aNumber toRow: j
	columns do: [:each| each at: j put: (each at: i) * aNumber + (each at: j)]! !

!ColumnMatrix methodsFor: 'reduction-operations' stamp: 'len 1/16/2018 22:10:18'!
multiplyColumn: i by: aNumber
	self multiplyColumn: i by: aNumber startingAt: 1! !

!ColumnMatrix methodsFor: 'reduction-operations' stamp: 'len 1/16/2018 22:10:00'!
multiplyColumn: i by: aNumber startingAt: startIndex
	(columns at: i) multiplyBy: aNumber startingAt: startIndex! !

!ColumnMatrix methodsFor: 'reduction-operations' stamp: 'len 1/16/2018 22:10:27'!
multiplyRow: i by: aNumber
	columns do: [:each| each at: i put: (each at: i) * aNumber]! !

!ColumnMatrix methodsFor: 'reduction-operations' stamp: 'len 3/3/2017 12:11:47'!
swapColumn: i with: j
	columns swap: i with: j! !

!ColumnMatrix methodsFor: 'reduction-operations' stamp: 'len 3/3/2017 12:07:39'!
swapRow: i with: j
	columns do: [:each| each swap: i with: j]! !

!ColumnMatrix methodsFor: 'testing' stamp: 'len 3/23/2016 02:44'!
isZero
	^ columns allSatisfy: [:each| each isZero]! !

!ColumnMatrix methodsFor: 'testing' stamp: 'len 12/1/2016 17:05:02'!
isZeroAt: aPoint
	^ (columns at: aPoint y) isZeroAt: aPoint x! !

!ColumnMatrix methodsFor: 'private' stamp: 'len 5/29/2020 09:15:50'!
validate
	columns size = domain rank ifFalse: [^ false].
	^ super validate! !

!ColumnMatrix class methodsFor: 'instance creation' stamp: 'len 5/29/2020 05:45:24'!
from: aDomain to: aCodomain columns: anArray
	^ self new domain: aDomain; codomain: aCodomain; columns: anArray! !

!ColumnMatrix class methodsFor: 'instance creation' stamp: 'len 5/29/2020 05:48:59'!
newFrom: aMatrix
	^ self from: aMatrix domain to: aMatrix codomain columns: (aMatrix columns collect: [:each| each copy])! !

!RowMatrix methodsFor: 'accessing' stamp: 'len 12/20/2021 13:28:22'!
atRow: i column: j
	^ (rows at: i) at: j! !

!RowMatrix methodsFor: 'accessing' stamp: 'len 12/20/2021 13:28:38'!
atRow: i column: j ifAbsent: exceptionBlock
	^ (rows at: i ifAbsent: [^ exceptionBlock value]) at: j ifAbsent: exceptionBlock! !

!RowMatrix methodsFor: 'accessing' stamp: 'len 12/20/2021 13:28:50'!
atRow: i column: j put: anObject
	^ (rows at: i) at: j put: anObject! !

!RowMatrix methodsFor: 'accessing' stamp: 'len 5/29/2020 16:36:51'!
columnAt: j
	^ codomain filling: [:i| (rows at: i) at: j]! !

!RowMatrix methodsFor: 'accessing' stamp: 'len 4/23/2018 21:09:39'!
denominator
	| answer |
	self scalars isLocalization ifFalse: [^ self scalars one].
	answer _ self scalars integers one.
	rows do: [:each| answer _ each denominator lcm: answer].
	^ answer! !

!RowMatrix methodsFor: 'accessing' stamp: 'len 5/29/2020 09:02:16'!
lift
	"If the coefficients ring is a quotient R/I, answer a representative of the receiver over R. See >>%."
	^ self class from: domain lift to: codomain lift rows: (rows collect: [:each| each lift])! !

!RowMatrix methodsFor: 'accessing' stamp: 'len 5/29/2020 09:02:30'!
representative
	"If the coefficients ring is a quotient R/I, answer a representative of the receiver over R. See >>%."
	^ self class from: domain lift to: codomain lift rows: (rows collect: [:each| each representative])! !

!RowMatrix methodsFor: 'accessing' stamp: 'len 3/23/2016 00:16'!
rowAt: i
	^ rows at: i! !

!RowMatrix methodsFor: 'accessing' stamp: 'len 3/23/2016 00:18'!
rowAt: i put: aTuple
	^ rows at: i put: aTuple! !

!RowMatrix methodsFor: 'accessing' stamp: 'len 3/23/2016 00:17'!
rows
	^ rows! !

!RowMatrix methodsFor: 'converting' stamp: 'len 7/30/2021 14:28:43'!
asTuple
	"Answer the receiver converted to Tuple by concatenating its rows (which is also the coordinates of the receiver in the canonical basis)."
	^ rows size = 1 ifTrue: [rows first] ifFalse: [super asTuple]! !

!RowMatrix methodsFor: 'converting' stamp: 'len 5/29/2020 08:53:54'!
over: aRing
	| newDomain |
	self scalars = aRing ifTrue: [^ self].
	^ self class from: (newDomain _ self domain over: aRing) to: (self codomain over: aRing) rows: (rows collect: [:each| newDomain !! each])! !

!RowMatrix methodsFor: 'copying' stamp: 'len 5/29/2020 09:02:03'!
copy
	^ self class from: domain to: codomain rows: (rows collect: [:each| each copy])! !

!RowMatrix methodsFor: 'enumerating' stamp: 'len 3/24/2018 19:28:25'!
allSatisfy: aBlock
	^ rows allSatisfy: [:each| each allSatisfy: aBlock]! !

!RowMatrix methodsFor: 'enumerating' stamp: 'len 5/29/2020 09:01:43'!
collect: aBlock
	^ self class from: domain to: codomain rows: (rows collect: [:each| each collect: aBlock])! !

!RowMatrix methodsFor: 'enumerating' stamp: 'len 7/14/2019 15:20:53'!
do: aBlock
	rows do: [:each| each do: aBlock]! !

!RowMatrix methodsFor: 'enumerating' stamp: 'len 3/23/2016 00:18'!
rowsDo: aBlock
	rows do: aBlock! !

!RowMatrix methodsFor: 'enumerating' stamp: 'len 7/16/2021 22:24:07'!
withIndicesDo: aBlock
	rows withIndexDo: [:row :i| row withIndexDo: [:each :j| aBlock value: each value: i value: j]]! !

!RowMatrix methodsFor: 'initialization' stamp: 'len 3/23/2016 00:20'!
rows: anArray
	rows _ anArray! !

!RowMatrix methodsFor: 'operations' stamp: 'len 5/29/2020 09:01:17'!
+ aMatrix
	self checkDimensionMatch: aMatrix.
	self checkScalarsMatch: aMatrix.
	^ self class from: domain to: codomain rows: rows + aMatrix rows! !

!RowMatrix methodsFor: 'operations' stamp: 'len 5/29/2020 09:01:24'!
- aMatrix
	self checkDimensionMatch: aMatrix.
	self checkScalarsMatch: aMatrix.
	^ self class from: domain to: codomain rows: rows - aMatrix rows! !

!RowMatrix methodsFor: 'operations' stamp: 'len 5/29/2020 09:01:31'!
negated
	^ self class from: domain to: codomain rows: rows negated! !

!RowMatrix methodsFor: 'operations' stamp: 'len 8/9/2020 07:50:03'!
transpose
	^ Matrix from: codomain to: domain columns: rows! !

!RowMatrix methodsFor: 'reduction-operations' stamp: 'len 5/30/2019 07:22:05'!
addColumn: i times: aNumber toColumn: j
	rows do: [:each| each at: j put: (each at: i) * aNumber + (each at: j)]! !

!RowMatrix methodsFor: 'reduction-operations' stamp: 'len 5/30/2019 07:21:28'!
addRow: src times: aNumber toRow: dst
	self addRow: src times: aNumber toRow: dst startingAt: 1! !

!RowMatrix methodsFor: 'reduction-operations' stamp: 'len 5/30/2019 07:21:44'!
addRow: src times: aNumber toRow: dst startingAt: columnIndex
	(rows at: dst) add: (rows at: src) times: aNumber startingAt: columnIndex! !

!RowMatrix methodsFor: 'reduction-operations' stamp: 'len 1/16/2018 22:11:15'!
multiplyColumn: i by: aNumber
	rows do: [:each| each at: i put: (each at: i) * aNumber]! !

!RowMatrix methodsFor: 'reduction-operations' stamp: 'len 1/16/2018 22:08:39'!
multiplyRow: i by: aNumber
	self multiplyRow: i by: aNumber startingAt: 1! !

!RowMatrix methodsFor: 'reduction-operations' stamp: 'len 1/16/2018 22:08:30'!
multiplyRow: i by: aNumber startingAt: startIndex
	(rows at: i) multiplyBy: aNumber startingAt: startIndex! !

!RowMatrix methodsFor: 'reduction-operations' stamp: 'len 3/23/2016 00:20'!
swapColumn: i with: j
	rows do: [:each| each swap: i with: j]! !

!RowMatrix methodsFor: 'reduction-operations' stamp: 'len 3/23/2016 00:17'!
swapRow: i with: j
	rows swap: i with: j! !

!RowMatrix methodsFor: 'testing' stamp: 'len 3/23/2016 00:19'!
isZero
	^ rows allSatisfy: [:each| each isZero]! !

!RowMatrix methodsFor: 'testing' stamp: 'len 12/1/2016 17:04:49'!
isZeroAt: aPoint
	^ (rows at: aPoint x) isZeroAt: aPoint y! !

!RowMatrix methodsFor: 'private' stamp: 'len 5/29/2020 09:16:26'!
validate
	rows size = codomain rank ifFalse: [^ false].
	^ super validate! !

!RowMatrix class methodsFor: 'instance creation' stamp: 'len 5/29/2020 06:36:44'!
from: aDomain to: aCodomain rows: anArray
	^ self new domain: aDomain; codomain: aCodomain; rows: anArray! !

!RowMatrix class methodsFor: 'instance creation' stamp: 'len 5/29/2020 05:49:49'!
newFrom: aMatrix
	^ self from: aMatrix domain to: aMatrix codomain rows: (aMatrix rows collect: [:each| each copy])! !

!RowMajorMatrix methodsFor: 'accessing' stamp: 'len 5/28/2020 12:49:58'!
at: aPoint
	"Answer the coefficient at i@j (row i, column j)."
	^ coefficients at: aPoint x - 1 * self width + aPoint y! !

!RowMajorMatrix methodsFor: 'accessing' stamp: 'len 5/28/2020 12:50:03'!
at: aPoint put: anElement
	"Set the coefficient at i@j (row i, column j)."
	^ coefficients at: aPoint x - 1 * self width + aPoint y put: anElement! !

!RowMajorMatrix methodsFor: 'accessing' stamp: 'len 5/28/2020 09:57:19'!
coefficients
	^ coefficients! !

!RowMajorMatrix methodsFor: 'constants' stamp: 'len 5/28/2020 10:13:51'!
identity
	self isEmpty ifTrue: [^ self].
	^ self domain to: self codomain scalar: self scalars one! !

!RowMajorMatrix methodsFor: 'constants' stamp: 'len 5/28/2020 10:15:24'!
zero
	^ self domain to: self codomain scalar: self scalars zero! !

!RowMajorMatrix methodsFor: 'converting' stamp: 'len 5/28/2020 10:16:21'!
asTuple
	"Answer the receiver converted to Tuple by concatenating its rows (which is also the coordinates of the receiver in the canonical basis)."
	^ coefficients! !

!RowMajorMatrix methodsFor: 'copying' stamp: 'len 5/28/2020 10:37:35'!
copyFromColumn: start to: end
	^ self domain to: self codomain columns: ((start to: end) collect: [:each| self columnAt: each])! !

!RowMajorMatrix methodsFor: 'copying' stamp: 'len 5/30/2020 05:00:20'!
copyFromRow: start to: end
	^ self class from: domain to: codomain rows: ((start to: end) collect: [:each| self rowAt: each])! !

!RowMajorMatrix methodsFor: 'enumerating' stamp: 'len 5/29/2020 04:11:36'!
collect: aBlock
	^ self class from: domain to: codomain coefficients: (coefficients collect: aBlock)! !

!RowMajorMatrix methodsFor: 'enumerating' stamp: 'len 5/28/2020 10:32:10'!
diagonalDo: aBlock
	| i w |
	i _ 1.
	w _ self width + 1.
	[i <= coefficients size]
		whileTrue:
			[aBlock value: (coefficients at: i).
			i _ i + w]! !

!RowMajorMatrix methodsFor: 'enumerating' stamp: 'len 5/28/2020 10:34:42'!
do: aBlock
	coefficients do: aBlock! !

!RowMajorMatrix methodsFor: 'operations' stamp: 'len 5/29/2020 04:39:45'!
+ aMatrix
	(aMatrix isKindOf: RowMajorMatrix) ifFalse: [^ self adapt: aMatrix andSend: #+].
	(self domain = aMatrix domain and: [self codomain = aMatrix codomain])
			ifFalse: [^ DomainError signal: 'domains don''t match'].
	^ self class from: domain to: codomain coefficients: coefficients + aMatrix coefficients! !

!RowMajorMatrix methodsFor: 'private' stamp: 'len 5/29/2020 07:04:34'!
coefficients: aTuple
	coefficients _ aTuple! !

!RowMajorMatrix methodsFor: 'private' stamp: 'len 5/29/2020 09:16:50'!
validate
	coefficients size = (domain rank * codomain rank) ifFalse: [^ false].
	^ super validate! !

!RowMajorMatrix class methodsFor: 'instance creation' stamp: 'len 5/29/2020 04:08:08'!
from: aDomain to: aCodomain coefficients: aTuple
	^ self new domain: aDomain; codomain: aCodomain; coefficients: aTuple! !

!LatticeMap methodsFor: 'accessing' stamp: 'len 7/29/2020 08:39:41'!
matrix
	^ matrix! !

!LatticeMap methodsFor: 'initialization' stamp: 'len 7/29/2020 13:03:05'!
matrix: aMatrix
	matrix _ aMatrix! !

!LatticeMap methodsFor: 'operations' stamp: 'len 7/29/2020 08:40:16'!
value: anElement
	^ self codomain elementAt: matrix * (self domain !! anElement) coordinates! !

!LatticeMap class methodsFor: 'class initialization' stamp: 'len 7/29/2020 08:35:50'!
initialize
	super initialize.
	Smalltalk at: #Lattices put: (Category new name: #Lattices)! !

!LatticeMap class methodsFor: 'instance creation' stamp: 'len 7/29/2020 08:39:16'!
from: aDomain to: aCodomain matrix: aMatrix
	^ self new
		domain: aDomain;
		codomain: aCodomain;
		matrix: aMatrix! !

!QuadraticForm methodsFor: 'accessing' stamp: 'len 3/28/2018 02:47:11'!
at: aPoint
	| i j n |
	i _ aPoint x - 1.
	j _ aPoint y - 1.
	i > j ifTrue: [i _ j. j _ aPoint x - 1].
	n _ self rank.
	^ self coefficients at: i * n - (i-1*i//2) + j - i + 1! !

!QuadraticForm methodsFor: 'accessing' stamp: 'len 3/28/2018 03:01:03'!
bitSize
	^ self coefficients bitSize! !

!QuadraticForm methodsFor: 'accessing' stamp: 'len 12/30/2015 21:16'!
codomain
	^ self scalars! !

!QuadraticForm methodsFor: 'accessing' stamp: 'len 3/28/2018 03:00:51'!
coefficients
	"Answer the coefficients of the receiver in lexicographical order."
	^ coefficients! !

!QuadraticForm methodsFor: 'accessing' stamp: 'len 9/22/2018 18:57:55'!
content
	^ self coefficients content! !

!QuadraticForm methodsFor: 'accessing' stamp: 'len 3/28/2018 03:12:29'!
determinant
	"Answer the determinant of the Hessian matrix of the receiver. This is the determinant of the Gram matrix of twice the receiver."
	^ self hessian determinant! !

!QuadraticForm methodsFor: 'accessing' stamp: 'len 9/22/2018 18:57:51'!
discriminant
	"Note: this invariant is defined differently by different authors."
	self rank odd ifTrue: [^ self determinant / 2].
	(self rank // 2) odd ifTrue: [self determinant negated].
	^ self determinant! !

!QuadraticForm methodsFor: 'accessing' stamp: 'len 8/4/2021 14:24:00'!
gramian
	"Answer the Gramian matrix G for the receiver Q.
	This is a matrix G such that Q(x) = x^t * G * x."
	| R two |
	R _ self scalars.
	two _ R !! 2.
	^ self hessian collect: [:each| R !! (each / two)]! !

!QuadraticForm methodsFor: 'accessing' stamp: 'len 12/18/2021 20:31:05'!
hessian
	"Answer the Hessian matrix H for the receiver Q.
	This is a matrix H such that Q(x) = x^t * H * x / 2."
	^ self scalars matrix: self domain rank filling: [:i :j| i = j ifTrue: [(self at: i@j)*2] ifFalse: [self at: i@j]]! !

!QuadraticForm methodsFor: 'accessing' stamp: 'len 3/27/2018 23:58:26'!
rank
	^ self domain rank! !

!QuadraticForm methodsFor: 'accessing' stamp: 'len 3/19/2018 20:00:15'!
scalars
	^ self domain scalars! !

!QuadraticForm methodsFor: 'comparing' stamp: 'len 3/28/2018 03:12:11'!
= aQuadraticForm
	(aQuadraticForm isKindOf: QuadraticForm) ifFalse: [^ false].
	^ self coefficients = aQuadraticForm coefficients! !

!QuadraticForm methodsFor: 'comparing' stamp: 'len 9/22/2018 18:57:58'!
~ aQuadraticForm
	"Answer true if the receiver and the argument are integrally equivalent."
	^ self hessian ~ aQuadraticForm hessian! !

!QuadraticForm methodsFor: 'comparing' stamp: 'len 3/28/2018 03:12:33'!
hash
	^ self coefficients hash! !

!QuadraticForm methodsFor: 'converting' stamp: 'len 7/6/2020 10:56:53'!
asPolynomial
	| n R answer |
	n _ self rank.
	R _ self domain coordinateRing.
	answer _ R zero.
	1 to: n do: [:i|
		| vi |
		vi _ R x: i.
		i to: n do: [:j| answer _  vi * (R x: j) * (self at: i@j) + answer]].
	^ answer! !

!QuadraticForm methodsFor: 'converting' stamp: 'len 7/20/2020 06:57:04'!
polarization
	"Answer the associated symmetric bilinear form (assuming the characteristic is not 2).
	This is, via the polarization identity: B(v,w) := (Q(v+w) - Q(v) -Q(w)) / 2."
	^ BilinearForm on: self domain matrix: self gramian! !

!QuadraticForm methodsFor: 'initialization' stamp: 'len 3/28/2018 03:06:18'!
coefficients: aTuple
	coefficients _ aTuple! !

!QuadraticForm methodsFor: 'operations' stamp: 'len 3/28/2018 02:59:45'!
* anObject
	^ self class from: self domain coefficients: self coefficients * anObject! !

!QuadraticForm methodsFor: 'operations' stamp: 'len 7/5/2020 20:10:42'!
+ aQuadraticForm
	self domain = aQuadraticForm domain ifFalse: [^ self error: 'domains don''t match'].
"	self domain matrix = aQuadraticForm domain matrix ifFalse: [self notYetImplemented]."
	^ self class
		from: self domain
		coefficients: self coefficients + aQuadraticForm coefficients! !

!QuadraticForm methodsFor: 'operations' stamp: 'len 7/6/2020 11:32:27'!
 aQuadraticForm
	"Answer the orthogonal sum of the receiver and the argument."
	(aQuadraticForm isKindOf: QuadraticForm) ifFalse: [^ DomainError signal].
	^ self class from: self domain  aQuadraticForm domain gramian: self gramian  aQuadraticForm gramian! !

!QuadraticForm methodsFor: 'operations' stamp: 'len 7/22/2021 18:54:22'!
adjoint
	"Answer the adjoint (integral) quadratic form associated to the receiver."
	| A |
	A _ self hessian conjugate.
	self rank odd ifTrue: [A _ A*2].
	^ self class from: self domain hessian: A! !

!QuadraticForm methodsFor: 'operations' stamp: 'len 7/28/2020 19:37:10'!
automorphisms
	"Answer the orthogonal group consisting of the self-isometries with respect to the receiver."
	^ OrthogonalGroup on: self! !

!QuadraticForm methodsFor: 'operations' stamp: 'len 3/28/2018 02:59:58'!
negated
	^ self class from: self domain coefficients: self coefficients negated! !

!QuadraticForm methodsFor: 'operations' stamp: 'len 7/17/2019 10:51:12'!
primitivePart
	^ self class from: self domain coefficients: self coefficients primitivePart! !

!QuadraticForm methodsFor: 'operations' stamp: 'len 7/17/2019 10:51:22'!
reciprocal
	^ self adjoint primitivePart * self content! !

!QuadraticForm methodsFor: 'operations' stamp: 'len 4/26/2021 11:43:35'!
value: aVector
	| v n answer |
	v _ self domain \ aVector.
	n _ self rank.
	answer _ self scalars zero.
	1 to: n do: [:i|
		| vi |
		vi _ v at: i.
		i to: n do: [:j|
			answer _ (self at: i@j) * vi * (v at: j) + answer]].
	^ answer! !

!QuadraticForm methodsFor: 'testing' stamp: 'len 3/28/2018 03:12:40'!
isDiagonal
	"Answer true if the receiver is in diagonal form."
	^ self hessian isDiagonal! !

!QuadraticForm methodsFor: 'testing' stamp: 'len 3/28/2018 01:03:53'!
isPrimitive
	^ self content = self scalars one! !

!QuadraticForm methodsFor: 'testing' stamp: 'len 7/6/2020 06:25:48'!
isRegular
	^ self polarization isNonDegenerate! !

!QuadraticForm methodsFor: 'testing' stamp: 'len 7/13/2020 18:13:26'!
isZero
	^ coefficients isZero! !

!QuadraticForm class methodsFor: 'instance creation' stamp: 'len 7/19/2020 07:21:29'!
coefficients: aTuple
	"Answer the quadratic form with the given coefficients (in lexicographical order)."
	aTuple isTuple ifFalse: [^ self error: 'not a tuple'].
	^ self from: aTuple scalars ^ (aTuple size * 2) sqrtFloor coefficients: aTuple! !

!QuadraticForm class methodsFor: 'instance creation' stamp: 'len 7/19/2020 07:22:46'!
from: aFreeModule coefficients: aTuple
	"Answer the quadratic form associated with the given coefficients (in lexicographical order) in the distinguished basis of the given free module."
	^ self new domain: aFreeModule; coefficients: ((aTuple isTuple and: [aTuple scalars = aFreeModule scalars]) ifTrue: [aTuple] ifFalse: [aFreeModule scalars ^ aTuple size !! aTuple])! !

!QuadraticForm class methodsFor: 'instance creation' stamp: 'len 7/6/2020 09:37:00'!
from: aFreeModule gramian: aMatrix
	| coefficients n |
	coefficients _ OrderedCollection new.
	n _ aFreeModule rank.
	1 to: n do: [:i|
		i to: n do: [:j|
			coefficients add: (i = j ifTrue: [aMatrix at: i@j] ifFalse: [(aMatrix at: i@j) * 2])]].
	^ self from: aFreeModule coefficients: (aFreeModule scalars tuple: coefficients asArray)! !

!QuadraticForm class methodsFor: 'instance creation' stamp: 'len 7/6/2020 09:37:51'!
from: aFreeModule hessian: aMatrix
	^ self from: aFreeModule gramian: aMatrix/2! !

!RingMap methodsFor: 'comparing' stamp: 'len 8/6/2019 06:24:17'!
= aRingMap
	"(aRingMap isKindOf: RingMap) ifFalse: [^ super = aRingMap].
	(self domain = aRingMap domain and: [self codomain = aRingMap codomain]) ifFalse: [^ false].
	^ self domain generators allSatisfy: [:each| (self value: each) = (aRingMap value: each)]"
	^ super = aRingMap! !

!RingMap methodsFor: 'converting' stamp: 'len 10/25/2020 08:09:40'!
asAbelianGroupMap
	^ self domain asAbelianGroup to: self codomain asAbelianGroup evaluating: [:x| self value: self domain !! x]! !

!RingMap methodsFor: 'converting' stamp: 'len 9/28/2018 06:51:12'!
asModuleMap
	^ self domain asModule to: self codomain asModule evaluating: self! !

!RingMap methodsFor: 'operations' stamp: 'len 8/14/2019 10:18:26'!
kernel
	^ self propertyAt: #kernel! !

!RingMap methodsFor: 'operations' stamp: 'len 12/20/2021 12:07:39'!
opposite
	"Answer the ring homomorphism induced by the receiver on the opposite rings."
	^ self domain opposite to: self codomain opposite evaluating: [:x| x opposite]! !

!RingMap methodsFor: 'operations' stamp: 'len 8/14/2019 10:22:57'!
preimage: anObject
	| section |
	section _ self section.
	(self codomain includes: anObject) ifTrue: [^ (section value: anObject) + self kernel].
	((anObject isKindOf: Ideal) and: [anObject scalars = self codomain]) ifFalse: [DomainError signal].
	^ self domain * (anObject generators collect: [:each| section value: each]) + self kernel! !

!RingMap methodsFor: 'operations' stamp: 'len 12/23/2021 14:08:57'!
proj
	"This is the Proj functor. Answer the morphism between projective schemes induced by the receiver, i.e. given a graded ring homomorphism f:R->S, Proj(f) is a scheme morphism Proj(S)->Proj(R)."
	^ ProjectiveMorphism adjoint: self! !

!RingMap methodsFor: 'operations' stamp: 'len 12/23/2021 14:08:35'!
spec
	"This is the Spec functor. Answer the morphism between affine schemes induced by the receiver, i.e. given a ring homomorphism f:R->S, Spec(f) is a scheme morphism Spec(S)->Spec(R)."
	^ AffineMorphism adjoint: self

"
	^ self codomain spec to: self domain spec evaluating: [:anIdeal| self preimage: anIdeal]"! !

!RingMap methodsFor: 'operations' stamp: 'len 5/2/2019 08:03:52'!
units
	"This is the natural functor from the cateogry of rings to the category of groups which sends each ring R to its group of units U(R) and each ring homomorphism to the restriction to U(R). This functor has a left adjoint which sends each group G to the integral group ring Z[G]."
	^ self domain units to: self codomain units evaluating: [:each| self value: each]! !

!RingMap methodsFor: 'testing' stamp: 'len 12/25/2021 12:06:30'!
isEpimorphism
	"Answer true if the receiver is right cancelable: a morphism f:A->B is an epimorphism if, for any pair of morphisms g:B->C, h:B->C, gf = hf implies g = h.
	In the category of unital rings not all epimorphisms are surjective. For example, the initial morphism Z -> Q from the rational integers to the rational numbers is not surjective but it is an epimorphism."
	self isSurjective ifTrue: [^ true].
	^ self notYetImplemented! !

!RingMap methodsFor: 'testing' stamp: 'len 8/22/2021 12:41:24'!
isInjective
"	(self domain isField and: [self codomain isTrivial not]) ifTrue: [^ true]." "a ring homomorphism from a field to a nontrivial ring is injective."
	^ self kernel isTrivial! !

!RingMap methodsFor: 'testing' stamp: 'len 9/22/2018 19:00:11'!
isLocal
	"A ring homomorphism called 'local' if it is a homomorphism of local rings and carries the maximal ideal to the maximal ideal."
	^ self domain isLocal and: [self codomain isLocal and: [(self domain maximalIdeal apply: self) <= self codomain maximalIdeal]]! !

!RingMap methodsFor: 'testing' stamp: 'len 5/10/2019 07:41:10'!
isRingHomomorphism
	^ true! !

!RingMap methodsFor: 'testing' stamp: 'len 1/2/2022 10:14:24'!
isZero
	"A ring homomorphism to a nontrivial ring cannot be zero, because 1 maps to 1."
	^ (self value: self domain one) = self codomain zero
"	^ self codomain isTrivial"! !

!RingMap methodsFor: 'private' stamp: 'len 1/11/2018 17:38:33'!
species
	^ RingMap! !

!RingMap methodsFor: 'private' stamp: 'len 5/15/2019 07:24:39'!
verify
	^ super isRingHomomorphism! !

!RingMap class methodsFor: 'examples' stamp: 'len 5/23/2020 09:34:55'!
example1
	"The ring of rational integers is the initial object in the category of rings.
	There's always a unique ring homomorphism from the integers to any given ring:"
	^  -> (/6) polynomials! !

!RingMap class methodsFor: 'initialization' stamp: 'len 4/26/2020 18:13:54'!
initialize
	super initialize.
	Smalltalk at: #Rings put: (Category new name: #Rings)! !

!AffineAlgebraMap methodsFor: 'comparing' stamp: 'len 12/15/2021 11:42:40'!
= anObject
	(anObject isKindOf: AffineAlgebraMap) ifFalse: [^ super = anObject].
	(self domain = anObject domain and: [self codomain = anObject codomain]) ifFalse: [^ false].
	^ self domain generators allSatisfy: [:each| (self value: each) = (anObject value: each)]! !

!AffineAlgebraMap methodsFor: 'operations' stamp: 'len 4/27/2018 01:28:13'!
implicitization
	"As implemented in RationalMap. Maybe shouldn't implement it here.
	Magma uses the algorithm in p. 97 of [CLO96]."
	self notYetImplemented! !

!AffineAlgebraMap methodsFor: 'operations' stamp: 'len 3/18/2021 16:44:53'!
kernel
	"See RationalMap>>image."
	| A B m n P t embedding generators I |
	self propertyAt: #kernel ifPresent: [:anIdeal| ^ anIdeal].
	A _ self domain.
	B _ self codomain.
	n _ A rank.
	m _ B rank.
	P _ self codomain scalars polynomialsIn: n + m + 1.
	embedding _ B to: P mapping: [:i| P x: i+n].
	t _ P x: P rank.
	generators _ OrderedCollection new.
	1 to: n do: [:i|
		generators add: (P x: i) - (embedding value: (self value: (A x: i)))].
	generators add: P one - t.
	I _ P * generators eliminateAll: (n+1 to: P rank).
	^ self propertyAt: #kernel put: A * (I generators collect: [:each| A !! each])! !

!AffineAlgebraMap methodsFor: 'operations' stamp: 'len 12/11/2021 19:32:07'!
proj
	"This is the Proj functor. Answer the morphism between projective schemes induced by the receiver, i.e. given a graded ring homomorphism f:R->S, Proj(f) is a scheme morphism Proj(S)->Proj(R)."
	^ self notYetImplemented! !

!AffineAlgebraMap methodsFor: 'operations' stamp: 'len 12/15/2021 12:54:47'!
spec
	"This is the Spec functor. Answer the morphism between affine schemes induced by the receiver, i.e. given a ring homomorphism f:R->S, Spec(f) is a scheme morphism Spec(S)->Spec(R)."
	^ RationalMap from: self codomain spec to: self domain spec representatives: ((1 to: self domain rank) collect: [:i| self value: (self domain x: i)])! !

!AffineAlgebraMap methodsFor: 'testing' stamp: 'len 2/12/2017 13:04:30'!
imageContains: aPolynomial
	"As in Magma, algorithm in p. 82 of [AL94]."
	self notYetImplemented! !

!AffineAlgebraMap methodsFor: 'testing' stamp: 'len 2/12/2017 13:02:51'!
isSurjective
	^ self codomain generators allSatisfy: [:each| self imageContains: each]! !

!AffineAlgebraMap class methodsFor: 'as yet unclassified' stamp: 'len 4/30/2021 13:03:08'!
from: aDomain to: aCodomain mapping: aBlock
	| images |
	images _ (1 to: aDomain rank) collect: [:i| aBlock value: i].
	^ self from: aDomain to: aCodomain evaluating: [:f| f value: images]! !

!AlgebraMap methodsFor: 'converting' stamp: 'len 7/14/2020 09:58:17'!
asModuleMap
	^ self propertyAt: #moduleMap! !

!AlgebraMap methodsFor: 'initialization' stamp: 'len 7/14/2020 10:07:31'!
moduleMap: aModuleMap
	self propertyAt: #moduleMap put: aModuleMap! !

!AlgebraMap methodsFor: 'operations' stamp: 'len 5/3/2021 17:55:06'!
image
	^ self codomain span: self asModuleMap image! !

!AlgebraMap methodsFor: 'operations' stamp: 'len 7/9/2021 09:47:56'!
kernel
	^ self domain * self asModuleMap kernel generators! !

!AlgebraMap methodsFor: 'operations' stamp: 'len 7/14/2020 09:57:47'!
value: anElement
	^ self codomain !! (self asModuleMap value: anElement asModuleElement)! !

!AlgebraMap methodsFor: 'private' stamp: 'len 7/11/2021 10:36:36'!
verify
	"Since the map is linear by construction, we only need to verify that it preserves multiplication between elements of the basis, and that it sends the identity to the identity."
	self domain basis do: [:x|
		self domain basis do: [:y|
			(self value: x*y) = ((self value: x) * (self value: y))
				ifFalse: [^ false]]].
	^ (self value: self domain one) = self codomain one! !

!AlgebraMap class methodsFor: 'as yet unclassified' stamp: 'len 7/14/2020 09:58:40'!
from: aDomain to: aCodomain moduleMap: aModuleMap
	^ self new domain: aDomain; codomain: aCodomain; moduleMap: aModuleMap! !

!DistributiveAlgebraMap methodsFor: 'as yet unclassified' stamp: 'len 7/18/2021 13:07:26'!
asModuleMap
	^ self propertyAt: #moduleMap! !

!DistributiveAlgebraMap methodsFor: 'as yet unclassified' stamp: 'len 7/18/2021 13:08:41'!
image
	^ self codomain span: self asModuleMap image! !

!DistributiveAlgebraMap methodsFor: 'as yet unclassified' stamp: 'len 7/18/2021 13:08:21'!
kernel
	^ self domain span: self asModuleMap kernel! !

!DistributiveAlgebraMap methodsFor: 'as yet unclassified' stamp: 'len 7/18/2021 13:07:46'!
moduleMap: aModuleMap
	self propertyAt: #moduleMap put: aModuleMap! !

!DistributiveAlgebraMap methodsFor: 'as yet unclassified' stamp: 'len 7/18/2021 13:07:55'!
value: anElement
	^ self codomain !! (self asModuleMap value: anElement asModuleElement)! !

!DistributiveAlgebraMap methodsFor: 'as yet unclassified' stamp: 'len 7/18/2021 13:09:22'!
verify
	"Since the map is linear by construction, we only need to verify that it preserves multiplication between elements of the basis, and that it sends the identity to the identity."
	self domain basis do: [:x|
		self domain basis do: [:y|
			(self value: x*y) = ((self value: x) * (self value: y))
				ifFalse: [^ false]]].
	^ true! !

!RationalMap methodsFor: 'accessing' stamp: 'len 12/28/2016 21:54:27'!
at: anInteger
	"Answer the anInteger-th component of the receiver (a rational function, an element of the function field of the domain)."
	^ self representatives at: anInteger! !

!RationalMap methodsFor: 'accessing' stamp: 'len 5/17/2018 18:49:34'!
base
	"Answer the subscheme of the domain where the receiver is indetermined (because some denominator vanishes)."
	self notYetImplemented.
"this is wrong:"
	^ self domain subscheme: (self representatives collect: [:each| each denominator])! !

!RationalMap methodsFor: 'accessing' stamp: 'len 12/28/2016 21:43:15'!
representatives
	"Answer the array of representatives of the components of the receiver, i.e. formal fractions of polynomials or polynomials."
	^ self propertyAt: #representatives! !

!RationalMap methodsFor: 'accessing' stamp: 'len 1/5/2017 09:27:06'!
size
	"Answer the number of components of the receiver."
	^ self codomain ambient rank! !

!RationalMap methodsFor: 'arithmetic' stamp: 'len 1/20/2018 22:05:44'!
* anObject
	^ self species from: self domain to: self codomain representatives: self representatives * anObject! !

!RationalMap methodsFor: 'arithmetic' stamp: 'len 5/20/2018 16:27:16'!
+ aRationalMap
	aRationalMap isTuple
		ifTrue: [^ self species from: self domain to: self codomain representatives: self representatives + aRationalMap].
	(self domain = aRationalMap domain and: [self codomain = aRationalMap codomain])
		ifFalse: [^ DomainError signal].
	^ self species from: self domain to: self codomain representatives: self representatives + aRationalMap representatives! !

!RationalMap methodsFor: 'arithmetic' stamp: 'len 8/19/2021 10:04:47'!
 aRationalMap
	self species = aRationalMap species ifFalse: [^ super  aRationalMap].
	self domain >= aRationalMap codomain ifFalse: [DomainError signal: 'domains don''t match'].
	^ self species from: aRationalMap domain to: self codomain representatives: (self representatives asArray collect: [:each| each value: aRationalMap representatives])! !

!RationalMap methodsFor: 'arithmetic' stamp: 'len 1/20/2018 22:05:58'!
negated
	^ self species from: self domain to: self codomain representatives: self representatives negated! !

!RationalMap methodsFor: 'comparing' stamp: 'len 12/15/2021 12:01:49'!
= aRationalMap
	| I |
	(aRationalMap isKindOf: RationalMap) ifFalse: [^ super = aRationalMap].
	(self domain = aRationalMap domain and: [self codomain = aRationalMap codomain])
		ifFalse: [^ false].
	I _ self domain asIdeal.
	1 to: self size do: [:i| | f g |
		f _ self at: i.
		g _ aRationalMap at: i.
		(I includes: f numerator * g denominator - (f denominator * g numerator))
			ifFalse: [^ false]].
	^ true! !

!RationalMap methodsFor: 'converting' stamp: 'len 6/7/2020 06:21:51'!
asRingMap
	"Answer the induced ring homomorphism between the coordinate rings.
	This is the adjoint of the Spec functor."
	self isPolynomial ifFalse: [DomainError signal: 'not a polynomial map'].
	^ self codomain coordinateRing to: self domain coordinateRing evaluating: [:f| f value: (self representatives collect: [:each| each numerator])]! !

!RationalMap methodsFor: 'operations' stamp: 'len 5/15/2018 16:58:45'!
graph
	^ self domain  self image! !

!RationalMap methodsFor: 'operations' stamp: 'len 12/15/2021 12:01:55'!
image
	"Answer (the Zeriski closure of) the image of the receiver. This is a subscheme of the codomain.
	Performs ideal elimination (a Groebner basis computation with the lexicographical order).
	See PolynomialRingMap>>kernel."
	| A B m n P t embedding generators g I |
	A _ self domain ambient coordinateRing.
	B _ self codomain ambient coordinateRing.
	m _ A rank.
	n _ B rank.
	P _ self domain scalars polynomialsIn: n + m + 1.
	"the embedding mapping the i-th indeterminate to the (i+n)-th indeterminate in the bigger ring:"
	embedding _ A to: P mapping: [:i| P x: i+n].
	t _ P x: P rank.
	generators _ OrderedCollection new.
	g _ P one.
	1 to: n do: [:i| | numerator denominator |
		numerator _ embedding value: (self representatives at: i) numerator.
		denominator _ embedding value: (self representatives at: i) denominator.
		generators add: denominator * (P x: i) - numerator.
		g _ g * denominator].
	self domain asIdeal generators do: [:each| generators add: (embedding value: each)].
	generators add: P one - (g * t).
	I _ P * generators eliminateAll: (n+1 to: P rank).
	^ self codomain subscheme: (I generators collect: [:f| B !! f])! !

!RationalMap methodsFor: 'operations' stamp: 'len 12/18/2021 20:31:12'!
jacobian
	"Answer the Jacobian matrix of the receiver."
	^ self domain ambient coordinateRing
		matrix: self codomain ambient rank @ self domain ambient rank
		filling: [:i :j| (self representatives at: i) derivativeIn: j]! !

!RationalMap methodsFor: 'operations' stamp: 'len 1/15/2017 17:24:31'!
projectiveClosure
	^ self class
		from: self domain projectiveClosure
		to: self codomain projectiveClosure
		representatives: (self representatives collect: [:each| each homogenized])! !

!RationalMap methodsFor: 'operations' stamp: 'len 12/15/2021 12:02:00'!
pullback: aScheme
	"Answer the preimage of aScheme. The argument is a subscheme of the codomain, and the answer is a subscheme of the domain."
	^ self domain subscheme: (aScheme asIdeal apply: self asRingMap)! !

!RationalMap methodsFor: 'operations' stamp: 'len 8/19/2021 10:05:17'!
value: aPoint
	| x value |
	(aPoint isKindOf: Ideal)
		ifTrue: [^ self asRingMap preimage: aPoint].
	x _ aPoint asTuple.
	value _ aPoint scalars tuple: (self representatives asArray collect: [:each| each value: x]).
	(aPoint isKindOf: RationalPoint)
		ifTrue: [^ self codomain pointAt: value].
	^ value! !

!RationalMap methodsFor: 'testing' stamp: 'len 1/15/2017 17:18:42'!
isAffineLinear
	"Answer true if the receiver is an affine linear map (defined by polynomials of degree 1)."
	^ self representatives allSatisfy: [:each| each isAffineLinear]! !

!RationalMap methodsFor: 'testing' stamp: 'len 12/28/2016 21:55:19'!
isConstant
	^ self representatives allSatisfy: [:each| each isConstant]! !

!RationalMap methodsFor: 'testing' stamp: 'len 10/17/2016 16:21'!
isDominant
	"Answer true if the closure of the image of the receiver is the whole codomain."
	^ self image = self codomain! !

!RationalMap methodsFor: 'testing' stamp: 'len 1/15/2017 17:17:24'!
isLinear
	"Answer true if the receiver is a homogeneous linear map (defined by homogeneous linear polynomials, with independent coefficient zero)."
	^ self representatives allSatisfy: [:each| each isLinear]! !

!RationalMap methodsFor: 'testing' stamp: 'len 6/7/2020 06:20:30'!
isPolynomial
	"Answer true if the receiver is a polynomial map."
	^ self representatives allSatisfy: [:each| each isIntegral]! !

!RationalMap methodsFor: 'testing' stamp: 'len 1/15/2017 17:23:31'!
isRegular
	"Answer true if the receiver is defined at all points of its domain."
	(self domain ambient isKindOf: AffineSpace) ifTrue: [^ self isPolynomial].
	(self domain ambient isKindOf: ProjectiveSpace) ifTrue: [^ self isConstant].
	^ DomainError signal! !

!RationalMap methodsFor: 'private' stamp: 'len 5/9/2020 22:18:28'!
representatives: aTuple
	self propertyAt: #representatives put: aTuple! !

!RationalMap methodsFor: 'private' stamp: 'len 1/10/2017 18:47:11'!
species
	^ RationalMap! !

!RationalMap class methodsFor: 'examples' stamp: 'len 12/15/2021 13:23:36'!
example1TwistedCubicTangentParametrization
	"Example from Cox's 'Ideals, Varieties and Algorithms' pag. 234.
	Parametrization of the tangent surface of the twisted cubic."
	| A2 A3 |
	A2 _ AffineSpace new: #(t u) over: .
	A3 _ AffineSpace new: 3 over: .
	^ RationalMap from: A2 to: A3 evaluatingWithArguments: [:t :u| {t + u. t^2 + (t*u*2). t^3 + (t^2*u*3)}]! !

!RationalMap class methodsFor: 'examples' stamp: 'len 11/1/2016 16:51'!
example2TwistedCubicTangent
	"The tangent surface of the twisted cubic."
	^ self example1TwistedCubicTangentParametrization image! !

!RationalMap class methodsFor: 'instance creation' stamp: 'len 6/1/2020 13:27:10'!
from: aDomain to: aCodomain evaluating: anExpression
	| F |
	F _ aDomain ambient functionField.
	^ self from: aDomain to: aCodomain representatives: (anExpression value: (F^aDomain ambient rank filling: [:i| F x: i]))! !

!RationalMap class methodsFor: 'instance creation' stamp: 'len 5/9/2020 22:18:46'!
from: aDomain to: aCodomain representatives: anArrayOfRationalFunctions
	((aDomain isProjective or: [aCodomain isProjective]) and: [anArrayOfRationalFunctions anySatisfy: [:any| any isHomogeneous not]])
		ifTrue: [^ self error: 'not homogeneous'].
	^ self new domain: aDomain; codomain: aCodomain; representatives: (aDomain ambient functionField tuple: anArrayOfRationalFunctions)! !

!EllipticCurveIsogeny methodsFor: 'as yet unclassified' stamp: 'len 3/6/2017 16:48:06'!
dual
	"Answer the dual of the receiver. If the receiver is f:E->E' of degree n, its dual is an isogeny g:E'->E such that the compositions are [n] (multiplication by n)."
	^ self notYetImplemented! !

!EllipticCurveIsogeny methodsFor: 'as yet unclassified' stamp: 'len 12/25/2016 08:42:27'!
isSurjective
	^ self isZero not! !

!EllipticCurveIsogeny methodsFor: 'as yet unclassified' stamp: 'len 12/25/2016 08:43:44'!
isZero
	^ self degree = 0! !

!EllipticCurveIsogeny methodsFor: 'as yet unclassified' stamp: 'len 12/28/2016 11:16:46'!
kernelPolynomial
	^ self propertyAt: #kernelPolynomial ifAbsentPut: [self computeKernelPolynomial]! !

!LinearFractionalMap methodsFor: 'accessing' stamp: 'len 12/9/2016 10:07:23'!
a
	^ a! !

!LinearFractionalMap methodsFor: 'accessing' stamp: 'len 12/9/2016 10:07:26'!
b
	^ b! !

!LinearFractionalMap methodsFor: 'accessing' stamp: 'len 12/9/2016 10:07:29'!
c
	^ c! !

!LinearFractionalMap methodsFor: 'accessing' stamp: 'len 5/23/2020 09:31:47'!
codomain
	^ ! !

!LinearFractionalMap methodsFor: 'accessing' stamp: 'len 12/9/2016 10:07:31'!
d
	^ d! !

!LinearFractionalMap methodsFor: 'accessing' stamp: 'len 5/23/2020 09:31:47'!
domain
	^ ! !

!LinearFractionalMap methodsFor: 'accessing' stamp: 'len 12/9/2016 16:30:21'!
identity
	^ self class I! !

!LinearFractionalMap methodsFor: 'accessing-private' stamp: 'len 12/9/2016 10:08:43'!
a: aNumber
	a _ aNumber! !

!LinearFractionalMap methodsFor: 'accessing-private' stamp: 'len 12/9/2016 10:08:45'!
b: aNumber
	b _ aNumber! !

!LinearFractionalMap methodsFor: 'accessing-private' stamp: 'len 12/9/2016 10:08:48'!
c: aNumber
	c _ aNumber! !

!LinearFractionalMap methodsFor: 'accessing-private' stamp: 'len 12/9/2016 10:08:50'!
d: aNumber
	d _ aNumber! !

!LinearFractionalMap methodsFor: 'comparing' stamp: 'len 12/10/2016 11:51:23'!
= aMoebiusMap
	aMoebiusMap species = self species ifFalse: [^ super = aMoebiusMap].
	^ a = aMoebiusMap a and: [b = aMoebiusMap b and: [c = aMoebiusMap c and: [d = aMoebiusMap d]]]! !

!LinearFractionalMap methodsFor: 'comparing' stamp: 'len 12/10/2016 11:51:45'!
hash
	^ ((a hash + b hash) hashMultiply + c hash) hashMultiply + d hash! !

!LinearFractionalMap methodsFor: 'converting' stamp: 'len 6/1/2020 12:38:46'!
asMatrix
	^ (self domain scalars^2) endomorphisms !! {a. b. c. d}! !

!LinearFractionalMap methodsFor: 'converting' stamp: 'len 12/28/2016 10:24:10'!
asRationalFunction
	| z |
	z _ (self domain scalars polynomialsIn: #(z)) fractions x.
	^ z * a + b / (z * c + d)! !

!LinearFractionalMap methodsFor: 'operations' stamp: 'len 3/13/2020 06:14:59'!
 aModularMap
	self species = aModularMap species ifFalse: [^ super  aModularMap].
	^ self class
		a: a * aModularMap a + (b * aModularMap c)
		b: a * aModularMap b + (b * aModularMap d)
		c: c * aModularMap a + (d * aModularMap c)
		d: c * aModularMap b + (d * aModularMap d)! !

!LinearFractionalMap methodsFor: 'operations' stamp: 'len 12/9/2016 10:14:36'!
inverse
	^ self class a: d b: b negated c: c negated d: a! !

!LinearFractionalMap methodsFor: 'operations' stamp: 'len 12/9/2016 21:50:06'!
trace
	^ a + d! !

!LinearFractionalMap methodsFor: 'operations' stamp: 'len 12/15/2016 17:46:03'!
traceSquared
	^ (a + d) squared! !

!LinearFractionalMap methodsFor: 'operations' stamp: 'len 12/9/2016 10:07:06'!
value: anObject
	^ anObject * a + b / (anObject * c + d)! !

!LinearFractionalMap methodsFor: 'testing' stamp: 'len 12/14/2016 10:31:41'!
isCircular
	^ self trace = 0! !

!LinearFractionalMap methodsFor: 'testing' stamp: 'len 12/15/2016 17:48:21'!
isElliptic
	^ self traceSquared < 4! !

!LinearFractionalMap methodsFor: 'testing' stamp: 'len 12/15/2016 17:48:27'!
isHyperbolic
	^ self traceSquared > 4! !

!LinearFractionalMap methodsFor: 'testing' stamp: 'len 12/10/2016 12:04:59'!
isIdentity
	^ a = 1 and: [b = 0 and: [c = 0 and: [d = 1]]]! !

!LinearFractionalMap methodsFor: 'testing' stamp: 'len 12/15/2016 17:48:33'!
isLoxodromic
	| t |
	^ (t _ self traceSquared) < 0 or: [t > 4]! !

!LinearFractionalMap methodsFor: 'testing' stamp: 'len 12/15/2016 17:48:39'!
isParabolic
	^ self traceSquared = 4! !

!LinearFractionalMap class methodsFor: 'instance creation' stamp: 'len 12/9/2016 16:29:49'!
I
	^ self a: 1 b: 0 c: 0 d: 1! !

!LinearFractionalMap class methodsFor: 'instance creation' stamp: 'len 12/9/2016 16:29:54'!
R
	^ self a: 0 b: 1 c: -1 d: 1! !

!LinearFractionalMap class methodsFor: 'instance creation' stamp: 'len 12/9/2016 16:30:03'!
S
	^ self a: 0 b: -1 c: 1 d: 0! !

!LinearFractionalMap class methodsFor: 'instance creation' stamp: 'len 12/9/2016 16:30:11'!
T
	^ self a: 1 b: 1 c: 0 d: 1! !

!LinearFractionalMap class methodsFor: 'instance creation' stamp: 'len 12/9/2016 10:08:59'!
a: a b: b c: c d: d
	^ self new a: a; b: b; c: c; d: d! !

!LinearFractionalMap class methodsFor: 'instance creation' stamp: 'len 12/10/2016 12:37:18'!
matrix: aMatrix
	^ self a: (aMatrix at: 1@1) b: (aMatrix at: 1@2) c: (aMatrix at: 2@1) d: (aMatrix at: 2@2)! !

!ModularMap methodsFor: 'as yet unclassified' stamp: 'len 6/1/2020 13:05:39'!
asMatrix
	^ (^2) endomorphisms !! {a. b. c. d}! !

!ModularMap methodsFor: 'as yet unclassified' stamp: 'len 12/14/2016 10:26:46'!
isElliptic
	^ self trace abs < 2! !

!ModularMap methodsFor: 'as yet unclassified' stamp: 'len 12/14/2016 10:26:54'!
isHyperbolic
	^ self trace abs > 2! !

!ModularMap methodsFor: 'as yet unclassified' stamp: 'len 12/14/2016 10:27:12'!
isParabolic
	^ self trace abs = 2! !

!Sequence methodsFor: 'operations' stamp: 'len 6/4/2019 09:20:19'!
* anObject
	^ (self codomain includes: anObject)
		ifTrue: [self species to: self codomain evaluating: [:n| (self at: n) * anObject]]
		ifFalse: [self species to: self codomain evaluating: [:n| (self at: n) * (anObject at: n)]]! !

!Sequence methodsFor: 'operations' stamp: 'len 6/4/2019 09:21:05'!
+ anObject
	^ (self codomain includes: anObject)
		ifTrue: [self species to: self codomain evaluating: [:n| (self at: n) + anObject]]
		ifFalse: [self species to: self codomain evaluating: [:n| (self at: n) + (anObject at: n)]]! !

!Sequence methodsFor: 'operations' stamp: 'len 5/6/2019 03:53:45'!
- anObject
	^ self + anObject negated! !

!Sequence methodsFor: 'operations' stamp: 'len 5/6/2019 03:51:55'!
/ anObject
	^ self * anObject reciprocal! !

!Sequence methodsFor: 'operations' stamp: 'len 6/1/2019 08:29:43'!
<< anInteger
	^ self >> anInteger negated! !

!Sequence methodsFor: 'operations' stamp: 'len 12/27/2015 02:11'!
average
	^ self species to: self codomain evaluating: [:N| ((1 to: N) sum: [:n| self at: n]) / N]! !

!Sequence methodsFor: 'operations' stamp: 'len 6/4/2019 09:21:51'!
backwardDifference: n at: h
	^ self species
		to: self codomain
		evaluating: [:x| (0 to: n) sum: [:i| (-1)^i * (n choose: i) * (self at: x + (i*h))]]! !

!Sequence methodsFor: 'operations' stamp: 'len 6/4/2019 18:10:01'!
binomialInverseTransform
	^ self species to: self codomain evaluating: [:n| (0 to: n-1) sum: [:k| (n-1 choose: k) * (self at: k+1)]]! !

!Sequence methodsFor: 'operations' stamp: 'len 6/4/2019 18:06:06'!
binomialTransform
	"The binomial transform is its own inverse, it's an involution."
	^ self species to: self codomain evaluating: [:n| (0 to: n-1) sum: [:k| (-1)^(n-1-k) * (n-1 choose: k) * (self at: k+1)]]! !

!Sequence methodsFor: 'operations' stamp: 'len 6/4/2019 09:22:08'!
centralDifference: n at: h
	^ self species
		to: self codomain
		evaluating: [:x| (0 to: n) sum: [:i| (-1)^i * (n choose: i) * (self at: x + ((n/2 - i)*h))]]! !

!Sequence methodsFor: 'operations' stamp: 'len 6/4/2019 05:29:55'!
convolution: aSequence
	^ self species to: self codomain evaluating: [:n| (0 to: n-1) sum: [:i| (self at: 1+i) * (aSequence at: n-i)]]! !

!Sequence methodsFor: 'operations' stamp: 'len 6/1/2019 08:31:04'!
difference
	"Answer the 'difference' sequence of the receiver, or delta, or discrete derivative."
	^ (self << 1) - self! !

!Sequence methodsFor: 'operations' stamp: 'len 12/27/2015 02:11'!
dirichlet: aSequence
	"Answer the Dirichlet convolution of the receiver with the argument, assuming both are arithmetic functions (i.e. functions from the natural numbers to the complex numbers).
	The set of arithmetic functions form a commutative ring (the Dirichlet ring) under pointwise addition and Dirichlet convolution."
	^ self species to: self codomain evaluating: [:n| n divisors sum: [:d| (self at: d) * (aSequence at: n/d)]]! !

!Sequence methodsFor: 'operations' stamp: 'len 6/4/2019 09:22:27'!
forwardDifference: n at: h
	^ self species
		to: self codomain
		evaluating: [:x| (0 to: n) sum: [:i| (-1)^(n-i) * (n choose: i) * (self at: x + ((n-i)*h))]]! !

!Sequence methodsFor: 'operations' stamp: 'len 6/4/2019 09:22:50'!
hadamard: aSequence
	"Answer the entrywise product with the argument, also called Hadamard product."
	^ self class to: self codomain evaluating: [:i| (self at: i) * (aSequence at: i)]! !

!Sequence methodsFor: 'operations' stamp: 'len 12/27/2015 02:11'!
moebiusInverse
	"This is equivalent to the Dirichlet convolution of the Moebius arithmetic function with the receiver.
	If f(n) and g(n) are two arithmetic functions satisfying g = f * 1 (Dirichlet convolution of f with the constant function 1), then the Moebius inversion formula can be used to retrieve f as f = mu * g. It is said that f and g and Moebius transforms of each other."
	^ self species to: self codomain evaluating: [:n| n divisors sum: [:d| d moebius * (self at: n/d)]]! !

!Sequence methodsFor: 'operations' stamp: 'len 6/4/2019 09:24:13'!
negated
	^ self species to: self codomain evaluating: [:n| (self at: n) negated]! !

!Sequence methodsFor: 'operations' stamp: 'len 12/27/2015 19:48'!
product
	"Answer the indefinite product of the receiver."
	^ self species to: self codomain evaluating: [:i| (1 to: i) collect: [:k| self at: k] andFold: [:a :b| a*b]]! !

!Sequence methodsFor: 'operations' stamp: 'len 6/4/2019 09:23:27'!
reciprocal
	^ self species to: self codomain evaluating: [:n| (self at: n) reciprocal]! !

!Sequence methodsFor: 'operations' stamp: 'len 5/6/2019 03:54:25'!
squared
	^ self * self! !

!Sequence methodsFor: 'operations' stamp: 'len 12/27/2015 02:12'!
stirlingInverseTransform
	^ self species to: self codomain evaluating: [:n| (1 to: n) sum: [:k| (n stirling: k) * (self at: k)]]! !

!Sequence methodsFor: 'operations' stamp: 'len 12/27/2015 02:12'!
stirlingTransform
	^ self species to: self codomain evaluating: [:n| (1 to: n) sum: [:k| (n Stirling: k) * (self at: k)]]! !

!Sequence methodsFor: 'operations' stamp: 'len 12/27/2015 19:48'!
sum
	"Answer the indefinite sum of the receiver."
	^ self species to: self codomain evaluating: [:i| (1 to: i) sum: [:k| self at: k]]! !

!Sequence methodsFor: 'operations' stamp: 'len 12/4/2015 04:00'!
value: aNumber
	^ self at: aNumber asInteger! !

!Sequence methodsFor: 'printing' stamp: 'len 4/25/2016 07:23'!
lookup
	^ OEIS default lookup: self! !

!Sequence methodsFor: 'printing' stamp: 'len 12/28/2016 11:13:18'!
printLimit
	^ self propertyAt: #printLimit ifAbsent: [17]! !

!Sequence methodsFor: 'printing' stamp: 'len 12/28/2016 11:13:57'!
printLimit: anInteger
	self propertyAt: #printLimit put: anInteger! !

!Sequence methodsFor: 'printing' stamp: 'len 4/26/2016 06:46'!
printOn: aStream base: base
	(1 to: self printLimit) do: [:i| (self at: i) printOn: aStream base: base] separatedBy: [aStream nextPutAll:', ' ].
	aStream nextPutAll: '...'! !

!Sequence methodsFor: 'printing' stamp: 'len 4/26/2016 06:47'!
printStringBase: base
	^ String streamContents:
		[:aStream| self printOn: aStream base: base]! !

!Sequence methodsFor: 'accessing' stamp: 'len 6/4/2019 05:39:30'!
at: anInteger
	^ self at: anInteger ifAbsent: []! !

!Sequence methodsFor: 'accessing' stamp: 'len 6/3/2019 17:30:31'!
at: anInteger ifAbsent: aBlock
	^ anInteger > 0 ifTrue: [super value: anInteger] ifFalse: [aBlock value]! !

!Sequence methodsFor: 'accessing' stamp: 'len 5/23/2020 09:34:55'!
codomain
	^ self propertyAt: #codomain ifAbsent: []! !

!Sequence methodsFor: 'accessing' stamp: 'len 5/23/2020 09:30:12'!
domain
	^ self propertyAt: #domain ifAbsent: []! !

!Sequence methodsFor: 'accessing' stamp: 'len 6/1/2019 08:33:57'!
scalars
	"For compatibility with tuples."
	^ self codomain! !

!Sequence methodsFor: 'accessing' stamp: 'len 12/29/2021 11:55:57'!
size
	^ self propertyAt: #size ifAbsent: [Cardinal new]! !

!Sequence methodsFor: 'comparing' stamp: 'len 12/5/2015 01:11'!
beginsWith: aSequenceableCollection
	1 to: aSequenceableCollection size do: [:i| (self at: i) = (aSequenceableCollection at: i) ifFalse: [^ false]].
	^ true! !

!Sequence methodsFor: 'comparing' stamp: 'len 12/27/2015 01:29'!
equals: aSequence upTo: n
	^ self beginsWith: (aSequence copyFrom: 1 to: n)! !

!Sequence methodsFor: 'comparing' stamp: 'len 12/27/2015 03:56'!
hash
	^ (self at: 1) hash + (self at: 3) hash + (self at: 5) hash! !

!Sequence methodsFor: 'converting' stamp: 'len 12/2/2016 09:57:05'!
asStream
	^ ReadStream on: self! !

!Sequence methodsFor: 'copying' stamp: 'len 6/1/2019 08:31:20'!
copyFrom: start to: end
	end isInfinite
		ifTrue: [^ self >> (1 - start)].
	^ (start to: end) collect: [:i| self at: i]! !

!Sequence methodsFor: 'copying' stamp: 'len 4/20/2016 21:25'!
first: n
	^ self copyFrom: 1 to: n! !

!Sequence methodsFor: 'enumerating' stamp: 'len 12/3/2015 20:34'!
collect: aBlock
	^ self species evaluating: [:i| aBlock value: (self at: i)]! !

!Sequence methodsFor: 'enumerating' stamp: 'len 4/25/2016 07:08'!
count: aBlock
	^ (self collect: [:each| (aBlock value: each) ifTrue: [1] ifFalse: [0]]) sum! !

!Sequence methodsFor: 'enumerating' stamp: 'len 12/27/2015 03:45'!
do: aBlock
	1 to: self size do: [:each| aBlock value: (self at: each)]! !

!Sequence methodsFor: 'enumerating' stamp: 'len 6/2/2019 04:31:06'!
findFirst: aBlock
	"Return the index of my first element for which aBlock evaluates as true."
	| index |
	index _ 0.
	[(aBlock value: (self at: (index _ index + 1))) ifTrue: [^ index]] repeat! !

!Sequence methodsFor: 'enumerating' stamp: 'len 12/3/2015 23:16'!
select: aBlock
	^ self species evaluating: [:i|
		| k j value |
		k _ 1.
		j _ 1.
		[[aBlock value: (value _ self at: k)] whileFalse: [k _ k + 1]. j < i] whileTrue: [j _ j + 1. k _ k + 1].
		value]! !

!Sequence methodsFor: 'enumerating' stamp: 'len 3/27/2016 04:44'!
withIndexDo: aBlock
	| i |
	i _ 1.
	self do: [:each| aBlock value: each value: i. i _ i + 1]! !

!Sequence methodsFor: 'series' stamp: 'len 6/2/2019 16:58:56'!
bellSeries: p
	^ self codomain powerSeries coefficients: (self species to: self codomain evaluating: [:n| self at: p^(n-1)])! !

!Sequence methodsFor: 'series' stamp: 'len 12/29/2015 04:25'!
dirichletSeries
	"Answer the Dirichlet series generating function of the receiver."
	^ DirichletSeries coefficients: self! !

!Sequence methodsFor: 'series' stamp: 'len 6/2/2019 17:00:18'!
exponentialSeries
	"Answer the exponential generating function of the receiver."
	^ self codomain powerSeries coefficients: (self species to: self codomain evaluating: [:n| (self at: n) / (n-1) factorial])! !

!Sequence methodsFor: 'series' stamp: 'len 12/29/2015 04:26'!
generatingSeries
	"Answer the ordinary generating function of the receiver."
	^ self ordinaryGeneratingSeries! !

!Sequence methodsFor: 'series' stamp: 'len 6/2/2019 17:00:31'!
ordinaryGeneratingSeries
	"Answer the ordinary generating function of the receiver."
	^ self codomain powerSeries coefficients: self! !

!Sequence methodsFor: 'private' stamp: 'len 12/3/2015 20:34'!
species
	^ Sequence! !

!Sequence class methodsFor: 'examples' stamp: 'len 8/5/2021 08:43:00'!
Omega
	"Number of prime divisors of n counted with multiplicity. A001222."
	^ Sequence evaluating: [:n| n factorization size]! !

!Sequence class methodsFor: 'examples' stamp: 'len 2/22/2017 08:24:46'!
aliquot
	"This is the aliquot function a(n) or s(n).
	It is the sum of the proper divisors of n (aliquot parts of n).
	If a(n) = n, n is a perfect number. If a(n) = n - 1, it is almost perfect. If a(n) > n, it is an abundant number."
	^ Sequence evaluating: [:n| n divisors sum - n]! !

!Sequence class methodsFor: 'examples' stamp: 'len 4/16/2016 19:33'!
bbs: s p: p q: q
	"Answer the Blum Blum Shub sequence for the given parameters."
	| lambda m |
	lambda _ p - 1 lcm: q - 1.
	m _ p * q.
	^ self evaluating: [:i| s raisedTo: (2 raisedTo: i modulo: lambda) modulo: m]! !

!Sequence class methodsFor: 'examples' stamp: 'len 6/4/2019 18:03:08'!
bellNumbers
	"The Bell numbers."
	^ Sequence evaluating: [:n| (0 to: n-1) sum: [:k| n-1 Stirling: k]]! !

!Sequence class methodsFor: 'examples' stamp: 'len 5/23/2020 09:33:01'!
bernoulli
	"This is the sequence of Bernoulli numbers (starting at 1), computed via a recurrence."
	^ Sequence to:  initialValues: #(1) recurrence: [:f :n| (n>4 and: [n even]) ifTrue: [0] ifFalse: [((0 to: n-2) sum: [:k| (n choose: k) * (f at: k+1)]) / n negated]]! !

!Sequence class methodsFor: 'examples' stamp: 'len 5/23/2020 09:33:01'!
calkinWilf
	"The Calkin-Wilf sequence.
	It enumerates the positive rational numbers by a breadth-first traversal of the Calkin-Wilf tree."
	^ Sequence
		to: 
		evaluating:
			[:n| | q |
			q _ 1.
			n-1 timesRepeat: [q _ 1 / (2 * q floor - q + 1)].
			q]! !

!Sequence class methodsFor: 'examples' stamp: 'len 2/22/2017 08:25:48'!
catalanNumbers
	"The Catalan numbers."
	^ Sequence evaluating: [:n| (2*(n-1) choose: n-1) / n]! !

!Sequence class methodsFor: 'examples' stamp: 'len 2/22/2017 08:26:11'!
fibonacci
	"The Fibonacci sequence defined as a recurrence."
	^ Sequence initialValues: #(0 1) recurrence: [:f :n| (f at: n-1) + (f at: n-2)]! !

!Sequence class methodsFor: 'examples' stamp: 'len 5/23/2020 09:33:01'!
harmonicNumbers
	"The harmonic numbers."
	^ Sequence to:  evaluating: [:n| (1 to: n) sum: [:k| 1/k]]! !

!Sequence class methodsFor: 'examples' stamp: 'len 7/17/2016 22:10'!
hensel: aPolynomial at: anIntegerRoot mod: p
	"Answer the p-adic expansion by Hensel lemma."
	| x |
	x _ aPolynomial species x.
	^ self recurrence:
		[:f :n|
		n = 1
			ifTrue: [anIntegerRoot]
			ifFalse:
				[| g a |
				g _ (f at: n-1) + (p^(n-1) * x).
				a _ (aPolynomial value: g % (p^n)) roots anyOne representative.
				(g value: a) \\ (p^n)]]! !

!Sequence class methodsFor: 'examples' stamp: 'len 2/22/2017 08:38:27'!
highlyCompositeNumbers
	"The sequence of highly composite numbers."
	^ Sequence recurrence: [:f :n| | i max |
		n = 1
			ifTrue: [1]
			ifFalse:
				[i _ f at: n-1.
				max _ i numberOfDivisors.
				[(i _ i + 1) numberOfDivisors > max] whileFalse. i]]! !

!Sequence class methodsFor: 'examples' stamp: 'len 2/22/2017 08:27:03'!
id
	"The identity sequence."
	^ Sequence evaluating: [:n| n]! !

!Sequence class methodsFor: 'examples' stamp: 'len 2/22/2017 08:27:15'!
liouville
	"The Liouville function."
	| Omega |
	Omega _ Sequence Omega.
	^ Sequence evaluating: [:n| (-1) ^ (Omega at: n)]! !

!Sequence class methodsFor: 'examples' stamp: 'len 8/5/2021 08:43:02'!
mangoldt
	"The von Mangoldt function (float)."
	^ Sequence evaluating: [:n| | factors | factors _ n factorization. factors asSet size = 1 ifTrue: [factors anyOne ln] ifFalse: [0]]! !

!Sequence class methodsFor: 'examples' stamp: 'len 8/5/2021 08:43:05'!
mangoldt2
	"The log2 von Mangoldt function."
	^ Sequence evaluating: [:n| | factors | factors _ n factorization. factors asSet size = 1 ifTrue: [factors anyOne highBit] ifFalse: [0]]! !

!Sequence class methodsFor: 'examples' stamp: 'len 2/22/2017 08:29:45'!
moebius
	"The Moebius function mu(n).
	This is 0 if n is squarefree, and (-1)^k otherwise (where k is the number of prime factors counted with multiplicity)."
	^ Sequence evaluating: [:n| n moebius]! !

!Sequence class methodsFor: 'examples' stamp: 'len 8/5/2021 08:43:07'!
omega
	"Number of distinct primes dividing n. A001221."
	^ Sequence evaluating: [:n| n factorization asSet size]! !

!Sequence class methodsFor: 'examples' stamp: 'len 2/22/2017 08:38:14'!
one
	"The constant sequence that is always 1."
	^ Sequence constant: 1! !

!Sequence class methodsFor: 'examples' stamp: 'len 2/22/2017 08:38:09'!
partitions
	"The partition function p(n) = number of partition of n. OEIS A000041."
	^ Sequence evaluating: [:n| n partitions size]! !

!Sequence class methodsFor: 'examples' stamp: 'len 2/22/2017 08:38:03'!
phi
	"Euler's totient function."
	^ Sequence evaluating: [:n| n phi]! !

!Sequence class methodsFor: 'examples' stamp: 'len 6/1/2019 13:35:39'!
primeGaps
	"The sequence of prime gaps.
	This is p(n+1) - p(n), the difference between concecutive primes."
	| p |
	p _ 2.
	^ Sequence streaming: [p negated + (p _ p nextPrime)]
"	^ Sequence primes difference"! !

!Sequence class methodsFor: 'examples' stamp: 'len 2/22/2017 08:31:34'!
primes
	"The sequence of primes."
	^ Sequence initialValues: #(2) recurrence: [:f :i| (f at: i-1) nextPrime]
"	^ Sequence evaluating: [:i|
		| n count |
		n _ 2.
		count _ 1.
		[count = i] whileFalse: [n _ n nextPrime. count _ count + 1].
		n]"! !

!Sequence class methodsFor: 'examples' stamp: 'len 2/22/2017 08:32:01'!
sigma
	"The sigma(n) function, defined as the sum of the positive divisors of n.
	The number n is said to be a perfect number iff sigma(n) = 2*n."
	^ Sequence evaluating: [:n| n divisors sum]! !

!Sequence class methodsFor: 'examples' stamp: 'len 12/4/2015 22:44'!
sigma: x
	"Answer the sigma(x,n) function."
	^ Sequence evaluating: [:n| n divisors sum: [:d| d^x]]! !

!Sequence class methodsFor: 'examples' stamp: 'len 12/4/2015 01:54'!
tau
	"Number of divisors of n, also called d(n) and sigma_O(n). A000005."
	^ Sequence evaluating: [:n| n divisors size]! !

!Sequence class methodsFor: 'intance creation' stamp: 'len 5/23/2020 09:34:55'!
constant: anInteger
	anInteger isInteger
		ifFalse: [^ DomainError signal: 'argument is not integer'].
	^ self to:  constant: anInteger! !

!Sequence class methodsFor: 'intance creation' stamp: 'len 5/23/2020 09:34:55'!
dynamic: aBlock
	^ self to:  dynamic: aBlock! !

!Sequence class methodsFor: 'intance creation' stamp: 'len 5/23/2020 09:34:55'!
evaluating: aBlock
	^ self to:  evaluating: aBlock! !

!Sequence class methodsFor: 'intance creation' stamp: 'len 5/23/2020 09:34:55'!
initialValues: anArray recurrence: aBinaryBlock
	^ self to:  initialValues: anArray recurrence: aBinaryBlock! !

!Sequence class methodsFor: 'intance creation' stamp: 'len 10/10/2016 21:08'!
recurrence: aBinaryBlock
	^ self initialValues: #() recurrence: aBinaryBlock! !

!Sequence class methodsFor: 'intance creation' stamp: 'len 5/23/2020 09:34:55'!
streaming: aBlock
	^ self to:  streaming: aBlock! !

!Sequence class methodsFor: 'intance creation' stamp: 'len 4/19/2016 21:42'!
to: aDomain constant: anObject
	^ self to: aDomain evaluating: [:n| anObject]! !

!Sequence class methodsFor: 'intance creation' stamp: 'len 5/11/2016 23:16'!
to: aDomain dynamic: aBlock
	^ self to: aDomain evaluating:
			[:n| | x |
			x _ 0.
			n timesRepeat: [x _ aBlock value: x].
			x]! !

!Sequence class methodsFor: 'intance creation' stamp: 'len 5/23/2020 09:30:18'!
to: aDomain evaluating: aBlock
	^ self from:  to: aDomain evaluating: aBlock! !

!Sequence class methodsFor: 'intance creation' stamp: 'len 10/10/2016 21:07'!
to: aDomain initialValues: anArray recurrence: aBlock
	| cache |
	cache _ OrderedCollection withAll: anArray.
	^ self to: aDomain evaluating:
			[:n|
			"(n isInteger and: [n > 0]) ifFalse: [DomainError signal]."
			[cache size < n] whileTrue: [cache add: (aBlock value: cache value: cache size + 1)].
			cache at: n]! !

!Sequence class methodsFor: 'intance creation' stamp: 'len 10/10/2016 21:08'!
to: aDomain recurrence: aBlock
	^ self to: aDomain initialValues: #() recurrence: aBlock! !

!Sequence class methodsFor: 'intance creation' stamp: 'len 6/1/2019 13:35:57'!
to: aDomain streaming: aBlock
	| cache |
	cache _ OrderedCollection new.
	^ self to: aDomain evaluating:
			[:n|
			"(n isInteger and: [n > 0]) ifFalse: [DomainError signal]."
			[cache size < n] whileTrue: [cache add: aBlock value].
			cache at: n]! !

!CFiniteSequence methodsFor: 'operations' stamp: 'len 12/24/2015 03:35'!
* anObject
	(anObject isKindOf: self class)
		ifTrue: [^ self class to: self codomain evaluating: super * anObject maxOrder: self order * anObject order].
	(self codomain includes: anObject)
		ifTrue: [^ self class to: self codomain evaluating: super * anObject maxOrder: self order].
	^ super * anObject! !

!CFiniteSequence methodsFor: 'operations' stamp: 'len 12/24/2015 03:29'!
+ aSequence
	(aSequence isKindOf: self class) ifFalse: [^ super + aSequence].
	^ self class to: self codomain evaluating: super + aSequence maxOrder: self order + aSequence order! !

!CFiniteSequence methodsFor: 'operations' stamp: 'len 12/24/2015 03:28'!
convolution: aSequence
	(aSequence isKindOf: self class) ifFalse: [^ super convolution: aSequence].
	^ self class to: self codomain evaluating: (super convolution: aSequence) maxOrder: self order * aSequence order! !

!CFiniteSequence methodsFor: 'operations' stamp: 'len 12/28/2016 11:14:22'!
minimal
	^ self propertyAt: #minimal ifAbsentPut: [self class to: self codomain evaluating: self maxOrder: self order]! !

!CFiniteSequence methodsFor: 'operations' stamp: 'len 12/24/2015 03:31'!
negated
	^ self class to: self codomain evaluating: super negated maxOrder: self order! !

!CFiniteSequence methodsFor: 'operations' stamp: 'len 12/24/2015 03:39'!
squared
	| n |
	n _ self order.
	^ self class to: self codomain evaluating: super squared maxOrder: n*(n-1)/2! !

!CFiniteSequence methodsFor: 'operations' stamp: 'len 12/27/2015 19:49'!
sum
	"Answer the indefinite sum of the receiver."
	^ self class to: self codomain evaluating: super sum maxOrder: self order squared! !

!CFiniteSequence methodsFor: 'accessing' stamp: 'len 6/4/2019 05:39:53'!
at: n ifAbsent: aBlock
	self order = 0 ifTrue: [^ self codomain zero].
	n <= initialValues size ifTrue: [^ initialValues at: n].
	^ (self matrix ^ (n - self order) * initialValues) last
"	answer _ 0.
	1 to: self order do: [:i |
		answer _ (self at: n - self order + i - 1) * (coefficients at: i) + answer].
	^ answer"! !

!CFiniteSequence methodsFor: 'accessing' stamp: 'len 12/27/2015 01:41'!
characteristicPolynomial
	^ self codomain polynomials coefficients: (coefficients negated copyWith: self codomain one)! !

!CFiniteSequence methodsFor: 'accessing' stamp: 'len 12/27/2015 03:49'!
coefficients
	^ coefficients! !

!CFiniteSequence methodsFor: 'accessing' stamp: 'len 12/27/2015 03:49'!
initialValues
	^ initialValues! !

!CFiniteSequence methodsFor: 'accessing' stamp: 'len 8/9/2020 07:50:39'!
matrix
	^ self propertyAt: #matrix ifAbsentPut: [self characteristicPolynomial companion transpose]! !

!CFiniteSequence methodsFor: 'accessing' stamp: 'len 12/27/2015 02:08'!
minimalPolynomial
	^ self minimal characteristicPolynomial! !

!CFiniteSequence methodsFor: 'accessing' stamp: 'len 12/28/2015 23:45'!
order
	^ coefficients size! !

!CFiniteSequence methodsFor: 'accessing' stamp: 'len 12/27/2015 01:44'!
startIndex
	^ 1! !

!CFiniteSequence methodsFor: 'accessing-private' stamp: 'len 12/3/2015 23:02'!
coefficients: anArray
	coefficients _ anArray! !

!CFiniteSequence methodsFor: 'accessing-private' stamp: 'len 6/1/2020 15:06:14'!
initialValues: anArray
	initialValues _ anArray.
	initialValues isTuple ifFalse: [initialValues _ self codomain^initialValues size !! initialValues]! !

!CFiniteSequence methodsFor: 'comparing' stamp: 'len 5/23/2020 10:04:19'!
= aSequence
	| f g |
	(aSequence isKindOf: CFiniteSequence)
		ifFalse: [^ super = aSequence].
	f _ self minimal.
	g _ aSequence minimal.
	^ f coefficients = g coefficients and: [f initialValues = g initialValues]! !

!CFiniteSequence methodsFor: 'printing' stamp: 'len 12/27/2015 01:25'!
printLimit
	^ self order + 10 min: super printLimit! !

!CFiniteSequence methodsFor: 'series' stamp: 'len 1/1/2022 09:34:05'!
generatingFunction
	| r s |
	"Answer the generating function of the receiver, which is a rational function that equals its ordinary generating series."
	s _ self characteristicPolynomial reversed.
	r _ self codomain polynomials coefficients:
		((0 to: self order - 1) collect: [:j|
			(self at: j+1) - ((1 to: j) sum: [:i| (s at: i) * (self at: j-i+1)])]).
	^ r / s! !

!CFiniteSequence methodsFor: 'testing' stamp: 'len 12/27/2015 02:08'!
isMinimal
	^ self minimalPolynomial = self characteristicPolynomial! !

!CFiniteSequence methodsFor: 'testing' stamp: 'len 4/11/2016 23:10'!
isZero
	^ self minimal order = 0! !

!CFiniteSequence class methodsFor: 'examples' stamp: 'len 5/23/2020 10:04:12'!
fibonacci
	"The Fibonacci sequence defined as a C-finite sequence."
	^ CFiniteSequence initialValues: #(0 1) coefficients: #(1 1)! !

!CFiniteSequence class methodsFor: 'examples' stamp: 'len 5/23/2020 09:33:01'!
geometric: aNumber
	(aNumber isInteger or: [aNumber isFraction])
		ifFalse: [^ DomainError signal: 'argument is not rational'].
	^ CFiniteSequence to:  initialValues: #(1) coefficients: {aNumber}! !

!CFiniteSequence class methodsFor: 'examples' stamp: 'len 5/23/2020 09:33:01'!
id
	"The identity sequence id(n) := n, defined by a recurrence."
	^ CFiniteSequence to:  initialValues: #(1 2) coefficients: #(-1 2)! !

!CFiniteSequence class methodsFor: 'examples' stamp: 'len 2/22/2017 08:36:33'!
jacobsthalNumbers
	"The Jacobsthal numbers."
	^ CFiniteSequence initialValues: #(0 1) coefficients: #(2 1)! !

!CFiniteSequence class methodsFor: 'examples' stamp: 'len 2/22/2017 08:36:42'!
lucasNumbers
	"The Lucas numbers."
	^ CFiniteSequence initialValues: #(2 1) coefficients: #(1 1)! !

!CFiniteSequence class methodsFor: 'examples' stamp: 'len 2/22/2017 08:36:49'!
pellNumbers
	"The Pell numbers."
	^ CFiniteSequence initialValues: #(0 1) coefficients: #(1 2)! !

!CFiniteSequence class methodsFor: 'instance creation' stamp: 'len 5/23/2020 09:34:55'!
initialValues: anArray coefficients: anotherArray
	^ self to:  initialValues: anArray coefficients: anotherArray! !

!CFiniteSequence class methodsFor: 'instance creation' stamp: 'len 12/27/2015 19:42'!
to: codomain constant: anObject
	^ self to: codomain initialValues: {anObject} coefficients: {anObject one}! !

!CFiniteSequence class methodsFor: 'instance creation' stamp: 'len 8/6/2016 00:46'!
to: codomain evaluating: aBlock maxOrder: n
	| initialValues bm f |
	initialValues _ (1 to: 2*n) collect: aBlock.
	bm _ ModifiedBerlekampMassey new
		field: (codomain isField ifTrue: [codomain] ifFalse: [codomain fractions]);
		input: initialValues.
	f _ bm minimalPolynomial.
	^ self to: codomain initialValues: (initialValues copyFrom: 1 to: f degree) minimalPolynomial:f! !

!CFiniteSequence class methodsFor: 'instance creation' stamp: 'len 3/30/2016 03:54'!
to: codomain initialValues: anArray characteristicPolynomial: aPolynomial
	^ self to: codomain initialValues: anArray coefficients: aPolynomial tail negated coefficients! !

!CFiniteSequence class methodsFor: 'instance creation' stamp: 'len 11/5/2016 10:27'!
to: aCodomain initialValues: anArray coefficients: anotherArray
	^ self new codomain: aCodomain; initialValues: anArray; coefficients: anotherArray! !

!CFiniteSequence class methodsFor: 'instance creation' stamp: 'len 12/28/2016 12:19:00'!
to: codomain initialValues: anArray minimalPolynomial: aPolynomial
	| answer |
	answer _ self to: codomain initialValues: anArray characteristicPolynomial: aPolynomial.
	answer propertyAt: #minimal put: answer.
	^ answer! !

!CFiniteSequence class methodsFor: 'instance creation' stamp: 'len 6/4/2019 07:19:55'!
to: aCodomain initialValues: initialArray periodic: periodArray
	| coefficients |
	coefficients _ Array new: initialArray size + periodArray size.
	coefficients atAllPut: periodArray first zero.
	coefficients at: initialArray size + 1 put: periodArray first one.
	^ self to: aCodomain initialValues: initialArray asArray, periodArray coefficients: coefficients! !

!CFiniteSequence class methodsFor: 'instance creation' stamp: 'len 12/27/2015 03:41'!
to: codomain periodic: anArray
	| coefficients |
	coefficients _ Array new: anArray size.
	coefficients atAllPut: anArray first zero.
	coefficients at: 1 put: anArray first one.
	^ self to: codomain initialValues: anArray coefficients: coefficients! !

!SimplicialMap methodsFor: 'comparing' stamp: 'len 2/20/2017 16:04:20'!
= aSimplicialMap
	self == aSimplicialMap ifTrue: [^ true].
	(aSimplicialMap isKindOf: SimplicialMap)
		ifFalse: [^ false].
	(self domain = aSimplicialMap domain and: [self codomain = aSimplicialMap codomain])
		ifFalse: [^ false].
	^ map = aSimplicialMap map! !

!SimplicialMap methodsFor: 'operations' stamp: 'len 2/20/2017 16:10:51'!
 aSimplicialMap
	"Answer the fibered product of the receiver and the argument."
	self codomain = aSimplicialMap codomain ifFalse: [^ DomainError signal: 'codomains don''t match'].
	^ self domain  aSimplicialMap domain to: self codomain evaluating: [:each| Simplex vertices: (each vertices collect: [:v| {self map value: (v at: 1). aSimplicialMap map value: (v at: 2)}]) asSet]! !

!SimplicialMap methodsFor: 'operations' stamp: 'len 2/20/2017 15:46:09'!
value: aSimplex
	^ Simplex vertices: (aSimplex vertices collect: [:each| map at: each]) asSet! !

!SimplicialMap methodsFor: 'testing' stamp: 'len 2/20/2017 15:55:51'!
isInjective
	^ map asSet size = map size! !

!SimplicialMap methodsFor: 'testing' stamp: 'len 2/20/2017 15:28:04'!
isSurjective
	^ self codomain = self image! !

!SimplicialMap methodsFor: 'private' stamp: 'len 2/20/2017 15:17:40'!
map: aDictionary
	map _ aDictionary! !

!SimplicialMap class methodsFor: 'instance creation' stamp: 'len 2/20/2017 18:41:31'!
from: aSimplicialComplex to: anotherSimplicialComplex evaluating: aBlock
	^ self from: aSimplicialComplex to: anotherSimplicialComplex mapping: [:v| (aBlock value: (Simplex vertices: {v})) vertices anyOne]! !

!SimplicialMap class methodsFor: 'instance creation' stamp: 'len 2/20/2017 18:38:40'!
from: aSimplicialComplex to: anotherSimplicialComplex map: aDictionary
	^ self new domain: aSimplicialComplex; codomain: anotherSimplicialComplex; map: aDictionary! !

!SimplicialMap class methodsFor: 'instance creation' stamp: 'len 2/20/2017 18:40:49'!
from: aSimplicialComplex to: anotherSimplicialComplex mapping: aBlock
	| map |
	map _ Dictionary new.
	aSimplicialComplex support do: [:each| map at: each put: (aBlock value: each)].
	^ self from: aSimplicialComplex to: anotherSimplicialComplex map: map! !

!SimplicialMap class methodsFor: 'class initialization' stamp: 'len 10/26/2020 13:48:55'!
initialize
	super initialize.
	Smalltalk at: #SCpx put: (Category new name: #SCpx)! !

!ModularForm methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:31:47'!
codomain
	^ ! !

!ModularForm methodsFor: 'as yet unclassified' stamp: 'len 12/11/2016 08:26:35'!
domain
	^ HH! !

!ModularForm methodsFor: 'as yet unclassified' stamp: 'len 12/8/2016 22:05:02'!
expansion
	"Answer the q-expansion (Fourier expansion) of the receiver."
	self notYetImplemented! !

!ModularForm methodsFor: 'as yet unclassified' stamp: 'len 12/8/2016 22:04:11'!
group
	^ self notYetImplemented! !

!ModularForm methodsFor: 'as yet unclassified' stamp: 'len 12/8/2016 22:04:15'!
level
	^ self notYetImplemented! !

!ModularForm methodsFor: 'as yet unclassified' stamp: 'len 12/8/2016 22:04:14'!
weight
	^ self notYetImplemented! !

!EisensteinSeries methodsFor: 'as yet unclassified' stamp: 'len 12/6/2016 20:40:21'!
weight
	^ weight! !

!EisensteinSeries methodsFor: 'as yet unclassified' stamp: 'len 12/6/2016 20:42:07'!
weight: anInteger
	(anInteger even and: [anInteger >= 4]) ifFalse: [^ self error: 'the weight must be even >= 4'].
	weight _ anInteger! !

!EisensteinSeries class methodsFor: 'as yet unclassified' stamp: 'len 12/6/2016 20:42:26'!
new: anInteger
	^ self new weight: anInteger! !

!ChainMap methodsFor: 'accessing' stamp: 'len 11/4/2020 12:29:27'!
at: anInteger
	^ components at: components size - anInteger + self domain minDegree ifAbsent:
		[| X Y |
		X _ self domain chains: anInteger.
		Y _ self codomain chains: anInteger.
		self assert: (X isTrivial or: [Y isTrivial]).
		X -> Y]! !

!ChainMap methodsFor: 'accessing' stamp: 'len 4/22/2020 14:25:19'!
components
	^ components! !

!ChainMap methodsFor: 'accessing' stamp: 'len 11/4/2020 16:24:37'!
degree
	^ 0! !

!ChainMap methodsFor: 'accessing' stamp: 'len 10/30/2020 11:18:47'!
opposite
	^ self propertyAt: #opposite ifAbsentPut: [CochainMap opposite: self]! !

!ChainMap methodsFor: 'comparing' stamp: 'len 4/22/2020 21:28:19'!
= anObject
	self == anObject ifTrue: [^ true].
	(anObject isKindOf: ChainMap) ifFalse: [^ super = anObject].
	^ self domain = anObject domain and: [self codomain = anObject codomain and: [self components = anObject components]]! !

!ChainMap methodsFor: 'homology' stamp: 'len 4/22/2020 15:42:34'!
boundaries: k
	^ (self domain boundaries: k) to: (self codomain boundaries: k) evaluating: [:x| (self at: k+1) value: x]! !

!ChainMap methodsFor: 'homology' stamp: 'len 4/22/2020 15:42:12'!
cycles: k
	^ (self domain cycles: k) to: (self codomain cycles: k) evaluating: [:x| (self at: k) value: x]! !

!ChainMap methodsFor: 'homology' stamp: 'len 4/22/2020 15:44:02'!
homology: k
	^ self notYetImplemented! !

!ChainMap methodsFor: 'operations' stamp: 'len 4/23/2020 00:23:25'!
* anElement
	^ self class from: self domain to: self codomain components: components * anElement! !

!ChainMap methodsFor: 'operations' stamp: 'len 4/22/2020 20:05:42'!
+ aChainMap
	(aChainMap isKindOf: ChainMap) ifFalse: [^ super + aChainMap].
	^ self class from: self domain to: self codomain components: components + aChainMap components! !

!ChainMap methodsFor: 'operations' stamp: 'len 4/22/2020 20:05:51'!
- aChainMap
	^ self + aChainMap negated! !

!ChainMap methodsFor: 'operations' stamp: 'len 4/23/2020 00:23:33'!
 aChainMap
	(aChainMap isKindOf: ChainMap) ifFalse: [^ super  aChainMap].
	^ self class from: aChainMap domain to: self codomain components: (components with: aChainMap components collect: [:f :g| f  g])! !

!ChainMap methodsFor: 'operations' stamp: 'len 4/23/2020 00:11:18'!
cokernel
	| chains |
	chains _ components collect: [:each| each cokernel].
"	^ ChainComplex differentials:  (self domain differentials withIndexCollect: [:each :i| (terms at: i) to: (terms at: i+1) evaluating: each])"
	self notYetImplemented! !

!ChainMap methodsFor: 'operations' stamp: 'len 4/23/2020 00:11:38'!
image
	| chains |
	chains _ components collect: [:each| each image].
	^ ChainComplex differentials:  (self codomain differentials withIndexCollect: [:each :i| (chains at: i) to: (chains at: i+1) evaluating: each])! !

!ChainMap methodsFor: 'operations' stamp: 'len 4/23/2020 00:22:25'!
inverse
	^ self class from: self codomain to: self domain components: (components collect: [:each| each inverse ifNil: [^ nil]])! !

!ChainMap methodsFor: 'operations' stamp: 'len 4/23/2020 00:11:55'!
kernel
	| chains |
	chains _ components collect: [:each| each kernel].
	^ ChainComplex differentials:  (self domain differentials withIndexCollect: [:each :i| (chains at: i) to: (chains at: i+1) evaluating: each])! !

!ChainMap methodsFor: 'operations' stamp: 'len 4/22/2020 20:03:57'!
negated
	^ self class from: self domain to: self codomain components: components negated! !

!ChainMap methodsFor: 'operations' stamp: 'len 4/23/2020 00:22:45'!
retraction
	^ self class from: self codomain to: self domain components: (components collect: [:each| each retraction ifNil: [^ nil]])! !

!ChainMap methodsFor: 'operations' stamp: 'len 4/23/2020 00:22:52'!
section
	^ self class from: self codomain to: self domain components: (components collect: [:each| each section ifNil: [^ nil]])! !

!ChainMap methodsFor: 'testing' stamp: 'len 4/22/2020 19:23:14'!
isIdentity
	^ components allSatisfy: [:each| each isIdentity]! !

!ChainMap methodsFor: 'testing' stamp: 'len 4/22/2020 12:32:34'!
isInjective
	^ self components allSatisfy: [:each| each isInjective]! !

!ChainMap methodsFor: 'testing' stamp: 'len 4/22/2020 15:45:25'!
isQuasiIsomorphism
	^ self indices allSatisfy: [:i| (self homology: i) isIsomorphism]! !

!ChainMap methodsFor: 'testing' stamp: 'len 4/22/2020 12:32:44'!
isSurjective
	^ self components allSatisfy: [:each| each isSurjective]! !

!ChainMap methodsFor: 'testing' stamp: 'len 4/22/2020 12:33:13'!
isZero
	^ self components allSatisfy: [:each| each isZero]! !

!ChainMap methodsFor: 'private' stamp: 'len 4/22/2020 14:25:03'!
components: anArray
	components _ anArray! !

!ChainMap methodsFor: 'private' stamp: 'len 4/22/2020 15:38:06'!
verify
	^ self indices allButLast allSatisfy: [:i| (self at: i)  (self domain at: i) = ((self codomain at: i)  (self at: i+1))]! !

!ChainMap class methodsFor: 'as yet unclassified' stamp: 'len 4/22/2020 14:29:07'!
from: aDomain to: aCodomain components: anArray
	^ self new domain: aDomain; codomain: aCodomain; components: anArray! !

!CochainMap methodsFor: 'accessing' stamp: 'len 10/30/2020 11:27:24'!
at: anInteger
	^ opposite at: anInteger negated! !

!CochainMap methodsFor: 'accessing' stamp: 'len 11/4/2020 16:26:55'!
degree
	^ opposite degree! !

!CochainMap methodsFor: 'accessing' stamp: 'len 11/4/2020 11:57:29'!
opposite
	^ opposite! !

!CochainMap methodsFor: 'printing' stamp: 'len 10/30/2020 11:38:20'!
verify
	^ opposite verify! !

!CochainMap methodsFor: 'cohomology' stamp: 'len 10/30/2020 11:28:31'!
coboundaries: k
	^ opposite boundaries: k negated! !

!CochainMap methodsFor: 'cohomology' stamp: 'len 10/30/2020 11:29:51'!
cocycles: k
	^ opposite cycles: k negated! !

!CochainMap methodsFor: 'cohomology' stamp: 'len 10/30/2020 11:30:11'!
cohomology: k
	^ opposite homology: k negated! !

!CochainMap methodsFor: 'comparing' stamp: 'len 10/30/2020 11:26:15'!
= anObject
	self == anObject ifTrue: [^ true].
	(anObject isKindOf: CochainMap) ifFalse: [^ super = anObject].
	^ opposite = anObject opposite! !

!CochainMap methodsFor: 'comparing' stamp: 'len 11/4/2020 16:27:20'!
hash
	^ opposite hash! !

!CochainMap methodsFor: 'operations' stamp: 'len 10/30/2020 11:24:49'!
* anElement
	^ self class opposite: opposite * anElement! !

!CochainMap methodsFor: 'operations' stamp: 'len 10/30/2020 11:25:27'!
+ aCochainMap
	(aCochainMap isKindOf: CochainMap) ifFalse: [^ super + aCochainMap].
	^ self class opposite: opposite + aCochainMap opposite! !

!CochainMap methodsFor: 'operations' stamp: 'len 10/30/2020 11:25:37'!
- aCochainMap
	^ self + aCochainMap negated! !

!CochainMap methodsFor: 'operations' stamp: 'len 10/30/2020 11:26:44'!
 aCochainMap
	(aCochainMap isKindOf: CochainMap) ifFalse: [^ super  aCochainMap].
	^ self class opposite: opposite  aCochainMap! !

!CochainMap methodsFor: 'operations' stamp: 'len 10/30/2020 11:29:27'!
cokernel
	^ opposite cokernel opposite! !

!CochainMap methodsFor: 'operations' stamp: 'len 10/30/2020 11:30:21'!
image
	^ opposite image opposite! !

!CochainMap methodsFor: 'operations' stamp: 'len 10/30/2020 11:30:38'!
inverse
	^ self class opposite: opposite inverse! !

!CochainMap methodsFor: 'operations' stamp: 'len 10/30/2020 11:36:07'!
kernel
	^ opposite kernel opposite! !

!CochainMap methodsFor: 'operations' stamp: 'len 10/30/2020 11:36:49'!
negated
	^ self class opposite: opposite negated! !

!CochainMap methodsFor: 'operations' stamp: 'len 10/30/2020 11:37:56'!
retraction
	^ self class opposite: opposite retraction! !

!CochainMap methodsFor: 'operations' stamp: 'len 10/30/2020 11:38:05'!
section
	^ self class opposite: opposite section! !

!CochainMap methodsFor: 'testing' stamp: 'len 10/30/2020 11:34:57'!
isIdentity
	^ opposite isIdentity! !

!CochainMap methodsFor: 'testing' stamp: 'len 10/30/2020 11:35:10'!
isInjective
	^ opposite isInjective! !

!CochainMap methodsFor: 'testing' stamp: 'len 10/30/2020 11:35:29'!
isQuasiIsomorphism
	^ opposite isQuasiIsomorphism! !

!CochainMap methodsFor: 'testing' stamp: 'len 10/30/2020 11:35:43'!
isSurjective
	^ opposite isSurjective! !

!CochainMap methodsFor: 'testing' stamp: 'len 10/30/2020 11:35:55'!
isZero
	^ opposite isZero! !

!AffineMorphism methodsFor: 'accessing' stamp: 'len 7/3/2019 10:22:00'!
adjoint
	^ adjoint! !

!AffineMorphism methodsFor: 'accessing' stamp: 'len 7/3/2019 10:23:31'!
codomain
	^ adjoint domain spec! !

!AffineMorphism methodsFor: 'accessing' stamp: 'len 7/3/2019 10:23:26'!
domain
	^ adjoint codomain spec! !

!AffineMorphism methodsFor: 'comparing' stamp: 'len 12/23/2021 14:08:35'!
= anObject
	^ (anObject isKindOf: AffineMorphism) and: [adjoint = anObject adjoint]! !

!AffineMorphism methodsFor: 'comparing' stamp: 'len 12/19/2021 19:33:42'!
hash
	^ adjoint hash! !

!AffineMorphism methodsFor: 'converting' stamp: 'len 12/20/2021 13:59:40'!
asRingMap
	^ adjoint! !

!AffineMorphism methodsFor: 'operations' stamp: 'len 12/19/2021 19:36:10'!
pullback: aScheme
	"Answer the preimage of aScheme. The argument is a subscheme of the codomain, and the answer is a subscheme of the domain."
	^ self domain subscheme: (aScheme asIdeal apply: self asRingMap)! !

!AffineMorphism methodsFor: 'operations' stamp: 'len 12/15/2021 11:57:44'!
value: aPoint
	^ self codomain !! (adjoint preimage: aPoint asIdeal)! !

!AffineMorphism methodsFor: 'private' stamp: 'len 7/3/2019 10:21:54'!
adjoint: aRingMap
	adjoint _ aRingMap! !

!AffineMorphism class methodsFor: 'instance creation' stamp: 'len 7/3/2019 10:21:41'!
adjoint: aRingMap
	^ self new adjoint: aRingMap! !

!ProjectiveMorphism methodsFor: 'accessing' stamp: 'len 12/20/2021 13:59:51'!
adjoint
	^ adjoint! !

!ProjectiveMorphism methodsFor: 'accessing' stamp: 'len 12/20/2021 14:00:42'!
codomain
	^ adjoint domain proj! !

!ProjectiveMorphism methodsFor: 'accessing' stamp: 'len 12/20/2021 14:00:36'!
domain
	^ adjoint codomain proj! !

!ProjectiveMorphism methodsFor: 'comparing' stamp: 'len 12/23/2021 14:08:57'!
= anObject
	^ (anObject isKindOf: ProjectiveMorphism) and: [adjoint = anObject adjoint]! !

!ProjectiveMorphism methodsFor: 'comparing' stamp: 'len 12/20/2021 13:59:27'!
hash
	^ adjoint hash! !

!ProjectiveMorphism methodsFor: 'converting' stamp: 'len 12/20/2021 13:59:34'!
asRingMap
	^ adjoint! !

!ProjectiveMorphism methodsFor: 'operations' stamp: 'len 12/20/2021 14:01:02'!
pullback: aScheme
	"Answer the preimage of aScheme. The argument is a subscheme of the codomain, and the answer is a subscheme of the domain."
	^ self domain subscheme: (aScheme asIdeal apply: self asRingMap)! !

!ProjectiveMorphism methodsFor: 'operations' stamp: 'len 12/20/2021 14:00:48'!
value: aPoint
	^ self codomain !! (adjoint preimage: aPoint asIdeal)! !

!ProjectiveMorphism methodsFor: 'private' stamp: 'len 12/20/2021 13:58:40'!
adjoint: aGradedRingMap
	adjoint _ aGradedRingMap! !

!ProjectiveMorphism class methodsFor: 'instance creation' stamp: 'len 12/20/2021 13:58:10'!
adjoint: aGradedRingMap
	^ self new adjoint: aGradedRingMap! !

!RationalPoint methodsFor: 'accessing' stamp: 'len 2/9/2017 09:54:09'!
ambient
	^ self codomain ambient! !

!RationalPoint methodsFor: 'accessing' stamp: 'len 11/16/2016 08:43'!
codomain
	^ codomain! !

!RationalPoint methodsFor: 'accessing' stamp: 'len 12/17/2021 11:50:46'!
coordinates
	^ coordinates! !

!RationalPoint methodsFor: 'accessing' stamp: 'len 11/16/2016 08:45'!
domain
	^ self scalars spec! !

!RationalPoint methodsFor: 'accessing' stamp: 'len 12/17/2021 11:51:49'!
scalars
	^ coordinates scalars! !

!RationalPoint methodsFor: 'converting' stamp: 'len 12/17/2021 11:53:17'!
asTuple
	^ coordinates! !

!RationalPoint methodsFor: 'testing' stamp: 'len 12/17/2021 11:55:00'!
isAffine
	^ false! !

!RationalPoint methodsFor: 'testing' stamp: 'len 1/11/2017 13:32:11'!
isFlex
	^ self multiplicity >= 3! !

!RationalPoint methodsFor: 'testing' stamp: 'len 12/17/2021 11:55:07'!
isProjective
	^ false! !

!RationalPoint methodsFor: 'testing' stamp: 'len 11/7/2016 08:27'!
isSingular
	^ self isSmooth not! !

!RationalPoint methodsFor: 'private' stamp: 'len 11/16/2016 08:43'!
codomain: aScheme
	codomain _ aScheme! !

!RationalPoint methodsFor: 'private' stamp: 'len 12/17/2021 11:50:58'!
coordinates: aTuple
	coordinates _ aTuple! !

!AffinePoint methodsFor: 'accessing' stamp: 'len 12/15/2021 11:55:03'!
asIdeal
	"Answer the prime ideal defining the receiver."
	| R |
	self codomain scalars = self scalars ifFalse: [^ self notYetImplemented].
	R _ self codomain ambient coordinateRing.
	^ R * (R generators - self coordinates)! !

!AffinePoint methodsFor: 'accessing' stamp: 'len 1/7/2017 22:07:07'!
height
	^ coordinates height! !

!AffinePoint methodsFor: 'accessing' stamp: 'len 12/20/2021 13:52:55'!
localRing
	"Answer the local ring at this point. This is the stalk of the structure sheaf at the receiver, i.e. the ring of germs."
	^ self neighborhood coordinateRing localization! !

!AffinePoint methodsFor: 'accessing' stamp: 'len 4/12/2018 04:17:19'!
multiplicity
	^ self codomain multiplicityAt: coordinates
	"^ self localRing multiplicity"! !

!AffinePoint methodsFor: 'accessing' stamp: 'len 12/20/2021 13:53:30'!
neighborhood
	"Answer a neighborhood certered at this point."
	^ self codomain - coordinates! !

!AffinePoint methodsFor: 'accessing' stamp: 'len 4/12/2018 04:17:39'!
tangentCone
	"Answer the affine tangent cone at this point."
	^ self codomain tangentConeAt: coordinates! !

!AffinePoint methodsFor: 'accessing' stamp: 'len 4/12/2018 04:17:46'!
tangentSpace
	"Answer the affine tangent space at this point."
	^ self codomain tangentSpaceAt: coordinates! !

!AffinePoint methodsFor: 'arithmetic' stamp: 'len 12/16/2021 11:40:18'!
+ aTuple
	"Answer the result of translating the receiver by a vector."
	^ self shallowCopy coordinates: self coordinates + aTuple! !

!AffinePoint methodsFor: 'arithmetic' stamp: 'len 12/31/2016 21:06:47'!
- anAffinePoint
	"The difference between two affine points is a vector (a tuple)."
	^ self coordinates - anAffinePoint coordinates! !

!AffinePoint methodsFor: 'comparing' stamp: 'len 11/7/2016 03:31'!
= anAffinePoint
	^ self coordinates = anAffinePoint coordinates! !

!AffinePoint methodsFor: 'comparing' stamp: 'len 11/7/2016 03:32'!
hash
	^ self coordinates hash! !

!AffinePoint methodsFor: 'converting' stamp: 'len 9/28/2018 06:51:58'!
asRingMap
	^ self codomain coordinateRing to: self domain coordinateRing evaluating: [:f| f value: self coordinates]! !

!AffinePoint methodsFor: 'converting' stamp: 'len 1/10/2017 20:47:52'!
homogenized
	"Answer the corresponding point in the projective closure."
	^ self codomain projectiveEmbedding value: self! !

!AffinePoint methodsFor: 'testing' stamp: 'len 12/17/2021 11:55:18'!
isAffine
	^ true! !

!AffinePoint methodsFor: 'testing' stamp: 'len 2/8/2017 07:15:41'!
isSmooth
	^ (self codomain singular satisfies: self coordinates) not! !

!AffinePoint class methodsFor: 'instance creation' stamp: 'len 2/13/2017 21:16:06'!
on: anAffineVariety coordinates: aTuple
	^ self new codomain: anAffineVariety; coordinates: aTuple! !

!ProjectivePoint methodsFor: 'printing' stamp: 'len 2/10/2017 09:55:36'!
printInsidesOn: aStream
	| separator |
	separator _ (self coordinates anySatisfy: [:any| any printString isAlphaNumeric not]) ifTrue: [' : '] ifFalse: [':'].
	self coordinates do: [:each| aStream print: each] separatedBy: [aStream nextPutAll: separator].
! !

!ProjectivePoint methodsFor: 'accessing' stamp: 'len 12/15/2021 11:56:14'!
asIdeal
	"Answer the prime ideal defining the receiver."
	| R m am xm ai generators |
	self codomain scalars = self scalars ifFalse: [^ self notYetImplemented].
	R _ self codomain ambient coordinateRing.
	generators _ OrderedCollection new: coordinates size.
	m _ coordinates depth.
	am _ coordinates at: m.
	xm _ R x: m.
	1 to: m do: [:i|
		ai _ coordinates at: i.
		ai isZero ifTrue: [generators add: (R x: i)] ifFalse: [generators add: (R x: i) * am - (xm*ai)]].
	m+1 to: coordinates size do: [:i|
		generators add: (R x: i)].
	^ R * generators! !

!ProjectivePoint methodsFor: 'accessing' stamp: 'len 12/18/2021 07:03:10'!
localRing
	"Answer the local ring at this point. This is the stalk of the structure sheaf at the receiver, i.e. the ring of germs."
	^ self dehomogenized localRing! !

!ProjectivePoint methodsFor: 'accessing' stamp: 'len 2/13/2017 07:53:19'!
multiplicity
	^ self dehomogenized multiplicity "assuming none of the components of the projective variety lies on the hyperplane at infinity"! !

!ProjectivePoint methodsFor: 'accessing' stamp: 'len 12/20/2021 13:53:57'!
neighborhood
	"Answer an affine neighborhood certered at this point."
	^ self dehomogenized neighborhood! !

!ProjectivePoint methodsFor: 'accessing' stamp: 'len 2/9/2017 10:41:07'!
tangentCone
	"Answer the projective tangent cone at this point."
	^ self dehomogenized tangentCone projectiveClosure "this projective closure uses the embedding corresponding to the same affine patch index that was used for dehomogenization"! !

!ProjectivePoint methodsFor: 'comparing' stamp: 'len 7/8/2019 13:20:39'!
= aProjectivePoint
	self class = aProjectivePoint class ifFalse: [^ super = aProjectivePoint].
	coordinates size = aProjectivePoint coordinates size ifFalse: [^ false].
	^ coordinates ~ aProjectivePoint coordinates! !

!ProjectivePoint methodsFor: 'comparing' stamp: 'len 5/3/2018 04:28:40'!
hash
	self scalars isField ifTrue: [^ self hashField].
	self scalars isIntegralDomain ifTrue: [^ self hashIntegralDomain].
	^ self scalars hash "hashMultiply + self coordinates lastNonZeroDivisor"! !

!ProjectivePoint methodsFor: 'comparing' stamp: 'len 8/17/2019 08:51:16'!
hashField
	| hash x |
	hash _ 0.
	x _ coordinates at: coordinates depth.
	1 to: coordinates size do: [:i | hash _ (hash + ((coordinates at: i) / x) hash) hashMultiply].
	^hash! !

!ProjectivePoint methodsFor: 'comparing' stamp: 'len 8/17/2019 08:51:24'!
hashIntegralDomain
	| Q hash x |
	Q _ self scalars fractions.
	hash _ 0.
	x _ Q embed: (coordinates at: coordinates depth).
	1 to: coordinates size do: [:i | hash _ (hash + ((Q embed: (coordinates at: i)) / x) hash) hashMultiply].
	^ hash! !

!ProjectivePoint methodsFor: 'converting' stamp: 'len 8/17/2019 08:51:02'!
dehomogenized
	"Answer the dehomogenization of the receiver."
	^ self dehomogenizedIn: self coordinates depth! !

!ProjectivePoint methodsFor: 'converting' stamp: 'len 6/1/2020 13:26:52'!
dehomogenizedIn: anInteger
	"Answer the dehomogenization of the receiver with respect to the anInteger-th coordinate."
	| scalar |
	scalar _ coordinates at: anInteger.
	^ (self codomain patch: anInteger) pointAt:
		(self scalars^(coordinates size - 1)
			filling: [:i| (i < anInteger ifTrue: [coordinates at: i] ifFalse: [coordinates at: i + 1]) / scalar])! !

!ProjectivePoint methodsFor: 'testing' stamp: 'len 12/17/2021 11:55:29'!
isProjective
	^ true! !

!ProjectivePoint methodsFor: 'testing' stamp: 'len 2/8/2017 07:19:00'!
isSmooth
	^ (self codomain singular satisfies: self coordinates) not
	
"OR:
	^ self dehomogenized isSmooth
but dehomogenizing requires it be be over a field"
! !

!ProjectivePoint class methodsFor: 'instance creation' stamp: 'len 2/13/2017 21:15:36'!
on: aProjectiveVariety coordinates: aTuple
	^ self new codomain: aProjectiveVariety; coordinates: aTuple! !

!ProjectiveLinePoint methodsFor: 'accessing' stamp: 'len 7/30/2019 05:43:44'!
denominator
	self isInfinity ifTrue: [^ self scalars zero].
	^ self value denominator! !

!ProjectiveLinePoint methodsFor: 'accessing' stamp: 'len 12/4/2016 22:21:04'!
infinity
	^ self shallowCopy coordinates: (self scalars tuple: {self scalars one. self scalars zero})! !

!ProjectiveLinePoint methodsFor: 'accessing' stamp: 'len 12/5/2016 10:33:53'!
numerator
	self isInfinity ifTrue: [^ Infinity projective].
	^ self value numerator! !

!ProjectiveLinePoint methodsFor: 'accessing' stamp: 'len 12/4/2016 22:23:56'!
one
	^ self shallowCopy coordinates: (self scalars tuple: {self scalars one. self scalars one})! !

!ProjectiveLinePoint methodsFor: 'accessing' stamp: 'len 12/4/2016 22:10:21'!
value
	^ self coordinates at: 1! !

!ProjectiveLinePoint methodsFor: 'accessing' stamp: 'len 12/4/2016 22:21:41'!
zero
	^ self shallowCopy coordinates: (self scalars tuple: {self scalars zero. self scalars one})! !

!ProjectiveLinePoint methodsFor: 'arithmetic' stamp: 'len 4/8/2018 18:28:32'!
* aCusp
	self isInfinity ifTrue: [aCusp isZero ifTrue: [DomainError signal: 'undefined'] ifFalse: [^ self]].
	aCusp isInfinity ifTrue: [self isZero ifTrue: [DomainError signal: 'undefined'] ifFalse: [^ aCusp]].
	^ self shallowCopy coordinates: (self scalars tuple: {self value * aCusp value. self scalars one})! !

!ProjectiveLinePoint methodsFor: 'arithmetic' stamp: 'len 12/4/2016 22:17:25'!
+ aCusp
	self isInfinity ifTrue: [^ self].
	aCusp isInfinity ifTrue: [^ aCusp].
	^ self shallowCopy coordinates: (self scalars tuple: {self value + aCusp value. self scalars one})! !

!ProjectiveLinePoint methodsFor: 'arithmetic' stamp: 'len 12/4/2016 22:17:46'!
- aCusp
	^ self + aCusp negated! !

!ProjectiveLinePoint methodsFor: 'arithmetic' stamp: 'len 5/3/2020 10:09:56'!
/ aCusp
	^ self * aCusp inverse! !

!ProjectiveLinePoint methodsFor: 'arithmetic' stamp: 'len 5/3/2020 10:10:08'!
^ anInteger
	"Answer the receiver raised to the power anInteger."
	anInteger = 1 ifTrue: [^ self].
	anInteger = 0 ifTrue: [^ self one].
	anInteger < 0 ifTrue: [^ self inverse ^ anInteger negated].
	^ anInteger even ifTrue: [self squared ^ (anInteger // 2)] ifFalse: [self squared ^ (anInteger // 2) * self]! !

!ProjectiveLinePoint methodsFor: 'arithmetic' stamp: 'len 8/12/2019 10:58:35'!
inverse
	self isInfinity ifTrue: [^ self zero].
	self isZero ifTrue: [^ self infinity].
	^ self shallowCopy coordinates: (self scalars tuple: {self value inverse. self scalars one})! !

!ProjectiveLinePoint methodsFor: 'arithmetic' stamp: 'len 12/4/2016 22:16:53'!
negated
	self isInfinity ifTrue: [^ self].
	^ self shallowCopy coordinates: (self scalars tuple: {self value negated. self scalars one})! !

!ProjectiveLinePoint methodsFor: 'testing' stamp: 'len 5/4/2020 10:07:37'!
|| aPoint
	"Answer true if the receiver is parallel with aPoint.
	Two points [a:b] and [c:d] of a projective line over a ring R are called 'neighbours' or 'parallel' if the matrix:
		[a b]
		[c d]
	is not in GL(2,R), i.e. its determinant ad - cb is not a unit of R.
	Points that are not neighbours are called 'distant'."

	^ (self coordinates x * aPoint coordinates y - (aPoint coordinates x * self coordinates y)) isUnit not! !

!ProjectiveLinePoint methodsFor: 'testing' stamp: 'len 12/4/2016 22:09:36'!
isInfinity
	^ (self coordinates at: 2) isZero! !

!ProjectiveLinePoint methodsFor: 'testing' stamp: 'len 12/4/2016 22:13:31'!
isZero
	^ self isInfinity not and: [self value isZero]! !

!EllipticCurvePoint methodsFor: 'accessing' stamp: 'len 11/11/2016 05:22'!
x
	^ self coordinates at: 1! !

!EllipticCurvePoint methodsFor: 'accessing' stamp: 'len 11/11/2016 05:22'!
y
	^ self coordinates at: 2! !

!EllipticCurvePoint methodsFor: 'arithmetic' stamp: 'len 11/11/2016 09:58'!
* anInteger
	anInteger isInteger ifFalse: [^ DomainError signal: 'argument must be integer'].
	anInteger = 1 ifTrue: [^ self].
	anInteger = 0 ifTrue: [^ self zero].
	anInteger < 0 ifTrue: [^ (self * anInteger negated) negated].
	^ anInteger even
		ifTrue: [self doubled * (anInteger // 2)]
		ifFalse: [self doubled * (anInteger // 2) + self]! !

!EllipticCurvePoint methodsFor: 'arithmetic' stamp: 'len 11/11/2016 09:53'!
+ aPoint
	"Answer the sum of the receiver and the argument.
	Reference: Henri Cohen, 'A Course In Computational Algebraic Number Theory', Proposition 7.1.7."
	| W x1 y1 x2 y2 m x3 y3 |
	aPoint isZero ifTrue: [^ self].
	self isZero ifTrue: [^ aPoint].
	W _ self codomain equation.
	x1 _ self x. y1 _ self y.
	x2 _ aPoint x. y2 _ aPoint y.
	(x1 = x2 and: [y1 = (y2 negated - (W a1 * x2) - W a3)]) "self = aPoint negated"
		ifTrue: [^ self zero].
	m _ (x1 = x2 and: [y1 = y2]) "self = aPoint"
		ifTrue: [x1 squared * 3 + (W a2 * x1 * 2) + W a4 - (W a1 * y1) / (y1 * 2 + (W a1 * x1) + W a3)]
		ifFalse: [y1 - y2 / (x1 - x2)].
	x3 _ x1 negated - x2 - W a2 + (m*(m + W a1)).
	y3 _ y1 negated - W a3 - (W a1 * x3) + (m*(x1 - x3)).
	^ self shallowCopy coordinates: (self scalars tuple: {x3. y3. self scalars one})! !

!EllipticCurvePoint methodsFor: 'arithmetic' stamp: 'len 11/9/2016 08:28'!
- aPoint
	^ self + aPoint negated! !

!EllipticCurvePoint methodsFor: 'arithmetic' stamp: 'len 11/11/2016 09:56'!
doubled
	"Answer the receiver times 2, i.e. self + self.
	Reference: Henri Cohen, 'A Course In Computational Algebraic Number Theory', Proposition 7.1.7."
	| W x1 y1 m x3 y3 |
	self isZero ifTrue: [^ self].
	W _ self codomain equation.
	x1 _ self x. y1 _ self y.
	m _ x1 squared * 3 + (W a2 * x1 * 2) + W a4 - (W a1 * y1) / (y1 * 2 + (W a1 * x1) + W a3).
	x3 _ x1*(-2) - W a2 + (m*(m + W a1)).
	y3 _ y1 negated - W a3 - (W a1 * x3) + (m*(x1 - x3)).
	^ self shallowCopy coordinates: (self scalars tuple: {x3. y3. self scalars one})! !

!EllipticCurvePoint methodsFor: 'arithmetic' stamp: 'len 11/11/2016 05:23'!
negated
	| W x |
	self isZero ifTrue: [^ self].
	W _ self codomain equation.
	x _ self x.
	^ self shallowCopy coordinates: (self scalars tuple: {x. self y negated + (W a1 * x) - W a3. self scalars one})! !

!EllipticCurvePoint methodsFor: 'arithmetic' stamp: 'len 11/9/2016 15:19'!
zero
	| R |
	R _ self scalars.
	^ self shallowCopy coordinates: (R tuple: {R zero. R one. R zero})! !

!EllipticCurvePoint methodsFor: 'converting' stamp: 'len 11/11/2016 08:24'!
adaptToInteger: anInteger andSend: selector
	selector = #* ifTrue: [^ self * anInteger].
	self error: 'undefined operation'! !

!EllipticCurvePoint methodsFor: 'testing' stamp: 'len 11/9/2016 13:33'!
isZero
	^ (self coordinates at: 1) isZero and: [(self coordinates at: 3) isZero]! !

!SheafMap methodsFor: 'accessing' stamp: 'len 12/21/2021 20:44:01'!
space
	^ self domain space! !

!SheafMap methodsFor: 'converting' stamp: 'len 12/13/2021 17:21:43'!
asModuleMap
	^ moduleMap! !

!SheafMap methodsFor: 'operations' stamp: 'len 12/23/2021 14:51:55'!
/\ aSheafMap
	^ self notYetImplemented! !

!SheafMap methodsFor: 'operations' stamp: 'len 12/23/2021 14:52:01'!
\/ aSheafMap
	^ self notYetImplemented! !

!SheafMap methodsFor: 'operations' stamp: 'len 12/23/2021 14:49:34'!
 aSheafMap
	^ self notYetImplemented! !

!SheafMap methodsFor: 'operations' stamp: 'len 12/23/2021 14:49:40'!
 aSheafMap
	^ self notYetImplemented! !

!SheafMap methodsFor: 'operations' stamp: 'len 12/21/2021 20:43:39'!
cokernel
	^ Sheaf module: self asModuleMap cokernel on: self space! !

!SheafMap methodsFor: 'operations' stamp: 'len 12/21/2021 20:43:46'!
kernel
	^ Sheaf module: self asModuleMap kernel on: self space! !

!SheafMap methodsFor: 'private' stamp: 'len 12/21/2021 20:38:03'!
moduleMap: aModuleMap
	moduleMap _ aModuleMap! !

!SheafMap class methodsFor: 'instance creation' stamp: 'len 12/21/2021 20:36:22'!
from: aDomain to: aCodomain moduleMap: aModuleMap
	^ self new domain: aDomain; codomain: aCodomain; moduleMap: aModuleMap! !

!MonomialOrdering methodsFor: 'accessing' stamp: 'len 7/4/2016 00:40'!
indeterminates
	^ indeterminates! !

!MonomialOrdering methodsFor: 'accessing' stamp: 'len 7/4/2016 00:40'!
rank
	^ indeterminates size! !

!MonomialOrdering methodsFor: 'accessing' stamp: 'len 7/2/2016 23:33'!
type
	^ nil! !

!MonomialOrdering methodsFor: 'comparing' stamp: 'len 8/8/2019 04:55:44'!
= anObject
	self == anObject ifTrue: [^ true].
	^ self class = anObject class and: [indeterminates = anObject indeterminates]! !

!MonomialOrdering methodsFor: 'comparing' stamp: 'len 2/3/2017 07:14:12'!
hash
	^ self type hash! !

!MonomialOrdering methodsFor: 'operations' stamp: 'len 3/6/2021 14:57:57'!
, aMonomialOrdering
	(self type notNil and: [aMonomialOrdering type notNil]) ifFalse: [^ self notYetImplemented].
	^ BlockMonomialOrdering blocks: {self. aMonomialOrdering}! !

!MonomialOrdering methodsFor: 'operations' stamp: 'len 3/6/2021 14:53:04'!
 aMonomialOrdering
	"Answer the product of the monomial ordering, shifting indeterminates to correct for the new rank."
	(self type notNil and: [self type = aMonomialOrdering type])
		ifTrue: [^ self class indeterminates: self indeterminates, (aMonomialOrdering indeterminates collect: [:i| i + self rank])].
	^ self, (aMonomialOrdering substitute: [:i| i + self rank])! !

!MonomialOrdering methodsFor: 'operations' stamp: 'len 3/6/2021 15:00:56'!
slice: anArray
	"Answer the ordering corresponding to a subset of the indeterminates."
	self type notNil ifFalse: [^ self subclassResponsibility].
	^ self class new: anArray size! !

!MonomialOrdering methodsFor: 'operations' stamp: 'len 3/6/2021 15:00:14'!
substitute: aBlock
	"Answer a new ordering like the receiver but substituting indeterminates by aBlock."
	self type notNil ifFalse: [^ self subclassResponsibility].
	^ self class indeterminates: (self indeterminates collect: aBlock)! !

!MonomialOrdering methodsFor: 'ordering' stamp: 'len 1/28/2017 09:51:49'!
blockCompare: aMonomial with: anotherMonomial
	^ self compare: aMonomial with: anotherMonomial! !

!MonomialOrdering methodsFor: 'ordering' stamp: 'len 11/21/2016 08:42:01'!
compare: aMonomial with: anotherMonomial
	^ self subclassResponsibility! !

!MonomialOrdering methodsFor: 'testing' stamp: 'len 1/26/2017 22:27:21'!
isGlobal
	"Answer true if the receiver is a noetherian or global ordering (as opposed to a local ordering).
	Global orderings satisfy 1 < m for all nontrivial monomials m."
	^ false! !

!MonomialOrdering methodsFor: 'testing' stamp: 'len 10/28/2016 10:43'!
isGraded
	"Answer true if the receiver is a graded (also called total) ordering."
	^ false! !

!MonomialOrdering methodsFor: 'testing' stamp: 'len 7/31/2021 10:55:26'!
isGradedWeighted
	^ false! !

!MonomialOrdering methodsFor: 'testing' stamp: 'len 1/22/2017 21:53:20'!
isLocal
	"Answer true if the receiver is a local (or non-noetherian) ordering.
	Local orderings satisfy 1 > m for all nontrivial monomials m."
	^ false! !

!MonomialOrdering methodsFor: 'private' stamp: 'len 12/15/2021 11:47:53'!
degreeOf: aMonomial
	| exponents |
	^ (exponents _ aMonomial exponents) isEmpty ifTrue: [0] ifFalse: [exponents sum]! !

!MonomialOrdering methodsFor: 'private' stamp: 'len 3/6/2021 14:47:17'!
indeterminates: anArray
	indeterminates _ anArray asArray! !

!MonomialOrdering class methodsFor: 'examples' stamp: 'len 2/12/2017 06:06:37'!
glex: anArray
	^ GradedLexicographicOrdering indeterminates: anArray! !

!MonomialOrdering class methodsFor: 'examples' stamp: 'len 2/12/2017 06:06:43'!
grevlex: anArray
	^ GradedReverseLexicographicOrdering indeterminates: anArray! !

!MonomialOrdering class methodsFor: 'examples' stamp: 'len 7/31/2021 10:59:31'!
grevlex: anArray weights: anotherArray
	^ GradedReverseLexicographicWeightedOrdering indeterminates: anArray weights: anotherArray! !

!MonomialOrdering class methodsFor: 'examples' stamp: 'len 7/30/2021 13:27:29'!
invlex: anArray
	^ LexicographicOrdering indeterminates: anArray reversed! !

!MonomialOrdering class methodsFor: 'examples' stamp: 'len 7/4/2016 00:45'!
lex: anArray
	^ LexicographicOrdering indeterminates: anArray! !

!MonomialOrdering class methodsFor: 'examples' stamp: 'len 2/12/2017 06:01:42'!
lglex: anArray
	^ LocalGradedLexicographicOrdering indeterminates: anArray! !

!MonomialOrdering class methodsFor: 'examples' stamp: 'len 2/12/2017 06:02:42'!
lgrevlex: anArray
	^ LocalGradedReverseLexicographicOrdering indeterminates: anArray! !

!MonomialOrdering class methodsFor: 'examples' stamp: 'len 1/19/2017 07:28:23'!
llex: anArray
	^ LocalLexicographicOrdering indeterminates: anArray! !

!MonomialOrdering class methodsFor: 'instance creation' stamp: 'len 1/28/2017 10:04:02'!
indeterminates: anArray
	anArray isInteger ifTrue: [^ self new: anArray].
	^ self new indeterminates: anArray! !

!MonomialOrdering class methodsFor: 'instance creation' stamp: 'len 1/28/2017 10:04:09'!
new: anInteger
	^ self new indeterminates: (1 to: anInteger)! !

!BlockMonomialOrdering methodsFor: 'comparing' stamp: 'len 8/8/2019 04:54:50'!
= anObject
	self == anObject ifTrue: [^ true].
	^ self class = anObject class and: [blocks = anObject blocks]! !

!BlockMonomialOrdering methodsFor: 'comparing' stamp: 'len 8/8/2019 04:55:01'!
hash
	^ blocks hash! !

!BlockMonomialOrdering methodsFor: 'operations' stamp: 'len 3/6/2021 20:59:57'!
slice: anArray
	"Answer the ordering corresponding to a subset of the indeterminates."
	| answerBlocks |
	answerBlocks _ OrderedCollection new.
	blocks do: [:each|
		| subset |
		subset _ anArray select: [:i| each indeterminates includes: i].
		subset notEmpty ifTrue: [answerBlocks add: (each slice: subset)]].
	answerBlocks size = 1 ifTrue: [^ answerBlocks first].
	^ self class blocks: answerBlocks! !

!BlockMonomialOrdering methodsFor: 'ordering' stamp: 'len 7/31/2021 10:11:35'!
compare: aMonomial with: anotherMonomial
	| answer |
	blocks do: [:each| (answer _ each blockCompare: aMonomial with: anotherMonomial) == 0 ifFalse: [^ answer]].
	^ answer! !

!BlockMonomialOrdering methodsFor: 'testing' stamp: 'len 1/28/2017 09:18:31'!
isGlobal
	^ blocks allSatisfy: [:each| each isGlobal]! !

!BlockMonomialOrdering methodsFor: 'testing' stamp: 'len 1/28/2017 09:30:58'!
isLocal
	^ blocks allSatisfy: [:each| each isLocal]! !

!BlockMonomialOrdering methodsFor: 'private' stamp: 'len 1/28/2017 09:43:49'!
blocks: anArray
	blocks _ anArray.
	indeterminates _ Array streamContents: [:aStream| blocks do: [:each| aStream nextPutAll: each indeterminates]]! !

!BlockMonomialOrdering class methodsFor: 'instance creation' stamp: 'len 1/28/2017 09:46:11'!
blocks: anArray
	^ self new blocks: anArray! !

!GradedLexicographicOrdering methodsFor: 'accessing' stamp: 'len 2/12/2017 06:05:25'!
type
	^ #glex! !

!GradedLexicographicOrdering methodsFor: 'ordering' stamp: 'len 1/28/2017 09:55:07'!
blockCompare: aMonomial with: anotherMonomial
	| d1 d2 e1 e2 n1 n2 |
	e1 _ aMonomial exponents.
	e2 _ anotherMonomial exponents.
	n1 _ e1 size.
	n2 _ e2 size.

	d1 _ 0.
	d2 _ 0.
	1 to: indeterminates size do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		xi <= n1 ifTrue: [d1 _ d1 + (e1 at: xi)].
		xi <= n2 ifTrue: [d2 _ d2 + (e2 at: xi)]].
	d1 > d2 ifTrue: [^ 1].
	d1 = d2 ifFalse: [^ -1].

	1 to: indeterminates size do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		a _ xi <= n1 ifTrue: [e1 at: xi] ifFalse: [0].
		b _ xi <= n2 ifTrue: [e2 at: xi] ifFalse: [0].
		a > b ifTrue: [^ 1].
		a = b ifFalse: [^ -1]].
	^ 0! !

!GradedLexicographicOrdering methodsFor: 'ordering' stamp: 'len 11/21/2016 13:43:16'!
compare: aMonomial with: anotherMonomial
	| d1 d2 e1 e2 n1 n2 |
	(d1 _ aMonomial degree) > (d2 _ anotherMonomial degree) ifTrue: [^ 1].
	d1 = d2 ifFalse: [^ -1].
	e1 _ aMonomial exponents.
	e2 _ anotherMonomial exponents.
	n1 _ e1 size.
	n2 _ e2 size.
	1 to: indeterminates size do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		a _ xi <= n1 ifTrue: [e1 at: xi] ifFalse: [0].
		b _ xi <= n2 ifTrue: [e2 at: xi] ifFalse: [0].
		a > b ifTrue: [^ 1].
		a = b ifFalse: [^ -1]].
	^ 0! !

!GradedLexicographicOrdering methodsFor: 'testing' stamp: 'len 1/26/2017 22:27:59'!
isGlobal
	^ true! !

!GradedLexicographicOrdering methodsFor: 'testing' stamp: 'len 7/6/2016 08:27'!
isGraded
	^ true! !

!GradedReverseLexicographicOrdering methodsFor: 'accessing' stamp: 'len 2/12/2017 06:07:37'!
type
	^ #grevlex! !

!GradedReverseLexicographicOrdering methodsFor: 'ordering' stamp: 'len 1/28/2017 09:56:14'!
blockCompare: aMonomial with: anotherMonomial
	| d1 d2 n1 n2 e1 e2 |
	e1 _ aMonomial exponents.
	e2 _ anotherMonomial exponents.
	n1 _ e1 size.
	n2 _ e2 size.
	
	d1 _ 0.
	d2 _ 0.
	1 to: indeterminates size do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		xi <= n1 ifTrue: [d1 _ d1 + (e1 at: xi)].
		xi <= n2 ifTrue: [d2 _ d2 + (e2 at: xi)]].
	d1 > d2 ifTrue: [^ 1].
	d1 = d2 ifFalse: [^ -1].

	indeterminates size to: 1 by: -1 do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		a _ xi <= n1 ifTrue: [e1 at: xi] ifFalse: [0].
		b _ xi <= n2 ifTrue: [e2 at: xi] ifFalse: [0].
		a < b ifTrue: [^ 1].
		a = b ifFalse: [^ -1]].
	^ 0! !

!GradedReverseLexicographicOrdering methodsFor: 'ordering' stamp: 'len 11/21/2016 12:20:07'!
compare: aMonomial with: anotherMonomial
	| d1 d2 n1 n2 e1 e2 |
	(d1 _ aMonomial degree) > (d2 _ anotherMonomial degree) ifTrue: [^ 1].
	d1 = d2 ifFalse: [^ -1].
	e1 _ aMonomial exponents.
	e2 _ anotherMonomial exponents.
	n1 _ e1 size.
	n2 _ e2 size.
	indeterminates size to: 1 by: -1 do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		a _ xi <= n1 ifTrue: [e1 at: xi] ifFalse: [0].
		b _ xi <= n2 ifTrue: [e2 at: xi] ifFalse: [0].
		a < b ifTrue: [^ 1].
		a = b ifFalse: [^ -1]].
	^ 0! !

!GradedReverseLexicographicOrdering methodsFor: 'testing' stamp: 'len 1/26/2017 22:28:06'!
isGlobal
	^ true! !

!GradedReverseLexicographicOrdering methodsFor: 'testing' stamp: 'len 7/6/2016 08:27'!
isGraded
	^ true! !

!GradedReverseLexicographicWeightedOrdering methodsFor: 'as yet unclassified' stamp: 'len 7/31/2021 10:44:58'!
compare: aMonomial with: anotherMonomial
	| d1 d2 n1 n2 e1 e2 |
	(d1 _ self degreeOf: aMonomial) > (d2 _ self degreeOf: anotherMonomial) ifTrue: [^ 1].
	d1 = d2 ifFalse: [^ -1].
	e1 _ aMonomial exponents.
	e2 _ anotherMonomial exponents.
	n1 _ e1 size.
	n2 _ e2 size.
	indeterminates size to: 1 by: -1 do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		a _ xi <= n1 ifTrue: [e1 at: xi] ifFalse: [0].
		b _ xi <= n2 ifTrue: [e2 at: xi] ifFalse: [0].
		a < b ifTrue: [^ 1].
		a = b ifFalse: [^ -1]].
	^ 0! !

!GradedReverseLexicographicWeightedOrdering methodsFor: 'as yet unclassified' stamp: 'len 12/15/2021 11:48:59'!
degreeOf: aMonomial
	| answer exponents |
	exponents _ aMonomial exponents.
	answer _ 0.
	indeterminates with: weights do: [:i :w| answer _ (exponents at: i) * w].
	^ answer! !

!GradedReverseLexicographicWeightedOrdering methodsFor: 'as yet unclassified' stamp: 'len 7/31/2021 10:55:36'!
isGradedWeighted
	^ true! !

!GradedReverseLexicographicWeightedOrdering methodsFor: 'as yet unclassified' stamp: 'len 7/31/2021 10:58:42'!
type
	^ #grevlexw! !

!GradedReverseLexicographicWeightedOrdering methodsFor: 'as yet unclassified' stamp: 'len 7/31/2021 10:19:43'!
weights
	^ weights! !

!GradedReverseLexicographicWeightedOrdering methodsFor: 'as yet unclassified' stamp: 'len 7/31/2021 10:20:46'!
weights: anArray
	weights _ anArray! !

!GradedReverseLexicographicWeightedOrdering class methodsFor: 'instance creation' stamp: 'len 7/31/2021 10:58:11'!
indeterminates: anArray
	^ self shouldNotImplement! !

!GradedReverseLexicographicWeightedOrdering class methodsFor: 'instance creation' stamp: 'len 7/31/2021 10:57:59'!
indeterminates: anArray weights: anotherArray
	^ self new indeterminates: anArray; weights: anotherArray! !

!LexicographicOrdering methodsFor: 'accessing' stamp: 'len 7/2/2016 23:26'!
type
	^ #lex! !

!LexicographicOrdering methodsFor: 'ordering' stamp: 'len 11/21/2016 13:40:59'!
compare: aMonomial with: anotherMonomial
	| e1 e2 n1 n2 |
	e1 _ aMonomial exponents.
	e2 _ anotherMonomial exponents.
	n1 _ e1 size.
	n2 _ e2 size.
	1 to: indeterminates size do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		a _ xi <= n1 ifTrue: [e1 at: xi] ifFalse: [0].
		b _ xi <= n2 ifTrue: [e2 at: xi] ifFalse: [0].
		a > b ifTrue: [^ 1].
		a = b ifFalse: [^ -1]].
	^ 0! !

!LexicographicOrdering methodsFor: 'testing' stamp: 'len 1/26/2017 22:27:28'!
isGlobal
	^ true! !

!LocalGradedLexicographicOrdering methodsFor: 'accessing' stamp: 'len 2/12/2017 06:02:13'!
type
	^ #lglex! !

!LocalGradedLexicographicOrdering methodsFor: 'ordering' stamp: 'len 1/28/2017 09:56:50'!
blockCompare: aMonomial with: anotherMonomial
	| d1 d2 e1 e2 n1 n2 |
	e1 _ aMonomial exponents.
	e2 _ anotherMonomial exponents.
	n1 _ e1 size.
	n2 _ e2 size.

	d1 _ 0.
	d2 _ 0.
	1 to: indeterminates size do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		xi <= n1 ifTrue: [d1 _ d1 + (e1 at: xi)].
		xi <= n2 ifTrue: [d2 _ d2 + (e2 at: xi)]].
	d1 < d2 ifTrue: [^ 1].
	d1 = d2 ifFalse: [^ -1].

	indeterminates size to: 1 by: -1 do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		a _ xi <= n1 ifTrue: [e1 at: xi] ifFalse: [0].
		b _ xi <= n2 ifTrue: [e2 at: xi] ifFalse: [0].
		a < b ifTrue: [^ 1].
		a = b ifFalse: [^ -1]].
	^ 0! !

!LocalGradedLexicographicOrdering methodsFor: 'ordering' stamp: 'len 1/26/2017 08:46:40'!
compare: aMonomial with: anotherMonomial
	| d1 d2 e1 e2 n1 n2 |
	(d1 _ aMonomial degree) < (d2 _ anotherMonomial degree) ifTrue: [^ 1].
	d1 = d2 ifFalse: [^ -1].
	e1 _ aMonomial exponents.
	e2 _ anotherMonomial exponents.
	n1 _ e1 size.
	n2 _ e2 size.
	indeterminates size to: 1 by: -1 do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		a _ xi <= n1 ifTrue: [e1 at: xi] ifFalse: [0].
		b _ xi <= n2 ifTrue: [e2 at: xi] ifFalse: [0].
		a < b ifTrue: [^ 1].
		a = b ifFalse: [^ -1]].
	^ 0! !

!LocalGradedLexicographicOrdering methodsFor: 'testing' stamp: 'len 1/19/2017 08:09:27'!
isGraded
	^ true! !

!LocalGradedLexicographicOrdering methodsFor: 'testing' stamp: 'len 1/19/2017 08:03:51'!
isLocal
	^ true! !

!LocalGradedReverseLexicographicOrdering methodsFor: 'accessing' stamp: 'len 2/12/2017 06:03:00'!
type
	^ #lgrevlex! !

!LocalGradedReverseLexicographicOrdering methodsFor: 'ordering' stamp: 'len 1/28/2017 09:57:27'!
blockCompare: aMonomial with: anotherMonomial
	| d1 d2 e1 e2 n1 n2 |
	e1 _ aMonomial exponents.
	e2 _ anotherMonomial exponents.
	n1 _ e1 size.
	n2 _ e2 size.

	d1 _ 0.
	d2 _ 0.
	1 to: indeterminates size do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		xi <= n1 ifTrue: [d1 _ d1 + (e1 at: xi)].
		xi <= n2 ifTrue: [d2 _ d2 + (e2 at: xi)]].
	d1 < d2 ifTrue: [^ 1].
	d1 = d2 ifFalse: [^ -1].

	1 to: indeterminates size do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		a _ xi <= n1 ifTrue: [e1 at: xi] ifFalse: [0].
		b _ xi <= n2 ifTrue: [e2 at: xi] ifFalse: [0].
		"a > b ifTrue: [^ 1]." "Magma handbook and Using Algebraic Geometry contradict each other"
		a < b ifTrue: [^ 1].
		a = b ifFalse: [^ -1]].
	^ 0! !

!LocalGradedReverseLexicographicOrdering methodsFor: 'ordering' stamp: 'len 1/28/2017 12:37:48'!
compare1: aMonomial with: anotherMonomial
	"This follows Magma conventions."
	| d1 d2 e1 e2 n1 n2 |
	(d1 _ aMonomial degree) < (d2 _ anotherMonomial degree) ifTrue: [^ 1].
	d1 = d2 ifFalse: [^ -1].
	e1 _ aMonomial exponents.
	e2 _ anotherMonomial exponents.
	n1 _ e1 size.
	n2 _ e2 size.
	1 to: indeterminates size do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		a _ xi <= n1 ifTrue: [e1 at: xi] ifFalse: [0].
		b _ xi <= n2 ifTrue: [e2 at: xi] ifFalse: [0].
		a < b ifTrue: [^ 1].
		a = b ifFalse: [^ -1]].
	^ 0! !

!LocalGradedReverseLexicographicOrdering methodsFor: 'ordering' stamp: 'len 1/28/2017 12:37:26'!
compare2: aMonomial with: anotherMonomial
	"This is Singular's 'ds' ordering (indeterminates are reversed)."
	| d1 d2 e1 e2 n1 n2 |
	(d1 _ aMonomial degree) < (d2 _ anotherMonomial degree) ifTrue: [^ 1].
	d1 = d2 ifFalse: [^ -1].
	e1 _ aMonomial exponents.
	e2 _ anotherMonomial exponents.
	n1 _ e1 size.
	n2 _ e2 size.
	indeterminates size to: 1 by: -1 do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		a _ xi <= n1 ifTrue: [e1 at: xi] ifFalse: [0].
		b _ xi <= n2 ifTrue: [e2 at: xi] ifFalse: [0].
		a < b ifTrue: [^ 1].
		a = b ifFalse: [^ -1]].
	^ 0! !

!LocalGradedReverseLexicographicOrdering methodsFor: 'ordering' stamp: 'len 1/28/2017 12:38:26'!
compare: aMonomial with: anotherMonomial
	"This follows Magma conventions."
	| d1 d2 e1 e2 n1 n2 |
	(d1 _ aMonomial degree) < (d2 _ anotherMonomial degree) ifTrue: [^ 1].
	d1 = d2 ifFalse: [^ -1].
	e1 _ aMonomial exponents.
	e2 _ anotherMonomial exponents.
	n1 _ e1 size.
	n2 _ e2 size.
	1 to: indeterminates size do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		a _ xi <= n1 ifTrue: [e1 at: xi] ifFalse: [0].
		b _ xi <= n2 ifTrue: [e2 at: xi] ifFalse: [0].
		a < b ifTrue: [^ 1].
		a = b ifFalse: [^ -1]].
	^ 0! !

!LocalGradedReverseLexicographicOrdering methodsFor: 'testing' stamp: 'len 11/22/2016 14:56:05'!
isGraded
	^ true! !

!LocalGradedReverseLexicographicOrdering methodsFor: 'testing' stamp: 'len 11/22/2016 14:56:02'!
isLocal
	^ true! !

!LocalLexicographicOrdering methodsFor: 'accessing' stamp: 'len 1/19/2017 07:29:54'!
type
	^ #llex! !

!LocalLexicographicOrdering methodsFor: 'ordering' stamp: 'len 1/28/2017 12:33:32'!
compare1: aMonomial with: anotherMonomial
	"This is Magma's 'llex' ordering."
	| e1 e2 n1 n2 |
	e1 _ aMonomial exponents.
	e2 _ anotherMonomial exponents.
	n1 _ e1 size.
	n2 _ e2 size.
	indeterminates size to: 1 by: -1 do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		a _ xi <= n1 ifTrue: [e1 at: xi] ifFalse: [0].
		b _ xi <= n2 ifTrue: [e2 at: xi] ifFalse: [0].
		a < b ifTrue: [^ 1].
		a = b ifFalse: [^ -1]].
	^ 0! !

!LocalLexicographicOrdering methodsFor: 'ordering' stamp: 'len 1/28/2017 12:33:15'!
compare2: aMonomial with: anotherMonomial
	"This is Singular's 'ls' ordering (indeterminates are reversed)."
	| e1 e2 n1 n2 |
	e1 _ aMonomial exponents.
	e2 _ anotherMonomial exponents.
	n1 _ e1 size.
	n2 _ e2 size.
	1 to: indeterminates size do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		a _ xi <= n1 ifTrue: [e1 at: xi] ifFalse: [0].
		b _ xi <= n2 ifTrue: [e2 at: xi] ifFalse: [0].
		a < b ifTrue: [^ 1].
		a = b ifFalse: [^ -1]].
	^ 0! !

!LocalLexicographicOrdering methodsFor: 'ordering' stamp: 'len 1/28/2017 12:31:30'!
compare: aMonomial with: anotherMonomial
	| e1 e2 n1 n2 |
	e1 _ aMonomial exponents.
	e2 _ anotherMonomial exponents.
	n1 _ e1 size.
	n2 _ e2 size.
	indeterminates size to: 1 by: -1 do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		a _ xi <= n1 ifTrue: [e1 at: xi] ifFalse: [0].
		b _ xi <= n2 ifTrue: [e2 at: xi] ifFalse: [0].
		a < b ifTrue: [^ 1].
		a = b ifFalse: [^ -1]].
	^ 0! !

!LocalLexicographicOrdering methodsFor: 'testing' stamp: 'len 10/28/2016 10:44'!
isLocal
	^ true! !

!WeightedMonomialOrdering methodsFor: 'accessing' stamp: 'len 7/2/2016 23:18'!
weights
	^ weights! !

!WeightedMonomialOrdering methodsFor: 'arithmetic' stamp: 'len 7/3/2016 02:24'!
* aMonomialOrdering
	| newWeights zero |
	newWeights _ OrderedCollection new.
	zero _ aMonomialOrdering weights first zero.
	weights do: [:each| newWeights add: each, zero].
	zero _ weights first zero.
	aMonomialOrdering weights do: [:each| newWeights add: zero, each].
	^ self class
		new: self rank + aMonomialOrdering rank
		weights: newWeights! !

!WeightedMonomialOrdering methodsFor: 'arithmetic' stamp: 'len 7/3/2016 02:50'!
, aMonomialOrdering
	"Answer the concatenation of the recever and the argument."

	self rank = aMonomialOrdering rank ifFalse: [^ self error: 'cannot concatenate monomial orderings of different rank'].
	^ self class
		new: self rank
		weights: (self weights copy addAll: aMonomialOrdering weights; yourself)! !

!WeightedMonomialOrdering methodsFor: 'arithmetic' stamp: 'len 3/6/2021 13:48:28'!
inverse
	^ self class
		indeterminates: self indeterminates
		weights: (self weights collect: [:each| each reversed])! !

!WeightedMonomialOrdering methodsFor: 'arithmetic' stamp: 'len 3/6/2021 13:47:11'!
reverse
	^ self class
		indeterminates: self indeterminates
		weights: (self weights reversed collect: [:each| each negated])! !

!WeightedMonomialOrdering methodsFor: 'ordering' stamp: 'len 3/26/2021 16:58:07'!
compare: aMonomial with: anotherMonomial
	| t1 t2 |
	t1 _ Float32Array new: indeterminates size.
	t2 _ t1 copy.
	1 to: indeterminates size do: [:i| | xi |
		t1 at: i put: (aMonomial at: (xi _ indeterminates at: i)).
		t2 at: i put: (anotherMonomial at: xi)].
	self weights do: [:w|
		| a b |
		a _ w  t1.
		b _ w  t2.
		a = b ifFalse: [^ a > b ifTrue: [1] ifFalse: [-1]]].
	^ 0! !

!WeightedMonomialOrdering methodsFor: 'ordering' stamp: 'len 3/26/2021 16:58:14'!
leadingMonomialOf: aPolynomial
	"Answer the head monomial of aPolynomial according to this ordering."
	| head headTuple |
	headTuple _ Float32Array new: indeterminates size.
	aPolynomial monomialsDo: [:each|
		| t a b |
		t _ Float32Array new: indeterminates size.
		1 to: indeterminates size do: [:i| t at: i put: (each at: (indeterminates at: i))].
		head isNil
			ifTrue: [head _ each. headTuple _ t]
			ifFalse: [(self weights anySatisfy: [:w|
				a _ w  t.
				b _ w  headTuple. "could be precomputed up to some extent"
				a ~= b]) ifTrue: [a > b ifTrue: [head _ each. headTuple _ t]]]].
	^ head! !

!WeightedMonomialOrdering methodsFor: 'private' stamp: 'len 3/26/2021 16:58:22'!
weights: aCollectionOfTuples
	weights _ aCollectionOfTuples collect: [:each| each as: Float32Array]! !

!WeightedMonomialOrdering class methodsFor: 'instance creation' stamp: 'len 3/6/2021 13:46:16'!
glex: anArray
	| weights |
	weights _ OrderedCollection new.
	weights add: (Array new: anArray size withAll: 1).
	weights addAll: (self lex: anArray) weights.
	^ self indeterminates: anArray weights: weights asArray! !

!WeightedMonomialOrdering class methodsFor: 'instance creation' stamp: 'len 3/6/2021 13:46:43'!
grevlex: anArray
	| weights |
	weights _ OrderedCollection new.
	weights add: (Array new: anArray size withAll: 1).
	weights addAll: (self lex: anArray) reverse weights.
	^ self indeterminates: anArray weights: weights asArray! !

!WeightedMonomialOrdering class methodsFor: 'instance creation' stamp: 'len 7/3/2016 02:27'!
indeterminates: indeterminates weights: weights
	weights isSequenceable ifFalse: [self error: 'the indeterminates are unordered'].
	^ self new: indeterminates size weights: (weights collect: [:each| each withIndexCollect: [:x :i| each at: (indeterminates indexOf: i)]])! !

!WeightedMonomialOrdering class methodsFor: 'instance creation' stamp: 'len 3/6/2021 13:46:24'!
lex: anArray
	| weighs |
	weighs _ (1 to: anArray size) collect: [:i| (1 to: anArray size) collect: [:j| i=j ifTrue: [1] ifFalse: [0]]].
	^ self indeterminates: anArray weights: weighs! !

!WeightedMonomialOrdering class methodsFor: 'instance creation' stamp: 'len 7/3/2016 02:44'!
new: anInteger weights: anArray
	^ (self new: anInteger) weights: anArray! !

!WeightedMonomialOrdering class methodsFor: 'instance creation' stamp: 'len 3/6/2021 13:46:28'!
revlex: anArray
	^ (self lex: anArray) reverse! !

!GroupElement methodsFor: 'accessing' stamp: 'len 5/10/2019 10:11:51'!
identity
	^ self parent identity! !

!GroupElement methodsFor: 'accessing' stamp: 'len 5/15/2019 03:56:05'!
order
	^ self parent orderOf: self! !

!GroupElement methodsFor: 'operations' stamp: 'len 12/6/2021 08:02:15'!
* anElement
	^ self  anElement! !

!GroupElement methodsFor: 'operations' stamp: 'len 12/4/2021 13:22:41'!
/ anElement
	^ self  anElement inverse! !

!GroupElement methodsFor: 'operations' stamp: 'len 12/4/2021 13:24:02'!
\ anElement
	^ self inverse  anElement! !

!GroupElement methodsFor: 'operations' stamp: 'len 8/11/2020 08:47:00'!
^ anInteger
	"Answer the receiver composed with itself anInteger times.
	If the argument is another group element, answer the conjugation."
	anInteger isInteger ifFalse: [^ anInteger inverse  self  anInteger].
	anInteger = 1 ifTrue: [^ self].
	anInteger = 0 ifTrue: [^ self identity].
	anInteger < 0 ifTrue: [^ self inverse ^ anInteger negated].
	^ anInteger even ifTrue: [self  self ^ (anInteger // 2)] ifFalse: [self  self ^ (anInteger // 2)  self]! !

!GroupElement methodsFor: 'operations' stamp: 'len 5/6/2019 02:50:01'!
 anElement
	^ self subclassResponsibility! !

!GroupElement methodsFor: 'operations' stamp: 'len 5/10/2019 10:57:13'!
commutator: anElement
	^ self inverse  anElement inverse  self  anElement! !

!GroupElement methodsFor: 'operations' stamp: 'len 5/6/2019 02:49:53'!
inverse
	^ self subclassResponsibility! !

!GroupElement methodsFor: 'operations' stamp: 'len 12/6/2021 08:01:06'!
reciprocal
	^ self inverse! !

!GroupElement methodsFor: 'operations' stamp: 'len 12/6/2021 08:00:15'!
squared
	^ self  self! !

!GroupElement methodsFor: 'testing' stamp: 'len 5/25/2019 06:18:44'!
isIdentity
	^ self = self identity! !

!Monomial methodsFor: 'copying' stamp: 'len 5/14/2019 03:30:59'!
copyWith: anIndeterminate to: anInteger
	^ parent exponents: (exponents copy at: anIndeterminate put: anInteger; yourself)! !

!Monomial methodsFor: 'copying' stamp: 'len 5/14/2019 03:31:04'!
copyWithout: anIndeterminate
	"Answer a copy of the receiver with the given indeterminate removed."
	^ parent exponents: (exponents copy at: anIndeterminate put: 0; yourself)! !

!Monomial methodsFor: 'printing' stamp: 'len 1/15/2022 17:31:56'!
printExponent: anInteger on: aStream
	| exponent |
	(exponent _ anInteger printString) = '1' ifTrue: [^ self].
	aStream isText ifTrue: [aStream nextPutAll: exponent super. ^ self].
	aStream nextPut: $^.
	exponent size = 1
		ifTrue: [aStream nextPutAll: exponent]
		ifFalse: [aStream nextPut: ${; nextPutAll: exponent; nextPut: $}]! !

!Monomial methodsFor: 'printing' stamp: 'len 1/15/2022 17:49:14'!
printIndeterminate: anInteger on: aStream
	(self parent names ifNotNil: [:names| names at: anInteger ifAbsent: []])
		ifNotNil: [:name| aStream nextPutAll: name displayStringOrText. ^ self].
	aStream isText
		ifTrue: [aStream nextPut: $x; nextPutAll: anInteger printString sub]
		ifFalse:[aStream nextPutAll: '{x', anInteger printString, '}']! !

!Monomial methodsFor: 'accessing' stamp: 'len 11/21/2016 15:56:16'!
at: anIndeterminate
	^ exponents at: anIndeterminate! !

!Monomial methodsFor: 'accessing' stamp: 'len 3/16/2016 20:03'!
bitSize
	^ exponents inject: 0 into: [:x :each| x + each bitSize]! !

!Monomial methodsFor: 'accessing' stamp: 'len 3/16/2016 20:05'!
exponents
	^ exponents! !

!Monomial methodsFor: 'accessing' stamp: 'len 1/2/2022 10:04:35'!
indeterminates
	"Answer the list of indeterminates effectively present in this monomial (with nonzero exponent). This is called the 'support' of a monomial."
	^ (1 to: exponents size) select: [:i| (exponents at: i) ~= 0]! !

!Monomial methodsFor: 'accessing' stamp: 'len 6/6/2016 07:00'!
lastIndeterminate
	"Answer the leading indeterminate of the receiver (the last indeterminate effectively present)."
	^ exponents findLast: [:one| one ~= 0]! !

!Monomial methodsFor: 'accessing' stamp: 'len 11/20/2016 11:56:47'!
ordering
	^ parent ordering! !

!Monomial methodsFor: 'accessing' stamp: 'len 1/23/2017 11:35:28'!
parent
	^ parent! !

!Monomial methodsFor: 'accessing' stamp: 'len 1/2/2022 10:04:42'!
support
	"Answer the list of indeterminates effectively present in this monomial (with nonzero exponent)."
	^ self indeterminates! !

!Monomial methodsFor: 'comparing' stamp: 'len 11/20/2016 16:44:54'!
< aMonomial
	^ (self >= aMonomial) not! !

!Monomial methodsFor: 'comparing' stamp: 'len 11/20/2016 16:44:09'!
<= aMonomial
	self == aMonomial ifTrue: [^ true].
	^ (self > aMonomial) not! !

!Monomial methodsFor: 'comparing' stamp: 'len 11/21/2016 19:44:36'!
= aMonomial
	| b |
	self == aMonomial ifTrue: [^ true].
	aMonomial isInteger ifTrue: [^ self degree = aMonomial].
"	^ exponents = aMonomial exponents"
	b _ aMonomial exponents.
	exponents size = b size ifFalse: [^ false].
	1 to: exponents size do: [:i| (exponents at: i) = (b at: i) ifFalse: [^ false]].
	^ true! !

!Monomial methodsFor: 'comparing' stamp: 'len 11/21/2016 08:36:58'!
> aMonomial
	^ (self compare: aMonomial) > 0! !

!Monomial methodsFor: 'comparing' stamp: 'len 11/21/2016 11:19:23'!
>= aMonomial
	self == aMonomial ifTrue: [^ true].
	^ (self compare: aMonomial) >= 0! !

!Monomial methodsFor: 'comparing' stamp: 'len 1/5/2018 11:12:42'!
compare: aMonomial
	"Answer -1 if the receiver is < than the argument, 0 if they are equal, 1 if it is > than the argument."
	^ self ordering compare: self with: aMonomial! !

!Monomial methodsFor: 'comparing' stamp: 'len 11/30/2016 21:59:33'!
hash
	| answer |
	answer _ self lastIndeterminate.
	1 to: exponents size do: [:i|
		| e |
		(e _ exponents at: i) = 0
			ifFalse: [answer _ answer hashMultiply + e hash]].
	^ answer! !

!Monomial methodsFor: 'converting' stamp: 'len 5/23/2018 22:18:46'!
orderedBy: aMonomialOrdering
	^ (self parent orderedBy: aMonomialOrdering) !! self! !

!Monomial methodsFor: 'enumerating' stamp: 'len 5/14/2019 04:00:53'!
do: aBinaryBlock
	exponents withIndexDo: [:each :i| aBinaryBlock value: i value: each]! !

!Monomial methodsFor: 'operations' stamp: 'len 5/14/2019 03:30:33'!
/ aMonomial
	"Answer the exact division of the receiver by the argument."
	| b bn c |
	b _ aMonomial exponents.
	bn _ aMonomial exponents size.
	exponents size = bn ifFalse: [^ self error: 'not same size'].
	c _ Array new: bn.
	1 to: bn do: [:i| c at: i put: (exponents at: i) - (b at: i)].
	^ parent exponents: c! !

!Monomial methodsFor: 'operations' stamp: 'len 5/14/2019 03:30:39'!
^ anInteger
	^ parent exponents: exponents * anInteger! !

!Monomial methodsFor: 'operations' stamp: 'len 5/14/2019 03:30:44'!
 aMonomial
	| b bn c |
	b _ aMonomial exponents.
	bn _ aMonomial exponents size.
	exponents size = bn ifFalse: [^ self error: 'not same size'].
	c _ Array new: bn.
	1 to: bn do: [:i| c at: i put: (exponents at: i) + (b at: i)].
	^ parent exponents: c! !

!Monomial methodsFor: 'operations' stamp: 'len 5/14/2019 03:30:53'!
complete: anInteger in: anIndeterminate
	"Answer a copy of the receiver of degree anInteger completing with a power of the indeterminate anotherInteger."
	| n |
	(n _ self degree) = anInteger ifTrue: [^ self].
	^ parent exponents: (exponents copy at: anIndeterminate put: anInteger - n + (self at: anIndeterminate); yourself)! !

!Monomial methodsFor: 'operations' stamp: 'len 5/12/2018 20:02:01'!
degree
	"Answer the total degree of the receiver."
	^ degree ifNil: [degree _ exponents isEmpty ifTrue: [0] ifFalse: [exponents sum]]! !

!Monomial methodsFor: 'operations' stamp: 'len 3/17/2016 00:25'!
degreeIn: anIndeterminate
	"Answer the degree of the receiver in the given indeterminate, i.e. the power to which the indeterminate appears in the receiver."

	^ self at: anIndeterminate! !

!Monomial methodsFor: 'operations' stamp: 'len 5/14/2019 03:31:08'!
dehomogenizedIn: anIndeterminate
	| newExponents |
	newExponents _ Array new: exponents size.
	newExponents replaceFrom: 1 to: anIndeterminate - 1 with: exponents startingAt: 1.
	newExponents replaceFrom: anIndeterminate to: exponents size - 1 with: exponents startingAt: anIndeterminate + 1.
	newExponents at: exponents size put: 0.
	^ parent exponents: newExponents! !

!Monomial methodsFor: 'operations' stamp: 'len 5/15/2019 03:14:30'!
eq: aMonomial
	"Answer the relator for the relation that equates the receiver to the argument."
	^ self  aMonomial inverse! !

!Monomial methodsFor: 'operations' stamp: 'len 5/14/2019 03:31:12'!
gcd: aMonomial
	"Answer the greatest common divisor of the receiver and the argument."
	exponents size <= aMonomial exponents size ifFalse: [^ aMonomial gcd: self].
	^ parent exponents: (exponents withIndexCollect: [:each :i| each min: (aMonomial at: i)])! !

!Monomial methodsFor: 'operations' stamp: 'len 5/14/2019 03:31:26'!
lcm: aMonomial
	"Answer the least common multiple of the receiver and the argument."
	exponents size >= aMonomial exponents size ifFalse: [^ aMonomial lcm: self].
	^ parent exponents: (exponents withIndexCollect: [:each :i| each max: (aMonomial at: i)])! !

!Monomial methodsFor: 'operations' stamp: 'len 5/15/2019 04:32:30'!
log: b
	"Answer the discrete logarithm of the receiver in base b. This is, answer an integer k such that b^k equals the receiver."
	self notYetImplemented! !

!Monomial methodsFor: 'operations' stamp: 'len 1/23/2017 11:36:23'!
permutedBy: aPermutation
	"Permute the variables of the receiver. The argument can be an Array (permutation in 'image format'). For example given a monomial in x,z,y, #(1 2 3) doesn't change anything, #(2 1 3) exchanges variables x and y."
	| answer |
	answer _ self parent identity.
	exponents withIndexDo: [:exp :i|
		exp = 0 ifFalse: [answer _ answer * (self parent x: (aPermutation at: i) to: exp)]].
	^ answer! !

!Monomial methodsFor: 'operations' stamp: 'len 5/14/2019 03:31:39'!
root: anInteger
	^ parent exponents: exponents / anInteger! !

!Monomial methodsFor: 'operations' stamp: 'len 5/14/2019 03:31:46'!
root: anInteger in: anIndeterminate
	^ parent exponents: (exponents copy at: anIndeterminate put: (self at: anIndeterminate) / anInteger; yourself)! !

!Monomial methodsFor: 'operations' stamp: 'len 2/9/2017 03:20:49'!
substitute: aBlock
	"Answer the receiver after substituting indeterminates by aBlock."
	| answer |
	answer _ self parent identity.
	exponents withIndexDo: [:exp :i|
		exp = 0 ifFalse: [answer _ answer * (self parent x: (aBlock value: i) to: exp)]].
	^ answer! !

!Monomial methodsFor: 'operations' stamp: 'len 1/21/2017 20:16:54'!
value: anObject
	| answer next |
	1 to: exponents size do: [:i|
		next _ (anObject at: i) ^ (exponents at: i).
		answer _ answer ifNil: [next] ifNotNil: [next * answer]].
	^ answer! !

!Monomial methodsFor: 'operations' stamp: 'len 6/6/2016 04:45'!
without: anIndeterminate
	^ (self has: anIndeterminate) ifFalse: [self] ifTrue: [self copyWithout: anIndeterminate]! !

!Monomial methodsFor: 'testing' stamp: 'len 5/11/2018 06:54:29'!
| aMonomial
	"Answer true if the receiver divides the argument."
"	self degree > aMonomial degree ifTrue: [^ false]. <- this doesn't seem to help"
	1 to: exponents size do: [:i|
		(exponents at: i) > (aMonomial at: i) ifTrue: [^ false]].
	^ true! !

!Monomial methodsFor: 'testing' stamp: 'len 12/5/2015 22:34'!
has: anIndeterminate
	^ (self at: anIndeterminate) ~= 0! !

!Monomial methodsFor: 'testing' stamp: 'len 6/6/2016 02:50'!
isIdentity
	^ exponents allSatisfy: [:each| each = 0]! !

!Monomial methodsFor: 'testing' stamp: 'len 2/14/2017 10:38:05'!
isPurePower
	"Answer true if the receiver is a power of a single indeterminate."
	| count |
	count _ 0.
	exponents do: [:each| each == 0 ifFalse: [count _ count + 1]. count > 1 ifTrue: [^ false]].
	^ count = 1! !

!Monomial methodsFor: 'testing' stamp: 'len 1/9/2022 08:30:18'!
isSquarefree
	^ exponents allSatisfy: [:each| each == 0 or: [each == 1]]! !

!Monomial methodsFor: 'testing' stamp: 'len 6/6/2016 05:03'!
isUnivariateIn: anIndeterminate
	^ exponents isEmpty or: [(self at: anIndeterminate) = self degree]! !

!Monomial methodsFor: 'private' stamp: 'len 3/16/2016 20:04'!
exponents: anArray
	exponents _ anArray! !

!Monomial methodsFor: 'private' stamp: 'len 2/26/2017 10:37:42'!
parent: aFreeAbelianMonoid
	parent _ aFreeAbelianMonoid! !

!Monomial class methodsFor: 'instance creation' stamp: 'len 11/20/2016 12:01:21'!
exponents: anArray
	^ self basicNew exponents: anArray! !

!Monomial class methodsFor: 'instance creation' stamp: 'len 11/24/2016 10:58:05'!
new
	^ self shouldNotImplement! !

!Monomial class methodsFor: 'instance creation' stamp: 'len 11/20/2016 11:25:52'!
new: anInteger
	^ self exponents: ((Array new: anInteger) atAllPut: 0; yourself)! !

!Monomial class methodsFor: 'instance creation' stamp: 'len 11/24/2016 10:54:53'!
new: anInteger x: i
	"Answer a new instance of the receiver with only one indeterminate: the argument i."
	^ self new: anInteger x: i to: 1! !

!Monomial class methodsFor: 'instance creation' stamp: 'len 11/24/2016 10:54:37'!
new: anInteger x: i to: k
	"Answer a new instance of the receiver with only one indeterminate, xi, raised to n."
	^ self exponents: ((Array new: anInteger) atAllPut: 0; at: i put: k; yourself)! !

!Word methodsFor: 'printing' stamp: 'len 7/2/2016 16:29'!
printExponent: anInteger on: aStream
	| exponent |
	(exponent _ anInteger printString) = '1'
		ifTrue: [^ self].
	aStream isText
		ifTrue:
			[aStream nextPutAll: exponent super.
			^ self].
	aStream nextPut: $^.
	exponent size = 1
		ifTrue: [aStream nextPutAll: exponent]
		ifFalse: [aStream nextPut: ${; nextPutAll: exponent; nextPut: $}]! !

!Word methodsFor: 'printing' stamp: 'len 5/13/2019 13:39:13'!
printLetter: letter on: aStream
	letter isInteger
		ifFalse:
			[letter class = self class
				ifTrue: [aStream nextPut: $(; print: letter; nextPut: $)]
				ifFalse: [(aStream isText and: [letter isString])
					ifTrue: [aStream nextPutAll: letter asText]
					ifFalse: [aStream print: letter]].
			^ self].
	aStream isText
		ifTrue: [aStream nextPut: $x; nextPutAll: letter printString sub]
		ifFalse: [aStream nextPutAll: '{x', letter printString, '}']! !

!Word methodsFor: 'accessing' stamp: 'len 1/10/2018 11:28:25'!
length
	syllables isEmpty ifTrue: [^ 0].
	^ syllables sum: [:each| each value abs]! !

!Word methodsFor: 'accessing' stamp: 'len 5/10/2019 14:41:44'!
parent
	^ parent! !

!Word methodsFor: 'accessing' stamp: 'len 3/3/2016 05:24'!
syllables
	^ syllables! !

!Word methodsFor: 'comparing' stamp: 'len 1/9/2018 21:32:27'!
< aWord
	^ (self >= aWord) not! !

!Word methodsFor: 'comparing' stamp: 'len 1/9/2018 21:32:46'!
<= aWord
	self == aWord ifTrue: [^ true].
	^ (self > aWord) not! !

!Word methodsFor: 'comparing' stamp: 'len 3/3/2016 05:23'!
= aWord
	^ syllables = aWord syllables! !

!Word methodsFor: 'comparing' stamp: 'len 1/9/2018 21:33:57'!
> aWord
	^ (self compare: aWord) > 0! !

!Word methodsFor: 'comparing' stamp: 'len 1/9/2018 21:34:13'!
>= aWord
	self == aWord ifTrue: [^ true].
	^ (self compare: aWord) >= 0! !

!Word methodsFor: 'comparing' stamp: 'len 1/10/2018 11:40:04'!
compare: aWord
	"Answer -1 if the receiver is < than the argument, 0 if they are equal, 1 if it is > than the argument.
	This is the noncommutative graded-lexicographical ordering."
	| result stream1 stream2 a1 a2 r1 r2 r x1 x2 |
	(result _ (self length - aWord length) sign) = 0 ifFalse: [^ result].
	self isEmpty ifTrue: [^ 0].
	stream1 _ syllables readStream.
	stream2 _ aWord syllables readStream.
	r1 _ 0.
	r2 _ 0.
	[r1 > 0 ifFalse: [a1 _ stream1 next. x1 _ a1 key. r1 _ a1 value].
	r2 > 0 ifFalse: [a2 _ stream2 next. x2 _ a2 key. r2 _ a2 value].
	r _ r1 min: r2.
	x1 < x2 ifTrue: [^ -1].
	x1 = x2 ifFalse: [^ 1].
	r1 _ r1 - r.
	r2 _ r2 - r.
	stream1 atEnd and: [stream2 atEnd]] whileFalse.
	^ 0! !

!Word methodsFor: 'comparing' stamp: 'len 3/3/2016 05:23'!
hash
	^ syllables hash! !

!Word methodsFor: 'copying' stamp: 'len 5/10/2019 17:16:33'!
copyWithout: anInteger
	^ self class syllables: (self syllables select: [:each| each key ~= anInteger])! !

!Word methodsFor: 'enumerating' stamp: 'len 5/10/2019 18:29:24'!
do: aBinaryBlock
	syllables do: [:each| aBinaryBlock value: each key value: each value]! !

!Word methodsFor: 'operations' stamp: 'len 5/10/2019 16:13:17'!
 aWord
	| x y |
	self isEmpty ifTrue: [^ aWord].
	aWord isEmpty ifTrue: [^ self].
	parent = aWord parent ifFalse: [DomainError signal: 'words with different parents'].
	syllables last key = aWord syllables first key
		ifFalse: [^ (self class syllables: syllables, aWord syllables) parent: parent].
	x _ syllables as: OrderedCollection.
	y _ aWord syllables as: OrderedCollection.
	[x notEmpty and: [y notEmpty and: [x last key = y first key]]]
		whileTrue:
			[| xn y1 exponent |
			xn _ x removeLast.
			y1 _ y removeFirst.
			(exponent _ xn value + y1 value) = 0
				ifFalse: [^ (self class syllables: (x, {Association key: xn key value: exponent}, y) asArray) parent: parent]].
	^ (self class syllables: (x, y) asArray) parent: parent! !

!Word methodsFor: 'operations' stamp: 'len 5/15/2019 03:14:42'!
eq: aWord
	"Answer the relator for the relation that equates the receiver to the argument."
	^ self  aWord inverse! !

!Word methodsFor: 'operations' stamp: 'len 5/10/2019 16:13:38'!
inverse
	^ (self class syllables: (syllables collect: [:each| Association key: each key value: each value negated]) reversed) parent: parent! !

!Word methodsFor: 'operations' stamp: 'len 5/10/2019 16:13:47'!
reversed
	^ (self class syllables: syllables reversed) parent: parent! !

!Word methodsFor: 'testing' stamp: 'len 3/3/2016 05:23'!
isEmpty
	^ syllables isEmpty! !

!Word methodsFor: 'testing' stamp: 'len 1/10/2018 16:54:56'!
isStandard
	"Answer true if the receiver is a standard word, i.e. if the symbols appear in ascending order."
	syllables size < 2 ifTrue: [^ true].
	1 to: syllables size - 1 do: [:i|
		(syllables at: i) key < (syllables at: i+1) key
			ifFalse: [^ false]].
	^ true! !

!Word methodsFor: 'private' stamp: 'len 5/10/2019 14:41:37'!
parent: aDomain
	parent _ aDomain! !

!Word methodsFor: 'private' stamp: 'len 3/3/2016 05:21'!
syllables: anArray
	syllables _ anArray! !

!Word class methodsFor: 'instance creation' stamp: 'len 6/30/2016 02:31'!
empty
	^ self syllables: #()! !

!Word class methodsFor: 'instance creation' stamp: 'len 6/30/2016 02:31'!
new
	^ self shouldNotImplement! !

!Word class methodsFor: 'instance creation' stamp: 'len 6/30/2016 02:30'!
syllables: anArray
	^ self basicNew syllables: anArray! !

!Word class methodsFor: 'instance creation' stamp: 'len 2/12/2016 07:30'!
x: i
	^ self x: i to: 1! !

!Word class methodsFor: 'instance creation' stamp: 'len 3/3/2016 05:24'!
x: i to: k
	"Answer a new instance of the receiver with only one indeterminate, xi, raised to n."
	k = 0 ifTrue: [^ self empty].
	^ self syllables: {i -> k}! !

!Coset methodsFor: 'accessing' stamp: 'len 11/25/2015 02:29'!
representative
	^ representative! !

!Coset methodsFor: 'comparing' stamp: 'len 5/9/2019 11:21:41'!
= aCoset
	^ relations includes: representative  aCoset representative inverse! !

!Coset methodsFor: 'comparing' stamp: 'len 5/9/2019 11:21:32'!
hash
	^ relations hash! !

!Coset methodsFor: 'enumerating' stamp: 'len 5/9/2019 11:20:31'!
do: aBlock
	"Enumerate the elements of the receiver."
	relations do: [:each| aBlock value: each  representative]! !

!Coset methodsFor: 'operations' stamp: 'len 5/9/2019 11:21:25'!
 aCoset
	^ self class representative: representative  aCoset representative relations: relations! !

!Coset methodsFor: 'operations' stamp: 'len 5/9/2019 11:20:46'!
inverse
	^ self class representative: representative inverse relations: relations! !

!Coset methodsFor: 'testing' stamp: 'len 5/9/2019 11:22:04'!
contains: anElement
	^ relations contains: anElement  representative inverse! !

!Coset methodsFor: 'testing' stamp: 'len 5/9/2019 11:21:53'!
includes: anElement
	^ (relations ambient includes: anElement) and: [self contains: anElement]! !

!Coset methodsFor: 'private' stamp: 'len 5/9/2019 11:22:18'!
relations: aSubgroup
	relations _ aSubgroup! !

!Coset methodsFor: 'private' stamp: 'len 11/25/2015 02:29'!
representative: anObject
	representative _ anObject! !

!Coset class methodsFor: 'instance creation' stamp: 'len 5/9/2019 11:22:46'!
representative: anObject relations: aSubgroup
	^ self new representative: anObject; relations: aSubgroup! !

!DirectProductGroupElement methodsFor: 'accessing' stamp: 'len 4/25/2020 06:38:06'!
at: anInteger
	^ components at: anInteger! !

!DirectProductGroupElement methodsFor: 'accessing' stamp: 'len 4/25/2020 06:38:11'!
parent
	^ parent! !

!DirectProductGroupElement methodsFor: 'accessing' stamp: 'len 4/25/2020 06:38:16'!
size
	^ components size! !

!DirectProductGroupElement methodsFor: 'comparing' stamp: 'len 4/25/2020 06:38:33'!
= anObject
	^ self class = anObject class and: [components = anObject components]! !

!DirectProductGroupElement methodsFor: 'comparing' stamp: 'len 4/25/2020 06:38:37'!
hash
	^ components hash! !

!DirectProductGroupElement methodsFor: 'operations' stamp: 'len 4/25/2020 07:48:01'!
 anElement
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #].
	^ self class new parent: parent; components: components  anElement components! !

!DirectProductGroupElement methodsFor: 'operations' stamp: 'len 4/25/2020 06:39:38'!
inverse
	^ self class new parent: parent; components: (components collect: [:each| each inverse])! !

!DirectProductGroupElement methodsFor: 'private' stamp: 'len 4/25/2020 06:39:26'!
components
	^ components! !

!DirectProductGroupElement methodsFor: 'private' stamp: 'len 4/25/2020 06:38:54'!
components: anArray
	components _ anArray! !

!DirectProductGroupElement methodsFor: 'private' stamp: 'len 4/25/2020 06:39:20'!
parent: aDirectProductGroup
	parent _ aDirectProductGroup! !

!OppositeGroupElement methodsFor: 'accessing' stamp: 'len 5/9/2019 08:04:46'!
opposite
	^ opposite! !

!OppositeGroupElement methodsFor: 'accessing' stamp: 'len 5/9/2019 08:05:19'!
parent
	^ opposite parent opposite! !

!OppositeGroupElement methodsFor: 'comparing' stamp: 'len 5/9/2019 08:06:35'!
= anElement
	^ self class = anElement class and: [opposite = anElement opposite]! !

!OppositeGroupElement methodsFor: 'comparing' stamp: 'len 5/9/2019 08:06:41'!
hash
	^ opposite hash! !

!OppositeGroupElement methodsFor: 'operations' stamp: 'len 5/9/2019 08:05:01'!
 anElement
	^ self class opposite: anElement opposite  opposite! !

!OppositeGroupElement methodsFor: 'operations' stamp: 'len 5/9/2019 08:05:10'!
inverse
	^ self class opposite: opposite inverse! !

!OppositeGroupElement class methodsFor: 'instance creation' stamp: 'len 5/9/2019 08:05:39'!
opposite: anElement
	^ self new opposite: anElement! !

!Permutation methodsFor: 'accessing' stamp: 'len 5/25/2019 05:27:21'!
aChange
	"Answer a point changed by the receiver (or nil if there is none)."
	self supportDo: [:each| ^ each].
	^ nil! !

!Permutation methodsFor: 'accessing' stamp: 'len 5/25/2019 06:22:47'!
at: anInteger
	^ images at: anInteger ifAbsent: [anInteger]! !

!Permutation methodsFor: 'accessing' stamp: 'len 5/25/2019 06:19:36'!
at: anInteger put: anotherInteger
	^ images at: anInteger put: anotherInteger! !

!Permutation methodsFor: 'accessing' stamp: 'len 2/8/2018 08:49:09'!
codomain
	^ self domain! !

!Permutation methodsFor: 'accessing' stamp: 'len 5/25/2019 06:19:41'!
degree
	^ images size! !

!Permutation methodsFor: 'accessing' stamp: 'len 4/30/2019 12:30:51'!
domain
	^ parent space! !

!Permutation methodsFor: 'accessing' stamp: 'len 5/25/2019 05:29:24'!
fixedPoints
	"Answer the points fixed by the receiver."
	^ Iterator on: self performing: #fixedPointsDo:! !

!Permutation methodsFor: 'accessing' stamp: 'len 4/30/2019 12:31:23'!
identity
	"Answer the identity permutation."
	^ parent identity! !

!Permutation methodsFor: 'accessing' stamp: 'len 2/8/2018 08:52:14'!
one
	^ self identity! !

!Permutation methodsFor: 'accessing' stamp: 'len 2/8/2018 09:09:16'!
order
	self isIdentity ifTrue: [^ 1].
	^ self cycles inject: 1 into: [:last :each| last lcm: each size]! !

!Permutation methodsFor: 'accessing' stamp: 'len 2/8/2018 08:51:36'!
order2
	| answer next |
	answer _ 1.
	next _ self.
	[next isIdentity] whileFalse: [next _ next * self. answer _ answer + 1].
	^ answer! !

!Permutation methodsFor: 'accessing' stamp: 'len 4/30/2019 12:32:10'!
parent
	^ parent! !

!Permutation methodsFor: 'accessing' stamp: 'len 2/8/2018 09:28:02'!
sign
	| answer |
	answer _ 1.
	self cyclesDo: [:each| each size even ifTrue: [answer _ answer * -1]].
	^ answer

	"^ self transpositions size even ifTrue: [1] ifFalse: [-1]"! !

!Permutation methodsFor: 'accessing' stamp: 'len 5/25/2019 05:26:06'!
support
	"Answer the points changed by the receiver."
	^ Iterator on: self performing: #supportDo:! !

!Permutation methodsFor: 'accessing' stamp: 'len 5/25/2019 05:25:42'!
transpositions
	"Answer the decomposition of the receiver in product of transpositions."
	| answer last value X |
	answer _ OrderedCollection new.
	X _ parent indexToSpace.
	self supportDo: [:each|
		last _ each.
		answer reverseDo: [:one| last _ one at: last].
		(value _ self at: each) = last
			ifFalse: [answer addFirst: (parent transposing: (X at: last) with: (X at: value))]].
	^ answer! !

!Permutation methodsFor: 'accessing' stamp: 'len 5/1/2019 02:37:25'!
type
	"Answer the type of the receiver."
	^ (self cycles asSortedCollection: [:a :b| a size <= b size]) collect: [:each| each size]! !

!Permutation methodsFor: 'actions' stamp: 'len 2/8/2018 08:51:52'!
permute: anArray
	"Answer the permutation of the elements of anArray induced by the receiver."
	| answer |
	answer _ Array new: anArray size.
	1 to: anArray size do: [:i| answer at: i put: (anArray at: (self at: i))].
	^ answer! !

!Permutation methodsFor: 'actions' stamp: 'len 5/1/2019 02:43:35'!
value: anObject
	^ self at: (parent spaceToIndex at: anObject ifAbsent: [^ anObject])! !

!Permutation methodsFor: 'comparing' stamp: 'len 5/25/2019 06:21:34'!
= aPermutation
	^ self class = aPermutation class and: [images = aPermutation images]! !

!Permutation methodsFor: 'comparing' stamp: 'len 5/25/2019 06:22:25'!
hash
	| answer |
	answer _ 0.
	1 to: images size do: [:i| | value |
		(value _ images at: i) = i ifFalse: [answer _ answer bitXor: i hash hashMultiply + value hash]].
	^ answer! !

!Permutation methodsFor: 'converting' stamp: 'len 5/25/2019 06:22:16'!
asArray
	^ images! !

!Permutation methodsFor: 'cycles' stamp: 'len 2/8/2018 08:49:33'!
cycles
	"Answer the cycles of the receiver."
	^ Iterator on: self performing: #cyclesDo:! !

!Permutation methodsFor: 'cycles' stamp: 'len 5/25/2019 05:26:23'!
cyclesDo: aBlock
	"Iterate over the cycles of the receiver."
	| left first next cycle |
	left _ self support copyAs: Set.
	[left size > 0] whileTrue:
		[first _ left anyOne.
		cycle _ OrderedCollection new.
		next _ first.
		[(cycle add: (left remove: (next _ self at: next))) ~= first] whileTrue.
		aBlock value: cycle]! !

!Permutation methodsFor: 'enumerating' stamp: 'len 5/25/2019 06:19:47'!
fixedPointsDo: aBlock
	"Enumerate the points fixed by the receiver."
	1 to: images size do: [:i| (images at: i) = i ifTrue: [aBlock value: i]]! !

!Permutation methodsFor: 'enumerating' stamp: 'len 5/25/2019 06:21:06'!
supportDo: aBlock
	"Enumerate the points changed by the receiver."
	1 to: images size do: [:i| (images at: i) = i ifFalse: [aBlock value: i]]! !

!Permutation methodsFor: 'operations' stamp: 'len 5/25/2019 06:26:25'!
 aPermutation
	"Answer the product (function composition) of the receiver with the argument.
	This is the group operation."
	| otherImages newImages |
	(images size = aPermutation images size)
		ifFalse: [^ DomainError signal: 'permutation of different degree'].
	otherImages _ aPermutation images.
	newImages _ images class new: images size.
	1 to: images size do: [:i| newImages at: i put: (images at: (otherImages at: i))].
	^ parent images: newImages! !

!Permutation methodsFor: 'operations' stamp: 'len 5/25/2019 06:26:32'!
inverse
	"Answer the compositive inverse of the receiver."
	| values |
	values _ images class new: images size.
	1 to: images size do: [:i| values at: (images at: i) put: i].
	^ parent images: values! !

!Permutation methodsFor: 'testing' stamp: 'len 2/8/2018 08:44:34'!
even
	^ self sign = 1! !

!Permutation methodsFor: 'testing' stamp: 'len 2/8/2018 08:45:31'!
isConjugateWith: aPermutation
	"Answer true if the receiver and the argument are conjugate."

	^ self type = aPermutation type! !

!Permutation methodsFor: 'testing' stamp: 'len 8/19/2020 15:45:24'!
isCycle
	"Answer true if the receiver is a cycle."

	^ self cycles isSingleton! !

!Permutation methodsFor: 'testing' stamp: 'len 5/25/2019 05:26:31'!
isIdentity
	"Answer true if the receiver is the identity permutation."

	^ self support size = 0! !

!Permutation methodsFor: 'testing' stamp: 'len 5/25/2019 05:26:46'!
isTransposition
	"Answer true if the receiver is a transposition."

	^ self support size = 2! !

!Permutation methodsFor: 'testing' stamp: 'len 2/8/2018 08:51:17'!
odd
	^ self sign = -1! !

!Permutation methodsFor: 'private' stamp: 'len 5/25/2019 06:22:06'!
images
	^ images! !

!Permutation methodsFor: 'private' stamp: 'len 5/25/2019 06:21:59'!
images: anArray
	images _ anArray! !

!Permutation methodsFor: 'private' stamp: 'len 4/30/2019 12:32:14'!
parent: aSymmetricGroup
	parent _ aSymmetricGroup! !

!FractionalIdeal methodsFor: 'accessing' stamp: 'len 5/3/2020 21:06:35'!
denominator
	^ denominator! !

!FractionalIdeal methodsFor: 'accessing' stamp: 'len 5/3/2020 21:09:15'!
denominatorIdeal
	"Answer the denominator ideal of the receiver, which is an integral ideal."
	^ self scalars * denominator
"
	^ (self + self ambient oneIdeal) inverse
"! !

!FractionalIdeal methodsFor: 'accessing' stamp: 'len 5/3/2020 21:10:54'!
generators
	| K denominatorInverse |
	K _ self scalars fractions.
	denominatorInverse _ (K !! denominator) inverse.
	^ numerator generators collect: [:each| (K !! each) * denominatorInverse]! !

!FractionalIdeal methodsFor: 'accessing' stamp: 'len 5/3/2020 21:06:11'!
numerator
	"Answer the numerator ideal of the receiver, which is an integral ideal."
	^ numerator! !

!FractionalIdeal methodsFor: 'accessing' stamp: 'len 5/3/2020 21:09:07'!
scalars
	^ numerator scalars! !

!FractionalIdeal methodsFor: 'comparing' stamp: 'len 1/7/2022 14:02:40'!
= anObject
	^ (anObject isKindOf: FractionalIdeal) and: [numerator * anObject denominator = (anObject numerator * denominator)]! !

!FractionalIdeal methodsFor: 'comparing' stamp: 'len 1/7/2022 14:02:48'!
hash
	^ 0! !

!FractionalIdeal methodsFor: 'operations' stamp: 'len 1/7/2022 14:04:33'!
* aFractionalIdeal
	self flag: #fix. "this is not unique, should reduce denominator"
	^ self class numerator: numerator * aFractionalIdeal numerator denominator: denominator * aFractionalIdeal denominator! !

!FractionalIdeal methodsFor: 'operations' stamp: 'len 1/7/2022 13:59:04'!
+ aFractionalIdeal
	| d |
	d _ self denominator lcm: aFractionalIdeal denominator.
	^ self class numerator: self numerator * d + (aFractionalIdeal numerator * d) denominator: d! !

!FractionalIdeal methodsFor: 'operations' stamp: 'len 1/7/2022 14:01:04'!
^ anInteger
	^ self class numerator: self numerator ^ anInteger denominator: self denominator ^ anInteger! !

!FractionalIdeal methodsFor: 'testing' stamp: 'len 1/7/2022 13:56:47'!
contains: anElement
	self isTrivial ifTrue: [^ anElement isZero].
	^ self numerator contains: anElement * self denominator! !

!FractionalIdeal methodsFor: 'testing' stamp: 'len 5/3/2020 21:08:58'!
includes: anObject
	^ (self scalars includes: anObject) and: [self contains: anObject]! !

!FractionalIdeal methodsFor: 'testing' stamp: 'len 1/7/2022 13:56:26'!
isIntegral
	^ denominator isOne! !

!FractionalIdeal methodsFor: 'testing' stamp: 'len 7/15/2021 10:49:29'!
isMaximal
	^ self isZero not and: [self isPrime]! !

!FractionalIdeal methodsFor: 'testing' stamp: 'len 8/5/2021 08:38:40'!
isPrime
	^ self factorization size = 1! !

!FractionalIdeal methodsFor: 'testing' stamp: 'len 1/4/2022 08:53:06'!
isPrincipal
	"Answer true if the receiver is generated by a single element."
	self generators size <= 1 ifTrue: [^ true].
	self scalars isPIR ifTrue: [^ true].
	^ self propertyAt: #isPrincipal! !

!FractionalIdeal methodsFor: 'testing' stamp: 'len 6/26/2019 03:53:25'!
isTrivial
	^ self numerator isTrivial! !

!FractionalIdeal methodsFor: 'private' stamp: 'len 5/3/2020 21:12:34'!
numerator: anIdeal denominator: anElement
	numerator _ anIdeal.
	denominator _ anElement! !

!FractionalIdeal class methodsFor: 'instance creation' stamp: 'len 5/3/2020 21:12:54'!
numerator: anIdeal denominator: anElement
	^ self new numerator: anIdeal denominator: anElement! !

!SemidirectProductElement methodsFor: 'accessing' stamp: 'len 5/5/98 00:18'!
left
	"Answer the left component of the receiver."
	^ left! !

!SemidirectProductElement methodsFor: 'accessing' stamp: 'len 10/6/2016 15:37'!
parent
	^ parent! !

!SemidirectProductElement methodsFor: 'accessing' stamp: 'len 5/5/98 00:18'!
right
	"Answer the right component of the receiver."
	^ right! !

!SemidirectProductElement methodsFor: 'constants' stamp: 'len 1/23/2017 11:46:24'!
identity
	^ self parent identity! !

!SemidirectProductElement methodsFor: 'operations' stamp: 'len 5/5/2019 18:19:05'!
 aSemidirectProduct
	^ self parent
		project:
			{left  aSemidirectProduct left.
			parent action value: {aSemidirectProduct left. right}  aSemidirectProduct right}! !

!SemidirectProductElement methodsFor: 'operations' stamp: 'len 5/5/2019 18:17:09'!
inverse
	| leftInverse rightInverse |
	leftInverse _ left inverse.
	rightInverse _ right inverse.
	^ parent project: {leftInverse. (parent action value: {leftInverse. rightInverse}) inverse}! !

!SemidirectProductElement methodsFor: 'private' stamp: 'len 5/5/98 00:17'!
left: anObject
	left _ anObject! !

!SemidirectProductElement methodsFor: 'private' stamp: 'len 10/6/2016 15:37'!
parent: aSemidirectProductGroup
	parent _ aSemidirectProductGroup! !

!SemidirectProductElement methodsFor: 'private' stamp: 'len 5/5/98 00:17'!
right: anObject
	right _ anObject! !

!ProductReplacementRandomGenerator methodsFor: 'accessing' stamp: 'len 5/25/2019 04:34:49'!
generators: aCollection
	generators _ aCollection.
	state _ nil! !

!ProductReplacementRandomGenerator methodsFor: 'generating' stamp: 'len 5/25/2019 04:36:25'!
atRandom: aRandom
	"Product Replacement Algorithm. After the initial precomputation, every new random element takes one multiplication and 1/2 inversion in the group."
	| g h i |
	state isNil ifTrue: "initial precomputation takes about 60 multiplications / inversions in the group"
		[state _ generators asOrderedCollection.
		60 - (state size min: 10) timesRepeat: [self atRandom: aRandom]].
	g _ state atRandom: aRandom.
	[(state at: (i _ state size atRandom: aRandom)) == g and: [state size > 1 "otherwise fails with cyclic groups"]] whileTrue.
	(2 atRandom: aRandom) = 1 ifTrue: [g _ g inverse].
	h _ aRandom nextBoolean ifTrue: [g  (state at: i)] ifFalse: [(state at: i)  g].
	state size < 10 ifTrue: [state add: h] ifFalse: [state at: i put: h].
	^ h! !

!SchreierSims methodsFor: 'accessing' stamp: 'len 6/30/2016 09:02'!
base
	"A base of a group G acting on X is a finite sequence of distinct points B={x1,..,xn} such that the stabilizer of B is {id}, i.e. the only element that fixes all xi is the identity."
	base ifNil: [self run].
	^ base! !

!SchreierSims methodsFor: 'accessing' stamp: 'len 6/30/2016 10:13'!
order
	"Answer the order of the group."
	order ifNil: [self run].
	^ order! !

!SchreierSims methodsFor: 'accessing' stamp: 'len 6/25/2016 20:06'!
strongGeneratingSet
	strongGeneratingSet ifNil: [self run].
	^ strongGeneratingSet! !

!SchreierSims methodsFor: 'accessing-private' stamp: 'len 6/22/2016 07:31'!
action: aGroupAction
	action _ aGroupAction! !

!SchreierSims methodsFor: 'accessing-private' stamp: 'len 6/22/2016 16:32'!
generators: aCollection
	generators _ aCollection asArray! !

!SchreierSims methodsFor: 'computing' stamp: 'len 6/23/2020 17:30:00'!
contains: anElement
	"Answer true if the group includes anElement."
	^ (self strip: anElement) first = action group identity! !

!SchreierSims methodsFor: 'computing' stamp: 'len 5/8/2019 19:33:18'!
elementFromImage: anArray
	| image g |
	image _ anArray copy.
	g _ action group identity.
	trees withIndexDo: [:each :i|
		g _ (each trace: (image at: i))  g.
		i to: base size do: [:j| image at: j put: (action value: {each traceInverse: (image at: i). image at: j})]].
	^ g! !

!SchreierSims methodsFor: 'computing' stamp: 'len 6/30/2016 10:02'!
imageOf: anElement
	^ base collect: [:each| action value: {anElement. each}]! !

!SchreierSims methodsFor: 'computing' stamp: 'len 5/8/2019 19:33:34'!
strip: anElement
	| g |
	g _ anElement.
	trees withIndexDo: [:each :i| | b b2 |
		b _ each root.
		b2 _ action value: {g. b}.
		(each orbits includes: b2)
			ifFalse: [^ {g. i}].
		g _ g  (each traceInverse: b2)].
	^ {g. trees size + 1}! !

!SchreierSims methodsFor: 'computing-private' stamp: 'len 7/1/2016 05:46'!
buildBSGS
	base _ OrderedCollection new.
	strongGeneratingSet _ OrderedCollection new.
	self buildPartialBSGS.
	base size to: 1 by: -1 do: [:i| self schreierSimsStep: i]! !

!SchreierSims methodsFor: 'computing-private' stamp: 'len 7/1/2016 00:39'!
buildPartialBSGS
	| id |
	id _ action group identity.
	generators do: [:each| each = id ifFalse: [strongGeneratingSet add: each]].
	strongGeneratingSet copy do: [:s|
		(base allSatisfy: [:b| (s value: b) = b])
			ifTrue: [base add: (action space detect: [:one| action isFixedPoint: one])].
			s squared = id ifFalse: [base add: s inverse]]! !

!SchreierSims methodsFor: 'computing-private' stamp: 'len 7/19/2016 08:37'!
run
	| G |
	G _ action group.
	order _ 1.
	base _ OrderedCollection new.
	strongGeneratingSet _ OrderedCollection new.
	trees _ OrderedCollection new.
	G action space do: [:b| | tree |
		G isTrivial ifTrue: [^ order].
		tree _ SchreierTree root: b generators: G generators action: G action.
		trees add: tree.
		order _ order * tree orbit size.
		G _ tree stabilizer].
	self error: 'what?'.
	^ order! !

!SchreierTree methodsFor: 'accessing' stamp: 'len 6/24/2016 03:07'!
orbit
	^ orbit! !

!SchreierTree methodsFor: 'accessing' stamp: 'len 5/8/2019 19:32:19'!
stabilizer
	"Answer the stabilizer of the root."
	| stabilizerGenerators id |
	stabilizerGenerators _ Set new.
	id _ action group identity.
	self orbit do: [:i|
		generators do: [:s|
			| g |
			g _ (self traceInverse: (s value: i))  s  (self trace: i).
			g = id ifFalse: [stabilizerGenerators add: g]]].
	^ action group span: stabilizerGenerators! !

!SchreierTree methodsFor: 'accessing' stamp: 'len 5/8/2019 19:32:27'!
trace: aPoint
	"Trace the Schreier spanning tree (v,w) for the orbit containing aPoint.
	Answer the transversal u(aPoint), i.e. an element such that root^u(aPoint) = aPoint.
	This is the representative function, and in particular u(root^h) is a representative of the coset G_root * h, where G_root is the stabilizer at the root of this Schreier tree.
	For an element g in G, there's an h in G_root g = h * u(root^g), and h = h * u(root^h)^-1."
	| alpha u |
	u _ action group identity.
	alpha _ aPoint.
	[(v at: alpha) notNil]
		whileTrue:
			[u _ u  (v at: alpha).
			alpha _ w at: alpha].
	^ u! !

!SchreierTree methodsFor: 'accessing' stamp: 'len 5/8/2019 19:32:35'!
traceInverse: aPoint
	"Calculate inverses of coset representatives. See 'The Schreier-Sims Algorithm' pp 18. Assumes we're using a (strong) generating set that is closed under inversion. This makes backward pointers unnecesary."
	| alpha u |
	u _ action group identity.
	alpha _ aPoint.
	[(v at: alpha) notNil]
		whileTrue:
			[u _ (inverses at: alpha ifAbsentPut: [(v at: alpha) inverse])  u.
			alpha _ w at: alpha].
	^ u! !

!SchreierTree methodsFor: 'initialization' stamp: 'len 11/30/2016 14:45:01'!
root: aPoint generators: anArray action: aGroupAction
	| queue |
	root _ aPoint.
	generators _ anArray.
	action _ aGroupAction.
	v _ Dictionary new. "Schreier vector"
	w _ Dictionary new. "backward pointers"
	inverses _ Dictionary new. "inverses of the Schreier generators from v"
	orbit _ Set with: aPoint.
	v at: aPoint put: nil. "-1"
	w at: aPoint put: nil. "-1"
	queue _ OrderedCollection with: aPoint.
	[| a |
	a _ queue removeFirst.
	1 to: generators size do: [:i|
		| x g |
		g _ generators at: i.
		x _ action value: {g. a}.
		(orbit includes: x)
			ifFalse:
				[orbit add: x.
				queue add: x.
				v at: x put: g.
				w at: x put: a]].
	queue isEmpty] whileFalse! !

!SchreierTree methodsFor: 'private' stamp: 'len 11/14/2016 08:26'!
verify
	^ self stabilizer generators allSatisfy: [:each| (each value: root) = root]! !

!SchreierTree class methodsFor: 'instance creation' stamp: 'len 6/24/2016 03:07'!
root: aPoint generators: anArray action: aGroupAction
	^ self new root: aPoint generators: anArray action: aGroupAction! !

!ModuleElement methodsFor: 'comparing' stamp: 'len 4/25/2020 09:25:18'!
= anObject
	^ self class == anObject class and: [self parent = anObject parent and: [(self - anObject) isZero]]! !

!ModuleElement methodsFor: 'comparing' stamp: 'len 3/30/2020 07:36:18'!
hash
	^ 0! !

!ModuleElement methodsFor: 'constants' stamp: 'len 7/27/2020 14:45:50'!
zero
	^ self parent zero! !

!ModuleElement methodsFor: 'converting' stamp: 'len 3/13/2020 17:32:23'!
adaptToFraction: rcvr andSend: selector
	selector = #* ifTrue: [^ self * rcvr].
	^ super adaptToNumber: rcvr andSend: selector! !

!ModuleElement methodsFor: 'converting' stamp: 'len 3/13/2020 17:32:28'!
adaptToInteger: rcvr andSend: selector
	selector = #* ifTrue: [^ self * rcvr].
	^ super adaptToInteger: rcvr andSend: selector! !

!ModuleElement methodsFor: 'converting' stamp: 'len 3/13/2020 17:32:32'!
adaptToRealAlgebraic: rcvr andSend: selector
	(selector = #* and: [self scalars includes: rcvr]) ifTrue: [^ self * rcvr].
	^ super adaptToNumber: rcvr andSend: selector! !

!ModuleElement methodsFor: 'operations' stamp: 'len 5/3/2020 10:01:44'!
* aScalar
	^ self subclassResponsibility! !

!ModuleElement methodsFor: 'operations' stamp: 'len 5/3/2020 10:01:50'!
+ anElement
	^ self subclassResponsibility! !

!ModuleElement methodsFor: 'operations' stamp: 'len 3/13/2020 17:29:22'!
- anElement
	^ self + anElement negated! !

!ModuleElement methodsFor: 'operations' stamp: 'len 7/30/2020 18:22:09'!
/ aScalar
	^ self * (self parent scalars !! aScalar) inverse! !

!ModuleElement methodsFor: 'operations' stamp: 'len 5/29/2020 07:53:35'!
negated
	^ self * -1! !

!ModuleElement methodsFor: 'operations' stamp: 'len 12/10/2021 19:16:28'!
normalization
	"Answer a unit u such that 'self * u' is a unique choice of associate. See >>normalized."
	^ self subclassResponsibility! !

!ModuleElement methodsFor: 'operations' stamp: 'len 7/30/2021 10:25:59'!
normalized
	"Answer a unique choice of associate. See >>normalization."
	^ self * self normalization! !

!ModuleElement methodsFor: 'testing' stamp: 'len 3/13/2020 17:35:09'!
isZero
	^ self subclassResponsibility! !

!ModuleCoset methodsFor: 'accessing' stamp: 'len 10/25/2020 10:08:21'!
order
	^ self parent orderOf: self! !

!ModuleCoset methodsFor: 'accessing' stamp: 'len 3/18/2020 17:40:47'!
parent
	^ parent! !

!ModuleCoset methodsFor: 'accessing' stamp: 'len 6/4/2016 04:18'!
representative
	^ representative! !

!ModuleCoset methodsFor: 'comparing' stamp: 'len 7/6/2020 16:13:01'!
= anObject
	^ self class == anObject class and: [parent == anObject parent and: [self contains: anObject representative]]! !

!ModuleCoset methodsFor: 'enumerating' stamp: 'len 3/18/2020 17:36:16'!
do: aBlock
	parent relations do: [:each| aBlock value: each + representative]! !

!ModuleCoset methodsFor: 'operations' stamp: 'len 3/18/2020 17:30:02'!
* aScalar
	^ parent project: representative * aScalar! !

!ModuleCoset methodsFor: 'operations' stamp: 'len 3/18/2020 17:34:25'!
+ anElement
	(parent includes: anElement) ifFalse: [^ self  adapt: anElement andSend: #+].
	^ parent project: representative + anElement representative! !

!ModuleCoset methodsFor: 'operations' stamp: 'len 3/18/2020 17:35:26'!
negated
	^ parent project: representative negated! !

!ModuleCoset methodsFor: 'random' stamp: 'len 3/18/2020 17:21:59'!
atRandom: aRandom
	^ (parent relations atRandom: aRandom) + representative! !

!ModuleCoset methodsFor: 'random' stamp: 'len 3/18/2020 17:22:06'!
atRandom: aRandom bits: bitSize
	^ (parent relations atRandom: aRandom bits: bitSize) + representative! !

!ModuleCoset methodsFor: 'testing' stamp: 'len 3/18/2020 17:17:36'!
contains: anObject
	^ parent relations contains: anObject - representative! !

!ModuleCoset methodsFor: 'testing' stamp: 'len 3/18/2020 17:17:53'!
includes: anObject
	^ (parent base includes: anObject) and: [self contains: anObject]! !

!ModuleCoset methodsFor: 'testing' stamp: 'len 7/6/2020 16:04:43'!
isZero
	^ representative isZero
"	^ parent relations contains: representative"

"this is unnecesary if the representative of 0 is ensured to be 0:
	^ parent relations includes: representative
"
! !

!ModuleCoset methodsFor: 'private' stamp: 'len 3/18/2020 17:17:12'!
parent: aQuotientModule
	parent _ aQuotientModule! !

!ModuleCoset methodsFor: 'private' stamp: 'len 6/4/2016 04:30'!
representative: aPoint
	representative _ aPoint! !

!Tuple methodsFor: 'printing' stamp: 'len 5/19/2018 19:44:02'!
printCoefficientsOn: aStream
	| separator |
	separator _ (self anySatisfy: [:any| any printString includesAnyOf: ', ']) ifTrue: [', '] ifFalse: [','].
	self do: [:x| aStream print: x] separatedBy: [aStream nextPutAll: separator]! !

!Tuple methodsFor: 'printing' stamp: 'len 5/29/2020 06:29:52'!
validate
	self parent rank = self size ifFalse: [^ false].
	^ self allSatisfy: [:each| self scalars includes: each]! !

!Tuple methodsFor: 'accessing' stamp: 'len 5/10/2020 19:24:35'!
associates
	^ self scalars units collect: [:each| self * each]! !

!Tuple methodsFor: 'accessing' stamp: 'len 11/18/2016 20:21:46'!
at: index ifAbsent: exceptionBlock
	"Answer the element at my position index. If I do not contain an element
	at index, answer the result of evaluating the argument, exceptionBlock."

	(index between: 1 and: self size) ifTrue: [^ self at: index].
	^ exceptionBlock value! !

!Tuple methodsFor: 'accessing' stamp: 'len 3/29/2016 18:54'!
bitSize
	| answer |
	answer _ 0.
	self do: [:each| answer _ answer + each bitSize].
	^ answer! !

!Tuple methodsFor: 'accessing' stamp: 'len 7/29/2020 06:52:29'!
degree
	^ parent rank! !

!Tuple methodsFor: 'accessing' stamp: 'len 4/21/2018 23:08:36'!
denominator
	| answer |
	self scalars isLocalization ifFalse: [^ self scalars one].
	answer _ self scalars integers one.
	self do: [:each| answer _ each denominator lcm: answer].
	^ answer! !

!Tuple methodsFor: 'accessing' stamp: 'len 1/2/2022 09:56:42'!
depth
	"Answer the index of the last nonzero entry, or 0.
	(Instead, Magma defines this as the index of the *first* nonzero entry.)
	See >>pivot for the index of the first nonzero entry."
	self size to: 1 by: -1 do: [:i| (self isZeroAt: i) ifFalse: [^ i]].
	^ 0! !

!Tuple methodsFor: 'accessing' stamp: 'len 11/5/2016 09:26'!
first
	^ self at: 1! !

!Tuple methodsFor: 'accessing' stamp: 'len 11/6/2016 04:32'!
last
	^ self at: self size! !

!Tuple methodsFor: 'accessing' stamp: 'len 4/4/2021 08:04:20'!
lift
	"If the coefficients ring is a quotient R/I, answer a representative of the receiver over R. See >>%."
	^ parent lift filling: [:i| (self at: i) lift]! !

!Tuple methodsFor: 'accessing' stamp: 'len 5/9/2020 10:01:13'!
numerator
	self scalars isLocalization ifFalse: [^ self].
	^ self * (self scalars !! self denominator) over: self scalars integers! !

!Tuple methodsFor: 'accessing' stamp: 'len 5/28/2020 13:09:52'!
parent
	^ parent! !

!Tuple methodsFor: 'accessing' stamp: 'len 1/6/2022 11:29:49'!
pivot
	"Answer the index of the first nonzero entry, or nil.
	See >>depth for the index of the last nonzero entry."
	1 to: self size do: [:i| (self isZeroAt: i) ifFalse: [^ i]].
	^ nil! !

!Tuple methodsFor: 'accessing' stamp: 'len 5/28/2020 13:09:44'!
scalars
	"Answer the ring of scalars (or ring of coefficients) of the receiver."
	^ parent scalars! !

!Tuple methodsFor: 'accessing' stamp: 'len 5/16/2020 12:27:17'!
second
	^ self at: 2! !

!Tuple methodsFor: 'accessing' stamp: 'len 7/26/2020 13:24:26'!
size
	^ parent rank! !

!Tuple methodsFor: 'accessing' stamp: 'len 3/29/2016 19:06'!
x
	^ self at: 1! !

!Tuple methodsFor: 'accessing' stamp: 'len 3/29/2016 19:06'!
y
	^ self at: 2! !

!Tuple methodsFor: 'accessing' stamp: 'len 3/29/2016 19:06'!
z
	^ self at: 3! !

!Tuple methodsFor: 'comparing' stamp: 'len 4/30/2021 13:27:29'!
~ aTuple
	"Answer true if the receiver and the argument are equivalent as homogeneous tuples."
	self scalars isIntegralDomain ifTrue:
		[| depth x y |
		depth _ self depth.
		(depth = 0 or: [aTuple depth ~= depth]) ifTrue: [^ false].
		x _ self at: depth.
		y _ aTuple at: depth.
		1 to: depth do: [:i| (self at: i) * y = ((aTuple at: i) * x) ifFalse: [^ false]].
		^ true].
	"Over a PIR we compare use their Howell normal form:"
"	self scalars isPIR ifTrue: [^ self asRowMatrix echelon = aTuple asRowMatrix echelon]."
	"In a general ring we have to check all units:"
	self scalars isFinite ifFalse: [^ self error: 'not over a finite ring'].
	^ self scalars units anySatisfy: [:any| self * any = aTuple]

"	1 to: self size do: [:i|
		i+1 to: self size do: [:j|
			(self at: i) * (aTuple at: j) = ((self at: j) * aTuple at: i)
				ifFalse: [^ false]]].
	^ true"! !

!Tuple methodsFor: 'converting' stamp: 'len 11/8/2016 07:19'!
adaptToCollection: aCollection andSend: selector
	self size = aCollection size ifFalse: [^ self error: 'sizes don''t match'].
	^ aCollection withIndexCollect: [:each :index| each perform: selector with: (self at: index)]! !

!Tuple methodsFor: 'converting' stamp: 'len 11/5/2016 09:46'!
asArray
	^ self as: Array! !

!Tuple methodsFor: 'converting' stamp: 'len 7/7/2020 09:46:27'!
asMatrix
	"Tuples are equivalent to columns."
	^ Matrix columns: {self}! !

!Tuple methodsFor: 'converting' stamp: 'len 3/13/2018 18:48:37'!
asRowMatrix
	^ Matrix rows: {self}! !

!Tuple methodsFor: 'converting' stamp: 'len 11/7/2016 13:48'!
asTuple
	^ self! !

!Tuple methodsFor: 'converting' stamp: 'len 5/29/2020 08:49:26'!
over: aRing
	self scalars = aRing ifFalse: [^ (self parent over: aRing) elementAt: self]! !

!Tuple methodsFor: 'converting' stamp: 'len 12/13/2016 16:49:22'!
readStream
	^ ReadStream on: self! !

!Tuple methodsFor: 'copying' stamp: 'len 5/30/2020 14:29:08'!
coproject: aList
	| answer |
	answer _ self zero copy.
	aList do: [:i| answer at: i put: (self at: i)].
	^ answer! !

!Tuple methodsFor: 'copying' stamp: 'len 5/28/2020 14:57:28'!
extendedTo: anInteger
	self size = anInteger ifTrue: [^ self].
	self size > anInteger ifTrue: [^ DomainError signal: 'tuple to large'].
	^ self, (self scalars^(anInteger - self size)) zero! !

!Tuple methodsFor: 'enumerating' stamp: 'len 11/5/2016 07:06'!
allSatisfy: aBlock
	"Evaluate aBlock with the elements of the receiver.
	If aBlock returns false for any element return false.
	Otherwise return true."

	self do: [:each | (aBlock value: each) ifFalse: [^ false]].
	^ true! !

!Tuple methodsFor: 'enumerating' stamp: 'len 11/5/2016 09:09'!
anySatisfy: aBlock
	"Evaluate aBlock with the elements of the receiver.
	If aBlock returns true for any element return true.
	Otherwise return false"

	self do:[:item | (aBlock value: item) ifTrue: [^ true]].
	^ false! !

!Tuple methodsFor: 'enumerating' stamp: 'len 5/29/2020 16:32:36'!
collect: aBlock
	^ parent filling: [:i| aBlock value: (self at: i)]! !

!Tuple methodsFor: 'enumerating' stamp: 'len 11/5/2016 09:43'!
count: aBlock
	| count |
	count _ 0.
	self do: [:each| (aBlock value: each) ifTrue: [count _ count + 1]].
	^ count! !

!Tuple methodsFor: 'enumerating' stamp: 'len 11/5/2016 06:46'!
do: aBlock
	1 to: self size do: [:each| aBlock value: (self at: each)]! !

!Tuple methodsFor: 'enumerating' stamp: 'len 11/5/2016 09:26'!
do: elementBlock separatedBy: separatorBlock
	| beforeFirst | 
	"Evaluate the elementBlock for all elements in the receiver,
	and evaluate the separatorBlock between."

	beforeFirst _ true.
	self do: [ :element |
		beforeFirst
			ifTrue: [beforeFirst _ false]
			ifFalse: [separatorBlock value].
		elementBlock value: element]! !

!Tuple methodsFor: 'enumerating' stamp: 'len 11/12/2016 08:51'!
findFirst: aBlock
	"Return the index of my first element for which aBlock evaluates as true."

	| index |
	index _ 0.
	[(index _ index + 1) <= self size] whileTrue:
		[(aBlock value: (self at: index)) ifTrue: [^index]].
	^ 0! !

!Tuple methodsFor: 'enumerating' stamp: 'len 11/5/2016 07:05'!
findLast: aBlock
	"Return the index of my last element for which aBlock evaluates as true."

	| index |
	index _ self size + 1.
	[(index _ index - 1) >= 1] whileTrue:
		[(aBlock value: (self at: index)) ifTrue: [^index]].
	^ 0! !

!Tuple methodsFor: 'enumerating' stamp: 'len 11/5/2016 06:48'!
inject: thisValue into: binaryBlock 
	| nextValue |
	nextValue _ thisValue.
	self do: [:each | nextValue _ binaryBlock value: nextValue value: each].
	^ nextValue! !

!Tuple methodsFor: 'enumerating' stamp: 'len 1/13/2022 09:27:25'!
max: aBlock
	"Answer the maximum of evaluating aBlock on all the coefficients of the receiver."
	| answer |
	self isEmpty ifTrue: [^ self error: 'empty tuple'].
	self do: [:each| answer _ answer isNil ifTrue: [aBlock value: each] ifFalse: [answer max: (aBlock value: each)]].
	^ answer! !

!Tuple methodsFor: 'enumerating' stamp: 'len 11/6/2016 14:22'!
product
	^ self product: [:each| each]! !

!Tuple methodsFor: 'enumerating' stamp: 'len 12/13/2016 09:55:53'!
product: aBlock
	^ self inject: self scalars one into: [:nextValue :each| nextValue * (aBlock value: each)]! !

!Tuple methodsFor: 'enumerating' stamp: 'len 11/5/2016 06:47'!
reverseDo: aBlock
	self size to: 1 by: -1 do: [:each| aBlock value: (self at: each)]! !

!Tuple methodsFor: 'enumerating' stamp: 'len 11/6/2016 14:22'!
sum
	^ self sum: [:each| each]! !

!Tuple methodsFor: 'enumerating' stamp: 'len 12/13/2016 09:55:29'!
sum: aBlock
	^ self inject: self scalars zero into: [:nextValue :each| nextValue + (aBlock value: each)]! !

!Tuple methodsFor: 'enumerating' stamp: 'len 7/22/2020 09:31:48'!
supportDo: aBlock
	1 to: self size do: [:index| (self isZeroAt: index) ifFalse: [aBlock value: index]]! !

!Tuple methodsFor: 'enumerating' stamp: 'len 1/4/2022 12:32:19'!
with: aTuple collect: aBlock
	^ parent filling: [:i| aBlock value: (self at: i) value: (aTuple at: i)]! !

!Tuple methodsFor: 'enumerating' stamp: 'len 3/13/2020 16:15:51'!
with: otherCollection do: twoArgBlock 
	"Evaluate twoArgBlock with corresponding elements from this collection and otherCollection."
	otherCollection size = self size ifFalse: [self error: 'otherCollection must be the same size'].
	1 to: self size do:
		[:index |
		twoArgBlock value: (self at: index)
				value: (otherCollection at: index)]! !

!Tuple methodsFor: 'enumerating' stamp: 'len 5/29/2020 16:31:58'!
withIndexCollect: aBlock
	^ parent filling: [:i| aBlock value: (self at: i) value: i]! !

!Tuple methodsFor: 'enumerating' stamp: 'len 11/5/2016 06:47'!
withIndexDo: aBlock
	1 to: self size do: [:index| aBlock value: (self at: index) value: index]! !

!Tuple methodsFor: 'enumerating' stamp: 'len 7/26/2020 13:16:06'!
withNamesDo: aBlock
	| names |
	names _ parent names.
	1 to: self size do: [:index| (self isZeroAt: index) ifFalse: [aBlock value: (self at: index) value: (names at: index)]]! !

!Tuple methodsFor: 'enumerating' stamp: 'len 7/19/2020 07:58:07'!
withSupportDo: aBlock
	1 to: self size do: [:index| (self isZeroAt: index) ifFalse: [aBlock value: (self at: index) value: index]]! !

!Tuple methodsFor: 'operations' stamp: 'len 6/1/2020 13:40:06'!
% anInteger
	| R |
	self flag: #fix. "optimize. this is slow because creates lots of residue class objects"
	R _  / anInteger.
	^ R^self size filling: [:i| R project: (self at: i) asInteger]! !

!Tuple methodsFor: 'operations' stamp: 'len 7/27/2021 09:17:59'!
* anObject
	((self scalars includes: anObject) or: [anObject isInteger]) ifTrue: [^ self collect: [:each| each * anObject]].
	anObject isMatrix ifTrue: [^ (self asRowMatrix * anObject) asTuple].
	anObject isTuple ifTrue: [^ self  anObject].
	^ self * (self scalars !! anObject)! !

!Tuple methodsFor: 'operations' stamp: 'len 8/28/2021 11:17:11'!
/ anElement
	"Answer X such that XA = B, where B is self and A is the argument.  X is called a lift of B along A.
	If the argument is a scalar, just divide each element of the tuple by it."
	anElement isMatrix ifTrue: [^ (anElement colift: self asMatrix transpose) asTuple].
	^ self collect: [:each| each / anElement]! !

!Tuple methodsFor: 'operations' stamp: 'len 1/13/2022 09:14:56'!
// anElement
	^ self collect: [:each| each // anElement]! !

!Tuple methodsFor: 'operations' stamp: 'len 3/29/2016 19:02'!
<< anInteger
	^ self >> anInteger negated! !

!Tuple methodsFor: 'operations' stamp: 'len 3/29/2016 18:45'!
<<< anInteger
	^ self >>> anInteger negated! !

!Tuple methodsFor: 'operations' stamp: 'len 5/28/2020 14:57:00'!
>>> anInteger
	anInteger == 0 ifTrue: [^ self].
	anInteger < 0 ifTrue: [^ self copyFrom: anInteger negated + 1 to: self size].
	^ (self scalars^anInteger) zero, self! !

!Tuple methodsFor: 'operations' stamp: 'len 1/13/2022 09:14:51'!
\\ anElement
	^ self collect: [:each| each \\ anElement]! !

!Tuple methodsFor: 'operations' stamp: 'len 7/9/2020 07:56:46'!
| aTuple
	"Answer the inner product of the receiver and the argument."
	^ parent innerProduct value: aTuple value: self! !

!Tuple methodsFor: 'operations' stamp: 'len 7/27/2020 14:52:43'!
 aTuple
	| answer |
	answer _ self scalars zero.
	1 to: (self depth min: aTuple depth) do: [:i| answer _ (self at: i) * (aTuple at: i) + answer].
	^ answer! !

!Tuple methodsFor: 'operations' stamp: 'len 7/8/2020 06:41:56'!
 aTuple
	"Answer the cross product of the receiver with the argument."
	(self size = 3 and: [aTuple parent = self parent]) ifFalse: [DomainError signal].
	^ self class
		components:
			{(self at: 2)*(aTuple at: 3) - ((self at: 3)*(aTuple at: 2)).
			(self at: 3)*(aTuple at: 1) - ((self at: 1)*(aTuple at: 3)).
			(self at: 1)*(aTuple at: 2) - ((self at: 2)*(aTuple at: 1))}
		parent: self parent! !

!Tuple methodsFor: 'operations' stamp: 'len 4/28/2021 11:40:42'!
 anElement
	"Answer the outer product of the receiver with the argument."
	anElement isTuple ifTrue: [^ Matrix from: anElement parent to: self parent filling: [:i :j| (self at: i)*(anElement at: j)]].
	anElement isMatrix ifTrue: [^ self asMatrix  anElement transpose].
	^ super  anElement! !

!Tuple methodsFor: 'operations' stamp: 'len 6/6/2019 09:45:07'!
add: aTuple shifted: delta from: startIndex to: stopIndex
	startIndex to: stopIndex do: [:i| self at: i add: (aTuple at: i-delta)]! !

!Tuple methodsFor: 'operations' stamp: 'len 5/30/2019 07:23:04'!
add: aTuple times: aNumber
	self add: aTuple times: aNumber startingAt: 1! !

!Tuple methodsFor: 'operations' stamp: 'len 6/6/2019 09:45:24'!
add: aTuple times: aNumber from: startIndex to: stopIndex
	startIndex to: stopIndex do: [:i| self at: i add: (aTuple at: i) * aNumber]! !

!Tuple methodsFor: 'operations' stamp: 'len 5/30/2019 07:10:41'!
add: aTuple times: aNumber startingAt: startIndex
	self add: aTuple times: aNumber from: startIndex to: (self size min: aTuple size)! !

!Tuple methodsFor: 'operations' stamp: 'len 7/15/2021 10:41:40'!
annihilator
	^ self annihilatorIdeal generator! !

!Tuple methodsFor: 'operations' stamp: 'len 7/15/2021 10:41:26'!
annihilatorIdeal
	| answer |
	answer _ self scalars asIdeal.
	self isZero ifTrue: [^ answer].
	self do: [:each| answer _ answer /\ each annihilatorIdeal. answer isTrivial ifTrue: [^ answer]].
	^ answer! !

!Tuple methodsFor: 'operations' stamp: 'len 7/27/2020 14:54:43'!
apply: aMorphism
	"Apply a homomorphism to the coefficients of the receiver."
	aMorphism isBlock ifTrue: [^ self collect: aMorphism].
	aMorphism codomain isRing ifFalse: [^ DomainError signal].
	^ aMorphism codomain^self size filling: [:i| aMorphism value: (self at: i)]! !

!Tuple methodsFor: 'operations' stamp: 'len 8/9/2020 07:47:06'!
conjugate
	^ self collect: [:each| each conjugate]! !

!Tuple methodsFor: 'operations' stamp: 'len 7/17/2019 11:02:11'!
content
	"Answer the GCD of the coefficients of the receiver.
	In a field, it is convenient to define the content as 1.
	For example, (2,4) has content 2 over Z and 1 over Q."
	| answer |
	self isZero ifTrue: [^ self scalars zero].
	self scalars isField ifTrue: [^ self scalars one].
	answer _ self scalars zero.
	self do: [:each| answer _ answer gcd: each].
	^ answer! !

!Tuple methodsFor: 'operations' stamp: 'len 5/29/2020 16:31:30'!
hadamard: aTuple
	"Answer the entrywise product with the argument, also called Hadamard product."
	
	^ (self size <= aTuple size ifTrue: [parent] ifFalse: [aTuple parent]) filling: [:i| (self at: i) * (aTuple at: i)]! !

!Tuple methodsFor: 'operations' stamp: 'len 11/27/2016 13:25:12'!
height
	| answer |
	answer _ 1.
	self do: [:each| answer _ answer max: each height].
	^ answer! !

!Tuple methodsFor: 'operations' stamp: 'len 1/14/2022 10:59:49'!
homogenizedAt: anInteger
	^ (self copyFrom: 1 to: anInteger - 1), self scalars one, (self copyFrom: anInteger to: self size)! !

!Tuple methodsFor: 'operations' stamp: 'len 7/27/2020 15:03:24'!
length
	^ self norm sqrt! !

!Tuple methodsFor: 'operations' stamp: 'len 5/1/2020 18:48:04'!
max
	| answer |
	answer _ self first.
	2 to: self size do: [:i| answer _ answer max: (self at: i)].
	^ answer! !

!Tuple methodsFor: 'operations' stamp: 'len 5/1/2020 18:48:12'!
min
	| answer |
	answer _ self first.
	2 to: self size do: [:i| answer _ answer min: (self at: i)].
	^ answer! !

!Tuple methodsFor: 'operations' stamp: 'len 1/16/2018 22:02:42'!
multiplyBy: aNumber
	self multiplyBy: aNumber startingAt: 1! !

!Tuple methodsFor: 'operations' stamp: 'len 1/16/2018 22:03:27'!
multiplyBy: aNumber from: startIndex to: stopIndex
	startIndex to: stopIndex do: [:i|
		self at: i put: (self at: i) * aNumber]! !

!Tuple methodsFor: 'operations' stamp: 'len 1/16/2018 22:01:18'!
multiplyBy: aNumber startingAt: startIndex
	self multiplyBy: aNumber from: startIndex to: self size! !

!Tuple methodsFor: 'operations' stamp: 'len 3/29/2016 18:56'!
negated
	^ self collect: [:each| each negated]! !

!Tuple methodsFor: 'operations' stamp: 'len 7/10/2020 09:23:39'!
norm
	^ self | self! !

!Tuple methodsFor: 'operations' stamp: 'len 12/10/2021 19:20:51'!
normalization
	"Answer a unit u such that 'self * u' is a unique choice of associate. See >>normalized."
	| d |
	self reverseDo: [:each| each isUnit ifTrue: [^ each]].
	(d _ self depth) > 0 ifFalse: [^ self scalars one].
	^ (self at: d) normalization
"	u _ (self at: d) unit.
	a _ (self at: d) * u inverse.
	u2 _ (self copyFrom: 1 to: d-1) unit.
	a * u2 inverse = a ifTrue: [^ u*u2].
	^ u"! !

!Tuple methodsFor: 'operations' stamp: 'len 5/29/2020 19:46:38'!
polynomialDivisionBy: aTuple
	| q r n m bmInv |
	(m _ aTuple depth) = 0 ifTrue: [^ (ZeroDivide receiver: self selector: #polynomialDivisionBy: argument: aTuple) signal].
	bmInv _ (aTuple at: m) inverse. "m = degree(self)+1, bmInv = inverse of leading coefficient"
	q _ self zero.
	r _ self copy.
	[(n _ r depth) >= m] "n = degree(r)+1"
		whileTrue:
			[| i c |
			i _ n-m+1.
			c _ (r at: n) * bmInv.
			q at: i put: (q at: i) + c.
			1 to: m do: [:j| r at: j+i-1 put: (r at: j+i-1) - ((aTuple at: j)*c)]].
	^ {q. r}! !

!Tuple methodsFor: 'operations' stamp: 'len 5/29/2020 19:46:55'!
polynomialPartialDivisionBy: aTuple
	| q r n m  bm |
	(m _ aTuple depth) = 0 ifTrue: [^ (ZeroDivide receiver: self selector: #polynomialPartialDivisionBy: argument: aTuple) signal].
	bm _ (aTuple at: m). "m = degree(self)+1, bm = leading coefficient"
	q _ self zero.
	r _ self copy.
	[(n _ r depth) >= m] "n = degree(r)+1"
		whileTrue:
			[| i c |
			i _ n-m+1.
			c _ (r at: n) // bm.
			c isZero ifTrue: [^ {q. r}].
			q at: i put: (q at: i) + c.
			1 to: m do: [:j| r at: j+i-1 put: (r at: j+i-1) - ((aTuple at: j)*c)]].
	^ {q. r}! !

!Tuple methodsFor: 'operations' stamp: 'len 5/29/2020 19:47:02'!
polynomialRemainderOfDivisionBy: aTuple
	"See >>polynomialDivisionBy:. This is the same, except that computation of the quotient was removed."
	| r n m bmInv |
	(m _ aTuple depth) = 0 ifTrue: [^ (ZeroDivide receiver: self selector: #polynomialRemainderOfDivisionBy: argument: aTuple) signal].
	bmInv _ (aTuple at: m) inverse. "m = degree(self)+1, bm = inverse of leading coefficient"
	r _ self copy.
	[(n _ r depth) >= m] "n = degree(r)+1"
		whileTrue:
			[| i c |
			i _ n-m+1.
			c _ (r at: n) * bmInv.
			1 to: m do: [:j| r at: j+i-1 put: (r at: j+i-1) - ((aTuple at: j)*c)]].
	^ r! !

!Tuple methodsFor: 'operations' stamp: 'len 5/29/2020 19:47:09'!
polynomialRemainderOfPartialDivisionBy: aTuple
	"See >>polynomialPartialDivisionBy:. This is the same, except that computation of the quotient was removed."
	| r n m bm |
	(m _ aTuple depth) = 0 ifTrue: [^ (ZeroDivide receiver: self selector: #polynomialRemainderOfPartialDivisionBy: argument: aTuple) signal].
	bm _ (aTuple at: m). "m = degree(self)+1, bm = leading coefficient"
	r _ self copy.
	[(n _ r depth) >= m] "n = degree(r)+1"
		whileTrue:
			[| i c |
			i _ n-m+1.
			c _ (r at: n) // bm.
			c isZero ifTrue: [^ r].
			1 to: m do: [:j| r at: j+i-1 put: (r at: j+i-1) - ((aTuple at: j)*c)]].
	^ r! !

!Tuple methodsFor: 'operations' stamp: 'len 11/23/2016 05:43:12'!
polynomialValue: anObject
	"Evaluate the receiver (as an univariate polynomial) at the given argument using Horner's method."
	| answer one |
	answer _ anObject zero.
	one _ anObject one.
	self reverseDo: [:each| answer _ anObject * answer + (one * each)].
	^ answer! !

!Tuple methodsFor: 'operations' stamp: 'len 1/9/2022 08:19:26'!
primitivePart
	"Answer the primitive part of the receiver."
	^ self isZero ifTrue: [self] ifFalse: [self / self content]! !

!Tuple methodsFor: 'operations' stamp: 'len 5/16/2020 13:32:19'!
stabilizers
	| answer last |
	self size <= 1 ifTrue: [^ #()].
	answer _ OrderedCollection new: self size - 1.
	last _ self at: 1.
	2 to: self size do: [:i| | ai ci |
		ai _ self at: i.
		ci _ last stabilizerWith: ai.
		answer add: ci.
		last _ ci*ai + last].
	^ answer! !

!Tuple methodsFor: 'operations' stamp: 'len 11/5/2016 09:27'!
support
	^ (1 to: self size) reject: [:each| (self at: each) isZero]! !

!Tuple methodsFor: 'operations' stamp: 'len 11/12/2016 08:41'!
weight
	"Answer the Hamming weight of the receiver, i.e. the number of entries that are not zero."
	^ self count: [:each| each isZero not]! !

!Tuple methodsFor: 'operations' stamp: 'len 5/29/2020 16:32:26'!
wrap: n
	"Perform a cyclic right shift."
	^ parent filling: [:i| self at: i-1-n \\ self size + 1]! !

!Tuple methodsFor: 'testing' stamp: 'len 8/11/2019 12:20:17'!
beginsWith: anArray
	"Answer true if the receiver starts with the argument collection."
	| n |
	self size < (n _ anArray size) ifTrue: [^ false].
	1 to: n do: [:index| (anArray at: index) = (self at: index) ifFalse: [^ false]].
	^ true! !

!Tuple methodsFor: 'testing' stamp: 'len 11/5/2016 09:45'!
includes: anObject 
	"Answer whether anObject is one of the receiver's elements."

	self do: [:each| each = anObject ifTrue: [^ true]].
	^ false! !

!Tuple methodsFor: 'testing' stamp: 'len 11/5/2016 07:12'!
isEmpty
	^ self size = 0! !

!Tuple methodsFor: 'testing' stamp: 'len 7/26/2021 15:24:17'!
isMonomial
	^ self allSatisfy: [:each| each isMonomial]! !

!Tuple methodsFor: 'testing' stamp: 'len 5/22/2018 16:53:54'!
isSequenceable
	^ true! !

!Tuple methodsFor: 'testing' stamp: 'len 3/28/2018 18:01:30'!
isTuple
	^ true! !

!Tuple methodsFor: 'testing' stamp: 'len 5/16/2020 10:34:21'!
isUnimodular
	"Answer true if the coefficients of the receiver generate the unit ideal.
	Some authors use the name 'primitive' instead of 'unimodular'."
	^ (self scalars * self asArray) isOne! !

!Tuple methodsFor: 'testing' stamp: 'len 3/29/2016 19:04'!
isZero
	^ self allSatisfy: [:each| each isZero]! !

!Tuple methodsFor: 'testing' stamp: 'len 12/1/2016 17:05:22'!
isZeroAt: anInteger
	^ (self at: anInteger) isZero! !

!Tuple methodsFor: 'testing' stamp: 'len 4/12/2021 12:27:26'!
isZeroFrom: start to: stop
	start to: stop do: [:i| (self isZeroAt: i) ifFalse: [^ false]].
	^ true! !

!Tuple methodsFor: 'private' stamp: 'len 6/6/2019 09:41:21'!
at: anInteger add: anElement
	^ self at: anInteger put: (self at: anInteger) + anElement! !

!Tuple methodsFor: 'private' stamp: 'len 5/29/2020 07:48:29'!
parent: aFreeModule
	parent _ aFreeModule! !

!DenseTuple methodsFor: 'operations' stamp: 'len 7/18/2020 06:04:19'!
+ aTuple
	| a b n m c |
	(aTuple isTuple and: [self scalars = aTuple scalars]) ifFalse: [^ self adapt: aTuple andSend: #+].
	a _ components.
	b _ aTuple components.
	n _ a size.
	m _ b size.
	c _ Array new: (n max: m).
	1 to: (n min: m) do: [:i| c at: i put: (a at: i) + (b at: i)].
	m > n
		ifTrue: [c replaceFrom: n+1 to: m with: b startingAt: n+1]
		ifFalse: [m < n ifTrue: [c replaceFrom: m+1 to: n with: a startingAt: m+1]].
	^ self class components: c parent: (n >= m ifTrue: [parent] ifFalse: [aTuple parent])! !

!DenseTuple methodsFor: 'operations' stamp: 'len 7/18/2020 06:03:27'!
- aTuple
	| a b n m c |
	(aTuple isTuple and: [self scalars = aTuple scalars]) ifFalse: [^ self adapt: aTuple andSend: #-].
	a _ components.
	b _ aTuple components.
	n _ a size.
	m _ b size.
	c _ Array new: (n max: m).
	1 to: (n min: m) do: [:i| c at: i put: (a at: i) - (b at: i)].
	n > m
		ifTrue: [c replaceFrom: m+1 to: n with: a startingAt: m+1]
		ifFalse: [n < m ifTrue: [n+1 to: m do: [:i| c at: i put: (b at: i) negated]]].
	^ self class components: c parent: (n >= m ifTrue: [parent] ifFalse: [aTuple parent])! !

!DenseTuple methodsFor: 'operations' stamp: 'len 6/6/2019 10:00:36'!
convolution2: aTuple
	| a aH aHbH aL aLbL b bH bL mid n m |
	self size >= aTuple size ifTrue: [a _ self. b _ aTuple] ifFalse: [a _ aTuple. b _ self].
	n _ a size.
	m _ b size.
	m > 200 ifFalse: [^ self convolution: aTuple].
	mid _ n // 2.
	m > mid ifFalse: [^ self convolution: aTuple].
	aL _ a copyFrom: 1 to: mid.
	aH _ a copyFrom: mid+1 to: n.
	bL _ b copyFrom: 1 to: mid.
	bH _ b copyFrom: mid+1 to: m.
	aLbL _ aL convolution2: bL.
	aHbH _ aH convolution2: bH.
	^ aLbL + ((aL + aH convolution2: bL + bH) - aLbL - aHbH >>> mid) + (aHbH >>> (mid*2))! !

!DenseTuple methodsFor: 'operations' stamp: 'len 5/28/2020 14:44:26'!
convolution: aTuple
	| array |
	self isEmpty ifTrue: [^ self].
	aTuple isEmpty ifTrue: [^ aTuple].
	(aTuple isTuple and: [self scalars = aTuple scalars]) ifFalse: [^ self adapt: aTuple andSend: #convolution:].
	array _ Array new: self size + aTuple size - 1.
	array atAllPut: self scalars zero.
	self withIndexDo: [:xi :i|
		xi isZero ifFalse:
			[aTuple withIndexDo: [:yj :j|
				array at: i+j-1 add: xi*yj]]].
	^ self class components: array parent: self scalars^array size! !

!DenseTuple methodsFor: 'operations' stamp: 'len 5/28/2020 14:42:52'!
reversed
	^ self class components: components reversed parent: parent! !

!DenseTuple methodsFor: 'accessing' stamp: 'len 1/1/2022 10:24:41'!
at: anInteger
	anInteger isInteger ifFalse: [^ (components at: anInteger position) at: anInteger monomial].
	^ components at: anInteger! !

!DenseTuple methodsFor: 'accessing' stamp: 'len 1/1/2022 10:23:49'!
at: anInteger ifAbsent: aBlock
	anInteger isInteger ifFalse: [^ (components at: anInteger position ifAbsent: [^aBlock value]) at: anInteger monomial ifAbsent: aBlock].
	^ components at: anInteger ifAbsent: aBlock! !

!DenseTuple methodsFor: 'accessing' stamp: 'len 7/26/2020 13:29:00'!
size
	^ components size! !

!DenseTuple methodsFor: 'comparing' stamp: 'len 4/15/2021 09:47:16'!
= anObject
	| n otherComponents |
	self class = anObject class ifFalse: [^ false].
"	scalars = anObject scalars ifFalse: [^ false]."
	otherComponents _ anObject components.
	(n _ components size) = otherComponents size ifFalse:
		[(n _ self depth) = anObject depth ifFalse: [^ false]].
	1 to: n do: [:i| (components at: i) = (otherComponents at: i) ifFalse: [^ false]].
	^ true! !

!DenseTuple methodsFor: 'comparing' stamp: 'len 7/27/2020 08:31:26'!
hash
	| answer |
	answer _ 0.
	components do: [:each| each isZero ifFalse: [answer _ answer hashMultiply + each hash]].
	^ answer! !

!DenseTuple methodsFor: 'converting' stamp: 'len 8/18/2019 18:50:34'!
asArray
	^ components! !

!DenseTuple methodsFor: 'copying' stamp: 'len 6/1/2020 15:05:41'!
, anObject
	(anObject isTuple or: [anObject isArray])
		ifTrue: [^ self scalars^(self size + anObject size) elementAt: components, anObject asArray].
	^ self copyWith: anObject! !

!DenseTuple methodsFor: 'copying' stamp: 'len 5/28/2020 14:41:59'!
copy
	^ self class components: components copy parent: parent! !

!DenseTuple methodsFor: 'copying' stamp: 'len 5/28/2020 14:42:15'!
copyFrom: start to: stop
	^ self class components: (components copyFrom: start to: stop) parent: self scalars^(stop-start+1)! !

!DenseTuple methodsFor: 'copying' stamp: 'len 5/28/2020 14:42:40'!
copyWith: anElement
	^ self class components: (components copyWith: self scalars !! anElement) parent: self scalars^(self size + 1)! !

!DenseTuple methodsFor: 'enumerating' stamp: 'len 8/18/2019 18:46:09'!
allSatisfy: aBlock
	^ components allSatisfy: aBlock! !

!DenseTuple methodsFor: 'enumerating' stamp: 'len 8/18/2019 18:49:31'!
anySatisfy: aBlock
	^ components anySatisfy: aBlock! !

!DenseTuple methodsFor: 'enumerating' stamp: 'len 8/4/2021 14:37:35'!
collect: aBlock
	| R |
	R _ self scalars.
	^ self class components: (components collect: [:each| R !! (aBlock value: each)]) parent: parent! !

!DenseTuple methodsFor: 'enumerating' stamp: 'len 8/12/2019 16:51:45'!
detect: aBlock ifNone: exceptionBlock 
	"Evaluate aBlock with each of the receiver's elements as the argument. 
	Answer the first element for which aBlock evaluates to true. If none 
	evaluate to true, then evaluate the argument, exceptionBlock."

	self do: [:each | (aBlock value: each) ifTrue: [^each]].
	^exceptionBlock value! !

!DenseTuple methodsFor: 'enumerating' stamp: 'len 8/18/2019 18:50:26'!
do: aBlock
	components do: aBlock! !

!DenseTuple methodsFor: 'enumerating' stamp: 'len 8/18/2019 18:45:55'!
findFirst: aBlock
	^ components findFirst: aBlock! !

!DenseTuple methodsFor: 'enumerating' stamp: 'len 8/18/2019 18:44:35'!
findLast: aBlock
	^ components findLast: aBlock! !

!DenseTuple methodsFor: 'enumerating' stamp: 'len 8/18/2019 18:45:37'!
reverseDo: aBlock
	components reverseDo: aBlock! !

!DenseTuple methodsFor: 'enumerating' stamp: 'len 8/18/2019 18:45:43'!
withIndexDo: aBlock
	components withIndexDo: aBlock! !

!DenseTuple methodsFor: 'testing' stamp: 'len 8/18/2019 18:50:44'!
includes: anObject
	^ components includes: anObject! !

!DenseTuple methodsFor: 'private' stamp: 'len 8/18/2019 18:50:39'!
at: anInteger put: anObject
	^ components at: anInteger put: anObject! !

!DenseTuple methodsFor: 'private' stamp: 'len 9/4/2019 12:54:27'!
components
	^ components! !

!DenseTuple methodsFor: 'private' stamp: 'len 5/28/2020 17:50:46'!
components: anArray
	components _ anArray asArray! !

!DenseTuple methodsFor: 'private' stamp: 'len 8/18/2019 18:45:24'!
swap: i with: j
	components swap: i with: j! !

!DenseTuple class methodsFor: 'instance creation' stamp: 'len 5/28/2020 17:50:40'!
components: anArray parent: aFreeModule
	^ self basicNew components: anArray; parent: aFreeModule! !

!DenseTuple class methodsFor: 'instance creation' stamp: 'len 11/5/2016 07:13'!
new
	^ self shouldNotImplement! !

!MultivariateTuple methodsFor: 'accessing' stamp: 'len 1/14/2022 13:54:47'!
ecart
	"Answer the ecart of the receiver. This is a measure of how far a tuple is from being homogeneous."
	self isZero ifTrue: [^ Infinity negative].
	^ (self max: [:each| each degree]) - self leadingMonomial degree! !

!MultivariateTuple methodsFor: 'accessing' stamp: 'len 1/13/2022 10:10:04'!
leadingCoefficient
	^ self at: self leadingMonomial! !

!MultivariateTuple methodsFor: 'accessing' stamp: 'len 4/11/2021 11:01:33'!
leadingMonomial
	^ leadingMonomial ifNil: [leadingMonomial _ self ordering leadingMonomialOf: self]! !

!MultivariateTuple methodsFor: 'accessing' stamp: 'len 1/13/2022 10:10:22'!
leadingTerm
	^ self termAt: self leadingMonomial! !

!MultivariateTuple methodsFor: 'accessing' stamp: 'len 1/13/2022 10:15:13'!
ordering
	^ parent ordering! !

!MultivariateTuple methodsFor: 'accessing' stamp: 'len 1/13/2022 10:10:35'!
tail
	^ self - self leadingTerm! !

!MultivariateTuple methodsFor: 'accessing' stamp: 'len 1/13/2022 10:10:43'!
termAt: aTupleMonomial
	^ (parent x: aTupleMonomial position) * ((self at: aTupleMonomial position) termAt: aTupleMonomial monomial)! !

!MultivariateTuple methodsFor: 'operations' stamp: 'len 7/27/2021 13:29:26'!
* anObject
	anObject class = TupleMonomial ifFalse: [^ super * anObject].
	^ (self parent x: anObject position) * ((self at: anObject position) * anObject monomial)! !

!MultivariateTuple methodsFor: 'operations' stamp: 'len 1/13/2022 09:14:11'!
// anObject
	anObject isCollection ifTrue: [^ (self divisionBy: anObject) quotients].
	anObject class = TupleMonomial ifTrue: [^ self withIndexCollect: [:each :i| i = anObject position ifTrue: [each // anObject monomial] ifFalse: [each]]].
	^ self collect: [:each| each // anObject]! !

!MultivariateTuple methodsFor: 'operations' stamp: 'len 1/13/2022 10:05:00'!
\\ anObject
	anObject isCollection ifTrue: [^ self reductionFullBy: anObject].
	^ self collect: [:each| each \\ anObject]! !

!MultivariateTuple methodsFor: 'operations' stamp: 'len 1/13/2022 09:23:17'!
divisionBy: anArray
	self scalars ordering isGlobal ifFalse: [^ self notYetImplemented].
	^ MultivariateDivision divide: self by: (anArray isCollection ifTrue: [anArray] ifFalse: [{anArray}])! !

!MultivariateTuple methodsFor: 'operations' stamp: 'len 1/13/2022 09:22:38'!
reductionBy: anArray
	"If the ordering is global answer a top-reduction of the receiver with respect to the argument (without doing tail reduction). Otherwise answer the Mora normal form."
	^ self scalars ordering isGlobal
		ifTrue: [self reductionGlobalBy: anArray]
		ifFalse: [self reductionMoraBy: anArray]! !

!MultivariateTuple methodsFor: 'operations' stamp: 'len 1/13/2022 10:05:13'!
reductionFullBy: anArray
	"Answer the tail-reduced normal form of the receiver with respect to the argument (doing full tail reduction).
	For an ordering that is not global, answer the Mora normal form."
	| g h |
	self scalars ordering isGlobal ifFalse: [^ self reductionMoraBy: anArray].
	g _ self.
	h _ g zero.
	[g isZero]
		whileFalse:
			[g _ g reductionGlobalBy: anArray.
			g isZero ifFalse: [h _ h + g leadingTerm. g _ g tail]].
	^ h! !

!MultivariateTuple methodsFor: 'operations' stamp: 'len 1/13/2022 09:12:50'!
reductionGlobalBy: anArray
	"Answer a top-reduction of the receiver with respect to the argument (without doing tail reduction)."
	| h |
	h _ self.
	[h isZero]
		whileFalse:
			[| lh lg g |
			lh _ h leadingMonomial.
			g _ anArray detect: [:one| (lg _ one leadingMonomial) | lh] ifNone: [^ h].
			h _ h + (g * (lh / lg) * (h leadingCoefficient negated / g leadingCoefficient))].
	^ h! !

!MultivariateTuple methodsFor: 'operations' stamp: 'len 1/13/2022 09:12:59'!
reductionMoraBy: anArray
	"Answer Mora's normal form of the receiver with respect to the argument."
	| h L m g ecartg |
	h _ self.
	L _ OrderedCollection withAll: anArray.
	[h isZero ifTrue: [^ h].
	m _ h leadingMonomial.
	g _ nil.
	ecartg _ -1.
	L do: [:each|
		| ecart |
		(each leadingMonomial | m and: [ecart _ each ecart. g isNil or: [ecart < ecartg]])
			ifTrue: [g _ each. ecartg _ ecart]].
	g isNil ifTrue: [^ h].
	ecartg > h ecart ifTrue: [L add: h].
	h _ h + (g * (m / g leadingMonomial) * (h leadingCoefficient negated / g leadingCoefficient))] repeat! !

!MultivariateTuple methodsFor: 'operations' stamp: 'len 7/30/2021 09:43:19'!
s: aTuple
	"Answer the S-tuple of the receiver with the argument."
	| h1 h2 lcm |
	h1 _ self leadingMonomial.
	h2 _ aTuple leadingMonomial.
	lcm _ (h1 lcm: h2) ifNil: [^ self zero].
	^ self * (lcm / h1) / self leadingCoefficient + (aTuple * (lcm / h2) / aTuple leadingCoefficient negated)! !

!MultivariateTuple methodsFor: 'enumerating' stamp: 'len 7/28/2021 10:18:46'!
monomialsDo: aBlock
	| ordering |
	ordering _ self ordering.
	self withIndexDo: [:fi :i|
		fi monomialsDo: [:m| aBlock value: (TupleMonomial new ordering: ordering; position: i; monomial: m)]]! !

!SparseTuple methodsFor: 'accessing' stamp: 'len 7/18/2020 05:41:20'!
at: key
	^ components at: key ifAbsent: [self scalars zero]! !

!SparseTuple methodsFor: 'accessing' stamp: 'len 7/18/2020 05:42:55'!
at: key ifAbsent: exceptionBlock
	^ components at: key ifAbsent: exceptionBlock! !

!SparseTuple methodsFor: 'accessing' stamp: 'len 7/18/2020 06:10:41'!
at: anObject ifPresent: aBlock
	^ components at: anObject ifPresent: aBlock! !

!SparseTuple methodsFor: 'accessing' stamp: 'len 7/18/2020 05:43:24'!
at: key put: value
	value isZero ifTrue: [components removeKey: key ifAbsent: []. ^ value].
	^ components at: key put: value! !

!SparseTuple methodsFor: 'accessing' stamp: 'len 7/18/2020 05:43:40'!
bitSize
	| answer |
	answer _ 0.
	components keysAndValuesDo: [:key :value| answer _ answer + key bitSize + value bitSize].
	^ answer! !

!SparseTuple methodsFor: 'accessing' stamp: 'len 7/18/2020 07:00:41'!
size
	^ components size! !

!SparseTuple methodsFor: 'comparing' stamp: 'len 7/18/2020 06:08:29'!
= anObject
	^ self class = anObject class and: [components = anObject components]! !

!SparseTuple methodsFor: 'comparing' stamp: 'len 7/18/2020 06:08:44'!
hash
	^ components hash! !

!SparseTuple methodsFor: 'enumerating' stamp: 'len 7/18/2020 07:02:56'!
collect: aBlock 
	| newComponents |
	newComponents _ Dictionary new: self size.
	components associationsDo: [:each| | newValue |
		(newValue _ aBlock value: each value) isZero ifFalse: [newComponents at: each key put: newValue]].
	^ self class components: newComponents parent: parent! !

!SparseTuple methodsFor: 'enumerating' stamp: 'len 7/18/2020 06:57:14'!
withIndexDo: elementAndIndexBlock 
	components keysAndValuesDo: [:key :value| elementAndIndexBlock value: value value: key]! !

!SparseTuple methodsFor: 'initialization' stamp: 'len 7/18/2020 07:04:57'!
components: aDictionary
	components _ aDictionary! !

!SparseTuple methodsFor: 'initialization' stamp: 'len 7/18/2020 05:37:44'!
initialize
	super initialize.
	components _ Dictionary new! !

!SparseTuple methodsFor: 'operations' stamp: 'len 7/18/2020 06:58:12'!
+ aTuple
	| other answer |
	(aTuple isTuple and: [self scalars = aTuple scalars]) ifFalse: [^ self adapt: aTuple andSend: #+].
	self size <= aTuple size
		ifTrue: [answer _ aTuple copy. other _ self]
		ifFalse: [answer _ self copy. other _ aTuple].
	other withIndexDo: [:each :index| answer at: index add: each].
	^ answer! !

!SparseTuple methodsFor: 'operations' stamp: 'len 7/18/2020 06:58:49'!
- aTuple
	| answer |
	(aTuple isTuple and: [self scalars = aTuple scalars]) ifFalse: [^ self adapt: aTuple andSend: #-].
	self size <= aTuple size
		ifTrue:
			[answer _ aTuple negated.
			self withIndexDo: [:each :index| answer at: index add: each]]
		ifFalse:
			[answer _ self copy.
			aTuple withIndexDo: [:each :index| answer at: index add: each negated]].
	^ answer! !

!SparseTuple methodsFor: 'operations' stamp: 'len 7/18/2020 06:59:44'!
 aTuple
	| answer |
	answer _ self scalars zero.
	self withIndexDo: [:each :index|
		aTuple at: index ifPresent: [:other| answer _ each*other + answer]].
	^ answer! !

!SparseTuple methodsFor: 'operations' stamp: 'len 7/18/2020 07:00:07'!
negated
	^ self copy components associationsDo: [:each| each value: each value negated]! !

!SparseTuple methodsFor: 'operations' stamp: 'len 7/27/2020 15:48:16'!
weight
	"Answer the Hamming weight of the receiver, i.e. the number of entries that are not zero."
	^ components size! !

!SparseTuple methodsFor: 'private' stamp: 'len 7/18/2020 05:41:14'!
at: key add: value
	^ components at: key addAndRemoveIfZero: value! !

!SparseTuple methodsFor: 'private' stamp: 'len 7/18/2020 06:04:59'!
components
	^ components! !

!SparseTuple class methodsFor: 'instance creation' stamp: 'len 7/18/2020 07:03:57'!
components: anArrayOrDictionary parent: aFreeModule
	| answer |
	anArrayOrDictionary class = Dictionary
		ifTrue: [^ self basicNew components: anArrayOrDictionary; parent: aFreeModule].
	answer _ self new parent: aFreeModule.
	anArrayOrDictionary withIndexDo: [:each :i| each isZero ifFalse: [answer at: i put: each]].
	^ answer! !

!BitTuple methodsFor: 'operations' stamp: 'len 5/15/2019 23:57:46'!
* aBit
	aBit isMatrix ifTrue: [^ super * aBit].
	^ ((aBit isInteger and: [aBit even]) or: [aBit isZero]) ifTrue: [self zero] ifFalse: [self]! !

!BitTuple methodsFor: 'operations' stamp: 'len 5/28/2020 14:27:21'!
+ aBitTuple
	^ self class
		bits: (bits bitXor: aBitTuple asInteger)
		parent: (self size >= aBitTuple size ifTrue: [parent] ifFalse: [aBitTuple parent])! !

!BitTuple methodsFor: 'operations' stamp: 'len 3/28/2016 06:51'!
- aBitTuple
	^ self + aBitTuple! !

!BitTuple methodsFor: 'operations' stamp: 'len 5/28/2020 14:30:57'!
>>> anInteger
	anInteger = 0 ifTrue: [^ self].
	^ self class bits: (bits bitShift: anInteger) parent: self scalars^(self size + anInteger max: 0)! !

!BitTuple methodsFor: 'operations' stamp: 'len 5/8/2019 03:09:41'!
 aBitTuple
	^ (bits bitAnd: aBitTuple asInteger) bitParity = 0 ifTrue: [Zero] ifFalse: [One]

"	^ self hadamard: aBitTuple :: sum
"

"	| x |
	x _ self asInteger bitAnd: aBitTuple asInteger.
	[x > 1]
		whileTrue: [x _ x >> (x highBit // 2) bitAnd: x].
	^ x"! !

!BitTuple methodsFor: 'operations' stamp: 'len 5/29/2020 07:47:48'!
convolution: aBitTuple
	| a b c |
	a _ bits.
	b _ aBitTuple asInteger.
	c _ 0.
	1 to: a highBit do: [:i|
		(a bitAt: i) = 1 ifTrue: [c _ c bitXor: b].
		b _ b bitShift: 1].
	^ self class bits: c parent: self scalars ^ (self size + aBitTuple size - 1 max: 0)! !

!BitTuple methodsFor: 'operations' stamp: 'len 5/28/2020 14:34:18'!
hadamard: aBitTuple
	"Answer the entrywise product with the argument, also called Hadamard product."
	^ self class bits: (bits bitAnd: aBitTuple asInteger) parent: (self size <= aBitTuple size ifTrue: [parent] ifFalse: [aBitTuple parent])! !

!BitTuple methodsFor: 'operations' stamp: 'len 7/10/2020 17:23:55'!
length
	^ self norm! !

!BitTuple methodsFor: 'operations' stamp: 'len 5/8/2019 03:09:27'!
lift
	"Answer a representative integer tuple."
	^ self representative! !

!BitTuple methodsFor: 'operations' stamp: 'len 3/28/2016 07:30'!
negated
	^ self! !

!BitTuple methodsFor: 'operations' stamp: 'len 7/10/2020 17:25:49'!
norm
	self flag: #fix. "this assumes the inner product is the dot product"
	^ self sum! !

!BitTuple methodsFor: 'operations' stamp: 'len 5/8/2019 03:08:16'!
parity
	"Answer 1 if the receiver has an odd number of bits on, 0 if it has an even number of bits on."
	| n parity |
	bits = 0 ifTrue: [^ 0].
"	n _ bits >> (bits lowBit - 1). skip initial zeros, we could also skip chunks of zeros in the middle"
	n _ bits.
	parity _ 0.
	[n = 0] whileFalse: [parity _ parity bitXor: (n bitAnd: 1). n _ n >> 1].
	^ parity! !

!BitTuple methodsFor: 'operations' stamp: 'len 5/29/2020 19:40:07'!
polynomialDivisionBy: aTuple
	| q r b n m |
	b _ aTuple asInteger.
	(m _ b highBit) = 0 ifTrue: [^ (ZeroDivide receiver: self selector: #polynomialDivisionBy: argument: aTuple) signal].
	q _ 0.
	r _ self asInteger.
	[(n _ r highBit) >= m] "n = degree(r)+1"
		whileTrue:
			[| i |
			i _ n-m.
			q _ q bitXor: 1 << i. "wasting some memory while creating 2^i"
			r _ r bitXor: b << i]. "also wasting some memory here"
	^ {self class newFrom: q. self class newFrom: r}! !

!BitTuple methodsFor: 'operations' stamp: 'len 5/29/2020 19:40:15'!
polynomialRemainderOfDivisionBy: aTuple
	| r b n m |
	b _ aTuple asInteger.
	(m _ b highBit) = 0 ifTrue: [^ (ZeroDivide receiver: self selector: #polynomialRemainderOfDivisionBy: argument: aTuple) signal].
	r _ self asInteger.
	[(n _ r highBit) >= m] "n = degree(r)+1"
		whileTrue:
			[r _ r bitXor: b << (n-m)]. "wasting some memory here"
	^ self class newFrom: r! !

!BitTuple methodsFor: 'operations' stamp: 'len 11/23/2016 05:42:05'!
polynomialValue: anObject
	Zero = anObject ifTrue: [^ self at: 1].
	One = anObject ifFalse: [^ super polynomialValue: anObject].
	^ self sum! !

!BitTuple methodsFor: 'operations' stamp: 'len 5/28/2020 14:25:18'!
reversed
	^ self class bits: (bits bitReverse: self size) parent: parent! !

!BitTuple methodsFor: 'operations' stamp: 'len 5/8/2019 02:58:43'!
sum
	"Answer the sum of the bits, i.e. the parity."
	^ bits bitParity = 0 ifTrue: [Zero] ifFalse: [One]! !

!BitTuple methodsFor: 'operations' stamp: 'len 11/12/2016 08:41'!
weight
	"Answer the Hamming weight of the receiver, i.e. the number of entries that are not zero."
	^ self asInteger bitCount! !

!BitTuple methodsFor: 'accessing' stamp: 'len 5/8/2019 02:58:37'!
at: anInteger
	^ (bits bitAt: anInteger) = 1 ifTrue: [One] ifFalse: [Zero]! !

!BitTuple methodsFor: 'accessing' stamp: 'len 1/1/2022 21:56:38'!
at: anInteger put: aBit
	| bit |
	anInteger > self size ifTrue: [self error: 'index out of bounds'].
	bit _ aBit.
	bit isInteger ifTrue: [bit _ bit even ifTrue: [Zero] ifFalse: [One]].
	(self at: anInteger) = bit
		ifFalse: [bits _ bits bitXor: (1 bitShift: anInteger - 1)].
	^ bit! !

!BitTuple methodsFor: 'accessing' stamp: 'len 7/19/2020 08:06:56'!
bitAt: anInteger
	^ bits bitAt: anInteger! !

!BitTuple methodsFor: 'accessing' stamp: 'len 7/19/2020 08:08:54'!
bitAt: anInteger put: oneOrZero
	anInteger > self size ifTrue: [self error: 'index out of bounds'].
	(self bitAt: anInteger) = oneOrZero
		ifFalse: [bits _ bits bitXor: 1 << (anInteger - 1)].
	^ oneOrZero! !

!BitTuple methodsFor: 'accessing' stamp: 'len 1/2/2022 09:56:51'!
depth
	"Answer the index of the last nonzero entry, or 0.
	(Instead, Magma defines this as the index of the *first* nonzero entry.)
	See >>pivot for the index of the first nonzero entry."
	^ bits highBit! !

!BitTuple methodsFor: 'accessing' stamp: 'len 5/29/2020 15:21:10'!
representative
	"Answer a representative integer tuple."
	^ parent lift filling: [:i| bits bitAt: i]! !

!BitTuple methodsFor: 'accessing' stamp: 'len 5/4/2018 19:09:27'!
scalars
	^ One parent! !

!BitTuple methodsFor: 'comparing' stamp: 'len 7/27/2020 08:43:41'!
= anObject
	^ self class = anObject class and: [bits = anObject asInteger]! !

!BitTuple methodsFor: 'comparing' stamp: 'len 5/8/2019 03:06:15'!
hash
	^ bits hash! !

!BitTuple methodsFor: 'constants' stamp: 'len 5/28/2020 14:24:55'!
zero
	^ self class bits: 0 parent: parent! !

!BitTuple methodsFor: 'converting' stamp: 'len 5/8/2019 03:10:19'!
asInteger
	^ bits! !

!BitTuple methodsFor: 'copying' stamp: 'len 5/28/2020 14:29:53'!
, anObject
	anObject isTuple
		ifTrue: [^ self class bits: (bits bitXor: (anObject asInteger bitShift: self size)) parent: self scalars^(self size+anObject size)].
	^ self copyWith: anObject! !

!BitTuple methodsFor: 'copying' stamp: 'len 1/1/2022 21:09:00'!
copyFrom: start to: stop 
	"Answer a copy of a subset of the receiver, starting from element at 
	index start until element at index stop."
	| n |
	n _ stop - start + 1 max: 0.
	^ self class bits: ((bits bitShift: 1 - start) bitAnd: (1 bitShift: n) - 1) parent: self scalars^n! !

!BitTuple methodsFor: 'copying' stamp: 'len 5/28/2020 14:24:12'!
copyWith: aBit
	| answer |
	answer _ self class bits: bits parent: self scalars^(self size + 1).
	aBit = One ifTrue: [answer at: self size+1 put: One. ^ answer].
	aBit = Zero ifFalse: [DomainError signal].
	^ answer! !

!BitTuple methodsFor: 'enumerating' stamp: 'len 11/5/2016 09:14'!
anySatisfy: aBlock
	"Optimized. There are only two possible elements that could satisfy aBlock (1 or 0)."
	self isEmpty ifTrue: [^ false].
	(self isZero not and: [aBlock value: One]) ifTrue: [^ true].
	^ (aBlock value: Zero) and: [super anySatisfy: [:any| any = Zero]]! !

!BitTuple methodsFor: 'testing' stamp: 'len 1/3/2022 18:29:45'!
isZero
	^ bits == 0! !

!BitTuple methodsFor: 'testing' stamp: 'len 12/30/2021 11:34:15'!
isZeroAt: anInteger
	^ (bits bitAt: anInteger) = 0! !

!BitTuple methodsFor: 'private' stamp: 'len 5/8/2019 03:03:28'!
bits: anInteger
	bits _ anInteger! !

!BitTuple class methodsFor: 'initialization' stamp: 'len 5/23/2020 08:58:58'!
initialize
	| Z2 |
	super initialize.
	Z2 _  / 2.
	One _ Z2 one.
	Zero _ Z2 zero! !

!BitTuple class methodsFor: 'instance creation' stamp: 'len 1/1/2022 20:27:22'!
bits: anInteger parent: aFreeModule
	self assert: anInteger highBit <= aFreeModule rank.
	^ self basicNew bits: anInteger; parent: aFreeModule! !

!BitTuple class methodsFor: 'instance creation' stamp: 'len 5/28/2020 14:51:42'!
components: anArray parent: aFreeModule
	| answer |
	answer _ self bits: 0 parent: aFreeModule.
	anArray withIndexDo: [:each :i| answer at: i put: each].
	^ answer! !

!BitTuple class methodsFor: 'instance creation' stamp: 'len 11/5/2016 07:09'!
new
	^ self shouldNotImplement! !

!BitTuple class methodsFor: 'instance creation' stamp: 'len 5/28/2020 14:38:16'!
newFrom: anInteger
	anInteger isInteger ifTrue: [^ self bits: anInteger parent: One parent^anInteger highBit].
	^ super newFrom: anInteger! !

!ModularTuple methodsFor: 'accessing' stamp: 'len 5/28/2020 13:18:42'!
at: anInteger
	^ self scalars representative: (representatives at: anInteger ifAbsent: [^ self scalars zero])! !

!ModularTuple methodsFor: 'accessing' stamp: 'len 5/28/2020 13:19:19'!
at: anInteger put: anElement
	anElement isInteger ifTrue: [^ representatives at: anInteger put: anElement \\ self scalars modulus].
	representatives at: anInteger put: anElement representative.
	^ anElement! !

!ModularTuple methodsFor: 'accessing' stamp: 'len 1/6/2022 14:25:27'!
depth
	"Answer the index of the last nonzero entry, or 0.
	(Instead, Magma defines this as the index of the *first* nonzero entry.)
	See >>pivot for the index of the first nonzero entry."
	representatives size to: 1 by: -1 do: [:i| (representatives at: i) == 0 ifFalse: [^ i]].
	^ 0! !

!ModularTuple methodsFor: 'accessing' stamp: 'len 4/4/2021 09:51:28'!
lift
	"Answer a balanced representative integer tuple."
	| m h |
	m _ self scalars modulus.
	h _ m >> 1.
	^ parent lift filling: [:i| | r | r _ representatives at: i. r <= h ifTrue: [r] ifFalse: [r - m]]! !

!ModularTuple methodsFor: 'accessing' stamp: 'len 1/6/2022 14:25:11'!
pivot
	"Answer the index of the first nonzero entry, or nil.
	See >>depth for the index of the last nonzero entry."
	1 to: representatives size do: [:i| (representatives at: i) == 0 ifFalse: [^ i]].
	^ nil! !

!ModularTuple methodsFor: 'accessing' stamp: 'len 5/29/2020 15:22:21'!
representative
	"Answer a representative integer tuple."
	^ parent lift elementAt: representatives! !

!ModularTuple methodsFor: 'accessing' stamp: 'len 7/26/2020 13:29:14'!
size
	^ representatives size! !

!ModularTuple methodsFor: 'comparing' stamp: 'len 4/15/2021 09:37:30'!
= anObject
	| n otherRepresentatives |
	(self class = anObject class and: [self scalars = anObject scalars]) ifFalse: [^ false].
	otherRepresentatives _ anObject representatives.
	(n _ representatives size) = otherRepresentatives size ifFalse:
		[(n _ self depth) = anObject depth ifFalse: [^ false]].
	1 to: n do: [:i| (representatives at: i) = (otherRepresentatives at: i) ifFalse: [^ false]].
	^ true! !

!ModularTuple methodsFor: 'comparing' stamp: 'len 7/27/2020 08:39:57'!
hash
	| answer |
	answer _ 0.
	representatives do: [:each| each = 0 ifFalse: [answer _ answer hashMultiply + each hash]].
	^ answer! !

!ModularTuple methodsFor: 'copying' stamp: 'len 5/28/2020 14:35:37'!
, anObject
	anObject isTuple
		ifTrue:
			[self scalars = anObject scalars ifFalse: [^ DomainError signal].
			^ self class representatives: representatives, anObject representatives parent: self scalars^(self size + anObject size)].
	^ self copyWith: anObject! !

!ModularTuple methodsFor: 'copying' stamp: 'len 5/28/2020 14:35:50'!
copy
	^ self class representatives: representatives copy parent: parent! !

!ModularTuple methodsFor: 'copying' stamp: 'len 5/28/2020 14:35:56'!
copyFrom: start to: stop
	^ self class representatives: (representatives copyFrom: start to: stop) parent: self scalars^(stop-start+1)! !

!ModularTuple methodsFor: 'copying' stamp: 'len 5/28/2020 14:36:06'!
copyWith: anElement
	(self scalars includes: anElement) ifFalse: [^ DomainError signal].
	^ self class representatives: (representatives copyWith: anElement representative) parent: self scalars^(self size + 1)! !

!ModularTuple methodsFor: 'operations' stamp: 'len 5/28/2020 14:35:16'!
* anElement
	| modulus x array |
	anElement isMatrix ifTrue: [^ super * anElement].
	x _ anElement isInteger ifTrue: [anElement] ifFalse: [anElement representative].
	modulus _ self scalars modulus.
	array _ representatives copy.
	1 to: self size do: [:i| array at: i put: (array at: i) * x \\ modulus].
	^ self class representatives: array parent: parent! !

!ModularTuple methodsFor: 'operations' stamp: 'len 5/29/2020 19:53:28'!
+ aTuple
	| modulus a an b bn c |
	(an _ self size) <= (bn _ aTuple size) ifFalse: [^ aTuple + self].
	modulus _ self scalars modulus.
	a _ representatives.
	b _ aTuple representatives.
	c _ representatives class new: bn.
	1 to: an do: [:i| c at: i put: (a at: i) + (b at: i) \\ modulus].
	c replaceFrom: an+1 to: bn with: b startingAt: an+1.
	^ self class representatives: c parent: aTuple parent! !

!ModularTuple methodsFor: 'operations' stamp: 'len 5/28/2020 13:18:02'!
 aTuple
	| modulus representatives2 answer |
	(aTuple class = self class and: [self scalars = aTuple scalars])
		ifFalse: [^ super  aTuple].
	modulus _ self scalars modulus.
	representatives2 _ aTuple representatives.
	answer _ 0.
	1 to: (representatives size min: representatives2 size) do: [:i|
		answer _ (representatives at: i) * (representatives2 at: i) + answer \\ modulus].
	^ self scalars representative: answer! !

!ModularTuple methodsFor: 'operations' stamp: 'len 3/11/2021 17:20:32'!
add: aTuple times: aNumber from: startIndex to: stopIndex
	| m representatives2 x |
	(self class = aTuple class "and: [self scalars = aTuple scalars]")
		ifFalse: [^ super add: aTuple times: aNumber from: startIndex to: stopIndex].
	m _ self scalars modulus.
	representatives2 _ aTuple representatives.
	x _ aNumber representative.
	0 = x ifTrue: [^ self].
	startIndex to: stopIndex do: [:i|
		| y |
		y _ (representatives2 at: i) * x + (representatives at: i).
		y >= m ifTrue: [y _ y \\ m].
		representatives at: i put: y]! !

!ModularTuple methodsFor: 'operations' stamp: 'len 5/28/2020 14:35:44'!
convolution: aTuple
	| modulus array |
	self isEmpty ifTrue: [^ self].
	aTuple isEmpty ifTrue: [^ aTuple].
	modulus _ self scalars modulus.
	array _ representatives class new: self size + aTuple size - 1.
	array atAllPut: 0. "in case it's Array"
	representatives withIndexDo: [:xi :i|
		xi = 0 ifFalse:
			[aTuple representatives withIndexDo: [:yj :j| | index |
				index _ i+j-1.
				array at: index put: xi*yj + (array at: index) \\ modulus]]].
	^ self class representatives: array parent: self scalars^array size! !

!ModularTuple methodsFor: 'operations' stamp: 'len 5/28/2020 14:36:16'!
hadamard: aTuple
	| modulus c b answerParent |
	(self class = aTuple class and: [self scalars = aTuple scalars])
		ifFalse: [^ super hadamard: aTuple].
	modulus _ self scalars modulus.
	answerParent _ self size <= aTuple size ifTrue: [parent] ifFalse: [aTuple parent].
	c _ representatives class new: answerParent rank.
	b _ aTuple representatives.
	1 to: c size do: [:i| c at: i put: (representatives at: i) * (b at: i) \\ modulus].
	^ self class representatives: c parent: answerParent! !

!ModularTuple methodsFor: 'operations' stamp: 'len 3/11/2021 17:22:19'!
multiplyBy: aNumber from: startIndex to: stopIndex
	| m x |
	m _ self modulus.
	x _ aNumber representative.
	startIndex to: stopIndex do: [:i|
		| y |
		y _ (representatives at: i) * x.
		y >= m ifTrue: [y _ y \\ m].
		representatives at: i put: y]! !

!ModularTuple methodsFor: 'operations' stamp: 'len 5/28/2020 14:36:27'!
negated
	| modulus array |
	array _ representatives copy.
	modulus _ self modulus.
	1 to: self size do: [:i| array at: i put: (array at: i) negated \\ modulus].
	^ self class representatives: array parent: parent! !

!ModularTuple methodsFor: 'operations' stamp: 'len 5/29/2020 19:42:36'!
polynomialDivisionBy: aTuple
	| quo q rem r bmInv n m b modulus |
	aTuple isZero ifTrue: [^ (ZeroDivide receiver: self selector: #polynomialDivisionBy: argument: aTuple) signal].
	quo _ self zero.
	q _ quo representatives.
	rem _ self copy.
	r _ rem representatives.
	m _ aTuple depth. "m = degree(self)+1"
	bmInv _ (aTuple at: m) inverse representative.
	b _ aTuple representatives.
	modulus _ self modulus.
	[(n _ rem depth) >= m] "n = degree(rem)+1"
		whileTrue:
			[| i c |
			i _ n-m+1.
			c _ (r at: n) * bmInv \\ modulus. "<- is it better to reduce or not reduce here?"
			q at: i put: (q at: i) + c \\ modulus.
			1 to: m do: [:j| r at: j+i-1 put: (r at: j+i-1) - ((b at: j)*c) \\ modulus]].
	^ {quo. rem}! !

!ModularTuple methodsFor: 'operations' stamp: 'len 5/29/2020 19:42:51'!
polynomialPartialDivisionBy: aTuple
	| quo q rem r n m b bm modulus |
	aTuple isZero ifTrue: [^ (ZeroDivide receiver: self selector: #polynomialPartialDivisionBy: argument: aTuple) signal].
	quo _ self zero.
	q _ quo representatives.
	rem _ self copy.
	r _ rem representatives.
	m _ aTuple depth. "m = degree(self)+1"
	b _ aTuple representatives.
	bm _ b at: m.
	modulus _ self modulus.
	[(n _ rem depth) >= m] "n = degree(rem)+1"
		whileTrue:
			[| i c |
			i _ n-m+1.
			c _ (r at: n) quotientBy: bm modulo: modulus.
			c = 0 ifTrue: [^ {quo. rem}].
			q at: i put: (q at: i) + c \\ modulus.
			1 to: m do: [:j| r at: j+i-1 put: (r at: j+i-1) - ((b at: j)*c) \\ modulus]].
	^ {quo. rem}! !

!ModularTuple methodsFor: 'operations' stamp: 'len 5/29/2020 19:42:57'!
polynomialRemainderOfDivisionBy: aTuple
	| rem r bmInv n m b modulus |
	aTuple isZero ifTrue: [^ (ZeroDivide receiver: self selector: #polynomialRemainderOfDivisionBy: argument: aTuple) signal].
	rem _ self copy.
	r _ rem representatives.
	m _ aTuple depth. "m = degree(self)+1"
	bmInv _ (aTuple at: m) inverse representative.
	b _ aTuple representatives.
	modulus _ self modulus.
	[(n _ rem depth) >= m] "n = degree(rem)+1"
		whileTrue:
			[| i c |
			i _ n-m+1.
			c _ (r at: n) * bmInv \\ modulus. "<- is it better to reduce or not reduce here?"
			1 to: m do: [:j| r at: j+i-1 put: (r at: j+i-1) - ((b at: j)*c) \\ modulus]].
	^ rem! !

!ModularTuple methodsFor: 'operations' stamp: 'len 5/29/2020 19:43:05'!
polynomialRemainderOfPartialDivisionBy: aTuple
	| rem r n m b bm modulus |
	aTuple isZero ifTrue: [^ (ZeroDivide receiver: self selector: #polynomialRemainderOfPartialDivisionBy: argument: aTuple) signal].
	rem _ self copy.
	r _ rem representatives.
	m _ aTuple depth. "m = degree(self)+1"
	b _ aTuple representatives.
	bm _ b at: m.
	modulus _ self modulus.
	[(n _ rem depth) >= m] "n = degree(rem)+1"
		whileTrue:
			[| i c |
			i _ n-m+1.
			c _ (r at: n) quotientBy: bm modulo: modulus.
			c = 0 ifTrue: [^ rem].
			1 to: m do: [:j| r at: j+i-1 put: (r at: j+i-1) - ((b at: j)*c) \\ modulus]].
	^ rem! !

!ModularTuple methodsFor: 'operations' stamp: 'len 5/28/2020 13:25:10'!
polynomialValue: anElement
	| modulus x answer |
	(self scalars includes: anElement)
		ifFalse: [^ super polynomialValue: anElement].
	modulus _ self modulus.
	x _ anElement representative.
	answer _ 0.
	representatives reverseDo: [:each| answer _ x * answer + each \\ modulus].
	^ self scalars representative: answer! !

!ModularTuple methodsFor: 'operations' stamp: 'len 5/28/2020 14:36:34'!
reversed
	^ self class representatives: representatives reversed parent: parent! !

!ModularTuple methodsFor: 'operations' stamp: 'len 12/3/2016 09:13:11'!
weight
	"Answer the Hamming weight of the receiver, i.e. the number of entries that are not zero."
	^ representatives count: [:each| each ~~ 0]! !

!ModularTuple methodsFor: 'testing' stamp: 'len 12/5/2016 17:54:18'!
isZero
	1 to: representatives size do: [:i| (representatives at: i) == 0 ifFalse: [^ false]].
	^ true! !

!ModularTuple methodsFor: 'testing' stamp: 'len 12/30/2021 11:34:38'!
isZeroAt: anInteger
	^ (representatives at: anInteger) = 0! !

!ModularTuple methodsFor: 'testing' stamp: 'len 4/12/2021 12:28:13'!
isZeroFrom: start to: stop
	start to: stop do: [:i| (representatives at: i) == 0 ifFalse: [^ false]].
	^ true! !

!ModularTuple methodsFor: 'private' stamp: 'len 5/28/2020 13:23:21'!
modulus
	^ self scalars modulus! !

!ModularTuple methodsFor: 'private' stamp: 'len 3/31/2016 07:43'!
representatives
	^ representatives! !

!ModularTuple methodsFor: 'private' stamp: 'len 12/1/2016 16:36:25'!
representatives: anArray
	representatives _ anArray
"	representatives do: [:each| (each between: 0 and: modulus) ifFalse: [self halt]]"! !

!ModularTuple class methodsFor: 'instance creation' stamp: 'len 3/25/2021 14:46:18'!
components: anArray parent: aFreeModule
	| n array |
	n _ anArray size.
	array _ self representativesArrayClass new: n.
	1 to: n do: [:i| array at: i put: (anArray at: i) representative].
	^ self representatives: array parent: aFreeModule! !

!ModularTuple class methodsFor: 'instance creation' stamp: 'len 5/28/2020 13:13:06'!
representatives: anArray parent: aFreeModule
	^ self basicNew parent: aFreeModule; representatives: anArray! !

!ModularTuple class methodsFor: 'private' stamp: 'len 3/25/2021 14:46:36'!
representativesArrayClass
	^ Array! !

!ByteModularTuple class methodsFor: 'private' stamp: 'len 3/25/2021 14:47:10'!
representativesArrayClass
	^ ByteArray! !

!WordModularTuple class methodsFor: 'private' stamp: 'len 3/25/2021 14:47:23'!
representativesArrayClass
	^ WordArray! !

!ModuleTuple methodsFor: 'accessing' stamp: 'len 4/25/2020 07:15:45'!
at: anInteger
	^ components at: anInteger! !

!ModuleTuple methodsFor: 'accessing' stamp: 'len 4/25/2020 09:29:24'!
coordinates
	^ components inject: (self scalars tuple: #()) into: [:answer :each| answer, each coordinates]! !

!ModuleTuple methodsFor: 'accessing' stamp: 'len 4/25/2020 07:15:52'!
parent
	^ parent! !

!ModuleTuple methodsFor: 'accessing' stamp: 'len 4/25/2020 07:15:56'!
size
	^ components size! !

!ModuleTuple methodsFor: 'comparing' stamp: 'len 4/25/2020 07:16:08'!
= anObject
	^ self class = anObject class and: [components = anObject components]! !

!ModuleTuple methodsFor: 'comparing' stamp: 'len 4/25/2020 07:16:03'!
hash
	^ components hash! !

!ModuleTuple methodsFor: 'operations' stamp: 'len 5/3/2020 12:52:25'!
* anElement
	anElement isInteger ifTrue: [^ self class new parent: parent; components: components * anElement].
	(parent scalars includes: anElement) ifTrue: [^ self class new parent: parent; components: components * anElement].
	^ DomainError signal! !

!ModuleTuple methodsFor: 'operations' stamp: 'len 4/25/2020 07:16:30'!
+ anElement
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #+].
	^ self class new parent: parent; components: components + anElement components! !

!ModuleTuple methodsFor: 'operations' stamp: 'len 4/25/2020 07:16:38'!
negated
	^ self class new parent: parent; components: (components collect: [:each| each negated])! !

!ModuleTuple methodsFor: 'testing' stamp: 'len 4/25/2020 09:26:58'!
isZero
	^ components allSatisfy: [:each| each isZero]! !

!ModuleTuple methodsFor: 'private' stamp: 'len 4/25/2020 07:19:10'!
components
	^ components! !

!ModuleTuple methodsFor: 'private' stamp: 'len 4/25/2020 07:19:06'!
components: anArray
	components _ anArray! !

!ModuleTuple methodsFor: 'private' stamp: 'len 4/25/2020 07:19:01'!
parent: aDirectSumModule
	parent _ aDirectSumModule! !

!Sum methodsFor: 'printing' stamp: 'len 2/25/2017 09:43:39'!
printCoefficient: coefficient on: aStream
	| c |
	((c _ coefficient) printString first = $- "or: [coefficient isNumber and: [coefficient negative]]")
		ifTrue: [aStream nextPut: $-. c _ c negated].
	((c isKindOf: Polynomial) and: [c isMonomial])
		ifTrue: [aStream print: c. ^ self].
	(c printString allSatisfy: [:each| each isAlphaNumeric or: ['{}()/' includes: each]])
		ifTrue: [aStream print: c. ^ self].
	aStream nextPut: $(; print: c; nextPut: $)! !

!Sum methodsFor: 'printing' stamp: 'len 2/28/2017 08:43:47'!
printLiteral: anObject on: aStream
	((anObject isKindOf: Word) and: [anObject isEmpty])
		ifTrue: [^ self].
	anObject isInteger
		ifTrue:
			[aStream isText
				ifTrue: [aStream nextPut: $x; nextPutAll: anObject printString sub]
				ifFalse: [aStream nextPutAll: '{x', anObject printString, '}'].
			^ self].
	(aStream isText and: [anObject isString])
			ifTrue: [aStream nextPutAll: anObject asText]
			ifFalse: [aStream print: anObject]! !

!Sum methodsFor: 'printing' stamp: 'len 2/25/2017 08:38:18'!
printOn2: aStream
	aStream nextPut: $(.
	(Iterator on: self performing: #associationsDo:)
		do: [:each| aStream print: each] separatedBy: [aStream nextPutAll: ', '].
	aStream nextPut: $)! !

!Sum methodsFor: 'accessing' stamp: 'len 1/10/2018 21:04:34'!
at: anObject
	^ coefficients at: anObject ifAbsent: [self scalars zero]! !

!Sum methodsFor: 'accessing' stamp: 'len 11/18/2016 10:02:25'!
at: key add: value
	^ coefficients at: key addAndRemoveIfZero: value! !

!Sum methodsFor: 'accessing' stamp: 'len 11/18/2016 17:29:29'!
at: anObject ifAbsent: aBlock
	^ coefficients at: anObject ifAbsent: aBlock! !

!Sum methodsFor: 'accessing' stamp: 'len 11/18/2016 17:29:44'!
at: anObject ifPresent: aBlock
	^ coefficients at: anObject ifPresent: aBlock! !

!Sum methodsFor: 'accessing' stamp: 'len 11/18/2016 17:27:44'!
at: key put: value
	value isZero ifTrue: [coefficients removeKey: key ifAbsent: []. ^ value].
	^ coefficients at: key put: value! !

!Sum methodsFor: 'accessing' stamp: 'len 7/22/2020 09:33:46'!
bitSize
	| answer |
	answer _ 0.
	coefficients withSupportDo: [:value :key| answer _ answer + key bitSize + value bitSize].
	^ answer! !

!Sum methodsFor: 'accessing' stamp: 'len 4/23/2018 21:08:15'!
denominator
	| answer |
	self scalars isLocalization ifFalse: [^ self scalars one].
	answer _ self scalars integers one.
	self do: [:each| answer _ each denominator lcm: answer].
	^ answer! !

!Sum methodsFor: 'accessing' stamp: 'len 11/18/2016 20:33:21'!
keys
	^ coefficients keys! !

!Sum methodsFor: 'accessing' stamp: 'len 4/23/2018 21:08:38'!
numerator
	self scalars isLocalization ifFalse: [^ self].
	^ self * self denominator over: self scalars integers! !

!Sum methodsFor: 'accessing' stamp: 'len 7/21/2020 17:39:14'!
parent
	^ parent! !

!Sum methodsFor: 'accessing' stamp: 'len 4/23/2018 20:40:20'!
representative
	"If the coefficients ring is a quotient R/I, answer a representative of the receiver over R. See >>%."
	^ self apply: self scalars projection section! !

!Sum methodsFor: 'accessing' stamp: 'len 1/10/2018 19:57:14'!
scalars
	^ parent scalars! !

!Sum methodsFor: 'accessing' stamp: 'len 11/18/2016 09:55:05'!
size
	^ coefficients size! !

!Sum methodsFor: 'accessing' stamp: 'len 1/10/2018 21:09:50'!
zero
	^ parent zero! !

!Sum methodsFor: 'comparing' stamp: 'len 7/23/2020 08:15:05'!
= aSum
	^ coefficients = aSum coefficients! !

!Sum methodsFor: 'comparing' stamp: 'len 11/18/2016 20:11:39'!
hash
	^ coefficients hash! !

!Sum methodsFor: 'converting' stamp: 'len 1/10/2018 21:09:44'!
over: aRing
	| newCoefficients |
	self scalars = aRing ifTrue: [^ self].
	newCoefficients _ Dictionary new: self size.
	self associationsDo: [:each| | newValue |
		(newValue _ aRing !! each value) isZero
			ifFalse: [newCoefficients add: (each copy value: newValue)]].
	^ (self class coefficients: newCoefficients) parent: (parent over: aRing)! !

!Sum methodsFor: 'enumerating' stamp: 'len 11/18/2016 09:54:31'!
associationsDo: aBlock
	coefficients associationsDo: aBlock! !

!Sum methodsFor: 'enumerating' stamp: 'len 1/10/2018 21:43:05'!
coefficientsDo: aBlock
	coefficients do: aBlock! !

!Sum methodsFor: 'enumerating' stamp: 'len 1/10/2018 21:22:05'!
collect: aBlock 
	| newCoefficients |
	newCoefficients _ Dictionary new: self size.
	self associationsDo: [:each| | newValue |
		(newValue _ aBlock value: each value) isZero ifFalse: [newCoefficients at: each key put: newValue]].
	^ (self class coefficients: newCoefficients) parent: parent! !

!Sum methodsFor: 'enumerating' stamp: 'len 11/18/2016 09:54:10'!
collectNoZero: aBlock
	"The result of aBlock must never be zero."
	^ self copy associationsDo: [:each| each value: (aBlock value: each value)]! !

!Sum methodsFor: 'enumerating' stamp: 'len 11/18/2016 20:24:16'!
do: aBlock
	coefficients do: aBlock! !

!Sum methodsFor: 'enumerating' stamp: 'len 11/18/2016 17:45:00'!
keysAndValuesDo: aBlock
	coefficients keysAndValuesDo: aBlock! !

!Sum methodsFor: 'enumerating' stamp: 'len 11/18/2016 17:45:38'!
keysDo: aBlock
	coefficients keysDo: aBlock! !

!Sum methodsFor: 'enumerating' stamp: 'len 7/22/2020 09:32:43'!
supportDo: aBlock
	coefficients keysDo: aBlock! !

!Sum methodsFor: 'enumerating' stamp: 'len 7/24/2020 12:14:38'!
withIndexDo: elementAndIndexBlock 
	"Just like with:do: except that the iteration index supplies the second argument to the block."
	self withSupportDo: elementAndIndexBlock! !

!Sum methodsFor: 'enumerating' stamp: 'len 7/24/2020 12:14:26'!
withSupportDo: elementAndIndexBlock 
	"Just like with:do: except that the iteration index supplies the second argument to the block."
	coefficients keysAndValuesDo: [:key :value| elementAndIndexBlock value: value value: key]! !

!Sum methodsFor: 'operations' stamp: 'len 11/18/2016 09:51:39'!
* aNumber
	^ self collect: [:each| each*aNumber]! !

!Sum methodsFor: 'operations' stamp: 'len 5/6/2019 02:56:21'!
+ aSum
	| other answer |
	self size <= aSum size
		ifTrue: [answer _ aSum copy. other _ self]
		ifFalse: [answer _ self copy. other _ aSum].
	other associationsDo: [:each| answer at: each key add: each value].
	^ answer! !

!Sum methodsFor: 'operations' stamp: 'len 5/6/2019 02:56:07'!
- aSum
	| answer |
	self size <= aSum size
		ifTrue:
			[answer _ aSum negated.
			self associationsDo: [:each| answer at: each key add: each value]]
		ifFalse:
			[answer _ self copy.
			aSum associationsDo: [:each| answer at: each key add: each value negated]].
	^ answer! !

!Sum methodsFor: 'operations' stamp: 'len 2/6/2017 03:13:39'!
/ aNumber
	^ self collect: [:each| each / aNumber]! !

!Sum methodsFor: 'operations' stamp: 'len 5/14/2020 12:31:41'!
// anElement
	^ self collect: [:each| each // anElement]! !

!Sum methodsFor: 'operations' stamp: 'len 5/14/2020 12:31:08'!
\\ anElement
	^ self collect: [:each| each \\ anElement]! !

!Sum methodsFor: 'operations' stamp: 'len 5/6/2019 02:55:32'!
 aSum
	| answer |
	self size <= aSum size ifFalse: [^ aSum  self].
	answer _ self scalars zero.
	coefficients associationsDo: [:each|
		aSum at: each key ifPresent: [:value2| answer _ answer + (each value*value2)]].
	^ answer! !

!Sum methodsFor: 'operations' stamp: 'len 7/18/2020 05:17:14'!
convolution: aSum
	| newCoefficients |
	newCoefficients _ Dictionary new: self size + aSum size.
	self associationsDo: [:each|
		aSum associationsDo: [:other|
			newCoefficients at: each key * other key addAndRemoveIfZero: each value * other value]].
	^ (self class coefficients: newCoefficients) parent: parent! !

!Sum methodsFor: 'operations' stamp: 'len 5/6/2019 02:55:06'!
hadamard: aSum
	"Answer the pointwise product with the argument, also called Hadamard product."
	| answer |
	self size <= aSum size ifFalse: [^ aSum hadamard: self]. "assuming it's commutative"
	answer _ self copyEmpty.
	coefficients associationsDo: [:each| | key |
		key _ each key.
		answer at: key put: each value * (aSum at: key)].
	^ answer! !

!Sum methodsFor: 'operations' stamp: 'len 11/18/2016 09:57:04'!
negated
	^ self collectNoZero: [:each| each negated]! !

!Sum methodsFor: 'testing' stamp: 'len 11/18/2016 09:56:53'!
isZero
	^ coefficients isEmpty! !

!Sum methodsFor: 'private' stamp: 'len 11/18/2016 20:11:53'!
coefficients
	^ coefficients! !

!Sum methodsFor: 'private' stamp: 'len 9/16/2018 16:12:06'!
coefficients: aDictionary
	coefficients _ aDictionary.
	coefficients associationsDo: [:each| each value isZero ifTrue: [self error: 'the coefficinets dictionary contains zeroes']]! !

!Sum methodsFor: 'private' stamp: 'len 7/21/2020 17:39:28'!
parent: aFreeModule
	parent _ aFreeModule! !

!Sum class methodsFor: 'instance creation' stamp: 'len 1/10/2018 19:58:43'!
coefficients: aDictionary
	^ self basicNew coefficients: aDictionary! !

!Sum class methodsFor: 'instance creation' stamp: 'len 7/23/2020 08:13:42'!
coefficients: aDictionary parent: aFreeModule
	^ self basicNew coefficients: aDictionary; parent: aFreeModule! !

!Sum class methodsFor: 'instance creation' stamp: 'len 9/16/2018 16:12:13'!
new
	^ self coefficients: Dictionary new! !

!Sum class methodsFor: 'instance creation' stamp: 'len 1/10/2018 19:58:56'!
new: anInteger
	^ self coefficients: (Dictionary new: anInteger)! !

!Sum class methodsFor: 'instance creation' stamp: 'len 7/23/2020 08:14:37'!
new: anInteger parent: aFreeModule
	^ self coefficients: (Dictionary new: anInteger) parent: aFreeModule! !

!Sum class methodsFor: 'instance creation' stamp: 'len 7/23/2020 08:14:21'!
parent: aFreeModule
	^ self coefficients: Dictionary new parent: aFreeModule! !

!Divisor methodsFor: 'accessing' stamp: 'len 1/10/2018 21:59:43'!
degree
	| answer |
	answer _ 0.
	self coefficientsDo: [:each| answer _ answer + each].
	^ answer! !

!Divisor methodsFor: 'accessing' stamp: 'len 5/10/2019 04:36:00'!
support
	| answer |
	answer _ nil. "should start from the empty variety"
	self keysDo: [:each| answer _ answer ifNil: [each] ifNotNil: [answer \/ each]].
	^ answer! !

!Divisor methodsFor: 'comparing' stamp: 'len 1/11/2017 16:34:02'!
<= aDivisor
	^ (aDivisor - self) isEffective! !

!Divisor methodsFor: 'comparing' stamp: 'len 1/2/2017 15:43:41'!
= anObject
	^ (anObject isKindOf: Divisor) and: [self ~ anObject]! !

!Divisor methodsFor: 'comparing' stamp: 'len 10/27/2016 10:26'!
>= aDivisor
	^ (self - aDivisor) isEffective! !

!Divisor methodsFor: 'comparing' stamp: 'len 1/2/2017 15:43:29'!
~ aDivisor
	"Answer true if the receiver and the argument are linearly equivalent."
	^ (self - aDivisor) isPrincipal! !

!Divisor methodsFor: 'operations' stamp: 'len 1/10/2018 21:58:23'!
gcd: aDivisor
	| newCoefficients |
	newCoefficients _ Dictionary new.
	self keysAndValuesDo: [:key :value|
		aDivisor at: key ifPresent: [:value2| newCoefficients at: key put: (value min: value2)]].
	^ (self class coefficients: newCoefficients) parent: parent! !

!Divisor methodsFor: 'operations' stamp: 'len 2/25/2017 09:09:10'!
lcm: aDivisor
	| answer |
	answer _ self copy.
	aDivisor keysAndValuesDo: [:key :value|
		answer at: key put: ((self at: key) max: value)].
	^ answer! !

!Divisor methodsFor: 'testing' stamp: 'len 2/25/2017 09:09:25'!
isEffective
	^ self allSatisfy: [:each| each positive]! !

!Tensor2 methodsFor: 'converting' stamp: 'len 9/22/2018 22:07:17'!
asSimpleTensor
	"Answer an array of basis elements."
	self size = 1 ifFalse: [^ self error: 'not a simple tensor'].
	self keysAndValuesDo: [:any| ^ (any withIndexCollect: [:i :j| (parent at: j) e: i])].
	^ self halt! !

!Tensor2 methodsFor: 'operations' stamp: 'len 5/14/2019 20:50:19'!
 aTensor
	^ self parent  aTensor parent compose: {self. aTensor}! !

!Tensor2 methodsFor: 'printing' stamp: 'len 5/23/2020 07:22:06'!
printLiteral: anArray on: aStream
	(1 to: anArray size) do: [:i| aStream nextPutAll: ((parent at: i) names at: (anArray at: i))] separatedBy: [aStream nextPut: $]! !

!Tensor methodsFor: 'as yet unclassified' stamp: 'len 7/13/2020 07:26:26'!
asMultilinearMap
	^ map! !

!Tensor methodsFor: 'as yet unclassified' stamp: 'len 7/13/2020 07:33:43'!
associatedForm
	"Answer the associated multilinear form."
	self notYetImplemented
"	^ MultilinearMap from: self frame to: self scalars table: table"! !

!Tensor methodsFor: 'as yet unclassified' stamp: 'len 7/13/2020 09:01:44'!
at: anArray
	| answer |
	answer _ table.
	anArray do: [:i| answer _ answer at: i].
	^ answer! !

!Tensor methodsFor: 'as yet unclassified' stamp: 'len 7/13/2020 07:35:15'!
compression
	"Answers the compression of the receiver, removing all 1-dimensional spaces in the domain."
	^ self notYetImplemented! !

!Tensor methodsFor: 'as yet unclassified' stamp: 'len 7/13/2020 07:33:57'!
frame
	^ map domain, map codomain! !

!Tensor methodsFor: 'as yet unclassified' stamp: 'len 7/13/2020 13:18:58'!
isContravariant
	self notYetImplemented! !

!Tensor methodsFor: 'as yet unclassified' stamp: 'len 7/13/2020 13:18:52'!
isCovariant
	self notYetImplemented! !

!Tensor methodsFor: 'as yet unclassified' stamp: 'len 7/13/2020 07:34:20'!
valence
	^ map domain arity! !

!TupleMonomial methodsFor: 'accessing' stamp: 'len 1/13/2022 09:28:08'!
degree
	^ monomial degree! !

!TupleMonomial methodsFor: 'accessing' stamp: 'len 1/14/2017 20:20:21'!
monomial
	^ monomial! !

!TupleMonomial methodsFor: 'accessing' stamp: 'len 1/14/2017 20:20:47'!
position
	^ position! !

!TupleMonomial methodsFor: 'comparing' stamp: 'len 7/27/2021 19:07:53'!
< aTupleMonomial
	^ (self >= aTupleMonomial) not! !

!TupleMonomial methodsFor: 'comparing' stamp: 'len 7/27/2021 19:08:05'!
<= aTupleMonomial
	self == aTupleMonomial ifTrue: [^ true].
	^ (self > aTupleMonomial) not! !

!TupleMonomial methodsFor: 'comparing' stamp: 'len 7/27/2021 19:09:17'!
= aTupleMonomial
	^ self class == aTupleMonomial class and: [monomial = aTupleMonomial monomial and: [position = aTupleMonomial position]]! !

!TupleMonomial methodsFor: 'comparing' stamp: 'len 7/27/2021 19:08:51'!
> aTupleMonomial
	^ (self compare: aTupleMonomial) > 0! !

!TupleMonomial methodsFor: 'comparing' stamp: 'len 7/27/2021 19:09:03'!
>= aTupleMonomial
	self == aTupleMonomial ifTrue: [^ true].
	^ (self compare: aTupleMonomial) >= 0! !

!TupleMonomial methodsFor: 'comparing' stamp: 'len 7/27/2021 19:09:33'!
compare: aTupleMonomial
	"Answer -1 if the receiver is < than the argument, 0 if they are equal, 1 if it is > than the argument."
	^ ordering compare: self with: aTupleMonomial! !

!TupleMonomial methodsFor: 'comparing' stamp: 'len 1/5/2018 11:20:11'!
hash
	^ monomial hash + position hash hashMultiply! !

!TupleMonomial methodsFor: 'operations' stamp: 'len 7/27/2021 19:19:23'!
* aTupleMonomial
	self assert: position = aTupleMonomial position.
	^ self class new ordering: ordering; position: position; monomial: monomial * aTupleMonomial monomial! !

!TupleMonomial methodsFor: 'operations' stamp: 'len 7/27/2021 19:11:00'!
/ aTupleMonomial
	self assert: position = aTupleMonomial position.
	^ monomial / aTupleMonomial monomial! !

!TupleMonomial methodsFor: 'operations' stamp: 'len 7/27/2021 19:20:54'!
lcm: aTupleMonomial
	^ position = aTupleMonomial position ifTrue: [self class new ordering: ordering; position: position; monomial: (monomial lcm: aTupleMonomial monomial)]! !

!TupleMonomial methodsFor: 'testing' stamp: 'len 7/27/2021 19:07:36'!
| aTupleMonomial
	"Answer true if the receiver divides the argument."
	^ position = aTupleMonomial position and: [monomial | aTupleMonomial monomial]! !

!TupleMonomial methodsFor: 'private' stamp: 'len 1/14/2017 20:20:31'!
monomial: aMonomial
	monomial _ aMonomial! !

!TupleMonomial methodsFor: 'private' stamp: 'len 7/27/2021 19:11:32'!
ordering: aTupleMonomialOrdering
	ordering _ aTupleMonomialOrdering! !

!TupleMonomial methodsFor: 'private' stamp: 'len 1/14/2017 20:20:41'!
position: anInteger
	position _ anInteger! !

!TupleMonomialOrdering methodsFor: 'ordering' stamp: 'len 7/28/2021 09:54:41'!
compare: aTupleMonomial with: anotherTupleMonomial
	^ self subclassResponsibility! !

!TupleMonomialOrdering methodsFor: 'ordering' stamp: 'len 7/28/2021 10:18:29'!
leadingMonomialOf: aTuple
	| answer |
	answer _ nil.
	aTuple monomialsDo: [:each| (answer isNil or: [each > answer]) ifTrue: [answer _ each]].
	^ answer! !

!TupleMonomialOrdering class methodsFor: 'examples' stamp: 'len 7/28/2021 11:52:09'!
pot
	^ POTOrdering new! !

!TupleMonomialOrdering class methodsFor: 'examples' stamp: 'len 7/28/2021 11:52:02'!
top
	^ TOPOrdering new! !

!POTOrdering methodsFor: 'comparing' stamp: 'len 7/28/2021 11:51:12'!
= anObject
	^ self class = anObject class! !

!POTOrdering methodsFor: 'comparing' stamp: 'len 7/28/2021 11:53:26'!
hash
	^ self class hash! !

!POTOrdering methodsFor: 'ordering' stamp: 'len 7/28/2021 11:49:53'!
compare: aTupleMonomial with: anotherTupleMonomial
	| result |
	(result _ (aTupleMonomial position - anotherTupleMonomial position) sign) == 0 ifFalse: [^ result].
	^ aTupleMonomial monomial compare: anotherTupleMonomial monomial! !

!POTOrdering methodsFor: 'ordering' stamp: 'len 7/27/2021 13:29:26'!
leadingMonomialOf: aTuple
	aTuple size to: 1 by: -1 do: [:i| | f |
		(f _ aTuple at: i) isZero ifFalse: [^ TupleMonomial new ordering: self; monomial: f leadingMonomial; position: i]].
	^ nil! !

!SchreyerOrdering methodsFor: 'accessing' stamp: 'len 1/5/2018 11:25:47'!
type
	^ #schreyer! !

!SchreyerOrdering methodsFor: 'comparing' stamp: 'len 7/27/2021 11:42:24'!
= anObject
	^ self class = anObject class and: [weights = anObject weights]! !

!SchreyerOrdering methodsFor: 'comparing' stamp: 'len 7/27/2021 19:24:47'!
hash
	^ weights hash! !

!SchreyerOrdering methodsFor: 'ordering' stamp: 'len 7/28/2021 09:59:31'!
compare: aTupleMonomial with: anotherTupleMonomial
	| result |
	(result _ ((weights at: aTupleMonomial position) * aTupleMonomial monomial) leadingMonomial compare: ((weights at: anotherTupleMonomial position) * anotherTupleMonomial monomial) leadingMonomial) == 0 ifFalse: [^ result].
	^ (anotherTupleMonomial position - aTupleMonomial position) sign! !

!SchreyerOrdering methodsFor: 'private' stamp: 'len 7/28/2021 10:04:41'!
weights: anArray
	weights _ anArray! !

!SchreyerOrdering class methodsFor: 'instance creation' stamp: 'len 7/28/2021 09:53:43'!
weights: anArray
	^ self new weights: anArray! !

!TOPOrdering methodsFor: 'comparing' stamp: 'len 7/28/2021 11:51:16'!
= anObject
	^ self class = anObject class! !

!TOPOrdering methodsFor: 'comparing' stamp: 'len 7/28/2021 11:53:41'!
hash
	^ self class hash! !

!TOPOrdering methodsFor: 'ordering' stamp: 'len 7/27/2021 19:23:19'!
compare: aTupleMonomial with: anotherTupleMonomial
	| result |
	(result _ aTupleMonomial monomial compare: anotherTupleMonomial monomial) == 0 ifFalse: [^ result].
	^ (aTupleMonomial position - anotherTupleMonomial position) sign! !

!TOPOrdering methodsFor: 'ordering' stamp: 'len 7/27/2021 13:29:26'!
leadingMonomialOf: aTuple
	| monomial position |
	monomial _ nil.
	1 to: aTuple size do: [:i|
		(aTuple at: i) leadingMonomial
			ifNotNil: [:aMonomial|
				(monomial isNil or: [aMonomial > monomial])
					ifTrue: [monomial _ aMonomial. position _ i]]].
	^ monomial ifNotNil: [TupleMonomial new ordering: self; monomial: monomial; position: position]! !

!HermiteColumnReduction methodsFor: 'as yet unclassified' stamp: 'len 9/28/2018 19:46:17'!
matrix: aMatrix
	matrix _ ColumnMatrix newFrom: aMatrix.
	self run! !

!HermiteColumnReduction methodsFor: 'as yet unclassified' stamp: 'len 7/10/2019 16:42:08'!
reduceStep: k row: i
	| j0 b |
	"2. Row finished?"
	[j0 _ (1 to: k-1)
		detect: [:j| (matrix at: i@j) ~= 0]
		ifNone: [(matrix at: i@k) < 0 ifTrue: [matrix multiplyColumn: k by: -1]. ^ self "go to step 5"].
	"3. Choose non-zero entry with smallest absolute value:"
	j0 _ ((k to: j0 by: -1) select: [:j| (matrix at: i@j) ~= 0]) detectMin: [:j| (matrix at: i@j) abs].
	j0 < k ifTrue: [matrix swapColumn: j0 with: k].
	(matrix at: i@k) < 0 ifTrue: [matrix multiplyColumn: k by: -1].
	b _ matrix at: i@k.
	"4. Reduce:"
	1 to: k-1 do: [:j| | q |
		q _ ((matrix at: i@j) / b) rounded.
"		q _ (matrix at: i@j) // b."
		matrix addColumn: k times: q negated toColumn: j]] repeat! !

!HermiteColumnReduction methodsFor: 'as yet unclassified' stamp: 'len 9/28/2018 19:46:34'!
reduced
	^ matrix! !

!HermiteColumnReduction methodsFor: 'as yet unclassified' stamp: 'len 5/30/2019 07:11:48'!
run
	| n m i k l b |
	m _ matrix height.
	n _ matrix width.
	"1. Initialize:"
	i _ m.
	k _ n.
	l _ m > n ifTrue: [m-n+1] ifFalse: [1].
	[self reduceStep: k row: i.
	"5. Final reductions:"
	b _ matrix at: i@k.
	b = 0
		ifTrue:
			[k _ k + 1]
		ifFalse:
			[k+1 to: n do: [:j| | q |
				q _ ((matrix at: i@j) / b) floor. "(matrix at: i@j) // b."
				matrix addColumn: k times: q negated toColumn: j]].
	"6. Finished?"
	i = l] whileFalse: [i _ i - 1. k _ k - 1].
	^ matrix "copyFrom: 1@k to: m@n"! !

!HermiteColumnReduction class methodsFor: 'instance creation' stamp: 'len 9/28/2018 19:47:06'!
on: aMatrix
	^ self new matrix: aMatrix! !

!MatrixReduction methodsFor: 'accessing' stamp: 'len 4/5/2018 15:35:51'!
dependentColumns
	"Answer the collection of indices of dependent columns."
	| independent d answer |
	independent _ self independentColumns.
	d _ 1.
	answer _ OrderedCollection new: matrix width - independent size.
	independent do: [:i| answer addAll: (d to: i-1). d _ i+1].
	answer addAll: (d to: matrix width).
	^ answer! !

!MatrixReduction methodsFor: 'accessing' stamp: 'len 4/5/2018 15:43:28'!
determinant
	"Answer the determinant of the matrix."
	| determinant |
	determinant _ matrix scalars one.
	1 to: matrix height do: [:i|
		determinant _ determinant * (matrix at: i@i)].
	^ determinant / determinantFactor! !

!MatrixReduction methodsFor: 'accessing' stamp: 'len 12/26/2015 05:38'!
extension
	^ extension! !

!MatrixReduction methodsFor: 'accessing' stamp: 'len 3/3/2017 06:08:12'!
independentColumns
	"Answer the collection of indexes of independent columns."
	^ self pivots collect: [:each| each y]! !

!MatrixReduction methodsFor: 'accessing' stamp: 'len 4/5/2018 15:36:11'!
pivots
	| answer i j n |
	answer _ OrderedCollection new: matrix height.
	j _ 1.
	i _ 1.
	n _ matrix width.
	matrix rowsDo: [:row|
		j > n ifTrue: [^ answer].
		((j to: n) detect: [:j0| (row isZeroAt: j0) not] ifNone: [])
			ifNotNil: [:j0| answer add: i@j0. j _ j0 + 1].
		i _ i + 1].
	^ answer! !

!MatrixReduction methodsFor: 'accessing' stamp: 'len 12/26/2015 03:23'!
rank
	^ self pivots size! !

!MatrixReduction methodsFor: 'accessing' stamp: 'len 12/26/2015 03:23'!
reduced
	"Answer the reduced matrix."
	^ matrix! !

!MatrixReduction methodsFor: 'initialization' stamp: 'len 1/19/2018 21:47:11'!
matrix: aMatrix extension: anotherMatrix
	matrix _ RowMatrix newFrom: aMatrix.
	extension _ anotherMatrix ifNotNil: [RowMatrix newFrom: anotherMatrix].
	determinantFactor _ aMatrix scalars one.
	self run! !

!MatrixReduction methodsFor: 'operations' stamp: 'len 5/30/2019 07:21:15'!
addRow: i0 times: aNumber toRow: i1
	self addRow: i0 times: aNumber toRow: i1 startingAt: 1! !

!MatrixReduction methodsFor: 'operations' stamp: 'len 7/10/2019 16:34:23'!
addRow: i0 times: aNumber toRow: i1 startingAt: startIndex
	"Transcript cr; show: 'addRow: ', i0 printString, ' toRow: ', i1 printString, ' startingAt: ', startIndex printString."
	matrix addRow: i0 times: aNumber toRow: i1 startingAt: startIndex.
	extension notNil ifTrue: [extension addRow: i0 times: aNumber toRow: i1]! !

!MatrixReduction methodsFor: 'operations' stamp: 'len 1/19/2018 21:38:21'!
multiplyRow: i by: aNumber
	self multiplyRow: i by: aNumber startingAt: 1! !

!MatrixReduction methodsFor: 'operations' stamp: 'len 7/10/2019 16:34:29'!
multiplyRow: i by: aNumber startingAt: startIndex
	"Transcript cr; show: 'multiplyRow: ', i printString, ' by: ', aNumber printString, ' startingAt: ', startIndex printString."
	matrix multiplyRow: i by: aNumber startingAt: startIndex.
	extension notNil ifTrue: [extension multiplyRow: i by: aNumber].
	determinantFactor _ determinantFactor * aNumber! !

!MatrixReduction methodsFor: 'operations' stamp: 'len 7/10/2019 16:34:36'!
swapRow: i with: j
	"Transcript cr; show: 'swapRow: ', i printString, ' with: ', j printString."
	matrix swapRow: i with: j.
	extension notNil ifTrue: [extension swapRow: i with: j].
	determinantFactor _ determinantFactor negated! !

!MatrixReduction class methodsFor: 'instance creation' stamp: 'len 12/26/2015 05:41'!
on: aMatrix
	^ self on: aMatrix extension: nil! !

!MatrixReduction class methodsFor: 'instance creation' stamp: 'len 12/26/2015 05:15'!
on: aMatrix extension: anotherMatrix
	^ self new matrix: aMatrix extension: anotherMatrix! !

!GaussianElimination methodsFor: 'initialization' stamp: 'len 4/5/2018 15:37:44'!
matrix: aMatrix extension: anotherMatrix
	pivots _ OrderedCollection new: aMatrix height.
	currentPivot _ 0 @ 0.
	super matrix: aMatrix extension: anotherMatrix! !

!GaussianElimination methodsFor: 'operations' stamp: 'len 5/30/2019 07:21:00'!
addRow: i0 times: aNumber toRow: i1
	self addRow: i0 times: aNumber toRow: i1 startingAt: currentPivot y! !

!GaussianElimination methodsFor: 'operations' stamp: 'len 1/19/2018 21:54:00'!
multiplyRow: i by: aNumber
	self multiplyRow: i by: aNumber startingAt: currentPivot y! !

!GaussianElimination methodsFor: 'operations' stamp: 'len 1/19/2018 23:22:35'!
swapRow: i
	"Swap the anInteger-th row with the row at the current pivot."
	i = currentPivot x ifTrue: [^ self].
	self swapRow: i with: currentPivot x.
	pivots removeLast.
	self addPivot: i @ currentPivot y! !

!GaussianElimination methodsFor: 'private' stamp: 'len 1/19/2018 21:31:10'!
addPivot: aPoint
	currentPivot _ aPoint.
	^ pivots add: aPoint! !

!GaussianElimination methodsFor: 'private' stamp: 'len 4/5/2018 15:37:51'!
nextPivot
	"Advance the position to the next available pivot."
	| col |
	col _ currentPivot y + 1.
	[col <= matrix width]
		whileTrue:
			[1 to: matrix height do: [:each|
				((pivots anySatisfy: [:one| one x = each]) or: [matrix isZeroAt: each @ col])
						ifFalse: [^ self addPivot: each @ col]].
			col _ col + 1].
	^ nil! !

!GaussianElimination methodsFor: 'private' stamp: 'len 1/19/2018 21:59:16'!
pivots
	^ pivots! !

!GaussianElimination methodsFor: 'private' stamp: 'len 8/22/2021 12:44:57'!
reduceStep
	"Perform one step in the reduction of the matrix using the current pivot."
	| row col |
	row _ currentPivot x.
	col _ currentPivot y.
	self multiplyRow: row by: (matrix at: row @ col) inverse.
	1 to: matrix height do: [:i|
		(i = row or: [matrix isZeroAt: i @ col])
			ifFalse: [self addRow: row times: (matrix at: i @ col) negated toRow: i]]! !

!GaussianElimination methodsFor: 'private' stamp: 'len 1/19/2018 22:13:04'!
run
	| row |
	row _ 1.
	[self nextPivot isNil]
		whileFalse:
			[self swapRow: row.
			row _ row + 1.
			self reduceStep]! !

!EuclideanGaussianElimination methodsFor: 'private' stamp: 'len 7/15/2019 03:19:43'!
reduceStep
	"Perform one step in the reduction of the matrix using the current pivot."
	| row j |
	row _ currentPivot x.
	j _ currentPivot y.
	self assert: row = j.
	1 to: matrix height do: [:i|
		(i = j or: [matrix isZeroAt: i @ j])
			ifFalse:
				[| ajj aij euclid g bi bj ri rj |
				ajj _ matrix at: j @ j.
				aij _ matrix at: i @ j.
				euclid _ ExtendedEuclid on: {aij. ajj}.
				g _ euclid gcd.
				bi _ euclid bezout first.
				bj _ euclid bezout last.
				euclid verify ifFalse: [self halt].
				ri _ matrix rowAt: i.
				rj _ matrix rowAt: j.
				matrix rowAt: j put: ri * bi + (rj * bj).
				matrix rowAt: i put: rj * (aij // g) - (ri * (ajj // g))]]! !

!GaussBareiss methodsFor: 'private' stamp: 'len 5/30/2019 07:18:55'!
reduceStep
	"Perform one step reduction of the matrix using the current pivot."
	| row col pivot value |
	row _ currentPivot x.
	col _ currentPivot y.
	pivot _ matrix at: row @ col.
	1 to: matrix height do: [:i|
		(i = row or: [(value _ matrix at: i @ col) isZero])
			ifFalse:
				[self multiplyRow: i by: pivot.
				self addRow: row times: value negated toRow: i]]! !

!HermiteReduction methodsFor: 'private' stamp: 'len 1/2/2022 10:12:09'!
reduceStep: k column: j
	"Perform the reduction step on row k and column j."
	| i0 b |
	"2. Column finished?"
	[i0 _ (matrix height to: k+1 by: -1)
		detect: [:i| (matrix at: i@j) isZero not]
		ifNone: [self multiplyRow: k by: (matrix at: k@j) normalization. ^ self "go to step 5"].
	"3. Choose nonzero entry with smallest absolute value:"
	i0 _ ((k to: i0) select: [:i| (matrix at: i@j) isZero not]) detectMin: [:i| (matrix at: i@j) gauge].
	i0 > k ifTrue: [self swapRow: i0 with: k].
	self multiplyRow: k by: (matrix at: k@j) normalization.
	b _ matrix at: k@j.
	"4. Reduce:"
	matrix height to: k+1 by: -1 do: [:i| | q |
		q _ (matrix at: i@j) // b.
		self addRow: k times: q negated toRow: i]] repeat! !

!HermiteReduction methodsFor: 'private' stamp: 'len 8/3/2020 12:20:59'!
run
	| n m k j b |
	m _ matrix height.
	n _ matrix width.
	(m = 0 or: [n = 0]) ifTrue: [^ self]. "nothing to do"
	"1. Initialize:"
	k _ 1.
	j _ 1.
	[self reduceStep: k column: j.
	"5. Final reductions:"
	b _ matrix at: k@j.
	b isZero
		ifTrue:
			[k _ k - 1]
		ifFalse:
			[1 to: k-1 do: [:i| | q |
				q _ (matrix at: i@j) // b.
				self addRow: k times: q negated toRow: i]].
	"6. Finished?"
	j = n or: [k = m]] whileFalse: [j _ j + 1. k _ k + 1].
	^ matrix! !

!HowellReduction methodsFor: 'private' stamp: 'len 5/19/2020 12:47:35'!
cancel: aPoint with: anotherPoint
	| a b mgcd g s t u v j i Aj Ai |
	mgcd _ (a _ matrix at: aPoint) xxgcd: (b _ matrix at: anotherPoint).
	g _ mgcd at: 1.
	s _ mgcd at: 2.
	t _ mgcd at: 3.
	u _ mgcd at: 4.
	v _ mgcd at: 5.
	self assert: s*a + (t*b) = g.
	self assert: (u*a + (v*b)) isZero.
	self assert: (s*v - (t*u)) = g one.
	"optimize!! avoid wasting memory"
	"is this changing the determinant? should also update the extension"
	j _ aPoint x.
	i _ anotherPoint x.
	Aj _ (matrix rowAt: j) copy.
	Ai _ (matrix rowAt: i) copy.
	matrix rowAt: j put: Aj*s + (Ai*t).
	matrix rowAt: i put: Aj*u + (Ai*v)! !

!HowellReduction methodsFor: 'private' stamp: 'len 5/19/2020 12:46:15'!
cancel: aPoint withTemporary: aTuple
	| a b mgcd g s t u v j Aj |
	mgcd _ (a _ matrix at: aPoint) xxgcd: (b _ aTuple at: aPoint y).
	g _ mgcd at: 1.
	s _ mgcd at: 2.
	t _ mgcd at: 3.
	u _ mgcd at: 4.
	v _ mgcd at: 5.
	self assert: s*a + (t*b) = g.
	self assert: (u*a + (v*b)) isZero.
	self assert: (s*v - (t*u)) = g one.
	"optimize!! avoid wasting memory"
	"is this changing the determinant? should also update the extension"
	j _ aPoint x.
	Aj _ (matrix rowAt: j) copy.
	matrix rowAt: j put: Aj*s + (aTuple*t).
	^ Aj*u + (aTuple*v)! !

!HowellReduction methodsFor: 'private' stamp: 'len 7/30/2021 10:45:21'!
run
	| n |
	n _ matrix width.
	"Augment the matrix with zero rows to make it square:"
	n > matrix height ifTrue: [matrix _ matrix  (matrix domain => (matrix scalars ^ (n - matrix height))) zero].
	self assert: matrix height = n.
"	Transcript clear."
	"Put it in upper triangular form:"
	1 to: n do: [:j|
		j+1 to: n do: [:i|
"			Transcript print: i@j; newLine; space; print: matrix; newLine."
			 self cancel: j@j with: i@j]].
	self assert: matrix isUpperTriangular.			
	"Put it in Howell form:"
	1 to: n do: [:j|
		| B |
"		Transcript print: j; newLine; space; print: matrix; newLine."
		(matrix isZeroAt: j@j)
			ifTrue:
				[B _ (matrix rowAt: j) copy]
			ifFalse:
				[self multiplyRow: j by: (matrix at: j@j) normalization.
				1 to: j-1 do: [:i| self addRow: j times: ((matrix at: i@j) // (matrix at: j@j)) negated toRow: i].
				B _ (matrix rowAt: j) * (matrix at: j@j) annihilator].
"		Transcript nextPut: $.; print: matrix; newLine."
		j+1 to: n do: [:i| B _ self cancel: i@i withTemporary: B]].
"	Transcript print: matrix; newLine."
	^ matrix! !

!CochainComplex methodsFor: 'operations' stamp: 'len 1/3/2022 10:54:51'!
/ aSubcomplex
	^ (opposite / aSubcomplex opposite) opposite! !

!CochainComplex methodsFor: 'operations' stamp: 'len 10/26/2020 11:55:45'!
<< n
	"Answer the complex with degrees shifted by n."
	^ self >> n negated! !

!CochainComplex methodsFor: 'operations' stamp: 'len 1/3/2022 10:54:14'!
@ aPrimeIdeal
	"Answer the localization of the receiver at aPrimeIdeal."
	^ (opposite @ aPrimeIdeal) opposite! !

!CochainComplex methodsFor: 'operations' stamp: 'len 11/4/2020 12:07:22'!
~ aCochainComplex
	^ opposite ~ aCochainComplex opposite! !

!CochainComplex methodsFor: 'operations' stamp: 'len 1/3/2022 10:54:02'!
 aCochainComplex
	^ (opposite  aCochainComplex opposite) opposite! !

!CochainComplex methodsFor: 'operations' stamp: 'len 1/3/2022 10:54:28'!
 aCochainComplex
	^ (opposite  aCochainComplex opposite) opposite! !

!CochainComplex methodsFor: 'operations' stamp: 'len 1/3/2022 10:54:41'!
hom: aCodomain
	^ (aCodomain opposite => opposite) opposite! !

!CochainComplex methodsFor: 'accessing' stamp: 'len 10/30/2020 10:57:51'!
at: k
	"Answer the k-th differential or boundary map d(k):C(k)->C(k-1)."
	^ opposite at: k negated! !

!CochainComplex methodsFor: 'accessing' stamp: 'len 10/30/2020 10:58:04'!
cochains
	^ opposite chains! !

!CochainComplex methodsFor: 'accessing' stamp: 'len 10/30/2020 10:40:58'!
opposite
	^ opposite! !

!CochainComplex methodsFor: 'accessing' stamp: 'len 10/30/2020 10:58:50'!
scalars
	^ opposite scalars! !

!CochainComplex methodsFor: 'cohomology' stamp: 'len 10/30/2020 10:57:58'!
coboundaries: k
	^ opposite boundaries: k negated! !

!CochainComplex methodsFor: 'cohomology' stamp: 'len 10/30/2020 10:58:08'!
cocycles: k
	^ opposite cycles: k negated! !

!CochainComplex methodsFor: 'cohomology' stamp: 'len 10/30/2020 10:58:14'!
cohomology: k
	^ opposite homology: k negated! !

!CochainComplex methodsFor: 'comparing' stamp: 'len 10/30/2020 10:41:28'!
= anObject
	^ (anObject isKindOf: CochainComplex) and: [opposite = anObject opposite]! !

!CochainComplex methodsFor: 'comparing' stamp: 'len 10/30/2020 10:58:17'!
hash
	^ opposite hash! !

!CochainComplex methodsFor: 'morphisms' stamp: 'len 10/30/2020 10:58:28'!
id
	^ CochainMap opposite: opposite id! !

!CochainComplex methodsFor: 'testing' stamp: 'len 10/30/2020 10:58:35'!
isTrivial
	^ opposite isTrivial! !

!CochainComplex methodsFor: 'private' stamp: 'len 10/30/2020 10:59:03'!
opposite: aChainComplex
	opposite _ aChainComplex! !

!CochainComplex class methodsFor: 'instance creation' stamp: 'len 10/30/2020 10:59:20'!
opposite: aChainComplex
	^ self new opposite: aChainComplex! !

!LLL methodsFor: 'accessing' stamp: 'len 12/23/2015 03:01'!
reducedBasis
	orthogonalBasis notNil ifFalse: [self computeReducedBasis].
	^ basis! !

!LLL methodsFor: 'initialization' stamp: 'len 7/8/2020 08:19:26'!
basis: aCollection innerProduct: aBilinearForm
	basis _ aCollection asArray.
	innerProduct _ aBilinearForm.
	"d _ basis size."
	delta _ 3/4 "(4/3 + 0.0000000001)^((d-1)/2)"! !

!LLL methodsFor: 'private' stamp: 'len 7/13/2020 11:57:10'!
computeMu
	| n bi oj |
	n _ basis size.
	mu _ (^n) endomorphisms filling: [:i :j|
		bi _ basis at: i.
		oj _ orthogonalBasis at: j.
		(innerProduct value: bi value: oj) / (orthogonalBasisNorms at: j)] "redundant matrix multiplication by oj"! !

!LLL methodsFor: 'private' stamp: 'len 7/8/2020 08:24:22'!
computeOrthogonalBasis
	| k vectors |
	vectors _ Array withAll: basis.
	k _ vectors size.
	1 to: k do: [:i|
		| vi norm |
		vi _ vectors at: i.
		norm _ innerProduct value: vi value: vi.
		i+1 to: k do: [:j|
			| vj |
			vj _ vectors at: j.
			vj _ vj - (vi * ((innerProduct value: vj value: vi) / norm)).
			vectors at: j put: vj]].
	orthogonalBasis _ vectors.
	orthogonalBasisNorms _ orthogonalBasis collect: [:each| innerProduct value: each value: each]! !

!LLL methodsFor: 'private' stamp: 'len 7/8/2020 08:25:20'!
computeReducedBasis
	| k mukj bj bk a b |
	self computeOrthogonalBasis; computeMu.
	k _ 1.
	[k < basis size] whileTrue:
		[k-1 to: 0 by: -1 do: [ :j |
			mukj _ mu at: k+1 @ (j+1).
			bj _ basis at: j+1.
			bk _ basis at: k+1.
			mukj abs > (1/2) ifTrue:
				[basis at: k+1 put: bk - (bj * mukj rounded).
				self update: k+1]].
		a _ orthogonalBasisNorms at: k+1.
		b _ orthogonalBasisNorms at: k.
		a >= ((delta - (mu at: k+1 @ k) squared) * b)
			ifTrue: [k _ k + 1]
			ifFalse:
				[basis swap: k+1 with: k.
				self update: k+1.
				k _ k-1 max: 1]].
	^ basis! !

!LLL methodsFor: 'private' stamp: 'len 2/23/2016 07:33'!
update: k
	self flag: #fix. "don't need to recompute all"
	self computeOrthogonalBasis; computeMu! !

!LLL class methodsFor: 'examples' stamp: 'len 7/8/2020 08:27:58'!
example
	| V b1 b2 b3 reducer |
	V _ ^3.
	b1 _ V !! (1, 1, 1).
	b2 _ V !! (-1, 0, 2).
	b3 _ V !! (3, 5, 6).
	reducer _ self basis: { b1. b2. b3 } innerProduct: V innerProduct.
	^ reducer reducedBasis! !

!LLL class methodsFor: 'examples' stamp: 'len 7/8/2020 08:28:50'!
example2
	"Find polynomial x^2 - x - 1 that has the golden ratio phi as root."
	| V r b1 b2 b3 reducer |
	V _ ^4.
	r _ 1.618034.
	b1 _ V !! (1, 0, 0, (10000 * r squared) rounded).
	b2 _ V !! (0, 1, 0, (10000 * r) rounded).
	b3 _ V !! (0, 0, 1, 10000).
	reducer _ self basis: { b1. b2. b3 } innerProduct: V innerProduct.
	^ reducer reducedBasis! !

!LLL class methodsFor: 'instance creation' stamp: 'len 7/8/2020 08:18:40'!
basis: aCollection innerProduct: aBilinearForm
	^ self new basis: aCollection innerProduct: aBilinearForm! !

!LatticeElement methodsFor: 'converting' stamp: 'len 7/29/2020 06:32:28'!
asVector
	| answer |
	answer _ parent space zero.
	coordinates with: parent basis do: [:ai :xi| answer _ xi * ai + answer].
	^ answer! !

!LatticeElement methodsFor: 'initialization' stamp: 'len 7/29/2020 06:30:18'!
coordinates: aTuple parent: aLattice 
	coordinates _ aTuple.
	parent _ aLattice! !

!LatticeElement methodsFor: 'operations' stamp: 'len 7/29/2020 06:42:14'!
* anInteger
	anInteger isInteger ifFalse: [^ DomainError signal].
	^ self class coordinates: coordinates * anInteger parent: parent! !

!LatticeElement methodsFor: 'operations' stamp: 'len 7/29/2020 06:42:23'!
+ anElement
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #+].
	^ self class coordinates: coordinates + anElement coordinates parent: parent! !

!LatticeElement methodsFor: 'operations' stamp: 'len 7/8/2020 18:50:32'!
- anElement
	^ self + anElement negated! !

!LatticeElement methodsFor: 'operations' stamp: 'len 7/29/2020 06:42:36'!
// anInteger
	anInteger isInteger ifFalse: [^ DomainError signal].
	^ self class coordinates: coordinates // anInteger parent: parent! !

!LatticeElement methodsFor: 'operations' stamp: 'len 7/28/2020 19:39:07'!
| anElement
	"Answer the inner product of the receiver and the argument."
	^ parent innerProduct value: anElement asVector value: self asVector! !

!LatticeElement methodsFor: 'operations' stamp: 'len 7/8/2020 19:13:58'!
length
	^ self norm sqrt! !

!LatticeElement methodsFor: 'operations' stamp: 'len 7/29/2020 06:43:08'!
negated
	^ self class coordinates: coordinates negated parent: parent! !

!LatticeElement methodsFor: 'operations' stamp: 'len 7/8/2020 19:14:19'!
norm
	| v |
	v _ self asVector.
	^ parent innerProduct value: v value: v! !

!LatticeElement methodsFor: 'testing' stamp: 'len 7/8/2020 18:52:04'!
isZero
	^ coordinates isZero! !

!LatticeElement methodsFor: 'private' stamp: 'len 7/8/2020 18:47:55'!
coordinates
	^ coordinates! !

!LatticeElement methodsFor: 'private' stamp: 'len 7/8/2020 18:47:25'!
parent
	^ parent! !

!LatticeElement class methodsFor: 'instance creation' stamp: 'len 7/29/2020 06:30:28'!
coordinates: aTuple parent: aLattice
	^ self new coordinates: aTuple parent: aLattice! !

!Division methodsFor: 'accessing' stamp: 'len 5/15/2020 05:40:12'!
dividend
	^ dividend! !

!Division methodsFor: 'accessing' stamp: 'len 5/15/2020 05:40:17'!
divisor
	^ divisor! !

!Division methodsFor: 'accessing' stamp: 'len 5/15/2020 06:06:23'!
exactQuotient
	self remainder isZero ifFalse: [self error: 'not an exact division'].
	^ self quotient! !

!Division methodsFor: 'accessing' stamp: 'len 5/15/2020 06:05:51'!
quotient
	^ quotient ifNil: [quotient _ dividend // divisor]! !

!Division methodsFor: 'accessing' stamp: 'len 5/17/2020 07:32:15'!
remainder
	^ remainder ifNil: [remainder _ dividend - (divisor * self quotient)]! !

!Division methodsFor: 'accessing' stamp: 'len 7/28/2021 12:58:42'!
remainderAlone
	^ self remainder! !

!Division methodsFor: 'private' stamp: 'len 5/29/2020 19:41:24'!
dividend: a divisor: b
	dividend _ a.
	b isZero ifTrue: [^ (ZeroDivide receiver: a selector: #// argument: b) signal].
	divisor _ b! !

!Division methodsFor: 'private' stamp: 'len 5/15/2020 05:44:56'!
quotient: anElement
	quotient _ anElement! !

!Division methodsFor: 'private' stamp: 'len 5/15/2020 05:44:49'!
remainder: anElement
	remainder _ anElement! !

!Division methodsFor: 'private' stamp: 'len 8/22/2021 13:17:35'!
verify
	^ divisor * self quotient + self remainder = dividend! !

!Division class methodsFor: 'instance creation' stamp: 'len 5/15/2020 06:14:59'!
divide: a by: b
	^ self new dividend: a divisor: b! !

!Division class methodsFor: 'instance creation' stamp: 'len 5/15/2020 05:45:23'!
dividend: a divisor: b quotient: q remainder: r
	^ self new dividend: a divisor: b; quotient: q; remainder: r! !

!RingElement methodsFor: 'accessing' stamp: 'len 12/10/2021 19:37:31'!
associates
	^ self parent units collect: [:each| self * each]! !

!RingElement methodsFor: 'accessing' stamp: 'len 12/29/2021 12:21:24'!
gauge
	"Answer the value of the Euclidean function at the receiver."
	self parent isDVR ifTrue: [^ self isZero ifTrue: [0] ifFalse: [self valuation + 1]].
	^ self subclassResponsibility! !

!RingElement methodsFor: 'accessing' stamp: 'len 9/24/2018 22:58:16'!
one
	^ self parent one! !

!RingElement methodsFor: 'accessing' stamp: 'len 5/8/2020 18:22:38'!
valuation
	"If the receiver is an element of a valuation ring or a Euclidean ring, answer its valuation or Euclidean function."
	^ self subclassResponsibility! !

!RingElement methodsFor: 'accessing' stamp: 'len 8/7/2019 09:11:23'!
valuation: p
	"Answer the p-adic valuation of the receiver.
	This is the exponent of the highest power of p that divides the receiver."
	| answer q |
	self isZero ifTrue: [^ Infinity positive].
	q _ self normalized.
	answer _ 0.
	[p | q] whileTrue: [answer _ answer + 1. q _ q // p].
	^ answer! !

!RingElement methodsFor: 'accessing' stamp: 'len 9/24/2018 22:58:19'!
zero
	^ self parent zero! !

!RingElement methodsFor: 'comparing' stamp: 'len 7/17/2019 08:31:58'!
< anElement
	^self <= anElement and: [self ~= anElement]! !

!RingElement methodsFor: 'comparing' stamp: 'len 7/17/2019 08:31:39'!
<= anElement
	^self subclassResponsibility! !

!RingElement methodsFor: 'comparing' stamp: 'len 7/17/2019 08:30:19'!
> anElement
	"Answer whether the receiver is greater than the argument."

	^anElement < self! !

!RingElement methodsFor: 'comparing' stamp: 'len 7/17/2019 08:30:40'!
>= anElement
	"Answer whether the receiver is greater than or equal to the argument."

	^anElement <= self! !

!RingElement methodsFor: 'comparing' stamp: 'len 1/13/2022 05:47:29'!
| anElement
	"Answer true if the receiver divides anElement."
	anElement isZero ifTrue: [^ true].
	self isZero ifTrue: [^ false].
	self parent isEuclidean ifTrue: [^ (anElement \\ self) isZero].
	^ (self \ anElement) notNil
	
"	^ self isZero not and: [self parent * self includes: anElement]"
! !

!RingElement methodsFor: 'comparing' stamp: 'len 5/10/2020 10:56:45'!
~ anElement
	"Answer true if the receiver and the argument are associates.
	Note that we define 'a ~ b' if there's a unit 'u' such that 'a = b*u',
	this relation is called 'strongly associate' by some authors."
	^ self normalized = anElement normalized! !

!RingElement methodsFor: 'comparing' stamp: 'len 7/17/2019 08:29:10'!
between: min and: max 
	"Answer whether the receiver is less than or equal to the argument, max,  and greater than or equal to the argument, min."

	^self >= min and: [self <= max]! !

!RingElement methodsFor: 'comparing' stamp: 'len 7/17/2019 08:28:07'!
max: anElement 
	"Answer the receiver or the argument, whichever is greater."

	^ self > anElement ifTrue: [self] ifFalse: [anElement]! !

!RingElement methodsFor: 'comparing' stamp: 'len 7/17/2019 08:28:50'!
min: anElement
	"Answer the receiver or the argument, whichever is lesser."

	^ self < anElement ifTrue: [self] ifFalse: [anElement]! !

!RingElement methodsFor: 'comparing' stamp: 'len 7/17/2019 08:27:20'!
min: aMin max: aMax
	^ (self min: aMin) max: aMax! !

!RingElement methodsFor: 'converting' stamp: 'len 5/11/2019 08:29:13'!
adaptToFraction: rcvr andSend: selector
	(#(* + - /) includes: selector)
		ifTrue: [^ self parent !! rcvr perform: selector with: self].
	^ super adaptToFraction: rcvr andSend: selector! !

!RingElement methodsFor: 'converting' stamp: 'len 5/11/2019 08:27:06'!
adaptToInteger: rcvr andSend: selector
	selector = #* ifTrue: [^ self * rcvr].
	selector = #+ ifTrue: [^ self one * rcvr + self].
	selector = #- ifTrue: [^ self one * rcvr - self].
	selector = #/ ifTrue: [^ self one * rcvr / self].
	^ super adaptToInteger: rcvr andSend: selector! !

!RingElement methodsFor: 'converting' stamp: 'len 1/3/2022 11:07:20'!
asIdeal
	"Answer the ideal generated by the receiver."
	^ self parent * self! !

!RingElement methodsFor: 'operations' stamp: 'len 6/17/2019 11:19:47'!
* anElement
	^ self subclassResponsibility! !

!RingElement methodsFor: 'operations' stamp: 'len 6/17/2019 11:19:52'!
+ anElement
	^ self subclassResponsibility! !

!RingElement methodsFor: 'operations' stamp: 'len 7/17/2019 15:27:12'!
, aTuple
	^ (self parent tuple: {self}), aTuple! !

!RingElement methodsFor: 'operations' stamp: 'len 6/17/2019 11:19:36'!
- anElement
	^ self + anElement negated! !

!RingElement methodsFor: 'operations' stamp: 'len 1/3/2022 11:31:22'!
/ anElement
	"Answer x such that xa = b, where b is self and a is anElement.
	The behavior is undefined if a doesn't divide b."
	(self parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #/].
	anElement isUnit ifTrue: [^ self * anElement inverse].
	^ self // anElement! !

!RingElement methodsFor: 'operations' stamp: 'len 5/14/2020 14:29:55'!
// anElement
	"Answer the quotient of the division of the receiver by the argument.
	In Euclidean rings, this is the quotient of the Euclidean division."
	^ self subclassResponsibility! !

!RingElement methodsFor: 'operations' stamp: 'len 1/3/2022 11:37:17'!
\ anElement
	"Answer x such that ax = b, where a is self and b is anElement.
	The behavior is undefined if a doesn't divide b."
	self parent isCommutative ifTrue: [^ anElement / self].
	(self parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #\].
	self parent isInvolutive ifTrue: [^ (anElement conjugate / self conjugate) conjugate].
	self parent isFinite ifFalse: [^ self subclassResponsibility].
	^ self parent detect: [:x| self * x = anElement] ifNone: []! !

!RingElement methodsFor: 'operations' stamp: 'len 8/22/2021 16:33:53'!
\\ anElement
	"Answer the remainder of the division of the receiver by the argument.
	In Euclidean rings, this is the remainder of the Euclidean division."
	^ self - (anElement * (self // anElement))! !

!RingElement methodsFor: 'operations' stamp: 'len 7/5/2021 12:16:36'!
^ anInteger
	"Answer the receiver raised to the power anInteger."
	anInteger = 1 ifTrue: [^ self].
	anInteger = 0 ifTrue: [^ self one].
	anInteger < 0 ifTrue: [^ self  inverse ^ anInteger negated].
"	self parent isAssociative ifFalse:
		[| answer |
		answer _ self.
		anInteger - 1 timesRepeat: [answer _ answer * self].
		^ answer]."
	^ anInteger even ifTrue: [self squared ^ (anInteger // 2)] ifFalse: [self squared ^ (anInteger // 2) * self]! !

!RingElement methodsFor: 'operations' stamp: 'len 6/17/2019 11:20:04'!
 anElement
	^ self * anElement! !

!RingElement methodsFor: 'operations' stamp: 'len 7/15/2021 10:42:28'!
annihilator
	"Answer a generator of the ideal of all elements that multiplied by the receiver are zero."
"	self parent isIntegralDomain ifTrue: [^ self parent zero]."
	^ self annihilatorIdeal generator! !

!RingElement methodsFor: 'operations' stamp: 'len 1/6/2022 09:23:42'!
annihilatorIdeal
	"Answer the ideal of all elements that multiplied by the receiver are zero."
	self parent isIntegralDomain ifTrue: [^ self parent asIdeal null].
	^ self parent * (self parent zerodivisors select: [:each| (self * each) isZero])
"	^ self parent * (self parent select: [:each| (self * each) isZero])"! !

!RingElement methodsFor: 'operations' stamp: 'len 4/27/2021 12:40:15'!
centralizer
	"Answer the subalgebra of the parent algebra commuting with the receiver."
	^ self parent centralizerOf: (self parent span: {self})! !

!RingElement methodsFor: 'operations' stamp: 'len 4/30/2021 12:47:47'!
commutator: anElement
	"Answer the Lie bracket between the receiver and the argument."
	^ self * anElement - (anElement * self)! !

!RingElement methodsFor: 'operations' stamp: 'len 5/15/2020 06:15:27'!
divisionBy: anElement
	^ Division divide: self by: anElement! !

!RingElement methodsFor: 'operations' stamp: 'len 5/17/2020 07:26:13'!
gcd: anElement
	"Answer the greatest common divisor of the receiver and the argument,
	i.e. a generator of the principal ideal generated by the reciever and the argument.
	The result is the canonical associate (normalized)."
	| a b |
	(self parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #gcd:].
	a _ self.
	b _ anElement.
	[a isZero] whileFalse: [a _ b \\ (b _ a)].
	^ b normalized! !

!RingElement methodsFor: 'operations' stamp: 'len 4/23/2021 11:13:08'!
inverse
	^ self \ self one! !

!RingElement methodsFor: 'operations' stamp: 'len 12/10/2021 19:41:57'!
lcm: anElement
	"Answer the least common multiple of the receiver and the argument.
	The result is the canonical associate (normalized)."
	self isZero ifTrue: [^ self].
	anElement isZero ifTrue: [^ anElement].
	^ (self / (self gcd: anElement) * anElement) normalized! !

!RingElement methodsFor: 'operations' stamp: 'len 5/29/2020 07:53:44'!
negated
	^ self * -1! !

!RingElement methodsFor: 'operations' stamp: 'len 12/10/2021 19:19:49'!
normalization
	"Answer a unit u such that 'self * u' is a unique choice of associate. See >>normalized."
	self isUnit ifTrue: [^ self inverse].
	self isZero ifTrue: [^ self parent one].
	^ self subclassResponsibility! !

!RingElement methodsFor: 'operations' stamp: 'len 7/30/2021 10:27:06'!
normalized
	"Answer a unique choice of associate. See >>normalization."
	^ self * self normalization! !

!RingElement methodsFor: 'operations' stamp: 'len 12/20/2021 13:01:52'!
opposite
	"Answer the receiver as an element of the opposite ring."
	self parent isCommutative ifTrue: [^ self].
	self parent isInvolutive ifTrue: [^ self conjugate].
	^ OppositeRingElement opposite: self! !

!RingElement methodsFor: 'operations' stamp: 'len 4/23/2021 11:46:44'!
quotientBy: anElement modulo: m
	"Answer the Euclidean quotient of the receiver by anElement modulo m.
	If the receiver is 'a' and anElement is 'b', answer 'q' such that 'b*q = a mod m', or in other words 'b*q - a' is divisible by 'm' and 'q' is either 0 or the Euclidean degree of 'q' is strictly smaller than the Euclidean degree of 'm'."
	| f g fs gs h hs q r |
	f _ anElement. fs _ self one.
	g _ m. gs _ self zero.
	[g isZero] whileFalse:
		[q _ f // g. r _ f - (g*q).
		h _ g. hs _ gs.
		g _ r. gs _ fs - (q*gs).
		f _ h. fs _ hs].
	q _ self // f. "<- should this be exact quotient?"
	^ fs * q \\ m! !

!RingElement methodsFor: 'operations' stamp: 'len 5/14/2020 06:53:56'!
raisedTo: anInteger modulo: anElement
	"Answer the receiver raised to the power anInteger modulo anElement."
	anInteger = 1 ifTrue: [^ self \\ anElement].
	anInteger = 0 ifTrue: [^ self one \\ anElement].
	anInteger < 0 ifTrue: [^ (self raisedTo: anInteger negated modulo: anElement) inverse \\ anElement].
	self flag: #fix. "performs unnecesary \\ when anInteger = 2"
	^ anInteger even ifTrue: [self squared \\ anElement raisedTo: anInteger // 2 modulo: anElement] ifFalse: [(self squared \\ anElement raisedTo: anInteger // 2 modulo: anElement) * self \\ anElement]! !

!RingElement methodsFor: 'operations' stamp: 'len 1/7/2022 13:47:33'!
reciprocal
	^ (self parent fractions !! self) inverse! !

!RingElement methodsFor: 'operations' stamp: 'len 9/24/2018 22:53:02'!
squared
	^ self * self! !

!RingElement methodsFor: 'operations' stamp: 'len 5/10/2020 11:00:58'!
stabilizerWith: b modulo: N
	"If the receiver is 'a', answer 'c' such that '<a + cb, N> = <a, b, N>'."
	self notYetImplemented! !

!RingElement methodsFor: 'operations' stamp: 'len 7/30/2021 10:48:36'!
xgcd: anElement
	"Extended Euclidean algorithm.
	If the receiver is 'a' and the argument is 'b'. answer an array {g. s. t} where as + bt = g = (a gcd: b)."
	| a b zero one s1 t1 s t r1 r u |
	(self parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #xgcd:].
	a _ self.
	b _ anElement.
	zero _ a zero. one _ a one.
	s1 _ zero. s _ one.
	t1 _ one. t _ zero.
	r1 _ a normalized.
	r _ b normalized.
	[r1 isZero]
		whileFalse:
			[ | q temp |
			q _ r // r1.
			temp _ r1. r1 _ r - (q * r1). r _ temp.
			temp _ s1. s1 _ s - (q * s1). s _ temp.
			temp _ t1. t1 _ t - (q * t1). t _ temp].
	s _ s * b normalization. t _ t * a normalization.
	u _ r normalization.
	s _ s * u. t _ t * u. r _ r * u.
	^ {r. t. s}! !

!RingElement methodsFor: 'operations' stamp: 'len 1/9/2022 08:19:15'!
xxgcd: anElement
	"(More) Extended Euclidean algorithm.
	If the receiver is 'a' and the argument is 'b'. answer an array {g. s. t. u. v} where as + bt = g = (a gcd: b), au + bv = 0, and sv - ut = 1, i.e. answer the coefficients of a unimodular matrix such that:.
		[s  t] [a]
		[u v] [b] = (g 0)."
	| xgcd g |
	(self isZero and: [anElement isZero]) ifTrue: [^ {self. self parent one. self. self. self parent one}].
"	self parent isIntegralDomain ifFalse: [^ DomainError signal]."
	^ (xgcd _ self xgcd: anElement), {(anElement / (g _ xgcd at: 1)) negated. self / g}! !

!RingElement methodsFor: 'testing' stamp: 'len 4/27/2021 12:41:11'!
isCentral
	"Answer true if the receiver is in the center of its parent algebra."
	^ self parent center contains: self! !

!RingElement methodsFor: 'testing' stamp: 'len 6/11/2020 12:31:32'!
isIdempotent
	^ self squared isOne! !

!RingElement methodsFor: 'testing' stamp: 'len 5/10/2020 11:49:43'!
isIdentity
	^ self isOne! !

!RingElement methodsFor: 'testing' stamp: 'len 5/4/2020 09:27:40'!
isIrreducible
	"A nonzero nonunit element 'a' is called irreducible if a=bc implies that a|b (and then c is a unit) or a|c (and then b is a unit)."
	(self isZero or: [self isUnit]) ifTrue: [^ false].
	self parent isIntegralDomain ifTrue: [^ self isPrime].
	self parent isFinite ifFalse: [^ self subclassResponsibility].
	self parent do: [:x|
		self parent do: [:y|
			x*y = self ifTrue: [(x isUnit or: [y isUnit]) ifFalse: [^ false]]]].
	^ true! !

!RingElement methodsFor: 'testing' stamp: 'len 7/30/2019 05:25:00'!
isNilpotent
	"Answer true if self^n = 0 for some integer n >= 1."
	^ self parent nilradical contains: self! !

!RingElement methodsFor: 'testing' stamp: 'len 9/24/2018 02:11:01'!
isOne
	^ self = self parent one! !

!RingElement methodsFor: 'testing' stamp: 'len 5/4/2020 09:33:07'!
isPrime
	"A nonzero nonunit element 'a' is called prime if a|bc implies that a|b or a|c."
	(self isZero or: [self isUnit]) ifTrue: [^ false].
	self parent isFinite ifFalse: [^ self subclassResponsibility].
	self parent do: [:x|
		self parent do: [:y| | xy |
			((xy _ x*y) isZero not and: [self | (xy)])
				ifTrue: [(self | x or: [self | y]) ifFalse: [^ false]]]].
	^ true! !

!RingElement methodsFor: 'testing' stamp: 'len 7/21/2019 12:47:10'!
isReal
	^ false! !

!RingElement methodsFor: 'testing' stamp: 'len 6/20/2019 18:19:45'!
isReducible
	"A nonzero nonunit element is called 'reducible' if it is not irreducible."
	^ self isZero not and: [self isUnit not and: [self isIrreducible not]]! !

!RingElement methodsFor: 'testing' stamp: 'len 4/23/2021 11:17:20'!
isUnit
	"Answer true if the receiver is invertible."
	self parent isDivisionRing ifTrue: [^ self isZero not].
	^ self inverse notNil! !

!RingElement methodsFor: 'testing' stamp: 'len 9/24/2018 02:10:54'!
isZero
	^ self = self parent zero! !

!RingElement methodsFor: 'testing' stamp: 'len 1/6/2022 09:28:51'!
isZerodivisor
	"Answer true if there exists a nonzero element that multiplied by the receiver is zero."
	self parent isIntegralDomain ifTrue: [^ self isZero].
	self parent isFinite ifFalse: [^ self notYetImplemented].
	^ self parent anySatisfy: [:any| any isZero not and: [(self * any) isZero]]! !

!OppositeRingElement methodsFor: 'accessing' stamp: 'len 4/26/2021 11:21:37'!
opposite
	^ opposite! !

!OppositeRingElement methodsFor: 'comparing' stamp: 'len 4/26/2021 11:20:57'!
= anElement
	^ self class = anElement class and: [opposite = anElement opposite]! !

!OppositeRingElement methodsFor: 'comparing' stamp: 'len 4/26/2021 11:21:05'!
hash
	^ opposite hash! !

!OppositeRingElement methodsFor: 'operations' stamp: 'len 4/26/2021 11:21:22'!
* anElement
	^ self class opposite: anElement opposite * opposite! !

!OppositeRingElement methodsFor: 'operations' stamp: 'len 4/26/2021 11:21:32'!
inverse
	^ self class opposite: opposite inverse! !

!OppositeRingElement methodsFor: 'private' stamp: 'len 4/26/2021 11:21:41'!
parent
	^ opposite parent opposite! !

!OppositeRingElement class methodsFor: 'instance creation' stamp: 'len 4/26/2021 11:22:25'!
opposite: anElement
	^ self new opposite: anElement! !

!ProductRingElement methodsFor: 'accessing' stamp: 'len 4/23/2020 01:42:02'!
at: anInteger
	^ components at: anInteger! !

!ProductRingElement methodsFor: 'accessing' stamp: 'len 1/4/2022 10:56:44'!
gauge
	"Answer the value of the Euclidean function at the receiver."
	^ components inject: 0 asOrdinal into: [:answer :each|   * answer + each gauge asOrdinal]! !

!ProductRingElement methodsFor: 'accessing' stamp: 'len 4/23/2020 01:37:47'!
parent
	^ parent! !

!ProductRingElement methodsFor: 'accessing' stamp: 'len 4/23/2020 01:41:55'!
size
	^ components size! !

!ProductRingElement methodsFor: 'comparing' stamp: 'len 4/23/2020 01:40:33'!
= anObject
	^ self class = anObject class and: [components = anObject components]! !

!ProductRingElement methodsFor: 'comparing' stamp: 'len 4/23/2020 01:41:03'!
hash
	^ components hash! !

!ProductRingElement methodsFor: 'operations' stamp: 'len 5/3/2020 09:48:18'!
* anElement
	anElement isInteger ifTrue: [^ self class new parent: parent; components: components * anElement].
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #*].
	^ self class new parent: parent; components: components * anElement components! !

!ProductRingElement methodsFor: 'operations' stamp: 'len 4/23/2020 01:39:27'!
+ anElement
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #+].
	^ self class new parent: parent; components: components + anElement components! !

!ProductRingElement methodsFor: 'operations' stamp: 'len 1/6/2022 19:40:27'!
// anElement
	| a1 a2 b1 b2 |
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #//].
	anElement isZero ifTrue: [^ InversionError signal: anElement].
	components size = 2 ifFalse: [^ self notYetImplemented].
	a1 _ self at: 1.
	a2 _ self at: 2.
	b1 _ anElement at: 1.
	b2 _ anElement at: 2.
	(b1 isZero not and: [b2 isZero not]) ifTrue:
		[ | q1 q2 r1 r2 |
		q1 _ a1 // b1.
		q2 _ a2 // b2.
		r1 _ a1 - (b1*q1).
		r2 _ a2 - (b2*q2).
		r1 isZero = r2 isZero ifTrue: [^ parent compose: {q1. q2}].
		r1 isZero ifTrue: [^ parent compose: {q1 - 1. q2}].
		^ parent compose: {q1. q2 - 1}].
	self notYetImplemented.
	^ parent compose: (components with: anElement components collect: [:a :b| b isZero ifTrue: [b] ifFalse: [a // b]])! !

!ProductRingElement methodsFor: 'operations' stamp: 'len 5/17/2020 07:26:25'!
gcd: anElement
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #gcd:].
	^ parent compose: (components with: anElement components collect: [:a :b| a gcd: b])! !

!ProductRingElement methodsFor: 'operations' stamp: 'len 4/25/2020 06:39:41'!
inverse
	^ self class new parent: parent; components: (components collect: [:each| each inverse])! !

!ProductRingElement methodsFor: 'operations' stamp: 'len 5/17/2020 07:27:12'!
lcm: anElement
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #lcm:].
	^ parent compose: (components with: anElement components collect: [:a :b| a lcm: b])! !

!ProductRingElement methodsFor: 'operations' stamp: 'len 4/25/2020 06:39:56'!
negated
	^ self class new parent: parent; components: (components collect: [:each| each negated])! !

!ProductRingElement methodsFor: 'operations' stamp: 'len 12/10/2021 19:20:25'!
normalization
	"Answer a unit u such that 'self * u' is a unique choice of associate. See >>normalized."
	^ parent compose: (components collect: [:each| each normalization])! !

!ProductRingElement methodsFor: 'testing' stamp: 'len 1/4/2022 11:02:15'!
isOne
	^ components allSatisfy: [:each| each isOne]! !

!ProductRingElement methodsFor: 'testing' stamp: 'len 5/4/2020 09:36:53'!
isUnit
	"Answer true if the receiver is invertible."
	^ components allSatisfy: [:each| each isUnit]! !

!ProductRingElement methodsFor: 'testing' stamp: 'len 1/4/2022 11:02:09'!
isZero
	^ components allSatisfy: [:each| each isZero]! !

!ProductRingElement methodsFor: 'testing' stamp: 'len 1/6/2022 09:28:19'!
isZerodivisor
	"Answer true if there exists a nonzero element that multiplied by the receiver is zero."
	^ components anySatisfy: [:any| any isZerodivisor]! !

!ProductRingElement methodsFor: 'private' stamp: 'len 4/23/2020 01:37:55'!
components
	^ components! !

!ProductRingElement methodsFor: 'private' stamp: 'len 4/23/2020 01:38:03'!
components: anArray
	components _ anArray! !

!ProductRingElement methodsFor: 'private' stamp: 'len 4/23/2020 01:38:31'!
parent: aProductRing
	parent _ aProductRing! !

!Ratio methodsFor: 'accessing' stamp: 'len 12/28/2015 20:31'!
bitSize
	^ numerator bitSize + denominator bitSize! !

!Ratio methodsFor: 'accessing' stamp: 'len 11/28/2015 06:28'!
denominator
	^ denominator! !

!Ratio methodsFor: 'accessing' stamp: 'len 11/28/2015 06:28'!
numerator
	^ numerator! !

!Ratio methodsFor: 'accessing' stamp: 'len 7/10/2019 10:45:14'!
parent
	^ numerator parent fractions! !

!Ratio methodsFor: 'accessing' stamp: 'len 3/3/2021 07:45:01'!
representative
	| F |
	F _ self parent integers base fractions.
	^ F !! self numerator representative / (F !! self denominator representative)! !

!Ratio methodsFor: 'accessing' stamp: 'len 5/8/2020 18:22:25'!
valuation
	"If the receiver is an element of a valuation ring or a Euclidean ring, answer its valuation or Euclidean function."
	^ numerator valuation - denominator valuation! !

!Ratio methodsFor: 'accessing' stamp: 'len 7/31/2019 05:42:19'!
valuation: p
	"Answer the p-adic valuation of the receiver."
	^ (numerator valuation: p) - (denominator valuation: p)! !

!Ratio methodsFor: 'accessing-multivariate' stamp: 'len 8/14/2019 08:21:18'!
degree
	^ numerator degree - denominator degree! !

!Ratio methodsFor: 'accessing-multivariate' stamp: 'len 1/7/2022 13:50:24'!
degreeIn: anIndeterminate
	^ (numerator degreeIn: anIndeterminate) - (denominator degreeIn: anIndeterminate)! !

!Ratio methodsFor: 'accessing-multivariate' stamp: 'len 8/14/2019 08:22:48'!
independentCoefficient
	self isIntegral ifFalse: [^ DomainError signal: 'not integral'].
	^ numerator independentCoefficient! !

!Ratio methodsFor: 'accessing-multivariate' stamp: 'len 8/14/2019 08:23:11'!
indeterminates
	^ Set new addAll: numerator indeterminates; addAll: denominator indeterminates; yourself! !

!Ratio methodsFor: 'accessing-multivariate' stamp: 'len 8/14/2019 08:23:30'!
leadingCoefficient
	self isIntegral ifFalse: [^ DomainError signal: 'not integral'].
	^ numerator leadingCoefficient! !

!Ratio methodsFor: 'accessing-multivariate' stamp: 'len 8/14/2019 08:23:48'!
leadingMonomial
	self isIntegral ifFalse: [^ DomainError signal: 'not integral'].
	^ numerator leadingMonomial! !

!Ratio methodsFor: 'accessing-multivariate' stamp: 'len 12/27/2021 07:56:32'!
leadingTerm
	^ self parent numerator: numerator leadingTerm denominator: denominator! !

!Ratio methodsFor: 'comparing' stamp: 'len 7/30/2019 05:14:23'!
<= anElement
	^ numerator * anElement denominator <= (anElement numerator * denominator)! !

!Ratio methodsFor: 'comparing' stamp: 'len 1/2/2022 17:38:07'!
= anObject
	^ self class = anObject class and: [numerator * anObject denominator = (denominator * anObject numerator)]! !

!Ratio methodsFor: 'comparing' stamp: 'len 11/28/2015 06:36'!
hash
	^ 0! !

!Ratio methodsFor: 'operations' stamp: 'len 1/2/2022 17:44:59'!
* anElement
	anElement isInteger ifTrue: [^ self parent numerator: numerator * anElement denominator: denominator].
	(self parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #*].
	"Assuming we have GCD, this could be optimized by reducing first taking crossed GCDs:"
	^ self parent numerator: numerator * anElement numerator denominator: denominator * anElement denominator! !

!Ratio methodsFor: 'operations' stamp: 'len 12/27/2021 07:49:55'!
+ anElement
	(self parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #+].
	^ self parent
		numerator: numerator * anElement denominator + (denominator * anElement numerator)
		denominator: denominator * anElement denominator! !

!Ratio methodsFor: 'operations' stamp: 'len 1/3/2022 11:28:35'!
// anElement
	"Answer the quotient of the division of the receiver by anElement."
	anElement isUnit ifTrue: [^ self * anElement inverse].
	self flag: #fix. "this looks wrong:"
	^ self parent numerator: numerator * anElement denominator // anElement numerator denominator: denominator! !

!Ratio methodsFor: 'operations' stamp: 'len 12/27/2021 07:49:17'!
^ anInteger
	anInteger = 1 ifTrue: [^ self].
	anInteger < 0 ifTrue: [^ self inverse ^ anInteger negated].
	^ self parent
		reducedNumerator: numerator ^ anInteger
		denominator: denominator ^ anInteger! !

!Ratio methodsFor: 'operations' stamp: 'len 7/17/2019 11:14:07'!
height
	^ numerator height max: denominator height! !

!Ratio methodsFor: 'operations' stamp: 'len 1/6/2022 19:45:05'!
inverse
	| u |
	self isUnit ifFalse: [^ InversionError signal: self].
	u _ numerator normalization.
	^ self parent reducedNumerator: denominator * u denominator: numerator * u! !

!Ratio methodsFor: 'operations' stamp: 'len 12/27/2021 07:50:51'!
negated 
	^ self parent reducedNumerator: numerator negated denominator: denominator! !

!Ratio methodsFor: 'operations' stamp: 'len 12/27/2021 07:53:53'!
normalization
	"Answer a unit u such that 'self * u' is a unique choice of associate. See >>normalized."
	self isUnit ifTrue: [^ self inverse].
	^ self parent reducedNumerator: denominator * numerator normalization denominator: denominator one! !

!Ratio methodsFor: 'operations' stamp: 'len 12/29/2021 13:59:08'!
squared
	^ self parent reducedNumerator: numerator squared denominator: denominator squared! !

!Ratio methodsFor: 'operations' stamp: 'len 1/9/2022 13:27:49'!
value: anObject
	^ (numerator value: anObject) / (denominator value: anObject)! !

!Ratio methodsFor: 'operations' stamp: 'len 1/9/2022 13:28:15'!
valueWithArguments: anArray
	^ (numerator valueWithArguments: anArray) / (denominator valueWithArguments: anArray)! !

!Ratio methodsFor: 'testing' stamp: 'len 1/2/2022 17:42:47'!
isIntegral
	^ denominator isOne! !

!Ratio methodsFor: 'testing' stamp: 'len 7/30/2019 05:27:02'!
isNilpotent
	"Answer true if self^n = 0 for some integer n >= 1."
	^ numerator isNilpotent! !

!Ratio methodsFor: 'testing' stamp: 'len 1/6/2022 09:25:55'!
isUnit
	"Answer true if the receiver is invertible."
	^ self isZerodivisor not! !

!Ratio methodsFor: 'testing' stamp: 'len 11/28/2015 06:36'!
isZero
	^ numerator isZero! !

!Ratio methodsFor: 'testing' stamp: 'len 1/6/2022 09:28:29'!
isZerodivisor
	"Answer true if there exists a nonzero element that multiplied by the receiver is zero."
	^ numerator isZerodivisor! !

!Ratio methodsFor: 'private' stamp: 'len 1/2/2022 09:49:29'!
reduce
	| gcd u |
	numerator isZero ifTrue: [denominator _ numerator one. ^ self].
	gcd _ numerator gcd: denominator.
	numerator _ numerator / gcd.
	denominator _ denominator / gcd.
	u _ denominator normalization.
	numerator _ numerator * u.
	denominator _ denominator * u! !

!Ratio methodsFor: 'private' stamp: 'len 3/3/2021 14:21:09'!
setNumerator: anElement denominator: anotherElement
	numerator _ anElement.
	denominator _ anotherElement! !

!Ratio class methodsFor: 'instance creation' stamp: 'len 4/7/2018 00:41:16'!
reducedNumerator: anObject denominator: anotherObject
	^ self new setNumerator: anObject denominator: anotherObject! !

!Germ methodsFor: 'accessing' stamp: 'len 6/29/2019 18:19:48'!
parent
	^ parent! !

!Germ methodsFor: 'accessing' stamp: 'len 1/9/2022 21:42:05'!
valuation
	"Answer the p-adic valuation of the receiver."
	^ self valuation: parent p! !

!Germ methodsFor: 'comparing' stamp: 'len 12/22/2021 14:36:41'!
= anObject
	parent = anObject parent ifFalse: [^ false].
	parent integers isIntegralDomain
		ifTrue: [^ numerator * anObject denominator = (denominator * anObject numerator)].
	"when we have canonical associates we can do this:
	parent integers hasCanonicalAssociates
		ifTrue: [^ (numerator * anObject denominator) normalized = (denominator * anObject numerator) normalized]."
	^ ((numerator * anObject denominator - (denominator * anObject numerator)) annihilatorIdeal <= parent localizationIdeal) not! !

!Germ methodsFor: 'operations' stamp: 'len 1/6/2022 19:39:09'!
// anElement
	"Answer the quotient of the Euclidean division of the receiver by the argument."
	| v |
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #//].
	anElement isZero ifTrue: [^ InversionError signal: anElement].
	self isZero ifTrue: [^ self].
	(v _ self valuation - anElement valuation) < 0 ifTrue: [^ self zero].
	^ self normalization inverse * anElement normalization * (parent p ^ v)! !

!Germ methodsFor: 'operations' stamp: 'len 12/29/2021 13:57:31'!
^ anInteger
	anInteger = 1 ifTrue: [^ self].
	anInteger < 0 ifTrue: [^ self inverse ^ anInteger negated].
	^ parent reducedNumerator: numerator ^ anInteger denominator: denominator ^ anInteger! !

!Germ methodsFor: 'operations' stamp: 'len 8/5/2021 08:35:13'!
factorization
	"If the parent of the receiver is a DVR, this means it is an UFD with unique irreducible element up to multiplication by units."
	^ Bag new add: parent uniformizer withOccurrences: self valuation; yourself! !

!Germ methodsFor: 'operations' stamp: 'len 1/9/2022 21:23:53'!
gcd: anElement
	"Answer the greatest common divisor of the receiver and the argument,
	i.e. a generator of the principal ideal generated by the reciever and the argument.
	The result is the canonical associate (normalized)."
	self isZero ifTrue: [^ anElement normalized].
	anElement isZero ifTrue: [^ self normalized].
	^ parent uniformizer ^ (self valuation min: anElement valuation)! !

!Germ methodsFor: 'operations' stamp: 'len 6/29/2019 17:46:38'!
lcm: anElement
	self isZero ifTrue: [^ self].
	anElement isZero ifTrue: [^ anElement].
	^ parent uniformizer ^ (self valuation max: anElement valuation)! !

!Germ methodsFor: 'operations' stamp: 'len 1/3/2022 11:57:03'!
normalization
	"Answer a unit u such that 'self * u' is a unique choice of associate. See >>normalized."
	| p q |
	self isZero ifTrue: [^ parent one].
	p _ parent p.
	q _ numerator.
	[p | q] whileTrue: [q _ q // p]. "TODO: optimize this, it's computing division twice"
	^ parent reducedNumerator: denominator denominator: q! !

!Germ methodsFor: 'testing' stamp: 'len 1/2/2022 17:50:45'!
isUnit
	"Answer true if the receiver is invertible."
	^ (parent localizationIdeal includes: numerator) not! !

!Germ methodsFor: 'private' stamp: 'len 6/28/2019 13:24:53'!
parent: aLocalRing
	parent _ aLocalRing! !

!Rational methodsFor: 'printing' stamp: 'len 8/1/2020 18:41:49'!
printOn: aStream base: base
	^ self asFraction printOn: aStream base: base! !

!Rational methodsFor: 'accessing' stamp: 'len 7/21/2019 04:48:21'!
imaginary
	^ self zero! !

!Rational methodsFor: 'accessing' stamp: 'len 5/23/2020 09:33:01'!
minimalPolynomial
	^  polynomials x - self! !

!Rational methodsFor: 'accessing' stamp: 'len 5/23/2020 09:33:01'!
parent
	^ ! !

!Rational methodsFor: 'accessing' stamp: 'len 7/21/2019 04:48:12'!
real
	^ self! !

!Rational methodsFor: 'comparing' stamp: 'len 7/17/2019 08:41:44'!
< anElement
	anElement isFloat ifTrue: [^ self asFloat < anElement].
	^ numerator * anElement denominator < (anElement numerator * denominator)! !

!Rational methodsFor: 'comparing' stamp: 'len 7/17/2019 08:41:36'!
<= anElement
	anElement isFloat ifTrue: [^ self asFloat <= anElement].
	^ numerator * anElement denominator <= (anElement numerator * denominator)! !

!Rational methodsFor: 'comparing' stamp: 'len 7/17/2019 11:23:10'!
= anObject
	anObject isInteger ifTrue: [^ denominator = 1 and: [numerator = anObject]].
	anObject isFraction ifTrue: [^ numerator = anObject numerator and: [denominator = anObject denominator]].
	^ super = anObject! !

!Rational methodsFor: 'comparing' stamp: 'len 7/17/2019 11:24:56'!
hash
	^ self isIntegral ifTrue: [numerator hash] ifFalse: [self asFloat hash]! !

!Rational methodsFor: 'converting' stamp: 'len 7/21/2019 08:56:58'!
adaptToAlgebraic: rcvr andSend: selector
	^ rcvr perform: selector with: (ComplexAlgebraicNumber fromRational: self)! !

!Rational methodsFor: 'converting' stamp: 'len 7/17/2019 08:34:42'!
adaptToFloat: rcvr andSend: selector 
	"If I am involved in arithmetic with a Float, convert me to a Float."
	^ rcvr perform: selector with: self asFloat! !

!Rational methodsFor: 'converting' stamp: 'len 7/17/2019 03:12:15'!
adaptToFraction: rcvr andSend: selector
	^ self parent !! rcvr perform: selector with: self! !

!Rational methodsFor: 'converting' stamp: 'len 7/17/2019 03:13:48'!
adaptToInteger: rcvr andSend: selector
	^ self parent !! rcvr perform: selector with: self! !

!Rational methodsFor: 'converting' stamp: 'len 7/21/2019 08:57:06'!
adaptToRealAlgebraic: rcvr andSend: selector
	^ rcvr perform: selector with: (RealAlgebraicNumber fromRational: self)! !

!Rational methodsFor: 'converting' stamp: 'len 7/17/2019 08:33:51'!
asFloat
	^ self asFraction asFloat! !

!Rational methodsFor: 'converting' stamp: 'len 7/16/2019 16:23:35'!
asFraction
	^ numerator / denominator! !

!Rational methodsFor: 'converting' stamp: 'len 7/16/2019 16:41:22'!
asInteger
	self isIntegral ifFalse: [^ DomainError signal: 'not integral'].
	^ numerator! !

!Rational methodsFor: 'operations' stamp: 'len 7/19/2021 11:50:32'!
* anElement
	| d1 d2 |
	anElement isFraction ifFalse: [^ super * anElement].
	d1 _ numerator gcd: anElement denominator.
	d2 _ denominator gcd: anElement numerator.
	(d2 = denominator and: [d1 = anElement denominator])
		ifTrue: [^ self class reducedNumerator: numerator // d1 * (anElement numerator // d2) denominator: 1].
	^ self class
		reducedNumerator: numerator // d1 * (anElement numerator // d2)
		denominator: denominator // d2 * (anElement denominator // d1)! !

!Rational methodsFor: 'operations' stamp: 'len 7/23/2021 11:19:08'!
+ anElement
	| d d1 d2 n |
	anElement isFraction ifFalse: [^ super + anElement].
	d _ denominator gcd: anElement denominator.
	n _ numerator * (d1 _ anElement denominator // d) + (anElement numerator * (d2 _ denominator // d)).
	d1 _ d1 * d2.
	n _ n // (d2 _ n gcd: d).
	d _ d1 * (d // d2).
	^ self class reducedNumerator: n denominator: d! !

!Rational methodsFor: 'operations' stamp: 'len 7/17/2019 03:34:48'!
abs
	^ self class reducedNumerator: numerator abs denominator: denominator! !

!Rational methodsFor: 'operations' stamp: 'len 7/21/2019 08:56:49'!
abs: p
	"Answer the p-adic absolute value of the receiver."
	^ (numerator abs: p) / (denominator abs: p)! !

!Rational methodsFor: 'operations' stamp: 'len 7/17/2019 11:13:35'!
height
	^ numerator abs max: denominator! !

!Rational methodsFor: 'operations' stamp: 'len 12/10/2021 19:19:36'!
normalization
	"Answer a unit u such that 'self * u' is a unique choice of associate. See >>normalized."
	^ self isZero ifTrue: [self one] ifFalse: [self inverse]! !

!Rational methodsFor: 'operations' stamp: 'len 7/19/2019 06:58:54'!
rounded
	"Answer the integer nearest the receiver."
	^ numerator + ((denominator bitShift: -1) * numerator sign)  // denominator! !

!Rational methodsFor: 'operations' stamp: 'len 7/17/2019 03:21:26'!
sign
	^ numerator sign! !

!Rational methodsFor: 'operations' stamp: 'len 8/3/2020 08:30:39'!
sqrt
	| n d answer |
	n _ numerator sqrt.
	d _ denominator sqrt.
	(n isInteger and: [d isInteger]) ifTrue: [^ self class reducedNumerator: n denominator: d].
	"The #sqrt method in integer will only answer a Float if there's no exact square root.
	So, we need a float anyway."
	(n isInfinite or: [d isInfinite]) ifTrue: [^ self asFloat sqrt].
	answer _ n / d.
	answer isNaN ifTrue: [^ self asFloat sqrt].
	^ answer! !

!Rational methodsFor: 'operations' stamp: 'len 7/19/2019 07:28:52'!
squareRoot
	self positive ifTrue: [^ RealAlgebraicNumber sqrt: self].
	^ ComplexAlgebraicNumber sqrt: self! !

!Rational methodsFor: 'testing' stamp: 'len 7/17/2019 08:44:18'!
isFraction
	^ true! !

!Rational methodsFor: 'testing' stamp: 'len 7/31/2020 18:03:45'!
isNumber
	^ true! !

!Rational methodsFor: 'testing' stamp: 'len 7/21/2019 12:45:17'!
isRational
	^ true! !

!Rational methodsFor: 'testing' stamp: 'len 7/21/2019 12:46:51'!
isReal
	^ true! !

!Rational methodsFor: 'testing' stamp: 'len 5/8/2020 17:00:34'!
isUnit
	^ self isZero not! !

!Rational methodsFor: 'testing' stamp: 'len 7/19/2019 07:29:10'!
negative
	^ numerator negative! !

!Rational methodsFor: 'testing' stamp: 'len 7/19/2019 07:29:02'!
positive
	^ numerator positive! !

!Rational methodsFor: 'testing' stamp: 'len 7/19/2019 07:29:26'!
strictlyPositive
	^ numerator strictlyPositive! !

!RationalFunction methodsFor: 'operations' stamp: 'len 1/2/2022 09:43:05'!
derivative
	| a g |
	a _ denominator * numerator derivative - (numerator * denominator derivative).
	g _ denominator gcd: a.
	^ self parent numerator: a // g denominator: (denominator // g) squared * g! !

!RationalFunction methodsFor: 'operations' stamp: 'len 1/2/2022 09:43:10'!
homogenized
	"Answer the homogenization of the receiver introducing a new indeterminate."
	| R S |
	R _ numerator parent.
	S _ R scalars polynomialsIn: R rank + 1.
	^ self parent numerator: (S !! numerator homogenizedIn: S rank) denominator: (S !! denominator homogenizedIn: S rank)! !

!RationalFunction methodsFor: 'operations' stamp: 'len 1/2/2022 09:43:18'!
homogenizedIn: anIndeterminate
	"Answer the homogenization of the receiver in the given indeterminate."
	^ self parent numerator: (numerator homogenizedIn: anIndeterminate) denominator: (denominator homogenizedIn: anIndeterminate)! !

!RationalFunction methodsFor: 'roots and poles' stamp: 'len 3/24/2018 20:30:55'!
allPoles
	^ denominator allRoots! !

!RationalFunction methodsFor: 'roots and poles' stamp: 'len 3/24/2018 20:30:46'!
allPolesIn: aRing
	^ denominator allRootsIn: aRing! !

!RationalFunction methodsFor: 'roots and poles' stamp: 'len 3/24/2018 20:30:17'!
allRoots
	^ numerator allRoots! !

!RationalFunction methodsFor: 'roots and poles' stamp: 'len 3/24/2018 20:30:25'!
allRootsIn: aRing
	"Answer the roots (counted with multiplicity) in the given domain."
	^ numerator allRootsIn: aRing! !

!RationalFunction methodsFor: 'roots and poles' stamp: 'len 12/4/2017 20:39:51'!
orderAt: aNumber
	^ (numerator multiplicityAt: aNumber) - (denominator multiplicityAt: aNumber)! !

!RationalFunction methodsFor: 'roots and poles' stamp: 'len 2/12/2016 02:56'!
poles
	^ denominator roots! !

!RationalFunction methodsFor: 'roots and poles' stamp: 'len 3/24/2018 20:30:38'!
polesIn: aRing
	^ denominator rootsIn: aRing! !

!RationalFunction methodsFor: 'roots and poles' stamp: 'len 2/12/2016 02:56'!
roots
	^ numerator roots! !

!RationalFunction methodsFor: 'roots and poles' stamp: 'len 3/24/2018 20:30:33'!
rootsIn: aRing
	^ numerator rootsIn: aRing! !

!RationalFunction methodsFor: 'testing' stamp: 'len 8/8/2019 08:42:14'!
isAffineLinear
	^ numerator isAffineLinear and: [denominator isConstant]! !

!RationalFunction methodsFor: 'testing' stamp: 'len 11/4/2016 09:49'!
isHomogeneous
	^ self numerator isHomogeneous and: [self denominator isHomogeneous]! !

!RationalFunction methodsFor: 'testing' stamp: 'len 10/17/2016 09:39'!
isLinear
	^ denominator isLinear and: [denominator isConstant]! !

!Residue methodsFor: 'accessing' stamp: 'len 12/28/2015 20:32'!
bitSize
	^ representative bitSize! !

!Residue methodsFor: 'accessing' stamp: 'len 8/14/2019 04:35:05'!
lift
	^ representative! !

!Residue methodsFor: 'accessing' stamp: 'len 11/30/2016 19:16:51'!
modulus
	^ parent modulus! !

!Residue methodsFor: 'accessing' stamp: 'len 10/16/2016 15:57'!
one
	^ parent one! !

!Residue methodsFor: 'accessing' stamp: 'len 11/3/2016 04:43'!
parent
	^ parent! !

!Residue methodsFor: 'accessing' stamp: 'len 11/25/2015 03:11'!
representative
	^ representative! !

!Residue methodsFor: 'accessing' stamp: 'len 5/10/2020 18:24:04'!
valuation
	"If the receiver is an element of a valuation ring or a Euclidean ring, answer its valuation or Euclidean function."
	^ self normalized lift valuation "assuming the lift has minimal valuation in the base ring"! !

!Residue methodsFor: 'accessing' stamp: 'len 10/16/2016 15:58'!
zero
	^ parent zero! !

!Residue methodsFor: 'accessing-multivariate' stamp: 'len 8/14/2019 08:10:39'!
degree
	^ representative degree! !

!Residue methodsFor: 'accessing-multivariate' stamp: 'len 1/9/2022 13:21:42'!
degreeIn: anIndeterminate
	^ representative degreeIn: anIndeterminate! !

!Residue methodsFor: 'accessing-multivariate' stamp: 'len 8/14/2019 08:10:49'!
independentCoefficient
	^ representative independentCoefficient! !

!Residue methodsFor: 'accessing-multivariate' stamp: 'len 8/14/2019 08:10:54'!
indeterminates
	^ representative indeterminates! !

!Residue methodsFor: 'accessing-multivariate' stamp: 'len 8/14/2019 08:11:05'!
leadingCoefficient
	^ representative leadingCoefficient! !

!Residue methodsFor: 'accessing-multivariate' stamp: 'len 8/14/2019 08:11:10'!
leadingMonomial
	^ representative leadingMonomial! !

!Residue methodsFor: 'accessing-multivariate' stamp: 'len 8/14/2019 08:11:16'!
leadingTerm
	^ parent representative: representative leadingTerm! !

!Residue methodsFor: 'accessing-multivariate' stamp: 'len 8/14/2019 08:11:56'!
tail
	^ parent representative: representative tail! !

!Residue methodsFor: 'comparing' stamp: 'len 7/16/2021 11:31:37'!
= anObject
	^ self class = anObject class and: [parent = anObject parent and: [self contains: anObject representative]]! !

!Residue methodsFor: 'comparing' stamp: 'len 1/13/2022 05:47:50'!
| anElement
	"Answer true if the receiver divides anElement."
	anElement isZero ifTrue: [^ true].
	self isZero ifTrue: [^ false].
	^ (representative gcd: anElement representative) | parent modulus! !

!Residue methodsFor: 'comparing' stamp: 'len 7/16/2021 11:10:35'!
hash
	^ parent hasCanonicalReduction ifTrue: [representative hash] ifFalse: [parent hash]! !

!Residue methodsFor: 'conjugation' stamp: 'len 8/9/2020 07:45:57'!
conjugate
	^ self ^ self parent characteristic! !

!Residue methodsFor: 'conjugation' stamp: 'len 4/20/2016 20:23'!
conjugates
	^ Iterator on: [:aBlock| self conjugatesDo: aBlock]! !

!Residue methodsFor: 'conjugation' stamp: 'len 8/14/2019 04:34:51'!
conjugatesDo: aBlock
	"Iterate over the conjugancy class of the receiver, i.e. all the conjugates including the receiver."
	| alpha |
	alpha _ self.
	[aBlock value: alpha.
	alpha _ alpha ^ parent relations scalars characteristic.
	alpha = self] whileFalse! !

!Residue methodsFor: 'operations' stamp: 'len 8/14/2019 04:33:31'!
* anElement
	anElement isInteger ifTrue: [^ parent project: representative * anElement].
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #*].
	^ parent project: representative * anElement representative! !

!Residue methodsFor: 'operations' stamp: 'len 8/14/2019 04:33:18'!
+ anElement
	(parent includes: anElement) ifFalse: [^ self  adapt: anElement andSend: #+].
	^ parent project: representative + anElement representative! !

!Residue methodsFor: 'operations' stamp: 'len 1/9/2022 21:20:32'!
/ anElement
	"Answer x such that xa = b, where b is self and a is anElement.
	The behavior is undefined if a doesn't divide b."
	| euclid |
	self isZero ifTrue: [^ self].
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #/].
	parent base isEuclidean ifFalse: [^ self notYetImplemented].
	euclid _ anElement representative xgcd: self modulus.
	^ parent project: (euclid at: 2) * (representative / (euclid at: 1))! !

!Residue methodsFor: 'operations' stamp: 'len 1/6/2022 19:41:37'!
// anElement
	"Answer the quotient of the division of the receiver by the argument."
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #//].
	anElement isZero ifTrue: [^ InversionError signal: anElement].
	self isZero ifTrue: [^ self].
	^ parent representative: (representative quotientBy: anElement representative modulo: parent modulus)! !

!Residue methodsFor: 'operations' stamp: 'len 1/9/2022 21:19:16'!
annihilator
	"Answer a generator of the ideal of all elements that multiplied by the receiver are zero."
	| euclid |
	euclid _ representative xgcd: parent modulus.
	^ parent representative: ((euclid at: 2) annihilator gcd: parent modulus / (euclid at: 1))! !

!Residue methodsFor: 'operations' stamp: 'len 7/15/2021 10:38:02'!
annihilatorIdeal
	"Answer the ideal of all elements that multiplied by the receiver are zero."
	parent base isPIR ifFalse: [^ super annihilatorIdeal].
	^ parent * self annihilator! !

!Residue methodsFor: 'operations' stamp: 'len 12/29/2021 12:13:20'!
gauge
	"Answer the value of the Euclidean function at the receiver."
	^ self normalized lift gauge "assuming the lift has minimal Euclidean valuation in the base ring"! !

!Residue methodsFor: 'operations' stamp: 'len 1/9/2022 21:22:09'!
gcd: anElement
	"Answer the greatest common divisor of the receiver and the argument,
	i.e. a generator of the principal ideal generated by the reciever and the argument.
	The result is the canonical associate (normalized)."
	parent base isEuclidean ifFalse: [^ self notYetImplemented].
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #gcd:].
	^ (parent project: (representative gcd: anElement representative)) normalized! !

!Residue methodsFor: 'operations' stamp: 'len 1/10/2022 11:45:08'!
inverse
	| euclid |
	self isOne ifTrue: [^ self].
	euclid _ representative xgcd: self modulus.
	^ (euclid at: 1) isOne ifTrue: [parent project: (euclid at: 2)]! !

!Residue methodsFor: 'operations' stamp: 'len 10/16/2016 15:57'!
negated
	^ parent project: representative negated! !

!Residue methodsFor: 'operations' stamp: 'len 1/4/2022 09:15:37'!
normalization
	"Answer a unit u such that 'self * u' is a unique choice of associate. See >>normalized."
	"Adapted from ModularInteger>>\. This algorithm solves the congruence ax = self (mod m) where 'a' is the canonical associate of the receiver, and then looks for a solution 'x' that is a unit."
	| a x modulus m euclid |
	self isZero ifTrue: [^ parent one].
	self flag: #fix. "optimize and generalize for when base is not a PIR"
	"See [Sto00], pag. 15."
	parent base isEuclidean ifFalse: [^ self notYetImplemented].
	a _ representative gcd: (modulus _ parent modulus).
	a isOne ifTrue: [^ self inverse].
	x _ representative // a.
	m _ modulus // a.
	[(euclid _ x xgcd: modulus) first isOne] whileFalse: [x _ x + m].
	^ parent project: euclid second! !

!Residue methodsFor: 'operations' stamp: 'len 8/14/2019 08:11:36'!
value: anObject
	^ representative value: anObject! !

!Residue methodsFor: 'operations' stamp: 'len 8/14/2019 08:11:41'!
valueWithArguments: anArray
	^ representative valueWithArguments: anArray! !

!Residue methodsFor: 'operations' stamp: 'len 1/9/2022 21:18:05'!
xgcd: anElement
	"Extended Euclidean algorithm.
	If the receiver is 'a' and the argument is 'b'. answer an array {g. s. t} where as + bt = g = (a gcd: b)."
	| euclid g u |
	parent base isEuclidean ifFalse: [^ self notYetImplemented].
	euclid _ representative xgcd: anElement representative.
	g _ parent project: (euclid at: 1).
	u _ g normalization.
	^ {g * u. (parent project: (euclid at: 2)) * u. (parent project: (euclid at: 3)) * u}! !

!Residue methodsFor: 'operations' stamp: 'len 7/30/2021 10:48:11'!
xxgcd: anElement
	"(More) Extended Euclidean algorithm.
	If the receiver is 'a' and the argument is 'b'. answer an array {g. s. t. u. v} where as + bt = g = (a gcd: b), au + bv = 0, and sv - ut = 1, i.e. answer the coefficients of a unimodular matrix such that:.
		[s  t] [a]
		[u v] [b] = (g 0)."
	| result g s t u v x |
	(self isZero and: [anElement isZero]) ifTrue: [^ {self. self parent one. self. self. self parent one}].
	result _ representative xxgcd: anElement representative.
	g _ parent project: (result at: 1).
	x _ g normalization.
	g _ g * x.
	s _ (parent project: (result at: 2)) * x.
	t _ (parent project: (result at: 3)) * x.
	u _ (parent project: (result at: 4)) * x.
	v _ (parent project: (result at: 5)) * x.
	x _ (s*v - (u*t)) inverse.
	u _ u * x.
	v _ v * x.
	^ {g. s. t. u. v}! !

!Residue methodsFor: 'testing' stamp: 'len 1/9/2022 13:55:34'!
contains: anObject
	^ parent relations contains: anObject - representative! !

!Residue methodsFor: 'testing' stamp: 'len 9/15/2018 16:07:16'!
includes: anObject
	^ (parent base includes: anObject) and: [self contains: anObject]! !

!Residue methodsFor: 'testing' stamp: 'len 8/3/2021 13:19:10'!
isUnit
	"Answer true if the receiver is invertible."
	^ self inverse notNil! !

!Residue methodsFor: 'testing' stamp: 'len 3/18/2020 17:21:12'!
isZero
	^ representative isZero

"this is unnecesary if the representative of 0 is ensured to be 0:
	^ (parent relations remainderOf: representative) isZero
"! !

!Residue methodsFor: 'private' stamp: 'len 10/16/2016 16:01'!
parent: aQuotientRing
	parent _ aQuotientRing! !

!Residue methodsFor: 'private' stamp: 'len 11/25/2015 03:12'!
representative: anObject
	representative _ anObject! !

!ModularInteger methodsFor: 'accessing' stamp: 'len 4/21/2016 05:55'!
bitSize
	^ representative bitSize! !

!ModularInteger methodsFor: 'accessing' stamp: 'len 8/5/2021 08:35:56'!
factorization
	"Answer a collection with the irreducible factors of the receiver (with multiplicity)."
	^ (self normalized representative factorization apply: [:each| parent representative: each]) select: [:each| each isIrreducible]! !

!ModularInteger methodsFor: 'accessing' stamp: 'len 4/4/2021 09:51:40'!
lift
	"Answer a balanced integer representative."
	| m |
	m _ parent modulus.
	^ representative <= (m >> 1) ifTrue: [representative] ifFalse: [representative - m]! !

!ModularInteger methodsFor: 'accessing' stamp: 'len 3/29/2016 20:49'!
representative
	^ representative! !

!ModularInteger methodsFor: 'comparing' stamp: 'len 9/16/2018 16:14:36'!
= aModularInteger
	self class == aModularInteger class ifFalse: [^ false].
	self == aModularInteger ifTrue: [^ true].
	^ representative = aModularInteger representative and: [parent = aModularInteger parent]! !

!ModularInteger methodsFor: 'comparing' stamp: 'len 3/29/2016 20:48'!
hash
	^ representative hash! !

!ModularInteger methodsFor: 'converting' stamp: 'len 12/2/2016 09:43:47'!
asRational
	"Answer the rational reconstruction of the receiver, or nil if it doesn't exist."
	| N |
	N _ (self modulus // 2) sqrtFloor.
	^ self asRationalMaxNumerator: N maxDenominator: N! !

!ModularInteger methodsFor: 'converting' stamp: 'len 7/30/2021 12:38:12'!
asRational: T
	"Answer the rational reconstruction of the receiver, or nil if not found.
	This is the MQRR (Maximal Quotient Rational Reconstruction) algorithm.
	The parameter T > 0 bounds the size of the possible outputs. If u is the representative of the receiver and m is the modulus, the algorithm returns a rational n/d = u mod m, d > 0, gcd(n,d) = 1 and T*|n|*d < m, or fails.
	The algorithm is almost optimal in the sense that requires that the modulus be only a modest number bits longer than 2*|n|*d. The time complexity is O(log^2 m).
	See [Mon04]."
	| T2 n d t0 r0 t1 r1 temp answer |
	representative == 0 ifTrue: [^ self modulus > T ifTrue: [0]].
	n _ 0. d _ 0.
	t0 _ 0. r0 _ self modulus.
	t1 _ 1. r1 _ representative.
	T2 _ T.
	[r1 ~~ 0 and: [r0 > T2]]
		whileTrue:
			[| q |
			(q _ r0 // r1) > T2
				ifTrue: [n _ r1. d _ t1. T2 _ q].
			temp _ r0 - (q * r1). r0 _ r1. r1 _ temp.
			temp _ t0 - (q * t1). t0 _ t1. t1 _ temp].
	^ (d ~~ 0 and: [(answer _ (n/d) asRational) numerator abs = n abs]) ifTrue: [answer]! !

!ModularInteger methodsFor: 'converting' stamp: 'len 3/11/2021 15:26:11'!
asRationalMaxNumerator: N maxDenominator: D
	"Answer the rational reconstruction of the receiver, or nil if it doesn't exist."
	| n d t0 r0 t1 r1 temp answer |
	representative == 0 ifTrue: [^ 0].
	t0 _ 0. r0 _ self modulus.
	t1 _ 1. r1 _ representative.
	[r1 > N]
		whileTrue:
			[| q |
			q _ r0 // r1.
			temp _ r0 - (q * r1). r0 _ r1. r1 _ temp.
			temp _ t0 - (q * t1). t0 _ t1. t1 _ temp].
	n _ r1. d _ t1.
	d <= 0 ifTrue: [n _ n negated. d _ d negated].
	^ (d <= D and: [(answer _ (n/d) asRational) numerator abs = n abs]) ifTrue: [answer]! !

!ModularInteger methodsFor: 'operations' stamp: 'len 1/9/2022 20:54:19'!
+ anElement
	| m r |
	anElement isInteger ifTrue: [^ parent project: representative + anElement].
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #+].
	m _ parent modulus.
	r _ representative + anElement representative.
	r >= m ifTrue: [r _ r - m].
	^ parent representative: r! !

!ModularInteger methodsFor: 'operations' stamp: 'len 1/9/2022 20:54:57'!
- anElement
	| m r |
	anElement isInteger ifTrue: [^ parent project: representative - anElement].
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #-].
	m _ parent modulus.
	r _ representative + m - anElement representative.
	r >= m ifTrue: [r _ r - m].
	^ parent representative: r! !

!ModularInteger methodsFor: 'operations' stamp: 'len 1/3/2022 11:01:55'!
/ anElement
	"Answer x such that xa = b, where b is self and a is anElement.
	The behavior is undefined if a doesn't divide b."
	| a b d m |
	anElement isInteger ifTrue: [^ self * (parent inverseOfRepresentative: anElement)].
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #/].
	m _ parent modulus.
	m = 1 ifTrue: [^ self]. "case for the trivial ring"
	b _ representative.
	a _ anElement representative.
	d _ a gcd: m.
	d = 1 ifTrue: [^ parent project: (a reciprocalModulo: m) * b].
	d | b ifFalse: [^ nil].
	a _ a // d.
	b _ b // d.
	m _ m // d.
	^ parent project: (a reciprocalModulo: m) * b "up to adding multiples of the new m, see >>solve:"! !

!ModularInteger methodsFor: 'operations' stamp: 'len 1/6/2022 19:39:40'!
// anElement
	"Answer the quotient of the Euclidean division of the receiver by the argument."
	anElement isZero ifTrue: [^ InversionError signal: anElement].
	self isZero ifTrue: [^ self].
	^ parent project: (representative quotientBy: anElement representative modulo: parent modulus)! !

!ModularInteger methodsFor: 'operations' stamp: 'len 1/9/2022 20:57:13'!
^ anInteger
	^ parent representative: (representative raisedTo: (anInteger isInteger ifTrue: [anInteger] ifFalse: [anInteger representative]) modulo: parent modulus)! !

!ModularInteger methodsFor: 'operations' stamp: 'len 1/9/2022 20:57:31'!
additiveOrder
	| m |
	m _ self modulus.
	^ m // (representative gcd: m)! !

!ModularInteger methodsFor: 'operations' stamp: 'len 1/9/2022 08:09:47'!
annihilator
	"Answer a generator of the ideal of all elements that multiplied by the receiver are zero."
	^ parent project: parent modulus // (representative gcd: parent modulus)! !

!ModularInteger methodsFor: 'operations' stamp: 'len 12/29/2021 12:09:48'!
gauge
	"Answer the value of the Euclidean function at the receiver."
	^ self isZero ifTrue: [0] ifFalse: [representative gcd: parent modulus]! !

!ModularInteger methodsFor: 'operations' stamp: 'len 5/15/2019 04:42:45'!
log: b
	"Answer the discrete logarithm of the receiver in base b. This is, answer an integer k such that b^k equals the receiver. Note that this is the discrete logarithm problem in the group of units of Z/nZ, which is multiplicative, not in Z/nZ as additive group."
	| m g answer x |
	representative = 0 ifTrue: [^ nil].
	representative = 1 ifTrue: [^ 0].
	m _ parent modulus.
	g _ b representative.
	answer _ 1.
	x _ g.
	[x = representative] whileFalse: [x = 0 ifTrue: [^ nil]. x _ x * g \\ m. answer _ answer + 1].
	^ answer! !

!ModularInteger methodsFor: 'operations' stamp: 'len 6/19/2019 14:57:16'!
multiplicativeOrder
	self isZero ifTrue: [^ 0].
	^ parent units orderOf: self! !

!ModularInteger methodsFor: 'operations' stamp: 'len 6/8/2019 12:06:49'!
negated
	representative = 0 ifTrue: [^ self].
	^ parent representative: parent modulus - representative! !

!ModularInteger methodsFor: 'operations' stamp: 'len 12/10/2021 19:16:23'!
normalization
	"Answer a unit u such that 'self * u' is a unique choice of associate. See >>normalized."
	^ self normalizationInverse inverse! !

!ModularInteger methodsFor: 'operations' stamp: 'len 12/10/2021 19:14:32'!
normalizationInverse
	"Answer a unit u such that 'self * u inverse' is a unique choice of associate."
	"Adapted from ModularInteger>>\. This algorithm solves the congruence ax = self (mod m) where 'a' is the canonical associate of the receiver, and then looks for a solution 'x' that is a unit."
	| a x modulus m |
	self isZero ifTrue: [^ parent one].
	a _ representative gcd: (modulus _ parent modulus).
	a = 1 ifTrue: [^ self].
	x _ representative // a.
	m _ modulus // a.
	[(x gcd: modulus) = 1] whileFalse: [x _ x + m]. "at most 'a' solutions, and some is guaranteed to be a unit"
	^ parent project: x

"alternative 1 (similar as above but computes extra GCDs and creates extra elements):
	^ self normalized \ self detect: [:u| u isUnit]"
	
"alternative 2 (bruteforce):
	| associate |
	associate _ self normalized.
	^ self units detect: [:u| associate * u = self]"! !

!ModularInteger methodsFor: 'operations' stamp: 'len 7/30/2021 10:25:31'!
normalized
	"Answer a unique choice of associate. See >>normalization."
	representative = 0 ifTrue: [^ self].
	^ parent representative: (representative gcd: parent modulus)! !

!ModularInteger methodsFor: 'operations' stamp: 'len 4/23/2021 11:09:05'!
solve: anElement
	"Answer all solutions 'x' such that 'ax = b (mod m)', where the receiver is 'a (mod m)' and the argument is 'b (mod m)'."
	| a b d m x |
	m _ parent modulus.
	a _ representative.
	b _ anElement isInteger ifTrue: [anElement] ifFalse: [anElement representative].
	d _ a gcd: m.
	d = 1 ifTrue: [^ {parent project: (a reciprocalModulo: m) * b}].
	d | b ifFalse: [^ #()].
	a _ a // d.
	b _ b // d.
	m _ m // d.
	x _ (a reciprocalModulo: m) * b.
	^ Iterator on: [:aBlock| 0 to: d-1 do: [:i| aBlock value: (parent project: i*m + x)]]! !

!ModularInteger methodsFor: 'operations' stamp: 'len 7/8/2019 02:15:33'!
squareRoot
	"Assuming the receiver is a quadratic residue, answer a square root."
	^ self notYetImplemented! !

!ModularInteger methodsFor: 'operations' stamp: 'len 1/9/2022 08:09:58'!
stabilizerWith: anElement
	| N g |
	N _ self modulus.
	g _ (representative gcd: anElement representative) gcd: N.
	^ parent representative: (N // g split: representative // g)! !

!ModularInteger methodsFor: 'operations' stamp: 'len 1/14/2022 14:10:40'!
valuation
	"Answer the Euclidean valuation of the receiver."
	^ self isZero ifTrue: [Infinity negative] ifFalse: [representative gcd: parent modulus]! !

!ModularInteger methodsFor: 'testing' stamp: 'len 5/4/2020 09:29:01'!
isIrreducible
	"An element of Z/mZ is irreducible iff its canonical associate is a prime p in Z and its exponent in the prime factorization of m is > 1, or equivalently p^2 | m."
	^ (parent modulusFactors occurrencesOf: self normalized representative) > 1! !

!ModularInteger methodsFor: 'testing' stamp: 'len 8/3/2021 13:38:32'!
isOne
	^ representative == 1! !

!ModularInteger methodsFor: 'testing' stamp: 'len 5/4/2020 09:31:35'!
isPrime
	"An element of Z/mZ is prime iff its canonical associate is a prime p in Z and p < m."
	| p |
	p _ self normalized representative.
	^ p < parent modulus and: [parent modulusFactors includes: p]! !

!ModularInteger methodsFor: 'testing' stamp: 'len 6/19/2019 15:10:07'!
isPrimitiveRoot
	^ self isUnit and: [self multiplicativeOrder = self parent units size "phi"]! !

!ModularInteger methodsFor: 'testing' stamp: 'len 1/9/2022 21:05:05'!
isQuadraticResidue
	(representative kronecker: self modulus) ~= 1 ifTrue: [^ false].
	^ self notYetImplemented! !

!ModularInteger methodsFor: 'testing' stamp: 'len 1/6/2022 09:25:37'!
isUnit
	"Answer true if the receiver is invertible.
	An element in a finite ring is either a unit or a zero-divisor."
	^ self isZerodivisor not! !

!ModularInteger methodsFor: 'testing' stamp: 'len 12/4/2016 15:16:58'!
isZero
	^ representative == 0! !

!ModularInteger methodsFor: 'testing' stamp: 'len 1/6/2022 09:27:43'!
isZerodivisor
	"Answer true if there exists a nonzero element that multiplied by the receiver is zero.
	An element in a finite ring is either a unit or a zero-divisor."
	self isZero ifTrue: [^ parent isTrivial not].
	^ (representative gcd: parent modulus) ~= 1! !

!ModularInteger methodsFor: 'private' stamp: 'len 3/29/2016 23:52'!
representative: anInteger
	representative _ anInteger! !

!PrimePowerResidue methodsFor: 'operations' stamp: 'len 12/10/2021 19:19:27'!
normalization
	"Answer a unit u such that 'self * u' is a unique choice of associate. See >>normalized."
	^ self normalizationInverse inverse! !

!PrimePowerResidue methodsFor: 'operations' stamp: 'len 12/10/2021 19:14:48'!
normalizationInverse
	"Answer a unit u such that 'self * u inverse' is a unique choice of associate."
	| p q |
	self isZero ifTrue: [^ parent one].
	p _ parent p.
	q _ representative.
	[p | q] whileTrue: [q _ q // p].
	^ parent representative: q! !

!PrimePowerResidue methodsFor: 'operations' stamp: 'len 7/8/2019 12:53:17'!
squareRoot
	"Assuming the receiver is a quadratic residue, answer a square root."
	| p a v x q r e |
	(representative == 0 or: [representative == 1]) ifTrue: [^ self].
	p _ parent p.
	p == 2 ifTrue: [^ self notYetImplemented].
	a _ representative.
	v _ 0.
	[p | a] whileTrue: [v _ v + 1. a _ a // p].
	v odd ifTrue: [^ nil].
	x _ parent residueField squareRootOfRepresentative: a \\ p.
	q _ parent modulus.
	r _ q // p.
	e _ q - (2*r) + 1 // 2.
	^ ((parent representative: x) ^ r * ((parent representative: a) ^ e)) * ((parent representative: p) ^ (v // 2))! !

!PrimePowerResidue methodsFor: 'operations-euclidean' stamp: 'len 1/6/2022 19:40:13'!
// anElement
	"Answer the quotient of the Euclidean division of the receiver by the argument."
	| v |
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #//].
	anElement isZero ifTrue: [^ InversionError signal: anElement].
	self isZero ifTrue: [^ self].
	(v _ self valuation - anElement valuation) < 0 ifTrue: [^ self zero].
	^ self normalization inverse * anElement normalization * (parent p ^ v)! !

!PrimePowerResidue methodsFor: 'operations-euclidean' stamp: 'len 5/3/2020 23:17:48'!
gcd: anElement
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #gcd:].
	self isZero ifTrue: [^ anElement normalized].
	anElement isZero ifTrue: [^ self normalized].
	^ parent representative: parent p ^ (self valuation min: anElement valuation)! !

!PrimePowerResidue methodsFor: 'operations-euclidean' stamp: 'len 5/10/2020 19:40:31'!
lcm: anElement
	parent = anElement parent ifFalse: [^ self adapt: anElement andSend: #lcm:].
	self isZero ifTrue: [^ self].
	anElement isZero ifTrue: [^ anElement].
	^ parent representative: parent p ^ (self valuation max: anElement valuation)! !

!PrimePowerResidue methodsFor: 'operations-euclidean' stamp: 'len 12/29/2021 12:11:59'!
valuation
	"Answer the p-adic valuation of the receiver."
	^ representative valuation: parent p! !

!PrimePowerResidue methodsFor: 'testing' stamp: 'len 1/6/2022 09:25:43'!
isNilpotent
	"Answer true if self^n = 0 for some integer n >= 1."
	^ self isZerodivisor! !

!PrimePowerResidue methodsFor: 'testing' stamp: 'len 1/6/2022 09:28:02'!
isZerodivisor
	"Answer true if there exists a nonzero element that multiplied by the receiver is zero."
	^ parent p | representative! !

!PrimeResidue methodsFor: 'operations' stamp: 'len 7/8/2019 03:40:28'!
allSquareRoots
	"Answer all square roots of the receiver."
	| x |
	representative == 0 ifTrue: [^ {self}].
	x _ self squareRoot ifNil: [^ #()].
	^ {x. x negated}! !

!PrimeResidue methodsFor: 'operations' stamp: 'len 8/3/2021 13:21:48'!
inverse
	^ parent representative: ((parent inverseOfRepresentative: representative) ifNil: [^ nil])! !

!PrimeResidue methodsFor: 'operations' stamp: 'len 7/30/2021 10:26:29'!
normalized
	"Answer a unique choice of associate. See >>normalization."
	representative = 0 ifTrue: [^ self].
	^ parent one! !

!PrimeResidue methodsFor: 'operations' stamp: 'len 7/8/2019 02:28:37'!
squareRoot
	"Assuming the receiver is a quadratic residue, answer a square root."
	| p |
	(representative == 0 or: [representative == 1]) ifTrue: [^ self].
	p _ parent modulus.
	p == 2 ifTrue: [^ self].
	(p bitAnd: 3) == 3 ifTrue: [^ self ^ (p + 1 // 4)].
	^ parent representative: ((parent squareRootOfRepresentative: representative) ifNil: [^ nil])! !

!PrimeResidue methodsFor: 'operations-euclidean' stamp: 'len 5/3/2020 23:17:34'!
gcd: anElement
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #gcd:].
	representative = 0 ifTrue: [^ anElement normalized].
	^ parent one! !

!PrimeResidue methodsFor: 'operations-euclidean' stamp: 'len 8/14/2019 05:06:05'!
lcm: anElement
	parent = anElement parent ifFalse: [^ self adapt: anElement andSend: #lcm:].
	representative = 0 ifTrue: [^ parent zero].
	^ anElement normalized! !

!PrimeResidue methodsFor: 'testing' stamp: 'len 1/9/2022 21:04:59'!
isQuadraticResidue
	^ (representative kronecker: self modulus) = 1! !

!PrimeResidue methodsFor: 'testing' stamp: 'len 1/6/2022 09:28:10'!
isZerodivisor
	"Answer true if there exists a nonzero element that multiplied by the receiver is zero."
	^ self isZero! !

!SmallPrimeResidue methodsFor: 'operations' stamp: 'len 9/2/2018 21:50:50'!
* aModularInteger
	| b i p |
	aModularInteger class == self class ifFalse: [^ super * aModularInteger].
	b _ aModularInteger representative.
	(representative = 0 or: [b = 1]) ifTrue: [^ self].
	(representative = 1 or: [b = 0]) ifTrue: [^ aModularInteger].
	i _ (parent logTable at: representative) + (parent logTable at: b).
	i >= (p _ parent modulus) ifTrue: [i _ i - p + 1].
	^ parent representative: (parent expTable at: i)! !

!SmallPrimeResidue methodsFor: 'operations' stamp: 'len 1/6/2022 19:42:05'!
/ anElement
	| b i |
	anElement class == self class ifFalse: [^ super / anElement].
	b _ anElement representative.
	(representative = 0 or: [b = 1]) ifTrue: [^ self].
	b = 0 ifTrue: [^ InversionError signal: anElement].
	i _ (parent logTable at: representative) - (parent logTable at: b).
	i <= 0 ifTrue: [i _ i + parent modulus - 1].
	^ parent representative: (parent expTable at: i)! !

!RegularFunction methodsFor: 'accessing' stamp: 'len 8/22/2021 12:08:06'!
characteristicPolynomial
	^ self representation characteristicPolynomial! !

!RegularFunction methodsFor: 'accessing' stamp: 'len 6/25/2019 02:08:46'!
denominator
	^ self minimalPolynomial coefficients denominator! !

!RegularFunction methodsFor: 'accessing' stamp: 'len 8/22/2021 12:07:18'!
minimalPolynomial
	^ self representation minimalPolynomial! !

!RegularFunction methodsFor: 'accessing' stamp: 'len 5/4/2018 17:20:53'!
norm
	| f |
	f _ self minimalPolynomial.
	^ f independentCoefficient / f leadingCoefficient * (f degree even ifTrue: [1] ifFalse: [-1])
	
"alternatively:
	^ self representation determinant"! !

!RegularFunction methodsFor: 'accessing' stamp: 'len 1/17/2019 03:22:20'!
numerator
	^ self * self denominator! !

!RegularFunction methodsFor: 'accessing' stamp: 'len 7/24/2021 13:06:30'!
representation
	"Answer the module endomorphism defined by multiplication by the receiver."
	| V |
	^ (V _ self parent asModule) endomorphisms evaluating: [:x| V !! (self parent !! x * self)]! !

!RegularFunction methodsFor: 'accessing' stamp: 'len 11/3/2016 04:41'!
symmetricFunction: i
	^ self notYetImplemented! !

!RegularFunction methodsFor: 'accessing' stamp: 'len 7/18/2021 07:37:56'!
trace
	^ self representation trace
	
"alternatively:
	| f |
	f _ self minimalPolynomial.
	^ (f coefficientAtDegree: f degree - 1) negated"
! !

!RegularFunction methodsFor: 'converting' stamp: 'len 7/16/2021 09:30:45'!
asRationalFunction
	"Answer the rational function reconstruction of the receiver, or nil if it doesn't exist.
	This is Wang's rational reconstruction algorithm extended to rational functions."
	| f g M N r0 r1 t0 t1 |
	self assert: self parent scalars isField.
	self assert: self parent isUnivariate.
	f _ self parent modulus.
	g _ self representative.
	M _ f degree.
	N _ M // 2.
	"D _ M - N - 1."
	r0 _ f. t0 _ f parent zero.
	r1 _ g. t1 _ f parent one.
	[r1 degree > N]
		whileTrue:
			[| q temp |
			q _ r0 // r1.
			temp _ r0.
			r0 _ r1.
			r1 _ temp - (q*r1).
			temp _ t0.
			t0 _ t1.
			t1 _ temp - (q*t1)].
	(r1 gcd: t1) isOne ifFalse: [^ nil].
	^ self parent base fractions
		reducedNumerator: r1 / t1 leadingCoefficient
		denominator: t1 / t1 leadingCoefficient! !

!RegularFunction methodsFor: 'operations' stamp: 'len 8/22/2021 12:13:20'!
inverse
	^ super inverse

	"See [KSWZ17]."
	"Should we require something on the coefficients ring? Must it be a PIR or Euclidean?"
"	self isOne ifTrue: [^ self].
	(parent isEuclidean or: [parent relators size = 1 and: [self modulus leadingCoefficient isUnit]]) ifTrue:
		[| euclid |
		euclid _ representative xgcd: self modulus.
		^ (euclid at: 1) isOne ifTrue: [parent project: (euclid at: 2)]].
	self notYetImplemented
"
"
	| R S y z X G T P Q Q0 P1 |
	R _ parent.
	y _ R rank + 1.
	z _ R rank + 2.
	S _ R scalars polynomialsIn: R rank + 2 ordering: (MonomialOrdering lex: {y. z}), (MonomialOrdering grevlex: R indeterminates).
	self assert: (S monomials x: y) > (S monomials x: z).
	1 to: R rank do: [:i| self assert: (S monomials x: z) > (S monomials x: i)].
	X _ OrderedCollection new.
	parent relators do: [:g| X add: S !! g].
	X add: S !! representative * (S x: y) - (S x: z).
	G _ (S * X) standardBasis.
	T _ S extract: {y. z}.
	P _ [:s|
		| answer |
		answer _ OrderedCollection new.
		G do: [:g| | h | h _ T !! g. (h leadingMonomial degreeIn: 1) = 0 and: [(h leadingMonomial degreeIn: 2) <= s ifTrue: [answer add: R !! h leadingCoefficient]]].
		answer].
	Q _ [:s|
		| answer |
		answer _ OrderedCollection new.
		G do: [:g| | h | h _ T !! g. (h leadingMonomial degreeIn: 1) = 1 and: [(h leadingMonomial degreeIn: 2) <= s ifTrue: [answer add: R !! h leadingCoefficient]]].
		answer].
	Q0 _ Q value: 0.
	(Q0 anySatisfy: [:any| any isUnit]) ifFalse: [^ nil].
	P1 _ P value: 1.
	(P1 noneSatisfy: [:none| none isUnit]) ifFalse: [^ nil].
	^ G"! !

!RegularFunction methodsFor: 'operations' stamp: 'len 1/13/2022 10:33:16'!
inverse2
	| R S y z X G T P Q Q0 P1 |
	self isOne ifTrue: [^ self].
	R _ parent base.
	"Should we require something on the coefficients ring? Must it be a PIR or Euclidean?"
	(R isEuclidean or: [parent relators size = 1 and: [self modulus leadingCoefficient isUnit]]) ifTrue:
		[| euclid |
		euclid _ representative xgcd: self modulus.
		^ (euclid at: 1) isOne ifTrue: [parent project: (euclid at: 2)]].
	y _ R rank + 1.
	z _ R rank + 2.
	S _ R scalars polynomialsIn: R rank + 2 ordering: (MonomialOrdering lex: {y. z}), (MonomialOrdering grevlex: R indeterminates).
	self assert: (S monomials x: y) > (S monomials x: z).
	1 to: R rank do: [:i| self assert: (S monomials x: z) > (S monomials x: i)].
	X _ OrderedCollection new.
	parent relators do: [:g| X add: S !! g].
	X add: S !! representative * (S x: y) - (S x: z).
	G _ (S * X) basis.
	T _ S extract: {y. z}.
	P _ [:s|
		| answer |
		answer _ OrderedCollection new.
		G do: [:g| | h | h _ T !! g. (h leadingMonomial degreeIn: 1) = 0 and: [(h leadingMonomial degreeIn: 2) <= s ifTrue: [answer add: R !! h leadingCoefficient]]].
		answer].
	Q _ [:s|
		| answer |
		answer _ OrderedCollection new.
		G do: [:g| | h | h _ T !! g. (h leadingMonomial degreeIn: 1) = 1 and: [(h leadingMonomial degreeIn: 2) <= s ifTrue: [answer add: R !! h leadingCoefficient]]].
		answer].
	Q0 _ Q value: 0.
	(Q0 anySatisfy: [:any| any isUnit]) ifFalse: [^ nil].
	P1 _ P value: 1.
	(P1 noneSatisfy: [:none| none isUnit]) ifFalse: [^ nil].
	^ G! !

!RegularFunction methodsFor: 'testing' stamp: 'len 7/8/2021 12:02:31'!
isIntegral
	^ self minimalPolynomial coefficients allSatisfy: [:each| each isIntegral]! !

!RegularFunction methodsFor: 'testing' stamp: 'len 1/13/2022 10:33:21'!
isZerodivisor
	"See [KSWZ17]."
	| R S y z X G T P P0 P1 |
	R _ parent base.
	y _ R rank + 1.
	z _ R rank + 2.
	S _ R scalars polynomialsIn: R rank + 2 ordering: (MonomialOrdering lex: {y. z}), (MonomialOrdering grevlex: R indeterminates).
	self assert: (S monomials x: y) > (S monomials x: z).
	1 to: R rank do: [:i| self assert: (S monomials x: z) > (S monomials x: i)].
	X _ OrderedCollection new.
	parent relators do: [:g| X add: S !! g].
	X add: S !! representative * (S x: y) - (S x: z).
	G _ (S * X) basis.
	T _ S extract: {y. z}.
	P _ [:s|
		| answer |
		answer _ OrderedCollection new.
		G do: [:g| | h | h _ T !! g. (h leadingMonomial degreeIn: 1) = 0 and: [(h leadingMonomial degreeIn: 2) <= s ifTrue: [answer add: R !! h leadingCoefficient]]].
		answer].
"	Q _ [:s|
		| answer |
		answer _ OrderedCollection new.
		G do: [:g| | h | h _ T !! g. (h leadingMonomial degreeIn: 1) = 1 and: [(h leadingMonomial degreeIn: 2) <= s ifTrue: [answer add: R !! h leadingCoefficient]]].
		answer]."
	P0 _ P value: 0.
	P1 _ P value: 1.
	^ P0 size <= P1 size and: [P1 noneSatisfy: [:none| none isUnit]]! !

!GaloisResidue methodsFor: 'accessing' stamp: 'len 1/28/2022 07:08:05'!
gauge
	"Answer the value of the Euclidean function at the receiver."
	^ self valuation! !

!GaloisResidue methodsFor: 'accessing' stamp: 'len 6/25/2019 02:34:22'!
valuation
	^ representative content valuation! !

!GaloisResidue methodsFor: 'operations' stamp: 'len 1/6/2022 19:36:34'!
// anElement
	"Answer the quotient of the Euclidean division of the receiver by the argument."
	| v |
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #//].
	anElement isZero ifTrue: [^ InversionError signal: anElement].
	self isZero ifTrue: [^ self].
	(v _ self valuation - anElement valuation) < 0 ifTrue: [^ self zero].
	^ self normalization inverse * anElement normalization * (parent p ^ v)! !

!GaloisResidue methodsFor: 'operations' stamp: 'len 9/7/2019 10:32:44'!
gcd: anElement
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #gcd:].
	self isZero ifTrue: [^ anElement normalized].
	anElement isZero ifTrue: [^ self normalized].
	^ parent representative: (parent base constant: (representative content gcd: anElement representative content))! !

!GaloisResidue methodsFor: 'operations' stamp: 'len 9/7/2019 10:32:55'!
lcm: anElement
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #lcm:].
	self isZero ifTrue: [^ self].
	anElement isZero ifTrue: [^ anElement].
	^ parent representative: (parent base constant: (representative content lcm: anElement representative content))! !

!GaloisResidue methodsFor: 'operations' stamp: 'len 12/10/2021 19:16:06'!
normalization
	"Answer a unit u such that 'self * u' is a unique choice of associate. See >>normalized."
	^ self normalizationInverse inverse! !

!GaloisResidue methodsFor: 'operations' stamp: 'len 12/10/2021 19:14:17'!
normalizationInverse
	"Answer a unit u such that 'self * u inverse' is a unique choice of associate."
	self isZero ifTrue: [^ parent one].
	^ parent representative: representative primitivePart! !

!GaloisResidue methodsFor: 'operations' stamp: 'len 7/30/2021 10:28:13'!
normalized
	"Answer a unique choice of associate. See >>normalization."
	^ self * self normalization! !

!GaloisResidue methodsFor: 'testing' stamp: 'len 1/6/2022 09:25:26'!
isNilpotent
	"Answer true if self^n = 0 for some integer n >= 1."
	^ self isZerodivisor! !

!GaloisResidue methodsFor: 'testing' stamp: 'len 1/6/2022 09:25:29'!
isUnit
	"Answer true if the argument is invertible.
	An element in a finite ring is either a unit or a zero-divisor."
	^ self isZerodivisor not! !

!GaloisResidue methodsFor: 'testing' stamp: 'len 1/6/2022 09:27:23'!
isZerodivisor
	"Answer true if there exists a nonzero element that multiplied by the receiver is zero."
	^ representative coefficients allSatisfy: [:each| each isZerodivisor]

"alternative:
	^ parent maximalIdeal contains: self
"! !

!LaurentPolynomial methodsFor: 'as yet unclassified' stamp: 'len 1/15/2022 17:27:26'!
printCoefficient: c monomial: m on: aStream
	(c isOne not or: [m degree = 0]) ifTrue: [self printCoefficient: c on: aStream].
	m degree = 0 ifFalse: [self printMonomial: m on: aStream]! !

!LaurentPolynomial methodsFor: 'as yet unclassified' stamp: 'len 1/15/2022 17:26:54'!
printCoefficient: coefficient on: aStream
	| c |
	(c _ coefficient) printString first = $-
		ifTrue: [aStream nextPut: $-. c _ c negated].
	(c printString allSatisfy: [:each| each isAlphaNumeric or: ['{}()/' includes: each]])
		ifTrue: [aStream print: c. ^ self].
	aStream nextPut: $(; print: c; nextPut: $)! !

!LaurentPolynomial methodsFor: 'as yet unclassified' stamp: 'len 1/15/2022 17:51:28'!
printExponent: anInteger on: aStream
	| exponent |
	(exponent _ anInteger printString) = '1' ifTrue: [^ self].
	aStream isText ifTrue: [aStream nextPutAll: exponent super. ^ self].
	aStream nextPut: $^.
	exponent size = 1
		ifTrue: [aStream nextPutAll: exponent]
		ifFalse: [aStream nextPut: ${; nextPutAll: exponent; nextPut: $}]! !

!LaurentPolynomial methodsFor: 'as yet unclassified' stamp: 'len 1/15/2022 17:50:35'!
printIndeterminate: anInteger on: aStream
	| h i |
	h _ self parent rank / 2.
	i _ anInteger > h ifTrue: [anInteger - h] ifFalse: [anInteger].
	(self parent names ifNotNil: [:names| names at: i ifAbsent: []])
		ifNotNil: [:name| aStream nextPutAll: name displayStringOrText. ^ self].
	aStream isText
		ifTrue: [aStream nextPut: $x; nextPutAll: i printString sub]
		ifFalse:[aStream nextPutAll: '{x', i printString, '}']! !

!LaurentPolynomial methodsFor: 'as yet unclassified' stamp: 'len 1/15/2022 17:53:33'!
printMonomial: m on: aStream
	| h |
	m degree = 0 ifTrue: [aStream print: 1. ^ self].
	h _ self parent rank / 2.
	(m ordering indeterminates select: [:i| (m at: i) ~= 0])
		do: [:i|
			self printIndeterminate: i on: aStream.
			self printExponent: (i > h ifTrue: [(m at: i) negated] ifFalse: [m at: i]) on: aStream]! !

!GaussianRational methodsFor: 'accessing' stamp: 'len 1/4/2022 14:57:05'!
imaginary
	^ representative at: 1! !

!GaussianRational methodsFor: 'accessing' stamp: 'len 1/4/2022 14:57:00'!
real
	^ representative at: 0! !

!GaussianRational methodsFor: 'operations' stamp: 'len 1/4/2022 15:10:25'!
conjugate
	^ parent real: self real imaginary: self imaginary negated! !

!GaussianRational methodsFor: 'operations' stamp: 'len 1/5/2022 09:59:06'!
i
	^ parent real: self imaginary negated imaginary: self real! !

!Polynomial methodsFor: 'printing' stamp: 'len 1/2/2022 10:44:52'!
printCoefficient: c monomial: m on: aStream
	(c isOne not or: [m degree = 0]) ifTrue: [self printCoefficient: c on: aStream].
	m degree = 0 ifFalse: [aStream print: m]! !

!Polynomial methodsFor: 'printing' stamp: 'len 1/2/2022 11:03:12'!
printCoefficient: coefficient on: aStream
	| c |
	(c _ coefficient) printString first = $-
		ifTrue: [aStream nextPut: $-. c _ c negated].
	(c printString allSatisfy: [:each| each isAlphaNumeric or: ['{}()/' includes: each]])
		ifTrue: [aStream print: c. ^ self].
	aStream nextPut: $(; print: c; nextPut: $)! !

!Polynomial methodsFor: 'printing' stamp: 'len 5/31/2020 12:16:15'!
validate
	self monomials do: [:each|
		each indeterminates do: [:i| (self parent has: i) ifFalse: [^ false]].
		each exponents size = self parent rank ifFalse: [^ false]].
	(self coefficients allSatisfy: [:any| (self parent scalars includes: any)]) ifFalse: [^ false].
	^ super validate! !

!Polynomial methodsFor: 'accessing' stamp: 'len 12/29/2021 12:07:57'!
gauge
	"Answer the value of the Euclidean function at the receiver."
	^ self isZero ifTrue: [0] ifFalse: [self leadingMonomial degree]! !

!Polynomial methodsFor: 'accessing' stamp: 'len 10/6/2016 15:34'!
parent
	^ parent! !

!Polynomial methodsFor: 'accessing' stamp: 'len 7/16/2019 16:53:18'!
representative
	"If the coefficients ring is a quotient R/I, answer a representative of the receiver over R. See >>%."
	^ self apply: self scalars projection section! !

!Polynomial methodsFor: 'accessing' stamp: 'len 10/6/2016 15:34'!
scalars
	^ parent scalars! !

!Polynomial methodsFor: 'accessing' stamp: 'len 5/8/2020 18:22:10'!
valuation
	"If the receiver is an element of a valuation ring or a Euclidean ring, answer its valuation or Euclidean function."
	self isZero ifTrue: [^ Infinity negative].
	^ self leadingMonomial degree! !

!Polynomial methodsFor: 'accessing-coefficients' stamp: 'len 1/2/2022 10:07:54'!
coefficients
	"Answer the collection of coefficients of the receiver, possibly including zero entries."
	^ Iterator on: self performing: #coefficientsDo:! !

!Polynomial methodsFor: 'accessing-coefficients' stamp: 'len 4/4/2018 21:34:43'!
independentCoefficient
	"Answer the coefficient of the constant monomial of the receiver."

	^ self at: self parent monomials identity! !

!Polynomial methodsFor: 'accessing-indeterminates' stamp: 'len 3/1/2016 16:31'!
has: anIndeterminate
	"Answer true if anIndeterminate is effectively present in the receiver."
	^ self monomials anySatisfy: [:any| any has: anIndeterminate]! !

!Polynomial methodsFor: 'accessing-indeterminates' stamp: 'len 2/18/2017 19:52:08'!
indeterminates
	"Answer the indeterminates effectively present in this polynomial."
	^ self parent indeterminates select: [:each| self has: each]! !

!Polynomial methodsFor: 'accessing-indeterminates' stamp: 'len 2/3/2017 07:16:12'!
leadingIndeterminate
	"Answer the main (or leading) indeterminate of the receiver (according to a monomial ordering)."
	| indeterminates |
	indeterminates _ self ordering indeterminates.
	indeterminates reverseDo: [:i| (self has: i) ifTrue: [^ i]].
	^ indeterminates first! !

!Polynomial methodsFor: 'accessing-monomials' stamp: 'len 1/24/2017 12:04:29'!
degree
	"Answer the total degree of the receiver, i.e. the maximum of the degree of its monomials."
	self isZero ifTrue: [^ Infinity negative].
	^ self monomials max: [:each| each degree]! !

!Polynomial methodsFor: 'accessing-monomials' stamp: 'len 3/2/2016 23:47'!
degreeIn: anIndeterminate
	"Answer the degree of the receiver in the given indeterminate."
	self isZero ifTrue: [^ Infinity negative].
	^ self monomials max: [:each| each degreeIn: anIndeterminate]! !

!Polynomial methodsFor: 'accessing-monomials' stamp: 'len 2/6/2017 06:40:57'!
density
	"Answer a measure of the density/sparsity of the receiver."
	self isZero ifTrue: [^ 0].
	^ self coefficients size / (self degree + 1)! !

!Polynomial methodsFor: 'accessing-monomials' stamp: 'len 1/14/2022 13:53:56'!
ecart
	"Answer the ecart of the receiver. This is a measure of how far a polynomial is from being homogeneous."
	^ self degree - self leadingMonomial degree! !

!Polynomial methodsFor: 'accessing-monomials' stamp: 'len 1/2/2022 10:08:16'!
monomials
	"Answer the collection of monomials effectively present in this polynomial (with nonzero coefficient). This is called the 'support' of a polynomial."
	^ Iterator on: self performing: #monomialsDo:! !

!Polynomial methodsFor: 'accessing-monomials' stamp: 'len 2/3/2017 06:51:05'!
order
	"Answer the minimum degree of the monomials present in the receiver."

	^ self isZero ifTrue: [Infinity negative] ifFalse: [self monomials min: [:each| each degree]]! !

!Polynomial methodsFor: 'accessing-monomials' stamp: 'len 2/3/2017 07:17:54'!
ordering
	"Answer the monomial ordering of the receiver."
	^ self parent ordering! !

!Polynomial methodsFor: 'accessing-monomials' stamp: 'len 1/2/2022 10:08:28'!
support
	"Answer the collection of monomials effectively present in this polynomial (with nonzero coefficient)."
	^ self monomials! !

!Polynomial methodsFor: 'accessing-terms' stamp: 'len 2/7/2017 03:38:56'!
formAt: anInteger
	"Answer the homogeneous component of degree anInteger (an anInteger-form)."
	| answer |
	answer _ self zero.
	self terms do: [:each| each degree = anInteger ifTrue: [answer _ answer + each]].
	^ answer! !

!Polynomial methodsFor: 'accessing-terms' stamp: 'len 6/7/2020 14:32:41'!
initialForm
	"Answer the homogeneous component of the lowest degree.
	This makes sense for a local ordering."
	self ordering isLocal ifFalse: [self error: 'not a local ordering'].
	^ self isZero
		 ifTrue: [self]
		 ifFalse: [self formAt: self order]! !

!Polynomial methodsFor: 'accessing-terms' stamp: 'len 6/7/2020 14:31:24'!
initialTerm
	^ self isZero
		 ifTrue: [self]
		 ifFalse: [self termAt: self initialMonomial]! !

!Polynomial methodsFor: 'accessing-terms' stamp: 'len 3/1/2016 22:11'!
leadingTerm
	"Answer the first term of the receiver."

	^ self isZero
		 ifTrue: [self]
		 ifFalse: [self termAt: self leadingMonomial]! !

!Polynomial methodsFor: 'accessing-terms' stamp: 'len 2/10/2017 20:28:17'!
linearForm
	^ self formAt: 1! !

!Polynomial methodsFor: 'accessing-terms' stamp: 'len 12/24/2017 20:10:34'!
parts
	^ Iterator on: self performing: #partsDo:! !

!Polynomial methodsFor: 'accessing-terms' stamp: 'len 3/1/2016 22:08'!
tail
	^ self - self leadingTerm! !

!Polynomial methodsFor: 'accessing-terms' stamp: 'len 12/21/2017 18:25:51'!
termAt: aMonomial
	^ self parent coefficient: (self at: aMonomial) monomial: aMonomial! !

!Polynomial methodsFor: 'accessing-terms' stamp: 'len 11/29/2016 11:49:38'!
terms
	^ Iterator on: self performing: #termsDo:! !

!Polynomial methodsFor: 'converting' stamp: 'len 7/7/2020 09:22:31'!
asBilinearForm
	(self degree = 2 and: [self isHomogeneous]) ifFalse: [^ self error: 'not homogeneous of degree 2'].
	self parent rank even ifFalse: [^ self error: 'not even rank'].
	^ BilinearForm on: self scalars ^ (self parent rank / 2) evaluatingWithArguments: [:x :y| self value: (x, y)]! !

!Polynomial methodsFor: 'converting' stamp: 'len 1/2/2022 11:14:14'!
asMultivariate
	"Convert a polynomial in R[x1,...,xn][y] to a polynomial in R[x1,...,xn,y]."
	(self scalars isKindOf: PolynomialRing) ifFalse: [^ self].
	self parent isUnivariate ifFalse: [^ self].
	^ self parent asMultivariate !! self! !

!Polynomial methodsFor: 'converting' stamp: 'len 1/1/2022 09:37:06'!
asQuadraticForm
	| coefficients |
	(self degree = 2 and: [self isHomogeneous]) ifFalse: [^ self error: 'not homogeneous of degree 2'].
	coefficients _ OrderedCollection new.
	1 to: self parent rank do: [:i|
		i to: self parent rank do: [:j|
			coefficients add: (self at: ((self parent monomials x: i) * (self parent monomials x: j)))]].
	^ QuadraticForm from: (self scalars ^ self parent rank) coefficients: (self parent scalars tuple: coefficients asArray)! !

!Polynomial methodsFor: 'converting' stamp: 'len 12/21/2017 20:09:56'!
asScalar
	self isConstant ifFalse: [^ self error: 'not a constant polynomial'].
	^ self leadingCoefficient! !

!Polynomial methodsFor: 'converting' stamp: 'len 3/6/2021 15:19:31'!
asUnivariate
	"Answer the receiver as univariate in the last indeterminate, e.g. go from R[x,y,z] to R[x,y][z]."
	self parent isUnivariate ifTrue: [^ self].
	^ self parent asUnivariate !! self

"	| S term n d coefficients |
	self parent isUnivariate ifTrue: [^ self].
	n _ self parent rank.
	S _ self parent asUnivariate.
	(d _ self degreeIn: n) <= 0
		ifTrue: [^ S constant: S scalars !! self].
	coefficients _ Array new: d+1.
	coefficients atAllPut: S scalars zero.
	self partsDo: [:each|
		term _ S scalars coefficient: each value monomial: S scalars monomials !! (each key without: n).
		coefficients at: (each key degreeIn: n)+1 add: term].
	^ S coefficients: coefficients"! !

!Polynomial methodsFor: 'converting' stamp: 'len 3/6/2021 15:20:06'!
asUnivariateIn: anIndeterminate
	"Answer the receiver as univariate in the given indeterminate, e.g. go from R[x,y,z] to R[x,y][z]."
	(self parent isUnivariate and: [self parent indeterminate = anIndeterminate]) ifTrue: [^ self].
	^ (self parent asUnivariateIn: anIndeterminate) !! self! !

!Polynomial methodsFor: 'converting' stamp: 'len 5/23/2018 22:30:47'!
orderedBy: aMonomialOrdering
	"Answer a copy of the receiver with a different monomial ordering."
	^ (self parent orderedBy: aMonomialOrdering) !! self! !

!Polynomial methodsFor: 'enumerating' stamp: 'len 12/24/2017 20:07:32'!
termsDo: aBlock
	self partsDo: [:each| aBlock value: (self parent coefficient: each value monomial: each key)]! !

!Polynomial methodsFor: 'factorization' stamp: 'len 7/17/2019 10:59:36'!
content
	"Answer the GCD of the coefficients of the receiver.
	In a field, it is convenient to define the content as 1.
	For example, 2x^2 + 4 has content 2 in Z[x] and 1 in Q[x]."
	| answer |
	self isZero ifTrue: [^ self scalars zero].
	self scalars isField ifTrue: [^ self scalars one].
	answer _ self scalars zero.
	self coefficients do: [:each| answer _ answer gcd: each].
	^ answer! !

!Polynomial methodsFor: 'factorization' stamp: 'len 7/14/2021 09:26:12'!
integerContent
	"Answer the integer content of the receiver.
	NOTE: assumes the receiver is a polynomial over the rationals."
	| a b |
"	(self scalars isKindOf: RationalIntegerRing) ifFalse: [DomainError signal]."
	self isZero ifTrue: [^ self].
	a _ self leadingCoefficient numerator.
	b _ self leadingCoefficient denominator.
	self coefficientsDo: [:each|
		a _ a gcd: each numerator.
		b _ b lcm: each denominator].
	^ self scalars numerator: a abs denominator: b abs! !

!Polynomial methodsFor: 'factorization' stamp: 'len 7/17/2019 10:53:46'!
integerPrimitivePart
	"Answer the integer primitive polynomial associated to the receiver.
	Remove the integer content and the sign.
	NOTE: the receiver is a polynomial over the rational numbers."

	self isZero ifTrue: [^ self].
	^ self / (self integerContent * self sign)! !

!Polynomial methodsFor: 'factorization' stamp: 'len 1/9/2022 08:11:32'!
primitivePart
	"Answer the primitive part of the receiver."
	self isZero ifTrue: [^ self].
	^ self / self content! !

!Polynomial methodsFor: 'factorization' stamp: 'len 9/25/2018 00:28:05'!
sign
	"Answer the sign of the receiver, i.e. the sign if its leading coefficient."
	^ self leadingCoefficient sign! !

!Polynomial methodsFor: 'operations' stamp: 'len 4/26/2021 10:54:00'!
% anInteger
	self scalars ==  ifFalse: [DomainError signal].
	^ self apply: (self scalars / anInteger) projection! !

!Polynomial methodsFor: 'operations' stamp: 'len 8/14/2019 04:59:01'!
* anObject
	(anObject isInteger or: [self scalars includes: anObject])
		ifTrue: [^ self multipliedByScalar: anObject].
	(self parent includes: anObject)
		ifTrue: [^ self multipliedBy: anObject].
	(anObject isKindOf: Monomial)
		ifTrue: [^ self multipliedByMonomial: anObject].
	((anObject isKindOf: Polynomial) and: [anObject scalars includes: self])
		ifTrue: [^ anObject multipliedByScalar: self].
"	(anObject isKindOf: RationalFunction)
		ifTrue: [^ anObject * self]."
	^ self adapt: anObject andSend: #*! !

!Polynomial methodsFor: 'operations' stamp: 'len 12/4/2021 13:44:10'!
/ anElement
	"Answer x such that xa = b, where b is self and a is anElement.
	The behavior is undefined if a doesn't divide b."
	self isZero ifTrue: [^ self].
	(anElement isKindOf: Monomial)
		ifTrue: [^ self dividedByMonomial: anElement].
	(self scalars includes: anElement)
		ifTrue: [^ self dividedByScalar: anElement].
	(self parent includes: anElement)
		ifFalse: [^ self  adapt: anElement andSend: #/].
	anElement isConstant
		ifTrue: [^ self dividedByScalar: anElement leadingCoefficient].
	^ (self divisionBy: anElement) exactQuotient! !

!Polynomial methodsFor: 'operations' stamp: 'len 1/5/2022 12:45:48'!
// anObject
	"Answer the quotient of the division of the receiver by the argument."
	(anObject isKindOf: Monomial)
		ifTrue: [^ self dividedByMonomial: anObject].
	(self scalars includes: anObject)
		ifTrue: [^ self apply: [:each| each // anObject]].
	anObject isCollection ifTrue: [^ (self divisionBy: anObject) quotients].
	^ (self divisionBy: anObject) quotient! !

!Polynomial methodsFor: 'operations' stamp: 'len 7/28/2021 12:57:14'!
\\ anObject
	"Answer the remainder of the division of the receiver by the argument."
	(self scalars includes: anObject) ifTrue: [^ self apply: [:each| each \\ anObject]].
	^ (self divisionBy: anObject) remainderAlone! !

!Polynomial methodsFor: 'operations' stamp: 'len 5/5/2019 18:28:02'!
 anObject
	"Answer the composition of the receiver with the argument."
	anObject isBlock ifTrue: [^ [:x| self value: (anObject value: x)]].
	^ self value: anObject! !

!Polynomial methodsFor: 'operations' stamp: 'len 1/10/2017 16:29:46'!
dehomogenizedIn: anIndeterminate
	"Answer the dehomogenization of the receiver in the given indeterminate."
	^ self monomialsApply: [:each| each dehomogenizedIn: anIndeterminate]! !

!Polynomial methodsFor: 'operations' stamp: 'len 1/11/2017 14:26:35'!
derivative: n in: anIndeterminate
	"Answer the n-th derivative in the given indeterminate."
	| answer |
	n < 0 ifTrue: [^ self error: 'the order of the derivative should be positive'].
	answer _ self.
	n timesRepeat: [answer _ answer derivativeIn: anIndeterminate].
	^ answer! !

!Polynomial methodsFor: 'operations' stamp: 'len 12/24/2017 20:16:14'!
derivativeIn: anIndeterminate
	| answer |
	answer _ self parent zero.
	self partsDo: [:each| | degree |
		degree _ each key degreeIn: anIndeterminate.
		degree > 0
			ifTrue:
				[answer _ answer + (self parent coefficient: each value * degree monomial: (each key parent exponents: (each key exponents copy at: anIndeterminate put: degree - 1; yourself)))]].
	^ answer! !

!Polynomial methodsFor: 'operations' stamp: 'len 1/12/2022 18:21:42'!
gcd: aPolynomial
	"Answer the greatest common divisor of the receiver and the argument,
	i.e. a generator of the principal ideal generated by the reciever and the argument.
	The result is the canonical associate (normalized)."
	| a b r |
	self isZero ifTrue: [^ aPolynomial normalized].
	aPolynomial isZero ifTrue: [^ self normalized].
	(self parent includes: aPolynomial) ifFalse: [^ self adapt: aPolynomial andSend: #gcd:].
	(self isUnivariate and: [aPolynomial isUnivariate])
		ifFalse: "Multivariate case:"
			[self scalars isUFD ifFalse: [^ self error: 'not a UFD'].
			(self isConstant or: [aPolynomial isConstant])
				ifTrue: [^ self scalars isField ifTrue: [self one] ifFalse: [self parent constant: (self content gcd: aPolynomial content)]].
			a _ self asUnivariate.
			b _ aPolynomial asUnivariate.
			^ (self parent !! ((a primitivePart gcd: b primitivePart) * (a content gcd: b content)) asMultivariate) normalized].
	self scalars isField
		ifTrue: "generic euclidean algorithm:"
			[a _ self.
			b _ aPolynomial.
			[a isZero] whileFalse: [a _ b \\ (b _ a)].
			^ b normalized].
	"Over a general ring we use the primitive PRS algorithm:"
	a _ self primitivePart.
	b _ aPolynomial primitivePart.
	[b isZero] whileFalse: [r _ (a pseudoRem: b) primitivePart. a _ b. b _ r].
	a isConstant ifTrue: [a _ self one].
	^ a * (self content gcd: aPolynomial content)! !

!Polynomial methodsFor: 'operations' stamp: 'len 1/23/2017 11:41:39'!
gradient
	^ self parent indeterminates collect: [:each| self derivativeIn: each]! !

!Polynomial methodsFor: 'operations' stamp: 'len 5/2/2018 16:30:02'!
height
	self isZero ifTrue: [^ 1].
	^ self coefficients inject: 1 into: [:x :each| x max: each height]! !

!Polynomial methodsFor: 'operations' stamp: 'len 12/18/2021 20:30:07'!
hessian
	"Answer the Hessian matrix of the receiver."
	| derivatives |
	self flag: #fix. "optimize (the matrix is symmetrical)"
	derivatives _ (1 to: self parent rank) collect: [:i| self derivativeIn: i].
	^ self parent matrix: self parent rank filling: [:i :j| (derivatives at: i) derivativeIn: j]! !

!Polynomial methodsFor: 'operations' stamp: 'len 5/23/2018 22:30:27'!
homogenized
	"Answer the homogenization of the receiver introducing a new indeterminate."
	| R S |
	R _ self parent.
	S _ R scalars polynomialsIn: R rank + 1.
	^ S !! self homogenizedIn: S rank! !

!Polynomial methodsFor: 'operations' stamp: 'len 3/22/2016 23:19'!
homogenizedIn: anIndeterminate
	"Answer the homogenization of the receiver in the given indeterminate.
	Assume the indeterminate is in its species (not a new indeterminate)."
	| degree |
	degree _ self degree.
	^ self monomialsApply: [:each| each complete: degree in: anIndeterminate]! !

!Polynomial methodsFor: 'operations' stamp: 'len 7/6/2021 09:19:46'!
inverse
	self isConstant ifTrue: [^ self parent constant: self independentCoefficient inverse].
	^ super inverse! !

!Polynomial methodsFor: 'operations' stamp: 'len 5/2/2018 16:21:10'!
length
	self isZero ifTrue: [^ 0].
	^ self coefficients sum: [:each| each height]! !

!Polynomial methodsFor: 'operations' stamp: 'len 3/3/2016 01:01'!
norm
	"Answer the euclidean norm of the receiver."
	^ self norm2 squareRoot! !

!Polynomial methodsFor: 'operations' stamp: 'len 3/2/2016 23:55'!
norm1
	"Answer the 1-norm (or taxicab norm, or Manhattan norm) of the receiver."
	^ self coefficients inject: self scalars zero into: [:x :each| x + each abs]! !

!Polynomial methodsFor: 'operations' stamp: 'len 3/2/2016 23:49'!
norm2
	"Answer the squared norm of the receiver."
	^ self coefficients inject: self scalars zero into: [:x :each| x + each squared]! !

!Polynomial methodsFor: 'operations' stamp: 'len 3/2/2016 23:54'!
normInfinite
	"Answer the infinite norm of the receiver.
	(In finite-dimensional vector spaces it's the same as the maximum norm)."
	^ self normMax! !

!Polynomial methodsFor: 'operations' stamp: 'len 3/2/2016 23:52'!
normMax
	"Answer the maximum norm of the receiver."
	^ self coefficients inject: self scalars zero into: [:x :each| x max: each abs]! !

!Polynomial methodsFor: 'operations' stamp: 'len 12/10/2021 19:18:40'!
normalization
	"Answer a unit u such that 'self * u' is a unique choice of associate. See >>normalized.
	NOTE: when the coefficients ring is not an integral domain this choice of unit might not be unique."
	self isZero ifTrue: [^ parent one].
	^ parent constant: self leadingCoefficient normalization! !

!Polynomial methodsFor: 'operations' stamp: 'len 2/8/2017 07:58:32'!
permutedBy: aPermutation
	"Permute the variables of the receiver. The argument can be an Array (a permutation in 'image format'). For example given a polynomial in x,z,y, #(1 2 3) doesn't change anything, and #(2 1 3) exchanges variables x and y."
	^ self monomialsApply: [:each| each permutedBy: aPermutation]! !

!Polynomial methodsFor: 'operations' stamp: 'len 4/26/2021 10:53:47'!
pgcd: aPolynomial
	"Answer the greatest common divisor of the receiver and aPolynomial using a probabilistic algorithm."
	| f g maps samples n |
	self parent scalars ==  ifFalse: [^ DomainError signal: 'polynomial not in Z[x]'].
	f _ self primitivePart.
	g _ aPolynomial primitivePart.
	n _ f degree max: g degree.
	maps _ OrderedCollection new: n + 1.
	samples _ 1 to: n.
	samples do: [:each| maps add: each -> ((f value: each) gcd: (g value: each))].
	^ self parent interpolate: maps! !

!Polynomial methodsFor: 'operations' stamp: 'len 5/15/2020 09:33:45'!
pseudoDivisionBy: aPolynomial
	"Answer a pseudo-division algorithm to divide the receiver by aPolynomial."
	self isUnivariate ifFalse: [^ DomainError signal: 'polynomial is not univariate'].
"	self scalars isUFD ifFalse: [^ DomainError signal: 'polynomial not over a UFD']."
	^ PseudoDivision divide: self by: aPolynomial! !

!Polynomial methodsFor: 'operations' stamp: 'len 3/6/2021 15:22:47'!
pseudoDivisionBy: aPolynomial in: anIndeterminate
	| U |
	U _ self parent asUnivariateIn: anIndeterminate.
	^ U !! self pseudoDivisionBy: U !! aPolynomial ! !

!Polynomial methodsFor: 'operations' stamp: 'len 4/24/2018 19:40:35'!
pseudoQuo: aPolynomial
	"Answer the quotient of the pseudo-division of the receiver by the argument."
	self isUnivariate ifFalse: [^ (self pseudoDivisionBy: aPolynomial in: self leadingIndeterminate) quotient asMultivariate].
	^ (self pseudoDivisionBy: aPolynomial) quotient! !

!Polynomial methodsFor: 'operations' stamp: 'len 3/6/2021 15:17:53'!
pseudoRem2: aPolynomial
	"Answer the remainder of the pseudo-division of the receiver by the argument."
"	self isUnivariate ifFalse: [^ (self pseudoDivisionBy: aPolynomial in: self leadingIndeterminate) remainder asMultivariate]."
	^ (self pseudoDivisionBy: aPolynomial) remainder! !

!Polynomial methodsFor: 'operations' stamp: 'len 3/6/2021 15:17:45'!
pseudoRem3: aPolynomial
	"Answer the remainder of the pseudo-division of the receiver by the argument."
	| n d b w k |
"	self isUnivariate ifFalse: [^ (self pseudoDivisionBy: aPolynomial in: self leadingIndeterminate) remainder asMultivariate]."
	"^ (self pseudoDivisionBy: aPolynomial) remainder"
	self degree < (n _ aPolynomial degree) ifTrue: [^ self].
	w _ self.
	d _ self degree - n + 1.
	b _ aPolynomial leadingCoefficient.
	[k _ w degree - n.
	w _ b * w - ((self parent coefficient: w leadingCoefficient degree: k)*aPolynomial).
	w isZero ifTrue: [^ w].
	w degree < n ifTrue: [^ w * (b ^ k)].
	k > d ifTrue: [w _ w * (b ^ (k - d))]] repeat! !

!Polynomial methodsFor: 'operations' stamp: 'len 7/15/2021 12:38:27'!
pseudoRem4: aPolynomial
	"Answer the remainder of the pseudo-division of the receiver by the argument."
	| n b w e k |
"	self isUnivariate ifFalse: [^ (self pseudoDivisionBy: aPolynomial in: self leadingIndeterminate) remainder asMultivariate]."
	"^ (self pseudoDivisionBy: aPolynomial) remainder"
	self degree < (n _ aPolynomial degree) ifTrue: [^ self].
	w _ self.
	e _ self degree - n + 1.
	b _ aPolynomial leadingCoefficient.
	[k _ w degree - n.
	w _ w * b - (aPolynomial << k * w leadingCoefficient).
	w isZero ifTrue: [^ w].
	w degree < n ifTrue: [^ w * (b ^ k)].
	k > e ifTrue: [w _ w * (b ^ (k - e))]] repeat! !

!Polynomial methodsFor: 'operations' stamp: 'len 4/24/2018 19:40:49'!
pseudoRem: aPolynomial
	"Answer the remainder of the pseudo-division of the receiver by the argument."
	self isUnivariate ifFalse: [^ (self pseudoDivisionBy: aPolynomial in: self leadingIndeterminate) remainder asMultivariate].
	^ (self pseudoDivisionBy: aPolynomial) remainder! !

!Polynomial methodsFor: 'operations' stamp: 'len 7/30/2021 09:43:41'!
s: aPolynomial
	"Answer the S-polynomial of the receiver with the argument."
	| h1 h2 lcm |
	h1 _ self leadingMonomial.
	h2 _ aPolynomial leadingMonomial.
	lcm _ h1 lcm: h2.
	^ self * (lcm / h1) / self leadingCoefficient + (aPolynomial * (lcm / h2) / aPolynomial leadingCoefficient negated)! !

!Polynomial methodsFor: 'operations' stamp: 'len 11/11/2015 02:29'!
squared
	^ self * self! !

!Polynomial methodsFor: 'operations' stamp: 'len 1/9/2022 08:35:16'!
squarefreePart
	"Answer the maximal squarefree divisor of the receiver."
	| g |
	self parent scalars characteristic = 0 ifFalse: [^ self error: 'field must include Q (i.e., must be of characteristic 0)'].
	g _ self.
	self indeterminates do: [:each| g _ g gcd: (self derivativeIn: each)].
	^ self / g! !

!Polynomial methodsFor: 'operations' stamp: 'len 2/9/2017 03:18:14'!
substitute: aBlock
	"Answer the receiver after substituting indeterminates by aBlock."
	^ self monomialsApply: [:each| each substitute: aBlock]! !

!Polynomial methodsFor: 'operations' stamp: 'len 8/9/2019 12:40:41'!
value: anObject
	"Answer the value of the receiver at the argument. For multivariate polynomials, a Tuple or Array is expected."
	| answer one |
	anObject size = self parent rank
		ifFalse: [self error: 'the arity of the argument should match the number of indeterminates'].
	answer _ (anObject at: 1) zero.
	one _ answer one.
	self partsDo: [:each|
		| monomial |
		monomial _ each key.
		answer _ (monomial isIdentity ifTrue: [one * each value] ifFalse: [(monomial value: anObject) * each value]) + answer].
	^ answer! !

!Polynomial methodsFor: 'operations' stamp: 'len 11/1/2016 18:40'!
valueWithArguments: anArray
	^ self value: anArray! !

!Polynomial methodsFor: 'operations' stamp: 'len 1/9/2022 21:16:21'!
xgcd: aPolynomial
	"Extended Euclidean algorithm.
	If the receiver is 'a' and the argument is 'b'. answer an array {g. s. t} where as + bt = g = (a gcd: b)."
	| a b zero one s1 t1 s t r1 r u |
	(self parent includes: aPolynomial) ifFalse: [^ self adapt: aPolynomial andSend: #xgcd:].
	a _ self.
	b _ aPolynomial.
	zero _ a zero. one _ a one.
	s1 _ zero. s _ one.
	t1 _ one. t _ zero.
	self scalars isField
		ifTrue:
			[r1 _ a normalized.
			r _ b normalized.
			[r1 isZero]
				whileFalse:
					[ | q temp |
					q _ r // r1.
					temp _ r1. r1 _ r - (q * r1). r _ temp.
					temp _ s1. s1 _ s - (q * s1). s _ temp.
					temp _ t1. t1 _ t - (q * t1). t _ temp].
			s _ s * b normalization. t _ t * a normalization.
			u _ r normalization.
			s _ s * u. t _ t * u. r _ r * u]
		ifFalse:
			[r1 _ a primitivePart normalized.
			r _ b primitivePart normalized.
			[r1 isZero]
				whileFalse:
					[| division q m temp |
					division _ r pseudoDivisionBy: r1.
					q _ division quotient.
					m _ r1 leadingCoefficient ^ division delta.
					temp _ r1. r1 _ r*m - (q * r1). r _ temp.
					temp _ s1. s1 _ s*m - (q * s1). s _ temp.
					temp _ t1. t1 _ t*m - (q * t1). t _ temp].
			s _ s * b normalization. t _ t * a normalization.
			u _ (a content gcd: b content) * r normalization.
			s _ s * u. t _ t * u. r _ r * u].
	^ {r. t. s}! !

!Polynomial methodsFor: 'remainder sequences' stamp: 'len 3/9/2016 00:07'!
eprs: aPolynomial
	"Answer the (Pseudo) Euclidean Polynomial Remainder Sequence of the receiver with the argument."
	| answer f0 f1 r |
	answer _ OrderedCollection new.
	f1 _ self.
	answer add: f1.
	r _ aPolynomial.
	[r isZero]
		whileFalse:
			[answer add: r.
			f0 _ f1.
			f1 _ r.
			r _ f0 pseudoRem: f1].
	^ answer! !

!Polynomial methodsFor: 'remainder sequences' stamp: 'len 7/17/2019 10:49:49'!
pprs: aPolynomial
	"Answer the Primitive Polynomial Remainder Sequence of the receiver with the argument."
	| answer f0 f1 r |
	answer _ OrderedCollection new.
	f1 _ self.
	answer add: f1.
	r _ aPolynomial.
	[r isZero]
		whileFalse:
			[answer add: r.
			f0 _ f1.
			f1 _ r.
			r _ (f0 pseudoRem: f1) primitivePart].
	^ answer! !

!Polynomial methodsFor: 'remainder sequences' stamp: 'len 1/23/2017 11:43:25'!
prs: aPolynomial
	"Answer the Polynomial Remainder Sequence of the receiver with the argument."
	| answer f0 f1 r |
	self parent scalars isField ifFalse: [^ DomainError signal: 'scalars are not a field'].
	answer _ OrderedCollection new.
	f1 _ self.
	answer add: f1.
	r _ aPolynomial.
	[r isZero]
		whileFalse:
			[answer add: r.
			f0 _ f1.
			f1 _ r.
			r _ f0 \\ f1].
	^ answer! !

!Polynomial methodsFor: 'remainder sequences' stamp: 'len 3/9/2016 06:32'!
sprs2: aPolynomial
	"Answer the Subresultant Polynomial Remainder Sequence of the receiver with the argument."
	| delta b phi beta f1 f2 r answer |
	self assert: self scalars isUFD.
	self assert: self degree >= aPolynomial degree.
	delta _ self degree - aPolynomial degree + 1.
	b _ aPolynomial leadingCoefficient.
	phi _ b ^ (delta - 1).
	beta _ (-1) ^ delta.
	answer _ OrderedCollection new.
	answer add: self; add: aPolynomial.
	f1 _ aPolynomial. f2 _ self. "f1 is F_{i-1}, f2 is F_{i-2}, r is F_i"
	[r _ (f2 pseudoRem: f1) / beta.
	r isZero ifTrue: [^ answer].
	answer add: r. f2 _ f1. f1 _ r.
	delta _ f1 degree - r degree + 1.
	beta _ (-1) ^ delta * (phi ^ (delta - 1)) * b.
	b _ r leadingCoefficient.
	phi _ phi * ((b / phi) ^ (delta - 1))] repeat! !

!Polynomial methodsFor: 'remainder sequences' stamp: 'len 1/9/2022 08:19:48'!
sprs: aPolynomial
	"Answer the Subresultant Polynomial Remainder Sequence of the receiver with the argument."
	| delta phi beta f1 f2 r answer |
	self assert: self scalars isUFD.
	self assert: self degree >= aPolynomial degree.
	f2 _ self. f1 _ aPolynomial."f1 is F_{i-1}, f2 is F_{i-2}, r is F_i"
	phi _ self scalars one.
	answer _ OrderedCollection new.
	answer add: f2.
	[f1 isZero]
		whileFalse:
			[answer add: f1.
			delta _ f2 degree - f1 degree + 1.
			beta _ (-1) ^ delta * (phi ^ (delta - 1)) * f2 leadingCoefficient.
			phi _ phi * ((f1 leadingCoefficient / phi) ^ (delta - 1)).
			r _ (f2 pseudoRem: f1) / beta.
			f2 _ f1. f1 _ r].
	^ answer! !

!Polynomial methodsFor: 'testing' stamp: 'len 1/13/2022 05:48:21'!
| aPolynomial
	"Answer true if the receiver divides aPolynomial."
	aPolynomial isZero ifTrue: [^ true].
	self isZero ifTrue: [^ false].
	self scalars isField ifTrue: [^ (aPolynomial \\ self) isZero].
	^ (aPolynomial pseudoRem: self) isZero! !

!Polynomial methodsFor: 'testing' stamp: 'len 12/30/2016 20:10:56'!
isAffineLinear
	^ self degree < 2! !

!Polynomial methodsFor: 'testing' stamp: 'len 1/14/2022 11:53:45'!
isBasicIrreducible
	self scalars isLocal ifFalse: [self error: 'not over a local ring'].
	^ (self apply: self scalars -> self scalars residueField) isIrreducible! !

!Polynomial methodsFor: 'testing' stamp: 'len 2/17/2017 08:07:02'!
isBinomial
	^ self monomials size = 2! !

!Polynomial methodsFor: 'testing' stamp: 'len 11/11/2015 03:24'!
isConstant
	^ self degree < 1! !

!Polynomial methodsFor: 'testing' stamp: 'len 3/1/2016 17:33'!
isHomogeneous
	| n |
	n _ self degree.
	self monomials do: [ :each | each degree = n ifFalse: [^ false]].
	^ true! !

!Polynomial methodsFor: 'testing' stamp: 'len 5/10/2020 12:34:09'!
isIdempotent
	^ self isConstant and: [self independentCoefficient isIdempotent]! !

!Polynomial methodsFor: 'testing' stamp: 'len 8/5/2021 08:40:43'!
isIrreducible
	self isConstant ifTrue: [^ false]. "constant polynomials are not reducible nor irreducible"
	self degree = 1 ifTrue: [^ true].
	^ self factorization size = 1! !

!Polynomial methodsFor: 'testing' stamp: 'len 12/30/2016 20:11:59'!
isLinear
	^ self degree < 2 and: [self independentCoefficient isZero]! !

!Polynomial methodsFor: 'testing' stamp: 'len 1/9/2022 09:58:58'!
isMonic
	^ self leadingCoefficient isOne! !

!Polynomial methodsFor: 'testing' stamp: 'len 2/17/2017 08:07:17'!
isMonomial
	^ self monomials size = 1! !

!Polynomial methodsFor: 'testing' stamp: 'len 7/30/2019 05:28:21'!
isNilpotent
	"Answer true if self^n = 0 for some integer n >= 1."
	^ self coefficients allSatisfy: [:each| each isNilpotent]! !

!Polynomial methodsFor: 'testing' stamp: 'len 12/23/2021 14:45:40'!
isPrimitive
	"A polynomial is primitive if it has content unity.
	(More generally, a polynomial is primitive if the coefficients generate the unit ideal <1>.)"
	^ self content isUnit! !

!Polynomial methodsFor: 'testing' stamp: 'len 6/25/2019 05:15:56'!
isSeparable
	"A polynomial over a field K is separable if it's roots are distinct in an algebraic closure of K."
	self scalars isField ifTrue: [^ (self gcd: self derivative) isConstant].
	"Over a local ring, separable is equivalent to basic irreducible, which in turn is equivalent to irreducible in the residue field:"
	self scalars isLocal ifTrue: [^ self isBasicIrreducible].
	^ self notYetImplemented! !

!Polynomial methodsFor: 'testing' stamp: 'len 1/9/2022 08:30:45'!
isSquarefree
	self isMonomial ifTrue: [^ self monomials anyOne isSquarefree].
	^ self isZero not and: [(self gcd: self derivative) isConstant]! !

!Polynomial methodsFor: 'testing' stamp: 'len 1/1/2022 09:28:28'!
isUnit
	"Answer true if the receiver is invertible."
	self isConstant ifTrue: [^ self independentCoefficient isUnit].
	parent scalars isIntegralDomain ifTrue: [^ false].
	self independentCoefficient isUnit ifFalse: [^ false].
	"this assumes the polynomial is univariate, can it be generalized to multivariate?"
	^ (1 to: self degree) allSatisfy: [:i| (self at: i) isNilpotent]
	"Also: for a local ring R with residue field K, a polynomial in R[x] is a unit iff its projection to K[x] is a unit."! !

!Polynomial methodsFor: 'testing' stamp: 'len 1/23/2017 11:42:42'!
isUnivariate
	^ self parent isUnivariate! !

!Polynomial methodsFor: 'testing' stamp: 'len 1/23/2017 11:42:50'!
isUnivariateIn: anInteger
	"Answer true if the receiver is an univariate polynomial in the anInteger-th indeterminate."
	(anInteger = 1 and: [self parent isUnivariate]) ifTrue: [^ true].
	self monomialsDo: [:each| (each isUnivariateIn: anInteger) ifFalse: [^ false]].
	^ true! !

!Polynomial methodsFor: 'testing' stamp: 'len 1/6/2022 09:27:52'!
isZerodivisor
	"Answer true if there exists a nonzero element that multiplied by the receiver is zero."
	| annihilator |
	parent isIntegralDomain ifTrue: [^ self isZero].
	"If the receiver has only 1 term, we can just check if the coefficient is a zerodivisor:"
	self support isSingleton ifTrue: [^ self leadingCoefficient isZerodivisor].
	"McCoy's theorem: a polynomial f in R[X] is a zerodivisor iff there is r in R with fr = 0."
	annihilator _ self scalars asIdeal.
	self coefficientsDo: [:each| each isZero ifFalse: [(annihilator _ annihilator /\ each annihilatorIdeal) isTrivial ifTrue: [^ false]]].
	^ annihilator isTrivial not! !

!Polynomial methodsFor: 'private' stamp: 'len 8/10/2019 08:47:34'!
karatsubaMultipliedBy: aPolynomial
	"Ref: Zippel pp 119. O(n^1.56)"
	| n h f0 f1 g0 g1 f0g0 f1g1 |
	n _ self degree.
"	self assert: aPolynomial degree = n."
	self assert: self isUnivariate.
	h _ n // 2.
	f0 _ self >> h. f1 _ self - (f0 << h).
	g0 _ aPolynomial >> h. g1 _ aPolynomial - (g0 << h).
	f0g0 _ f0 * g0.
	f1g1 _ f1 * g1.
	^ f0g0 << (2*h) + ((f1+f0)*(g1+g0) - f0g0 - f1g1 << h) + f1g1! !

!Polynomial methodsFor: 'private' stamp: 'len 8/11/2019 12:13:56'!
multipliedBy: aPolynomial truncatedTo: anInteger
	^ (self multipliedBy: aPolynomial) truncatedTo: anInteger "optimize this"! !

!Polynomial methodsFor: 'private' stamp: 'len 10/6/2016 15:35'!
parent: aPolynomialRing
	parent _ aPolynomialRing! !

!Polynomial methodsFor: 'reduction' stamp: 'len 1/13/2022 09:08:39'!
reductionBy: anArray
	"If the ordering is global answer a top-reduction of the receiver with respect to the argument (without doing tail reduction). Otherwise answer the Mora normal form."
	^ self ordering isGlobal
		ifTrue: [self reductionGlobalBy: anArray]
		ifFalse: [self reductionMoraBy: anArray]! !

!Polynomial methodsFor: 'reduction' stamp: 'len 1/13/2022 10:05:22'!
reductionFullBy: anArray
	"Answer the tail-reduced normal form of the receiver with respect to the argument (doing full tail reduction).
	For an ordering that is not global, answer the Mora normal form."
	| g h |
	self ordering isGlobal ifFalse: [^ self reductionMoraBy: anArray].
	g _ self.
	h _ g zero.
	[g isZero]
		whileFalse:
			[g _ g reductionGlobalBy: anArray.
			g isZero ifFalse: [h _ h + g leadingTerm. g _ g tail]].
	^ h! !

!Polynomial methodsFor: 'reduction' stamp: 'len 1/13/2022 09:06:19'!
reductionGlobalBy: anArray
	"Answer a top-reduction of the receiver with respect to the argument (without doing tail reduction)."
	| h |
	h _ self.
	[h isZero]
		whileFalse:
			[| lh lg g |
			lh _ h leadingMonomial.
			g _ anArray detect: [:one| (lg _ one leadingMonomial) | lh] ifNone: [^ h].
			h _ h + (g * (lh / lg) * (h leadingCoefficient negated / g leadingCoefficient))].
	^ h! !

!Polynomial methodsFor: 'reduction' stamp: 'len 1/13/2022 09:05:53'!
reductionMoraBy: anArray
	"Answer Mora's normal form of the receiver with respect to the argument."
	| h L m g ecartg |
	h _ self.
	L _ OrderedCollection withAll: anArray.
	[h isZero ifTrue: [^ h].
	m _ h leadingMonomial.
	g _ nil.
	ecartg _ -1.
	L do: [:each|
		| ecart |
		(each leadingMonomial | m and: [ecart _ each ecart. g isNil or: [ecart < ecartg]])
			ifTrue: [g _ each. ecartg _ ecart]].
	g isNil ifTrue: [^ h].
	ecartg > h ecart ifTrue: [L add: h].
	h _ h + (g * (m / g leadingMonomial) * (h leadingCoefficient negated / g leadingCoefficient))] repeat! !

!Polynomial class methodsFor: 'instance creation' stamp: 'len 2/6/2017 05:43:55'!
new
	^ self shouldNotImplement! !

!MultivariatePolynomial methodsFor: 'accessing' stamp: 'len 12/22/2017 17:51:19'!
bitSize
	self isZero ifTrue: [^ 0].
	^ parts sum: [:each| each key bitSize + each value bitSize]! !

!MultivariatePolynomial methodsFor: 'accessing-coefficients' stamp: 'len 1/1/2022 09:39:33'!
at: aMonomial
	aMonomial isInteger ifTrue: [^ self at: (self parent monomials x: self leadingIndeterminate to: aMonomial) ifAbsent: [self scalars zero]].
	^ self at: aMonomial ifAbsent: [self scalars zero]! !

!MultivariatePolynomial methodsFor: 'accessing-coefficients' stamp: 'len 6/7/2020 14:34:08'!
initialCoefficient
	^ parts isEmpty ifTrue: [self scalars zero] ifFalse: [parts first value]! !

!MultivariatePolynomial methodsFor: 'accessing-coefficients' stamp: 'len 8/18/2019 06:07:09'!
leadingCoefficient
	^ parts isEmpty ifTrue: [self scalars zero] ifFalse: [parts last value]! !

!MultivariatePolynomial methodsFor: 'accessing-monomials' stamp: 'len 6/7/2020 14:28:56'!
initialMonomial
	^ parts isEmpty ifFalse: [parts first key]! !

!MultivariatePolynomial methodsFor: 'accessing-monomials' stamp: 'len 8/18/2019 06:07:17'!
leadingMonomial
	^ parts isEmpty ifFalse: [parts last key]! !

!MultivariatePolynomial methodsFor: 'accessing-terms' stamp: 'len 5/9/2018 15:41:18'!
leadingTerm
	"Answer the first term of the receiver."

	| leadingPart |
	self isZero ifTrue: [^ self].
	leadingPart _ parts last.
	^ self parent coefficient: leadingPart value monomial: leadingPart key! !

!MultivariatePolynomial methodsFor: 'accessing-terms' stamp: 'len 4/11/2021 12:08:32'!
tail
	self isZero ifTrue: [^ self].
	^ self parent parts: parts allButLast! !

!MultivariatePolynomial methodsFor: 'comparing' stamp: 'len 12/22/2017 17:51:27'!
= aPolynomial
	self == aPolynomial ifTrue: [^ true].
	aPolynomial class = self class ifTrue: [^ parts = aPolynomial parts].
	^ super = aPolynomial! !

!MultivariatePolynomial methodsFor: 'comparing' stamp: 'len 12/22/2017 17:51:38'!
hash
	^ parts hash! !

!MultivariatePolynomial methodsFor: 'converting' stamp: 'len 4/4/2021 09:49:25'!
lift
	"If the coefficients ring is a quotient R/I, answer a representative of the receiver over R. See >>%."
	^ parent lift parts: (parts collect: [:each| each copy value: each value lift])! !

!MultivariatePolynomial methodsFor: 'converting' stamp: 'len 12/22/2017 19:06:16'!
over: aRing
	| newParts |
	self scalars = aRing ifTrue: [^ self].
	newParts _ OrderedCollection new: parts size.
	parts do: [:each| | newValue |
		(newValue _ aRing !! each value) isZero
			ifFalse: [newParts add: (each copy value: newValue)]].
	^ (self parent over: aRing) parts: newParts! !

!MultivariatePolynomial methodsFor: 'copying' stamp: 'len 12/22/2017 17:50:59'!
copy
	^ parent parts: (parts collect: [:each| each copy])! !

!MultivariatePolynomial methodsFor: 'enumerating' stamp: 'len 12/22/2017 17:51:42'!
coefficientsDo: aBlock
	parts do: [:each| aBlock value: each value]! !

!MultivariatePolynomial methodsFor: 'enumerating' stamp: 'len 12/24/2017 20:32:45'!
monomialsApply: aBlock
	| dictionary newParts |
	dictionary _ Dictionary new: parts size.
	parts do: [:each|
		dictionary at: (aBlock value: each key) add: each value].
	newParts _ OrderedCollection new: dictionary size.
	newParts resetTo: 1.
	dictionary associationsDo: [:each| each value isZero ifFalse: [newParts add: each]].
	newParts sort.
	^ self parent parts: newParts! !

!MultivariatePolynomial methodsFor: 'enumerating' stamp: 'len 1/2/2022 10:04:47'!
monomialsDo: aBlock
	"Iterate over the support of the receiver, i.e. the monomials with nonzero coefficient."
	parts do: [:each| aBlock value: each key]! !

!MultivariatePolynomial methodsFor: 'enumerating' stamp: 'len 12/24/2017 20:10:01'!
partsDo: aBlock
	parts do: aBlock! !

!MultivariatePolynomial methodsFor: 'operations' stamp: 'len 9/15/2019 09:29:20'!
+ anObject
	(self parent includes: anObject) ifFalse: [^ self adapt: anObject andSend: #+].
	^ self summedWith: anObject! !

!MultivariatePolynomial methodsFor: 'operations' stamp: 'len 1/13/2022 09:50:18'!
\\ anObject
	"Answer the remainder of the division of the receiver by the argument."
	(self scalars includes: anObject) ifTrue: [^ self apply: [:each| each \\ anObject]].
	^ self reductionFullBy: (anObject isCollection ifTrue: [anObject] ifFalse: [{anObject}])! !

!MultivariatePolynomial methodsFor: 'operations' stamp: 'len 12/23/2021 15:28:36'!
apply: aMorphism
	"Answer a new polynomial with coefficients obtainted by applying aMorphism to the coefficients of the receiver. This map is a ring homomorphism from the scalars ring.
	If aMorphism is a block we assume the parent doesn't change, i.e. the block must evaluate to values within the scalars ring of the receiver."

	| newAssociations |
	newAssociations _ OrderedCollection new: parts size.
	parts do: [:each| | newValue |
		(newValue _ aMorphism value: each value) isZero
			ifFalse: [newAssociations add: (each copy value: newValue)]].
	^ (aMorphism isBlock ifTrue: [parent] ifFalse: [parent over: aMorphism codomain]) parts: newAssociations! !

!MultivariatePolynomial methodsFor: 'operations' stamp: 'len 1/13/2022 09:54:22'!
divisionBy: anArray
	self ordering isGlobal ifFalse: [^ self notYetImplemented].
	^ MultivariateDivision divide: self by: (anArray isCollection ifTrue: [anArray] ifFalse: [{anArray}])! !

!MultivariatePolynomial methodsFor: 'operations' stamp: 'len 12/22/2017 17:47:14'!
negated
	"Answer the additive inverse of the receiver."
	^ parent parts: (parts collect: [:each| each key -> each value negated])! !

!MultivariatePolynomial methodsFor: 'operations' stamp: 'len 4/14/2020 14:26:12'!
truncatedTo: anInteger
	self degree < anInteger ifTrue: [^ self].
	^ parent parts: (parts select: [:each| each key degree < anInteger])! !

!MultivariatePolynomial methodsFor: 'testing' stamp: 'len 12/22/2017 17:49:16'!
isZero
	^ parts isEmpty! !

!MultivariatePolynomial methodsFor: 'private' stamp: 'len 12/22/2017 17:47:53'!
at: aMonomial add: aNumber
	parts isEmpty ifTrue: [aNumber isZero ifFalse: [parts add: aMonomial -> aNumber]. ^ self].
	parts
		findBinaryIndex: [:each| (each key compare: aMonomial) negated]
		do: [:index| | association newValue |
			association _ parts at: index.
			(newValue _ association value + aNumber) isZero
				ifTrue: [parts removeIndex: index]
				ifFalse: [association value: newValue "associations at: index put: aMonomial -> newValue"]]
		ifNone: [:low :high| aNumber isZero ifFalse: [parts add: aMonomial -> aNumber beforeIndex: high]]! !

!MultivariatePolynomial methodsFor: 'private' stamp: 'len 12/22/2017 17:51:33'!
at: aMonomial ifAbsent: exceptionBlock
	^ parts findBinary: [:each| (each key compare: aMonomial) negated] do: [:each| each value] ifNone: [:high :low| exceptionBlock value]! !

!MultivariatePolynomial methodsFor: 'private' stamp: 'len 12/21/2017 17:44:14'!
at: key ifPresent: presentBlock
	"Lookup the given key in the receiver. If it is present, answer the value of evaluating the given block with the value associated with the key. Otherwise, answer nil."

	| v |
	v _ self at: key ifAbsent: [ ^ nil ].
	^ presentBlock value: v! !

!MultivariatePolynomial methodsFor: 'private' stamp: 'len 12/22/2017 17:49:08'!
at: aMonomial put: aNumber
	parts isEmpty ifTrue: [aNumber isZero ifFalse: [parts add: aMonomial -> aNumber]. ^ self].
	parts
		findBinaryIndex: [:each| (each key compare: aMonomial) negated]
		do: [:index| aNumber isZero ifTrue: [parts removeIndex: index] ifFalse: [(parts at: index) value: aNumber]]
		ifNone: [:low :high| aNumber isZero ifFalse: [parts add: aMonomial -> aNumber beforeIndex: high]].
	^ aNumber! !

!MultivariatePolynomial methodsFor: 'private' stamp: 'len 12/22/2017 17:48:20'!
dividedByMonomial: aMonomial
	"The monomial ordering is preserved by this operation."
	^ parent parts: (parts collect: [:each| each key / aMonomial -> each value])! !

!MultivariatePolynomial methodsFor: 'private' stamp: 'len 8/28/2021 11:08:45'!
dividedByScalar: anElement
	^ parent parts: (parts collect: [:each| each copy value: each value / anElement])! !

!MultivariatePolynomial methodsFor: 'private' stamp: 'len 8/10/2019 08:45:11'!
multipliedBy: aPolynomial
	| dictionary newAssociations |
	dictionary _ Dictionary new: parts size + aPolynomial parts size.
	parts do: [:each|
		aPolynomial parts do: [:other|
			dictionary at: each key * other key add: each value * other value]].
	newAssociations _ OrderedCollection new: dictionary size.
	newAssociations resetTo: 1.
	dictionary associationsDo: [:each| each value isZero ifFalse: [newAssociations add: each]].
	newAssociations sort.
	^ self parent parts: newAssociations! !

!MultivariatePolynomial methodsFor: 'private' stamp: 'len 12/22/2017 17:46:56'!
multipliedByMonomial: aMonomial
	"The monomial ordering is preserved by this operation."
	^ parent parts: (parts collect: [:each| each key * aMonomial -> each value])! !

!MultivariatePolynomial methodsFor: 'private' stamp: 'len 5/9/2018 16:35:03'!
multipliedByScalar: aNumber
	| newAssociations |
	aNumber isZero ifTrue: [^ parent zero].
"	parent scalars isIntegralDomain ifTrue: [^ parent parts: (parts collect: [:each| each copy value: each value * aNumber])]."
	newAssociations _ OrderedCollection new: parts size.
	newAssociations resetTo: 1.
	parts do: [:each| | newValue |
		(newValue _ each value * aNumber) isZero
			ifFalse: [newAssociations add: (each copy value: newValue)]].
	^ parent parts: newAssociations! !

!MultivariatePolynomial methodsFor: 'private' stamp: 'len 12/22/2017 17:52:34'!
parts
	^ parts! !

!MultivariatePolynomial methodsFor: 'private' stamp: 'len 12/22/2017 17:52:46'!
parts: aCollection
	parts _ aCollection! !

!MultivariatePolynomial methodsFor: 'private' stamp: 'len 12/21/2017 18:38:44'!
sum: someAssociations with: otherAssociations into: newAssociations
	| stream1 stream2 |
	stream1 _ someAssociations readStream.
	stream2 _ otherAssociations readStream.
	[stream1 atEnd or: [stream2 atEnd]]
		whileFalse:
			[| cmp |
			cmp _ stream1 peek key compare: stream2 peek key.
			cmp < 0
				ifTrue: [newAssociations add: stream1 next copy]
				ifFalse: [cmp > 0
					ifTrue: [newAssociations add: stream2 next copy]
					ifFalse:
						[| a b newValue |
						a _ stream1 next.
						b _ stream2 next.
						(newValue _ a value + b value) isZero
							ifFalse: [newAssociations add: (a copy value: newValue)]]]].
	[stream1 atEnd] whileFalse: [newAssociations add: stream1 next copy].
	[stream2 atEnd] whileFalse: [newAssociations add: stream2 next copy].
	^ newAssociations! !

!MultivariatePolynomial methodsFor: 'private' stamp: 'len 8/10/2019 08:46:20'!
summedWith: aPolynomial
	| newAssociations |
	newAssociations _ OrderedCollection new: parts size + aPolynomial parts size.
	newAssociations resetTo: 1.
	self sum: parts with: aPolynomial parts into: newAssociations.
	^ parent parts: newAssociations! !

!MultivariatePolynomial class methodsFor: 'instance creation' stamp: 'len 12/22/2017 18:22:36'!
parts: aCollection
	^ self basicNew parts: aCollection! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 1/6/2022 19:59:40'!
+ anObject
	(self parent includes: anObject) ifFalse: [^ self  adapt: anObject andSend: #+].
	^ self parent coefficients: self coefficients + anObject coefficients! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 8/8/2019 04:45:03'!
- anObject
	(self parent includes: anObject)
		ifTrue: [^ self parent coefficients: self coefficients - anObject coefficients].
	^ self adapt: anObject andSend: #-! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 12/4/2021 13:45:20'!
/ anElement
	"Answer x such that xa = b, where b is self and a is anElement.
	The behavior is undefined if a doesn't divide b."
	| division |
	self isZero ifTrue: [^ self].
	(anElement isKindOf: Monomial)
		ifTrue: [^ self dividedByMonomial: anElement].
	(self scalars includes: anElement)
		ifTrue: [^ self parent coefficients: self coefficients / anElement].
	(self parent includes: anElement)
		ifFalse: [^ self  adapt: anElement andSend: #/].
	anElement isConstant
		ifTrue: [^ self parent coefficients: self coefficients / anElement leadingCoefficient].
	"This is a minor optimization that avoids creating an instance of Division as it is done in the superclass.
	Perhaps it is not worth it and this method should be removed."
	division _ anElement leadingCoefficient isUnit
		ifTrue: [self coefficients polynomialDivisionBy: anElement coefficients]
		ifFalse: [self coefficients polynomialPartialDivisionBy: anElement coefficients].
	division second isZero ifFalse: [^ self error: 'division not exact'].
	^ self parent coefficients: division first! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 5/13/2020 08:50:14'!
// anElement
	"Answer the quotient of the division of the receiver by the argument."
	(self scalars includes: anElement)
		ifTrue: [^ self parent coefficients: self coefficients // anElement].
	(self parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #//].
	anElement leadingCoefficient isUnit
		ifFalse: [^ self parent coefficients: (self coefficients polynomialPartialDivisionBy: anElement coefficients) first].
	^ self parent coefficients: (self coefficients polynomialDivisionBy: anElement coefficients) first! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 7/15/2021 12:44:07'!
<< anInteger
	| n |
	self isZero ifTrue: [^ self].
	n _ self degree + anInteger.
	n >= 0 ifFalse: [^ self zero].
	^ self parent coefficients: coefficients >>> anInteger! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 5/15/2020 07:01:41'!
\\ anElement
	"Answer the remainder of the division of the receiver by the argument."
	(self scalars includes: anElement)
		ifTrue: [^ self parent coefficients: self coefficients \\ anElement].
	(self parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #\\].
	anElement leadingCoefficient isUnit
		ifFalse: [^ self parent coefficients: (self coefficients polynomialRemainderOfPartialDivisionBy: anElement coefficients)].
	^ self parent coefficients: (self coefficients polynomialRemainderOfDivisionBy: anElement coefficients)! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 12/15/2021 21:06:07'!
apply: aMorphism
	"Answer a new polynomial with coefficients obtainted by applying aMorphism to the coefficients of the receiver. This morphism is a ring homomorphism from the scalars ring.
	If aMorphism is a block we assume the parent doesn't change, i.e. the block must evaluate to values within the scalars ring of the receiver."

	aMorphism isBlock ifTrue: [^ self parent coefficients: (self coefficients collect: aMorphism)].
	^ (self parent over: aMorphism codomain) coefficients: (self coefficients apply: aMorphism)! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 1/1/2022 09:34:19'!
companion
	"Answer the Frobenius companion matrix of the receiver.
	The companion matrix of a polynomial f in R[x] is the matrix of the 'multiplication by x' map on the R-algebra R[x]/<f>. This is a matrix that has f as both the characteristic and minimal polynomial.
	Also, given a linear recursive sequence with characteristic polynomial f, the transpose companion matrix of f generates the sequence."
	| n one zero |
	self isMonic ifFalse: [^ DomainError signal: 'Undefined for non-monic polynomials'].
	n _ self degree.
	zero _ self scalars zero.
	one _ self scalars one.
	^ self scalars matrix: n@n filling: [:i :j| i-1 = j ifTrue: [one] ifFalse: [j < n ifTrue: [zero] ifFalse: [(self at: i-1) negated]]]! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 1/1/2022 09:34:31'!
derivative
	| newCoefficients |
	self isZero ifTrue: [^ self].
	newCoefficients _ Array new: self degree.
	1 to: self degree do: [ :i | newCoefficients at: i put: (self at: i) * i ].
	^ self parent coefficients: newCoefficients! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 3/26/2016 23:05'!
derivativeIn: anIndeterminate
	^ (self has: anIndeterminate) ifTrue: [self derivative] ifFalse: [self zero]! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 7/9/2016 03:06'!
discriminant
	"Answer the (standard) discriminant of the receiver."
	| n |
	n _ self degree.
	^ (-1) ^ (n*(n-1)/2) / self leadingCoefficient * (self resultant: self derivative)! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 7/9/2016 03:06'!
discriminant0
	"Answer the (normalized) discriminant of the receiver."
	| n |
	n _ self degree.
	^ (-1) ^ (n*(n-1)/2) / (self leadingCoefficient ^ (2*n-1)) * (self resultant: self derivative)! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 5/15/2020 06:46:33'!
divisionBy: aPolynomial
	| result |
	result _ aPolynomial leadingCoefficient isUnit
		ifTrue: [self coefficients polynomialDivisionBy: aPolynomial coefficients]
		ifFalse: [self coefficients polynomialPartialDivisionBy: aPolynomial coefficients].
	^ Division dividend: self divisor: aPolynomial quotient: (self parent coefficients: result first) remainder: (self parent coefficients: result second)! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 1/23/2017 11:47:45'!
even
	"Decompose the receiver in the form f(x^2)x + g(x^2) and answer g(x)."
	^ self parent coefficients: ((1 to: self coefficients size by: 2) collect: [:each| coefficients at: each])! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 7/6/2021 09:29:30'!
inverse
	^ super inverse

	"If not over a field, compute the inverse of the receiver, provided the receiver is a unit."
"
	don't know when to finish, this is actually the power series expansion and if the independent coefficient is a unit and the other coefficients are all nilpotents this process is finite, but don't know when to end it..
	| a b u |
	self scalars isField ifTrue: [^ super inverse].
	a _ coefficients.
	a isEmpty ifTrue: [(ZeroDivide dividend: self one) signal].
	u _ a first inverse.
	b _ OrderedCollection new: self degree.
	b add: u.
	2 to: a size do: [:k| b add: ((1 to: k-1) sum: [:i| (b at: k-i) * (a at: i+1)]) negated * u].
	^ self parent coefficients: b"! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 12/21/2017 22:03:21'!
negated
	"Answer the additive inverse of the receiver."
	^ self parent coefficients: self coefficients negated! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 1/23/2017 11:48:16'!
odd
	"Decompose the receiver in the form f(x^2)x + g(x^2) and answer f(x)."
	^ self parent coefficients: ((2 to: self coefficients size by: 2) collect: [:each| coefficients at: each])! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 7/15/2021 12:34:51'!
psc2: i with: aPolynomial
	"Answer the anInteger-th principal subresultant coefficient of the receiver with aPolynomial."
	self flag: #fix. "use version 2, more efficient, but must test"
	^ (self subresultant: i with: aPolynomial) leadingCoefficient "WTF, sometimes subresultant returns nil, SemialgebraicSet circle"! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 1/1/2022 09:35:37'!
psc: anInteger with: aPolynomial
	"Answer the anInteger-th principal subresultant coefficient of the receiver with aPolynomial."

	| f g n m t rows tuple V |
	f _ self.
	g _ aPolynomial.
	m _ f degree.
	n _ g degree.
	t _ m + n - anInteger - anInteger.
	t <= 0 ifTrue: [^ self scalars one].
	V _ self scalars^t.
	rows _ OrderedCollection new: t.
	tuple _ V filling: [:i| f at: m - i + 1].
	n - anInteger timesRepeat: [rows add: tuple. tuple _ tuple >> 1].
	tuple _ V filling: [:i| g at: n - i + 1].
	m - anInteger timesRepeat: [rows add: tuple. tuple _ tuple >> 1].
	^ (Matrix rows: rows) determinant! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 7/9/2016 03:07'!
resultant2: aPolynomial
	"Answer the resultant of the receiver with the argument."
	| f g mult |
	self degree <= aPolynomial degree
		ifTrue: [f _ self. g _ aPolynomial]
		ifFalse: [f _ aPolynomial. g _ self].
	f isConstant ifTrue: [^ (f ^ g degree)].
	f isMonic
		ifTrue:
			[mult _ f leadingCoefficient]
		ifFalse:
			[mult _ f leadingCoefficient ^ g degree.
			f _ f / f leadingCoefficient].
	^ (g value: f companion) determinant * mult! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 7/9/2016 03:07'!
resultant3: aPolynomial
	"Answer the resultant of the receiver with the argument."

	| f g answer negate |
	self degree > aPolynomial degree
		ifTrue: [f _ aPolynomial. g _ self. negate _ true]
		ifFalse: [f _ self. g _ aPolynomial. negate _ false].
	answer _ f isConstant
		ifTrue: [f ^ g degree]
		ifFalse:
			[(f resultant3: g \\ f) * (f leadingCoefficient ^ (g degree - f degree + 1))].
	^ negate ifTrue: [answer negated] ifFalse: [answer]! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 8/1/2021 11:32:03'!
resultant: aPolynomial
	"Answer the resultant of the receiver with aPolynomial."
	(self isZero or: [aPolynomial isZero]) ifTrue: [^ self scalars zero].
	self isConstant ifTrue: [^ self independentCoefficient ^ aPolynomial degree].
	aPolynomial isConstant ifTrue: [^ aPolynomial independentCoefficient ^ self degree].
	^ (self sylvester: aPolynomial) determinant! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 1/23/2017 11:48:20'!
reversed
	"Answer the reverse of the receiver."

	^ self parent coefficients: coefficients reversed! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 1/1/2022 09:35:46'!
subresultant: i with: aPolynomial
	"Answer the i-th subresultant of the receiver with aPolynomial."
	| lambda mu n m c V rows matrix tuple |
	m _ self degree.
	n _ aPolynomial degree.
	lambda _ m min: n.
	mu _ (m max: n) - 1.
	i = lambda
		ifTrue:
			[m + 1 < n
				ifTrue: [c _ self]
				ifFalse:
					[n + 1 < m
						ifTrue: [c _ aPolynomial] ifFalse: [^ nil]].
			^ c * (c leadingCoefficient ^ ((m - n) abs - 1))].
	(i between: lambda and: mu) ifTrue: [^ self zero].
	(i between: 0 and: lambda - 1) ifFalse: [self error: 'index out of range'].
	V _ self parent^(m + n - (2*i)).
	rows _ OrderedCollection new.
	tuple _ V filling: [:k| self parent constant: (self at: m - k + 1)].
	n - i timesRepeat: [rows add: tuple. tuple _ tuple >> 1].
	tuple _ V filling: [:k| self parent constant: (aPolynomial at: n - k + 1)].
	m - i timesRepeat: [rows add: tuple. tuple _ tuple >> 1].
	matrix _ Matrix rows: rows.
	1 to: n - i do: [:k|
		matrix at: k @ (m + n - (2*i)) put: self << (n - i - k)].
	1 to: m - i do: [:k|
		matrix at: n - i + k @ (m + n - (2*i)) put: aPolynomial << (m - i - k)].
	^ matrix determinant! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 7/9/2016 03:08'!
subresultantChain: aPolynomial
	"Answer the Subresultant Chain of the receiver with the argument."
	| n answer |
	n _ self degree > aPolynomial degree ifTrue: [self degree - 1] ifFalse: [aPolynomial degree].
	answer _ OrderedCollection new: n + 2.
	answer add: self; add: aPolynomial.
	n - 1 to: 0 by: -1 do: [:i|
		answer add: (self subresultant: i with: aPolynomial)].
	^ answer! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 1/1/2022 09:35:54'!
sylvester: aPolynomial
	"Answer the Sylvester matrix of the receiver with the argument.
	If p,q are polynomials of degrees m and n:
		det S(p,q) = res (p,q)
		deg (gcd(p,q)) = m - n + rank (S(p,q))
	The kernel of the transposed Sylvester matrix gives all solutions of the Bezout equation:
		f*p + g*q = 0
	"
	| m n V rows tuple |
	m _ self degree.
	n _ aPolynomial degree.
	V _ self scalars^(m+n).
	rows _ OrderedCollection new: m+n.
	tuple _ V filling: [:i| self at: m-i+1].
	n timesRepeat: [rows add: tuple. tuple _ tuple >> 1].
	tuple _ V filling: [:i| aPolynomial at: n-i+1].
	m timesRepeat: [rows add: tuple. tuple _ tuple >> 1].
	^ Matrix rows: rows! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 4/14/2020 14:26:43'!
truncatedTo: anInteger
	coefficients size <= anInteger ifTrue: [^ self].
	^ parent coefficients: (coefficients copyFrom: 1 to: anInteger)! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 3/28/2018 18:04:25'!
value: anObject
	"Evaluate the receiver at the given argument using Horner's method."
	| x |
	x _ (anObject isTuple or: [anObject isArray])
		ifTrue: [anObject at: 1] ifFalse: [anObject].
	^ coefficients polynomialValue: x! !

!UnivariatePolynomial methodsFor: 'accessing' stamp: 'len 12/21/2017 18:20:42'!
bitSize
	^ self coefficients bitSize! !

!UnivariatePolynomial methodsFor: 'accessing' stamp: 'len 12/21/2017 18:26:42'!
coefficients
	^ coefficients! !

!UnivariatePolynomial methodsFor: 'accessing' stamp: 'len 4/4/2021 09:49:59'!
lift
	"If the coefficients ring is a quotient R/I, answer a representative of the receiver over R. See >>%."
	^ parent lift coefficients: coefficients lift! !

!UnivariatePolynomial methodsFor: 'accessing' stamp: 'len 3/3/2021 07:43:21'!
representative
	"If the coefficients ring is a quotient R/I, answer a representative of the receiver over R. See >>%."
	^ (parent over: parent scalars base) coefficients: coefficients representative! !

!UnivariatePolynomial methodsFor: 'accessing-coefficients' stamp: 'len 1/1/2022 09:30:45'!
at: aMonomial
	| i |
	i _ aMonomial isInteger ifTrue: [aMonomial] ifFalse: [aMonomial degree].
	^ coefficients at: i+1 ifAbsent: [self scalars zero]! !

!UnivariatePolynomial methodsFor: 'accessing-coefficients' stamp: 'len 3/24/2016 03:50'!
degree
	coefficients isEmpty ifTrue: [^ Infinity negative].
	^ coefficients size - 1! !

!UnivariatePolynomial methodsFor: 'accessing-coefficients' stamp: 'len 1/1/2022 09:31:08'!
independentCoefficient
	^ coefficients at: 1 ifAbsent: [self scalars zero]! !

!UnivariatePolynomial methodsFor: 'accessing-coefficients' stamp: 'len 1/1/2022 09:31:29'!
initialCoefficient
	^ coefficients detect: [:one| one isZero not] ifNone: [self scalars zero]! !

!UnivariatePolynomial methodsFor: 'accessing-coefficients' stamp: 'len 1/1/2022 11:24:04'!
leadingCoefficient
	parent isLocal ifTrue: [^ self coefficients detect: [:one| one isZero not] ifNone: [self scalars zero]].
	self isZero ifTrue: [^ self scalars zero].
	^ self at: self degree! !

!UnivariatePolynomial methodsFor: 'accessing-monomials' stamp: 'len 2/6/2017 05:53:46'!
leadingMonomial
	| answer |
	self monomialsDo: [:each| (answer isNil or: [each > answer]) ifTrue: [answer _ each]].
	^ answer

"this could be faster, but it fails with local orderings for example:
	^ self isZero ifFalse: [self parent monomials x: self parent indeterminate to: self degree]
"! !

!UnivariatePolynomial methodsFor: 'accessing-monomials' stamp: 'len 4/14/2020 18:53:35'!
order
	"Answer the minimum degree of the monomials present in the receiver."

	^ self isZero ifTrue: [Infinity negative] ifFalse: [(coefficients findFirst: [:one| one isZero not]) - 1]! !

!UnivariatePolynomial methodsFor: 'comparing' stamp: 'len 7/9/2016 03:00'!
= anObject
	(anObject isKindOf: UnivariatePolynomial) ifFalse: [^ false].
	^ self coefficients = anObject coefficients
"	self degree = anObject degree ifFalse: [^ false].
	0 to: self degree do: [:i| (self coefficientAtDegree: i) = (anObject coefficientAtDegree: i) ifFalse: [^ false]].
	^ true"! !

!UnivariatePolynomial methodsFor: 'comparing' stamp: 'len 1/1/2022 09:34:36'!
hash
	| answer |
	self isZero ifTrue: [^ 0].
	answer _ self degree.
	0 to: self degree do: [:i| answer _ answer + (self at: i) hash].
	^ answer! !

!UnivariatePolynomial methodsFor: 'converting' stamp: 'len 12/21/2017 21:52:44'!
over: aRing
	^ (self parent over: aRing) coefficients: (self coefficients over: aRing)! !

!UnivariatePolynomial methodsFor: 'copying' stamp: 'len 12/21/2017 22:06:33'!
copy
	^ self parent coefficients: self coefficients copy! !

!UnivariatePolynomial methodsFor: 'enumerating' stamp: 'len 12/21/2017 21:51:15'!
coefficientsDo: aBlock
	self coefficients do: aBlock! !

!UnivariatePolynomial methodsFor: 'enumerating' stamp: 'len 5/15/2019 01:52:21'!
monomialsApply: aBlock
	| monomials n newCoefficients |
	monomials _ (1 to: coefficients size) collect: [:i|
		(aBlock value: (self parent monomials x: 1 to: i-1)) -> (coefficients at: i)].
	n _ monomials max: [:each| each key degree].
	newCoefficients _ (Array new: n+1) atAllPut: self scalars zero.
	monomials do: [:each| newCoefficients at: each key degree + 1 add: each value].
	^ self parent coefficients: newCoefficients ! !

!UnivariatePolynomial methodsFor: 'enumerating' stamp: 'len 1/2/2022 10:10:42'!
monomialsDo: aBlock
	"Iterate over the support of the receiver, i.e. the monomials with nonzero coefficient."
	1 to: coefficients size do: [:i|
		(coefficients at: i) isZero
			ifFalse: [aBlock value: (self parent monomials x: 1 to: i-1)]]! !

!UnivariatePolynomial methodsFor: 'enumerating' stamp: 'len 4/22/2019 04:04:31'!
partsDo: aBlock
	coefficients withIndexDo: [:value :index| value isZero ifFalse: [aBlock value: (self parent monomials x: 1 to: index-1) -> value]]! !

!UnivariatePolynomial methodsFor: 'factorization' stamp: 'len 1/9/2022 21:02:26'!
distinctDegreeFactorization
	"Answer the distinct-degree factorization of a monic squarefree polynomial over a finite field.
	The factorizations is a Dictionary d -> g, where g is the product of all irreducible factors of degree d."
	| answer i f f2 one q x R h |
	answer _ Dictionary new.
	f _ self.
	R _ f parent.
	x _ R x.
	one _ R one.
	q _ R scalars size.
	i _ 1.
	f2 _ f.
	h _ x.
	[f2 degree >= (2*i)]
		whileTrue:
			[ | g | g _ f2 gcd: (h _ h raisedTo: q modulo: f2) - x.
			g ~= one ifTrue: [answer at: i put: g. f2 _ f2 // g].
			i _ i + 1].
	f2 ~= one ifTrue: [answer at: f2 degree put: f2].
	answer isEmpty ifTrue: [answer at: 1 put: f].
	^ answer! !

!UnivariatePolynomial methodsFor: 'factorization' stamp: 'len 12/17/2021 14:44:53'!
equalDegreeFactorization: d
	"Cantor-Zassenhaus algorithm. Answer the equal-degree factorization of a monic squarefree univariate polynomial which has r>=2 pairwise distinct irreducible factors each of degree d."
	| f r q h g one factors c |
	f _ self.
	q _ f scalars size.
	q odd ifFalse: [^ self equalDegreeFactorization2: d].
	r _ f degree / d.
	one _ f parent one.
	factors _ OrderedCollection with: f.
	[factors size < r]
		whileTrue:
			[[h _ (f parent atRandomMaxDegree: 2*d-1). "should be monic? should: d <= deg(h) <= 2d-1"
			h isZero] whileTrue. "ensure it's not 0"
			h _ h normalized.
			g _ (h raisedTo: q^d - 1 / 2 modulo: f) - one. "<- most time is spent here"
			factors do: [:u|
				u degree > d
					ifTrue:
						[c _ g gcd: u.
						(c ~= one and: [c ~= u])
							ifTrue: "found non-trivial common factor c"
								[factors _ factors copyWithout: u.
								factors add: c; add: u // c]]]].
	^ factors! !

!UnivariatePolynomial methodsFor: 'factorization' stamp: 'len 8/5/2021 08:36:29'!
factorization
	^ self scalars factorizationOf: self! !

!UnivariatePolynomial methodsFor: 'factorization' stamp: 'len 1/9/2022 08:35:42'!
squarefreeFactorization
	"Answer a squarefree factorization of the receiver."
	^ self scalars squarefreeFactorizationOf: self! !

!UnivariatePolynomial methodsFor: 'factorization-private' stamp: 'len 4/16/2018 20:24:33'!
equalDegreeFactorization2: d
	"Cantor-Zassenhaus algorithm. Answer the equal-degree factorization of a monic squarefree univariate polynomial which has r>=2 pairwise distinct irreducible factors each of degree d."
	| f r h g one factors c |
	f _ self.
"	q _ f parent scalars size.
	q even ifFalse: [^ self error: 'order not even']."
	r _ f degree / d.
	one _ f parent one.
	factors _ OrderedCollection with: f.
	h _ f parent x.
	[factors size < r]
		whileTrue:
			[g _ h.
			d - 1 timesRepeat: [g _ h + g squared \\ f].
			factors do: [:u|
				u degree > d
					ifTrue:
						[c _ g gcd: u.
						(c ~= one and: [c ~= u])
							ifTrue:
								[factors _ factors copyWithout: u.
								factors add: c; add: u // c]]].
			h _ h << 2].
	^ factors! !

!UnivariatePolynomial methodsFor: 'factorization-private' stamp: 'len 1/9/2022 21:02:32'!
factorizationZassenhauss
	"Zassenhauss algorithm. Answer the irreducible factors of a squarefree primitive polynomial with integer coefficients."
	| f n A b B C  df p Zp fp dfp k factors r answer |
	f _ self.
	n _ f degree.
	n = 1 ifTrue: [^ {f}].
	A _ f normMax.
	b _ f leadingCoefficient.
	B _ (n+1) sqrt * (1<<n) * A * b. "float will fail"
	C _ (n+1)^(2*n)*(A^(2*n-1)).
"	 _ (2 * (C log: 2)) ceiling."
	 _ 2 * C highBit. "+1?"
	df _ f derivative.
	[[p _ (2** ln) asInteger atRandom nextPrime.
	p | b] whileTrue.
	Zp _ PrimeField new: p.
	fp _ f over: Zp.
	dfp _ df over: Zp.
	(fp gcd: dfp) isConstant] whileFalse.
	"modular factorization"
	factors _ fp normalized factorization.
	r _ factors size. "should repeat this 5 times and choose smallest r"
	r = 1 ifTrue: [^ {f}]. "if irreducible mod p, also irreducible over Z"
"	self assert: (self % p - (factors product * b)) isZero."
	"hensel lifting"
	k _ ((2*B+1) log: p) abs ceiling. "p^k > 2B"
	k _ 1 << k highBit. "<- in order to do quadratic liftings, maybe shouldn't"
	factors _ f henselLift: factors asArray to: (PrimePowerRing new: p to: k). "lift to p^k" "<- about 20% of time is spent here"
"	1 to: k do: [:i|
		self assert: (self - ((factors product: [:fi| fi lift]) * b) % (p^i)) isZero]."
	"recombination"
	answer _ Bag new.
	1 to: r do: [:j|
		(factors combinations: j) do: [:each| | g division | "<- about 50% of time is spent in this recombination step"
			g _ (each product * b) lift primitivePart.
			division _ f divisionBy: g.
			division remainder isZero ifTrue: [answer add: g. f _ division quotient. f isConstant ifTrue: [^ answer]]]].
	^ answer add: f; yourself! !

!UnivariatePolynomial methodsFor: 'factorization-private' stamp: 'len 1/9/2022 21:02:37'!
factorizationZassenhauss2
	"ZassenHauss algorithm. Answer the irreducible factors of a squarefree polynomial with integer coefficients."
	| answer f df p fp dfp factors r B e g |
	answer _ Bag new.
	f _ self integerPrimitivePart.
	"remove x factor"
"	f leadingCoefficient abs > f independentCoefficient abs ifTrue: [f _ f reversed]."
	df _ f derivative.
	B _ f landauMignotteBound.
	"1. Choose a prime p such that gcd(f,df) = 1 mod p:"
	[p _ 1000 atRandom nextPrime.
	fp _ f % p.
	dfp _ df % p.
	(fp gcd: dfp) = fp one] whileFalse.
	"2. Modular factorization: factor f mod p."
	factors _ fp factorization.
	r _ factors size. "should repeat this 5 times and choose smallest r"
	r = 1 ifTrue: [^ {f}]. "if irreducible mod p, also irreducible over Z"
	"3. Compute Landau-Mignotte bound and p^a with enough precision for Hensel lifting:"
	e _ (B*2*f leadingCoefficient log: p) ceiling.
	"4. Hensel lift to precision p^a:"
		"..."
	"5. Recombination: try all combinations of factors and find divisors of f:"
	1 to: r do: [:k|
		(factors combinations: k) do: [:each|
			g _ each product.
			g | f ifTrue: [answer add: g]]].
	^ answer! !

!UnivariatePolynomial methodsFor: 'factorization-private' stamp: 'len 5/9/2020 14:06:47'!
henselLift: factors to: Zpk
	"The receiver is a polynomial in Z[x].
	The argument 'factors' is a factorization of the receiver's projection to (Z/pZ)[x].
	Answer the Hensel lift of the factorization to (Z/(p^k)Z)[x]."
	| r mid g h s t euclid gFactors hFactors |
"	p _ factors anyOne scalars characteristic."
	r _ factors size.
	r = 1 ifTrue: "can be optimized, compute inverse modulo p using extended euclid, then lift to p^k with newton iteration algorithm 9.10 (modern computer algebra)"
		[^ {(self over: Zpk) * (Zpk !! self leadingCoefficient) inverse}].
	mid _ r // 2.
	gFactors _ factors copyFrom: 1 to: mid.
	hFactors _ factors copyFrom: mid+1 to: r.
	g _ gFactors product * self leadingCoefficient.
	h _ hFactors product.
	euclid _ g xgcd: h.
	s _ euclid at: 2.
	t _ euclid at: 3.
"	m _ p."
	Zpk quadraticLiftingsDo: [:phi| "Hensel step:"
		| e division c d b |
"		self assert: (self % m - (g*h)) isZero.
		self assert: (s*g + (t*h) - 1) isZero.
		m _ m squared."
		g _ g apply: phi. h _ h apply: phi. s _ s apply: phi. t _ t apply: phi.
		e _ (self over: phi codomain) - (g*h).
		division _ s*e divisionBy: h.
		c _ division quotient.
		d _ division remainder.
		g _ g + (t*e) + (c*g).
		h _ h + d.
		b _ s*g + (t*h) - 1.
		division _ s*b divisionBy: h.
		c _ division quotient.
		d _ division remainder.
		s _ s - d.
		t _ t - (t*b) - (c*g).
"		self assert: (self % m - (g*h)) isZero.
		self assert: (s*g + (t*h) - 1) isZero"].
	^ (g lift henselLift: gFactors to: Zpk), (h lift henselLift: hFactors to: Zpk)! !

!UnivariatePolynomial methodsFor: 'factorization-private' stamp: 'len 4/24/2018 01:32:31'!
landauMignotteBound
	"Answer the Landau-Mignotte bounds for the receiver.
	This is an upper bound for the absolute value of the coefficients of any nontrivial factor of a polynomial with integer coefficients. The bound depends on both the degree and the size of the coefficients of the receiver."
	| d h |
	d _ self degree // 2.
	h _ d // 2.
	^ (d - 1 choose: h) * self norm2 + (d - 1 choose: h - 1)! !

!UnivariatePolynomial methodsFor: 'factorization-private' stamp: 'len 1/9/2022 21:03:04'!
squarefreeFactorizationFiniteField
	"Answer the squarefree decomposition of a monic polynomial."
	"NOTE: this only works on prime fields. For non-prime fields, after substituting x^p by x we must also apply the inverse of the Frobenius automorphism to the coefficients."
	| answer f one p i g c w y z |
	self isMonic ifFalse: [self error: 'not monic'].
	answer _ Bag new.
	f _ self.
	one _ f one.
	p _ f scalars characteristic.
	(g _ f derivative) isZero
		ifTrue:
			[f _ f monomialsApply: [:m| m root: p]. "not enough if the field is non-prime"
			f squarefreeFactorizationFiniteField
				do: [:each| answer add: each withOccurrences: p].
			^ answer].
	c _ f gcd: g.
	w _ f // c.
	i _ 1.
	[w = one]
		whileFalse:
			[y _ w gcd: c. z _ w // y.
			z ^ i = one ifFalse: [answer add: z withOccurrences: i].
			i _ i + 1.
			w _ y. c _ c // y].
	c = one
		ifFalse:
			[c _ c monomialsApply: [:m| m root: p]. "not enough if the field is non-prime"
			c squarefreeFactorizationFiniteField
				do: [:each| answer add: each withOccurrences: p]].
	^ answer! !

!UnivariatePolynomial methodsFor: 'factorization-private' stamp: 'len 1/9/2022 21:03:10'!
squarefreeFactorizationYun
	"Answer a squarefree decomposition of the receiver.
	Use Yun's algorithm. Assume the coefficients are in a unique
	factorization domain or in a field of characteristic 0.
	Yun's algorithm on an input polynomial of degree n uses O(M(n)log(n)) operations in the base field F, where M(n) is the number of operations in F required to multiply two polynomias of degree n in F[x]."

	| p q gcd count answer |
	answer _ Bag new.
	count _ 1.
"	lc _ self leadingCoefficient.
	lc = self scalars one
		ifFalse: [answer add: (self parent constant: lc)].
	p _ self / lc."
	p _ self normalized.
	q _ p derivative.
	gcd _ p gcd: q.
	gcd degree > 0
		ifTrue:
			[p _ p // gcd.
			q _ q // gcd - p derivative.
			[q isZero]
				whileFalse:
					[gcd _ p gcd: q.
					gcd degree > 0 ifTrue: [answer add: gcd withOccurrences: count].
					count _ count + 1.
					p _ p // gcd.
					q _ q // gcd - p derivative]].
	^ answer add: p withOccurrences: count; yourself! !

!UnivariatePolynomial methodsFor: 'roots' stamp: 'len 4/10/2018 16:11:32'!
allRoots
	"Answer the roots (counted with multiplicity) in the coefficients ring or field."
	^ self allRootsIn: self scalars! !

!UnivariatePolynomial methodsFor: 'roots' stamp: 'len 7/13/2021 15:00:25'!
allRootsIn: aRing
	"Answer the roots (counted with multiplicity) in aRing."
	^ aRing allRootsOf: self! !

!UnivariatePolynomial methodsFor: 'roots' stamp: 'len 4/16/2018 19:49:43'!
anyRoot
	^ self anyRootIn: self scalars! !

!UnivariatePolynomial methodsFor: 'roots' stamp: 'len 7/13/2021 14:58:03'!
anyRootIn: aRing
	^ aRing anyRootOf: self! !

!UnivariatePolynomial methodsFor: 'roots' stamp: 'len 4/16/2018 20:38:44'!
cauchyRootBound
	| max a0 an |
	max _ 0.
	self coefficients do: [:each| max _ max max: each abs].
	a0 _ self independentCoefficient abs.
	an _ self leadingCoefficient abs.
	^ Array with: a0 / (a0 + max) with: an + max / an! !

!UnivariatePolynomial methodsFor: 'roots' stamp: 'len 2/13/2017 07:54:44'!
multiplicityAt: aPoint
	"Answer the multiplicity of aPoint as zero of the receiver."
	| answer f |
	self isZero ifTrue: [^ Infinity positive].
	answer _ 0.
	f _ self.
	[(f value: aPoint) isZero]
		whileTrue:
			[answer _ answer + 1.
			f _ f derivative].
	^ answer! !

!UnivariatePolynomial methodsFor: 'roots' stamp: 'len 2/6/2017 06:44:06'!
orderAt: aPoint
	^ self multiplicityAt: aPoint! !

!UnivariatePolynomial methodsFor: 'roots' stamp: 'len 4/10/2018 16:11:22'!
roots
	"Answer the set of distinct roots in the coefficients ring or field."
	^ self rootsIn: self scalars! !

!UnivariatePolynomial methodsFor: 'roots' stamp: 'len 7/13/2021 14:58:45'!
rootsIn: aRing
	"Answer the distinct roots (not counted with multiplicity) in the given domain."
	^ aRing rootsOf: self! !

!UnivariatePolynomial methodsFor: 'roots' stamp: 'len 1/9/2022 21:02:55'!
signature
	"Answer the signature (r1,r2) of the receiver, where r1 is the number of real roots and 2*r2 is the number of non-real roots. Assume the receiver's coefficients are integers. Throw an error if the receiver is not squarefree.
	Ref: COHEN Algorithm 4.1.11 (Sturm)."
	| A B g h s n t r1 d R |
	self isZero ifTrue: [^ #(0 0)].
	A _ self primitivePart.
	B _ self derivative primitivePart.
	g _ 1.
	h _ 1.
	s _ A sign.
	n _ A degree.
	t _ n even ifTrue: [s negated] ifFalse: [s].
	r1 _ 1.
	[d _ A degree - B degree.
	R _ A pseudoRem: B.
	R isZero ifTrue: [^ self error: 'polynomial is not squarefree'].
	(d odd or: [B leadingCoefficient > 0])
		ifTrue: [R _ R negated].
	"Use Sturm:"
	R sign ~= s ifTrue: [s _ s negated. r1 _ r1 - 1].
	R sign ~= ((-1) ^ R degree * t) ifTrue: [t _ t negated. r1 _ r1 + 1].
	"Finished?"
	R isConstant]
		whileFalse:
			[A _ B.
			B _ R / (h ^ d * g).
			g _ A leadingCoefficient abs.
			h _ h ^ (1 - d) * (g ^ d)].
	^ {r1. n - r1 / 2}! !

!UnivariatePolynomial methodsFor: 'roots' stamp: 'len 12/17/2021 14:45:11'!
zeroAddition: aPolynomial
	"Answer a polynomial whose zeros are the addition of the zeros of the receiver with the zeros of the argument."
	| f g R S X Y C |
	self degree <= aPolynomial degree
		ifTrue: [f _ self. g _ aPolynomial]
		ifFalse: [g _ self. f _ aPolynomial].
	R _ self parent.
	S _ self scalars polynomialsIn: 2.
	X _ S x: 1.
	Y _ S x: 2.
	f isMonic ifFalse: [f _ f normalized]. "otherwise the companion matrix is undefined"
	C _ f companion apply: R scalars -> R.
	^ ((g value: X - Y) asUnivariate value: C) determinant! !

!UnivariatePolynomial methodsFor: 'roots' stamp: 'len 4/30/2018 05:17:16'!
zeroNegation
	"Answer a polynomial whose zeros are the receiver zeros negated."
	^ self parent coefficients:
		(self degree odd "this distinction is made to keep the leading coefficient positive, as a minimal polynomial"
			ifTrue: [self coefficients withIndexCollect: [:each :i| i odd ifTrue: [each negated] ifFalse: [each]]]
			ifFalse: [self coefficients withIndexCollect: [:each :i| i even ifTrue: [each negated] ifFalse: [each]]])! !

!UnivariatePolynomial methodsFor: 'roots' stamp: 'len 12/17/2021 14:45:16'!
zeroProduct: aPolynomial
	"Answer a polynomial whose zeros are the product of the receiver zeros by the zeros of the argument."
	| f g C R |
	self degree <= aPolynomial degree
		ifTrue: [f _ self. g _ aPolynomial]
		ifFalse: [g _ self. f _ aPolynomial].
	f isMonic ifFalse: [f _ f normalized]. "otherwise the companion matrix is undefined"
	R _ self parent.
	C _ f companion apply: R scalars -> R.
	^ (g homogenized asUnivariate value: C) determinant! !

!UnivariatePolynomial methodsFor: 'roots' stamp: 'len 4/27/2018 16:25:56'!
zeroRaisedTo: anInteger
	"Answer a polynomial whose zeros are the zeros of the receiver raised to anInteger."
	self notYetImplemented! !

!UnivariatePolynomial methodsFor: 'roots' stamp: 'len 11/20/2016 10:22:25'!
zeroReciprocal
	"Answer a polynomial whose zeros are the reciprocals of the receiver's zeros."

	^ self reversed! !

!UnivariatePolynomial methodsFor: 'roots' stamp: 'len 12/4/2017 10:22:45'!
zeroSquareRoot
	^ self value: self parent x squared! !

!UnivariatePolynomial methodsFor: 'testing' stamp: 'len 1/23/2017 11:47:49'!
has: anIndeterminate
	^ self degree > 0 and: [self parent has: anIndeterminate]! !

!UnivariatePolynomial methodsFor: 'testing' stamp: 'len 6/14/2019 01:28:07'!
isEisenstein
	coefficients first valuation = 1 ifFalse: [^ false].
	((2 to: coefficients size - 1) allSatisfy: [:i| (coefficients at: i) valuation >= 1]) ifFalse: [^ false].
	^ coefficients last valuation = 0! !

!UnivariatePolynomial methodsFor: 'testing' stamp: 'len 6/14/2019 01:28:30'!
isInertial
	coefficients first valuation = 0 ifFalse: [^ false].
	coefficients last valuation = 0 ifFalse: [^ false].
	^ (self apply: self scalars -> self scalars residueField) isIrreducible! !

!UnivariatePolynomial methodsFor: 'testing' stamp: 'len 8/5/2021 08:43:22'!
isIrreducible
	| R |
	self isConstant ifTrue: [^ false]. "constant polynomials are not reducible nor irreducible"
	self degree = 1 ifTrue: [^ true].
	R _ self scalars.
	((R isKindOf: RealField) and: [self degree > 2])
		ifTrue: [^ false].
	(R isKindOf: ComplexField)
		ifTrue: [^ self degree = 1].
	R isFiniteField
		ifTrue: [^ self isIrreducibleRabin].
"	(R isKindOf: RationalField)
		ifTrue: [^ self isIrreducibleHeuristic: ...]."
	"f irreducible in R[x] => mu(f(x)) = k*(g(x))^n, where k is unit and mu is the canonical projection to the residue field K:"
"	(R isLocal and: [(self apply: R -> R residueField) factors asSet size = 1])
		ifTrue: [^ true]."
	^ self factorization size = 1! !

!UnivariatePolynomial methodsFor: 'testing' stamp: 'len 4/16/2018 20:26:51'!
isIrreducibleBenOr
	"Ben-Or Irreducibility Test algorithm for polynomials in field of characteristic q."
	| q x one |
	q _ self scalars characteristic.
	x _ self parent x.
	one _ self one.
	1 to: self degree // 2 do: [:i|
		(self gcd: x^(q^i) - x \\ self) = one ifTrue: [^ false]].
	^ true! !

!UnivariatePolynomial methodsFor: 'testing' stamp: 'len 7/17/2019 10:55:01'!
isIrreducibleHeuristic2: anInteger
	"Answer an Integer or nil. If the answer is an Integer, the
	receiver is irreducible iff that integer is prime, and in fact the
	integer will be prime with a very high probability (a probabilistic
	test is used here). If the answer is nil, the heuristic test has failed,
	and nothing can be said about the irreducibility of the receiver."

	"This is a probabilistic test for irreudcibility of rational univariate
	polynomials. It works looking for a prime evaluation of the polynomial.
	If it finds such a prime, then it's returned, and nil otherwise. The
	argument anInteger is the upper bound for the looking for primes."

	"Reference: 'A Heuristic Polynomial Irreducibility Test', Michael
	Monagan, J. Symbolic Comp., (1992) Vol. 13, No. 1, pp 47-57."

	| f g bg bound val try gcd |
	f _ self integerPrimitivePart.
	g _ f reversed.
	(bg _ g norm1 / g leadingCoefficient abs + 1) <
	(bound _ f norm1 / f leadingCoefficient abs + 1)
		ifTrue: [f _ g. bound _ bg].
	bound to: anInteger - 1 / 2 do: [ :each |
		val _ (f value: each) abs.
		gcd _ val gcd: 355929487585205167172661547995662840887819680000.
		(gcd <= (each - bound) squared and: [(try _ val / gcd) isPrime])
			ifTrue: [^ try].
		val _ (f value: each negated) abs.
		gcd _ val gcd: 355929487585205167172661547995662840887819680000.
		(gcd <= (each - bound) squared and: [(try _ val / gcd) isPrime])
			ifTrue: [^ try]
	].
	^ nil! !

!UnivariatePolynomial methodsFor: 'testing' stamp: 'len 7/17/2019 10:55:07'!
isIrreducibleHeuristic: anInteger
	"Answer an Integer or nil. If the answer is an Integer, the
	receiver is irreducible iff that integer is prime, and in fact the
	integer will be prime with a very high probability (a probabilistic
	test is used here). If the answer is nil, the heuristic test has failed,
	and nothing can be said about the irreducibility of the receiver."

	"This is a probabilistic test for irreudcibility of rational univariate
	polynomials. It works looking for a prime evaluation of the polynomial.
	If it finds such a prime, then it's returned, and nil otherwise. The
	argument anInteger is the upper bound for the looking for primes."

	| f val bound interval |
	f _ self integerPrimitivePart.
	bound _ self cauchyRootBound first floor abs.
	bound even ifTrue: [bound _ 0 max: bound - 1].
	interval _ f independentCoefficient odd
		ifTrue: [bound to: bound + (anInteger // 2)]
		ifFalse: [bound to: bound + anInteger by: 2].
	interval do: [ :each |
		val _ (f value: each) abs.
		val isPrime ifTrue: [^ val].
		val _ (f value: each negated) abs.
		val isPrime ifTrue: [^ val]
	].
	^ nil! !

!UnivariatePolynomial methodsFor: 'testing' stamp: 'len 8/5/2021 08:43:25'!
isIrreducibleRabin
	| Fx x one f n h g q |
	(self independentCoefficient isZero and: [self degree > 1]) ifTrue: [^ false].
	"Rabin's algorithm:"
	f _ self.
	Fx _ f parent.
	q _ Fx scalars size.
	x _ Fx x.
	one _ Fx one.
	n _ f degree.
	n factorization asSet do: [:p|
		h _ (x raisedTo: q^(n/p) modulo: f) - x \\ f.
		g _ f gcd: h.
		g ~= one ifTrue: [^ false]].
	g _ (x raisedTo: q^n modulo: f) - x \\ f.
	g isZero ifFalse: [^ false].
	^ true! !

!UnivariatePolynomial methodsFor: 'testing' stamp: 'len 3/27/2016 07:56'!
isUnivariate
	^ true! !

!UnivariatePolynomial methodsFor: 'testing' stamp: 'len 12/21/2017 18:40:41'!
isZero
	^ coefficients isZero! !

!UnivariatePolynomial methodsFor: 'private' stamp: 'len 7/28/2021 10:12:53'!
coefficients: aTuple
	| n |
	coefficients _ (n _ aTuple depth) < aTuple size
		ifTrue: [aTuple copyFrom: 1 to: n] ifFalse: [aTuple]! !

!UnivariatePolynomial methodsFor: 'private' stamp: 'len 7/15/2021 12:34:04'!
dividedByMonomial: aMonomial
	^ self << aMonomial degree negated! !

!UnivariatePolynomial methodsFor: 'private' stamp: 'len 8/28/2021 11:08:05'!
dividedByScalar: anElement
	^ self parent coefficients: self coefficients / anElement! !

!UnivariatePolynomial methodsFor: 'private' stamp: 'len 7/15/2021 12:41:15'!
exactlyDividedBy2: aPolynomial
	"Answer the exact division of the receiver by the argument.
	Apply the Schonhage-Jabelean algorithm, for polynomials of degree at most 2n and n with coefficients in a field. When necesary conditions don't hold, do the ordinary division.
	Ref: 'Algorithms With Exact Divisions Made Faster', Arnold Schonhage,
	INRIA Research Report Nro. 2381, Algorithms Seminar 1993-1994, p. 51."

	| order f g m n h l k cg q |
	self flag: #fix. "this has some bug"
	self isZero
		ifTrue: [^ self].
	aPolynomial isConstant
		ifTrue: [^ self / aPolynomial leadingCoefficient].
	(self isUnivariate and: [aPolynomial isUnivariate])
		ifFalse: [^ (MultivariateDivision divide: self by: {aPolynomial}) exactQuotient].
	self scalars isField
		ifFalse: [^ (PseudoDivision divide: self by: aPolynomial) exactQuotient].
	(order _ aPolynomial order) > 0 ifTrue: [^ self >> order exactlyDividedBy: aPolynomial >> order].
	f _ self coefficients.
	g _ aPolynomial coefficients.
	m _ f size.
	n _ g size.
	m = n ifTrue: [^ self parent constant: f last / g last].
 	n * 2 > m ifFalse: [^ (self divisionBy: aPolynomial) exactQuotient].

	h _ f size // 2.
	l _ h // 2.
	k _ h - l.

	q _ Array new: m-n+1.
	
	"Jebelean division for the lowest half:"
	cg _ g first inverse. "reciprocal of the independent coefficient"
	0 to: l do: [:i|
		| qi |
		qi _ q at: i+1 put: (f at: i+1) * cg.
		1 to: l-i do: [:j|
			f at: i+j+1 put: (f at: i+j+1) - (qi*(g at: j+1))]]. "optimize negated"
	
	"Schonhage division for the other half:"
	cg _ g last inverse. "reciprocal of the leading coefficient"
	m-n to: m-n-k+1 by: -1 do: [:i|
		| qi |
		qi _ q at: i+1 put: (f at: i+n) * cg.
		n-2 to: m-k-i by: -1 do: [:j|
			f at: i+j+1 put: (f at: i+j+1) - (qi*(g at: j+1))]].

	^ self parent coefficients: q! !

!UnivariatePolynomial methodsFor: 'private' stamp: 'len 8/10/2019 08:44:31'!
multipliedBy: aPolynomial
	^ self parent coefficients: (self coefficients convolution: aPolynomial coefficients)! !

!UnivariatePolynomial methodsFor: 'private' stamp: 'len 7/15/2021 12:34:10'!
multipliedByMonomial: aMonomial
	^ self << aMonomial degree! !

!UnivariatePolynomial methodsFor: 'private' stamp: 'len 12/24/2017 19:32:53'!
multipliedByScalar: aNumber
	^ self parent coefficients: self coefficients * aNumber! !

!UnivariatePolynomial class methodsFor: 'instance creation' stamp: 'len 12/22/2017 18:22:09'!
coefficients: aTuple
	^ self basicNew coefficients: aTuple! !

!AlgebraElement methodsFor: 'accessing' stamp: 'len 6/11/2020 12:36:23'!
characteristicPolynomial
	^ self representation characteristicPolynomial! !

!AlgebraElement methodsFor: 'accessing' stamp: 'len 7/24/2021 13:03:01'!
corepresentation
	"Answer the module endomorphism defined by right multiplication by the receiver."
	^ self parent asModule endomorphisms evaluating: [:x| (self parent !! x * self) asModuleElement]! !

!AlgebraElement methodsFor: 'accessing' stamp: 'len 7/11/2021 10:37:14'!
minimalPolynomial
	^ self representation minimalPolynomial! !

!AlgebraElement methodsFor: 'accessing' stamp: 'len 7/18/2021 07:38:48'!
norm
	^ self representation determinant
	
"alternatively:
	| f |
	f _ self minimalPolynomial.
	^ f independentCoefficient / f leadingCoefficient * (f degree even ifTrue: [1] ifFalse: [-1])"! !

!AlgebraElement methodsFor: 'accessing' stamp: 'len 6/10/2020 14:00:48'!
parent
	^ parent! !

!AlgebraElement methodsFor: 'accessing' stamp: 'len 7/24/2021 13:02:41'!
representation
	"Answer the module endomorphism defined by left multiplication by the receiver."
	^ representation ifNil: [representation _ self parent asModule endomorphisms evaluating: [:x| (self * (self parent !! x)) asModuleElement]]! !

!AlgebraElement methodsFor: 'accessing' stamp: 'len 7/18/2021 07:37:30'!
trace
	^ self representation trace

"alternatively:
	| f |
	f _ self minimalPolynomial.
	^ (f coefficientAtDegree: f degree - 1) negated"! !

!AlgebraElement methodsFor: 'comparing' stamp: 'len 7/14/2020 09:50:46'!
= anObject
	^ self class = anObject class and: [moduleElement = anObject asModuleElement]! !

!AlgebraElement methodsFor: 'comparing' stamp: 'len 7/14/2020 09:50:50'!
hash
	^ moduleElement hash! !

!AlgebraElement methodsFor: 'converting' stamp: 'len 7/14/2020 09:51:07'!
asModuleElement
	^ moduleElement! !

!AlgebraElement methodsFor: 'converting' stamp: 'len 6/21/2020 14:06:13'!
asScalar
	"If the receiver is the embedding of an element of the scalars ring in the parent algebra, answer the corresponding scalar."
	^ self notYetImplemented! !

!AlgebraElement methodsFor: 'initialization' stamp: 'len 7/14/2020 09:51:39'!
parent: anAlgebra moduleElement: anElement
	parent _ anAlgebra.
	moduleElement _ anElement! !

!AlgebraElement methodsFor: 'operations' stamp: 'len 7/19/2020 08:00:53'!
* anElement
	(anElement isInteger or: [self parent scalars includes: anElement])
		ifTrue: [^ self class parent: parent moduleElement: moduleElement * anElement].
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #*].
	^ self class parent: parent moduleElement: (parent multiplication value: moduleElement value: anElement asModuleElement)! !

!AlgebraElement methodsFor: 'operations' stamp: 'len 7/14/2020 09:53:21'!
+ anElement
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #+].
	^ self class parent: parent moduleElement: moduleElement + anElement asModuleElement! !

!AlgebraElement methodsFor: 'operations' stamp: 'len 1/4/2022 15:28:47'!
/ anElement
	"Answer x such that xa = b, where b is self and a is anElement.
	Answer nil if there's no solution."
	parent isCommutative ifTrue: [^ super / anElement].
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #/].
	^ self parent !! ((self corepresentation preimage: anElement asModuleElement) ifNil: [^ nil])! !

!AlgebraElement methodsFor: 'operations' stamp: 'len 12/3/2021 16:03:04'!
\ anElement
	"Answer x such that ax = b, where a is self and b is anElement.
	Answer nil if there's no solution."
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #\].
	^ self parent !! ((self representation preimage: anElement asModuleElement) ifNil: [^ nil])! !

!AlgebraElement methodsFor: 'operations' stamp: 'len 7/22/2021 10:59:56'!
annihilatorIdeal
	"Answer the ideal of all elements that multiplied by the receiver are zero."
	^ self parent * self representation kernel generators! !

!AlgebraElement methodsFor: 'operations' stamp: 'len 7/14/2020 09:54:04'!
negated
	^ self class parent: parent moduleElement: moduleElement negated! !

!AlgebraElement methodsFor: 'operations' stamp: 'len 12/20/2021 13:01:35'!
opposite
	"Answer the receiver as an element of the opposite ring."
	self parent isCommutative ifTrue: [^ self].
	self parent isInvolutive ifTrue: [^ self conjugate].
	^ self parent opposite fromModuleElement: moduleElement! !

!AlgebraElement methodsFor: 'testing' stamp: 'len 7/8/2021 12:02:57'!
isIntegral
	^ self minimalPolynomial coefficients allSatisfy: [:each| each isIntegral]! !

!AlgebraElement methodsFor: 'testing' stamp: 'len 7/22/2021 18:35:04'!
isNilpotent
	"Answer true if self^n = 0 for some integer n >= 1."
	^ (self ^ self parent rank) isZero

"alternative:
	^ self parent nilradical contains: self
	
or:
	^ self representation isNilpotent"! !

!AlgebraElement methodsFor: 'testing' stamp: 'len 6/21/2020 14:05:18'!
isScalar
	"Answer true if the receiver corresponds to the embedding of an element of the scalars ring in the parent algebra."
	^ self notYetImplemented! !

!AlgebraElement methodsFor: 'testing' stamp: 'len 8/25/2021 18:19:46'!
isUnit
	"Answer true if the receiver is invertible."
"	self parent isDivisionRing ifTrue: [^ self isZero not]."
	^ self representation isIsomorphism

"alternatively:
	^ self norm isUnit"! !

!AlgebraElement methodsFor: 'testing' stamp: 'len 1/6/2022 09:26:11'!
isZerodivisor
	"Answer true if there exists a nonzero element that multiplied by the receiver is zero."
"	self parent isIntegralDomain ifTrue: [^ self isZero]."
	^ self representation determinant isZero and: [self parent isCommutative or: [self corepresentation determinant isZero]]! !

!AlgebraElement class methodsFor: 'instance creation' stamp: 'len 7/14/2020 10:06:42'!
parent: anAlgebra moduleElement: anElement
	^ self new parent: anAlgebra moduleElement: anElement! !

!GroupAlgebraElement methodsFor: 'operations' stamp: 'len 7/19/2020 08:01:35'!
* anElement
	| groupElementToIndex indexToGroupElement result |
	(anElement isInteger or: [self parent scalars includes: anElement])
		ifTrue: [^ self class parent: parent moduleElement: moduleElement * anElement].
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #*].
	indexToGroupElement _ parent propertyAt: #indexToGroupElement.
	groupElementToIndex _ parent propertyAt: #groupElementToIndex.
	result _ parent asModule zero.
	moduleElement withIndexDo: [:a :i|
		a isZero ifFalse:
			[| gi |
			gi _ indexToGroupElement at: i.
			anElement asModuleElement withIndexDo: [:b :j|
				b isZero ifFalse:
					[| gj |
					gj _ indexToGroupElement at: j.
					result at: (groupElementToIndex at: gi * gj) add: a*b]]]].
	^ self class parent: parent moduleElement: result! !

!GroupAlgebraElement methodsFor: 'operations' stamp: 'len 7/21/2021 16:26:33'!
conjugate
	| groupElementToIndex indexToGroupElement result |
	indexToGroupElement _ parent propertyAt: #indexToGroupElement.
	groupElementToIndex _ parent propertyAt: #groupElementToIndex.
	result _ parent asModule zero.
	moduleElement withIndexDo: [:a :i|
		a isZero ifFalse:
			[result at: (groupElementToIndex at: (indexToGroupElement at: i) inverse) put: a]].
	^ self class parent: parent moduleElement: result! !

!Multivector methodsFor: 'accessing' stamp: 'len 7/20/2020 10:21:38'!
grade: anInteger
	"Answer the projection on grade anInteger. This is the homogeneous component of grade anInteger (an anInteger-vector)."
	| zero |
	zero _ parent scalars zero.
	^ self class parent: parent moduleElement: (moduleElement withIndexCollect: [:each :i| (i - 1) bitCount = anInteger ifTrue: [each] ifFalse: [zero]])! !

!Multivector methodsFor: 'converting' stamp: 'len 7/22/2020 11:58:26'!
asPolynomial
	| R answer |
	R _ self parent scalars polynomialsIn: ((1 to: self parent degree) collect: [:i| 'e', i printString sub]).
	answer _ R zero.
	moduleElement withIndexDo: [:each :i| | term |
		term _ R !! each.
		1 to: parent degree do: [:j| (i-1 bitAt: j) = 1 ifTrue: [term _ term * (R x: j)]].
		answer _ answer + term].
	^ answer! !

!Multivector methodsFor: 'converting' stamp: 'len 7/14/2020 10:04:26'!
asScalar
	self isScalar ifFalse: [^ self error: 'not a scalar element'].
	^ moduleElement at: 1! !

!Multivector methodsFor: 'converting' stamp: 'len 7/22/2020 09:39:27'!
asVector
	| B answer |
	self isVector ifFalse: [^ self error: 'not a vector element'].
	B _ parent orthogonalBasis.
	answer _ parent space zero.
	1 to: parent degree do: [:i| answer _ (B at: i) * (moduleElement at: 1 << (i-1) + 1) + answer].
	^ answer! !

!Multivector methodsFor: 'operations' stamp: 'len 7/22/2020 15:56:55'!
* anElement
	"Answer the geometric product of the receiver with the argument.
	This is the main product operation of the Clifford algebra."
	(anElement isInteger or: [self parent scalars includes: anElement])
		ifTrue: [^ self class parent: parent moduleElement: moduleElement * anElement].
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #*].
	^ self product: anElement condition: [:i :j| true]! !

!Multivector methodsFor: 'operations' stamp: 'len 7/19/2020 20:07:31'!
/\ anElement
	"Answer the exterior product (or outer product, or wedge product) of the receiver with the argument.
	This is the product of the exterior algebra contained in the parent of the receiver."
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #/\].
	^ self product: anElement condition: [:i :j| (i bitAnd: j) = 0]! !

!Multivector methodsFor: 'operations' stamp: 'len 7/20/2020 07:13:58'!
< anElement
	"Answer the left inner or interior product of the receiver with the argument."
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #<].
	^ self product: anElement condition: [:i :j| (i bitAnd: j) = i]! !

!Multivector methodsFor: 'operations' stamp: 'len 7/20/2020 06:34:44'!
\/ anElement
	"Answer the regressive product of the receiver with the argument.
	This is the dual of the exterior product."
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #\/].
	^ (self dual /\ anElement dual) * parent pseudoscalar! !

!Multivector methodsFor: 'operations' stamp: 'len 7/22/2020 15:58:27'!
 anElement
	"Answer the dot product of the receiver with the argument."
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #].
	^ self product: anElement condition: [:i :j| i = j] "this can be optimized, lots of unnecesary iterations here"! !

!Multivector methodsFor: 'operations' stamp: 'len 7/20/2020 07:14:15'!
> anElement
	"Answer the right inner or interior product of the receiver with the argument."
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #>].
	^ self product: anElement condition: [:i :j| (i bitAnd: j) = j]! !

!Multivector methodsFor: 'operations' stamp: 'len 7/22/2020 15:59:30'!
conjugate
	"Answer the Clifford conjugate of the receiver."
	^ self reflection transpose! !

!Multivector methodsFor: 'operations' stamp: 'len 7/20/2020 06:34:01'!
dual
	^ self * parent pseudoscalarInverse! !

!Multivector methodsFor: 'operations' stamp: 'len 12/20/2021 13:11:37'!
product: anElement condition: conditionBlock
	| coordinates table |
	coordinates _ parent asModule zero.
	table _ parent propertyAt: #basisMultiplicationTable.
	self asModuleElement withSupportDo: [:x :i|
		anElement asModuleElement withSupportDo: [:y :j|
			| product |
			(conditionBlock value: i-1 value: j-1)
				ifTrue:
					[product _ (table at: i) at: j.
					coordinates at: product first add: x * y * product second]]].
	^ self class parent: parent moduleElement: coordinates! !

!Multivector methodsFor: 'operations' stamp: 'len 7/21/2020 12:47:04'!
reflection
	"Answer the image of the reflection automorphism.
	This is also called grade involution or the (first) main involution, and it is notated with a superscript star."
	^ self class parent: parent moduleElement: (moduleElement withIndexCollect: [:each :i| (i-1) bitParity = 1 ifTrue: [each negated] ifFalse: [each]])! !

!Multivector methodsFor: 'operations' stamp: 'len 7/21/2020 12:47:45'!
transpose
	"Answer the reversion of the receiver.
	This is also called the second main involution or the principal antiautomorphism, and it is notated with a superscript dagger."
	^ self class parent: parent moduleElement: (moduleElement withIndexCollect: [:each :i| ((i-1) bitCount choose: 2) odd ifTrue: [each negated] ifFalse: [each]])! !

!Multivector methodsFor: 'testing' stamp: 'len 7/22/2020 09:27:21'!
isBivector
	moduleElement supportDo: [:i| (i-1) bitCount = 2 ifFalse: [^ false]].
	^ true! !

!Multivector methodsFor: 'testing' stamp: 'len 7/6/2020 07:34:35'!
isEven
	^ self parent evenSubalgebra contains: self! !

!Multivector methodsFor: 'testing' stamp: 'len 7/14/2021 16:53:37'!
isParavector
	"A paravector is the sum of a vector and a scalar."
	^ (self parent degree + 2 to: self parent rank) allSatisfy: [:i| (moduleElement at: i) isZero]! !

!Multivector methodsFor: 'testing' stamp: 'len 7/14/2021 16:53:43'!
isPseudoscalar
	moduleElement supportDo: [:i| i = parent rank ifFalse: [^ false]].
	^ true! !

!Multivector methodsFor: 'testing' stamp: 'len 7/22/2020 09:40:55'!
isPseudovector
	| k |
	k _ parent degree - 1.
	moduleElement supportDo: [:i| (i-1) bitCount = k ifFalse: [^ false]].
	^ true! !

!Multivector methodsFor: 'testing' stamp: 'len 7/22/2020 09:41:18'!
isScalar
	moduleElement supportDo: [:i| i = 1 ifFalse: [^ false]].
	^ true! !

!Multivector methodsFor: 'testing' stamp: 'len 7/22/2020 09:26:56'!
isVector
	moduleElement supportDo: [:i| (i-1) bitCount = 1 ifFalse: [^ false]].
	^ true! !

!Quaternion methodsFor: 'accessing' stamp: 'len 4/30/2021 12:42:19'!
imaginary
	"Answer the imaginary part of the receiver."
	^ self - self real! !

!Quaternion methodsFor: 'accessing' stamp: 'len 4/30/2021 12:43:14'!
real
	"Answer the real part of the receiver."
	^ self parent one * (moduleElement at: 1)! !

!Quaternion methodsFor: 'converting' stamp: 'len 7/14/2020 10:03:39'!
asScalar
	self isScalar ifFalse: [^ self error: 'not a scalar element'].
	^ moduleElement at: 1! !

!Quaternion methodsFor: 'operations' stamp: 'len 7/14/2020 10:03:33'!
conjugate
	"Answer the conjugate of the receiver, such that the reduced trace is the conjugate added to the receiver, and the reduced norm is the conjugate times the receiver."
	^ self class parent: parent moduleElement: (moduleElement withIndexCollect: [:each :i| i=1 ifTrue: [each] ifFalse: [each negated]])

"alternatively:
	^ self negated + self trace
"! !

!Quaternion methodsFor: 'operations' stamp: 'len 7/16/2020 19:02:30'!
inverse
	^ self conjugate * self norm inverse! !

!Quaternion methodsFor: 'operations' stamp: 'len 7/14/2020 10:05:46'!
norm
	"Answer the reduced norm of the receiver."
	^ (self * self conjugate) asModuleElement at: 1! !

!Quaternion methodsFor: 'operations' stamp: 'len 7/14/2020 10:05:53'!
trace
	"Answer the reduced trace of the receiver."
	^ (self + self conjugate) asModuleElement at: 1! !

!Quaternion methodsFor: 'testing' stamp: 'len 6/11/2020 19:45:58'!
isIsotropic
	^ self isZero not and: [self norm isZero]! !

!Quaternion methodsFor: 'testing' stamp: 'len 7/14/2020 10:03:44'!
isPure
	^ (moduleElement at: 1) isZero! !

!Quaternion methodsFor: 'testing' stamp: 'len 7/14/2020 10:03:49'!
isScalar
	^ (2 to: 4) allSatisfy: [:i| (moduleElement at: i) isZero]! !

!Quaternion methodsFor: 'testing' stamp: 'len 6/11/2020 19:43:26'!
isUnit
	"Answer true if the receiver is invertible."
	^ self norm isZero not! !

!AlgebraicInteger methodsFor: 'testing' stamp: 'len 7/11/2021 11:19:13'!
isIntegral
	^ true! !

!AlgebraicInteger methodsFor: 'testing' stamp: 'len 1/6/2022 09:26:21'!
isZerodivisor
	"Answer true if there exists a nonzero element that multiplied by the receiver is zero."
	^ self isZero! !

!QuadraticInteger methodsFor: 'testing' stamp: 'len 8/5/2021 08:42:38'!
isPrime
	"The norm of a (quadratic) prime is a (rational) integer prime or a prime squared.
	If the norm is a prime, the number is prime."
	| norm factors |
	(norm _ self norm) isPrime ifTrue: [^ true].
	factors _ norm factorization.
	(factors size <= 2 and: [factors asSet size = 1]) ifFalse: [^ false].
	self notYetImplemented! !

!QuadraticInteger methodsFor: 'testing' stamp: 'len 7/11/2021 18:30:31'!
isUnit
	^ self norm abs = 1
"there's also equations, a + bw is a unit if:
	a^2 - Db^2 = 1 for D = 2,3 mod 4
	(a + b/2)^2 - (1/4)Db^2 = 1 for D = 1 mod 4"! !

!GaussianInteger methodsFor: 'accessing' stamp: 'len 3/24/2021 07:45:20'!
imaginary
	^ moduleElement at: 2! !

!GaussianInteger methodsFor: 'accessing' stamp: 'len 3/24/2021 07:45:16'!
real
	^ moduleElement at: 1! !

!GaussianInteger methodsFor: 'operations' stamp: 'len 1/6/2022 19:38:49'!
// anElement
	"Answer the quotient of the Euclidean division of the receiver by the argument."
	| a b c d n |
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #//].
	anElement isZero ifTrue: [^ InversionError signal: anElement].
	a _ self real.
	b _ self imaginary.
	c _ anElement real.
	d _ anElement imaginary.
	n _ c squared + d squared.
	^ parent real: (a*c + (b*d) / n) rounded imaginary: (b*c - (a*d) / n) rounded! !

!GaussianInteger methodsFor: 'operations' stamp: 'len 1/4/2022 15:10:04'!
conjugate
	^ parent real: self real imaginary: self imaginary negated

"alternatively:
	^ self negated + self trace
"! !

!GaussianInteger methodsFor: 'operations' stamp: 'len 1/4/2022 12:23:48'!
gauge
	"Answer the value of the Euclidean function at the receiver."
	^ self norm! !

!GaussianInteger methodsFor: 'operations' stamp: 'len 3/24/2021 07:47:09'!
inverse
	^ self conjugate * self norm inverse! !

!GaussianInteger methodsFor: 'operations' stamp: 'len 1/4/2022 14:44:39'!
norm
	"Answer the reduced norm of the receiver."
	^ self real squared + self imaginary squared

"	^ (self * self conjugate) asModuleElement at: 1"! !

!GaussianInteger methodsFor: 'operations' stamp: 'len 1/4/2022 18:50:18'!
normalization
	"Answer a unit u such that 'self * u' is a unique choice of associate. See >>normalized."
	"Choose an associate in the first quadrant of the complex plane."
	| a b |
	self isZero ifTrue: [^ parent one].
	a _ self real.
	b _ self imaginary.
	a > 0 ifTrue: [
		b >= 0 ifTrue: [^ parent one].
		^ parent i].
	a < 0 ifTrue: [
		b <= 0 ifTrue: [^ parent one negated].
		^ parent i negated].
	^ b < 0 ifTrue: [parent i] ifFalse: [parent i negated]! !

!GaussianInteger methodsFor: 'operations' stamp: 'len 3/24/2021 07:47:27'!
trace
	"Answer the reduced trace of the receiver."
	^ (self + self conjugate) asModuleElement at: 1! !

!GaussianInteger methodsFor: 'testing' stamp: 'len 3/24/2021 07:43:10'!
isIrreducible
	"A Gaussian integer is irriducible if and only if it is prime."
	^ self isPrime! !

!GaussianInteger methodsFor: 'testing' stamp: 'len 1/5/2022 09:58:00'!
isPrime
	"A Gaussian integer a+bi is prime if either:
	- one of a, b is zero and absolute value of the other is prime congruent to 3 mod 4;
	- both are nonzero and a^2 + b%2 is prime."
	| a b |
	a _ self real.
	b _ self imaginary.
	a = 0 ifTrue: [^ b \\ 4 = 3 and: [b abs isPrime]].
	b = 0 ifTrue: [^ a \\ 4 = 3 and: [a abs isPrime]].
	^ (a squared + (b \\ 2)) isPrime! !

!GaussianInteger methodsFor: 'testing' stamp: 'len 1/5/2022 09:57:39'!
isUnit
	"All the units are: 1, -1, i, -i."
	^ (self real abs = 1 and: [self imaginary = 0]) or: [self real = 0 and: [self imaginary abs = 1]]! !

!AdicInteger methodsFor: 'operations' stamp: 'len 4/15/2020 08:00:19'!
* anElement
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #*].
	self isZero ifTrue: [^ self]. "should take into account precision?"
	anElement isZero ifTrue: [^ anElement].
	^ parent project: representative * anElement representative precision: (precision + anElement valuation min: anElement precision + self valuation)! !

!AdicInteger methodsFor: 'operations' stamp: 'len 9/7/2019 10:16:39'!
+ anElement
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #+].
	^ parent project: representative + anElement representative precision: (precision min: anElement precision)! !

!AdicInteger methodsFor: 'operations' stamp: 'len 1/6/2022 19:34:55'!
// anElement
	"Answer the quotient of the Euclidean division of the receiver by the argument."
	| v |
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #//].
	anElement isZero ifTrue: [^ InversionError signal: anElement].
	self isZero ifTrue: [^ self].
	(v _ self valuation - anElement valuation) < 0 ifTrue: [^ self zero].
	^ self normalization inverse * anElement normalization * (parent power: v)! !

!AdicInteger methodsFor: 'operations' stamp: 'len 8/11/2019 11:22:59'!
<< anInteger
	^ self >> anInteger negated! !

!AdicInteger methodsFor: 'operations' stamp: 'len 8/11/2019 09:37:20'!
O: anInteger
	"Answer a new p-adic element with precision decreased to anInteger."
	precision <= anInteger ifTrue: [^ self].
	anInteger > 0 ifFalse: [self error: 'precision must be positive'].
	^ parent project: representative precision: anInteger! !

!AdicInteger methodsFor: 'operations' stamp: 'len 8/5/2021 08:35:02'!
factorization
	"The ring of p-adic integers is a DVR, and this means it is an UFD with unique irreducible element up to multiplication by units."
	^ Bag new add: parent uniformizer withOccurrences: self valuation; yourself! !

!AdicInteger methodsFor: 'operations' stamp: 'len 9/7/2019 10:16:59'!
gcd: anElement
	| v N |
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #gcd:].
	self isZero ifTrue: [^ anElement normalized].
	anElement isZero ifTrue: [^ self normalized].
	v _ self valuation min: anElement valuation.
	N _ precision min: anElement precision.
	v >= N ifTrue: [parent zero O: N].
	^ parent representative: (parent power: v) precision: N! !

!AdicInteger methodsFor: 'operations' stamp: 'len 8/12/2019 10:51:29'!
inverse
	representative = 1 ifTrue: [^ self].
	representative = 0 ifTrue: [^ DomainError signal: 'not invertible'].
	^ parent representative: ((representative reciprocalModulo: (parent power: precision)) ifNil: [^ DomainError signal: 'not invertible']) precision: precision! !

!AdicInteger methodsFor: 'operations' stamp: 'len 8/11/2019 08:47:35'!
negated
	^ parent project: representative negated precision: precision! !

!AdicInteger methodsFor: 'operations' stamp: 'len 12/10/2021 19:16:02'!
normalization
	"Answer a unit u such that 'self * u' is a unique choice of associate. See >>normalized."
	^ self normalizationInverse inverse! !

!AdicInteger methodsFor: 'operations' stamp: 'len 12/10/2021 19:14:02'!
normalizationInverse
	"Answer a unit u such that 'self * u inverse' is a unique choice of associate."
	| p q v |
	self isZero ifTrue: [^ parent one].
	p _ parent p.
	q _ representative.
	v _ 0.
	[p | q] whileTrue: [q _ q // p. v _ v + 1].
	^ parent representative: q precision: precision - v! !

!AdicInteger methodsFor: 'printing' stamp: 'len 5/23/2020 07:27:30'!
printExpansionOn: aStream shifted: v
	| coefficients first |
	self isZero ifTrue: [aStream nextPut: $0. ^ self].
	precision isFinite ifFalse:
		[aStream print: representative.
		v ~= 0 ifTrue: [aStream nextPut: $; print: parent p. v ~= 1 ifTrue: [aStream nextPutAll: v printString super]].
		^ self].
	first _ true.
	coefficients _ self coefficients.
	v to: v + precision + 1 do: [:i|
		| x |
		(x _ coefficients at: i-v+1) isZero
			ifFalse:
				[first ifFalse: [aStream nextPutAll: ' + '].
				(x ~= 1 or: [i = 0]) ifTrue: [aStream print: x. i ~= 0 ifTrue: [aStream nextPut: $]].
				i ~= 0 ifTrue: [aStream print: parent p. i ~= 1 ifTrue: [aStream nextPutAll: i printString super]].
				first _ false]].
	aStream nextPutAll: ' + ', 'O' italic; nextPut: $(; print: parent p; nextPutAll: (precision + v) printString super; nextPut: $)! !

!AdicInteger methodsFor: 'printing' stamp: 'len 7/30/2021 10:43:01'!
printOn: aStream shifted: valuationShift
	| v u |
	self isZero ifTrue: [aStream nextPut: $0. ^ self].
	v _ self valuation - valuationShift.
	u _ self normalizationInverse centeredRepresentative.
	v = 0
		ifTrue: [aStream print: u]
		ifFalse:
			[u abs ~= 1
				ifTrue: [aStream print: u; nextPut: $]
				ifFalse: [u = -1 ifTrue: [aStream nextPut: $-]].
			aStream print: parent p.
			v ~= 1 ifTrue: [aStream nextPutAll: v printString super]].
	aStream nextPutAll: ' + ', 'O' italic; nextPut: $(; print: parent p; nextPutAll: (precision + valuationShift) printString super; nextPut: $)! !

!AdicInteger methodsFor: 'accessing' stamp: 'len 8/11/2019 10:30:30'!
absolutePrecision
	^ precision! !

!AdicInteger methodsFor: 'accessing' stamp: 'len 8/12/2019 11:25:18'!
centeredRepresentative
	| m |
	m _ parent power: precision.
	^ representative <= (m >> 1) ifTrue: [representative] ifFalse: [representative - m]! !

!AdicInteger methodsFor: 'accessing' stamp: 'len 8/11/2019 02:23:45'!
coefficients
	| p q |
	p _ parent p.
	q _ representative.
	^ Sequence streaming: [| r | r _ q \\ p. q _ q // p. r]! !

!AdicInteger methodsFor: 'accessing' stamp: 'len 8/7/2019 10:13:08'!
parent
	^ parent! !

!AdicInteger methodsFor: 'accessing' stamp: 'len 8/11/2019 02:22:45'!
precision
	^ precision! !

!AdicInteger methodsFor: 'accessing' stamp: 'len 8/11/2019 10:30:22'!
relativePrecision
	representative isZero ifTrue: [^ 0].
	^ self absolutePrecision - self valuation! !

!AdicInteger methodsFor: 'accessing' stamp: 'len 8/11/2019 02:33:28'!
representative
	^ representative! !

!AdicInteger methodsFor: 'accessing' stamp: 'len 8/11/2019 02:23:15'!
valuation
	^ representative valuation: parent p! !

!AdicInteger methodsFor: 'comparing' stamp: 'len 4/28/2021 13:49:34'!
= anObject
	^ self class = anObject class and: [representative = anObject representative and: [precision = anObject precision]]! !

!AdicInteger methodsFor: 'comparing' stamp: 'len 8/11/2019 02:24:16'!
hash
	^ representative hash! !

!AdicInteger methodsFor: 'comparing' stamp: 'len 5/9/2020 09:02:53'!
isWeaklyEqualTo: anElement
	"Answer true if the receiver is 'weakly equal' to the argument.
	Note that this relation is not transitive."
	anElement precision > precision ifTrue: [^ anElement isWeaklyEqualTo: self].
	precision = anElement precision ifTrue: [^ representative = anElement representative].
	^ representative = (anElement representative \\ precision)! !

!AdicInteger methodsFor: 'testing' stamp: 'len 8/11/2019 11:42:47'!
abs
	"Answer the p-adic absolute value (or norm) of the receiver."
	^ self isZero ifTrue: [0] ifFalse: [parent p ^ self valuation negated]! !

!AdicInteger methodsFor: 'testing' stamp: 'len 5/4/2020 09:30:54'!
isPrime
	^ self isZero or: [self valuation = 1] "optimize"! !

!AdicInteger methodsFor: 'testing' stamp: 'len 1/9/2022 08:29:40'!
isSquarefree
	self valuation >= 2 ifTrue: [^ false].
"	self isWeaklyZero ifTrue: [^ self error: 'not enough precision']."
	^ true! !

!AdicInteger methodsFor: 'testing' stamp: 'len 5/4/2020 09:42:55'!
isUnit
	"Answer true if the receiver is invertible."
	^ (parent p | representative) not! !

!AdicInteger methodsFor: 'testing' stamp: 'len 8/11/2019 02:17:45'!
isZero
	^ representative isZero! !

!AdicInteger methodsFor: 'private' stamp: 'len 8/11/2019 04:13:14'!
parent: anAdicRing representative: anInteger precision: N
	parent _ anAdicRing.
	representative _ anInteger.
	precision _ N! !

!AdicNumber methodsFor: 'accessing' stamp: 'len 8/11/2019 11:11:11'!
abs
	"Answer the p-adic absolute value (or norm) of the receiver."
	^ self isWeaklyZero ifTrue: [0] ifFalse: [self p ^ valuation negated]! !

!AdicNumber methodsFor: 'accessing' stamp: 'len 5/8/2020 17:50:48'!
absolutePrecision
	^ unitPart absolutePrecision! !

!AdicNumber methodsFor: 'accessing' stamp: 'len 5/8/2020 17:51:10'!
denominator
	^ valuation < 0 ifTrue: [unitPart one << valuation] ifFalse: [unitPart one]! !

!AdicNumber methodsFor: 'accessing' stamp: 'len 5/8/2020 17:52:01'!
numerator
	^ valuation <= 0 ifTrue: [unitPart] ifFalse: [unitPart >> valuation]! !

!AdicNumber methodsFor: 'accessing' stamp: 'len 5/8/2020 17:52:23'!
parent
	^ unitPart parent fractions! !

!AdicNumber methodsFor: 'accessing' stamp: 'len 5/8/2020 17:52:17'!
relativePrecision
	unitPart isZero ifTrue: [^ 0].
	^ self absolutePrecision - valuation! !

!AdicNumber methodsFor: 'accessing' stamp: 'len 5/8/2020 17:54:03'!
unitPart
	^ unitPart! !

!AdicNumber methodsFor: 'accessing' stamp: 'len 8/7/2019 10:02:12'!
valuation
	^ valuation! !

!AdicNumber methodsFor: 'comparing' stamp: 'len 5/8/2020 17:51:51'!
= anObject
	^ anObject class = self class and: [valuation = anObject valuation and: [unitPart = anObject unitPart]]! !

!AdicNumber methodsFor: 'comparing' stamp: 'len 5/8/2020 17:53:42'!
hash
	^ unitPart hash + valuation hash! !

!AdicNumber methodsFor: 'operations' stamp: 'len 5/8/2020 17:52:35'!
* anElement
	anElement isInteger ifTrue: [^ (self class new valuation: valuation unit: unitPart * anElement) canonicalize].
	self isWeaklyZero ifTrue: [^ self].
	"(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #*]."
	anElement isWeaklyZero ifTrue: [^ anElement].
	^ self class new valuation: valuation + anElement valuation unit: unitPart * anElement unitPart! !

!AdicNumber methodsFor: 'operations' stamp: 'len 7/21/2020 17:25:26'!
+ anElement
	| answer v |
	"(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #+]."
	self isWeaklyZero ifTrue: [^ anElement].
	anElement isWeaklyZero ifTrue: [^ self].
	v _ valuation - anElement valuation.
	v = 0
		ifTrue:
			[answer _ self class new
				valuation: valuation
				unit: unitPart + anElement unitPart.
			answer canonicalize.
			answer isWeaklyZero ifTrue: [^ answer]]
		ifFalse:
			[| u |
			u _ v > 0
				ifTrue: [unitPart + (anElement unitPart >> v)]
				ifFalse: [unitPart >> v + anElement unitPart].
			answer _ self class new
				valuation: (valuation min: anElement valuation)
				unit: u].
	^ answer! !

!AdicNumber methodsFor: 'operations' stamp: 'len 1/6/2022 19:34:34'!
/ anElement
"	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #/]."
	anElement isWeaklyZero ifTrue: [^ InversionError signal: anElement].
	self isWeaklyZero ifTrue: [^ self].
	^ self class new
		valuation: valuation - anElement valuation
		unit: unitPart * anElement unitPart inverse! !

!AdicNumber methodsFor: 'operations' stamp: 'len 6/7/2019 11:37:35'!
exp
	^ self notYetImplemented! !

!AdicNumber methodsFor: 'operations' stamp: 'len 1/6/2022 19:34:07'!
inverse
	self isWeaklyZero ifTrue: [^ InversionError signal: self].
	self relativePrecision <= 0 ifTrue: [^ self zero].
	^ self class new
		valuation: valuation negated
		unit: unitPart inverse! !

!AdicNumber methodsFor: 'operations' stamp: 'len 6/7/2019 11:37:32'!
log
	^ self notYetImplemented! !

!AdicNumber methodsFor: 'operations' stamp: 'len 5/8/2020 17:50:43'!
negated
	^ self class new
		valuation: valuation
		unit: unitPart negated! !

!AdicNumber methodsFor: 'operations' stamp: 'len 6/7/2019 15:29:53'!
sqrt
	^ self notYetImplemented! !

!AdicNumber methodsFor: 'testing' stamp: 'len 6/7/2019 11:25:07'!
isIntegral
	^ self valuation >= 0! !

!AdicNumber methodsFor: 'testing' stamp: 'len 5/8/2020 17:50:57'!
isWeaklyZero
	^ unitPart isZero! !

!AdicNumber methodsFor: 'testing' stamp: 'len 6/7/2019 13:29:05'!
isZero
	self isWeaklyZero ifFalse: [^ false].
	^ self shouldNotImplement! !

!AdicNumber methodsFor: 'private' stamp: 'len 5/8/2020 17:53:34'!
canonicalize
	unitPart = 0
		ifTrue:
			[valuation _ Infinity positive]
		ifFalse:
			[valuation _ unitPart valuation.
			unitPart _ unitPart << valuation]! !

!AdicNumber methodsFor: 'private' stamp: 'len 5/8/2020 17:51:02'!
valuation: v unit: u
	valuation _ v.
	unitPart _ u! !

!LaurentSeries methodsFor: 'accessing' stamp: 'len 5/8/2020 17:48:59'!
absolutePrecision
	^ unitPart absolutePrecision! !

!LaurentSeries methodsFor: 'accessing' stamp: 'len 5/8/2020 17:47:34'!
denominator
	^ valuation < 0 ifTrue: [unitPart one << valuation] ifFalse: [unitPart one]! !

!LaurentSeries methodsFor: 'accessing' stamp: 'len 5/8/2020 17:47:47'!
numerator
	^ valuation <= 0 ifTrue: [unitPart] ifFalse: [unitPart >> valuation]! !

!LaurentSeries methodsFor: 'accessing' stamp: 'len 4/28/2021 13:52:48'!
parent
	^ unitPart parent fractions! !

!LaurentSeries methodsFor: 'accessing' stamp: 'len 5/8/2020 17:49:07'!
relativePrecision
	unitPart isZero ifTrue: [^ 0].
	^ self absolutePrecision - valuation! !

!LaurentSeries methodsFor: 'accessing' stamp: 'len 5/8/2020 17:48:53'!
unitPart
	^ unitPart! !

!LaurentSeries methodsFor: 'accessing' stamp: 'len 6/3/2019 02:33:25'!
valuation
	^ valuation! !

!LaurentSeries methodsFor: 'comparing' stamp: 'len 5/8/2020 17:48:09'!
= anObject
	^ anObject class = self class and: [valuation = anObject valuation and: [unitPart = anObject unitPart]]! !

!LaurentSeries methodsFor: 'comparing' stamp: 'len 5/8/2020 17:47:53'!
hash
	^ unitPart hash + valuation hash! !

!LaurentSeries methodsFor: 'operations' stamp: 'len 6/7/2020 15:15:46'!
over: aRing
	^ self class on: (self integers over: aRing)! !

!LaurentSeries methodsFor: 'testing' stamp: 'len 8/11/2019 11:35:18'!
isIntegral
	^ self valuation >= 0! !

!LaurentSeries methodsFor: 'private' stamp: 'len 5/8/2020 17:48:40'!
valuation: anInteger unit: aPowerSeries
	valuation _ anInteger.
	unitPart _ aPowerSeries! !

!LaurentSeries class methodsFor: 'instance creation' stamp: 'len 6/3/2019 18:40:45'!
valuation: anInteger unit: anAdicInteger
	^ self new valuation: anInteger unit: anAdicInteger! !

!PowerSeries methodsFor: 'accessing' stamp: 'len 8/11/2019 10:30:27'!
absolutePrecision
	^ precision! !

!PowerSeries methodsFor: 'accessing' stamp: 'len 8/11/2019 12:18:04'!
coefficients
	^ representative coefficients! !

!PowerSeries methodsFor: 'accessing' stamp: 'len 8/12/2019 16:28:06'!
independentCoefficient
	^ representative independentCoefficient! !

!PowerSeries methodsFor: 'accessing' stamp: 'len 6/7/2020 14:29:59'!
leadingCoefficient
	^ representative initialCoefficient! !

!PowerSeries methodsFor: 'accessing' stamp: 'len 6/7/2020 14:30:20'!
leadingMonomial
	^ representative initialMonomial! !

!PowerSeries methodsFor: 'accessing' stamp: 'len 6/7/2020 14:30:30'!
leadingTerm
	^ representative initialTerm! !

!PowerSeries methodsFor: 'accessing' stamp: 'len 8/9/2019 09:44:38'!
parent
	^ parent! !

!PowerSeries methodsFor: 'accessing' stamp: 'len 8/9/2019 09:45:35'!
precision
	^ precision! !

!PowerSeries methodsFor: 'accessing' stamp: 'len 8/9/2019 10:36:13'!
relativePrecision
	representative isZero ifTrue: [^ 0].
	^ self absolutePrecision - self valuation! !

!PowerSeries methodsFor: 'accessing' stamp: 'len 8/9/2019 09:45:12'!
representative
	^ representative! !

!PowerSeries methodsFor: 'accessing' stamp: 'len 4/14/2020 18:54:45'!
valuation
	^ representative order! !

!PowerSeries methodsFor: 'comparing' stamp: 'len 4/28/2021 13:49:52'!
= anObject
	^ self class = anObject class and: [representative = anObject representative and: [precision = anObject precision]]! !

!PowerSeries methodsFor: 'comparing' stamp: 'len 8/10/2019 05:59:52'!
hash
	^ representative hash! !

!PowerSeries methodsFor: 'comparing' stamp: 'len 5/9/2020 09:03:44'!
isWeaklyEqualTo: aPowerSeries
	"Answer true if the receiver is 'weakly equal' to the argument.
	Note that this relation is not transitive."
	aPowerSeries precision > precision ifTrue: [^ aPowerSeries isWeaklyEqualTo: self].
	precision = aPowerSeries precision ifTrue: [^ representative = aPowerSeries representative].
	^ representative = (aPowerSeries representative truncatedTo: precision)! !

!PowerSeries methodsFor: 'operations' stamp: 'len 6/7/2020 14:52:16'!
* anElement
	| N |
	anElement isInteger ifTrue: [^ parent representative: representative * anElement precision: precision].
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #*].
	self isZero ifTrue: [^ self].
	anElement isZero ifTrue: [^ anElement].
	N _ precision + anElement valuation min: anElement precision + self valuation.
	^ parent representative: (representative multipliedBy: anElement representative truncatedTo: N) precision: N! !

!PowerSeries methodsFor: 'operations' stamp: 'len 8/10/2019 06:04:29'!
+ anElement
	| N |
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #+].
	N _ precision min: anElement precision.
	^ parent representative: (representative truncatedTo: N) + (anElement representative truncatedTo: N) precision: N! !

!PowerSeries methodsFor: 'operations' stamp: 'len 8/11/2019 09:37:47'!
O: anInteger
	"Answer a new power series with precision decreased to anInteger."
	precision <= anInteger ifTrue: [^ self].
	anInteger > 0 ifFalse: [self error: 'precision must be positive'].
	^ parent representative: (representative truncatedTo: anInteger) precision: anInteger! !

!PowerSeries methodsFor: 'operations' stamp: 'len 8/12/2019 16:57:35'!
derivative
	^ parent representative: representative derivative precision: precision - 1! !

!PowerSeries methodsFor: 'operations' stamp: 'len 8/12/2019 16:59:13'!
derivativeIn: anIndeterminate
	^ parent representative: (representative derivativeIn: anIndeterminate) precision: precision - 1! !

!PowerSeries methodsFor: 'operations' stamp: 'len 8/5/2021 08:36:11'!
factorization
	"If the parent of the receiver is a DVR, this means it is an UFD with unique irreducible element up to multiplication by units."
	^ Bag new add: parent uniformizer withOccurrences: self valuation; yourself! !

!PowerSeries methodsFor: 'operations' stamp: 'len 5/4/2020 10:06:02'!
inverse
	"Naive but general power series inversion algorithm."
	| answer g g1 u |
	u _ self independentCoefficient inverse.
	g _ self one.
	g1 _ g - (self * u).
	answer _ self one.
	1 to: self precision do: [:i|
		answer _ answer + (g _ g * g1)].
	^ answer * u! !

!PowerSeries methodsFor: 'operations' stamp: 'len 8/10/2019 05:57:46'!
negated
	^ parent representative: representative negated precision: precision! !

!PowerSeries methodsFor: 'operations' stamp: 'len 12/10/2021 19:19:21'!
normalization
	"Answer a unit u such that 'self * u' is a unique choice of associate. See >>normalized."
	^ self normalizationInverse inverse! !

!PowerSeries methodsFor: 'operations' stamp: 'len 12/10/2021 19:14:41'!
normalizationInverse
	"Answer a unit u such that 'self * u inverse' is a unique choice of associate."
	self isUnit ifTrue: [^ self].
	self isZero ifTrue: [^ self parent one].
	self parent isUnivariate
		ifTrue:
			[| v |
			v _ representative order.
			^ self parent representative: representative >> v precision: precision - v].
	^ self notYetImplemented! !

!PowerSeries methodsFor: 'operations' stamp: 'len 8/9/2019 12:41:12'!
value: anObject
	^ representative value: anObject! !

!PowerSeries methodsFor: 'testing' stamp: 'len 5/4/2020 09:38:15'!
isUnit
	"Answer true if the receiver is invertible."
	self parent scalars isField ifTrue: [^ self independentCoefficient isUnit].
	^ super isUnit! !

!PowerSeries methodsFor: 'testing' stamp: 'len 6/7/2020 14:49:57'!
isZero
	^ representative isZero! !

!PowerSeries methodsFor: 'private' stamp: 'len 8/9/2019 09:44:51'!
parent: aPowerSeriesRing
	parent _ aPowerSeriesRing! !

!PowerSeries methodsFor: 'private' stamp: 'len 8/9/2019 09:45:24'!
precision: anInteger
	precision _ anInteger! !

!PowerSeries methodsFor: 'private' stamp: 'len 8/9/2019 09:45:01'!
representative: aPolynomial
	representative _ aPolynomial! !

!PuiseuxSeries methodsFor: 'as yet unclassified' stamp: 'len 7/10/2021 18:18:16'!
denominator
	^ denominator! !

!PuiseuxSeries methodsFor: 'as yet unclassified' stamp: 'len 7/10/2021 18:17:09'!
valuation
	^ self notYetImplemented! !

!RelaxedAdicInteger methodsFor: 'accessing' stamp: 'len 6/3/2019 17:26:18'!
<< anInteger
	^ self >> anInteger negated! !

!RelaxedAdicInteger methodsFor: 'accessing' stamp: 'len 6/5/2019 13:18:16'!
abs
	"Answer the p-adic absolute value (or norm) of the receiver."
	^ self isZero ifTrue: [0] ifFalse: [self p ^ self valuation negated]! !

!RelaxedAdicInteger methodsFor: 'accessing' stamp: 'len 6/2/2019 10:18:59'!
absolutePrecision
	^ parent precision! !

!RelaxedAdicInteger methodsFor: 'accessing' stamp: 'len 6/2/2019 16:35:37'!
at: anInteger
	anInteger < 0 ifTrue: [^ 0].
	^ digits at: anInteger + 1! !

!RelaxedAdicInteger methodsFor: 'accessing' stamp: 'len 6/1/2019 17:30:48'!
digits
	^ digits! !

!RelaxedAdicInteger methodsFor: 'accessing' stamp: 'len 6/1/2019 17:24:34'!
p
	^ parent p! !

!RelaxedAdicInteger methodsFor: 'accessing' stamp: 'len 12/17/2016 20:59:36'!
parent
	^ parent! !

!RelaxedAdicInteger methodsFor: 'accessing' stamp: 'len 6/2/2019 13:54:50'!
relativePrecision
	^ self absolutePrecision! !

!RelaxedAdicInteger methodsFor: 'accessing' stamp: 'len 12/29/2021 11:55:57'!
size
	^ Cardinal new: 1! !

!RelaxedAdicInteger methodsFor: 'accessing' stamp: 'len 6/2/2019 11:30:57'!
valuation
	self isZero ifTrue: [^ Infinity positive].
	^ (digits findFirst: [:x| x isZero not]) - 1
"	i _ 0.
	precision _ parent precision.
	[(digits at: (i _ i + 1)) isZero not ifTrue: [^ i].
	precision > i ifFalse: [^ i]] repeat"! !

!RelaxedAdicInteger methodsFor: 'printing' stamp: 'len 5/23/2020 07:42:09'!
printOn: aStream withPowersShiftedBy: k
	| printPrecision first |
	self isZero
		ifTrue: [aStream nextPut: $0]
		ifFalse:
			[printPrecision _ 10.
			first _ true.
			self valuation - k to: self valuation + printPrecision - 1 - k do: [:i|
				| x |
				(x _ self digits at: i+1+k) isZero
					ifFalse:
						[first ifFalse: [aStream nextPutAll: ' + '].
						(x ~= 1 or: [i = 0]) ifTrue: [aStream print: x. i ~= 0 ifTrue: [aStream nextPut: $]].
						i ~= 0 ifTrue: [aStream print: self p. i ~= 1 ifTrue: [aStream nextPutAll: i printString super]].
						first _ false]]].
	aStream nextPutAll: ' + ...'
	"parent isBounded
		ifTrue: [aStream nextPutAll: ' + ', 'O' italic; nextPut: $(; print: self p; nextPutAll: parent precision printString super; nextPut: $)]
		ifFalse: [aStream nextPutAll: ' + ...']"! !

!RelaxedAdicInteger methodsFor: 'arithmetic' stamp: 'len 6/2/2019 11:02:42'!
* anAdic
	| a b n carry  p |
	anAdic class = self class ifFalse: [^ self * (parent !! anAdic)].
	a _ digits.
	b _ anAdic digits.
	p _ self p.
	n _ 1.
	carry _ 0.
	^ parent streaming:
		[| t |
		t _ ((1 to: n) sum: [:i| (a at: i) * (b at: n-i+1)]) + carry.
		n _ n + 1.
		carry _ t // p.
		t \\ p]! !

!RelaxedAdicInteger methodsFor: 'arithmetic' stamp: 'len 6/1/2019 17:30:18'!
+ anAdic
	| a b n carry  p |
	a _ digits.
	b _ anAdic digits.
	p _ self p.
	n _ 1.
	carry _ 0.
	^ parent streaming:
		[| t |
		t _ (a at: n) + (b at: n) + carry.
		n _ n + 1.
		t < p ifTrue: [carry _ 0. t] ifFalse: [carry _ 1. t - p]]! !

!RelaxedAdicInteger methodsFor: 'arithmetic' stamp: 'len 6/1/2019 17:30:22'!
- anAdic
	| a b n carry  p |
	a _ digits.
	b _ anAdic digits.
	p _ self p.
	n _ 1.
	carry _ 0.
	^ parent streaming:
		[| t |
		t _ (a at: n) - (b at: n) - carry.
		n _ n + 1.
		t >= 0 ifTrue: [carry _ 0. t] ifFalse: [carry _ 1. t + p]]! !

!RelaxedAdicInteger methodsFor: 'arithmetic' stamp: 'len 6/2/2019 11:39:02'!
negated
	| n p |
	p _ self p.
	n _ 0.
	^ parent streaming: [n = 0 ifTrue: [p - (digits at: (n _ n + 1))] ifFalse: [p - 1 - (digits at: (n _ n + 1))]]! !

!RelaxedAdicInteger methodsFor: 'arithmetic' stamp: 'len 6/6/2019 03:43:40'!
reciprocal
	| p a b1 carry |
	p _ self p.
	a _ digits.
	b1 _ (a at: 1) reciprocalModulo: p.
	carry _ 0.
	^ parent digits:
		(Sequence
			initialValues: {b1}
			recurrence:
				[:b :n| | q |
				q _ b1 negated * (((2 to: n) sum: [:i| (a at: i) * (b at: n-i+1)]) + carry).
				carry _ q // p.
				q \\ p])! !

!RelaxedAdicInteger methodsFor: 'comparing' stamp: 'len 8/7/2019 06:47:58'!
= anAdic
	((anAdic isKindOf: RelaxedAdicInteger) and: [parent = anAdic parent]) ifFalse: [^ false].
	parent isBounded ifFalse: [^ false].
	"a bounded p-adics that are equal up to their precision are considered equal
	(but maybe it should answer always false, like Magma)"
	1 to: parent precision do: [:i|
		(digits at: i) = (anAdic digits at: i) ifFalse: [^ false]].
	^ true! !

!RelaxedAdicInteger methodsFor: 'comparing' stamp: 'len 6/3/2019 15:24:04'!
hash
	| answer |
	answer _ 0.
	1 to: 4 do: [:i| "just 4 terms? how to decide how many terms to use?"
		answer _ answer hashMultiply + (digits at: i) hash].
	^ answer! !

!RelaxedAdicInteger methodsFor: 'converting' stamp: 'len 8/7/2019 10:08:38'!
jet: anInteger
	"Answer the anInteger-th jet of the receiver, that is the truncation to anInteger terms."
	^ (self parent jet: anInteger) !! self! !

!RelaxedAdicInteger methodsFor: 'testing' stamp: 'len 6/2/2019 10:00:28'!
isZero
	parent isBounded ifFalse: [^ false].
	"a bounded p-adic that is 0 up to its precision is considered 0
	(but maybe it should answers always false, like Magma)"
	1 to: parent precision do: [:i|
		(digits at: i) isZero ifFalse: [^ false]].
	^ true! !

!RelaxedAdicInteger methodsFor: 'private' stamp: 'len 6/1/2019 16:50:33'!
digits: aSequence
	digits _ aSequence! !

!RelaxedAdicInteger methodsFor: 'private' stamp: 'len 6/1/2019 16:50:14'!
parent: aPAdicIntegersRing
	parent _ aPAdicIntegersRing! !

!RelaxedAdicNumber methodsFor: 'accessing' stamp: 'len 6/5/2019 13:19:40'!
abs
	"Answer the p-adic absolute value (or norm) of the receiver."
	^ self isZero ifTrue: [0] ifFalse: [self p ^ valuation negated]! !

!RelaxedAdicNumber methodsFor: 'accessing' stamp: 'len 6/3/2019 18:20:17'!
absolutePrecision
	^ unit absolutePrecision! !

!RelaxedAdicNumber methodsFor: 'accessing' stamp: 'len 6/3/2019 18:37:29'!
denominator
	^ valuation < 0 ifTrue: [unit parent !! (self p ^ valuation negated)] ifFalse: [unit one]! !

!RelaxedAdicNumber methodsFor: 'accessing' stamp: 'len 6/3/2019 18:21:46'!
numerator
	^ valuation <= 0 ifTrue: [unit] ifFalse: [unit >> valuation]! !

!RelaxedAdicNumber methodsFor: 'accessing' stamp: 'len 6/3/2019 18:21:54'!
p
	^ unit p! !

!RelaxedAdicNumber methodsFor: 'accessing' stamp: 'len 6/5/2019 11:26:00'!
parent
	^ unit parent fractions! !

!RelaxedAdicNumber methodsFor: 'accessing' stamp: 'len 6/2/2019 10:46:39'!
relativePrecision
	^ self absolutePrecision - valuation! !

!RelaxedAdicNumber methodsFor: 'accessing' stamp: 'len 6/3/2019 18:22:52'!
unit
	^ unit! !

!RelaxedAdicNumber methodsFor: 'accessing' stamp: 'len 6/2/2019 10:48:05'!
valuation
	^ valuation! !

!RelaxedAdicNumber methodsFor: 'private' stamp: 'len 6/3/2019 18:26:19'!
valuation: anInteger unit: anAdicInteger
	valuation _ anInteger.
	unit _ anAdicInteger! !

!RelaxedAdicNumber class methodsFor: 'instance creation' stamp: 'len 6/3/2019 18:25:44'!
valuation: anInteger unit: anAdicInteger
	^ self new valuation: anInteger unit: anAdicInteger! !

!RelaxedPowerSeries methodsFor: 'accessing' stamp: 'len 12/27/2015 15:45'!
coefficients
	^ coefficients! !

!RelaxedPowerSeries methodsFor: 'accessing' stamp: 'len 12/27/2015 15:45'!
indeterminate
	^ 1! !

!RelaxedPowerSeries methodsFor: 'accessing' stamp: 'len 10/28/2016 10:37'!
parent
	^ parent! !

!RelaxedPowerSeries methodsFor: 'accessing' stamp: 'len 12/28/2015 04:12'!
scalars
	^ coefficients codomain! !

!RelaxedPowerSeries methodsFor: 'accessing' stamp: 'len 9/22/2018 18:55:44'!
terms
	| P |
	P _ self scalars polynomials.
	^ Sequence to: P evaluating: [:i| P coefficient: (coefficients at: i) degree: i-1]! !

!RelaxedPowerSeries methodsFor: 'accessing' stamp: 'len 6/14/2019 01:33:51'!
valuation
	^ (self coefficients findFirst: [:each| each isZero not]) - 1! !

!RelaxedPowerSeries methodsFor: 'accessing-private' stamp: 'len 12/27/2015 15:46'!
coefficients: aSequence
	coefficients _ aSequence! !

!RelaxedPowerSeries methodsFor: 'accessing-private' stamp: 'len 10/28/2016 10:38'!
parent: aPowerSeriesRing
	parent _ aPowerSeriesRing! !

!RelaxedPowerSeries methodsFor: 'arithmetic' stamp: 'len 8/9/2019 09:43:30'!
* anObject
	((anObject isKindOf: RelaxedPowerSeries) and: [anObject parent = parent])
		ifTrue: [^ parent coefficients: (coefficients convolution: anObject coefficients)].
	(self scalars includes: anObject)
		ifTrue: [^ parent coefficients: coefficients * anObject].
	(anObject isKindOf: Polynomial)
		ifTrue: [^ self * (parent !! anObject)].
	^ DomainError signal! !

!RelaxedPowerSeries methodsFor: 'arithmetic' stamp: 'len 8/9/2019 09:43:30'!
+ anObject
	(anObject isKindOf: RelaxedPowerSeries)
		ifTrue: [^ parent coefficients: coefficients + anObject coefficients].
	(self scalars includes: anObject)
		ifTrue: [^ parent coefficients: coefficients + (CFiniteSequence to: self scalars initialValues: {anObject} periodic: {anObject zero})].
	(anObject isKindOf: Polynomial)
		ifTrue: [^ self + (parent !! anObject)].
	^ DomainError signal! !

!RelaxedPowerSeries methodsFor: 'arithmetic' stamp: 'len 6/2/2019 17:14:04'!
negated
	^ parent coefficients: coefficients negated! !

!RelaxedPowerSeries methodsFor: 'arithmetic' stamp: 'len 6/5/2019 17:04:52'!
reciprocal
	| b1 a |
	a _ coefficients.
	b1 _ (a at: 1) reciprocal.
	^ parent coefficients:
		(Sequence
			to: self scalars
			initialValues: {b1}
			recurrence:
				[:b :n|
				b1 negated * ((2 to: n) sum: [:i| (a at: i) * (b at: n-i+1)])])! !

!RelaxedPowerSeries methodsFor: 'comparing' stamp: 'len 8/9/2019 09:43:30'!
= anObject
	^ (anObject isKindOf: RelaxedPowerSeries) and: [coefficients = anObject coefficients]! !

!RelaxedPowerSeries methodsFor: 'comparing' stamp: 'len 12/28/2015 19:45'!
hash
	^ coefficients hash! !

!RelaxedPowerSeries methodsFor: 'converting' stamp: 'len 12/27/2015 19:09'!
asRationalFunction
	^ coefficients generatingFunction! !

!RelaxedPowerSeries methodsFor: 'converting' stamp: 'len 8/7/2019 10:08:50'!
jet: anInteger
	"Answer the anInteger-th jet of the receiver, that is the truncation to anInteger terms."
	^ (self parent jet: anInteger) !! self! !

!RelaxedPowerSeries methodsFor: 'operations' stamp: 'len 6/2/2019 17:11:59'!
derivative
	^ parent coefficients: coefficients << 1 * CFiniteSequence identity! !

!RelaxedPowerSeries methodsFor: 'operations' stamp: 'len 2/29/2016 04:58'!
value: anObject upTo: n
	| answer |
	answer _ anObject zero.
	self terms do: [:each| each degree > n ifTrue: [^ answer]. answer _ answer + (each value: anObject)].
	^ answer! !

!RelaxedPowerSeries methodsFor: 'testing' stamp: 'len 4/11/2016 23:09'!
isZero
	^ coefficients isZero! !

!RelaxedPowerSeries class methodsFor: 'examples' stamp: 'len 5/23/2020 09:33:01'!
cos
	"The power series expansion of cos(x)."
	^  powerSeries coefficients:
		(Sequence to:  evaluating: [:n| n even ifTrue: [0] ifFalse: [|k| k _ n-1/2. (-1)^k / (2*k) factorial]])! !

!RelaxedPowerSeries class methodsFor: 'examples' stamp: 'len 5/23/2020 09:33:01'!
exp
	"The power series expansion of exp(x)."
	^  powerSeries
		coefficients: (Sequence to:  evaluating: [:n| 1 / n factorial])! !

!RelaxedPowerSeries class methodsFor: 'examples' stamp: 'len 5/23/2020 09:33:01'!
sin
	"The power series expansion of sin(x)."
	^  powerSeries
		coefficients: (Sequence to:  evaluating: [:n| n odd ifTrue: [0] ifFalse: [|k| k _ n/2-1. (-1)^k / (2*k+1) factorial]])! !

!RelaxedPowerSeries class methodsFor: 'instance creation' stamp: 'len 12/27/2015 16:21'!
coefficients: aSequence
	^ self new coefficients: aSequence! !

!RelaxedPowerSeries class methodsFor: 'instance creation' stamp: 'len 11/25/2016 10:32:44'!
fromPolynomial: aPolynomial
	^ self coefficients: (CFiniteSequence to: aPolynomial scalars initialValues: aPolynomial coefficients periodic: {aPolynomial scalars zero})! !

!FreePolynomial methodsFor: 'accessing' stamp: 'len 3/3/2016 05:27'!
degree
	"Answer the total degree of the receiver."
	self isZero ifTrue: [^ Infinity negative].
	^ self monomials max: [:each| each length]! !

!FreePolynomial methodsFor: 'accessing' stamp: 'len 1/10/2018 13:29:49'!
leadingCoefficient
	^ self at: self leadingMonomial! !

!FreePolynomial methodsFor: 'accessing' stamp: 'len 1/10/2018 13:29:36'!
leadingMonomial
	^ self monomials asSortedCollection first! !

!FreePolynomial methodsFor: 'accessing' stamp: 'len 1/10/2018 16:56:38'!
monomials
	^ Iterator on: self performing: #monomialsDo:! !

!FreePolynomial methodsFor: 'accessing' stamp: 'len 1/10/2018 16:56:11'!
monomialsDo: aBlock
	self keysDo: aBlock! !

!FreePolynomial methodsFor: 'accessing' stamp: 'len 1/10/2018 20:07:45'!
one
	^ self parent one! !

!FreePolynomial methodsFor: 'arithmetic' stamp: 'len 1/10/2018 21:49:36'!
* anObject
	((self scalars includes: anObject) or: [anObject isInteger])
		ifTrue: [^ super * anObject].
	(self parent includes: anObject)
		ifTrue: [^ self convolution: anObject].
	(self parent words includes: anObject)
		ifTrue: [^ self multipliedByMonomial: anObject].
	^ DomainError signal! !

!FreePolynomial methodsFor: 'arithmetic' stamp: 'len 6/8/2019 02:24:51'!
^ anInteger
	"Answer the receiver raised to the power anInteger."
	(anInteger isInteger and: [anInteger >= 0])
		ifFalse: [^ DomainError signal: 'undefinted'].
	anInteger = 0 ifTrue: [^ self one].
	anInteger = 1 ifTrue: [^ self].
	^ anInteger even ifTrue: [self squared ^ (anInteger // 2)] ifFalse: [self squared ^ (anInteger // 2) * self]! !

!FreePolynomial methodsFor: 'arithmetic' stamp: 'len 1/10/2018 20:18:46'!
multipliedByMonomial: aWord
	| newCoefficients |
	newCoefficients _ Dictionary new: self size.
	self associationsDo: [:each| newCoefficients at: each key * aWord put: each value].
	^ self parent coefficients: newCoefficients! !

!FreePolynomial methodsFor: 'arithmetic' stamp: 'len 3/2/2016 05:35'!
squared
	^ self * self! !

!FreePolynomial methodsFor: 'testing' stamp: 'len 1/10/2018 16:57:08'!
isStandard
	"Answer true if the receiver is a standard polynomial, i.e. all its monomials are standard words."
	self monomialsDo: [:each| each isStandard ifFalse: [^ false]].
	^ true! !

!Buchberger methodsFor: 'accessing' stamp: 'len 1/10/2022 12:23:20'!
basis
	^ basis! !

!Buchberger methodsFor: 'accessing' stamp: 'len 1/10/2022 12:27:30'!
basisMatrix
	^ self isRankOne
		ifTrue: [(matrix scalars^basis size !! basis) asRowMatrix]
		ifFalse: [Matrix to: matrix codomain columns: basis]! !

!Buchberger methodsFor: 'accessing' stamp: 'len 1/12/2022 14:05:12'!
ordering
	^ matrix scalars ordering! !

!Buchberger methodsFor: 'accessing' stamp: 'len 1/13/2022 08:09:29'!
scalars
	^ matrix scalars scalars! !

!Buchberger methodsFor: 'computing' stamp: 'len 1/13/2022 09:20:28'!
autoreduce
	"Make the basis a reduced basis.
	Based on [BW93], algorithm REDGROEBNER (p. 216) and REDUCTION (p. 203).
	[BW93] Thomas Becker; Volker Weispfenning; 'Groebner Bases: A Computational Approach to Commutative Algebra' (1993)"
	| H |
	H _ OrderedCollection new.
	1 to: basis size do: [:i| | f m |
		f _ basis at: i.
		m _ f leadingMonomial.
		(((i+1 to: basis size) noneSatisfy: [:j| (basis at: j) leadingMonomial | m])
			and: [H noneSatisfy: [:h| h leadingMonomial | m]])
				ifTrue: [H add: f]].
	H _ H asArray.
	basis _ OrderedCollection new.
	1 to: H size do: [:i| | h r |
		h _ H at: i.
		(r _ h reductionFullBy: (H copyWithoutIndex: i)) isZero ifFalse:
			[basis add: r normalized]]! !

!Buchberger methodsFor: 'computing' stamp: 'len 1/13/2022 09:20:01'!
process: anArray
	| i0 r queue |
	i0 _ basis size + 1.
	anArray do: [:f| (r _ f reductionBy: basis) isZero ifFalse: [basis add: r normalized]].
	queue _ OrderedCollection new.
	1 to: basis size do: [:i| | fi hi ci |
		fi _ basis at: i.
		hi _ fi leadingMonomial.
		ci _ fi leadingCoefficient.
		(i+1 max: i0) to: basis size do: [:k| | fk hk ck f |
			fk _ basis at: k.
			hk _ fk leadingMonomial.
			(hi lcm: hk) ifNotNil: [:lcm|
				"Buchberger Product Criterion and Chain Criterion
				(Product Criterion is only applicable to rank 1):"
				((self isRankOne not or: [lcm ~= (hi * hk)]) and: [((1 to: i-1) noneSatisfy: [:j| (basis at: j) leadingMonomial | lcm])])
					ifTrue:
						[ck _ fk leadingCoefficient.
						f _ fi * (lcm / hi) / ci - (fk * (lcm / hk) / ck).
						(r _ f reductionBy: basis) isZero ifFalse: [queue add: r]]]]].
	^ queue! !

!Buchberger methodsFor: 'computing' stamp: 'len 1/30/2022 06:51:41'!
run
	| queue |
"	self scalars isField ifFalse: [^ self error: 'not over a field']."
	basis _ OrderedCollection new.
	queue _ OrderedCollection new.
	(self isRankOne ifTrue: [matrix asTuple asArray] ifFalse: [matrix columns])
		withIndexDo: [:each :i| each isZero ifFalse: [queue add: each]].
	[queue isEmpty] whileFalse:
		[queue _ self process: (queue asSortedCollection: [:a :b| a leadingMonomial <= b leadingMonomial])].
	"This adds about 50% time in some cases:"
	self autoreduce.
	self sort! !

!Buchberger methodsFor: 'computing' stamp: 'len 1/13/2022 11:40:48'!
sort
	"Sort the basis to make it unique (if it's autoreduced):"
	basis sort: [:a :b| a leadingMonomial >= b leadingMonomial].
! !

!Buchberger methodsFor: 'testing' stamp: 'len 1/10/2022 12:12:04'!
isRankOne
	^ matrix height = 1! !

!Buchberger methodsFor: 'private' stamp: 'len 1/10/2022 12:12:41'!
matrix: aMatrix
	matrix _ aMatrix! !

!Buchberger methodsFor: 'private' stamp: 'len 1/13/2022 09:40:10'!
verify
	self basisMatrix isStandardBasis ifFalse: [^ false].
	self basisMatrix isReducedStandardBasis ifFalse: [^ false].
	self basisMatrix isMinimalStandardBasis ifFalse: [^ self error: 'a reduced basis should be minimal'].
	^ (basis sorted: [:a :b| a leadingMonomial <= b leadingMonomial]) = basis asArray! !

!ExtendedBuchberger methodsFor: 'accessing' stamp: 'len 1/12/2022 13:45:32'!
transformation
	^ matrix scalars^combinations size to: matrix domain filling: [:i :j| (combinations at: j) at: i]! !

!ExtendedBuchberger methodsFor: 'computing' stamp: 'len 1/13/2022 09:56:58'!
autoreduce
	"Make the basis a reduced basis.
	Based on [BW93], algorithm REDGROEBNER (p. 216) and REDUCTION (p. 203).
	[BW93] Thomas Becker; Volker Weispfenning; 'Groebner Bases: A Computational Approach to Commutative Algebra' (1993)"
	| H T |
	H _ OrderedCollection new.
	T _ OrderedCollection new.
	1 to: basis size do: [:i| | f m |
		f _ basis at: i.
		m _ f leadingMonomial.
		(((i+1 to: basis size) noneSatisfy: [:j| (basis at: j) leadingMonomial | m])
			and: [H noneSatisfy: [:h| h leadingMonomial | m]])
				ifTrue: [H add: f. T add: (combinations at: i)]].
	H _ H asArray.
	T _ T asArray.
	H size > 1 ifFalse: [basis _ H. combinations _ T. ^ self].
	basis _ OrderedCollection new.
	combinations _ OrderedCollection new.
	1 to: H size do: [:i| | h division r u |
		h _ H at: i.
		division _ h divisionBy: (H copyWithoutIndex: i).
		(r _ division remainder) isZero ifFalse:
			[u _ r normalization.
			basis add: r*u.
			combinations add: (T at: i) - ((T copyWithoutIndex: i) * division quotients) sum * u]]! !

!ExtendedBuchberger methodsFor: 'computing' stamp: 'len 1/12/2022 13:44:32'!
process: anArray
	| i0 division r u queue |
	i0 _ basis size + 1.
	"Full reduction in this step produces a reduced basis:"
	anArray do: [:f|
		division _ f key divisionBy: basis.
		(r _ division remainder) isZero ifFalse:
			[u _ r normalization.
			basis add: r*u.
			combinations add: (combinations isEmpty ifTrue: [f value] ifFalse: [f value - (combinations * division quotients) sum])*u]].
	queue _ OrderedCollection new.
	1 to: basis size do: [:i| | fi hi ci ai |
		fi _ basis at: i.
		hi _ fi leadingMonomial.
		ci _ fi leadingCoefficient.
		ai _ combinations at: i.
		(i+1 max: i0) to: basis size do: [:k| | fk hk ck f ak |
			fk _ basis at: k.
			hk _ fk leadingMonomial.
			(hi lcm: hk) ifNotNil: [:lcm|
				"Buchberger Product Criterion and Chain Criterion
				(Product Criterion is only applicable to rank 1):"
				((self isRankOne not or: [lcm ~= (hi * hk)]) and: [((1 to: i-1) noneSatisfy: [:j| (basis at: j) leadingMonomial | lcm])])
					ifTrue:
						[ck _ fk leadingCoefficient.
						ak _ combinations at: k.
						f _ fi * (lcm / hi) / ci - (fk * (lcm / hk) / ck).
						division _ f divisionBy: basis.
						(r _ division remainder) isZero ifFalse:
							[queue add: (Association key: r value: ((ai * (matrix scalars one * (lcm / hi) / ci) - (ak * (matrix scalars one * (lcm / hk) / ck))) - (combinations * division quotients) sum))]]]]].
	^ queue! !

!ExtendedBuchberger methodsFor: 'computing' stamp: 'len 1/30/2022 06:51:50'!
run
	| queue |
"	self scalars isField ifFalse: [^ self error: 'not over a field']."
	self ordering isGlobal ifFalse: [^ self notYetImplemented].
	basis _ OrderedCollection new.
	combinations _ OrderedCollection new.
	queue _ OrderedCollection new.
	(self isRankOne ifTrue: [matrix asTuple asArray] ifFalse: [matrix columns])
		withIndexDo: [:each :i| each isZero ifFalse: [queue add: (Association key: each value: (matrix domain x: i))]].
	[(queue _ self process: (queue asSortedCollection: [:a :b| a key leadingMonomial <= b key leadingMonomial])) isEmpty] whileFalse.
	self autoreduce.
	self sort! !

!ExtendedBuchberger methodsFor: 'computing' stamp: 'len 1/13/2022 11:41:01'!
sort
	"Sort the basis to make it unique (if it's autoreduced):"
	| temp |
	temp _ (1 to: basis size) collect: [:i| Association key: (basis at: i) value: (combinations at: i)].
	temp sort: [:a :b| a key leadingMonomial >= b key leadingMonomial].
	basis _ temp collect: [:each| each key].
	combinations _ temp collect: [:each| each value]! !

!ExtendedBuchberger methodsFor: 'private' stamp: 'len 1/12/2022 13:46:04'!
verify
	^ super verify and: [matrix * self transformation = self basisMatrix]! !

!ComplexBox methodsFor: 'accessing' stamp: 'len 1/16/2016 05:56'!
area
	^ self measure! !

!ComplexBox methodsFor: 'accessing' stamp: 'len 1/16/2016 05:59'!
closure
	^ self class real: real closure imaginary: imaginary closure! !

!ComplexBox methodsFor: 'accessing' stamp: 'len 1/11/2016 02:58'!
imaginary
	^ imaginary! !

!ComplexBox methodsFor: 'accessing' stamp: 'len 1/11/2016 02:55'!
measure
	^ real measure * imaginary measure! !

!ComplexBox methodsFor: 'accessing' stamp: 'len 1/15/2016 07:21'!
midpoint
	^ Complex real: real midpoint imaginary: imaginary midpoint! !

!ComplexBox methodsFor: 'accessing' stamp: 'len 6/5/2016 06:20'!
quarters
	| imaginaries reals |
	reals _ self real halves.
	imaginaries _ self imaginary halves.
	^ {self class real: (reals at: 1) imaginary: (imaginaries at: 1).
		self class real: (reals at: 1) imaginary: (imaginaries at: 2).
		self class real: (reals at: 2) imaginary: (imaginaries at: 1).
		self class real: (reals at: 2) imaginary: (imaginaries at: 2)}! !

!ComplexBox methodsFor: 'accessing' stamp: 'len 6/5/2016 04:08'!
radius2
	^ real length squared + imaginary length squared / 4! !

!ComplexBox methodsFor: 'accessing' stamp: 'len 1/11/2016 02:58'!
real
	^ real! !

!ComplexBox methodsFor: 'accessing' stamp: 'len 6/1/2020 13:09:57'!
sample
	"Answer a sample point in the receiver."
	| sampleImaginary sampleReal |
	sampleReal _ real sample.
	sampleImaginary _ imaginary sample.
	^ ^sampleReal size filling: [:i| Complex real: (sampleReal at: i) imaginary: (sampleImaginary at: i)]! !

!ComplexBox methodsFor: 'accessing' stamp: 'len 6/5/2016 21:42'!
width
	^ real length min: imaginary length! !

!ComplexBox methodsFor: 'accessing-private' stamp: 'len 1/11/2016 02:53'!
imaginary: aRealInterval
	imaginary _ aRealInterval! !

!ComplexBox methodsFor: 'accessing-private' stamp: 'len 1/11/2016 02:53'!
real: aRealInterval
	real _ aRealInterval! !

!ComplexBox methodsFor: 'testing' stamp: 'len 1/16/2016 05:50'!
closureIncludes: aComplex
	^ (real closureIncludes: aComplex real) and: [imaginary closureIncludes: aComplex imaginary]! !

!ComplexBox methodsFor: 'testing' stamp: 'len 1/11/2016 02:54'!
includes: aComplex
	^ (real includes: aComplex real) and: [imaginary includes: aComplex imaginary]! !

!ComplexBox methodsFor: 'testing' stamp: 'len 1/16/2016 05:52'!
intersects: aComplexBox
	^ (real intersects: aComplexBox real) and: [imaginary intersects: aComplexBox imaginary]! !

!ComplexBox methodsFor: 'testing' stamp: 'len 1/11/2016 03:40'!
isBounded
	^ real isBounded and: [imaginary isBounded]! !

!ComplexBox methodsFor: 'testing' stamp: 'len 1/11/2016 03:40'!
isClosed
	^ real isClosed and: [imaginary isClosed]! !

!ComplexBox methodsFor: 'testing' stamp: 'len 1/11/2016 03:41'!
isOpen
	^ real isOpen and: [imaginary isOpen]! !

!ComplexBox class methodsFor: 'instance creation' stamp: 'len 6/4/2016 21:53'!
center: aComplex radius: aNumber
	^ self
		real: (RealInterval closed: aComplex real - aNumber closed: aComplex real + aNumber)
		imaginary: (RealInterval closed: aComplex imaginary - aNumber closed: aComplex imaginary + aNumber)! !

!ComplexBox class methodsFor: 'instance creation' stamp: 'len 1/11/2016 03:43'!
real: aRealInterval imaginary: anotherRealInterval
	^ self new real: aRealInterval; imaginary: anotherRealInterval! !

!ComplexBox class methodsFor: 'instance creation' stamp: 'len 6/5/2016 04:07'!
with: aComplex with: anotherComplex
	^ self
		real: (RealInterval with: aComplex real with: anotherComplex real)
		imaginary: (RealInterval with: aComplex imaginary with: anotherComplex imaginary)! !

!ComplexDisk methodsFor: 'accessing' stamp: 'len 1/13/2016 22:30'!
center
	^ center! !

!ComplexDisk methodsFor: 'accessing' stamp: 'len 6/30/2016 04:43'!
enclosingBox
	"Answer a ComplexBox that encloses the receiver."
	^ ComplexBox center: self center radius: self radius! !

!ComplexDisk methodsFor: 'accessing' stamp: 'len 1/15/2016 07:21'!
midpoint
	^ self center! !

!ComplexDisk methodsFor: 'accessing' stamp: 'len 6/5/2016 20:42'!
radius
	^ radius! !

!ComplexDisk methodsFor: 'accessing-private' stamp: 'len 6/5/2016 20:47'!
center: aComplex
	center _ aComplex! !

!ComplexDisk methodsFor: 'accessing-private' stamp: 'len 6/5/2016 20:47'!
radius: aNumber
	radius _ aNumber! !

!ComplexDisk methodsFor: 'arithmetic' stamp: 'len 6/5/2016 20:46'!
* aDisk
	^ self class center: aDisk center * self center radius: self radius * aDisk radius! !

!ComplexDisk methodsFor: 'arithmetic' stamp: 'len 6/30/2016 04:37'!
+ aDisk
	^ self class center: aDisk center + self center radius: self radius + aDisk radius! !

!ComplexDisk methodsFor: 'testing' stamp: 'len 6/5/2016 20:44'!
includes: anObject
	^ (anObject - center) norm2 <= radius squared! !

!ComplexDisk methodsFor: 'testing' stamp: 'len 6/5/2016 04:13'!
intersects: aBall
	self flag: #fix.
	^ (aBall center - center) norm2 <= (self radius + aBall radius) squared! !

!ComplexDisk class methodsFor: 'instance creation' stamp: 'len 6/5/2016 20:47'!
center: aComplex radius: aNumber
	^ self new center: aComplex; radius: aNumber! !

!ComplexRootIsolator methodsFor: 'as yet unclassified' stamp: 'len 3/6/2017 16:56:02'!
T2: K at: m radius: r
	| t |
	t _ 0.
	1 to: self derivatives size - 1 do: [:j|
		| f |
		f _ derivatives at: j+1.
		t _ (f value: m) abs * (r ^ j) / j factorial + t].
	^ (derivatives first value: m) abs > (K * t)! !

!ComplexRootIsolator methodsFor: 'as yet unclassified' stamp: 'len 4/24/2018 17:53:58'!
T: K at: m radius: r
	| t |
	t _ 0.
	1 to: self derivatives size do: [:j|
		| f |
		f _ derivatives at: j.
		t _ (f value: m) abs * (r ^ j) / j factorial + t].
	^ (polynomial value: m) abs > (K * t)! !

!ComplexRootIsolator methodsFor: 'as yet unclassified' stamp: 'len 12/4/2017 13:22:20'!
atMostOneRootAround: center radius: radius
	"If this holds, there's at most one root in the givem disk."
	^ self T2: 3/2 at: center radius: radius
"	^ (self rootsIn: aBox) size > 1"! !

!ComplexRootIsolator methodsFor: 'as yet unclassified' stamp: 'len 4/11/2018 21:50:32'!
bigBounds
	"Compute and answer a first estimate of a box containing all the complex roots."
	| bound |
	bound _ self polynomial norm1 / self polynomial leadingCoefficient.
	bound _ bound max: 1.
	^ ComplexBox center: 0.0 radius: bound asFloat! !

!ComplexRootIsolator methodsFor: 'as yet unclassified' stamp: 'len 4/24/2018 17:54:29'!
derivatives
	| f |
	derivatives ifNotNil: [^ derivatives].
	f _ polynomial.
	derivatives _ OrderedCollection new: f degree.
	f degree timesRepeat: [derivatives add: (f _ f derivative)].
	^ derivatives! !

!ComplexRootIsolator methodsFor: 'as yet unclassified' stamp: 'len 4/24/2018 17:54:34'!
eightPointTest: m width: w
	| N NE E SE S SW W NW points values imaginaryCrossings realCrossings |
	N _ 1 i.
	NE _ 20/29 + (21/29) i.
	E _ 1.
	SE _ 20/29 - (21/29) i.
	S _ -1 i.
	SW _ -20/29 - (21/29) i.
	W _ -1.
	NW _ -20/29 + (21/29) i.
	points _ {N. NE. E. SE. S. SW. W. NW} collect: [:p| w*p + m].
	values _ points collect: [:p| polynomial value: p].
	realCrossings _ (1 to: values size) select: [:j| (values at: j) real isZero or: [(values at: j) real * (values atWrap: j+1) real < 0]].
	realCrossings size = 2 ifFalse: [^ false].
	imaginaryCrossings _ (1 to: values size) select: [:j| (values at: j) imaginary isZero or: [(values at: j) imaginary * (values atWrap: j+1) imaginary < 0]].
	imaginaryCrossings size = 2 ifFalse: [^ false].
	realCrossings first < imaginaryCrossings first
		ifTrue: [^ realCrossings second < imaginaryCrossings second].
	^ realCrossings first > imaginaryCrossings first
		and: [realCrossings second > imaginaryCrossings second]! !

!ComplexRootIsolator methodsFor: 'as yet unclassified' stamp: 'len 4/24/2018 18:20:26'!
polynomial
	^ polynomial! !

!ComplexRootIsolator methodsFor: 'as yet unclassified' stamp: 'len 7/17/2019 10:54:00'!
polynomial: aPolynomial
	polynomial _ aPolynomial integerPrimitivePart! !

!ComplexRootIsolator methodsFor: 'as yet unclassified' stamp: 'len 4/16/2018 16:06:13'!
roots
	"Separate the roots in disks each of them containing one isolated root."
	^ self rootsInBox: self bigBounds! !

!ComplexRootIsolator methodsFor: 'as yet unclassified' stamp: 'len 4/29/2018 16:56:39'!
rootsInBox: aBox
	"Separate the roots in disks each of them containing one isolated root."
	| queue disks |
	queue _ OrderedCollection with: aBox.
	disks _ OrderedCollection new.
	[queue isEmpty]
		whileFalse:
			[| B m delta |
			B _ queue removeFirst.
			m _ B midpoint.
			delta _ B width * 3 / 4. "> B radius, and a dyadic fraction"
			(self T: 1 at: m radius: delta)
				"if holds, then D(m,delta) constains no roots"
				ifFalse:
					[((self T2: 6 at: m radius: 4*delta) and: [self T2: 3/2 at: m radius: 8*delta])
						"if the second holds, then D(m,8*delta) contains at most one root"
						"the first is required so that if two disks overlap, we can discard any one of them"
						ifTrue:
							[(self eightPointTest: m width: B width)
								ifTrue:
									[| D i D2 |
									D _ ComplexDisk center: m radius: 4*delta.
									(i _ (1 to: disks size) detect: [:j| (D2 _ disks at: j) intersects: D] ifNone: [])
									 isNil
										ifTrue: [disks add: D]
										ifFalse: [D2 radius < D radius ifTrue: [disks at: i put: D]]]]
						ifFalse:
							[queue addAll: B quarters]]].
	^ disks! !

!ComplexRootIsolator class methodsFor: 'instance creation' stamp: 'len 4/24/2018 18:01:29'!
on: aPolynomial
	^ self new polynomial: aPolynomial! !

!MultivariateDivision methodsFor: 'accessing' stamp: 'len 12/2/2015 02:48'!
dividend
	^ dividend! !

!MultivariateDivision methodsFor: 'accessing' stamp: 'len 12/2/2015 02:48'!
divisors
	^ divisors! !

!MultivariateDivision methodsFor: 'accessing' stamp: 'len 2/6/2017 07:47:28'!
exactQuotient
	self remainder isZero ifFalse: [self error: 'not an exact division'].
	^ self quotient! !

!MultivariateDivision methodsFor: 'accessing' stamp: 'len 3/9/2016 07:55'!
quotient
	self quotients size = 1 ifFalse: [self error: 'not just one quotient'].
	^ self quotients first! !

!MultivariateDivision methodsFor: 'accessing' stamp: 'len 12/6/2015 06:13'!
quotients
	quotients isNil ifTrue: [self divide].
	^ quotients! !

!MultivariateDivision methodsFor: 'accessing' stamp: 'len 12/6/2015 06:13'!
remainder
	remainder isNil ifTrue: [self divide].
	^ remainder! !

!MultivariateDivision methodsFor: 'accessing' stamp: 'len 7/28/2021 07:41:51'!
remainderAlone
	| p head |
	remainder ifNotNil: [^ remainder].
	divisors isEmpty ifTrue: [^ remainder _ dividend].
	remainder _ dividend zero.
	p _ dividend.
	[p isZero] whileFalse:
		[head _ p leadingMonomial.
		divisors detect: [:fi| fi leadingMonomial | head]
			ifFound: [:fi| p _ p + (fi * (head / fi leadingMonomial) * (p leadingCoefficient negated / fi leadingCoefficient))]
			ifNone:
				[remainder _ remainder + p leadingTerm.
				p _ p tail]].
	^ remainder! !

!MultivariateDivision methodsFor: 'initialization' stamp: 'len 12/6/2015 19:03'!
divide: aPolynomial by: anArrayOfPolynomials
	dividend _ aPolynomial.
	divisors _ anArrayOfPolynomials! !

!MultivariateDivision methodsFor: 'private' stamp: 'len 7/29/2021 10:11:02'!
divide
	"Perform the division algorithm computing quotients and remainder."
	| R p s fi q head i |
	R _ dividend isTuple ifTrue: [dividend scalars] ifFalse: [dividend parent].
	quotients _ Array new: divisors size withAll: R zero.
	divisors isEmpty ifTrue: [remainder _ dividend. ^ self].
	remainder _ dividend zero.
	s _ divisors size.
	p _ dividend.
	[p isZero] whileFalse:
		[head _ p leadingMonomial.
		i _ 1.
		[(fi _ divisors at: i) leadingMonomial | head or: [(i _ i + 1) > s]] whileFalse.
		i <= s "i.e. found fi with leading monomial dividing head"
			ifTrue:
				[q _ R coefficient: p leadingCoefficient / fi leadingCoefficient monomial: head / fi leadingMonomial.
				quotients at: i put: (quotients at: i) + q.
				p _ p + (fi * q negated)]
			ifFalse:
				[remainder _ remainder + p leadingTerm.
				p _ p tail]]! !

!MultivariateDivision methodsFor: 'private' stamp: 'len 5/10/2018 07:23:22'!
verify
	| total |
	total _ self remainder.
	self divisors with: self quotients do: [:f :q| total _ total + (f*q)].
	total = self dividend ifFalse: [^ false].

	self divisors with: self quotients do: [:f :q|
		(q isZero or: [(f*q) leadingMonomial <= self dividend leadingMonomial])
			ifFalse: [^ false]].

	self remainder monomials do: [:each| (self divisors noneSatisfy: [:f| f leadingMonomial | each]) ifFalse: [^ false]].
	^ true! !

!MultivariateDivision class methodsFor: 'instance creation' stamp: 'len 11/20/2016 15:19:29'!
divide: aPolynomial by: anArrayOfPolynomials
	^ self new divide: aPolynomial by: anArrayOfPolynomials! !

!NumericalComplexRootIsolator methodsFor: 'accessing' stamp: 'len 5/10/2019 08:30:57'!
rootNear: aComplex
"	[self roots do: [:each| (each approximation - aComplex) abs < epsilon ifTrue: [^ each]].
	self roots do: [:each| each refine]] repeat"
	^ self roots detectMin: [:each| (each approximation - aComplex) abs]! !

!NumericalComplexRootIsolator methodsFor: 'accessing' stamp: 'len 1/15/2016 05:57'!
tolerance
	^ tolerance! !

!NumericalComplexRootIsolator methodsFor: 'accessing' stamp: 'len 1/15/2016 05:53'!
tolerance: aNumber
	tolerance _ aNumber! !

!NumericalComplexRootIsolator methodsFor: 'initialization' stamp: 'len 1/15/2016 06:09'!
initialize
	super initialize.
	tolerance _ 0.1! !

!NumericalComplexRootIsolator methodsFor: 'private' stamp: 'len 1/13/2016 03:01'!
initialValue
	^ 1.3 + 0.314159 i! !

!NumericalComplexRootIsolator methodsFor: 'private' stamp: 'len 8/9/2020 07:46:58'!
roots
	| roots X P Q P2 Q2 n x v m c dx x1 v1 m1 realCoefficients |
	X _ polynomial parent x.
	P _ polynomial.
	Q _ P.
	P2 _ P derivative.
	Q2 _ P2.
	n _ P degree.
	roots _ OrderedCollection new: n.
	realCoefficients _ P coefficients allSatisfy: [:each| (each isKindOf: Number) or: [each imaginary isZero]].
	["Initialize root finding:"
	x _ self initialValue.
	v _ Q value: x.
	m _ v norm2.
	"Initialize recursion:"
	c _ 0. dx _ v / (Q2 value: x).
	[dx abs < tolerance]
		whileFalse:
			[x1 _ x - dx.
			v1 _ Q value: x1.
			m1 _ v1 norm2.
			m1 < m
				ifTrue: [x _ x1. v _ v1. m _ m1. c _ 0. dx _ v / (Q2 value: x)]
				ifFalse: [c _ c + 1. dx _ dx / 4. c > 20 ifTrue: [self error: 'failed']]].
	"Polish root:"
	2 timesRepeat: [x _ x - ((P value: x) / (P2 value: x))].
	"Divide:"
	((realCoefficients not or: [n = 1]) or: [x imaginary abs < tolerance "###"])
		ifTrue: "found one root"
			[x imaginary abs < tolerance ifTrue: [x _ x real]. "###"
			roots add: (ComplexDisk center: x radius: tolerance).
			Q _ Q // (X - x).
			Q2 _ Q derivative. "###"
			n _ n - 1]
		ifFalse: "found a root and (if the root is not real) also found its conjugate"
			[roots
				add: (ComplexDisk center: x radius: tolerance);
				add: (ComplexDisk center: x conjugate radius: tolerance).
			Q _ Q // (X^2 - (X * (x real * 2)) + x abs squared).
			Q2 _ Q derivative. "###"
			n _ n - 2].
	n > 0] whileTrue.
	^ roots! !

!NumericalComplexRootIsolator class methodsFor: 'instance creation' stamp: 'len 1/9/2022 08:38:42'!
polynomial: aPolynomial
	^ self squarefreePolynomial: aPolynomial // (aPolynomial gcd: aPolynomial derivative)! !

!NumericalComplexRootIsolator class methodsFor: 'instance creation' stamp: 'len 1/9/2022 08:38:08'!
squarefreePolynomial: aPolynomial
	^ super polynomial: aPolynomial! !

!PseudoDivision methodsFor: 'accessing' stamp: 'len 3/8/2016 22:39'!
delta
	"Answer an integer delta such that the dividend multiplied by the divisor's leading coeficient raised to the delta equals the product of the quotient by the divisor plus the remainder (the pseudo-division relation)."
	^ self dividend degree - self divisor degree + 1 max: 0! !

!PseudoDivision methodsFor: 'accessing' stamp: 'len 12/11/2015 06:55'!
dividend
	^ dividend! !

!PseudoDivision methodsFor: 'accessing' stamp: 'len 12/2/2015 02:51'!
divisor
	^ divisor! !

!PseudoDivision methodsFor: 'accessing' stamp: 'len 1/9/2022 08:18:28'!
exactQuotient
	"Answer the quotient of an exact division."
	self remainder isZero ifFalse: [self error: 'not an exact division'].
	^ self quotient / (divisor leadingCoefficient ^ self delta)! !

!PseudoDivision methodsFor: 'accessing' stamp: 'len 5/10/2020 05:18:36'!
quotient
	quotient isNil ifTrue: [remainder notNil ifTrue: [self error: 'should call #quotient first']. self divide].
	^ quotient! !

!PseudoDivision methodsFor: 'accessing' stamp: 'len 12/6/2015 07:31'!
remainder
	remainder isNil ifTrue: [self divide].
	^ remainder! !

!PseudoDivision methodsFor: 'accessing' stamp: 'len 7/28/2021 12:59:10'!
remainderAlone
	^ self remainder! !

!PseudoDivision methodsFor: 'initialization' stamp: 'len 12/11/2015 06:56'!
divide: aPolynomial by: anotherPolynomial
	dividend _ aPolynomial.
	divisor _ anotherPolynomial! !

!PseudoDivision methodsFor: 'private' stamp: 'len 5/29/2020 19:44:02'!
divide
	"COHEN Algorithm 3.1.2 (Pseudo-Division)."
	| P m n d e lc s |
	divisor isZero ifTrue: [^ (ZeroDivide receiver: dividend selector: #// argument: divisor) signal].
	P _ dividend parent.
	(m _ dividend degree) < (n _ divisor degree)
		ifTrue: [quotient _ P zero. remainder _ dividend. ^ self].
	d _ divisor leadingCoefficient.
	remainder _ dividend.
	quotient _ P zero.
	e _ m - n + 1.
	[remainder degree < n
		ifTrue: [| q | q _ d ^ e. quotient _ quotient * q. remainder _ remainder * q. ^ self].
	lc _ remainder leadingCoefficient.
	m _ remainder degree.
	s _ P coefficient: lc degree: remainder degree - n.
	quotient _ quotient * d + s.
	remainder _ remainder * d - (divisor * s).
	e _ e - 1] repeat! !

!PseudoDivision methodsFor: 'private' stamp: 'len 5/10/2020 05:01:48'!
verify
	^ dividend * (divisor leadingCoefficient ^ self delta) = (self quotient * divisor + self remainder)! !

!PseudoDivision class methodsFor: 'instance creation' stamp: 'len 12/11/2015 06:57'!
divide: aPolynomial by: anotherPolynomial
	"Answer a pseudo-division algorithm to divide aPolynomial by anotherPolynomial."
	^ self new divide: aPolynomial by: anotherPolynomial! !

!RealBox methodsFor: 'accessing' stamp: 'len 1/11/2016 02:33'!
add: aRealInterval
	^ components add: aRealInterval! !

!RealBox methodsFor: 'accessing' stamp: 'len 12/13/97 15:21'!
addAll: aCollection
	"Add the elements in the argument to the receiver. Answer the argument."

	aCollection do: [ :each | self add: each].
	^ aCollection! !

!RealBox methodsFor: 'accessing' stamp: 'len 1/11/2016 02:33'!
at: anInteger
	"Answer the anInteger-th component of the receiver."
	^ components at: anInteger! !

!RealBox methodsFor: 'accessing' stamp: 'len 1/11/2016 02:35'!
dimension
	^ components inject: 0 into: [:sum :each| sum + each]! !

!RealBox methodsFor: 'accessing' stamp: 'len 1/11/2016 02:35'!
first
	^ self at: 1! !

!RealBox methodsFor: 'accessing' stamp: 'len 1/11/2016 02:35'!
last
	^ self at: self size! !

!RealBox methodsFor: 'accessing' stamp: 'len 1/11/2016 02:36'!
measure
	^ components inject: 1 into: [:measure :each| measure * each measure]! !

!RealBox methodsFor: 'accessing' stamp: 'len 5/23/2020 09:31:27'!
midpoint
	^  tuple: (components collect: [:each| each midpoint])! !

!RealBox methodsFor: 'accessing' stamp: 'len 6/1/2020 13:27:25'!
sample
	"Answer a sample point in the receiver."
	^ ^self size filling: [:each| (self at: each) sample]! !

!RealBox methodsFor: 'accessing' stamp: 'len 1/11/2016 02:37'!
size
	^ components size! !

!RealBox methodsFor: 'accessing-private' stamp: 'len 1/11/2016 02:37'!
components
	^ components! !

!RealBox methodsFor: 'accessing-private' stamp: 'len 1/11/2016 02:37'!
components: aCollection
	components _ aCollection! !

!RealBox methodsFor: 'comparing' stamp: 'len 12/19/97 22:06'!
= anObject
	"Answer true if the receiver equals the argument."

	self size = anObject size ifFalse: [^ false].
	1 to: self size do: [ :each | (self at: each) = (anObject at: each) ifFalse: [^ false]].
	^ true! !

!RealBox methodsFor: 'comparing' stamp: 'len 6/28/2016 09:28'!
hash
	"Answer the hash value of the receiver."

	^ self size = 0
		ifTrue: [0]
		ifFalse: [self first hash hashMultiply + self last hash hashMultiply + self size hash]! !

!RealBox methodsFor: 'enumerating' stamp: 'len 1/11/2016 02:38'!
do: aBlock
	"Enumerate the components of the receiver."
	components do: aBlock! !

!RealBox methodsFor: 'initialization' stamp: 'len 1/11/2016 02:38'!
initialize
	components _ OrderedCollection new: 3! !

!RealBox methodsFor: 'testing' stamp: 'len 1/11/2016 02:40'!
includes: aTuple
	1 to: self size do: [:each|
		((self at: each) includes: (aTuple at: each)) ifFalse: [^ false]].
	^ true! !

!RealBox methodsFor: 'testing' stamp: 'len 1/11/2016 02:40'!
isBounded
	self do: [:each| each isBounded ifFalse: [^ false]].
	^ true! !

!RealBox methodsFor: 'testing' stamp: 'len 1/11/2016 02:40'!
isClosed
	self do: [:each| each isClosed ifFalse: [^ false]].
	^ true! !

!RealBox methodsFor: 'testing' stamp: 'len 1/11/2016 02:41'!
isOpen
	self do: [ :each | each isOpen ifFalse: [^ false]].
	^ true! !

!RealInterval methodsFor: 'accessing' stamp: 'len 12/19/97 22:10'!
dimension
	"Answer the dimension of the receiver."

	self isEmpty ifTrue: [^ Infinity negative].
	self left = self right ifTrue: [^ 0].
	^ 1! !

!RealInterval methodsFor: 'accessing' stamp: 'len 6/5/2016 06:26'!
halves
	| m |
	m _ self midpoint.
	^ {self copy right: m; rightOpen: false . self copy left: m; leftOpen: true}! !

!RealInterval methodsFor: 'accessing' stamp: 'len 12/13/97 03:22'!
inf
	"Answer the infimun of the receiver."

	^ self left! !

!RealInterval methodsFor: 'accessing' stamp: 'len 12/13/97 03:21'!
left
	"Answer the left bound of the receiver."

	^ left! !

!RealInterval methodsFor: 'accessing' stamp: 'len 1/16/2016 05:56'!
length
	^ self measure! !

!RealInterval methodsFor: 'accessing' stamp: 'len 12/13/97 03:24'!
max
	"Answer the maximum of the receiver."

	self isRightOpen ifTrue: [^ self error: 'there''s not maximum'].
	^ self right! !

!RealInterval methodsFor: 'accessing' stamp: 'len 1/11/2016 02:43'!
measure
	^ self right - self left! !

!RealInterval methodsFor: 'accessing' stamp: 'len 1/15/2016 07:19'!
midpoint
	^ left + right / 2! !

!RealInterval methodsFor: 'accessing' stamp: 'len 12/13/97 03:23'!
min
	"Answer the minimum of the receiver."

	self isLeftOpen ifTrue: [^ self error: 'there''s not minimun'].
	^ self left! !

!RealInterval methodsFor: 'accessing' stamp: 'len 12/13/97 03:21'!
right
	"Answer the right bound of the receiver."

	^ right! !

!RealInterval methodsFor: 'accessing' stamp: 'len 11/5/2016 09:58'!
sample
	"Answer a sample point in the receiver."

	self isEmpty ifTrue: [^ self error: 'empty interval'].
	self isLeftClosed ifTrue: [^ self left].
	self isRightClosed ifTrue: [^ self right].
	(self isLeftBounded and: [self isRightBounded])
		ifTrue: [^ self left + self right / 2].
	self isLeftBounded ifTrue: [^ self left + 1].
	self isRightBounded ifTrue: [^ self right - 1].
	^ 0! !

!RealInterval methodsFor: 'accessing' stamp: 'len 12/13/97 03:24'!
sup
	"Answer the supremum of the receiver."

	^ self right! !

!RealInterval methodsFor: 'accessing-private' stamp: 'len 12/13/97 03:18'!
left: aNumber
	left _ aNumber! !

!RealInterval methodsFor: 'accessing-private' stamp: 'len 12/13/97 02:30'!
leftOpen: aBoolean
	leftOpen _ aBoolean! !

!RealInterval methodsFor: 'accessing-private' stamp: 'len 12/13/97 03:21'!
right: aNumber
	right _ aNumber! !

!RealInterval methodsFor: 'accessing-private' stamp: 'len 12/13/97 02:32'!
rightOpen: aBoolean
	rightOpen _ aBoolean! !

!RealInterval methodsFor: 'arithmetic' stamp: 'len 12/13/97 03:19'!
* anInterval
	"Answer the product of the receiver by the argument."

	| l1l2 l1r2 r1l2 r1r2 |
	l1l2 _ self left * anInterval left.
	l1r2 _ self left * anInterval right.
	r1l2 _ self right * anInterval left.
	r1r2 _ self right * anInterval right.
	^ self copy
		left: ((l1l2 min: l1r2) min: (r1l2 min: r1r2));
		right: ((l1l2 max: l1r2) max: (r1l2 max: r1r2))! !

!RealInterval methodsFor: 'arithmetic' stamp: 'len 12/13/97 03:20'!
+ anInterval
	"Answer the sum of the receiver and the argument."

	^ self copy
		left: self left + anInterval left;
		right: self right + anInterval right! !

!RealInterval methodsFor: 'arithmetic' stamp: 'len 12/13/97 03:36'!
- anInterval
	"Answer the difference of the receiver and the argument."

	^ self + anInterval negated! !

!RealInterval methodsFor: 'arithmetic' stamp: 'len 12/13/97 02:14'!
/ anInterval
	"Answer the quotient of the receiver by the argument."

	^ self * anInterval reciprocal! !

!RealInterval methodsFor: 'arithmetic' stamp: 'len 12/13/97 03:20'!
negated
	"Answer the additive inverse of the receiver."

	^ self copy
		right: self left negated;
		left: self right negated;
		leftOpen: self isRightOpen;
		rightOpen: self isLeftOpen! !

!RealInterval methodsFor: 'arithmetic' stamp: 'len 1/16/2016 05:48'!
reciprocal
	"Answer the multiplicative inverse of the receiver."
	(self closureIncludes: 0) ifTrue: [^ ZeroDivide signal].
	^ self copy
		left: self right reciprocal;
		right: self left reciprocal! !

!RealInterval methodsFor: 'arithmetic' stamp: 'len 1/16/2016 06:58'!
squared
	^ self * self! !

!RealInterval methodsFor: 'comparing' stamp: 'len 1/16/2016 05:57'!
= anInterval
	^ left = anInterval left and: [right = anInterval right and: [self isLeftOpen = anInterval isLeftOpen and: [self isRightOpen = anInterval isRightOpen]]]! !

!RealInterval methodsFor: 'comparing' stamp: 'len 6/28/2016 09:30'!
hash
	^ self left hash hashMultiply + self right hash + self isRightOpen hash + self isLeftOpen hash hashMultiply! !

!RealInterval methodsFor: 'constants' stamp: 'len 12/13/97 03:20'!
identity
	"Answer the identity element for the receiver."

	^ self copy left: 1; right: 1! !

!RealInterval methodsFor: 'constants' stamp: 'len 12/13/97 03:20'!
null
	"Answer the null element for the receiver."

	^ self copy left: 0; right: 0! !

!RealInterval methodsFor: 'converting' stamp: 'len 12/13/97 02:31'!
close
	"Answer a closed inverval with the same bounds that the receiver."

	self isClosed ifFalse: [^ self copy leftOpen: false; rightOpen: false]! !

!RealInterval methodsFor: 'converting' stamp: 'len 12/13/97 02:40'!
closeLeft
	"Answer a closed left interval with the same bounds that the receiver."

	self isLeftClosed ifFalse: [^ self copy leftOpen: false]! !

!RealInterval methodsFor: 'converting' stamp: 'len 12/13/97 02:35'!
closeRight
	"Answer a closed right interval with the same bounds that the receiver."

	self isRightClosed ifFalse: [^ self copy rightOpen: false]! !

!RealInterval methodsFor: 'converting' stamp: 'len 12/13/97 02:32'!
open
	"Answer an open inverval with the same bounds that the receiver."

	self isOpen ifFalse: [^ self copy leftOpen: true; rightOpen: true]! !

!RealInterval methodsFor: 'converting' stamp: 'len 12/13/97 02:38'!
openLeft
	"Answer an open left interval with the same bounds that the receiver."

	self isLeftOpen ifFalse: [^ self copy leftOpen: true]! !

!RealInterval methodsFor: 'converting' stamp: 'len 12/13/97 02:39'!
openRight
	"Answer an open right interval with the same bounds that the receiver."

	self isRightOpen ifFalse: [^ self copy rightOpen: true]! !

!RealInterval methodsFor: 'initialization' stamp: 'len 12/13/97 03:18'!
setLeftBound: leftBound rightBound: rightBound leftOpen: leftOpenBool rightOpen: rightOpenBool
	left _ leftBound.
	right _ rightBound.
	"If the interval is left-closed or right-closed and two points are
	the same, then the interval is a single point... so it's closed."
	((leftOpenBool & rightOpenBool) not and: [left = right])
		ifTrue: [leftOpen _ false.
				rightOpen _ false]
		ifFalse: [leftOpen _ leftOpenBool.
				rightOpen _ rightOpenBool]! !

!RealInterval methodsFor: 'operations' stamp: 'len 12/30/2017 16:20:58'!
, anInterval
	"Answer the cartesian product of the receiver by the argument."
	| answer |
	answer _ RealBox new add: self; yourself.
	anInterval do: [:each| answer add: each].
	^ answer! !

!RealInterval methodsFor: 'operations' stamp: 'len 1/16/2016 05:59'!
closure
	^ self class closed: left closed: right! !

!RealInterval methodsFor: 'operations' stamp: 'len 6/2/2016 07:29'!
interior
	^ self class open: left open: right! !

!RealInterval methodsFor: 'testing' stamp: 'len 3/28/2018 18:05:40'!
closureIncludes: anObject
	anObject isTuple ifTrue: [^ anObject size = 1 and: [self includes: anObject first]].
	^ anObject between: left and: right! !

!RealInterval methodsFor: 'testing' stamp: 'len 3/28/2018 18:05:25'!
includes: anObject
	anObject isTuple ifTrue: [^ anObject size = 1 and: [self includes: (anObject at: 1)]].
	(self left > anObject or: [self right < anObject])
		ifTrue: [^ false].
	(self left < anObject and: [self right > anObject])
		ifTrue: [^ true].
	((self isLeftClosed and: [anObject = self left])
	or: [self isRightClosed and: [anObject = self right]])
		ifTrue: [^ true].
	^ false! !

!RealInterval methodsFor: 'testing' stamp: 'len 6/4/2016 21:43'!
intersects: anInterval
	"Answer true if the receiver overlaps the argument."
	self right < anInterval left ifTrue: [^ false].
	self left > anInterval right ifTrue: [^ false].
	self right = anInterval left ifTrue: [^ self isRightClosed and: [anInterval isLeftClosed]].
	self left = anInterval right ifTrue: [^ self isLeftClosed and: [anInterval isRightClosed]].
	^ true! !

!RealInterval methodsFor: 'testing' stamp: 'len 12/13/97 03:29'!
isBounded
	"Answer true if the receiver is bounded."

	^ self isLeftBounded and: [self isRightBounded]! !

!RealInterval methodsFor: 'testing' stamp: 'len 12/13/97 02:36'!
isClosed
	"Answer true if the receiver is closed."

	^ self isLeftClosed and: [self isRightClosed]! !

!RealInterval methodsFor: 'testing' stamp: 'len 12/13/97 03:23'!
isEmpty
	"Answer true if the receiver is empty."

	^ self isLeftBounded
		ifTrue: [self right < self left]
		ifFalse: [self left > self right]! !

!RealInterval methodsFor: 'testing' stamp: 'len 6/2/2016 05:16'!
isFinite
	^ left = right and: [leftOpen not | rightOpen not]! !

!RealInterval methodsFor: 'testing' stamp: 'len 12/13/97 02:14'!
isHalfOpen
	"Answer true if the receiver is hald-open."

	^ self isClosed not and: [self isOpen not]! !

!RealInterval methodsFor: 'testing' stamp: 'len 12/13/97 02:23'!
isLeftBounded
	"Answer true if the receiver is left bounded."

	^ self left isInfinity not! !

!RealInterval methodsFor: 'testing' stamp: 'len 12/13/97 02:33'!
isLeftClosed
	"Answer true if the receiver is left closed."

	^ self isLeftOpen not! !

!RealInterval methodsFor: 'testing' stamp: 'len 12/13/97 02:36'!
isLeftOpen
	"Answer true if the receiver is left open."

	^ leftOpen! !

!RealInterval methodsFor: 'testing' stamp: 'len 12/13/97 02:38'!
isOpen
	"Answer true if the receiver is open."

	^ self isLeftOpen and: [self isRightOpen]! !

!RealInterval methodsFor: 'testing' stamp: 'len 12/13/97 02:24'!
isRightBounded
	"Answer true if the receiver is right bounded."

	^ self right isInfinity not! !

!RealInterval methodsFor: 'testing' stamp: 'len 12/13/97 02:35'!
isRightClosed
	"Answer true if the receiver is right closed."

	^ self isRightOpen not! !

!RealInterval methodsFor: 'testing' stamp: 'len 12/13/97 02:37'!
isRightOpen
	"Answer true if the receiver is open right."

	^ rightOpen! !

!RealInterval methodsFor: 'testing' stamp: 'len 12/13/97 03:23'!
sign
	"Answer 1 if the receiver is greater than 0, -1 if less than 0, else 0."

	self left > 0 ifTrue: [^ 1].
	self right < 0 ifTrue: [^ -1].
	^ 0! !

!RealInterval class methodsFor: 'instance creation' stamp: 'len 12/13/97 02:29'!
closed: left closed: right
	"Answer a new [left, right] interval."

	^ self new setLeftBound: left rightBound: right leftOpen: false rightOpen: false! !

!RealInterval class methodsFor: 'instance creation' stamp: 'len 12/13/97 02:30'!
closed: left open: right
	"Answer a new [left, right) interval."

	^ self new setLeftBound: left rightBound: right leftOpen: false rightOpen: true! !

!RealInterval class methodsFor: 'instance creation' stamp: 'len 12/13/97 02:30'!
open: left closed: right
	"Answer a new (left, right] interval."

	^ self new setLeftBound: left rightBound: right leftOpen: true rightOpen: false! !

!RealInterval class methodsFor: 'instance creation' stamp: 'len 12/13/97 02:30'!
open: left open: right
	"Answer a new (left, right) interval."

	^ self new setLeftBound: left rightBound: right leftOpen: true rightOpen: true! !

!RealRootIsolator methodsFor: 'accessing' stamp: 'len 11/18/97 00:38'!
fourier
	"Answer the Budan-Fourier sequence for the polynomial of the receiver."

	fourier isNil ifTrue: [self computeFourier].
	^ fourier! !

!RealRootIsolator methodsFor: 'accessing' stamp: 'len 4/24/2018 18:20:19'!
polynomial
	^ polynomial! !

!RealRootIsolator methodsFor: 'accessing' stamp: 'len 6/5/2016 04:47'!
roots
	"Answer a collection with the roots of the polynomial."
	roots isNil ifTrue: [self separateRoots].
	^ roots! !

!RealRootIsolator methodsFor: 'accessing' stamp: 'len 8/23/97 18:10'!
sturm
	"Answer a sturm sequence for the polynomial of the receiver."

	sturm isNil ifTrue: [self computeSturm].
	^ sturm! !

!RealRootIsolator methodsFor: 'couting roots' stamp: 'len 4/24/2018 17:59:22'!
lowerBoundNumberOfRootsBetween: leftBound and: rightBound
	"Answer a lower bound for the number of real roots in the open interval (leftBound, rightBound)."
	| answer last sign |
	answer _ 0.
	last _ 0.
	1 to: polynomial degree * 2 do: [:each|
		sign _ (polynomial value: (rightBound - leftBound) / each) sign.
		(last ~= sign and: [sign ~= 0]) ifTrue: [answer _ answer + 1].
		last _ sign].
	^ answer! !

!RealRootIsolator methodsFor: 'couting roots' stamp: 'len 1/16/2016 08:33'!
moreThanOneRootBetween: leftBound and: rightBound
	"Answer true if there are only one root in the interval (leftBound, rightBound]."

	| upper lower |
	sturm isNil "if the Sturm chain was not yet computed, first try some bounds and heuristics"
		ifTrue:
			[(upper _ self upperBoundNumberOfRootsBetween: leftBound and: rightBound) < 2
				ifTrue: [^ false].
			(upper even and: [self heuristicDetectOneRootBetween: leftBound and: rightBound])
				ifTrue: [^ true].
			lower _ self lowerBoundNumberOfRootsBetween: leftBound and: rightBound.
			lower > 1 ifTrue: [^ true].
			(upper even and: [lower > 0]) ifTrue: [^ true]].

	^ (self numberOfRootsBetween: leftBound and: rightBound) > 1! !

!RealRootIsolator methodsFor: 'couting roots' stamp: 'len 4/24/2018 17:59:16'!
numberOfNegativeRoots
	"Answer the number of negative roots."
	| fix |
	fix _ (polynomial value: 0) = 0 ifTrue: [1] ifFalse: [0].
	^ (self numberOfRootsBetween: self bigBounds min and: 0) - fix! !

!RealRootIsolator methodsFor: 'couting roots' stamp: 'len 1/15/2016 02:41'!
numberOfPositiveRoots
	"Answer the number of positive roots."
	^ self numberOfRootsBetween: 0 and: self bigBounds max! !

!RealRootIsolator methodsFor: 'couting roots' stamp: 'len 1/15/2016 02:41'!
numberOfRoots
	"Answer the number of real roots of the receiver."

	| interval |
	interval _ self bigBounds.
	^ self numberOfRootsBetween: interval min and: interval max! !

!RealRootIsolator methodsFor: 'couting roots' stamp: 'len 1/16/2016 08:03'!
numberOfRootsBetween: leftBound and: rightBound
	"Answer the number of real roots in the left open interval (leftBound, rightBound]."

	| leftSignChanges rightSignChanges a b |
	a _ leftBound asFraction.
	b _ rightBound asFraction.
	leftSignChanges _ 0.
	(self sturm collect: [ :each | (each value: a) sign])
		inject: 0 into: [ :lastSign :each |
			(lastSign ~= each and: [each ~= 0])
				ifTrue: [leftSignChanges _ leftSignChanges + 1].
			each].

	rightSignChanges _ 0.
	(self sturm collect: [ :each | (each value: b) sign])
		inject: 0 into: [ :lastSign :each |
			(lastSign ~= each and: [each ~= 0])
				ifTrue: [rightSignChanges _ rightSignChanges + 1].
			each].

	^ leftSignChanges - rightSignChanges! !

!RealRootIsolator methodsFor: 'couting roots' stamp: 'len 1/15/2016 02:42'!
upperBoundNumberOfRoots
	"Answer an upper bound for the number of real roots of the receiver."
	| interval |
	interval _ self bigBounds.
	^ self upperBoundNumberOfRootsBetween: interval min and: interval max! !

!RealRootIsolator methodsFor: 'couting roots' stamp: 'len 11/24/2015 06:10'!
upperBoundNumberOfRootsBetween: leftBound and: rightBound
	"Answer an upper bound for the number of real roots
	in the open interval (leftBound, rightBound)."

	| leftSignChanges rightSignChanges |

	leftSignChanges _ 0.
	(self fourier collect: [ :each | (each value: leftBound) sign])
		inject: 0 into: [ :lastSign :each |
			(lastSign ~= each and: [each ~= 0])
				ifTrue: [leftSignChanges _ leftSignChanges + 1].
			each].

	rightSignChanges _ 0.
	(self fourier collect: [ :each | (each value: rightBound) sign])
		inject: 0 into: [ :lastSign :each |
			(lastSign ~= each and: [each ~= 0])
				ifTrue: [rightSignChanges _ rightSignChanges + 1].
			each].

	^ leftSignChanges - rightSignChanges! !

!RealRootIsolator methodsFor: 'initialization' stamp: 'len 4/24/2018 18:02:05'!
polynomial: aPolynomial
	polynomial _ aPolynomial! !

!RealRootIsolator methodsFor: 'operations' stamp: 'len 4/29/2018 18:27:49'!
separateRoots
	"Separate the roots in intervals each of them including an isolated root."

	| bounds |
	roots _ SortedCollection sortBlock: [ :one :other | one left <= other left].
	bounds _ self bigBounds.
	self separateRootsBetween: bounds min and: bounds max! !

!RealRootIsolator methodsFor: 'operations' stamp: 'len 4/29/2018 18:28:56'!
separateRootsBetween: leftBound and: rightBound
	"Separate the roots in the real interval given by the arguments."
	| r mid |
	r _ self numberOfRootsBetween: leftBound and: rightBound.
	r = 0 ifTrue: [^ self].
	r = 1 ifTrue: [^ roots add: (RealInterval closed: leftBound closed: rightBound)].

	mid _ leftBound + rightBound / 2.0. "2 for exact rationals or 2.0 to use floats."
	self separateRootsBetween: leftBound and: mid.
	self separateRootsBetween: mid and: rightBound! !

!RealRootIsolator methodsFor: 'private' stamp: 'len 7/21/2019 08:52:22'!
bigBounds
	"Compute and answer a first estimate of an interval containing all the real roots."
	| bound |
	bound _ polynomial norm1 asFloat / polynomial leadingCoefficient asFloat.
	bound _ bound max: 1.0.
	^ RealInterval closed: bound negated closed: bound! !

!RealRootIsolator methodsFor: 'private' stamp: 'len 4/24/2018 17:59:04'!
computeFourier
	"Compute the Budan-Fourier sequence for the polynomial of the receiver."
	| f |
	f _ polynomial.
	fourier _ (OrderedCollection new: f degree + 1) add: f; yourself.
	f degree timesRepeat: [fourier add: (f _ f derivative)]! !

!RealRootIsolator methodsFor: 'private' stamp: 'len 4/24/2018 17:59:08'!
computeSturm
	"Compute a sturmian sequence for the receiver."
	| f g r |
	f _ polynomial.
	g _ f derivative.
	sturm _ (OrderedCollection new: f degree + 1) add: f; add: g; yourself.
	[g degree > 0]
		whileTrue:
			[r _ sturm add: (f \\ g) negated.
			f _ g.
			g _ r]! !

!RealRootIsolator methodsFor: 'private' stamp: 'len 4/24/2018 17:59:00'!
heuristicDetectOneRootBetween: leftBound and: rightBound
	| first |
	first _ polynomial value: leftBound.
	2 to: 10 do: [:each|
		first ~= (polynomial value: (rightBound - leftBound) / each) sign
			ifTrue: [^ true]].
	^ false! !

!RealRootIsolator class methodsFor: 'instance creation' stamp: 'len 4/24/2018 18:01:20'!
on: aPolynomial
	^ self new polynomial: aPolynomial! !

!DistributiveAlgebraElement methodsFor: 'accessing' stamp: 'len 7/19/2021 06:11:33'!
characteristicPolynomial
	^ self representation characteristicPolynomial! !

!DistributiveAlgebraElement methodsFor: 'accessing' stamp: 'len 7/24/2021 13:03:50'!
corepresentation
	"Answer the module endomorphism defined by right multiplication by the receiver."
	^ self parent asModule endomorphisms evaluating: [:x| (self parent !! x * self) asModuleElement]! !

!DistributiveAlgebraElement methodsFor: 'accessing' stamp: 'len 7/19/2021 06:12:38'!
minimalPolynomial
	^ self representation minimalPolynomial! !

!DistributiveAlgebraElement methodsFor: 'accessing' stamp: 'len 7/19/2021 06:12:47'!
norm
	^ self representation determinant
	
"alternatively:
	| f |
	f _ self minimalPolynomial.
	^ f independentCoefficient / f leadingCoefficient * (f degree even ifTrue: [1] ifFalse: [-1])"! !

!DistributiveAlgebraElement methodsFor: 'accessing' stamp: 'len 7/19/2021 06:12:52'!
parent
	^ parent! !

!DistributiveAlgebraElement methodsFor: 'accessing' stamp: 'len 7/24/2021 13:04:08'!
representation
	"Answer the module endomorphism defined by left multiplication by the receiver."
	^ representation ifNil: [representation _ self parent asModule endomorphisms evaluating: [:x| (self * (self parent !! x)) asModuleElement]]! !

!DistributiveAlgebraElement methodsFor: 'accessing' stamp: 'len 7/19/2021 06:13:26'!
trace
	^ self representation trace

"alternatively:
	| f |
	f _ self minimalPolynomial.
	^ (f coefficientAtDegree: f degree - 1) negated"! !

!DistributiveAlgebraElement methodsFor: 'comparing' stamp: 'len 7/19/2021 06:10:42'!
= anObject
	^ self class = anObject class and: [moduleElement = anObject asModuleElement]! !

!DistributiveAlgebraElement methodsFor: 'comparing' stamp: 'len 7/19/2021 06:11:38'!
hash
	^ moduleElement hash! !

!DistributiveAlgebraElement methodsFor: 'converting' stamp: 'len 7/19/2021 06:11:12'!
asModuleElement
	^ moduleElement! !

!DistributiveAlgebraElement methodsFor: 'operations' stamp: 'len 7/19/2021 06:10:18'!
* anElement
	(anElement isInteger or: [self parent scalars includes: anElement])
		ifTrue: [^ self class parent: parent moduleElement: moduleElement * anElement].
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #*].
	^ self class parent: parent moduleElement: (parent multiplication value: moduleElement value: anElement asModuleElement)! !

!DistributiveAlgebraElement methodsFor: 'operations' stamp: 'len 7/19/2021 06:10:28'!
+ anElement
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #+].
	^ self class parent: parent moduleElement: moduleElement + anElement asModuleElement! !

!DistributiveAlgebraElement methodsFor: 'operations' stamp: 'len 12/3/2021 16:03:47'!
\ anElement
	"Answer x such that ax = b, where a is self and b is anElement.
	Answer nil if there's no solution."
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #\].
	^ self parent !! ((self representation preimage: anElement asModuleElement) ifNil: [^ nil])! !

!DistributiveAlgebraElement methodsFor: 'operations' stamp: 'len 7/19/2021 06:12:42'!
negated
	^ self class parent: parent moduleElement: moduleElement negated! !

!DistributiveAlgebraElement methodsFor: 'operations' stamp: 'len 12/20/2021 13:05:57'!
opposite
	"Answer the receiver as an element of the opposite algebra."
	^ self parent opposite fromModuleElement: moduleElement! !

!DistributiveAlgebraElement methodsFor: 'testing' stamp: 'len 1/6/2022 09:27:00'!
isZerodivisor
	"Answer true if there exists a nonzero element that multiplied by the receiver is zero."
"	self parent isIntegralDomain ifTrue: [^ self isZero]."
	^ self representation determinant isZero and: [self isCommutative or: [self corepresentation determinant isZero]]! !

!DistributiveAlgebraElement methodsFor: 'private' stamp: 'len 7/19/2021 06:12:56'!
parent: anAlgebra moduleElement: anElement
	parent _ anAlgebra.
	moduleElement _ anElement! !

!DistributiveAlgebraElement class methodsFor: 'instance creation' stamp: 'len 7/19/2021 06:09:42'!
parent: anAlgebra moduleElement: anElement
	^ self new parent: anAlgebra moduleElement: anElement! !

!Octonion methodsFor: 'as yet unclassified' stamp: 'len 4/30/2021 12:47:05'!
 anOctonion
	"Answer the cross-product of the receiver with the argument."
	^ (self commutator: anOctonion) / 2! !

!Octonion methodsFor: 'as yet unclassified' stamp: 'len 4/30/2021 12:38:18'!
asScalar
	self isScalar ifFalse: [^ self error: 'not a scalar element'].
	^ moduleElement at: 1! !

!Octonion methodsFor: 'as yet unclassified' stamp: 'len 4/30/2021 12:38:48'!
conjugate
	"Answer the conjugate of the receiver, such that the reduced trace is the conjugate added to the receiver, and the reduced norm is the conjugate times the receiver."
	^ self class parent: parent moduleElement: (moduleElement withIndexCollect: [:each :i| i=1 ifTrue: [each] ifFalse: [each negated]])

"alternatively:
	^ self negated + self trace
"! !

!Octonion methodsFor: 'as yet unclassified' stamp: 'len 4/30/2021 12:43:29'!
imaginary
	"Answer the imaginary part of the receiver."
	^ self - self real! !

!Octonion methodsFor: 'as yet unclassified' stamp: 'len 4/30/2021 12:44:32'!
inverse
	^ self conjugate * self norm inverse! !

!Octonion methodsFor: 'as yet unclassified' stamp: 'len 4/30/2021 12:40:27'!
norm
	"Answer the reduced norm of the receiver."
	^ (self * self conjugate) asModuleElement at: 1! !

!Octonion methodsFor: 'as yet unclassified' stamp: 'len 4/30/2021 12:43:24'!
real
	"Answer the real part of the receiver."
	^ self parent one * (moduleElement at: 1)! !

!ComplexAlgebraicNumber methodsFor: 'printing' stamp: 'len 4/30/2018 00:27:26'!
printOn: aStream base: base
	| real imaginary isImaginary |
	minimalPolynomial degree = 2 ifTrue: [^ self printQuadraticOn: aStream base: base].
	self refineTo: self printPrecision.
	real _ approximation real asFloat roundTo: self printPrecision.
	imaginary _ approximation imaginary asFloat roundTo: self printPrecision.
	(isImaginary _ self isImaginary)
		ifFalse: [real printOn: aStream base: base].
	self isReal
		ifFalse:
			[isImaginary ifFalse: [aStream nextPutAll: (0 <= imaginary ifTrue: [' + '] ifFalse: [imaginary _ imaginary negated. ' - '])].
			imaginary printOn: aStream base: base.
			aStream nextPutAll: 'i' italic].
	aStream nextPutAll: '..'! !

!ComplexAlgebraicNumber methodsFor: 'printing' stamp: 'len 1/11/2018 21:07:33'!
printPrecision
"	self absoluteError < 1 ifTrue: [^ self absoluteError asFloat].
	^ 0.001"
	^ 0.00001! !

!ComplexAlgebraicNumber methodsFor: 'printing' stamp: 'len 1/9/2022 08:33:51'!
printQuadraticOn: aStream base: base
	| a b c discriminant z y x1 x2 sign |
	a _ (minimalPolynomial at: 2) asFraction.
	b _ (minimalPolynomial at: 1) asFraction.
	c _ (minimalPolynomial at: 0) asFraction.
	discriminant _ b squared - (4*a*c).
	z _ discriminant squarefreePart.
	y _ (discriminant / z) sqrt.
	x1 _ b negated + (discriminant negative ifTrue: [discriminant negated sqrt i] ifFalse: [discriminant sqrt]) / (2*a).
	x2 _ b negated - (discriminant negative ifTrue: [discriminant negated sqrt i] ifFalse: [discriminant sqrt]) / (2*a).
	(x1 - approximation) abs <= radius
		ifTrue: [sign _ ' + ']
		ifFalse: [(x2 - approximation) abs <= radius ifTrue: [sign _ ' - '. y _ y negated] ifFalse: [self halt]].
	b = 0 ifFalse:
		[b/(-2*a) printOn: aStream base: base.
		aStream nextPutAll: sign.
		y _ y abs].
	y negative ifTrue: [aStream nextPut: $-. y _ y abs].
	y/(2*a) = 1 ifFalse: [y/(2*a) printOn: aStream base: base].
	z abs = 1 ifFalse:
		[aStream nextPut: $.
		z abs printOn: aStream base: base].
	z negative ifTrue: [aStream nextPutAll: 'i' italic]! !

!ComplexAlgebraicNumber methodsFor: 'accessing' stamp: 'len 5/23/2020 09:31:47'!
conjugates
	"The conjugates of an algebraic number with minimal polynomial of degree n are all its n-th roots."
	^ (minimalPolynomial rootsIn: ) "copyWithout: self"! !

!ComplexAlgebraicNumber methodsFor: 'accessing' stamp: 'len 5/2/2018 16:37:43'!
degree
	^ minimalPolynomial degree! !

!ComplexAlgebraicNumber methodsFor: 'accessing' stamp: 'len 4/29/2018 18:46:05'!
denominator
	"The denominator of an algebraic number is the smallest positive integer that multiplied by the algebraic number is an algebraic integer."
	^ minimalPolynomial coefficients inject: 1 into: [:result :each| result lcm: each denominator]! !

!ComplexAlgebraicNumber methodsFor: 'accessing' stamp: 'len 5/2/2018 16:33:35'!
height
	^ self minimalPolynomial height! !

!ComplexAlgebraicNumber methodsFor: 'accessing' stamp: 'len 4/28/2018 07:07:34'!
minimalPolynomial
	^ minimalPolynomial! !

!ComplexAlgebraicNumber methodsFor: 'accessing' stamp: 'len 6/4/2016 21:18'!
one
	^ 1! !

!ComplexAlgebraicNumber methodsFor: 'accessing' stamp: 'len 6/4/2016 21:18'!
zero
	^ 0! !

!ComplexAlgebraicNumber methodsFor: 'accessing-private' stamp: 'len 1/15/2016 02:07'!
approximation: aNumber radius: anotherNumber
	approximation _ aNumber.
	radius _ anotherNumber! !

!ComplexAlgebraicNumber methodsFor: 'accessing-private' stamp: 'len 7/17/2019 10:53:56'!
minimalPolynomial: aPolynomial
	minimalPolynomial _ aPolynomial integerPrimitivePart "<- or should it be monic?"! !

!ComplexAlgebraicNumber methodsFor: 'approximating' stamp: 'len 6/5/2016 19:35'!
absoluteError
	^ radius! !

!ComplexAlgebraicNumber methodsFor: 'approximating' stamp: 'len 3/24/2018 21:01:14'!
approximation
	"Answre a rational or float current approximation of the receiver."
	^ approximation! !

!ComplexAlgebraicNumber methodsFor: 'approximating' stamp: 'len 6/5/2016 20:59'!
bounds
	"Answer a disk in the complex plane where the receiver is located, isolated from all other roots of its minimal polynomial."
	^ ComplexDisk center: approximation radius: radius! !

!ComplexAlgebraicNumber methodsFor: 'approximating' stamp: 'len 5/2/2018 16:47:24'!
refine
	| P Q P2 Q2 m x v c dx y v1 m1 |
	radius _ radius / 2.0.
	P _ minimalPolynomial. "should it be monic?"
	Q _ P.
	P2 _ P derivative.
	Q2 _ P2.
	x _ approximation.
	v _ Q value: x.
	m _ v norm2.
	c _ 0. dx _ v / (Q2 value: x).
	[dx abs >= radius]
		whileTrue:
			[y _ x - dx.
			v1 _ Q value: y.
			m1 _ v1 norm2.
			m1 < m
				ifTrue: [x _ y. v _ v1. m _ m1. c _ 0. dx _ v / (Q2 value: x)]
				ifFalse: [c _ c + 1. dx _ dx / 4. c > 20 ifTrue: [self error: 'failed']]].
	"Polish root:"
	2 timesRepeat: [x _ x - ((P value: x) / (P2 value: x))].
	approximation _ x! !

!ComplexAlgebraicNumber methodsFor: 'approximating' stamp: 'len 12/5/2017 20:05:25'!
refineTo: aNumber
	"Refine the receiver up to get an approximation error < aNumber."
	[self absoluteError > aNumber] whileTrue: [self refine]! !

!ComplexAlgebraicNumber methodsFor: 'approximating' stamp: 'len 3/24/2018 21:00:20'!
refineWith: aComplexAlgebraicNumber
	"Refine the rational interval approximation of either the receiver or the argument, depending on which is less precise at the moment."
	self relativeError > aComplexAlgebraicNumber relativeError
		ifTrue: [self refine]
		ifFalse: [aComplexAlgebraicNumber refine]! !

!ComplexAlgebraicNumber methodsFor: 'approximating' stamp: 'len 4/29/2018 20:17:35'!
relativeError
	"Answer the relative error in the current rational approximation."
	self isZero ifTrue: [^ 0].
	^ self absoluteError / self approximation abs! !

!ComplexAlgebraicNumber methodsFor: 'arithmetic' stamp: 'len 1/9/2022 08:33:39'!
* aNumber
	| isolator x r |
	aNumber class = self class
		ifFalse: [^ aNumber adaptToAlgebraic: self andSend: #*].
	aNumber isZero ifTrue: [^ aNumber].
	self isZero ifTrue: [^ self].
	isolator _ ComplexRootIsolator on: (minimalPolynomial zeroProduct: aNumber minimalPolynomial) squarefreePart.
	[x _ approximation * aNumber approximation.
	r _ self absoluteError * aNumber approximation norm2 + (approximation norm2 * aNumber absoluteError).
	isolator atMostOneRootAround: x radius: r]
		whileFalse:
			[self refineWith: aNumber].
	^ self class polynomial: isolator polynomial approximation: x radius: r! !

!ComplexAlgebraicNumber methodsFor: 'arithmetic' stamp: 'len 1/9/2022 08:33:47'!
+ aNumber
	| isolator x r |
	aNumber class = self class
		ifFalse: [^ aNumber adaptToAlgebraic: self andSend: #+].
	aNumber isZero ifTrue: [^ self].
	self isZero ifTrue: [^ aNumber].
	isolator _ ComplexRootIsolator on: (minimalPolynomial zeroAddition: aNumber minimalPolynomial) squarefreePart.
	[x _ approximation + aNumber approximation.
	r _ self absoluteError + aNumber absoluteError.
	isolator atMostOneRootAround: x radius: r]
		whileFalse:
			[self refineWith: aNumber].
	^ self class polynomial: isolator polynomial approximation: x radius: r! !

!ComplexAlgebraicNumber methodsFor: 'arithmetic' stamp: 'len 1/12/2016 03:38'!
- anObject
	^ self + anObject negated! !

!ComplexAlgebraicNumber methodsFor: 'arithmetic' stamp: 'len 5/9/2020 20:35:07'!
/ aNumber
	aNumber class = self class
		ifFalse: [^ aNumber adaptToAlgebraic: self andSend: #+].
	^ self * aNumber inverse! !

!ComplexAlgebraicNumber methodsFor: 'arithmetic' stamp: 'len 1/13/2016 04:01'!
i
	^ self * self class i! !

!ComplexAlgebraicNumber methodsFor: 'arithmetic' stamp: 'len 8/12/2019 11:02:07'!
inverse
	"Answer the multiplicative inverse of the receiver."
	| isolator x r |
	self isZero ifTrue: [^ ZeroDivide signal].
	isolator _ ComplexRootIsolator on: minimalPolynomial zeroReciprocal.
	[x _ approximation reciprocal.
	r _ self absoluteError / approximation norm2 * x norm2.
	isolator atMostOneRootAround: x radius: r]
		whileFalse:
			[self refine].
	^ self class minimalPolynomial: isolator polynomial approximation: x radius: r! !

!ComplexAlgebraicNumber methodsFor: 'arithmetic' stamp: 'len 4/28/2018 07:10:56'!
negated
	"Answer the additive inverse of the receiver."
	^ self class
		minimalPolynomial: minimalPolynomial zeroNegation
		approximation: approximation negated
		radius: radius! !

!ComplexAlgebraicNumber methodsFor: 'arithmetic' stamp: 'len 1/9/2022 08:33:55'!
squareRoot
	| isolator x r |
	self isZero ifTrue: [^ self].
	isolator _ ComplexRootIsolator on: minimalPolynomial zeroSquareRoot squarefreePart.
	[x _ approximation sqrt.
	r _ self absoluteError sqrt.
	isolator atMostOneRootAround: x radius: r]
		whileFalse:
			[self refine].
	^ self class polynomial: isolator polynomial approximation: x radius: r! !

!ComplexAlgebraicNumber methodsFor: 'arithmetic' stamp: 'len 5/4/2018 19:10:55'!
squared
	| x odd even |
	x _ minimalPolynomial parent x.
	odd _ minimalPolynomial odd.
	even _ minimalPolynomial even.
	^ self class
		polynomial: odd squared * x - even squared
		approximation: approximation squared
		radius: radius * approximation norm2 * 2! !

!ComplexAlgebraicNumber methodsFor: 'comparing' stamp: 'len 4/28/2018 16:48:28'!
= anObject
	self == anObject ifTrue: [^ true].
	anObject isNumber ifFalse: [^ false].
	anObject class = self class
		ifFalse: [^ anObject adaptToAlgebraic: self andSend: #=].
	^ minimalPolynomial = anObject minimalPolynomial and: [self bounds intersects: anObject bounds]! !

!ComplexAlgebraicNumber methodsFor: 'comparing' stamp: 'len 4/29/2018 20:09:45'!
hash
	^ minimalPolynomial hash! !

!ComplexAlgebraicNumber methodsFor: 'converting' stamp: 'len 1/13/2016 03:41'!
adaptToFloat: rcvr andSend: selector
	^ rcvr perform: selector with: self asFloat! !

!ComplexAlgebraicNumber methodsFor: 'converting' stamp: 'len 1/13/2016 03:42'!
adaptToFraction: rcvr andSend: selector
	^ (self class fromRational: rcvr) perform: selector with: self! !

!ComplexAlgebraicNumber methodsFor: 'converting' stamp: 'len 1/13/2016 03:42'!
adaptToInteger: rcvr andSend: selector
	^ (self class fromRational: rcvr) perform: selector with: self! !

!ComplexAlgebraicNumber methodsFor: 'converting' stamp: 'len 1/13/2016 03:59'!
asComplexFloat
	"Answer a Float approximation of the receiver."
	self refineTo: 0.000001.
	^ approximation asFloat! !

!ComplexAlgebraicNumber methodsFor: 'converting' stamp: 'len 6/4/2016 22:16'!
asFloat
	"Answer a Float approximation of the receiver."
	self refineTo: 0.000001.
	^ self approximation asFloat! !

!ComplexAlgebraicNumber methodsFor: 'converting' stamp: 'len 5/23/2020 09:33:01'!
asRational
	"Convert the receiver to Fraction or Integer."
	| alpha |
	radius = 0 ifTrue: [^ approximation]. "could be float!!"
	minimalPolynomial degree < 2
		ifTrue:
			[alpha _ minimalPolynomial independentCoefficient negated / minimalPolynomial leadingCoefficient.
			approximation _ alpha. radius _ 0.
			^ alpha].
	(minimalPolynomial rootsIn: )
		do: [:each|
			(each - approximation) abs < radius
				ifTrue: [approximation _ each. radius _ 0. ^ each]].
	self error: 'the number is irrational'! !

!ComplexAlgebraicNumber methodsFor: 'operations' stamp: 'len 4/30/2018 04:46:52'!
norm
	^ minimalPolynomial independentCoefficient / minimalPolynomial leadingCoefficient * (minimalPolynomial degree even ifTrue: [1] ifFalse: [-1])

"alternatively:
	^ self conjugates product"! !

!ComplexAlgebraicNumber methodsFor: 'operations' stamp: 'len 1/1/2022 09:27:54'!
trace
	"Answer the absolute trace of the receiver."
	^ (minimalPolynomial at: minimalPolynomial degree - 1) negated

"alternatively:
	^ self conjugates sum"! !

!ComplexAlgebraicNumber methodsFor: 'testing' stamp: 'len 1/13/2016 03:33'!
isAlgebraic
	^ true! !

!ComplexAlgebraicNumber methodsFor: 'testing' stamp: 'len 5/2/2018 17:16:29'!
isAlgebraicInteger
	"An algebraic number is an 'algebraic integer' if it's the root of a monic polynomial in Z[x], in particular if it's minimal polynomial has integer coefficients."
	^ minimalPolynomial isMonic "<- defining the minimal polynomial as integer primitive"

"alternatively, defining the minimal polynomial as monic:
	^ minimalPolynomial coefficients allSatisfy: [:each| each isInteger]
"! !

!ComplexAlgebraicNumber methodsFor: 'testing' stamp: 'len 4/29/2018 23:49:18'!
isImaginary
	^ approximation real abs < radius! !

!ComplexAlgebraicNumber methodsFor: 'testing' stamp: 'len 1/13/2016 03:33'!
isNumber
	^ true! !

!ComplexAlgebraicNumber methodsFor: 'testing' stamp: 'len 5/23/2020 09:33:01'!
isRational
	minimalPolynomial degree < 2 ifTrue: [^ true].
	radius = 0 ifTrue: [^ true].
	(minimalPolynomial rootsIn: )
		do: [:each|
			(each - approximation) abs < radius
				ifTrue: [approximation _ each. radius _ 0. ^ true]].
	^ false! !

!ComplexAlgebraicNumber methodsFor: 'testing' stamp: 'len 4/29/2018 23:49:23'!
isReal
	^ approximation imaginary abs < radius "and: [((RealRootIsolator on: minimalPolynomial) numberOfRootsBetween: approximation real - radius and: approximation real + radius) > 0]"! !

!ComplexAlgebraicNumber methodsFor: 'testing' stamp: 'len 4/28/2018 07:10:14'!
isZero
	^ approximation abs < radius and: [(minimalPolynomial value: 0) = 0]! !

!ComplexAlgebraicNumber class methodsFor: 'examples' stamp: 'len 5/23/2020 09:33:01'!
i
	| x |
	x _  polynomials x.
	^ self minimalPolynomial: x^2 + 1 approximation: 1 i radius: 0! !

!ComplexAlgebraicNumber class methodsFor: 'examples' stamp: 'len 5/23/2020 09:33:01'!
phi
	"Answer the Phidias number or Golden Ratio."
	| x |
	x _  polynomials x.
	^ self minimalPolynomial: x^2 - x - 1 approximation: 2.0 radius: 1! !

!ComplexAlgebraicNumber class methodsFor: 'examples' stamp: 'len 5/23/2020 09:33:01'!
sqrt2
	"Answer an instance of the receiver representing the square root of 2."

	^ self
		minimalPolynomial:  polynomials x squared - 2
 		approximation: 1.5
		radius: 0.1! !

!ComplexAlgebraicNumber class methodsFor: 'examples' stamp: 'len 5/23/2020 09:33:01'!
sqrt: anIntegerOrFraction
	"Answer a square root of the rational argument."
	^ self
		minimalPolynomial:  polynomials x squared - anIntegerOrFraction
 		approximation: (anIntegerOrFraction negative ifTrue: [anIntegerOrFraction negated sqrt i] ifFalse: [anIntegerOrFraction sqrt]) radius: 0.00001! !

!ComplexAlgebraicNumber class methodsFor: 'instance creation' stamp: 'len 1/15/2016 02:04'!
approximation: approximateValue radius: approximationError maxDegree: n
	"Answer an algebraic number with the given approximate value, approximation error, with minimal polynomial of degree at most n."
	^ self notYetImplemented! !

!ComplexAlgebraicNumber class methodsFor: 'instance creation' stamp: 'len 5/23/2020 09:33:01'!
fromRational: anIntegerOrFraction
	"Answer an instance of the receiver representing the rational number anIntegerOrFraction."
	| q x |
	q _ anIntegerOrFraction asFraction.
	x _  polynomials x.
	^ self
		minimalPolynomial: x * q denominator - q numerator
 		approximation: anIntegerOrFraction
		radius: 0! !

!ComplexAlgebraicNumber class methodsFor: 'instance creation' stamp: 'len 1/15/2016 02:05'!
minimalPolynomial: aPolynomial approximation: aComplex radius: aNumber
	^ self new
		minimalPolynomial: aPolynomial;
		approximation: aComplex radius: aNumber! !

!ComplexAlgebraicNumber class methodsFor: 'instance creation' stamp: 'len 8/5/2021 08:37:14'!
polynomial: aPolynomial approximation: aComplex radius: aNumber
	| minimalPolynomial |
	minimalPolynomial _ aPolynomial factorization detectMin: [:f| (f value: aComplex) abs].
	minimalPolynomial degree = 1 ifTrue: [^ minimalPolynomial independentCoefficient negated / minimalPolynomial leadingCoefficient].
	^ self minimalPolynomial: minimalPolynomial approximation: aComplex radius: aNumber! !

!SchemePoint methodsFor: 'as yet unclassified' stamp: 'len 12/21/2021 20:12:41'!
ideal: anIdeal
	ideal _ anIdeal! !

!SchemePoint methodsFor: 'as yet unclassified' stamp: 'len 12/21/2021 20:12:18'!
parent: aScheme
	^ parent _ aScheme! !

!CRT methodsFor: 'computing' stamp: 'len 5/14/2020 12:28:51'!
solve: remainders
	| k mj y yj x |
	k _ moduli size.
	y _ Array new: k.
	y at: 1 put: (remainders at: 1) \\ (moduli at: 1).
	2 to: k do: [:j|
		mj _ moduli at: j.
		yj _ y at: j-1.
		j-2 to: 1 by: -1 do: [:i| yj _ yj * (moduli at: i) + (y at: i) \\ mj].
		yj _ ((remainders at: j) - yj) * (C at: j) \\ mj.
		y at: j put: yj].
	x _ y at: k.
	k-1 to: 1 by: -1 do: [:i| x _ x * (moduli at: i) + (y at: i)].
	"it would be more correct to return the residue class mod m1*m2*..*mk"
	^ x! !

!CRT methodsFor: 'initialization' stamp: 'len 5/14/2020 12:28:03'!
moduli: anArray
	| one k mj p euclid |
	moduli _ anArray.
	"Precomputations:"
	one _ moduli first one.
	k _ moduli size.
	C _ Array new: k.
	C at: 1 put: one.
	2 to: k do: [:j|
		| u |
		mj _ moduli at: j.
		p _ one. 1 to: j-1 do: [:i| p _ p * (moduli at: i) \\ mj].
		euclid _ p xgcd: mj.
		(euclid at: 1) ~= one ifTrue: [^ self error: 'the moduli are not coprime'].
		p * (u _ euclid at: 2) + (mj * (euclid at: 3)) = one ifFalse: [self error: 'failed'].
		C at: j put: u]! !

!CRT class methodsFor: 'instance creation' stamp: 'len 4/14/2021 05:58:38'!
moduli: anArray
	^ self new moduli: anArray! !

!CRT class methodsFor: 'instance creation' stamp: 'len 5/9/2020 13:55:54'!
solve: aCollection
	| x m |
	x _ aCollection first.
	m _ x modulus.
	aCollection allButFirstDo: [:each| | xi mi euclid |
		xi _ each.
		mi _ xi modulus.
		euclid _ m xgcd: mi.
		x _ (euclid at: 2) * m * xi representative + ((euclid at: 3) * mi * x representative).
		m _ m*mi.
		x _ x % m].
	^ x! !

!DFT methodsFor: 'as yet unclassified' stamp: 'len 6/1/2020 13:11:17'!
value: aTuple
	^ ring^n filling: [:k| (1 to: n) sum: [:j| (aTuple at: j) * (alpha ^ (j*k))]]! !

!ExtendedEuclid methodsFor: 'accessing' stamp: 'len 4/18/2018 06:26:17'!
bezout
	"Answer a tuple of Bezout coefficients for the receiver."
	bezout isNil ifTrue: [self run].
	^ bezout! !

!ExtendedEuclid methodsFor: 'accessing' stamp: 'len 12/23/2015 19:49'!
gcd
	gcd isNil ifTrue: [self run].
	^ gcd! !

!ExtendedEuclid methodsFor: 'accessing-private' stamp: 'len 12/23/2015 20:09'!
elements: anArray
	elements _ anArray! !

!ExtendedEuclid methodsFor: 'private' stamp: 'len 7/30/2021 10:43:43'!
run
	| a b zero one s1 t1 s t r1 r u |
	self assert: elements size = 2.
	a _ elements first. b _ elements second.
	zero _ a zero. one _ a one.
	s1 _ zero. s _ one.
	t1 _ one. t _ zero.
	r1 _ a normalized.
	r _ b normalized.
	[r1 isZero]
		whileFalse:
			[ | q temp |
			q _ r // r1.
			temp _ r1. r1 _ r - (q * r1). r _ temp.
			temp _ s1. s1 _ s - (q * s1). s _ temp.
			temp _ t1. t1 _ t - (q * t1). t _ temp].
	gcd _ r.
	s _ s * b normalization. t _ t * a normalization.
	u _ gcd normalization.
	s _ s * u. t _ t * u. gcd _ gcd * u.
	bezout _ {t. s}! !

!ExtendedEuclid methodsFor: 'private' stamp: 'len 4/18/2018 06:23:25'!
verify
	^ (elements * self bezout) sum = self gcd! !

!ExtendedEuclid methodsFor: 'private' stamp: 'len 4/18/2018 06:23:35'!
verify2
	| a b d u v |
	a _ elements at: 1.
	b _ elements at: 2.
	u _ self bezout at: 1.
	v _ self bezout at: 2.
	d _ self gcd.
	(a abs negated / d < (v * b sign) and: [v * b sign <= 0])
		ifFalse: [^ false].
	b = 0 ifTrue: [^ true].
	(1 <= (u * a sign) and: [u * a sign <= (b abs / d)])
		ifFalse: [^ false].
	^ true! !

!ExtendedEuclid methodsFor: 'private' stamp: 'len 4/18/2018 06:23:44'!
verifyMinimal
	| a b d u v |
	(elements allSatisfy: [:each| each isInteger]) ifFalse: [^ true].
	a _ elements first.
	b _ elements second.
	d _ self gcd.
	u _ self bezout first.
	v _ self bezout last.
	a abs / d negated < (v * b sign) ifFalse: [^ false].
	v * b sign <= 0 ifFalse: [^ false].
	1 <= (u * a sign) ifFalse: [^ false].
	u * a sign <= (b abs / d) ifFalse: [^ false].
	^ true! !

!ExtendedEuclid class methodsFor: 'instance creation' stamp: 'len 12/23/2015 20:09'!
on: anArray
	^ self new elements: anArray! !

!LagrangeGaussReduction methodsFor: 'as yet unclassified' stamp: 'len 12/12/2015 21:55'!
computeShortVector
	| innerProduct a b A B t T n r |
	innerProduct _ vectorSpace innerProduct. "Euclidean inner product"

	"Initialization:"
	a _ v1. b _ v2.
	A _ innerProduct value: {a. a}.
	B _ innerProduct value: {b. b}.
	A < B ifTrue: [b _ v1. a _ v2. t _ A. A _ B. B _ t].
	
	["Euclidean step:"
	n _ innerProduct value: {a. b}.
	r _ (n/B) rounded. "nearest integer"
	T _ A - (2*r*n) + (r*r*B).
	T >= B]
		whileFalse:
			[t _ a - (r*b).
			a _ b.
			b _ t.
			A _ B.
			B _ T].
	
	shortVector _ b! !

!LagrangeGaussReduction methodsFor: 'as yet unclassified' stamp: 'len 12/12/2015 21:55'!
shortVector
	shortVector isNil ifTrue: [self computeShortVector].
	^ shortVector! !

!ModifiedBerlekampMassey methodsFor: 'accessing' stamp: 'len 11/29/2015 16:02'!
field: aField
	field _ aField! !

!ModifiedBerlekampMassey methodsFor: 'accessing' stamp: 'len 12/27/2015 05:01'!
input: anArray
	input _ anArray.
	minimalPolynomial _ nil! !

!ModifiedBerlekampMassey methodsFor: 'accessing' stamp: 'len 12/27/2015 04:59'!
minimalPolynomial
	minimalPolynomial isNil ifTrue: [self run].
	^ minimalPolynomial! !

!ModifiedBerlekampMassey methodsFor: 'private' stamp: 'len 4/24/2018 19:38:22'!
run
	"Modified Berlekamp-Massey from 'The Berlekamp-Massey Algorithm revisited', Nadie Ben Atti, Gema M Diaz-Toca, Henri Lombardi."
	| Fx x R0 R1 V V0 V1 n m |
	n _ input size // 2.
	m _ 2*n - 1.
	Fx _ field polynomials.
	x _ Fx x.
	R0 _ x^(2*n). R1 _ (0 to: m) sum: [:i| x^i*(input at: m-i+1)].
	V0 _ Fx zero. V1 _ Fx one.
	[n <= R1 degree]
		whileTrue:
			[ | division |
			division _ R0 divisionBy: R1.
			V _ V0 - (division quotient * V1).
			V0 _ V1. V1 _ V. R0 _ R1. R1 _ division remainder].
	minimalPolynomial _ V1 / V1 leadingCoefficient! !

!NTT methodsFor: 'accessing' stamp: 'len 4/25/2016 00:28'!
modulus
	^ modulus! !

!NTT methodsFor: 'accessing' stamp: 'len 3/23/2016 21:06'!
primitive
	^ primitive! !

!NTT methodsFor: 'initialization' stamp: 'len 4/25/2016 00:29'!
modulus: anInteger
	self modulus: anInteger primitive: anInteger primitiveRoot! !

!NTT methodsFor: 'initialization' stamp: 'len 4/25/2016 00:29'!
modulus: anInteger primitive: anotherInteger
	modulus _ anInteger.
	primitive _ anotherInteger! !

!NTT methodsFor: 'running' stamp: 'len 5/13/2019 16:17:03'!
inverseValue: input
	"naive algorithm, O(n^2)"
	^ (1 to: input size) collect: [:i| ((1 to: input size) sum: [:j| (primitive negated raisedTo: i*j modulo: modulus) * (input at: j) \\ modulus]) \\ modulus]! !

!NTT methodsFor: 'running' stamp: 'len 5/13/2019 16:17:08'!
value: input
	"naive algorithm, O(n^2)"
	^ (1 to: input size) collect: [:i| ((1 to: input size) sum: [:j| (primitive raisedTo: i*j modulo: modulus) * (input at: j) \\ modulus]) \\ modulus]! !

!NTT class methodsFor: 'instance creation' stamp: 'len 4/25/2016 00:30'!
modulo: anInteger
	"anInteger must be prime"
	^ self new modulus: anInteger! !

!TonelliShanks methodsFor: 'as yet unclassified' stamp: 'len 7/8/2019 04:16:30'!
modulus: anInteger
	| n |
	anInteger == 2 ifTrue: [self error: 'modulus must be odd'].
	p _ anInteger.
	e _ (p - 1) lowBit - 1.
	q _ p - 1 bitShift: e negated.
	"find generator of the multiplicative group of units (Z/pZ)*"
	[n _ (p - 1) atRandom.
	(n kronecker: p) == -1] whileFalse.
	z _ n raisedTo: q modulo: p.! !

!TonelliShanks methodsFor: 'as yet unclassified' stamp: 'len 3/6/2017 17:04:50'!
squareRootOf: anInteger
	| a y r x b m b2 t |
	anInteger == 0 ifTrue: [^ anInteger].
	a _ anInteger.
	y _ z. r _ e. x _ a raisedTo: q-1 // 2 modulo: p. b _ a*x squared \\ p. x _ a*x \\ p.
	[b == 1 ifTrue: [^ x].
	b2 _ b. m _ 1. [(b2 _ b2 squared \\ p) == 1] whileFalse: [m _ m + 1].
	(b raisedTo: (2 ^ m) modulo: p) == 1 ifFalse: [self halt].
	(m > 1 and: [(b raisedTo: (2 ^ (m-1)) modulo: p) == 1]) ifTrue: [self halt].
	m = r ifTrue: [^ nil]. "the input is not a quadratic residue modulo p"
	t _ y. r - m - 1 timesRepeat: [t _ t squared \\ p]. "t _ y ^ (2 ^ (r - m - 1)) mod p"
	y _ t squared \\ p. r _ m. x _ x * t \\ p. b _ b * y \\ p] repeat! !

!DirichletSeries methodsFor: 'accessing' stamp: 'len 12/28/2015 19:26'!
coefficients
	^ coefficients! !

!DirichletSeries methodsFor: 'accessing' stamp: 'len 12/28/2015 19:26'!
coefficients: aSequence
	coefficients _ aSequence! !

!DirichletSeries methodsFor: 'accessing' stamp: 'len 12/28/2015 19:26'!
indeterminate
	^ 1! !

!DirichletSeries methodsFor: 'accessing' stamp: 'len 12/28/2015 19:26'!
scalars
	^ coefficients codomain! !

!DirichletSeries methodsFor: 'arithmetic' stamp: 'len 12/28/2015 19:28'!
* anObject
	(self scalars includes: anObject)
		ifTrue: [^ self class coefficients: coefficients * anObject].
	(anObject isKindOf: self class)
		ifTrue: [^ self class coefficients: (coefficients dirichlet: anObject coefficients)].
	^ DomainError signal! !

!DirichletSeries methodsFor: 'arithmetic' stamp: 'len 12/28/2015 19:29'!
+ anObject
	^ self class coefficients: coefficients + anObject coefficients! !

!DirichletSeries methodsFor: 'arithmetic' stamp: 'len 12/28/2015 19:29'!
- anObject
	^ self + anObject negated! !

!DirichletSeries methodsFor: 'arithmetic' stamp: 'len 12/28/2015 19:30'!
/ anObject
	^ self * anObject reciprocal! !

!DirichletSeries methodsFor: 'arithmetic' stamp: 'len 12/28/2015 19:30'!
negated
	^ self class coefficients: coefficients negated! !

!DirichletSeries methodsFor: 'arithmetic' stamp: 'len 12/28/2015 19:30'!
squared
	^ self * self! !

!DirichletSeries methodsFor: 'comparing' stamp: 'len 12/28/2015 19:46'!
= anObject
	^ (anObject isKindOf: DirichletSeries) and: [self coefficients = anObject coefficients]! !

!DirichletSeries methodsFor: 'comparing' stamp: 'len 12/28/2015 19:46'!
hash
	^ coefficients hash! !

!DirichletSeries methodsFor: 'operations' stamp: 'len 6/4/2019 05:32:07'!
value: aNumber upTo: n
	| answer |
	answer _ aNumber zero.
	1 to: n do: [:i|
		| c |
		c _ coefficients at: i.
		answer _ answer + (c / (i ^ aNumber))].
	^ answer! !

!DirichletSeries class methodsFor: 'examples' stamp: 'len 10/31/2016 04:14'!
zeta
	^ self coefficients: (CFiniteSequence constant: 1)! !

!DirichletSeries class methodsFor: 'instance creation' stamp: 'len 12/28/2015 19:54'!
coefficients: aSequence
	^ self new coefficients: aSequence! !

!YoungDiagram methodsFor: 'as yet unclassified' stamp: 'len 2/21/2017 18:40:23'!
conjugate
	"Answer the Young diagram of the conjugate partition."
	^ self class shape: ((1 to: shape size) collect: [:k| shape findLast: [:i| i >= k]])! !

!YoungDiagram methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 03:17'!
hookLengthAt: aPoint
	| answer |
	answer _ (shape at: aPoint x) - aPoint y. "boxes to the right"
	aPoint x + 1 to: shape size do: [:i|
		(shape at: i) >= aPoint y
			ifFalse: [^ answer].
		answer _ answer + 1].
	^ answer! !

!YoungDiagram methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 03:12'!
shape
	^ shape! !

!YoungDiagram methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 03:12'!
shape: aPartition
	shape _ aPartition! !

!YoungDiagram class methodsFor: 'instance creation' stamp: 'len 8/1/2016 03:13'!
shape: aPartition
	^ self new shape: aPartition! !

!WeierstrassEquation methodsFor: 'accessing' stamp: 'len 11/9/2016 13:01'!
curve
	^ EllipticCurve equation: self! !

!WeierstrassEquation methodsFor: 'accessing' stamp: 'len 5/23/2018 22:35:52'!
homogeneousPolynomial
	^ (self scalars polynomialsIn: #(x y z)) !! self polynomial homogenizedIn: 3! !

!WeierstrassEquation methodsFor: 'accessing' stamp: 'len 8/8/2019 05:00:57'!
polynomial
	^ (self scalars polynomialsIn: #(x y))
		!! [:x :y| y^2 + (x*y * self a1) + (y * self a3) - (x^3) - (x^2 * self a2) - (x * self a4) - self a6]! !

!WeierstrassEquation methodsFor: 'accessing' stamp: 'len 11/9/2016 07:16'!
scalars
	^ coefficients scalars! !

!WeierstrassEquation methodsFor: 'accessing-private' stamp: 'len 11/9/2016 07:08'!
coefficients: aTuple
	coefficients _ aTuple! !

!WeierstrassEquation methodsFor: 'converting' stamp: 'len 1/20/2017 09:36:51'!
over: aRing
	^ self class coefficients: (coefficients over: aRing)! !

!WeierstrassEquation methodsFor: 'invariants' stamp: 'len 11/9/2016 07:08'!
a1
	^ coefficients at: 1! !

!WeierstrassEquation methodsFor: 'invariants' stamp: 'len 11/9/2016 07:08'!
a2
	^ coefficients at: 2! !

!WeierstrassEquation methodsFor: 'invariants' stamp: 'len 11/9/2016 07:08'!
a3
	^ coefficients at: 3! !

!WeierstrassEquation methodsFor: 'invariants' stamp: 'len 11/9/2016 07:08'!
a4
	^ coefficients at: 4! !

!WeierstrassEquation methodsFor: 'invariants' stamp: 'len 11/9/2016 07:08'!
a6
	^ coefficients at: 5! !

!WeierstrassEquation methodsFor: 'invariants' stamp: 'len 11/11/2016 10:16'!
b2
	^ self a1 squared + (self a2 * 4) "NOTE: this is wrong in Silverman 'The Arithmetic Of Elliptic Curves'"! !

!WeierstrassEquation methodsFor: 'invariants' stamp: 'len 11/9/2016 07:23'!
b4
	^ self a4 * 2 + (self a1 * self a3)! !

!WeierstrassEquation methodsFor: 'invariants' stamp: 'len 11/9/2016 07:23'!
b6
	^ self a3 squared + (self a6 * 4)! !

!WeierstrassEquation methodsFor: 'invariants' stamp: 'len 11/9/2016 07:24'!
b8
	^ self a1 squared * self a6 + (self a2 * self a6 * 4) - (self a1 * self a3 * self a4) + (self a2 * self a3 squared) - self a4 squared! !

!WeierstrassEquation methodsFor: 'invariants' stamp: 'len 11/9/2016 07:25'!
c4
	^ self b2 squared - (self b4 * 24)! !

!WeierstrassEquation methodsFor: 'invariants' stamp: 'len 11/9/2016 07:26'!
c6
	^ (self b2 ^ 3) negated + (self b2 * self b4 * 36) - (self b6 * 216)! !

!WeierstrassEquation methodsFor: 'invariants' stamp: 'len 11/9/2016 07:27'!
discriminant
	^ (self b2 squared * self b8) negated - (self b4 ^ 3 * 8) - (self b6 squared * 27) + (self b2 * self b4 * self b6 * 9)! !

!WeierstrassEquation methodsFor: 'invariants' stamp: 'len 11/9/2016 07:28'!
j
	^ self c4 ^ 3 / self discriminant! !

!WeierstrassEquation class methodsFor: 'instance creation' stamp: 'len 11/9/2016 07:08'!
coefficients: aTuple
	^ self new coefficients: aTuple! !

!BerlekampMassey methodsFor: 'as yet unclassified' stamp: 'len 1/1/2022 09:33:44'!
run
	| F Fx x C L N m B d b s |
	x _ Fx x.
	C _ Fx one.
	L _ 0. "current number of errors"
	N _ 100. "total number of syndromes"
	B _ C.
	b _ F one. "copy of the last discrepancy d"
	m _ 1. "number of iterations since last update"
	0 to: N do: [:n|
		"calculate discrepancy:"
		d _ (s at: n) + ((1 to: L) sum: [:i| (C at: i) * (s at: n-i)]).
		d = 0
			ifTrue: [m _ m + 1]
			ifFalse: [2*L <= n
				ifTrue:
					[|t|
					t _ C.
					C _ C - ((x^m)*(d/b)*B).
					B _ t.
					L _ n + 1 - L.
					b _ d.
					m _ 1]
				ifFalse:
					[C _ C - ((x^m)*(d/b)*B).
					m _ m + 1]]].
	^ L! !

!ExtendedSmithReduction methodsFor: 'as yet unclassified' stamp: 'len 5/5/2019 12:43:36'!
matrix
	^ matrix! !

!ExtendedSmithReduction methodsFor: 'as yet unclassified' stamp: 'len 5/5/2019 12:44:19'!
matrix: aMatrix
	matrix _ aMatrix! !

!ExtendedSmithReduction methodsFor: 'as yet unclassified' stamp: 'len 1/9/2022 09:43:10'!
reduceStep: i mod: D
	| j c euclid B Ai Aj |
	"2. Initialize j for row reduction:"
	[j _ i-1. c _ 0.
	"3. Check zero:"
	[[j >= 1 and: [(S at: i@j) isZero]] whileTrue: [j _ j - 1].
	j >= 1]
		whileTrue: "4. Euclidean step:"
			[euclid _ ExtendedEuclid on: {S at: i@i. S at: i@j}.
"			euclid verifyMinimal ifFalse: [self halt]."
			B _ (Ai _ S columnAt: i) * euclid bezout first + ((Aj _ S columnAt: j) * euclid bezout second).
			S columnAt: j put: Aj * ((S at: i@i) // euclid gcd) - (Ai * ((S at: i@j) // euclid gcd)) \\ D.
			S columnAt: i put: B \\ D.
			j _ j - 1].
	"5. Initialize j for column reduction:"
	j _ i-1.
	"6. Check zero (find pivot):"
	[[j >= 1 and: [(S at: j@i) isZero]] whileTrue: [j _ j - 1].
	j >= 1]
		whileTrue: "7. Euclidean step:"
			[euclid _ ExtendedEuclid on: {S at: i@i. S at: j@i}.
"			euclid verifyMinimal ifFalse: [self halt]."
			B _ (Ai _ S rowAt: i) * euclid bezout first + ((Aj _ S rowAt: j) * euclid bezout second).
			S rowAt: j put: Aj * ((S at: i@i) // euclid gcd) - (Ai * ((S at: j@i) // euclid gcd)) \\ D.
			S rowAt: i put: B \\ D.
			j _ j - 1.
			c _ c + 1].
	c > 0] whileTrue "8. Repeat stage i?"! !

!ExtendedSmithReduction methodsFor: 'as yet unclassified' stamp: 'len 1/9/2022 09:42:05'!
run
	| n i D b k |
	n _ matrix height.
	L _ matrix codomain id.
	R _ matrix domain id.
	S _ matrix copy.
	elementaryDivisors _ OrderedCollection new: n.
	"1. Initialize i:"
	i _ n.
	D _ S determinant normalized.
	n = 1 ifTrue: [^ self].
	"2-9. Reduction:"
	[[self reduceStep: i mod: D.
	"9. Check the rest of the matrix:"
	b _ S at: i@i.
	k _ (1 to: i-1) detect: [:k0| ((1 to: i-1) allSatisfy: [:l| b | (S at: k0@l)]) not] ifNone: [].
	k isNil]
		whileFalse:
			[S rowAt: i put: (S rowAt: i) + (S rowAt: k).
			L rowAt: i put: (L rowAt: i) + (L rowAt: k)].
	"10. Next stage:"
	elementaryDivisors add: ((S at: i@i) gcd: D).
	D _ D // elementaryDivisors last.
	i = 2]
		whileFalse: [i _ i - 1].
	elementaryDivisors add: ((S at: 1@1) gcd: D).
	^ {L. S. R}! !

!ModularHermiteReduction methodsFor: 'as yet unclassified' stamp: 'len 4/5/2018 15:36:20'!
addColumn: a to: B
	^ (B columnAugmented: a) HNF columnAt: B width + 1! !

!ModularHermiteReduction methodsFor: 'as yet unclassified' stamp: 'len 4/5/2018 15:36:28'!
addRow: b to: H
	| H0 |
	H0 _ H isSquare
		ifTrue: [H]
		ifFalse:
			[H rowAugmented: (H scalars ^ (H width - 1) :: zero, (H rowAugmented: b) determinant)].
	"..."! !

!ModularHermiteReduction methodsFor: 'as yet unclassified' stamp: 'len 7/16/2016 01:28'!
matrix: aMatrix
	matrix _ aMatrix! !

!ModularHermiteReduction methodsFor: 'as yet unclassified' stamp: 'len 4/12/2021 12:37:29'!
probablePivotsOf: aMatrix
	^ aMatrix % (10007 to: 46000) atRandom nextPrime :: echelon pivots
! !

!ModularHermiteReduction methodsFor: 'as yet unclassified' stamp: 'len 7/16/2016 04:35'!
run
"
	HNF _ matrix zero.
	HNF at: 1@1 put: (matrix at: 1@1).
	2 to: matrix numberOfColumns do: [:j|
		a _ matrix columnAt: j.
		x _ self addColumn: a.
		HNF _ addRow: a to: HNF | x
"! !

!MultivariateReducer methodsFor: 'as yet unclassified' stamp: 'len 1/14/2022 11:24:18'!
divide: anElement
	"Perform the division algorithm computing quotients, remainder and a unit."
	^ self notYetImplemented! !

!MultivariateReducer methodsFor: 'as yet unclassified' stamp: 'len 1/14/2022 11:25:02'!
divisors: anArray
	divisors _ anArray! !

!MultivariateReducer methodsFor: 'as yet unclassified' stamp: 'len 1/14/2022 11:18:30'!
reduce: anElement 
	"Answer Mora's normal form of anElement."
	| h L lh g ecartg |
	h _ anElement.
	L _ OrderedCollection withAll: divisors.
	[h isZero ifTrue: [^ h].
	lh _ h leadingMonomial.
	g _ nil.
	ecartg _ -1.
	L do: [:each|
		| ecart |
		(each leadingMonomial | lh and: [ecart _ each ecart. g isNil or: [ecart < ecartg]])
			ifTrue: [g _ each. ecartg _ ecart]].
	g isNil ifTrue: [^ h].
	ecartg > h ecart ifTrue: [L add: h].
	h _ h + (g * (lh / g leadingMonomial) * (h leadingCoefficient negated / g leadingCoefficient))] repeat! !

!MultivariateReducer methodsFor: 'as yet unclassified' stamp: 'len 1/14/2022 11:18:57'!
reduceFull: anElement
	^ self reduce: anElement! !

!MultivariateReducer methodsFor: 'as yet unclassified' stamp: 'len 1/14/2022 11:19:20'!
reduces: anElement
	^ (self reduce: anElement) isZero! !

!MultivariateReducer class methodsFor: 'as yet unclassified' stamp: 'len 1/14/2022 11:25:16'!
divisors: anArray
	^ self new divisors: anArray! !

!GlobalMultivariateReducer methodsFor: 'as yet unclassified' stamp: 'len 1/14/2022 11:23:36'!
divide: anElement
	"Perform the division algorithm computing quotients and remainder."
	| R quotients remainder p s fi q head i |
	R _ anElement isTuple ifTrue: [anElement scalars] ifFalse: [anElement parent].
	quotients _ Array new: divisors size withAll: R zero.
	divisors isEmpty ifTrue: [remainder _ anElement. ^ self].
	remainder _ anElement zero.
	s _ divisors size.
	p _ anElement.
	[p isZero] whileFalse:
		[head _ p leadingMonomial.
		i _ 1.
		[(fi _ divisors at: i) leadingMonomial | head or: [(i _ i + 1) > s]] whileFalse.
		i <= s "i.e. found fi with leading monomial dividing head"
			ifTrue:
				[q _ R coefficient: p leadingCoefficient / fi leadingCoefficient monomial: head / fi leadingMonomial.
				quotients at: i put: (quotients at: i) + q.
				p _ p + (fi * q negated)]
			ifFalse:
				[remainder _ remainder + p leadingTerm.
				p _ p tail]].
	^ {quotients. remainder}! !

!GlobalMultivariateReducer methodsFor: 'as yet unclassified' stamp: 'len 1/14/2022 11:23:11'!
reduce: anElement
	"Answer a top-reduced normal form of anElement (without doing tail reduction)."
	| h |
	divisors isEmpty ifTrue: [^ anElement].
	h _ anElement.
	[h isZero]
		whileFalse:
			[| lh lg g |
			lh _ h leadingMonomial.
			g _ divisors detect: [:one| (lg _ one leadingMonomial) | lh] ifNone: [^ h].
			h _ h + (g * (lh / lg) * (h leadingCoefficient negated / g leadingCoefficient))].
	^ h! !

!GlobalMultivariateReducer methodsFor: 'as yet unclassified' stamp: 'len 1/14/2022 11:22:49'!
reduceFull: anElement
	"Answer the tail-reduced normal form of anElement (doing full tail reduction)."
	| g h |
	g _ anElement.
	h _ g zero.
	[g isZero]
		whileFalse:
			[g _ self reduce: g.
			g isZero ifFalse: [h _ h + g leadingTerm. g _ g tail]].
	^ h normalized! !

!OEIS methodsFor: 'as yet unclassified' stamp: 'len 4/27/2016 07:02'!
initialize
	entries _ OrderedCollection new.
	'oeis.txt' asFileEntry readStream: [:aStream|
		[aStream atEnd]
			whileFalse:
				[| line |
				line _ aStream nextLine.
				line first = $#
					ifFalse:
						[| name tokens |
						tokens _ line findTokens: ','.
						name _ tokens first allButLast.
						entries add: name -> (tokens allButFirst collect: [:each| each asInteger]) asArray]]].
	entries _ entries asArray sort: [:a :b| a value size >= b value size]! !

!OEIS methodsFor: 'as yet unclassified' stamp: 'len 4/27/2016 07:02'!
longestEntrySize
	^ entries first value size! !

!OEIS methodsFor: 'as yet unclassified' stamp: 'len 4/20/2016 21:41'!
lookup2: anArray
	'oeis.txt' asFileEntry readStream: [:aStream|
		[aStream atEnd]
			whileFalse:
				[| line |
				line _ aStream nextLine.
				line first = $#
					ifFalse:
						[| name tokens |
						tokens _ line findTokens: ','.
						name _ tokens first allButLast.
						((1 to: (tokens size - 1 min: anArray size))
							allSatisfy: [:i| (tokens at: i+1) asInteger = (anArray at: i)])
								ifTrue: [^ name]]]].
		^ nil! !

!OEIS methodsFor: 'as yet unclassified' stamp: 'len 4/27/2016 07:04'!
lookup: anArray
	| array |
	array _ (anArray is: #Sequence) ifTrue: [anArray copyFrom: 1 to: self longestEntrySize] ifFalse: [anArray].
	entries do: [:each|
		each value size = 0 ifTrue: [^ nil].
		((1 to: (each value size min: array size))
			allSatisfy: [:i| (each value at: i) = (array at: i)])
				ifTrue: [^ each key]].			
	^ nil! !

!OEIS class methodsFor: 'as yet unclassified' stamp: 'len 4/25/2016 07:16'!
default
	^ Default ifNil: [Default _ self new]! !

!SmithReduction methodsFor: 'accessing' stamp: 'len 5/28/2019 08:51:31'!
invariants
	invariants isNil ifTrue: [self run].
	^ invariants! !

!SmithReduction methodsFor: 'accessing' stamp: 'len 5/25/2019 10:28:41'!
matrix
	^ matrix! !

!SmithReduction methodsFor: 'accessing' stamp: 'len 5/25/2019 10:28:41'!
matrix: aMatrix
	matrix _ aMatrix! !

!SmithReduction methodsFor: 'accessing' stamp: 'len 6/1/2020 12:00:45'!
reduced
	^ (matrix scalars^self invariants size) endomorphisms diagonal: self invariants! !

!SmithReduction methodsFor: 'private' stamp: 'len 1/9/2022 09:42:37'!
reduceStep: i mod: R
	| j c euclid B Ai Aj |
	"2. Initialize j for row reduction:"
	[j _ i-1. c _ 0.
	"3. Check zero:"
	[[j >= 1 and: [(matrix at: i@j) isZero]] whileTrue: [j _ j - 1].
	j >= 1]
		whileTrue: "4. Euclidean step:"
			[euclid _ ExtendedEuclid on: {matrix at: i@i. matrix at: i@j}.
"			euclid verifyMinimal ifFalse: [self halt]."
			B _ (Ai _ matrix columnAt: i) * euclid bezout first + ((Aj _ matrix columnAt: j) * euclid bezout second).
			matrix columnAt: j put: Aj * ((matrix at: i@i) // euclid gcd) - (Ai * ((matrix at: i@j) // euclid gcd)) \\ R.
			matrix columnAt: i put: B \\ R.
			j _ j - 1].
	"5. Initialize j for column reduction:"
	j _ i-1.
	"6. Check zero (find pivot):"
	[[j >= 1 and: [(matrix at: j@i) isZero]] whileTrue: [j _ j - 1].
	j >= 1]
		whileTrue: "7. Euclidean step:"
			[euclid _ ExtendedEuclid on: {matrix at: i@i. matrix at: j@i}.
"			euclid verifyMinimal ifFalse: [self halt]."
			B _ (Ai _ matrix rowAt: i) * euclid bezout first + ((Aj _ matrix rowAt: j) * euclid bezout second).
			matrix rowAt: j put: Aj * ((matrix at: i@i) // euclid gcd) - (Ai * ((matrix at: j@i) // euclid gcd)) \\ R.
			matrix rowAt: i put: B \\ R.
			j _ j - 1.
			c _ c + 1].
	c > 0] whileTrue "8. Repeat stage i?"! !

!SmithReduction methodsFor: 'private' stamp: 'len 1/9/2022 09:42:47'!
run
	| n i R b k |
	n _ matrix height.
	invariants _ OrderedCollection new: n.
	"1. Initialize i:"
	i _ n.
	R _ matrix determinant.
	R _ R normalized. "replaces R _ R abs"
	n = 1 ifTrue: [invariants add: R. ^ self].
	"2-9. Reduction:"
	[[self reduceStep: i mod: R.
	"9. Check the rest of the matrix:"
	b _ matrix at: i@i.
	k _ (1 to: i-1) detect: [:k0| ((1 to: i-1) allSatisfy: [:l| b | (matrix at: k0@l)]) not] ifNone: [].
	k isNil]
		whileFalse: [matrix rowAt: i put: (matrix rowAt: i) + (matrix rowAt: k)].
	"10. Next stage:"
	invariants add: ((matrix at: i@i) gcd: R).
	R _ R // invariants last.
	i = 2]
		whileFalse: [i _ i - 1].
	invariants add: ((matrix at: 1@1) gcd: R).
"	diagonal _ matrix scalars tuple: diagonal"! !

!SturmChain methodsFor: 'as yet unclassified' stamp: 'len 11/3/2015 06:50'!
countSignChanges: signs
	| x count |
	x _ signs first.
	count _ 0.
	signs do: [ :each | each sign ~= x ifTrue: [ count _ count + 1 ]. x _ each sign ].
	^ count! !

!SturmChain methodsFor: 'as yet unclassified' stamp: 'len 11/3/2015 06:44'!
numberOfRealRoots
	^ self numberOfSignChangesAtMinusInfinity - self numberOfSignChangesAtInfinity! !

!SturmChain methodsFor: 'as yet unclassified' stamp: 'len 11/3/2015 06:51'!
numberOfSignChangesAt: aNumber
	^ self countSignChanges: (chain collect: [ :each | (each value: aNumber) sign])! !

!SturmChain methodsFor: 'as yet unclassified' stamp: 'len 11/3/2015 06:51'!
numberOfSignChangesAtInfinity
	^ self countSignChanges: (chain collect: [ :each | each leadingCoefficient sign ])! !

!SturmChain methodsFor: 'as yet unclassified' stamp: 'len 11/3/2015 06:51'!
numberOfSignChangesAtMinusInfinity
	^ self countSignChanges: (chain collect: [ :each | each leadingCoefficient sign * (each degree odd ifTrue: [-1] ifFalse: [1])])! !

!SturmChain methodsFor: 'as yet unclassified' stamp: 'len 11/3/2015 20:45'!
polynomial
	^ chain first! !

!SturmChain methodsFor: 'as yet unclassified' stamp: 'len 1/15/2016 06:27'!
polynomial: aPolynomial
	chain _ OrderedCollection with: aPolynomial with: aPolynomial derivative.
	[ chain last degree > 0 ] whileTrue: [ chain add: ((chain at: chain size - 1) \\ chain last) negated ]! !

!SturmChain class methodsFor: 'as yet unclassified' stamp: 'len 11/3/2015 06:46'!
on: aPolynomial
	^ self basicNew setPolynomial: aPolynomial! !

!SubgroupSeries methodsFor: 'accessing' stamp: 'len 5/1/98 17:35'!
add: aSubgroup
	^ self subgroups add: aSubgroup! !

!SubgroupSeries methodsFor: 'accessing' stamp: 'len 5/1/98 17:34'!
at: anInteger
	^ self subgroups at: anInteger! !

!SubgroupSeries methodsFor: 'accessing' stamp: 'len 2/8/2016 03:55'!
objects
	^ subgroups! !

!SubgroupSeries methodsFor: 'accessing' stamp: 'len 5/4/2016 06:25'!
size
	^ subgroups size! !

!SubgroupSeries methodsFor: 'accessing' stamp: 'len 5/1/98 17:33'!
subgroups
	^ subgroups! !

!SubgroupSeries methodsFor: 'enumerating' stamp: 'len 5/1/98 17:35'!
do: aBlock
	self subgroups do: aBlock! !

!SubgroupSeries methodsFor: 'initialization' stamp: 'len 5/1/98 17:32'!
initialize
	self subgroups: OrderedCollection new! !

!SubgroupSeries methodsFor: 'testing' stamp: 'len 5/1/98 17:52'!
isAbelian
	"Answer true if the receiver is an abelian tower of subgroups."
	self isNormal ifFalse: [^ false].
	2 to: self size do: [ :each | ((self at: each - 1) / (self at: each)) isAbelian ifFalse: [^ false]].
	^ true! !

!SubgroupSeries methodsFor: 'testing' stamp: 'len 5/3/98 01:07'!
isCyclic
	"Answer true if the receiver is a cyclic tower of subgroups."
	self isNormal ifFalse: [^ false].
	2 to: self size do: [ :each | ((self at: each - 1) / (self at: each)) isCyclic ifFalse: [^ false]].
	^ true! !

!SubgroupSeries methodsFor: 'testing' stamp: 'len 5/1/98 17:47'!
isNormal
	"Answer true if the receiver is a normal tower of subgroups."
	2 to: self size do: [ :each | ((self at: each) isNormalIn: (self at: each - 1)) ifFalse: [^ false]].
	^ true! !

!SubgroupSeries methodsFor: 'private' stamp: 'len 5/1/98 17:33'!
subgroups: aCollection
	subgroups _ aCollection! !

!CoxeterDiagram methodsFor: 'as yet unclassified' stamp: 'len 2/11/2016 22:11'!
gramMatrix
	^ matrix collect: [:x| -2 * (Float pi / x) cos]! !

!CoxeterDiagram methodsFor: 'as yet unclassified' stamp: 'len 2/11/2016 22:14'!
isConnected
	^ self notYetImplemented! !

!CoxeterDiagram methodsFor: 'as yet unclassified' stamp: 'len 2/11/2016 22:14'!
isElliptic
	^ self notYetImplemented! !

!CoxeterDiagram methodsFor: 'as yet unclassified' stamp: 'len 2/11/2016 22:41'!
isHyperbolic
	^ (self gramMatrix spectrum count: [:each| each negative]) = 1! !

!CoxeterDiagram methodsFor: 'as yet unclassified' stamp: 'len 2/11/2016 22:22'!
isLannerDiagram
	^ self isConnected and: [self isElliptic not and: [self gramMatrix determinant < 0]]! !

!CoxeterDiagram methodsFor: 'as yet unclassified' stamp: 'len 2/11/2016 22:23'!
isParabolic
	| spectrum |
	spectrum _ self gramMatrix spectrum.
	^ (spectrum occurrencesOf: 0) = 1 and: [spectrum allSatisfy: [:each| each >= 0]]! !

!RootSystem methodsFor: 'accessing' stamp: 'len 5/23/2016 05:00'!
ambient
	"Answer the ambient space of the receiver."
	^ ambient! !

!RootSystem methodsFor: 'accessing' stamp: 'len 5/23/2016 04:59'!
rank
	^ ambient dimension! !

!RootSystem methodsFor: 'accessing' stamp: 'len 1/6/2016 04:46'!
roots
	^ roots! !

!RootSystem methodsFor: 'accessing-private' stamp: 'len 5/23/2016 05:00'!
ambient: aVectorSpace
	ambient _ aVectorSpace! !

!RootSystem methodsFor: 'accessing-private' stamp: 'len 2/11/2016 19:21'!
roots: aCollection
	roots _ aCollection! !

!RootSystem methodsFor: 'operations' stamp: 'len 5/5/2019 18:33:56'!
coxeterElement
	| O answer |
	O _ ambient automorphisms orthogonal.
	answer _ ambient id.
	self simpleRoots do: [:each| answer _ answer  (O reflectionAt: each)].
	^ answer! !

!RootSystem methodsFor: 'operations' stamp: 'len 12/18/2021 20:31:19'!
coxeterMatrix
	"Answer the Coxeter matrix of the receiver.
	Given a basis a_i of simple roots, the Coxeter matrix m_ij is defined by <a_i,a_j> = -2 cos(pi / m_ij)."
	| S |
	S _ self normalized simpleRoots.
	^ ambient scalars
		matrix: S size
		filling: [:i :j| Float pi / ((ambient innerProduct value: {(S at: i). (S at: j)}) / -2) arcCos]! !

!RootSystem methodsFor: 'operations' stamp: 'len 6/18/2016 17:14'!
coxeterNumber
	^ self weylGroup orderOf: self coxeterElement! !

!RootSystem methodsFor: 'operations' stamp: 'len 5/23/2016 04:59'!
dual
	^ self class on: ambient roots: self coroots! !

!RootSystem methodsFor: 'operations' stamp: 'len 2/11/2016 20:59'!
exponents
	"Answer the 'sequence of exponents' of the root system."
	| h |
	self flag: #fix. "complex eigenvalues, but how about finite fields?"
	h _ self coxeterNumber.
	^ self coxeterElement eigenvalues collect: [:each| each log / (Float pi * 2 i / h)]! !

!RootSystem methodsFor: 'operations' stamp: 'len 5/20/2018 15:59:24'!
lattice
	"Answer the root lattice, the Z-submodule spanned by roots of the receiver."
	^ Lattice basis: self simpleRoots! !

!RootSystem methodsFor: 'operations' stamp: 'len 5/23/2016 05:01'!
normalized
	^ self class on: ambient roots: (roots collect: [:x| x * (2 / (ambient innerProduct value: {x.x}))])! !

!RootSystem methodsFor: 'operations' stamp: 'len 2/10/2016 23:01'!
positiveWeylChamber
	"Answer the positive Weyl chamber that is choosen in the receiver to define the positive roots."
	^ self notYetImplemented! !

!RootSystem methodsFor: 'operations' stamp: 'len 5/20/2018 15:59:29'!
weightLattice
	"Answer the lattice spanned by the weights of the receiver. This lattice is invariant under the Weyl group and also under the map v -> -v. Also, the root lattice is contained in the weight lattice."
	^ Lattice basis: self weights! !

!RootSystem methodsFor: 'operations' stamp: 'len 1/7/2016 05:42'!
weights
	"Answer the fundamental weights of the receiver.
	A vector v is integral iff it can be expressed as integer linear combination of the fundamental weights."
	^ self notYetImplemented! !

!RootSystem methodsFor: 'operations' stamp: 'len 10/17/2016 11:03'!
weylAction
	| W |
	W _ self weylGroup.
	W name: 'W'.
	^ GroupAction from: (W, self roots) to: self roots evaluatingWithArguments: [:f :x| f value: x]! !

!RootSystem methodsFor: 'operations' stamp: 'len 9/27/2018 21:19:17'!
weylGroup
	"Answer the Weyl group of the root system, i.e. the (finite) group of isometries of the ambient vector space generated by reflections through hyperplanes perpendicular to the roots. The Weyl group W(R) is the subgroup of GL(V) (and more specifically O(V)) generated by the reflections {s_r} that act on each root r by -1: s_r(r) = -r."
	| O W |
	O _ ambient automorphisms orthogonal.
	W _ O span: (self roots collect: [:each| O reflectionAt: each]).
"	W name: 'W'."
	^ W! !

!RootSystem methodsFor: 'operations' stamp: 'len 1/6/2016 00:00'!
weylVector
	^ self positiveRoots sum / 2! !

!RootSystem methodsFor: 'roots' stamp: 'len 5/23/2016 05:00'!
coroots
	^ roots collect: [:v| v * 2 / (ambient innerProduct value: {v.v})]! !

!RootSystem methodsFor: 'roots' stamp: 'len 1/6/2016 05:01'!
degreeOf: aPositiveRoot
	"Answer the degree of the given positive root."
	^ (self simpleRoots coordinatesOf: aPositiveRoot) asArray sum! !

!RootSystem methodsFor: 'roots' stamp: 'len 1/6/2016 03:52'!
negativeRoots
	^ self positiveRoots negated! !

!RootSystem methodsFor: 'roots' stamp: 'len 6/25/2016 23:08'!
positiveRoots
	| answer |
	answer _ Set new.
	roots do: [:a| (answer includes: a negated)
		ifFalse:
			[answer add: a.
			answer copy do: [:b| (roots includes: a+b) ifTrue: [answer add: b]]]].
	^ answer! !

!RootSystem methodsFor: 'roots' stamp: 'len 1/6/2016 04:51'!
positiveRootsSorted
	^ self positiveRoots asSortedCollection: [:a :b| (self simpleRoots coordinatesOf: b - a) asArray allSatisfy: [:each| each positive]]! !

!RootSystem methodsFor: 'roots' stamp: 'len 3/6/2020 18:19:43'!
simpleRoots
	| M |
	M _ Matrix columns: (self positiveRoots asArray collect: [:each| ambient coordinatesOf: each]).
	^ M image! !

!RootSystem methodsFor: 'testing' stamp: 'len 5/23/2016 04:59'!
isCrystallographic
	^ self roots allSatisfy: [:x|
		self coroots allSatisfy: [:y|
			(ambient innerProduct value: {x. y}) isInteger]]! !

!RootSystem methodsFor: 'testing' stamp: 'len 2/11/2016 21:16'!
isIntegral
	^ self isCrystallographic! !

!RootSystem methodsFor: 'testing' stamp: 'len 2/11/2016 20:46'!
isIrreducible
	^ self coxeterDiagram isConnected! !

!RootSystem methodsFor: 'testing' stamp: 'len 5/23/2016 05:01'!
isNormalized
	^ roots allSatisfy: [:each| (ambient innerProduct value: {each.each}) = 2]! !

!RootSystem class methodsFor: 'examples' stamp: 'len 7/14/2016 00:09'!
A: V
	| roots |
	roots _ Set new.
	1 to: V dimension do: [:i|
		i to: V dimension do: [:j|
			roots add: (V e: i) - (V e: j)]].
	^ self on: V roots: roots! !

!RootSystem class methodsFor: 'examples' stamp: 'len 7/14/2016 00:09'!
B: V
	| roots |
	roots _ Set new.
	1 to: V dimension do: [:i|
		roots add: (V e: i).
		i to: V dimension do: [:j|
			roots add: (V e: i) - (V e: j); add: (V e: i) + (V e: j)]].
	^ self on: V roots: roots! !

!RootSystem class methodsFor: 'examples' stamp: 'len 7/14/2016 00:09'!
C: V
	| roots |
	roots _ Set new.
	1 to: V dimension do: [:i|
		roots add: (V e: i)*2.
		i to: V dimension do: [:j|
			roots add: (V e: i) - (V e: j); add: (V e: i) + (V e: j)]].
	^ self on: V roots: roots! !

!RootSystem class methodsFor: 'examples' stamp: 'len 7/14/2016 00:09'!
D: V
	| roots |
	roots _ Set new.
	1 to: V dimension do: [:i|
		i to: V dimension do: [:j|
			roots add: (V e: i) - (V e: j); add: (V e: i) + (V e: j)]].
	^ self on: V roots: roots! !

!RootSystem class methodsFor: 'examples' stamp: 'len 5/23/2020 09:33:01'!
example1
	"This is a normalized root system in R^n. The Weyl group associated to it is the symmetric group S_n."
	| V roots |
	V _  ^ 3.
	roots _ Set new.
	1 to: V dimension do: [:i|
		1 to: i-1 do: [:j|
			roots add: (V e: i) - (V e: j); add: (V e: j) - (V e: i)]].
	^ RootSystem on: V roots: roots! !

!RootSystem class methodsFor: 'examples' stamp: 'len 5/23/2020 09:31:27'!
example2
	"This is a normalized root system in R^n. The Weyl group associated to it is the hyperoctahedral group."
	| V roots |
	V _  ^ 3.
	roots _ Set new.
	1 to: V dimension do: [:i|
		1 to: i-1 do: [:j|
			roots
				add: (V e: i) * (RealAlgebraicNumber sqrt: 2);
				add: (V e: i) * (RealAlgebraicNumber sqrt: 2) negated;
				add: (V e: i) - (V e: j);
				add: (V e: j) - (V e: i);
				add: (V e: i) + (V e: j);
				add: ((V e: i) + (V e: j)) negated]].
	^ RootSystem on: V roots: roots! !

!RootSystem class methodsFor: 'examples' stamp: 'len 5/23/2020 09:33:01'!
example3
	"This is a normalized root system in R^n. The Weyl group associated to it is an index 2 subgroup of the hyperoctahedral group."
	| V roots |
	V _  ^ 3.
	roots _ Set new.
	1 to: 3 do: [:i|
		1 to: i-1 do: [:j|
			roots
				add: (V e: i) - (V e: j);
				add: (V e: j) - (V e: i);
				add: (V e: i) + (V e: j);
				add: ((V e: i) + (V e: j)) negated]].
	^ RootSystem on: V roots: roots! !

!RootSystem class methodsFor: 'examples' stamp: 'len 5/23/2020 09:33:01'!
hexagonal
	^ self A:  ^ 2! !

!RootSystem class methodsFor: 'instance creation' stamp: 'len 5/23/2016 05:00'!
on: aVectorSpace roots: aCollection
	^ self new ambient: aVectorSpace; roots: aCollection! !

!RootSystemTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:33:01'!
rootSystem1
	| V roots |
	V _  ^ 3.
	roots _ Set new.
	1 to: 3 do: [:i| 1 to: i-1 do: [:j| |r| roots add: (r _ (V x: i) - (V x: j)); add: r negated]].
	^ RootSystem on: V roots: roots! !

!RootSystemTest methodsFor: 'as yet unclassified' stamp: 'len 5/23/2020 09:33:01'!
rootSystem2
	| V roots |
	V _  ^ 3.
	roots _ Set new.
	1 to: 3 do: [:i|
		1 to: i-1 do: [:j|
			roots
				add: (V x: i) - (V x: j);
				add: (V x: j) - (V x: i);
				add: (V x: i) + (V x: j);
				add: ((V x: i) + (V x: j)) negated]].
	^ RootSystem on: V roots: roots! !

!RootSystemTest methodsFor: 'as yet unclassified' stamp: 'len 2/23/2016 07:26'!
testBaseSignCondition
	| R |
	R _ self rootSystem1.
	R roots do: [:each| | coordinates |
		coordinates _ R simpleRoots coordinatesOf: each :: asArray.
		self assert: (coordinates allSatisfy: [:xi| xi >= 0]) | (coordinates allSatisfy: [:xi| xi <= 0])]! !

!RootSystemTest methodsFor: 'as yet unclassified' stamp: 'len 6/25/2016 23:09'!
testPositiveRoots
	| V R |
	R _ self rootSystem1.
	V _ R ambient.
	R positiveRoots do: [:each|
		self assert: (V innerProduct value: {each. (1,1,1)}) > 0] "the point must be in the positive Weyl chamber"! !

!RootSystemTest methodsFor: 'as yet unclassified' stamp: 'len 2/11/2016 01:39'!
testWeylGroup
	| R W |
	R _ self rootSystem1.
	W _ R weylGroup.
	"The Weyl group of this root system is isomorphic to Sym(3), so we test some properties of Sym(3):"
	self assert: W order = 6.
	self assert: W center isTrivial.
	self assert: W isSolvable.
	self assert: W isCyclic not! !

!RootSystemTest methodsFor: 'as yet unclassified' stamp: 'len 2/10/2016 22:43'!
testWeylGroup2
	| R W |
	R _ self rootSystem2.
	W _ R weylGroup. "this is an index 2 subgroup of the hyperoctahedral group"
	self assert: W order = 24! !

!RootSystemTest methodsFor: 'as yet unclassified' stamp: 'len 2/10/2016 22:56'!
testWeylGroupAndSimpleRoots
	"For every root, there exists an transformation in the Weyl group that makes it a simple root."
	| R W |
	R _ self rootSystem1.
	W _ R weylGroup.
	R roots do: [:r| self assert: (W anySatisfy: [:w| R simpleRoots includes: (w value: r)])]! !

!ModularSymbol methodsFor: 'as yet unclassified' stamp: 'len 12/21/2016 20:48:11'!
apply: aMorphism
	^ self class alpha: (aMorphism value: alpha) beta: (aMorphism value: beta)! !

!FareySymbol methodsFor: 'as yet unclassified' stamp: 'len 12/19/2016 22:32:21'!
cusps
	^ self notYetImplemented! !

!FareySymbol methodsFor: 'as yet unclassified' stamp: 'len 12/20/2016 20:42:22'!
denominatorAt: i
	i == 0 ifTrue: [^ 0].
	i == (fractions size + 1) ifTrue: [^ 0].
	^ (fractions at: i) denominator! !

!FareySymbol methodsFor: 'as yet unclassified' stamp: 'len 12/20/2016 21:21:44'!
e2
	"Answer the number of inequivalent order-2 elliptic points."
	^ pairings count: [:each| each == #even]! !

!FareySymbol methodsFor: 'as yet unclassified' stamp: 'len 12/20/2016 21:21:53'!
e3
	"Answer the number of inequivalent order-3 elliptic points."
	^ pairings count: [:each| each == #odd]! !

!FareySymbol methodsFor: 'as yet unclassified' stamp: 'len 12/20/2016 21:04:58'!
example
	group _ PrincipalCongruenceSubgroup new: 2.
	fractions _ {0. 1. 2}.
	pairings _ {1. 2. 2. 1}! !

!FareySymbol methodsFor: 'as yet unclassified' stamp: 'len 12/21/2016 16:09:10'!
generators
	^ (1 to: fractions size) collect: [:i| self pairingMapAt: i]! !

!FareySymbol methodsFor: 'as yet unclassified' stamp: 'len 12/20/2016 21:25:43'!
genus
	^ self rank - self numberOfCusps / 2! !

!FareySymbol methodsFor: 'as yet unclassified' stamp: 'len 12/20/2016 21:27:27'!
index
	"Answer the index of the group of the receiver as subgroup of the modular group."
	^ (self size - 1) * 3 + self e3! !

!FareySymbol methodsFor: 'as yet unclassified' stamp: 'len 12/20/2016 20:41:51'!
numeratorAt: i
	i == 0 ifTrue: [^ -1].
	i == (fractions size + 1) ifTrue: [^ 1].
	^ (fractions at: i) numerator! !

!FareySymbol methodsFor: 'as yet unclassified' stamp: 'len 12/20/2016 21:12:26'!
pairingAt: i
	"Answer the pairing between i-1 and i. Each pairing is either a positive integer (a free pairing), #even or #odd."
	^ pairings at: i! !

!FareySymbol methodsFor: 'as yet unclassified' stamp: 'len 3/6/2017 17:01:38'!
pairingMapAt: i
	| a b a1 b1 k ak bk ak1 bk1 |
	a _ self numeratorAt: i-1.
	b _ self denominatorAt: i-1.
	a1 _ self numeratorAt: i.
	b1 _ self denominatorAt: i.
	k _ self pairingAt: i.
	k == #even ifTrue: [^ ModularMap a: a1*b1 + (a*b) b: a*a negated - (a1*a1) c: b*b + (b1*b1) d: a1*b1 negated - (a*b)].
	k == #odd ifTrue: [^ ModularMap a: a1*b1 + (a*b1) + (a*b) b: a*a negated - (a*a1) - (a1*a1) c: b*b + (b*b1) + (b1*b1) d: a1*b1 negated - (a1*b) - (a*b)].
	ak _ self numeratorAt: k.
	bk _ self denominatorAt: k.
	ak1 _ self numeratorAt: k+1.
	bk1 _ self denominatorAt: k+1.
	^ ModularMap a: ak1*b1 + (ak*b) b: ak*ak negated - (ak1*a1) c: bk*b + (bk1*b1) d: a1*bk1 negated - (a*bk)! !

!FareySymbol methodsFor: 'as yet unclassified' stamp: 'len 12/20/2016 21:23:12'!
r
	"Answer the rank of the fundamental group of the uncompactified modular curve G\H, where G denotes de group of the receiver and H is the upper half plane."
	^ pairings count: [:each| each isInteger]! !

!FareySymbol methodsFor: 'as yet unclassified' stamp: 'len 12/20/2016 21:12:07'!
size
	^ fractions size! !

!ModularGroupTest methodsFor: 'as yet unclassified' stamp: 'len 12/10/2016 12:56:12'!
testGamma0Index
	self assert: (1 to: 19 :: collect: [:each| Gamma0CongruenceSubgroup new: each :: index]) = #(1 3 4 6 6 12 8 12 12 18 12 24 14 24 24 24 18 36 20).
	self assert: (Gamma0CongruenceSubgroup new: 32041) index = 32220! !

!ModularGroupTest methodsFor: 'as yet unclassified' stamp: 'len 12/10/2016 12:23:06'!
testGamma0NumberOfCusps
	| p |
	self assert: (1 to: 19 :: collect: [:each| Gamma0CongruenceSubgroup new: each :: numberOfCusps]) =  #(1 2 2 3 2 4 2 4 4 4 2 6 2 4 4 6 2 8 2).
	p _ 1.
	100 timesRepeat: [self assert: (Gamma0CongruenceSubgroup new: (p _ p nextPrime)) numberOfCusps = 2]! !

!ModularGroupTest methodsFor: 'as yet unclassified' stamp: 'len 12/15/2016 23:02:48'!
testGammaIndex
	self assert: (1 to: 19 :: collect: [:each| PrincipalCongruenceSubgroup new: each :: index]) =  #(1 6 24 48 120 144 336 384 648 720 1320 1152 2184 2016 2880 3072 4896 3888 6840)! !

!ModularGroupTest methodsFor: 'as yet unclassified' stamp: 'len 12/15/2016 23:16:41'!
testIndexOf
	| G H |
	G _ PrincipalCongruenceSubgroup new: 2.
	H _ PrincipalCongruenceSubgroup new: 8.
	self assert: (G indexOf: H) = 32 "according to GAP manual chap. 2, Gamma(2) has index 12"! !

!Object methodsFor: '*domains' stamp: 'len 4/22/2020 06:16:21'!
adapt: anElement andSend: selector
	self parent ifNotNil: [:aDomain| (aDomain adapt: anElement) ifNotNil: [:adapted| ^ self perform: selector with: adapted]].
	anElement parent ifNotNil: [:aDomain| (aDomain adapt: self) ifNotNil: [:adapted| ^ adapted perform: selector with: anElement]].
	^ DomainError signal: 'coercion failed'! !

!Object methodsFor: '*domains' stamp: 'len 11/6/2016 09:07'!
adaptToCollection: rcvr andSend: selector
	"If I am involved in arithmetic with a Collection, return a Collection of
	the results of each element combined with me in that expression."

	^ rcvr collect: [:element | element perform: selector with: self]! !

!Object methodsFor: '*domains' stamp: 'len 10/26/2020 14:21:55'!
id
	^ self -> self! !

!Object methodsFor: '*domains' stamp: 'len 5/8/2020 15:46:45'!
isDomain
	^ false! !

!Object methodsFor: '*domains' stamp: 'len 4/22/2020 06:09:43'!
isElement
	"Answer true if the receiver is an element of a Domain, i.e. if it understands the message #parent and answers its parent Domain."
	^ self parent notNil! !

!Object methodsFor: '*domains' stamp: 'len 5/19/2018 17:53:50'!
isEvaluable
	^ self isBlock! !

!Object methodsFor: '*domains' stamp: 'len 11/19/2015 17:01'!
isInfinity
	^ false! !

!Object methodsFor: '*domains' stamp: 'len 4/2/2018 05:16:06'!
isMatrix
	^ false! !

!Object methodsFor: '*domains' stamp: 'len 5/8/2020 15:46:36'!
isMorphism
	^ false! !

!Object methodsFor: '*domains' stamp: 'len 8/5/2016 21:51'!
isReal
	"Answer true if the receiver is a real number."
	^ false! !

!Object methodsFor: '*domains' stamp: 'len 5/22/2018 16:53:19'!
isSequenceable
	"Answer true if the receiver is some sort of ordered tuple of objects, understands #at: and #size and it's indexed by integers starting at 1."
	^ false! !

!Object methodsFor: '*domains' stamp: 'len 3/28/2018 18:01:41'!
isTuple
	^ false! !

!Object methodsFor: '*domains' stamp: 'len 4/22/2020 06:09:50'!
parent
	^ nil! !

!Object methodsFor: '*domains' stamp: 'len 5/29/2020 06:29:20'!
printText
	| answer |
	answer _ Text streamContents: [:aStream| self printOn: aStream].
	self validate ifFalse: [answer under].
	^ answer! !

!Object methodsFor: '*domains' stamp: 'len 5/29/2020 06:23:48'!
validate
	"Answer false if the internal invariants of this object are broken."
	^ true! !

!Object class methodsFor: '*domains' stamp: 'len 7/7/2020 11:06:32'!
!! anObject
	(self newFrom: anObject) ifNotNil: [:anInstance| ^ anInstance].
	^ DomainError signal: 'coercion failed'! !

!Workspace methodsFor: '*domains' stamp: 'len 11/23/2015 03:28'!
bindingOf: aString
	mustDeclareVariables ifTrue: [^ nil].
	(bindings includesKey: aString) ifFalse: [
		"aString first isUppercase
			ifTrue: [^nil]
			ifFalse: ["bindings at: aString put: nil]"]".
	^bindings associationAt: aString! !

!Class methodsFor: '*domains' stamp: 'len 12/1/2016 09:03:19'!
newSubclass
	"Answer a new subclass of the receiver. The new subclass will be unnamed and uncategorized, and if no instances exist it can be subject of garbage collection."
	| newMetaclass |
	newMetaclass _ Metaclass new.
	newMetaclass
		superclass: self class
		methodDictionary: MethodDictionary new
		format: self class format.
	^ newMetaclass new
		superclass: self
		methodDictionary: MethodDictionary new
		format: self format! !

!Magnitude methodsFor: '*domains' stamp: 'len 10/18/2016 13:58'!
isFinite
	^ self isInfinite not! !

!Magnitude methodsFor: '*domains' stamp: 'len 10/18/2016 13:57'!
isInfinite
	^ false! !

!Number methodsFor: '*domains' stamp: 'len 5/29/2020 19:43:31'!
^ aNumber
	aNumber isInteger ifTrue: [^ self raisedToInteger: aNumber].
	aNumber isFraction ifTrue: [^ (self root: aNumber denominator) raisedToInteger: aNumber numerator ].
	0 = aNumber ifTrue: [^ self class one].
	1 = aNumber ifTrue: [^ self].
	0 = self ifTrue: [
		aNumber < 0
			ifTrue: [^ (ZeroDivide receiver: self selector: #'^' argument: aNumber) signal]
			ifFalse: [^ self]].
	^ (aNumber * self ln) exp! !

!Number methodsFor: '*domains' stamp: 'len 8/9/2020 07:47:51'!
conjugate
	"Answer the complex conjugate of the receiver."

	^ self! !

!Number methodsFor: '*domains' stamp: 'len 6/4/2016 21:55'!
imaginary
	^ 0! !

!Number methodsFor: '*domains' stamp: 'len 3/17/2016 03:40'!
isAlgebraic
	^ false! !

!Number methodsFor: '*domains' stamp: 'len 8/5/2016 21:44'!
isComplex
	^ true "real numbers are also complex numbers"! !

!Number methodsFor: '*domains' stamp: 'len 11/19/2015 17:20'!
isRational
	^ false! !

!Number methodsFor: '*domains' stamp: 'len 8/5/2016 21:44'!
isReal
	^ true! !

!Number methodsFor: '*domains' stamp: 'len 1/12/2016 03:18'!
norm
	^ self abs! !

!Number methodsFor: '*domains' stamp: 'len 1/13/2016 02:54'!
norm2
	^ self squared! !

!Number methodsFor: '*domains' stamp: 'len 11/19/2015 20:58'!
one
	^ 1! !

!Number methodsFor: '*domains' stamp: 'len 6/4/2016 21:54'!
real
	^ self! !

!Number methodsFor: '*domains' stamp: 'len 3/25/2018 16:05:30'!
root: anInteger
	anInteger = 2 ifTrue: [^ self squareRoot].
	anInteger = 1 ifTrue: [^ self].
	^ self notYetImplemented! !

!Number methodsFor: '*domains' stamp: 'len 11/19/2015 20:58'!
zero
	^ 0! !

!Float methodsFor: '*domains' stamp: 'len 5/23/2020 10:12:50'!
, aTuple
	^ ( tuple: {self}), aTuple! !

!Float methodsFor: '*domains' stamp: 'len 1/13/2016 03:55'!
adaptToAlgebraic: rcvr andSend: selector
	^ rcvr asComplexFloat perform: selector with: self asComplex! !

!Float methodsFor: '*domains' stamp: 'len 1/13/2016 03:52'!
adaptToRealAlgebraic: rcvr andSend: selector
	^ rcvr asFloat perform: selector with: self! !

!Float methodsFor: '*domains' stamp: 'len 5/3/2020 07:43:34'!
inverse
	^ self reciprocal! !

!Float methodsFor: '*domains' stamp: 'len 5/23/2020 10:13:14'!
parent
	^ ! !

!Float methodsFor: '*domains' stamp: 'len 2/25/2016 17:17'!
squareRoot
	^ self sqrt! !

!Fraction methodsFor: '*domains' stamp: 'len 5/23/2020 09:53:21'!
% anInteger
	| R |
	R _  / anInteger.
	^ (R project: numerator) / (R project: denominator)! !

!Fraction methodsFor: '*domains' stamp: 'len 5/23/2020 09:53:29'!
, aTuple
	^ ( tuple: {self}), aTuple! !

!Fraction methodsFor: '*domains' stamp: 'len 6/5/2019 14:48:57'!
abs: p
	"Answer the p-adic absolute value of the receiver."
	^ (numerator abs: p) / (denominator abs: p)! !

!Fraction methodsFor: '*domains' stamp: 'len 1/20/2018 19:17:36'!
adaptToAlgebraic: rcvr andSend: selector
	^ rcvr perform: selector with: (ComplexAlgebraicNumber fromRational: self)! !

!Fraction methodsFor: '*domains' stamp: 'len 1/13/2016 03:55'!
adaptToRealAlgebraic: rcvr andSend: selector
	^ rcvr perform: selector with: (RealAlgebraicNumber fromRational: self)! !

!Fraction methodsFor: '*domains' stamp: 'len 3/3/2021 15:03:13'!
asRational
	^ Rational reducedNumerator: numerator denominator: denominator! !

!Fraction methodsFor: '*domains' stamp: 'len 2/10/2016 21:13'!
bitSize
	^ numerator bitSize + denominator bitSize! !

!Fraction methodsFor: '*domains' stamp: 'len 1/8/2017 16:37:12'!
height
	^ numerator abs max: denominator! !

!Fraction methodsFor: '*domains' stamp: 'len 7/30/2019 02:14:23'!
isIntegral
	^ false! !

!Fraction methodsFor: '*domains' stamp: 'len 11/19/2015 17:20'!
isRational
	^ true! !

!Fraction methodsFor: '*domains' stamp: 'len 5/23/2020 09:53:13'!
minimalPolynomial
	^  polynomials x - self! !

!Fraction methodsFor: '*domains' stamp: 'len 1/20/2018 19:17:29'!
squareRoot
	self positive ifTrue: [^ RealAlgebraicNumber sqrt: self].
	^ ComplexAlgebraicNumber sqrt: self! !

!Fraction methodsFor: '*domains' stamp: 'len 6/5/2019 14:50:10'!
valuation: p
	"Answer the p-adic valuation of the receiver."
	^ (numerator valuation: p) - (denominator valuation: p)! !

!Integer methodsFor: '*domains' stamp: 'len 5/23/2020 09:54:28'!
% anInteger
	^  / anInteger project: self! !

!Integer methodsFor: '*domains' stamp: 'len 5/23/2020 09:54:43'!
, aTuple
	^ ( tuple: {self}), aTuple! !

!Integer methodsFor: '*domains' stamp: 'len 1/13/2022 05:49:10'!
| anInteger
	"Answer true if the receiver divides anInteger."
	anInteger == 0 ifTrue: [^ true].
	self == 0 ifTrue: [^ false].
	^ anInteger \\ self == 0! !

!Integer methodsFor: '*domains' stamp: 'len 5/10/2020 10:58:50'!
~ anInteger
	^ self normalized = anInteger normalized! !

!Integer methodsFor: '*domains' stamp: 'len 12/12/2016 09:35:38'!
Stirling: anInteger
	"Answer the Stirling number of the second kind S(n,k).
	Stirling numbers of the second kind count the ways to partition a set of n things into k nonempty subsets."
	(anInteger > self or: [self < 0]) ifTrue: [^ DomainError signal].
	self = anInteger ifTrue: [^ 1].
	anInteger = 0 ifTrue: [^ 0].
	self+1 = anInteger ifTrue: [^ self choose: 2].
	anInteger = 2 ifTrue: [^ 2 ^ (self-1) - 1].
	^ anInteger*(self - 1 Stirling: anInteger) + (self - 1 Stirling: anInteger - 1)! !

!Integer methodsFor: '*domains' stamp: 'len 3/3/2021 07:31:56'!
abs: p
	"Answer the p-adic absolute value of the receiver."
	| powers q |
	self = 0 ifTrue: [^ 0].
	q _ self abs.
	powers _ 1.
	[p | q] whileTrue: [powers _ powers * p. q _ q // p].
	^ powers asRational reciprocal! !

!Integer methodsFor: '*domains' stamp: 'len 1/20/2018 19:17:45'!
adaptToAlgebraic: rcvr andSend: selector
	^ rcvr perform: selector with: (ComplexAlgebraicNumber fromRational: self)! !

!Integer methodsFor: '*domains' stamp: 'len 3/3/2021 07:32:03'!
adaptToRealAlgebraic: rcvr andSend: selector
	^ rcvr perform: selector with: (RealAlgebraicNumber fromRational: self asRational)! !

!Integer methodsFor: '*domains' stamp: 'len 12/14/2016 14:35:53'!
additiveOrder
	^ self == 0 ifTrue: [1] ifFalse: [Infinity positive]! !

!Integer methodsFor: '*domains' stamp: 'len 7/15/2021 10:32:47'!
annihilator
	"Answer a generator of the ideal of all elements that multiplied by the receiver are zero."
	^ 0! !

!Integer methodsFor: '*domains' stamp: 'len 7/15/2021 10:32:53'!
annihilatorIdeal
	"Answer the ideal of all elements that multiplied by the receiver are zero."
	^  asIdeal null! !

!Integer methodsFor: '*domains' stamp: 'len 12/28/2021 18:49:57'!
asOrdinal
	^ Ordinal fromInteger: self! !

!Integer methodsFor: '*domains' stamp: 'len 3/3/2021 15:03:36'!
asRational
	^ Rational reducedNumerator: self denominator: 1! !

!Integer methodsFor: '*domains' stamp: 'len 5/10/2020 10:57:45'!
associates
	^ self = 0 ifTrue: [#(0)] ifFalse: [{self negated. self}]! !

!Integer methodsFor: '*domains' stamp: 'len 7/2/2016 05:45'!
bitCount
	"Answer the number of bits that are set, i.e. the number of 1s in the binary representation."
	| n |
	self = 0 ifTrue: [^ 0].
	self = 1 ifTrue: [^ 1].
	n _ self digitLength * 8. "this will always be >= 32, because SmallInteger implements bitCount"
	n _ n // 2.
	^ (self bitShift: n negated) bitCount + (self bitAnd: (1 bitShift: n) - 1) bitCount! !

!Integer methodsFor: '*domains' stamp: 'len 7/2/2016 05:43'!
bitParity
	"Answer 1 if there are an odd number of bits set, 0 otherwise."
	| n |
	self = 0 ifTrue: [^ 0].
	self = 1 ifTrue: [^ 1].
	n _ self digitLength * 8. "this will always be >= 32, because SmallInteger implements bitParity"
	n _ n // 2.
	^ ((self bitShift: n negated) bitXor: (self bitAnd: (1 bitShift: n) - 1)) bitParity! !

!Integer methodsFor: '*domains' stamp: 'len 7/2/2016 05:43'!
bitParity2
	"Answer 1 if there are an odd number of bits set, 0 otherwise."
	| i n |
	self = 0 ifTrue: [^ 0].
	self = 1 ifTrue: [^ 1].
	i _ self digitLength * 8. "this will always be >= 32, because SmallInteger implements bitParity"
	n _ self.
	[i _ i bitShift: -1.
	i > 30] whileTrue:
		[n _ n bitXor: (n bitShift: i negated)].
	^ (n bitAnd: (1 bitShift: i) - 1) bitParity! !

!Integer methodsFor: '*domains' stamp: 'len 7/1/2016 23:03'!
bitSize
	self negative ifTrue: [^ self negated highBit + 1].
	^ self highBit! !

!Integer methodsFor: '*domains' stamp: 'len 12/12/2016 09:35:09'!
choose: anInteger
	"Answer the binomial coefficient (self anInteger)"
	" 6 choose: 3  "

	(anInteger < 0 or: [anInteger > self]) ifTrue: [^0].
	^(self - anInteger + 1 productTo: self) // anInteger factorial! !

!Integer methodsFor: '*domains' stamp: 'len 6/29/2016 06:40'!
choose: anInteger q: q
	"Answer the q-binomial coefficient of self with anInteger.
	This counts the number of 'anInteger'-dimensional subspaces of a vector space of dimension 'self' over a finite field of order 'q' (power of a prime)."

	(anInteger < 0 or: [anInteger > self]) ifTrue: [^0].
	^ ((0 to: anInteger - 1) inject: 1 into: [:x :i| 1 - (q^(self-i)) * x]) / ((1 to: anInteger) inject: 1 into: [:x :i| 1 - (q^i) * x])! !

!Integer methodsFor: '*domains' stamp: 'len 4/23/2016 19:35'!
count: aBlock
	| answer |
	answer _ 0.
	self timesRepeat: [aBlock value ifTrue: [answer _ answer + 1]].
	^ answer! !

!Integer methodsFor: '*domains' stamp: 'len 5/15/2020 06:15:20'!
divisionBy: anElement
	^ Division divide: self by: anElement! !

!Integer methodsFor: '*domains' stamp: 'len 12/26/2016 21:24:14'!
divisors
	"Answer the collection of positive divisors of the receiver including 1 and self."
	^ Iterator on: self performing: #divisorsDo:! !

!Integer methodsFor: '*domains' stamp: 'len 12/26/2016 21:23:53'!
divisorsDo: aBlock
	"Iterate over the positive divisors of the receiver, including 1 and self."
	| n sqrt |
	n _ self abs.
	sqrt _ n sqrtFloor.
	1 to: sqrt - 1
		do: [:k| n \\ k = 0 ifTrue: [aBlock value: k; value: n // k]].
	n \\ sqrt = 0
		ifTrue:
			[aBlock value: sqrt.
			sqrt * sqrt = n ifFalse: [aBlock value: n // sqrt]]! !

!Integer methodsFor: '*domains' stamp: 'len 8/5/2021 08:35:27'!
factorization
	"Answer a collection with the prime factors of the receiver (with multiplicity)."
	| answer |
	answer _ Bag new.
	self factorizationDo: [:p :e| answer add: p withOccurrences: e].
	^ answer! !

!Integer methodsFor: '*domains' stamp: 'len 12/26/2016 20:13:44'!
factorizationDo: aBlock
	| n times |
	n _ self abs.
	n <= 1 ifTrue: [^ self].
	n even ifTrue:
		[aBlock value: 2 value: (times _ n lowBit - 1).
		n _ n bitShift: times negated].
	Integer primesUpTo: n sqrtFloor + 1 do: [:p| "tests again 2, but who cares"
		n == 1 ifTrue: [^ self].
		times _ 0.
		[n \\ p == 0] whileTrue: [times _ times + 1. n _ n // p].
		times > 0 ifTrue: [aBlock value: p value: times]].
	n == 1 ifFalse: [aBlock value: n value: 1]! !

!Integer methodsFor: '*domains' stamp: 'len 1/4/2022 09:23:57'!
gauge
	"Answer the value of the Euclidean function at the receiver."
	^ self abs! !

!Integer methodsFor: '*domains' stamp: 'len 11/19/2016 21:03:03'!
height
	self = 0 ifTrue: [^ 1].
	^ self abs! !

!Integer methodsFor: '*domains' stamp: 'len 1/6/2022 19:44:30'!
inverse
	self isUnit ifTrue: [^ self].
	^ InversionError signal: self! !

!Integer methodsFor: '*domains' stamp: 'len 1/9/2022 08:31:42'!
isFundamentalDiscriminant
	| m r |
	r _ self \\ 4.
	r == 1 ifTrue: [^ self isSquarefree].
	r == 0 ifFalse: [^ false].
	m _ self // 4.
	r _ m \\ 4.
	^ (r == 2 or: [r == 3]) and: [m isSquarefree]! !

!Integer methodsFor: '*domains' stamp: 'len 7/16/2019 17:23:08'!
isIdempotent
	^ self isUnit! !

!Integer methodsFor: '*domains' stamp: 'len 7/30/2019 02:13:42'!
isIntegral
	^ true! !

!Integer methodsFor: '*domains' stamp: 'len 7/16/2019 17:23:43'!
isIrreducible
	^ self isPrime! !

!Integer methodsFor: '*domains' stamp: 'len 7/16/2019 17:22:24'!
isNilpotent
	"Answer true if self^n = 0 for some integer n >= 1."
	^ self = 0! !

!Integer methodsFor: '*domains' stamp: 'len 1/3/2022 18:29:08'!
isOne
	^ self  == 1! !

!Integer methodsFor: '*domains' stamp: 'len 1/7/2017 21:04:34'!
isPerfectSquare
	^ self sqrtFloor squared = self! !

!Integer methodsFor: '*domains' stamp: 'len 8/5/2021 08:39:43'!
isPrimePower
	"Answer true if the receiver is of the form p^k for a prime p and a k > 0."
	^ self > 1 and: [self factorization asSet size = 1]! !

!Integer methodsFor: '*domains' stamp: 'len 11/19/2015 17:21'!
isRational
	^ true! !

!Integer methodsFor: '*domains' stamp: 'len 7/16/2019 17:24:16'!
isReducible
	"A nonzero nonunit element is called 'reducible' if it is not irreducible."
	^ self isZero not and: [self isUnit not and: [self isIrreducible not]]! !

!Integer methodsFor: '*domains' stamp: 'len 1/9/2022 08:30:09'!
isSquarefree
	"Answer true if the factorization of the receiver is squarefree."
	self factorizationDo: [:p :e| e > 1 ifTrue: [^ false]].
	^ true

"
The limit of the density of squarefree positive integers < n is 6 / pi^2 ~ 0.6079271:
(1000 count: [100000 atRandom isSquareFree]) / 1000.0
"! !

!Integer methodsFor: '*domains' stamp: 'len 7/16/2019 17:21:36'!
isUnit
	"Answer true if the receiver is invertible."
	^ self = 1 or: [self = -1]! !

!Integer methodsFor: '*domains' stamp: 'len 12/4/2016 15:14:11'!
isZero
	^ self == 0! !

!Integer methodsFor: '*domains' stamp: 'len 1/6/2022 09:27:33'!
isZerodivisor
	"Answer true if there exists a nonzero element that multiplied by the receiver is zero."
	^ self = 0! !

!Integer methodsFor: '*domains' stamp: 'len 4/10/2018 17:29:24'!
jacobi: m
	"Answer the Jacobi symbol of the receiver and the positive odd integer m.
	This is a generalization of the Legendre symbol that allows a composite argument m."

	^ self kronecker: m! !

!Integer methodsFor: '*domains' stamp: 'len 4/10/2018 17:28:55'!
jacobiNew: m
	"Answer the Jacobi symbol of the receiver and the positive odd integer m.
	This is a generalization of the Legendre symbol that allows a composite argument m."

	"this is broken, it should satisfy: (3 jacobiNew: 11) = 1"
	| x y z answer |
	m odd ifFalse: [^ self error: 'the argument must by an odd positive integer'].
	(self gcd: m) = 1 ifFalse: [^ 0].
	x _ self \\ m.
	y _ m.
	answer _ 1.
	[x > 1] whileTrue:
		[[x \\ 4 = 0] whileTrue: [x _ x // 4].
		x \\ 2 = 0
			ifTrue:
				[x _ x // 2.
				y + 2 \\ 8 > 4 ifTrue: [answer _ answer negated]].
		z _ y \\ x.
		y _ x.
		x _ z].
	^ answer! !

!Integer methodsFor: '*domains' stamp: 'len 8/20/97 02:26'!
jacobiOld: n
	"Answer the Jacoby symbol of the receiver and the argument."

	| a minusOne |
"	n odd ifFalse: [^ self error: 'the argument must by an odd positive integer']."
	a _ self \\ n.
	a = 2 ifTrue: [^ (n squared - 1) lowBit > 3 ifTrue: [1] ifFalse: [-1]].
	minusOne _ n - 1.
	a = minusOne ifTrue: [^ minusOne lowBit > 1 ifTrue: [1] ifFalse: [-1]].
	^ (a - 1 * minusOne) lowBit > 2
		ifTrue: [n jacobiOld: a] ifFalse: [(n jacobiOld: a) negated]! !

!Integer methodsFor: '*domains' stamp: 'len 7/30/2021 11:23:17'!
kronecker: anInteger
	"Answer the Kronecker symbol (a | b) for a, b integers. This is the Legendre symbol when b is an odd prime.
	See [Coh96] Algorithm 1.4.10."
	| a b v k r |
	a _ self.
	b _ anInteger.
	"1. Test b = 0"
	b == 0 ifTrue: [^ a abs == 1 ifTrue: [1] ifFalse: [0]].
	"2. Remove 2's from b"
	(a even and: [b even]) ifTrue: [^ 0].
	v _ b lowBit - 1.
	b _ b bitShift: v negated.
	"v even ifTrue: [k _ 1] ifFalse: [k _ (-1) ^ (a squared - 1 / 8)]."
	v even ifTrue: [k _ 1] ifFalse: [k _ #(0 1 0 -1 0 -1 0 1) at: (a bitAnd: 7) + 1].
	b < 0 ifTrue: [b _ b negated. a < 0 ifTrue: [k _ k negated]].
	"3. Finished?"
	[a == 0 ifTrue: [^ b == 1 "b is odd and > 0" ifTrue: [k] ifFalse: [0]].
	v _ a lowBit - 1.
	a _ a bitShift: v negated.
	"v odd ifTrue: [k _ (-1) ^ (b squared - 1 / 8) * k]."
	v odd ifTrue: [k _ (#(0 1 0 -1 0 -1 0 1) at: (b bitAnd: 7) + 1) * k].
	"4. Apply reciprocity"
	"k _ (-1) ^ ((a - 1)*(b - 1)/4) * k."
	((a bitAnd: b) bitAnd: 2) == 0 ifFalse: [k _ k negated].
	r _ a abs.
	a _ b \\ r.
	b _ r] repeat! !

!Integer methodsFor: '*domains' stamp: 'len 12/26/2016 22:53:38'!
legendre: p
	"Answer the Legendre symbol (a | p) where p is an odd prime. This is:
		1 if a is a quadratic residue modulo p and a is not 0 modulo p;
		-1 if a is a quadratic non-residue modulo p;
		0 if a is 0 modulo p.
	See also >>jacobi: and >>kronecker:."
	| answer |
	answer _ self raisedToInteger: p - 1 // 2 modulo: p.
	answer > 1 ifTrue: [answer _ answer - p].
	^ answer! !

!Integer methodsFor: '*domains' stamp: 'len 5/23/2020 10:03:14'!
minimalPolynomial
	^  polynomials x - self! !

!Integer methodsFor: '*domains' stamp: 'len 8/5/2021 08:39:48'!
moebius
	"Answer the Moebius function mu of the receiver."
	| factors |
	factors _ self factorization.
	factors asSet size = factors size ifFalse: [^ 0].
	^ factors size even ifTrue: [1] ifFalse: [-1]! !

!Integer methodsFor: '*domains' stamp: 'len 4/30/2019 11:01:13'!
multichoose: anInteger
	"Answer 'd multichoose: n', the number of ways of counting n objects from a set of d elements where repetition is allowed and order does not matter."
	^ self + anInteger - 1 choose: anInteger! !

!Integer methodsFor: '*domains' stamp: 'len 12/14/2016 14:36:14'!
multiplicativeOrder
	^ self == 1 ifTrue: [1] ifFalse: [self == -1 ifTrue: [2] ifFalse: [Infinity positive]]! !

!Integer methodsFor: '*domains' stamp: 'len 12/10/2021 19:16:18'!
normalization
	"Answer a unit u such that 'self * u' is a unique choice of associate. See >>normalized."
	^ self < 0 ifTrue: [-1] ifFalse: [1]! !

!Integer methodsFor: '*domains' stamp: 'len 7/30/2021 10:25:24'!
normalized
	"Answer a unique choice of associate. See >>normalization."
	^ self abs! !

!Integer methodsFor: '*domains' stamp: 'len 12/13/2015 02:00'!
numberOfDivisors
	^ self primeSignature inject: 1 into: [:x :each| x * (each + 1)]! !

!Integer methodsFor: '*domains' stamp: 'len 5/23/2020 10:03:23'!
parent
	^ ! !

!Integer methodsFor: '*domains' stamp: 'len 7/2/2016 20:55'!
partitions
	^ Iterator on: self performing: #partitionsDo:! !

!Integer methodsFor: '*domains' stamp: 'len 7/2/2016 20:57'!
partitionsDo: aBlock
	self < 0 ifTrue: [^ DomainError signal: 'negative number'].
	self = 0 ifTrue: [^ aBlock value: #()].
	self - 1 partitionsDo: [:each|
		aBlock value: #(1), each.
		(each size > 0 and: [each size < 2 or: [(each at: 2) > (each at: 1)]])
			ifTrue: [aBlock value: (each copy at: 1 put: (each at: 1) + 1; yourself)]]! !

!Integer methodsFor: '*domains' stamp: 'len 12/10/2016 12:18:54'!
phi
	"Answer Euler's totient function phi of the receiver."
	^ (1 to: self) count: [:each| (self gcd: each) = 1]! !

!Integer methodsFor: '*domains' stamp: 'len 12/3/2016 13:17:26'!
pollard
	"Answer a non trivial factor of the receiver.
	Pollard's p-1 algorithm is used. This works well to find a prime factor p such that p - 1 is smooth."

	| N a x y p count |
	N _ self abs.
	a _ N atRandom.
	x _ N atRandom.
	y _ x.
	count _ 1.
	[x _ x squared + a \\ self.
	y _ (y squared + a \\ self) squared + a \\ self.
	(p _ y - x gcd: self) = 1
		ifFalse: [^ Array with: p with: count].
	count _ count + 1] repeat! !

!Integer methodsFor: '*domains' stamp: 'len 12/3/2016 13:25:38'!
pollard: L
	"Answer a nontrivial factor of the receiver, or nil if fail.
	This is Pollard's p-1 algorithm. It works well with numbers divisible by a prime p such that p - 1 is smooth with some small factor q^k where k*q <= L."
	| N A F |
	N _ self abs.
	A _ (2 to: N-1) atRandom.
	1 to: L do: [:i|
		A _ A raisedTo: i modulo: N.
		(F _ A - 1 gcd: N) = 1
			ifFalse: [^ F]].
	^ nil! !

!Integer methodsFor: '*domains' stamp: 'len 8/5/2021 08:39:54'!
primeSignature
	| factors |
	factors _ self factorization.
	^ (factors asSet asSortedCollection collect: [:each| factors occurrencesOf: each]) asArray! !

!Integer methodsFor: '*domains' stamp: 'len 5/14/2020 12:34:33'!
quotientBy: anInteger modulo: m
	"Answer the Euclidean quotient of the receiver by anInteger modulo m.
	If the receiver is 'a' and anInteger is 'b', answer 'q' such that 'b*q = a mod m', or in other words 'b*q - a' is divisible by 'm' and 'q' is either 0 or the Euclidean degree of 'q' is strictly smaller than the Euclidean degree of 'm'."
	| f g fs gs h hs q r |
	f _ anInteger. fs _ 1.
	g _ m. gs _ 0.
	[g isZero] whileFalse:
		[q _ f // g. r _ f - (g*q).
		h _ g. hs _ gs.
		g _ r. gs _ fs - (q*gs).
		f _ h. fs _ hs].
	q _ self // f.
	^ fs * q \\ m! !

!Integer methodsFor: '*domains' stamp: 'len 12/14/2016 14:48:30'!
radical
	"Answer the product of the prime divisors of the receiver."
	| answer |
	answer _ self sign.
	self factorizationDo: [:p :e| answer _ answer * p].
	^ answer! !

!Integer methodsFor: '*domains' stamp: 'len 12/4/2016 13:11:44'!
reciprocalModulo2: n
	"Answer an integer x such that self * x \\ n = 1, with 0 < x < n, or nil if it doesn't exist."
	| xgcd |
	self == 0 ifTrue: [^ nil].
	self == 1 ifTrue: [^ 1].
	xgcd _ self xgcd: n.
	^ (xgcd at: 1) == 1 ifTrue: [^ (xgcd at: 2) \\ n]! !

!Integer methodsFor: '*domains' stamp: 'sqr 1/14/2014 01:30'!
reciprocalModulo: mod
	"Answer an integer x such that self * x \\ n = 1, with 0 < x < n, or nil if x does not exist.
	The algorithm is a non extended euclidean modular inversion called NINV.
	It is described in this article:
		'Using an RSA Accelerator for Modular Inversion'
	by Martin Seysen. See http://www.iacr.org/archive/ches2005/017.pdf"

	| receiver u v f fPlusN b result result2 |
	mod > 1 ifFalse: [^nil].
	receiver := (self >= mod or: [self < 0])
		ifTrue: [self \\ mod] ifFalse: [self].
	b := mod highBit + 1.
	f := 1 bitShift: b.
	v := (receiver bitShift: b) + 1.
	u := mod bitShift: b.
	fPlusN := f + mod.
	[v >= fPlusN] whileTrue:
		[v := u \\\ (u := v)].
	result := v - f.
	result2 := result + mod.
	result2 > 0 ifFalse: [^nil].
	^result positive
		ifTrue: [result]
		ifFalse: [result2]! !

!Integer methodsFor: '*domains' stamp: 'len 5/15/2020 12:11:29'!
split: anInteger
	"Answer a factor of the argument splitting off the common factors between the argument and the receiver.
	Reference: 'Fast Algorithms for Linear Algebra Modulo N', Arne Storjohann, Thom Mulders."
	| a |
	a _ self.
	anInteger highBit highBit timesRepeat: [a _ a squared \\ anInteger].
	^ anInteger // (a gcd: anInteger)! !

!Integer methodsFor: '*domains' stamp: 'len 1/20/2018 19:17:41'!
squareRoot
	self positive ifTrue: [^ RealAlgebraicNumber sqrt: self].
	^ ComplexAlgebraicNumber sqrt: self! !

!Integer methodsFor: '*domains' stamp: 'len 1/9/2022 08:35:04'!
squarefreePart
	"Answer the unique integer z such that the receiver equals z * y^2 with z squarefree and y^2 a perfect square."
	| answer |
	answer _ self sign.
	self factorizationDo: [:p :e| e even ifFalse: [answer _ answer * p]].
	^ answer! !

!Integer methodsFor: '*domains' stamp: 'len 12/12/2016 09:35:43'!
stirling: anInteger
	"Answer the Stirling number of the first kind s(n,k).
	Stirling numbers of the first kind count the ways to arrange n objects into k cycles."
	(anInteger > self or: [self < 0]) ifTrue: [^ DomainError signal].
	anInteger = 1 ifTrue: [^ (self - 1) factorial].
	self = anInteger ifTrue: [^ self Stirling: anInteger].
	self+1 = anInteger ifTrue: [^ self choose: 2].
	^ (self-1) * (self-1 stirling: anInteger) + (self-1 stirling: anInteger-1)! !

!Integer methodsFor: '*domains' stamp: 'len 6/9/2019 07:58:03'!
valuation
	"Answer the Euclidean function at the receiver."
	^ self abs! !

!Integer methodsFor: '*domains' stamp: 'len 8/7/2019 09:10:47'!
valuation: p
	"Answer the p-adic valuation of the receiver.
	This is the exponent of the highest power of p that divides the receiver."
	| answer q |
	self = 0 ifTrue: [^ Infinity positive].
	q _ self abs.
	answer _ 0.
	[p | q] whileTrue: [answer _ answer + 1. q _ q // p].
	^ answer! !

!Integer methodsFor: '*domains' stamp: 'len 1/9/2022 21:16:07'!
xgcd: anInteger
	"Extended Euclidean algorithm.
	If the receiver is 'a' and the argument is 'b'. answer an array {g. s. t} where as + bt = g = (a gcd: b)."
	| a b s1 t1 s t r1 r |
	a _ self. b _ anInteger.
	s1 _ 0. s _ 1.
	t1 _ 1. t _ 0.
	r1 _ a abs. r _ b abs.
	[r1 == 0]
		whileFalse:
			[ | q temp |
			q _ r // r1.
			temp _ r1. r1 _ r - (q * r1). r _ temp.
			temp _ s1. s1 _ s - (q * s1). s _ temp.
			temp _ t1. t1 _ t - (q * t1). t _ temp].
	s _ s * b sign. t _ t * a sign.
	^ {r. t. s}! !

!Integer methodsFor: '*domains' stamp: 'len 1/9/2022 08:09:31'!
xxgcd: anInteger
	"(More) Extended Euclidean algorithm.
	If the receiver is 'a' and the argument is 'b'. answer an array {g. s. t. u. v} where as + bt = g = (a gcd: b), au + bv = 0, and sv - ut = 1, i.e. answer the coefficients of a unimodular matrix such that:.
		[s  t] [a]
		[u v] [b] = (g 0)."
	| xgcd g |
	(self = 0 and: [anInteger = 0]) ifTrue: [^ {0. 1. 0. 0. 1}].
	^ (xgcd _ self xgcd: anInteger), {(anInteger // (g _ xgcd at: 1)) negated. self // g}! !

!SmallInteger methodsFor: '*domains' stamp: 'len 11/12/2016 08:38'!
bitCount
	"Answer the number of bits that are set, i.e. the number of 1s in the binary representation."
	| v count |
	v _ self.
	count _ 0.
	[v = 0] whileFalse: [v _ v bitAnd: v - 1. count _ count + 1].
	^ count
	
	"HACKMEM:
	| count |
	self flag: #fix.
	count _ self - ((self >> 1) bitAnd: 8r33333333333) - ((self >> 1) bitAnd: 8r11111111111).
	^ (count + (count >> 3) bitAnd: 8r30707070707) \\ 63
"
! !

!SmallInteger methodsFor: '*domains' stamp: 'len 7/2/2016 05:43'!
bitParity
	"Answer 1 if there are an odd number of bits set, 0 otherwise."
	| v parity |
	v _ self.
	parity _ 0.
	[v = 0] whileFalse: [parity _ parity bitXor: (v bitAnd: 1). v _ v bitShift: -1].
	^ parity

"	n _ self.
	n _ n bitXor: (n bitShift: -16).
	n _ n bitXor: (n bitShift: -8).
	n _ n bitXor: (n bitShift: -4).
	n _ n bitAnd: 16rF.
	^ (16r6996 bitShift: n negated) bitAnd: 1
"! !

!SmallInteger methodsFor: '*domains' stamp: 'len 7/12/2019 05:24:51'!
raisedToInteger: anInteger
	self == -1 ifTrue: [^ anInteger odd ifTrue: [-1] ifFalse: [1]].
	^ super raisedToInteger: anInteger! !

!Association methodsFor: '*domains' stamp: 'len 10/26/2020 12:15:02'!
* anAssociation
	^ self  anAssociation! !

!Association methodsFor: '*domains' stamp: 'len 10/26/2020 10:44:58'!
 anAssociation
	self value = anAssociation key ifFalse: [DomainError signal: 'domain and codomain don''t match'].
	^ self class key: key value: anAssociation value! !

!Association methodsFor: '*domains' stamp: 'len 10/26/2020 10:45:16'!
inverse
	^ self class key: value value: key! !

!BlockClosure methodsFor: '*domains' stamp: 'len 4/24/2016 06:00'!
count
	| count |
	count _ 0.
	self whileTrue: [count _ count + 1].
	^ count! !

!Collection methodsFor: '*domains' stamp: 'len 5/10/2019 04:26:01'!
/\ aCollection
	^ self intersection: aCollection! !

!Collection methodsFor: '*domains' stamp: 'len 2/19/2017 09:13:36'!
\ aCollection
	"Answer the complement of aCollection in the receiver."
	^ self reject: [:each| aCollection includes: each]! !

!Collection methodsFor: '*domains' stamp: 'len 5/10/2019 04:26:11'!
\/ aCollection
	^ self union: aCollection! !

!Collection methodsFor: '*domains' stamp: 'len 5/6/2019 03:01:10'!
 anObject
	^ anObject adaptToCollection: self andSend: #! !

!Collection methodsFor: '*domains' stamp: 'len 2/18/2003 21:40'!
anyIfNone: aBlock
	"Answer a representative sample of the receiver. This method can
	be helpful when needing to preinfer the nature of the contents of 
	semi-homogeneous collections."

	self do: [:each | ^ each].
	^aBlock value! !

!Collection methodsFor: '*domains' stamp: 'len 4/27/2018 01:29:32'!
apply: aFunction
	^ self collect: aFunction! !

!Collection methodsFor: '*domains' stamp: 'len 5/25/2018 18:10:51'!
atRandom: aRandom bits: bitSize
	^ self atRandom: aRandom! !

!Collection methodsFor: '*domains' stamp: 'len 1/30/2018 21:35:53'!
atRandomBits: anInteger
	^ self atRandom! !

!Collection methodsFor: '*domains' stamp: 'len 2/13/2003 23:19'!
copyEmpty
	^ self species new! !

!Collection methodsFor: '*domains' stamp: 'len 2/13/2003 23:19'!
copyEmpty: anInteger
	^ self species new: anInteger! !

!Collection methodsFor: '*domains' stamp: 'len 2/19/2017 10:40:52'!
intersects: aCollection
	^ self anySatisfy: [:any| aCollection includes: any]! !

!Collection methodsFor: '*domains' stamp: 'len 5/6/2019 02:58:39'!
inverse
	^ self collect: [:a | a inverse]! !

!Collection methodsFor: '*domains' stamp: 'len 6/23/2016 05:29'!
isFinite
	^ true! !

!Collection methodsFor: '*domains' stamp: 'len 6/23/2016 05:29'!
isInfinite
	^ false! !

!Collection methodsFor: '*domains' stamp: 'len 5/10/2020 12:26:12'!
isSingleton
	"Answer true if the receiver contains exactly one element."
	| seenOneElement |
	seenOneElement _ false.
	self do: [:each| seenOneElement ifTrue: [^ false]. seenOneElement _ true].
	^ seenOneElement! !

!Collection methodsFor: '*domains' stamp: 'len 5/8/2018 07:15:12'!
printElementsOn: aStream
	aStream nextPut: $(.
	self do: [:element| aStream print: element] separatedBy: [aStream nextPutAll: ', '].
	aStream nextPut: $)! !

!Collection methodsFor: '*domains' stamp: 'len 6/23/2019 04:34:56'!
upTo: max do: aBlock
	"Iterate over the elements of the receiver, just like #do:, but stop after max elements."
	| k |
	k _ 1.
	self do: [:each|
		k > max ifTrue: [^ self].
		aBlock value: each.
		k _ k+1]! !

!SequenceableCollection methodsFor: '*domains' stamp: 'len 8/12/2016 22:01'!
<= aCollection
	"Answer true if the receiver is a subcollection of aCollection."
	(aCollection isKindOf: self species) ifFalse: [^ false].
	self size <= aCollection size ifFalse: [^ false].
	^ (aCollection indexOfSubCollection: self startingAt: 1) > 0! !

!SequenceableCollection methodsFor: '*domains' stamp: 'len 3/23/2016 05:04'!
at: anInteger add: anObject
	^ self at: anInteger put: (self at: anInteger) + anObject! !

!SequenceableCollection methodsFor: '*domains' stamp: 'len 2/21/2017 18:59:40'!
combinations: r
	^ Iterator on: [:aBlock| self combinations: r atATimeDo: [:each| aBlock value: each copy]]! !

!SequenceableCollection methodsFor: '*domains' stamp: 'len 11/22/2016 05:40:12'!
convolution: aCollection
	| answer |
	self isEmpty ifTrue: [^ self].
	aCollection isEmpty ifTrue: [^ aCollection].
	answer _ self species new: self size + aCollection size - 1.
	answer atAllPut: (self at: 1) - (self at: 1).
	1 to: self size do: [:i|
		1 to: aCollection size do: [:k|
			answer at: i+k-1 add: (self at: i) * (aCollection at: k)]].
	^ answer! !

!SequenceableCollection methodsFor: '*domains' stamp: 'len 3/3/2016 23:07'!
copyWithoutIndex: index 
	| answer |
	answer _ self species new: self size - 1.
	answer replaceFrom: 1 to: index - 1 with: self startingAt: 1.
	answer replaceFrom: index to: answer size with: self startingAt: index + 1.
	^ answer! !

!SequenceableCollection methodsFor: '*domains' stamp: 'len 11/6/2016 09:06'!
isZero
	self do: [:each| each isZero ifFalse: [^ false]].
	^ true! !

!SequenceableCollection methodsFor: '*domains' stamp: 'len 2/21/2017 19:00:52'!
permutations
	^ Iterator on: [:aBlock| self permutationsDo: [:each| aBlock value: each copy]]! !

!SequenceableCollection methodsFor: '*domains' stamp: 'len 11/18/2016 08:42:32'!
permutedBy: aPermutation
	| answer |
	answer _ Array new: self size.
	1 to: self size do: [:i| answer at: (aPermutation at: i) put: (self at: i)].
	^ answer! !

!SequenceableCollection methodsFor: '*domains' stamp: 'len 11/18/2016 08:58:16'!
sum
	| answer |
	answer _ self at: 1.
	2 to: self size do: [:i| answer _ answer + (self at: i)].
	^ answer! !

!Array methodsFor: '*domains' stamp: 'len 3/4/2021 18:06:17'!
>- aCodomain
	"Answer the canonical coprojections from the components of the receiver to the argument.
	See also message -<."
	aCodomain propertyAt: #coprojections ifPresent: [:aDictionary| aDictionary at: self ifPresent: [:anArrayOfMorphisms| ^ anArrayOfMorphisms]].
	^ aCodomain fromAll: self! !

!Array methodsFor: '*domains' stamp: 'len 11/6/2016 09:26'!
printOn: aStream
	self == Smalltalk specialObjectsArray
		ifTrue: [aStream nextPutAll: 'Smalltalk specialObjectsArray' ]
		ifFalse:
			[aStream nextPut: $(.
			self do: [:each| aStream print: each] separatedBy: [aStream nextPutAll: ', '].
			aStream nextPut: $)]! !

!ByteArray methodsFor: '*domains' stamp: 'len 6/10/2020 09:20:43'!
primitivePermutationInverseInto: aByteArray
	<primitive: 'primitiveBytesPermutationInvert' module: 'DomainsPlugin'>
	self error: 'failed'! !

!FloatArray methodsFor: '*domains' stamp: 'len 5/13/2019 21:32:12'!
 anObject
	^ self dot: anObject! !

!Float64Array methodsFor: '*domains' stamp: 'len 5/13/2019 21:32:22'!
 anObject
	^ self dot: anObject! !

!Interval methodsFor: '*domains' stamp: 'len 11/14/2016 13:59'!
isStandard
	"Answer true if the receiver is an interval [1..n]."
	^ start = 1 and: [stop isInteger and: [stop >= 1 and: [stop - start + 1 = count]]]! !

!Interval methodsFor: '*domains' stamp: 'len 11/14/2016 10:15'!
printOn: aStream
	self increment = 1
		ifTrue: [aStream nextPut: $[; print: start; nextPutAll: '..'; print: stop; nextPut: $]]
		ifFalse: [self storeOn: aStream]! !

!Interval methodsFor: '*domains' stamp: 'len 11/14/2016 10:14'!
storeOn: aStream
	aStream nextPut: $(; print: start; nextPutAll: ' to: '; print: stop.
	self increment ~= 1 ifTrue: [aStream nextPutAll: ' by: '; print: self increment].
	aStream nextPut: $)! !

!Bag methodsFor: '*domains' stamp: 'len 4/24/2018 17:42:11'!
apply: aFunction
	| answer |
	answer _ self species new.
	self withOccurrencesDo: [:each :times| answer add: (aFunction value: each) withOccurrences: times].
	^ answer! !

!Bag methodsFor: '*domains' stamp: 'len 8/5/2021 08:32:53'!
printOn: aStream
	aStream nextPut: ${.
	self asSet
		do: [:each|
			| times |
			times _ self occurrencesOf: each.
			(each printString isAlphaNumeric or: [times = 1])
				ifTrue: [aStream print: each]
				ifFalse: [aStream nextPut: $(; print: each; nextPut: $)].
			times > 1 ifTrue: [aStream nextPutAll: times printString super]]
		separatedBy: [aStream nextPutAll: ', '].
	aStream nextPut: $}! !

!Bag methodsFor: '*domains' stamp: 'len 12/10/2016 11:26:24'!
withOccurrencesDo: aBlock
	contents associationsDo: [:each| aBlock value: each key value: each value]! !

!Set methodsFor: '*domains' stamp: 'len 4/27/2016 02:28'!
add: newObject ifAbsent: aBlock
	"Include newObject as one of the receiver's elements, but only if
	not already present. Answer newObject."

	| index |
	newObject ifNil: [self error: 'Sets cannot meaningfully contain nil as an element'].
	index _ self findElementOrNil: newObject.
	(array at: index) ifNil: [self atNewIndex: index put: newObject. aBlock value].
	^ newObject! !

!Set methodsFor: '*domains' stamp: 'len 5/12/2016 23:24'!
add: newObject ifPresent: aBlock
	"Include newObject as one of the receiver's elements, but only if
	not already present. Answer newObject."

	| index |
	newObject ifNil: [self error: 'Sets cannot meaningfully contain nil as an element'].
	index _ self findElementOrNil: newObject.
	(array at: index) isNil
		ifTrue: [self atNewIndex: index put: newObject]
		ifFalse: [aBlock value].
	^ newObject! !

!Set methodsFor: '*domains' stamp: 'len 7/31/2020 11:44:10'!
asDomain
	^ self as: Structure! !

!Set methodsFor: '*domains' stamp: 'len 11/7/2016 09:28'!
printOn: aStream
	(self isMemberOf: Set)
		ifFalse: [^ super printOn: aStream].
	aStream nextPut: ${.
	self do: [:each| aStream print: each] separatedBy: [aStream nextPutAll: ', '].
	aStream nextPut: $}! !

!Dictionary methodsFor: '*domains' stamp: 'len 11/30/2016 14:47:44'!
at: key add: value
	| index assoc |
	index _ self findElementOrNil: key.
	assoc _ array at: index.
	assoc
		ifNil:
			[value isZero ifFalse: [self atNewIndex: index put: (Association key: key value: value)]]
		ifNotNil:
			[|newValue|
			newValue _ assoc value + value.
			assoc value: newValue.
			^ newValue].
	^ value! !

!Dictionary methodsFor: '*domains' stamp: 'len 11/30/2016 14:47:14'!
at: key addAndRemoveIfZero: value
	| index assoc |
	index _ self findElementOrNil: key.
	assoc _ array at: index.
	assoc
		ifNil:
			[value isZero ifFalse: [self atNewIndex: index put: (Association key: key value: value)]]
		ifNotNil:
			[|newValue|
			newValue _ assoc value + value.
			newValue isZero
				ifTrue:
					[array at: index put: nil.
					tally _ tally - 1.
					self fixCollisionsFrom: index]
				ifFalse: [assoc value: newValue].
			^ newValue].
	^ value! !

!Dictionary methodsFor: '*domains' stamp: 'len 3/6/2017 19:54:46'!
printElementsOn: aStream
	aStream nextPut: ${.
	self keysSortedSafely do:
		[:key | aStream print: key; nextPutAll: '->'; print: (self at: key)] separatedBy: [aStream space].
	aStream nextPut: $}! !

!Graph methodsFor: '*domains-comparing' stamp: 'len 7/23/2016 04:06'!
~ aGraph
	"Answer true if the receiver is isomorphic to aGraph."
	| n G H |
	self isLabeled ifTrue: [self notYetImplemented].
	self species = aGraph species ifFalse: [^ false].
	(n _ self size) = aGraph size ifFalse: [^ false].
	"we could insert some heuristic tests here, comparing easy-to-compute invariants"
	G _ self asStandard.
	H _ aGraph asStandard.
	(SymmetricGroup new: n) do: [:each| (G apply: each) = H ifTrue: [^ true]].
	^ false! !

!Graph methodsFor: '*domains-operations' stamp: 'len 6/2/2020 11:51:18'!
adjacencyMatrix
	"Answer the adjacency matrix of the receiver, assuming that the vertices are the integers {1,..,n}.
	If the graph is labelled, use the labels as entries in the matrix."
	| n matrix |
	n _ self order.
	matrix _ (^n) endomorphisms zero.
	self edgesAndLabelsDo: [:edge :label| matrix at: edge key @ edge value add: (label ifNil: [1])].
	^ matrix! !

!Graph methodsFor: '*domains-operations' stamp: 'len 6/1/2020 13:59:25'!
adjacencyMatrix: vertices
	"Answer the adjacency matrix of the receiver, using the vertex ordering given by the argument."
	^ (^vertices size) endomorphisms filling: [:i :j| self multiplicityFrom: (vertices at: i) to: (vertices at: j)]! !

!Graph methodsFor: '*domains-operations' stamp: 'len 5/10/2020 09:52:40'!
automorphisms
	"Answer the group of symmetries of the receiver, i.e. the group of permutations of vertices that don't change the graph."
	| S |
	S _ SymmetricGroup on: self values.
	^ S span: (S select: [:each| (self apply: each) = self])! !

!Graph methodsFor: '*domains-operations' stamp: 'len 7/25/2016 02:37'!
automorphismsWithInvariant: aBlock
	"Answer the group of symmetries of the receiver, i.e. the group of permutations of vertices that don't change the graph."
	| partition |
	partition _ Dictionary new.
	self nodesDo: [:each| (partition at: (aBlock value: each) ifAbsentPut: [OrderedCollection new]) add: each value].
	^ self automorphismsWithPartition: partition! !

!Graph methodsFor: '*domains-operations' stamp: 'len 6/2/2020 12:11:00'!
automorphismsWithPartition: aCollection
	"Answer the group of symmetries of the receiver, i.e. the group of permutations of vertices that don't change the graph."
	| product automorphisms |
	product _ CartesianProduct components: (aCollection collect: [:each| SymmetricGroup on: each]).
	automorphisms _ OrderedCollection new.
	product do: [:each|
		| f |
		f _ each product.
		(self apply: f) = self ifTrue: [automorphisms add: f]].
	^ (SymmetricGroup on: self values) span: automorphisms! !

!Graph methodsFor: '*domains-operations' stamp: 'len 7/13/2016 22:06'!
chromaticNumber
	"The minimum number of colors to do a proper coloring of the graph."
	| chi |
	chi _ self chromaticPolynomial.
	^ (1 to: self size) detect: [:i| (chi value: i) > 0]! !

!Graph methodsFor: '*domains-operations' stamp: 'len 5/23/2020 09:34:55'!
chromaticPolynomial
	"The chromatic polynomial P(G,k) is a polynomial in k that counts the number of k-colorings of G."
	^ self chromaticPolynomialAt:  polynomials x! !

!Graph methodsFor: '*domains-operations' stamp: 'len 7/14/2016 06:50'!
chromaticPolynomialAt: k
	"The chromatic polynomial P(G,k) is a polynomial in k that counts the number of k-colorings of G. Answer the evaluation at k."
	self isEdgeless ifTrue: [^ k ^ self size].
	self edgesDo: [:each|
		each key = each value
			ifFalse: [^ ((self - each) chromaticPolynomialAt: k) - ((self / each) chromaticPolynomialAt: k)]].
	^ k*0! !

!Graph methodsFor: '*domains-random' stamp: 'len 7/21/2016 01:53'!
shuffledBy: aRandom
	^ self collect: ((SymmetricGroup on: self values) atRandom: aRandom)! !

!UndirectedGraph methodsFor: '*domains-operations' stamp: 'len 5/23/2020 09:34:55'!
flowPolynomial
	"The flow polynomial F(G,k) is a polynomial in k that counts the number of nowhere-zero k-flows of G."
	| x |
	x _  polynomials x.
	^ (-1)^(self size + self numberOfEdges + self components size) * (self tuttePolynomial value: {0. 1 - x})! !

!UndirectedGraph methodsFor: '*domains-operations' stamp: 'len 5/23/2020 09:34:55'!
tuttePolynomial
	| P K G |
	P _  polynomialsIn: #(x y).
	self isEdgeless ifTrue: [^ P one].
	K _ self components size.
	self edgesDo: [:e|
		e key = e value "it's a loop"
			ifTrue: [^ P y * (self - e) tuttePolynomial]
			ifFalse:
				[G _ self - e.
				G components size > K "it's a bridge"
					ifTrue: [^ P x * (self / e) tuttePolynomial]
					ifFalse: [^ G tuttePolynomial + (self / e) tuttePolynomial]]].
	^ self error: 'inconsistency, this line should have been reaached'! !

!Stream methodsFor: '*domains' stamp: 'len 5/15/2020 06:10:16'!
printWithParenthesis: anObject
	(anObject printString includesAnyOf: ' +-/')
		ifTrue: [self nextPut: $(; print: anObject; nextPut: $)]
		ifFalse: [self print: anObject]! !

!Point methodsFor: '*domains' stamp: 'len 2/25/2016 17:01'!
norm
	^ (x*x + (y*y)) sqrt! !

!Point methodsFor: '*domains' stamp: 'len 2/25/2016 17:00'!
norm2
	^ x*x + (y*y)! !

!StrikeFont class methodsFor: '*domains-character shapes' stamp: 'len 12/8/2016 12:11:12'!
buildMathFont
	"
	StrikeFont buildMathFont
	"
	#(5 6 7 8 9 10 11 12 13 14 17 22) do: [:pointSize| self buildMathFont: pointSize]! !

!StrikeFont class methodsFor: '*domains-character shapes' stamp: 'len 3/7/2017 08:00:46'!
buildMathFont: pointSize
	| font normal larger muchLarger |
	font _ AbstractFont familyName: 'DejaVu Sans Mono' pointSize: pointSize.
	font characterToGlyphMap at: 96 put: 28. "use left arrow instead of underscore"
	normal _ AbstractFont familyName: 'DejaVu' pointSize: pointSize.
"	#(1 0) detect: [:one| (slightlyLarger _ (AbstractFont familyName: 'DejaVu' pointSize: pointSize+one)) notNil]."
	#(2 1 3 0) detect: [:one| (larger _ (AbstractFont familyName: 'DejaVu' pointSize: pointSize+one)) notNil].
	#(4 3 2 1 0) detect: [:one| (muchLarger _ (AbstractFont familyName: 'DejaVu' pointSize: pointSize+one)) notNil].
	"replace some math glyphs with their normal counterpart, because the monospaced glyphs are far too small (and some are missing):"
	'' do: [:each|
		font takeAllGlyphFor: each from: each in: normal].
"	'' do: [:each|
		font takeAllGlyphFor: each from: each in: slightlyLarger].
"	'' do: [:each|
		font takeAllGlyphFor: each from: each in: larger].
	'' do: [:each|
		font takeAllGlyphFor: each from: each in: muchLarger].
	"make arrows bigger"
	'' do: [:each|
		font takeAllGlyphFor: each from: each in: larger]! !

!StrikeFont class methodsFor: '*domains-character shapes' stamp: 'len 3/7/2017 08:03:34'!
installMathFonts
"
StrikeFont installMathFonts
"
	| family codeFamily |
	StrikeFont install: 'DejaVu'.
	StrikeFont install: 'DejaVu Sans Mono'.
	StrikeFont buildMathFont.
	Character initialize.
	family _ 'DejaVu Sans Mono'.
	codeFamily _ 'DejaVu Sans Mono'.
	Preferences setDefaultFonts: {
		{#setSystemFontTo:. family. 10}.
		{#setListFontTo:. family. 10}.
		{#setMenuFontTo:. family. 9}.
		{#setWindowTitleFontTo:. family. 10}.
		{#setCodeFontTo:. codeFamily. 10}.
		{#setButtonFontTo:. family. 9}}.
	DisplayScreen runningWorld ifNotNil: [ :world | world fontPreferenceChanged ].
! !

!Morph methodsFor: '*domains' stamp: 'len 12/5/2016 11:59:49'!
findA: aClass
	^ self findDeepSubmorphThat: [:each| each isKindOf: aClass] ifAbsent: [self error: 'not found']! !

!BitBltCanvas methodsFor: '*domains' stamp: 'len 5/23/2020 07:16:22'!
fillEllipse: aRectangle color: aColor
	| displayRectangle |
	displayRectangle _ (currentTransformation displayBoundsOfTransformOf: aRectangle) truncated.
	self setPaintColor: aColor.
	engine fillOval: displayRectangle! !

!BitBltCanvas methodsFor: '*domains' stamp: 'len 2/18/2016 06:43'!
fillEllipse: aRectangle color: aColor borderWidth: borderWidth borderColor: borderColor
	self fillEllipse: (aRectangle insetBy: borderWidth) color: aColor.
	(borderWidth > 0 and: [borderColor isTransparent not])
		ifTrue: [self frameEllipse: aRectangle borderWidth: borderWidth color: borderColor]! !

!BitBltCanvas methodsFor: '*domains' stamp: 'len 5/23/2020 07:16:14'!
frameEllipse: aRectangle borderWidth: borderWidth color: aColor
	| displayRectangle |
	displayRectangle _ (currentTransformation displayBoundsOfTransformOf: aRectangle) truncated.
	self setPaintColor: aColor.
	engine frameOval: displayRectangle borderWidth: borderWidth! !

!Complex methodsFor: '*domains' stamp: 'len 1/22/2017 08:13:12'!
^ aNumber
	^ self raisedTo: aNumber! !

!Complex methodsFor: '*domains' stamp: 'len 8/9/2020 07:47:37'!
conjugate
	^self class real: real imaginary: imaginary negated! !

!Complex methodsFor: '*domains' stamp: 'len 12/6/2016 13:18:52'!
isInfinite
	^ real isInfinite or: [imaginary isInfinite]! !

!Complex methodsFor: '*domains' stamp: 'len 8/5/2016 21:45'!
isReal
	^ self imaginary isZero! !

!Complex methodsFor: '*domains' stamp: 'len 3/3/2016 01:01'!
norm
	^ (real squared + imaginary squared) squareRoot! !

!Complex methodsFor: '*domains' stamp: 'len 1/11/2016 05:54'!
norm2
	^ real squared + imaginary squared! !

!Complex methodsFor: '*domains' stamp: 'len 12/26/2015 19:56'!
one
	^ self class real: real one imaginary: imaginary zero! !

!Complex methodsFor: '*domains' stamp: 'len 5/23/2020 10:12:18'!
parent
	^ ! !

!Complex methodsFor: '*domains' stamp: 'len 11/29/2016 11:42:24'!
printOn: aStream
	(real ~= 0 or: [imaginary = 0])
		ifTrue:
			[aStream print: real.
			imaginary = 0
				ifFalse:
					[aStream space.
					imaginary positive
						ifTrue: [aStream nextPut: $+]
						ifFalse: [aStream nextPut: $-].
					aStream space.
					imaginary abs = 1 ifFalse: [aStream print: imaginary abs].
					aStream nextPutAll: 'i' italic]]
		ifFalse:
			[imaginary negative
				ifTrue: [aStream nextPut: $-].
			imaginary abs = 1 ifFalse: [aStream print: imaginary abs].
			aStream nextPutAll: 'i' italic]! !

!Complex methodsFor: '*domains' stamp: 'len 1/4/2022 12:51:00'!
rounded
	^ self class real: real rounded imaginary: imaginary rounded! !

!Complex methodsFor: '*domains' stamp: 'len 12/26/2015 19:56'!
zero
	^ self class real: real zero imaginary: imaginary zero! !
Ordinal initialize!
Naturals initialize!
RationalField initialize!
GaloisRing initialize!
RationalIntegerRing initialize!
ComplexField initialize!
RealField initialize!
UpperHalfPlane initialize!
Function initialize!
Functor initialize!
MonoidMap initialize!
GroupMap initialize!
LatticeMap initialize!
RingMap initialize!
SimplicialMap initialize!
BitTuple initialize!
