'From Cuis 5.0 of 7 November 2016 [latest update: #3784] on 6 June 2019 at 1:36:35 pm'!
'Description A computational algebra system in Smalltalk'!
!provides: 'Domains' 1 516!
!requires: 'RayTracer' 1 2 nil!
SystemOrganization addCategory: #'Domains-Kernel'!
SystemOrganization addCategory: #'Domains-Kernel-Support'!
SystemOrganization addCategory: #'Domains-Sets'!
SystemOrganization addCategory: #'Domains-Monoids'!
SystemOrganization addCategory: #'Domains-Monoids-Orderings'!
SystemOrganization addCategory: #'Domains-Groups'!
SystemOrganization addCategory: #'Domains-Groups-Permutations'!
SystemOrganization addCategory: #'Domains-Groups-Linear'!
SystemOrganization addCategory: #'Domains-Groups-Affine'!
SystemOrganization addCategory: #'Domains-Groups-Algorithms'!
SystemOrganization addCategory: #'Domains-Rings'!
SystemOrganization addCategory: #'Domains-Rings-Finite'!
SystemOrganization addCategory: #'Domains-Rings-Adic'!
SystemOrganization addCategory: #'Domains-Fields'!
SystemOrganization addCategory: #'Domains-Fields-Finite'!
SystemOrganization addCategory: #'Domains-Fields-Number Fields'!
SystemOrganization addCategory: #'Domains-Modules'!
SystemOrganization addCategory: #'Domains-Modules-Free'!
SystemOrganization addCategory: #'Domains-Modules-Complexes'!
SystemOrganization addCategory: #'Domains-Modules-Tuples'!
SystemOrganization addCategory: #'Domains-Modules-Matrices'!
SystemOrganization addCategory: #'Domains-Modules-Matrices-Algorithms'!
SystemOrganization addCategory: #'Domains-Modules-Lattices'!
SystemOrganization addCategory: #'Domains-Modules-Tensors'!
SystemOrganization addCategory: #'Domains-Modules-Multivariate'!
SystemOrganization addCategory: #'Domains-Modules-Multivariate-Orderings'!
SystemOrganization addCategory: #'Domains-Polynomials'!
SystemOrganization addCategory: #'Domains-Polynomials-Algorithms'!
SystemOrganization addCategory: #'Domains-Schemes'!
SystemOrganization addCategory: #'Domains-Schemes-Affine'!
SystemOrganization addCategory: #'Domains-Schemes-Projective'!
SystemOrganization addCategory: #'Domains-Schemes-Projective-Product'!
SystemOrganization addCategory: #'Domains-Codes'!
SystemOrganization addCategory: #'Domains-Algorithms'!
SystemOrganization addCategory: #'Domains-Sequences'!
SystemOrganization addCategory: #'Domains-Graphs'!
SystemOrganization addCategory: #'Domains-Graphs-Parts'!
SystemOrganization addCategory: #'Domains-Graphs-Algorithms'!
SystemOrganization addCategory: #'Domains-Graphs-Morphic'!
SystemOrganization addCategory: #'Domains-Tableaux'!
SystemOrganization addCategory: #'Domains-Complexes'!
SystemOrganization addCategory: #'Domains-Elliptic Curves'!
SystemOrganization addCategory: #'Domains-Modular Forms'!
SystemOrganization addCategory: #'Domains-Modular Group'!
SystemOrganization addCategory: #'Domains-Morphic'!
SystemOrganization addCategory: #'Domains-Etc'!
SystemOrganization addCategory: #'Domains-Etc-Lie'!
SystemOrganization addCategory: #'Domains-Etc-Approximate'!
SystemOrganization addCategory: #'Domains-Etc-Diagrams'!
SystemOrganization addCategory: #'Domains-Etc-Algebras'!
SystemOrganization addCategory: #'Domains-Etc-Groups-Abelian'!


!classDefinition: #RealAlgebraicNumber category: #'Domains-Fields'!
Number subclass: #RealAlgebraicNumber
	instanceVariableNames: 'minimalPolynomial bounds rightSign'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Fields'!
!classDefinition: 'RealAlgebraicNumber class' category: #'Domains-Fields'!
RealAlgebraicNumber class
	instanceVariableNames: ''!

!classDefinition: #ContinuedFraction category: #'Domains-Sequences'!
Number subclass: #ContinuedFraction
	instanceVariableNames: 'coefficients'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Sequences'!
!classDefinition: 'ContinuedFraction class' category: #'Domains-Sequences'!
ContinuedFraction class
	instanceVariableNames: ''!

!classDefinition: #DyadicFraction category: #'Domains-Etc'!
Number subclass: #DyadicFraction
	instanceVariableNames: 'numerator shift'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'DyadicFraction class' category: #'Domains-Etc'!
DyadicFraction class
	instanceVariableNames: ''!

!classDefinition: #MutualAssociation category: #'Domains-Graphs-Parts'!
Association subclass: #MutualAssociation
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Graphs-Parts'!
!classDefinition: 'MutualAssociation class' category: #'Domains-Graphs-Parts'!
MutualAssociation class
	instanceVariableNames: ''!

!classDefinition: #Aleph category: #'Domains-Kernel-Support'!
Magnitude subclass: #Aleph
	instanceVariableNames: 'order'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Kernel-Support'!
!classDefinition: 'Aleph class' category: #'Domains-Kernel-Support'!
Aleph class
	instanceVariableNames: ''!

!classDefinition: #Infinity category: #'Domains-Kernel-Support'!
Magnitude subclass: #Infinity
	instanceVariableNames: 'sign'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Kernel-Support'!
!classDefinition: 'Infinity class' category: #'Domains-Kernel-Support'!
Infinity class
	instanceVariableNames: ''!

!classDefinition: #BitArray category: #'Domains-Etc'!
ArrayedCollection subclass: #BitArray
	instanceVariableNames: 'bytes length'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'BitArray class' category: #'Domains-Etc'!
BitArray class
	instanceVariableNames: ''!

!classDefinition: #LinearBasis category: #'Domains-Etc'!
ArrayedCollection subclass: #LinearBasis
	instanceVariableNames: 'ambient matrix'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'LinearBasis class' category: #'Domains-Etc'!
LinearBasis class
	instanceVariableNames: ''!

!classDefinition: #StandardBasis category: #'Domains-Polynomials-Algorithms'!
SequenceableCollection subclass: #StandardBasis
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Polynomials-Algorithms'!
!classDefinition: 'StandardBasis class' category: #'Domains-Polynomials-Algorithms'!
StandardBasis class
	instanceVariableNames: ''!

!classDefinition: #GroebnerBasis category: #'Domains-Polynomials-Algorithms'!
StandardBasis subclass: #GroebnerBasis
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Polynomials-Algorithms'!
!classDefinition: 'GroebnerBasis class' category: #'Domains-Polynomials-Algorithms'!
GroebnerBasis class
	instanceVariableNames: ''!

!classDefinition: #KeyedSet category: #'Domains-Kernel-Support'!
Set subclass: #KeyedSet
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Kernel-Support'!
!classDefinition: 'KeyedSet class' category: #'Domains-Kernel-Support'!
KeyedSet class
	instanceVariableNames: ''!

!classDefinition: #Iterator category: #'Domains-Kernel-Support'!
Collection subclass: #Iterator
	instanceVariableNames: 'block'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Kernel-Support'!
!classDefinition: 'Iterator class' category: #'Domains-Kernel-Support'!
Iterator class
	instanceVariableNames: ''!

!classDefinition: #Graph category: #'Domains-Graphs'!
Collection subclass: #Graph
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Graphs'!
!classDefinition: 'Graph class' category: #'Domains-Graphs'!
Graph class
	instanceVariableNames: ''!

!classDefinition: #Digraph category: #'Domains-Graphs'!
Graph subclass: #Digraph
	instanceVariableNames: 'nodes nodeCreator type'
	classVariableNames: 'InitializationBlocks'
	poolDictionaries: ''
	category: 'Domains-Graphs'!
!classDefinition: 'Digraph class' category: #'Domains-Graphs'!
Digraph class
	instanceVariableNames: ''!

!classDefinition: #RootedDigraph category: #'Domains-Graphs'!
Digraph subclass: #RootedDigraph
	instanceVariableNames: 'roots'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Graphs'!
!classDefinition: 'RootedDigraph class' category: #'Domains-Graphs'!
RootedDigraph class
	instanceVariableNames: ''!

!classDefinition: #UndirectedGraph category: #'Domains-Graphs'!
Graph subclass: #UndirectedGraph
	instanceVariableNames: 'digraph'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Graphs'!
!classDefinition: 'UndirectedGraph class' category: #'Domains-Graphs'!
UndirectedGraph class
	instanceVariableNames: ''!

!classDefinition: #YoungTableau category: #'Domains-Tableaux'!
Collection subclass: #YoungTableau
	instanceVariableNames: 'rows'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Tableaux'!
!classDefinition: 'YoungTableau class' category: #'Domains-Tableaux'!
YoungTableau class
	instanceVariableNames: ''!

!classDefinition: #Simplex category: #'Domains-Complexes'!
Collection subclass: #Simplex
	instanceVariableNames: 'vertices'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Complexes'!
!classDefinition: 'Simplex class' category: #'Domains-Complexes'!
Simplex class
	instanceVariableNames: ''!

!classDefinition: #MonomialIndexedTuple category: #'Domains-Etc'!
Collection subclass: #MonomialIndexedTuple
	instanceVariableNames: 'scalars associations'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'MonomialIndexedTuple class' category: #'Domains-Etc'!
MonomialIndexedTuple class
	instanceVariableNames: ''!

!classDefinition: #CompositeGraphMorph category: #'Domains-Graphs-Morphic'!
LayoutMorph subclass: #CompositeGraphMorph
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Graphs-Morphic'!
!classDefinition: 'CompositeGraphMorph class' category: #'Domains-Graphs-Morphic'!
CompositeGraphMorph class
	instanceVariableNames: ''!

!classDefinition: #GraphMorph category: #'Domains-Graphs-Morphic'!
RectangleLikeMorph subclass: #GraphMorph
	instanceVariableNames: 'graph nodeToMorph edgeToMorph focusNode dimension lastMousePosition components'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Graphs-Morphic'!
!classDefinition: 'GraphMorph class' category: #'Domains-Graphs-Morphic'!
GraphMorph class
	instanceVariableNames: ''!

!classDefinition: #SpringGraphMorph category: #'Domains-Graphs-Morphic'!
GraphMorph subclass: #SpringGraphMorph
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Graphs-Morphic'!
!classDefinition: 'SpringGraphMorph class' category: #'Domains-Graphs-Morphic'!
SpringGraphMorph class
	instanceVariableNames: ''!

!classDefinition: #GraphNodeMorph category: #'Domains-Graphs-Morphic'!
RectangleLikeMorph subclass: #GraphNodeMorph
	instanceVariableNames: 'node x dx shape label labelMorph'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Graphs-Morphic'!
!classDefinition: 'GraphNodeMorph class' category: #'Domains-Graphs-Morphic'!
GraphNodeMorph class
	instanceVariableNames: ''!

!classDefinition: #SpringNodeMorph category: #'Domains-Graphs-Morphic'!
GraphNodeMorph subclass: #SpringNodeMorph
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Graphs-Morphic'!
!classDefinition: 'SpringNodeMorph class' category: #'Domains-Graphs-Morphic'!
SpringNodeMorph class
	instanceVariableNames: ''!

!classDefinition: #ComplexPlotMorph category: #'Domains-Morphic'!
RectangleLikeMorph subclass: #ComplexPlotMorph
	instanceVariableNames: 'function image box palette'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Morphic'!
!classDefinition: 'ComplexPlotMorph class' category: #'Domains-Morphic'!
ComplexPlotMorph class
	instanceVariableNames: ''!

!classDefinition: #FunctionPlotMorph category: #'Domains-Morphic'!
RectangleLikeMorph subclass: #FunctionPlotMorph
	instanceVariableNames: 'backgroundColor fillColor textColor function xMin xMax yMin yMax evaluationPoints values firstMousePosition lastMousePosition'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Morphic'!
!classDefinition: 'FunctionPlotMorph class' category: #'Domains-Morphic'!
FunctionPlotMorph class
	instanceVariableNames: ''!

!classDefinition: #HistogramMorph category: #'Domains-Morphic'!
RectangleLikeMorph subclass: #HistogramMorph
	instanceVariableNames: 'backgroundColor textColor tallies extraBinsForClampedValues lowBinCenter highBinCenter'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Morphic'!
!classDefinition: 'HistogramMorph class' category: #'Domains-Morphic'!
HistogramMorph class
	instanceVariableNames: ''!

!classDefinition: #ImplicitFunctionPlotMorph category: #'Domains-Morphic'!
RectangleLikeMorph subclass: #ImplicitFunctionPlotMorph
	instanceVariableNames: 'function image box'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Morphic'!
!classDefinition: 'ImplicitFunctionPlotMorph class' category: #'Domains-Morphic'!
ImplicitFunctionPlotMorph class
	instanceVariableNames: ''!

!classDefinition: #ImplicitSurfacePlotMorph category: #'Domains-Morphic'!
RectangleLikeMorph subclass: #ImplicitSurfacePlotMorph
	instanceVariableNames: 'polynomial rotation scaling surface scene camera image resolutionRatio lastMousePosition'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Morphic'!
!classDefinition: 'ImplicitSurfacePlotMorph class' category: #'Domains-Morphic'!
ImplicitSurfacePlotMorph class
	instanceVariableNames: ''!

!classDefinition: #MultiplicationTableMorph category: #'Domains-Morphic'!
RectangleLikeMorph subclass: #MultiplicationTableMorph
	instanceVariableNames: 'elements colors operation'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Morphic'!
!classDefinition: 'MultiplicationTableMorph class' category: #'Domains-Morphic'!
MultiplicationTableMorph class
	instanceVariableNames: ''!

!classDefinition: #ScalarPlotMorph category: #'Domains-Morphic'!
RectangleLikeMorph subclass: #ScalarPlotMorph
	instanceVariableNames: 'function palette xMin xMax yMin yMax form'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Morphic'!
!classDefinition: 'ScalarPlotMorph class' category: #'Domains-Morphic'!
ScalarPlotMorph class
	instanceVariableNames: ''!

!classDefinition: #ScatterPlotMorph category: #'Domains-Morphic'!
RectangleLikeMorph subclass: #ScatterPlotMorph
	instanceVariableNames: 'points transformation max min positionBlock colorBlock sizeBlock lastMousePosition'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Morphic'!
!classDefinition: 'ScatterPlotMorph class' category: #'Domains-Morphic'!
ScatterPlotMorph class
	instanceVariableNames: ''!

!classDefinition: #UnitDiskPlotMorph category: #'Domains-Morphic'!
RectangleLikeMorph subclass: #UnitDiskPlotMorph
	instanceVariableNames: 'function image palette inverseMap'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Morphic'!
!classDefinition: 'UnitDiskPlotMorph class' category: #'Domains-Morphic'!
UnitDiskPlotMorph class
	instanceVariableNames: ''!

!classDefinition: #GraphEdgeMorph category: #'Domains-Graphs-Morphic'!
Morph subclass: #GraphEdgeMorph
	instanceVariableNames: 'color source target width drawArrowHead label labelMorph multiplicity'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Graphs-Morphic'!
!classDefinition: 'GraphEdgeMorph class' category: #'Domains-Graphs-Morphic'!
GraphEdgeMorph class
	instanceVariableNames: ''!

!classDefinition: #SpringEdgeMorph category: #'Domains-Graphs-Morphic'!
GraphEdgeMorph subclass: #SpringEdgeMorph
	instanceVariableNames: 'desiredDistance'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Graphs-Morphic'!
!classDefinition: 'SpringEdgeMorph class' category: #'Domains-Graphs-Morphic'!
SpringEdgeMorph class
	instanceVariableNames: ''!

!classDefinition: #ImplicitSurface category: #'Domains-Morphic'!
RayTraceObject subclass: #ImplicitSurface
	instanceVariableNames: 'polynomial gradient radiusSquared interiorTexture'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Morphic'!
!classDefinition: 'ImplicitSurface class' category: #'Domains-Morphic'!
ImplicitSurface class
	instanceVariableNames: ''!

!classDefinition: #Domain category: #'Domains-Kernel'!
Object subclass: #Domain
	instanceVariableNames: 'properties'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Kernel'!
!classDefinition: 'Domain class' category: #'Domains-Kernel'!
Domain class
	instanceVariableNames: ''!

!classDefinition: #HomSet category: #'Domains-Kernel'!
Domain subclass: #HomSet
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Kernel'!
!classDefinition: 'HomSet class' category: #'Domains-Kernel'!
HomSet class
	instanceVariableNames: ''!

!classDefinition: #PointSet category: #'Domains-Schemes'!
HomSet subclass: #PointSet
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Schemes'!
!classDefinition: 'PointSet class' category: #'Domains-Schemes'!
PointSet class
	instanceVariableNames: ''!

!classDefinition: #AbelianGroupHomSet category: #'Domains-Etc-Groups-Abelian'!
HomSet subclass: #AbelianGroupHomSet
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc-Groups-Abelian'!
!classDefinition: 'AbelianGroupHomSet class' category: #'Domains-Etc-Groups-Abelian'!
AbelianGroupHomSet class
	instanceVariableNames: ''!

!classDefinition: #ComplexBox category: #'Domains-Kernel-Support'!
Domain subclass: #ComplexBox
	instanceVariableNames: 'real imaginary'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Kernel-Support'!
!classDefinition: 'ComplexBox class' category: #'Domains-Kernel-Support'!
ComplexBox class
	instanceVariableNames: ''!

!classDefinition: #ComplexDisk category: #'Domains-Kernel-Support'!
Domain subclass: #ComplexDisk
	instanceVariableNames: 'center radius'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Kernel-Support'!
!classDefinition: 'ComplexDisk class' category: #'Domains-Kernel-Support'!
ComplexDisk class
	instanceVariableNames: ''!

!classDefinition: #RealBox category: #'Domains-Kernel-Support'!
Domain subclass: #RealBox
	instanceVariableNames: 'components'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Kernel-Support'!
!classDefinition: 'RealBox class' category: #'Domains-Kernel-Support'!
RealBox class
	instanceVariableNames: ''!

!classDefinition: #RealInterval category: #'Domains-Kernel-Support'!
Domain subclass: #RealInterval
	instanceVariableNames: 'left right rightOpen leftOpen'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Kernel-Support'!
!classDefinition: 'RealInterval class' category: #'Domains-Kernel-Support'!
RealInterval class
	instanceVariableNames: ''!

!classDefinition: #CartesianProduct category: #'Domains-Sets'!
Domain subclass: #CartesianProduct
	instanceVariableNames: 'components'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Sets'!
!classDefinition: 'CartesianProduct class' category: #'Domains-Sets'!
CartesianProduct class
	instanceVariableNames: ''!

!classDefinition: #EquivalenceClass category: #'Domains-Sets'!
Domain subclass: #EquivalenceClass
	instanceVariableNames: 'representative'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Sets'!
!classDefinition: 'EquivalenceClass class' category: #'Domains-Sets'!
EquivalenceClass class
	instanceVariableNames: ''!

!classDefinition: #EquivalenceRelation category: #'Domains-Sets'!
Domain subclass: #EquivalenceRelation
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Sets'!
!classDefinition: 'EquivalenceRelation class' category: #'Domains-Sets'!
EquivalenceRelation class
	instanceVariableNames: ''!

!classDefinition: #Naturals category: #'Domains-Sets'!
Domain subclass: #Naturals
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Sets'!
!classDefinition: 'Naturals class' category: #'Domains-Sets'!
Naturals class
	instanceVariableNames: ''!

!classDefinition: #QuotientSet category: #'Domains-Sets'!
Domain subclass: #QuotientSet
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Sets'!
!classDefinition: 'QuotientSet class' category: #'Domains-Sets'!
QuotientSet class
	instanceVariableNames: ''!

!classDefinition: #Semigroup category: #'Domains-Monoids'!
Domain subclass: #Semigroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Monoids'!
!classDefinition: 'Semigroup class' category: #'Domains-Monoids'!
Semigroup class
	instanceVariableNames: ''!

!classDefinition: #FreeAbelianSemigroup category: #'Domains-Monoids'!
Semigroup subclass: #FreeAbelianSemigroup
	instanceVariableNames: 'rank ordering'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Monoids'!
!classDefinition: 'FreeAbelianSemigroup class' category: #'Domains-Monoids'!
FreeAbelianSemigroup class
	instanceVariableNames: ''!

!classDefinition: #FreeSemigroup category: #'Domains-Monoids'!
Semigroup subclass: #FreeSemigroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Monoids'!
!classDefinition: 'FreeSemigroup class' category: #'Domains-Monoids'!
FreeSemigroup class
	instanceVariableNames: ''!

!classDefinition: #Monoid category: #'Domains-Monoids'!
Semigroup subclass: #Monoid
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Monoids'!
!classDefinition: 'Monoid class' category: #'Domains-Monoids'!
Monoid class
	instanceVariableNames: ''!

!classDefinition: #FreeAbelianMonoid category: #'Domains-Monoids'!
Monoid subclass: #FreeAbelianMonoid
	instanceVariableNames: 'rank ordering'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Monoids'!
!classDefinition: 'FreeAbelianMonoid class' category: #'Domains-Monoids'!
FreeAbelianMonoid class
	instanceVariableNames: ''!

!classDefinition: #FreeMonoid category: #'Domains-Monoids'!
Monoid subclass: #FreeMonoid
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Monoids'!
!classDefinition: 'FreeMonoid class' category: #'Domains-Monoids'!
FreeMonoid class
	instanceVariableNames: ''!

!classDefinition: #Group category: #'Domains-Groups'!
Monoid subclass: #Group
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups'!
!classDefinition: 'Group class' category: #'Domains-Groups'!
Group class
	instanceVariableNames: ''!

!classDefinition: #AbelianGroup category: #'Domains-Groups'!
Group subclass: #AbelianGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups'!
!classDefinition: 'AbelianGroup class' category: #'Domains-Groups'!
AbelianGroup class
	instanceVariableNames: ''!

!classDefinition: #FreeAbelianGroup category: #'Domains-Groups'!
AbelianGroup subclass: #FreeAbelianGroup
	instanceVariableNames: 'rank ordering'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups'!
!classDefinition: 'FreeAbelianGroup class' category: #'Domains-Groups'!
FreeAbelianGroup class
	instanceVariableNames: ''!

!classDefinition: #DirectProductGroup category: #'Domains-Groups'!
Group subclass: #DirectProductGroup
	instanceVariableNames: 'components'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups'!
!classDefinition: 'DirectProductGroup class' category: #'Domains-Groups'!
DirectProductGroup class
	instanceVariableNames: ''!

!classDefinition: #FPGroup category: #'Domains-Groups'!
Group subclass: #FPGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups'!
!classDefinition: 'FPGroup class' category: #'Domains-Groups'!
FPGroup class
	instanceVariableNames: ''!

!classDefinition: #FreeGroup category: #'Domains-Groups'!
FPGroup subclass: #FreeGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups'!
!classDefinition: 'FreeGroup class' category: #'Domains-Groups'!
FreeGroup class
	instanceVariableNames: ''!

!classDefinition: #OppositeGroup category: #'Domains-Groups'!
Group subclass: #OppositeGroup
	instanceVariableNames: 'opposite'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups'!
!classDefinition: 'OppositeGroup class' category: #'Domains-Groups'!
OppositeGroup class
	instanceVariableNames: ''!

!classDefinition: #QuotientGroup category: #'Domains-Groups'!
Group subclass: #QuotientGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups'!
!classDefinition: 'QuotientGroup class' category: #'Domains-Groups'!
QuotientGroup class
	instanceVariableNames: ''!

!classDefinition: #SemidirectProductGroup category: #'Domains-Groups'!
Group subclass: #SemidirectProductGroup
	instanceVariableNames: 'left right action'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups'!
!classDefinition: 'SemidirectProductGroup class' category: #'Domains-Groups'!
SemidirectProductGroup class
	instanceVariableNames: ''!

!classDefinition: #PermutationGroup category: #'Domains-Groups-Permutations'!
Group subclass: #PermutationGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups-Permutations'!
!classDefinition: 'PermutationGroup class' category: #'Domains-Groups-Permutations'!
PermutationGroup class
	instanceVariableNames: ''!

!classDefinition: #AlternatingGroup category: #'Domains-Groups-Permutations'!
PermutationGroup subclass: #AlternatingGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups-Permutations'!
!classDefinition: 'AlternatingGroup class' category: #'Domains-Groups-Permutations'!
AlternatingGroup class
	instanceVariableNames: ''!

!classDefinition: #SymmetricGroup category: #'Domains-Groups-Permutations'!
PermutationGroup subclass: #SymmetricGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups-Permutations'!
!classDefinition: 'SymmetricGroup class' category: #'Domains-Groups-Permutations'!
SymmetricGroup class
	instanceVariableNames: ''!

!classDefinition: #LinearGroup category: #'Domains-Groups-Linear'!
Group subclass: #LinearGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups-Linear'!
!classDefinition: 'LinearGroup class' category: #'Domains-Groups-Linear'!
LinearGroup class
	instanceVariableNames: ''!

!classDefinition: #GeneralLinearGroup category: #'Domains-Groups-Linear'!
LinearGroup subclass: #GeneralLinearGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups-Linear'!
!classDefinition: 'GeneralLinearGroup class' category: #'Domains-Groups-Linear'!
GeneralLinearGroup class
	instanceVariableNames: ''!

!classDefinition: #OrthogonalGroup category: #'Domains-Groups-Linear'!
LinearGroup subclass: #OrthogonalGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups-Linear'!
!classDefinition: 'OrthogonalGroup class' category: #'Domains-Groups-Linear'!
OrthogonalGroup class
	instanceVariableNames: ''!

!classDefinition: #ScalarGroup category: #'Domains-Groups-Linear'!
LinearGroup subclass: #ScalarGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups-Linear'!
!classDefinition: 'ScalarGroup class' category: #'Domains-Groups-Linear'!
ScalarGroup class
	instanceVariableNames: ''!

!classDefinition: #SpecialLinearGroup category: #'Domains-Groups-Linear'!
LinearGroup subclass: #SpecialLinearGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups-Linear'!
!classDefinition: 'SpecialLinearGroup class' category: #'Domains-Groups-Linear'!
SpecialLinearGroup class
	instanceVariableNames: ''!

!classDefinition: #SpecialOrthogonalGroup category: #'Domains-Groups-Linear'!
LinearGroup subclass: #SpecialOrthogonalGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups-Linear'!
!classDefinition: 'SpecialOrthogonalGroup class' category: #'Domains-Groups-Linear'!
SpecialOrthogonalGroup class
	instanceVariableNames: ''!

!classDefinition: #SpecialScalarGroup category: #'Domains-Groups-Linear'!
LinearGroup subclass: #SpecialScalarGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups-Linear'!
!classDefinition: 'SpecialScalarGroup class' category: #'Domains-Groups-Linear'!
SpecialScalarGroup class
	instanceVariableNames: ''!

!classDefinition: #AffineGroup category: #'Domains-Groups-Affine'!
Group subclass: #AffineGroup
	instanceVariableNames: 'space'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups-Affine'!
!classDefinition: 'AffineGroup class' category: #'Domains-Groups-Affine'!
AffineGroup class
	instanceVariableNames: ''!

!classDefinition: #EuclideanGroup category: #'Domains-Groups-Affine'!
AffineGroup subclass: #EuclideanGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups-Affine'!
!classDefinition: 'EuclideanGroup class' category: #'Domains-Groups-Affine'!
EuclideanGroup class
	instanceVariableNames: ''!

!classDefinition: #GeneralAffineGroup category: #'Domains-Groups-Affine'!
AffineGroup subclass: #GeneralAffineGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups-Affine'!
!classDefinition: 'GeneralAffineGroup class' category: #'Domains-Groups-Affine'!
GeneralAffineGroup class
	instanceVariableNames: ''!

!classDefinition: #SpecialAffineGroup category: #'Domains-Groups-Affine'!
AffineGroup subclass: #SpecialAffineGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups-Affine'!
!classDefinition: 'SpecialAffineGroup class' category: #'Domains-Groups-Affine'!
SpecialAffineGroup class
	instanceVariableNames: ''!

!classDefinition: #SpecialEuclideanGroup category: #'Domains-Groups-Affine'!
AffineGroup subclass: #SpecialEuclideanGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups-Affine'!
!classDefinition: 'SpecialEuclideanGroup class' category: #'Domains-Groups-Affine'!
SpecialEuclideanGroup class
	instanceVariableNames: ''!

!classDefinition: #UnitGroup category: #'Domains-Rings'!
Group subclass: #UnitGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings'!
!classDefinition: 'UnitGroup class' category: #'Domains-Rings'!
UnitGroup class
	instanceVariableNames: ''!

!classDefinition: #ModularIntegerUnitGroup category: #'Domains-Rings-Finite'!
UnitGroup subclass: #ModularIntegerUnitGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings-Finite'!
!classDefinition: 'ModularIntegerUnitGroup class' category: #'Domains-Rings-Finite'!
ModularIntegerUnitGroup class
	instanceVariableNames: ''!

!classDefinition: #EllipticCurveGroup category: #'Domains-Elliptic Curves'!
Group subclass: #EllipticCurveGroup
	instanceVariableNames: 'curve scalars'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Elliptic Curves'!
!classDefinition: 'EllipticCurveGroup class' category: #'Domains-Elliptic Curves'!
EllipticCurveGroup class
	instanceVariableNames: ''!

!classDefinition: #DirichletGroup category: #'Domains-Modular Forms'!
Group subclass: #DirichletGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modular Forms'!
!classDefinition: 'DirichletGroup class' category: #'Domains-Modular Forms'!
DirichletGroup class
	instanceVariableNames: ''!

!classDefinition: #MoebiusGroup category: #'Domains-Modular Forms'!
Group subclass: #MoebiusGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modular Forms'!
!classDefinition: 'MoebiusGroup class' category: #'Domains-Modular Forms'!
MoebiusGroup class
	instanceVariableNames: ''!

!classDefinition: #ArithmeticGroup category: #'Domains-Modular Group'!
Group subclass: #ArithmeticGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modular Group'!
!classDefinition: 'ArithmeticGroup class' category: #'Domains-Modular Group'!
ArithmeticGroup class
	instanceVariableNames: ''!

!classDefinition: #CongruenceSubgroup category: #'Domains-Modular Group'!
ArithmeticGroup subclass: #CongruenceSubgroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modular Group'!
!classDefinition: 'CongruenceSubgroup class' category: #'Domains-Modular Group'!
CongruenceSubgroup class
	instanceVariableNames: ''!

!classDefinition: #Gamma0CongruenceSubgroup category: #'Domains-Modular Group'!
CongruenceSubgroup subclass: #Gamma0CongruenceSubgroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modular Group'!
!classDefinition: 'Gamma0CongruenceSubgroup class' category: #'Domains-Modular Group'!
Gamma0CongruenceSubgroup class
	instanceVariableNames: ''!

!classDefinition: #Gamma1CongruenceSubgroup category: #'Domains-Modular Group'!
CongruenceSubgroup subclass: #Gamma1CongruenceSubgroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modular Group'!
!classDefinition: 'Gamma1CongruenceSubgroup class' category: #'Domains-Modular Group'!
Gamma1CongruenceSubgroup class
	instanceVariableNames: ''!

!classDefinition: #PrincipalCongruenceSubgroup category: #'Domains-Modular Group'!
CongruenceSubgroup subclass: #PrincipalCongruenceSubgroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modular Group'!
!classDefinition: 'PrincipalCongruenceSubgroup class' category: #'Domains-Modular Group'!
PrincipalCongruenceSubgroup class
	instanceVariableNames: ''!

!classDefinition: #ModularGroup category: #'Domains-Modular Group'!
PrincipalCongruenceSubgroup subclass: #ModularGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modular Group'!
!classDefinition: 'ModularGroup class' category: #'Domains-Modular Group'!
ModularGroup class
	instanceVariableNames: ''!

!classDefinition: #CoxeterGroup category: #'Domains-Etc-Lie'!
Group subclass: #CoxeterGroup
	instanceVariableNames: 'diagram'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc-Lie'!
!classDefinition: 'CoxeterGroup class' category: #'Domains-Etc-Lie'!
CoxeterGroup class
	instanceVariableNames: ''!

!classDefinition: #Semiring category: #'Domains-Rings'!
Domain subclass: #Semiring
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings'!
!classDefinition: 'Semiring class' category: #'Domains-Rings'!
Semiring class
	instanceVariableNames: ''!

!classDefinition: #Ring category: #'Domains-Rings'!
Semiring subclass: #Ring
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings'!
!classDefinition: 'Ring class' category: #'Domains-Rings'!
Ring class
	instanceVariableNames: ''!

!classDefinition: #CompletionRing category: #'Domains-Rings'!
Ring subclass: #CompletionRing
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings'!
!classDefinition: 'CompletionRing class' category: #'Domains-Rings'!
CompletionRing class
	instanceVariableNames: ''!

!classDefinition: #AdicIntegerRing category: #'Domains-Rings-Adic'!
CompletionRing subclass: #AdicIntegerRing
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings-Adic'!
!classDefinition: 'AdicIntegerRing class' category: #'Domains-Rings-Adic'!
AdicIntegerRing class
	instanceVariableNames: ''!

!classDefinition: #PowerSeriesRing category: #'Domains-Sequences'!
CompletionRing subclass: #PowerSeriesRing
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Sequences'!
!classDefinition: 'PowerSeriesRing class' category: #'Domains-Sequences'!
PowerSeriesRing class
	instanceVariableNames: ''!

!classDefinition: #LocalizationRing category: #'Domains-Rings'!
Ring subclass: #LocalizationRing
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings'!
!classDefinition: 'LocalizationRing class' category: #'Domains-Rings'!
LocalizationRing class
	instanceVariableNames: ''!

!classDefinition: #FractionRing category: #'Domains-Rings'!
LocalizationRing subclass: #FractionRing
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings'!
!classDefinition: 'FractionRing class' category: #'Domains-Rings'!
FractionRing class
	instanceVariableNames: ''!

!classDefinition: #AdicRationalField category: #'Domains-Rings-Adic'!
FractionRing subclass: #AdicRationalField
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings-Adic'!
!classDefinition: 'AdicRationalField class' category: #'Domains-Rings-Adic'!
AdicRationalField class
	instanceVariableNames: ''!

!classDefinition: #RationalField category: #'Domains-Fields'!
FractionRing subclass: #RationalField
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Fields'!
!classDefinition: 'RationalField class' category: #'Domains-Fields'!
RationalField class
	instanceVariableNames: ''!

!classDefinition: #RationalFunctionField category: #'Domains-Polynomials'!
FractionRing subclass: #RationalFunctionField
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Polynomials'!
!classDefinition: 'RationalFunctionField class' category: #'Domains-Polynomials'!
RationalFunctionField class
	instanceVariableNames: ''!

!classDefinition: #LaurentSeriesRing category: #'Domains-Sequences'!
FractionRing subclass: #LaurentSeriesRing
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Sequences'!
!classDefinition: 'LaurentSeriesRing class' category: #'Domains-Sequences'!
LaurentSeriesRing class
	instanceVariableNames: ''!

!classDefinition: #ValuationRing category: #'Domains-Etc-Approximate'!
LocalizationRing subclass: #ValuationRing
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc-Approximate'!
!classDefinition: 'ValuationRing class' category: #'Domains-Etc-Approximate'!
ValuationRing class
	instanceVariableNames: ''!

!classDefinition: #OppositeRing category: #'Domains-Rings'!
Ring subclass: #OppositeRing
	instanceVariableNames: 'opposite'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings'!
!classDefinition: 'OppositeRing class' category: #'Domains-Rings'!
OppositeRing class
	instanceVariableNames: ''!

!classDefinition: #ProductRing category: #'Domains-Rings'!
Ring subclass: #ProductRing
	instanceVariableNames: 'components'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings'!
!classDefinition: 'ProductRing class' category: #'Domains-Rings'!
ProductRing class
	instanceVariableNames: ''!

!classDefinition: #QuotientRing category: #'Domains-Rings'!
Ring subclass: #QuotientRing
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings'!
!classDefinition: 'QuotientRing class' category: #'Domains-Rings'!
QuotientRing class
	instanceVariableNames: ''!

!classDefinition: #ModularIntegerRing category: #'Domains-Rings-Finite'!
QuotientRing subclass: #ModularIntegerRing
	instanceVariableNames: 'modulus'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings-Finite'!
!classDefinition: 'ModularIntegerRing class' category: #'Domains-Rings-Finite'!
ModularIntegerRing class
	instanceVariableNames: ''!

!classDefinition: #PrimePowerRing category: #'Domains-Rings-Finite'!
ModularIntegerRing subclass: #PrimePowerRing
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings-Finite'!
!classDefinition: 'PrimePowerRing class' category: #'Domains-Rings-Finite'!
PrimePowerRing class
	instanceVariableNames: ''!

!classDefinition: #PrimeField category: #'Domains-Fields-Finite'!
PrimePowerRing subclass: #PrimeField
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Fields-Finite'!
!classDefinition: 'PrimeField class' category: #'Domains-Fields-Finite'!
PrimeField class
	instanceVariableNames: ''!

!classDefinition: #SmallPrimeField category: #'Domains-Fields-Finite'!
PrimeField subclass: #SmallPrimeField
	instanceVariableNames: 'expTable logTable'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Fields-Finite'!
!classDefinition: 'SmallPrimeField class' category: #'Domains-Fields-Finite'!
SmallPrimeField class
	instanceVariableNames: ''!

!classDefinition: #AffineRing category: #'Domains-Schemes-Affine'!
QuotientRing subclass: #AffineRing
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Schemes-Affine'!
!classDefinition: 'AffineRing class' category: #'Domains-Schemes-Affine'!
AffineRing class
	instanceVariableNames: ''!

!classDefinition: #AlgebraicExtensionRing category: #'Domains-Fields'!
AffineRing subclass: #AlgebraicExtensionRing
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Fields'!
!classDefinition: 'AlgebraicExtensionRing class' category: #'Domains-Fields'!
AlgebraicExtensionRing class
	instanceVariableNames: ''!

!classDefinition: #GaloisRing category: #'Domains-Rings-Finite'!
AlgebraicExtensionRing subclass: #GaloisRing
	instanceVariableNames: ''
	classVariableNames: 'IrreduciblePolynomialsCache'
	poolDictionaries: ''
	category: 'Domains-Rings-Finite'!
!classDefinition: 'GaloisRing class' category: #'Domains-Rings-Finite'!
GaloisRing class
	instanceVariableNames: ''!

!classDefinition: #GaloisField category: #'Domains-Fields-Finite'!
GaloisRing subclass: #GaloisField
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Fields-Finite'!
!classDefinition: 'GaloisField class' category: #'Domains-Fields-Finite'!
GaloisField class
	instanceVariableNames: ''!

!classDefinition: #QuasiGaloisRing category: #'Domains-Rings-Finite'!
AlgebraicExtensionRing subclass: #QuasiGaloisRing
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings-Finite'!
!classDefinition: 'QuasiGaloisRing class' category: #'Domains-Rings-Finite'!
QuasiGaloisRing class
	instanceVariableNames: ''!

!classDefinition: #FunctionField category: #'Domains-Fields'!
AlgebraicExtensionRing subclass: #FunctionField
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Fields'!
!classDefinition: 'FunctionField class' category: #'Domains-Fields'!
FunctionField class
	instanceVariableNames: ''!

!classDefinition: #NumberField category: #'Domains-Fields-Number Fields'!
AlgebraicExtensionRing subclass: #NumberField
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Fields-Number Fields'!
!classDefinition: 'NumberField class' category: #'Domains-Fields-Number Fields'!
NumberField class
	instanceVariableNames: ''!

!classDefinition: #CyclotomicField category: #'Domains-Fields-Number Fields'!
NumberField subclass: #CyclotomicField
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Fields-Number Fields'!
!classDefinition: 'CyclotomicField class' category: #'Domains-Fields-Number Fields'!
CyclotomicField class
	instanceVariableNames: ''!

!classDefinition: #QuadraticField category: #'Domains-Fields-Number Fields'!
NumberField subclass: #QuadraticField
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Fields-Number Fields'!
!classDefinition: 'QuadraticField class' category: #'Domains-Fields-Number Fields'!
QuadraticField class
	instanceVariableNames: ''!

!classDefinition: #AdicQuotientRing category: #'Domains-Etc'!
QuotientRing subclass: #AdicQuotientRing
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'AdicQuotientRing class' category: #'Domains-Etc'!
AdicQuotientRing class
	instanceVariableNames: ''!

!classDefinition: #RationalIntegerRing category: #'Domains-Rings'!
Ring subclass: #RationalIntegerRing
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings'!
!classDefinition: 'RationalIntegerRing class' category: #'Domains-Rings'!
RationalIntegerRing class
	instanceVariableNames: ''!

!classDefinition: #ComplexField category: #'Domains-Fields'!
Ring subclass: #ComplexField
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Fields'!
!classDefinition: 'ComplexField class' category: #'Domains-Fields'!
ComplexField class
	instanceVariableNames: ''!

!classDefinition: #RealField category: #'Domains-Fields'!
Ring subclass: #RealField
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Fields'!
!classDefinition: 'RealField class' category: #'Domains-Fields'!
RealField class
	instanceVariableNames: ''!

!classDefinition: #Order category: #'Domains-Fields-Number Fields'!
Ring subclass: #Order
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Fields-Number Fields'!
!classDefinition: 'Order class' category: #'Domains-Fields-Number Fields'!
Order class
	instanceVariableNames: ''!

!classDefinition: #NumberRing category: #'Domains-Fields-Number Fields'!
Order subclass: #NumberRing
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Fields-Number Fields'!
!classDefinition: 'NumberRing class' category: #'Domains-Fields-Number Fields'!
NumberRing class
	instanceVariableNames: ''!

!classDefinition: #CyclotomicRing category: #'Domains-Fields-Number Fields'!
NumberRing subclass: #CyclotomicRing
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Fields-Number Fields'!
!classDefinition: 'CyclotomicRing class' category: #'Domains-Fields-Number Fields'!
CyclotomicRing class
	instanceVariableNames: ''!

!classDefinition: #QuadraticRing category: #'Domains-Fields-Number Fields'!
NumberRing subclass: #QuadraticRing
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Fields-Number Fields'!
!classDefinition: 'QuadraticRing class' category: #'Domains-Fields-Number Fields'!
QuadraticRing class
	instanceVariableNames: ''!

!classDefinition: #GaussianIntegerRing category: #'Domains-Fields-Number Fields'!
QuadraticRing subclass: #GaussianIntegerRing
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Fields-Number Fields'!
!classDefinition: 'GaussianIntegerRing class' category: #'Domains-Fields-Number Fields'!
GaussianIntegerRing class
	instanceVariableNames: ''!

!classDefinition: #MatrixRing category: #'Domains-Modules-Matrices'!
Ring subclass: #MatrixRing
	instanceVariableNames: 'scalars degree'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Matrices'!
!classDefinition: 'MatrixRing class' category: #'Domains-Modules-Matrices'!
MatrixRing class
	instanceVariableNames: ''!

!classDefinition: #PolynomialRing category: #'Domains-Polynomials'!
Ring subclass: #PolynomialRing
	instanceVariableNames: 'monomials scalars'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Polynomials'!
!classDefinition: 'PolynomialRing class' category: #'Domains-Polynomials'!
PolynomialRing class
	instanceVariableNames: ''!

!classDefinition: #LocalRing category: #'Domains-Etc-Approximate'!
Ring subclass: #LocalRing
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc-Approximate'!
!classDefinition: 'LocalRing class' category: #'Domains-Etc-Approximate'!
LocalRing class
	instanceVariableNames: ''!

!classDefinition: #Module category: #'Domains-Modules'!
Domain subclass: #Module
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules'!
!classDefinition: 'Module class' category: #'Domains-Modules'!
Module class
	instanceVariableNames: ''!

!classDefinition: #Ideal category: #'Domains-Rings'!
Module subclass: #Ideal
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings'!
!classDefinition: 'Ideal class' category: #'Domains-Rings'!
Ideal class
	instanceVariableNames: ''!

!classDefinition: #QuotientIdeal category: #'Domains-Rings'!
Ideal subclass: #QuotientIdeal
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings'!
!classDefinition: 'QuotientIdeal class' category: #'Domains-Rings'!
QuotientIdeal class
	instanceVariableNames: ''!

!classDefinition: #RationalIntegerIdeal category: #'Domains-Rings'!
Ideal subclass: #RationalIntegerIdeal
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings'!
!classDefinition: 'RationalIntegerIdeal class' category: #'Domains-Rings'!
RationalIntegerIdeal class
	instanceVariableNames: ''!

!classDefinition: #PolynomialIdeal category: #'Domains-Polynomials'!
Ideal subclass: #PolynomialIdeal
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Polynomials'!
!classDefinition: 'PolynomialIdeal class' category: #'Domains-Polynomials'!
PolynomialIdeal class
	instanceVariableNames: ''!

!classDefinition: #MonomialIdeal category: #'Domains-Polynomials'!
PolynomialIdeal subclass: #MonomialIdeal
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Polynomials'!
!classDefinition: 'MonomialIdeal class' category: #'Domains-Polynomials'!
MonomialIdeal class
	instanceVariableNames: ''!

!classDefinition: #FractionalIdeal category: #'Domains-Fields-Number Fields'!
Module subclass: #FractionalIdeal
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Fields-Number Fields'!
!classDefinition: 'FractionalIdeal class' category: #'Domains-Fields-Number Fields'!
FractionalIdeal class
	instanceVariableNames: ''!

!classDefinition: #HomModule category: #'Domains-Modules'!
Module subclass: #HomModule
	instanceVariableNames: 'domain codomain'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules'!
!classDefinition: 'HomModule class' category: #'Domains-Modules'!
HomModule class
	instanceVariableNames: ''!

!classDefinition: #QuotientModule category: #'Domains-Modules'!
Module subclass: #QuotientModule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules'!
!classDefinition: 'QuotientModule class' category: #'Domains-Modules'!
QuotientModule class
	instanceVariableNames: ''!

!classDefinition: #FreeModule category: #'Domains-Modules-Free'!
Module subclass: #FreeModule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Free'!
!classDefinition: 'FreeModule class' category: #'Domains-Modules-Free'!
FreeModule class
	instanceVariableNames: ''!

!classDefinition: #DirectSumModule category: #'Domains-Modules-Free'!
FreeModule subclass: #DirectSumModule
	instanceVariableNames: 'components'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Free'!
!classDefinition: 'DirectSumModule class' category: #'Domains-Modules-Free'!
DirectSumModule class
	instanceVariableNames: ''!

!classDefinition: #FreeHomModule category: #'Domains-Modules-Free'!
FreeModule subclass: #FreeHomModule
	instanceVariableNames: 'domain codomain'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Free'!
!classDefinition: 'FreeHomModule class' category: #'Domains-Modules-Free'!
FreeHomModule class
	instanceVariableNames: ''!

!classDefinition: #QuotientSpace category: #'Domains-Modules-Free'!
FreeModule subclass: #QuotientSpace
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Free'!
!classDefinition: 'QuotientSpace class' category: #'Domains-Modules-Free'!
QuotientSpace class
	instanceVariableNames: ''!

!classDefinition: #RingModule category: #'Domains-Modules-Free'!
FreeModule subclass: #RingModule
	instanceVariableNames: 'scalars'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Free'!
!classDefinition: 'RingModule class' category: #'Domains-Modules-Free'!
RingModule class
	instanceVariableNames: ''!

!classDefinition: #FreeSumsModule category: #'Domains-Modules-Tuples'!
FreeModule subclass: #FreeSumsModule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Tuples'!
!classDefinition: 'FreeSumsModule class' category: #'Domains-Modules-Tuples'!
FreeSumsModule class
	instanceVariableNames: ''!

!classDefinition: #TupleModule category: #'Domains-Modules-Tuples'!
FreeModule subclass: #TupleModule
	instanceVariableNames: 'scalars rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Tuples'!
!classDefinition: 'TupleModule class' category: #'Domains-Modules-Tuples'!
TupleModule class
	instanceVariableNames: ''!

!classDefinition: #MultivariateTupleModule category: #'Domains-Modules-Multivariate'!
TupleModule subclass: #MultivariateTupleModule
	instanceVariableNames: 'ordering'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Multivariate'!
!classDefinition: 'MultivariateTupleModule class' category: #'Domains-Modules-Multivariate'!
MultivariateTupleModule class
	instanceVariableNames: ''!

!classDefinition: #MatrixModule category: #'Domains-Modules-Matrices'!
FreeModule subclass: #MatrixModule
	instanceVariableNames: 'scalars height width'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Matrices'!
!classDefinition: 'MatrixModule class' category: #'Domains-Modules-Matrices'!
MatrixModule class
	instanceVariableNames: ''!

!classDefinition: #Lattice category: #'Domains-Modules-Lattices'!
FreeModule subclass: #Lattice
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Lattices'!
!classDefinition: 'Lattice class' category: #'Domains-Modules-Lattices'!
Lattice class
	instanceVariableNames: ''!

!classDefinition: #BilinearForms category: #'Domains-Modules-Tensors'!
FreeModule subclass: #BilinearForms
	instanceVariableNames: 'vectorSpace domain'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Tensors'!
!classDefinition: 'BilinearForms class' category: #'Domains-Modules-Tensors'!
BilinearForms class
	instanceVariableNames: ''!

!classDefinition: #TensorProductModule category: #'Domains-Modules-Tensors'!
FreeModule subclass: #TensorProductModule
	instanceVariableNames: 'components'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Tensors'!
!classDefinition: 'TensorProductModule class' category: #'Domains-Modules-Tensors'!
TensorProductModule class
	instanceVariableNames: ''!

!classDefinition: #PolynomialFiltrationModule category: #'Domains-Polynomials'!
FreeModule subclass: #PolynomialFiltrationModule
	instanceVariableNames: 'polynomials degree'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Polynomials'!
!classDefinition: 'PolynomialFiltrationModule class' category: #'Domains-Polynomials'!
PolynomialFiltrationModule class
	instanceVariableNames: ''!

!classDefinition: #PolynomialGradingModule category: #'Domains-Polynomials'!
FreeModule subclass: #PolynomialGradingModule
	instanceVariableNames: 'polynomials degree'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Polynomials'!
!classDefinition: 'PolynomialGradingModule class' category: #'Domains-Polynomials'!
PolynomialGradingModule class
	instanceVariableNames: ''!

!classDefinition: #ModularFormSpace category: #'Domains-Modular Forms'!
FreeModule subclass: #ModularFormSpace
	instanceVariableNames: 'weight group'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modular Forms'!
!classDefinition: 'ModularFormSpace class' category: #'Domains-Modular Forms'!
ModularFormSpace class
	instanceVariableNames: ''!

!classDefinition: #ExteriorPower category: #'Domains-Etc'!
FreeModule subclass: #ExteriorPower
	instanceVariableNames: 'space degree'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'ExteriorPower class' category: #'Domains-Etc'!
ExteriorPower class
	instanceVariableNames: ''!

!classDefinition: #MultivariateModule category: #'Domains-Modules-Multivariate'!
Module subclass: #MultivariateModule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Multivariate'!
!classDefinition: 'MultivariateModule class' category: #'Domains-Modules-Multivariate'!
MultivariateModule class
	instanceVariableNames: ''!

!classDefinition: #AffineSubspace category: #'Domains-Modules-Free'!
Domain subclass: #AffineSubspace
	instanceVariableNames: 'direction representative'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Free'!
!classDefinition: 'AffineSubspace class' category: #'Domains-Modules-Free'!
AffineSubspace class
	instanceVariableNames: ''!

!classDefinition: #Scheme category: #'Domains-Schemes'!
Domain subclass: #Scheme
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Schemes'!
!classDefinition: 'Scheme class' category: #'Domains-Schemes'!
Scheme class
	instanceVariableNames: ''!

!classDefinition: #Grassmannian category: #'Domains-Modules-Free'!
Scheme subclass: #Grassmannian
	instanceVariableNames: 'space rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Free'!
!classDefinition: 'Grassmannian class' category: #'Domains-Modules-Free'!
Grassmannian class
	instanceVariableNames: ''!

!classDefinition: #AffineScheme category: #'Domains-Schemes'!
Scheme subclass: #AffineScheme
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Schemes'!
!classDefinition: 'AffineScheme class' category: #'Domains-Schemes'!
AffineScheme class
	instanceVariableNames: ''!

!classDefinition: #AffineVariety category: #'Domains-Schemes-Affine'!
AffineScheme subclass: #AffineVariety
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Schemes-Affine'!
!classDefinition: 'AffineVariety class' category: #'Domains-Schemes-Affine'!
AffineVariety class
	instanceVariableNames: ''!

!classDefinition: #AffineCurve category: #'Domains-Schemes-Affine'!
AffineVariety subclass: #AffineCurve
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Schemes-Affine'!
!classDefinition: 'AffineCurve class' category: #'Domains-Schemes-Affine'!
AffineCurve class
	instanceVariableNames: ''!

!classDefinition: #AffineHypersurface category: #'Domains-Schemes-Affine'!
AffineVariety subclass: #AffineHypersurface
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Schemes-Affine'!
!classDefinition: 'AffineHypersurface class' category: #'Domains-Schemes-Affine'!
AffineHypersurface class
	instanceVariableNames: ''!

!classDefinition: #AffinePlaneCurve category: #'Domains-Schemes-Affine'!
AffineHypersurface subclass: #AffinePlaneCurve
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Schemes-Affine'!
!classDefinition: 'AffinePlaneCurve class' category: #'Domains-Schemes-Affine'!
AffinePlaneCurve class
	instanceVariableNames: ''!

!classDefinition: #AffineSpace category: #'Domains-Schemes-Affine'!
AffineVariety subclass: #AffineSpace
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Schemes-Affine'!
!classDefinition: 'AffineSpace class' category: #'Domains-Schemes-Affine'!
AffineSpace class
	instanceVariableNames: ''!

!classDefinition: #ProductAffineSpace category: #'Domains-Schemes-Affine'!
AffineSpace subclass: #ProductAffineSpace
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Schemes-Affine'!
!classDefinition: 'ProductAffineSpace class' category: #'Domains-Schemes-Affine'!
ProductAffineSpace class
	instanceVariableNames: ''!

!classDefinition: #ProjectiveScheme category: #'Domains-Schemes'!
Scheme subclass: #ProjectiveScheme
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Schemes'!
!classDefinition: 'ProjectiveScheme class' category: #'Domains-Schemes'!
ProjectiveScheme class
	instanceVariableNames: ''!

!classDefinition: #ProjectiveVariety category: #'Domains-Schemes-Projective'!
Scheme subclass: #ProjectiveVariety
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Schemes-Projective'!
!classDefinition: 'ProjectiveVariety class' category: #'Domains-Schemes-Projective'!
ProjectiveVariety class
	instanceVariableNames: ''!

!classDefinition: #ProjectiveCurve category: #'Domains-Schemes-Projective'!
ProjectiveVariety subclass: #ProjectiveCurve
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Schemes-Projective'!
!classDefinition: 'ProjectiveCurve class' category: #'Domains-Schemes-Projective'!
ProjectiveCurve class
	instanceVariableNames: ''!

!classDefinition: #ProjectiveHypersurface category: #'Domains-Schemes-Projective'!
ProjectiveVariety subclass: #ProjectiveHypersurface
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Schemes-Projective'!
!classDefinition: 'ProjectiveHypersurface class' category: #'Domains-Schemes-Projective'!
ProjectiveHypersurface class
	instanceVariableNames: ''!

!classDefinition: #ProjectivePlaneCurve category: #'Domains-Schemes-Projective'!
ProjectiveHypersurface subclass: #ProjectivePlaneCurve
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Schemes-Projective'!
!classDefinition: 'ProjectivePlaneCurve class' category: #'Domains-Schemes-Projective'!
ProjectivePlaneCurve class
	instanceVariableNames: ''!

!classDefinition: #Conic category: #'Domains-Schemes-Projective'!
ProjectivePlaneCurve subclass: #Conic
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Schemes-Projective'!
!classDefinition: 'Conic class' category: #'Domains-Schemes-Projective'!
Conic class
	instanceVariableNames: ''!

!classDefinition: #RationalCurve category: #'Domains-Schemes-Projective'!
ProjectivePlaneCurve subclass: #RationalCurve
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Schemes-Projective'!
!classDefinition: 'RationalCurve class' category: #'Domains-Schemes-Projective'!
RationalCurve class
	instanceVariableNames: ''!

!classDefinition: #EllipticCurve category: #'Domains-Elliptic Curves'!
ProjectivePlaneCurve subclass: #EllipticCurve
	instanceVariableNames: 'equation'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Elliptic Curves'!
!classDefinition: 'EllipticCurve class' category: #'Domains-Elliptic Curves'!
EllipticCurve class
	instanceVariableNames: ''!

!classDefinition: #ProjectiveSpace category: #'Domains-Schemes-Projective'!
ProjectiveVariety subclass: #ProjectiveSpace
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Schemes-Projective'!
!classDefinition: 'ProjectiveSpace class' category: #'Domains-Schemes-Projective'!
ProjectiveSpace class
	instanceVariableNames: ''!

!classDefinition: #ProjectiveLine category: #'Domains-Schemes-Projective'!
ProjectiveSpace subclass: #ProjectiveLine
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Schemes-Projective'!
!classDefinition: 'ProjectiveLine class' category: #'Domains-Schemes-Projective'!
ProjectiveLine class
	instanceVariableNames: ''!

!classDefinition: #ProjectivePlane category: #'Domains-Schemes-Projective'!
ProjectiveSpace subclass: #ProjectivePlane
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Schemes-Projective'!
!classDefinition: 'ProjectivePlane class' category: #'Domains-Schemes-Projective'!
ProjectivePlane class
	instanceVariableNames: ''!

!classDefinition: #ProductProjectiveVariety category: #'Domains-Schemes-Projective-Product'!
Scheme subclass: #ProductProjectiveVariety
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Schemes-Projective-Product'!
!classDefinition: 'ProductProjectiveVariety class' category: #'Domains-Schemes-Projective-Product'!
ProductProjectiveVariety class
	instanceVariableNames: ''!

!classDefinition: #ProductProjectiveSpace category: #'Domains-Schemes-Projective-Product'!
ProductProjectiveVariety subclass: #ProductProjectiveSpace
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Schemes-Projective-Product'!
!classDefinition: 'ProductProjectiveSpace class' category: #'Domains-Schemes-Projective-Product'!
ProductProjectiveSpace class
	instanceVariableNames: ''!

!classDefinition: #LinearCode category: #'Domains-Codes'!
Domain subclass: #LinearCode
	instanceVariableNames: 'subspace'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Codes'!
!classDefinition: 'LinearCode class' category: #'Domains-Codes'!
LinearCode class
	instanceVariableNames: ''!

!classDefinition: #CyclicCode2 category: #'Domains-Codes'!
LinearCode subclass: #CyclicCode2
	instanceVariableNames: 'generator'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Codes'!
!classDefinition: 'CyclicCode2 class' category: #'Domains-Codes'!
CyclicCode2 class
	instanceVariableNames: ''!

!classDefinition: #PolynomialCode category: #'Domains-Codes'!
LinearCode subclass: #PolynomialCode
	instanceVariableNames: 'generator'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Codes'!
!classDefinition: 'PolynomialCode class' category: #'Domains-Codes'!
PolynomialCode class
	instanceVariableNames: ''!

!classDefinition: #CyclicCode category: #'Domains-Codes'!
PolynomialCode subclass: #CyclicCode
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Codes'!
!classDefinition: 'CyclicCode class' category: #'Domains-Codes'!
CyclicCode class
	instanceVariableNames: ''!

!classDefinition: #SemistandardTableaux category: #'Domains-Tableaux'!
Domain subclass: #SemistandardTableaux
	instanceVariableNames: 'shape alphabet'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Tableaux'!
!classDefinition: 'SemistandardTableaux class' category: #'Domains-Tableaux'!
SemistandardTableaux class
	instanceVariableNames: ''!

!classDefinition: #StandardTableaux category: #'Domains-Tableaux'!
SemistandardTableaux subclass: #StandardTableaux
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Tableaux'!
!classDefinition: 'StandardTableaux class' category: #'Domains-Tableaux'!
StandardTableaux class
	instanceVariableNames: ''!

!classDefinition: #CellComplex category: #'Domains-Complexes'!
Domain subclass: #CellComplex
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Complexes'!
!classDefinition: 'CellComplex class' category: #'Domains-Complexes'!
CellComplex class
	instanceVariableNames: ''!

!classDefinition: #SimplicialComplex category: #'Domains-Complexes'!
CellComplex subclass: #SimplicialComplex
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Complexes'!
!classDefinition: 'SimplicialComplex class' category: #'Domains-Complexes'!
SimplicialComplex class
	instanceVariableNames: ''!

!classDefinition: #UpperHalfPlane category: #'Domains-Modular Forms'!
Domain subclass: #UpperHalfPlane
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modular Forms'!
!classDefinition: 'UpperHalfPlane class' category: #'Domains-Modular Forms'!
UpperHalfPlane class
	instanceVariableNames: ''!

!classDefinition: #CoxeterSystem category: #'Domains-Etc-Lie'!
Domain subclass: #CoxeterSystem
	instanceVariableNames: 'group generators matrix diagram'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc-Lie'!
!classDefinition: 'CoxeterSystem class' category: #'Domains-Etc-Lie'!
CoxeterSystem class
	instanceVariableNames: ''!

!classDefinition: #Algebra category: #'Domains-Etc-Algebras'!
Domain subclass: #Algebra
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc-Algebras'!
!classDefinition: 'Algebra class' category: #'Domains-Etc-Algebras'!
Algebra class
	instanceVariableNames: ''!

!classDefinition: #FPAlgebra category: #'Domains-Etc-Algebras'!
Algebra subclass: #FPAlgebra
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc-Algebras'!
!classDefinition: 'FPAlgebra class' category: #'Domains-Etc-Algebras'!
FPAlgebra class
	instanceVariableNames: ''!

!classDefinition: #FreeAlgebra category: #'Domains-Etc-Algebras'!
FPAlgebra subclass: #FreeAlgebra
	instanceVariableNames: 'scalars words'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc-Algebras'!
!classDefinition: 'FreeAlgebra class' category: #'Domains-Etc-Algebras'!
FreeAlgebra class
	instanceVariableNames: ''!

!classDefinition: #GroupAlgebra category: #'Domains-Etc-Algebras'!
Algebra subclass: #GroupAlgebra
	instanceVariableNames: 'group scalars'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc-Algebras'!
!classDefinition: 'GroupAlgebra class' category: #'Domains-Etc-Algebras'!
GroupAlgebra class
	instanceVariableNames: ''!

!classDefinition: #MatrixAlgebra category: #'Domains-Etc-Algebras'!
Algebra subclass: #MatrixAlgebra
	instanceVariableNames: 'degree scalars'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc-Algebras'!
!classDefinition: 'MatrixAlgebra class' category: #'Domains-Etc-Algebras'!
MatrixAlgebra class
	instanceVariableNames: ''!

!classDefinition: #Element category: #'Domains-Kernel'!
Object subclass: #Element
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Kernel'!
!classDefinition: 'Element class' category: #'Domains-Kernel'!
Element class
	instanceVariableNames: ''!

!classDefinition: #Morphism category: #'Domains-Kernel'!
Element subclass: #Morphism
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Kernel'!
!classDefinition: 'Morphism class' category: #'Domains-Kernel'!
Morphism class
	instanceVariableNames: ''!

!classDefinition: #Function category: #'Domains-Kernel'!
Morphism subclass: #Function
	instanceVariableNames: 'properties'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Kernel'!
!classDefinition: 'Function class' category: #'Domains-Kernel'!
Function class
	instanceVariableNames: ''!

!classDefinition: #GroupAction category: #'Domains-Groups'!
Function subclass: #GroupAction
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups'!
!classDefinition: 'GroupAction class' category: #'Domains-Groups'!
GroupAction class
	instanceVariableNames: ''!

!classDefinition: #GroupMap category: #'Domains-Groups'!
Function subclass: #GroupMap
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups'!
!classDefinition: 'GroupMap class' category: #'Domains-Groups'!
GroupMap class
	instanceVariableNames: ''!

!classDefinition: #ConjugationMap category: #'Domains-Groups'!
GroupMap subclass: #ConjugationMap
	instanceVariableNames: 'element elementInverse'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups'!
!classDefinition: 'ConjugationMap class' category: #'Domains-Groups'!
ConjugationMap class
	instanceVariableNames: ''!

!classDefinition: #DirichletCharacter category: #'Domains-Modular Forms'!
GroupMap subclass: #DirichletCharacter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modular Forms'!
!classDefinition: 'DirichletCharacter class' category: #'Domains-Modular Forms'!
DirichletCharacter class
	instanceVariableNames: ''!

!classDefinition: #GroupRepresentation category: #'Domains-Etc'!
GroupMap subclass: #GroupRepresentation
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'GroupRepresentation class' category: #'Domains-Etc'!
GroupRepresentation class
	instanceVariableNames: ''!

!classDefinition: #AbelianGroupMap category: #'Domains-Etc-Groups-Abelian'!
GroupMap subclass: #AbelianGroupMap
	instanceVariableNames: 'domain codomain matrix'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc-Groups-Abelian'!
!classDefinition: 'AbelianGroupMap class' category: #'Domains-Etc-Groups-Abelian'!
AbelianGroupMap class
	instanceVariableNames: ''!

!classDefinition: #RingMap category: #'Domains-Rings'!
Function subclass: #RingMap
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings'!
!classDefinition: 'RingMap class' category: #'Domains-Rings'!
RingMap class
	instanceVariableNames: ''!

!classDefinition: #PolynomialRingMap category: #'Domains-Polynomials'!
RingMap subclass: #PolynomialRingMap
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Polynomials'!
!classDefinition: 'PolynomialRingMap class' category: #'Domains-Polynomials'!
PolynomialRingMap class
	instanceVariableNames: ''!

!classDefinition: #ModuleMap category: #'Domains-Modules'!
Function subclass: #ModuleMap
	instanceVariableNames: 'domain codomain matrix'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules'!
!classDefinition: 'ModuleMap class' category: #'Domains-Modules'!
ModuleMap class
	instanceVariableNames: ''!

!classDefinition: #FreeModuleMap category: #'Domains-Modules-Free'!
ModuleMap subclass: #FreeModuleMap
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Free'!
!classDefinition: 'FreeModuleMap class' category: #'Domains-Modules-Free'!
FreeModuleMap class
	instanceVariableNames: ''!

!classDefinition: #AffineMap category: #'Domains-Modules-Free'!
Function subclass: #AffineMap
	instanceVariableNames: 'linearMap translation'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Free'!
!classDefinition: 'AffineMap class' category: #'Domains-Modules-Free'!
AffineMap class
	instanceVariableNames: ''!

!classDefinition: #QuadraticForm category: #'Domains-Modules-Lattices'!
Function subclass: #QuadraticForm
	instanceVariableNames: 'coefficients'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Lattices'!
!classDefinition: 'QuadraticForm class' category: #'Domains-Modules-Lattices'!
QuadraticForm class
	instanceVariableNames: ''!

!classDefinition: #MultilinearMap category: #'Domains-Modules-Tensors'!
Function subclass: #MultilinearMap
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Tensors'!
!classDefinition: 'MultilinearMap class' category: #'Domains-Modules-Tensors'!
MultilinearMap class
	instanceVariableNames: ''!

!classDefinition: #BilinearMap category: #'Domains-Modules-Tensors'!
MultilinearMap subclass: #BilinearMap
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Tensors'!
!classDefinition: 'BilinearMap class' category: #'Domains-Modules-Tensors'!
BilinearMap class
	instanceVariableNames: ''!

!classDefinition: #BilinearForm category: #'Domains-Modules-Tensors'!
BilinearMap subclass: #BilinearForm
	instanceVariableNames: 'halfDomain matrix'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Tensors'!
!classDefinition: 'BilinearForm class' category: #'Domains-Modules-Tensors'!
BilinearForm class
	instanceVariableNames: ''!

!classDefinition: #RationalMap category: #'Domains-Schemes'!
Function subclass: #RationalMap
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Schemes'!
!classDefinition: 'RationalMap class' category: #'Domains-Schemes'!
RationalMap class
	instanceVariableNames: ''!

!classDefinition: #EllipticCurveIsogeny category: #'Domains-Elliptic Curves'!
RationalMap subclass: #EllipticCurveIsogeny
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Elliptic Curves'!
!classDefinition: 'EllipticCurveIsogeny class' category: #'Domains-Elliptic Curves'!
EllipticCurveIsogeny class
	instanceVariableNames: ''!

!classDefinition: #LinearFractionalMap category: #'Domains-Modular Forms'!
RationalMap subclass: #LinearFractionalMap
	instanceVariableNames: 'a b c d'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modular Forms'!
!classDefinition: 'LinearFractionalMap class' category: #'Domains-Modular Forms'!
LinearFractionalMap class
	instanceVariableNames: ''!

!classDefinition: #ModularMap category: #'Domains-Modular Forms'!
LinearFractionalMap subclass: #ModularMap
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modular Forms'!
!classDefinition: 'ModularMap class' category: #'Domains-Modular Forms'!
ModularMap class
	instanceVariableNames: ''!

!classDefinition: #Sequence category: #'Domains-Sequences'!
Function subclass: #Sequence
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Sequences'!
!classDefinition: 'Sequence class' category: #'Domains-Sequences'!
Sequence class
	instanceVariableNames: ''!

!classDefinition: #CFiniteSequence category: #'Domains-Sequences'!
Sequence subclass: #CFiniteSequence
	instanceVariableNames: 'coefficients initialValues'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Sequences'!
!classDefinition: 'CFiniteSequence class' category: #'Domains-Sequences'!
CFiniteSequence class
	instanceVariableNames: ''!

!classDefinition: #SimplicialMap category: #'Domains-Complexes'!
Function subclass: #SimplicialMap
	instanceVariableNames: 'map'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Complexes'!
!classDefinition: 'SimplicialMap class' category: #'Domains-Complexes'!
SimplicialMap class
	instanceVariableNames: ''!

!classDefinition: #ModularForm category: #'Domains-Modular Forms'!
Function subclass: #ModularForm
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modular Forms'!
!classDefinition: 'ModularForm class' category: #'Domains-Modular Forms'!
ModularForm class
	instanceVariableNames: ''!

!classDefinition: #EisensteinSeries category: #'Domains-Modular Forms'!
ModularForm subclass: #EisensteinSeries
	instanceVariableNames: 'weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modular Forms'!
!classDefinition: 'EisensteinSeries class' category: #'Domains-Modular Forms'!
EisensteinSeries class
	instanceVariableNames: ''!

!classDefinition: #RationalPoint category: #'Domains-Schemes'!
Morphism subclass: #RationalPoint
	instanceVariableNames: 'codomain'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Schemes'!
!classDefinition: 'RationalPoint class' category: #'Domains-Schemes'!
RationalPoint class
	instanceVariableNames: ''!

!classDefinition: #AffinePoint category: #'Domains-Schemes-Affine'!
RationalPoint subclass: #AffinePoint
	instanceVariableNames: 'coordinates'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Schemes-Affine'!
!classDefinition: 'AffinePoint class' category: #'Domains-Schemes-Affine'!
AffinePoint class
	instanceVariableNames: ''!

!classDefinition: #ProjectivePoint category: #'Domains-Schemes-Projective'!
RationalPoint subclass: #ProjectivePoint
	instanceVariableNames: 'coordinates'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Schemes-Projective'!
!classDefinition: 'ProjectivePoint class' category: #'Domains-Schemes-Projective'!
ProjectivePoint class
	instanceVariableNames: ''!

!classDefinition: #ProjectiveLinePoint category: #'Domains-Schemes-Projective'!
ProjectivePoint subclass: #ProjectiveLinePoint
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Schemes-Projective'!
!classDefinition: 'ProjectiveLinePoint class' category: #'Domains-Schemes-Projective'!
ProjectiveLinePoint class
	instanceVariableNames: ''!

!classDefinition: #EllipticCurvePoint category: #'Domains-Elliptic Curves'!
ProjectivePoint subclass: #EllipticCurvePoint
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Elliptic Curves'!
!classDefinition: 'EllipticCurvePoint class' category: #'Domains-Elliptic Curves'!
EllipticCurvePoint class
	instanceVariableNames: ''!

!classDefinition: #ProductProjectivePoint category: #'Domains-Schemes-Projective-Product'!
RationalPoint subclass: #ProductProjectivePoint
	instanceVariableNames: 'components'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Schemes-Projective-Product'!
!classDefinition: 'ProductProjectivePoint class' category: #'Domains-Schemes-Projective-Product'!
ProductProjectivePoint class
	instanceVariableNames: ''!

!classDefinition: #GroupElement category: #'Domains-Groups'!
Element subclass: #GroupElement
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups'!
!classDefinition: 'GroupElement class' category: #'Domains-Groups'!
GroupElement class
	instanceVariableNames: ''!

!classDefinition: #Monomial category: #'Domains-Monoids'!
GroupElement subclass: #Monomial
	instanceVariableNames: 'exponents parent degree'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Monoids'!
!classDefinition: 'Monomial class' category: #'Domains-Monoids'!
Monomial class
	instanceVariableNames: ''!

!classDefinition: #Word category: #'Domains-Monoids'!
GroupElement subclass: #Word
	instanceVariableNames: 'syllables parent'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Monoids'!
!classDefinition: 'Word class' category: #'Domains-Monoids'!
Word class
	instanceVariableNames: ''!

!classDefinition: #Coset category: #'Domains-Groups'!
GroupElement subclass: #Coset
	instanceVariableNames: 'representative relations'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups'!
!classDefinition: 'Coset class' category: #'Domains-Groups'!
Coset class
	instanceVariableNames: ''!

!classDefinition: #OppositeGroupElement category: #'Domains-Groups'!
GroupElement subclass: #OppositeGroupElement
	instanceVariableNames: 'opposite'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups'!
!classDefinition: 'OppositeGroupElement class' category: #'Domains-Groups'!
OppositeGroupElement class
	instanceVariableNames: ''!

!classDefinition: #SemidirectProductElement category: #'Domains-Groups'!
GroupElement subclass: #SemidirectProductElement
	instanceVariableNames: 'parent left right'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups'!
!classDefinition: 'SemidirectProductElement class' category: #'Domains-Groups'!
SemidirectProductElement class
	instanceVariableNames: ''!

!classDefinition: #Permutation category: #'Domains-Groups-Permutations'!
GroupElement subclass: #Permutation
	instanceVariableNames: 'images parent'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups-Permutations'!
!classDefinition: 'Permutation class' category: #'Domains-Groups-Permutations'!
Permutation class
	instanceVariableNames: ''!

!classDefinition: #RingElement category: #'Domains-Rings'!
Element subclass: #RingElement
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings'!
!classDefinition: 'RingElement class' category: #'Domains-Rings'!
RingElement class
	instanceVariableNames: ''!

!classDefinition: #OppositeRingElement category: #'Domains-Rings'!
RingElement subclass: #OppositeRingElement
	instanceVariableNames: 'opposite'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings'!
!classDefinition: 'OppositeRingElement class' category: #'Domains-Rings'!
OppositeRingElement class
	instanceVariableNames: ''!

!classDefinition: #ProductRingElement category: #'Domains-Rings'!
RingElement subclass: #ProductRingElement
	instanceVariableNames: 'components'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings'!
!classDefinition: 'ProductRingElement class' category: #'Domains-Rings'!
ProductRingElement class
	instanceVariableNames: ''!

!classDefinition: #Ratio category: #'Domains-Rings'!
RingElement subclass: #Ratio
	instanceVariableNames: 'numerator denominator'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings'!
!classDefinition: 'Ratio class' category: #'Domains-Rings'!
Ratio class
	instanceVariableNames: ''!

!classDefinition: #RationalFunction category: #'Domains-Polynomials'!
Ratio subclass: #RationalFunction
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Polynomials'!
!classDefinition: 'RationalFunction class' category: #'Domains-Polynomials'!
RationalFunction class
	instanceVariableNames: ''!

!classDefinition: #ValuationRingElement category: #'Domains-Etc-Approximate'!
Ratio subclass: #ValuationRingElement
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc-Approximate'!
!classDefinition: 'ValuationRingElement class' category: #'Domains-Etc-Approximate'!
ValuationRingElement class
	instanceVariableNames: ''!

!classDefinition: #Residue category: #'Domains-Rings'!
RingElement subclass: #Residue
	instanceVariableNames: 'representative parent'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings'!
!classDefinition: 'Residue class' category: #'Domains-Rings'!
Residue class
	instanceVariableNames: ''!

!classDefinition: #ModularInteger category: #'Domains-Rings-Finite'!
Residue subclass: #ModularInteger
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings-Finite'!
!classDefinition: 'ModularInteger class' category: #'Domains-Rings-Finite'!
ModularInteger class
	instanceVariableNames: ''!

!classDefinition: #SmallPrimeFieldElement category: #'Domains-Fields-Finite'!
ModularInteger subclass: #SmallPrimeFieldElement
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Fields-Finite'!
!classDefinition: 'SmallPrimeFieldElement class' category: #'Domains-Fields-Finite'!
SmallPrimeFieldElement class
	instanceVariableNames: ''!

!classDefinition: #RegularFunction category: #'Domains-Schemes-Affine'!
Residue subclass: #RegularFunction
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Schemes-Affine'!
!classDefinition: 'RegularFunction class' category: #'Domains-Schemes-Affine'!
RegularFunction class
	instanceVariableNames: ''!

!classDefinition: #AlgebraicElement category: #'Domains-Fields'!
RegularFunction subclass: #AlgebraicElement
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Fields'!
!classDefinition: 'AlgebraicElement class' category: #'Domains-Fields'!
AlgebraicElement class
	instanceVariableNames: ''!

!classDefinition: #AdicInteger category: #'Domains-Rings-Adic'!
RingElement subclass: #AdicInteger
	instanceVariableNames: 'parent digits'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings-Adic'!
!classDefinition: 'AdicInteger class' category: #'Domains-Rings-Adic'!
AdicInteger class
	instanceVariableNames: ''!

!classDefinition: #AdicNumber category: #'Domains-Rings-Adic'!
RingElement subclass: #AdicNumber
	instanceVariableNames: 'valuation unit'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Rings-Adic'!
!classDefinition: 'AdicNumber class' category: #'Domains-Rings-Adic'!
AdicNumber class
	instanceVariableNames: ''!

!classDefinition: #Polynomial category: #'Domains-Polynomials'!
RingElement subclass: #Polynomial
	instanceVariableNames: 'parent'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Polynomials'!
!classDefinition: 'Polynomial class' category: #'Domains-Polynomials'!
Polynomial class
	instanceVariableNames: ''!

!classDefinition: #MultivariatePolynomial category: #'Domains-Polynomials'!
Polynomial subclass: #MultivariatePolynomial
	instanceVariableNames: 'parts'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Polynomials'!
!classDefinition: 'MultivariatePolynomial class' category: #'Domains-Polynomials'!
MultivariatePolynomial class
	instanceVariableNames: ''!

!classDefinition: #UnivariatePolynomial category: #'Domains-Polynomials'!
Polynomial subclass: #UnivariatePolynomial
	instanceVariableNames: 'coefficients'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Polynomials'!
!classDefinition: 'UnivariatePolynomial class' category: #'Domains-Polynomials'!
UnivariatePolynomial class
	instanceVariableNames: ''!

!classDefinition: #LaurentSeries category: #'Domains-Sequences'!
RingElement subclass: #LaurentSeries
	instanceVariableNames: 'valuation unit'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Sequences'!
!classDefinition: 'LaurentSeries class' category: #'Domains-Sequences'!
LaurentSeries class
	instanceVariableNames: ''!

!classDefinition: #PowerSeries category: #'Domains-Sequences'!
RingElement subclass: #PowerSeries
	instanceVariableNames: 'parent coefficients'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Sequences'!
!classDefinition: 'PowerSeries class' category: #'Domains-Sequences'!
PowerSeries class
	instanceVariableNames: ''!

!classDefinition: #LocalRingElement category: #'Domains-Etc-Approximate'!
RingElement subclass: #LocalRingElement
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc-Approximate'!
!classDefinition: 'LocalRingElement class' category: #'Domains-Etc-Approximate'!
LocalRingElement class
	instanceVariableNames: ''!

!classDefinition: #TruncatedAdicNumber category: #'Domains-Etc-Approximate'!
LocalRingElement subclass: #TruncatedAdicNumber
	instanceVariableNames: 'valuation unit precision'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc-Approximate'!
!classDefinition: 'TruncatedAdicNumber class' category: #'Domains-Etc-Approximate'!
TruncatedAdicNumber class
	instanceVariableNames: ''!

!classDefinition: #ModuleElement category: #'Domains-Modules'!
Element subclass: #ModuleElement
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules'!
!classDefinition: 'ModuleElement class' category: #'Domains-Modules'!
ModuleElement class
	instanceVariableNames: ''!

!classDefinition: #Sum category: #'Domains-Modules-Tuples'!
ModuleElement subclass: #Sum
	instanceVariableNames: 'coefficients parent'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Tuples'!
!classDefinition: 'Sum class' category: #'Domains-Modules-Tuples'!
Sum class
	instanceVariableNames: ''!

!classDefinition: #Tensor category: #'Domains-Modules-Tensors'!
Sum subclass: #Tensor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Tensors'!
!classDefinition: 'Tensor class' category: #'Domains-Modules-Tensors'!
Tensor class
	instanceVariableNames: ''!

!classDefinition: #Divisor category: #'Domains-Etc'!
Sum subclass: #Divisor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'Divisor class' category: #'Domains-Etc'!
Divisor class
	instanceVariableNames: ''!

!classDefinition: #SimplicialChain category: #'Domains-Etc'!
Sum subclass: #SimplicialChain
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'SimplicialChain class' category: #'Domains-Etc'!
SimplicialChain class
	instanceVariableNames: ''!

!classDefinition: #FreePolynomial category: #'Domains-Etc-Algebras'!
Sum subclass: #FreePolynomial
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc-Algebras'!
!classDefinition: 'FreePolynomial class' category: #'Domains-Etc-Algebras'!
FreePolynomial class
	instanceVariableNames: ''!

!classDefinition: #GroupAlgebraElement category: #'Domains-Etc-Algebras'!
Sum subclass: #GroupAlgebraElement
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc-Algebras'!
!classDefinition: 'GroupAlgebraElement class' category: #'Domains-Etc-Algebras'!
GroupAlgebraElement class
	instanceVariableNames: ''!

!classDefinition: #Tuple category: #'Domains-Modules-Tuples'!
ModuleElement subclass: #Tuple
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Tuples'!
!classDefinition: 'Tuple class' category: #'Domains-Modules-Tuples'!
Tuple class
	instanceVariableNames: ''!

!classDefinition: #BitTuple category: #'Domains-Modules-Tuples'!
Tuple subclass: #BitTuple
	instanceVariableNames: 'bits size'
	classVariableNames: 'One Zero'
	poolDictionaries: ''
	category: 'Domains-Modules-Tuples'!
!classDefinition: 'BitTuple class' category: #'Domains-Modules-Tuples'!
BitTuple class
	instanceVariableNames: ''!

!classDefinition: #GenericTuple category: #'Domains-Modules-Tuples'!
Tuple subclass: #GenericTuple
	instanceVariableNames: 'coefficients scalars'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Tuples'!
!classDefinition: 'GenericTuple class' category: #'Domains-Modules-Tuples'!
GenericTuple class
	instanceVariableNames: ''!

!classDefinition: #ModularTuple category: #'Domains-Modules-Tuples'!
Tuple subclass: #ModularTuple
	instanceVariableNames: 'representatives scalars'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Tuples'!
!classDefinition: 'ModularTuple class' category: #'Domains-Modules-Tuples'!
ModularTuple class
	instanceVariableNames: ''!

!classDefinition: #MultivariateTuple category: #'Domains-Modules-Multivariate'!
Tuple subclass: #MultivariateTuple
	instanceVariableNames: 'parent components'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Multivariate'!
!classDefinition: 'MultivariateTuple class' category: #'Domains-Modules-Multivariate'!
MultivariateTuple class
	instanceVariableNames: ''!

!classDefinition: #Matrix category: #'Domains-Modules-Matrices'!
ModuleElement subclass: #Matrix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Matrices'!
!classDefinition: 'Matrix class' category: #'Domains-Modules-Matrices'!
Matrix class
	instanceVariableNames: ''!

!classDefinition: #ColumnMatrix category: #'Domains-Modules-Matrices'!
Matrix subclass: #ColumnMatrix
	instanceVariableNames: 'columns'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Matrices'!
!classDefinition: 'ColumnMatrix class' category: #'Domains-Modules-Matrices'!
ColumnMatrix class
	instanceVariableNames: ''!

!classDefinition: #RowMatrix category: #'Domains-Modules-Matrices'!
Matrix subclass: #RowMatrix
	instanceVariableNames: 'rows'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Matrices'!
!classDefinition: 'RowMatrix class' category: #'Domains-Modules-Matrices'!
RowMatrix class
	instanceVariableNames: ''!

!classDefinition: #MonomialOrdering category: #'Domains-Monoids-Orderings'!
Object subclass: #MonomialOrdering
	instanceVariableNames: 'indeterminates'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Monoids-Orderings'!
!classDefinition: 'MonomialOrdering class' category: #'Domains-Monoids-Orderings'!
MonomialOrdering class
	instanceVariableNames: ''!

!classDefinition: #BlockMonomialOrdering category: #'Domains-Monoids-Orderings'!
MonomialOrdering subclass: #BlockMonomialOrdering
	instanceVariableNames: 'blocks'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Monoids-Orderings'!
!classDefinition: 'BlockMonomialOrdering class' category: #'Domains-Monoids-Orderings'!
BlockMonomialOrdering class
	instanceVariableNames: ''!

!classDefinition: #GradedLexicographicOrdering category: #'Domains-Monoids-Orderings'!
MonomialOrdering subclass: #GradedLexicographicOrdering
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Monoids-Orderings'!
!classDefinition: 'GradedLexicographicOrdering class' category: #'Domains-Monoids-Orderings'!
GradedLexicographicOrdering class
	instanceVariableNames: ''!

!classDefinition: #GradedReverseLexicographicOrdering category: #'Domains-Monoids-Orderings'!
MonomialOrdering subclass: #GradedReverseLexicographicOrdering
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Monoids-Orderings'!
!classDefinition: 'GradedReverseLexicographicOrdering class' category: #'Domains-Monoids-Orderings'!
GradedReverseLexicographicOrdering class
	instanceVariableNames: ''!

!classDefinition: #LexicographicOrdering category: #'Domains-Monoids-Orderings'!
MonomialOrdering subclass: #LexicographicOrdering
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Monoids-Orderings'!
!classDefinition: 'LexicographicOrdering class' category: #'Domains-Monoids-Orderings'!
LexicographicOrdering class
	instanceVariableNames: ''!

!classDefinition: #LocalGradedLexicographicOrdering category: #'Domains-Monoids-Orderings'!
MonomialOrdering subclass: #LocalGradedLexicographicOrdering
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Monoids-Orderings'!
!classDefinition: 'LocalGradedLexicographicOrdering class' category: #'Domains-Monoids-Orderings'!
LocalGradedLexicographicOrdering class
	instanceVariableNames: ''!

!classDefinition: #LocalGradedReverseLexicographicOrdering category: #'Domains-Monoids-Orderings'!
MonomialOrdering subclass: #LocalGradedReverseLexicographicOrdering
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Monoids-Orderings'!
!classDefinition: 'LocalGradedReverseLexicographicOrdering class' category: #'Domains-Monoids-Orderings'!
LocalGradedReverseLexicographicOrdering class
	instanceVariableNames: ''!

!classDefinition: #LocalLexicographicOrdering category: #'Domains-Monoids-Orderings'!
MonomialOrdering subclass: #LocalLexicographicOrdering
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Monoids-Orderings'!
!classDefinition: 'LocalLexicographicOrdering class' category: #'Domains-Monoids-Orderings'!
LocalLexicographicOrdering class
	instanceVariableNames: ''!

!classDefinition: #WeightedMonomialOrdering category: #'Domains-Monoids-Orderings'!
MonomialOrdering subclass: #WeightedMonomialOrdering
	instanceVariableNames: 'weights'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Monoids-Orderings'!
!classDefinition: 'WeightedMonomialOrdering class' category: #'Domains-Monoids-Orderings'!
WeightedMonomialOrdering class
	instanceVariableNames: ''!

!classDefinition: #SubgroupSeries category: #'Domains-Groups'!
Object subclass: #SubgroupSeries
	instanceVariableNames: 'subgroups'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups'!
!classDefinition: 'SubgroupSeries class' category: #'Domains-Groups'!
SubgroupSeries class
	instanceVariableNames: ''!

!classDefinition: #ProductReplacementRandomGenerator category: #'Domains-Groups-Algorithms'!
Object subclass: #ProductReplacementRandomGenerator
	instanceVariableNames: 'generators state'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups-Algorithms'!
!classDefinition: 'ProductReplacementRandomGenerator class' category: #'Domains-Groups-Algorithms'!
ProductReplacementRandomGenerator class
	instanceVariableNames: ''!

!classDefinition: #SchreierSims category: #'Domains-Groups-Algorithms'!
Object subclass: #SchreierSims
	instanceVariableNames: 'action generators base strongGeneratingSet trees order'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups-Algorithms'!
!classDefinition: 'SchreierSims class' category: #'Domains-Groups-Algorithms'!
SchreierSims class
	instanceVariableNames: ''!

!classDefinition: #SchreierTree category: #'Domains-Groups-Algorithms'!
Object subclass: #SchreierTree
	instanceVariableNames: 'root generators action v inverses w orbit'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups-Algorithms'!
!classDefinition: 'SchreierTree class' category: #'Domains-Groups-Algorithms'!
SchreierTree class
	instanceVariableNames: ''!

!classDefinition: #ToddCoxeter category: #'Domains-Groups-Algorithms'!
Object subclass: #ToddCoxeter
	instanceVariableNames: 'group subgroup representatives generators'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Groups-Algorithms'!
!classDefinition: 'ToddCoxeter class' category: #'Domains-Groups-Algorithms'!
ToddCoxeter class
	instanceVariableNames: ''!

!classDefinition: #ComplexAlgebraicNumber category: #'Domains-Fields'!
Object subclass: #ComplexAlgebraicNumber
	instanceVariableNames: 'minimalPolynomial approximation radius'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Fields'!
!classDefinition: 'ComplexAlgebraicNumber class' category: #'Domains-Fields'!
ComplexAlgebraicNumber class
	instanceVariableNames: ''!

!classDefinition: #ModuleResidue category: #'Domains-Modules'!
Object subclass: #ModuleResidue
	instanceVariableNames: 'representative parent'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules'!
!classDefinition: 'ModuleResidue class' category: #'Domains-Modules'!
ModuleResidue class
	instanceVariableNames: ''!

!classDefinition: #ChainComplex category: #'Domains-Modules-Complexes'!
Object subclass: #ChainComplex
	instanceVariableNames: 'differentials degree'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Complexes'!
!classDefinition: 'ChainComplex class' category: #'Domains-Modules-Complexes'!
ChainComplex class
	instanceVariableNames: ''!

!classDefinition: #ExactSequence category: #'Domains-Modules-Complexes'!
ChainComplex subclass: #ExactSequence
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Complexes'!
!classDefinition: 'ExactSequence class' category: #'Domains-Modules-Complexes'!
ExactSequence class
	instanceVariableNames: ''!

!classDefinition: #ShortExactSequence category: #'Domains-Modules-Complexes'!
ExactSequence subclass: #ShortExactSequence
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Complexes'!
!classDefinition: 'ShortExactSequence class' category: #'Domains-Modules-Complexes'!
ShortExactSequence class
	instanceVariableNames: ''!

!classDefinition: #ChainMap category: #'Domains-Modules-Complexes'!
Object subclass: #ChainMap
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Complexes'!
!classDefinition: 'ChainMap class' category: #'Domains-Modules-Complexes'!
ChainMap class
	instanceVariableNames: ''!

!classDefinition: #ExtendedSmithReduction category: #'Domains-Modules-Matrices-Algorithms'!
Object subclass: #ExtendedSmithReduction
	instanceVariableNames: 'matrix elementaryDivisors L S R'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Matrices-Algorithms'!
!classDefinition: 'ExtendedSmithReduction class' category: #'Domains-Modules-Matrices-Algorithms'!
ExtendedSmithReduction class
	instanceVariableNames: ''!

!classDefinition: #HermiteColumnReduction category: #'Domains-Modules-Matrices-Algorithms'!
Object subclass: #HermiteColumnReduction
	instanceVariableNames: 'matrix'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Matrices-Algorithms'!
!classDefinition: 'HermiteColumnReduction class' category: #'Domains-Modules-Matrices-Algorithms'!
HermiteColumnReduction class
	instanceVariableNames: ''!

!classDefinition: #MatrixReduction category: #'Domains-Modules-Matrices-Algorithms'!
Object subclass: #MatrixReduction
	instanceVariableNames: 'matrix extension determinantFactor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Matrices-Algorithms'!
!classDefinition: 'MatrixReduction class' category: #'Domains-Modules-Matrices-Algorithms'!
MatrixReduction class
	instanceVariableNames: ''!

!classDefinition: #GaussianElimination category: #'Domains-Modules-Matrices-Algorithms'!
MatrixReduction subclass: #GaussianElimination
	instanceVariableNames: 'pivots currentPivot'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Matrices-Algorithms'!
!classDefinition: 'GaussianElimination class' category: #'Domains-Modules-Matrices-Algorithms'!
GaussianElimination class
	instanceVariableNames: ''!

!classDefinition: #GaussBareiss category: #'Domains-Modules-Matrices-Algorithms'!
GaussianElimination subclass: #GaussBareiss
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Matrices-Algorithms'!
!classDefinition: 'GaussBareiss class' category: #'Domains-Modules-Matrices-Algorithms'!
GaussBareiss class
	instanceVariableNames: ''!

!classDefinition: #HermiteReduction category: #'Domains-Modules-Matrices-Algorithms'!
MatrixReduction subclass: #HermiteReduction
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Matrices-Algorithms'!
!classDefinition: 'HermiteReduction class' category: #'Domains-Modules-Matrices-Algorithms'!
HermiteReduction class
	instanceVariableNames: ''!

!classDefinition: #ModularHermiteReduction category: #'Domains-Modules-Matrices-Algorithms'!
Object subclass: #ModularHermiteReduction
	instanceVariableNames: 'matrix HNF'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Matrices-Algorithms'!
!classDefinition: 'ModularHermiteReduction class' category: #'Domains-Modules-Matrices-Algorithms'!
ModularHermiteReduction class
	instanceVariableNames: ''!

!classDefinition: #SmithReduction category: #'Domains-Modules-Matrices-Algorithms'!
Object subclass: #SmithReduction
	instanceVariableNames: 'matrix invariants'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Matrices-Algorithms'!
!classDefinition: 'SmithReduction class' category: #'Domains-Modules-Matrices-Algorithms'!
SmithReduction class
	instanceVariableNames: ''!

!classDefinition: #LLL category: #'Domains-Modules-Lattices'!
Object subclass: #LLL
	instanceVariableNames: 'basis delta orthogonalBasis mu'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Lattices'!
!classDefinition: 'LLL class' category: #'Domains-Modules-Lattices'!
LLL class
	instanceVariableNames: ''!

!classDefinition: #ModuleMonomial category: #'Domains-Modules-Multivariate'!
Object subclass: #ModuleMonomial
	instanceVariableNames: 'parent monomial position'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Multivariate'!
!classDefinition: 'ModuleMonomial class' category: #'Domains-Modules-Multivariate'!
ModuleMonomial class
	instanceVariableNames: ''!

!classDefinition: #ModuleMonomialOrdering category: #'Domains-Modules-Multivariate-Orderings'!
Object subclass: #ModuleMonomialOrdering
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Multivariate-Orderings'!
!classDefinition: 'ModuleMonomialOrdering class' category: #'Domains-Modules-Multivariate-Orderings'!
ModuleMonomialOrdering class
	instanceVariableNames: ''!

!classDefinition: #PositionOverTermOrdering category: #'Domains-Modules-Multivariate-Orderings'!
ModuleMonomialOrdering subclass: #PositionOverTermOrdering
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Multivariate-Orderings'!
!classDefinition: 'PositionOverTermOrdering class' category: #'Domains-Modules-Multivariate-Orderings'!
PositionOverTermOrdering class
	instanceVariableNames: ''!

!classDefinition: #SchreyerOrdering category: #'Domains-Modules-Multivariate-Orderings'!
ModuleMonomialOrdering subclass: #SchreyerOrdering
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Multivariate-Orderings'!
!classDefinition: 'SchreyerOrdering class' category: #'Domains-Modules-Multivariate-Orderings'!
SchreyerOrdering class
	instanceVariableNames: ''!

!classDefinition: #TermOverPositionOrdering category: #'Domains-Modules-Multivariate-Orderings'!
ModuleMonomialOrdering subclass: #TermOverPositionOrdering
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modules-Multivariate-Orderings'!
!classDefinition: 'TermOverPositionOrdering class' category: #'Domains-Modules-Multivariate-Orderings'!
TermOverPositionOrdering class
	instanceVariableNames: ''!

!classDefinition: #Buchberger category: #'Domains-Polynomials-Algorithms'!
Object subclass: #Buchberger
	instanceVariableNames: 'ideal basis'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Polynomials-Algorithms'!
!classDefinition: 'Buchberger class' category: #'Domains-Polynomials-Algorithms'!
Buchberger class
	instanceVariableNames: ''!

!classDefinition: #ExtendedBuchberger category: #'Domains-Polynomials-Algorithms'!
Buchberger subclass: #ExtendedBuchberger
	instanceVariableNames: 'matrix'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Polynomials-Algorithms'!
!classDefinition: 'ExtendedBuchberger class' category: #'Domains-Polynomials-Algorithms'!
ExtendedBuchberger class
	instanceVariableNames: ''!

!classDefinition: #ComplexRootIsolator category: #'Domains-Polynomials-Algorithms'!
Object subclass: #ComplexRootIsolator
	instanceVariableNames: 'polynomial derivatives'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Polynomials-Algorithms'!
!classDefinition: 'ComplexRootIsolator class' category: #'Domains-Polynomials-Algorithms'!
ComplexRootIsolator class
	instanceVariableNames: ''!

!classDefinition: #MultivariatePolynomialDivision category: #'Domains-Polynomials-Algorithms'!
Object subclass: #MultivariatePolynomialDivision
	instanceVariableNames: 'dividend divisors quotients remainder'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Polynomials-Algorithms'!
!classDefinition: 'MultivariatePolynomialDivision class' category: #'Domains-Polynomials-Algorithms'!
MultivariatePolynomialDivision class
	instanceVariableNames: ''!

!classDefinition: #NumericalComplexRootIsolator category: #'Domains-Polynomials-Algorithms'!
Object subclass: #NumericalComplexRootIsolator
	instanceVariableNames: 'polynomial tolerance'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Polynomials-Algorithms'!
!classDefinition: 'NumericalComplexRootIsolator class' category: #'Domains-Polynomials-Algorithms'!
NumericalComplexRootIsolator class
	instanceVariableNames: ''!

!classDefinition: #PolynomialDivision category: #'Domains-Polynomials-Algorithms'!
Object subclass: #PolynomialDivision
	instanceVariableNames: 'dividend divisor quotient remainder'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Polynomials-Algorithms'!
!classDefinition: 'PolynomialDivision class' category: #'Domains-Polynomials-Algorithms'!
PolynomialDivision class
	instanceVariableNames: ''!

!classDefinition: #PolynomialPseudoDivision category: #'Domains-Polynomials-Algorithms'!
Object subclass: #PolynomialPseudoDivision
	instanceVariableNames: 'dividend divisor quotient remainder'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Polynomials-Algorithms'!
!classDefinition: 'PolynomialPseudoDivision class' category: #'Domains-Polynomials-Algorithms'!
PolynomialPseudoDivision class
	instanceVariableNames: ''!

!classDefinition: #RealRootIsolator category: #'Domains-Polynomials-Algorithms'!
Object subclass: #RealRootIsolator
	instanceVariableNames: 'polynomial sturm fourier roots'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Polynomials-Algorithms'!
!classDefinition: 'RealRootIsolator class' category: #'Domains-Polynomials-Algorithms'!
RealRootIsolator class
	instanceVariableNames: ''!

!classDefinition: #BerlekampMassey category: #'Domains-Algorithms'!
Object subclass: #BerlekampMassey
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algorithms'!
!classDefinition: 'BerlekampMassey class' category: #'Domains-Algorithms'!
BerlekampMassey class
	instanceVariableNames: ''!

!classDefinition: #CRT category: #'Domains-Algorithms'!
Object subclass: #CRT
	instanceVariableNames: 'moduli C'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algorithms'!
!classDefinition: 'CRT class' category: #'Domains-Algorithms'!
CRT class
	instanceVariableNames: ''!

!classDefinition: #DFT category: #'Domains-Algorithms'!
Object subclass: #DFT
	instanceVariableNames: 'ring n alpha'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algorithms'!
!classDefinition: 'DFT class' category: #'Domains-Algorithms'!
DFT class
	instanceVariableNames: ''!

!classDefinition: #ExtendedEuclid category: #'Domains-Algorithms'!
Object subclass: #ExtendedEuclid
	instanceVariableNames: 'elements gcd bezout'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algorithms'!
!classDefinition: 'ExtendedEuclid class' category: #'Domains-Algorithms'!
ExtendedEuclid class
	instanceVariableNames: ''!

!classDefinition: #LagrangeGaussReduction category: #'Domains-Algorithms'!
Object subclass: #LagrangeGaussReduction
	instanceVariableNames: 'vectorSpace v1 v2 shortVector'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algorithms'!
!classDefinition: 'LagrangeGaussReduction class' category: #'Domains-Algorithms'!
LagrangeGaussReduction class
	instanceVariableNames: ''!

!classDefinition: #ModifiedBerlekampMassey category: #'Domains-Algorithms'!
Object subclass: #ModifiedBerlekampMassey
	instanceVariableNames: 'input field minimalPolynomial'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algorithms'!
!classDefinition: 'ModifiedBerlekampMassey class' category: #'Domains-Algorithms'!
ModifiedBerlekampMassey class
	instanceVariableNames: ''!

!classDefinition: #NTT category: #'Domains-Algorithms'!
Object subclass: #NTT
	instanceVariableNames: 'modulus primitive'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algorithms'!
!classDefinition: 'NTT class' category: #'Domains-Algorithms'!
NTT class
	instanceVariableNames: ''!

!classDefinition: #TonelliShanks category: #'Domains-Algorithms'!
Object subclass: #TonelliShanks
	instanceVariableNames: 'p q e z'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Algorithms'!
!classDefinition: 'TonelliShanks class' category: #'Domains-Algorithms'!
TonelliShanks class
	instanceVariableNames: ''!

!classDefinition: #DirichletSeries category: #'Domains-Sequences'!
Object subclass: #DirichletSeries
	instanceVariableNames: 'coefficients'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Sequences'!
!classDefinition: 'DirichletSeries class' category: #'Domains-Sequences'!
DirichletSeries class
	instanceVariableNames: ''!

!classDefinition: #GraphNode category: #'Domains-Graphs-Parts'!
Object subclass: #GraphNode
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Graphs-Parts'!
!classDefinition: 'GraphNode class' category: #'Domains-Graphs-Parts'!
GraphNode class
	instanceVariableNames: ''!

!classDefinition: #ExplicitGraphNode category: #'Domains-Graphs-Parts'!
GraphNode subclass: #ExplicitGraphNode
	instanceVariableNames: 'inNeighbors outNeighbors'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Graphs-Parts'!
!classDefinition: 'ExplicitGraphNode class' category: #'Domains-Graphs-Parts'!
ExplicitGraphNode class
	instanceVariableNames: ''!

!classDefinition: #LabeledExplicitGraphNode category: #'Domains-Graphs-Parts'!
ExplicitGraphNode subclass: #LabeledExplicitGraphNode
	instanceVariableNames: 'label'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Graphs-Parts'!
!classDefinition: 'LabeledExplicitGraphNode class' category: #'Domains-Graphs-Parts'!
LabeledExplicitGraphNode class
	instanceVariableNames: ''!

!classDefinition: #ImplicitGraphNode category: #'Domains-Graphs-Parts'!
GraphNode subclass: #ImplicitGraphNode
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Graphs-Parts'!
!classDefinition: 'ImplicitGraphNode class' category: #'Domains-Graphs-Parts'!
ImplicitGraphNode class
	instanceVariableNames: ''!

!classDefinition: #ImplicitCollectionGraphNode category: #'Domains-Graphs-Parts'!
ImplicitGraphNode subclass: #ImplicitCollectionGraphNode
	instanceVariableNames: 'collectionBlock'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Graphs-Parts'!
!classDefinition: 'ImplicitCollectionGraphNode class' category: #'Domains-Graphs-Parts'!
ImplicitCollectionGraphNode class
	instanceVariableNames: ''!

!classDefinition: #ImplicitIteratorGraphNode category: #'Domains-Graphs-Parts'!
ImplicitGraphNode subclass: #ImplicitIteratorGraphNode
	instanceVariableNames: 'iterator'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Graphs-Parts'!
!classDefinition: 'ImplicitIteratorGraphNode class' category: #'Domains-Graphs-Parts'!
ImplicitIteratorGraphNode class
	instanceVariableNames: ''!

!classDefinition: #DAGFrontier category: #'Domains-Graphs-Algorithms'!
Object subclass: #DAGFrontier
	instanceVariableNames: 'frontier bag'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Graphs-Algorithms'!
!classDefinition: 'DAGFrontier class' category: #'Domains-Graphs-Algorithms'!
DAGFrontier class
	instanceVariableNames: ''!

!classDefinition: #Dijkstra category: #'Domains-Graphs-Algorithms'!
Object subclass: #Dijkstra
	instanceVariableNames: 'graph source predecessor distance'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Graphs-Algorithms'!
!classDefinition: 'Dijkstra class' category: #'Domains-Graphs-Algorithms'!
Dijkstra class
	instanceVariableNames: ''!

!classDefinition: #FloydWarshall category: #'Domains-Graphs-Algorithms'!
Object subclass: #FloydWarshall
	instanceVariableNames: 'graph distances'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Graphs-Algorithms'!
!classDefinition: 'FloydWarshall class' category: #'Domains-Graphs-Algorithms'!
FloydWarshall class
	instanceVariableNames: ''!

!classDefinition: #YoungDiagram category: #'Domains-Tableaux'!
Object subclass: #YoungDiagram
	instanceVariableNames: 'shape'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Tableaux'!
!classDefinition: 'YoungDiagram class' category: #'Domains-Tableaux'!
YoungDiagram class
	instanceVariableNames: ''!

!classDefinition: #WeierstrassEquation category: #'Domains-Elliptic Curves'!
Object subclass: #WeierstrassEquation
	instanceVariableNames: 'coefficients'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Elliptic Curves'!
!classDefinition: 'WeierstrassEquation class' category: #'Domains-Elliptic Curves'!
WeierstrassEquation class
	instanceVariableNames: ''!

!classDefinition: #ManinSymbol category: #'Domains-Modular Forms'!
Object subclass: #ManinSymbol
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modular Forms'!
!classDefinition: 'ManinSymbol class' category: #'Domains-Modular Forms'!
ManinSymbol class
	instanceVariableNames: ''!

!classDefinition: #ModularSymbol category: #'Domains-Modular Forms'!
Object subclass: #ModularSymbol
	instanceVariableNames: 'alpha beta'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modular Forms'!
!classDefinition: 'ModularSymbol class' category: #'Domains-Modular Forms'!
ModularSymbol class
	instanceVariableNames: ''!

!classDefinition: #FareySymbol category: #'Domains-Modular Group'!
Object subclass: #FareySymbol
	instanceVariableNames: 'group fractions pairings'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Modular Group'!
!classDefinition: 'FareySymbol class' category: #'Domains-Modular Group'!
FareySymbol class
	instanceVariableNames: ''!

!classDefinition: #AutomaticPalette category: #'Domains-Morphic'!
Object subclass: #AutomaticPalette
	instanceVariableNames: 'map'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Morphic'!
!classDefinition: 'AutomaticPalette class' category: #'Domains-Morphic'!
AutomaticPalette class
	instanceVariableNames: ''!

!classDefinition: #ComplexPalette category: #'Domains-Morphic'!
Object subclass: #ComplexPalette
	instanceVariableNames: 'luminanceBlock hueBlock zeroColor infinityColor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Morphic'!
!classDefinition: 'ComplexPalette class' category: #'Domains-Morphic'!
ComplexPalette class
	instanceVariableNames: ''!

!classDefinition: #DiscretePalette category: #'Domains-Morphic'!
Object subclass: #DiscretePalette
	instanceVariableNames: 'colors map'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Morphic'!
!classDefinition: 'DiscretePalette class' category: #'Domains-Morphic'!
DiscretePalette class
	instanceVariableNames: ''!

!classDefinition: #RealPalette category: #'Domains-Morphic'!
Object subclass: #RealPalette
	instanceVariableNames: 'colors min max'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Morphic'!
!classDefinition: 'RealPalette class' category: #'Domains-Morphic'!
RealPalette class
	instanceVariableNames: ''!

!classDefinition: #AdicIntegerResidue category: #'Domains-Etc'!
Object subclass: #AdicIntegerResidue
	instanceVariableNames: 'representative'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'AdicIntegerResidue class' category: #'Domains-Etc'!
AdicIntegerResidue class
	instanceVariableNames: ''!

!classDefinition: #AlgebraicExtensionAsModule category: #'Domains-Etc'!
Object subclass: #AlgebraicExtensionAsModule
	instanceVariableNames: 'extension'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'AlgebraicExtensionAsModule class' category: #'Domains-Etc'!
AlgebraicExtensionAsModule class
	instanceVariableNames: ''!

!classDefinition: #GaussianElimination2 category: #'Domains-Etc'!
Object subclass: #GaussianElimination2
	instanceVariableNames: 'matrix extension subreducer pivots columns inverse determinant'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'GaussianElimination2 class' category: #'Domains-Etc'!
GaussianElimination2 class
	instanceVariableNames: ''!

!classDefinition: #GramSchmidt category: #'Domains-Etc'!
Object subclass: #GramSchmidt
	instanceVariableNames: 'basis innerProduct orthogonalBasis matrix'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'GramSchmidt class' category: #'Domains-Etc'!
GramSchmidt class
	instanceVariableNames: ''!

!classDefinition: #JordanReduction category: #'Domains-Etc'!
Object subclass: #JordanReduction
	instanceVariableNames: 'matrix blocks'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'JordanReduction class' category: #'Domains-Etc'!
JordanReduction class
	instanceVariableNames: ''!

!classDefinition: #LinearBasisTest category: #'Domains-Etc'!
Object subclass: #LinearBasisTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'LinearBasisTest class' category: #'Domains-Etc'!
LinearBasisTest class
	instanceVariableNames: ''!

!classDefinition: #Maxel category: #'Domains-Etc'!
Object subclass: #Maxel
	instanceVariableNames: 'pixels'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'Maxel class' category: #'Domains-Etc'!
Maxel class
	instanceVariableNames: ''!

!classDefinition: #OEIS category: #'Domains-Etc'!
Object subclass: #OEIS
	instanceVariableNames: 'entries'
	classVariableNames: 'Default'
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'OEIS class' category: #'Domains-Etc'!
OEIS class
	instanceVariableNames: ''!

!classDefinition: #OrderAsModule category: #'Domains-Etc'!
Object subclass: #OrderAsModule
	instanceVariableNames: 'order'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'OrderAsModule class' category: #'Domains-Etc'!
OrderAsModule class
	instanceVariableNames: ''!

!classDefinition: #Pixel category: #'Domains-Etc'!
Object subclass: #Pixel
	instanceVariableNames: 'row column'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'Pixel class' category: #'Domains-Etc'!
Pixel class
	instanceVariableNames: ''!

!classDefinition: #PolynomialInterpolator category: #'Domains-Etc'!
Object subclass: #PolynomialInterpolator
	instanceVariableNames: 'polynomial corrector'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'PolynomialInterpolator class' category: #'Domains-Etc'!
PolynomialInterpolator class
	instanceVariableNames: ''!

!classDefinition: #QRDecomposition category: #'Domains-Etc'!
Object subclass: #QRDecomposition
	instanceVariableNames: 'matrix Q R'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'QRDecomposition class' category: #'Domains-Etc'!
QRDecomposition class
	instanceVariableNames: ''!

!classDefinition: #Quaternion category: #'Domains-Etc'!
Object subclass: #Quaternion
	instanceVariableNames: 'a b c d'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'Quaternion class' category: #'Domains-Etc'!
Quaternion class
	instanceVariableNames: ''!

!classDefinition: #SLP category: #'Domains-Etc'!
Object subclass: #SLP
	instanceVariableNames: 'word'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'SLP class' category: #'Domains-Etc'!
SLP class
	instanceVariableNames: ''!

!classDefinition: #SturmChain category: #'Domains-Etc'!
Object subclass: #SturmChain
	instanceVariableNames: 'chain'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'SturmChain class' category: #'Domains-Etc'!
SturmChain class
	instanceVariableNames: ''!

!classDefinition: #Subdomain category: #'Domains-Etc'!
Object subclass: #Subdomain
	instanceVariableNames: 'representative'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'Subdomain class' category: #'Domains-Etc'!
Subdomain class
	instanceVariableNames: ''!

!classDefinition: #WuRittProcess category: #'Domains-Etc'!
Object subclass: #WuRittProcess
	instanceVariableNames: 'polynomials characteristicSet'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc'!
!classDefinition: 'WuRittProcess class' category: #'Domains-Etc'!
WuRittProcess class
	instanceVariableNames: ''!

!classDefinition: #CoxeterDiagram category: #'Domains-Etc-Lie'!
Object subclass: #CoxeterDiagram
	instanceVariableNames: 'matrix'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc-Lie'!
!classDefinition: 'CoxeterDiagram class' category: #'Domains-Etc-Lie'!
CoxeterDiagram class
	instanceVariableNames: ''!

!classDefinition: #RootSystem category: #'Domains-Etc-Lie'!
Object subclass: #RootSystem
	instanceVariableNames: 'roots ambient'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc-Lie'!
!classDefinition: 'RootSystem class' category: #'Domains-Etc-Lie'!
RootSystem class
	instanceVariableNames: ''!

!classDefinition: #Product category: #'Domains-Etc-Diagrams'!
Object subclass: #Product
	instanceVariableNames: 'projections'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc-Diagrams'!
!classDefinition: 'Product class' category: #'Domains-Etc-Diagrams'!
Product class
	instanceVariableNames: ''!

!classDefinition: #DirectSum category: #'Domains-Etc-Diagrams'!
Product subclass: #DirectSum
	instanceVariableNames: 'coprojections'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc-Diagrams'!
!classDefinition: 'DirectSum class' category: #'Domains-Etc-Diagrams'!
DirectSum class
	instanceVariableNames: ''!

!classDefinition: #Quotient category: #'Domains-Etc-Diagrams'!
Object subclass: #Quotient
	instanceVariableNames: 'projection'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc-Diagrams'!
!classDefinition: 'Quotient class' category: #'Domains-Etc-Diagrams'!
Quotient class
	instanceVariableNames: ''!

!classDefinition: #TensorProduct category: #'Domains-Etc-Diagrams'!
Object subclass: #TensorProduct
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Domains-Etc-Diagrams'!
!classDefinition: 'TensorProduct class' category: #'Domains-Etc-Diagrams'!
TensorProduct class
	instanceVariableNames: ''!


!RealAlgebraicNumber commentStamp: '<historical>' prior: 0!
Real algebraic numbers, i.e. real zeros of polynomials with integer (or rational) coefficients, in 'minimal polynomial' representation. See also ComplexAlgebraicNumber.!

!ContinuedFraction commentStamp: '<historical>' prior: 0!
Finite or infinite continued fractions.

The finite case correspondes to rational numbers, for example:
  36/17 as: ContinuedFraction

But continued fractions can be infinite:
  ContinuedFraction e

Given a Float, and assuming the number is actually rational, its continued fraction expansion can be used to guess the rational number by truncating it when the convergents start to get too big (in bitsize terms), or when the coefficients of the continued fraction get too big:
  (2.117647 as: ContinuedFraction) convergents
!

!DyadicFraction commentStamp: '<historical>' prior: 0!
My instances represent dyadic fractions, i.e. fractions of the form a / 2^n where a is integer and n is >= 0.

Example:
	(DyadicFraction numerator: 5 shift: 3) + (DyadicFraction numerator: 3 shift: 2)
!

!Aleph commentStamp: '<historical>' prior: 0!
Aleph numbers, i.e. cardinalities of infinite sets. Aleph-naught is the cardinality of the natural numbers. Assuming the continuum hypothesis, aleph-one is taken to be the cardinality of the real numbers.!

!Infinity commentStamp: '<historical>' prior: 0!
The real +infinity or -infinity.

For some examples try these:
	Infinity positive * Infinity negative.
	Infinity positive * 2.
	Infinity positive - 7811234871239847.
	Infinity negative / -199.
	Infinity positive reciprocal.
	Infinity positive > Infinity negative.
	Infinity negative < -19238479182374598172349871234.
	Infinity negative > 0.
	Infinity negative min: Infinity positive.

The following are examples of undeterminations (they produce an error):
	Infinity positive + Infinity negative.
	Infinity positive * 0.
	Infinity positive / Infinity positive.
	Infinity positive raisedToInteger: 0.
!

!LinearBasis commentStamp: '<historical>' prior: 0!
Finite and ordered bases of free modules. They are internally represented by a matrix whose rows are the ambient distinguished coordinates of the basis elements.!

!StandardBasis commentStamp: '<historical>' prior: 0!
Standard bases of polynomial ideals. A standard basis is nothing but a special set of generators with the property that the leading monomials generate the leading ideal.

When the choosen monomial ordering is global (a well-ordering), these are Groebner bases and are computed with Buchberger's algorithm. For arbitrary monomial orderings, they are computed using Mora's normal form.

See also Buchberger and ExtendedBuchberger.!

!GroebnerBasis commentStamp: '<historical>' prior: 0!
Groebner bases are a special case of standard bases.

For a fixed global monomial ordering, a subset G = {g1,...,gm} of an ideal I = <f1,...,fm> of a polynomial ring is called a Groebner basis for I if every polynomial f in I is reducible by G, i.e. there exists g in G such that its leading monomial LM(g) divides LM(f).

When all generators {f1,...,fm} are linear, a Groebner basis corresponds to "row echelon form" or "triangular system"; when they are univariate, then a Groebner basis corresponds to gcd(f1,...,fm). In general, a Groebner basis for an ideal I consists of all the "smallest polynomials" in I under the given monomial ordering.

See also Buchberger and ExtendedBuchberger.!

!Iterator commentStamp: '<historical>' prior: 0!
An Iterator is a read-only collection that evaluates a block to yield the elements of the collection.!

!Graph commentStamp: '<historical>' prior: 0!
Abstract class for (directed or undirected) graphs. See subclasses.!

!Digraph commentStamp: '<historical>' prior: 0!
Directed graphs (digraphs). The vertices (values) can be arbitrary objects, and the edges are Associations v1 -> v2. It uses a sparse representation, implemented as a collection of nodes (GraphNodes) where each node knows its neighbors.

Some properties of the graph are encoded in the class of its nodes (e.g. whether the graph is ordered, has a fixed arity, or the edges are labeled). The 'creation block' is initialized so that appropriate nodes are made.

Structure:
 nodes 			Set of GraphNodes
 nodeCreator 	a block which is evaluated to create a new node
 type 			a Symbol indicating what the default node type is!

!RootedDigraph commentStamp: '<historical>' prior: 0!
Directed graphs with some distinguished vertices that we call 'roots'.

Structure:
 roots 		Set of root objects
!

!UndirectedGraph commentStamp: '<historical>' prior: 0!
Undirected graphs. The vertices (values) can be arbitrary objects, and the edges are MutualAssociations v1 <-> v2.

Internally, graphs are represented as symmetric digraphs (i.e., whenever the edge v1 -> v2 is present, v2 -> v1 is also present).

Structure:
 digraph 		The associated directed graph (which is always symmetric)!

!Simplex commentStamp: '<historical>' prior: 0!
(Abstract) n-simplices.

It is assumed that the vertices are objects that implement a total ordering with #<= (such as integers, strings, monomials), so that they can be ordered to choose an unambiguos orientation.!

!MonomialIndexedTuple commentStamp: 'len 2/25/2017 09:47:13' prior: 0!
My instances are formal sums of monomials.

Internally, they are represented by a list of associations monomial -> value. The list is kept sorted by the underlying monomial ordering.!

!GraphMorph commentStamp: '<historical>' prior: 0!
A GraphMorph is composed of nodes and edges (GraphNodeMorph and GraphEdgeMorph or subclasses). Subclasses of GraphMorph implement different layouts.

Examples:
	| A4 a b |
	A4 _ AlternatingGroup on: (1 to: 4).
	a _ Permutation image: (2,1,4,3).
	b _ Permutation image: (2,3,1,4).
	(A4 cayleyGraphMorph: {a.b}) openInWorld.

	| R W |
	R _ RootSystem example1.
	W _ R dual weylGroup.
	(W cayleyGraphMorph: {W atRandom. W atRandom}) openInWorld

	| G |
	G _ Graph exampleImplicitGraph.
	SpringGraphMorph new graph: G; openInWorld 

	| G |
	G _ RootedDigraph exampleSmallLabelledTree.
	SpringGraphMorph new graph: G; openInWorld 
!

!HistogramMorph commentStamp: '<historical>' prior: 0!
Histograms to be used for statistical purposes. Useful, for example, for many image processing algorithms. See http://en.wikipedia.org/wiki/Histogram .
Counts are currently held in a WordArray, and limited to about 4 billion counts (32 bit unsigned integers)

A good number of bins can be n^(1/2) or n^(1/3), where n is the total number of samples. See Wikipedia article for rationale.!

!Domain commentStamp: '<historical>' prior: 0!
Domains are algebraic structures (such as Groups, Rings, Modules, Schemes, etc), connected by their corresponding Morphisms. Domains are the objects of category theory. In many practical situations domains can be seen as sets of elements, and their morphisms as structure-preserving Functions.

Domains with an underlying set can have finite or infinite cardinality, and whenever makes sense they implement some *Collection* protocol (such as #do:, #size, #asSet, #atRandom:, etc).

Domains can be derived from other domains, for example by taking products or coproducts (cartesian products, direct products, direct sums), quotients, extensions, localizations, completions, duals, etc. These operations are functors, and are implemented as Smalltalk messages.

Domains can have subobjects: groups have subgroups, vector spaces have subspaces, rings have subrings and ideals, schemes have subschemes, etc. Subobjects of an ambient domain can be implemented either concretely as subsets of the ambient domain (i.e., their elements are elements of the ambient domain), or more abstractly as isomorphism classes of injective monomorphisms from another domain of the same category into the ambient domain.

Given two domains A and B in the same category, the set Hom(A,B) of morphisms between them is obtained by sending the message 'A hom: B' (see HomSet). The #hom: message is the external Hom(A,-) functor. The internal hom(A,-) functor is implemented as the #=> message. The identity morphism is returned by the message #id. And a morphism from A to B can be constructed by sending 'A to: B evaluating: [:x| ...]'.

Domains often come equipped with canonical morphisms. For example, field extensions and localizations have canonical embeddings (monomorphisms), and quotient objects have canonical projections (epimorphisms). N-ary products and coproducts have coordinate projection maps from their components, and coproducts also have coprojection maps onto their components.

More generally, canonical morphisms (respectively injective morphisms, surjective morphisms and isomorphisms) that are uniquely determined by their domain and codomain can be retrieved by sending the message #-> (respectively #>->, #->> and #<->). This can be used for automatic coercion of elements between domains. For example, for any ring R, 'ZZ -> R' returns the canonical ring homomorphism that sends an integer 'n' to 'n times the unit of R'. In order for this mechanism to work, subclasses must sometimes extend the messages #to: and #from: to answer canonical morphisms when such morphisms are known.

There's also a very simple coercion mechanism that allows the convertion of elements from a domain to another via the message #!!. For example, the coercion of an integer 'n' to an element of any unital ring 'R' can be performed simply as 'R !! n'. Although available canonical morphisms will be used automatically for coercion, subclasses can also extend the message #!! for convenience.

References:
	https://ncatlab.org/nlab/show/category+theory
	https://en.wikipedia.org/wiki/Algebraic_structure
	https://en.wikipedia.org/wiki/Category_theory
	https://en.wikipedia.org/wiki/Subobject
	https://en.wikipedia.org/wiki/Product_(category_theory)
	https://en.wikipedia.org/wiki/Coproduct
!

!HomSet commentStamp: '<historical>' prior: 0!
Hom-Set objects Hom(A,B) for domain A and codomain B, i.e. sets of all morphisms between two Domains. When A = B, this is the set of endomorphisms of A and it's noted End(A).

References:
	https://ncatlab.org/nlab/show/hom-set
!

!PointSet commentStamp: '<historical>' prior: 0!
Sets of S-points (or S-rational points) of a scheme X, noted X(S), where X and S are schemes over some base scheme or ring B. By definition, an S-point is a morphism from S to X over B. See also RationalPoint.!

!ComplexBox commentStamp: '<historical>' prior: 0!
Boxes in the complex plane, defined by two real intervals (for the real and imaginary parts).!

!ComplexDisk commentStamp: '<historical>' prior: 0!
Closed disks in the complex plane, defined by a center point and a radius.!

!RealBox commentStamp: '<historical>' prior: 0!
Boxes in R^n built by the cartesian product of one-dimensional intervals (instances of RealInterval).

Example:
	RealBox new
		add: (RealInterval closed: -1 closed: 1);
		add: (RealInterval open: 3 open: 4);
		add: (RealInterval closed: 0 open: Infinity positive);
		yourself.
!

!RealInterval commentStamp: '<historical>' prior: 0!
Real intervals in the real line. Each of my instances can have finite or infinite and open or closed bounds.

For some examples try this:
	RealInterval open: 1 closed: 2.
	RealInterval open: 0 open: Infinity positive.
	RealInterval closed: -1 closed: 1.
	RealInterval open: Infinity negative open: Infinity positive.
!

!CartesianProduct commentStamp: '<historical>' prior: 0!
Cartesian products of sets. See Domain>>,.

Example:
	(ZZ, QQ)

Note that message # is often used for the direct product (of rings or groups, for example), but #, always gives the cartesian product of the underlying sets.

References:
	https://en.wikipedia.org/wiki/Cartesian_product
!

!EquivalenceClass commentStamp: '<historical>' prior: 0!
Given a set X and an equivalence relation ~, the equivalence class of an element a is the set of elements equivalent to a: [a] = {x in X such that x ~ a}. An member of an equivalence class is called a 'representative'.

Elements of quotient objects (elements of QuotientRings, QuotientSpaces, etc) are polymorphic with EquivalenceClass.

See EquivalenceRelation.

References:
	https://en.wikipedia.org/wiki/Equivalence_class!

!EquivalenceRelation commentStamp: '<historical>' prior: 0!
An equivalence relation on X is a binary relation ~ on X with the following properties:
- For every element a in X, a ~ a (reflexivity);
- For every two elements a, b in X, if a ~ b then b ~ a (symmetry);
- For every three elements a, b, c in X, if a ~ b and b ~ c then a ~ c (transitivity).

See EquivalenceClass.

References:
	https://en.wikipedia.org/wiki/Equivalence_relation!

!Naturals commentStamp: '<historical>' prior: 0!
The singletion global instance NN is the set of natural numbers 1, 2, 3, ...!

!QuotientSet commentStamp: '<historical>' prior: 0!
Quotient of a set by an equivalence relation. The elements are equivalence classes. See EquivalenceRelation and EquivalenceClass.!

!Semigroup commentStamp: '<historical>' prior: 0!
Semigroups consist of a set and an associative binary operation. They are like monoids except that they don't necessarily have an identity element.!

!FreeAbelianSemigroup commentStamp: '<historical>' prior: 0!
The free abelian semigroup on a finite alphabet or indeterminates, is the subsemigroup of the free abelian monoid containing all elements except the identity monomial. See FreeAbelianMonoid and Monomial.

See FreeSemigroup for the noncommutative analog.!

!FreeSemigroup commentStamp: '<historical>' prior: 0!
The free semigroup on a finite alphabet or indeterminates, is the subsemigroup of the free monoid containing all elements except the identity (the empty word). See FreeMonoid and Word.

See FreeAbelianSemigroup for the commutative analog.!

!Monoid commentStamp: '<historical>' prior: 0!
Monoids consist of a set, an associative binary operation and an identity element. So, they are semigroups with identity.!

!FreeAbelianMonoid commentStamp: '<historical>' prior: 0!
Commutative monoids of monomials in n indeterminates. Elements are instances of Monomial.

The number of indeterminates is called the rank. The indeterminates are referred by index (positive integer numbers), and can be given names that are used when printing.

Monomials have an associated monomial ordering. See MonomialOrdering.

See FreeMonoid for the noncommutative analog.
!

!FreeMonoid commentStamp: '<historical>' prior: 0!
A free monoid is a monoid whose elements are words (see Word) on a finite alphabet or set of indeterminates, together with word concatenation as monoid operation, and empty word as identity element.

See FreeAbelianMonoid for the commutative analog.
!

!Group commentStamp: '<historical>' prior: 0!
Groups consist of a set with an associative binary operation, an inverse map (every element has an inverse), and an identity element.

Small groups can be represented explicitly (and naively) as a set of elements, plus a distinguished 'identity' element, group operation and inverse map. Groups can be also defined and represented more compactly by a set of generators.

Some specific groups (such as permutation groups and matrix groups) can be represented in more efficient ways, and operate with more efficient algorithms. See subclasses.

References:
	https://en.wikipedia.org/wiki/Group_(mathematics)!

!AbelianGroup commentStamp: '<historical>' prior: 0!
Finitely generated abelian groups.!

!DirectProductGroup commentStamp: '<historical>' prior: 0!
Direct products of groups. Elements are tuples, and the group composition law is defined component-wise.!

!FPGroup commentStamp: '<historical>' prior: 0!
Finitely presented groups given by generators and relators. Their elements are (noncommutative) words. See Word.!

!OppositeGroup commentStamp: 'len 5/8/2019 14:55:05' prior: 0!
The opposite group G^op of a group G is a group constructed from the original group G inverting the order of the group operation. This way, it is possible to define a left action as a special case of a right action.

Abelian groups are equal to their opposites. Also, every group is naturally isomorphic to its opposite by the isomorphism that takes an element and sends it to its inverse.

See also OppositeGroupElement.!

!QuotientGroup commentStamp: '<historical>' prior: 0!
Quotient groups (or factor groups) G/N (read "G mod N"), i.e. the quotient of a group G by a normal subgroup N. The elements are the cosets of N (see Coset).

References:
	https://en.wikipedia.org/wiki/Quotient_group!

!SemidirectProductGroup commentStamp: '<historical>' prior: 0!
Semidirect products of groups.!

!PermutationGroup commentStamp: '<historical>' prior: 0!
Permutation groups, i.e. subgroups of the symmetric group Sym(X) of permutations on the elements of a set X (see SymmetricGroup).

The set X is refered to as the 'space' of the group, elements of the X are 'points', while the word 'element' is used for elements of the group itself (permutations). The group acts naturally on the space X by the action p^x := p(x).!

!AlternatingGroup commentStamp: 'len 5/22/2018 21:41:36' prior: 0!
The alternating group Alt(X) of even permutations on the elements of a set X (which we call 'space'). This is a subgroup of Sym(X) (see SymmetricGroup).!

!SymmetricGroup commentStamp: 'len 5/22/2018 21:46:32' prior: 0!
The symmetric group Sym(X) of permutations on the elements of a set X (which we call 'space'). This is the ambient of all PermutationGroups.!

!LinearGroup commentStamp: 'len 9/27/2018 21:46:03' prior: 0!
Groups of automorphisms of a free R-module over a commutative ring R. They are subgroups of the general linear group GL(V).!

!GeneralLinearGroup commentStamp: 'len 9/27/2018 21:46:56' prior: 0!
The general linear group GL(V) of automorphisms of a free R-module V. These are the invertible endomorphisms of V, i.e. the endomorphisms whose determinat are units of R.!

!OrthogonalGroup commentStamp: 'len 9/27/2018 21:48:12' prior: 0!
O(V), the Orthogonal Group of a vector space V. This is the subgroup of the group of automorphisms GL(V) consisting of all automorphisms that preserve the inner product.!

!ScalarGroup commentStamp: 'len 9/27/2018 21:49:50' prior: 0!
This is the group of scalar linear maps of a free R-module over a commutative ring R.!

!SpecialLinearGroup commentStamp: 'len 9/27/2018 21:48:40' prior: 0!
SL(V), the Special Linear Group of automorphisms with determinant 1.!

!AffineGroup commentStamp: '<historical>' prior: 0!
Groups of (invertible) affine maps acting on an affine space. They are subgroups of the general affine group GA(A).!

!EuclideanGroup commentStamp: '<historical>' prior: 0!
The Euclidean group E(n) or ISO(n), the symmetry group of n-dimensional Euclidean space. Its elements are the isometries associated with the Euclidean metric, and are called Euclidean motions (they are affine maps).

E(n) includes the subgroup E*(n) or SE(n) of isometries preserving orientation, also called rigid motions or special Euclidean group.!

!GeneralAffineGroup commentStamp: '<historical>' prior: 0!
The (general) affine group of an affine space, consisting of all invertible affine transformations from the space into itself.

If the scalar field is R, C or H, this is a Lie group.!

!SpecialAffineGroup commentStamp: '<historical>' prior: 0!
The special affine group of an affine space, consisting of all invertible affine transformations from the space into itself that preserve volumes.!

!SpecialEuclideanGroup commentStamp: '<historical>' prior: 0!
The special Euclidean group SE(n) or E*(n), a subgroup of the Euclidean group E(n) that consists of rigid motions, i.e. isometries preserving orientation.
!

!UnitGroup commentStamp: '<historical>' prior: 0!
Given a ring R, the group of units of R is the set of elements of R that have multiplicative inverse, and they form a group under multiplication. For a field F (or more generally a division ring), the units are all the non-zero elements F \ {0}.

Categorically, this construction is a functor from the cateogory of rings to the category of groups. This functor has a left adjoint which is the integral group ring construction (see GroupRing).

References:
	https://en.wikipedia.org/wiki/Unit_(ring_theory)!

!ModularIntegerUnitGroup commentStamp: '<historical>' prior: 0!
(Z/nZ)*, i.e. the multiplicaive group of units modulo n for some integer n. This group is generated by a primitive root modulo n.!

!EllipticCurveGroup commentStamp: '<historical>' prior: 0!
Abelian groups E(K) consisting of the K-rational points of an elliptic curve E.!

!DirichletGroup commentStamp: '<historical>' prior: 0!
Groups of Dirichlet characters modulo n, whose elements are group homomorphisms from (Z/nZ)* to C* (see DirichletCharacter).!

!MoebiusGroup commentStamp: '<historical>' prior: 0!
My instances are groups of Moebius transformations acting on some space, like the Riemann sphere P^1(C) or the upper half plane H or the extended upper half plane H U P^1(Q).!

!ArithmeticGroup commentStamp: '<historical>' prior: 0!
Finite index subgroups of the modular group.!

!CongruenceSubgroup commentStamp: '<historical>' prior: 0!
Congruence subgroups of the modular group SL(2,Z), i.e. subgroups that contain the kernel of SL(2,Z) -> SL(2,Z/nZ) for some positive integer n (which is called the level of the congruence subgroup). See also ModularGroup.!

!Gamma0CongruenceSubgroup commentStamp: '<historical>' prior: 0!
Subgroups of SL(2,Z) associated with matrices of the form:
  [a b]   [* *]
  [c d] = [0 *] (mod n).!

!Gamma1CongruenceSubgroup commentStamp: '<historical>' prior: 0!
Subgroups of SL(2,Z) associated with matrices of the form:
  [a b]   [1 *]
  [c d] = [0 1] (mod n).!

!PrincipalCongruenceSubgroup commentStamp: '<historical>' prior: 0!
Principal congruence subgroups of SL(2,Z), i.e. subgroups of SL(2,Z) associated with matrices of the form:
  [a b]   [1 0]
  [c d] = [0 1] (mod n).

They are the kernel of the quotient projection SL(2,Z) -> SL(2,Z/nZ) for some positive integer n (which is called the level of the congruence subgroup). Since they are kernels, my instances are normal subgroups.!

!ModularGroup commentStamp: '<historical>' prior: 0!
The special linear group SL(2,Z).!

!Semiring commentStamp: '<historical>' prior: 0!
Semirings are like rings, but without the requirement that each element must have an additive inverse. This is, addition yields only a commutative monoid, not necessarily a commutative group as with rings.

Examples of semirings are the non-negative rational numbers and the non-negative real numbers. Another example is the set of all ideals of a given ring under addition and multiplication of ideals.!

!Ring commentStamp: '<historical>' prior: 0!
Objects in the category of unital rings, with RingMaps as their morphisms.

The idea of 'ring' appears naturally in mathematics when considering the endomorphisms of abelian groups (or other abelian categories) under composition. Essentially, rings are to be thought as functions in some space. In the case of a commutative ring R, this space is the prime spectrum Spec(R). See AffineScheme.

Rings can be commutative or non-commutative. Some specific kinds of commutative rings are given with the following class of inclusions:
	commutative rings > integral domains > integrity closed domains > unique factorization domains > principal ideal domains > euclidean domains > fields

Rings can be constructed from existing rings by taking quotients by an ideal (see QuotientRing), by making transcendental extensions (see PolynomialRing), etc.

Rings can also be made into fields by 'adding the missing multiplicative inverses' (localization), for example by constructing the fractions of an integral domain (see FractionRing and LocalizationRing).

References:
	https://en.wikipedia.org/wiki/Ring_(mathematics)!

!CompletionRing commentStamp: '<historical>' prior: 0!
Completion of a given commutative ring R at a given maximal ideal I. This is the inverse limit of the quotient rings R / I^n.!

!AdicIntegerRing commentStamp: '<historical>' prior: 0!
Ring of p-adic integers Zp. Elements are AdicIntegers. See also AdicRationalField, AdicNumber and PrimePowerRing.!

!PowerSeriesRing commentStamp: '<historical>' prior: 0!
Ring R[[x]] of univariate formal power series over a commutative ring R in an indetermiate x. See PowerSeries.!

!LocalizationRing commentStamp: '<historical>' prior: 0!
Localization of a given commutative ring R at a given prime ideal P. The elements are fractions a / b with a in R and b in R \ P.!

!FractionRing commentStamp: 'len 9/28/2018 19:17:32' prior: 0!
Rings of fractions (quotients) with numerator and (nonzero) denominator in a ring. When the ring is an integral domain they form a field. See Ring>>fractions.

For example, the field of fractions of the rational integers is the rational numbers:
	ZZ fractions

The ring of fractions is a particular case of the more general construction of the localization of a ring or module. The ring of fractions is the localization at the zero ideal.

References:
	https://en.wikipedia.org/wiki/Field_of_fractions!

!AdicRationalField commentStamp: '<historical>' prior: 0!
Field of p-adic numbers Qp. This is the fraction field of the ring of p-adic integers Zp. Elements are AdicNumbers. See also AdicIntegerRing and AdicInteger.!

!RationalField commentStamp: '<historical>' prior: 0!
The singletion global instance QQ is the field of rational numbers.!

!RationalFunctionField commentStamp: '<historical>' prior: 0!
The field of fractions of a polynomial ring with coefficients over a field.!

!LaurentSeriesRing commentStamp: '<historical>' prior: 0!
Ring R((x)) of univariate formal Laurent series over a commutative ring R in an indetermiate x. See LaurentSeries.!

!OppositeRing commentStamp: 'len 5/8/2019 14:55:02' prior: 0!
The opposite ring R^op of a ring R is a ring constructed from the original ring R inverting the order of multiplication. This way, it is possible to define left modules as a special case of right modules.

Commutative rings are equal to their opposites.

See also OppositeRingElement.!

!ProductRing commentStamp: 'len 5/22/2018 16:08:59' prior: 0!
Direct products of rings. Elements are tuples where the i-th component corresponds to an element in the i-th ring of the product (see ProductRingElement), and multiplication and addition are defined component wise.!

!QuotientRing commentStamp: '<historical>' prior: 0!
Quotient rings (also called factor rings, difference rings or residue class rings). Their elements are residue classes (see ResidueClass and subclasses).

Given a commutative ring R and an ideal I of R, the quotient ring R/I (read 'R modulo I' or 'R mod I') is the set of cosets (residue clases) of I in R by the equivalence relation a ~ b if a - b is in I. If the ideal is maximal, the resulting quotient ring is a field. If it's only prime, the quotient ring is an integral domain.

The quotient ring R/I is equipped with the projection map that sends elements of R to their residue classes in R/I. The projection map is a canonical homomorphism of rings. See >>project: and >>projection.

References:
	https://en.wikipedia.org/wiki/Quotient_ring!

!ModularIntegerRing commentStamp: '<historical>' prior: 0!
Residue class rings of Z, i.e. rings Z/mZ of residue classes of integers modulo m. Elements are instances of ModularInteger.!

!PrimePowerRing commentStamp: '<historical>' prior: 0!
Residue class rings Z/(p^n)Z of integers modulo p^n.

These are the simplest examples of Galois rings, GR(p^n,1). They are local rings with maximal ideal <p> and residue field isomorphic to Z/pZ. The maximal ideal <p> is also the set of zero-divisors as well as nilpotent elements. Other Galois rings are constructed by finite algebraic extensions (see GaloisRing).

These are also the simplest examples of 'chain rings', rings whose ideals form a chain under inclusion. A finite chain ring is a principal ideal ring, and its maximal ideal is the nilradical (the set of nilpotent elements).

There are canonical projections from Z/(p^n)Z to Z/(p^m)Z for any 1 <= m <= n.

Since the ring of p-adic integers Zp is the projective limit of Z/(p^n)Z, there are also canonical projections from Zp to Z/(p^n)Z, and these are approximations of precision n (see AdicRing).!

!PrimeField commentStamp: '<historical>' prior: 0!
Residue class fields Z/pZ of integers modulo a prime p.

These are the simplest examples of Galois fields, GF(p^1). Other Galois fields are constructed by finite algebraic extensions (see GaloisField).!

!SmallPrimeField commentStamp: '<historical>' prior: 0!
Prime fields Z/pZ for small primes p, such that it is feasable to build exponentiation and logarithmic tables and accelerate arithmetic through table lookups.

The initialization of the tables is very fast. The main concern is memory usage. For a field Z/pZ, each of the two tables have p-1 elements. They are WordArrays (32 bits per entry), so a field Z/pZ uses about 8*(p-1) bytes of memory. For example, Z/65537 uses 524K of memory, and Z/1048583 (a 20-bits modulus) uses about 8M.
!

!AffineRing commentStamp: '<historical>' prior: 0!
Quotients of polynomial rings. They are called affine rings or affine algebras because they are finitely-generated (and finitely-presented) commutative algebras and they are the coordinate rings of affine varieties (closed subschemes of affine space, see AffineVariety). They are also sometimes called the 'rings of regular functions' (on affine varieties). Their elements are RegularFunctions.

When the coefficients ring is a field K and the relations ideal I is maximal, the affine algebra K[X]/I is a field. In this way, affine algebras are multivariate generalizations of number fields and algebraic function fields.

See also PolynomialRing and PolynomialIdeal.!

!AlgebraicExtensionRing commentStamp: '<historical>' prior: 0!
(Finite) algebraic extensions E/F of a field (or ring) F. They are defined by an irreducible polynomial f with coefficients in F, and are isomorphic to F[x]/<f>. An extension field (or ring) E/F can also be viewed as a vector space (or module) over F.

See also AlgebraicElement.!

!GaloisRing commentStamp: '<historical>' prior: 0!
The Galois ring GR(p^n,m) is a Galois extension of degree m of the prime power ring Z/(p^n)Z of characteristic p^n. This is the unique (up to isomorphism) extension of degree m of the ring Z/(p^n)Z of integers modulo p^n (see PrimePowerRing). When n=1 they are fields (see GaloisField).

Galois rings GR(p^n,m) are local rings with maximal ideal <p>, and <p> is also the set of zero-divisors.

The subrings of GR(p^n,m) correspond to the positive divisors of m.

More generally, any finite local ring can be constructed as a finitely-generated GR(p^n,m)-algebra, i.e. a quotient of a polynomial ring (in a number of indeterminates) with coefficients in a Galois ring modulo a primary ideal of the polynomial ring (see AffineRing).

References:
	[1] Ganske, G.; McDonald, B.R. 'Finite local rings'. Rocky Mountain J. Math. 3 (1973), no. 4, 521-540
	[2] Bini, G.; Flamini, F. 'Finite commutative rings and their applications' (2015)!

!GaloisField commentStamp: '<historical>' prior: 0!
Finite nonprime fields, i.e. fields GF(p^r) with r>1. These are finite algebraic extensions of prime fields. See also PrimeField.!

!QuasiGaloisRing commentStamp: '<historical>' prior: 0!
The quasi-Galois ring A(p^r,n) is an extension of degree n of the Galois field GF(p^r) isomorphic to GF(p^r)[x]/<x^n>. See also GaloisRing.
!

!FunctionField commentStamp: '<historical>' prior: 0!
Algebraic function fields, i.e. finite (and thus algebraic) field extensions of a rational function field. Function fields can also be viewed as vector spaces over the coefficients field.
!

!NumberField commentStamp: '<historical>' prior: 0!
Algebraic number fields, i.e. finite (and thus algebraic) field extensions of the rational numbers Q. Number fields can also be viewed as vector spaces over Q.
!

!CyclotomicField commentStamp: '<historical>' prior: 0!
Cyclotomic fields, i.e. number fields obtained by adjoining a complex primitive root of unity to Q. The n-th cyclotomic field is obtained by adjoining a primitive n-th root of unity to the rational numbers.!

!QuadraticField commentStamp: '<historical>' prior: 0!
Quadratic number fields, i.e. number fields with defining quadratic polynomial of the form x^2 - d, with d a squarefree integer.!

!RationalIntegerRing commentStamp: '<historical>' prior: 0!
The singletion global instance ZZ is the ring of rational integers.!

!ComplexField commentStamp: '<historical>' prior: 0!
The singletion global instance CC is the field of complex numbers.!

!RealField commentStamp: '<historical>' prior: 0!
The singletion global instance RR is the field of real numbers.!

!Order commentStamp: '<historical>' prior: 0!
Orders in a number field, i.e. subrings of a number field that as Z-modules are finitely generated and of maximal rank (with rank equal to the degree of the number field). See NumberField.!

!NumberRing commentStamp: '<historical>' prior: 0!
Rings of integers of number fields (i.e. maximal orders). They are the integral closure of Z (the rational integers) in a number field. See NumberField.
!

!CyclotomicRing commentStamp: '<historical>' prior: 0!
Rings of integers of cyclotomic number fields. See CyclotomicField.!

!QuadraticRing commentStamp: '<historical>' prior: 0!
Rings of integers of quadratic number fields. See QuadraticField.!

!MatrixRing commentStamp: '<historical>' prior: 0!
Rings of square matrices with coefficients over a commutative ring R. They are R-algebras. See also MatrixModule.!

!PolynomialRing commentStamp: '<historical>' prior: 0!
Polynomial rings R[x1,...,xn] in one or many indeterminates over a commutative ring R. These are the finitely-generated free commutative R-algebras.

The number of indeterimnates is called the rank of the polynomial ring. The indeterminates are referred by index (positive integer numbers).

Polynomial rings have an associated monomial ordering. This is used for defining the leading term of a polynomial, multivariate division (also called normal form or reduction) and the computation of Groebner bases and standard bases.

See also PolynomialRingMap, PolynomialIdeal, AffineRing, RationalFunctionField, AffineSpace.
!

!Module commentStamp: '<historical>' prior: 0!
Finitely-presented R-modules, where R is a commutative ring.!

!Ideal commentStamp: '<historical>' prior: 0!
Finitely-generated ideals of a commutative ring.

For an arbitrary ring R, a subset I <= R is called a (two-sided) ideal of R if it's a subgroup of R (as group under addition) and "absorbs multiplication by elements of R", i.e. I * R = I and R * I = I. Equivalently, an ideal of R is a R-submodule of R.

Ideals are the ring theory analog of normal subgroups from group theory. They are 'normal subsets' that are in one-to-one correspondence with certain congruences, and this allows to quotient by them. Given a ring R and an ideal I, the quotient ring R/I can be constructed canonically (see QuotientRing). Ideals are the "kernels" of ring homomorphisms, but they are not kernels in the sense of cateogry theory because ideals are not subobjects in the category of unital rings (they are not rings, proper ideals don't include 1).

References:
	https://en.wikipedia.org/wiki/Ideal_(ring_theory)!

!QuotientIdeal commentStamp: '<historical>' prior: 0!
Ideals of quotient rings.!

!RationalIntegerIdeal commentStamp: '<historical>' prior: 0!
Ideals of integers. They are cyclic, i.e. they are all multiples of a given integer (the #generator).!

!PolynomialIdeal commentStamp: '<historical>' prior: 0!
Ideals of polynomials. See PolynomialRing and AffineRing.!

!MonomialIdeal commentStamp: '<historical>' prior: 0!
Polynomial ideals generated by monomials.

With monomial ideals computations are much easier than with general polynomial ideals, and in many cases problems in general polynomial ideals can be reduced to problems in simpler monomial ideals (for example, by using Groebner bases).

Monomial ideals have a rich theory with connections to convex geometry and combinatorics. There's a one-to-one correspondences between:
- Simplicial complexes on {1,2,...,n};
- Squarefree monomial ideals in K[x1,...,xn];
- Unions of coordinate subspaces of K^n.

See also SimplicialComplex.!

!FractionalIdeal commentStamp: '<historical>' prior: 0!
A fractional ideal is an R-submodule of the fraction field of R, for an integral domain R.!

!HomModule commentStamp: '<historical>' prior: 0!
R-modules of linear maps from a R-module A to another one B, i.e. the internal Hom(A,B) of the category of R-modules. When A = B, it is noted End(A). Note that this is an R-module because R is commutative, otherwise it would just be a Z-module.

See Module and ModuleMap.!

!QuotientModule commentStamp: '<historical>' prior: 0!
Quotient modules M/S (read "M mod S") of a given module M 'modulo' a submodule S, where both M and S are finite-rank free modules.

The elements of a quotient module M/S are cosets S + x with x in M.

See QuotientSpace for quotients of vector spaces.

References:
	https://en.wikipedia.org/wiki/Quotient_module
	https://en.wikipedia.org/wiki/Quotient_space_(linear_algebra)!

!FreeModule commentStamp: '<historical>' prior: 0!
Finite-rank free R-modules, i.e. R-modules with a finite basis. They are isomorphic to R^n.

Most functionality is implemented for the cases where R is a field (vector spaces, relying on gaussian elimination), or a PID such as Z or Q[x] (relying on the Hermite normal form or computing in the field of fractions).

For R a PID, free R-modules are always embedded in an ambient K-vector space, where K is the field of fractions of R.

See also FreeModuleMap.!

!DirectSumModule commentStamp: '<historical>' prior: 0!
Direct sum of free R-modules, for a commutative ring R.!

!FreeHomModule commentStamp: '<historical>' prior: 0!
Free R-modules (or K-vector spaces) of linear maps from a free R-module (or K-vector space) A to another one B, i.e. the internal Hom(A,B) of the category of R-modules (or K-vector spaces). When A = B, it is noted End(A).

See FreeModule and FreeModuleMap.!

!QuotientSpace commentStamp: '<historical>' prior: 0!
Quotient spaces V/S (read "V mod S") of a given vector space V modulo a subspace S.

The elements of a quotient space are cosets (affine subspaces, flats) S + x with x in V, and they form a vector space. See AffineSubspace.

See also QuotientModule.

References:
	https://en.wikipedia.org/wiki/Quotient_space_(linear_algebra)!

!RingModule commentStamp: '<historical>' prior: 0!
Rank 1 free module (or vector space) of scalars, i.e. a ring R viewed as R-module.
!

!FreeSumsModule commentStamp: '<historical>' prior: 0!
Free R-modules of formal sums of elements in a finite set with coefficients over R. See Sum.!

!TupleModule commentStamp: '<historical>' prior: 0!
Free R-modules (or K-vector spaces) of ordered n-tuples over a given ring R (or field K).!

!MatrixModule commentStamp: '<historical>' prior: 0!
Ambient modules (or vector spaces) of matrices of n rows by m columns over a given commutative ring (or field). See also MatrixRing.!

!Lattice commentStamp: '<historical>' prior: 0!
A lattice is the set of integer linear combinations of a basis of a rational vector space. This is a discrete subgroup of the ambient Q-vector space (as abelian group) isomorphic to Z^n, and a free Z-module.

Lattice coordinates are in Z, while the elements of the receiver live in the ambient Q-vector space.!

!TensorProductModule commentStamp: '<historical>' prior: 0!
Tensor product over R of a list of free R-modules. This is a free R-module with basis given by elementary tensors on the choice of basis of the component modules.

See Tensor.!

!PolynomialFiltrationModule commentStamp: '<historical>' prior: 0!
Submodules of univariate polynomials of degree <= n for a fixed n, in the ring of univariate polynomials R[x]. They define a filtration (see PolynomialRing>>filtrationAt:).!

!PolynomialGradingModule commentStamp: '<historical>' prior: 0!
Submodules of homogeneous polynomials of a given fixed degree, in a multivariate polynomial ring R[x1,...,xn]. They define a grading (see PolynomialRing>>gradingAt:).!

!ExteriorPower commentStamp: 'len 8/1/2016 23:59' prior: 0!
TODO:
- elements: k-vectors (ExteriorProduct or ExteriorVector?)
- ExteriorAlgebra as a graded algebra, direct sum of /\^i(V) for i in [1..n]!

!MultivariateModule commentStamp: '<historical>' prior: 0!
R-modules where R is a multivariate ring such as a polynomial ring or an affine ring.!

!AffineSubspace commentStamp: '<historical>' prior: 0!
Module cosets or affine subspaces contained in a given vector space or module, i.e. flats, or linear varieties, linear manifolds, or translated subspaces/submodules (cosets).

They appear when considering the solutions of non-homogeneous linear systems, or the set of all the vectors in the domain of a linear map that are mapped to a given vector in the codomain of the transformation (the 'fiber' of the vector). They are also the elements of quotient spaces or quotient modules.
!

!Scheme commentStamp: '<historical>' prior: 0!
Abstract superclass for schemes. Subclasses implement particular types of schemes.

An important class of schemes are those defined by polynomial equations in some ambient space. See subclasses AffineVariety and ProjectiveVariety, which are closed subschemes of affine and projective space respectively. See also RationalPoint and subclasses.!

!Grassmannian commentStamp: 'len 11/3/2016 09:19' prior: 0!
The Grassmannian Gr(r,V) is the set of r-dimensional subspaces of the vector space V.!

!AffineScheme commentStamp: '<historical>' prior: 0!
An affine scheme is the prime spectrum Spec(R) of a commutative ring R, equipped with a sheaf of local rings (which makes it a locally ringed space). As a set, their elements are the prime ideals of the associated coordinate ring R.

In scheme theory, affine schemes are the fundamental building blocks of general schemes. Any scheme can be constructed by gluing together finitely many affine schemes, and conversely schemes that are not affine can be covered by a finite number of affine patches.!

!AffineVariety commentStamp: '<historical>' prior: 0!
Closed subschemes of an affine space (see AffineSpace). Their coordinate rings are quotients of multivariate polynomial rings by an ideal (also called affine rings or affine algebras, see AffineRing). Their rational points are AffinePoints.

These are schemes, not classical algebraic varieties. Here the name 'variety' only means that they are defined by polynomial equations. The integral (reduced and irreducible) closed subschemes of affine space over an algebraically closed field correspond to the classical affine algebraic varieties.
!

!AffineCurve commentStamp: '<historical>' prior: 0!
Affine algebraic curves, i.e. schemes of dimension 1 over an affine space.!

!AffineHypersurface commentStamp: '<historical>' prior: 0!
Affine algebraic hypersurfaces, i.e. schemes of codimension 1 over an affine space. They can be defined by a single polynomial (the defining ideal is principal).!

!AffinePlaneCurve commentStamp: '<historical>' prior: 0!
Affine plane algebraic curves, i.e. schemes of dimension 1 over an affine plane.!

!AffineSpace commentStamp: '<historical>' prior: 0!
Affine spaces R^n as schemes, i.e. Spec R[x1,...,xn] for some commutative ring R.

Note that affine spaces defined as schemes differ from the classical affine spaces defined as 'vector spaces that have forgotten the origin'. The morphisms of this affine space are of course morphisms of schemes, not just the classical (linear) affine transformations.

Note also that the dimension of an affine space as scheme is the Krull dimension of its coordinate ring, and this can be bigger than the number of indeterminates (see >>dimension and >>rank). For affine spaces over fields, the dimension and the rank are equal (because fields have Krull dimension 0).!

!ProductAffineSpace commentStamp: '<historical>' prior: 0!
Cartesian products of affine spaces.
!

!ProjectiveScheme commentStamp: '<historical>' prior: 0!
A projective schemes is the projective (or homogeneous) spectrum Proj(R) of a graded commutative ring R, equipped with a sheaf of local rings (which makes it a locally ringed space). As a set, their elements are the relevant prime ideals of the associated homogeneous coordinate ring R.

Proj(R) is contained in its affine cone Spec(R).!

!ProjectiveVariety commentStamp: '<historical>' prior: 0!
Projective closed subschemes of a projective space (see ProjectiveSpace). Their homogeneous coordinate rings are quotient rings of multivariate polynomial rings by a homogeneous ideal, i.e. graded affine algebras. Their rational points are ProjectivePoints.

These are schemes, and not classical algebraic varieties (they don't need to be reduced, irreducible nor over an algebraically closed field). Here the name 'variety' only means that they are defined by polynomial equations.!

!ProjectiveCurve commentStamp: '<historical>' prior: 0!
Projective algebraic curves, i.e. projective schemes of dimension 1 over a projective space.!

!ProjectiveHypersurface commentStamp: '<historical>' prior: 0!
Projective algebraic hypersurfaces, i.e. schemes of codimension 1 over a projective space. They can be defined by a single homogeneous polynomial (the defining ideal is principal).!

!ProjectivePlaneCurve commentStamp: '<historical>' prior: 0!
Projective plane algebraic curves, i.e. schemes of dimension 1 over a projective plane.!

!Conic commentStamp: '<historical>' prior: 0!
Projective plane curves of genus 0 and degree 2. They are defined by quadratic polynomials.

Conics, together with rational curves (see RationalCurve), are the only curves of genus 0.

As any genus 0 curve, a conic either has no rational points, or it has infinitely many.!

!RationalCurve commentStamp: '<historical>' prior: 0!
Projective plane curves of genus 0 and degree 1. They are defined by linear polynomials.

Rational curves, together with Conics, are the only curves of genus 0.!

!EllipticCurve commentStamp: '<historical>' prior: 0!
Elliptic curves are the projective plane curves of genus 1. They can be defined by a Weierstrass equation (see WeierstrassEquation).

Elliptic curves are abelian varieties, i.e. the sets E(K) of K-rational points are abelian groups. See EllipticCurvePoint and EllipticCurveGroup.
!

!ProjectiveSpace commentStamp: 'len 5/17/2018 19:02:53' prior: 0!
Projective spaces P^nR as schemes, i.e. Proj R[x1,...,xn] for some commutative ring R.
!

!ProjectiveLine commentStamp: '<historical>' prior: 0!
Projective lines are P^1(R) for some commutative ring R. They are essentially the underlying ring R extended with an additional point at infinity. For example, the complex projective line is the Riemann sphere: the extended complex plane that includes the point at infinity. See also ProjectiveLinePoint.!

!ProductProjectiveSpace commentStamp: '<historical>' prior: 0!
Cartesian products of projective spaces.

Example:
	ProductProjectiveSpace new: #((x y z) (a b)) over: QQ.
!

!LinearCode commentStamp: '<historical>' prior: 0!
In coding theory, a linear code is an error-correcting code for which any linear combination of codewords is also a codeword. Thus, linear codes can be seen as a vector space (or more precisely as a subspace of a vector space).

References:
	https://en.wikipedia.org/wiki/Linear_code
!

!PolynomialCode commentStamp: '<historical>' prior: 0!
In coding theory, a polynomial code is a type of linear code whose set of valid codewords consists of those polynomials (usually of some fixed length) that are divisible by some fixed polynomial (of shorter length, called the generator polynomial).

References:
	https://en.wikipedia.org/wiki/Polynomial_code
!

!CellComplex commentStamp: '<historical>' prior: 0!
Abstract cell complexes. See subclasses.!

!SimplicialComplex commentStamp: '<historical>' prior: 0!
Abstract simplicial complexes. These are combinatorial objects consisting of a collection of simplices (the 'faces' of the simplicial complex) with the following properties:
- every subface of a face is also in the complex;
- the intersection of two faces is either empty or a common face of both simplices, and it is also in the complex.

An abstract simplicial complex can also be seen as a subset of the power set of some set V, often V={1,...,n}, closed under inclusion.

Simplicial complexes form a category with simplicial maps as morphisms. See SimplicialMap.!

!UpperHalfPlane commentStamp: '<historical>' prior: 0!
This is the upper half complex plane H, i.e. the set of complex numbers with imaginary part > 0.

This serves as a model of the hyperbolic plane, defining lines as:
1. the intersection of the half-plane H and Euclidean lines orthogonal to the real axis, or
2. the intersection of the half-plane H and Euclidean half-circles with center on the real axis.

The group of hyperbolic isometries, as well as conformal automorphisms, is the general Moebius group. This is the group of Moebius transformations, i.e. transformations of the form z |-> (az + b) / (cz + d) with ad - cd ~= 0 (or without loss of generality ad - cd = 1).!

!FreeAlgebra commentStamp: '<historical>' prior: 0!
(Associative) algebras of noncommutative polynomials in a finite set of indeterminates. Their elements are FreePolynomials.

This is the noncommutative analogue of a polynomial ring.!

!GroupAlgebra commentStamp: '<historical>' prior: 0!
Given a ring R and a group G, the group ring R[G] can be seen as a ring or as a free R-module with basis one-to-one with G. As a ring, its addition law is that of the free module, and the multiplication extends by linearity the given group law on the basis.

The elements of the group ring R[G] are finite formal linear combinations of elements of G with coefficients in R, or the finite-support functions from G to R (see GroupRingElement).

When the ring R is commutative, the group ring is also referred to as a group algebra.

Categorically, the group ring construction is left adjoint to the group of units (see UnitGroup). It's also a 'category algebra' analogous to the monoid ring for monoids and incidence algebra for posets.

References:
	https://en.wikipedia.org/wiki/Group_ring!

!Element commentStamp: '<historical>' prior: 0!
Elements are members of the underlying set of a Domain (their parent). They are, for example, numbers in a field or ring, n-tuples in a module, polynomials in a polynomial ring, etc.!

!Morphism commentStamp: 'len 4/19/2019 05:00:43' prior: 0!
Abstract superclass for Functions and other morphisms. See subclasses, and Domain and HomSet.

Examples (three equivalent ways to construct a vector space homomorphism):
	QQ^3 to: QQ^3 evaluating: [:v| (v x - v y, v x, v z)].
	QQ^3 => (QQ^3) evaluating: [:v| (v x - v y, v x, v z)].
	(QQ^3) endomorphisms evaluating: [:v| (v x - v y, v x, v z)].

References:
	https://en.wikipedia.org/wiki/Morphism
!

!Function commentStamp: 'len 5/11/2019 04:25:34' prior: 0!
Maps from a set (domain) to another set (codomain). Evaluated at elements of the domain (>>#value:) they produce elements of the codomain. See Domain and HomSet.

Example:
	Function from: ZZ to: ZZ evaluating: [:x| x squared + 1].

A Function is a morphism of sets. If the function preserves some mathematical structure, it is called a morphism of some category corresponding to the preserved structure. For example linear maps are morphisms of vector spaces or modules, continuous functions are morphisms of topological spaces, and group homomorphisms are morphisms of groups.

Example (three equivalent ways to construct homomorphisms):
	"These constructions are similar to the explicit construction above, but they return not arbitrary functions but homomorphisms of the corresponding category (in this case linear maps, i.e. morphisms of vector spaces):"
	QQ^3 to: QQ^3 evaluating: [:v| (v x - v y, v x, v z)].
	QQ^3 => (QQ^3) evaluating: [:v| (v x - v y, v x, v z)].
	(QQ^3) endomorphisms evaluating: [:v| (v x - v y, v x, v z)].

In general, functions are defined by specifying a domain, a codomain, and an expression that can be evaluated at elements of the domain and produces elements of the codomain. One such expression can be a Smalltalk block, another Function, or more generally any Smalltalk object that admits evaluation (#value:), such as polynomials:

Example (two ways to define the Frobenius endomorphism):
	(ZZ/6) endomorphisms evaluating: [:x| x^6].
	(ZZ/6) endomorphisms evaluating: (ZZ/6) polynomials x ^ 6.

Note that functions defined by polynomials or other symbolic expressions, as opposed to functions defined by Smalltalk blocks, are printed more explicitly (as a formula).

References:
	https://en.wikipedia.org/wiki/Function_(set_theory)
	https://en.wikipedia.org/wiki/Morphism
!

!GroupAction commentStamp: '<historical>' prior: 0!
(Left) group actions.

Given a group G and a set X, a (left) group action phi:GxX -> X is a function that satisfies:
- identity: phi(id,x) = x;
- compatibility: phi(g, phi(h,x)) = phi(g*h, x).

The group G is said to 'act' on X (on the left). The set X is called a (left) G-set (or G-space, G-module, depending on the category of X). Here we just call it 'space'.

References:
	https://en.wikipedia.org/wiki/Group_action!

!GroupMap commentStamp: '<historical>' prior: 0!
Group homomorphisms. They can be defined by an evaluable expression or Smalltalk block, or by images of generators. See Group.!

!ConjugationMap commentStamp: '<historical>' prior: 0!
Group homomorphisms defined as conjugation by a given element. These are the inner automorphisms.!

!DirichletCharacter commentStamp: '<historical>' prior: 0!
Characters on the units of Z/nZ, i.e. group homomorphisms (Z/nZ)* -> C* from the unit group of the ring Z/nZ to the multiplicative group of nonzero complex numbers.!

!GroupRepresentation commentStamp: '<historical>' prior: 0!
Given a group and an object X, a group representation is a group homomorphism from G to the automorphisms group Aut(X). X is called the representation space. Informally speaking, a representation allows us to view a group as symmetries of an object.

For example, a linear representation of a group G on a vector space V is a group homomorphism G -> GL(V). A permutation representation of G on a set X is a group homomorphism G -> Sym(X). 
Any group action can be seen as a permutation representation. In turn, any representation phi has an associated action on the representation space that maps (g,x) -> phi(g)(x).

References:
	https://en.wikipedia.org/wiki/Group_representation!

!RingMap commentStamp: '<historical>' prior: 0!
Homomorphisms of commutative rings. See Ring.!

!PolynomialRingMap commentStamp: '<historical>' prior: 0!
Homomorphisms of polynomial rings.!

!ModuleMap commentStamp: '<historical>' prior: 0!
Homomorphisms of modules. See Module and HomModule.!

!FreeModuleMap commentStamp: '<historical>' prior: 0!
Linear transformations between finite-rank free modules (or finite-dimensional vector spaces). They are homomorphisms of free modules, and are internally represented by a matrix and a choice of bases for the domain and codomain.

See FreeModule and FreeHomModule.!

!AffineMap commentStamp: '<historical>' prior: 0!
Affine transformations (affine maps or affinities) defined over affine linear spaces (vector spaces considered as affine spaces by 'forgetting the origin').

Affine maps are defined by a linear map and a translation (a vector of the codomain).

References:
	https://en.wikipedia.org/wiki/Affine_transformation!

!QuadraticForm commentStamp: '<historical>' prior: 0!
Quadratic forms as homogeneous quadratic functions M->R from a finite-rank free R-module to R. Given a basis of M, they can be represented as homogeneous quadratic polynomials or as symmetric matrices that define symmetric bilinear forms MxM->R.!

!MultilinearMap commentStamp: '<historical>' prior: 0!
MultilinearMaps are functions from a cartesian product of R-modules to another R-module, that are linear when fixing all but one of the arguments.!

!BilinearForm commentStamp: '<historical>' prior: 0!
Bilinear forms are functions from MxM to R (where M is a R-module) that satisfy:
	B(v+cv', w) = B(v, w) + cB(v', w)
	B(v, w+cw') = B(v, w) + cB(v, w')
!

!RationalMap commentStamp: '<historical>' prior: 0!
Rational maps between varieties (closed subschemes of affine or projective space). They are defined by a tuple of rational functions.

Rational maps are partial functions defined in a dense open subset of the domain. The scheme where the a rational map is undefined is called its base scheme (see >>base).

A rational map is called 'regular' if it defines a morphism of varieties (i.e., for affine varieties it is defined by polynomials, and in case of projective varieties it is constant.) A regular map is called 'dominant' if its image is dense in its codomain.

The category of affine varieties or projective varieties with dominant rational maps and the category of function fields are contravariantly equivalent.!

!EllipticCurveIsogeny commentStamp: '<historical>' prior: 0!
Scheme morphisms of elliptic curves E -> E' that send the origin of E to the origin of E'. They are homomorphisms of group schemes.!

!LinearFractionalMap commentStamp: '<historical>' prior: 0!
Transformations of the form
	z |-> az + b / (cz + d)
where ad - cb ~= 0.!

!Sequence commentStamp: '<historical>' prior: 0!
Sequences are functions with domain the natural numbers {1,2,...}. They can be evaluated at an index (#value: and #at:), and can also be iterated over like Smalltalk collections (#do:, #collect:, #select, etc).

Example (the Fibonacci sequence):
	Sequence initialValues: #(0 1) recurrence: [:f :n| (f at: n-1) + (f at: n-2)].

Example (the harmonic numbers):
	Sequence to: QQ evaluating: [:n| (1 to: n) sum: [:k| 1/k]].

Each sequence has an associated generating series, which is the formal power series with coefficients given by the sequence (see PowerSeries):
	Sequence fibonacci generatingSeries
and Dirichlet series (see DirichletSeries):
	Sequence fibonacci dirichletSeries
!

!CFiniteSequence commentStamp: '<historical>' prior: 0!
Constant-recursive (or C-recursive or C-finite) sequences, i.e. sequences satisfying homogeneous linear recurrences with constant coefficients:
	a(n) = c_1 a(n-1) + ... + c_d a(n-d)

These sequences are closed under:
- addition a(n)+b(n)
- (Hadamard or termwise) multiplication a(n)*b(n)
- convolution (Cauchy multiplication)
- interlacing {a(1),b(1),a(2),b(2),...}
- scalar multiplication a(n)*c
- (left) shift a(n+k), k>0
- indefinite sumation a(1)+a(2)+...+a(n)
- multisection a(mn+r), 0 <= r < m.

Power series whose coefficients are linear recursive sequences are closed under:
- addition
- multiplication
- derivation

Example:
	CFiniteSequence fibonacci.
	CFiniteSequence fibonacci generatingFunction

Example:
	| f |
	f _ CFiniteSequence fibonacci * CFiniteSequence pellNumbers.
	f minimalPolynomial
!

!SimplicialMap commentStamp: '<historical>' prior: 0!
Morphisms of simplicial complexes. See SimplicialComplex.!

!ModularForm commentStamp: '<historical>' prior: 0!
A modular form of weight k is a holomorphic function f:H -> C from the upper half plane to the complex plane, satisfying for a,b,c,d coefficients of a matrix in SL(2,R)
	f((az + b) / (cz + d)) = (cz + d)^k f(z)
where k is a fixed integer or half-integer. Modular forms of weight 0 are called modular functions, and are invariant under the action of SL(2,R). The factor (cz + d)^k, which is 1 in the case of modular functions, is called the automorphic factor.

Modular forms are functions having an infinite group of symmetries and many beautiful properties. They are one of the five basic operations in arithmetic, together with addition, substraction, multiplication and division.

A modular form f(z) can be seen as power series on a new variable q = e^(2 pi i z). This is its Fourier expansion or q-expansion. The coefficients a(n) of the q-expansion are usually interesting arithmetic functions.

Given a group G, the set of modular forms of a given weight k form a finite-dimensional vector space M_k(G). See ModularFormSpace. The set of all modular forms of all weights is noted M_*(G) and it's a ring. All modular functions form a field.!

!RationalPoint commentStamp: '<historical>' prior: 0!
Abstract superclass for K-rational points on a scheme X, seen as morphisms Spec(K) -> X.

See also Scheme and PointSet.!

!AffinePoint commentStamp: '<historical>' prior: 0!
K-rational points on an affine variety X, seen as morphisms Spec(K) -> X.

See also AffineVariety.!

!ProjectivePoint commentStamp: '<historical>' prior: 0!
K-rational points on a projective variety X, seen as morphisms Spec(K) -> X.

See also ProjectiveVariety.!

!ProjectiveLinePoint commentStamp: '<historical>' prior: 0!
Points on the projective line P^1(R) for some ring R. See also ProjectiveLine.!

!EllipticCurvePoint commentStamp: '<historical>' prior: 0!
K-rational points on an elliptic curve E, seen as morphisms Spec(K) -> E. These objects implement the group law (with additive notation). The identity element (zero, or the point at infinity) is [0:1:0].

Following conventions, a point [a:b:1] is printed '(a,b)', and the point at infinity [0:1:0] is printed 'O'.

See also EllipticCurve.!

!Monomial commentStamp: '<historical>' prior: 0!
Commutative power products of one or many indeterminates. They form a monoid (see FreeAbelianMonoid). Their formal linear combinations over a ring are Polynomials (see also PolynomialRing).

See also Word for the noncommutative analog, and Sum for the additive analog.!

!Word commentStamp: '<historical>' prior: 0!
A word is a noncommutative formal product on a finite ordered list of indeterminates. They are elements of a FreeMonoid.

See also Monomial for the commutative analog, and Sum for the additive analog.!

!Coset commentStamp: 'len 10/10/2018 06:26:47' prior: 0!
Right cosets of a subgroup H of a group G: {Hg : g in G}.!

!OppositeGroupElement commentStamp: 'len 5/8/2019 14:34:38' prior: 0!
Elements of the opposite group of a given group. See OppositeGroup.!

!Permutation commentStamp: '<historical>' prior: 0!
Permutations are bijective functions on a finite set. Permutations under composition form groups (see SymmetricGroup and PermutationGroup).!

!OppositeRingElement commentStamp: 'len 5/8/2019 14:55:26' prior: 0!
Elements of the opposite ring of a given ring. See OppositeRing.!

!ProductRingElement commentStamp: 'len 5/22/2018 16:08:11' prior: 0!
Elements of direct products of rings. See ProductRing.!

!Ratio commentStamp: '<historical>' prior: 0!
Elements of the form 'a / b', with a and b in a commutative ring R, and satisfying the equivalence relation: (a / b) = (a' / b') iff a*b' = a'*b.

They are elements of ring localizations or fraction fields. See LocalizationRing and FractionRing.!

!RationalFunction commentStamp: '<historical>' prior: 0!
Rational functions are fractions of polynomials. They are elements of the field of fractions of a polynomial ring over a field (see RationalFunctionField).!

!Residue commentStamp: '<historical>' prior: 0!
Elements of a quotient ring. They are residue classes of elements of a ring modulo an ideal. See QuotientRing.!

!ModularInteger commentStamp: '<historical>' prior: 0!
Residue classes of integers modulo an integer m, i.e. elements of the quotient ring Z/mZ (see ModularIntegerRing).!

!RegularFunction commentStamp: '<historical>' prior: 0!
Residue classes of polynomials modulo an ideal. They are elements of a quotient polynomial ring (an affine algebra, see AffineRing). They correspond to regular functions on an affine variety (see AffineVariety).!

!AlgebraicElement commentStamp: '<historical>' prior: 0!
Elements of finite algebraic field (or ring) extensions. See AlgebraicExtensionRing.!

!AdicInteger commentStamp: '<historical>' prior: 0!
Elements of the p-adic ring Zp. See AdicIntegerRing.!

!AdicNumber commentStamp: '<historical>' prior: 0!
Elements of the p-adic field Qp. See AdicRationalField.

A p-adic number z is represented uniquely by an integer k (the valuation) and a unit u in Zp, such that z = (p^k)*u.!

!Polynomial commentStamp: 'len 5/11/2019 08:20:21' prior: 0!
Polynomials in one or many indeterminates, with coefficients in a commutative ring. These are elements of a PolynomialRing.

This is an abstract class. See subclasses MultivariatePolynomial and UnivariatePolynomial for concrete implementations.

See also PolynomialRing, RationalFunction.!

!MultivariatePolynomial commentStamp: '<historical>' prior: 0!
Polynomials in one or more indeterminates, represented in sparse form.

Multivariate polynomials are internally stored as a list of associations 'monomial -> coefficient'. Zero coefficients are excluded, and the list is kept sorted according to the corresponding monomial ordering.!

!UnivariatePolynomial commentStamp: '<historical>' prior: 0!
Univariate polynomials, represented in dense form.

They are stored as a Tuple indexed by degree (the first element of the coefficients tuple corresponds to the independent coefficient of the polynomial).!

!LaurentSeries commentStamp: '<historical>' prior: 0!
Univariate formal Laurent series with coefficients over a commutative ring. See LaurentSeriesRing.!

!PowerSeries commentStamp: '<historical>' prior: 0!
Univariate formal power series with coefficients over a commutative ring. See PowerSeriesRing.!

!Sum commentStamp: '<historical>' prior: 0!
Formal sums (or formal linear combinations) of arbitrary symbols with coefficients over a given ring R. They can be thought of as Tuples indexed not by positive integers but by arbitrary symbols. They form free R-modules (see FreeSumsModule).

See also Monomial for the multiplicative analog, and Word for the noncommutative analog.!

!Tensor commentStamp: '<historical>' prior: 0!
Elements of tensor product modules (see TensorProductModule).

Tensors are represented as sparse formal sums of formal products of basis elements.!

!Divisor commentStamp: '<historical>' prior: 0!
Weil divisors, i.e. formal sums (with integer coefficients) of prime divisors (integral closed subschemes of codimension 1) of an integral locally Noetherian scheme.!

!SimplicialChain commentStamp: '<historical>' prior: 0!
A simplicial k-chain is a formal linear combination of k-simplices.!

!FreePolynomial commentStamp: '<historical>' prior: 0!
Polynomials in a finite set of non-commuting indeterminates. They are elements of a free associative algebra (FreeAlgebra).

A free polynomial is a formal linear combination of Words, that in turn are formal (noncommutative) products of arbitrary objects (indeterminates).!

!GroupAlgebraElement commentStamp: '<historical>' prior: 0!
Formal linear combinations of elements of a group G with coefficients in a ring R. Alternatively, they can be thought as the finite-support functions from G to R. They form a ring R[G] called the group ring of G over R. See GroupRing.!

!Tuple commentStamp: '<historical>' prior: 0!
n-tuples with coefficients in some ring R, i.e. finite ordered lists of n elements of R indexed by integers 1 to n. They are the elements of the R-module R^n.

Some subclasses implement special kinds of tuples for concrete rings, such as Z/mZ and Z/2Z. These special tuples have a compact representation that saves memory and allows fast arithmetic. Many parts of the system (such as linear algebra and polynomials) ultimately rely on tuples.

Tuples are commonly created by sending a message to the ring where the coefficients belong to. For example:
	"Two ways to create the 4-tuple (1,2,4,8) with integer coefficients:"
	ZZ tuple: #(1 2 4 8).
	ZZ tuple: 4 evaluating: [:i| i squared].

It is also handy to create tuples by sending the message #, to a number. For example:
  (1,2,4,8)
However, when created in this way, even if all the coefficients are Integers, the tuple will be considered a rational tuple (with coefficients in the field of rational numbers QQ), so the above example is equivalent to:
	QQ tuple: #(1 2 4 8)
!

!BitTuple commentStamp: '<historical>' prior: 0!
Tuples of integer residue classes modulo 2, i.e. a binary tuple, a bit string, or a tuple of bits. The coefficients field is Z/2Z.

Example:
	"A handy way to create a binary tuple:"
	(1,0,1,1,0,1,1,1) % 2
!

!GenericTuple commentStamp: '<historical>' prior: 0!
Gneral n-tuples internally represented as an Array. These are the tuples used by default for an arbitrary ring.!

!ModularTuple commentStamp: '<historical>' prior: 0!
Tuples with coefficients in an integer residue class ring (or field) Z/mZ. See ModularInteger, ModularIntegerRing, PrimeField.

Example:
	"A handy way to create a tuple of integers modulo 3:"
	(1,2,3,4) % 3
!

!Matrix commentStamp: 'len 4/4/2018 01:27:42' prior: 0!
Matrices with coefficients in a commutative ring.!

!ColumnMatrix commentStamp: '<historical>' prior: 0!
My instances are matrices with coefficients over some commutative ring, represented as a list of column tuples. Column operations are fast on these matrices.!

!RowMatrix commentStamp: '<historical>' prior: 0!
Matrices with coefficients over some commutative ring, represented as a list of row tuples. Row operations are fast on these matrices.!

!MonomialOrdering commentStamp: '<historical>' prior: 0!
A monomial ordering is a total order on the set of all monomials in n indeterminates, satisfying the properties:
- respects multiplication: if u <= v, then u*w <= v*w for any other monomial w;
- 1 <= u for any monomial u.

Orderings are used in the computation of Groebner bases and more generally standard bases. See StandardBasis.
!

!BlockMonomialOrdering commentStamp: '<historical>' prior: 0!
Block or product monomial orderings. They are used, for example, to define elimination orderings such that a subset of the indeterminates are always greater and the rest of the indeterminates.!

!GradedLexicographicOrdering commentStamp: 'len 2/12/2017 06:08:59' prior: 0!
The graded (or total degree) lexicographic ordering first compares the total degree of the monomials, and takes the monomial with largest total degree. If two monomials have the same total degree, the lexicographic ordering is used to break the tie.

The graded lexicographic ordering has the property that for each subring S[x1..xn] <= R, and each homogeneous polynomial f in R, f is in S iff its leading monomial is in S.

Elimination by the graded lexicographic ordering produces elements of an homogeneous ideal which are free of the first variable.!

!GradedReverseLexicographicOrdering commentStamp: 'len 2/12/2017 06:09:26' prior: 0!
The graded (or total degree) reverse lexicographic ordering first compares the total degree of the monomials, and takes the monomial with largest total degree. If two monomials have the same total degree, the reverse lexicographic ordering is used to break the tie (this is the lexicographic ordering on the reversed list of indeterminates (xn, ..., x1).

The graded reverse lexicographic ordering has the property that for each subring S[x1..xn] <= R, and each homogeneous polynomial f in S[x1..xi], xi divides f iff it divides the leading monomial.

Elimination by the graded reverse lexicographic ordering produces elements of a homogeneous ideal which are divisible by the last variable.!

!LexicographicOrdering commentStamp: '<historical>' prior: 0!
The lexicographic ordering is the 'dictionary' ordering.

The lexicographic ordering has the property that for each subring S[x1..xn] <= R, and each polynomial f in R, f is in S iff its leading monomial is in S.

Elimination by the lexicographic ordering produces elements of an ideal which are free of the first variable.!

!LocalGradedLexicographicOrdering commentStamp: 'len 2/12/2017 06:10:10' prior: 0!
The local graded lexicographic order (lglex) is the negation of the global graded lexicographic order (glex).

This is the order called 'lglex' in Magma. What Singular calls 'Ds', on the other hand, is like this but with the indeterminates reversed.!

!LocalGradedReverseLexicographicOrdering commentStamp: 'len 2/12/2017 06:10:33' prior: 0!
The local graded reverse lexicographic order (lgrevlex) is the negation of the global graded reverse lexicographic order (grevlex).

This is the order called 'lgrevlex' in Magma. What Singular calls 'ds', on the other hand, is like this but with the indeterminates reversed.!

!LocalLexicographicOrdering commentStamp: '<historical>' prior: 0!
The local lexicographic order (llex) is the negation of the global lexicographic order.

This is the order called 'llex' in Magma. What Singular calls 'ls', on the other hand, is like this but with the indeterminates reversed.!

!WeightedMonomialOrdering commentStamp: '<historical>' prior: 0!
Monomial orderings defined by weight tuples.

For monomials in n variables, there are n!! (n factorial) orderings. In certain applications such as Groebner bases it's desirable to easily construct new monomial orderings.

ideterminates 		an array with the indeterminates (variables) in order;
weights 				n-tuples with real coefficients.

Suppose you have two monomials:
	a = x1^a1 x2^a2 ... xn^an
	b = x1^b1 x2^b2 ... xn^bn
where some of the ai or bi may be 0. And suppose the variables are ordered x1 < x2 < ... < xn. If we are asked for the truth of a < b, we enumerate the weights and for each one, (w1, w2, ..., wn) we do:
	aSum = a1 w1 + a2 w2 + ... + an wn,
	bSum = b1 w1 + b2 w2 + ... + bn wn;
if aSum < bSum, then a < b; if aSum > bSum, then a > b; if aSum = bSum, we continue with the next weight, until there are no more weights (then, a should equal b...).

Theorem: For any monomial ordering in a finite number of variables, there is a collection of weights that models the ordering. So, with this idea we can contruct any ordering.
!

!ProductReplacementRandomGenerator commentStamp: '<historical>' prior: 0!
Product Replacement Algorithm for generating random elements in a group from a set of generators. Essentially, it performs a random walk on a Cayley graph.!

!SchreierTree commentStamp: '<historical>' prior: 0!
Given a finite group G with a generating set S, and an action of G on X, a Schreier tree with root x for S is a representation of the orbit of x: it's a tree rooted at x with the elements of x^G as its vertices, and its edges describing the elements of S needed to get from x to each vertex, i.e. each edge {i,j} in the tree with i closer to the root than j is labeled by a generator s in S moving i to j.

Schreier trees allow for fast computation of stabilizers by Schreier's Lemma: with the notation above, the stabilizer of x is generated by the set of Schreier generators <t(i) * s * t(s(i))^-1> where i runs over the orbit of x, s runs over the generating set S, and t(i) is an element of G moving x to i, i.e. a coset representative of i (see >>trace: and >>traceInverse:).
!

!ComplexAlgebraicNumber commentStamp: '<historical>' prior: 0!
Complex algebraic numbers, i.e. zeros of polynomials with integer (or rational) coefficients, in 'minimal polynomial' representation. See also RealAlgebraicNumber.!

!ChainComplex commentStamp: 'len 5/14/2019 16:24:42' prior: 0!
(Bounded) chain complexes.

A chain complex is a sequence of abelian groups or modules C(k) (called k-chains) conected by homomorphisms d(k):C(k)->C(k-1) (called boundary operators or differentials) such that the composition between any two consecutive differentials is the trivial map: d(k)d{k+1} = 0.

A bounded chain complex is one where only a finite number of C(k) are not {0}.

Chain complexes form a cateogory with chain maps as morphisms. See ChainMap.!

!ChainMap commentStamp: '<historical>' prior: 0!
A chain map between two chain complexes defined by differentials d(k):C(k)->C(k-1) and d'(k):C'(k)->C'(k-1) is a sequence of homomorphisms f(k):C(k)->C'(k) that commute with the differentials in the two complexes: d'(k) o f(k) = f(k-1) o d(k). They send cycles to cycles and boundaries to boundaries, and this descends to a map in homology f(k)* : H(k) -> H'(k).

Chain maps are morphisms in the category of chain complexes. See ChainComplex.!

!HermiteColumnReduction commentStamp: '<historical>' prior: 0!
This is the Hermite column reduction algorithm. Given a matrix with coefficients in the rational integers Z, it reduces the matrix to its column-style Hermite normal form.

Reference: Henri Cohen, 'A Course in Computational Algebraic Number Theory', Algorithm 2.4.4.

See HermiteReduction for the algorithm modified to do row reduction instead of column reduction, and generalized to work over any computable Euclidean domain.!

!MatrixReduction commentStamp: '<historical>' prior: 0!
Abstract superclass for matrix (row) echelonization algorithms.!

!GaussianElimination commentStamp: '<historical>' prior: 0!
This is the Gaussian Elimination algorithm.

My instances perform Gaussian reduction on a matrix to compute its echelon form, linear dependency of the columns, rank, determinant, inverse matrix, etc.

Input: a matrix with coefficients in a field;
Output: the reduced echelon form of the matrix, determinant and left inverse.

The algorithm performs O(2n^3/3) field operations for nxn matrices, but due to exponential growth of intermediate coefficients it can be impractical in many situations (for example, with rational coefficients).!

!GaussBareiss commentStamp: '<historical>' prior: 0!
This is the Gauss-Bereiss algorithm, a variant of Gassian elimination. It performs division-free Gaussian elimination on a matrix with coefficients in an integral domain, and computes the echelon form.

Input: a matrix with coefficients in a an integral domain;
Output: the reduced echelon form and the determinant.

The algorithm performs O(n^3) ring operations for nxn matrices. While the standard Gaussian elimination suffers from exponential intermediate coefficients growth, the Gauss-Bareiss algorithm has bit complexity O(n^5).
!

!HermiteReduction commentStamp: '<historical>' prior: 0!
This is the Hermite row reduction algorithm. Given a matrix with coefficients in a computable Euclidean domain, it reduces the matrix to its row-style Hermite normal form.

Reference: Henri Cohen, 'A Course in Computational Algebraic Number Theory', Algorithm 2.4.4 (modified to do row reduction instead of column reduction and generalized to Euclidean domains).
!

!SmithReduction commentStamp: '<historical>' prior: 0!
This is the Smith reduction algorithm. Given a matrix with coefficients in a PID, it reduces the matrix to its Smith normal form.

The Smith normal form is very useful for working with finitely generated modules over a PID, and in particular for deducing the structure of a quotient of a free module.

Reference: Henri Cohen, 'A Course in Computational Algebraic Number Theory', Algorithm 2.4.14.!

!LLL commentStamp: '<historical>' prior: 0!
This is the Lenstra-Lenstra-Lovasz algorithm.

Input: integer lattice of dimension d given by a basis {b1, ..., bd};
Output: an almost H-reduced basis of the lattice.

The algorithm takes at most O(d^6 ln^3(B)), where the input vectors bi all satisfy |bi|^2 <= B. In practice however, this upper bound is quite pessimistic.
!

!ModuleMonomial commentStamp: '<historical>' prior: 0!
Mnomials in multivariate R-modules (where R is a multivariate ring such as a polynomial ring or an affine ring). They are the formal product of a monomial in R by a basis element.!

!ModuleMonomialOrdering commentStamp: '<historical>' prior: 0!
Generalizations of monomial orderings to multivariate R-modules (where R is a multivariate ring such as a polynomial ring or an affine ring). They extend the ordering of the coefficients ring R to elements of the R-module.!

!Buchberger commentStamp: 'len 5/7/2018 23:50:07' prior: 0!
This is the Buchberger's algorithm.

Input: a polynomial ideal given by generators, with a choice of monomial ordering;
Output: a standard basis or a Groebner basis.

When the monomial ordering is global, the algorithm outputs a Groebner basis. In case of a local monomial ordering, the algorithm uses Mora's normal form and outputs a standard basis.
!

!ExtendedBuchberger commentStamp: '<historical>' prior: 0!
This is the extended Buchberger algorithm. It keeps track of how the polynomials in the Groebner basis arise as linear combinations of the original generators of the ideal, and produces a matrix that maps the original generators to the Groebner basis (or equivalently a 'change of coordinates' module endomorphism of the corresponding ideal).

Input: a polynomial ideal given by generators, with a choice of *global* monomial ordering;
Output: a Groebner basis, and a 'change of basis' matrix that maps the original generators to the Groebner basis.

See Buchberger for a more general algorithm that works with both global and local monomial orderings.!

!ComplexRootIsolator commentStamp: '<historical>' prior: 0!
This is the CEVAL algorithm [1] for isolating the complex roots of a square-free polynomial.

[1] Michael Sagraloff, Chee K. Yap, "An Efficient and Exact Subdivision Algorithm for Isolating Complex Roots of a Polynomial and its Complexity Analysis" (2009)!

!MultivariatePolynomialDivision commentStamp: '<historical>' prior: 0!
This is the multivariate polynomial division algorithm for polynomials over a field.

Input: dividend f and divisors f1,..,fs in K[x1..xd] with a monomial ordering;
Output: quotients q1,..,qs and remander r in K[x1..xd] such that f = q1*f1 + ... + qn*fn + r, such that:
1. LM(qifi) <= LM(f);
2. None of the monomials in r is divisible by any LM(fi).

The algorithm performs O(n^d m^d) operations in the coefficients field K, where n is the total degree of f and m is the maximal total degree of f1..fs.!

!NumericalComplexRootIsolator commentStamp: '<historical>' prior: 0!
This algorithm separates complex roots of polynomials with real or complex coefficients. This is Newton's modified algorithm [1], and the convergence is quadratic. The polynomial is assumed to be squarefree.

Input: a square-free polynomial of degree n with real or complex coefficients, and a desired minimum absolute error (tolerance);
Output: a collection of the n complex roots of the polynomial.

[1] "A Course in Computational Algebraic Number Theory", Cohen, Algorithm 3.6.6.!

!PolynomialDivision commentStamp: '<historical>' prior: 0!
This is the long division algorithm for univariate polynomials over a field.

Input: dividend and divisor polynomials f,g in K[x], where K is a field;
Output: quotient and remainder polynomials q,r in K[x] such that f = q*g + r, deg(r) < deg(g).

The algorithm performs O(n^2) arithmetic operations for dense polynomials of degree n.!

!PolynomialPseudoDivision commentStamp: '<historical>' prior: 0!
This is the pseudo-division algorithm for univariate polynomials over a ring.

Input: dividend and divisor polynomials f,g in R[x], where R is a ring;
Output: quotient and remainder polynomials q,r in R[x], such that b*f = q*g + r, deg(f) = deg(g) + deg(q), deg(r) < deg(g) and b = LC(g)^max(0,deg(f)-deg(g)+1).

The algorithm performs O(n^2) arithmetic operations for dense polynomials of degree n.!

!BerlekampMassey commentStamp: '<historical>' prior: 0!
This is the Berlekamp-Massey algorithm. The initial purpose of this algorithm was to evaluate Binary BCH codes, but it has found many uses, including inverting matrices of constant diagonal, solving linear recurrences (synthesizing LFSRs with a specified output sequence), etc.

Input: a_1..a_{2n} the first 2n coefficients of a linear recursive sequence over a field K of order at most n (the minimal polynomial has degree bound n);
Output: the minimal polynomial of the sequence.

The algorithm performs O(n^2/2) multiplications; more precisely, at most 2 floor(n^2/4) - n + 1 multiplications.!

!CRT commentStamp: '<historical>' prior: 0!
This is the Chinese Remainder Theorem. My instances find solutions to systems of linear Diophantine equations x = x_i (mod m_i). The algorithm works on any Euclidean domain.

Input: x_1...x_k, k elements in an Euclidean domain, and m_1,...,m_k pairwise coprime, defining the Diophantine system x = x_i (mod m_i);
Output: x such that x = x_i (mod m_i) for 1<=i<=k.
!

!ExtendedEuclid commentStamp: '<historical>' prior: 0!
This is the extended Euclidean algorithm.

Input: an array of two elements in an Euclidean domain {a. b}
Output: the GCD of a with b, and a pair of Bezout coefficients {u. v} such that a*u + b*v = (a,b).

In the case of integers, if |a|<=|b| the output |u| and |v| are unique and satisfy:
	-|a| / d < v*sign(b) <= 0.
	1 <= u*sign(a) <= |b| / d
where d = gcd(a,b).

For integers, the algorithm takes time O(ln^3 N) where |a|,|b| <= N. For polynomials of degree n, it is O(n^3).!

!LagrangeGaussReduction commentStamp: '<historical>' prior: 0!
This is the Lagrange-Gauss reduction algorithm. My instances perform reduction of lattice basis of rank 2, and the algorithm it is essentially Euclid's algorithm.

Input: a vector space V and two independent vectors {v1,v2} that generate a lattice;
Output: a short vector in the lattice.
!

!ModifiedBerlekampMassey commentStamp: '<historical>' prior: 0!
This is a modified [1] Berlekamp-Massey algorithm. This modified version admits lazy evaluation.

Input: a_1..a_{2n} the first 2n coefficients of a linear recursive sequence over a field K of order at most n (the minimal polynomial has degree bound n);
Output: the minimal polynomial of the sequence.

[1] 'The Berlekamp-Massey Algorithm revisited', Nadie Ben Atti, Gema M Diaz-Toca, Henri Lombardi.
!

!NTT commentStamp: '<historical>' prior: 0!
Number Theoretic Transforms, the analog of DFTs for the field of integers modulo a prime p. Special cases are the Fermat Number Transform (p = 2^k + 1) and the Mersenne Number Transform (p = 2^k - 1).

The (pseudo) number theoretic transform may be meaningful in the ring Z/<m> even when the modulo m is not prime, provided a principal root of order n exists.!

!TonelliShanks commentStamp: 'len 12/29/2016 08:02:15' prior: 0!
This is the Tonelli-Shanks algorithm for computing square roots in a prime field Z/pZ.

Reference: Henri Cohen, 'A Course in Computational Algebraic Number Theory', Algorithm 1.5.1.!

!DirichletSeries commentStamp: '<historical>' prior: 0!
Formal Dirichlet series, i.e. formal series in an indeterminate x of the form: sum a(n) * n^{-x} for n >= 1.

Examples:
	DirichletSeries coefficients: Sequence moebius.
	Sequence liouville dirichletSeries.

Structure:
 coefficients	Sequence -- the coefficients of the Dirichlet series
!

!GraphNode commentStamp: '<historical>' prior: 0!
Abstract class for nodes that are held in a graph.

Each node holds on to a corresponding object that is the value of that node.

Subclasses add state/behaviour to represent edges in the graph.!

!ExplicitGraphNode commentStamp: '<historical>' prior: 0!
An explicit nodes stores the edges in a collection, an instance variable. The type of the collection varies as to whether the graph is ordered, of fixed arity, etc.

To change the edge collection, addNeighbor: and removeNeighbor: messages are supplied.
!

!LabeledExplicitGraphNode commentStamp: '<historical>' prior: 0!
A labeled explicit node associates a label with each neighbor, and a label with the node itself; i.e. nodes and edges are labeled.

When adding neighbors, the edge label must be given.!

!ImplicitGraphNode commentStamp: '<historical>' prior: 0!
An implicit node has the edge structure represented within its value, and therefore forwards messages to the value to access edges.

To change the edge collection, you must send messages to the value.

Subclasses decide as to whether the value can yield a collection of edges more efficiently than iterating over them.!

!ImplicitCollectionGraphNode commentStamp: '<historical>' prior: 0!
Implicit graphs nodes that access the collection of edges by evaluating a block.!

!ImplicitIteratorGraphNode commentStamp: '<historical>' prior: 0!
Implicit graph nodes that iterate over the collection of edges by evaluating the iterator.!

!DAGFrontier commentStamp: '<historical>' prior: 0!
A DAGFrontier is used to iterate a directed acyclic graph (DAG) respecting the dependencies between nodes.  A client does not create it directly, but sends the message "frontier" to the DAG in question.

At any moment it holds a "frontier" of nodes that can be accessed.  When any node in the frontier has been processed, it can be removed from the frontier, and the frontier will be updated if necessary (in situ).

Instance variables:
frontier		<Set> of nodes on the frontier, empty if the whole DAG has been enumerated.
bag		<Bag> of nodes, used to calculate updates to the frontier.

Clients of this class must *not* modify the frontier set, only access it.
!

!Dijkstra commentStamp: '<historical>' prior: 0!
This is Dijkstra's algorithm for computing distances and shortest paths in a graph from a fixed starting node (source). If the graph is edge-labeled, the labels are used as weights.

Pre-Input: a graph G = (V, E), and a node (source);
Input: a target node;
Output: the shortest distance from the source node to the target node, or a shortest path.

The initial precomputation takes time O(|V|^2). Afterwards, it's possible to compute disntances in time O(log |V|) and shortest paths of length k in O(k log |V|). The O(log |V|) comes from the dictionary lookup operation, a lookup in a hash table.!

!FloydWarshall commentStamp: '<historical>' prior: 0!
This is the Floyd-Warshall algorithm for solving the all-pairs shortest path problem (for weighted graphs). I compute distances and shortest paths in a graph. If the graph is edge-labeled, the labels are used as weights.

Pre-Input: a graph G = (V, E);
Input: a pair of nodes (source and target);
Output: the shortest distance from the source node to the target node, or a shortest path.

The initial precomputation takes time O(|V|^3). Afterwards, it's possible to compute distances in time O(log |V|) and shortest paths of length k in O(k log |V|). The O(log |V|) comes from the dictionary lookup operation, a lookup in a hash table.

While (after initial precomputation) Dijkstra's algorithm is able to efficiently compute distances from a fixed source node, Floyd-Warshall's computes distances from any two arbitrary nodes. However, for sparse graphs with non-negative edge weights a better choice is to use Dijkstra's algorithm with binary heaps, which gives a time complexity of O(|V| |E| log |V|).!

!WeierstrassEquation commentStamp: '<historical>' prior: 0!
Weierstrass equations are equations of the form
	y^2 + a1 xy + a3 y = x^3 + a2 x^2 + a4 x + a0
with coefficients (a1,a2,a3,a4,a6) in some field.

When the discriminant is not zero, they define an elliptic curve. See EllipticCurve.!

!FareySymbol commentStamp: '<historical>' prior: 0!
Farey symbols give information about finite index subgroups of the modular group (such as index, generators, etc) and about the associated modular curve (such as genus and rank of the fundamental group).

References
	R. S. Kulkarni, "An arithmetic-geometric method in the study of the subgroups of the modular group", American Journal of Mathematics 113 (1991), no. 6, 1053-1133.
	Chris A. Kurth, Ling Long, "Computations with finite index subgroups of PSL(2,Z) using Farey symbols".
	John Voight, "Computational methods for modular and Shimura curves", lecture videos in youtube.!

!AdicIntegerResidue commentStamp: '<historical>' prior: 0!
Residues of a p-adic quotient ring Zp/(p^k)Zp, or equivalently p-adic integers (finite approximations to p-adic integers by the p-adic expansion up to p^k). It is represented by an integer residue class modulo p^k (i.e., an element of a PrimePowerRing).
!

!AlgebraicExtensionAsModule commentStamp: '<historical>' prior: 0!
Algebraic extensions seen as modules or vector spaces. See AlgebraicExtension.!

!GaussianElimination2 commentStamp: '<historical>' prior: 0!
I am the Gaussian Elimination algorithm.

Given a matrix M with coefficients in a field, my instances perform Gaussian reduction on the matrix to compute linear dependency of the columns, rank, determinant, inverse matrix, etc.!

!GramSchmidt commentStamp: '<historical>' prior: 0!
I am the Modified (stabilized) Gram-Schmidt basis orthogonalization algorithm.

Input: a basis B = {v_1, ..., v_n} of m-tuples;
Output: another basis, namely B' = {v_1', ..., v_n'} generating the same subspace and satisfying:
	o. v_1' = v_1;
	o. v_i' is the orthogonal projection of v_i onto the space generated by the first i-1 vectors.
Furthermore, the algorithm computes a lower triangular matrix, M, such that:
	B = B'^t M.

The algorithm performs O(2mn^2) arithmetic operations.
!

!OrderAsModule commentStamp: '<historical>' prior: 0!
Orders of number fields seen as free Z-modules. They are embedded in the ambient vector space corresponding to the ambient number field of the order. See Order.!

!QRDecomposition commentStamp: '<historical>' prior: 0!
My instances are QR factorizations of a given real or complex matrix A, such that A = Q*R where Q is unitary (orthogonal) and R is upper triangular. Morover, if A is nonsingular, the diagonal of R may be taken to be positive, in which case the factorization is unique.!

!Quaternion commentStamp: 'len 11/20/2015 00:39' prior: 0!
My instances are quaternions. Quaternions constitute an example of non-commutative field.
!

!Subdomain commentStamp: '<historical>' prior: 0!
Subdomains of a Domain are the subobjects of category theory.

A subdomain of a domain C is an isomorphism class of monomorphisms i:A->C into C, where two morphisms i:A->C and j:B->C are isomorphic if there exists an isomorphism k:A->B such that i = jk.

References:
	https://ncatla.org/nlab/show/subobject
!

!WuRittProcess commentStamp: 'len 12/30/2015 05:43' prior: 0!
I'm the Ritt-Wu process.

Input: a set of polynomials F = {f1,...,fr} in K[x1,...,xn];
Output: an extended characteristic set (or ascending chain, or Wu characteristic set) of F.
!

!MutualAssociation methodsFor: 'printing' stamp: 'len 7/13/2016 07:31'!
printOn: aStream
	aStream
		print: key;
		nextPutAll: ' <-> ';
		print: value! !

!Aleph methodsFor: 'printing' stamp: 'len 6/7/2016 21:43'!
printOn: aStream
	aStream nextPut: Character aleph; nextPutAll: order printString sub! !

!Infinity methodsFor: 'printing' stamp: 'len 4/11/2016 23:43'!
printOn: aStream
	self negative ifTrue: [aStream nextPut: $-].
	aStream nextPut: Character infinity
"	aStream nextPutAll: 'infinity'"! !

!BitArray methodsFor: 'printing' stamp: 'len 12/21/2015 20:42'!
printOn: aStream
	1 to: self size do: [:i| aStream print: (self at: i)]! !

!LinearBasis methodsFor: 'printing' stamp: 'len 12/12/2017 19:27:13'!
printOn: aStream
	aStream nextPut: ${.
	self do: [:each| aStream print: each] separatedBy: [aStream nextPutAll: '; '].
	aStream nextPut: $}! !

!StandardBasis methodsFor: 'printing' stamp: 'len 5/7/2018 23:22:28'!
printOn: aStream
	aStream nextPut: ${.
	elements do: [:each| aStream print: each] separatedBy: [aStream nextPutAll: ', '].
	aStream nextPut: $}! !

!Graph methodsFor: 'printing' stamp: 'len 7/13/2016 22:54'!
printOn: aStream
	self isEmpty ifTrue: [aStream nextPut: Character emptySet. ^ self].
	super printOn: aStream! !

!YoungTableau methodsFor: 'printing' stamp: 'len 1/17/2017 09:06:41'!
printOn: aStream
	self rows do: [:row|
		aStream nextPut: $[.
		row do: [:each| aStream print: each] separatedBy: [aStream nextPut: $|].
		aStream nextPut: $]] separatedBy: [aStream lf; space]! !

!Simplex methodsFor: 'printing' stamp: 'len 2/27/2017 08:21:52'!
printOn: aStream
"	self isTrivial ifTrue: [aStream nextPut: Character emptySet. ^ self]."
	aStream nextPut: ${.
	self vertices do: [:each|
		(each isString and: [aStream isText])
			ifTrue: [aStream nextPutAll: each asText]
			ifFalse: [aStream print: each]] separatedBy: [aStream nextPut: $,].
	aStream nextPut: $}! !

!MonomialIndexedTuple methodsFor: 'printing' stamp: 'len 2/25/2017 08:53:10'!
printOn: aStream
	| c |
	self isZero ifTrue: [aStream nextPutAll: '0'. ^ self].
	c _ associations last value.
	c printString first = $-
		ifTrue: [c _ c negated. aStream nextPut: $-].
	c ~= scalars one ifTrue: [self printCoefficient: c on: aStream].
	associations last key isIdentity
		ifFalse: [aStream print: associations last key].
	associations allButLast reverseDo: [:each|
		c _ each value.
		c printString first = $-
			ifTrue: [aStream nextPutAll: ' - '. c _ c negated]
			ifFalse: [aStream nextPutAll: ' + '].
		c ~= c one ifTrue: [self printCoefficient: c on: aStream].
		each key isIdentity
			ifFalse: [aStream print: each key]]! !

!HistogramMorph methodsFor: 'copying' stamp: 'jmv 4/10/2015 16:16'!
postCopy
	tallies _ tallies copy! !

!Domain methodsFor: 'accessing' stamp: 'len 12/28/2016 11:21:15'!
name
	^ self propertyAt: #name ifAbsent: [self printString]! !

!Domain methodsFor: 'copying' stamp: 'len 3/19/2016 22:41'!
postCopy
	super postCopy.
	properties _ properties copy! !

!Domain methodsFor: 'printing' stamp: 'len 5/25/2018 18:11:49'!
printOn: aStream
	"Subclasses should reimplement defaultPrintOn: instead of this method."
	self propertyAt: #name ifPresent: [:aString| aStream nextPutAll: aString italic. ^ self].
	self propertyAt: #elements ifPresent: [:aCollection|
		(aCollection isKindOf: Domain) ifTrue: [aStream print: aCollection. ^ self].
		aStream nextPut: ${. "Wildberger notation for unordered sets: elements separated by spaces"
		aCollection asSet do: [:each| aStream print: each] separatedBy: [aStream nextPutAll: ' '].
		aStream nextPut: $}.
		^ self].
	^ super printOn: aStream! !

!HomSet methodsFor: 'printing' stamp: 'len 12/5/2016 11:56:13'!
printOn: aStream
	self isEndomorphisms
		ifTrue: [aStream nextPutAll: 'End'; nextPut: $(; print: self domain; nextPut: $)]
		ifFalse: [aStream nextPutAll: 'Hom'; nextPut: $(; print: self domain; nextPut: $,; print: self codomain; nextPut: $)]! !

!ComplexBox methodsFor: 'printing' stamp: 'len 1/11/2016 02:57'!
printOn: aStream
	aStream print: real; nextPutAll: ' + '; print: imaginary; nextPut: $i! !

!ComplexDisk methodsFor: 'printing' stamp: 'len 6/5/2016 20:42'!
printOn: aStream
	aStream nextPutAll: 'D('; print: self center; nextPut: $,; print: self radius; nextPut: $)! !

!RealBox methodsFor: 'printing' stamp: 'len 6/7/2016 00:51'!
printOn: aStream
	components do: [:each| aStream print: each] separatedBy: [aStream nextPut: Character times]! !

!RealInterval methodsFor: 'printing' stamp: 'len 12/13/97 03:23'!
printOn: aStream
	"Print a representation of the receiver in the stream aStream."

	aStream
		nextPut: (self isLeftOpen ifTrue: [ $( ] ifFalse: [ $[ ]);
		print: self left;
		nextPutAll: ', ';
		print: self right;
		nextPut: (self isRightOpen ifTrue: [ $) ] ifFalse: [ $] ])! !

!CartesianProduct methodsFor: 'printing' stamp: 'len 6/7/2016 00:50'!
printOn: aStream
	components do: [:each| aStream print: each] separatedBy: [aStream nextPut: Character times]! !

!EquivalenceClass methodsFor: 'printing' stamp: 'len 4/24/2016 04:37'!
printOn: aStream
	aStream nextPut: $[; print: self representative; nextPut: $]! !

!EquivalenceRelation methodsFor: 'printing' stamp: 'len 12/28/2016 12:27:26'!
printOn: aStream
	((self hasProperty: #name) or: [self hasProperty: #elements])
		ifTrue: [^ super printOn: aStream].
	aStream nextPut: $~! !

!Naturals methodsFor: 'printing' stamp: 'len 6/8/2016 21:05'!
printOn: aStream
	aStream nextPut: Character NN! !

!QuotientSet methodsFor: 'printing' stamp: 'len 4/25/2016 09:25'!
printOn: aStream
	aStream print: self relation domain; nextPut: $/; print: self relation
"	| domain |
	domain _ self relation domain.
	(domain printString allSatisfy: [:each|each isAlphaNumeric])
		ifTrue: [aStream print: domain]
		ifFalse: [aStream nextPut: $(; print: domain; nextPut: $)].
	aStream nextPut: $/; print: self relation"! !

!FreeAbelianSemigroup methodsFor: 'printing' stamp: 'len 5/13/2019 12:23:53'!
printOn: aStream
	self isTrivial ifTrue: [^ super printOn: aStream].
	aStream nextPut: $[.
	self generators do: [:each| aStream print: each] separatedBy: [aStream nextPut: $,].
	aStream nextPutAll: ']+'! !

!FreeSemigroup methodsFor: 'printing' stamp: 'len 5/13/2019 11:10:38'!
printOn: aStream
	self isTrivial ifTrue: [aStream nextPutAll: '{}'. ^ self].
	aStream nextPut: ${.
	self generators do: [:each| aStream print: each] separatedBy: [aStream nextPut: $,].
	aStream nextPutAll: '}+'! !

!FreeAbelianMonoid methodsFor: 'printing' stamp: 'len 5/13/2019 12:21:50'!
printOn: aStream
	self isTrivial ifTrue: [aStream nextPut: ${; print: self identity; nextPut: $}. ^ self].
	aStream nextPut: $[.
	self generators do: [:each| aStream print: each] separatedBy: [aStream nextPut: $,].
	aStream nextPutAll: ']*'! !

!FreeMonoid methodsFor: 'printing' stamp: 'len 5/13/2019 11:09:38'!
printOn: aStream
	self isTrivial ifTrue: [aStream nextPut: ${; print: self identity; nextPut: $}. ^ self].
	aStream nextPut: ${.
	self generators do: [:each| aStream print: each] separatedBy: [aStream nextPut: $,].
	aStream nextPutAll: '}*'! !

!Group methodsFor: 'printing' stamp: 'len 12/28/2016 12:27:40'!
printOn: aStream
	| generators |
	((self hasProperty: #name) or: [(generators _ self generators) isNil])
		ifTrue: [^ super printOn: aStream].
	"use the original printOn for wrapped objects:"
	self propertyAt: #elements ifPresent: [:elements| (elements isKindOf: Domain) ifTrue: [aStream print: elements. ^ self]].
	generators isEmpty
		ifTrue: [aStream nextPut: ${; print: self identity; nextPut: $}. ^ self].
	aStream nextPut: $<.
	generators do: [:each| aStream print: each] separatedBy: [aStream nextPutAll: '; '].
	aStream nextPut: $>! !

!AbelianGroup methodsFor: 'printing' stamp: 'len 5/14/2019 04:18:16'!
printOn: aStream
	self generators isEmpty
		ifTrue: [aStream nextPut: ${; print: self identity; nextPut: $}. ^ self].
	aStream nextPut: $<.
	self generators do: [:each| aStream print: each] separatedBy: [aStream nextPut: $,].
	aStream nextPutAll: ' | '.
	self relators do: [:each| aStream print: each] separatedBy: [aStream nextPut: $,].
	self relators isEmpty ifTrue: [aStream nextPut: Character emptySet].
	aStream nextPut: $>


"	| first |
	self isTrivial ifTrue: [aStream nextPut: ${; print: self identity; nextPut: $}. ^ self].
	first _ true.
	(RunArray newFrom: self orders) runsAndValuesDo: [:exponent :modulus|
		first ifFalse: [aStream nextPut: Character times].
		modulus = 0
			ifTrue: [aStream nextPut: $C]
			ifFalse:
				[aStream nextPut: $C; nextPutAll: modulus printString sub].
		exponent > 1 ifTrue: [aStream nextPutAll: exponent printString super].
		first _ false]"! !

!FreeAbelianGroup methodsFor: 'printing' stamp: 'len 5/13/2019 12:27:10'!
printOn: aStream
	self isTrivial ifTrue: [super printOn: aStream].
	aStream nextPut: $<.
	self generators do: [:each| aStream print: each] separatedBy: [aStream nextPut: $,].
	aStream nextPutAll: '>'! !

!DirectProductGroup methodsFor: 'printing' stamp: 'len 6/11/2016 21:02'!
printOn: aStream
	components do: [:each| aStream print: each] separatedBy: [aStream nextPut: Character times]! !

!FPGroup methodsFor: 'printing' stamp: 'len 5/14/2019 02:33:15'!
printOn: aStream
"	self isFree ifTrue: [aStream nextPutAll: 'F('; print: symbols; nextPut: $). ^ self]."
	self generators isEmpty
		ifTrue: [aStream nextPut: ${; print: self identity; nextPut: $}. ^ self].
	aStream nextPut: $<.
	self generators do: [:each| aStream print: each] separatedBy: [aStream nextPut: $,].
	aStream nextPutAll: ' | '.
	self relators do: [:each| aStream print: each] separatedBy: [aStream nextPut: $,].
	self relators isEmpty ifTrue: [aStream nextPut: Character emptySet].
	aStream nextPut: $>! !

!FreeGroup methodsFor: 'printing' stamp: 'len 5/13/2019 11:09:58'!
printOn: aStream
	self isTrivial ifTrue: [aStream nextPut: ${; print: self identity; nextPut: $}. ^ self].
	aStream nextPut: $<.
	self generators do: [:each| aStream print: each] separatedBy: [aStream nextPut: $,].
	aStream nextPutAll: '>'! !

!OppositeGroup methodsFor: 'printing' stamp: 'len 5/8/2019 13:52:38'!
printOn: aStream
	aStream print: opposite; nextPutAll: 'op' super! !

!QuotientGroup methodsFor: 'printing' stamp: 'len 2/28/2017 10:13:26'!
printOn: aStream
	(self base printString includes: $/)
		ifTrue: [aStream nextPut: $(; print: self base; nextPut: $)]
		ifFalse: [aStream print: self base].
	aStream nextPut: $/.
	(self relations printString includes: $/)
		ifTrue: [aStream nextPut: $(; print: self relations; nextPut: $)]
		ifFalse: [aStream print: self relations]
! !

!SemidirectProductGroup methodsFor: 'printing' stamp: 'len 4/21/2016 00:16'!
printOn: aStream
	aStream print: left; nextPutAll: ' X| '; print: right! !

!AlternatingGroup methodsFor: 'printing' stamp: 'len 1/31/2018 17:31:29'!
printOn: aStream
	aStream nextPutAll: 'Alt('; print: self space; nextPut: $)! !

!SymmetricGroup methodsFor: 'printing' stamp: 'len 4/30/2019 17:59:53'!
printOn: aStream
	self isStandard
		ifTrue: [aStream nextPutAll: 'S', self degree printText sub]
		ifFalse: [aStream nextPutAll: 'Sym('; print: self space; nextPut: $)]! !

!LinearGroup methodsFor: 'printing' stamp: 'len 9/25/2018 17:10:42'!
printOn: aStream
	self shortName isNil ifTrue: [^ super printOn: aStream].
	(self space isKindOf: TupleModule) ifTrue: [^ self printMatrixGroupOn: aStream].
	aStream nextPutAll: self shortName; nextPut: $(; print: self space; nextPut: $)! !

!AffineGroup methodsFor: 'printing' stamp: 'len 11/10/2016 08:43'!
printOn: aStream
	self class == AffineGroup ifTrue: [aStream nextPutAll: 'Aff('; print: self linear; nextPut: $). ^ self].
	aStream nextPutAll: self shortName.
	aStream nextPut: $(; print: space; nextPut: $)! !

!UnitGroup methodsFor: 'printing' stamp: 'len 5/6/2019 02:41:14'!
printOn: aStream
	aStream print: self space; nextPutAll: Character times asString super ! !

!EllipticCurveGroup methodsFor: 'printing' stamp: 'len 11/10/2016 08:13'!
printOn: aStream
	aStream nextPutAll: 'E('; print: self scalars; nextPut: $)! !

!DirichletGroup methodsFor: 'as yet unclassified' stamp: 'len 12/9/2016 15:50:16'!
printOn: aStream
	aStream nextPut: $(; print: ZZ; nextPut: $/; print: self modulus; nextPutAll: ')', '*' super! !

!Gamma0CongruenceSubgroup methodsFor: 'as yet unclassified' stamp: 'len 12/8/2016 19:36:12'!
printOn: aStream
	aStream nextPut: Character Gamma; nextPutAll: '0' sub; nextPut: $(; print: self level; nextPut: $)! !

!Gamma1CongruenceSubgroup methodsFor: 'as yet unclassified' stamp: 'len 12/8/2016 19:36:23'!
printOn: aStream
	aStream nextPut: Character Gamma; nextPutAll: '1' sub; nextPut: $(; print: self level; nextPut: $)! !

!PrincipalCongruenceSubgroup methodsFor: 'as yet unclassified' stamp: 'len 12/15/2016 21:36:37'!
printOn: aStream
	aStream nextPut: Character Gamma.
	self level ~= 1 ifTrue: [aStream nextPut: $(; print: self level; nextPut: $)]! !

!ModularGroup methodsFor: 'as yet unclassified' stamp: 'len 12/8/2016 19:36:34'!
printOn: aStream
	aStream nextPut: Character Gamma! !

!AdicIntegerRing methodsFor: 'printing' stamp: 'len 6/6/2019 12:07:53'!
printOn: aStream
	aStream print: ZZ; nextPutAll: self p printString sub! !

!PowerSeriesRing methodsFor: 'printing' stamp: 'len 9/22/2018 19:20:17'!
printOn: aStream
	aStream print: self scalars; nextPutAll: '[['.
	self printIndeterminatesOn: aStream.
	aStream nextPutAll: ']]'! !

!LocalizationRing methodsFor: 'printing' stamp: 'len 12/18/2016 21:05:06'!
printOn: aStream
	aStream print: self integers; nextPutAll: self maximalIdeal printString sub! !

!FractionRing methodsFor: 'printing' stamp: 'len 10/20/2016 11:00'!
printOn: aStream
	aStream nextPutAll: 'Frac('; print: self integers; nextPut: $)! !

!AdicRationalField methodsFor: 'as yet unclassified' stamp: 'len 12/17/2016 22:21:17'!
printOn: aStream
	aStream print: QQ; nextPutAll: self p printString sub! !

!RationalField methodsFor: 'printing' stamp: 'len 6/8/2016 21:05'!
printOn: aStream
	aStream nextPut: Character QQ! !

!RationalFunctionField methodsFor: 'printing' stamp: 'len 10/28/2016 10:36'!
printOn: aStream
	aStream print: self scalars.
	aStream nextPut: $(.
	self integers printIndeterminatesOn: aStream.
	aStream nextPut: $)! !

!LaurentSeriesRing methodsFor: 'printing' stamp: 'len 9/22/2018 19:20:53'!
printOn: aStream
	aStream print: self scalars; nextPutAll: '(('.
	self integers printIndeterminatesOn: aStream.
	aStream nextPutAll: '))'! !

!ValuationRing methodsFor: 'as yet unclassified' stamp: 'len 6/3/2019 05:23:32'!
printOn: aStream
	aStream nextPutAll: 'V('; print: self fractions; nextPut: $,; print: self p; nextPut: $)! !

!OppositeRing methodsFor: 'printing' stamp: 'len 5/8/2019 14:52:19'!
printOn: aStream
	aStream print: opposite; nextPutAll: 'op' super! !

!ProductRing methodsFor: 'printing' stamp: 'len 8/29/2016 04:12'!
printOn: aStream
	components do: [:each| aStream print: each] separatedBy: [aStream nextPut: Character times]! !

!QuotientRing methodsFor: 'printing' stamp: 'len 2/27/2017 20:53:15'!
printOn: aStream
	(self base printString includes: $/)
		ifTrue: [aStream nextPut: $(; print: self base; nextPut: $)]
		ifFalse: [aStream print: self base].
	aStream nextPut: $/; print: self relations! !

!ModularIntegerRing methodsFor: 'printing' stamp: 'len 12/8/2016 10:50:20'!
printOn: aStream
	aStream print: self base; nextPut: $/; print: self modulus; print: self base! !

!PrimePowerRing methodsFor: 'printing' stamp: 'len 5/21/2018 04:31:00'!
printOn: aStream
	aStream print: self base; nextPut: $/; print: self p; nextPutAll: self exponent printString super; print: self base! !

!PrimeField methodsFor: 'printing' stamp: 'len 12/17/2016 23:05:18'!
printOn: aStream
	aStream nextPut: Character FF; nextPutAll: self modulus printString sub! !

!AlgebraicExtensionRing methodsFor: 'printing' stamp: 'len 12/28/2016 12:27:58'!
printOn: aStream
	(self hasProperty: #name) ifTrue: [^ super printOn: aStream].
	aStream print: self scalars; nextPut: $(; print: self polynomial; nextPut: $)! !

!GaloisRing methodsFor: 'printing' stamp: 'len 5/21/2018 07:20:18'!
printOn: aStream
	aStream nextPutAll: 'GR('; print: self scalars p; nextPutAll: self scalars exponent printString super; nextPut: $,; print: self degree; nextPut: $)! !

!GaloisField methodsFor: 'printing' stamp: 'len 12/17/2016 23:04:02'!
printOn: aStream
	aStream nextPut: Character FF; nextPutAll: self size printString sub
"	aStream nextPutAll: 'GF('; print: self characteristic; nextPutAll: self degree printString super; nextPut: $)"! !

!QuasiGaloisRing methodsFor: 'printing' stamp: 'len 5/9/2019 09:53:57'!
printOn: aStream
	aStream nextPutAll: 'A('; print: self scalars p; nextPutAll: self scalars degree printString super; nextPut: $,; print: self degree; nextPut: $)! !

!NumberField methodsFor: 'printing' stamp: 'len 2/22/2017 08:49:34'!
printOn: aStream
	"aStream print: self scalars; nextPut: $(; print: self adjoint; nextPut: $)"
	aStream print: self scalars; nextPut: $(; print: self polynomial; nextPut: $)! !

!CyclotomicField methodsFor: 'printing' stamp: 'len 12/11/2016 13:46:42'!
printOn: aStream
	aStream print: self scalars; nextPut: $(; nextPut: Character zeta; nextPutAll: self order printString sub; nextPut: $)! !

!QuadraticField methodsFor: 'printing' stamp: 'len 12/23/2016 16:31:16'!
printOn: aStream
	aStream print: self scalars; nextPut: $(; print: self x; nextPut: $)! !

!RationalIntegerRing methodsFor: 'printing' stamp: 'len 12/8/2016 12:38:27'!
printOn: aStream
	aStream nextPut: Character ZZ! !

!ComplexField methodsFor: 'printing' stamp: 'len 8/5/2016 21:35'!
printOn: aStream
	aStream nextPut: Character CC! !

!RealField methodsFor: 'printing' stamp: 'len 8/5/2016 21:35'!
printOn: aStream
	aStream nextPut: Character RR! !

!NumberRing methodsFor: 'printing' stamp: 'len 1/18/2018 19:23:29'!
printOn: aStream
	aStream nextPut: Character ZZ; nextPutAll: self ambient printString sub
"	aStream nextPutAll: 'O' italic; nextPut: $(; print: field; nextPut: $)"! !

!CyclotomicRing methodsFor: 'printing' stamp: 'len 1/18/2018 19:23:55'!
printOn: aStream
	aStream print: ZZ; nextPut: $[; print: self ambient x; nextPut: $]! !

!QuadraticRing methodsFor: 'printing' stamp: 'len 1/18/2018 19:26:15'!
printOn: aStream
	| K a |
	K _ self ambient.
	a _ K d \\ 4 = 1 ifTrue: [K x + K one / (K one * 2)] ifFalse: [K x].
	aStream print: ZZ; nextPut: $[; print: a; nextPut: $]! !

!MatrixRing methodsFor: 'printing' stamp: 'len 1/5/2017 08:08:47'!
printOn: aStream
	aStream print: self asModule! !

!PolynomialRing methodsFor: 'printing' stamp: 'len 2/12/2017 06:49:02'!
printOn: aStream
	aStream print: self scalars; nextPut: $[.
	self printIndeterminatesOn: aStream.
	aStream nextPut: $].
	self ordering isLocal ifTrue: [aStream nextPutAll: self maximalIdeal printText sub]! !

!Module methodsFor: 'printing' stamp: 'len 4/29/2019 04:57:07'!
printOn: aStream
	self isTrivial ifTrue: [aStream nextPutAll: '{0}'. ^ self].
	aStream nextPut: $<.
	self generators do: [:each| aStream print: each] separatedBy: [aStream nextPutAll: '; '].
	aStream nextPut: $>.
	self scalars ~= self ambient scalars ifTrue: [aStream nextPutAll: self scalars printText sub]! !

!Ideal methodsFor: 'printing' stamp: 'len 1/15/2018 18:51:39'!
printOn: aStream
	self isZero ifTrue: [aStream nextPut: ${; print: self scalars zero; nextPut: $}. ^ self].
	aStream nextPut: $<.
	(self generators asSortedCollection: [:a :b| a printString <= b printString])
		do: [:each| aStream print: each] separatedBy: [aStream nextPutAll: ', '].
	aStream nextPut: $>! !

!QuotientIdeal methodsFor: 'printing' stamp: 'len 5/21/2018 22:08:23'!
printOn: aStream
	self isZero ifTrue: [aStream nextPut: ${; print: self scalars zero; nextPut: $}. ^ self].
	(self scalars isKindOf: ModularIntegerRing)
		ifTrue: [aStream print: self generator; print: self scalars. ^ self].
	super printOn: aStream! !

!RationalIntegerIdeal methodsFor: 'printing' stamp: 'len 5/21/2018 22:05:31'!
printOn: aStream
	self isZero ifTrue: [aStream nextPutAll: '{0}'. ^ self].
	aStream print: self generator; nextPut: Character ZZ! !

!FractionalIdeal methodsFor: 'printing' stamp: 'len 5/5/2018 05:12:32'!
printOn: aStream
	aStream nextPut: $<.
	(self generators asSortedCollection: [:a :b| a printString <= b printString])
		do: [:each| aStream print: each] separatedBy: [aStream nextPutAll: ', '].
	aStream nextPut: $>! !

!HomModule methodsFor: 'printing' stamp: 'len 10/2/2018 01:19:34'!
printOn: aStream
	self isEndomorphisms
		ifTrue: [aStream nextPutAll: 'End'; nextPutAll: self scalars printText sub; nextPut: $(; print: self domain; nextPut: $)]
		ifFalse: [aStream nextPutAll: 'Hom'; nextPutAll: self scalars printText sub; nextPut: $(; print: self domain; nextPut: $,; print: self codomain; nextPut: $)]! !

!QuotientModule methodsFor: 'printing' stamp: 'len 1/24/2018 21:54:55'!
printOn: aStream
	aStream print: self base; nextPut: $/; print: self relations! !

!DirectSumModule methodsFor: 'printing' stamp: 'len 10/2/2018 00:52:00'!
printOn: aStream
	components do: [:each| aStream print: each] separatedBy: [aStream nextPut: Character oplus]! !

!FreeHomModule methodsFor: 'printing' stamp: 'len 4/28/2019 10:34:39'!
printOn: aStream
	self isTrivial ifTrue: [^ super printOn: aStream].
	self isEndomorphisms
		ifTrue: [aStream nextPutAll: 'End'; nextPutAll: self scalars printText sub; nextPut: $(; print: self domain; nextPut: $)]
		ifFalse: [aStream nextPutAll: 'Hom'; nextPutAll: self scalars printText sub; nextPut: $(; print: self domain; nextPut: $,; print: self codomain; nextPut: $)]! !

!QuotientSpace methodsFor: 'printing' stamp: 'len 1/24/2018 21:54:35'!
printOn: aStream
	aStream print: self base; nextPut: $/; print: self relations! !

!RingModule methodsFor: 'printing' stamp: 'len 4/21/2016 00:04'!
printOn: aStream
	aStream print: scalars! !

!TupleModule methodsFor: 'printing' stamp: 'len 4/28/2019 10:34:05'!
printOn: aStream
	self isTrivial ifTrue: [^ super printOn: aStream].
	aStream print: self scalars.
	aStream isText
		ifTrue: [aStream nextPutAll: self rank printString super]
		ifFalse: [aStream nextPutAll: '^'; print: self rank]! !

!MatrixModule methodsFor: 'printing' stamp: 'len 4/5/2018 15:25:06'!
printOn: aStream
	aStream print: self scalars.
	aStream isText
		ifTrue: [aStream nextPutAll: (height printString, Character times asString, width printString) super]
		ifFalse: [aStream nextPutAll: '^('; print: height; nextPut: Character times; print: width; nextPut: $)]! !

!BilinearForms methodsFor: 'printing' stamp: 'len 4/21/2016 00:01'!
printOn: aStream
	aStream nextPutAll: 'Bil('; print: vectorSpace; nextPut: $)! !

!TensorProductModule methodsFor: 'printing' stamp: 'len 6/3/2018 20:17:20'!
printOn: aStream
	components do: [:each| aStream print: each] separatedBy: [aStream nextPut: Character otimes]! !

!PolynomialFiltrationModule methodsFor: 'printing' stamp: 'len 6/7/2016 21:44'!
printOn: aStream
	aStream print: polynomials; nextPutAll: ('<', (degree+1) printString) sub! !

!PolynomialGradingModule methodsFor: 'printing' stamp: 'len 7/6/2016 08:39'!
printOn: aStream
	aStream print: polynomials; nextPutAll: degree printString sub! !

!ModularFormSpace methodsFor: 'as yet unclassified' stamp: 'len 12/7/2016 12:09:24'!
printOn: aStream
	aStream nextPut: $M; nextPutAll: weight printString sub; nextPut: $(; print: group; nextPut: $)! !

!ExteriorPower methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 23:52'!
printOn: aStream
	aStream nextPutAll: '/\'; nextPutAll: (aStream isText ifTrue: [self degree printString super] ifFalse: ['^', self degree printString]); nextPut: $(; print: self space; nextPut: $)! !

!AffineSubspace methodsFor: 'printing' stamp: 'len 4/19/2019 07:13:41'!
printOn: aStream
"	self isEmpty ifTrue: [aStream nextPut: Character emptySet. ^ self].
	self dimension = 0 ifTrue: [aStream nextPut: ${; print: representative; nextPut: $}. ^ self].
	aStream nextPut: $[.
	representative isTuple ifTrue: [representative printCoefficientsOn: aStream] ifFalse: [aStream print: representative].
	aStream nextPut: $]

alternative:"
	direction isAmbient ifTrue: [aStream print: direction. ^ self].
	self isEmpty ifTrue: [aStream nextPut: Character emptySet. ^ self].
	self dimension = 0 ifTrue: [aStream nextPut: ${; print: representative; nextPut: $}. ^ self].
	aStream print: representative; nextPutAll: ' + '; print: direction! !

!Grassmannian methodsFor: 'printing' stamp: 'len 11/10/2016 08:45'!
printOn: aStream
	aStream nextPutAll: 'Gr('; print: rank; nextPut: $,; print: space; nextPut: $)! !

!AffineScheme methodsFor: 'printing' stamp: 'len 1/13/2017 16:02:35'!
printOn: aStream
	aStream nextPutAll: 'Spec '; print: self coordinateRing! !

!AffineSpace methodsFor: 'printing' stamp: 'len 1/1/2017 21:29:19'!
printOn: aStream
	aStream print: self scalars; nextPutAll: self rank printString super! !

!ProductAffineSpace methodsFor: 'printing' stamp: 'len 2/10/2017 08:48:52'!
printOn: aStream
	self components do: [:each| aStream print: each] separatedBy: [aStream nextPut: Character times]! !

!ProjectiveVariety methodsFor: 'printing' stamp: 'len 10/20/2016 15:27'!
printOn: aStream
		aStream nextPutAll: 'Proj '; print: self coordinateRing! !

!ProjectivePlaneCurve methodsFor: 'printing' stamp: 'len 12/25/2016 11:57:45'!
printOn: aStream
	aStream print: self polynomial; nextPutAll: ' = 0'! !

!EllipticCurve methodsFor: 'printing' stamp: 'len 12/11/2016 20:43:15'!
printOn: aStream
	aStream "nextPutAll: 'E : ';" print: self equation! !

!ProjectiveSpace methodsFor: 'printing' stamp: 'len 1/1/2017 21:29:13'!
printOn: aStream
	aStream nextPut: Character PP; nextPutAll: (self rank - 1) printString super; print: self scalars! !

!ProductProjectiveSpace methodsFor: 'printing' stamp: 'len 2/10/2017 08:36:41'!
printOn: aStream
	self components do: [:each| aStream print: each] separatedBy: [aStream nextPut: Character times]! !

!LinearCode methodsFor: 'printing' stamp: 'len 6/7/2016 21:45'!
printOn: aStream
	aStream nextPut: $[; print: self length; nextPut: $,; print: self rank; nextPut: $,; print: self minimumDistance; nextPut: $].
	aStream isText
		ifTrue: [aStream nextPutAll: self ambient scalars size printString sub]
		ifFalse: [aStream nextPut: $-; print: self ambient scalars size]! !

!CellComplex methodsFor: 'printing' stamp: 'len 2/18/2017 21:21:19'!
printOn: aStream
	aStream nextPut: $<.
	self do: [:each| aStream print: each] separatedBy: [aStream nextPut: $,].
	aStream nextPut: $>! !

!SimplicialComplex methodsFor: 'printing' stamp: 'len 2/18/2017 21:21:41'!
printOn: aStream
	aStream nextPut: $<.
	self facets do: [:each| aStream print: each] separatedBy: [aStream nextPut: $,].
	aStream nextPut: $>! !

!UpperHalfPlane methodsFor: 'printing' stamp: 'len 12/8/2016 19:10:30'!
printOn: aStream
	aStream nextPut: Character HH! !

!FreeAlgebra methodsFor: 'printing' stamp: 'len 1/10/2018 12:24:54'!
printOn: aStream
	aStream print: scalars.
	aStream nextPut: $<.
	self indeterminates
		do: [:i| aStream print: (self x: i)]
		separatedBy: [aStream nextPut: $,].
	aStream nextPut: $>! !

!GroupAlgebra methodsFor: 'printing' stamp: 'len 8/7/2016 08:38'!
printOn: aStream
	aStream print: self scalars; nextPut: $[; print: self group; nextPut: $]! !

!Morphism methodsFor: 'printing' stamp: 'len 11/16/2016 18:08'!
name
	^ String streamContents: [:aStream| super printOn: aStream]! !

!Morphism methodsFor: 'printing' stamp: 'len 11/16/2016 18:08'!
printOn: aStream
	aStream nextPutAll: self name; nextPut: $:.
	self arrowPrintOn: aStream! !

!Function methodsFor: 'printing' stamp: 'len 12/28/2016 11:11:53'!
name
	^ self propertyAt: #name ifAbsent: [super name]! !

!Function methodsFor: 'printing' stamp: 'len 11/16/2016 18:12'!
printOn: aStream
	(self expression isBlock not and: [(self expression isKindOf: Function) not])
		ifTrue: [aStream print: self expression]
		ifFalse: [super printOn: aStream]! !

!AbelianGroupMap methodsFor: 'as yet unclassified' stamp: 'len 4/22/2019 14:50:38'!
printOn: aStream
	aStream print: ZZ^domain generators size => (ZZ^codomain generators size) !! matrix! !

!PolynomialRingMap methodsFor: 'printing' stamp: 'len 1/11/2017 07:55:38'!
printOn: aStream
"	self isIdentity ifTrue: [aStream nextPutAll: 'id'. ^ self].
	self negated isIdentity ifTrue: [aStream nextPutAll: '-id'. ^ self].
	self isZero ifTrue: [aStream nextPut: $0. ^ self].
"	aStream nextPut: $(.
	(1 to: self domain rank)
		do: [:i| aStream print: (self value: (self domain x: i))]
		separatedBy: [aStream nextPutAll: ', '].
	aStream nextPut: $)! !

!ModuleMap methodsFor: 'printing' stamp: 'len 11/2/2016 08:00'!
printOn: aStream
	self isIdentity ifTrue: [aStream nextPutAll: 'id'. ^ self].
	self negated isIdentity ifTrue: [aStream nextPutAll: '-id'. ^ self].
	self isZero ifTrue: [aStream nextPut: $0. ^ self].
	super printOn: aStream! !

!FreeModuleMap methodsFor: 'printing' stamp: 'len 4/19/2019 04:38:08'!
printOn: aStream
	| A B f |
	self isIdentity ifTrue: [aStream nextPutAll: 'id'. ^ self].
	self negated isIdentity ifTrue: [aStream nextPutAll: '-id'. ^ self].
	self isZero ifTrue: [aStream nextPut: $0. ^ self].
	self isLinearForm ifTrue: [aStream print: self asPolynomial. ^ self].
	"If the codomain is tuples, print the linear map as a tuple of linear forms:"
	(self codomain isKindOf: TupleModule) ifTrue:
		[aStream nextPut: $(.
		matrix rows
			do: [:each| aStream print: (self domain dual elementAt: each)]
			separatedBy: [aStream nextPutAll: ', '].
		aStream nextPut: $).
		^ self].
	"Print it as a linear combination of the generators of the codomain:"
	A _ self domain coordinateRing.
	B _ A polynomialsIn: self codomain names.
	f _ B zero.
	matrix rows
		withIndexDo: [:each :i| f _ (B x: i) * (self domain => self domain scalars asSelfModule elementAt: each) asPolynomial + f].
	aStream print: f! !

!AffineMap methodsFor: 'printing' stamp: 'len 1/3/2017 21:10:00'!
printOn: aStream
	self isIdentity ifTrue: [aStream nextPutAll: 'id'. ^ self].
	self negated isIdentity ifTrue: [aStream nextPutAll: '-id'. ^ self].
	"aStream print: linearPart; nextPutAll: ' + '; print: self translation"
	aStream print: self asRationalMap! !

!QuadraticForm methodsFor: 'printing' stamp: 'len 4/21/2016 00:22'!
printOn: aStream
	aStream print: self asPolynomial! !

!BilinearForm methodsFor: 'printing' stamp: 'len 3/18/2018 18:42:28'!
printOn: aStream
	aStream print: self asPolynomial! !

!RationalMap methodsFor: 'printing' stamp: 'len 12/28/2016 21:55:32'!
printOn: aStream 
	self codomain isProjective
		ifTrue:
			[aStream nextPut: $[.
			self representatives do: [:each| aStream print: each] separatedBy: [aStream nextPut: $:].
			aStream nextPut: $]]
		ifFalse:
			[aStream nextPut: $(.
			self representatives do: [:each| aStream print: each] separatedBy: [aStream nextPutAll: ', '].
			aStream nextPut: $)]! !

!LinearFractionalMap methodsFor: 'printing' stamp: 'len 12/9/2016 16:08:40'!
printOn: aStream
	| z denominator numerator |
	z _ (CC polynomialsIn: #(z)) x.
	c isZero ifTrue: [aStream print: z * a + b / d. ^ self].
	numerator _ z * a + b.
	(a = 0 or: [b = 0])
		ifTrue: [aStream print: numerator]
		ifFalse: [aStream nextPut: $(; print: numerator; nextPut: $)].
	aStream nextPut: $/.
	denominator _ z * c + d.
	(c = 0 or: [d = 0])
		ifTrue: [aStream print: denominator]
		ifFalse: [aStream nextPut: $(; print: denominator; nextPut: $)]! !

!Sequence methodsFor: 'operations' stamp: 'len 6/3/2019 17:29:54'!
>> anInteger
	^ self species to: self codomain evaluating: [:i| self at: i-anInteger ifAbsent: [self codomain zero]]! !

!Sequence methodsFor: 'printing' stamp: 'len 6/4/2019 05:30:08'!
printOn: aStream
	(1 to: self printLimit) do: [:i| aStream print: (self at: i)] separatedBy: [aStream nextPutAll:', ' ].
	aStream nextPutAll: '...'! !

!CFiniteSequence methodsFor: 'operations' stamp: 'len 6/1/2019 08:30:15'!
>> anInteger
	anInteger > 0 ifTrue: [^ super >> anInteger].
	^ self class to: self codomain evaluating: (super >> anInteger) maxOrder: self order squared! !

!SimplicialMap methodsFor: 'printing' stamp: 'len 2/20/2017 15:23:39'!
printOn: aStream
	self domain vertices do: [:each| aStream print: each -> (map at: each)] separatedBy: [aStream nextPutAll: ', ']! !

!EisensteinSeries methodsFor: 'as yet unclassified' stamp: 'len 12/6/2016 20:41:01'!
printOn: aStream
	aStream nextPutAll: 'G', weight printString sub! !

!AffinePoint methodsFor: 'printing' stamp: 'len 12/30/2016 14:37:32'!
printOn: aStream
	aStream print: self coordinates! !

!ProjectivePoint methodsFor: 'printing' stamp: 'len 2/10/2017 09:55:27'!
printOn: aStream
	aStream nextPut: $[.
	self printInsidesOn: aStream.
	aStream nextPut: $]! !

!ProjectiveLinePoint methodsFor: 'printing' stamp: 'len 5/2/2019 10:49:25'!
printOn: aStream
	self isInfinity
		ifTrue: [aStream nextPut: Character infinity]
		ifFalse: [self scalars isField ifTrue: [aStream print: self value] ifFalse: [super printOn: aStream]]! !

!EllipticCurvePoint methodsFor: 'printing' stamp: 'len 11/11/2016 05:21'!
printOn: aStream
	self isZero
		ifTrue: [aStream nextPutAll: 'O' italic]
		ifFalse: [aStream nextPut: $(; print: self x; nextPut: $,; print: self y; nextPut: $)]! !

!ProductProjectivePoint methodsFor: 'as yet unclassified' stamp: 'len 2/10/2017 09:55:12'!
printOn: aStream
	aStream nextPut: $[.
	self components do: [:each| each printInsidesOn: aStream] separatedBy: [aStream nextPutAll: ', '].
	aStream nextPut: $]! !

!Monomial methodsFor: 'copying' stamp: 'len 11/21/2016 11:07:43'!
postCopy
	exponents _ exponents copy.
	degree _ nil! !

!Monomial methodsFor: 'printing' stamp: 'len 2/27/2017 07:41:34'!
printOn: aStream
	self degree = 0 ifTrue: [aStream print: 1. ^ self].
	(self ordering indeterminates select: [:i| (self at: i) ~= 0])
		do: [:i|
			| x |
			x _ self parent names ifNil: [i] ifNotNil: [:names| names at: i ifAbsent: [i]].
			self printIndeterminate: x on: aStream.
			self printExponent: (self at: i) on: aStream]! !

!Word methodsFor: 'printing' stamp: 'len 5/13/2019 13:40:18'!
printOn: aStream
	self isEmpty ifTrue: [aStream nextPut: Character epsilon. ^ self].
	self do: [:each :exp|
		exp = 0 ifFalse:
			[| x |
			x _ self parent names ifNil: [each] ifNotNil: [:names| names at: each ifAbsent: [each]].
			self printLetter: x on: aStream.
			self printExponent: exp on: aStream]]! !

!Coset methodsFor: 'printing' stamp: 'len 12/6/2016 09:12:39'!
printOn: aStream
	aStream nextPut: $[; print: representative; nextPut: $]
"	| op |
	op _ subgroup operation name ifNil: ['*'].
	aStream print: subgroup; space; nextPutAll: op; space; print: representative"! !

!OppositeGroupElement methodsFor: 'printing' stamp: 'len 5/9/2019 08:05:24'!
printOn: aStream
	opposite printOn: aStream! !

!SemidirectProductElement methodsFor: 'printing' stamp: 'len 2/12/2016 06:10'!
printOn: aStream
	aStream nextPut: $(; print: left; nextPutAll: ', '; print: right; nextPut: $)! !

!Permutation methodsFor: 'printing' stamp: 'len 5/1/2019 02:47:04'!
printOn: aStream
	"Print a representation of the receiver on the stream aStream."

	self isIdentity ifTrue: [aStream nextPutAll: 'id'. ^ self].
	self cyclesDo: [:cycle|
		aStream nextPut: $(.
		cycle do: [:i| | element |
			element _ parent indexToSpace at: i.
			element isSymbol
				ifTrue: [aStream nextPutAll: element]
				ifFalse: [aStream print: element]] separatedBy: [aStream space].
		aStream nextPut: $)]! !

!OppositeRingElement methodsFor: 'printing' stamp: 'len 5/8/2019 14:42:55'!
printOn: aStream
	opposite printOn: aStream! !

!ProductRingElement methodsFor: 'printing' stamp: 'len 5/22/2018 16:12:57'!
printOn: aStream
	aStream print: components! !

!Ratio methodsFor: 'printing' stamp: 'len 4/7/2018 00:39:37'!
printOn: aStream
	| string |
	denominator = denominator one ifTrue: [aStream print: numerator. ^ self].
	aStream print: numerator; nextPutAll: ' / '.
	string _ denominator printString.
	((string includes: $+) or: [string includes: $-])
		ifTrue: [aStream nextPut: $(; print: denominator; nextPut: $)]
		ifFalse: [aStream print: denominator]! !

!RationalFunction methodsFor: 'printing' stamp: 'len 4/7/2018 01:08:35'!
printOn: aStream
	denominator = denominator one ifTrue: [aStream print: numerator. ^ self].
	numerator terms size > 1
		ifTrue: [aStream nextPut: $(; print: numerator; nextPut: $)]
		ifFalse: [aStream print: numerator].
	aStream nextPutAll: ' / '.
	denominator terms size > 1
		ifTrue: [aStream nextPut: $(; print: denominator; nextPut: $)]
		ifFalse: [aStream print: denominator]! !

!Residue methodsFor: 'printing' stamp: 'len 12/21/2015 22:51'!
printOn: aStream
	aStream print: representative"; nextPutAll: ' mod '; print: ideal"! !

!ModularInteger methodsFor: 'printing' stamp: 'len 3/29/2016 20:49'!
printOn: aStream
	aStream print: representative! !

!AdicInteger methodsFor: 'accessing' stamp: 'len 6/3/2019 17:28:33'!
>> anInteger
	"Multiply the receiver by p^anInteger shifting the digits by anInteger places."
	^ parent digits: digits >> anInteger! !

!AdicInteger methodsFor: 'printing' stamp: 'len 6/2/2019 10:09:25'!
printOn: aStream
	self printOn: aStream withPowersShiftedBy: 0! !

!AdicNumber methodsFor: 'printing' stamp: 'len 6/3/2019 18:28:16'!
printOn: aStream
	unit printOn: aStream withPowersShiftedBy: valuation negated! !

!Polynomial methodsFor: 'printing' stamp: 'len 5/30/2019 16:13:48'!
printOn: aStream
	| monomials leadingMonomial c |
	(self scalars isKindOf: ModularIntegerRing)
		ifTrue: [self lift printOn: aStream. ^ self].
	self isConstant ifTrue: [aStream print: self leadingCoefficient. ^ self].
	monomials _ self monomials asSortedCollection reversed.
	c _ self at: (leadingMonomial _ monomials first).
	(c printString first = $- or: [(c isKindOf: Number) and: [c negative]])
		ifTrue: [c _ c negated. aStream nextPut: $-].
	(c ~= parent scalars one or: [leadingMonomial degree = 0]) ifTrue: [self printCoefficient: c on: aStream].
	leadingMonomial degree > 0 ifTrue: [aStream print: leadingMonomial].
	monomials allButFirst do: [:m|
		c _ self at: m.
		(c printString first = $- or: [(c isKindOf: Number) and: [c negative]])
			ifTrue: [aStream nextPutAll: ' - '. c _ c negated]
			ifFalse: [aStream nextPutAll: ' + '].
		(c ~= parent scalars one or: [m degree = 0]) ifTrue: [self printCoefficient: c on: aStream].
		m degree > 0 ifTrue: [aStream print: m]]! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 7/9/2016 03:05'!
>> anInteger
	^ self << anInteger negated! !

!PowerSeries methodsFor: 'printing' stamp: 'len 6/6/2019 13:22:39'!
printOn: aStream
	| P f n |
	n _ coefficients printLimit.
	P _ parent base.
	f _ (P coefficients: (coefficients first: n)) orderedBy: #llex.
	aStream print: f; nextPutAll: ' + ', 'O' italic, '('; print: P x ^ (n+1); nextPut: $)! !

!Sum methodsFor: 'copying' stamp: 'len 11/18/2016 17:34:33'!
postCopy
	coefficients _ coefficients copy! !

!Sum methodsFor: 'printing' stamp: 'len 1/10/2018 21:04:41'!
printOn: aStream
	| elements c |
	self isZero ifTrue: [aStream nextPutAll: '0'. ^ self].
	elements _ self keys asSortedCollection: [:a :b| a printString <= b printString].
	c _ self at: elements first.
	c printString first = $-
		ifTrue: [c _ c negated. aStream nextPut: $-].
	c ~= self scalars one ifTrue: [self printCoefficient: c on: aStream].
	self printLiteral: elements first on: aStream.
	elements allButFirst do: [:each|
		c _ self at: each.
		c printString first = $-
			ifTrue: [aStream nextPutAll: ' - '. c _ c negated]
			ifFalse: [aStream nextPutAll: ' + '].
		c ~= c one ifTrue: [self printCoefficient: c on: aStream].
		self printLiteral: each on: aStream]! !

!Tuple methodsFor: 'operations' stamp: 'len 3/29/2016 19:02'!
>> anInteger
	^ self shift: anInteger! !

!Tuple methodsFor: 'printing' stamp: 'len 5/30/2019 16:14:55'!
printOn: aStream
	aStream nextPut: $(.
	self printCoefficientsOn: aStream.
	aStream nextPut: $)! !

!BitTuple methodsFor: 'printing' stamp: 'len 3/28/2016 04:52'!
printOn: aStream
	1 to: self size do: [:i| aStream print: (self at: i)]! !

!ModularTuple methodsFor: 'printing' stamp: 'len 12/1/2016 16:40:08'!
printOn: aStream
	self modulus > 16 ifTrue: [^ super printOn: aStream].
	1 to: self size do: [:i| (representatives at: i) printOn: aStream base: 16]! !

!Matrix methodsFor: 'printing' stamp: 'len 5/16/2019 00:13:05'!
printOn: aStream
	| lengths string pad |
	self isEmpty ifTrue: [aStream nextPutAll: '[]'. ^ self].
	self scalars size = 2 ifTrue: [^ self printBitsOn: aStream].
	lengths _ (1 to: self width) collect: [:each| 0].
	self rows do: [:each|
		1 to: each size do: [:i|
			lengths at: i put: ((lengths at: i) max: (each at: i) printText size)]].
	aStream nextPut: $[.
	self rows do: [:each|
		1 to: each size - 1 do: [:i|
			string _ (each at: i) printText.
			pad _ (lengths at: i) - string size.
			pad timesRepeat: [aStream space].
			aStream nextPutAll: string.
			pad + 1 timesRepeat: [aStream space]].
		string _ (each at: each size) printText.
		pad _ (lengths at: each size) - string size.
		pad timesRepeat: [aStream space].
		aStream nextPutAll: string.
		pad timesRepeat: [aStream space]]
			separatedBy: [aStream nextPut: $]; lf; nextPutAll: ' ['].
	aStream nextPut: $]! !

!MonomialOrdering methodsFor: 'printing' stamp: 'len 2/26/2017 09:25:36'!
printOn: aStream
	| M |
	self type isNil
		ifTrue: [super printOn: aStream]
		ifFalse: [aStream nextPutAll: self type].
	M _ FreeAbelianMonoid new: indeterminates max.
	aStream nextPut: $[.
	self indeterminates do: [:i| aStream print: (M x: i)] separatedBy: [aStream nextPut: $,].
	aStream nextPut: $]! !

!BlockMonomialOrdering methodsFor: 'printing' stamp: 'len 1/28/2017 10:29:04'!
printOn: aStream
	blocks do: [:each| aStream print: each] separatedBy: [aStream space; nextPut: Character times; space]! !

!WeightedMonomialOrdering methodsFor: 'printing' stamp: 'len 7/4/2016 06:26'!
printOn: aStream
	super printOn: aStream.
	aStream space.
	self weights do: [:each| aStream print: each] separatedBy: [aStream space]! !

!ComplexAlgebraicNumber methodsFor: 'printing' stamp: 'len 1/11/2016 06:44'!
printOn: aStream
	self printOn: aStream base: 10! !

!ChainComplex methodsFor: 'accessing' stamp: 'len 5/14/2019 16:44:34'!
>> n
	"Answer the complex with degrees shifted by n."
	^ self class differentials: differentials * (-1^n) degree: degree + n! !

!ChainComplex methodsFor: 'printing' stamp: 'len 5/14/2019 16:40:10'!
printOn: aStream
	aStream print: differentials first domain.
	differentials do: [:each| aStream nextPutAll: '  '; print: each codomain].! !

!ModuleMonomial methodsFor: 'printing' stamp: 'len 1/5/2018 16:01:39'!
printOn: aStream
	aStream print: monomial; nextPutAll: Character epsilon asText, position printString sub! !

!ModuleMonomialOrdering methodsFor: 'ordering' stamp: 'len 1/5/2018 11:15:24'!
printOn: aStream
	self type isNil
		ifTrue: [super printOn: aStream]
		ifFalse: [aStream nextPutAll: self type]! !

!MultivariatePolynomialDivision methodsFor: 'printing' stamp: 'len 1/24/98 12:49'!
printOn: aStream
	"Print a representation of the receiver on the stream aStream."

	aStream print: self dividend; nextPutAll: ' = '.
	(1 to: self divisors size) do: [ :each |
		aStream
			nextPut: $(; print: (self quotients at: each); nextPut: $);
			nextPut: $(; print: (self divisors at: each); nextPut: $);
			nextPutAll: ' + '].
	aStream print: self remainder! !

!PolynomialDivision methodsFor: 'printing' stamp: 'len 1/24/98 12:43'!
printOn: aStream
	"Print a representation of the receiver on the stream aStream."

	aStream
		print: self dividend;
		nextPutAll: ' = (';
		print: self quotient;
		nextPutAll: ')(';
		print: self divisor;
		nextPutAll: ') + ';
		print: self remainder! !

!PolynomialPseudoDivision methodsFor: 'printing' stamp: 'len 7/8/2016 05:47'!
printOn: aStream
	"Print a representation of the receiver on the stream aStream."

	aStream
		print: (self divisor leadingCoefficient ^ self delta);
		nextPut: $(;
		print: self dividend;
		nextPutAll: ') = (';
		print: self quotient;
		nextPutAll: ')(';
		print: self divisor;
		nextPutAll: ') + ';
		print: self remainder! !

!ExtendedEuclid methodsFor: 'printing' stamp: 'len 4/18/2018 06:23:18'!
printOn: aStream
	(1 to: elements size)
		do: [:i| aStream print: (elements at: i); nextPut: $*; print: (self bezout at: i)]
		separatedBy: [aStream nextPutAll: ' + '].
	aStream nextPutAll: ' = '; print: self gcd.
	self verify ifFalse: [aStream nextPutAll: ' (broken)'].
	self verifyMinimal ifFalse: [aStream nextPutAll: ' (not minimal)']! !

!DirichletSeries methodsFor: 'printing' stamp: 'len 6/4/2019 05:32:31'!
printOn: aStream
	| c n first |
	first _ true.
	1 to: coefficients printLimit do: [:i|
		c _ coefficients at: i.
		c isZero
			ifFalse:
				[n _ i.
				c printString first = $-
					ifTrue: [first ifFalse: [aStream nextPutAll: ' - '].
								c _ c negated]
					ifFalse: [first ifFalse: [aStream nextPutAll: ' + ']].
				c printOn: aStream. first _ false.
				n > 1 ifTrue: [aStream nextPut: $/; print: n; nextPutAll: 'x' super]]].
	aStream nextPutAll: ' + ...'! !

!GraphNode methodsFor: 'printing' stamp: 'len 2/14/2003 23:38'!
printOn: aStream
	aStream nextPut: $[; print: value; nextPut: $]! !

!YoungDiagram methodsFor: 'as yet unclassified' stamp: 'len 1/17/2017 09:06:37'!
printOn: aStream
	self shape do: [:k|
		aStream nextPut: $[.
		(1 to: k) do: [:ignore| aStream space] separatedBy: [aStream nextPut: $|].
		aStream nextPut: $]] separatedBy: [aStream lf; space]! !

!WeierstrassEquation methodsFor: 'printing' stamp: 'len 2/12/2017 06:05:00'!
printOn: aStream
	| P x y |
	P _ self scalars polynomialsIn: #(x y) ordering: (MonomialOrdering glex: #(2 1)).
	x _ P x.
	y _ P y.
	aStream print: y^2 + (x*y * self a1) + (y * self a3).
	aStream
		nextPutAll: ' = ';
		print: (x^3) + (x^2 * self a2) + (x * self a4) + self a6! !

!FareySymbol methodsFor: 'as yet unclassified' stamp: 'len 12/20/2016 21:30:43'!
printOn: aStream
	| n |
	n _ self size.
	aStream print: Infinity negative.
	1 to: n do: [:i|
		aStream nextPutAll: ' (', (self pairingAt: i) asString, ') '; print: (self numeratorAt: i); nextPut: $/; print: (self denominatorAt: i)].
	aStream nextPutAll: ' (', (self pairingAt: n+1) asString, ') '; print: Infinity positive! !

!AdicIntegerResidue methodsFor: 'as yet unclassified' stamp: 'len 6/1/2019 16:24:27'!
printOn: aStream
	((ZZ polynomialsIn: {(' ', self p printString) italic} ordering: #llex) coefficients: self digits) printOn: aStream! !

!Pixel methodsFor: 'as yet unclassified' stamp: 'len 2/13/2016 17:45'!
printOn: aStream
	aStream nextPut: $[; print: row; nextPut: $,; print: column; nextPut: $]! !

!Quaternion methodsFor: 'printing' stamp: 'len 11/19/2015 19:36'!
printOn: aStream
	"Print a representation of the receiver on the stream aStream."

	| something number |
	self isZero ifTrue: [aStream print: 0. ^ self].
	something _ false.
	a isZero ifFalse: [aStream print: a. something _ true].
	b isZero ifFalse: [number _ b.
						something
							ifTrue: [aStream nextPutAll: (number positive
								ifTrue: [' + ']
								ifFalse: [number _ number negated. ' - '])]
							ifFalse: [number negative
								ifTrue: [aStream nextPut: $-.
										number _ number negated]].
						number = number one ifFalse: [aStream print: number; space].
						aStream nextPut: $i. something _ true].
	c isZero ifFalse: [number _ c.
						something
							ifTrue: [aStream nextPutAll: (number positive
								ifTrue: [' + ']
								ifFalse: [number _ number negated. ' - '])]
							ifFalse: [number negative
								ifTrue: [aStream nextPut: $-.
										number _ number negated]].
						number = number one ifFalse: [aStream print: number; space].
						aStream nextPut: $j. something _ true].
	d isZero ifFalse: [number _ d.
						something
							ifTrue: [aStream nextPutAll: (number positive
								ifTrue: [' + ']
								ifFalse: [number _ number negated. ' - '])]
							ifFalse: [number negative
								ifTrue: [aStream nextPut: $-.
										number _ number negated]].
						number = number one ifFalse: [aStream print: number; space].
						aStream nextPut: $k. something _ true]! !

!SLP methodsFor: 'as yet unclassified' stamp: 'len 7/26/2016 23:00'!
printOn: aStream
	word printOn: aStream! !

!RootSystem methodsFor: 'printing' stamp: 'len 2/11/2016 01:34'!
printOn: aStream
	aStream nextPut: ${.
	roots do: [:each| aStream print: each] separatedBy: [aStream nextPut: $,].
	aStream nextPut: $}! !

!Product methodsFor: 'as yet unclassified' stamp: 'len 4/21/2019 03:05:23'!
printOn: aStream
	self components do: [:each| aStream print: each] separatedBy: [aStream nextPut: Character times]! !

!DirectSum methodsFor: 'as yet unclassified' stamp: 'len 4/21/2019 03:18:37'!
printOn: aStream
	self components do: [:each| aStream print: each] separatedBy: [aStream nextPut: Character oplus]! !

!RealAlgebraicNumber methodsFor: 'arithmetic' stamp: 'len 4/29/2018 18:33:11'!
* aNumber
	| f b |
	aNumber class = self class
		ifFalse: [^ aNumber adaptToRealAlgebraic: self andSend: #*].
	aNumber isZero ifTrue: [^ aNumber].
	self isZero ifTrue: [^ self].
	f _ RealRootIsolator on:
		(minimalPolynomial zeroProduct: aNumber minimalPolynomial) squareFree.
	[b _ self bounds * aNumber bounds.
	f moreThanOneRootBetween: b left and: b right]
		whileTrue:
			[self refineWith: aNumber].
	^ self class polynomial: f polynomial bounds: b! !

!RealAlgebraicNumber methodsFor: 'arithmetic' stamp: 'len 4/29/2018 18:33:25'!
+ aNumber
	| f b |
	aNumber class = self class
		ifFalse: [^ aNumber adaptToRealAlgebraic: self andSend: #+].
	aNumber isZero ifTrue: [^ self].
	self isZero ifTrue: [^ aNumber].
	f _ RealRootIsolator on:
		(minimalPolynomial zeroAddition: aNumber minimalPolynomial) squareFree.
	[b _ self bounds + aNumber bounds.
	f moreThanOneRootBetween: b left and: b right]
		whileTrue:
			[self refineWith: aNumber].
	^ self class polynomial: f polynomial bounds: b! !

!RealAlgebraicNumber methodsFor: 'arithmetic' stamp: 'len 11/9/2015 14:28'!
- anObject
	^ self + anObject negated! !

!RealAlgebraicNumber methodsFor: 'arithmetic' stamp: 'len 11/9/2015 14:29'!
/ anObject
	^ self * anObject reciprocal! !

!RealAlgebraicNumber methodsFor: 'arithmetic' stamp: 'len 4/29/2018 17:27:06'!
negated
	"Answer the additive inverse of the receiver."
	self isZero ifTrue: [^ self].
	^ self class
		minimalPolynomial: minimalPolynomial zeroNegation
		bounds: bounds negated! !

!RealAlgebraicNumber methodsFor: 'arithmetic' stamp: 'len 4/29/2018 17:29:53'!
reciprocal
	"Answer the multiplicative inverse of the receiver."
	self isZero ifTrue: [^ ZeroDivide signal].
	^ self class
		minimalPolynomial: minimalPolynomial zeroReciprocal
		bounds: bounds reciprocal! !

!RealAlgebraicNumber methodsFor: 'comparing' stamp: 'len 6/4/2016 21:32'!
< anObject
	"Answer whether the receiver is less than the argument."

	anObject class = self class ifFalse: [^ (self - anObject) sign = -1].
	(self = anObject) ifTrue: [^ false].
	[self bounds intersects: anObject bounds] whileTrue: [self refineWith: anObject].
	^ self rightBound < anObject leftBound! !

!RealAlgebraicNumber methodsFor: 'comparing' stamp: 'len 4/29/2018 18:34:58'!
= anObject
	anObject isNumber ifFalse: [^ false].
	self == anObject ifTrue: [^ true].
	anObject class = self class
		ifFalse: [^ anObject adaptToRealAlgebraic: self andSend: #=].
	^ minimalPolynomial = anObject minimalPolynomial and: [bounds intersects: anObject bounds]! !

!RealAlgebraicNumber methodsFor: 'comparing' stamp: 'len 12/13/97 03:56'!
hash
	"Answer the hash value for the receiver."

	^ self truncated hash! !

!RealAlgebraicNumber methodsFor: 'approximating' stamp: 'len 6/4/2016 22:22'!
absoluteError
	"Answer the maximun current error in the rational approximation of the receiver."
	^ bounds length / 2! !

!RealAlgebraicNumber methodsFor: 'approximating' stamp: 'len 6/4/2016 21:23'!
approximation
	"Answer the current rational approximation of the receiver."
	^ bounds midpoint! !

!RealAlgebraicNumber methodsFor: 'approximating' stamp: 'len 1/16/2016 06:27'!
bounds
	^ bounds! !

!RealAlgebraicNumber methodsFor: 'approximating' stamp: 'len 6/4/2016 23:06'!
refine
	"Refine the rational interval approximation of the receiver."
	self refineAt: self approximation! !

!RealAlgebraicNumber methodsFor: 'approximating' stamp: 'len 4/29/2018 18:37:00'!
refineAt: aFraction
	"Refine the rational interval approximation of the receiver to one of both (leftBound, aFraction] or (aFraction, rightBound]."
	| sign |
	self rightSign = (sign _ (minimalPolynomial value: aFraction) sign)
		ifTrue: [self rightBound: aFraction; rightSign: sign]
		ifFalse: [self leftBound: aFraction].
	sign = 0 ifTrue: [self leftBound: aFraction. self rightBound: aFraction]! !

!RealAlgebraicNumber methodsFor: 'approximating' stamp: 'len 1/16/2016 07:10'!
refineTo: aNumber
	"Refine the receiver up to get an approximation error < aNumber."
	[self absoluteError >= aNumber] whileTrue: [self refine]! !

!RealAlgebraicNumber methodsFor: 'approximating' stamp: 'len 1/17/2016 07:44'!
refineWith: aRealAlgebraicNumber
	"Refine the rational interval approximation of either the receiver or the argument, depending on which is less precise at the moment."
	self relativeError > aRealAlgebraicNumber relativeError
		ifTrue: [self refine]
		ifFalse: [aRealAlgebraicNumber refine]! !

!RealAlgebraicNumber methodsFor: 'approximating' stamp: 'len 6/4/2016 23:10'!
relativeError
	"Answer the relative error in the current rational approximation."
	self isZero ifTrue: [^ 0].
	^ self absoluteError / self approximation abs! !

!RealAlgebraicNumber methodsFor: 'converting' stamp: 'len 4/29/2018 18:39:36'!
adaptToAlgebraic: rcvr andSend: selector
	^ rcvr perform: selector with: (ComplexAlgebraicNumber polynomial: minimalPolynomial approximation: bounds midpoint radius: bounds length / 2)! !

!RealAlgebraicNumber methodsFor: 'converting' stamp: 'len 11/19/2015 21:39'!
adaptToFloat: rcvr andSend: selector
	^ rcvr perform: selector with: self asFloat! !

!RealAlgebraicNumber methodsFor: 'converting' stamp: 'len 11/19/2015 21:40'!
adaptToFraction: rcvr andSend: selector
	^ (self class fromRational: rcvr) perform: selector with: self! !

!RealAlgebraicNumber methodsFor: 'converting' stamp: 'len 11/19/2015 21:39'!
adaptToInteger: rcvr andSend: selector
	^ (self class fromRational: rcvr) perform: selector with: self! !

!RealAlgebraicNumber methodsFor: 'converting' stamp: 'len 6/4/2016 23:06'!
asFloat
	"Answer a Float approximation of the receiver."

	self refineTo: 0.000001.
	^ self approximation asFloat! !

!RealAlgebraicNumber methodsFor: 'converting' stamp: 'len 4/29/2018 20:28:54'!
asRational
	"Convert the receiver to Fraction or Integer."
	| alpha |
	self leftBound = self rightBound ifTrue: [^ self leftBound].
	minimalPolynomial degree < 2
		ifTrue:
			[alpha _ minimalPolynomial independentCoefficient negated / minimalPolynomial leadingCoefficient.
			self bounds: (RealInterval open: alpha closed: alpha).
			^ alpha].
	(minimalPolynomial rootsIn: QQ)
		do: [:each|
			(each between: self leftBound and: self rightBound)
				ifTrue: [self bounds: (RealInterval open: each closed: each). ^ each]].
	self error: 'the number is irrational'! !

!RealAlgebraicNumber methodsFor: 'accessing-private' stamp: 'len 1/17/2016 02:57'!
bounds: aRealInterval
	bounds _ aRealInterval.
	rightSign _ nil! !

!RealAlgebraicNumber methodsFor: 'accessing-private' stamp: 'len 1/16/2016 06:38'!
leftBound
	^ bounds left! !

!RealAlgebraicNumber methodsFor: 'accessing-private' stamp: 'len 1/16/2016 07:05'!
leftBound: aFraction
	bounds _ RealInterval open: aFraction closed: bounds right! !

!RealAlgebraicNumber methodsFor: 'accessing-private' stamp: 'len 1/16/2016 06:38'!
rightBound
	^ bounds right! !

!RealAlgebraicNumber methodsFor: 'accessing-private' stamp: 'len 1/17/2016 02:57'!
rightBound: aFraction
	bounds _ RealInterval open: bounds left closed: aFraction.
	rightSign _ nil! !

!RealAlgebraicNumber methodsFor: 'accessing-private' stamp: 'len 4/29/2018 18:37:11'!
rightSign
	rightSign isNil ifTrue: [rightSign _ (minimalPolynomial value: self rightBound) sign].
	^ rightSign! !

!RealAlgebraicNumber methodsFor: 'accessing-private' stamp: 'len 1/17/2016 02:59'!
rightSign: anInteger
	rightSign _ anInteger! !

!RealAlgebraicNumber methodsFor: 'accessing' stamp: 'len 4/29/2018 18:45:52'!
denominator
	"The denominator of an algebraic number is the smallest positive integer that multiplied by the algebraic number is an algebraic integer."
	^ minimalPolynomial coefficients inject: 1 into: [:result :each| result lcm: each denominator]! !

!RealAlgebraicNumber methodsFor: 'accessing' stamp: 'len 4/29/2018 17:32:57'!
minimalPolynomial
	^ minimalPolynomial! !

!RealAlgebraicNumber methodsFor: 'testing' stamp: 'len 12/5/2017 20:12:14'!
isAlgebraic
	^ true! !

!RealAlgebraicNumber methodsFor: 'testing' stamp: 'len 5/27/2016 02:06'!
isAlgebraicInteger
	"An algebraic number is an 'algebraic integer' if it's the root of a monic polynomial in Z[x], in particular if it's minimal polynomial has integer coefficients."
	^ self minimalPolynomial coefficients allSatisfy: [:each| each isInteger]! !

!RealAlgebraicNumber methodsFor: 'testing' stamp: 'len 4/29/2018 20:09:03'!
isRational
	"Answer true if the receiver is a rational number."
	minimalPolynomial degree < 2 ifTrue: [^ true].
	self rightBound = self leftBound ifTrue: [^ true].
	(minimalPolynomial rootsIn: QQ)
		do: [:each|
			(self bounds includes: each)
				ifTrue: [self bounds: (RealInterval closed: each closed: each). ^ true]].
	^ false! !

!RealAlgebraicNumber methodsFor: 'testing' stamp: 'len 11/19/2015 21:33'!
isZero
	^ self leftBound = 0 and: [self rightBound = 0]
"	^ self isRational and: [self asRational = 0]"! !

!RealAlgebraicNumber methodsFor: 'initialization' stamp: 'len 5/13/2019 12:54:19'!
minimalPolynomial: aPolynomial bounds: aRealInterval
	minimalPolynomial _ aPolynomial monic.
	bounds _ aRealInterval.
	self normalize! !

!RealAlgebraicNumber methodsFor: 'private' stamp: 'len 4/29/2018 18:36:44'!
normalize
	"Change the representation of the receiver such that if the receiver is not 0 then 0 is not in the rational approximation interval."
	| p sign |
	self leftBound sign = self rightBound sign ifTrue: [^ self].
	minimalPolynomial independentCoefficient isZero
		ifTrue: [^ self leftBound: 0; rightBound: 0].
	"for every real root r not 0: |r| > 1 / (1 + f normInfinite), from Cauchy and Landau inequalities"
	p _ 1 / (1 + minimalPolynomial normInfinite).
	p negated < self leftBound
		ifTrue: [^ self leftBound: p].
	p > self rightBound
		ifTrue: [^ self rightBound: p negated].
	sign _ (minimalPolynomial value: p negated) sign.
	sign ~= (minimalPolynomial value: self leftBound) sign
		ifTrue: [self rightBound: p negated; rightSign: sign]
		ifFalse: [(minimalPolynomial value: p) sign ~= self rightSign
				ifTrue: [self leftBound: p]
				ifFalse: [self leftBound: 0; rightBound: 0]].
	self leftBound > self rightBound ifTrue: [self error: 'interval normalization error']! !

!RealAlgebraicNumber methodsFor: 'printing' stamp: 'len 4/29/2018 18:39:50'!
printOn: aStream base: base
	minimalPolynomial degree < 4 "too slow" ifTrue: [self isRational ifTrue: [self asRational printOn: aStream base: base. ^ self]].
"	polynomial degree = 2 ifTrue: [^ self printQuadraticOn: aStream base: base]."
	(self asFloat roundTo: 0.00001) printOn: aStream base: base.
	aStream nextPutAll: '..'

	"aStream
		nextPutAll: self class name;
		space;
		nextPut: $(;
		print: self polynomial;
		nextPutAll: '; ~ ';
		print: self asFloat;
		nextPut: $)"! !

!RealAlgebraicNumber methodsFor: 'mathematical functions' stamp: 'len 8/8/97 20:54'!
sign
	"Answer 1, -1 or 0, depending on the sign of the receiver."

	^ self leftBound sign! !

!RealAlgebraicNumber methodsFor: 'mathematical functions' stamp: 'len 4/29/2018 18:38:08'!
squareRoot
	self isRational ifFalse: [^ self notYetImplemented].
	self negative ifTrue: [^ self negated squareRoot i].
	self isZero ifTrue: [^ self].
	^ self class
		polynomial: minimalPolynomial zeroSquareRoot "is it minimal?"
 		bounds: (RealInterval open: 0 open: (self asRational max: 1))! !

!RealAlgebraicNumber methodsFor: 'mathematical functions' stamp: 'len 4/29/2018 18:39:12'!
squared
	| x odd even |
	x _ minimalPolynomial parent x.
	odd _ minimalPolynomial odd.
	even _ minimalPolynomial even.
	self flag: #fix.
	^ self class "this could be rational"
		polynomial: odd squared * x - even squared
		bounds: self bounds squared! !

!RealAlgebraicNumber methodsFor: 'truncation and round off' stamp: 'len 1/17/2016 02:20'!
truncated
	"Answer the integer nearest the receiver toward zero."
	| t |
	self absoluteError truncated > 0 ifTrue: [self refineTo: 9/10].
	^ (t _ self rightBound truncated) = self rightBound
		ifTrue: [self refineAt: t.
				self rightBound truncated]
		ifFalse: [t]! !

!RealAlgebraicNumber class methodsFor: 'instance creation' stamp: 'len 7/15/2016 18:36'!
fromRational: anIntegerOrFraction
	"Answer an instance of the receiver representing the rational number anIntegerOrFraction."
	| q x |
	q _ anIntegerOrFraction asFraction.
	x _ QQ polynomials x.
	^ self
		minimalPolynomial: x * q denominator - q numerator
 		bounds: (RealInterval open: anIntegerOrFraction closed: anIntegerOrFraction)! !

!RealAlgebraicNumber class methodsFor: 'instance creation' stamp: 'len 4/29/2018 17:30:10'!
minimalPolynomial: aPolynomial bounds: aRealInterval
	"Answer an instance of the receiver representing the unique zero of aPolynomial in the given rational interval."
	^ self new minimalPolynomial: aPolynomial bounds: aRealInterval! !

!RealAlgebraicNumber class methodsFor: 'instance creation' stamp: 'len 5/10/2019 08:31:05'!
polynomial: aPolynomial bounds: aRealInterval
	"Answer an instance of the receiver representing the unique zero of aPolynomial in the given interval."
	| approximation |
	approximation _ aRealInterval midpoint.
	^ self minimalPolynomial: (aPolynomial factors detectMin: [:f| (f value: approximation) abs]) bounds: aRealInterval! !

!RealAlgebraicNumber class methodsFor: 'examples' stamp: 'len 4/12/2018 17:51:12'!
phi
	"Answer the Phidias number or Golden Ratio."
	| x |
	x _ QQ polynomials x.
	^ self minimalPolynomial: x^2 - x - 1 bounds: (RealInterval open: 1.0 open: 2.0)! !

!RealAlgebraicNumber class methodsFor: 'examples' stamp: 'len 4/12/2018 17:51:01'!
sqrt2
	"Answer an instance of the receiver representing the square root of 2."
	^ self
		minimalPolynomial: QQ polynomials x squared - 2
 		bounds: (RealInterval open: 1.0 open: 2.0)! !

!RealAlgebraicNumber class methodsFor: 'examples' stamp: 'len 4/12/2018 17:50:54'!
sqrt: aNumber
	"Answer a square root of the rational argument."
	aNumber positive ifFalse: [^ DomainError signal: 'negative square root'].
	^ self
		minimalPolynomial: QQ polynomials x squared - aNumber
 		bounds: (RealInterval open: 0.0 open: (aNumber max: 1.0))! !

!ContinuedFraction methodsFor: 'converting' stamp: 'len 10/18/2016 14:05'!
asFraction
	self isInfinite ifTrue: [self error: 'infinite continued fraction'].
	^ self convergentAt: coefficients size! !

!ContinuedFraction methodsFor: 'accessing' stamp: 'len 12/2/2015 00:07'!
coefficients
	^ coefficients! !

!ContinuedFraction methodsFor: 'initialization' stamp: 'len 11/12/2016 09:16'!
coefficients: aSequence
	coefficients _ ((aSequence isKindOf: Tuple) or: [aSequence isKindOf: Sequence])
		ifTrue: [aSequence]
		ifFalse: [ZZ tuple: aSequence]! !

!ContinuedFraction methodsFor: 'initialization' stamp: 'len 11/5/2016 10:29'!
fromFraction: aFraction
	| x a |
	aFraction isInfinity ifTrue: [coefficients _ ZZ tuple: 0 evaluating: []. ^ self].
	coefficients _ OrderedCollection new.
	x _ aFraction.
	a _ x floor.
	coefficients add: a.
	[x _ x - a.
	x ~= 0]
		whileTrue:
			[x _ x reciprocal.
			a _ x floor.
			coefficients add: a].
	coefficients _ ZZ tuple: coefficients asArray! !

!ContinuedFraction methodsFor: 'convergents' stamp: 'len 3/27/2016 04:46'!
convergentAt: anInteger
	| n x |
	coefficients size > 0 ifFalse: [^ Infinity positive].
	n _ coefficients size min: anInteger.
	x _ coefficients at: n.
	(1 to: n-1) reverseDo: [:i| x _ x reciprocal + (coefficients at: i)].
	^ x! !

!ContinuedFraction methodsFor: 'convergents' stamp: 'len 7/15/2016 18:31'!
convergents
	^ Sequence to: QQ evaluating: [:i| self convergentAt: i]! !

!ContinuedFraction methodsFor: 'convergents' stamp: 'len 3/27/2016 04:51'!
convergentsDo: aBlock
	| p1 p2 q1 q2 |
	p2 _ 0.
	p1 _ 1.
	q2 _ 1.
	q1 _ 0.
	coefficients withIndexDo: [:ai :i| | pi qi | pi _ ai*p1 + p2. qi _ ai*q1 + q2. aBlock value: pi/qi. p2 _ p1. p1 _ pi. q2 _ q1. q1 _ qi]! !

!ContinuedFraction methodsFor: 'convergents' stamp: 'len 3/27/2016 04:43'!
convergentsUpTo: n
	| answer |
	answer _ OrderedCollection new: n.
	self convergentsDo: [:each| answer size < n ifFalse: [^ answer]. answer add: each]! !

!ContinuedFraction methodsFor: 'testing' stamp: 'len 10/18/2016 14:05'!
isFinite
	^ coefficients size isInfinite not! !

!ContinuedFraction methodsFor: 'testing' stamp: 'len 10/18/2016 13:50'!
isInfinite
	^ self isFinite not! !

!ContinuedFraction methodsFor: 'arithmetic' stamp: 'len 12/3/2015 02:17'!
negated
	^ self class coefficients: coefficients negated! !

!ContinuedFraction methodsFor: 'arithmetic' stamp: 'len 12/4/2015 01:45'!
reciprocal
	^ (coefficients at: 1) = 0
		ifTrue: [self class coefficients: (coefficients copyFrom: 2 to: coefficients size)]
		ifFalse: [self class coefficients: 0, coefficients]! !

!ContinuedFraction methodsFor: 'printing' stamp: 'len 10/18/2016 13:49'!
printOn: aStream base: base
	| separator |
	aStream nextPut: $[.
	separator _ $;.
	(1 to: (coefficients size min: 10)) do: [:i| (coefficients at: i) printOn: aStream base: base] separatedBy: [aStream nextPut: separator. separator _ $,].
	coefficients size isInfinite ifTrue: [aStream nextPutAll: '...'].
	aStream nextPut: $]! !

!ContinuedFraction class methodsFor: 'instance creation' stamp: 'len 12/2/2015 00:10'!
coefficients: anArray
	^ self new coefficients: anArray! !

!ContinuedFraction class methodsFor: 'instance creation' stamp: 'len 3/27/2016 05:07'!
fromFloat: aFloat
	^ self fromFraction: aFloat asFraction! !

!ContinuedFraction class methodsFor: 'instance creation' stamp: 'len 12/1/2015 23:04'!
fromFraction: aFraction
	^ self new fromFraction: aFraction! !

!ContinuedFraction class methodsFor: 'instance creation' stamp: 'len 4/30/2016 04:34'!
newFrom: aNumber
	aNumber isFloat ifTrue: [^ self fromFloat: aNumber].
	aNumber isFraction ifTrue: [^ self fromFraction: aNumber].
	^ super newFrom: aNumber! !

!ContinuedFraction class methodsFor: 'examples' stamp: 'len 12/4/2015 22:17'!
e
	^ self coefficients: (Sequence evaluating: [:n| n=1 ifTrue: [2] ifFalse: [n \\ 3 = 0 ifTrue: [2*n/3] ifFalse: [1]]])! !

!ContinuedFraction class methodsFor: 'examples' stamp: 'len 12/4/2015 01:14'!
phi
	"Answer the golden ratio."
	^ self coefficients: (Sequence constant: 1)! !

!DyadicFraction methodsFor: 'arithmetic' stamp: 'len 1/16/2016 08:00'!
* aDyadicFraction
	aDyadicFraction isInteger ifTrue: [^ self class numerator: numerator * aDyadicFraction shift: shift].
	^ self class
		numerator: numerator * aDyadicFraction numerator
		shift: shift + aDyadicFraction shift! !

!DyadicFraction methodsFor: 'arithmetic' stamp: 'len 1/15/2016 08:00'!
+ aDyadicFraction
	^ self shift <= aDyadicFraction shift
		ifTrue:
			[self class
				numerator: (numerator bitShift: aDyadicFraction shift - shift) + aDyadicFraction numerator
				shift: aDyadicFraction shift]
		ifFalse:
			[self class
				numerator: (aDyadicFraction numerator bitShift: shift - aDyadicFraction shift) + numerator
				shift: shift]! !

!DyadicFraction methodsFor: 'arithmetic' stamp: 'len 1/16/2016 08:13'!
- aNumber
	^ self + aNumber negated! !

!DyadicFraction methodsFor: 'arithmetic' stamp: 'len 1/16/2016 07:49'!
/ anInteger
	| n |
	n _ anInteger abs.
	n isPowerOfTwo ifFalse: [DomainError signal: 'only can divide by a power of 2'].
	^ self class
		numerator: (anInteger positive ifTrue: [numerator] ifFalse: [numerator negated])
		shift: shift + n highBit - 1! !

!DyadicFraction methodsFor: 'arithmetic' stamp: 'len 1/15/2016 07:47'!
negated
	^ self class numerator: numerator negated shift: shift! !

!DyadicFraction methodsFor: 'comparing' stamp: 'len 1/17/2016 08:03'!
< aDyadicFraction
	"Answer whether the receiver is less than the argument."
	self sign ~= aDyadicFraction sign ifTrue: [^ self sign < aDyadicFraction sign].
	shift = aDyadicFraction shift ifTrue: [^ numerator < aDyadicFraction numerator].
"	numerator = aDyadicFraction numerator ifTrue: [^ numerator positive and: [shift > aDyadicFraction shift]]."
	^ (numerator bitShift: aDyadicFraction shift) < (aDyadicFraction numerator bitShift: shift)! !

!DyadicFraction methodsFor: 'comparing' stamp: 'len 1/16/2016 07:58'!
= aDyadicFraction
	^ numerator = aDyadicFraction numerator and: [shift = aDyadicFraction shift]! !

!DyadicFraction methodsFor: 'comparing' stamp: 'len 6/28/2016 09:12'!
hash
	^ numerator hashMultiply + shift! !

!DyadicFraction methodsFor: 'converting' stamp: 'len 1/16/2016 08:14'!
asFloat
	^ self asFraction asFloat! !

!DyadicFraction methodsFor: 'converting' stamp: 'len 1/16/2016 05:34'!
asFraction
	^ Fraction numerator: self numerator denominator: self denominator! !

!DyadicFraction methodsFor: 'private' stamp: 'len 1/15/2016 07:45'!
denominator
	^ 1 bitShift: shift! !

!DyadicFraction methodsFor: 'private' stamp: 'len 1/16/2016 08:15'!
normalize
	[numerator even and: [shift > 0]]
		whileTrue:
			[numerator _ numerator bitShift: -1.
			shift _ shift - 1]! !

!DyadicFraction methodsFor: 'private' stamp: 'len 1/15/2016 07:30'!
numerator
	^ numerator! !

!DyadicFraction methodsFor: 'private' stamp: 'len 1/16/2016 08:15'!
setNumerator: a shift: n
	numerator _ a asInteger.
	shift _ n asInteger.
	self normalize! !

!DyadicFraction methodsFor: 'private' stamp: 'len 1/15/2016 07:46'!
shift
	^ shift! !

!DyadicFraction methodsFor: 'testing' stamp: 'len 1/15/2016 07:48'!
isZero
	^ numerator isZero! !

!DyadicFraction methodsFor: 'testing' stamp: 'len 1/16/2016 08:05'!
sign
	^ numerator sign! !

!DyadicFraction methodsFor: 'constants' stamp: 'len 1/15/2016 07:48'!
one
	^ self class numerator: 1 shift: 0! !

!DyadicFraction methodsFor: 'constants' stamp: 'len 1/15/2016 07:48'!
zero
	^ self class numerator: 0 shift: 0! !

!DyadicFraction methodsFor: 'printing' stamp: 'len 1/15/2016 08:01'!
printOn: aStream base: base
	aStream nextPut: $(.
	numerator printOn: aStream base: base.
	aStream nextPutAll: '/2^'; print: shift; nextPut: $)! !

!DyadicFraction methodsFor: 'mathematical functions' stamp: 'len 1/16/2016 06:04'!
raisedToInteger: anInteger
	anInteger < 0 ifTrue: [^ self reciprocal raisedToInteger: anInteger negated].
	anInteger = 0 ifTrue: [^ self one].
	^ self class numerator: (numerator raisedToInteger: anInteger) shift: shift + anInteger! !

!DyadicFraction class methodsFor: 'instance creation' stamp: 'len 1/16/2016 05:36'!
fromFraction: aFraction
	^ self numerator: aFraction numerator shift: aFraction denominator highBit - 1! !

!DyadicFraction class methodsFor: 'instance creation' stamp: 'len 1/16/2016 07:57'!
fromInteger: anInteger
	anInteger isInteger ifFalse: [DomainError signal].
	^ self numerator: anInteger shift: 0! !

!DyadicFraction class methodsFor: 'instance creation' stamp: 'len 1/15/2016 07:46'!
numerator: anInteger shift: n
	^ self new setNumerator: anInteger shift: n! !

!MutualAssociation methodsFor: 'comparing' stamp: 'len 7/13/2016 07:55'!
= anAssociation
	(anAssociation isKindOf: Association)
		ifFalse: [^ false].
	^ key = anAssociation key
		ifTrue: [value = anAssociation value]
		ifFalse: [value = anAssociation key and: [key = anAssociation value]]! !

!MutualAssociation methodsFor: 'comparing' stamp: 'len 7/13/2016 07:31'!
hash
	^ key hash bitXor: value hash! !

!MutualAssociation class methodsFor: 'instance creation' stamp: 'len 7/23/2016 06:39'!
newFrom: anAssociation
	^ self with: anAssociation key with: anAssociation value! !

!MutualAssociation class methodsFor: 'instance creation' stamp: 'len 7/13/2016 07:33'!
with: anObject with: anotherObject
	^ self key: anObject value: anotherObject! !

!Aleph methodsFor: 'accessing' stamp: 'len 4/22/2016 05:06'!
order
	^ order! !

!Aleph methodsFor: 'arithmetic' stamp: 'len 4/22/2016 02:39'!
* anObject
	anObject = 0 ifTrue: [^ self errorUndetermined].
	^ self max: anObject! !

!Aleph methodsFor: 'arithmetic' stamp: 'len 1/22/2017 08:12:39'!
^ aNumber
	(aNumber isInteger and: [aNumber > 0]) ifTrue: [^ self].
	DomainError signal: 'only integer positive exponents allowed'! !

!Aleph methodsFor: 'comparing' stamp: 'len 4/22/2016 05:06'!
< anObject
	anObject class = self class ifTrue: [^ order < anObject order].
	^ false! !

!Aleph methodsFor: 'comparing' stamp: 'len 4/22/2016 05:06'!
= anObject
	^ self class == anObject class and: [order = anObject order]! !

!Aleph methodsFor: 'comparing' stamp: 'len 6/28/2016 09:04'!
hash
	^ self class hash + order hash! !

!Aleph methodsFor: 'converting' stamp: 'len 4/22/2016 05:11'!
adaptToNumber: rcvr andSend: selector
	selector == #+ ifTrue:[^self + rcvr].
	selector == #* ifTrue:[^self * rcvr].
	selector == #/ ifTrue:[^ rcvr isNumber ifTrue: [0] ifFalse: [self errorUndetermined]].
	selector == #> ifTrue:[^false].
	selector == #>= ifTrue:[^false].
	selector == #< ifTrue:[^true].
	selector == #<= ifTrue:[^true].
	^super adaptToNumber: rcvr andSend: selector! !

!Aleph methodsFor: 'initialization' stamp: 'len 4/22/2016 05:06'!
order: anInteger
	order _ anInteger! !

!Aleph methodsFor: 'testing' stamp: 'len 4/22/2016 05:06'!
isCountable
	^ order = 0! !

!Aleph methodsFor: 'testing' stamp: 'len 4/22/2016 04:54'!
isInfinite
	^ true! !

!Aleph class methodsFor: 'instance creation' stamp: 'len 4/22/2016 02:37'!
new
	^ self new: 0! !

!Aleph class methodsFor: 'instance creation' stamp: 'len 4/22/2016 05:07'!
new: anInteger
	^ self basicNew order: anInteger! !

!Infinity methodsFor: 'arithmetic' stamp: 'len 11/14/97 14:49'!
* anObject
	"Answer the product of the receiver by the argument."

	anObject = 0 ifTrue: [^ self errorUndetermined].
	^ self class sign: self sign * anObject sign! !

!Infinity methodsFor: 'arithmetic' stamp: 'len 12/13/97 02:26'!
+ anObject
	"Answer the sum of the receiver and the argument."

	(anObject isInfinity and: [self sign ~= anObject sign])
		ifTrue: [^ self errorUndetermined].
	^ self! !

!Infinity methodsFor: 'arithmetic' stamp: 'len 11/12/97 21:30'!
- anObject
	"Answer the difference between the receiver and the argument."

	^ self + anObject negated! !

!Infinity methodsFor: 'arithmetic' stamp: 'len 10/9/97 20:24'!
/ anObject
	"Answer the division of the receiver by the argument."

	^ self * anObject reciprocal! !

!Infinity methodsFor: 'arithmetic' stamp: 'len 1/22/2017 08:15:34'!
^ aNumber
	^ self raisedTo: aNumber! !

!Infinity methodsFor: 'arithmetic' stamp: 'len 11/12/97 21:31'!
negated
	"Answer a copy of the receiver with the sign changed."

	^ self class sign: self sign negated! !

!Infinity methodsFor: 'arithmetic' stamp: 'len 1/16/2016 06:08'!
raisedTo: aNumber
	aNumber isInteger ifTrue: [^ self raisedToInteger: aNumber].
	^ DomainError signal! !

!Infinity methodsFor: 'arithmetic' stamp: 'len 11/9/2015 23:18'!
raisedToInteger: anInteger
	anInteger = 0 ifTrue: [^ self errorUndetermined].
	anInteger negative ifTrue: [^ 0].
	^ anInteger odd ifTrue: [self] ifFalse: [self negated]! !

!Infinity methodsFor: 'arithmetic' stamp: 'len 11/12/97 21:32'!
reciprocal
	"Answer zero. (1 / self)"

	^ 0! !

!Infinity methodsFor: 'arithmetic' stamp: 'len 10/17/97 04:09'!
squared
	"Answer the square of the receiver."

	^ self class positive! !

!Infinity methodsFor: 'comparing' stamp: 'len 11/9/2015 15:19'!
< anObject
	anObject isInfinity ifTrue: [^ self sign < anObject sign].
	^ self negative! !

!Infinity methodsFor: 'comparing' stamp: 'len 11/9/2015 15:19'!
<= aMagnitude
	^ self < aMagnitude! !

!Infinity methodsFor: 'comparing' stamp: 'len 11/9/2015 15:19'!
= anObject
	^ self class == anObject class and: [self sign = anObject sign]! !

!Infinity methodsFor: 'comparing' stamp: 'len 11/9/2015 15:19'!
> anObject
	anObject isInfinity ifTrue: [^ self sign > anObject sign].
	^ self positive! !

!Infinity methodsFor: 'comparing' stamp: 'len 11/9/2015 15:19'!
>= aMagnitude
	^ self > aMagnitude! !

!Infinity methodsFor: 'comparing' stamp: 'len 6/28/2016 09:19'!
hash
	^ self sign hash + self class hash! !

!Infinity methodsFor: 'converting' stamp: 'len 11/11/2015 05:00'!
adaptToNumber: rcvr andSend: selector
	selector == #+ ifTrue:[^self + rcvr].
	selector == #* ifTrue:[^self * rcvr].
	selector == #- ifTrue:[^self negated + rcvr].
	selector == #/ ifTrue:[^ rcvr isInfinite ifTrue: [self errorUndetermined] ifFalse: [0]].
	selector == #> ifTrue:[^self < rcvr].
	selector == #>= ifTrue:[^self <= rcvr].
	selector == #< ifTrue:[^self > rcvr].
	selector == #<= ifTrue:[^self >= rcvr].
	^super adaptToNumber: rcvr andSend: selector! !

!Infinity methodsFor: 'private' stamp: 'len 10/9/97 20:29'!
errorUndetermined
	^ self error: 'undetermined'! !

!Infinity methodsFor: 'testing' stamp: 'len 10/18/2016 14:00'!
isInfinite
	^ true! !

!Infinity methodsFor: 'testing' stamp: 'len 11/19/2015 17:00'!
isInfinity
	^ true! !

!Infinity methodsFor: 'testing' stamp: 'len 12/6/2016 13:19:59'!
isZero
	^ false! !

!Infinity methodsFor: 'testing' stamp: 'len 11/14/97 14:50'!
negative
	"Answer true if the receiver is negative."

	^ self sign negative! !

!Infinity methodsFor: 'testing' stamp: 'len 11/14/97 14:50'!
positive
	"Answer true if the receiver is positive."

	^ self sign positive! !

!Infinity methodsFor: 'testing' stamp: 'len 11/14/97 14:51'!
strictlyPositive
	"Answer true if the receiver is strictly positive."

	^ self positive! !

!Infinity methodsFor: 'accessing' stamp: 'len 10/9/97 20:17'!
sign
	"Answer the sign of the receiver."

	^ sign! !

!Infinity methodsFor: 'accessing-private' stamp: 'len 10/9/97 20:16'!
sign: anInteger
	sign _ anInteger! !

!Infinity class methodsFor: 'instance creation' stamp: 'len 10/17/97 04:07'!
negative
	"Answer a new instance of the receiver representing -infinity."

	^ self sign: -1! !

!Infinity class methodsFor: 'instance creation' stamp: 'len 10/17/97 04:07'!
positive
	"Answer a new instance of the receiver representing +infinity."

	^ self sign: 1! !

!Infinity class methodsFor: 'instance creation' stamp: 'len 11/23/2015 02:41'!
projective
	"Answer a new instance of the receiver representing the projective (unsigned) infinity."

	^ self sign: 0! !

!Infinity class methodsFor: 'instance creation' stamp: 'len 10/9/97 20:27'!
sign: anInteger
	"Answer a new instance of the receiver with sign anInteger."

	^ self new sign: anInteger! !

!BitArray methodsFor: 'arithmetic' stamp: 'len 12/21/2015 22:15'!
* aBitArray
	| answer |
	answer _ self class new: (self size max: aBitArray size).
	1 to: answer byteSize do: [:i|
		answer byteAt: i put: ((self byteAt: i) bitAnd: (aBitArray byteAt: i))].
	^ answer! !

!BitArray methodsFor: 'arithmetic' stamp: 'len 12/21/2015 22:14'!
+ aBitArray
	| answer |
	answer _ self class new: (self size max: aBitArray size).
	1 to: answer byteSize do: [:i|
		answer byteAt: i put: ((self byteAt: i) bitXor: (aBitArray byteAt: i))].
	^ answer! !

!BitArray methodsFor: 'converting' stamp: 'len 12/21/2015 22:17'!
asByteArray
	^ bytes! !

!BitArray methodsFor: 'converting' stamp: 'len 12/21/2015 22:21'!
asInteger
	"Answer the receiver as a possitive integer."
	| answer i |
	answer _ 0.
	i _ 0.
	bytes do: [:each| answer _ answer + (each bitShift: i). i _ i + 8].
	^ answer! !

!BitArray methodsFor: 'accessing' stamp: 'len 12/21/2015 22:30'!
at: anInteger
	^ (bytes at: anInteger - 1 // 8 + 1 ifAbsent: [^ 0]) bitAt: anInteger - 1 \\ 8 + 1! !

!BitArray methodsFor: 'accessing' stamp: 'len 12/21/2015 22:07'!
at: anInteger put: aBit
	| i i0 b |
	i _ anInteger - 1 // 8 + 1.
	i0 _ anInteger - 1 \\ 8 + 1.
	b _ bytes at: i.
	(b bitAt: i0) == aBit
		ifFalse: [b _ b bitXor: (1 bitShift: i0-1)].
	bytes at: i put: b.
	^ aBit! !

!BitArray methodsFor: 'accessing' stamp: 'len 12/21/2015 22:16'!
byteAt: anInteger
	^ bytes at: anInteger ifAbsent: [0]! !

!BitArray methodsFor: 'accessing' stamp: 'len 12/21/2015 22:16'!
byteAt: anInteger put: aByte
	^ bytes at: anInteger put: aByte! !

!BitArray methodsFor: 'accessing' stamp: 'len 12/21/2015 20:41'!
size
	^ length! !

!BitArray methodsFor: 'initialization' stamp: 'len 12/21/2015 20:31'!
bytes: aByteArray length: anInteger
	bytes _ aByteArray.
	length _ anInteger! !

!BitArray class methodsFor: 'instance creation' stamp: 'len 12/21/2015 20:41'!
new: anInteger
	^ self new: anInteger bytes: (ByteArray new: (anInteger / 8) ceiling)! !

!BitArray class methodsFor: 'instance creation' stamp: 'len 12/21/2015 20:40'!
new: anInteger bytes: aByteArray
	^ self basicNew bytes: aByteArray length: anInteger! !

!BitArray class methodsFor: 'instance creation' stamp: 'len 12/21/2015 22:26'!
random: anInteger
	| answer |
	answer _ self new: anInteger.
	1 to: answer size do: [:i| answer at: i put: 2 atRandom - 1].
	^ answer! !

!LinearBasis methodsFor: 'operations' stamp: 'len 1/25/2018 17:57:45'!
+ aLinearBasis
	"Answer a basis for the sum of the modules generated by the receiver and the argument."
	^ self class on: ambient matrix: (matrix, aLinearBasis matrix) transposed imageMatrix! !

!LinearBasis methodsFor: 'operations' stamp: 'len 5/30/2019 07:05:57'!
/\ aLinearBasis
	"Answer a basis for the intersection of the modules generated by the receiver and the argument."
	| M N |
	M _ matrix.
	N _ (M transposed columnAugmented: aLinearBasis matrix transposed) kernelMatrix.
	N isEmpty ifTrue: [^ self class on: ambient matrix: (Matrix rows: #())].
	N _ N copyFrom: 1@1 to: N height @ M height.
	^ self class on: self ambient matrix: N * M! !

!LinearBasis methodsFor: 'operations' stamp: 'len 1/24/2018 21:11:28'!
 aLinearBasis
	"Answer the direct sum of the receiver and the argument."
	^ self class on: ambient  aLinearBasis ambient matrix: matrix  aLinearBasis matrix! !

!LinearBasis methodsFor: 'operations' stamp: 'len 7/10/2016 05:23'!
apply: aLinearMap
	| answer vector |
	answer _ self class on: (aLinearMap isBlock ifTrue: [ambient] ifFalse: [aLinearMap codomain]).
	self do: [:each|
		(answer generates: (vector _ aLinearMap value: each))
			ifFalse: [answer add: vector]].
	^ answer! !

!LinearBasis methodsFor: 'operations' stamp: 'len 1/25/2018 22:33:14'!
changeTo: aLinearBasis
	"Answer the matrix for changing from the receiver to aLinearBasis."
	^ (Matrix rows: (self collect: [:each| aLinearBasis coordinatesOf: each])) transposed! !

!LinearBasis methodsFor: 'operations' stamp: 'len 1/24/2018 21:57:14'!
dual
	ambient basis = self ifTrue: [^ ambient dual basis].
	^ self class on: ambient dual matrix: (Matrix rows: (self extended matrix transposed inverse rows first: self size))! !

!LinearBasis methodsFor: 'operations' stamp: 'len 1/24/2018 21:41:19'!
extended
	"Answer a basis spanning to all the ambient space, adding generating vectors if needed."
	self isFullRank ifTrue: [^ self].
	^ self class on: ambient matrix: (matrix, (ambient scalars identityMatrix: ambient rank)) transposed imageMatrix! !

!LinearBasis methodsFor: 'operations' stamp: 'len 1/24/2018 18:54:08'!
gramian
	"Answer the Gramian of the receiver, or Gram matrix.
	If M is the generator matrix of the receiver (>>matrix), then the Gramian is M * M transposed."
	| f |
	f _ ambient innerProduct.
	^ ambient scalars
		matrix: self size
		evaluating:
			[:i :j| f value: {(self at: i). (self at: j)}]! !

!LinearBasis methodsFor: 'operations' stamp: 'len 12/23/2015 05:19'!
orthogonalized
	"Answer the receiver orthogonalized by the Gram-Schmidt process."
	^ (GramSchmidt basis: self) orthogonalBasis! !

!LinearBasis methodsFor: 'operations' stamp: 'len 2/6/2016 20:40'!
orthonormalized
	"Answer the receiver orthonormalized by the Gram-Schmidt process."
	^ (GramSchmidt basis: self) orthonormalBasis! !

!LinearBasis methodsFor: 'operations' stamp: 'len 1/24/2018 21:58:14'!
perp
	"Answer a bssis of the orthogonal complement of the subspace spanned by the receiver."
	self isEmpty ifTrue: [^ ambient basis].
	"if we're in a vector space over the reals or complex numbers, we can get an orthogonal basis"
	((ambient scalars isKindOf: RealField) or: [ambient scalars isKindOf: ComplexField])
		ifTrue: [^ self extended orthogonalized copyFrom: self size + 1 to: self ambient rank].
	"otherwise we use this, but it assumes the associated bilinear form is just the dot product:"
	^ self class on: ambient matrix: matrix kernelMatrix! !

!LinearBasis methodsFor: 'comparing' stamp: 'len 1/24/2018 20:56:26'!
= aLinearBasis
	self == aLinearBasis ifTrue: [^ true].
	ambient == aLinearBasis ambient ifTrue: [matrix = aLinearBasis matrix].
	^ super = aLinearBasis! !

!LinearBasis methodsFor: 'accessing' stamp: 'len 11/3/2016 08:08'!
ambient
	^ ambient! !

!LinearBasis methodsFor: 'accessing' stamp: 'len 1/24/2018 20:50:20'!
at: anInteger
	^ ambient elementAt: (matrix rowAt: anInteger)! !

!LinearBasis methodsFor: 'accessing' stamp: 'len 1/24/2018 20:55:28'!
matrix
	"Answer the generator matrix M, i.e. the matrix whose rows are the coordinates of the vectors of the receiver in the ambient distinguished basis."
	^ matrix! !

!LinearBasis methodsFor: 'accessing' stamp: 'len 4/6/2017 10:41:34'!
scalars
	^ ambient scalars! !

!LinearBasis methodsFor: 'accessing' stamp: 'len 4/5/2018 15:45:13'!
size
	^ matrix height! !

!LinearBasis methodsFor: 'accessing' stamp: 'len 9/16/2018 16:14:08'!
span
	"Answer the submodule spanned by the elements of the receiver."
	self error: 'deprecated'.
	self isFullRank ifTrue: [^ ambient].
	^ ambient span: matrix! !

!LinearBasis methodsFor: 'accessing-private' stamp: 'len 1/24/2018 20:55:54'!
ambient: aFreeModule
	ambient _ aFreeModule! !

!LinearBasis methodsFor: 'accessing-private' stamp: 'len 2/5/2017 10:12:15'!
matrix: aMatrix
	matrix _ aMatrix! !

!LinearBasis methodsFor: 'coordinates' stamp: 'len 5/13/2019 14:00:48'!
coordinateMap
	^ FreeModuleMap from: self coordinateSpace to: ambient matrix: matrix transposed! !

!LinearBasis methodsFor: 'coordinates' stamp: 'len 5/23/2016 04:32'!
coordinateSpace
	^ ambient scalars ^ self size! !

!LinearBasis methodsFor: 'coordinates' stamp: 'len 1/24/2018 21:30:12'!
coordinatesOf: anElement
	"Answer the coordinates of anElement when expressed as a linear combination of the vectors of the receiver. Answer nil if anElement is independent from the receiver."
	anElement isZero ifTrue: [^ ambient scalars zeroTuple: self size "self coordinateSpace zero"].
	self isEmpty ifTrue: [^ nil].
"	1 to: self size do: [:i| (self at: i) = anElement ifTrue: [^ self coordinateSpace e: i]]."
	^ self matrix transposed \ ((ambient coordinatesOf: anElement) ifNil: [^ nil])
"alternative 1:
	answer _ self matrix leftInverse * (ambient coordinatesOf: anElement).
	^ answer isZero ifFalse: [answer]"
"alternative 2:
	m _ self matrix rowAugmented: (ambient coordinatesOf: anElement).
	reducer _ m transposed reducer.
	coords _ reducer reduced lastColumn.
	^ reducer rank > self size
		ifFalse:
			[answer _ self coordinateSpace zero copy.
			reducer pivots do: [:each| answer at: each x put: (coords at: each y)].
			answer]"! !

!LinearBasis methodsFor: 'coordinates' stamp: 'len 11/4/2016 10:13'!
elementAt: aTuple 
	"Answer the vector with coordinates aTuple when expressed as a linear combination of the receiver."
	| answer |
"	self assert: aTuple size = self size."
	answer _ self ambient zero.
	1 to: aTuple size do: [:each|
		answer _ (self at: each) * (aTuple at: each) + answer].
	^ answer! !

!LinearBasis methodsFor: 'coordinates' stamp: 'len 7/10/2016 07:31'!
vectorAt: aTuple 
	"Answer the vector with coordinates aTuple when expressed as a linear combination of the receiver."
	^ self elementAt: aTuple! !

!LinearBasis methodsFor: 'copying' stamp: 'len 12/12/2017 19:35:10'!
copy
	^ self class on: ambient matrix: matrix copy! !

!LinearBasis methodsFor: 'copying' stamp: 'len 1/24/2018 21:29:48'!
copyFrom: startIndex to: endIndex
	^ self class on: ambient matrix: (Matrix rows: (matrix rows copyFrom: startIndex to: endIndex))! !

!LinearBasis methodsFor: 'testing' stamp: 'len 12/4/2017 09:10:45'!
generates: anElement
	"Answer true if the argument is dependent to the receiver.
	Assume it is an element of the ambient module."
	self isEmpty ifTrue: [^ anElement isZero].
	self isFullRank ifTrue: [^ true].
	^ (self coordinatesOf: anElement) notNil
"no need to do extra work here, can optimize"
	"^ (self matrix | (ambient coordinatesOf: anElement)) rank = self size"! !

!LinearBasis methodsFor: 'testing' stamp: 'len 12/15/2017 18:53:15'!
isEmpty
	^ matrix isEmpty! !

!LinearBasis methodsFor: 'testing' stamp: 'len 1/17/2017 08:41:28'!
isFullRank
	^ self size = self ambient rank! !

!LinearBasis methodsFor: 'testing' stamp: 'len 5/23/2016 04:42'!
isOrthogonal
	self do: [:v|
		self do: [:w|
			(v ~~ w and: [(ambient innerProduct value: {v.w}) isZero not])
				ifTrue: [^ false]]].
	^ true! !

!LinearBasis methodsFor: 'testing' stamp: 'len 5/23/2016 04:43'!
isOrthonormal
	self isOrthogonal ifFalse: [^ false].
	self do: [:v| (ambient innerProduct value: {v.v}) = ambient scalars one ifFalse: [^ false]].
	^ true! !

!LinearBasis methodsFor: 'enumerating' stamp: 'len 1/24/2018 21:28:06'!
select: aBlock 
	"Evaluate aBlock with each of the receiver's elements as the argument. 
	Collect into a new collection like the receiver, only those elements for 
	which aBlock evaluates to true. Answer the new collection."

	^ self class on: ambient matrix: (Matrix rows: (((1 to: self size) select: [:i| aBlock value: (self at: i)]) collect: [:i| matrix rowAt: i]))! !

!LinearBasis methodsFor: 'private' stamp: 'len 12/12/2017 17:52:59'!
species
	^ Array! !

!LinearBasis class methodsFor: 'examples' stamp: 'len 12/12/2017 18:04:51'!
example
	"A basis for the vector space of 3-tuples with rational coefficients."
	| V |
	V _ QQ ^ 3.
	^ LinearBasis on: V elements: {(1, 2, 3). (3, 2, 3). (2, 0, 0)}! !

!LinearBasis class methodsFor: 'instance creation' stamp: 'len 1/24/2018 21:27:14'!
on: aFreeModule elements: aCollection
	^ self on: aFreeModule matrix: (Matrix rows: (aCollection collect: [:each| aFreeModule coordinatesOf: each]))! !

!LinearBasis class methodsFor: 'instance creation' stamp: 'len 12/12/2017 18:45:51'!
on: aFreeModule matrix: aMatrix
	^ self basicNew ambient: aFreeModule; matrix: aMatrix! !

!StandardBasis methodsFor: 'accessing' stamp: 'len 5/7/2018 23:22:50'!
add: aPolynomial
	^ elements add: aPolynomial! !

!StandardBasis methodsFor: 'accessing' stamp: 'len 5/7/2018 23:21:31'!
addAll: aCollection
	^ elements addAll: aCollection! !

!StandardBasis methodsFor: 'accessing' stamp: 'len 5/7/2018 23:22:47'!
at: anInteger
	^ elements at: anInteger! !

!StandardBasis methodsFor: 'accessing' stamp: 'len 11/21/2015 00:10'!
first
	^ self at: 1! !

!StandardBasis methodsFor: 'accessing' stamp: 'len 1/23/2017 11:47:32'!
indeterminates
	^ self anyOne parent indeterminates! !

!StandardBasis methodsFor: 'accessing' stamp: 'len 1/23/2017 11:47:29'!
ordering
	"Answer the monomial ordering of the receiver."
	^ self anyOne parent ordering! !

!StandardBasis methodsFor: 'accessing' stamp: 'len 5/7/2018 23:21:22'!
size
	^ elements size! !

!StandardBasis methodsFor: 'enumerating' stamp: 'len 7/8/2016 20:57'!
apply: aMorphism
	| answer |
	answer _ self copyEmpty.
	self do: [:each| answer add: (aMorphism value: each)].
	^ answer! !

!StandardBasis methodsFor: 'enumerating' stamp: 'len 5/7/2018 23:21:19'!
do: aBlock
	elements do: aBlock! !

!StandardBasis methodsFor: 'copying' stamp: 'len 5/10/2018 08:03:11'!
copy
	"Answer a copy of the reciever."
	^ self class new elements: elements copy! !

!StandardBasis methodsFor: 'copying' stamp: 'len 11/20/2016 15:32:11'!
copyEmpty
	^ self class new! !

!StandardBasis methodsFor: 'copying' stamp: 'len 5/7/2018 23:23:29'!
copyWithout: aPolynomial
	^ self class new elements: (elements copyWithout: aPolynomial)! !

!StandardBasis methodsFor: 'operations' stamp: 'len 5/7/2018 23:20:48'!
elementAt: aTuple
	^ (1 to: aTuple size) sum: [:i| (self at: i) * (aTuple at: i)]! !

!StandardBasis methodsFor: 'operations' stamp: 'len 1/26/2017 22:51:21'!
leadingTerms
	"Answer the standard basis made of all leading monomials of polynomials in the receiver."
	| answer |
	answer _ self class new.
	self do: [:each| | lt | lt _ each leadingTerm. (answer reduces: lt) ifFalse: [answer add: lt]].
	^ answer! !

!StandardBasis methodsFor: 'operations' stamp: 'len 5/10/2018 18:26:16'!
macaulayMatrix
	| monomials |
	monomials _ Set new.
	self do: [:each| monomials addAll: each monomials].
	monomials _ monomials asSortedCollection: [:a :b| a >= b].
	^ self anyOne parent scalars matrix: self size @ monomials size evaluating: [:i :j| (self at: i) coefficientAt: (monomials at: j)]! !

!StandardBasis methodsFor: 'operations' stamp: 'len 5/10/2018 18:14:57'!
minimal
	"Answer the minimal Groebner basis of the receiver."
	| heads goods answer |
	self isMinimal ifTrue: [^ self].
	heads _ elements collect: [:each| each leadingMonomial].
	goods _ (1 to: heads size) asSet.
	heads withIndexDo: [:head :i|
		(goods anySatisfy: [:one| i ~= one and: [(heads at: one) | head]])
			ifTrue: [goods remove: i]].
	answer _ self class new.
	(goods asSortedCollection: [:a :b| "make it triangular for lex" (elements at: a) leadingMonomial >= (elements at: b) leadingMonomial])
		do: [:i| answer add: (elements at: i) monic].
	^ answer! !

!StandardBasis methodsFor: 'operations' stamp: 'len 5/10/2019 08:31:13'!
reduce1: aPolynomial 
	"Answer Mora's normal form of aPolynomial with respect to the receiver)."
	| h L M |
	h _ aPolynomial.
	L _ OrderedCollection withAll: self.
	([h isZero or: [(M _ L select: [:g| g leadingMonomial | h leadingMonomial]) isEmpty]])
		whileFalse:
			[| g |
			g _ M detectMin: [:each| each ecart].
			g ecart > h ecart ifTrue: [L add: h].
			h _ h - (g * (h leadingMonomial / g leadingMonomial) * (h leadingCoefficient / g leadingCoefficient))].
	^ h! !

!StandardBasis methodsFor: 'operations' stamp: 'len 1/26/2017 22:07:58'!
reduce: aPolynomial 
	"Answer Mora's normal form of aPolynomial with respect to the receiver."
	| h L lmh g ecartg |
	h _ aPolynomial.
	L _ OrderedCollection withAll: self.
	[h isZero ifTrue: [^ h].
	lmh _ h leadingMonomial.
	g _ nil.
	ecartg _ -1.
	L do: [:each|
		| ecart |
		(each leadingMonomial | lmh and: [ecart _ each ecart. g isNil or: [ecart < ecartg]])
			ifTrue: [g _ each. ecartg _ ecart]].
	g isNil ifTrue: [^ h].
	ecartg > h ecart ifTrue: [L add: h].
	h _ h - (g * (lmh / g leadingMonomial) * (h leadingCoefficient / g leadingCoefficient))] repeat! !

!StandardBasis methodsFor: 'operations' stamp: 'len 5/11/2018 06:26:35'!
reduceFull: aPolynomial
	"In the general case of standard bases, this is the same as >>reduce:.
	It is reimplemented in GroebnerBasis."
	^ self reduce: aPolynomial! !

!StandardBasis methodsFor: 'operations' stamp: 'len 5/12/2018 17:54:24'!
reduceFull: aPolynomial startingAt: startIndex
	"In the general case of standard bases, this is the same as >>reduce:.
	It is reimplemented in GroebnerBasis."
	^ self reduce: aPolynomial! !

!StandardBasis methodsFor: 'operations' stamp: 'len 5/10/2018 18:11:33'!
reduced
	"Answer a reduced basis for the ideal generated by the receivr.
	Becker, Weispfenning, 'Groebner Bases', algorithm REDGROEBNER (p. 216) and REDUCTION (p. 203)."
	| G H |
	H _ OrderedCollection new.
	1 to: self size do: [:i| | fi lm |
		fi _ self at: i.
		lm _ fi leadingMonomial.
		(((i+1 to: self size) noneSatisfy: [:j| (self at: j) leadingMonomial | lm])
			and: [H noneSatisfy: [:h| h leadingMonomial | lm]])
				ifTrue: [H add: fi]].
	H _ H asArray.
	G _ self class new.
	1 to: H size do: [:i| | hi r |
		hi _ H at: i.
		(r _ hi \\ (H copyWithoutIndex: i)) isZero ifFalse: [G add: r monic]].
	G sort: [:a :b| a leadingMonomial >= b leadingMonomial]. "make it triangular for lex"
	^ G! !

!StandardBasis methodsFor: 'accessing-private' stamp: 'len 5/7/2018 23:23:36'!
elements: aCollection
	elements _ aCollection! !

!StandardBasis methodsFor: 'initialization' stamp: 'len 5/10/2018 08:03:16'!
initialize
"	elements _ SortedCollection sortBlock: [:a :b| a degree <= b degree]."
"	elements _ SortedCollection sortBlock: [:a :b| a leadingMonomial <= b leadingMonomial]."
	elements _ OrderedCollection new! !

!StandardBasis methodsFor: 'testing' stamp: 'len 5/10/2018 17:16:20'!
isMinimal
	"A Groebner basis G of an ideal I is called 'minimal' if the lead terms of the elements in G minimally generate in(I); or equivalently, if for all p in G:
	- LC(p) = 1, and
	- LT(p) is not in <G-{p}> (i.e., leading-term-minimal).
	Note that any leading-term-minimal Groebner basis is also cardinality-minimal."
	| one |
	one _ self first scalars one.
	self do: [:g| g leadingCoefficient ~= one ifTrue: [^ false]].
	self do: [:g|
		self do: [:f|
			(f ~~ g and: [f leadingMonomial | g leadingMonomial]) ifTrue: [^ false]]].
	^ true! !

!StandardBasis methodsFor: 'testing' stamp: 'len 5/10/2018 03:10:42'!
isMinimal2
	"A Groebner basis G is minimal when for all p in G:
	1. LC(p) = 1;
	2. LT(p) is not in <G-{p}>."
	| one |
	one _ self first scalars one.
	"Check all polynomials are monic:"
	self do: [:each| each leadingCoefficient ~= one ifTrue: [^ false]].
	self do: [:each| "Check if the basis without it still generates its leading term:"
		((self copyWithout: each) reduces: each leadingTerm)
				ifTrue: [^ false]].
	^ true! !

!StandardBasis methodsFor: 'testing' stamp: 'len 5/10/2018 17:18:12'!
isReduced
	"A Groebner basis G is called 'reduced' (or 'auto-reduced') if for all p in G:
	- LC(p) = 1, and
	- no monomial of p is in <G-{p}>.
	In particular, a reduced Groebner basis is leading-term-minimal (no leading term of any generator divides any other generator's leading term), and a leading-term-minimal basis is also cardinality-minimal."
	| one |
	one _ self first scalars one.
	self do: [:g| g leadingCoefficient ~= one ifTrue: [^ false]].
	self do: [:g|
		g monomials do: [:gi|
			self do: [:f|
				(f ~~ g and: [f leadingMonomial | gi]) ifTrue: [^ false]]]].
	^ true! !

!StandardBasis methodsFor: 'testing' stamp: 'len 5/9/2018 23:21:42'!
isReduced2
	"A Groebner basis G is reduced when for all p in G:
	1. LC(p) = 1;
	2. No monomial of p is contained in <G-{p}>."
	| one subBasis |
	one _ self first scalars one.
	"Check all polynomials are monic:"
	self do: [:each| each leadingCoefficient ~= one ifTrue: [^ false]].
	self do: [:each| "Check if the basis without it still generates its monomials:"
		subBasis _ self copyWithout: each.
		(each terms allSatisfy: [:other| subBasis reduces: other]) ifTrue: [^ false]].
	^ true! !

!StandardBasis methodsFor: 'testing' stamp: 'len 5/7/2018 23:21:47'!
isTrivial
	"Answer true if the basis is {1}."
	^ elements size = 1 and: [elements first isConstant and: [elements first isMonic]]
"	^ elements anySatisfy: [:f| f isConstant]"! !

!StandardBasis methodsFor: 'testing' stamp: 'len 10/29/2016 16:36'!
reduces: aPolynomial
	^ (self reduce: aPolynomial) isZero! !

!StandardBasis methodsFor: 'sorting' stamp: 'len 5/10/2018 17:52:05'!
sort: aBlock
	elements sort: aBlock! !

!StandardBasis methodsFor: 'private' stamp: 'len 3/6/2016 20:37'!
species
	^ Array! !

!StandardBasis methodsFor: 'private' stamp: 'len 5/10/2018 06:27:11'!
verify
	1 to: self size do: [:i| | fi |
		fi _ self at: i.
		i+1 to: self size do: [:j| | fj |
			fj _ self at: j.
			(self reduces: (fi s: fj))
				ifFalse: [^ false]]].
	^ true! !

!GroebnerBasis methodsFor: 'operations' stamp: 'len 4/9/2018 20:07:31'!
coordinatesOf: aPolynomial
	^ (MultivariatePolynomialDivision divide: aPolynomial by: self) quotients! !

!GroebnerBasis methodsFor: 'operations' stamp: 'len 4/9/2018 20:07:38'!
reduce2: aPolynomial 
	"Answer the remainder of the argument when divided by the receiver (i.e. the normal form with respect to the receiver)."
	| division |
	division _ MultivariatePolynomialDivision divide: aPolynomial by: self.
"	division verify ifFalse: [self halt]."
	^ division remainder! !

!GroebnerBasis methodsFor: 'operations' stamp: 'len 5/11/2018 06:45:06'!
reduce: aPolynomial
	"Answer a top-reduced normal form of aPolynomial with respect to the receiver (i.e. without doing tail reduction)."
	| h |
	h _ aPolynomial.
	[h isZero]
		whileFalse:
			[| lmh lmg g |
			lmh _ h leadingMonomial.
			g _ elements detect: [:one| (lmg _ one leadingMonomial) | lmh] ifNone: [^ h].
			h _ h - (g * (lmh / lmg) * (h leadingCoefficient / g leadingCoefficient))].
	^ h! !

!GroebnerBasis methodsFor: 'operations' stamp: 'len 5/12/2018 17:56:55'!
reduce: aPolynomial startingAt: startIndex
	"Answer a top-reduced normal form of aPolynomial with respect to the receiver (.e. without doing tail reduction)."
	| h |
	h _ aPolynomial.
	[h isZero]
		whileFalse:
			[| lmh lmg g |
			lmh _ h leadingMonomial.
			(startIndex to: elements size) detect: [:one| (lmg _ (g _ elements at: one) leadingMonomial) | lmh] ifNone: [^ h].
			h _ h - (g * (lmh / lmg) * (h leadingCoefficient / g leadingCoefficient))].
	^ h! !

!GroebnerBasis methodsFor: 'operations' stamp: 'len 5/11/2018 06:50:34'!
reduceFull: aPolynomial
	"Answer the tail-reduced normal form of aPolynomial with respect to the receiver (doing full tail reduction)."
	| g h |
	g _ aPolynomial.
	h _ g zero.
	[g isZero]
		whileFalse:
			[g _ self reduce: g.
			g isZero ifFalse: [h _ h + g leadingTerm. g _ g tail]].
	^ h / h leadingCoefficient! !

!GroebnerBasis methodsFor: 'operations' stamp: 'len 5/12/2018 17:54:55'!
reduceFull: aPolynomial startingAt: startIndex
	"Answer the tail-reduced normal form of aPolynomial with respect to the receiver (doing full tail reduction)."
	| g h |
	g _ aPolynomial.
	h _ g zero.
	[g isZero]
		whileFalse:
			[g _ self reduce: g startingAt: startIndex.
			g isZero ifFalse: [h _ h + g leadingTerm. g _ g tail]].
	^ h / h leadingCoefficient! !

!KeyedSet methodsFor: 'accessing' stamp: 'len 2/26/2016 21:26'!
at: anObject
	"Answer an object in the receiver that is equal to anObject,
	nil if no such object is found. Relies heavily on hash properties"
	| index |
	^(index _ self scanFor: anObject) = 0 ifFalse: [array at: index]! !

!KeyedSet methodsFor: 'accessing' stamp: 'len 2/26/2016 23:16'!
at: anObject ifAbsent: exceptionBlock
	| index |
	^ ((index _ self scanFor: anObject) = 0 ifFalse: [array at: index]) ifNil: exceptionBlock! !

!KeyedSet methodsFor: 'accessing' stamp: 'len 2/26/2016 21:31'!
at: anObject ifAbsentPut: aBlock
	"Answer an object in the receiver that is equal to anObject, or evaluate aBlock to get one and add it to the receiver,
	Relies heavily on hash properties, it is important that the following holds: aBlock value = anObject."
	| index |
	anObject ifNil: [self error: 'Sets cannot meaningfully contain nil as an element'].
	index _ self findElementOrNil: anObject.
	^ (array at: index) ifNil: [self atNewIndex: index put: aBlock value]! !

!Iterator methodsFor: 'adding'!
add: anObject
	"Iterators are read-only"
	self shouldNotImplement! !

!Iterator methodsFor: 'private'!
block: aBlock
	block := aBlock! !

!Iterator methodsFor: 'private'!
species
	^OrderedCollection! !

!Iterator methodsFor: 'enumerating'!
do: aBlock
	block value: aBlock! !

!Iterator methodsFor: 'enumerating'!
findFirst: aBlock
	"Answer the index of the first element of the receiver
	for which aBlock evaluates as true."

	| index |
	index := 1.
	self do: [ :el | (aBlock value: el) ifTrue: [^index].  index := index + 1].
	^0! !

!Iterator methodsFor: 'enumerating'!
findLast: aBlock
	"Answer the index of the last element of the receiver
	for which aBlock evaluates as true."

	| index last |
	index := 1.
	last := 0.
	self do: [ :el | (aBlock value: el) ifTrue: [last := index].  index := index + 1].
	^last! !

!Iterator methodsFor: 'enumerating'!
keysAndValuesDo: aBlock  
	"Evaluate aBlock with each of the receiver's key/value pairs
	(e.g. indexes and elements) as the arguments."

	| index |
	index := 1.
	self do: [:el | aBlock value: index value: el.  index := index + 1]! !

!Iterator methodsFor: 'copying' stamp: 'len 10/27/2016 15:39'!
first: n
	"Answer the first n elements of the receiver.
	Raise an error if there are not enough elements."
	| answer |
	answer _ self species new: n.
	self do: [:each|
		answer size = n ifTrue: [^ answer].
		answer add: each].
	^ self error: 'not enough elements'! !

!Iterator methodsFor: 'accessing'!
identityIndexOf: anElement 
	"Answer the identity index of anElement within the receiver.  If the receiver does
	not contain anElement, answer 0."

	^self identityIndexOf: anElement ifAbsent: [0]! !

!Iterator methodsFor: 'accessing'!
identityIndexOf: anElement ifAbsent: exceptionBlock 
	"Answer the identity index of anElement within the receiver.  If the receiver does
	not contain anElement, answer the result of evaluating the exceptionBlock."

	| index |
	index := 1.
	self do: [ :el | el == anElement ifTrue: [^index].  index := index + 1].
	^exceptionBlock value! !

!Iterator methodsFor: 'accessing'!
indexOf: anElement 
	"Answer the index of anElement within the receiver.  If the receiver does
	not contain anElement, answer 0."

	^self indexOf: anElement ifAbsent: [0]! !

!Iterator methodsFor: 'accessing'!
indexOf: anElement ifAbsent: exceptionBlock 
	"Answer the index of anElement within the receiver.  If the receiver does
	not contain anElement, answer the result of evaluating the exceptionBlock."

	| index |
	index := 1.
	self do: [ :el | el = anElement ifTrue: [^index].  index := index + 1].
	^exceptionBlock value! !

!Iterator methodsFor: 'removing'!
remove: oldObject ifAbsent: anExceptionBlock 
	"Iterators are read-only."
	self shouldNotImplement! !

!Iterator class methodsFor: 'instance creation' stamp: 'len 2/28/2016 20:32'!
on: aBlock
	^ self new block: aBlock! !

!Iterator class methodsFor: 'instance creation' stamp: 'len 2/14/2016 21:45'!
on: anObject performing: aSymbol
	^ self new block: [:aBlock| anObject perform: aSymbol with: aBlock]! !

!Graph methodsFor: 'operations' stamp: 'len 2/17/2017 07:41:42'!
* aGraph
	"Answer the graph with all edges that connect the vertices of the receiver with the vertices of the argument. This is a commutative operation (for unlabeled graphs)."
	^ self join: aGraph! !

!Graph methodsFor: 'operations' stamp: 'len 5/10/2019 04:36:17'!
+ aGraphOrEdge
	"Answer the dijoint union of the receiver with the argument. Assume they are disjoint."
	(aGraphOrEdge isKindOf: Association)
		ifFalse: [^ self \/ aGraphOrEdge].
	(self hasEdge: aGraphOrEdge)
		ifFalse: [^ self copy addEdge: aGraphOrEdge; yourself]! !

!Graph methodsFor: 'operations' stamp: 'len 7/13/2016 22:04'!
- anEdge
	"Answer the graph obtained by removing anEdge."
	(self hasEdge: anEdge)
		ifTrue: [^ self copy removeEdge: anEdge; yourself]! !

!Graph methodsFor: 'operations' stamp: 'len 7/13/2016 22:05'!
/ anEdge
	"Answer the graph obtained by contracting the given edge a -> b, by removing the edge and collapsing a with b in a single node."

	| answer newNode found |
	(self hasEdge: anEdge) ifFalse: [^ self].
	answer _ self copyEmpty.
	newNode _ anEdge.
	answer add: newNode.
	self nodesDo: [:each| (each = anEdge key or: [each = anEdge value]) ifFalse: [answer add: each]].
	found _ false.
	self edgesDo: [:each|
		(each = anEdge and: [found not])
			ifTrue: [found _ true]
			ifFalse:
				[| e |
				e _ each.
				(e key = anEdge key or: [e key = anEdge value])
					ifTrue: [e _ newNode -> e value].
				(e value = anEdge key or: [e value = anEdge value])
					ifTrue: [e _ e key -> newNode].
				answer addEdge: e]].
	^ answer! !

!Graph methodsFor: 'operations' stamp: 'len 5/10/2019 04:27:18'!
/\ aGraph
	"Answer the graph whose vertices and edges is the intersection of the vertices and edges of the receiver and the argument."
	| answer |
	answer _ self copyEmpty.
	aGraph nodesDo: [:each|
		(self nodeAt: each ifAbsent: [])
			ifNotNil: [:node|
				answer add: each.
				each neighborsDo: [:n|
					(node hasEdgeTo: n)
						ifTrue: [answer addEdgeFrom: each to: n]]]].
	^ answer! !

!Graph methodsFor: 'operations' stamp: 'len 5/10/2019 04:27:27'!
\/ aGraph
	"Answer the graph whose vertices and edges are the union of the vertices and edges of the receiver and the argument."
	| answer |
	answer _ self copy.
	aGraph do: [:each| answer add: each].
	aGraph edgesDo: [:each| answer addEdgeFrom: each key to: each value].
	^ answer! !

!Graph methodsFor: 'operations' stamp: 'len 12/30/2017 16:16:58'!
 aGraph
	"Answer the cartesian product of the receiver with the argument. This is a commutative and associative operation (for unlabeled graphs)."
	| G |
	G _ self copyEmpty.
	self do: [:x| aGraph do: [:y| G add: (x, y)]].
	self do: [:x| aGraph edgesDo: [:e| G addEdgeFrom: (x, e key) to: (x, e value)]].
	self edgesDo: [:e| aGraph do: [:y| G addEdgeFrom: (e key, y) to: (e value, y)]].
	^ G! !

!Graph methodsFor: 'operations' stamp: 'len 5/14/2019 20:49:36'!
 aGraph
	"Answer the tensor product (or direct graph product, categorical graph product, cardinal graph product, Kronecker graph product) of the receiver with the argument. This is a commutative operation (for unlabeled graphs)."
	| G |
	G _ self class ordered.
	self do: [:x| aGraph do: [:y| G add: (x, y)]].
	self edgesDo: [:e1|
		aGraph edgesDo: [:e2|
			G addEdgeFrom: (e1 key, e2 key) to: (e1 value, e2 value)]].
	^ G! !

!Graph methodsFor: 'operations' stamp: 'len 3/2/2017 19:57:31'!
adjacencyMatrix
	"Answer the adjacency matrix of the receiver, assuming that the vertices are the integers {1,..,n}.
	If the graph is labelled, use the labels as entries in the matrix."
	| n matrix |
	n _ self order.
	matrix _ (ZZ ^ (n@n)) zero.
	self edgesAndLabelsDo: [:edge :label| matrix at: edge key @ edge value add: (label ifNil: [1])].
	^ matrix! !

!Graph methodsFor: 'operations' stamp: 'len 7/19/2016 23:20'!
adjacencyMatrix: vertices
	"Answer the adjacency matrix of the receiver, using the vertex ordering given by the argument."
	^ ZZ ^ (vertices size @ vertices size) evaluating: [:i :j| self multiplicityFrom: (vertices at: i) to: (vertices at: j)]! !

!Graph methodsFor: 'operations' stamp: 'len 7/25/2016 02:32'!
automorphisms
	"Answer the group of symmetries of the receiver, i.e. the group of permutations of vertices that don't change the graph."
	^ (SymmetricGroup on: self values) select: [:each| (self apply: each) = self]! !

!Graph methodsFor: 'operations' stamp: 'len 7/25/2016 02:37'!
automorphismsWithInvariant: aBlock
	"Answer the group of symmetries of the receiver, i.e. the group of permutations of vertices that don't change the graph."
	| partition |
	partition _ Dictionary new.
	self nodesDo: [:each| (partition at: (aBlock value: each) ifAbsentPut: [OrderedCollection new]) add: each value].
	^ self automorphismsWithPartition: partition! !

!Graph methodsFor: 'operations' stamp: 'len 7/25/2016 02:46'!
automorphismsWithPartition: aCollection
	"Answer the group of symmetries of the receiver, i.e. the group of permutations of vertices that don't change the graph."
	| product automorphisms |
	product _ CartesianProduct components: (aCollection collect: [:each| SymmetricGroup on: each]).
	automorphisms _ OrderedCollection new.
	product do: [:each|
		| f |
		f _ each product.
		(self apply: f) = self ifTrue: [automorphisms add: f]].
	^ PermutationGroup on: self values elements: automorphisms! !

!Graph methodsFor: 'operations' stamp: 'len 7/13/2016 23:13'!
breadthFirstPath2From: origin to: target with: visitedNodes 
	| queue node nodesLevels |
	nodesLevels _ Dictionary new.
	nodesLevels at: origin value put: 0.
	queue _ OrderedCollection with: origin.
	visitedNodes add: origin.
	[queue isEmpty]
		whileFalse: [node _ queue removeFirst.
			node neighborsDo:
				[:each | (visitedNodes includes: each)
						ifFalse: [queue addLast: each.
							visitedNodes add: each.
							nodesLevels at: each value put: (nodesLevels at: node value)
									+ 1.
							each = target
								ifTrue: [^ nodesLevels at: each value]]]].
	"No path From origin to target, i.e. the two subgraph are not conected"
	^ 0! !

!Graph methodsFor: 'operations' stamp: 'len 7/13/2016 23:13'!
breadthFirstPathFrom: source to: target 
	| visitedNodes |
	(source isLeaf
			or: [target isLeaf])
		ifTrue: [^ 0]
		ifFalse: [visitedNodes _ Set new.
			^ self
				breadthFirstPath2From: source
				to: target
				with: visitedNodes]! !

!Graph methodsFor: 'operations' stamp: 'len 7/13/2016 23:13'!
breadthFirstPathFrom: origin to: target with: visitedNodes 
	| queue node nodesLevels |
	nodesLevels _ Bag new.
	queue _ OrderedCollection with: origin.
	visitedNodes add: origin.
	[queue isEmpty]
		whileFalse: [node _ queue removeFirst.
			node neighborsDo:
				[:each | (visitedNodes includes: each)
						ifFalse: [queue addLast: each.
							visitedNodes add: each.
							nodesLevels add: each withOccurrences: (nodesLevels occurrencesOf: node)
									+ 1.
							each = target
								ifTrue: [^ nodesLevels occurrencesOf: each]]]].
	"No path From origin to target, i.e. the two subgraph are not conected"
	^ 0! !

!Graph methodsFor: 'operations' stamp: 'len 7/13/2016 22:06'!
center
	"Answer the center of the receiver, i.e. the subset of vertices with maximal eccentricity.
	Using Dijsktra shortest path algorithm this computation requires time O(|V|^3)."
	| radius |
	radius _ self radius.
	^ self values select: [:each| (self eccentricityOf: each) = radius]! !

!Graph methodsFor: 'operations' stamp: 'len 7/13/2016 22:06'!
chromaticNumber
	"The minimum number of colors to do a proper coloring of the graph."
	| chi |
	chi _ self chromaticPolynomial.
	^ (1 to: self size) detect: [:i| (chi value: i) > 0]! !

!Graph methodsFor: 'operations' stamp: 'len 7/15/2016 18:23'!
chromaticPolynomial
	"The chromatic polynomial P(G,k) is a polynomial in k that counts the number of k-colorings of G."
	^ self chromaticPolynomialAt: ZZ polynomials x! !

!Graph methodsFor: 'operations' stamp: 'len 7/14/2016 06:50'!
chromaticPolynomialAt: k
	"The chromatic polynomial P(G,k) is a polynomial in k that counts the number of k-colorings of G. Answer the evaluation at k."
	self isEdgeless ifTrue: [^ k ^ self size].
	self edgesDo: [:each|
		each key = each value
			ifFalse: [^ ((self - each) chromaticPolynomialAt: k) - ((self / each) chromaticPolynomialAt: k)]].
	^ k*0! !

!Graph methodsFor: 'operations' stamp: 'len 7/13/2016 22:06'!
circumference
	"Answer the length of the longest cycle."
	^ self notYetImplemented! !

!Graph methodsFor: 'operations' stamp: 'len 7/13/2016 22:06'!
components
	"Answer the Strongly Connected Components of the receiver."
	^ Set accumulate: [:aBlock | self componentsDo: aBlock]! !

!Graph methodsFor: 'operations' stamp: 'len 7/13/2016 22:07'!
diameter
	^ self nodes max: [:each| self eccentricityOf: each]! !

!Graph methodsFor: 'operations' stamp: 'len 7/13/2016 23:05'!
distanceFrom: source to: target
	^ (Dijkstra graph: self source: source) distanceTo: target! !

!Graph methodsFor: 'operations' stamp: 'len 7/13/2016 23:05'!
eccentricityOf: anObject
	^ (Dijkstra graph: self source: anObject) eccentricity! !

!Graph methodsFor: 'operations' stamp: 'len 7/13/2016 22:07'!
girth
	"Answer the length of the shortest cycle."
	^ self notYetImplemented! !

!Graph methodsFor: 'operations' stamp: 'len 7/20/2016 23:19'!
join: aGraph
	"Answer the graph with all edges that connect the vertices of the receiver with the vertices of the argument. This is a commutative operation (for unlabeled graphs)."
	| answer |
	answer _ self copyEmpty.
	self edgesDo: [:each| (aGraph includes: each value) ifTrue: [answer addEdge: each]].
	aGraph edgesDo: [:each| (self includes: each key) ifTrue: [answer addEdge: each]].
	^ answer! !

!Graph methodsFor: 'operations' stamp: 'len 7/20/2016 23:54'!
line
	"Answer the line graph of the receiver, i.e. the graph L(G) such that:
	 - each edge of G is a vertex of L(G);
	 - if two edges of G share a common endpoint, the correspondng vertices in L(G) are connected." 
	| answer |
	self flag: #fix.
	answer _ self copyEmpty.
	self fullEdgesDo: [:each| "each contains GraphNodes, not values"
		each value neighborsDo: [:n|
			answer addEdgeFrom: each to: (Association key: each value value value: n value)]].
	^ answer! !

!Graph methodsFor: 'operations' stamp: 'len 7/13/2016 22:08'!
maxmimumDegree
	^ self nodes inject: Infinity negative into: [:maximum :each| maximum max: each degree]! !

!Graph methodsFor: 'operations' stamp: 'len 7/13/2016 22:08'!
minimumDegree
	^ self nodes inject: Infinity positive into: [:minimum :each| minimum min: each degree]! !

!Graph methodsFor: 'operations' stamp: 'len 7/13/2016 22:08'!
multiplicity
	^ self edges max: [:each| self multiplicityFrom: each key to: each value]! !

!Graph methodsFor: 'operations' stamp: 'len 7/13/2016 22:08'!
multiplicityFrom: source to: target
	^ (self nodeAt: source) neighbors occurrencesOf: target! !

!Graph methodsFor: 'operations' stamp: 'len 7/20/2016 23:22'!
neighborhoodOf: node
	"Answer the subgraph of everything that is reachable from the given vertex."
	^ self subgraphInducedBy: (self nodeAt: node) neighbors! !

!Graph methodsFor: 'operations' stamp: 'len 7/25/2016 08:47'!
quotient
	| Q |
	self isLabeled ifFalse: [DomainError signal: 'not a lebeled graph'].
	Q _ self copyEmpty.
	self nodesDo: [:each| Q add: each label].
	self fullEdgesAndLabelsDo: [:each :label| Q addEdgeFrom: each key label to: each value label label: label].
	^ Q! !

!Graph methodsFor: 'operations' stamp: 'len 7/13/2016 22:08'!
radius
	^ self nodes min: [:each| self eccentricityOf: each]
"	^ (FloydWarshall graph: self) radius"! !

!Graph methodsFor: 'operations' stamp: 'len 7/20/2016 23:47'!
reflexive
	"Answer the reflexive closure of the receiver."
	| answer |
	answer _ self copy.
	answer nodesDo: [:each | each hasLoop ifFalse: [answer addEdgeFrom: each to: each]].
	^ answer! !

!Graph methodsFor: 'operations' stamp: 'len 7/13/2016 23:05'!
shortestPathFrom: source to: target
	^ (Dijkstra graph: self source: source) shortestPathTo: target! !

!Graph methodsFor: 'operations' stamp: 'len 7/20/2016 23:55'!
subgraphInducedBy: aSet
	"Answer the subgraph induces by aSet of vertices."
	| answer |
	answer _ self copy.
	self edgesDo: [:each|
		((aSet includes: each key) and: [aSet includes: each value])
			ifTrue: [answer addEdge: each]].
	^ answer! !

!Graph methodsFor: 'operations' stamp: 'len 7/13/2016 23:06'!
symmetric
	"Answer the symmetric closure of the receiver."
	| answer |
	answer _ self copy.
	self edgesDo: [:each | answer addEdge: (Association key: each value value: each key)].
	^ answer! !

!Graph methodsFor: 'operations' stamp: 'len 7/13/2016 22:12'!
topologicalSort
	"Answer a topological sort of the receiver. This is a linear ordering of its vertices such that for each edge a -> b, a comes before to b in the ordering.
	This is Kahn's algorithm."
	| answer G S n |
	answer _ OrderedCollection new.
	G _ self copy.
	S _ G nodes select: [:each| each inDegree = 0].
	[S notEmpty]
		whileTrue:
			[n _ S anyOne.
			S remove: n.
			answer add: n.
			n neighbors do: [:m|
				n removeNeighbor: m.
				m inDegree = 0 ifTrue: [S add: m]]].
	G isEdgeless ifFalse: [^ self error: 'the graph has at least one cycle'].
	^ answer! !

!Graph methodsFor: 'operations' stamp: 'len 7/13/2016 23:06'!
transposed
	"Answer the transpose of the receiver. This is the graphs where edges a->b are inverted as b->a."
	| answer |
	answer _ self copyEmpty.
	self edgesDo: [:each | answer addEdge: (Association key: each value value: each key)].
	^ answer! !

!Graph methodsFor: 'comparing' stamp: 'len 8/12/2016 21:18'!
< aGraph
	"Answer true if the receiver is a proper subgraph of aGraph."
	(aGraph isKindOf: self species) ifFalse: [^ aGraph >= self].
	self size < aGraph size ifFalse: [^ false].
	self nodesDo: [:each|
		| node |
		(aGraph includes: each value) ifFalse: [^ false].
		node _ aGraph nodeAt: each value.
		each neighborsDo: [:n| (node hasEdgeTo: n value) ifFalse: [^ false]]].
	^ true! !

!Graph methodsFor: 'comparing' stamp: 'len 8/12/2016 21:45'!
<= aGraph
	"Answer true if the receiver is a subgraph of aGraph."
	(aGraph isKindOf: self species) ifFalse: [^ aGraph >= self].
	self size <= aGraph size ifFalse: [^ false].
	self nodesDo: [:each|
		| node |
		(aGraph includes: each value) ifFalse: [^ false].
		node _ aGraph nodeAt: each value.
		each neighborsDo: [:n| (node hasEdgeTo: n value) ifFalse: [^ false]]].
	^ true! !

!Graph methodsFor: 'comparing' stamp: 'len 7/21/2016 00:07'!
= aGraph
	^ (aGraph isKindOf: self species) and: [self nodes = aGraph nodes and: [self edges asBag = aGraph edges asBag]]! !

!Graph methodsFor: 'comparing' stamp: 'len 8/12/2016 21:47'!
> aGraph
	"Answer true if aGraph is a proper subgraph of the receiver."
	^ aGraph < self! !

!Graph methodsFor: 'comparing' stamp: 'len 8/12/2016 21:47'!
>= aGraph
	"Answer true if aGraph is a subgraph of the receiver."
	^ aGraph <= self! !

!Graph methodsFor: 'comparing' stamp: 'len 7/23/2016 04:06'!
~ aGraph
	"Answer true if the receiver is isomorphic to aGraph."
	| n G H |
	self isLabeled ifTrue: [self notYetImplemented].
	self species = aGraph species ifFalse: [^ false].
	(n _ self size) = aGraph size ifFalse: [^ false].
	"we could insert some heuristic tests here, comparing easy-to-compute invariants"
	G _ self asStandard.
	H _ aGraph asStandard.
	(SymmetricGroup new: n) do: [:each| (G apply: each) = H ifTrue: [^ true]].
	^ false! !

!Graph methodsFor: 'comparing' stamp: 'len 7/13/2016 21:58'!
hash
	^ self nodes hash! !

!Graph methodsFor: 'adding/removing' stamp: 'len 7/13/2016 21:55'!
addEdge: edge 
	"Add an edge (represented by an Association)."

	self addEdgeFrom: edge key to: edge value.
	^ edge! !

!Graph methodsFor: 'adding/removing' stamp: 'len 7/13/2016 21:55'!
addEdge: edge label: label
	"Add an edge (represented by an Association), with given label.
	pre: (self nodeAt: edge key) isLabeled"

	self addEdgeFrom: edge key to: edge value label: label.
	^edge! !

!Graph methodsFor: 'adding/removing' stamp: 'len 7/13/2016 23:54'!
addEdges: aCollection
	aCollection do: [:each| self addEdge: each].
	^ aCollection! !

!Graph methodsFor: 'adding/removing' stamp: 'len 7/13/2016 22:17'!
removeEdge: anEdge
	"Remove the given edge.
	pre: the edge must be in the graph."
	self removeEdge: anEdge ifAbsent: [self errorNotFound: anEdge]! !

!Graph methodsFor: 'adding/removing' stamp: 'len 7/13/2016 22:16'!
removeEdge: edge ifAbsent: exceptionBlock 
	"Remove the given edge, evaluate exceptionBlock if it doesn't exist.
	pre: both the source and target of the edge must be in the graph."
	^self removeEdgeFrom: edge key to: edge value ifAbsent: exceptionBlock! !

!Graph methodsFor: 'adding/removing' stamp: 'len 7/13/2016 22:17'!
removeEdgeFrom: src to: dest
	"Remove the given edge.
	pre: the edge must be in the graph."
	^self removeEdgeFrom: src to: dest ifAbsent: [self errorNotFound: src -> dest]! !

!Graph methodsFor: 'enumerating' stamp: 'len 5/13/2019 17:13:12'!
apply: aFunction
	"Answer the homomorphic image of the receiver, i.e. a new graph like the receiver but with vertices values mapped by aFunction."
	^ self collect: aFunction! !

!Graph methodsFor: 'enumerating' stamp: 'len 7/13/2016 22:03'!
collect: aBlock
	"Answer a new graph like the receiver but with vertices values mapped by aBlock."
	| answer |
	answer _ self copyEmpty.
	self nodesDo: [:each| answer add: (aBlock value: each value)].
	self edgesDo: [:each| answer addEdgeFrom: (aBlock value: each key) to: (aBlock value: each value)].
	^ answer! !

!Graph methodsFor: 'enumerating' stamp: 'len 7/20/2016 23:50'!
collect: aBlock labels: labelBlock
	"Answer a new graph like the receiver but with vertices values mapped by aBlock."
	| answer |
	answer _ self copyEmpty.
	self do: [:each| answer add: (aBlock value: each)].
	self edgesAndLabelsDo: [:each :label| answer addEdgeFrom: (aBlock value: each key) to: (aBlock value: each value) label: (labelBlock value: label)].
	^ answer! !

!Graph methodsFor: 'enumerating' stamp: 'len 7/20/2016 23:34'!
do: aBlock
	"Iterate over the vertices of the receiver (the values, not GraphNodes)."
	self nodesDo: [:each| aBlock value: each value]! !

!Graph methodsFor: 'enumerating' stamp: 'len 7/20/2016 23:54'!
select: aBlock
	"Answer the subgraph of the receiver whose vertices satisfy aBlock."
	| answer |
	answer _ self copyEmpty.
	self do: [:each| (aBlock value: each) ifTrue: [answer add: each]].
	self edgesDo: [:each|
		((aBlock value: each key) and: [aBlock value: each value])
			ifTrue: [answer addEdgeFrom: each key to: each value]].
	^ answer! !

!Graph methodsFor: 'converting' stamp: 'len 7/30/2016 07:33'!
asMorph
	| answer components |
	(components _ self components) size = 1
		ifTrue: [^ SpringGraphMorph new graph: self].
	answer _ CompositeGraphMorph newRow.
	components do: [:each|
		answer addComponent: (SpringGraphMorph new graph: each)].
	^ answer! !

!Graph methodsFor: 'converting' stamp: 'len 7/21/2016 02:12'!
asStandard
	^ self asStandard: self values asArray! !

!Graph methodsFor: 'converting' stamp: 'len 7/21/2016 02:12'!
asStandard: verticesArray
	^ self collect: [:each| verticesArray indexOf: each]! !

!Graph methodsFor: 'statistics' stamp: 'len 7/13/2016 23:11'!
averageDegree
	"The average degree of the graph."
	"^ 2 * self numberOfEdges / self size"
	| sum |
	sum _ self nodes sum: [:node | node degree].
	^ sum / self size! !

!Graph methodsFor: 'statistics' stamp: 'len 7/13/2016 23:11'!
averagePathLength
	"The average path length of the graph."
	| sum n progress max |
	self flag: #bug. "bug with implicit graph since nodes are labelled with integer"
	sum := 0.
	n := 2.
	max := (self order * (self order - 1) / 2) asFloat.
	"p _ 1 / self order."
	progress := ProgressMorph label: 'Average path length progress'.
	progress submorphs first color: Color paleGreen lighter lighter lighter.
	progress submorphs first borderWidth: 1.
	progress openInWorld.
	self
		nodesDo: [:node1 | 
			n
				to: self order
				do: [:node2 | sum := sum
								+ (self
										breadthFirstPathFrom: node1
										to: (self nodeAt: node2))].
			n := n + 1.
			progress incrDone: self order - n / max].
	progress delete.
	^ (sum / max) asFloat! !

!Graph methodsFor: 'statistics' stamp: 'len 7/13/2016 23:11'!
averagePathLength2
	"The average path length of the graph."
	| sum n max |
	sum := 0.
	n := 2.
	max := (self order * (self order - 1) / 2) asFloat.
	self
		nodesDo: [:node1 | 
			n
				to: self order
				do: [:node2 | sum := sum
								+ (self
										breadthFirstPathFrom: node1
										to: (self nodeAt: node2))].
			n := n + 1.].
	^ (sum / max) asFloat! !

!Graph methodsFor: 'statistics' stamp: 'len 7/13/2016 23:11'!
averagePathLengthAcuteAt
	"The aproximate average path length of the graph."
	| sum n progress p max nodesList |
	sum _ 0.
	n _ 2.
	max _ 0.
	progress _ ProgressMorph label: 'Average path length progress'.
	progress submorphs first color: Color paleGreen lighter lighter lighter.
	progress submorphs first borderWidth: 1.
	progress openInWorld.
	nodesList _ OrderedCollection new.
	(0.1 * self order) rounded
		timesRepeat: [nodesList
				add: self nodes atRandom].
	p _ 1 / nodesList size.
	nodesList
		do: [:node1 | 
			n
				to: nodesList size
				do: [:node2 | 
					max _ max + 1.
					sum _ sum
								+ (self
										breadthFirstPathFrom: node1
										to: (self nodeAt: node2))].
			n _ n + 1.
			progress incrDone: p].
	progress delete.
	^ (sum / max) asFloat! !

!Graph methodsFor: 'statistics' stamp: 'len 7/13/2016 23:11'!
averagePathLengthAcuteAt: percentage
	"The aproximate average path length of the graph."
	| sum n max nodesList |
	sum _ 0.
	n _ 2.
	max _ (self order * (self order - 1) / 2) asFloat.
	"p _ 1 / self order. 
	progress _ ProgressMorph label: 'Average path length progress'. 
	progress submorphs first color: Color paleGreen lighter lighter lighter. 
	progress submorphs first borderWidth: 1. 
	progress openInWorld."
	nodesList := OrderedCollection new.
	(percentage * self order) timesRepeat: [nodesList add: self nodes atRandom].
	nodesList
				do: [:node1 | 
					n
						to: nodesList size
						do: [:node2 | sum _ sum
										+ (self
												breadthFirstPathFrom: node1
												to: (self nodeAt: node2))].
					n _ n + 1].
	"progress delete."
	^ (sum / max) asFloat! !

!Graph methodsFor: 'statistics' stamp: 'len 7/13/2016 23:11'!
clusteringCoefficient
	| sum |
	sum _ 0.
	self nodesDo: [:node | node degree > 1 ifTrue: [sum _ sum + node clusteringCoefficient]].
	^ (sum / self order) asFloat! !

!Graph methodsFor: 'statistics' stamp: 'len 7/13/2016 23:11'!
degreeDistribution
	"The distribution degree of the graph."
	| b |
	b _ Bag new: self size.
	self nodesDo: [:each| b add: each degree].
	^ b frequencyDistribution! !

!Graph methodsFor: 'accessing' stamp: 'len 7/13/2016 21:53'!
degree
	self isEmpty ifTrue: [^ 0].
	^ self nodes max: [:each| each degree]! !

!Graph methodsFor: 'accessing' stamp: 'len 7/14/2016 08:36'!
density
	"Answer a measure of the graph density (vs sparsity), a number between 0 and 1.
	A graph is dense if the number of edges is close to the maximum (for the given number of vertices).
	pre: assume the graph is simple."
	| V E |
	V _ self size.
	E _ self numberOfEdges.
	^ self isDirected ifTrue: [2*E/(V*(V-1))] ifFalse: [E/(V*(V-1))]! !

!Graph methodsFor: 'accessing' stamp: 'len 7/13/2016 21:53'!
edges
	^ Iterator on: self performing: #edgesDo:! !

!Graph methodsFor: 'accessing' stamp: 'len 7/13/2016 22:24'!
nodeAt: anObject
	^ self nodeAt: anObject ifAbsent: [self errorNotFound: anObject]! !

!Graph methodsFor: 'accessing' stamp: 'len 7/13/2016 22:24'!
nodeAt: anObject ifAbsent: exceptionBlock
	^ self nodes at: anObject ifAbsent: exceptionBlock! !

!Graph methodsFor: 'accessing' stamp: 'len 7/13/2016 21:53'!
numberOfEdges
	"This is commonly known as the size of the graph, but the size message returns the order (number of vertices), as this fits in better with Smalltalk usage."
	| count |
	count _ 0.
	self nodesDo: [:each| count _ count + each neighbors size].
	^ count! !

!Graph methodsFor: 'accessing' stamp: 'len 7/13/2016 21:54'!
order
	"The size of a graph G=(V,E) is the number of vertices |V|, contrary to the more common convention of defining it as |E|."
	^ self size! !

!Graph methodsFor: 'accessing' stamp: 'len 7/13/2016 21:54'!
size
	"The size of a graph G=(V,E) is the number of vertices |V|, contrary to the more common convention of defining it as |E|."
	^ self nodes size! !

!Graph methodsFor: 'accessing' stamp: 'len 7/23/2016 04:32'!
values
	"Answer the set of vertices of the receievr ('values', as opposed to 'nodes' which are GraphNodes)."
	^ self nodes collect: [:each| each value]! !

!Graph methodsFor: 'random' stamp: 'len 7/13/2016 23:14'!
edgeAtRandom
	^ Random withDefaultDo: [:aRandom| self edgeAtRandom: aRandom]! !

!Graph methodsFor: 'random' stamp: 'len 7/21/2016 01:53'!
shuffled
	^ Random withDefaultDo: [:aRandom| self shuffledBy: aRandom]! !

!Graph methodsFor: 'random' stamp: 'len 7/21/2016 01:53'!
shuffledBy: aRandom
	^ self collect: ((SymmetricGroup on: self values) atRandom: aRandom)! !

!Graph methodsFor: 'testing' stamp: 'len 7/13/2016 22:31'!
hasEdge: edge
	^ self hasEdgeFrom: edge key to: edge value! !

!Graph methodsFor: 'testing' stamp: 'len 7/29/2016 06:34'!
hasEdgeFrom: a to: b
	^ (self nodeAt: a ifAbsent: [^ false]) hasEdgeTo: b! !

!Graph methodsFor: 'testing' stamp: 'len 7/13/2016 22:31'!
hasLoop
	self nodesDo: [:each| each hasLoop ifTrue: [^ true]].
	^ false! !

!Graph methodsFor: 'testing' stamp: 'len 7/13/2016 22:32'!
includes: anObject
	"Answer whether anObject is one of the vertices of the receiver."
	^ self nodes includes: anObject! !

!Graph methodsFor: 'testing' stamp: 'len 7/13/2016 22:32'!
isChain
	"Answer whether the graph is a chain - path graph."
	^ (self select: [:each| each isAnExtremity]) size + (self select:[:each| each isMiddle]) size = self order! !

!Graph methodsFor: 'testing' stamp: 'len 7/13/2016 22:32'!
isComplete
	self nodesDo: [:x| self nodesDo: [:y| (x hasEdgeTo: y) ifFalse: [^ false]]].
	^ true! !

!Graph methodsFor: 'testing' stamp: 'len 7/13/2016 22:33'!
isConnected
	| count |
	count _ 0.
	self componentsDo: [:each| count _ count + 1. count > 1 ifTrue: [^ false]].
	^ true! !

!Graph methodsFor: 'testing' stamp: 'len 7/13/2016 22:33'!
isCubic
	^ self nodes allSatisfy: [:each| each degree = 3]! !

!Graph methodsFor: 'testing' stamp: 'len 7/13/2016 22:33'!
isCyclic
	[self topologicalSort] on: Error do: [^ true].
	^ false
"	| remainingNodes |
	remainingNodes _ self nodes copy.
	[remainingNodes isEmpty]
		whileFalse:
			[Transcript show: 'pick'; newLine.
			remainingNodes anyOne walkPre: [:each|
					Transcript show: each printString; newLine.
					remainingNodes remove: each ifAbsent: [^ true]] post: [:ignore]].
	Transcript show: 'done'; newLine.
	^ false"! !

!Graph methodsFor: 'testing' stamp: 'len 7/13/2016 22:33'!
isEdgeless
	^ self numberOfEdges = 0! !

!Graph methodsFor: 'testing' stamp: 'len 7/13/2016 22:33'!
isEmpty
	"Answer whether the receiver contains any elements."

	^ self nodes isEmpty! !

!Graph methodsFor: 'testing' stamp: 'len 7/29/2016 08:12'!
isEulerian
	"Answer true if the receiver has an Eurlerian path."
	| count |
	self flag: #fix. "it should be 'has an Eulerian circuit', and isSemiEulerian must be implemented."
	count _ 0.
	self nodesDo: [:each| each degree odd ifTrue: [(count _ count + 1) > 2 ifTrue: [^ false]]].
	^ count = 0 or: [count = 2]! !

!Graph methodsFor: 'testing' stamp: 'len 7/13/2016 22:33'!
isHamiltonian
	"Answer true if the receiver has a Hamiltonian cycle (or Hamiltonian circuit, vertex tour, or graph cycle), which is a cycle that visits each node once except for the start/end node that is visited twice."
	^ self closure isComplete "Bondy-Chvatai theorem"! !

!Graph methodsFor: 'testing' stamp: 'len 7/13/2016 22:34'!
isReflexive
	^ self nodes allSatisfy: [:each| each isReflexive]! !

!Graph methodsFor: 'testing' stamp: 'len 7/13/2016 22:34'!
isRegular
	| n |
	self isEmpty ifTrue: [^ true].
	n _ self nodes anyOne degree.
	^ self nodes allSatisfy: [:each| each degree = n]! !

!Graph methodsFor: 'testing' stamp: 'len 7/29/2016 08:11'!
isSemiEulerian
	"Answer true if the receiver has an Eurlerian path but not an Eulerian circuit."
	self notYetImplemented! !

!Graph methodsFor: 'testing' stamp: 'len 7/13/2016 22:34'!
isSimple
	"A graph is simple if doesn't countain multiple edges with the same endpoints."
	^ self nodes allSatisfy: [:each| each isSimple]! !

!Graph methodsFor: 'testing' stamp: 'len 7/13/2016 22:34'!
isTraceable
	"Answer true if the receiver has a Hamiltonian path (or traceable path), which is a path that visits each vertex exactly once."
	^ self notYetImplemented! !

!Graph methodsFor: 'testing' stamp: 'len 7/13/2016 22:37'!
isUndirected
	^ self isDirected not! !

!Graph class methodsFor: 'example graphs' stamp: 'len 7/20/2016 19:17'!
C: n
	"Answer the cycle of n vertices 1 -> 2 -> ... -> n -> 1."
	| C |
	C _ self unordered.
	1 to: n-1 do: [:i| C addEdge: i->(i+1)].
	n >= 1 ifTrue: [C addEdge: n -> 1]. "the extremal case of n = 1 is just a loop"
	^ C! !

!Graph class methodsFor: 'example graphs' stamp: 'len 7/14/2016 00:12'!
K: n
	"Answer the n-complete graph."
	| K |
	K _ self unordered.
	1 to: n do: [:i| K add: i].
	1 to: n do: [:i| 1 to: i do: [:j| i ~= j ifTrue: [K addEdge: i->j]]].
	^ K! !

!Graph class methodsFor: 'example graphs' stamp: 'len 7/13/2016 22:40'!
N: n
	"Answer the null graph with n vertices {1..n}."
	^ self unordered addAll: (1 to: n); yourself! !

!Graph class methodsFor: 'example graphs' stamp: 'len 7/20/2016 19:16'!
P: n
	"Answer the path of n vertices 1 -> 2 -> ... -> n."
	| P |
	n > 1 ifFalse: [self error: 'path graph only definted for >= 2 vertices'].
	P _ self unordered.
	1 to: n-1 do: [:i| P addEdge: i->(i+1)].
	^ P! !

!Graph class methodsFor: 'example graphs' stamp: 'len 7/13/2016 22:40'!
S: n
	"Answer the star graph of n vertices."
	| S |
	S _ self unordered.
	2 to: n do: [:i| S addEdge: 1 -> i].
	^ S! !

!Graph class methodsFor: 'example graphs' stamp: 'len 7/13/2016 22:40'!
W: n
	"Answer the wheel graph of n vertices."
	| W |
	W _ self unordered.
	2 to: n do: [:i| W addEdge: 1 -> i; addEdge: i -> (i=n ifTrue: [2] ifFalse: [i+1])].
	^ W! !

!Graph class methodsFor: 'example graphs' stamp: 'len 7/13/2016 22:40'!
cube
	^ self cube: 3! !

!Graph class methodsFor: 'example graphs' stamp: 'len 12/30/2017 16:17:15'!
cube: n
	"Answer an n-cube."
	| G H |
	G _ self unordered addEdge: 1 -> 2; yourself.
	H _ G.
	n - 1 timesRepeat: [H _ H  G].
	^ H! !

!Graph class methodsFor: 'example graphs' stamp: 'len 7/13/2016 22:40'!
desargues
	"Answer the Desargues graph."
	^ self petersen: 10 order: 3! !

!Graph class methodsFor: 'example graphs' stamp: 'len 7/13/2016 22:40'!
dodecahedron
	^ self petersen: 10 order: 2! !

!Graph class methodsFor: 'example graphs' stamp: 'len 7/13/2016 22:41'!
durer
	"Answer the Durer graph."
	^ self petersen: 6 order: 2! !

!Graph class methodsFor: 'example graphs' stamp: 'len 7/13/2016 22:46'!
exampleImplicitGraph
	"Graph exampleImplicitGraph. BUG : There is a problem when you don't  
	test classes without subclasses, maybe a problem in the block creation  
	for ImplicitGraphNode (cf. Graph>>initialize)"
	| tree |
	tree _ self implicitCollection: [:class | class subclasses].
	Magnitude withAllSubclasses
		do: [:class| "class subclasses isEmpty ifFalse: ["tree add: class"]"].
	^ tree! !

!Graph class methodsFor: 'example graphs' stamp: 'len 7/13/2016 22:46'!
exampleImplicitGraph2
	| forest |
	forest := self implicitCollection: [:class | class ~= ProtoObject ifTrue: [{class superclass}] ifFalse:[#()]].
	(Smalltalk organization listAtCategoryNamed: 'Domains-Graphs') do: [:className| forest add: (Smalltalk at: className)].
	^ forest! !

!Graph class methodsFor: 'example graphs' stamp: 'len 7/13/2016 22:47'!
exampleImplicitGraph3
	"Graph exampleImplicitGraph3"
	| tree |
	tree _ self implicitIteratorBlock: [:class| [:aBlock| class subclasses do: aBlock]].
	RootedDigraph withAllSuperclasses do: [:class| tree add: class].
	^tree! !

!Graph class methodsFor: 'example graphs' stamp: 'len 7/13/2016 23:54'!
icosahedron
	^ self unordered addEdges:
		{1->2. 2->3. 3->1.
		4->5. 5->6. 6->7. 7->8. 8->9. 9->4.
		1->9. 1->4. 1->5. 2->5. 2->6. 2->7. 3->7. 3->8. 3->9.
		10->11. 11->12. 12->10.
		10->4. 10->5. 10->6. 11->6. 11->7. 11->8. 12->8. 12->9. 12->4}; yourself! !

!Graph class methodsFor: 'example graphs' stamp: 'len 7/13/2016 22:41'!
moebiusKantor
	"Answer the Moebius-Kantor graph."
	^ self petersen: 8 order: 3! !

!Graph class methodsFor: 'example graphs' stamp: 'len 7/13/2016 22:41'!
nauru
	"Answer the Nauru graph."
	^ self petersen: 12 order: 5! !

!Graph class methodsFor: 'example graphs' stamp: 'len 7/13/2016 23:54'!
octahedron
	^ self unordered addEdges: {1->2. 2->3. 3->1. 1->4. 2->4. 2->5. 3->5. 3->6. 1->6. 4->5. 5->6. 6->4}; yourself! !

!Graph class methodsFor: 'example graphs' stamp: 'len 7/13/2016 23:54'!
petersen
	^ self unordered addEdges:
		{1->2. 2->3. 3->4. 4->5. 5->1.
		1->6. 2->7. 3->8. 4->9. 5->10.
		6->8. 6->9. 7->9. 7->10. 8->10}; yourself! !

!Graph class methodsFor: 'example graphs' stamp: 'len 7/13/2016 23:55'!
petersen: n order: k
	"Answer the generalized Petersen graph G(n,k)."
	| G |
	k < (n/2) ifFalse: [^ DomainError signal].
	G _ self unordered.
	0 to: n-1 do: [:i|
		G addEdges: {i->(i+1\\n). i->(i+n). i+n->(i+k\\n+n)}].
	^ G ! !

!Graph class methodsFor: 'example graphs' stamp: 'len 7/13/2016 22:41'!
prism: n
	"Answer an n-prism."
	^ self petersen: n order: 1! !

!Graph class methodsFor: 'example graphs' stamp: 'len 7/13/2016 23:55'!
square
	^ self unordered addEdges: {1 -> 2. 2 -> 3. 3 -> 4. 4 -> 1}; yourself! !

!Graph class methodsFor: 'example graphs' stamp: 'len 7/13/2016 23:55'!
triangle
	^ self unordered addEdges: {1->2. 2->3. 3->1}; yourself! !

!Graph class methodsFor: 'instance creation' stamp: 'len 11/16/2016 09:58'!
arity: n
	"Create a new ordered graph with fixed arity."
	^ UndirectedGraph digraph: (Digraph arity: n)! !

!Graph class methodsFor: 'instance creation' stamp: 'len 11/16/2016 09:58'!
arityLabeled: n
	"Create a new labeled, ordered graph with fixed arity."
	^ UndirectedGraph digraph: (Digraph arityLabeled: n)! !

!Graph class methodsFor: 'instance creation' stamp: 'len 11/16/2016 10:01'!
binary
	"Create an ordered graph with arity of 2 (ie each vertex has exactly two connecting edges)."
	^ UndirectedGraph digraph: Digraph binary! !

!Graph class methodsFor: 'instance creation' stamp: 'len 11/16/2016 10:01'!
binaryLabeled
	"Create an labeled, ordered graph with arity of 2 (ie each vertex has exactly two connecting edges)."
	^ UndirectedGraph digraph: Digraph binaryLabeled! !

!Graph class methodsFor: 'instance creation' stamp: 'len 11/16/2016 10:01'!
implicitCollection: collectionBlock
	"Create a new graph, using the structure implicit in existing objects.
	Each node is the graph is accessed by evaluating collectionBlock to yield a collection of neighbouring nodes."
	^ UndirectedGraph digraph: (Digraph implicitCollection: collectionBlock)! !

!Graph class methodsFor: 'instance creation' stamp: 'len 11/16/2016 10:01'!
implicitIteratorBlock: iteratorBlock
	"Create a new graph, using the structure implicit in existing objects.
	Each node is the graph is accessed by evaluating iteratorBlock to iterate over a collection of neighbouring nodes."
	^ UndirectedGraph digraph: (Digraph implicitIteratorBlock: iteratorBlock)! !

!Graph class methodsFor: 'instance creation' stamp: 'len 11/16/2016 10:01'!
ordered
	"Create a new ordered graph."
	^ UndirectedGraph digraph: Digraph ordered! !

!Graph class methodsFor: 'instance creation' stamp: 'len 11/16/2016 10:02'!
orderedLabeled
	"Create a new labeled, ordered graph."
	^ UndirectedGraph digraph: Digraph orderedLabeled! !

!Graph class methodsFor: 'instance creation' stamp: 'len 11/16/2016 10:02'!
unordered
	"Create a new unordered graph."
	^ UndirectedGraph digraph: Digraph unordered! !

!Graph class methodsFor: 'instance creation' stamp: 'len 11/16/2016 10:02'!
unorderedLabeled
	"Create a new labeled, unordered graph."
	^ UndirectedGraph digraph: Digraph unorderedLabeled! !

!Graph class methodsFor: 'private' stamp: 'len 11/11/2016 21:03'!
new
	^ self shouldNotImplement! !

!Digraph methodsFor: 'adding/removing' stamp: 'len 7/11/2016 06:56'!
add: anObject
	"Create a new GraphNode for the value (if necessary), and add it to the graph. You shouldn't be calling this unless you're sure what you're doing. Better to add nodes by adding edges."
	^ nodes at: anObject ifAbsentPut: [nodeCreator value: ((anObject isKindOf: GraphNode) ifTrue: [anObject value] ifFalse: [anObject])]! !

!Digraph methodsFor: 'adding/removing' stamp: 'len 4/29/2016 22:29'!
addEdgeFrom: source to: target 
	| sourceNode targetNode |
	sourceNode _ self add: source.
	targetNode _ self add: target.
	sourceNode addNeighbor: targetNode! !

!Digraph methodsFor: 'adding/removing' stamp: 'len 5/25/2016 04:05'!
addEdgeFrom: source to: target label: label
	"pre: (self nodeAt: edge key) isLabeled"
	| sourceNode targetNode |
	sourceNode _ self add: source.
	targetNode _ self add: target.
	sourceNode addNeighbor: targetNode label: label! !

!Digraph methodsFor: 'adding/removing' stamp: 'timestamp) (no'!
remove: aGraphNode ifAbsent: exceptionBlock 
	"Remove the given node, evaluate exceptionBlock if it's not part of the graph.
	pre: the node shouldn't be the target of an edge."
	^nodes remove: aGraphNode ifAbsent: exceptionBlock! !

!Digraph methodsFor: 'adding/removing' stamp: 'len 5/25/2016 04:03'!
removeEdgeFrom: source to: target ifAbsent: exceptionBlock 
	"Remove the given edge, evaluate exceptionBlock if it doesn't exist. 
	pre: both the source and target of the edge must be in the graph."
	| sourceNode targetNode |
	sourceNode _ self nodeAt: source.
	targetNode _ self nodeAt: target.
	(sourceNode hasEdgeTo: targetNode)
		ifTrue: [sourceNode removeNeighbor: targetNode]
		ifFalse: [^ exceptionBlock value]! !

!Digraph methodsFor: 'initialization' stamp: 'len 2/14/2016 22:14'!
arity: n
	type _ #(#arity).
	nodeCreator _ (InitializationBlocks at: #arity) value: n! !

!Digraph methodsFor: 'initialization' stamp: 'len 2/20/2016 06:37'!
arityLabeled: n
	type _ #(#arity #labeled).
	nodeCreator _ (InitializationBlocks at: #arityLabeled) value: n! !

!Digraph methodsFor: 'initialization' stamp: 'len 2/14/2016 22:15'!
binary
	type _ #(#binary).
	nodeCreator _ InitializationBlocks at: #binary! !

!Digraph methodsFor: 'initialization' stamp: 'len 2/20/2016 06:38'!
binaryLabeled
	type _ #(#binary #labeled).
	nodeCreator _ InitializationBlocks at: #binaryLabeled! !

!Digraph methodsFor: 'initialization' stamp: 'len 2/14/2016 22:15'!
implicitCollection: collectionBlock
	type _ #(#implicitCollection).
	nodeCreator _ (InitializationBlocks at: #implicitCollection) value: self value: collectionBlock! !

!Digraph methodsFor: 'initialization' stamp: 'len 2/14/2016 22:15'!
implicitIteratorBlock: iteratorBlock
	type _ #(#implicitIteratorBlock).
	nodeCreator _ (InitializationBlocks at: #implicitIteratorBlock) value: self value: iteratorBlock! !

!Digraph methodsFor: 'initialization' stamp: 'len 2/26/2016 21:40'!
initialize
	nodes _ KeyedSet new! !

!Digraph methodsFor: 'initialization' stamp: 'len 2/14/2016 22:15'!
ordered
	type _ #(#ordered).
	nodeCreator _ InitializationBlocks at: #ordered! !

!Digraph methodsFor: 'initialization' stamp: 'len 2/20/2016 06:37'!
orderedLabeled
	type _ #(#ordered #labeled).
	nodeCreator _ InitializationBlocks at: #orderedLabeled! !

!Digraph methodsFor: 'initialization' stamp: 'len 2/14/2016 22:16'!
unordered
	type _ #(#unordered).
	nodeCreator _ InitializationBlocks at: #unordered! !

!Digraph methodsFor: 'initialization' stamp: 'len 2/20/2016 06:35'!
unorderedLabeled
	type _ #(#unordered #labeled).
	nodeCreator _ InitializationBlocks at: #unorderedLabeled! !

!Digraph methodsFor: 'converting' stamp: 'len 5/25/2016 03:15'!
asRooted
	| answer |
	answer _ RootedDigraph unordered.
	answer addAll: self.
	self edgesDo: [:each| answer addEdge: each].
	answer findRoots.
	^ answer! !

!Digraph methodsFor: 'converting' stamp: 'len 11/16/2016 09:54'!
asUndirected
	^ UndirectedGraph digraph: self symmetric! !

!Digraph methodsFor: 'random' stamp: 'len 7/11/2016 05:32'!
atRandom: aRandom
	^ (nodes atRandom: aRandom) value! !

!Digraph methodsFor: 'random' stamp: 'len 7/11/2016 05:59'!
edgeAtRandom: aRandom
	| count |
	3 timesRepeat:
		[| source |
		(source _ nodes atRandom: aRandom) neighbors
			ifNotEmpty: [:neighbors| ^ source -> (neighbors atRandom: aRandom)]].
	count _ self numberOfEdges atRandom.
	self edgesDo: [:each| (count _ count - 1) > 0 ifFalse: [^ each]].
	self error: 'inconsitency problem, edge not found'! !

!Digraph methodsFor: 'operations' stamp: 'len 2/19/2017 17:57:54'!
complement
	"Answer the complement graph, i.e. the graph where two vertices are connected iff they are *not* connected in the receiver."
	| answer |
	answer _ self copyEmpty.
	self nodesDo: [:x|
		| neighbors |
		answer add: x.
		neighbors _ x neighbors.
		self nodesDo: [:y| (neighbors includes: y) ifFalse: [answer addEdgeFrom: x to: y]]].
	^ answer! !

!Digraph methodsFor: 'enumerating' stamp: 'len 7/13/2016 22:25'!
componentsDo: aBlock
	"Iterate over the Strongly Connected Components of the receiver."
	| component remainingNodes node |
	remainingNodes _ self nodes copy.
	[remainingNodes isEmpty]
		whileFalse:
			[node _ remainingNodes anyOne.
			component _ self copyEmpty.
			node markDo: [:each|
				component nodes add: each.
				remainingNodes remove: each ifAbsent: []].
			aBlock value: component]! !

!Digraph methodsFor: 'enumerating' stamp: 'len 7/20/2016 23:39'!
edgesAndLabelsDo: aBinaryBlock
	self nodesDo: [:node| node neighborsAndLabelsDo: [:n :label| aBinaryBlock value: (Association key: node value value: n value) value: label]]! !

!Digraph methodsFor: 'enumerating' stamp: 'len 7/20/2016 23:39'!
edgesDo: aBlock
	self nodesDo: [:node| node neighborsDo: [:n| aBlock value: (Association key: node value value: n value)]]! !

!Digraph methodsFor: 'enumerating' stamp: 'len 7/20/2016 23:39'!
fullEdgesAndLabelsDo: aBinaryBlock
	self nodesDo: [:node| node neighborsAndLabelsDo: [:n :label| aBinaryBlock value: (Association key: node value: n) value: label]]! !

!Digraph methodsFor: 'enumerating' stamp: 'len 7/20/2016 23:39'!
fullEdgesDo: aBlock
	self nodesDo: [:node| node neighborsDo: [:n| aBlock value: (Association key: node value: n)]]! !

!Digraph methodsFor: 'enumerating' stamp: 'len 7/20/2016 23:42'!
nodesDo: aBlock
	self isImplicit
		ifTrue: [nodes asOrderedCollection do: aBlock]
		ifFalse: [nodes do: aBlock]! !

!Digraph methodsFor: 'copying' stamp: 'len 7/13/2016 22:56'!
copy
	^ self collect: [:each| each]! !

!Digraph methodsFor: 'copying' stamp: 'len 2/16/2016 22:19'!
copyEmpty
	"Return a graph of the same type with no nodes or edges."
	^self isImplicit
		ifTrue: [self class ordered]
		ifFalse: [super copy initialize]! !

!Digraph methodsFor: 'private' stamp: 'len 7/13/2016 22:37'!
isDirected
	^ true! !

!Digraph methodsFor: 'private' stamp: 'timestamp) (no'!
isImplicit
	"Is the node creator for implicit nodes?"
	^(type includes: #implicitCollection) or: [type includes: #implicitIteratorBlock]! !

!Digraph methodsFor: 'private' stamp: 'len 2/20/2016 06:38'!
isLabeled
	"Is the node creator for labeled nodes?"
	^type includes: #labeled! !

!Digraph methodsFor: 'private' stamp: 'timestamp) (no'!
nodeCreator: n
	nodeCreator := n! !

!Digraph methodsFor: 'testing' stamp: 'len 7/13/2016 20:56'!
isOrdered
	^ self type includes: #ordered! !

!Digraph methodsFor: 'testing' stamp: 'len 7/23/2016 07:29'!
isOriented
	self nodesDo: [:each|
		each neighborsDo: [:neighbor|
			(neighbor hasEdgeTo: each) ifTrue: [^ false]]].
	^ true! !

!Digraph methodsFor: 'testing' stamp: 'len 2/17/2016 03:38'!
isSymmetric
	^ nodes allSatisfy: [:each| each isSymmetric]! !

!Digraph methodsFor: 'testing' stamp: 'len 2/17/2016 03:37'!
isTransitive
	^ nodes allSatisfy: [:each| each isTransitive]! !

!Digraph methodsFor: 'testing' stamp: 'len 7/13/2016 20:56'!
isUnordered
	^ self type includes: #unordered! !

!Digraph methodsFor: 'testing' stamp: 'len 2/17/2016 02:42'!
isWeaklyConnected
	"A graph is said to be 'weakly connected' when its symmetric closure is connected."
	^ self symmetric isConnected! !

!Digraph methodsFor: 'accessing' stamp: 'len 2/14/2016 21:42'!
nodes
	^ nodes! !

!Digraph methodsFor: 'accessing' stamp: 'len 2/14/2016 21:55'!
type
	^ type! !

!Digraph class methodsFor: 'instance creation' stamp: 'len 7/13/2016 22:50'!
arity: n
	"Create a new ordered graph with fixed arity."
	^ self basicNew initialize arity: n! !

!Digraph class methodsFor: 'instance creation' stamp: 'len 7/13/2016 22:50'!
arityLabeled: n
	"Create a new labeled, ordered graph with fixed arity."
	^ self basicNew initialize arityLabeled: n! !

!Digraph class methodsFor: 'instance creation' stamp: 'len 7/13/2016 22:51'!
binary
	"Create an ordered graph with arity of 2 (ie each vertex has exactly two connecting edges)."
	^ self basicNew initialize binary! !

!Digraph class methodsFor: 'instance creation' stamp: 'len 7/13/2016 22:51'!
binaryLabeled
	"Create an labeled, ordered graph with arity of 2 (ie each vertex has exactly two connecting edges)."
	^ self basicNew initialize binaryLabeled! !

!Digraph class methodsFor: 'instance creation' stamp: 'len 7/13/2016 22:51'!
implicitCollection: collectionBlock
	"Create a new graph, using the structure implicit in existing objects.
	Each node is the graph is accessed by evaluating collectionBlock to yield a collection of neighbouring nodes."
	^ self basicNew initialize implicitCollection: collectionBlock! !

!Digraph class methodsFor: 'instance creation' stamp: 'len 7/13/2016 22:51'!
implicitIteratorBlock: iteratorBlock
	"Create a new graph, using the structure implicit in existing objects.
	Each node is the graph is accessed by evaluating iteratorBlock to iterate over a collection of neighbouring nodes."
	^ self basicNew initialize implicitIteratorBlock: iteratorBlock! !

!Digraph class methodsFor: 'instance creation' stamp: 'len 7/13/2016 22:51'!
ordered
	"Create a new ordered graph."
	^ self basicNew initialize ordered! !

!Digraph class methodsFor: 'instance creation' stamp: 'len 7/13/2016 22:51'!
orderedLabeled
	"Create a new labeled, ordered graph."
	^ self basicNew initialize orderedLabeled! !

!Digraph class methodsFor: 'instance creation' stamp: 'len 7/13/2016 22:51'!
unordered
	"Create a new unordered graph."
	^ self basicNew initialize unordered! !

!Digraph class methodsFor: 'instance creation' stamp: 'len 7/13/2016 22:51'!
unorderedLabeled
	"Create a new labeled, unordered graph."
	^ self basicNew initialize unorderedLabeled! !

!Digraph class methodsFor: 'initialization' stamp: 'len 7/14/2016 03:05'!
initialize
	"Digraph initialize"
	InitializationBlocks	_ Dictionary new.
	InitializationBlocks
		at: #binary
		put: [:value | ExplicitGraphNode binary: value];
		at: #arity
		put: [:n | [:value | ExplicitGraphNode on: value arity: n]];
		at: #ordered
		put: [:value | ExplicitGraphNode ordered: value];
		at: #unordered
		put: [:value | ExplicitGraphNode newOn: value];
		at: #arityLabeled
		put: [:n | [:value | LabeledExplicitGraphNode on: value arity: n]];
		at: #binaryLabeled
		put: [:value | LabeledExplicitGraphNode binary: value];
		at: #orderedLabeled
		put: [:value | LabeledExplicitGraphNode ordered: value];
		at: #unorderedLabeled
		put: [:value | LabeledExplicitGraphNode newOn: value];
		at: #implicitCollection
		put: [:graph :collectionBlock | [:value | ImplicitGraphNode
				on: value
				collectionBlock: [(collectionBlock value: value)
						collect: [:node | graph add: node]]]];
		at: #implicitIteratorBlock
		put: [:graph :iteratorBlock | [:value | 
			| iterator | 
			iterator := iteratorBlock value: value.
			ImplicitGraphNode
				on: value
				iteratorBlock: [:aBlock | iterator
						value: [:node | aBlock
								value: (graph nodes add: node)]]]]! !

!RootedDigraph methodsFor: 'adding' stamp: 'len 2/19/2016 21:17'!
addEdgeFrom: source to: target
	super addEdgeFrom: source to: target.
	roots remove: target ifAbsent: []! !

!RootedDigraph methodsFor: 'adding' stamp: 'len 2/19/2016 21:17'!
addEdgeFrom: source to: target label: label
	super addEdgeFrom: source to: target label: label.
	roots remove: target ifAbsent: []! !

!RootedDigraph methodsFor: 'adding' stamp: 'len 7/11/2016 06:23'!
addRoot: anObject
	"Add anObject as a root of the graph."
	| node |
	node _ self add: anObject.
	roots add: node value.
	^ node! !

!RootedDigraph methodsFor: 'adding' stamp: 'timestamp) (no'!
buildFromRoots: rootCollection
	"Build the graph with given roots.
	The nodes should all be ImplicitGraphNodes, or have outgoing edges attached."
	self roots: rootCollection.
	self markDo: [ :junk ]! !

!RootedDigraph methodsFor: 'adding' stamp: 'len 2/26/2016 05:10'!
roots: rootNodes children: aBlock
	"Build the graph with given rootNodes.
	Evaluate aBlock for each node to obtain a Collection of its children."
	^self roots: rootNodes childrenGenerator:
		[ :node | [ :iterationBlock | (aBlock value: node) do: iterationBlock]]! !

!RootedDigraph methodsFor: 'adding' stamp: 'timestamp) (no'!
roots: rootNodes children: aBlock label: labelBlock
	"Build the graph with given rootNodes.
	Evaluate aBlock for each node to obtain a Collection of its children."
	^self
		roots: rootNodes 
		childrenGenerator: [ :node | [ :iterationBlock | (aBlock value: node) do: iterationBlock]]
		label: labelBlock! !

!RootedDigraph methodsFor: 'adding' stamp: 'timestamp) (no'!
roots: rootNodes childrenGenerator: aBlock
	"Build the graph with given rootNodes.
	Evaluate aBlock for each node to obtain an iterator over a Collection of its children."
	^self roots: rootNodes childrenGenerator: aBlock label: nil! !

!RootedDigraph methodsFor: 'adding' stamp: 'len 2/26/2016 20:55'!
roots: rootNodes childrenGenerator: aBlock label: labelBlock
	"Build the graph with given rootNodes.
	Evaluate aBlock for each node to obtain an iterator over a Collection of its children.
	Evaluate labelBlock (if not nil) for each node and child to obtain a label for the edge."
	| todo |
	self roots: rootNodes.
	todo := rootNodes asSet copy.
	[todo isEmpty] whileFalse:
		[| node |
		node := todo anyOne.
		(aBlock value: node) value:
			[ :child |
				(self includes: child) ifFalse: [todo add: child].
				labelBlock isNil
					ifTrue: [self addEdgeFrom: node to: child]
					ifFalse: [self addEdgeFrom: node to: child label: (labelBlock value: node value: child)]].
			todo remove: node].
	^self! !

!RootedDigraph methodsFor: 'adding' stamp: 'len 2/26/2016 05:03'!
roots: rootNodes childrenLabelGenerator: aBlock
	"Build the graph with given rootNodes.
	Evaluate aBlock for each node to obtain an iterator over a Collection of its children and labels."
	| todo |
	self roots: rootNodes.
	todo := rootNodes asSet copy.
	[todo isEmpty] whileFalse:
		[| node |
		node := todo anyOne.
		(aBlock value: node) value:
			[ :child :label |
				(self includes: child) ifFalse: [todo add: child].
				self addEdgeFrom: node to: child label: label].
			todo remove: node].
	^self! !

!RootedDigraph methodsFor: 'adding' stamp: 'timestamp) (no'!
roots: rootNodes childrenMsg: msg
	"Build the graph with given rootNodes.
	Send msg to each node to obtain a Collection of its children."
	^self roots: rootNodes childrenGenerator:
		[ :node | [ :iterationBlock | (node perform: msg) do: iterationBlock]]! !

!RootedDigraph methodsFor: 'enumerating' stamp: 'timestamp) (no'!
breadthFirstDo: aBlock
	"Evaluate aBlock for each set of nodes at a given depth in the graph.
	A node is at depth n if the longest path to that node from a root has n steps.
	pre: self isCyclic not"

	| df current |
	df := self frontier.
	[current := df frontier copy.
	current isEmpty] whileFalse:
		[aBlock value: current.
		df removeAll: current]! !

!RootedDigraph methodsFor: 'enumerating' stamp: 'len 7/21/2016 00:02'!
collect: aBlock
	"Answer a new graph like the receiver but with vertices values mapped by aBlock.
	Note that aBlock is evaluated on the nodes, not the values."
	| answer |
	answer _ super copyEmpty.
	answer roots: (roots collect: aBlock).
	self do: [:each| answer add: (aBlock value: each)].
	self edgesDo: [:each| answer addEdgeFrom: (aBlock value: each key) to: (aBlock value: each value)].
	^ answer! !

!RootedDigraph methodsFor: 'enumerating' stamp: 'len 7/21/2016 00:02'!
collect: aBlock labels: labelBlock
	"Answer a new graph like the receiver but with vertices values mapped by aBlock.
	Note that aBlock is evaluated on the nodes, not the values."
	| answer |
	answer _ super copyEmpty.
	self rootNodes do: [:each| answer addRoot: (aBlock value: each)].
	self do: [:each| answer add: (aBlock value: each)].
	self edgesAndLabelsDo: [:each :label| answer addEdgeFrom: (aBlock value: each key) to: (aBlock value: each value) label: (labelBlock value: label)].
	^ answer! !

!RootedDigraph methodsFor: 'enumerating' stamp: 'len 2/17/2016 01:20'!
frontier
	"Return a DAGFrontier object, capable of iterating over this DAG."
	^ DAGFrontier on: self! !

!RootedDigraph methodsFor: 'enumerating' stamp: 'len 11/30/2016 14:44:37'!
markDo: aBlock
	"Visit each node in the graph once, applying aBlock.
	A node is only visited after at least one of its predecessors, but not necessarily after all the predecessors."
	| todo visited |
	todo _ self rootNodes as: Set.
	visited _ Set new.
	[todo isEmpty] whileFalse:
		[| node |
		node _ todo anyOne.
		visited add: node.
		aBlock value: node.
		node neighborsDo:
			[ :child |
				(visited includes: child)
					ifFalse: [todo add: child]].
		todo remove: node]! !

!RootedDigraph methodsFor: 'enumerating' stamp: 'len 6/24/2016 17:11'!
preOrderDo: aBlock 
	"Walk the graph, evaluating aBlock for each node.  Evaluate each node before its successors, but in no particular order when there is a choice.
	pre: self isCyclic not"

	| frontier remaining |
	frontier := self rootNodes.
	"Build a Bag of non-root nodes, each node once in the Bag for every predecessor."
	remaining := Bag new.
	nodes do: [:node | remaining addAll: node neighbors].
	
	[| next |
	next := frontier anyIfNone: [^self].
	aBlock value: next.
	frontier remove: next.
	next neighborsDo: 
			[:neighbor | 
			(remaining remove: neighbor) = 0 ifTrue: [frontier add: neighbor]]] 
			repeat! !

!RootedDigraph methodsFor: 'enumerating' stamp: 'len 2/14/2003 20:06'!
walkPre: preBlock post: postBlock
	"Recursively walk the tree(s).  Apply preBlock to each node, then walk the subtree below node, then apply postBlock to the node."
	self rootNodes do: [ :root | root walkPre: preBlock post: postBlock]! !

!RootedDigraph methodsFor: 'copying' stamp: 'len 2/19/2016 21:38'!
copyEmpty
	"Return a new graph of the same type, with the same roots, but no edges."
	^ super copyEmpty roots: roots copy asSet! !

!RootedDigraph methodsFor: 'operations' stamp: 'timestamp) (no'!
depthList
	"Partitions the DAG, returning a SequenceableCollection of Sets of nodes in the graph.  Element n in the SequenceableCollection is the Set of nodes in the graph reachable in n-1 steps by the longest route from a root."
	^OrderedCollection accumulate: [ :incBlock | self breadthFirstDo: incBlock]! !

!RootedDigraph methodsFor: 'operations' stamp: 'timestamp) (no'!
reduce
	"Remove all redundant edges to form the transitive reduction.

	Based on Algorithm 4 in 'An Algorithm for Finding a Minimum Equivalent Graph of a Digraph', by D. M. Moyles and G. L. Thompson, JACM 16(3), July 1969, pp455-60 (with obvious simplifications for acyclic graphs)."
	
	self rootNodes do: [ :root | self reduceStep: root with: OrderedCollection new]! !

!RootedDigraph methodsFor: 'operations' stamp: 'len 11/30/2016 14:44:48'!
reduceSlow
	"Remove all redundant edges to form the transitive reduction.

	Based on Algorithm 4 in 'An Algorithm for Finding a Minimum Equivalent Graph of a Digraph', by D. M. Moyles and G. L. Thompson, JACM 16(3), July 1969, pp455-60 (with obvious simplifications for acyclic graphs).
	
	This version sometimes builds huge sets!!"
	
	| seqSet |
	seqSet _ Set accumulate: [ :incBlock |
				self rootNodes do: [ :root | incBlock value: (Array with: root)]].

	[seqSet isEmpty] whileFalse:
		[| newSeqSet |
"Transcript show: seqSet size printString ; cr."
		newSeqSet _ Set new.
		seqSet do: [ :seq || tail |
			tail _ seq last.
			tail neighborsDo: [ :neighbor |
				seq do: [ :node |
					(node ~= tail and: [node hasEdgeTo: neighbor])
						ifTrue: [
"Transcript show: node printString, ' -> ', neighbor printString ; cr."
								self removeEdgeFrom: node to: neighbor]].
				newSeqSet add: (seq copyWith: neighbor)]].
		seqSet _ newSeqSet]! !

!RootedDigraph methodsFor: 'operations' stamp: 'len 5/7/2016 04:13'!
reduceStep: node with: sofar 
	node degree = 0 ifTrue: [^self].
	node neighbors copy do: 
			[:succ | 
			sofar 
				do: [:done | (done hasEdgeTo: succ) ifTrue: [self removeEdgeFrom: done to: succ]].
			sofar addLast: node.
			self reduceStep: succ with: sofar.
			sofar removeLast]! !

!RootedDigraph methodsFor: 'initialization' stamp: 'len 2/26/2016 23:01'!
findRoots
	"Find all nodes that are not the targets of an edge and make them the roots."
	roots _ self values.
	self nodesDo: [:node| node neighborsDo: [:n| roots remove: n value ifAbsent: []]]! !

!RootedDigraph methodsFor: 'initialization' stamp: 'timestamp) (no'!
initialize
	super initialize.
	roots := Set new! !

!RootedDigraph methodsFor: 'initialization' stamp: 'len 4/29/2016 22:28'!
roots: aCollection
	roots _ aCollection asSet.
	roots do: [:each| self add: each]! !

!RootedDigraph methodsFor: 'testing' stamp: 'len 6/24/2016 17:11'!
isCyclic
	"Is the graph cyclic?"

	| frontier remaining |
	frontier := self rootNodes.
	"Build a Bag of non-root nodes, each node once in the Bag for every predecessor."
	remaining := Bag new.
	nodes do: [:node | remaining addAll: node neighbors].
	
	[| next |
	next := frontier anyIfNone: [^remaining isEmpty not].
	frontier remove: next.
	next neighborsDo: 
			[:neighbor | 
			(remaining remove: neighbor) = 0 ifTrue: [frontier add: neighbor]]] 
			repeat! !

!RootedDigraph methodsFor: 'testing' stamp: 'timestamp) (no'!
isEmpty
	"Answer whether the receiver contains any elements."

	^roots isEmpty! !

!RootedDigraph methodsFor: 'testing' stamp: 'timestamp) (no'!
isTree
	"Is the graph a tree (more accurately, a forest)?
	It is if every node has at most one predecessor."
	| visited |
	visited := Set new.
	nodes do: [ :node |
		node neighborsDo: [ :neighbor |
			(visited includes: neighbor) ifTrue: [^false].
			visited add: neighbor]].
	^true! !

!RootedDigraph methodsFor: 'testing' stamp: 'len 5/5/2016 01:50'!
test
	^ #[1 2 3 4]! !

!RootedDigraph methodsFor: 'removing' stamp: 'len 5/7/2016 04:13'!
removeAllFrom: aNode 
	"Remove the subtree below aNode (and associated edges), excluding aNode itself.
	Note that nodes are removed from the graph without being sent any messages."

	aNode walkPre: [:junk | ]
		post: 
			[:child | 
			child == aNode 
				ifTrue: [aNode neighbors copy do: [:n | aNode removeNeighbor: n]]
				ifFalse: [self remove: child]]! !

!RootedDigraph methodsFor: 'accessing' stamp: 'len 7/21/2016 00:04'!
root
	"pre: roots size = 1"
	^ roots anyOne! !

!RootedDigraph methodsFor: 'accessing' stamp: 'len 2/26/2016 23:21'!
rootNode
	"return the GraphNode for the root.
	pre: roots size = 1"
	^self nodeAt: roots anyOne! !

!RootedDigraph methodsFor: 'accessing' stamp: 'len 2/26/2016 23:22'!
rootNodes
	"Return the GraphNodes for the roots."
	^roots collect: [ :root | self nodeAt: root]! !

!RootedDigraph methodsFor: 'accessing' stamp: 'len 7/21/2016 00:03'!
roots
	^ roots! !

!RootedDigraph class methodsFor: 'example graphs' stamp: 'timestamp) (no'!
exampleDAG
	"RootedGraph exampleDAG."
	| d |
	d := self unordered.
	d addRoot: #r1.
	d addRoot: #r2.
	d addEdge: #r1 -> #n1.
	d addEdge: #r1 -> #n2.
	d addEdge: #r2 -> #n2.
	d addEdge: #n1 -> #n3.
	d addEdge: #n2 -> #n3.
	^d! !

!RootedDigraph class methodsFor: 'example graphs' stamp: 'len 2/12/2003 22:59'!
exampleForest
	"RootedGraph exampleForest"
	^self unordered roots: (Set with: Number with: Stream) children: [ :class | class subclasses]! !

!RootedDigraph class methodsFor: 'example graphs' stamp: 'timestamp) (no'!
exampleImplicitLargeTree
	"RootedGraph exampleImplicitLargeTree"
	^(self
		implicitCollection:
			[ :class |
				class == Class
					ifTrue: [#()]
					ifFalse: [class subclasses asSortedCollection: [ :x :y | x name < y name]]]) 		buildFromRoots: (Array with: Object)! !

!RootedDigraph class methodsFor: 'example graphs' stamp: 'timestamp) (no'!
exampleImplicitSmallTree
	"RootedGraph exampleImplicitSmallTree"
	^(self implicitCollection: [ :class | class subclasses]) buildFromRoots: (Set with: Number)! !

!RootedDigraph class methodsFor: 'example graphs' stamp: 'len 2/12/2003 22:58'!
exampleLargeTree
	"RootedGraph exampleLargeTree"
	^self ordered roots: (Array with: Object) children:
		[ :class | class == Class
					ifTrue: [#()]
					ifFalse: [class subclasses asSortedCollection: [ :x :y | x name < y name]]]! !

!RootedDigraph class methodsFor: 'example graphs' stamp: 'len 2/20/2016 06:36'!
exampleMediumLabelledTree
	"RootedGraph exampleMediumLabelledTree"
	^self unorderedLabeled
		roots: (Set with: Collection)
		children: [ :class | class subclasses]
		label: [ :src :trg |
				trg isVariable
					ifTrue: [trg isBits ifTrue: [#variableByte] ifFalse: [#variable]]
					ifFalse: [#normal]]! !

!RootedDigraph class methodsFor: 'example graphs' stamp: 'len 2/25/2016 20:44'!
exampleMediumTree
	^self unordered roots: (Set with: Collection) children: [ :class | class subclasses]! !

!RootedDigraph class methodsFor: 'example graphs' stamp: 'len 2/14/2003 23:43'!
exampleMediumTree2
	^self unordered roots: (Set with: Collection) children: [ :class | class subclasses]! !

!RootedDigraph class methodsFor: 'example graphs' stamp: 'len 2/20/2016 06:36'!
exampleSmallLabelledTree
	"RootedGraph exampleSmallLabelledTree"
	^self unorderedLabeled
		roots: (Set with: Number)
		children: [ :class | class subclasses]
		label: [ :src :trg | trg category]! !

!RootedDigraph class methodsFor: 'example graphs' stamp: 'len 2/20/2016 06:36'!
exampleSmallLabelledTree2
	"RootedGraph exampleSmallLabelledTree2"
	^self unorderedLabeled
		roots: (Set with: Magnitude)
		children: [ :class | class subclasses]
		label: [ :src :trg |
				trg isVariable
					ifTrue: [trg isBits ifTrue: [#variableByte] ifFalse: [#variable]]
					ifFalse: [#normal]]! !

!RootedDigraph class methodsFor: 'example graphs' stamp: 'len 2/12/2003 22:42'!
exampleSmallTree
	"RootedGraph exampleSmallTree"
	^self unordered roots: (Set with: Number) children: [ :class | class subclasses]! !

!RootedDigraph class methodsFor: 'example graphs' stamp: 'len 2/18/2003 22:09'!
exampleSmallTree2
	"RootedGraph exampleSmallTree2"
	^self unordered roots: (Set with: Magnitude) childrenMsg: #subclasses! !

!UndirectedGraph methodsFor: 'adding/removing' stamp: 'len 7/13/2016 22:52'!
add: anObject
	^ digraph add: anObject! !

!UndirectedGraph methodsFor: 'adding/removing' stamp: 'len 5/25/2016 04:07'!
addEdgeFrom: source to: target 
	| sourceNode targetNode |
	sourceNode _ self add: source.
	targetNode _ self add: target.
	sourceNode addNeighbor: targetNode.
	targetNode addNeighbor: sourceNode! !

!UndirectedGraph methodsFor: 'adding/removing' stamp: 'len 5/25/2016 04:06'!
addEdgeFrom: source to: target label: label
	"pre: (self nodeAt: edge key) isLabeled"
	| sourceNode targetNode |
	sourceNode _ self add: source.
	targetNode _ self add: target.
	sourceNode addNeighbor: targetNode label: label.
	targetNode addNeighbor: sourceNode label: label! !

!UndirectedGraph methodsFor: 'adding/removing' stamp: 'len 7/13/2016 22:59'!
remove: aGraphNode ifAbsent: exceptionBlock 
	"Remove the given node, evaluate exceptionBlock if it's not part of the graph.
	pre: the node shouldn't be the target of an edge."
	^ digraph remove: aGraphNode ifAbsent: exceptionBlock! !

!UndirectedGraph methodsFor: 'adding/removing' stamp: 'len 5/25/2016 04:04'!
removeEdgeFrom: source to: target ifAbsent: exceptionBlock 
	"Remove the given edge, evaluate exceptionBlock if it doesn't exist. 
	pre: both the source and target of the edge must be in the graph."
	| sourceNode targetNode |
	sourceNode _ self nodeAt: source.
	targetNode _ self nodeAt: target.
	(sourceNode hasEdgeTo: targetNode)
		ifTrue:
			[sourceNode removeNeighbor: targetNode.
			targetNode removeNeighbor: sourceNode]
		ifFalse: [^ exceptionBlock value]! !

!UndirectedGraph methodsFor: 'converting' stamp: 'len 2/15/2017 15:53:55'!
asDirected
	^ digraph! !

!UndirectedGraph methodsFor: 'random' stamp: 'len 7/13/2016 23:14'!
atRandom: aRandom
	^ digraph atRandom: aRandom! !

!UndirectedGraph methodsFor: 'random' stamp: 'len 7/13/2016 23:15'!
edgeAtRandom: aRandom
	^ (digraph edgeAtRandom: aRandom) as: MutualAssociation! !

!UndirectedGraph methodsFor: 'operations' stamp: 'len 7/21/2016 02:44'!
complement
	^ self class digraph: digraph complement! !

!UndirectedGraph methodsFor: 'operations' stamp: 'len 7/15/2016 18:25'!
flowPolynomial
	"The flow polynomial F(G,k) is a polynomial in k that counts the number of nowhere-zero k-flows of G."
	| x |
	x _ ZZ polynomials x.
	^ (-1)^(self size + self numberOfEdges + self components size) * (self tuttePolynomial value: {0. 1 - x})! !

!UndirectedGraph methodsFor: 'operations' stamp: 'len 7/13/2016 22:13'!
symmetric
	^ self! !

!UndirectedGraph methodsFor: 'operations' stamp: 'len 7/13/2016 22:13'!
transposed
	^ self! !

!UndirectedGraph methodsFor: 'operations' stamp: 'len 3/6/2017 16:30:08'!
tuttePolynomial
	| P K G |
	P _ ZZ polynomialsIn: #(x y).
	self isEdgeless ifTrue: [^ P one].
	K _ self components size.
	self edgesDo: [:e|
		e key = e value "it's a loop"
			ifTrue: [^ P y * (self - e) tuttePolynomial]
			ifFalse:
				[G _ self - e.
				G components size > K "it's a bridge"
					ifTrue: [^ P x * (self / e) tuttePolynomial]
					ifFalse: [^ G tuttePolynomial + (self / e) tuttePolynomial]]].
	^ self error: 'inconsistency, this line should have been reaached'! !

!UndirectedGraph methodsFor: 'enumerating' stamp: 'len 7/13/2016 22:58'!
componentsDo: aBlock
	digraph componentsDo: [:each| aBlock value: (self class digraph: each)]! !

!UndirectedGraph methodsFor: 'enumerating' stamp: 'len 11/30/2016 14:45:13'!
edgesAndLabelsDo: aBinaryBlock
	| visited |
	visited _ Set new.
	digraph edgesAndLabelsDo: [:each :label|
		(visited includes: each value -> each key)
			ifFalse: [aBinaryBlock value: (each as: MutualAssociation) value: label].
		visited add: each]! !

!UndirectedGraph methodsFor: 'enumerating' stamp: 'len 11/30/2016 14:45:17'!
edgesDo: aBlock
	| visited |
	visited _ Set new.
	digraph edgesDo: [:each|
		(visited includes: each value -> each key)
			ifFalse: [aBlock value: (each as: MutualAssociation)].
		visited add: each]! !

!UndirectedGraph methodsFor: 'enumerating' stamp: 'len 11/30/2016 14:45:20'!
fullEdgesAndLabelsDo: aBinaryBlock
	| visited |
	visited _ Set new.
	digraph fullEdgesAndLabelsDo: [:each :label|
		(visited includes: each value -> each key)
			ifFalse: [aBinaryBlock value: (each as: MutualAssociation) value: label].
		visited add: each]! !

!UndirectedGraph methodsFor: 'enumerating' stamp: 'len 11/30/2016 14:45:25'!
fullEdgesDo: aBlock
	| visited |
	visited _ Set new.
	digraph fullEdgesDo: [:each|
		(visited includes: each value -> each key)
			ifFalse: [aBlock value: (each as: MutualAssociation)].
		visited add: each]! !

!UndirectedGraph methodsFor: 'enumerating' stamp: 'len 7/13/2016 22:53'!
nodesDo: aBlock
	digraph nodesDo: aBlock! !

!UndirectedGraph methodsFor: 'copying' stamp: 'len 7/13/2016 22:57'!
copy
	^ self class digraph: digraph copy! !

!UndirectedGraph methodsFor: 'copying' stamp: 'len 7/13/2016 22:30'!
copyEmpty
	^ self class digraph: digraph copyEmpty! !

!UndirectedGraph methodsFor: 'initialization' stamp: 'len 7/13/2016 22:29'!
digraph: aDigraph
	digraph _ aDigraph! !

!UndirectedGraph methodsFor: 'testing' stamp: 'len 7/13/2016 22:37'!
isDirected
	^ false! !

!UndirectedGraph methodsFor: 'testing' stamp: 'len 7/21/2016 02:13'!
isImplicit
	^ digraph isImplicit! !

!UndirectedGraph methodsFor: 'testing' stamp: 'len 7/21/2016 02:13'!
isLabeled
	^ digraph isLabeled! !

!UndirectedGraph methodsFor: 'testing' stamp: 'len 7/21/2016 02:13'!
isOrdered
	^ digraph isOrdered! !

!UndirectedGraph methodsFor: 'testing' stamp: 'len 7/13/2016 22:35'!
isSymmetric
	^ true! !

!UndirectedGraph methodsFor: 'testing' stamp: 'len 7/13/2016 22:35'!
isTransitive
	^ true! !

!UndirectedGraph methodsFor: 'testing' stamp: 'len 7/13/2016 22:36'!
occurrencesOf: anObject 
	"Answer how many of the receiver's elements are equal to anObject."

	^(self includes: anObject) ifTrue: [1] ifFalse: [0]! !

!UndirectedGraph methodsFor: 'accessing' stamp: 'len 7/13/2016 22:53'!
nodes
	^ digraph nodes! !

!UndirectedGraph methodsFor: 'accessing' stamp: 'len 7/13/2016 21:45'!
numberOfEdges
	^ digraph numberOfEdges / 2! !

!UndirectedGraph methodsFor: 'accessing' stamp: 'len 7/16/2016 08:25'!
type
	^ digraph type! !

!UndirectedGraph class methodsFor: 'instance creation' stamp: 'len 7/13/2016 22:27'!
digraph: aDigraph
	^ self basicNew digraph: aDigraph! !

!YoungTableau methodsFor: 'accessing' stamp: 'len 8/1/2016 02:52'!
at: aPoint
	^ (rows at: aPoint x) at: aPoint y! !

!YoungTableau methodsFor: 'accessing' stamp: 'len 8/1/2016 02:52'!
at: aPoint put: anObject
	^ (rows at: aPoint x) at: aPoint y put: anObject! !

!YoungTableau methodsFor: 'accessing' stamp: 'len 8/1/2016 03:19'!
diagram
	^ YoungDiagram shape: self shape! !

!YoungTableau methodsFor: 'accessing' stamp: 'len 4/5/2018 15:20:19'!
height
	^ rows size! !

!YoungTableau methodsFor: 'accessing' stamp: 'len 7/12/2016 00:07'!
rank
	^ rows sum: [:each| each size]! !

!YoungTableau methodsFor: 'accessing' stamp: 'len 7/11/2016 21:47'!
rows
	^ rows! !

!YoungTableau methodsFor: 'accessing' stamp: 'len 7/11/2016 22:34'!
shape
	^ rows collect: [:each| each size]! !

!YoungTableau methodsFor: 'accessing' stamp: 'len 7/12/2016 00:06'!
weight
	| answer |
	answer _ Array new: self rank.
	answer atAllPut: 0.
	self do: [:each| answer at: each put: (answer at: each) + 1].
	^ answer! !

!YoungTableau methodsFor: 'accessing' stamp: 'len 4/5/2018 15:20:10'!
width
	^ rows first size! !

!YoungTableau methodsFor: 'copying' stamp: 'len 7/11/2016 22:07'!
copy
	^ self class rows: (rows collect: [:each| each copy])! !

!YoungTableau methodsFor: 'enumerating' stamp: 'len 7/11/2016 22:11'!
do: aBlock
	rows do: [:each| each do: aBlock]! !

!YoungTableau methodsFor: 'enumerating' stamp: 'len 8/1/2016 02:54'!
withIndexDo: aBlock
	rows withIndexDo: [:row :i| row withIndexDo: [:each :j| aBlock value: each value: i@j]]! !

!YoungTableau methodsFor: 'testing' stamp: 'len 8/1/2016 02:36'!
isSemistandard
	self withIndexDo: [:each :index|
		(index x > 1 and: [each < (self at: index x - 1 @ index y)])
			ifTrue: [^ false].
		(index y > 1 and: [each < (self at: index x @ (index y - 1))])
			ifTrue: [^ false]].
	^ true! !

!YoungTableau methodsFor: 'testing' stamp: 'len 7/12/2016 00:15'!
isStandard
	"if it is semistandard and content = (1,1,..,1)"
	self withIndexDo: [:each :index|
		(index x > 1 and: [each <= (self at: index x - 1 @ index y)])
			ifTrue: [^ false].
		(index y > 1 and: [each <= (self at: index x @ (index y - 1))])
			ifTrue: [^ false]].
	^ true! !

!YoungTableau methodsFor: 'arithmetic' stamp: 'len 4/5/2018 15:43:58'!
negated
	self height = 1 ifTrue: [^ self].
	^ self copy at: 1@1 put: (self at: 1@2); at: 1@2 put: (self at: 1@1); yourself! !

!YoungTableau methodsFor: 'arithmetic' stamp: 'len 7/11/2016 21:56'!
sign
	self notYetImplemented! !

!YoungTableau methodsFor: 'initialization' stamp: 'len 7/11/2016 21:37'!
rows: anArray
	rows _ anArray! !

!YoungTableau class methodsFor: 'instance creation' stamp: 'len 7/11/2016 21:47'!
rows: anArray
	^ self basicNew rows: anArray! !

!YoungTableau class methodsFor: 'instance creation' stamp: 'len 7/11/2016 22:33'!
shape: anArray
	^ self rows: (anArray collect: [:each| Array new: each])! !

!Simplex methodsFor: 'operations' stamp: 'len 2/15/2017 08:55:06'!
* aSimplex
	"Answer the join of the receiver with the argument."
	^ self class vertices: (self vertices collect: [:x| {1. x}]), (aSimplex vertices collect: [:y| {2. y}])! !

!Simplex methodsFor: 'operations' stamp: 'len 5/10/2019 04:33:50'!
/\ aSimplex
	"Answer the face common to the receiver and aSimplex, which could be {}."
	^ self class vertices: self vertices /\ aSimplex vertices! !

!Simplex methodsFor: 'operations' stamp: 'len 2/19/2017 08:24:44'!
closure
	"Answer the simplicial complex with the receiver. By definition of simplicial complex, it also contains all faces of the receiver)."
	^ SimplicialComplex facets: {self}! !

!Simplex methodsFor: 'operations' stamp: 'len 2/19/2017 09:31:02'!
complementIn: aCollection
	"Answer the complement of the receiver in the given vertex set.
	This is the simplex formed by the vertices in aCollection *not* in the receiver."
	^ self class vertices: aCollection \ vertices! !

!Simplex methodsFor: 'comparing' stamp: 'len 6/13/2016 09:34'!
< aSimplex
	"Answer true if the receiver is strictly contained in aSimplex as a face."
	^ aSimplex > self! !

!Simplex methodsFor: 'comparing' stamp: 'len 6/13/2016 09:33'!
<= aSimplex
	"Answer true if the receiver is contained in aSimplex as a face."
	^ aSimplex >= self! !

!Simplex methodsFor: 'comparing' stamp: 'len 2/24/2017 11:41:54'!
= aSimplex
	"Answer true if the receiver equals the argument."
	^ self vertices = aSimplex vertices

"before we didn't keep vertices sorted, so we could check of two differently oriented simplices were equal:
	| iv v |
	vertices isEmpty ifTrue: [^ aSimplex vertices isEmpty].
	v _ vertices first.
	iv _ aSimplex vertices indexOf: v ifAbsent: [^ false].
	vertices withIndexDo: [:each :i|
		each = (aSimplex vertices atWrap: i+iv-1) ifFalse: [^ false]].
	^ true"! !

!Simplex methodsFor: 'comparing' stamp: 'len 2/15/2017 08:52:49'!
> aSimplex
	"Answer true if the receiver strictly containes aSimplex as a face."
	^ vertices size > aSimplex vertices size and: [vertices includesAllOf: aSimplex vertices]! !

!Simplex methodsFor: 'comparing' stamp: 'len 2/15/2017 08:56:30'!
>= aSimplex
	"Answer true if the receiver containes aSimplex as a face."
	^ vertices size >= aSimplex vertices size and: [vertices includesAllOf: aSimplex vertices]! !

!Simplex methodsFor: 'comparing' stamp: 'len 2/15/2017 08:14:56'!
~ aSimplex
	"Answer true if the receiver and the argument are isomorphic."
	^ self dimension = aSimplex dimension! !

!Simplex methodsFor: 'comparing' stamp: 'len 2/23/2017 19:08:39'!
hash
	^ vertices inject: 0 into: [:sum :each| sum + each hash] "this is independent of orientation"! !

!Simplex methodsFor: 'converting' stamp: 'len 2/14/2017 18:48:50'!
asSkeletonGraph
	| graph F |
	graph _ Graph unordered.
	F _ self faces: self dimension.
	graph addAll: self facets.
	F do: [:x| F do: [:y| graph addEdgeFrom: x to: y]].
	^ graph! !

!Simplex methodsFor: 'enumerating' stamp: 'len 2/24/2017 11:44:43'!
collect: aBlock
	^ self class vertices: (self vertices collect: aBlock) asSet "we don't assume aBlock is injective, so we have to convert to a Set to remove repetitions"! !

!Simplex methodsFor: 'enumerating' stamp: 'len 2/20/2017 18:49:55'!
do: aBlock
	^ self vertices do: aBlock! !

!Simplex methodsFor: 'accessing' stamp: 'len 2/15/2017 08:52:17'!
dimension
	^ vertices size - 1! !

!Simplex methodsFor: 'accessing' stamp: 'len 2/23/2017 10:20:17'!
size
	^ vertices size! !

!Simplex methodsFor: 'accessing' stamp: 'len 2/15/2017 08:56:46'!
vertices
	^ vertices! !

!Simplex methodsFor: 'accessing' stamp: 'len 2/23/2016 02:13'!
volume
	^ self notYetImplemented "see wikipedia"! !

!Simplex methodsFor: 'faces' stamp: 'len 2/23/2016 02:02'!
edges
	^ self faces: 1! !

!Simplex methodsFor: 'faces' stamp: 'len 6/13/2016 00:00'!
faces
	"Answer all faces of the receiver (including the empty set and the receiver)."
	^ Iterator on: [:aBlock| self facesDo: aBlock]! !

!Simplex methodsFor: 'faces' stamp: 'len 2/15/2017 08:09:38'!
faces: n
	"Answer the n-faces of the receiver."
	^ Iterator on: [:aBlock| self faces: n do: aBlock]! !

!Simplex methodsFor: 'faces' stamp: 'len 2/23/2017 18:55:13'!
faces: n do: aBlock
	"Iterate over the n-faces of the receiver."
	n = -1 ifTrue: [^ aBlock value: (self class vertices: #())].
	vertices isEmpty ifTrue: [^ self].
	vertices combinations: n+1 atATimeDo: [:each|
		aBlock value: (self class vertices: each asSet)]! !

!Simplex methodsFor: 'faces' stamp: 'len 6/12/2016 23:59'!
facesDo: aBlock
	"Iterate over all faces of the receiver (including the empty set and the receiver)."
	-1 to: self dimension do: [:i| self faces: i do: aBlock]! !

!Simplex methodsFor: 'faces' stamp: 'len 6/13/2016 00:09'!
facets
	"Answer the boundary faces of the receiver."
	^ self faces: self dimension - 1! !

!Simplex methodsFor: 'faces' stamp: 'len 6/12/2016 23:59'!
properFaces
	"Answer all proper faces of the receiver of any dimension (including the empty set)."
	^ Iterator on: [:aBlock| self properFacesDo: aBlock]! !

!Simplex methodsFor: 'faces' stamp: 'len 6/12/2016 23:59'!
properFacesDo: aBlock
	"Iterate over all proper faces of the receiver (including the empty set)."
	-1 to: self dimension - 1 do: [:i| self faces: i do: aBlock]! !

!Simplex methodsFor: 'faces' stamp: 'len 2/27/2016 08:15'!
ridges
	^ self faces: self dimension - 2! !

!Simplex methodsFor: 'testing' stamp: 'len 2/20/2017 18:49:36'!
includes: anObject
	^ vertices includes: anObject! !

!Simplex methodsFor: 'testing' stamp: 'len 2/19/2017 10:39:56'!
intersects: aSimplex
	^ self vertices intersects: aSimplex vertices! !

!Simplex methodsFor: 'testing' stamp: 'len 2/19/2017 18:20:51'!
isTrivial
	"Answer true if this is the empty simplex."
	^ vertices isEmpty! !

!Simplex methodsFor: 'private' stamp: 'len 2/20/2017 19:04:07'!
species
	^ Set! !

!Simplex methodsFor: 'accessing-private' stamp: 'len 2/24/2017 11:32:53'!
vertices: aCollection
	vertices _ aCollection asSortedCollection! !

!Simplex class methodsFor: 'instance creation' stamp: 'len 2/15/2017 08:54:40'!
new: n
	"Answer the standard n-simplex {1,...,n}."
	^ self vertices: (1 to: n+1)! !

!Simplex class methodsFor: 'instance creation' stamp: 'len 2/15/2017 08:54:35'!
newFrom: aCollection
	^ self vertices: aCollection! !

!Simplex class methodsFor: 'instance creation' stamp: 'len 2/15/2017 08:54:28'!
vertices: aCollection
	^ self new vertices: aCollection! !

!MonomialIndexedTuple methodsFor: 'printing' stamp: 'len 2/25/2017 09:44:26'!
printCoefficient: coefficient on: aStream
	| c |
	((c _ coefficient) printString first = $- "or: [coefficient isNumber and: [coefficient negative]]")
		ifTrue: [aStream nextPut: $-. c _ c negated].
	((c isKindOf: Polynomial) and: [c isMonomial])
		ifTrue: [aStream print: c. ^ self].
	(c printString allSatisfy: [:each| each isAlphaNumeric or: ['{}()/' includes: each]])
		ifTrue: [aStream print: c. ^ self].
	aStream nextPut: $(; print: c; nextPut: $)! !

!MonomialIndexedTuple methodsFor: 'printing' stamp: 'len 2/25/2017 08:48:39'!
printOn2: aStream
	aStream nextPut: $(.
	associations do: [:each| aStream print: each] separatedBy: [aStream nextPutAll: ', '].
	aStream nextPut: $)! !

!MonomialIndexedTuple methodsFor: 'operations' stamp: 'len 11/20/2016 16:56:16'!
* aNumber
	^ self collect: [:each| each*aNumber]! !

!MonomialIndexedTuple methodsFor: 'operations' stamp: 'len 11/29/2016 10:24:36'!
+ aMonomialTuple
	| newAssociations |
	newAssociations _ OrderedCollection new: self size + aMonomialTuple size.
	newAssociations resetTo: 1.
	self sum: associations with: aMonomialTuple associations into: newAssociations.
	^ self class associations: newAssociations over: scalars! !

!MonomialIndexedTuple methodsFor: 'operations' stamp: 'len 11/20/2016 16:55:37'!
- aMonomialTuple
	^ self + aMonomialTuple negated! !

!MonomialIndexedTuple methodsFor: 'operations' stamp: 'len 11/28/2016 22:03:32'!
/ aNumber
	self flag: #fix.
	^ self collectNoZero: [:each| each / aNumber] "this could be slow, could take reciprocal many times"! !

!MonomialIndexedTuple methodsFor: 'operations' stamp: 'len 11/28/2016 18:59:06'!
// aNumber
	^ self collect: [:each| each // aNumber]! !

!MonomialIndexedTuple methodsFor: 'operations' stamp: 'len 2/6/2017 03:14:46'!
/// aNumber
	^ self collect: [:each| each /// aNumber]! !

!MonomialIndexedTuple methodsFor: 'operations' stamp: 'len 11/28/2016 18:59:11'!
\\ aNumber
	^ self collect: [:each| each \\ aNumber]! !

!MonomialIndexedTuple methodsFor: 'operations' stamp: 'len 4/29/2019 10:19:26'!
 aMonomialTuple
	| answer |
	self flag: #fix. "optimize"
	self size <= aMonomialTuple size ifFalse: [^ aMonomialTuple  self].
	answer _ scalars zero.
	associations do: [:each| aMonomialTuple at: each key ifPresent: [:value2| answer _ answer + (each value*value2)]].
	^ answer! !

!MonomialIndexedTuple methodsFor: 'operations' stamp: 'len 3/6/2017 16:28:36'!
convolution22: aMonomialTuple
	| a b b2 c1 c2 c t |
	self size <= aMonomialTuple size
		ifTrue: [a _ associations. b _ aMonomialTuple associations]
		ifFalse: [a _ aMonomialTuple associations. b _ associations].
	c1 _ OrderedCollection new: a size + b size.
	c2 _ OrderedCollection new: a size + b size.
	c _ c1.
	b2 _ Array new: b size.
	a do: [:ai|
		1 to: b size do: [:i| | bi |
			bi _ b at: i.
			b2 at: i put: ai key * bi key -> (ai value * bi value)].
		t _ c1 == c ifTrue: [c2] ifFalse: [c1].
		t resetTo: 1.
		c _ self sum: c with: b2 into: t].
	^ self class associations: c over: scalars! !

!MonomialIndexedTuple methodsFor: 'operations' stamp: 'len 11/21/2016 13:04:43'!
convolution2: aMonomialTuple
	| a b answer temp |
	self size <= aMonomialTuple size
		ifTrue: [a _ associations. b _ aMonomialTuple associations]
		ifFalse: [a _ aMonomialTuple associations. b _ associations].
	answer _ self class over: scalars.
	temp _ Array new: b size.
	a do: [:each|
		1 to: b size do: [:i| | other | other _ b at: i. temp at: i put: other key * each key -> (other value * each value)].
		answer _ answer + (self class associations: temp over: scalars)].
	^ answer! !

!MonomialIndexedTuple methodsFor: 'operations' stamp: 'len 11/30/2016 14:46:11'!
convolution3: aMonomialTuple
	| dictionary newAssociations |
	dictionary _ Dictionary new: self size + aMonomialTuple size.
	self associationsDo: [:each|
		aMonomialTuple associationsDo: [:other|
			dictionary at: each key * other key add: each value * other value]].
	newAssociations _ OrderedCollection new: dictionary size.
	newAssociations resetTo: 1.
	dictionary associationsDo: [:each| each value isZero ifFalse: [newAssociations add: each]].
	newAssociations sort.
	^ self class associations: newAssociations over: scalars! !

!MonomialIndexedTuple methodsFor: 'operations' stamp: 'len 3/6/2017 16:29:09'!
convolution4: aMonomialTuple
	| a b c |
	self size <= aMonomialTuple size
		ifTrue: [a _ associations. b _ aMonomialTuple associations]
		ifFalse: [a _ aMonomialTuple associations. b _ associations].
	(a size < 25 and: [a size * 2 < b size])
		ifTrue:
			[| c1 c2 b2 t |
			c1 _ OrderedCollection new: a size + b size.
			c2 _ OrderedCollection new: a size + b size.
			c _ c1.
			b2 _ Array new: b size.
			a do: [:ai|
				1 to: b size do: [:i| | bi |
					bi _ b at: i.
					b2 at: i put: ai key * bi key -> (ai value * bi value)].
				t _ c1 == c ifTrue: [c2] ifFalse: [c1].
				t resetTo: 1.
				c _ self sum: c with: b2 into: t]]
		ifFalse: "if the sizes are not right, it's faster to use a hash table"
			[| dictionary |
			dictionary _ Dictionary new: a size + b size.
			a do: [:ai|
				b do: [:bi|
				dictionary at: ai key * bi key add: ai value * bi value]].
			c _ OrderedCollection new: dictionary size.
			c resetTo: 1.
			dictionary associationsDo: [:each| each value isZero ifFalse: [c add: each]].
			c sort].
	^ self class associations: c over: scalars! !

!MonomialIndexedTuple methodsFor: 'operations' stamp: 'len 11/30/2016 14:46:18'!
convolution: aMonomialTuple
	| dictionary newAssociations |
	dictionary _ Dictionary new: self size + aMonomialTuple size.
	self associationsDo: [:each|
		aMonomialTuple associationsDo: [:other|
			dictionary at: each key * other key add: each value * other value]].
	newAssociations _ OrderedCollection new: dictionary size.
	newAssociations resetTo: 1.
	dictionary associationsDo: [:each| each value isZero ifFalse: [newAssociations add: each]].
	newAssociations sort.
	^ self class associations: newAssociations over: scalars! !

!MonomialIndexedTuple methodsFor: 'operations' stamp: 'len 11/29/2016 09:30:44'!
dividedByMonomial: aMonomial
	"The monomial ordering is preserved by this operation."
	^ self class associations: (associations collect: [:each| each key / aMonomial -> each value]) over: scalars! !

!MonomialIndexedTuple methodsFor: 'operations' stamp: 'len 11/29/2016 09:30:48'!
multipliedByMonomial: aMonomial
	"The monomial ordering is preserved by this operation."
	^ self class associations: (associations collect: [:each| each key * aMonomial -> each value]) over: scalars! !

!MonomialIndexedTuple methodsFor: 'operations' stamp: 'len 11/20/2016 17:05:41'!
negated
	^ self class associations: (associations collect: [:each| each copy value: each value negated]) over: scalars! !

!MonomialIndexedTuple methodsFor: 'comparing' stamp: 'len 11/21/2016 09:14:40'!
= aMonomialTuple
	self size = aMonomialTuple size ifFalse: [^ false].
	self == aMonomialTuple ifTrue: [^ true].
	^ associations = aMonomialTuple associations! !

!MonomialIndexedTuple methodsFor: 'comparing' stamp: 'len 11/21/2016 09:18:00'!
hash
	^ associations hash! !

!MonomialIndexedTuple methodsFor: 'accessing-private' stamp: 'len 11/21/2016 08:30:05'!
associations
	^ associations! !

!MonomialIndexedTuple methodsFor: 'accessing-private' stamp: 'len 11/29/2016 08:52:12'!
associations: aCollection
"	(aCollection class == OrderedCollection) ifFalse: [^ self error: 'not an OrderedCollection']."
	associations _ aCollection! !

!MonomialIndexedTuple methodsFor: 'accessing-private' stamp: 'len 11/20/2016 10:26:40'!
scalars: aRing
	scalars _ aRing! !

!MonomialIndexedTuple methodsFor: 'enumerating' stamp: 'len 11/20/2016 17:02:42'!
associationsDo: aBlock
	associations do: aBlock! !

!MonomialIndexedTuple methodsFor: 'enumerating' stamp: 'len 11/28/2016 09:03:42'!
collect: aBlock
	| newAssociations |
	newAssociations _ OrderedCollection new: associations size.
	associations do: [:each| | newValue |
		(newValue _ aBlock value: each value) isZero
			ifFalse: [newAssociations add: (each copy value: newValue)]].
	^ self class associations: newAssociations over: scalars! !

!MonomialIndexedTuple methodsFor: 'enumerating' stamp: 'len 11/21/2016 08:50:46'!
collectNoZero: aBlock
	^ self class associations: (associations collect: [:each| each copy value: (aBlock value: each value)]) over: scalars! !

!MonomialIndexedTuple methodsFor: 'enumerating' stamp: 'len 11/20/2016 17:14:49'!
do: aBlock
	self associationsDo: [:each| aBlock value: each value]! !

!MonomialIndexedTuple methodsFor: 'enumerating' stamp: 'len 11/26/2016 07:40:36'!
keysAndValuesDo: aBlock
	associations do: [:each| aBlock value: each key value: each value]! !

!MonomialIndexedTuple methodsFor: 'enumerating' stamp: 'len 11/26/2016 07:40:24'!
keysDo: aBlock
	associations do: [:each| aBlock value: each key]! !

!MonomialIndexedTuple methodsFor: 'accessing' stamp: 'len 11/20/2016 10:36:07'!
at: aMonomial
	^ self at: aMonomial ifAbsent: [scalars zero]! !

!MonomialIndexedTuple methodsFor: 'accessing' stamp: 'len 11/28/2016 09:05:54'!
at: aMonomial add: aNumber
	associations isEmpty ifTrue: [aNumber isZero ifFalse: [associations add: aMonomial -> aNumber]. ^ self].
	associations
		findBinaryIndex: [:each| (each key compare: aMonomial) negated]
		do: [:index| | association newValue |
			association _ associations at: index.
			(newValue _ association value + aNumber) isZero
				ifTrue: [associations removeIndex: index]
				ifFalse: [association value: newValue "associations at: index put: aMonomial -> newValue"]]
		ifNone: [:low :high| aNumber isZero ifFalse: [associations add: aMonomial -> aNumber beforeIndex: high]]! !

!MonomialIndexedTuple methodsFor: 'accessing' stamp: 'len 11/26/2016 08:01:58'!
at: aMonomial ifAbsent: exceptionBlock
	^ associations findBinary: [:each| (each key compare: aMonomial) negated] do: [:each| each value] ifNone: [:high :low| exceptionBlock value]! !

!MonomialIndexedTuple methodsFor: 'accessing' stamp: 'len 11/20/2016 17:04:43'!
at: key ifPresent: presentBlock
	"Lookup the given key in the receiver. If it is present, answer the value of evaluating the given block with the value associated with the key. Otherwise, answer nil."

	| v |
	v _ self at: key ifAbsent: [ ^ nil ].
	^ presentBlock value: v! !

!MonomialIndexedTuple methodsFor: 'accessing' stamp: 'len 11/27/2016 08:32:12'!
at: aMonomial put: aNumber
	associations isEmpty ifTrue: [aNumber isZero ifFalse: [associations add: aMonomial -> aNumber]. ^ self].
	associations
		findBinaryIndex: [:each| (each key compare: aMonomial) negated]
		do: [:index| aNumber isZero ifTrue: [associations removeIndex: index] ifFalse: [(associations at: index) value: aNumber]]
		ifNone: [:low :high| aNumber isZero ifFalse: [associations add: aMonomial -> aNumber beforeIndex: high]].
	^ aNumber! !

!MonomialIndexedTuple methodsFor: 'accessing' stamp: 'len 11/28/2016 18:51:33'!
lastKey
	^ associations isEmpty ifFalse: [associations last key]! !

!MonomialIndexedTuple methodsFor: 'accessing' stamp: 'len 1/25/2017 18:06:36'!
lastValue
	^ associations isEmpty ifFalse: [associations last value]! !

!MonomialIndexedTuple methodsFor: 'accessing' stamp: 'len 11/20/2016 10:26:33'!
scalars
	^ scalars! !

!MonomialIndexedTuple methodsFor: 'accessing' stamp: 'len 11/21/2016 08:55:19'!
size
	^ associations size! !

!MonomialIndexedTuple methodsFor: 'copying' stamp: 'len 11/28/2016 09:27:34'!
copy
	^ self class associations: (associations collect: [:each| each copy]) over: scalars! !

!MonomialIndexedTuple methodsFor: 'testing' stamp: 'len 11/26/2016 07:38:01'!
isZero
	^ associations isEmpty! !

!MonomialIndexedTuple methodsFor: 'converting' stamp: 'len 1/20/2017 09:34:47'!
over: aRing
	| newAssociations |
	self scalars = aRing ifTrue: [^ self].
	newAssociations _ OrderedCollection new: associations size.
	associations do: [:each| | newValue |
		(newValue _ aRing !! each value) isZero
			ifFalse: [newAssociations add: (each copy value: newValue)]].
	^ self class associations: newAssociations over: aRing! !

!MonomialIndexedTuple methodsFor: 'private' stamp: 'len 11/29/2016 09:52:21'!
sum: someAssociations with: otherAssociations into: newAssociations
	| stream1 stream2 |
	stream1 _ someAssociations readStream.
	stream2 _ otherAssociations readStream.
	[stream1 atEnd or: [stream2 atEnd]]
		whileFalse:
			[| cmp |
			cmp _ stream1 peek key compare: stream2 peek key.
			cmp < 0
				ifTrue: [newAssociations add: stream1 next copy]
				ifFalse: [cmp > 0
					ifTrue: [newAssociations add: stream2 next copy]
					ifFalse:
						[| a b newValue |
						a _ stream1 next.
						b _ stream2 next.
						(newValue _ a value + b value) isZero
							ifFalse: [newAssociations add: (a copy value: newValue)]]]].
	[stream1 atEnd] whileFalse: [newAssociations add: stream1 next copy].
	[stream2 atEnd] whileFalse: [newAssociations add: stream2 next copy].
	^ newAssociations! !

!MonomialIndexedTuple class methodsFor: 'instance creation' stamp: 'len 11/20/2016 16:51:57'!
associations: aCollection over: aRing
	^ self basicNew scalars: aRing; associations: aCollection! !

!MonomialIndexedTuple class methodsFor: 'instance creation' stamp: 'len 11/20/2016 17:06:55'!
new: anInteger over: aRing
	^ self basicNew scalars: aRing; associations: (OrderedCollection new: anInteger)! !

!MonomialIndexedTuple class methodsFor: 'instance creation' stamp: 'len 11/20/2016 16:52:13'!
over: aRing
	^ self basicNew scalars: aRing; associations: OrderedCollection new! !

!CompositeGraphMorph methodsFor: 'as yet unclassified' stamp: 'len 7/30/2016 07:36'!
addComponent: aGraphMorph
	self addMorph: aGraphMorph proportionalWidth: 1! !

!CompositeGraphMorph methodsFor: 'as yet unclassified' stamp: 'len 7/30/2016 07:41'!
componentsDo: aBlock
	self submorphsDo: [:each| (each isKindOf: GraphMorph) ifTrue: [aBlock value: each]]! !

!CompositeGraphMorph methodsFor: 'as yet unclassified' stamp: 'len 7/30/2016 07:41'!
dimension: anInteger
	self componentsDo: [:each| each dimension: anInteger]! !

!CompositeGraphMorph methodsFor: 'as yet unclassified' stamp: 'len 7/31/2016 05:08'!
edgeAt: anEdge 
	^ self nodeAt: anEdge ifAbsent: [self error: 'edge not found']! !

!CompositeGraphMorph methodsFor: 'as yet unclassified' stamp: 'len 7/31/2016 05:08'!
edgeAt: anEdge ifAbsent: exceptionBlock
	self componentsDo: [:each| (each edgeAt: anEdge ifAbsent: []) ifNotNil: [:edge| ^edge]].
	^ exceptionBlock value! !

!CompositeGraphMorph methodsFor: 'as yet unclassified' stamp: 'len 7/31/2016 05:02'!
edgesAndLabelsDo: aBlock 
	self componentsDo: [:each| each edgesAndLabelsDo: aBlock]! !

!CompositeGraphMorph methodsFor: 'as yet unclassified' stamp: 'len 7/30/2016 07:43'!
hideLabels
	self componentsDo: [:each| each hideLabels]! !

!CompositeGraphMorph methodsFor: 'as yet unclassified' stamp: 'len 7/30/2016 07:38'!
initialize
	super initialize.
	self color: Color transparent.
	self morphExtent: 600 @ 300! !

!CompositeGraphMorph methodsFor: 'as yet unclassified' stamp: 'len 7/31/2016 05:06'!
nodeAt: anObject 
	^ self nodeAt: anObject ifAbsent: [self error: 'node not found']! !

!CompositeGraphMorph methodsFor: 'as yet unclassified' stamp: 'len 7/31/2016 05:05'!
nodeAt: anObject ifAbsent: exceptionBlock
	self componentsDo: [:each| (each nodeAt: anObject ifAbsent: []) ifNotNil: [:node| ^node]].
	^ exceptionBlock value! !

!CompositeGraphMorph methodsFor: 'as yet unclassified' stamp: 'len 7/31/2016 05:03'!
nodesDo: aBlock
	self componentsDo: [:each| each nodesDo: aBlock]! !

!GraphMorph methodsFor: 'event handling' stamp: 'len 2/19/2016 02:05'!
acceptDroppingMorph: aMorph event: evt
	(aMorph isKindOf: self nodeClass)
		ifTrue: [self addMorph: aMorph.
				"self focusOn: aMorph node".
				^ self startStepping].
	^ super acceptDroppingMorph: aMorph event: evt! !

!GraphMorph methodsFor: 'event handling' stamp: 'len 7/9/2016 22:52'!
allowSubmorphExtraction
	" allow extraction so submorphs can be grabbed and dragged to a new position.
	  usefull to rearrange the vertices manually"
	^ true! !

!GraphMorph methodsFor: 'event handling' stamp: 'len 7/9/2016 22:51'!
handlesMouseDown: aMouseButtonEvent
	"Do I want to receive mouseDown events (mouseDown:, mouseMove:, mouseUp:)?"
	^true! !

!GraphMorph methodsFor: 'event handling' stamp: 'len 7/9/2016 22:51'!
mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition
	super mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition.
	lastMousePosition _ localEventPosition! !

!GraphMorph methodsFor: 'event handling' stamp: 'len 7/9/2016 22:51'!
mouseMove: aMouseMoveEvent localPosition: localEventPosition
	lastMousePosition isNil
		ifFalse:
			[aMouseMoveEvent shiftPressed
				ifTrue:
					[| bounds d |
					bounds _ self morphLocalBounds.
					d _ (localEventPosition dist: lastMousePosition) / (bounds width min: bounds height).
					localEventPosition y >= lastMousePosition y ifTrue: [d _ d negated].
					self scaleEdgesBy: 2.0 ^ d]
				ifFalse: [self rotateNodesBy: lastMousePosition - localEventPosition]].
	lastMousePosition _ localEventPosition! !

!GraphMorph methodsFor: 'event handling' stamp: 'len 7/9/2016 22:51'!
rotateNodesBy: aPoint
	| xSpeed ySpeed |
	self dimension < 3 ifTrue: [^ self].
	xSpeed _ Float pi / self morphLocalBounds width.
	ySpeed _ Float pi / self morphLocalBounds height.
"	self dimension = 2 ifTrue: [self nodesDo: [:each| |p pp| p _ each x. pp _ p x @ p y rotatedBy: aPoint y * ySpeed negated + (aPoint x * xSpeed). each x: (pp x, pp y)]. ^ self]."
	self nodesDo: [:each| | p xz yz |
		p _ each x.
		xz _ p x @ p z.
		xz _ xz rotatedBy: aPoint x * xSpeed.
		yz _ p y @ xz y.
		yz _ yz rotatedBy: aPoint y * ySpeed.
		p _ (xz x, yz x, yz y).
		each x: p.
		each dx: p * 0. "optimization, dont rotate the velocities"].
	self startStepping! !

!GraphMorph methodsFor: 'private' stamp: 'len 2/12/2003 23:34'!
addEdge: anEdge
	^ self addEdge: anEdge label: nil! !

!GraphMorph methodsFor: 'private' stamp: 'len 7/14/2016 05:25'!
addEdge: anEdge label: label 
	| src dest |
	src _ self graph nodeAt: anEdge key.
	dest _ self graph nodeAt: anEdge value.
	^ self privateAddEdgeFrom: src to: dest label: label! !

!GraphMorph methodsFor: 'private' stamp: 'len 7/14/2016 05:42'!
addNode: aGraphNode 
	| morph |
	(nodeToMorph includesKey: aGraphNode)
		ifTrue: [^ nodeToMorph at: aGraphNode].
	morph _ self nodeClass new node: aGraphNode.
	morph dimension: dimension.
	nodeToMorph at: aGraphNode put: morph.
	morph morphPosition: self morphWidth asInteger atRandom @ self morphHeight asInteger atRandom.
	self addMorph: morph.
"	aGraphNode
		neighborsAndLabelsDo: [:each :label|
			self addNode: each.
			self privateAddEdgeFrom: aGraphNode to: each label: label]."
	^ morph! !

!GraphMorph methodsFor: 'private' stamp: 'len 7/9/2016 22:26'!
edgeClass
	^ GraphEdgeMorph! !

!GraphMorph methodsFor: 'private' stamp: 'len 7/9/2016 22:26'!
nodeClass
	^ GraphNodeMorph! !

!GraphMorph methodsFor: 'private' stamp: 'len 7/14/2016 05:38'!
privateAddEdgeFrom: source to: target label: label
	| edge morph |
	edge _ source -> target.
	graph isDirected ifFalse: [edge _ edge as: MutualAssociation].
	(edgeToMorph includesKey: edge)
		ifTrue: [^ (edgeToMorph at: edge) incrementMultiplicity].
	morph _ self edgeClass new.
	edgeToMorph at: edge put: morph.
	morph source: (nodeToMorph at: source); target: (nodeToMorph at: target).
	morph label: label.
	graph isDirected ifTrue: [morph showArrowHead] ifFalse: [morph hideArrowHead].
	self addMorphBack: morph.
	^ morph! !

!GraphMorph methodsFor: 'private' stamp: 'len 7/14/2016 05:39'!
privateRemoveEdgeFrom: source to: target label: label 
	| edge |
	edge _ source -> target.
	graph isDirected ifFalse: [edge _ edge as: MutualAssociation].
	(edgeToMorph removeKey: edge ifAbsent: [^ self]) delete! !

!GraphMorph methodsFor: 'private' stamp: 'timestamp) (no'!
removeEdge: anEdge 
	^ self removeEdge: anEdge label: nil! !

!GraphMorph methodsFor: 'private' stamp: 'len 2/17/2016 23:06'!
removeEdge: anEdge label: label 
	^ self privateRemoveEdgeFrom: anEdge key to: anEdge value label: label! !

!GraphMorph methodsFor: 'stepping' stamp: 'len 7/9/2016 22:47'!
alignToCenter
	| centerOfMass delta |
	centerOfMass _ nodeToMorph anyOne x * 0. "0@0"
	self nodesDo: [:each| centerOfMass _ centerOfMass + each x].
	centerOfMass _ centerOfMass / graph size.
	centerOfMass isZero ifTrue: [^ self].
	delta _ centerOfMass negated.
	self nodesDo: [:each| each translateBy: delta]! !

!GraphMorph methodsFor: 'stepping' stamp: 'len 7/9/2016 22:48'!
step
	| maxDelta |
	self nodesDo: [:each| each dampBy: 1.1]. "damping"
	self alignToCenter.
	maxDelta _ 0.
	self nodesDo: [:each| maxDelta _ maxDelta max: each doMove].
	self edgesDo: [:each| each adjustBounds].
	self redrawNeeded.
	maxDelta < 0.1 ifTrue: [self stopStepping]! !

!GraphMorph methodsFor: 'stepping' stamp: 'len 7/9/2016 22:48'!
stepTime
	^ 0! !

!GraphMorph methodsFor: 'stepping' stamp: 'len 7/9/2016 22:48'!
wantsSteps
	^ true! !

!GraphMorph methodsFor: 'layout' stamp: 'sam 6/1/2004 14:37'!
clearAll
	self clearEdges.
	self clearNodes.
	! !

!GraphMorph methodsFor: 'layout' stamp: 'len 2/14/2016 22:48'!
clearEdges
	self edgesDo: [:edgeMorph| edgeMorph delete].
	self initializeEdgeToMorph! !

!GraphMorph methodsFor: 'layout' stamp: 'len 2/14/2016 22:48'!
clearNodes
	self nodesDo: [:nodeMorph | nodeMorph delete].
	self initializeNodeToMorph! !

!GraphMorph methodsFor: 'accessing' stamp: 'len 7/9/2016 22:45'!
dimension
	^ dimension! !

!GraphMorph methodsFor: 'accessing' stamp: 'len 7/9/2016 22:45'!
dimension: anInteger
	dimension _ anInteger.
	self nodesDo: [:each| each dimension: anInteger].
	self startStepping! !

!GraphMorph methodsFor: 'accessing' stamp: 'len 7/31/2016 05:09'!
edgeAt: anEdge
	^ self edgeAt: anEdge ifAbsent: [self error: 'edge not found']! !

!GraphMorph methodsFor: 'accessing' stamp: 'len 7/31/2016 05:09'!
edgeAt: anEdge ifAbsent: exceptionBlock
	| edge |
	edge _ anEdge key -> anEdge value.
	graph isDirected ifFalse: [edge _ edge as: MutualAssociation].
	^ edgeToMorph at: edge ifAbsent: exceptionBlock! !

!GraphMorph methodsFor: 'accessing' stamp: 'len 5/4/2016 06:50'!
edges
	^ Iterator on: self performing: #edgesDo:! !

!GraphMorph methodsFor: 'accessing' stamp: 'Samir Saidani 12/16/2003 02:02'!
focusNode
	^focusNode! !

!GraphMorph methodsFor: 'accessing' stamp: 'len 7/9/2016 23:00'!
focusOn: aNode
	focusNode _ graph nodeAt: aNode.
	nodeToMorph at: focusNode ifPresent: [:aMorph| aMorph freeze].
	self startStepping! !

!GraphMorph methodsFor: 'accessing' stamp: 'len 2/14/2016 22:45'!
graph
	^ graph! !

!GraphMorph methodsFor: 'accessing' stamp: 'len 7/14/2016 05:42'!
graph: aGraph
	self clearAll.
	graph _ aGraph.
	graph nodesDo: [:each| self addNode: each].
	graph edgesAndLabelsDo: [:each :label| self addEdge: each label: label].
	graph
		when: #addNode: send: #addNode: to: self;
		when: #addEdge: send: #addEdge: to: self;
		when: #removeNode: send: #removeNode: to: self;
		when: #removeEdge: send: #removeEdge: to: self.
	(graph isKindOf: RootedDigraph)
		ifTrue: [self focusOn: graph rootNode]
		ifFalse: [self focusOn: graph anyOne]! !

!GraphMorph methodsFor: 'accessing' stamp: 'len 7/9/2016 22:45'!
hideLabels
	self nodesDo: [:each| each hideLabel].
	self edgesDo: [:each| each hideLabel]! !

!GraphMorph methodsFor: 'accessing' stamp: 'len 7/31/2016 05:07'!
nodeAt: anObject
	^ nodeToMorph at: anObject! !

!GraphMorph methodsFor: 'accessing' stamp: 'len 7/31/2016 05:06'!
nodeAt: anObject ifAbsent: exceptionBlock
	^ nodeToMorph at: anObject ifAbsent: exceptionBlock! !

!GraphMorph methodsFor: 'accessing' stamp: 'len 2/17/2016 23:11'!
origin
	^ (nodeToMorph at: (focusNode ifNil: [^ self morphExtent // 2])) morphBounds center! !

!GraphMorph methodsFor: 'accessing' stamp: 'len 7/9/2016 22:45'!
perturbate: n
	self nodesDo: [:each| each perturbate: n].
	self startStepping! !

!GraphMorph methodsFor: 'enumerating' stamp: 'len 2/29/2016 21:44'!
edgesAndLabelsDo: aBlock
	graph edgesAndLabelsDo: [:each :label| aBlock value: (self edgeAt: each) value: label]! !

!GraphMorph methodsFor: 'enumerating' stamp: 'len 2/15/2003 19:02'!
edgesDo: aBlock
	edgeToMorph do: aBlock! !

!GraphMorph methodsFor: 'enumerating' stamp: 'len 2/15/2003 18:58'!
nodesDo: aBlock
	nodeToMorph do: aBlock! !

!GraphMorph methodsFor: 'initialization' stamp: 'len 7/14/2016 02:56'!
initialize
	super initialize.
	self morphExtent: 300 @ 300.
	self color: Color transparent.
	self initializeNodeToMorph.
	self initializeEdgeToMorph.
	dimension _ 3! !

!GraphMorph methodsFor: 'initialization' stamp: 'Samir Saidani 12/7/2003 19:25'!
initializeEdgeToMorph
	edgeToMorph _ Dictionary new! !

!GraphMorph methodsFor: 'initialization' stamp: 'Samir Saidani 12/7/2003 19:25'!
initializeNodeToMorph
	nodeToMorph _ Dictionary new! !

!GraphMorph methodsFor: 'geometry' stamp: 'len 7/9/2016 22:53'!
privateExtent: aPoint
	^ (super privateExtent: aPoint) ifTrue: [self startStepping]; yourself! !

!SpringGraphMorph methodsFor: 'event handling' stamp: 'len 2/8/2003 00:38'!
allowSubmorphExtraction
	" allow extraction so submorphs can be grabbed and dragged to a new position.
	  usefull to rearrange the vertices manually"
	^ true! !

!SpringGraphMorph methodsFor: 'event handling' stamp: 'len 4/27/2016 08:01'!
scaleEdgesBy: aNumber
	self edgesDo: [:each| each desiredDistance: each desiredDistance * aNumber].
	self startStepping! !

!SpringGraphMorph methodsFor: 'stepping' stamp: 'len 4/30/2016 02:22'!
approachComponents
	| componentsDesiredDistance |
	(components isNil or: [components size < 2])
		ifTrue: [^ self].
	componentsDesiredDistance _ 1.
	components do: [:each|
		components do: [:other|
			each == other
				ifFalse:
					[| source target f currentDistance diff delta |
					source _ each atRandom.
					target _ other atRandom.
					(currentDistance _ (diff _ source x + source dx - target x - target dx) norm) > componentsDesiredDistance
						ifTrue:
							[f _ (componentsDesiredDistance - currentDistance) asFloat / (currentDistance * 4).
							delta _ diff * f / 2.
							"target dx: target dx - delta."
							source dx: source dx + (delta/other size)]]]]! !

!SpringGraphMorph methodsFor: 'stepping' stamp: 'len 2/25/2016 16:36'!
aproachConnectedNodes
	self edgesDo: [:each| each approachNodes]! !

!SpringGraphMorph methodsFor: 'stepping' stamp: 'len 2/19/2016 04:17'!
separateAllNodes
	self nodesDo: [:each | each separateFromAllNodes]! !

!SpringGraphMorph methodsFor: 'stepping' stamp: 'len 4/30/2016 02:23'!
step
	| maxDelta |
	self nodesDo: [:each| each dampBy: 1.1]. "damping"
	self aproachConnectedNodes; separateAllNodes; "approachComponents;" alignToCenter.
	maxDelta _ 0.
	self nodesDo: [:each| maxDelta _ maxDelta max: each doMove].
	self edgesDo: [:each| each adjustBounds].
	self redrawNeeded.
	maxDelta < 0.1 ifTrue: [self stopStepping]! !

!SpringGraphMorph methodsFor: 'accessing' stamp: 'len 4/26/2016 02:06'!
desiredDistance: aNumber
	^ self edgesDo: [:each| each desiredDistance: aNumber]! !

!SpringGraphMorph methodsFor: 'accessing' stamp: 'len 5/25/2016 03:15'!
graph: aGraph
	| morph desiredDistance |
	super graph: aGraph.
	(aGraph isKindOf: RootedDigraph)
		ifTrue: [morph _ nodeToMorph at: aGraph rootNode.
				morph morphAlign: morph morphBounds center with: self morphExtent // 2].
	aGraph size < 100
		ifTrue: [desiredDistance _ (self morphLocalBounds area / (aGraph radius min: 10) / 2) sqrt.
			components _ graph components asArray collect: [:each| each asArray collect: [:node| nodeToMorph at: node]]]
		ifFalse:
			[desiredDistance _ 10.
			components _ nil].
	self edgesDo: [:each| each desiredDistance: desiredDistance "/ each source node degree sqrt"]! !

!SpringGraphMorph methodsFor: 'private' stamp: 'len 2/15/2003 18:10'!
edgeClass
	^ SpringEdgeMorph! !

!SpringGraphMorph methodsFor: 'private' stamp: 'len 2/25/2016 17:42'!
nodeClass
	^ SpringNodeMorph! !

!GraphNodeMorph methodsFor: 'accessing' stamp: 'len 1/23/2017 09:33:59'!
alpha
	self dimension > 2 ifFalse: [^ 1.0].
	(owner isNil or: [x z >= 0]) ifTrue: [^ 1.0].
	^ (x z / owner morphExtent y + 1) squared min: 1.0 max: 0.0! !

!GraphNodeMorph methodsFor: 'accessing' stamp: 'len 7/9/2016 22:25'!
color
	^ color! !

!GraphNodeMorph methodsFor: 'accessing' stamp: 'len 7/9/2016 22:25'!
color: aColor
	color _ aColor! !

!GraphNodeMorph methodsFor: 'accessing' stamp: 'len 7/9/2016 22:39'!
dimension
	^ x size! !

!GraphNodeMorph methodsFor: 'accessing' stamp: 'len 11/5/2016 10:30'!
dimension: anInteger
	| n |
	(n _ x size) = anInteger
		ifTrue: [^ self].
	n > anInteger
		ifTrue:
			[x _ x copyFrom: 1 to: anInteger.
			dx _ dx copyFrom: 1 to: anInteger]
		ifFalse:
			[| z |
			z _ QQ tuple: anInteger - n evaluating: [:i| 0].
			x _ x, z.
			dx _ dx, z]! !

!GraphNodeMorph methodsFor: 'accessing' stamp: 'len 7/9/2016 22:41'!
dx
	^ dx! !

!GraphNodeMorph methodsFor: 'accessing' stamp: 'len 7/9/2016 22:41'!
dx: aVector
	dx _ aVector! !

!GraphNodeMorph methodsFor: 'accessing' stamp: 'len 2/18/2016 21:42'!
label
	^ label! !

!GraphNodeMorph methodsFor: 'accessing' stamp: 'len 2/18/2016 21:43'!
label: aString
	label _ aString.
	label notNil ifTrue: [self showLabel] ifFalse: [self hideLabel]! !

!GraphNodeMorph methodsFor: 'accessing' stamp: 'len 2/12/2003 23:20'!
node
	^ node! !

!GraphNodeMorph methodsFor: 'accessing' stamp: 'len 4/8/2016 23:02'!
node: aGraphNode 
	node _ aGraphNode.
	self label: node value printText! !

!GraphNodeMorph methodsFor: 'accessing' stamp: 'len 12/19/2016 12:38:16'!
radius
	^ extent x! !

!GraphNodeMorph methodsFor: 'accessing' stamp: 'len 12/19/2016 12:39:19'!
radius: aNumber
	self morphExtent: aNumber @ aNumber! !

!GraphNodeMorph methodsFor: 'accessing' stamp: 'len 2/18/2016 21:25'!
shape
	^ shape! !

!GraphNodeMorph methodsFor: 'accessing' stamp: 'len 2/18/2016 21:31'!
shape: aShapeSymbol
	shape _ aShapeSymbol.
	self redrawNeeded! !

!GraphNodeMorph methodsFor: 'accessing' stamp: 'len 2/18/2016 21:07'!
value
	^ node value! !

!GraphNodeMorph methodsFor: 'accessing' stamp: 'len 7/9/2016 22:14'!
x
	^ x! !

!GraphNodeMorph methodsFor: 'accessing' stamp: 'len 7/9/2016 22:14'!
x: aPoint
	x _ aPoint! !

!GraphNodeMorph methodsFor: 'moving' stamp: 'len 7/9/2016 22:40'!
dampBy: aNumber
	dx _ dx / aNumber! !

!GraphNodeMorph methodsFor: 'moving' stamp: 'len 7/9/2016 22:40'!
doMove
	| bounds delta |
	x _ x + dx.
	bounds _ owner morphLocalBounds.
	self morphPosition: bounds center + ((x at: 1) @ (x at: 2)).
	(bounds containsRect: self morphBounds)
		ifFalse: [delta _ 2 * (self morphBounds amountToTranslateWithin: bounds).
					x _ x + (delta x, delta y).
					self morphPosition: bounds center + ((x at: 1) @ (x at: 2)).
					dx _ dx * 0 "0@0"].
	^ dx norm! !

!GraphNodeMorph methodsFor: 'moving' stamp: 'len 7/9/2016 22:54'!
freeze
	dx _ dx * 0.0! !

!GraphNodeMorph methodsFor: 'moving' stamp: 'len 7/9/2016 22:42'!
perturbate: n
	dx _ dx + (dx collect: [:xi| n atRandom - n])! !

!GraphNodeMorph methodsFor: 'moving' stamp: 'len 7/9/2016 22:42'!
perturbation
	^ x collect: [:xi| 3 atRandom - 2]! !

!GraphNodeMorph methodsFor: 'moving' stamp: 'len 7/9/2016 22:42'!
translateBy: delta
	dx _ dx + delta! !

!GraphNodeMorph methodsFor: 'drawing' stamp: 'len 5/4/2016 06:37'!
drawOn: aCanvas
	(extent x abs < 2 and: [extent y abs < 2]) ifTrue: [^ self].
	shape == #circle
		ifTrue: [aCanvas fillEllipse: self morphLocalBounds color: self color. ^ self].
	shape == #square
		ifTrue: [aCanvas fillRectangle: self morphLocalBounds color: self color. ^ self].
	shape == #squareFrame
		ifTrue: [aCanvas frameRectangle: self morphLocalBounds borderWidth: 1 color: self color. ^ self].
	shape == #circleFrame
		ifTrue: [aCanvas frameEllipse: self morphLocalBounds borderWidth: 1 color: self color. ^ self].
	"otherwise do nothing"
	^ self! !

!GraphNodeMorph methodsFor: 'private' stamp: 'len 2/18/2016 21:42'!
hideLabel
	labelMorph notNil ifTrue: [labelMorph delete. labelMorph _ nil]! !

!GraphNodeMorph methodsFor: 'private' stamp: 'len 4/30/2016 06:55'!
showLabel
	(labelMorph notNil or: [label isNil]) ifTrue: [^ self].
	labelMorph _ StringMorph contents: label font: Preferences standardMenuFont.
	labelMorph color: Color white.
	self addMorph: labelMorph.
	labelMorph morphAlign: labelMorph morphBounds leftCenter with: self morphBounds rightCenter + (1@0)! !

!GraphNodeMorph methodsFor: 'initialization' stamp: 'len 7/9/2016 22:59'!
initialize
	super initialize.
	self color: Color gray.
	x _ (0,0).
	dx _ x.
	shape _ #circle.
	extent _ 10@10! !

!SpringNodeMorph methodsFor: 'event handling testing' stamp: 'len 7/9/2016 22:10'!
aboutToBeGrabbedBy: aHand 
	super aboutToBeGrabbedBy: aHand.
	(owner isKindOf: GraphMorph) ifTrue: ["owner focusOn: node; stopStepping"]! !

!SpringNodeMorph methodsFor: 'event handling testing' stamp: 'sam 2/10/2004 01:56'!
handlesMouseDown: evt 
	evt shiftPressed
		ifFalse: [^ super handlesMouseDown: evt]
		ifTrue: [^ true]! !

!SpringNodeMorph methodsFor: 'event handling testing' stamp: 'len 2/18/2016 06:02'!
wantsToBeDroppedInto: aMorph
	^ aMorph isKindOf: SpringGraphMorph! !

!SpringNodeMorph methodsFor: 'moving' stamp: 'len 3/6/2017 16:31:46'!
approachPoint: aPoint
	| dxNew x1 x2 diff |
	dxNew _ dx - dx. "0@0."
	x1 _ x.
	x2 _ aPoint.
	x1 = x2 ifTrue: [^ self].
	diff _ x1 - x2.
	dxNew _ dxNew + (diff / diff norm2).
	dxNew isZero ifFalse: [dx _ dx + (dxNew / dxNew norm * 2)]! !

!SpringNodeMorph methodsFor: 'moving' stamp: 'len 3/6/2017 16:32:42'!
separateFromAllNodes
	| dxNew x1 x2 |
	(owner isKindOf: SpringGraphMorph) ifFalse: [^ self].
	dxNew _ dx - dx. "0@0"
	x1 _ x.
	owner nodesDo: [:each|
		x2 _ each x + each dx.
		self == each
			ifFalse:
				[x1 = x2
					ifTrue: [dxNew _ dxNew + self perturbation]
					ifFalse:
						[| diff |
						diff _ x1 - x2.
						dxNew _ dxNew + (diff / diff norm2)]]].
	dxNew isZero ifFalse: [dx _ dx + (dxNew / dxNew norm * 2)]! !

!SpringNodeMorph methodsFor: 'private' stamp: 'len 2/29/2016 21:28'!
nearbyNodesDo: aBlock
	| count |
	count _ 0.
	node markDo: [:each |
		count _ count + 1.
		count > 40 ifTrue: [^ self].
		aBlock value: (owner nodeAt: each)]! !

!ComplexPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 12/6/2016 14:39:49'!
box: aRectangle
	box _ aRectangle.
	image _ nil.
	self redrawNeeded.
	self matchBoxRatio.! !

!ComplexPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 12/6/2016 16:53:54'!
buildImage
	image _ Form extent: self morphExtent depth: Display depth.
	1 to: image height do: [:j|
		| y |
		y _ j asFloat / image height * box height - box bottom.
		1 to: image width do: [:i|
			| x z c |
			x _ i asFloat / image width * box width - box right.
			z _ [function value: x + y i] on: ZeroDivide do: [Infinity projective].
			image colorAt: i@(image height - j + 1) put: (palette at: z)]]! !

!ComplexPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 12/6/2016 09:56:06'!
drawOn: aCanvas
	image isNil ifTrue: [self buildImage].
	aCanvas image: image at: 0@0! !

!ComplexPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 12/6/2016 09:56:01'!
function: aFunction
	function _ aFunction.
	image _ nil.
	self redrawNeeded! !

!ComplexPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 1/23/2017 09:46:10'!
initialize
	super initialize.
	extent _ 300@300.
	color _ Color lightGray.
	box _ -2@0 extent: 4@2.
	palette _ ComplexPalette default! !

!ComplexPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 12/6/2016 14:39:59'!
matchBoxRatio
	| ratio |
	((ratio _ box width / box height asFloat) - (extent x / extent y)) abs < 1
		ifFalse:
			[(ratio >= 1 and: [extent x >= extent y])
				ifTrue: [self morphExtent: extent x @ (extent x / ratio)]
				ifFalse: [self morphExtent: extent y * ratio @ extent y]]! !

!ComplexPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 12/6/2016 14:40:16'!
morphExtent: aPoint
	image _ nil.
	super morphExtent: aPoint! !

!ComplexPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 12/6/2016 16:54:28'!
palette: aComplexPalette
	palette _ aComplexPalette! !

!ComplexPlotMorph class methodsFor: 'as yet unclassified' stamp: 'len 12/18/2016 10:59:09'!
exampleBlaschkeProduct
	"This is a phase plot of the Blaschke product defined by 40 randomly choosen numbers in the unit disk."
	| random A f |
	random _ Random new.
	A _ (1 to: 40) collect: [:each| Complex abs: random next arg: Float twoPi * random next].
	f _ Function from: CC to: CC evaluating: [:z| A product: [:a| a abs / a * (a - z) / (1 - (a conjugated * z))]].
	^ ComplexPlotMorph new box: (-1 @ -1 corner: 1 @ 1); palette: ComplexPalette phase; function: f! !

!ComplexPlotMorph class methodsFor: 'as yet unclassified' stamp: 'len 5/15/2019 01:41:45'!
exampleReciprocalSinus
	| f |
	f _ Function from: CC to: CC evaluating: [:z| (1/z) sin].
	^ self new box: (-2 @ -1 corner: 2 @ 1); palette: ComplexPalette default; function: f! !

!ComplexPlotMorph class methodsFor: 'as yet unclassified' stamp: 'len 5/15/2019 01:41:57'!
exampleRiemannZetaFunction
	| f |
	f _ Function from: CC to: CC evaluating: [:z| (1 to: 100) sum: [:n| n^z negated]].
	^ self new morphExtent: 300@300; box: (-5@-5 corner: 5@5); palette: (ComplexPalette grid: 1@5); function: f! !

!ComplexPlotMorph class methodsFor: 'as yet unclassified' stamp: 'len 12/7/2016 16:37:54'!
exampleSinus
	| f |
	f _ Function from: CC to: CC evaluating: [:z| z sin].
	^ self new box: (-2*Float pi @ -1.5 corner: 2*Float pi @ 1.5); palette: (ComplexPalette grid: 1@10); function: f! !

!FunctionPlotMorph methodsFor: 'private' stamp: 'len 1/2/2016 06:07'!
computeEvaluationPoints
	evaluationPoints _ xMin to: xMax by: 1/100.0! !

!FunctionPlotMorph methodsFor: 'private' stamp: 'len 4/27/2016 22:23'!
computeValues
	values _ self evaluationPoints collect: [:x| [function value: x] on: Error do: [0]].
	yMin isNil
		ifTrue:
			[yMin _ values min.
			yMax _ values max]! !

!FunctionPlotMorph methodsFor: 'drawing' stamp: 'len 4/28/2016 05:42'!
drawOn: aCanvas
	| rect p lastP font |
	values isNil ifTrue: [self computeValues].
	rect _ self morphLocalBounds.
	aCanvas fillRectangle: rect color: backgroundColor.
	aCanvas line: (self localToMorphic:0@yMin)-(0@1) to: (self localToMorphic: 0 @ yMax)+(0@1) width: 1 color: textColor.
	aCanvas line: (self localToMorphic: xMin@0)+(1@0) to: (self localToMorphic: xMax@0)-(1@0) width: 1 color: textColor.

	lastP _ nil.
	self evaluationPoints with: values do: [:x :value|
		| y |
		y _ value ifNil: [0].
		(y between: yMin and: yMax)
			ifTrue:
				[p _ (self xToMorphic: x)@(self yToMorphic: y).
				p _ p rounded.
				lastP notNil
					ifTrue:
						[| y0 |
						aCanvas line: lastP to: p width: 1 color: color.
						y0 _ (self yToMorphic: 0) rounded.
						y > 0
							ifTrue: [aCanvas fillRectangle: (lastP corner: (p x @ (y0 min: rect bottom))) color: fillColor]
							ifFalse: [aCanvas fillRectangle: (lastP x @ (y0 max: rect top) corner: p) color: fillColor]].
					lastP _ p]
			ifFalse:
				[lastP _ nil]].

	font _ AbstractFont default. " Preferences standardButtonFont."
	aCanvas drawString: (yMax roundTo: 0.01) printString at: rect left + 2 @ (rect top + 2) font: font color: textColor.
	aCanvas drawString: (yMin roundTo: 0.01)  printString at: rect left + 2 @ (rect bottom - (font height * 2) - 2) font: font color: textColor.
	aCanvas drawString: (xMax roundTo: 0.01) printString at: rect right - (font widthOfString: (xMax  roundTo: 0.01) printString) - 2 @ (rect bottom - font height - 2) font: font color: textColor.
	aCanvas drawString: (xMin roundTo: 0.01) printString at: rect left + 2 + 20 @ (rect bottom - font height - 2) font: font color: textColor! !

!FunctionPlotMorph methodsFor: 'drawing' stamp: 'len 4/28/2016 05:40'!
localToMorphic: aPoint
	^(self xToMorphic: aPoint x) @ (self yToMorphic: aPoint y)! !

!FunctionPlotMorph methodsFor: 'drawing' stamp: 'len 4/27/2016 22:04'!
morphicToLocal: aPoint
	| bounds |
	bounds _ self morphLocalBounds.
	^ aPoint x - bounds left / bounds width * (xMax - xMin) + xMin @ (aPoint y - bounds top / bounds height * (yMax - yMin) + yMin)! !

!FunctionPlotMorph methodsFor: 'drawing' stamp: 'len 12/4/2015 05:00'!
xToMorphic: x
	^x - xMin / (xMax - xMin ) * extent x! !

!FunctionPlotMorph methodsFor: 'drawing' stamp: 'len 12/4/2015 05:00'!
yToMorphic: y
	^yMax - y / (yMax - yMin ) * extent y! !

!FunctionPlotMorph methodsFor: 'accessing' stamp: 'len 1/2/2016 06:03'!
evaluationPoints
	evaluationPoints isNil ifTrue: [self computeEvaluationPoints].
	^ evaluationPoints! !

!FunctionPlotMorph methodsFor: 'accessing' stamp: 'len 4/27/2016 21:36'!
evaluationPoints: aCollection
	xMin _ aCollection first.
	xMax _ aCollection last.
	evaluationPoints _ aCollection.
	values _ nil! !

!FunctionPlotMorph methodsFor: 'accessing' stamp: 'len 1/6/2016 02:53'!
function: aFunction
	function _ aFunction.
	yMin _ nil. yMax _ nil! !

!FunctionPlotMorph methodsFor: 'accessing' stamp: 'len 4/21/2016 05:29'!
yMin: min yMax: max
	yMin _ min.
	yMax _ max! !

!FunctionPlotMorph methodsFor: 'event handling' stamp: 'len 4/27/2016 21:11'!
handlesMouseDown: aMouseButtonEvent
	"Do I want to receive mouseDown events (mouseDown:, mouseMove:, mouseUp:)?"
	^true! !

!FunctionPlotMorph methodsFor: 'event handling' stamp: 'len 4/27/2016 21:57'!
mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition
	super mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition.
	firstMousePosition _ lastMousePosition _ localEventPosition! !

!FunctionPlotMorph methodsFor: 'event handling' stamp: 'len 6/24/2016 21:36'!
mouseButton1Up: aMouseButtonEvent localPosition: localEventPosition
	super mouseButton1Up: aMouseButtonEvent localPosition: localEventPosition.
	self flag: #fix.
"	mouseMoveEventHandler _ nil"! !

!FunctionPlotMorph methodsFor: 'event handling' stamp: 'len 4/27/2016 22:16'!
mouseMove: aMouseMoveEvent localPosition: localEventPosition
	firstMousePosition isNil
		ifTrue: [firstMousePosition _ localEventPosition]
		ifFalse:
			[aMouseMoveEvent shiftPressed
				ifTrue:
					[| bounds anchor delta |
					bounds _ self morphLocalBounds.
					delta _ localEventPosition - lastMousePosition / (bounds width max: bounds height).
					self scaleBy: 2.0 ^ delta x negated @ (2.0 ^ delta y) anchor: firstMousePosition]
				ifFalse:
					[| bounds delta |
					bounds _ self morphLocalBounds.
					delta _ localEventPosition - lastMousePosition / (bounds width max: bounds height).
					self scrollBy: delta]].
	lastMousePosition _ localEventPosition! !

!FunctionPlotMorph methodsFor: 'event handling' stamp: 'len 4/27/2016 22:21'!
scaleBy: aPoint anchor: anchorPoint
	| p |
	p _ self morphicToLocal: anchorPoint.
	self evaluationPoints: (self evaluationPoints collect: [:each| each - p x * aPoint x + p x]).
	self redrawNeeded! !

!FunctionPlotMorph methodsFor: 'event handling' stamp: 'len 4/27/2016 21:33'!
scrollBy: aPoint
	| dx dy |
	dx _ xMin - xMax * aPoint x.
	self evaluationPoints: (self evaluationPoints collect: [:each| each + dx]).
	dy _ yMax - yMin * aPoint y.
	yMin _ yMin + dy.
	yMax _ yMax + dy.
	self redrawNeeded! !

!FunctionPlotMorph methodsFor: 'initialization' stamp: 'len 4/24/2016 02:15'!
initialize
	super initialize.
	extent _ 280@175.
	color _ Color lightGray.
	backgroundColor _ Color transparent.
	fillColor _ Color transparent.
	textColor _ Color gray alpha: 0.5! !

!FunctionPlotMorph class methodsFor: 'examples' stamp: 'len 5/10/2019 17:06:42'!
example
	"
	FunctionPlotMorph example
	"
	| sin |
	sin _ Function from: RR to: RR evaluating: [:x| x sin].
	^ FunctionPlotMorph new evaluationPoints: (0.0 to: Float pi * 2 count: 100); function: sin; color: (Color red alpha: 0.5)! !

!FunctionPlotMorph class methodsFor: 'examples' stamp: 'len 4/21/2016 05:30'!
example2
	"
	FunctionPlotMorph example2
	"
	^ FunctionPlotMorph new
		color: (Color skyBlue alpha: 0.5);
		function: Sequence phi;
		evaluationPoints: (1 to: 150)! !

!FunctionPlotMorph class methodsFor: 'examples' stamp: 'len 4/21/2016 05:31'!
example3
	"
	FunctionPlotMorph example3
	"
	^ FunctionPlotMorph new
		evaluationPoints: (1 to: 150);
		function: Sequence calkinWilf;
		color: (Color yellow alpha: 0.5)! !

!FunctionPlotMorph class methodsFor: 'examples' stamp: 'len 4/21/2016 05:31'!
example4
	"
	FunctionPlotMorph example4
	"
	^ FunctionPlotMorph new
		evaluationPoints: (1 to: 5);
		function: Sequence primes;
		yMin: 0 yMax: 12;
		color: (Color orange alpha: 0.5)! !

!HistogramMorph methodsFor: 'building' stamp: 'jmv 4/10/2015 16:12'!
accumulate

	2 to: tallies size do: [ :i |
		tallies at: i put: (tallies at: i) + (tallies at: i-1) ]! !

!HistogramMorph methodsFor: 'building' stamp: 'jmv 4/10/2015 16:13'!
accumulated

	^self copy accumulate! !

!HistogramMorph methodsFor: 'building' stamp: 'jmv 4/6/2015 11:37'!
addValue: aNumber

	| i |
	i _ self indexFor: aNumber.
	tallies at: i put: (tallies at: i) + 1! !

!HistogramMorph methodsFor: 'building' stamp: 'len 12/27/2015 22:45'!
inverted
	"For accumulated histograms, compute de inverse cummulative function.
	This is not an exact inverse, and is so far an experiment.
	Some tests to ensure good properties, and maybe more work, are in order. "
	| answer answerTallies n i k |
	n _ self regularTalliesCount.
	answerTallies _ WordArray new: n.
	answer _ HistogramMorph basicNew
		tallies: answerTallies
		lowBinCenter: 0
		highBinCenter: n
		extraBinsForClampedValues: false.
	i _ 1.
	k _ 1.0 * n / tallies last.
	1 to: n do: [ :j |
		[ (tallies at: i) * k < j ] whileTrue: [ i _ i + 1 ].
		answerTallies at: j put: i
		].
	^answer! !

!HistogramMorph methodsFor: 'accessing' stamp: 'jmv 4/10/2015 16:11'!
countAt: value
	^tallies at: (self indexFor: value)! !

!HistogramMorph methodsFor: 'drawing' stamp: 'len 4/27/2016 08:18'!
drawOn: aCanvas
	| rect x dx y min max font |
	rect _ self morphLocalBounds.
	aCanvas fillRectangle: rect color: backgroundColor.
	min _ 0. max _ tallies max.
	max = min ifTrue: [^ self].
	dx _ rect width asFloat / tallies size.
	x _ rect left.
	tallies do: [:v|
		| bar |
		y _ (max-v) / (max-min) * rect height asFloat.
		y _ y min: rect height.
		y _ y max: 0.
		bar _ x truncated @ y corner: ((x _ x + dx) ceiling @ rect bottom).
		aCanvas fillRectangle: bar color: color].
	
	font _ AbstractFont default. " Preferences standardButtonFont."
	aCanvas drawString: max printString at: rect left + 2 @ (rect top + 2) font: font color: textColor.
	aCanvas drawString: min printString at: rect left + 2 @ (rect bottom - font height - 2) font: font color: textColor
! !

!HistogramMorph methodsFor: 'as yet unclassified' stamp: 'len 4/24/2016 05:38'!
handlesMouseDown: evt
	^ true! !

!HistogramMorph methodsFor: 'as yet unclassified' stamp: 'len 4/24/2016 05:35'!
handlesMouseOver: evt
	^ true! !

!HistogramMorph methodsFor: 'as yet unclassified' stamp: 'len 4/25/2016 07:46'!
mouseMove: aMouseMoveEvent localPosition: localEventPosition
	| i |
	i _ (localEventPosition x * tallies size / self morphLocalBounds width) truncated + 1.
	i _ (i min: tallies size) max: 1.
	self showBalloon: i printString, ' -> ', (tallies at: i) printString! !

!HistogramMorph methodsFor: 'private' stamp: 'len 4/25/2016 07:39'!
indexFor: aValue
	| slotIndex |
	slotIndex _ ((aValue - lowBinCenter / (highBinCenter -lowBinCenter )) * (tallies size-1)) rounded + 1.
	^slotIndex min: tallies size max: 1.! !

!HistogramMorph methodsFor: 'private' stamp: 'jmv 4/6/2015 11:18'!
regularTalliesCount

	^ extraBinsForClampedValues
		ifTrue: [ tallies size - 2 ]
		ifFalse: [ tallies size ]! !

!HistogramMorph methodsFor: 'private' stamp: 'len 4/25/2016 07:29'!
tallies: anArray lowBinCenter: aNumber highBinCenter: anotherNumber extraBinsForClampedValues: aBoolean
	tallies _ anArray.
	lowBinCenter _ aNumber.
	highBinCenter _ anotherNumber.
	extraBinsForClampedValues _ aBoolean.
	tallies size < 300 ifTrue: [extent _ (extent x / tallies size) truncated + 1 * tallies size @ extent y]! !

!HistogramMorph methodsFor: 'initialization' stamp: 'len 4/27/2016 07:28'!
initialize
	super initialize.
	extent _ 280@175.
	color _ Color darkGray.
	backgroundColor _ Color transparent.
	textColor _ Color gray alpha: 0.5! !

!HistogramMorph class methodsFor: 'examples' stamp: 'len 4/23/2016 04:02'!
example
	"
	HistogramMorph example
	"
	| r h |
	r _ Random new.
	h _ HistogramMorph new: 500 min: 0 max: 1.
	100000 timesRepeat: [h addValue: r next].
	h openInHand! !

!HistogramMorph class methodsFor: 'examples' stamp: 'len 7/15/2016 18:26'!
example2
	"
	HistogramMorph example2
	"
	| h S n |
	S _ ZZ ^ 4.
	n _ 40.
	h _ HistogramMorph new: 500 min: 0 max: n.
	100000 timesRepeat: [h addValue: (S atRandom: n) bitSize].
	h openInHand! !

!HistogramMorph class methodsFor: 'examples' stamp: 'len 3/6/2017 16:33:28'!
example3
	"primes conspiracy"
	| h p r |
	h _ HistogramMorph new: 22 min: 1 max: 100.
	p _ 2. r _ p \\ 10.
	100 timesRepeat:
		[| p2 r2 |
		p2 _ p nextPrime. r2 _ p2 \\ 10.
		h addValue: (r * 10 + r2).
		r _ r2. p _ p2].
	^ h! !

!HistogramMorph class methodsFor: 'instance creation' stamp: 'len 4/23/2016 04:02'!
new: binCount lowBinCenter: lowBinCenter highBinCenter: highBinCenter
	"lowBinCenter is the center value of the lowest bin.
	highBinCenter is the center value of the highest bin.
	
	Values lower than the lower bound of the first bin go in the fist bin,
	and values higher or equal than the upper bound of the last bin go in the last bin.
		(i.e., out of range values are simply clamped)
		
	For example, the following will give a histogram where first and last bins have half the counts as all the rest:
		| h r |
		h _ Histogram binCount: 10 lowBinCenter: 0 highBinCenter: 100.
		r _ Random new.
		10000 timesRepeat: [ h addValue: r next * 100  ].
		h plot
		
	Maybe what we wanted was:
		| h r |
		h _ Histogram binCount: 10 lowBinCenter: 5 highBinCenter: 95.
		r _ Random new.
		10000 timesRepeat: [ h addValue: r next  * 100 ].
		h plot
	
	Or more simply
		| h r |
		h _ Histogram binCount: 10 minValue: 0 maxValue: 100.
		r _ Random new.
		10000 timesRepeat: [ h addValue: r next  * 100 ].
		h plot
"

	^self new
		tallies: (WordArray new: binCount)
		lowBinCenter: lowBinCenter
		highBinCenter: highBinCenter
		extraBinsForClampedValues: false! !

!HistogramMorph class methodsFor: 'instance creation' stamp: 'len 4/23/2016 04:03'!
new: binCount min: min max: max
	"min is the lower bound of the lowest bin.
	max is the upper bound of the highest bin.
	
	Values lower than min go in the fist bin, and values higher or equal than max go in the last bin.
		(i.e., out of range values are simply clamped)

		| h r |
		h _ Histogram binCount: 10 minValue: 0.0 maxValue: 1.0.
		r _ Random new.
		10000 timesRepeat: [ h addValue: r next  ].
		h plot

	"

	^self new: binCount min: min max: max extraBinsForClampedValues: false! !

!HistogramMorph class methodsFor: 'instance creation' stamp: 'len 4/23/2016 04:01'!
new: regularBinCount min: min max: max extraBinsForClampedValues: aBoolean
	"min is the lower bound of the lowest bin.
	max is the upper bound of the highest bin.
	
	If aBoolean is false, values lower than min go in the fist bin, and values higher or equal than max go in the last bin.
		(i.e., out of range values are simply clamped)
	If aBoolean, then extra bins are added at each end for these 'out of range' values

		| h r |
		h _ Histogram binCount: 10 minValue: 0.0 maxValue: 1.0 extraBinsForClampedValues: true.
		r _ Random new.
		10000 timesRepeat: [ h addValue: r next  ].
		h plot
	"

	| tallies highBinCenter lowBinCenter halfBinWidth |
	halfBinWidth _ max - min / regularBinCount / 2.0.
	aBoolean
		ifTrue: [
			tallies _ WordArray new: regularBinCount + 2.
			lowBinCenter _ min - halfBinWidth.
			highBinCenter _ max + halfBinWidth ]
		ifFalse: [
			tallies _ WordArray new: regularBinCount.
			lowBinCenter _ min + halfBinWidth.
			highBinCenter _ max - halfBinWidth ].
	^self new
		tallies: tallies
		lowBinCenter: lowBinCenter
		highBinCenter: highBinCenter
		extraBinsForClampedValues: aBoolean! !

!HistogramMorph class methodsFor: 'instance creation' stamp: 'len 8/14/2016 00:10'!
new: binCount samples: aCollection
	| answer |
	answer _ self new: binCount min: aCollection min max: aCollection max.
	aCollection do: [:each| answer addValue: each].
	^ answer! !

!ImplicitFunctionPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 10/24/2016 21:38'!
box: aRectangle
	box _ aRectangle.
	image _ nil.
	self redrawNeeded! !

!ImplicitFunctionPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 10/24/2016 21:40'!
buildImage
	| lastRow |
	image _ Form extent: self morphExtent depth: Display depth.
	lastRow _ nil.
	1 to: image height do: [:j|
		| y row lastSign |
		y _ j asFloat / image height * box height - box bottom.
		row _ Array new: image width.
		lastSign _ nil.
		1 to: image width do: [:i|
			| x sign |
			x _ i asFloat / image width * box width - box right.
			sign _ (function value: (x,y)) sign.
			((lastSign notNil and: [lastSign ~= sign])
				or: [lastRow notNil and: [(lastRow at: i) ~= sign]])
					ifTrue: [image colorAt: i@(image height - j + 1) put: color].
			row at: i put: sign.
			lastSign _ sign].
		lastRow _ row]! !

!ImplicitFunctionPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 10/24/2016 21:19'!
drawOn: aCanvas
	image isNil ifTrue: [self buildImage].
	aCanvas image: image at: 0@0! !

!ImplicitFunctionPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 10/24/2016 21:38'!
function: aFunction
	function _ aFunction.
	image _ nil.
	self redrawNeeded! !

!ImplicitFunctionPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 10/24/2016 21:47'!
initialize
	super initialize.
	extent _ 150@150.
	color _ Color lightGray.
	box _ -1@-1 extent: 2@2! !

!ImplicitFunctionPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 10/24/2016 20:55'!
morphExtent: aPoint
	image _ nil.
	super morphExtent: aPoint! !

!ImplicitFunctionPlotMorph class methodsFor: 'as yet unclassified' stamp: 'len 10/24/2016 21:36'!
example
	"
	self example
	"
	| function |
	"Descartes folium"
	function _ Function from: QQ^2 to: QQ evaluatingWithArguments: [:x :y| x^3 + (y^3) - (3*x*y)].
	^ self new function: function! !

!ImplicitSurfacePlotMorph methodsFor: 'accessing' stamp: 'len 1/22/2017 07:44:33'!
color: aColor
	super color: aColor.
	surface color: aColor! !

!ImplicitSurfacePlotMorph methodsFor: 'accessing' stamp: 'len 1/22/2017 07:44:42'!
interiorColor: aColor
	surface interiorColor: aColor! !

!ImplicitSurfacePlotMorph methodsFor: 'accessing' stamp: 'len 1/22/2017 20:34:55'!
polynomial: aPolynomial
	polynomial _ aPolynomial.
	rotation _ Float64Quaternion identity.
	scaling _ 1.0.
	surface _ ImplicitSurface new polynomial: aPolynomial.
	surface color: color.
	camera _ Camera new
				location: 0 @ 0 @ -2.5;
				direction: 0 @ 0 @ 1;
				up: 0 @ 1 @ 0;
				right: 1 @ 0 @ 0.
	scene _ Scene new
				addLightSource: (LightSource new
							location: 15 @ 5 @ -20;
							color: Color lightYellow muchLighter);
"				addLightSource: (LightSource new
							location: -15 @ -5 @ 0;
							color: Color cyan);"
				addObject: surface;
"				addObject: (Plane new
							normal: 0 @ 1 @ 0;
							offset: 1;
							texture: (TextureWithFinish new
										pigment: (CheckerBoardPigment new
													center: 0 @ 0.1 @ 0;
													color1: Color gray;
													color2: Color white;
													squareSize: 1);
										finish: (CompoundFinish new
													addFinish: (PhongLightingModelFinish new
																ambient: 0.2;
																specular: 0;
																specularPower: 10);
													addFinish: (ReflectionFinish new reflection: 0.3))));
"				yourself.
	self render! !

!ImplicitSurfacePlotMorph methodsFor: 'drawing' stamp: 'len 1/20/2017 23:05:27'!
drawOn: aCanvas
	image isNil ifTrue: [^ super drawOn: aCanvas].
	aCanvas image: (image magnifyBy: resolutionRatio) at: 0@0! !

!ImplicitSurfacePlotMorph methodsFor: 'private' stamp: 'len 1/22/2017 09:57:17'!
fastResolutionRatio
	^ 8! !

!ImplicitSurfacePlotMorph methodsFor: 'private' stamp: 'len 1/22/2017 20:02:12'!
normalResolutionRatio
	^ 2! !

!ImplicitSurfacePlotMorph methodsFor: 'private' stamp: 'len 1/20/2017 23:05:05'!
render
	camera imageSize: extent // resolutionRatio.
	image _ camera renderScene: scene.
	self redrawNeeded! !

!ImplicitSurfacePlotMorph methodsFor: 'private' stamp: 'len 1/23/2017 10:13:53'!
renderBest
	resolutionRatio _ 1.
	self render! !

!ImplicitSurfacePlotMorph methodsFor: 'private' stamp: 'len 1/20/2017 22:31:58'!
setCameraBack: distance
	camera
		location: 0 @ 0 @ distance negated;
		direction: 0 @ 0 @ 1;
		up: 0 @ 1 @ 0;
		right: 1 @ 0 @ 0.
	self render! !

!ImplicitSurfacePlotMorph methodsFor: 'private' stamp: 'len 1/20/2017 22:32:04'!
setCameraLocation: aPoint
	camera location: aPoint.
	self render! !

!ImplicitSurfacePlotMorph methodsFor: 'private' stamp: 'len 1/20/2017 22:32:11'!
setCameraRight: distance
	camera
		location: distance @ 0 @ 0;
		direction: -1 @ 0 @ 0;
		up: 0 @ 1 @ 0;
		right: 0 @ 0 @ 1.
	self render! !

!ImplicitSurfacePlotMorph methodsFor: 'private' stamp: 'len 1/20/2017 22:32:28'!
setCameraTop: distance
	camera
		location: 0 @ distance @ 0;
		direction: 0 @ -1 @ 0;
		up: 0 @ 0 @ 1;
		right: 1 @ 0 @ 0.
	self render! !

!ImplicitSurfacePlotMorph methodsFor: 'private' stamp: 'len 1/20/2017 22:32:34'!
setLightSourceAt: aPoint
	scene lightSources first location: aPoint.
	self render! !

!ImplicitSurfacePlotMorph methodsFor: 'private' stamp: 'len 1/21/2017 19:11:40'!
setRadius: aNumber
	surface radius: aNumber.
	self render! !

!ImplicitSurfacePlotMorph methodsFor: 'event handling testing' stamp: 'len 1/21/2017 18:24:36'!
handlesMouseDown: aMouseButtonEvent
	"Do I want to receive mouseDown events (mouseDown:, mouseMove:, mouseUp:)?"
	^true! !

!ImplicitSurfacePlotMorph methodsFor: 'initialization' stamp: 'len 5/16/2018 05:24:03'!
initialize
	super initialize.
	self morphExtent: 300@300.
	resolutionRatio _ self normalResolutionRatio.
	self polynomial: AffineVariety clebschCubic asHypersurface polynomial! !

!ImplicitSurfacePlotMorph methodsFor: 'geometry' stamp: 'len 1/20/2017 21:55:28'!
morphExtent: aPoint
	image _ nil.
	super morphExtent: aPoint! !

!ImplicitSurfacePlotMorph methodsFor: 'events' stamp: 'len 1/21/2017 18:24:48'!
mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition
	super mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition.
	lastMousePosition _ localEventPosition! !

!ImplicitSurfacePlotMorph methodsFor: 'events' stamp: 'len 1/22/2017 09:57:36'!
mouseButton1Up: aMouseButtonEvent localPosition: localEventPosition
	super mouseButton1Up: aMouseButtonEvent localPosition: localEventPosition.
	resolutionRatio _ self normalResolutionRatio.
	self render! !

!ImplicitSurfacePlotMorph methodsFor: 'events' stamp: 'len 1/22/2017 09:57:49'!
mouseMove: aMouseMoveEvent localPosition: localEventPosition
	lastMousePosition isNil
		ifFalse:
			[aMouseMoveEvent shiftPressed
				ifTrue:
					[| bounds d |
					bounds _ self morphLocalBounds.
					d _ (localEventPosition dist: lastMousePosition) / (bounds width min: bounds height) * 2.0.
					localEventPosition y >= lastMousePosition y ifTrue: [d _ d negated].
					resolutionRatio _ self fastResolutionRatio.
					self scaleSurfaceBy: 2^d]
				ifFalse: [resolutionRatio _ self fastResolutionRatio.
					self rotateSurfaceBy: localEventPosition - lastMousePosition]].
	lastMousePosition _ localEventPosition! !

!ImplicitSurfacePlotMorph methodsFor: 'surface geometry' stamp: 'len 1/22/2017 09:14:31'!
rotateSurfaceBy: aPoint
	| xSpeed ySpeed |
	xSpeed _ Float pi / self morphLocalBounds width.
	ySpeed _ Float pi / self morphLocalBounds height.
	rotation _ ((Float64Quaternion radiansAngle: aPoint x * xSpeed axis: 0@1@0) * (Float64Quaternion radiansAngle: aPoint y * ySpeed axis: 1@0@0)) * rotation.
	self updateTransformation! !

!ImplicitSurfacePlotMorph methodsFor: 'surface geometry' stamp: 'len 1/22/2017 09:18:41'!
scaleSurfaceBy: aNumber
	scaling _ scaling * aNumber.
	self updateTransformation! !

!ImplicitSurfacePlotMorph methodsFor: 'surface geometry' stamp: 'len 1/22/2017 09:13:51'!
updateTransformation
	| M v |
	M _ rotation asMatrix3x3.
	v _ polynomial parent generate: [:x :y :z|
		{x * M a11 + (y * M a12) + (z * M a13) * scaling.
		x * M a21 + (y * M a22) + (z * M a23) * scaling.
		x * M a31 + (y * M a32) + (z * M a33) * scaling}].
	surface polynomial: (polynomial value: v).
	self render! !

!MultiplicationTableMorph methodsFor: 'as yet unclassified' stamp: 'len 7/31/2016 05:20'!
drawOn: aCanvas
	| h w |
	w _ extent x / elements size.
	h _ extent y / elements size.
	w > 10
		ifTrue:
			[1 to: elements size do: [:i|
				1 to: elements size do: [:j|
					aCanvas fillRectangle: ((i-1*w @ (j-1*h)) truncated corner: (i*w-1 @ (j*h-1)) truncated) color: (colors at: (operation value: {elements at: i. elements at: j}))]]]
		ifFalse:
			[1 to: elements size do: [:i|
				1 to: elements size do: [:j|
					aCanvas fillRectangle: ((i-1*w @ (j-1*h)) truncated corner: (i*w @ (j*h)) truncated) color: (colors at: (operation value: {elements at: i. elements at: j}))]]]
		! !

!MultiplicationTableMorph methodsFor: 'as yet unclassified' stamp: 'len 7/31/2016 01:47'!
elements: anArray
	elements _ anArray asArray! !

!MultiplicationTableMorph methodsFor: 'as yet unclassified' stamp: 'len 8/16/2016 04:03'!
initialize
	super initialize.
	self morphExtent: 150@150.
	colors _ AutomaticPalette new! !

!MultiplicationTableMorph methodsFor: 'as yet unclassified' stamp: 'len 7/31/2016 04:28'!
morphExtent: aPoint
	| max |
	max _ aPoint x max: aPoint y.
	super morphExtent: max @ max! !

!MultiplicationTableMorph methodsFor: 'as yet unclassified' stamp: 'len 7/31/2016 01:47'!
operation: aBinaryOperation
	operation _ aBinaryOperation! !

!MultiplicationTableMorph class methodsFor: 'as yet unclassified' stamp: 'len 7/31/2016 01:48'!
elements: anArray operation: aBinaryOperation
	^ self new elements: anArray; operation: aBinaryOperation! !

!ScalarPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 8/17/2016 23:44'!
drawOn: aCanvas
	| r |
	r _ 1.
	0 to: extent x - r by: r do: [:x|
		0 to: extent y - r by: r do: [:y|
			aCanvas fillRectangle: (x@y extent: r@r) color: (palette at: (function value: (self morphToDomain: x@y)))]]
! !

!ScalarPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 8/17/2016 23:23'!
function: aFunction
	function _ aFunction! !

!ScalarPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 12/6/2016 16:39:13'!
initialize
	super initialize.
	extent _ 100@100.
	function _ [:v| v x cos * v y sin].
	xMin _ -4. xMax _ 4.
	yMin _ -4. yMax _ 4.
	palette _ RealPalette default min: -1.0; max: 1.0! !

!ScalarPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 8/17/2016 23:30'!
morphToDomain: aPoint
	^ (aPoint x * (xMax - xMin) / extent x + xMin, (aPoint y * (yMax - yMin) / extent y + yMin))! !

!ScatterPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 5/5/2019 18:34:05'!
applyRotationBy: aPoint
	| bounds xSpeed ySpeed rotation |
	self dimension < 3 ifTrue: [^ self].
	bounds _ self morphLocalBounds.
	xSpeed _ Float pi / bounds width.
	ySpeed _ Float pi / bounds height.
	rotation _ (QQ^self dimension) endomorphisms evaluating: [:p|
		| xz yz |
		xz _ p x @ p z.
		xz _ xz rotatedBy: aPoint x * xSpeed.
		yz _ p y @ xz y.
		yz _ yz rotatedBy: aPoint y * ySpeed.
		(xz x, yz x, yz y), (p copyFrom: 4 to: p size)].
	transformation _ rotation  (transformation ifNil: [rotation identity]).
	self redrawNeeded! !

!ScatterPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 8/16/2016 02:00'!
applyScaleBy: aNumber
	transformation _ transformation * aNumber.
	self redrawNeeded! !

!ScatterPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 8/21/2016 07:13'!
colorBy: aBlock
	colorBlock _ aBlock.
	self redrawNeeded! !

!ScatterPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 8/15/2016 18:57'!
dimension
	^ points anyOne size! !

!ScatterPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 8/21/2016 07:19'!
drawOn: aCanvas
	| bounds range boxColor w |
	bounds _ self morphLocalBounds insetBy: 1.
	range _ max - min.
	"draw box:"
	self dimension >= 3 ifTrue:
		[boxColor _ Color white alpha: 0.2.
		self drawPolyline: {(-1,-1,-1). (-1,1,-1). (-1,1,1). (1,1,1). (1,-1,1). (1,-1,-1). (-1,-1,-1). (-1,-1,1). (-1,1,1)} color: boxColor on: aCanvas.
		self drawPolyline: {(1,-1,1). (-1,-1,1)} color: boxColor on: aCanvas.
		self drawPolyline: {(1,1,-1). (1,1,1)} color: boxColor on: aCanvas.
		self drawPolyline: {(1,-1,-1). (1,1,-1). (-1,1,-1)} color: boxColor on: aCanvas].
	
	"draw points:"
	w _ extent x min: extent y.
	points withIndexDo: [:each :k|
		| p xy z r shade c |
		p _ positionBlock value: each.
		p _ p collect: [:xi| xi - min / range - 0.5 * 2].
		transformation ifNotNil: [p _ transformation value: p].
		xy _ p x / 2 + 0.5 * w @ (p y / 2 + 0.5 * w).
		z _ p size >= 3 ifTrue: [(p z / 2 + 0.5 max: 0.0) min: 1.0] ifFalse: [1.0].
		r _ z * (sizeBlock value: each) :: rounded + 1.
		shade _ z / 2 + 0.5.
		c _ colorBlock value: each.
		c _ c mixed: shade with: Color black.
		c _ c alpha: c alpha * (shade / 2 + 0.5).
		(bounds containsPoint: xy) ifTrue:
			[aCanvas fillRectangle: (Rectangle center: xy extent: r@r) color: c]]! !

!ScatterPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 8/19/2016 18:39'!
drawPolyline: anArray color: aColor on: aCanvas
	| w lastPoint |
	w _ extent x min: extent y.
	lastPoint _ nil.
	anArray do: [:each|
		| p xy |
		p _ transformation ifNil: [each] ifNotNil: [transformation value: each].
		xy _ p x / 2 + 0.5 * w @ (p y / 2 + 0.5 * w).
		lastPoint ifNotNil: [aCanvas line: lastPoint to: xy width: 1 color: aColor].
		lastPoint _ xy]! !

!ScatterPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 8/13/2016 04:51'!
handlesMouseDown: aMouseButtonEvent
	"Do I want to receive mouseDown events (mouseDown:, mouseMove:, mouseUp:)?"
	^true! !

!ScatterPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 12/6/2016 16:39:19'!
initialize
	| palette |
	super initialize.
	color _ Color white.
	extent _ 250@250.
	transformation _ nil.
	positionBlock _ [:aTuple| aTuple copyFrom: 1 to: (aTuple size min: 3)].
	palette _ RealPalette default.
	colorBlock _ [:aTuple| palette at: (positionBlock value: aTuple) norm2 / (max - min) squared].
	sizeBlock _ [:aTuple| 3]! !

!ScatterPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 8/13/2016 04:51'!
mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition
	super mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition.
	lastMousePosition _ localEventPosition! !

!ScatterPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 8/16/2016 01:59'!
mouseMove: aMouseMoveEvent localPosition: localEventPosition
	lastMousePosition isNil
		ifFalse:
			[aMouseMoveEvent shiftPressed
				ifTrue:
					[| bounds d |
					bounds _ self morphLocalBounds.
					d _ (localEventPosition dist: lastMousePosition) / (bounds width min: bounds height).
					localEventPosition y >= lastMousePosition y ifTrue: [d _ d negated].
					self applyScaleBy: 2.0 ^ d]
				ifFalse: [self applyRotationBy: lastMousePosition - localEventPosition]].
	lastMousePosition _ localEventPosition! !

!ScatterPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 8/21/2016 07:14'!
points: anArray
	points _ anArray.
	max _ points max: [:each| each max].
	min _ points min: [:each| each min].
	transformation _ QQ^self dimension :: id.
	self redrawNeeded! !

!ScatterPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 8/21/2016 07:13'!
positionBy: aBlock
	positionBlock _ aBlock.
	self redrawNeeded! !

!ScatterPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 8/21/2016 07:13'!
sizeBy: aBlock
	sizeBlock _ aBlock.
	self redrawNeeded! !

!ScatterPlotMorph class methodsFor: 'as yet unclassified' stamp: 'len 12/6/2016 16:39:25'!
example
	| palette |
	palette _ RealPalette default.
	^ (self timeDelayPlot: (Sequence primes difference first: 1000))
			colorBy: [:each| palette at: each bitSize / 40.0]! !

!ScatterPlotMorph class methodsFor: 'as yet unclassified' stamp: 'len 8/19/2016 05:21'!
example2
	| samples |
	samples _ 1 to: 1000 :: collect: [:i| Random new next].
	^ self timeDelayPlot: samples! !

!ScatterPlotMorph class methodsFor: 'as yet unclassified' stamp: 'len 8/19/2016 05:22'!
example3
	| samples |
	samples _ 1 to: 1000 :: collect: [:i| | r | r _ Random new. 100 timesRepeat: [r next]. r next].
	^ self timeDelayPlot: samples! !

!ScatterPlotMorph class methodsFor: 'as yet unclassified' stamp: 'len 8/18/2016 06:38'!
timeDelayPlot: anArray
	^ self timeDelayPlot: anArray lag: 1! !

!ScatterPlotMorph class methodsFor: 'as yet unclassified' stamp: 'len 11/5/2016 06:17'!
timeDelayPlot: anArray dimension: m lag: r
	^ self new
		points: ((m*r+1 to: anArray size) collect: [:i|
			RR tuple: m evaluating: [:j| anArray at: i-(j-1*r)]])! !

!ScatterPlotMorph class methodsFor: 'as yet unclassified' stamp: 'len 8/18/2016 06:39'!
timeDelayPlot: anArray lag: r
	^ self timeDelayPlot: anArray dimension: 3 lag: r! !

!UnitDiskPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 12/15/2016 18:43:01'!
buildImage
	image _ Form extent: self morphExtent depth: Display depth.
	1 to: image height do: [:j|
		| y |
		y _ j asFloat / image height * 2 - 1.
		1 to: image width do: [:i|
			| x z c |
			x _ i asFloat / image width * 2 - 1.
			(x squared + y squared) sqrt < 1
				ifTrue:
					[| w |
					z _ x + y i.
					w _ [function value: (inverseMap value: z)] on: ZeroDivide do: [Infinity projective].
					image colorAt: i@j put: (palette at: w)]]]! !

!UnitDiskPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 12/9/2016 10:27:16'!
drawOn: aCanvas
	image isNil ifTrue: [self buildImage].
	aCanvas image: image at: 0@0! !

!UnitDiskPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 12/15/2016 18:41:22'!
function: aFunction
	function _ aFunction.
"	function domain = HH
		ifTrue: [self mapUpperHalfPlaneToUnitDisk]
		ifFalse: [function domain = CC ifTrue: [self mapPlaneToUnitDisk]]."
	image _ nil.
	self redrawNeeded! !

!UnitDiskPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 12/15/2016 18:38:39'!
initialize
	super initialize.
	extent _ 300@300.
	color _ Color lightGray.
	palette _ ComplexPalette default.
	inverseMap _ [:z| z] "by default use the identity map"! !

!UnitDiskPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 12/15/2016 18:36:26'!
mapPlaneToUnitDisk
	inverseMap _ [:z| z / (1 - z abs squared)]! !

!UnitDiskPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 12/15/2016 18:37:30'!
mapUpperHalfPlaneToUnitDisk
	inverseMap _ [:z| 1 + z / (1 - z) * 1 i]! !

!UnitDiskPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 12/9/2016 10:28:38'!
morphExtent: aPoint
	| side |
	image _ nil.
	side _ aPoint x min: aPoint y.
	super morphExtent: side @ side! !

!UnitDiskPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 12/9/2016 10:27:55'!
palette: aComplexPalette
	palette _ aComplexPalette! !

!UnitDiskPlotMorph class methodsFor: 'examples' stamp: 'len 12/18/2016 10:58:38'!
exampleBlaschkeProduct
	"This is a phase plot of the Blaschke product defined by 40 randomly choosen numbers in the unit disk, plotted through a conformal mapping of the complex plane into the unit disk."
	| random A f |
	random _ Random new.
	A _ (1 to: 40) collect: [:each| Complex abs: random next arg: Float twoPi * random next].
	f _ Function from: CC to: CC evaluating: [:z| A product: [:a| a abs / a * (a - z) / (1 - (a conjugated * z))]].
	^ UnitDiskPlotMorph new mapPlaneToUnitDisk; palette: ComplexPalette phase; function: f! !

!GraphEdgeMorph methodsFor: 'private' stamp: 'len 2/19/2016 19:04'!
adjustBounds
	| newBounds |
	newBounds _ (self externalize: self sourcePoint) rect: (self externalize: self targetPoint).
	self morphBounds: newBounds.
	labelMorph ifNotNil: [labelMorph morphAlign: labelMorph morphBounds center with: newBounds extent // 2]! !

!GraphEdgeMorph methodsFor: 'private' stamp: 'len 2/19/2016 19:01'!
hideLabel
	labelMorph notNil ifTrue: [labelMorph delete. labelMorph _ nil]! !

!GraphEdgeMorph methodsFor: 'private' stamp: 'len 4/30/2016 06:56'!
showLabel
	(labelMorph notNil or: [label isNil]) ifTrue: [^ self].
	labelMorph _ StringMorph contents: label asString font: Preferences standardMenuFont.
	labelMorph color: Color white.
	self addMorph: labelMorph.
	labelMorph morphAlign: labelMorph morphBounds leftCenter with: self morphBounds rightCenter + (1@0)! !

!GraphEdgeMorph methodsFor: 'accessing' stamp: 'len 7/9/2016 22:11'!
alpha
	^ source alpha + target alpha / 2.0! !

!GraphEdgeMorph methodsFor: 'accessing' stamp: 'len 7/9/2016 22:26'!
color
	^ color alpha: self alpha! !

!GraphEdgeMorph methodsFor: 'accessing' stamp: 'len 7/9/2016 22:27'!
color: aColor
	color _ aColor! !

!GraphEdgeMorph methodsFor: 'accessing' stamp: 'len 2/19/2016 03:25'!
hideArrowHead
	drawArrowHead _ false! !

!GraphEdgeMorph methodsFor: 'accessing' stamp: 'len 7/14/2016 05:33'!
incrementMultiplicity
	multiplicity _ multiplicity + 1! !

!GraphEdgeMorph methodsFor: 'accessing' stamp: 'len 2/19/2016 19:00'!
label
	^ label! !

!GraphEdgeMorph methodsFor: 'accessing' stamp: 'len 2/19/2016 19:00'!
label: aString
	label _ aString.
	label notNil ifTrue: [self showLabel] ifFalse: [self hideLabel]! !

!GraphEdgeMorph methodsFor: 'accessing' stamp: 'len 2/19/2016 03:25'!
showArrowHead
	drawArrowHead _ true! !

!GraphEdgeMorph methodsFor: 'accessing' stamp: 'Samir Saidani 6/23/2003 21:17'!
source
	^ source! !

!GraphEdgeMorph methodsFor: 'accessing' stamp: 'Samir Saidani 6/23/2003 21:17'!
source: aMorph
	source _ aMorph! !

!GraphEdgeMorph methodsFor: 'accessing' stamp: 'len 3/1/2016 01:48'!
sourcePoint
	^ self internalizeFromWorld: source morphBoundsInWorld center! !

!GraphEdgeMorph methodsFor: 'accessing' stamp: 'len 2/15/2016 22:56'!
target
	^ target! !

!GraphEdgeMorph methodsFor: 'accessing' stamp: 'len 2/15/2016 22:56'!
target: aMorph
	target _ aMorph! !

!GraphEdgeMorph methodsFor: 'accessing' stamp: 'len 2/17/2016 22:20'!
targetPoint
	^ self internalizeFromWorld: target morphBoundsInWorld center! !

!GraphEdgeMorph methodsFor: 'accessing' stamp: 'len 2/18/2016 06:16'!
width
	^ width! !

!GraphEdgeMorph methodsFor: 'accessing' stamp: 'len 2/18/2016 06:16'!
width: anInteger
	"Set the width of the line to draw."
	width _ anInteger! !

!GraphEdgeMorph methodsFor: 'drawing' stamp: 'len 3/1/2016 01:44'!
direction
	^ (self targetPoint - self sourcePoint) normalized! !

!GraphEdgeMorph methodsFor: 'drawing' stamp: 'len 1/23/2017 09:35:06'!
drawArcOn: aCanvas from: sourcePoint to: targetPoint
	multiplicity odd
		ifTrue: [aCanvas line: sourcePoint to: targetPoint width: width color: self color].
	1 to: multiplicity - (multiplicity \\ 2) do: [:i|
		self drawCurveOn: aCanvas from: sourcePoint to: targetPoint curvature: i+1//2 * (i odd ifTrue: [1] ifFalse: [-1])]! !

!GraphEdgeMorph methodsFor: 'drawing' stamp: 'len 12/19/2016 12:29:46'!
drawArrowOn: aCanvas from: aPoint to: anotherPoint
	| sourcePoint targetPoint direction |
	sourcePoint _ aPoint.
	targetPoint _ anotherPoint.
	direction _ (targetPoint - sourcePoint) normalized.
	target identityHash < source identityHash
		ifTrue:
			[ | shift |
			shift _ (direction rotatedBy: Float pi/2) * 4.
			sourcePoint _ sourcePoint + shift.
			targetPoint _ targetPoint + shift].
	targetPoint _ targetPoint - (direction * target radius).
	sourcePoint _ sourcePoint + (direction * source radius).
	self drawArcOn: aCanvas from: sourcePoint to: targetPoint.
	aCanvas line: targetPoint - (direction*3) - ((direction rotatedBy: Float pi / 4) * 4)
		to: targetPoint width: width color: self color.
	aCanvas line: targetPoint - (direction*2) - ((direction rotatedBy: Float pi / 4) * 4)
		to: targetPoint width: width color: self color.
	aCanvas line: targetPoint - (direction*3) - ((direction rotatedBy: Float pi * 7 / 4) * 4)
		to: targetPoint width: width color: self color.
	aCanvas line: targetPoint - (direction*2) - ((direction rotatedBy: Float pi * 7 / 4) * 4)
		to: targetPoint width: width color: self color.

"	self sourcePoint = self targetPoint
		ifFalse: [aCanvas
				drawThinArrowFrom: self sourcePoint
				to: self targetPoint
				width: 1
				color: self color]"
			
	"| circle string |  
	circle _ EllipseMorph new extent: 20 @ 20;  
	 
	color: (Color  
	r: 1.0  
	g: 0.452  
	b: 0.065).  
	circle align: circle center with: self center.  
	self addMorph: circle.  
	string _ StringMorph new contents: 'test'.  
	string align: string bounds leftCenter with: bounds rightCenter + (4 @  
	0). self addMorph: string"
"	| aa |
	aa _ PolygonMorph new.
	aa computeArrowFormAt: self sourcePoint from: self destinationPoint.
	self addMorph: aa"
! !

!GraphEdgeMorph methodsFor: 'drawing' stamp: 'len 1/23/2017 09:35:19'!
drawCurveOn: aCanvas from: sourcePoint to: targetPoint curvature: curvature
	| perp previous |
	perp _ targetPoint - sourcePoint / 10.0 rotatedBy: Float pi / 2.
	0.0 to: 1.0 count: 15 do: [:i|
		| current |
		current _ sourcePoint * i + (targetPoint * (1.0-i)).
		current _ current + ((0.5 - (0.5-i) abs) sqrt * curvature * perp).
		previous ifNotNil: [aCanvas line: previous to: current width: width color: self color].
		previous _ current]! !

!GraphEdgeMorph methodsFor: 'drawing' stamp: 'len 7/14/2016 02:51'!
drawLoopOn: aCanvas at: aPoint
	aCanvas frameEllipse: (aPoint - (10@20) extent: 20@20) borderWidth: width color: self color! !

!GraphEdgeMorph methodsFor: 'drawing' stamp: 'len 7/14/2016 05:21'!
drawOn: aCanvas 
	"frameRectangle: self bounds color: Color black;"
	| sourcePoint targetPoint |
	"aCanvas frameRectangle: self morphLocalBounds borderWidth: 1 color: Color red."
	[sourcePoint _ self sourcePoint.
	targetPoint _ self targetPoint] on: Error do: [^ self].
	targetPoint = sourcePoint ifTrue: [^ self drawLoopOn: aCanvas at: targetPoint].
	drawArrowHead ifTrue: [^ self drawArrowOn: aCanvas from: sourcePoint to: targetPoint].
	self drawArcOn: aCanvas from: sourcePoint to: targetPoint! !

!GraphEdgeMorph methodsFor: 'initialization' stamp: 'len 7/14/2016 05:37'!
initialize
	super initialize.
	self color: Color gray.
	width _ 1.
	drawArrowHead _ true.
	multiplicity _ 1! !

!GraphEdgeMorph methodsFor: 'geometry testing' stamp: 'len 4/28/2016 05:50'!
morphContainsPoint: aLocalPoint
	^ super morphContainsPoint: aLocalPoint! !

!GraphEdgeMorph methodsFor: 'stepping' stamp: 'len 2/26/2016 03:03'!
step
	(source owner isNil or: [target owner isNil]) ifTrue: [^ self delete].
	self adjustBounds! !

!GraphEdgeMorph methodsFor: 'stepping' stamp: 'Samir Saidani 6/23/2003 21:17'!
stepTime
	^ 0! !

!GraphEdgeMorph methodsFor: 'stepping' stamp: 'len 2/17/2016 22:15'!
wantsSteps
	^ true! !

!SpringEdgeMorph methodsFor: 'moving' stamp: 'len 2/25/2016 17:08'!
approachNodes
	"Connected nodes are tied with a rubber band."
	| f currentDistance diff delta |
	(currentDistance _ (diff _ source x + source dx - target x - target dx) norm) > desiredDistance
		ifTrue:
			[f _ (desiredDistance - currentDistance) asFloat / (currentDistance * 4).
			delta _ diff * f / 2.
			target dx: target dx - delta.
			source dx: source dx + delta]! !

!SpringEdgeMorph methodsFor: 'moving' stamp: 'len 4/27/2016 07:57'!
desiredDistance
	^ desiredDistance! !

!SpringEdgeMorph methodsFor: 'moving' stamp: 'len 2/15/2003 18:07'!
desiredDistance: anInteger
	"Set the distance I want between my vertices."
	desiredDistance _ anInteger! !

!SpringEdgeMorph methodsFor: 'initialization' stamp: 'Michael Piel 4/21/2004 11:12'!
initialize
	super initialize.
	desiredDistance _ 100! !

!SpringEdgeMorph methodsFor: 'stepping' stamp: 'len 2/26/2016 03:04'!
step
	(source owner isNil or: [target owner isNil]) ifTrue: [^ self delete].
"	self approachNodes."
	self adjustBounds! !

!SpringEdgeMorph methodsFor: 'stepping' stamp: 'len 2/24/2016 21:12'!
wantsSteps
	^ false! !

!ImplicitSurface methodsFor: 'accessing' stamp: 'len 1/21/2017 22:33:19'!
color: aColor
	self texture: (self defaultTextureForColor: aColor)! !

!ImplicitSurface methodsFor: 'accessing' stamp: 'len 1/21/2017 22:33:30'!
interiorColor: aColor
	self interiorTexture: (self defaultTextureForColor: aColor)! !

!ImplicitSurface methodsFor: 'accessing' stamp: 'len 1/21/2017 22:33:42'!
interiorTexture
	^ interiorTexture ifNil: [texture]! !

!ImplicitSurface methodsFor: 'accessing' stamp: 'len 1/21/2017 17:26:55'!
interiorTexture: aTexture
	interiorTexture _ aTexture! !

!ImplicitSurface methodsFor: 'accessing' stamp: 'len 1/21/2017 19:08:58'!
polynomial
	^ polynomial! !

!ImplicitSurface methodsFor: 'accessing' stamp: 'len 1/20/2017 21:07:10'!
polynomial: aPolynomial
	polynomial _ aPolynomial.
	gradient _ polynomial gradient! !

!ImplicitSurface methodsFor: 'accessing' stamp: 'len 1/21/2017 18:35:29'!
radius
	^ radiusSquared sqrt! !

!ImplicitSurface methodsFor: 'accessing' stamp: 'len 1/20/2017 17:56:18'!
radius: aNumber
	radiusSquared _ aNumber squared! !

!ImplicitSurface methodsFor: 'private' stamp: 'len 1/22/2017 20:39:02'!
defaultTextureForColor: aColor
	^ TextureWithFinish new
			pigment: (FlatColorPigment new color: aColor);
			finish: (PhongLightingModelFinish new
					ambient: 0.35;
					specular: 0.8;
					specularPower: 20)

"			finish: (CompoundFinish new
				addFinish: (PhongLightingModelFinish new
					ambient: 0.35;
					specular: 0.8;
					specularPower: 20);
				addFinish: (ReflectionFinish new reflection: 1);
				yourself)"! !

!ImplicitSurface methodsFor: 'initializing' stamp: 'len 5/16/2018 05:24:39'!
initialize
"	self polynomial: (RR polynomialsIn: #(x y z) :: generate: [:x :y :z| x**2 + (y**2) + (z**2) - 2])"
"	self polynomial: (RR polynomialsIn: #(x y z) :: generate: [:x :y :z| x**2 + (z**2) - (y**2)])."
	self polynomial: AffineVariety clebschCubic asHypersurface polynomial.
"	self polynomial: (QQ polynomialsIn: #(x y z) :: generate: [:x :y :z| x squared + y squared - ((1 - z) * (z**4))])."
	self radius: 1.0! !

!ImplicitSurface methodsFor: 'tracing-private' stamp: 'len 1/20/2017 21:25:30'!
intersectionWithSphere: aRay
	| a b c determinant t1 t2 |
	a _ aRay directionLengthSquared.
	b _ (aRay origin dot: aRay direction) * 2.0.
	c _ (aRay origin dot: aRay origin) - radiusSquared.
	determinant _ b * b - (4.0 * a * c).
	determinant < 0.0 ifTrue: [^ nil].
	determinant _ determinant sqrt.
	a _ a * 2.0.
	t1 _ (determinant - b) / a.
	t2 _ (determinant negated - b) / a.
	t1 negative ifTrue: [^ t2 positive ifTrue: [t2]].
	t2 negative ifTrue: [^ t1 positive ifTrue: [t1]].
	^ t1 min: t2! !

!ImplicitSurface methodsFor: 'tracing-private' stamp: 'len 1/20/2017 08:07:40'!
signChanges: a
	| lastSign count |
	lastSign _ a at: 1.
	count _ 0.
	2 to: a size do: [:i| | ai sign | (ai _ a at: i) abs < Float epsilon ifFalse: [(sign _ ai sign) == lastSign ifFalse: [count _ count + 1. lastSign _ sign]]].
	^ count! !

!ImplicitSurface methodsFor: 'tracing-private' stamp: 'len 1/22/2017 19:56:38'!
solve: f max: max
	| left right n a b c r0 r1 count |
	f isConstant ifTrue: [^ nil].
"	(f independentCoefficient < Float epsilon) ifTrue: [^ 0.0]."
	a _ f coefficients asArray reversed collect: [:each| each asFloat].
	n _ a size.
"	(self signChanges: a) > 0 ifFalse: [^ nil]." "no positive roots"
	b _ Array new: n.
	c _ Array new: n-1.
	left _ 0.000001.
	[right _ left + 0.1. (f value: left) * (f value: right) <= 0.0] whileFalse: [left _ right. left > max ifTrue: [^ nil]].
	r0 _ left.
	b at: 1 put: (a at: 1).
	c at: 1 put: (b at: 1).
	count _ 1.
	[2 to: n do: [:i|
		b at: i put: (a at: i) + (r0 * (b at: i-1)).
		i < n ifTrue: [c at: i put: (b at: i) + (r0 * (c at: i-1))]].
	r1 _ r0 - ((b at: n) / (c at: n-1)).
	(r1 - r0) abs < 10.0e-6 ifTrue: [^ r1].
	r0 _ r1.
	(count _ count + 1) > 100 ifTrue: [^ nil]] repeat! !

!ImplicitSurface methodsFor: 'tracing' stamp: 'len 1/21/2017 19:35:11'!
normalAt: aPoint
	^ (Float32Vector3 x: ((gradient at: 1) value: aPoint) y: ((gradient at: 2) value: aPoint) z: ((gradient at: 3) value: aPoint)) normalize! !

!ImplicitSurface methodsFor: 'tracing' stamp: 'len 1/22/2017 20:51:27'!
writeIntersectionsWith: aRay into: aCollection
	| t0 origin ox oy oz direction dx dy dz t f root intersection p |
	(t0 _ self intersectionWithSphere: aRay) ifNil: [^ self].
	origin _ aRay pointAtDistance: t0.
	ox _ origin x.
	oy _ origin y.
	oz _ origin z.
	direction _ aRay direction.
	dx _ direction x.
	dy _ direction y.
	dz _ direction z.
	t _ RR polynomials x.
	f _ polynomial value: {t*dx + ox. t*dy + oy. t*dz + oz}.
	(root _ self solve: f max: radiusSquared sqrt*2) ifNil: [^ self].
	intersection _ Intersection for: self ray: aRay distance: root+t0.
	p _ intersection intersectionPoint. "this is expensive, can we do without computing this intersection point?"
	(p dot: p) < (radiusSquared - 0.00001) ifTrue: [aCollection add: intersection]! !

!ImplicitSurface class methodsFor: 'examples' stamp: 'len 5/15/2019 01:47:44'!
example1
	^ self new
		polynomial: ((RR polynomialsIn: #(x y z)) generate: [:x :y :z| x^2 + (y^2) + (z^3) + (x*y*z*2) - 1]);
		radius: 1.0! !

!ImplicitSurface class methodsFor: 'examples' stamp: 'len 5/15/2019 01:48:24'!
example2
	^ self new
		polynomial: ((RR polynomialsIn: #(x y z)) generate: [:x :y :z| x^2 - ((y^2)*(z^2))]);
		radius: 5.0! !

!Domain methodsFor: 'accessing' stamp: 'len 12/28/2016 11:23:23'!
ambient
	"Domains can be subobjects of other domains, for example subspeces are subobjects of vector spaces.
	Answer the ambient domain of which the receiver is a subobject."
	^ self propertyAt: #ambient ifAbsent: [self]! !

!Domain methodsFor: 'accessing' stamp: 'len 12/28/2016 11:23:04'!
elements
	self propertyAt: #elements ifPresent: [:aCollectionOrDomain| ^ aCollectionOrDomain].
	^ Iterator on: self performing: #do:! !

!Domain methodsFor: 'accessing' stamp: 'len 10/6/2016 10:26'!
generator
	self generators size = 1 ifFalse: [self error: 'more than one generator'].
	^ self generators anyOne! !

!Domain methodsFor: 'accessing' stamp: 'len 10/17/2016 18:53'!
generator: anElement
	self generators: {anElement}! !

!Domain methodsFor: 'accessing' stamp: 'len 12/28/2016 11:22:22'!
generators
	"Subclases can use this or reimplement it when it makes sense."
	^ self propertyAt: #generators ifAbsent: []! !

!Domain methodsFor: 'accessing' stamp: 'len 12/28/2016 11:19:29'!
generators: aCollection
	"Subclases can use this or reimplement it when it makes sense."
	self propertyAt: #generators put: aCollection asArray! !

!Domain methodsFor: 'accessing' stamp: 'len 12/28/2016 11:23:29'!
name: aString
	self propertyAt: #name put: aString! !

!Domain methodsFor: 'accessing' stamp: 'len 12/28/2016 11:20:47'!
null
	"Answer the null or zero object in the category of the receiver, i.e. an object that is both intial and terminal. For example {id} in the case of groups (the trivial group)."
	"The null object in the category of sets is the empty set."
	^ self propertyAt: #null ifAbsent: [self class newFrom: (Set new: 0)]! !

!Domain methodsFor: 'accessing' stamp: 'len 6/5/2019 19:55:56'!
size
	^ self propertyAt: #size ifAbsentPut: [self elements size]! !

!Domain methodsFor: 'comparing' stamp: 'len 8/12/2016 21:51'!
< aDomain
	"Answer true if the receiver is a proper subobject of aDomain (strict inclusion)."
	aDomain isFinite ifTrue: [^ self size < aDomain size and: [self elements allSatisfy: [:each| aDomain includes: each]]].
	self isFinite ifTrue: [self do: [:each| (aDomain includes: each) ifFalse: [^ false]]. ^ true].
	^ aDomain > self! !

!Domain methodsFor: 'comparing' stamp: 'len 8/12/2016 21:49'!
<= aDomain
	"Answer true if the receiver is a subobject of aDomain (inclusion)."
	^ self = aDomain or: [self < aDomain]! !

!Domain methodsFor: 'comparing' stamp: 'len 12/28/2016 11:21:40'!
= aDomain
	self == aDomain ifTrue: [^ true].
	self size = aDomain size ifFalse: [^ false].
	self isFinite ifTrue: [^ self asSet = aDomain asSet].
	self propertyAt: #elements ifPresent: [:aCollectionOrDomain| ^ aDomain = aCollectionOrDomain].
	aDomain propertyAt: #elements ifPresent: [:aCollectionOrDomain| ^ self = aCollectionOrDomain].
	^ super = aDomain! !

!Domain methodsFor: 'comparing' stamp: 'len 8/12/2016 21:49'!
> aDomain
	"Answer true if aDomain is a proper subobject of the receiver (strict inclusion)."
	^ aDomain < self! !

!Domain methodsFor: 'comparing' stamp: 'len 8/12/2016 21:50'!
>= aDomain
	"Answer true if aDomain is a subobject of the receiver (inclusion)."
	^ aDomain <= self! !

!Domain methodsFor: 'comparing' stamp: 'len 7/16/2016 05:22'!
~ aDomain
	"Answer true if the receiver is isomorphic to the argument."
	^ self = aDomain "not much more we can test at this abstract level, subclasses should reimplement"! !

!Domain methodsFor: 'comparing' stamp: 'len 4/23/2016 00:41'!
hash
	^ self isFinite ifTrue: [self size hash] ifFalse: [super hash]! !

!Domain methodsFor: 'converting' stamp: 'len 12/28/2016 11:19:21'!
asArray
	self propertyAt: #elements ifPresent: [:aCollectionOrDomain| ^ aCollectionOrDomain asArray].
	^ (Iterator on: self performing: #do:) asArray! !

!Domain methodsFor: 'converting' stamp: 'len 2/20/2017 08:32:16'!
asSet
	self propertyAt: #elements ifPresent: [:aCollectionOrDomain| ^ aCollectionOrDomain asSet].
	^ Set accumulate: [:aBlock| self do: aBlock]! !

!Domain methodsFor: 'copying' stamp: 'len 5/1/2016 23:35'!
copyEmpty
	^ self species new! !

!Domain methodsFor: 'elements' stamp: 'len 5/14/2019 12:34:03'!
!! anObject
	"Coerce anObject to an element of the receiver. Subclasses should extend."
	(self includes: anObject) ifTrue: [^ anObject].
	self isAmbient ifFalse: [| element | element _ self ambient !! anObject. (self contains: element) ifTrue: [^ element]].
	anObject isElement ifTrue: [anObject parent -> self ifNotNil: [:aMorphism| ^ aMorphism value: anObject]].
	(anObject isBlock and: [self generators notNil and: [anObject numArgs = self generators size]]) ifTrue: [^ self generate: anObject].
	^ DomainError signal: 'coercion failed'! !

!Domain methodsFor: 'elements' stamp: 'len 12/26/2016 11:31:05'!
generate: aBlock
	"Answer the result of evaluating aBlock on the generators of the receiver."
	^ aBlock valueWithArguments: self generators asArray! !

!Domain methodsFor: 'elements' stamp: 'len 12/22/2016 22:44:33'!
newFrom: anObject
	"Coerce anObject to an element of the receiver. Implemented in order to be able to use >>as: consistently. Subclasses should reimplement >>!!."
	^ self !! anObject! !

!Domain methodsFor: 'elements' stamp: 'len 5/13/2019 14:18:36'!
x: anInteger
	"Answer the anInteger-th generator of the receiver."
	^ self generators at: anInteger! !

!Domain methodsFor: 'enumerating' stamp: 'len 5/1/2016 23:22'!
allSatisfy: aBlock
	self do: [:each| (aBlock value: each) ifFalse: [^ false]].
	^ true! !

!Domain methodsFor: 'enumerating' stamp: 'len 5/1/2016 23:21'!
anySatisfy: aBlock
	self do: [:each| (aBlock value: each) ifTrue: [^ true]].
	^ false! !

!Domain methodsFor: 'enumerating' stamp: 'len 10/27/2016 14:40'!
collect: aBlock
	| elements |
	elements _ Set new.
	self do: [:each| elements add: (aBlock value: each)].
	^ elements as: Domain! !

!Domain methodsFor: 'enumerating' stamp: 'len 9/16/2018 16:11:56'!
count: aBlock
	| answer |
	answer _ 0.
	self do: [:each| (aBlock value: each) ifTrue: [answer _ answer + 1]].
	^ answer! !

!Domain methodsFor: 'enumerating' stamp: 'len 7/29/2016 06:45'!
detect: aBlock
	"Evaluate aBlock with each of the receiver's elements as the argument. 
	Answer the first element for which aBlock evaluates to true."

	^ self detect: aBlock ifNone: [self error: 'Element is not in the domain']! !

!Domain methodsFor: 'enumerating' stamp: 'len 9/3/2016 07:19'!
detect: aBlock ifNone: exceptionBlock
	"Evaluate aBlock with each of the receiver's elements as the argument. 
	Answer the first element for which aBlock evaluates to true. If none 
	evaluate to true, then evaluate the argument, exceptionBlock."

	self do: [:each | (aBlock value: each) ifTrue: [^each]].
	^ exceptionBlock value! !

!Domain methodsFor: 'enumerating' stamp: 'len 12/28/2016 11:21:06'!
do: aBlock
	(self propertyAt: #elements ifAbsent: [self subclassResponsibility]) do: aBlock! !

!Domain methodsFor: 'enumerating' stamp: 'len 4/25/2016 09:44'!
do: elementBlock separatedBy: separatorBlock
	| beforeFirst | 
	"Evaluate the elementBlock for all elements in the receiver,
	and evaluate the separatorBlock between."

	beforeFirst _ true.
	self do: [ :element |
		beforeFirst
			ifTrue: [beforeFirst _ false]
			ifFalse: [separatorBlock value].
		elementBlock value: element]! !

!Domain methodsFor: 'enumerating' stamp: 'len 2/15/2017 11:26:26'!
max: aBlock
	^ self elements max: aBlock! !

!Domain methodsFor: 'enumerating' stamp: 'len 2/15/2017 11:26:35'!
min: aBlock
	^ self elements min: aBlock! !

!Domain methodsFor: 'enumerating' stamp: 'len 4/28/2018 05:05:39'!
noneSatisfy: aBlock
	self do: [:each| (aBlock value: each) ifTrue: [^ false]].
	^ true! !

!Domain methodsFor: 'enumerating' stamp: 'len 5/3/2018 01:29:25'!
product: aBlock
	^ self elements product: aBlock! !

!Domain methodsFor: 'enumerating' stamp: 'len 10/27/2016 14:40'!
select: aBlock
	| elements |
	elements _ Set new.
	self do: [:each| (aBlock value: each) ifTrue: [elements add: each]].
	^ elements as: Domain! !

!Domain methodsFor: 'enumerating' stamp: 'len 5/3/2018 01:29:16'!
sum: aBlock
	^ self elements sum: aBlock! !

!Domain methodsFor: 'enumerating' stamp: 'len 8/1/2016 03:53'!
upTo: maximumNumberOfElements
	| answer |
	answer _ OrderedCollection new.
	self do: [:each|
		answer size >= maximumNumberOfElements ifTrue: [^ answer].
		answer add: each].
	^ answer! !

!Domain methodsFor: 'enumerating' stamp: 'len 7/25/2016 23:46'!
upTo: max do: aBlock
	"Iterate over the elements of the receiver, just like #do:, but stop after max elements."
	| k |
	k _ 1.
	self do: [:each|
		k > max ifTrue: [^ self].
		aBlock value: each.
		k _ k+1]! !

!Domain methodsFor: 'morphisms' stamp: 'len 5/26/2019 04:34:02'!
-< aCartesianProduct
	"Answer the tuple of canonical projections from the receiver to each component of the argument.
	See also CartesianProduct's message >-."
	self propertyAt: #outputMapTuples ifPresent: [:aDictionary| aDictionary at: aCartesianProduct asArray ifPresent: [:aTupleOfMaps| ^ aTupleOfMaps]].
	^ nil! !

!Domain methodsFor: 'morphisms' stamp: 'len 5/15/2019 01:09:33'!
-> aCodomain
	"Answer the canonical morphism from the receiver to aCodomain.
	If the argument is a morphism, answer the composition with a canonical morphism to its domain. See also Morphism>>->."
	(aCodomain isKindOf: Morphism) ifTrue:
		[self = aCodomain domain ifTrue: [^ aCodomain].
		^ self -> aCodomain domain ifNotNil: [:aMorphism| aCodomain  aMorphism]].
	self propertyAt: #outputMaps ifPresent: [:aDictionary| aDictionary at: aCodomain ifPresent: [:aMorphism| ^ aMorphism]].
	aCodomain propertyAt: #inputMaps ifPresent: [:aDictionary| aDictionary at: self ifPresent: [:aMorphism| ^ aMorphism]].
	(self to: aCodomain) ifNotNil: [:aMorphism| ^ aMorphism].
	(aCodomain from: self) ifNotNil: [:aMorphism| ^ aMorphism].
	self propertyAt: #outputMaps ifPresent: [:aDictionary| aDictionary do: [:each| each -> aCodomain ifNotNil: [:aMorphism| ^ aMorphism]]].
	aCodomain propertyAt: #inputMaps ifPresent: [:aDictionary| aDictionary do: [:each| self -> each ifNotNil: [:aMorphism| ^ aMorphism]]].
	^ nil! !

!Domain methodsFor: 'morphisms' stamp: 'len 5/11/2019 02:08:41'!
->> aCodomain
	"Answer the canonical projection from the receiver onto aCodomain."
	| answer |
	answer _ self -> aCodomain ifNil: [^ nil].
	self assert: answer isSurjective.
	^ answer! !

!Domain methodsFor: 'morphisms' stamp: 'len 5/5/2019 18:30:22'!
=> anObject
	"This is the internal hom(A,-) functor, where A is the receiver:
	- if the argument is a domain X, answer hom(A,X), the domain of morphisms from A to X;
	- if the argument is a morphism g:X->Y, answer the morphism hom(A,g):hom(A,X)->hom(A,Y) that sends the morphism f to gf.
	See #hom: for the external Hom functor."
	(anObject isKindOf: Morphism) ifTrue: [^ self => anObject domain to: self => anObject codomain evaluating: [:f| anObject  f]].
	^ HomSet from: self to: anObject! !

!Domain methodsFor: 'morphisms' stamp: 'len 5/11/2019 02:08:49'!
>-> aCodomain
	"Answer the canonical embedding from the receiver into aCodomain."
	| answer |
	answer _ self -> aCodomain ifNil: [^ nil].
	self assert: answer isInjective.
	^ answer! !

!Domain methodsFor: 'morphisms' stamp: 'len 11/6/2016 08:58'!
| aMorphism
	"See also Morphism>>|."
	^ aMorphism restrictedTo: self! !

!Domain methodsFor: 'morphisms' stamp: 'len 5/24/2019 10:59:24'!
addCoprojections: anArray
	^ (self propertyAt: #inputMapTuples ifAbsentPut: [Dictionary new]) at: (anArray collect: [:each| each domain]) put: anArray! !

!Domain methodsFor: 'morphisms' stamp: 'len 5/11/2019 02:02:02'!
addMap: aMorphism
	aMorphism domain = self
		ifTrue: [^ (self propertyAt: #outputMaps ifAbsentPut: [Dictionary new]) at: aMorphism codomain put: aMorphism].
	aMorphism codomain = self
		ifTrue: [^ (self propertyAt: #inputMaps ifAbsentPut: [Dictionary new]) at: aMorphism domain put: aMorphism].
	^ DomainError signal! !

!Domain methodsFor: 'morphisms' stamp: 'len 5/24/2019 10:59:14'!
addProjections: anArray
	^ (self propertyAt: #outputMapTuples ifAbsentPut: [Dictionary new]) at: (anArray collect: [:each| each codomain]) put: anArray! !

!Domain methodsFor: 'morphisms' stamp: 'len 5/13/2019 17:12:18'!
apply: aMorphism
	"Answer the homomorphic image of the receiver."
	^ (aMorphism isBlock ifTrue: [self] ifFalse: [aMorphism codomain]) span: ((self generators ifNil: [^ self collect: aMorphism]) apply: aMorphism)! !

!Domain methodsFor: 'morphisms' stamp: 'len 12/30/2016 20:08:17'!
automorphisms
	self flag: #fix. "this shouldn't be here for all subclasses to inherit, maybe Domain should be abstract, and we could consider Collections as finite sets and implement these things in Collection; same with #to:evaluating:, etc."
	^ SymmetricGroup on: self! !

!Domain methodsFor: 'morphisms' stamp: 'len 4/19/2019 04:36:41'!
endomorphisms
	^ self => self! !

!Domain methodsFor: 'morphisms' stamp: 'len 5/11/2019 02:34:36'!
from: aDomain
	"Answer the canonical morphism from aDomain to the receiver."
	self = aDomain ifTrue: [^ self id].
	^ nil! !

!Domain methodsFor: 'morphisms' stamp: 'len 5/5/2019 18:30:52'!
hom: anObject
	"This is the external Hom(A,-) functor, where A is the receiver:
	- if the argument is a domain X, answer Hom(A,X), the set of morphisms from A to X;
	- if the argument is a morphism g:X->Y, answer the function Hom(A,f):Hom(A,X)->Hom(A,Y) that sends the morphism f to gf.
	See => for the internal hom functor."
	(anObject isKindOf: Morphism) ifTrue: [^ (self hom: anObject domain) to: (self hom: anObject codomain) evaluating: [:f| anObject  f]].
	^ HomSet from: self to: anObject! !

!Domain methodsFor: 'morphisms' stamp: 'len 5/16/2019 12:24:00'!
id
	"Answer the identity morphism."
	| answer |
	self propertyAt: #id ifPresent: [:aMorphism| ^ aMorphism].
	answer _ self to: self evaluating: [:x| x].
	answer properties
		at: #isIdentity put: true;
		at: #retraction put: answer;
		at: #section put: answer;
"		at: #kernel put: self null;"
		at: #image put: self.
	^ self propertyAt: #id put: answer! !

!Domain methodsFor: 'morphisms' stamp: 'len 5/27/2018 03:49:31'!
into: aCodomain evaluating: aBlock
	"Answer an embedding (an injective morphism) into the specified codomain (in the same category), evaluating as the given block."
	^ self to: aCodomain evaluating: aBlock! !

!Domain methodsFor: 'morphisms' stamp: 'len 5/24/2019 10:47:21'!
into: aCodomain mapping: aBlock
	^ self to: aCodomain mapping: aBlock! !

!Domain methodsFor: 'morphisms' stamp: 'len 5/27/2018 03:49:05'!
onto: aCodomain evaluating: aBlock
	"Answer a projection (a surjective morphism) onto the specified codomain (in the same category), evaluating as the given block."
	^ self to: aCodomain evaluating: aBlock! !

!Domain methodsFor: 'morphisms' stamp: 'len 5/24/2019 10:47:30'!
onto: aCodomain mapping: aBlock
	^ self to: aCodomain mapping: aBlock! !

!Domain methodsFor: 'morphisms' stamp: 'len 5/13/2019 18:49:19'!
to: aCodomain
	"Answer the canonical morphism from the receiver to aCodomain."
	self = aCodomain ifTrue: [^ self id].
	self isAmbient ifFalse: [self ambient -> aCodomain ifNotNil: [:aMorphism| ^ self | aMorphism]].
	^ nil! !

!Domain methodsFor: 'morphisms' stamp: 'len 2/15/2017 11:08:53'!
to: aCodomain evaluating: aBlock
	"Answer a morphism to the specified codomain (in the same category), evaluating as the given block.
	Example: ZZ to: ZZ evaluating: [:x| x squared]."
	^ Function from: self to: aCodomain evaluating: aBlock! !

!Domain methodsFor: 'morphisms' stamp: 'len 2/15/2017 11:09:11'!
to: aCodomain evaluatingWithArguments: aBlock
	"When the receiver is N-ary, this method allows to define morphisms by N-ary blocks.
	Example: ZZ  ZZ to: ZZ evaluatingWithArguments: [:a :b| a * b]."
	^ self to: aCodomain evaluating: [:each| aBlock valueWithArguments: each asArray]! !

!Domain methodsFor: 'morphisms' stamp: 'len 5/24/2019 10:46:58'!
to: aCodomain mapping: aBlock
	"Answer a morphism defined by images of generators.
	aBlock takes indices i and evaluates to the image of the i-th generator."
	^ self subclassResponsibility! !

!Domain methodsFor: 'operations' stamp: 'len 12/30/2017 16:26:42'!
* aDomain
	"This is a convenience method for doing categorical products. Subclasses can reimplement it to mean something different from the categorical product in order to match customary notation."
	^ self  aDomain! !

!Domain methodsFor: 'operations' stamp: 'len 12/30/2017 16:26:35'!
+ aDomain
	"This is a convenience method for doing coproducts. Subclasses can reimplement it to mean something different from the coproduct in order to match customary notation."
	^ self  aDomain! !

!Domain methodsFor: 'operations' stamp: 'len 12/30/2017 15:19:47'!
, aDomain
	"Answer the cartesian set product of the receiver with the argument."
	^ CartesianProduct components: {self. aDomain}! !

!Domain methodsFor: 'operations' stamp: 'len 5/3/2019 15:29:39'!
/ anEquivalenceRelation
	"Answer the categorical quotient of the receiver by an equivalence relation."
	| relation |
	relation _ anEquivalenceRelation isBlock ifTrue: [EquivalenceRelation on: self evaluating: anEquivalenceRelation] ifFalse: [anEquivalenceRelation].
	^ QuotientSet mod: relation! !

!Domain methodsFor: 'operations' stamp: 'len 5/10/2019 04:26:29'!
/\ aCollection
	"Answer the intersection of the receiver and the argument."
	^ self select: [:each| aCollection includes: each]! !

!Domain methodsFor: 'operations' stamp: 'len 1/22/2017 08:13:22'!
^ anInteger
	| components |
	components _ Array new: anInteger.
	components atAllPut: self.
	^ CartesianProduct components: components! !

!Domain methodsFor: 'operations' stamp: 'len 12/30/2017 16:36:36'!
 aDomain
	"This is a convenience method for doing categorical products. Subclasses can reimplement it to mean something different from the categorical product in order to match customary notation."
	^ self  aDomain! !

!Domain methodsFor: 'operations' stamp: 'len 12/30/2017 16:36:21'!
 aDomain
	"Answer the categorical product of the receiver with the argument."
	"The product in the category of sets is the cartesian product."
	^ self, aDomain! !

!Domain methodsFor: 'operations' stamp: 'len 5/10/2019 04:36:08'!
 aDomain
	"Answer the categorical sum (or coproduct) of the receiver with the argument."
	"The coproduct in the category of sets is the disjoint union."
	^ self species newFrom: ((self elements collect: [:each| {each. 0}]) \/ (aDomain elements collect: [:each| {each. 1}]))! !

!Domain methodsFor: 'properties' stamp: 'len 12/28/2016 12:25:43'!
hasProperty: aSymbol
	^ (properties ifNil: [^ false]) includesKey: aSymbol! !

!Domain methodsFor: 'properties' stamp: 'len 12/28/2016 12:25:33'!
properties
	^ properties ifNil: [properties _ IdentityDictionary new]! !

!Domain methodsFor: 'properties' stamp: 'len 6/20/2016 02:44'!
propertyAt: aSymbol
	^ self propertyAt: aSymbol ifAbsent: [self error: 'no such property']! !

!Domain methodsFor: 'properties' stamp: 'len 12/28/2016 12:26:08'!
propertyAt: aSymbol ifAbsent: exceptionBlock
	^ (properties ifNil: [^ exceptionBlock value]) at: aSymbol ifAbsent: exceptionBlock! !

!Domain methodsFor: 'properties' stamp: 'len 12/28/2016 12:26:16'!
propertyAt: aSymbol ifAbsentPut: aBlock
	^ self properties at: aSymbol ifAbsentPut: aBlock! !

!Domain methodsFor: 'properties' stamp: 'len 12/28/2016 12:26:28'!
propertyAt: aSymbol ifPresent: aBlock
	^ (properties ifNil: [^ nil]) at: aSymbol ifPresent: aBlock! !

!Domain methodsFor: 'properties' stamp: 'len 12/28/2016 12:26:33'!
propertyAt: aSymbol put: anObject
	^ self properties at: aSymbol put: anObject! !

!Domain methodsFor: 'random' stamp: 'len 6/28/2016 08:38'!
atRandom
	"Answer an element in the receiver choosen at random. This will fail if the receiver is not finite."
	^ Random withDefaultDo: [:aRandom| self atRandom: aRandom]! !

!Domain methodsFor: 'random' stamp: 'len 12/28/2016 11:19:04'!
atRandom: aRandom
	"Answer an element in the receiver choosen at random. This will fail if the receiver is not finite."
	self propertyAt: #elements ifPresent: [:aCollection| aCollection atRandom: aRandom].
	^ self atRandom: aRandom bits: Infinity positive! !

!Domain methodsFor: 'random' stamp: 'len 5/25/2018 18:12:30'!
atRandom: aRandom bits: bitSize
	"Answer an element of the receiver of at most n bits (as measured by #bitSize). The total number of elements that could be returned shouldn't exceed 2^n."
	self propertyAt: #elements ifPresent: [:aCollection| ^ aCollection atRandom: aRandom bits: bitSize].
	^ self subclassResponsibility! !

!Domain methodsFor: 'random' stamp: 'len 7/5/2016 02:29'!
atRandomBits: bitSize
	"Answer an element of the receiver of at most n bits (as measured by #bitSize). The total number of elements that could be returned shouldn't exceed 2^n."
	^ Random withDefaultDo: [:aRandom| self atRandom: aRandom bits: bitSize]! !

!Domain methodsFor: 'testing' stamp: 'len 4/19/2019 07:15:03'!
contains: anElement
	"Answer true if the receiver contains the given element of its ambient.
	This is similar to >>includes: but less checks are needed, because the element is not an arbitrary object."
	self isAmbient ifTrue: [^ true].
	^ self elements includes: anElement! !

!Domain methodsFor: 'testing' stamp: 'len 12/13/2016 07:34:43'!
containsAllOf: aCollection 
	"Answer whether all the elements of aCollection are in the receiver."
	aCollection do: [:each| (self contains: each) ifFalse: [^ false]].
	^ true! !

!Domain methodsFor: 'testing' stamp: 'len 6/23/2016 07:04'!
includes: anElement
	^ self elements includes: anElement! !

!Domain methodsFor: 'testing' stamp: 'len 6/24/2016 05:59'!
includesAllOf: aCollection 
	"Answer whether all the elements of aCollection are in the receiver."
	aCollection do: [:each| (self includes: each) ifFalse: [^ false]].
	^ true! !

!Domain methodsFor: 'testing' stamp: 'len 4/23/2016 00:24'!
is: aSymbol
	^ aSymbol == #Set or: [aSymbol == #Domain or: [super is: aSymbol]]! !

!Domain methodsFor: 'testing' stamp: 'len 4/19/2019 07:12:35'!
isAmbient
	^ self ambient == self! !

!Domain methodsFor: 'testing' stamp: 'len 5/22/2018 17:27:24'!
isCoproduct
	"Answer true if the receiver is some kind of categorical coproduct, such as direct sum of vector spaces or of other abelian groups. Coproducts are equipped with canonical embeddings from their components (they must implement >>embedding:)."
	^ false! !

!Domain methodsFor: 'testing' stamp: 'len 11/2/2016 08:54'!
isEmpty
	^ self size = 0! !

!Domain methodsFor: 'testing' stamp: 'len 12/28/2016 11:23:17'!
isFinite
	^ self propertyAt: #isFinite ifAbsent: [self size isInfinite not]! !

!Domain methodsFor: 'testing' stamp: 'len 6/17/2016 22:20'!
isInfinite
	^ self isFinite not! !

!Domain methodsFor: 'testing' stamp: 'len 12/28/2016 11:23:47'!
isInitial
	"Answer true if the receiver is an initial object.
	The empty set is the initial object in the category of sets. Subclasses can override."
	^ self propertyAt: #isInitial ifAbsent: [self isEmpty]! !

!Domain methodsFor: 'testing' stamp: 'len 5/22/2018 17:28:40'!
isProduct
	"Answer true if the receiver is some kind of categorical product, such as cartesian product of sets, direct product of groups, etc. Products are equipped with canonical projections to their components (they must implement >>projection:)."
	^ false! !

!Domain methodsFor: 'testing' stamp: 'len 5/22/2018 17:29:17'!
isQuotient
	"Answer true if the receiver is some kind of quotient object, such as a quotient of sets, gropus, vector spaces, etc. Quotients are equipped with a canonical embedding from their base object (they must implement >>embedding)."
	^ false! !

!Domain methodsFor: 'testing' stamp: 'len 12/28/2016 11:19:37'!
isTerminal
	"Answer true if the receiver is a terminal object.
	In the category of sets, the singletons (sets with one element) are the terminal objects. Subclasses can override."
	^ self propertyAt: #isTerminal ifAbsent: [self size = 1]! !

!Domain methodsFor: 'testing-category' stamp: 'len 12/14/2016 21:30:11'!
isAbelianGroup
	^ false! !

!Domain methodsFor: 'testing-category' stamp: 'len 1/11/2018 19:42:05'!
isAlgebra
	^ false! !

!Domain methodsFor: 'testing-category' stamp: 'len 4/27/2016 02:54'!
isCommutativeRing
	^ self isRing and: [self isCommutative]! !

!Domain methodsFor: 'testing-category' stamp: 'len 2/11/2016 22:18'!
isComplex
	^ false! !

!Domain methodsFor: 'testing-category' stamp: 'len 2/5/2016 20:22'!
isField
	^ false! !

!Domain methodsFor: 'testing-category' stamp: 'len 10/31/2016 15:23'!
isFractionRing
	^ false! !

!Domain methodsFor: 'testing-category' stamp: 'len 10/2/2018 00:55:32'!
isFreeModule
	^ self isModule and: [self isFree]! !

!Domain methodsFor: 'testing-category' stamp: 'len 12/14/2016 21:30:32'!
isGroup
	^ false! !

!Domain methodsFor: 'testing-category' stamp: 'len 10/2/2018 00:57:13'!
isModule
	^ false! !

!Domain methodsFor: 'testing-category' stamp: 'len 2/14/2016 18:08'!
isMonoid
	^ self isGroup! !

!Domain methodsFor: 'testing-category' stamp: 'len 2/11/2016 22:18'!
isReal
	^ false! !

!Domain methodsFor: 'testing-category' stamp: 'len 12/14/2016 21:30:53'!
isRing
	^ false! !

!Domain methodsFor: 'testing-category' stamp: 'len 2/14/2016 18:08'!
isSemigroup
	^ self isMonoid! !

!Domain methodsFor: 'testing-category' stamp: 'len 10/2/2018 00:58:23'!
isVectorSpace
	^ self isModule and: [self scalars isField]! !

!Domain methodsFor: 'private' stamp: 'len 3/16/2018 19:12:32'!
ambient: aDomain
	self propertyAt: #ambient put: aDomain! !

!Domain methodsFor: 'private' stamp: 'len 12/28/2016 11:20:10'!
elements: aCollection
	self propertyAt: #elements put: aCollection! !

!Domain class methodsFor: 'examples' stamp: 'len 12/20/2016 11:23:39'!
example1asSet
	"The ring Z/5Z as a Smalltalk Set.
	This is possible because the ring is finite."
	^ (ZZ/5) asSet! !

!Domain class methodsFor: 'examples' stamp: 'len 1/11/2018 21:21:53'!
example1atRandom
	"Taking an element at random from the Z-module of 3x3 matrices.
	Use 50 bits to generate this element. Essentially, this can return
	at most 2^50 different matrices, and their bitsize doesn't exceed 50
	bits (where bitsize is losely defined, in this case it's the sum
	of bitsize of the coefficients of the matrix)."
	^ ZZ^(3@3) atRandom: (Random seed: 12345) bits: 50! !

!Domain class methodsFor: 'examples' stamp: 'len 12/17/2016 09:27:30'!
example21VectorSpace
	"The vector space of 3-tuples with rational coefficients."
	^ QQ ^ 3! !

!Domain class methodsFor: 'examples' stamp: 'len 12/17/2016 09:27:22'!
example21VectorSpace2
	"The vector space of 3x3 matrices with complex coefficients."
	^ CC ^ (3@3)! !

!Domain class methodsFor: 'examples' stamp: 'len 3/3/2017 23:04:21'!
example2ModuleDirectSum
	"The direct sum of the module of 3x3 matrices
	with coefficients in Z/6Z plus the rank 1 module
	of Z/6Z scalars."
	^ ZZ/6 ^ (3@3)  (ZZ/6) asSelfModule! !

!Domain class methodsFor: 'examples' stamp: 'len 10/29/2016 08:05'!
example3DirectProductOfGroups
	"The direct product of the group of permutations of
	the symbols {#a, #b, #c} by the group of alternating
	permutations of {1,2,3,4}."
	^ (SymmetricGroup on: #(a b c))  (AlternatingGroup new: 4)! !

!Domain class methodsFor: 'examples' stamp: 'len 10/29/2016 07:58'!
example41Polynomials
	"Polynomials in two variables with integer coefficients."
	^ ZZ polynomialsIn: #(a b)! !

!Domain class methodsFor: 'examples' stamp: 'len 1/11/2018 21:29:20'!
example42AffineRing
	"The quotient of a polynomial ring by an ideal.
	This is an affine ring, in particular it is the coordinate ring of the twisted cubic."
	| R x y z I |
	R _ CC polynomialsIn: #(x y z).
	x _ R x: 1.
	y _ R x: 2.
	z _ R x: 3.
	I _ R * {(x^2) - y. (x^3) - z}.
	^ R / I! !

!Domain class methodsFor: 'examples' stamp: 'len 1/11/2018 21:29:07'!
example43AffineVariety
	"This is the twisted cubic affine variety, parameterized by (x, x^2, x^3) in C^3."
	| R x y z I |
	R _ CC polynomialsIn: #(x y z).
	x _ R x: 1.
	y _ R x: 2.
	z _ R x: 3.
	I _ R * {(x^2) - y. (x^3) - z}.
	^ (R / I) spec! !

!Domain class methodsFor: 'examples' stamp: 'len 1/11/2018 21:32:38'!
example5GL
	"The group GL(Q^3) of invertible linear maps
	on the vector space of 3-tuples with rational coefficients.
	This is the automorphisms group of the vector space, and
	its elements are linear maps, not matrices."
	^ (QQ ^ 3) automorphisms! !

!Domain class methodsFor: 'instance creation' stamp: 'len 4/23/2016 03:40'!
newFrom: anObject
	^ self new elements: anObject! !

!HomSet methodsFor: 'accessing' stamp: 'len 12/28/2016 11:23:54'!
codomain
	^ self propertyAt: #codomain! !

!HomSet methodsFor: 'accessing' stamp: 'len 12/28/2016 11:24:10'!
domain
	^ self propertyAt: #domain! !

!HomSet methodsFor: 'accessing-private' stamp: 'len 12/28/2016 11:24:05'!
codomain: aDomain
	self propertyAt: #codomain put: aDomain! !

!HomSet methodsFor: 'accessing-private' stamp: 'len 12/28/2016 11:24:00'!
domain: aDomain
	self propertyAt: #domain put: aDomain! !

!HomSet methodsFor: 'elements' stamp: 'len 5/19/2018 18:07:02'!
!! anObject
	anObject isEvaluable ifTrue: [^ self evaluating: anObject].
	^ super !! anObject! !

!HomSet methodsFor: 'elements' stamp: 'len 8/31/2016 03:37'!
evaluating: aBlock
	^ self domain to: self codomain evaluating: aBlock! !

!HomSet methodsFor: 'elements' stamp: 'len 10/23/2016 16:05'!
evaluatingWithArguments: aBlock
	^ self domain to: self codomain evaluatingWithArguments: aBlock! !

!HomSet methodsFor: 'elements' stamp: 'len 8/31/2016 03:41'!
identity
	^ self isEndomorphisms ifTrue: [self domain id]! !

!HomSet methodsFor: 'elements' stamp: 'len 5/24/2019 11:28:29'!
mapping: aBlock
	"Answer a morphism defined by images of generators.
	aBlock takes indices i and evaluates to the image of the i-th generator."
	^ self domain to: self codomain mapping: aBlock! !

!HomSet methodsFor: 'operations' stamp: 'len 9/16/2018 16:14:03'!
opposite
	^ self class from: self codomain to: self domain! !

!HomSet methodsFor: 'testing' stamp: 'len 10/4/2016 09:02'!
includes: aMorphism
	^ (aMorphism isKindOf: Morphism) and: [aMorphism domain = self domain and: [aMorphism codomain = self codomain]]! !

!HomSet methodsFor: 'testing' stamp: 'len 4/19/2016 04:53'!
isEndomorphisms
	^ self domain = self codomain! !

!HomSet class methodsFor: 'examples' stamp: 'len 4/22/2019 13:23:45'!
example1
	"The set Hom(N,Z), the functions from the natural numbers to the integers.
	This is the space of sequences. (See class Sequence)."
	^ NN hom: ZZ! !

!HomSet class methodsFor: 'examples' stamp: 'len 3/3/2017 17:42:46'!
example2
	"The endomorphisms of the rational integers Z.
	This is Hom(Z,Z), the set of ring homomorphisms from Z to itself."
	^ ZZ endomorphisms! !

!HomSet class methodsFor: 'examples' stamp: 'len 4/22/2019 13:30:14'!
example3
	"In some categories the Hom-Set has actually richer structure,
	and can be seen as an object of the category.
	Here's the vector space of linear maps from the Q^3 to Q^5.
	This is the internal hom(Q^3,Q^5), and it is a vector space itself.
	(It is not an instance of HomSet.)"
	^ (QQ^3) => (QQ^5)! !

!HomSet class methodsFor: 'instance creation' stamp: 'len 4/19/2016 04:53'!
from: aDomain to: anotherDomain
	^ self new domain: aDomain; codomain: anotherDomain! !

!PointSet methodsFor: 'accessing' stamp: 'len 11/7/2016 16:25'!
scalars
	^ self domain coordinateRing! !

!PointSet methodsFor: 'accessing' stamp: 'len 12/28/2016 11:24:20'!
size
	^ self propertyAt: #size ifAbsentPut: [self codomain pointsCountOver: self scalars]! !

!PointSet methodsFor: 'enumerating' stamp: 'len 11/7/2016 16:25'!
do: aBlock
	self codomain pointsOver: self scalars do: aBlock! !

!AbelianGroupHomSet methodsFor: 'as yet unclassified' stamp: 'len 4/21/2019 07:59:53'!
asAbelianGroup
	"Answer an abelian group that is isomorphic to this Hom-Set, equipped with coercion maps."
	^ self notYetImplemented! !

!ComplexBox methodsFor: 'accessing' stamp: 'len 1/16/2016 05:56'!
area
	^ self measure! !

!ComplexBox methodsFor: 'accessing' stamp: 'len 1/16/2016 05:59'!
closure
	^ self class real: real closure imaginary: imaginary closure! !

!ComplexBox methodsFor: 'accessing' stamp: 'len 1/11/2016 02:58'!
imaginary
	^ imaginary! !

!ComplexBox methodsFor: 'accessing' stamp: 'len 1/11/2016 02:55'!
measure
	^ real measure * imaginary measure! !

!ComplexBox methodsFor: 'accessing' stamp: 'len 1/15/2016 07:21'!
midpoint
	^ Complex real: real midpoint imaginary: imaginary midpoint! !

!ComplexBox methodsFor: 'accessing' stamp: 'len 6/5/2016 06:20'!
quarters
	| imaginaries reals |
	reals _ self real halves.
	imaginaries _ self imaginary halves.
	^ {self class real: (reals at: 1) imaginary: (imaginaries at: 1).
		self class real: (reals at: 1) imaginary: (imaginaries at: 2).
		self class real: (reals at: 2) imaginary: (imaginaries at: 1).
		self class real: (reals at: 2) imaginary: (imaginaries at: 2)}! !

!ComplexBox methodsFor: 'accessing' stamp: 'len 6/5/2016 04:08'!
radius2
	^ real length squared + imaginary length squared / 4! !

!ComplexBox methodsFor: 'accessing' stamp: 'len 1/11/2016 02:58'!
real
	^ real! !

!ComplexBox methodsFor: 'accessing' stamp: 'len 11/5/2016 09:53'!
sample
	"Answer a sample point in the receiver."
	| sampleImaginary sampleReal |
	sampleReal _ real sample.
	sampleImaginary _ imaginary sample.
	^ CC tuple: sampleReal size evaluating: [:i| Complex real: (sampleReal at: i) imaginary: (sampleImaginary at: i)]! !

!ComplexBox methodsFor: 'accessing' stamp: 'len 6/5/2016 21:42'!
width
	^ real length min: imaginary length! !

!ComplexBox methodsFor: 'accessing-private' stamp: 'len 1/11/2016 02:53'!
imaginary: aRealInterval
	imaginary _ aRealInterval! !

!ComplexBox methodsFor: 'accessing-private' stamp: 'len 1/11/2016 02:53'!
real: aRealInterval
	real _ aRealInterval! !

!ComplexBox methodsFor: 'testing' stamp: 'len 1/16/2016 05:50'!
closureIncludes: aComplex
	^ (real closureIncludes: aComplex real) and: [imaginary closureIncludes: aComplex imaginary]! !

!ComplexBox methodsFor: 'testing' stamp: 'len 1/11/2016 02:54'!
includes: aComplex
	^ (real includes: aComplex real) and: [imaginary includes: aComplex imaginary]! !

!ComplexBox methodsFor: 'testing' stamp: 'len 1/16/2016 05:52'!
intersects: aComplexBox
	^ (real intersects: aComplexBox real) and: [imaginary intersects: aComplexBox imaginary]! !

!ComplexBox methodsFor: 'testing' stamp: 'len 1/11/2016 03:40'!
isBounded
	^ real isBounded and: [imaginary isBounded]! !

!ComplexBox methodsFor: 'testing' stamp: 'len 1/11/2016 03:40'!
isClosed
	^ real isClosed and: [imaginary isClosed]! !

!ComplexBox methodsFor: 'testing' stamp: 'len 1/11/2016 03:41'!
isOpen
	^ real isOpen and: [imaginary isOpen]! !

!ComplexBox class methodsFor: 'instance creation' stamp: 'len 6/4/2016 21:53'!
center: aComplex radius: aNumber
	^ self
		real: (RealInterval closed: aComplex real - aNumber closed: aComplex real + aNumber)
		imaginary: (RealInterval closed: aComplex imaginary - aNumber closed: aComplex imaginary + aNumber)! !

!ComplexBox class methodsFor: 'instance creation' stamp: 'len 1/11/2016 03:43'!
real: aRealInterval imaginary: anotherRealInterval
	^ self new real: aRealInterval; imaginary: anotherRealInterval! !

!ComplexBox class methodsFor: 'instance creation' stamp: 'len 6/5/2016 04:07'!
with: aComplex with: anotherComplex
	^ self
		real: (RealInterval with: aComplex real with: anotherComplex real)
		imaginary: (RealInterval with: aComplex imaginary with: anotherComplex imaginary)! !

!ComplexDisk methodsFor: 'accessing' stamp: 'len 1/13/2016 22:30'!
center
	^ center! !

!ComplexDisk methodsFor: 'accessing' stamp: 'len 6/30/2016 04:43'!
enclosingBox
	"Answer a ComplexBox that encloses the receiver."
	^ ComplexBox center: self center radius: self radius! !

!ComplexDisk methodsFor: 'accessing' stamp: 'len 1/15/2016 07:21'!
midpoint
	^ self center! !

!ComplexDisk methodsFor: 'accessing' stamp: 'len 6/5/2016 20:42'!
radius
	^ radius! !

!ComplexDisk methodsFor: 'accessing-private' stamp: 'len 6/5/2016 20:47'!
center: aComplex
	center _ aComplex! !

!ComplexDisk methodsFor: 'accessing-private' stamp: 'len 6/5/2016 20:47'!
radius: aNumber
	radius _ aNumber! !

!ComplexDisk methodsFor: 'arithmetic' stamp: 'len 6/5/2016 20:46'!
* aDisk
	^ self class center: aDisk center * self center radius: self radius * aDisk radius! !

!ComplexDisk methodsFor: 'arithmetic' stamp: 'len 6/30/2016 04:37'!
+ aDisk
	^ self class center: aDisk center + self center radius: self radius + aDisk radius! !

!ComplexDisk methodsFor: 'testing' stamp: 'len 6/5/2016 20:44'!
includes: anObject
	^ (anObject - center) norm2 <= radius squared! !

!ComplexDisk methodsFor: 'testing' stamp: 'len 6/5/2016 04:13'!
intersects: aBall
	self flag: #fix.
	^ (aBall center - center) norm2 <= (self radius + aBall radius) squared! !

!ComplexDisk class methodsFor: 'instance creation' stamp: 'len 6/5/2016 20:47'!
center: aComplex radius: aNumber
	^ self new center: aComplex; radius: aNumber! !

!RealBox methodsFor: 'accessing' stamp: 'len 1/11/2016 02:33'!
add: aRealInterval
	^ components add: aRealInterval! !

!RealBox methodsFor: 'accessing' stamp: 'len 12/13/97 15:21'!
addAll: aCollection
	"Add the elements in the argument to the receiver. Answer the argument."

	aCollection do: [ :each | self add: each].
	^ aCollection! !

!RealBox methodsFor: 'accessing' stamp: 'len 1/11/2016 02:33'!
at: anInteger
	"Answer the anInteger-th component of the receiver."
	^ components at: anInteger! !

!RealBox methodsFor: 'accessing' stamp: 'len 1/11/2016 02:35'!
dimension
	^ components inject: 0 into: [:sum :each| sum + each]! !

!RealBox methodsFor: 'accessing' stamp: 'len 1/11/2016 02:35'!
first
	^ self at: 1! !

!RealBox methodsFor: 'accessing' stamp: 'len 1/11/2016 02:35'!
last
	^ self at: self size! !

!RealBox methodsFor: 'accessing' stamp: 'len 1/11/2016 02:36'!
measure
	^ components inject: 1 into: [:measure :each| measure * each measure]! !

!RealBox methodsFor: 'accessing' stamp: 'len 11/5/2016 10:39'!
midpoint
	^ RR tuple: (components collect: [:each| each midpoint])! !

!RealBox methodsFor: 'accessing' stamp: 'len 11/5/2016 05:48'!
sample
	"Answer a sample point in the receiver."
	^ RR tuple: self size evaluating: [:each| (self at: each) sample]! !

!RealBox methodsFor: 'accessing' stamp: 'len 1/11/2016 02:37'!
size
	^ components size! !

!RealBox methodsFor: 'accessing-private' stamp: 'len 1/11/2016 02:37'!
components
	^ components! !

!RealBox methodsFor: 'accessing-private' stamp: 'len 1/11/2016 02:37'!
components: aCollection
	components _ aCollection! !

!RealBox methodsFor: 'comparing' stamp: 'len 12/19/97 22:06'!
= anObject
	"Answer true if the receiver equals the argument."

	self size = anObject size ifFalse: [^ false].
	1 to: self size do: [ :each | (self at: each) = (anObject at: each) ifFalse: [^ false]].
	^ true! !

!RealBox methodsFor: 'comparing' stamp: 'len 6/28/2016 09:28'!
hash
	"Answer the hash value of the receiver."

	^ self size = 0
		ifTrue: [0]
		ifFalse: [self first hash hashMultiply + self last hash hashMultiply + self size hash]! !

!RealBox methodsFor: 'enumerating' stamp: 'len 1/11/2016 02:38'!
do: aBlock
	"Enumerate the components of the receiver."
	components do: aBlock! !

!RealBox methodsFor: 'initialization' stamp: 'len 1/11/2016 02:38'!
initialize
	components _ OrderedCollection new: 3! !

!RealBox methodsFor: 'testing' stamp: 'len 1/11/2016 02:40'!
includes: aTuple
	1 to: self size do: [:each|
		((self at: each) includes: (aTuple at: each)) ifFalse: [^ false]].
	^ true! !

!RealBox methodsFor: 'testing' stamp: 'len 1/11/2016 02:40'!
isBounded
	self do: [:each| each isBounded ifFalse: [^ false]].
	^ true! !

!RealBox methodsFor: 'testing' stamp: 'len 1/11/2016 02:40'!
isClosed
	self do: [:each| each isClosed ifFalse: [^ false]].
	^ true! !

!RealBox methodsFor: 'testing' stamp: 'len 1/11/2016 02:41'!
isOpen
	self do: [ :each | each isOpen ifFalse: [^ false]].
	^ true! !

!RealInterval methodsFor: 'accessing' stamp: 'len 12/19/97 22:10'!
dimension
	"Answer the dimension of the receiver."

	self isEmpty ifTrue: [^ Infinity negative].
	self left = self right ifTrue: [^ 0].
	^ 1! !

!RealInterval methodsFor: 'accessing' stamp: 'len 6/5/2016 06:26'!
halves
	| m |
	m _ self midpoint.
	^ {self copy right: m; rightOpen: false . self copy left: m; leftOpen: true}! !

!RealInterval methodsFor: 'accessing' stamp: 'len 12/13/97 03:22'!
inf
	"Answer the infimun of the receiver."

	^ self left! !

!RealInterval methodsFor: 'accessing' stamp: 'len 12/13/97 03:21'!
left
	"Answer the left bound of the receiver."

	^ left! !

!RealInterval methodsFor: 'accessing' stamp: 'len 1/16/2016 05:56'!
length
	^ self measure! !

!RealInterval methodsFor: 'accessing' stamp: 'len 12/13/97 03:24'!
max
	"Answer the maximum of the receiver."

	self isRightOpen ifTrue: [^ self error: 'there''s not maximum'].
	^ self right! !

!RealInterval methodsFor: 'accessing' stamp: 'len 1/11/2016 02:43'!
measure
	^ self right - self left! !

!RealInterval methodsFor: 'accessing' stamp: 'len 1/15/2016 07:19'!
midpoint
	^ left + right / 2! !

!RealInterval methodsFor: 'accessing' stamp: 'len 12/13/97 03:23'!
min
	"Answer the minimum of the receiver."

	self isLeftOpen ifTrue: [^ self error: 'there''s not minimun'].
	^ self left! !

!RealInterval methodsFor: 'accessing' stamp: 'len 12/13/97 03:21'!
right
	"Answer the right bound of the receiver."

	^ right! !

!RealInterval methodsFor: 'accessing' stamp: 'len 11/5/2016 09:58'!
sample
	"Answer a sample point in the receiver."

	self isEmpty ifTrue: [^ self error: 'empty interval'].
	self isLeftClosed ifTrue: [^ self left].
	self isRightClosed ifTrue: [^ self right].
	(self isLeftBounded and: [self isRightBounded])
		ifTrue: [^ self left + self right / 2].
	self isLeftBounded ifTrue: [^ self left + 1].
	self isRightBounded ifTrue: [^ self right - 1].
	^ 0! !

!RealInterval methodsFor: 'accessing' stamp: 'len 12/13/97 03:24'!
sup
	"Answer the supremum of the receiver."

	^ self right! !

!RealInterval methodsFor: 'accessing-private' stamp: 'len 12/13/97 03:18'!
left: aNumber
	left _ aNumber! !

!RealInterval methodsFor: 'accessing-private' stamp: 'len 12/13/97 02:30'!
leftOpen: aBoolean
	leftOpen _ aBoolean! !

!RealInterval methodsFor: 'accessing-private' stamp: 'len 12/13/97 03:21'!
right: aNumber
	right _ aNumber! !

!RealInterval methodsFor: 'accessing-private' stamp: 'len 12/13/97 02:32'!
rightOpen: aBoolean
	rightOpen _ aBoolean! !

!RealInterval methodsFor: 'arithmetic' stamp: 'len 12/13/97 03:19'!
* anInterval
	"Answer the product of the receiver by the argument."

	| l1l2 l1r2 r1l2 r1r2 |
	l1l2 _ self left * anInterval left.
	l1r2 _ self left * anInterval right.
	r1l2 _ self right * anInterval left.
	r1r2 _ self right * anInterval right.
	^ self copy
		left: ((l1l2 min: l1r2) min: (r1l2 min: r1r2));
		right: ((l1l2 max: l1r2) max: (r1l2 max: r1r2))! !

!RealInterval methodsFor: 'arithmetic' stamp: 'len 12/13/97 03:20'!
+ anInterval
	"Answer the sum of the receiver and the argument."

	^ self copy
		left: self left + anInterval left;
		right: self right + anInterval right! !

!RealInterval methodsFor: 'arithmetic' stamp: 'len 12/13/97 03:36'!
- anInterval
	"Answer the difference of the receiver and the argument."

	^ self + anInterval negated! !

!RealInterval methodsFor: 'arithmetic' stamp: 'len 12/13/97 02:14'!
/ anInterval
	"Answer the quotient of the receiver by the argument."

	^ self * anInterval reciprocal! !

!RealInterval methodsFor: 'arithmetic' stamp: 'len 12/13/97 03:20'!
negated
	"Answer the additive inverse of the receiver."

	^ self copy
		right: self left negated;
		left: self right negated;
		leftOpen: self isRightOpen;
		rightOpen: self isLeftOpen! !

!RealInterval methodsFor: 'arithmetic' stamp: 'len 1/16/2016 05:48'!
reciprocal
	"Answer the multiplicative inverse of the receiver."
	(self closureIncludes: 0) ifTrue: [^ ZeroDivide signal].
	^ self copy
		left: self right reciprocal;
		right: self left reciprocal! !

!RealInterval methodsFor: 'arithmetic' stamp: 'len 1/16/2016 06:58'!
squared
	^ self * self! !

!RealInterval methodsFor: 'comparing' stamp: 'len 1/16/2016 05:57'!
= anInterval
	^ left = anInterval left and: [right = anInterval right and: [self isLeftOpen = anInterval isLeftOpen and: [self isRightOpen = anInterval isRightOpen]]]! !

!RealInterval methodsFor: 'comparing' stamp: 'len 6/28/2016 09:30'!
hash
	^ self left hash hashMultiply + self right hash + self isRightOpen hash + self isLeftOpen hash hashMultiply! !

!RealInterval methodsFor: 'constants' stamp: 'len 12/13/97 03:20'!
identity
	"Answer the identity element for the receiver."

	^ self copy left: 1; right: 1! !

!RealInterval methodsFor: 'constants' stamp: 'len 12/13/97 03:20'!
null
	"Answer the null element for the receiver."

	^ self copy left: 0; right: 0! !

!RealInterval methodsFor: 'converting' stamp: 'len 12/13/97 02:31'!
close
	"Answer a closed inverval with the same bounds that the receiver."

	self isClosed ifFalse: [^ self copy leftOpen: false; rightOpen: false]! !

!RealInterval methodsFor: 'converting' stamp: 'len 12/13/97 02:40'!
closeLeft
	"Answer a closed left interval with the same bounds that the receiver."

	self isLeftClosed ifFalse: [^ self copy leftOpen: false]! !

!RealInterval methodsFor: 'converting' stamp: 'len 12/13/97 02:35'!
closeRight
	"Answer a closed right interval with the same bounds that the receiver."

	self isRightClosed ifFalse: [^ self copy rightOpen: false]! !

!RealInterval methodsFor: 'converting' stamp: 'len 12/13/97 02:32'!
open
	"Answer an open inverval with the same bounds that the receiver."

	self isOpen ifFalse: [^ self copy leftOpen: true; rightOpen: true]! !

!RealInterval methodsFor: 'converting' stamp: 'len 12/13/97 02:38'!
openLeft
	"Answer an open left interval with the same bounds that the receiver."

	self isLeftOpen ifFalse: [^ self copy leftOpen: true]! !

!RealInterval methodsFor: 'converting' stamp: 'len 12/13/97 02:39'!
openRight
	"Answer an open right interval with the same bounds that the receiver."

	self isRightOpen ifFalse: [^ self copy rightOpen: true]! !

!RealInterval methodsFor: 'initialization' stamp: 'len 12/13/97 03:18'!
setLeftBound: leftBound rightBound: rightBound leftOpen: leftOpenBool rightOpen: rightOpenBool
	left _ leftBound.
	right _ rightBound.
	"If the interval is left-closed or right-closed and two points are
	the same, then the interval is a single point... so it's closed."
	((leftOpenBool & rightOpenBool) not and: [left = right])
		ifTrue: [leftOpen _ false.
				rightOpen _ false]
		ifFalse: [leftOpen _ leftOpenBool.
				rightOpen _ rightOpenBool]! !

!RealInterval methodsFor: 'operations' stamp: 'len 12/30/2017 16:20:58'!
, anInterval
	"Answer the cartesian product of the receiver by the argument."
	| answer |
	answer _ RealBox new add: self; yourself.
	anInterval do: [:each| answer add: each].
	^ answer! !

!RealInterval methodsFor: 'operations' stamp: 'len 1/16/2016 05:59'!
closure
	^ self class closed: left closed: right! !

!RealInterval methodsFor: 'operations' stamp: 'len 6/2/2016 07:29'!
interior
	^ self class open: left open: right! !

!RealInterval methodsFor: 'testing' stamp: 'len 3/28/2018 18:05:40'!
closureIncludes: anObject
	anObject isTuple ifTrue: [^ anObject size = 1 and: [self includes: anObject first]].
	^ anObject between: left and: right! !

!RealInterval methodsFor: 'testing' stamp: 'len 3/28/2018 18:05:25'!
includes: anObject
	anObject isTuple ifTrue: [^ anObject size = 1 and: [self includes: (anObject at: 1)]].
	(self left > anObject or: [self right < anObject])
		ifTrue: [^ false].
	(self left < anObject and: [self right > anObject])
		ifTrue: [^ true].
	((self isLeftClosed and: [anObject = self left])
	or: [self isRightClosed and: [anObject = self right]])
		ifTrue: [^ true].
	^ false! !

!RealInterval methodsFor: 'testing' stamp: 'len 6/4/2016 21:43'!
intersects: anInterval
	"Answer true if the receiver overlaps the argument."
	self right < anInterval left ifTrue: [^ false].
	self left > anInterval right ifTrue: [^ false].
	self right = anInterval left ifTrue: [^ self isRightClosed and: [anInterval isLeftClosed]].
	self left = anInterval right ifTrue: [^ self isLeftClosed and: [anInterval isRightClosed]].
	^ true! !

!RealInterval methodsFor: 'testing' stamp: 'len 12/13/97 03:29'!
isBounded
	"Answer true if the receiver is bounded."

	^ self isLeftBounded and: [self isRightBounded]! !

!RealInterval methodsFor: 'testing' stamp: 'len 12/13/97 02:36'!
isClosed
	"Answer true if the receiver is closed."

	^ self isLeftClosed and: [self isRightClosed]! !

!RealInterval methodsFor: 'testing' stamp: 'len 12/13/97 03:23'!
isEmpty
	"Answer true if the receiver is empty."

	^ self isLeftBounded
		ifTrue: [self right < self left]
		ifFalse: [self left > self right]! !

!RealInterval methodsFor: 'testing' stamp: 'len 6/2/2016 05:16'!
isFinite
	^ left = right and: [leftOpen not | rightOpen not]! !

!RealInterval methodsFor: 'testing' stamp: 'len 12/13/97 02:14'!
isHalfOpen
	"Answer true if the receiver is hald-open."

	^ self isClosed not and: [self isOpen not]! !

!RealInterval methodsFor: 'testing' stamp: 'len 12/13/97 02:23'!
isLeftBounded
	"Answer true if the receiver is left bounded."

	^ self left isInfinity not! !

!RealInterval methodsFor: 'testing' stamp: 'len 12/13/97 02:33'!
isLeftClosed
	"Answer true if the receiver is left closed."

	^ self isLeftOpen not! !

!RealInterval methodsFor: 'testing' stamp: 'len 12/13/97 02:36'!
isLeftOpen
	"Answer true if the receiver is left open."

	^ leftOpen! !

!RealInterval methodsFor: 'testing' stamp: 'len 12/13/97 02:38'!
isOpen
	"Answer true if the receiver is open."

	^ self isLeftOpen and: [self isRightOpen]! !

!RealInterval methodsFor: 'testing' stamp: 'len 12/13/97 02:24'!
isRightBounded
	"Answer true if the receiver is right bounded."

	^ self right isInfinity not! !

!RealInterval methodsFor: 'testing' stamp: 'len 12/13/97 02:35'!
isRightClosed
	"Answer true if the receiver is right closed."

	^ self isRightOpen not! !

!RealInterval methodsFor: 'testing' stamp: 'len 12/13/97 02:37'!
isRightOpen
	"Answer true if the receiver is open right."

	^ rightOpen! !

!RealInterval methodsFor: 'testing' stamp: 'len 12/13/97 03:23'!
sign
	"Answer 1 if the receiver is greater than 0, -1 if less than 0, else 0."

	self left > 0 ifTrue: [^ 1].
	self right < 0 ifTrue: [^ -1].
	^ 0! !

!RealInterval class methodsFor: 'instance creation' stamp: 'len 12/13/97 02:29'!
closed: left closed: right
	"Answer a new [left, right] interval."

	^ self new setLeftBound: left rightBound: right leftOpen: false rightOpen: false! !

!RealInterval class methodsFor: 'instance creation' stamp: 'len 12/13/97 02:30'!
closed: left open: right
	"Answer a new [left, right) interval."

	^ self new setLeftBound: left rightBound: right leftOpen: false rightOpen: true! !

!RealInterval class methodsFor: 'instance creation' stamp: 'len 12/13/97 02:30'!
open: left closed: right
	"Answer a new (left, right] interval."

	^ self new setLeftBound: left rightBound: right leftOpen: true rightOpen: false! !

!RealInterval class methodsFor: 'instance creation' stamp: 'len 12/13/97 02:30'!
open: left open: right
	"Answer a new (left, right) interval."

	^ self new setLeftBound: left rightBound: right leftOpen: true rightOpen: true! !

!CartesianProduct methodsFor: 'accessing' stamp: 'len 2/16/2016 07:29'!
arity
	^ components size! !

!CartesianProduct methodsFor: 'accessing' stamp: 'len 2/12/2016 04:11'!
at: anInteger
	^ components at: anInteger! !

!CartesianProduct methodsFor: 'accessing' stamp: 'len 2/26/2017 09:47:17'!
size
	^ components product: [:each| each size]! !

!CartesianProduct methodsFor: 'comparing' stamp: 'len 9/16/2018 16:11:29'!
= anObject
	^ (anObject isKindOf: CartesianProduct) and: [components = anObject components]! !

!CartesianProduct methodsFor: 'comparing' stamp: 'len 11/10/2015 23:19'!
hash
	^ components hash! !

!CartesianProduct methodsFor: 'converting' stamp: 'len 5/26/2019 04:31:21'!
asArray
	^ components! !

!CartesianProduct methodsFor: 'enumerating' stamp: 'len 7/29/2016 06:53'!
do: aBlock
	(self components allSatisfy: [:each| each isFinite])
		ifFalse: [^ self upTo: self size rank: self arity do: aBlock].
	self upToComponent: self arity do: aBlock! !

!CartesianProduct methodsFor: 'enumerating' stamp: 'len 11/5/2016 10:29'!
upTo: max rank: n do: aBlock
	| k |
	self notYetImplemented.
	n = 0 ifTrue: [^ aBlock value: #()].
	k _ 1.
	(self at: n) upTo: max do: [:s|
		self upTo: k rank: n-1 do: [:p|
			aBlock value: {p. s}.
			"(self at: n) upTo: k-1 do: [:t| (p includes: s) ifTrue: [aBlock value: (p,t)]]"].
		k _ k + 1]! !

!CartesianProduct methodsFor: 'enumerating' stamp: 'len 5/2/2018 18:14:01'!
upToComponent: k do: aBlock
	k = 0 ifTrue: [aBlock value: Array new. ^ self].
	self upToComponent: k-1 do: [:each| (self at: k) do: [:last| aBlock value: (each copyWith: last)]]! !

!CartesianProduct methodsFor: 'morphisms' stamp: 'len 5/26/2019 04:33:44'!
>- aCodomain
	"Answer the tuple of canonical coprojections from each component of the receiver to the argument.
	See also Domain's message -<."
	aCodomain propertyAt: #inputMapTuples ifPresent: [:aDictionary| aDictionary at: self asArray ifPresent: [:aTupleOfMaps| ^ aTupleOfMaps]].
	^ nil! !

!CartesianProduct methodsFor: 'morphisms' stamp: 'len 10/10/2016 08:41'!
projection: i
	^ (self to: (self at: i) evaluating: [:x| x at: i]) name: Character pi asText, i printText sub! !

!CartesianProduct methodsFor: 'operations' stamp: 'len 12/30/2017 15:19:20'!
, aDomain
	^ aDomain class == self class
		ifTrue: [self class components: components, aDomain components]
		ifFalse: [self class components: (components copyWith: aDomain)]! !

!CartesianProduct methodsFor: 'random' stamp: 'len 4/19/2016 20:28'!
atRandom: aRandom
	^ components collect: [:each| each atRandom: aRandom]! !

!CartesianProduct methodsFor: 'random' stamp: 'len 4/19/2016 20:28'!
atRandom: aRandom bits: bitSize
	| n |
	n _ bitSize / components size.
	^ components collect: [:each| each atRandom: aRandom bits: n]! !

!CartesianProduct methodsFor: 'testing' stamp: 'len 5/22/2018 16:54:11'!
includes: anObject
	anObject isSequenceable ifFalse: [^ false].
	components size = anObject size ifFalse: [^ false].
	1 to: components size do: [:i|
		((components at: i) includes: (anObject at: i))
			ifFalse: [^ false]].
	^ true! !

!CartesianProduct methodsFor: 'testing' stamp: 'len 4/22/2016 13:42'!
isProduct
	^ true! !

!CartesianProduct methodsFor: 'private' stamp: 'len 11/10/2015 22:13'!
components
	^ components! !

!CartesianProduct methodsFor: 'private' stamp: 'len 11/5/2016 06:40'!
components: anArray
	components _ anArray! !

!CartesianProduct class methodsFor: 'examples' stamp: 'len 5/22/2018 21:37:09'!
example
	"The cartesian product of the ring of rational integers
	and the field of rational numbers (as sets)."
	^ (ZZ, QQ)
! !

!CartesianProduct class methodsFor: 'instance creation' stamp: 'len 11/10/2015 22:17'!
components: anArray
	^ self new components: anArray! !

!EquivalenceClass methodsFor: 'accessing' stamp: 'len 12/28/2016 11:24:38'!
relation
	^ self propertyAt: #relation! !

!EquivalenceClass methodsFor: 'accessing' stamp: 'len 4/25/2016 08:40'!
representative
	^ representative! !

!EquivalenceClass methodsFor: 'accessing-private' stamp: 'len 12/28/2016 11:24:32'!
relation: anEquivalenceRelation
	self propertyAt: #relation put: anEquivalenceRelation! !

!EquivalenceClass methodsFor: 'accessing-private' stamp: 'len 4/25/2016 08:40'!
representative: anElement
	representative _ anElement! !

!EquivalenceClass methodsFor: 'comparing' stamp: 'len 4/25/2016 09:14'!
= anEquivalenceClass
	^ anEquivalenceClass includes: self representative! !

!EquivalenceClass methodsFor: 'comparing' stamp: 'len 4/25/2016 09:13'!
hash
	^ self class hash! !

!EquivalenceClass methodsFor: 'enumerating' stamp: 'len 4/25/2016 09:33'!
do: aBlock
	self relation domain do: [:each| (self relation includes: {each. self representative}) ifTrue: [aBlock value: each]]! !

!EquivalenceClass methodsFor: 'testing' stamp: 'len 4/24/2016 04:40'!
includes: anElement
	^ self relation includes: {anElement. self representative}! !

!EquivalenceClass class methodsFor: 'instance creation' stamp: 'len 4/25/2016 09:23'!
representative: anElement relation: anEquivalenceRelation
	^ self new representative: anElement; relation: anEquivalenceRelation! !

!EquivalenceRelation methodsFor: 'accessing' stamp: 'len 12/28/2016 11:25:39'!
domain
	^ self propertyAt: #domain! !

!EquivalenceRelation methodsFor: 'accessing-private' stamp: 'len 12/28/2016 11:24:43'!
block: aBlock
	self propertyAt: #block put: aBlock! !

!EquivalenceRelation methodsFor: 'accessing-private' stamp: 'len 12/28/2016 11:25:32'!
domain: aDomain
	self propertyAt: #domain put: aDomain! !

!EquivalenceRelation methodsFor: 'enumerating' stamp: 'len 4/25/2016 08:55'!
do: aBlock
	self domain do: [:x|
		self domain do: [:y|
			| r |
			(self includes: (r _ {x.y})) ifTrue: [aBlock value: r]]]! !

!EquivalenceRelation methodsFor: 'testing' stamp: 'len 12/28/2016 11:25:26'!
includes: anArray
	^ (self propertyAt: #block) valueWithArguments: anArray! !

!EquivalenceRelation methodsFor: 'testing' stamp: 'len 4/24/2016 04:25'!
isReflexive
	^ true! !

!EquivalenceRelation methodsFor: 'testing' stamp: 'len 4/24/2016 04:24'!
isSymmetric
	^ true! !

!EquivalenceRelation methodsFor: 'testing' stamp: 'len 4/24/2016 04:25'!
isTransitive
	^ true! !

!EquivalenceRelation class methodsFor: 'instance creation' stamp: 'len 4/25/2016 08:48'!
on: aDomain evaluating: aBlock
	^ self new domain: aDomain; block: aBlock! !

!Naturals methodsFor: 'accessing' stamp: 'len 2/13/2016 20:41'!
identity
	^ 1! !

!Naturals methodsFor: 'accessing' stamp: 'len 4/24/2016 02:58'!
size
	^ Aleph new! !

!Naturals methodsFor: 'comparing' stamp: 'len 12/14/2015 01:55'!
= anObject
	^ self class == anObject class! !

!Naturals methodsFor: 'comparing' stamp: 'len 12/14/2015 01:55'!
hash
	^ self class hash! !

!Naturals methodsFor: 'enumerating' stamp: 'len 12/3/2015 20:12'!
do: aBlock
	| n |
	n _ 1.
	[aBlock value: n. n _ n + 1] repeat! !

!Naturals methodsFor: 'morphisms' stamp: 'len 9/17/2016 06:52'!
to: aDomain evaluating: aBlock
	"Answer a sequence with values in aDomain."
	^ Sequence to: aDomain evaluating: aBlock! !

!Naturals methodsFor: 'random' stamp: 'len 6/30/2016 00:34'!
atRandom: aRandom bits: bitSize
	^ (aRandom nextBits: bitSize truncated) + 1! !

!Naturals methodsFor: 'testing' stamp: 'len 2/13/2016 20:41'!
isCommutative
	^ true! !

!Naturals methodsFor: 'testing' stamp: 'len 12/5/2015 02:09'!
isFinite
	^ false! !

!Naturals methodsFor: 'testing' stamp: 'len 2/11/2016 22:19'!
isReal
	^ true! !

!Naturals class methodsFor: 'initialization' stamp: 'len 8/5/2016 21:33'!
initialize
	super initialize.
	Smalltalk at: #NN put: self new! !

!QuotientSet methodsFor: 'accessing' stamp: 'len 4/26/2016 07:26'!
base
	^ self relation domain! !

!QuotientSet methodsFor: 'accessing' stamp: 'len 12/28/2016 11:25:49'!
relation
	^ self propertyAt: #relation! !

!QuotientSet methodsFor: 'accessing-private' stamp: 'len 12/28/2016 11:25:44'!
relation: anEquivalenceRelation
	self propertyAt: #relation put: anEquivalenceRelation! !

!QuotientSet methodsFor: 'enumerating' stamp: 'len 8/14/2016 06:17'!
do: aBlock
	| visited |
	visited _ Set new.
	self base do: [:each|
		| x |
		x _ self project: each.
		visited add: x ifAbsent: [aBlock value: x]]! !

!QuotientSet methodsFor: 'morphisms' stamp: 'len 5/13/2019 19:07:40'!
from: aDomain
	aDomain = self base ifTrue: [^ self projection].
	aDomain -> self base ifNotNil: [:aMorphism| ^ aMorphism -> self].
	^ super from: aDomain! !

!QuotientSet methodsFor: 'morphisms' stamp: 'len 4/24/2016 04:46'!
project: anElement
	^ EquivalenceClass representative: anElement relation: self relation! !

!QuotientSet methodsFor: 'morphisms' stamp: 'len 10/10/2016 08:52'!
projection
	^ (Function from: self base to: self evaluating: [:v| self project: v]) name: Character pi asString! !

!QuotientSet methodsFor: 'testing' stamp: 'len 8/10/2016 01:01'!
isQuotient
	^ true! !

!QuotientSet class methodsFor: 'instance creation' stamp: 'len 12/30/2016 09:57:52'!
mod: anEquivalenceRelation
	^ self new relation: anEquivalenceRelation! !

!Semigroup methodsFor: 'accessing' stamp: 'len 5/13/2019 16:57:13'!
operation
	^ self propertyAt: #operation ifAbsentPut: [((self, self) to: self evaluatingWithArguments: [:x :y| x  y]) name: '']! !

!Semigroup methodsFor: 'morphic' stamp: 'len 5/13/2019 16:56:49'!
multiplicationTable
	| elements |
	elements _ self elements asArray asSortedCollection: [:a :b|
		| str |
		str _ a printString.
		({'id'. '0'. '1'} includes: str) or: [str <= b printString]].
	^ MultiplicationTableMorph elements: elements operation: self operation! !

!Semigroup methodsFor: 'morphic' stamp: 'len 5/13/2019 16:57:02'!
multiplicationTable2
	| elements op table palette p |
	op _ self operation.
	palette _ DiscretePalette default.
	table _ LayoutMorph newRow color: Color red.
	table morphExtent: 150@150.
	elements _ self elements asArray asSortedCollection: [:a :b|
		| str |
		str _ a printString.
		({'id'. '0'. '1'} includes: str) or: [str <= b printString]].
	p _ 1 / elements size.
	elements do: [:x| | column |
		column _ LayoutMorph newColumn color: Color green.
		elements do: [:y| | cell xy |
			xy _ op value: {x. y}.
			cell _ RectangleLikeMorph new color: (palette at: xy).
			cell setBalloonText: xy printString.
			column addMorph: cell proportionalHeight: p].
		table addMorph: column proportionalWidth: p].
	^ table! !

!Semigroup methodsFor: 'testing' stamp: 'len 5/13/2019 16:56:32'!
isCommutative
	| X |
	self propertyAt: #isCommutative ifPresent: [:aBoolean| ^ aBoolean].
	X _ self generators ifNil: [self].
	X do: [:x| X do: [:y| x  y = (y  x) ifFalse: [^ false]]].
	^ true! !

!Semigroup methodsFor: 'testing' stamp: 'len 12/14/2016 22:07:12'!
isSemigroup
	^ true! !

!Semigroup methodsFor: 'testing' stamp: 'len 5/13/2019 12:29:50'!
isTrivial
	^ self isEmpty! !

!FreeAbelianSemigroup methodsFor: 'accessing' stamp: 'len 5/23/2019 19:14:29'!
generators
	^ self propertyAt: #generators ifAbsentPut: [(1 to: rank) collect: [:i| (Monomial new: rank x: i) parent: self]]! !

!FreeAbelianSemigroup methodsFor: 'accessing' stamp: 'len 5/23/2019 19:15:55'!
names
	"Answer the indeterminate names to use when printing monomials."
	^ self propertyAt: #names ifAbsent: [self rank = 1 ifTrue: [#(x)]]! !

!FreeAbelianSemigroup methodsFor: 'accessing' stamp: 'len 5/23/2019 19:16:09'!
names: anArray
	"Set indeterminate names to use when printing monomials."
	self propertyAt: #names put: anArray! !

!FreeAbelianSemigroup methodsFor: 'accessing' stamp: 'len 5/23/2019 19:10:47'!
ordering
	^ ordering! !

!FreeAbelianSemigroup methodsFor: 'accessing' stamp: 'len 5/23/2019 19:15:21'!
rank
	^ rank! !

!FreeAbelianSemigroup methodsFor: 'accessing' stamp: 'len 5/23/2019 19:11:24'!
size
	^ self rank > 0 ifTrue: [Aleph new] ifFalse: [0]! !

!FreeAbelianSemigroup methodsFor: 'comparing' stamp: 'len 5/23/2019 19:09:57'!
= anObject
	^ (anObject isKindOf: FreeAbelianSemigroup) and: [anObject rank = rank]! !

!FreeAbelianSemigroup methodsFor: 'comparing' stamp: 'len 5/23/2019 19:09:41'!
hash
	^ self rank + self class hash! !

!FreeAbelianSemigroup methodsFor: 'elements' stamp: 'len 5/23/2019 19:07:06'!
!! anObject
	| exponents n |
	exponents _ anObject isSequenceable ifTrue: [anObject] ifFalse: [anObject exponents].
	(n _ exponents size) = rank
		ifFalse:
			[n > rank
				ifTrue: [exponents _ exponents copyFrom: 1 to: rank]
				ifFalse: [exponents _ exponents, (ByteArray new: rank - n) "hack"]].
	^ (Monomial exponents: exponents) parent: self! !

!FreeAbelianSemigroup methodsFor: 'elements' stamp: 'len 5/13/2019 20:44:07'!
exponents: anArray
	anArray size = rank ifFalse: [self error: 'exponents size doesn''t match rank'].
	^ (Monomial exponents: anArray) parent: self! !

!FreeAbelianSemigroup methodsFor: 'enumerating' stamp: 'len 5/23/2019 19:09:12'!
do: aBlock
	| first |
	first _ true.
	NN ^ self rank do: [:each| first ifFalse: [aBlock value: self !! (each asArray collect: [:x| x - 1])]. first _ false]! !

!FreeAbelianSemigroup methodsFor: 'random' stamp: 'len 5/23/2019 19:05:59'!
atRandom: aRandom bits: bitSize
	| M |
	M _ ZZ ^ self rank.
	^ self !! (((M atRandom: aRandom bits: bitSize) collect: [:each| each abs]) + (M generators atRandom: aRandom))! !

!FreeAbelianSemigroup methodsFor: 'testing' stamp: 'len 5/23/2019 18:50:38'!
isCommutative
	^ true! !

!FreeAbelianSemigroup methodsFor: 'private' stamp: 'len 5/23/2019 19:10:28'!
ordering: aMonomialOrdering
	ordering _ aMonomialOrdering isSymbol
		ifTrue: [MonomialOrdering perform: (aMonomialOrdering,':') asSymbol with: (1 to: self rank)]
		ifFalse: [aMonomialOrdering]! !

!FreeAbelianSemigroup methodsFor: 'private' stamp: 'len 5/23/2019 19:15:17'!
rank: anInteger
	rank _ anInteger! !

!FreeAbelianSemigroup class methodsFor: 'instance creation' stamp: 'len 5/23/2019 17:10:39'!
new: anIntegerOrCollection
	^ self new: anIntegerOrCollection ordering: #grevlex! !

!FreeAbelianSemigroup class methodsFor: 'instance creation' stamp: 'len 5/23/2019 17:10:18'!
new: anIntegerOrCollection ordering: aMonomialOrdering
	^ (anIntegerOrCollection isInteger
		ifTrue: [self new rank: anIntegerOrCollection] 
		ifFalse: [self new rank: anIntegerOrCollection size; names: anIntegerOrCollection asArray]) ordering: aMonomialOrdering! !

!FreeSemigroup methodsFor: 'accessing' stamp: 'len 5/13/2019 11:07:37'!
generators
	^ self propertyAt: #generators ifAbsentPut: ((1 to: self rank) collect: [:i| (Word x: i) parent: self])! !

!FreeSemigroup methodsFor: 'accessing' stamp: 'len 5/14/2019 05:42:11'!
names
	"Answer the indeterminate names to use when printing words."
	^ self propertyAt: #names ifAbsent: [self rank = 1 ifTrue: [#(x)]]! !

!FreeSemigroup methodsFor: 'accessing' stamp: 'len 5/13/2019 11:07:26'!
rank
	^ self propertyAt: #rank! !

!FreeSemigroup methodsFor: 'accessing' stamp: 'len 5/13/2019 11:06:58'!
size
	^ self rank > 0 ifTrue: [Aleph new] ifFalse: [0]! !

!FreeSemigroup methodsFor: 'random' stamp: 'len 5/23/2019 18:59:49'!
atRandom: aRandom bits: bitSize
	| answer n |
	answer _ self generators atRandom: aRandom.
	n _ self rank.
	bitSize // n highBit
		timesRepeat:
			[((n + 1) atRandom: aRandom) = 1
				ifFalse: [answer _ (self x: (self rank atRandom: aRandom)) * answer]].
	^ answer! !

!FreeSemigroup methodsFor: 'testing' stamp: 'len 5/23/2019 18:58:43'!
contains: aWord
	aWord isEmpty ifTrue: [^ false].
	aWord do: [:i :exp| (self rank <= i and: [exp >= 0]) ifFalse: [^ false]].
	^ true! !

!FreeSemigroup methodsFor: 'testing' stamp: 'len 5/23/2019 18:57:55'!
includes: aWord
	^ (aWord isKindOf: Word) and: [aWord parent = self]! !

!FreeSemigroup methodsFor: 'testing' stamp: 'len 5/13/2019 11:08:15'!
isCommutative
	^ self rank <= 1! !

!FreeSemigroup methodsFor: 'private' stamp: 'len 5/13/2019 13:01:27'!
names: anArray
	"Set indeterminate names to use when printing words."
	self propertyAt: #names put: anArray! !

!FreeSemigroup methodsFor: 'private' stamp: 'len 5/13/2019 11:21:46'!
rank: anInteger
	self propertyAt: #rank put: anInteger! !

!FreeSemigroup class methodsFor: 'instance creation' stamp: 'len 5/23/2019 17:09:21'!
new: anIntegerOrCollection
	^ anIntegerOrCollection isInteger
		ifTrue: [self new rank: anIntegerOrCollection] 
		ifFalse: [self new rank: anIntegerOrCollection size; names: anIntegerOrCollection asArray]! !

!Monoid methodsFor: 'accessing' stamp: 'len 12/28/2016 11:26:45'!
identity
	^ self propertyAt: #identity! !

!Monoid methodsFor: 'testing' stamp: 'len 2/14/2016 18:08'!
isMonoid
	^ true! !

!Monoid methodsFor: 'testing' stamp: 'len 5/13/2019 12:29:33'!
isTrivial
	"Answer true if the receiver is the trivial monoid {id}."
	| generators |
	self propertyAt: #elements ifPresent: [:aCollection| ^ aCollection size = 1].
	generators _ self generators ifNil: [^ self size = 1].
	^ generators allSatisfy: [:each| each = self identity]! !

!FreeAbelianMonoid methodsFor: 'accessing' stamp: 'len 5/13/2019 12:26:39'!
generators
	^ self propertyAt: #generators ifAbsentPut: [(1 to: rank) collect: [:i| self x: i to: 1]]! !

!FreeAbelianMonoid methodsFor: 'accessing' stamp: 'len 5/13/2019 11:53:52'!
identity
	^ self propertyAt: #identity ifAbsentPut: [(Monomial new: rank) parent: self]! !

!FreeAbelianMonoid methodsFor: 'accessing' stamp: 'len 5/14/2019 05:41:54'!
names
	"Answer the indeterminate names to use when printing monomials."
	^ self propertyAt: #names ifAbsent: [self rank = 1 ifTrue: [#(x)]]! !

!FreeAbelianMonoid methodsFor: 'accessing' stamp: 'len 2/27/2017 07:37:47'!
names: anArray
	"Set indeterminate names to use when printing monomials."
	self propertyAt: #names put: anArray! !

!FreeAbelianMonoid methodsFor: 'accessing' stamp: 'len 11/20/2016 11:03:52'!
ordering
	^ ordering! !

!FreeAbelianMonoid methodsFor: 'accessing' stamp: 'len 6/28/2016 23:37'!
rank
	^ rank! !

!FreeAbelianMonoid methodsFor: 'accessing' stamp: 'len 2/26/2017 09:29:46'!
size
	^ self rank > 0 ifTrue: [Aleph new] ifFalse: [1]! !

!FreeAbelianMonoid methodsFor: 'comparing' stamp: 'len 2/26/2017 09:25:28'!
= anObject
	^ (anObject isKindOf: FreeAbelianMonoid) and: [anObject rank = rank]! !

!FreeAbelianMonoid methodsFor: 'comparing' stamp: 'len 6/30/2016 00:21'!
hash
	^ self rank + self class hash! !

!FreeAbelianMonoid methodsFor: 'converting' stamp: 'len 5/13/2019 22:15:42'!
orderedBy: aMonomialOrdering
	| answer |
	answer _ self class new: self rank ordering: aMonomialOrdering.
	self names ifNotNil: [:aCollection| answer names: aCollection].
	^ answer! !

!FreeAbelianMonoid methodsFor: 'elements' stamp: 'len 5/13/2019 12:05:02'!
!! anObject
	| exponents n |
	exponents _ anObject isSequenceable ifTrue: [anObject] ifFalse: [anObject exponents].
	(n _ exponents size) = rank
		ifFalse:
			[n > rank
				ifTrue: [exponents _ exponents copyFrom: 1 to: rank]
				ifFalse: [exponents _ exponents, (ByteArray new: rank - n) "hack"]].
	^ (Monomial exponents: exponents) parent: self! !

!FreeAbelianMonoid methodsFor: 'elements' stamp: 'len 2/27/2017 07:52:27'!
exponents: anArray
	anArray size = rank ifFalse: [self error: 'exponents size doesn''t match rank'].
	^ (Monomial exponents: anArray) parent: self! !

!FreeAbelianMonoid methodsFor: 'elements' stamp: 'len 11/24/2016 10:59:05'!
x: anInteger to: exponent
	^ (Monomial new: rank x: anInteger to: exponent) parent: self! !

!FreeAbelianMonoid methodsFor: 'enumerating' stamp: 'len 2/21/2017 18:57:11'!
allMonomialsOfDegree: anInteger
	| answer |
	answer _ Set new.
	anInteger partitionsDo: [:partition|
		partition size <= self rank
			ifTrue:
				[(1 to: self rank) combinations: partition size atATimeDo: [:variables|
					partition permutationsDo: [:exponents|
						| monomial |
						monomial _ self identity.
						variables with: exponents do: [:i :r| monomial _ monomial * (self x: i to: r)].
						answer add: monomial]]]].
	^ answer asArray sort reverse! !

!FreeAbelianMonoid methodsFor: 'enumerating' stamp: 'len 5/13/2019 11:59:18'!
do: aBlock
	NN ^ self rank do: [:each| aBlock value: self !! (each asArray collect: [:x| x - 1])]! !

!FreeAbelianMonoid methodsFor: 'random' stamp: 'len 5/13/2019 11:59:34'!
atRandom: aRandom bits: bitSize
	^ self !! ((NN ^ self rank atRandom: aRandom bits: bitSize) asArray collect: [:x| x - 1])! !

!FreeAbelianMonoid methodsFor: 'testing' stamp: 'len 6/30/2016 00:12'!
includes: aMonomial
	^ (aMonomial isKindOf: Monomial) and: [aMonomial lastIndeterminate <= rank]! !

!FreeAbelianMonoid methodsFor: 'testing' stamp: 'len 6/30/2016 00:36'!
isCommutative
	^ true! !

!FreeAbelianMonoid methodsFor: 'private' stamp: 'len 1/28/2017 12:07:17'!
ordering: aMonomialOrdering
	ordering _ aMonomialOrdering isSymbol
		ifTrue: [MonomialOrdering perform: (aMonomialOrdering,':') asSymbol with: (1 to: self rank)]
		ifFalse: [aMonomialOrdering]! !

!FreeAbelianMonoid methodsFor: 'private' stamp: 'len 6/28/2016 23:37'!
rank: anInteger
	rank _ anInteger! !

!FreeAbelianMonoid class methodsFor: 'examples' stamp: 'len 5/22/2018 22:14:02'!
example1
	"The free abelian monoid in 3 indeterminates:"
	^ FreeAbelianMonoid new: 3! !

!FreeAbelianMonoid class methodsFor: 'examples' stamp: 'len 5/22/2018 22:16:05'!
example2
	"The free abelian monoid in 3 indeterminates with lexicographic monomial ordering:"
	^ FreeAbelianMonoid new: 3 ordering: #lex! !

!FreeAbelianMonoid class methodsFor: 'instance creation' stamp: 'len 5/23/2019 17:07:28'!
new: anIntegerOrCollection
	^ self new: anIntegerOrCollection ordering: #grevlex! !

!FreeAbelianMonoid class methodsFor: 'instance creation' stamp: 'len 5/23/2019 17:08:49'!
new: anIntegerOrCollection ordering: aMonomialOrdering
	^ (anIntegerOrCollection isInteger
		ifTrue: [self new rank: anIntegerOrCollection] 
		ifFalse: [self new rank: anIntegerOrCollection size; names: anIntegerOrCollection asArray]) ordering: aMonomialOrdering! !

!FreeMonoid methodsFor: 'accessing' stamp: 'len 5/13/2019 11:05:39'!
generators
	^ self propertyAt: #generators ifAbsentPut: ((1 to: self rank) collect: [:i| (Word x: i) parent: self])! !

!FreeMonoid methodsFor: 'accessing' stamp: 'len 5/13/2019 11:04:05'!
identity
	^ self propertyAt: #identity ifAbsentPut: [Word empty parent: self]! !

!FreeMonoid methodsFor: 'accessing' stamp: 'len 5/14/2019 05:42:05'!
names
	"Answer the indeterminate names to use when printing words."
	^ self propertyAt: #names ifAbsent: [self rank = 1 ifTrue: [#(x)]]! !

!FreeMonoid methodsFor: 'accessing' stamp: 'len 5/13/2019 12:59:52'!
names: anArray
	"Set indeterminate names to use when printing words."
	self propertyAt: #names put: anArray! !

!FreeMonoid methodsFor: 'accessing' stamp: 'len 5/10/2019 18:31:21'!
rank
	^ self propertyAt: #rank! !

!FreeMonoid methodsFor: 'accessing' stamp: 'len 2/26/2017 09:29:34'!
size
	^ self rank > 0 ifTrue: [Aleph new] ifFalse: [1]! !

!FreeMonoid methodsFor: 'elements' stamp: 'len 5/10/2019 17:15:50'!
x: anInteger to: anotherInteger
	^ (Word x: anInteger to: anotherInteger) parent: self! !

!FreeMonoid methodsFor: 'random' stamp: 'len 5/10/2019 18:32:23'!
atRandom: aRandom bits: bitSize
	| answer n |
	answer _ self identity.
	n _ self rank.
	bitSize // n highBit
		timesRepeat:
			[((n + 1) atRandom: aRandom) = 1
				ifFalse: [answer _ (self x: (self rank atRandom: aRandom)) * answer]].
	^ answer! !

!FreeMonoid methodsFor: 'testing' stamp: 'len 5/10/2019 18:32:59'!
contains: aWord
	aWord do: [:i :exp| (self rank <= i and: [exp >= 0]) ifFalse: [^ false]].
	^ true! !

!FreeMonoid methodsFor: 'testing' stamp: 'len 5/10/2019 15:17:39'!
includes: aWord
	^ (aWord isKindOf: Word) and: [aWord parent = self]! !

!FreeMonoid methodsFor: 'testing' stamp: 'len 5/10/2019 15:15:33'!
isCommutative
	^ self rank <= 1! !

!FreeMonoid methodsFor: 'private' stamp: 'len 5/10/2019 18:31:10'!
rank: anInteger
	self propertyAt: #rank put: anInteger! !

!FreeMonoid class methodsFor: 'instance creation' stamp: 'len 5/23/2019 17:06:53'!
new: anIntegerOrCollection
	^ anIntegerOrCollection isInteger
		ifTrue: [self new rank: anIntegerOrCollection] 
		ifFalse: [self new rank: anIntegerOrCollection size; names: anIntegerOrCollection asArray]! !

!Group methodsFor: 'accessing' stamp: 'len 12/28/2016 11:27:45'!
exponent
	"Answer the exponent of the receiver, i.e. the maximum order of an element."
	^ self propertyAt: #exponent ifAbsentPut: [self computeExponent]! !

!Group methodsFor: 'accessing' stamp: 'len 12/28/2016 11:28:19'!
generators
	self propertyAt: #generators ifPresent: [:aCollection| ^ aCollection].
	^ self propertyAt: #generators put: (self computeGenerators ifNil: [^ nil])! !

!Group methodsFor: 'accessing' stamp: 'len 5/5/2019 18:04:03'!
identity
	"Answer the identity element of the receiver."
	^ self propertyAt: #identity ifAbsent: [self do: [:each| ^ self propertyAt: #identity put: each  each inverse]]! !

!Group methodsFor: 'accessing' stamp: 'len 5/5/2019 18:04:14'!
inverseMap
	^ self propertyAt: #inverseMap ifAbsentPut: [(self to: self evaluating: [:each| each inverse]) name: 'inv']! !

!Group methodsFor: 'accessing' stamp: 'len 10/1/2018 04:38:56'!
null
	"Answer the trivial subgroup."
	^ self ambient span: #()! !

!Group methodsFor: 'accessing' stamp: 'len 1/6/2016 05:49'!
order
	^ self size! !

!Group methodsFor: 'converting' stamp: 'len 5/28/2019 09:15:13'!
asAbelianGroup
	| generators elementaryDivisors G H |
	self isTrivial ifTrue: [^ #()].
	generators _ self generators.
	elementaryDivisors _ OrderedCollection new.
	G _ self.
	H _ G commutator.
	G size factors asSet do: [:p| | ranks powers K r |
		ranks _ OrderedCollection new.
		[powers _ OrderedCollection new.
		generators do: [:g| | x |
			x _ g^p.
			(H contains: x) ifFalse: [powers add: x]].
		K _ powers isEmpty ifTrue: [H] ifFalse: [H ambient span: H generators, powers].
		r _ G size // K size.
		G _ K.
		generators _ powers.
		r = 1] whileFalse: [ranks add: (r factors occurrencesOf: p)].
		ranks isEmpty ifFalse:
			[powers _ (Array new: ranks first) atAllPut: 1.
			ranks do: [:i| 1 to: i do: [:j| powers at: j put: (powers at: j) * p]].
			elementaryDivisors addAll: powers]].
	^ AbelianGroup orders: elementaryDivisors sorted! !

!Group methodsFor: 'enumerating' stamp: 'len 5/1/2016 23:44'!
collect: aBlock
	"Answer the subgroup resulting of mapping the elements of the receiver by aBlock."
	| elements |
	elements _ Set new.
	self do: [:each| elements add: (aBlock value: each)].
	^ self copyEmpty elements: elements! !

!Group methodsFor: 'enumerating' stamp: 'len 5/5/2019 18:40:47'!
do: aBlock
	| generators current previous |
	self propertyAt: #elements ifPresent: [:aCollection| aCollection do: aBlock. ^ self].
	"iterate all elements from the generators:"
	self flag: #fix. "this is too expensive"
	generators _ self generators.
	current _ generators asSet.
	current do: aBlock.
	current add: self identity ifAbsent: [aBlock value: self identity].
	[previous _ current.
	current _ current copy.
	previous do: [:x|
		generators do: [:y|
			| xy |
			xy _ x  y.
			current add: xy ifAbsent: [aBlock value: xy]]].
	previous size < current size] whileTrue.
	self propertyAt: #elements put: current! !

!Group methodsFor: 'enumerating' stamp: 'len 5/1/2016 23:45'!
select: aBlock
	"Answer the subgroup resulting of the selection by aBlock."
	| elements |
	elements _ Set new.
	self do: [:each| (aBlock value: each) ifTrue: [elements add: each]].
	^ self copyEmpty elements: elements! !

!Group methodsFor: 'graphs' stamp: 'len 5/5/2019 18:37:46'!
cayleyGraph: generators
	"Answer the 'colored' Cayley graph of the receiver for the given set of generators.
	The set of generators is usually assumed to be symmetric (contains all inverses too) and to not contain the identity."
	| G |
	self isFinite ifFalse: [^ self error: 'not a finite group'].
	G _ Digraph unorderedLabeled.
	self do: [:g|
		generators do: [:x|
			G addEdgeFrom: g to: g  x label: x]].
	^ G! !

!Group methodsFor: 'graphs' stamp: 'len 4/29/2016 07:14'!
cayleyGraphMorph
	^ self cayleyGraphMorph: self generators! !

!Group methodsFor: 'graphs' stamp: 'len 12/19/2016 12:23:54'!
cayleyGraphMorph: generators
	"Answer the colored Cayley graph of the receiver for the given set of generators.
	The set of generators is usually assumed to be symmetric (contains all inverses too) and to not contain the identity."
	| G answer colors |
	G _ self cayleyGraph: generators.
	answer _ G asMorph.
	colors _ AutomaticPalette new.
	answer nodesDo: [:each| each color: Color transparent; radius: 0].
	generators do: [:each| colors at: each].
	generators do: [:each| (answer nodeAt: each) color: (colors at: each); radius: 10].
	answer edgesAndLabelsDo: [:each :label| each hideLabel; color: (colors at: label)].
	(answer nodeAt: self identity) color: Color white; shape: #square; radius: 10.
	^ answer! !

!Group methodsFor: 'graphs' stamp: 'len 5/5/2019 18:39:32'!
cycleGraph
	| G elements id |
	self isFinite ifFalse: [^ self error: 'not a finite group'].
	G _ Graph unordered.
	id _ self identity.
	elements _ self elements asSet copyWithout: id.
	[elements isEmpty]
		whileFalse:
			[| e g |
			e _ elements anyOne.
			g _ id.
			[| g2 |
			g2 _ g  e.
			(G hasEdgeFrom: g to: g2) ifFalse: [G addEdgeFrom: g to: g2].
			(g _ g2) = id] whileFalse: [elements remove: g ifAbsent: []]].
	^ G! !

!Group methodsFor: 'graphs' stamp: 'len 5/5/2019 18:39:53'!
cycleGraph2
	| G elements id |
	self flag: #fix. "incorrect, test dihedral 4, 5.."
	self isFinite ifFalse: [^ self error: 'not a finite group'].
	G _ Graph unordered.
	id _ self identity.
	elements _ self elements asSet copyWithout: id.
	[elements isEmpty]
		whileFalse:
			[| e g |
			e _ elements remove: elements anyOne.
			g _ id.
			[| g2 |
			g2 _ g  e.
			G addEdgeFrom: g to: g2.
			(g _ g2) = id] whileFalse].
	^ G! !

!Group methodsFor: 'graphs' stamp: 'len 7/29/2016 06:30'!
cycleGraphMorph
	| answer |
	answer _ self cycleGraph asMorph.
"	answer hideLabels."
	(answer nodeAt: self identity) color: Color white; shape: #square.
	^ answer! !

!Group methodsFor: 'morphisms' stamp: 'len 5/6/2019 05:00:35'!
adjointAction
	^ GroupAction from: (self, self) to: self evaluatingWithArguments: [:g :x| g inverse  x  g]! !

!Group methodsFor: 'morphisms' stamp: 'len 5/6/2019 05:00:47'!
conjugation
	^ GroupAction from: (self, self) to: self evaluatingWithArguments: [:g :x| g  x  g inverse]! !

!Group methodsFor: 'morphisms' stamp: 'len 5/13/2019 15:50:17'!
innerAutomorphisms
	^ Group new elements: (self elements collect: [:a| ConjugationMap by: a in: self])! !

!Group methodsFor: 'morphisms' stamp: 'len 1/6/2016 05:51'!
outerAutomorphisms
	^ self automorphisms / self innerAutomorphisms! !

!Group methodsFor: 'morphisms' stamp: 'len 5/11/2019 02:38:18'!
to: aCodomain
	(self isTrivial and: [aCodomain isGroup])
		ifTrue: [^ self to: aCodomain evaluating: [:x| aCodomain identity]].
	^ super to: aCodomain! !

!Group methodsFor: 'morphisms' stamp: 'len 1/11/2018 18:20:36'!
to: aGroup evaluating: aBlock
	aGroup isGroup ifFalse: [^ super to: aGroup evaluating: aBlock].
	^ GroupMap from: self to: aGroup evaluating: aBlock! !

!Group methodsFor: 'morphisms' stamp: 'len 5/25/2019 08:25:10'!
to: aGroup mapping: aBlock
	aGroup isGroup ifFalse: [^ super to: aGroup mapping: aBlock].
	^ GroupMap from: self to: aGroup mapping: aBlock! !

!Group methodsFor: 'operations' stamp: 'len 5/9/2019 11:24:34'!
* anElementOrGroup
	(anElementOrGroup isKindOf: Group) ifTrue: [^ self freeProduct: anElementOrGroup].
	^ Coset representative: anElementOrGroup relations: self! !

!Group methodsFor: 'operations' stamp: 'len 10/10/2018 06:29:35'!
/ aSubgroup
	"Answer the quotient group (or factor group) of the receiver by the argument.
	Assume aSubgroup is normal in the receiver, otherwise this is just the set of right cosets."
	^ QuotientGroup on: self by: aSubgroup

	"Answer the right factor group (or right quotient group) of the receiver by the argument.
	If aSubgroup is not normal in the receiver, this is just the set of left cosets."
"	^ self collect: [:each| LeftCoset on: aSubgroup representative: each]"! !

!Group methodsFor: 'operations' stamp: 'len 5/9/2019 11:24:55'!
// aSubgroup
	"Answer the set of right cosets of the receiver by aSubgroup."
	| answer |
	answer _ Set new.
	self do: [:each| answer add: (Coset representative: each relations: aSubgroup)].
	^ answer! !

!Group methodsFor: 'operations' stamp: 'len 5/10/2019 04:27:41'!
/\ aGroup
	"Answer the intersection of the receiver and the argument."
	self ambient = aGroup ambient ifFalse: [^ DomainError signal: 'groups in different ambients'].
	^ self select: [:each| aGroup includes: each]! !

!Group methodsFor: 'operations' stamp: 'len 1/22/2018 20:32:03'!
 aGroupOrAction
	(aGroupOrAction isKindOf: GroupAction)
		ifTrue: [^ SemidirectProductGroup left: self right: aGroupOrAction group action: aGroupOrAction].
	^ DirectProductGroup components: {self. aGroupOrAction}! !

!Group methodsFor: 'operations' stamp: 'len 2/20/2017 22:13:29'!
 aGroup
	"Answer the direct sum of the receiver and the argument."
	^ self  aGroup "finite direct sums of groups are the same as direct products"! !

!Group methodsFor: 'operations' stamp: 'len 12/28/2016 12:19:53'!
abelianization
	"Answer the receiver 'made abelian'."
	^ (self / self commutator)
		propertyAt: #isCommutative put: true;
		yourself! !

!Group methodsFor: 'operations' stamp: 'len 5/1/2016 22:58'!
center
	^ self centralizerOf: self! !

!Group methodsFor: 'operations' stamp: 'len 5/5/2019 18:38:13'!
centralizerOf: aCollection
	^ self select: [:x| aCollection allSatisfy: [:y| x  y = (y  x)]]! !

!Group methodsFor: 'operations' stamp: 'len 3/6/2017 16:33:57'!
commutator
	"Answer the commutator group [G,G] of the receiver G, also called the derived group and noted G'.
	This is the smallest normal subgroup of G such that the quotient G / [G,G] is commutative."
	^ self commutator: self! !

!Group methodsFor: 'operations' stamp: 'len 5/5/2019 18:02:05'!
commutator2: aGroup
	"Answer the commutator group [G,H] of the receiver G with the argument H."
	| generators |
	generators _ Set new.
	self generators do: [:x|
		| xInv |
		xInv _ x inverse.
		aGroup generators do: [:y| generators add: x  y  xInv  y inverse]].
	^ (self copyEmpty generators: self generators, aGroup generators) normalClosureOf: generators! !

!Group methodsFor: 'operations' stamp: 'len 5/5/2019 18:03:18'!
commutator: aSubgroup
	"Answer the commutator group [G,H] of the receiver G with the argument H."
	| elements |
	elements _ Set new.
	self do: [:x|
		| xInv |
		xInv _ x inverse.
		aSubgroup do: [:y| elements add: x  y  xInv  y inverse]].
	^ self copyEmpty elements: elements! !

!Group methodsFor: 'operations' stamp: 'len 7/27/2016 07:17'!
conjugacyClassOf: anElement
	^ self conjugation orbitOf: anElement! !

!Group methodsFor: 'operations' stamp: 'len 7/27/2016 07:11'!
conjugacyClasses
	^ self conjugation orbits! !

!Group methodsFor: 'operations' stamp: 'len 5/26/2019 08:42:36'!
groupAlgebra
	^ self groupAlgebraOver: ZZ! !

!Group methodsFor: 'operations' stamp: 'len 5/26/2019 08:45:21'!
groupAlgebraOver: aRing
	^ GroupAlgebra on: self over: aRing! !

!Group methodsFor: 'operations' stamp: 'len 5/1/2016 22:59'!
hypoabelianization
	^ self / self perfectCore! !

!Group methodsFor: 'operations' stamp: 'len 12/9/2016 22:44:53'!
index
	"Answer the index of the receiver in its ambient group."
	^ self ambient indexOf: self! !

!Group methodsFor: 'operations' stamp: 'len 2/16/2016 05:21'!
indexOf: aSubgroup
	^ (self / aSubgroup) size! !

!Group methodsFor: 'operations' stamp: 'len 5/25/2019 04:45:26'!
normalClosureOf: aSubset
	"From Handbook of Computational Group Theory (Holt) 74p.
	The normal closure of A <= G in G (denoted A^G) is the smallest normal subgroup of G that contains A, i.e. the intersection of all normal subgroups that contain A. Equivalently, it is the set A^G := {g^-1 * a * g | g in G, a in A}."
	| X Y Z random N |
	self flag: #fix. "test and fix, replace >>normalizerOf:?"
	X _ self generators.
	Y _ aSubset.
	Z _ Y.
	random _ Random new.
	N _ self copyEmpty generators: Z.
	["test whether <Z> = <Y>^<X>"
	X allSatisfy: [:g| Z allSatisfy: [:h| N includes: g  h  g inverse]]]
		whileFalse:
			["add some new random conjugates to Z"
			10 timesRepeat:
				[| h g hg |
				g _ self atRandom: random.
				h _ N atRandom: random.
				hg _ g  h  g inverse. "h^g"
				(N includes: hg) ifFalse: [Z add: hg. N _ self copyEmpty generators: Z]]].
	^ N! !

!Group methodsFor: 'operations' stamp: 'len 5/5/2019 18:06:49'!
normalizerOf: aCollection
	"Answer the normal closure of aCollection in the receiver, i.e. the smallest normal subgroup that contains aCollection."
	^ self select: [:x| | xInv | xInv _ x inverse. (aCollection collect: [:y| x  y  xInv]) = aCollection]! !

!Group methodsFor: 'operations' stamp: 'len 5/8/2019 14:35:27'!
opposite
	^ self propertyAt: #opposite ifAbsentPut: [OppositeGroup opposite: self]! !

!Group methodsFor: 'operations' stamp: 'len 9/24/2018 22:31:55'!
orderOf: anElement
	"Answer the order of the argument in the receiver, i.e. the minimum e such that g^e = 1.
	COHEN Algorithm 1.4.3 (Order of an Element)."
	| h factors id e g1 |
	h _ self size.
	factors _ self propertyAt: #orderFactorization ifAbsentPut: [h factors].
	e _ h.
	id _ self identity.
	factors asSet do: [:p|
		e _ e / (p ^ (factors occurrencesOf: p)).
		g1 _ self raise: anElement to: e.
		[g1 = id] whileFalse: [g1 _ self raise: g1 to: p. e _ e*p]].
	^ e! !

!Group methodsFor: 'operations' stamp: 'len 7/27/2016 02:01'!
orderOf: anElement boundedBy: n
	"Alternative to orderOf:, from Handbook of Computational Group Theory (Holt), 73p. Runs in time at most O(log(n)^3)."
	| id |
	n = 1 ifTrue: [^ 1].
	id _ self identity.
	n factors asSet do: [:p| (self raise: anElement to: n/p) = id ifTrue: [^ self orderOf: anElement boundedBy: n/p]].
	^ n! !

!Group methodsFor: 'operations' stamp: 'len 5/1/2016 22:59'!
perfectCore
	| answer |
	self derivedSeriesDo: [:each| answer _ each].
	^ answer! !

!Group methodsFor: 'operations' stamp: 'len 5/1/2016 23:45'!
span: aCollection
	"Answer the subgroup generated by the argument."
	^ self copyEmpty generators: aCollection! !

!Group methodsFor: 'random' stamp: 'len 5/25/2019 04:43:18'!
atRandom: aRandom
	self propertyAt: #elements ifPresent: [:aCollection| ^ aCollection atRandom: aRandom].
	^ (self propertyAt: #randomGenerator ifAbsentPut: [ProductReplacementRandomGenerator new generators: self generators]) atRandom: aRandom! !

!Group methodsFor: 'random' stamp: 'len 5/25/2019 04:41:49'!
atRandom: aRandom bits: bitSize
	self propertyAt: #elements ifPresent: [:aCollection| ^ aCollection atRandom: aRandom bits: bitSize].
	^ self atRandom: aRandom "assume it's finite"! !

!Group methodsFor: 'series' stamp: 'len 3/6/2017 16:38:33'!
derivedSeriesDo: aBlock
	"For finite groups the derived series terminates in a perfect group (called the perfect core), which may or may not be trivial."
	| G H |
	G _ self.
	[H _ G commutator.
	aBlock value: H.
	G order = H order ifTrue: [^ self].
	G _ H] repeat! !

!Group methodsFor: 'series' stamp: 'len 3/6/2017 16:38:17'!
lowerCentralSeriesDo: aBlock
	| G H |
	G _ self.
	[H _ G commutator: self.
	aBlock value: H.
	G order = H order ifTrue: [^ self].
	G _ H] repeat! !

!Group methodsFor: 'series' stamp: 'len 5/5/2019 18:07:54'!
upperCentralSeriesDo: aBlock
	| Z |
	Z _ self null.
	[Z _ self select: [:x| self allSatisfy: [:y| Z includes: x  y  x inverse]].
	aBlock value: Z.
	Z order = self order] whileFalse! !

!Group methodsFor: 'series' stamp: 'len 10/1/2018 04:38:20'!
upperCentralSeriesQuotientsDo: aBlock
	| Z1 |
	Z1 _ self null.
	self upperCentralSeriesDo: [:Z| aBlock value: Z / Z1. Z1 _ Z]! !

!Group methodsFor: 'testing' stamp: 'len 5/28/2019 04:23:16'!
isCommutative
	(self generators ifNil: [self]) do: [:x|
		(self generators ifNil: [self]) do: [:y|
			x  y = (y  x) ifFalse: [^ false]]].
	^ true! !

!Group methodsFor: 'testing' stamp: 'len 5/28/2019 04:51:53'!
isCyclic
	"Answer true if the receiver is generated by one element."
	self isTrivial ifTrue: [^ true].
	self generators ifNotNil: [:aCollection| aCollection size <= 1 ifTrue: [^ true]].
	self do: [:each| (self span: {each}) size = self size ifTrue: [^ true]].
	^ false! !

!Group methodsFor: 'testing' stamp: 'len 11/7/2015 22:01'!
isGroup
	^ true! !

!Group methodsFor: 'testing' stamp: 'len 5/2/2016 02:32'!
isHypoabelian
	^ self perfectCore isTrivial! !

!Group methodsFor: 'testing' stamp: 'len 11/28/2015 09:09'!
isInitial
	^ self isTrivial! !

!Group methodsFor: 'testing' stamp: 'len 5/2/2016 02:32'!
isNilpotent
	| termination |
	self lowerCentralSeriesDo: [:each| termination _ each].
	^ termination isTrivial! !

!Group methodsFor: 'testing' stamp: 'len 12/10/2016 12:52:18'!
isNormal
	"Answer true if the receiver is normal in its ambient overgroup."
	^ self isNormalIn: self ambient! !

!Group methodsFor: 'testing' stamp: 'len 5/5/2019 18:05:33'!
isNormalIn: anOvergroup
	"Answer true if the receiver is normal as subgroup of aGroup, i.e. if it is a subgroup invariant under conjugation."
	| X Y |
	X _ self generators ifNil: [self].
	Y _ anOvergroup generators ifNil: [anOvergroup].
	X do: [:x|
		Y do: [:y|
			| yInv |
			yInv _ y inverse.
			(self includes: y  x  yInv)
				ifFalse: [^ false]]].
	^ true! !

!Group methodsFor: 'testing' stamp: 'len 7/27/2016 07:53'!
isPerfect
	^ self isTrivial not and: [self = self commutator]! !

!Group methodsFor: 'testing' stamp: 'len 3/6/2017 16:37:20'!
isSolvable
	^ self perfectCore isTrivial

"
alternative implementations:
	| G G' |
	G _ self.
	[G isCyclic ifTrue: [^ true].
	G isTrivial ifTrue: [^ false].
	G' _ G commutator.
	G' order = G order ifTrue: [^ false].
	G _ G'] repeat

or:
	| G G' |
	G _ self.
	[G isTrivial ifTrue: [^ true].
	G' _ G commutator.
	G' order = G order ifTrue: [^ false].
	G _ G'] repeat"
! !

!Group methodsFor: 'testing' stamp: 'len 4/22/2016 14:04'!
isTerminal
	^ self isTrivial! !

!Group methodsFor: 'private' stamp: 'len 1/28/2018 08:23:20'!
computeExponent
	| answer |
	answer _ 1.
	self do: [:each| answer _ answer lcm: (self orderOf: each)].
	^ answer! !

!Group methodsFor: 'private' stamp: 'len 5/5/2019 18:39:00'!
computeGenerators
	"The receiver is a finite group represented explicitly as a set of its elements. This method computes a set of generators."
	| n generators elements |
	(self hasProperty: #elements) ifFalse: [^ nil].
	n _ self size.
	n isInfinite ifTrue: [^ nil].
	generators _ OrderedCollection new.
	elements _ Set with: self identity.
	self elements do: [:g|
		elements size = n ifTrue: [^ generators].
		(elements includes: g)
			ifFalse:
				[| previous |
				generators add: g.
				[(previous _ elements copy) do: [:x|
					generators do: [:y|
						elements add: x  y]].
				previous size = elements size] whileFalse]].
	^ generators! !

!Group methodsFor: 'private' stamp: 'len 5/5/2019 17:57:19'!
raise: anElement to: anInteger
	anInteger = 1 ifTrue: [^ anElement].
	anInteger = 0 ifTrue: [^ self identity].
	anInteger < 0 ifTrue: [^ self raise: anElement inverse to: anInteger negated].
	^ (self raise: anElement  anElement to: anInteger // 2)  (self raise: anElement to: anInteger \\ 2)! !

!Group methodsFor: 'private' stamp: 'len 5/1/2016 23:40'!
species
	^ Group! !

!Group class methodsFor: 'examples' stamp: 'len 12/14/2016 11:10:52'!
quaternions
	"Answer the quaternionic group."
	^ Group new generators: {Quaternion i. Quaternion j}! !

!Group class methodsFor: 'examples' stamp: 'len 5/22/2018 21:38:27'!
schnorr: q
	"Answer a Schnorr group of the given prime order q.
	This is a subgroup of the  group of (units of) integers modulo p
	for some prime p (with order p-1)."
	| p r h g |
	r _ 1.
	[(p _ q*r + 1) isPrime] whileFalse: [r _ r + 1].
	[h _ (1 to: p) atRandom.
	(g _ h raisedTo: r modulo: p) = 1] whileTrue.
	^ Group new generator: g % p! !

!AbelianGroup methodsFor: 'accessing' stamp: 'len 5/27/2019 10:11:58'!
base
	| answer |
	self isFree ifTrue: [^ self].
	answer _ FreeAbelianGroup new: self generators size.
	self names ifNotNil: [:aCollection| answer names: aCollection].
	^ answer! !

!AbelianGroup methodsFor: 'accessing' stamp: 'len 5/28/2019 09:55:41'!
basis
	"Answer a list of generators whose orders are the invariant factors (the Smith abelian invariants) of the receiver.
	See >>invariants."
	self notYetImplemented! !

!AbelianGroup methodsFor: 'accessing' stamp: 'len 5/14/2019 05:32:14'!
exponent
	"Answer the exponent of the receiver, i.e. the maximum order of an element."
	^ self orders inject: 1 into: [:answer :each| answer lcm: each]! !

!AbelianGroup methodsFor: 'accessing' stamp: 'len 5/14/2019 03:39:53'!
generators
	^ self propertyAt: #generators ifAbsentPut: [(1 to: self orders size) collect: [:i| self x: i to: 1]]! !

!AbelianGroup methodsFor: 'accessing' stamp: 'len 5/14/2019 03:34:32'!
identity
	^ self propertyAt: #identity ifAbsentPut: [self exponents: (self orders collect: [:each| 0])]! !

!AbelianGroup methodsFor: 'accessing' stamp: 'len 5/29/2019 12:34:53'!
invariants
	"Answer the Smith normal form abelian invariants of the reciever, each dividing the next.
	Each infinite cylic factor is represented by 0."
	^ self propertyAt: #invariants ifAbsentPut:
		[(self orders select: [:each| each isZero]), (self relationMatrix isEmpty ifTrue: [#()] ifFalse: [self relationMatrix elementaryDivisors select: [:each| each ~= 1]])]! !

!AbelianGroup methodsFor: 'accessing' stamp: 'len 5/14/2019 05:40:39'!
names
	"Answer the indeterminate names to use when printing words."
	^ self propertyAt: #names ifAbsent: [self generators size = 1 ifTrue: [#(x)]]! !

!AbelianGroup methodsFor: 'accessing' stamp: 'len 5/15/2019 03:18:45'!
orders
	"Answer the orders of the generators, with 0 to denote infinite order."
	^ self propertyAt: #orders! !

!AbelianGroup methodsFor: 'accessing' stamp: 'len 5/29/2019 12:34:30'!
primaryBasis
	"Answer a list of generators whose orders are the primary invariants of the receiver.
	See >>primaryInvariants."
	self notYetImplemented! !

!AbelianGroup methodsFor: 'accessing' stamp: 'len 5/29/2019 12:35:51'!
primaryInvariants
	"Answer the primary abelian invariants of the receiver, consisting of prime powers q(i) such that the torsion subgroup of the receiver is isomorphic to the direct sum of all the Z/q(i)Z. Each infinite cyclic factor is represented by 0."
	| answer |
	self propertyAt: #primaryInvariants ifPresent: [:aBag| ^ aBag].
	answer _ Bag new.
	"this can be improved because each invariant divides the next:"
	self invariants do: [:each|
		each isZero
			ifTrue: [answer add: each]
			ifFalse: [each factors withOccurrencesDo: [:p :k| answer add: p^k]]].
	^ self propertyAt: #primaryInvariants put: answer! !

!AbelianGroup methodsFor: 'accessing' stamp: 'len 5/14/2019 03:37:18'!
rank
	"Answer the torsion-free rank of the receiver."
	^ self orders count: [:each| each = 0]! !

!AbelianGroup methodsFor: 'accessing' stamp: 'len 5/28/2019 03:37:09'!
relationMatrix
	^ ZZ diagonalMatrix: (self orders select: [:each| each isZero not])! !

!AbelianGroup methodsFor: 'accessing' stamp: 'len 5/14/2019 04:22:38'!
relators
	| answer |
	answer _ OrderedCollection new.
	self orders withIndexDo: [:each :i| each ~= 0 ifTrue: [answer add: (self base x: i to: each)]].
	^ answer! !

!AbelianGroup methodsFor: 'accessing' stamp: 'len 5/15/2019 02:26:34'!
size
	| answer |
	self orders isEmpty ifTrue: [^ 1].
	(answer _ self orders product) = 0 ifTrue: [^ Aleph new].
	^ answer! !

!AbelianGroup methodsFor: 'accessing' stamp: 'len 5/15/2019 03:16:01'!
torsion
	"Answer the torsion subgroup, i.e. the subgroup of elements of finite order."
	| answer finiteOrderIndices |
	finiteOrderIndices _ (1 to: self orders size) select: [:each| (self orders at: each) ~= 0].
	^ (answer _ self species orders: (finiteOrderIndices collect: [:each| self orders at: each]))
		addMap: ((answer into: self mapping: [:i| self x: (finiteOrderIndices at: i)]) name: 'i');
		yourself! !

!AbelianGroup methodsFor: 'accessing' stamp: 'len 5/27/2019 19:03:59'!
torsionFree
	"Answer the torsion-free subgroup, i.e. the subgroup of elements of infinite order (plus the identity)."
	| answer infiniteOrderIndices |
	infiniteOrderIndices _ (1 to: self orders size) select: [:each| (self orders at: each) = 0].
	^ (answer _ FreeAbelianGroup new: infiniteOrderIndices size)
		addMap: ((answer into: self mapping: [:i| self x: (infiniteOrderIndices at: i)]) name: 'i');
		yourself! !

!AbelianGroup methodsFor: 'comparing' stamp: 'len 5/28/2019 09:10:02'!
~ aGroup
	"Answer true if the receiver is isomorphic to the argument."
	(aGroup isKindOf: AbelianGroup) ifTrue: [^ self invariants = aGroup invariants].
	^ super ~ aGroup! !

!AbelianGroup methodsFor: 'converting' stamp: 'len 5/29/2019 03:49:51'!
asFPGroup
	| F relators answer |
	F _ FreeGroup new: self orders size.
	relators _ OrderedCollection new.
	self orders withIndexDo: [:k :i| k ~= 0 ifTrue: [relators add: (F x: i)^k]].
	1 to: F rank do: [:i| 1 to: F rank do: [:j| i ~= j ifTrue: [relators add: ((F x: i) commutator: (F x: j))]]].
	^ (answer _ F / relators)
		addMap: (self to: answer mapping: [:i| answer x: i]);
		addMap: (answer to: self mapping: [:i| self x: i]);
		yourself! !

!AbelianGroup methodsFor: 'converting' stamp: 'len 5/28/2019 09:10:12'!
asPermutationGroup
	| answer |
	self isTorsion ifFalse: [self error: 'infinite abelian groups are not isomorphic to finite permutation groups'].
	answer _ SymmetricGroup new: 0.
	self invariants do: [:each| answer _ answer  (PermutationGroup cyclic: each)].
	"TODO: add isomorphisms"
	^ answer! !

!AbelianGroup methodsFor: 'elements' stamp: 'len 5/14/2019 03:32:26'!
!! anObject
	(anObject isSequenceable and: [anObject size = self orders size])
		ifTrue: [^ self exponents: anObject].
	^ super !! anObject! !

!AbelianGroup methodsFor: 'elements' stamp: 'len 5/14/2019 03:33:32'!
exponents: anArray
	anArray size = self generators size ifFalse: [self error: 'exponents size doesn''t match rank'].
	^ (Monomial exponents: (self orders with: anArray collect: [:m :each| m=0 ifTrue: [each] ifFalse: [each \\ m]])) parent: self! !

!AbelianGroup methodsFor: 'elements' stamp: 'len 5/25/2019 08:23:03'!
wordOf: aMonomial
	"Answer the argument expressed as a word on the generators."
	^ aMonomial! !

!AbelianGroup methodsFor: 'elements' stamp: 'len 5/14/2019 03:41:44'!
x: anInteger to: exponent
	| m |
	m _ self orders at: anInteger.
	^ (Monomial new: self orders size x: anInteger to: (m = 0 ifTrue: [exponent] ifFalse: [exponent \\ m])) parent: self! !

!AbelianGroup methodsFor: 'morphisms' stamp: 'len 5/26/2019 12:18:23'!
=> anAbelianGroup
	(anAbelianGroup isKindOf: AbelianGroup) ifFalse: [^ super => anAbelianGroup].
	^ AbelianGroupHomSet from: self to: anAbelianGroup! !

!AbelianGroup methodsFor: 'morphisms' stamp: 'len 5/24/2019 10:50:21'!
to: aGroup evaluating: aBlock
	aGroup isGroup ifFalse: [^ super to: aGroup evaluating: aBlock].
	^ self to: aGroup mapping: [:i| aBlock value: (self generators at: i)]! !

!AbelianGroup methodsFor: 'operations' stamp: 'len 4/21/2019 07:56:53'!
* anInteger
	^ self notYetImplemented! !

!AbelianGroup methodsFor: 'operations' stamp: 'len 4/21/2019 07:43:22'!
+ anAbelianGroup
	self ambient = anAbelianGroup ambient ifFalse: [DomainError signal].
	^ self notYetImplemented! !

!AbelianGroup methodsFor: 'operations' stamp: 'len 4/21/2019 04:58:00'!
/ aCollectionOrElement
	"Answer the quotient of the receiver by the given relations."
	self notYetImplemented! !

!AbelianGroup methodsFor: 'operations' stamp: 'len 5/10/2019 04:26:40'!
/\ anAbelianGroup
	self ambient = anAbelianGroup ambient ifFalse: [DomainError signal].
	^ self notYetImplemented! !

!AbelianGroup methodsFor: 'operations' stamp: 'len 5/26/2019 12:18:23'!
 aGroup
	"Answer the direct product (or direct sum) of the receiver and the argument."
	(aGroup isKindOf: AbelianGroup) ifTrue: [^ self  aGroup].
	^ super  aGroup! !

!AbelianGroup methodsFor: 'operations' stamp: 'len 5/27/2019 12:46:43'!
 anAbelianGroup
	"Answer the direct sum of the receiver and the argument as abelian groups."
	| n answer |
	n _ self orders size.
	^ (answer _ self species orders: self orders, anAbelianGroup orders)
		addCoprojections:
			{self into: answer mapping: [:i| answer x: i].
			anAbelianGroup into: answer mapping: [:i| answer x: i+n]};
		addProjections:
			{answer onto: self mapping: [:i| i <= n ifTrue: [self x: i] ifFalse: [self identity]].
			answer onto: anAbelianGroup mapping: [:i| i > n ifTrue: [anAbelianGroup x: i-n] ifFalse: [anAbelianGroup identity]]};
		yourself! !

!AbelianGroup methodsFor: 'operations' stamp: 'len 5/14/2019 20:48:55'!
 anAbelianGroup
	^ self notYetImplemented! !

!AbelianGroup methodsFor: 'operations' stamp: 'len 5/15/2019 03:32:23'!
centralizerOf: aCollection
	^ self! !

!AbelianGroup methodsFor: 'operations' stamp: 'len 5/15/2019 03:34:16'!
commutator
	"Answer the commutator group [G,G] of the receiver G, also called the derived group and noted G'.
	This is the smallest normal subgroup of G such that the quotient G / [G,G] is commutative.
	Since the receiver is abelian, this is the trivial group."
	^ self null! !

!AbelianGroup methodsFor: 'operations' stamp: 'len 5/28/2019 15:42:00'!
commutator: aSubgroup
	"Answer the commutator group [G,H] of the receiver G with the argument H.
	Since the receiver is commutative, this is the trivial group."
	^ self null! !

!AbelianGroup methodsFor: 'operations' stamp: 'len 5/15/2019 04:09:18'!
orderOf: aMonomial
	| answer |
	answer _ 1.
	self orders withIndexDo: [:n :i|
		| k |
		k _ aMonomial at: i.
		n = 0
			ifTrue: [(k ~= 0) ifTrue: [^ 0]]
			ifFalse: [answer _ answer lcm: n / (n gcd: k)]].
	^ answer! !

!AbelianGroup methodsFor: 'operations' stamp: 'len 4/21/2019 04:58:57'!
span: aCollection
	"Answer the subgroup spanned by the elements in aCollection."
	^ self notYetImplemented! !

!AbelianGroup methodsFor: 'testing' stamp: 'len 5/15/2019 00:05:21'!
includes: aMonomial
	^ (aMonomial isKindOf: Monomial) and: [aMonomial parent = self]! !

!AbelianGroup methodsFor: 'testing' stamp: 'len 5/14/2019 03:54:04'!
isCommutative
	^ true! !

!AbelianGroup methodsFor: 'testing' stamp: 'len 5/28/2019 09:10:17'!
isCyclic
	^ self invariants size <= 1! !

!AbelianGroup methodsFor: 'testing' stamp: 'len 5/15/2019 04:56:58'!
isElementaryAbelian
	"Answer true if the receiver is isomorphic to a direct sum of n copies of a cyclic group of prime order, i.e. isomorphic to (Z/pZ)^n for some prime p and natural number n."
	self notYetImplemented! !

!AbelianGroup methodsFor: 'testing' stamp: 'len 5/14/2019 03:43:24'!
isFree
	^ self orders allSatisfy: [:each| each = 0]! !

!AbelianGroup methodsFor: 'testing' stamp: 'len 5/15/2019 04:15:34'!
isMixed
	"An abelian group is mixed if it is nother a torsion group nor free."
	^ self isTorsion not and: [self isFree not]! !

!AbelianGroup methodsFor: 'testing' stamp: 'len 5/29/2019 04:12:17'!
isSimple
	"A group is 'simple' if the only normal subgroups are the trivial group and itself."
	^ self isTorsion and: [self isCyclic and: [self size isPrime]]! !

!AbelianGroup methodsFor: 'testing' stamp: 'len 5/14/2019 03:43:33'!
isTorsion
	^ self orders noneSatisfy: [:each| each = 0]! !

!AbelianGroup methodsFor: 'testing' stamp: 'len 5/14/2019 03:43:37'!
isTrivial
	^ self orders isEmpty! !

!AbelianGroup methodsFor: 'private' stamp: 'len 4/21/2019 04:43:16'!
names: anArray
	"Set indeterminate names to use when printing words."
	self propertyAt: #names put: anArray! !

!AbelianGroup methodsFor: 'private' stamp: 'len 5/14/2019 03:48:53'!
ordering
	^ self propertyAt: #ordering ifAbsentPut: [MonomialOrdering lex: self generators size]! !

!AbelianGroup methodsFor: 'private' stamp: 'len 5/14/2019 03:35:24'!
orders: anArray
	self propertyAt: #orders put: anArray! !

!AbelianGroup methodsFor: 'private' stamp: 'len 5/26/2019 12:18:23'!
species
	^ AbelianGroup! !

!AbelianGroup class methodsFor: 'instance creation' stamp: 'len 5/14/2019 03:36:10'!
orders: anArray
	^ self new orders: anArray! !

!FreeAbelianGroup methodsFor: 'accessing' stamp: 'len 5/27/2019 10:12:20'!
base
	^ self! !

!FreeAbelianGroup methodsFor: 'accessing' stamp: 'len 5/14/2019 02:10:04'!
generators
	^ self propertyAt: #generators ifAbsentPut: [(1 to: rank) collect: [:i| self x: i to: 1]]! !

!FreeAbelianGroup methodsFor: 'accessing' stamp: 'len 5/13/2019 11:53:41'!
identity
	^ self propertyAt: #identity ifAbsentPut: [(Monomial new: rank) parent: self]! !

!FreeAbelianGroup methodsFor: 'accessing' stamp: 'len 5/14/2019 05:41:46'!
names
	"Answer the indeterminate names to use when printing monomials."
	^ self propertyAt: #names ifAbsent: [self rank = 1 ifTrue: [#(x)]]! !

!FreeAbelianGroup methodsFor: 'accessing' stamp: 'len 5/13/2019 12:25:26'!
names: anArray
	"Set indeterminate names to use when printing monomials."
	self propertyAt: #names put: anArray! !

!FreeAbelianGroup methodsFor: 'accessing' stamp: 'len 5/6/2019 08:58:22'!
ordering
	^ ordering! !

!FreeAbelianGroup methodsFor: 'accessing' stamp: 'len 5/15/2019 03:19:26'!
orders
	"Answer the orders of the generators, with 0 to denote infinite order."
	^ (1 to: rank) collect: [:each| 0]! !

!FreeAbelianGroup methodsFor: 'accessing' stamp: 'len 5/6/2019 09:02:39'!
rank
	^ rank! !

!FreeAbelianGroup methodsFor: 'accessing' stamp: 'len 5/6/2019 09:02:54'!
size
	^ self rank > 0 ifTrue: [Aleph new] ifFalse: [1]! !

!FreeAbelianGroup methodsFor: 'accessing' stamp: 'len 5/15/2019 03:16:26'!
torsion
	"Answer the torsion subgroup, i.e. the subgroup of elements of finite order."
	^ self null! !

!FreeAbelianGroup methodsFor: 'comparing' stamp: 'len 5/13/2019 11:48:55'!
= anObject
	^ (anObject isKindOf: FreeAbelianGroup) and: [anObject rank = rank]! !

!FreeAbelianGroup methodsFor: 'comparing' stamp: 'len 5/6/2019 08:56:24'!
hash
	^ self rank + self class hash! !

!FreeAbelianGroup methodsFor: 'converting' stamp: 'len 5/14/2019 02:12:03'!
orderedBy: aMonomialOrdering
	| answer |
	answer _ self class new: self rank ordering: aMonomialOrdering.
	self names ifNotNil: [:aCollection| answer names: aCollection].
	^ answer! !

!FreeAbelianGroup methodsFor: 'elements' stamp: 'len 5/13/2019 11:55:08'!
!! anObject
	(anObject isSequenceable and: [anObject size = rank])
		ifTrue: [^ (Monomial exponents: anObject) parent: self].
	^ super !! anObject! !

!FreeAbelianGroup methodsFor: 'elements' stamp: 'len 5/13/2019 20:44:22'!
exponents: anArray
	anArray size = rank ifFalse: [self error: 'exponents size doesn''t match rank'].
	^ (Monomial exponents: anArray) parent: self! !

!FreeAbelianGroup methodsFor: 'elements' stamp: 'len 5/6/2019 09:03:49'!
x: anInteger to: exponent
	^ (Monomial new: rank x: anInteger to: exponent) parent: self! !

!FreeAbelianGroup methodsFor: 'enumerating' stamp: 'len 5/13/2019 11:56:21'!
do: aBlock
	ZZ ^ self rank do: [:each| aBlock value: self !! each asArray]! !

!FreeAbelianGroup methodsFor: 'random' stamp: 'len 5/13/2019 11:55:48'!
atRandom: aRandom bits: bitSize
	^ self !! (ZZ ^ self rank atRandom: aRandom bits: bitSize) asArray! !

!FreeAbelianGroup methodsFor: 'testing' stamp: 'len 5/6/2019 08:56:37'!
includes: aMonomial
	^ (aMonomial isKindOf: Monomial) and: [aMonomial lastIndeterminate <= rank]! !

!FreeAbelianGroup methodsFor: 'testing' stamp: 'len 5/14/2019 02:11:40'!
isCommutative
	^ true! !

!FreeAbelianGroup methodsFor: 'private' stamp: 'len 5/6/2019 08:58:30'!
ordering: aMonomialOrdering
	ordering _ aMonomialOrdering isSymbol
		ifTrue: [MonomialOrdering perform: (aMonomialOrdering,':') asSymbol with: (1 to: self rank)]
		ifFalse: [aMonomialOrdering]! !

!FreeAbelianGroup methodsFor: 'private' stamp: 'len 5/6/2019 09:02:43'!
rank: anInteger
	rank _ anInteger! !

!FreeAbelianGroup class methodsFor: 'instance creation' stamp: 'len 5/23/2019 17:12:05'!
new: anIntegerOrCollection
	^ self new: anIntegerOrCollection ordering: #grevlex! !

!FreeAbelianGroup class methodsFor: 'instance creation' stamp: 'len 5/23/2019 17:12:13'!
new: anIntegerOrCollection ordering: aMonomialOrdering
	^ (anIntegerOrCollection isInteger
		ifTrue: [self new rank: anIntegerOrCollection] 
		ifFalse: [self new rank: anIntegerOrCollection size; names: anIntegerOrCollection asArray]) ordering: aMonomialOrdering! !

!DirectProductGroup methodsFor: 'accessing' stamp: 'len 4/19/2019 07:14:28'!
ambient
	^ self propertyAt: #ambient ifAbsentPut: [(components allSatisfy: [:each| each isAmbient]) ifTrue: [self] ifFalse: [self class components: (components collect: [:each| each ambient])]]! !

!DirectProductGroup methodsFor: 'accessing' stamp: 'len 2/16/2016 07:30'!
arity
	^ components size! !

!DirectProductGroup methodsFor: 'accessing' stamp: 'len 2/12/2016 20:02'!
at: anInteger
	^ components at: anInteger! !

!DirectProductGroup methodsFor: 'accessing' stamp: 'len 4/22/2016 20:49'!
identity
	^ components collect: [:each| each identity]! !

!DirectProductGroup methodsFor: 'accessing' stamp: 'len 2/12/2016 20:10'!
size
	^ components product: [:each| each size]! !

!DirectProductGroup methodsFor: 'accessing-private' stamp: 'len 2/12/2016 20:00'!
components
	^ components! !

!DirectProductGroup methodsFor: 'accessing-private' stamp: 'len 11/5/2016 06:40'!
components: anArray
	components _ anArray! !

!DirectProductGroup methodsFor: 'comparing' stamp: 'len 2/12/2016 20:05'!
= anObject
	^ (anObject isKindOf: DirectProductGroup) and: [anObject components = components]! !

!DirectProductGroup methodsFor: 'comparing' stamp: 'len 2/12/2016 20:05'!
hash
	^ components hash! !

!DirectProductGroup methodsFor: 'converting' stamp: 'len 4/19/2016 20:39'!
asCartesianProduct
	^ CartesianProduct components: components! !

!DirectProductGroup methodsFor: 'enumerating' stamp: 'len 7/29/2016 06:51'!
do: aBlock
	self asCartesianProduct do: aBlock! !

!DirectProductGroup methodsFor: 'morphisms' stamp: 'len 4/23/2019 02:14:02'!
coprojection: i
	^ ((self at: i) to: self evaluating: [:x| components withIndexCollect: [:each :k| k = i ifTrue: [x] ifFalse: [each identity]]]) name: 'i', i printText sub! !

!DirectProductGroup methodsFor: 'morphisms' stamp: 'len 10/10/2016 08:42'!
projection: i
	^ (self to: (self at: i) evaluating: [:x| x at: i]) name: Character pi asText, i printText sub! !

!DirectProductGroup methodsFor: 'random' stamp: 'len 4/19/2016 20:39'!
atRandom: aRandom
	^ self asCartesianProduct atRandom: aRandom! !

!DirectProductGroup methodsFor: 'random' stamp: 'len 4/19/2016 20:39'!
atRandom: aRandom bits: bits
	^ self asCartesianProduct atRandom: aRandom bits: bits! !

!DirectProductGroup methodsFor: 'testing' stamp: 'len 5/22/2018 16:54:23'!
includes: anObject
	anObject isSequenceable ifFalse: [^ false].
	anObject size = components size ifFalse: [^ false].
	components with: anObject do: [:G :x| (G includes: x) ifFalse: [^ false]].
	^ true! !

!DirectProductGroup methodsFor: 'testing' stamp: 'len 4/22/2016 13:43'!
isProduct
	^ true! !

!DirectProductGroup methodsFor: 'private' stamp: 'len 12/30/2017 15:11:22'!
computeGenerators
	| answer |
	answer _ OrderedCollection new.
	1 to: self arity do: [:i|
		| p |
		p _ self projection: i.
		(self at: i) generators do: [:each| answer add: (p value: each)]].
	^ answer! !

!DirectProductGroup class methodsFor: 'instance creation' stamp: 'len 2/12/2016 20:02'!
components: anArray
	^ self new components: anArray! !

!FPGroup methodsFor: 'accessing' stamp: 'len 5/14/2019 02:27:28'!
base
	^ self propertyAt: #base! !

!FPGroup methodsFor: 'accessing' stamp: 'len 5/13/2019 22:53:01'!
generators
	^ self propertyAt: #generators ifAbsentPut: [(1 to: self base rank) collect: [:i| (Word x: i) parent: self]]! !

!FPGroup methodsFor: 'accessing' stamp: 'len 5/10/2019 14:52:34'!
identity
	^ Word empty parent: self! !

!FPGroup methodsFor: 'accessing' stamp: 'len 5/14/2019 02:28:10'!
names
	^ self base names! !

!FPGroup methodsFor: 'accessing' stamp: 'len 5/13/2019 13:30:04'!
relators
	^ self propertyAt: #relators ifAbsent: [#()]! !

!FPGroup methodsFor: 'accessing' stamp: 'len 5/14/2019 02:29:16'!
size
	self isFree ifTrue: [^ self base size].
	^ super size! !

!FPGroup methodsFor: 'comparing' stamp: 'len 5/14/2019 02:30:55'!
= anObject
	^ (anObject isKindOf: FPGroup) and: [self base = anObject base and: [self relators = anObject relators]]! !

!FPGroup methodsFor: 'comparing' stamp: 'len 5/24/2019 07:33:20'!
~ aGroup
	"Answer true if the receiver is isomorphic to the argument."
	(aGroup isKindOf: FPGroup) ifFalse: [^ super ~ aGroup].
	(self isFree and: [aGroup isFree]) ifTrue: [^ self base = aGroup base].
	^ super ~ aGroup! !

!FPGroup methodsFor: 'comparing' stamp: 'len 5/14/2019 02:30:40'!
hash
	^ self base hash! !

!FPGroup methodsFor: 'elements' stamp: 'len 5/14/2019 12:41:41'!
!! anObject
	(anObject isKindOf: Word) and: [anObject parent = self ifTrue: [^ anObject]].
	^ super !! anObject! !

!FPGroup methodsFor: 'elements' stamp: 'len 5/25/2019 08:23:29'!
wordOf: aWord
	"Answer the argument expressed as a word on the generators."
	^ aWord! !

!FPGroup methodsFor: 'morphisms' stamp: 'len 5/14/2019 10:09:58'!
from: aDomain
	self base == self ifTrue: [^ super from: aDomain].
	self base = aDomain ifTrue: [^ self addMap: ((aDomain onto: self mapping: [:i| self x: i]) name: Character pi asString)].
	aDomain -> self base ifNotNil: [:aMorphism| ^ aMorphism -> self].
	^ super from: aDomain! !

!FPGroup methodsFor: 'morphisms' stamp: 'len 5/24/2019 10:50:28'!
to: aGroup evaluating: aBlock
	aGroup isGroup ifFalse: [^ super to: aGroup evaluating: aBlock].
	^ self to: aGroup mapping: [:i| aBlock value: (self generators at: i)]! !

!FPGroup methodsFor: 'operations' stamp: 'len 5/26/2019 04:32:21'!
* aGroup
	"Answer the free product of the receiver with the argument."
	| F p |
	(aGroup isKindOf: FPGroup) ifFalse: [^ super * aGroup].
	F _ self base * aGroup base.
	p _ F -< (self base, aGroup base).
	^ F / ((self relators apply: p first), (aGroup relators apply: p second))! !

!FPGroup methodsFor: 'operations' stamp: 'len 5/15/2019 05:57:45'!
/ anObject
	| newRelators answer |
	newRelators _ Set new addAll: self relators; yourself.
	(self includes: anObject)
		ifTrue: [newRelators add: anObject]
		ifFalse:
			[anObject isCollection
				ifTrue: [newRelators addAll: anObject]
				ifFalse: [^ self notYetImplemented "subgroup?"]].
	^ (answer _ self base / newRelators)
		addMap: (self onto: answer mapping: [:i| answer x: i]);
		yourself! !

!FPGroup methodsFor: 'operations' stamp: 'len 5/26/2019 04:32:42'!
  aGroup
	"Answer the direct product of the receiver with the argument."
	| F p commutators relatorsLeft relatorsRight |
	(aGroup isKindOf: FPGroup) ifFalse: [^ super * aGroup].
	F _ self base * aGroup base.
	p _ F -< (self base, aGroup base).
	relatorsLeft _ self relators apply: p first.
	relatorsRight _ aGroup relators apply: p second.
	commutators _ OrderedCollection new.
	relatorsLeft do: [:x| relatorsRight do: [:y| commutators add: (x commutator: y)]].
	^ F / (relatorsLeft, relatorsRight, commutators)! !

!FPGroup methodsFor: 'operations' stamp: 'len 5/15/2019 05:59:19'!
span: aCollection
	self notYetImplemented! !

!FPGroup methodsFor: 'random' stamp: 'len 5/13/2019 22:51:18'!
atRandom: aRandom bits: bitSize
	| answer |
	answer _ self identity.
	bitSize // self generators size highBit
		timesRepeat:
			[answer _ (self generators atRandom: aRandom)^(#(-1 1) atRandom: aRandom) * answer].
	^ answer! !

!FPGroup methodsFor: 'testing' stamp: 'len 5/10/2019 14:37:34'!
includes: aWord
	^ (aWord isKindOf: Word) and: [aWord parent = self]! !

!FPGroup methodsFor: 'testing' stamp: 'len 5/14/2019 02:33:50'!
isCommutative
	self isFree ifTrue: [^ self generators size <= 1].
	^ super isCommutative! !

!FPGroup methodsFor: 'testing' stamp: 'len 5/13/2019 13:31:43'!
isFree
	^ self relators isEmpty! !

!FPGroup methodsFor: 'private' stamp: 'len 5/14/2019 02:27:11'!
base: aFreeGroup
	self propertyAt: #base put: aFreeGroup! !

!FPGroup methodsFor: 'private' stamp: 'len 5/14/2019 06:53:14'!
relators: aCollection
	self propertyAt: #relators put: aCollection! !

!FPGroup class methodsFor: 'examples' stamp: 'len 5/23/2019 17:14:28'!
D
	"Answer the infinite dihedral group as a finitely presented group."
	| F |
	F _ FreeGroup new: #(r f).
	^ F / (F !! [:r :f| {f^2. (rf)^2}])! !

!FPGroup class methodsFor: 'examples' stamp: 'len 5/23/2019 17:14:59'!
GL2Z
	"Answer GL(2,Z) as a finitely presented group."
	| F |
	F _ FreeGroup new: #(a b j).
	^ F / (F !! [:a :b :j| {aba eq: bab. (aba)^4. j^2. (ja)^2. (jb)^2}])! !

!FPGroup class methodsFor: 'examples' stamp: 'len 5/23/2019 17:15:09'!
PSL2Z
	"Answer PSL(2,Z) (the modular group) as a finitely presented group."
	| F |
	F _ FreeGroup new: #(a b).
	^ F / (F !! [:a :b| {a^2. b^3}])! !

!FPGroup class methodsFor: 'examples' stamp: 'len 5/23/2019 17:15:17'!
SL2Z
	"Answer SL(2,Z) as a finitely presented group."
	| F |
	F _ FreeGroup new: #(a b).
	^ F / (F !! [:a :b| {aba eq: bab. (aba)^4}])! !

!FPGroup class methodsFor: 'examples' stamp: 'len 5/14/2019 15:16:25'!
braid: n
	"Answer the braid group on n strands as a finitely presented group."
	| F relators |
	F _ FreeGroup new: n-1.
	relators _ OrderedCollection new.
	1 to: n-1 do: [:i|
		1 to: n-1 do: [:j| (i-1 = j or: [i+1 = j]) ifFalse: [relators add: ((F x: i) commutator: (F x: j))]].
		i < n-1 ifTrue: [relators add: ((F x: i)(F x: i+1))^3]].
	^ F / relators! !

!FPGroup class methodsFor: 'examples' stamp: 'len 5/14/2019 14:57:36'!
cyclic: n
	"Answer the cyclic group of order n as a finitely presented group."
	| F |
	F _ FreeGroup new: 1.
	^ F / (F !! [:x| x^n])! !

!FPGroup class methodsFor: 'examples' stamp: 'len 5/23/2019 17:15:38'!
dicyclic: n
	"Answer the infinite dihedral group as a finitely presented group."
	| F |
	F _ FreeGroup new: #(r f).
	^ F / (F !! [:r :f| {r^(2*n). r^n(f^-2). rfrf inverse}])! !

!FPGroup class methodsFor: 'examples' stamp: 'len 5/23/2019 17:15:47'!
dihedral: order
	"Answer the dihedral group of order 2n as a finitely presented group."
	| n F |
	order even ifFalse: [self error: 'order should be even'].
	n _ order // 2.
	F _ FreeGroup new: #(r f).
	^ F / (F !! [:r :f| {r^n. f^2. (rf)^2}])! !

!FPGroup class methodsFor: 'examples' stamp: 'len 5/23/2019 17:15:53'!
icosahedral
	"Answer the icosahedral group (ismorphic to A5) as a finitely presented group."
	| F |
	F _ FreeGroup new: #(s t).
	^ F / (F !! [:s :t| {s^2. t^3. (st)^5}])! !

!FPGroup class methodsFor: 'examples' stamp: 'len 5/23/2019 17:15:59'!
octahedral
	"Answer the octahedral group (ismorphic to S4) as a finitely presented group."
	| F |
	F _ FreeGroup new: #(s t).
	^ F / (F !! [:s :t| {s^2. t^3. (st)^4}])! !

!FPGroup class methodsFor: 'examples' stamp: 'len 5/23/2019 17:16:09'!
quaternion
	"Answer the quaternion group as a finitely presented group."
	| F |
	F _ FreeGroup new: #(i j).
	^ F / (F !! [:i :j| {jiji inverse. ijij inverse}])! !

!FPGroup class methodsFor: 'examples' stamp: 'len 5/14/2019 15:15:08'!
symmetric: n
	"Answer the symmetric group on n symbols as a finitely presented group."
	| F relators |
	F _ FreeGroup new: n-1.
	relators _ OrderedCollection new.
	1 to: n-1 do: [:i|
		relators add: (F x: i)^2.
		1 to: n-1 do: [:j| (i-1 = j or: [i+1 = j]) ifFalse: [relators add: ((F x: i) commutator: (F x: j))]].
		i < n-1 ifTrue: [relators add: ((F x: i)(F x: i+1))^3]].
	^ F / relators! !

!FPGroup class methodsFor: 'examples' stamp: 'len 5/23/2019 17:16:20'!
tetrahedral
	"Answer the tetrahedral group (ismorphic to A4) as a finitely presented group."
	| F |
	F _ FreeGroup new: #(s t).
	^ F / (F !! [:s :t| {s^2. t^3. (st)^3}])! !

!FPGroup class methodsFor: 'instance creation' stamp: 'len 5/14/2019 02:26:37'!
on: aFreeGroup relators: aCollection
	^ self new base: aFreeGroup; relators: aCollection! !

!FreeGroup methodsFor: 'accessing' stamp: 'len 5/14/2019 07:07:10'!
base
	^ self! !

!FreeGroup methodsFor: 'accessing' stamp: 'len 5/13/2019 11:07:43'!
generators
	^ self propertyAt: #generators ifAbsentPut: ((1 to: self rank) collect: [:i| (Word x: i) parent: self])! !

!FreeGroup methodsFor: 'accessing' stamp: 'len 5/13/2019 11:07:55'!
identity
	^ self propertyAt: #identity ifAbsentPut: [Word empty parent: self]! !

!FreeGroup methodsFor: 'accessing' stamp: 'len 5/14/2019 05:42:00'!
names
	"Answer the indeterminate names to use when printing words."
	^ self propertyAt: #names ifAbsent: [self rank = 1 ifTrue: [#(x)]]! !

!FreeGroup methodsFor: 'accessing' stamp: 'len 5/13/2019 13:01:18'!
names: anArray
	"Set indeterminate names to use when printing words."
	self propertyAt: #names put: anArray! !

!FreeGroup methodsFor: 'accessing' stamp: 'len 5/13/2019 11:07:22'!
rank
	^ self propertyAt: #rank! !

!FreeGroup methodsFor: 'accessing' stamp: 'len 5/14/2019 07:07:06'!
relators
	^ #()! !

!FreeGroup methodsFor: 'accessing' stamp: 'len 5/13/2019 11:07:04'!
size
	^ self rank > 0 ifTrue: [Aleph new] ifFalse: [1]! !

!FreeGroup methodsFor: 'comparing' stamp: 'len 5/14/2019 07:09:25'!
= anObject
	^ (anObject isKindOf: FreeGroup) and: [self rank = anObject rank]! !

!FreeGroup methodsFor: 'comparing' stamp: 'len 5/14/2019 07:09:46'!
hash
	^ self rank + self class hash! !

!FreeGroup methodsFor: 'operations' stamp: 'len 5/14/2019 12:20:28'!
* aGroup
	"Answer the free product of the receiver with the argument."
	| answer |
	(aGroup isKindOf: FreeGroup) ifFalse: [^ super * aGroup].
	^ (answer _ self class new: self rank + aGroup rank)
		addProjections:
			{(self into: answer mapping: [:i| answer x: i]) name: Character pi asText, '1' sub.
			(aGroup into: answer mapping: [:i| answer x: self rank + i]) name: Character pi asText, '2' sub};
		yourself! !

!FreeGroup methodsFor: 'operations' stamp: 'len 5/14/2019 10:06:31'!
/ anObject
	| newRelators answer |
	newRelators _ Set new.
	(self includes: anObject)
		ifTrue: [newRelators add: anObject]
		ifFalse:
			[anObject isCollection
				ifTrue: [newRelators addAll: anObject]
				ifFalse: [^ self notYetImplemented "subgroup?"]].
	answer _ FPGroup on: self relators: newRelators.
"	answer addMap: (self onto: answer mapping: [:i| answer x: i])."
	^ answer! !

!FreeGroup methodsFor: 'operations' stamp: 'len 5/13/2019 13:24:00'!
span: aCollection
	| answer newGenerators |
	newGenerators _ (aCollection asSet select: [:each| each isEmpty not]) asArray.
	answer _ self class new: newGenerators size.
	answer addMap: (answer into: self mapping: [:i| newGenerators at: i]).
	^ answer! !

!FreeGroup methodsFor: 'testing' stamp: 'len 5/14/2019 07:06:36'!
includes: anObject
	^ (anObject isKindOf: Word) and: [anObject parent = self]! !

!FreeGroup methodsFor: 'testing' stamp: 'len 5/13/2019 11:08:09'!
isCommutative
	^ self rank <= 1! !

!FreeGroup methodsFor: 'private' stamp: 'len 5/13/2019 11:21:51'!
rank: anInteger
	self propertyAt: #rank put: anInteger! !

!FreeGroup class methodsFor: 'instance creation' stamp: 'len 5/23/2019 17:11:34'!
new: anIntegerOrCollection
	^ anIntegerOrCollection isInteger
		ifTrue: [self new rank: anIntegerOrCollection] 
		ifFalse: [self new rank: anIntegerOrCollection size; names: anIntegerOrCollection asArray]! !

!FreeGroup class methodsFor: 'instance creation' stamp: 'len 5/14/2019 10:02:06'!
on: aFreeGroup relators: aCollection
	self shouldNotImplement! !

!OppositeGroup methodsFor: 'accessing' stamp: 'len 5/8/2019 14:22:26'!
generators
	^ opposite generators collect: [:each| self !! each]! !

!OppositeGroup methodsFor: 'accessing' stamp: 'len 5/8/2019 14:22:12'!
identity
	^ self !! opposite identity! !

!OppositeGroup methodsFor: 'elements' stamp: 'len 5/9/2019 08:05:51'!
!! anElement
	(opposite includes: anElement) ifTrue: [^ OppositeGroupElement opposite: anElement inverse].
	^ super !! anElement! !

!OppositeGroup methodsFor: 'operations' stamp: 'len 5/8/2019 13:41:23'!
opposite
	^ opposite! !

!OppositeGroup methodsFor: 'private' stamp: 'len 5/8/2019 13:41:37'!
opposite: aGroup
	opposite _ aGroup! !

!OppositeGroup class methodsFor: 'instance creation' stamp: 'len 5/8/2019 13:54:20'!
opposite: aGroup
	^ self new opposite: aGroup! !

!QuotientGroup methodsFor: 'accessing' stamp: 'len 12/28/2016 11:31:59'!
base
	^ self propertyAt: #base! !

!QuotientGroup methodsFor: 'accessing' stamp: 'len 12/22/2016 21:16:13'!
identity
	^ self project: self base identity! !

!QuotientGroup methodsFor: 'accessing' stamp: 'len 5/5/2019 18:15:42'!
relation
	^ EquivalenceRelation on: self base evaluating: [:x :y| self relations includes: x  y inverse]! !

!QuotientGroup methodsFor: 'accessing' stamp: 'len 2/28/2017 10:14:05'!
relations
	"Answer the relations subgroup, i.e. the normal subgroup by which we quotient."
	^ self propertyAt: #relations! !

!QuotientGroup methodsFor: 'accessing' stamp: 'len 1/9/2018 21:57:07'!
relators
	^ self relations generators! !

!QuotientGroup methodsFor: 'accessing' stamp: 'len 5/2/2016 02:14'!
size
	^ super size
"	^ properties at: #size ifAbsentPut: [base indexOf: subgroup]"! !

!QuotientGroup methodsFor: 'accessing-private' stamp: 'len 12/28/2016 11:31:54'!
base: aGroup
	self propertyAt: #base put: aGroup! !

!QuotientGroup methodsFor: 'accessing-private' stamp: 'len 2/28/2017 10:15:24'!
relations: aNormalSubgroup
	self propertyAt: #relations put: aNormalSubgroup! !

!QuotientGroup methodsFor: 'enumerating' stamp: 'len 12/22/2016 21:17:54'!
do: aBlock
	| visited |
	visited _ Set new.
	self base do: [:each| | x |
		visited add: (x _ self project: each) ifAbsent: [aBlock value: x]]! !

!QuotientGroup methodsFor: 'morphisms' stamp: 'len 5/13/2019 19:06:32'!
from: aDomain
	aDomain = self base ifTrue: [^ self projection].
	aDomain -> self base ifNotNil: [:aMorphism| ^ aMorphism -> self].
	^ super from: aDomain! !

!QuotientGroup methodsFor: 'morphisms' stamp: 'len 5/7/2018 22:53:14'!
lifting
	"Answer the map from the receiver to the base group lifting the canonical projection."
	^ self projection section! !

!QuotientGroup methodsFor: 'morphisms' stamp: 'len 5/9/2019 11:25:08'!
project: anElement
	^ Coset representative: anElement relations: self relations! !

!QuotientGroup methodsFor: 'morphisms' stamp: 'len 12/28/2016 11:31:42'!
projection
	"Answer the natural projection, or quotient map, or canonical homomorphism. This takes elements from the base group to the corresponding coset in the quotient group."
	^ self propertyAt: #projection ifAbsentPut: [self buildProjection]! !

!QuotientGroup methodsFor: 'random' stamp: 'len 12/22/2016 21:17:57'!
atRandom: aRandomGenerator bits: bitSize
	^ self project: (self base atRandom: aRandomGenerator bits: bitSize)! !

!QuotientGroup methodsFor: 'testing' stamp: 'len 8/10/2016 00:59'!
isQuotient
	^ true! !

!QuotientGroup methodsFor: 'private' stamp: 'len 5/16/2019 13:31:47'!
buildProjection
	"Answer the natural projection, or quotient map, or canonical homomorphism. This takes elements from the base group to the corresponding coset in the quotient group."
	| answer |
	answer _ self base onto: self evaluating: [:each| self project: each].
	answer name: Character pi asString.
	answer properties
		at: #kernel put: self relations;
		at: #image put: self;
		at: #section put: (self to: self base evaluating: [:each| each representative]).
	^ answer! !

!QuotientGroup class methodsFor: 'instance creation' stamp: 'len 2/28/2017 10:14:58'!
on: aGroup by: aNormalSubgroup
	^ self new base: aGroup; relations: aNormalSubgroup! !

!SemidirectProductGroup methodsFor: 'accessing' stamp: 'len 2/12/2016 06:15'!
action
	^ action! !

!SemidirectProductGroup methodsFor: 'accessing' stamp: 'len 2/16/2016 07:30'!
arity
	^ 2! !

!SemidirectProductGroup methodsFor: 'accessing' stamp: 'len 4/22/2016 20:49'!
identity
	^ self project: {left identity. right identity}! !

!SemidirectProductGroup methodsFor: 'accessing' stamp: 'len 2/12/2016 06:16'!
left
	^ left! !

!SemidirectProductGroup methodsFor: 'accessing' stamp: 'len 2/12/2016 06:16'!
right
	^ right! !

!SemidirectProductGroup methodsFor: 'accessing' stamp: 'len 2/12/2016 06:55'!
size
	^ left size * right size! !

!SemidirectProductGroup methodsFor: 'accessing-private' stamp: 'len 2/12/2016 06:17'!
action: anAction
	action _ anAction! !

!SemidirectProductGroup methodsFor: 'accessing-private' stamp: 'len 2/12/2016 06:17'!
left: aGroup
	left _ aGroup! !

!SemidirectProductGroup methodsFor: 'accessing-private' stamp: 'len 2/12/2016 06:17'!
right: aGroup
	right _ aGroup! !

!SemidirectProductGroup methodsFor: 'converting' stamp: 'len 4/19/2016 20:55'!
asCartesianProduct
	^ (left, right)! !

!SemidirectProductGroup methodsFor: 'enumerating' stamp: 'len 2/12/2016 06:57'!
do: aBlock
	left do: [:g| right do: [:h| aBlock value: (self project: {g.h})]]! !

!SemidirectProductGroup methodsFor: 'morphisms' stamp: 'len 10/6/2016 15:35'!
project: anArray
	"Project a cartesian product of two elements to their semidirect product."
	^ SemidirectProductElement new
		parent: self;
		left: (anArray at: 1);
		right: (anArray at: 2)! !

!SemidirectProductGroup methodsFor: 'morphisms' stamp: 'len 10/10/2016 08:53'!
projection
	"Answer the projection from the cartesian product of two groups to their semidirect product."
	^ ((left, right) to: self evaluating: [:each| self project: each]) name: Character pi asString! !

!SemidirectProductGroup methodsFor: 'random' stamp: 'len 4/19/2016 20:52'!
atRandom: aRandom
	^ self project: (self asCartesianProduct atRandom: aRandom)! !

!SemidirectProductGroup methodsFor: 'random' stamp: 'len 4/19/2016 20:52'!
atRandom: aRandom bits: bitSize
	^ self project: (self asCartesianProduct atRandom: aRandom bits: bitSize)! !

!SemidirectProductGroup methodsFor: 'testing' stamp: 'len 6/29/2016 21:21'!
isProduct
	^ true! !

!SemidirectProductGroup class methodsFor: 'instance creation' stamp: 'len 2/12/2016 06:16'!
left: aGroup right: anotherGroup action: anAction
	^ self new left: aGroup; right: anotherGroup; action: anAction! !

!PermutationGroup methodsFor: 'accessing' stamp: 'len 1/31/2018 18:40:20'!
action
	"Answer the natural action that sends (s, x) to s(x)."
	^ GroupAction from: (self, self space) to: self space evaluatingWithArguments: [:s :x| s value: x]! !

!PermutationGroup methodsFor: 'accessing' stamp: 'len 2/16/2016 05:48'!
degree
	^ self space size! !

!PermutationGroup methodsFor: 'accessing' stamp: 'len 2/1/2018 23:44:34'!
identity
	self ambient == self ifTrue: [^ self halt].
	^ self ambient identity! !

!PermutationGroup methodsFor: 'accessing' stamp: 'len 1/28/2018 18:27:42'!
polynomialActionOn: aPolynomialRing
	"Answer the action that permutes the indeterminates."
	^ GroupAction from: (self, aPolynomialRing) to: aPolynomialRing evaluatingWithArguments: [:s :f| f permutedBy: s]! !

!PermutationGroup methodsFor: 'accessing' stamp: 'len 1/28/2018 18:31:26'!
polynomialActionOver: aRing
	"Answer the action that permutes the indeterminates on a polynomial ring."
	| R |
	R _ aRing polynomialsIn: self degree.
	^ GroupAction from: (self, R) to: R evaluatingWithArguments: [:s :f| f permutedBy: s]! !

!PermutationGroup methodsFor: 'accessing' stamp: 'len 12/28/2016 11:29:34'!
size
	self propertyAt: #elements ifPresent: [:aCollection| ^ aCollection size].
	^ self propertyAt: #size ifAbsentPut: [self computeSize]! !

!PermutationGroup methodsFor: 'accessing' stamp: 'len 5/18/2018 19:01:32'!
space
	^ self ambient space! !

!PermutationGroup methodsFor: 'comparing' stamp: 'len 12/13/2016 07:35:29'!
= anObject
	self == anObject ifTrue: [^ true].
	(anObject isKindOf: self species)
		ifFalse: [^ super = anObject].
	self generators ifNotNil: [:g1| anObject generators ifNotNil: [:g2| g1 asSet = g2 asSet ifTrue: [^ true]]].
	self size = anObject size ifFalse: [^ false].
	anObject generators ifNotNil: [:generators| ^ self containsAllOf: generators].
	self generators ifNotNil: [:generators| ^ anObject containsAllOf: generators].
	^ super = anObject! !

!PermutationGroup methodsFor: 'converting' stamp: 'len 9/26/2018 22:03:36'!
asMatrixGroup
	"Return a matrix group isomorphic to the receiver.
	Assume the space of the receiver is an interval (1 to: n)."
	| n generators |
	n _ self degree.
	generators _ self generators collect: [:g| QQ matrix: n@n evaluating: [:i :j| (g at: i) = j ifTrue: [1] ifFalse: [0]]].
	^ LinearGroup generators: generators! !

!PermutationGroup methodsFor: 'copying' stamp: 'len 9/26/2018 22:36:31'!
copyEmpty
	^ self species new ambient: self ambient! !

!PermutationGroup methodsFor: 'operations' stamp: 'len 5/24/2019 16:58:00'!
 aGroup
	"Answer the direct product of the receiver and the argument."
	| S n m G1 G2 k answer |
	(aGroup isKindOf: PermutationGroup) ifFalse: [^ super  aGroup].
	n _ self degree.
	m _ aGroup degree.
	S _ SymmetricGroup new: n + m.
	G1 _ self generators collect: [:g| S !! (g asArray, (n+1 to: n+m))].
	G2 _ aGroup generators collect: [:g| S !! ((1 to: n), (g asArray collect: [:i| i+n]))].
	k _ G1 size.
	^ (answer _ S span: G1, G2) "<- assumes the order of the generators is kept"
		addCoprojections:
			{self into: answer mapping: [:i| answer x: i].
			aGroup into: answer mapping: [:i| answer x: i+k]};
		addProjections:
			{answer onto: self mapping: [:i| i <= k ifTrue: [self x: i] ifFalse: [self identity]].
			answer onto: aGroup mapping: [:i| i > k ifTrue: [aGroup x: i-k] ifFalse: [aGroup identity]]};
		yourself! !

!PermutationGroup methodsFor: 'operations' stamp: 'len 5/26/2019 11:26:50'!
reduced
	"Answer a permutation group isomorphic to the receiver but acting on a smaller space (if possible)."
"	support _ Set new.
	self generators do: [:each| support add: each support].
"
	self notYetImplemented! !

!PermutationGroup methodsFor: 'operations' stamp: 'len 2/1/2018 23:47:51'!
span: aCollection
	^ self ambient span: aCollection! !

!PermutationGroup methodsFor: 'testing' stamp: 'len 1/31/2018 18:41:29'!
includes: aPermutation
	^ (self ambient includes: aPermutation) and: [self contains: aPermutation]! !

!PermutationGroup methodsFor: 'testing' stamp: 'len 2/1/2018 23:13:17'!
isStandard
	"Answer true if the domain of the receiver is an interval [1..n]."
	^ self ambient isStandard! !

!PermutationGroup methodsFor: 'testing' stamp: 'len 5/25/2019 04:47:19'!
isSubgroupOfAn
	"Monte Carlo test."
	| random |
	self flag: #fix.
	self isTransitive ifFalse: [^ false].
	random _ Random new.
	20 timesRepeat: [(self atRandom: random) isPurple ifTrue: [^ true]].
	^ false! !

!PermutationGroup methodsFor: 'private' stamp: 'len 4/23/2019 02:12:09'!
ambient: aDomain
	self propertyAt: #ambient put: aDomain! !

!PermutationGroup methodsFor: 'private' stamp: 'len 1/31/2018 18:39:54'!
computeSize
	"Schreier-Sims algorithm."
	| G answer |
	G _ self.
	answer _ 1.
	self space do: [:b| | tree |
		G isTrivial ifTrue: [^ answer].
		tree _ SchreierTree root: b generators: G generators action: G action.
		answer _ answer * tree orbit size.
		G _ tree stabilizer].
	self error: 'what?'.
	^ answer! !

!PermutationGroup methodsFor: 'private' stamp: 'len 3/4/2016 20:36'!
species
	^ PermutationGroup! !

!PermutationGroup class methodsFor: 'examples' stamp: 'len 2/1/2018 23:25:24'!
Co3
	"Conway group Co3. This group has order 495766656000."
	| x y |
	x _ #(245 42 112 15 131 7 188 75 132 10 11 187 186 265 22 159 256 43 101 123 134 4 32 209 238 35 45 235 126 5 19 60 66 80 154 251 117 206 71 118 93 87 167 271 221 261 182 155 47 230 172 236 109 191 76 156 73 116 147 23 127 231 38 53 122 210 24 68 86 255 196 139 149 21 111 203 252 72 262 114 214 9 181 174 85 95 2 250 257 243 90 158 170 148 69 105 249 263 16 54 31 115 51 104 125 219 92 46 64 204 8 266 225 34 175 145 161 180 237 241 224 169 269 12 96 129 189 190 29 17 30 82 143 74 168 13 227 217 78 258 220 178 228 146 58 254 273 215 57 106 77 110 50 26 248 260 274 107 99 253 37 25 272 44 52 119 18 201 65 41 233 103 246 200 102 160 198 207 157 40 223 49 267 79 1 136 124 6 61 268 100 70 98 171 121 39 62 211 208 84 135 97 55 152 141 63 142 259 67 33 177 173 14 242 94 113 240 264 150 205 27 183 83 195 216 163 247 133 36 153 197 140 194 120 270 165 166 162 218 138 234 81 91 89 185 212 137 48 202 276 229 151 176 144 192 130 244 232 199 56 108 184 193 239 213 3 222 128 20 28 164 226 59 179 275 88).
	y _ #(204 203 33 236 5 172 77 76 47 146 133 224 229 53 84 16 223 228 130 131 252 190 13 263 242 10 32 196 199 65 246 209 40 99 241 198 269 251 75 118 176 271 183 116 197 238 22 29 178 26 174 129 2 153 272 257 41 12 59 20 27 175 106 159 218 259 137 258 261 164 262 189 45 177 260 85 25 15 226 96 24 1 274 148 264 132 48 117 36 60 171 201 101 253 95 120 142 213 165 51 115 44 103 167 243 66 141 108 88 97 276 30 139 222 166 173 231 3 73 239 56 170 82 162 163 207 145 128 52 104 90 216 220 155 74 237 28 4 113 273 230 270 248 180 206 50 250 78 127 150 54 232 217 121 69 156 6 125 210 86 89 46 184 211 265 93 19 138 23 126 43 188 102 244 219 192 256 83 58 144 181 187 91 158 205 235 147 157 114 9 152 57 39 64 143 67 119 161 87 200 111 79 14 123 21 149 122 191 61 194 266 225 31 81 62 160 151 112 215 254 234 72 17 179 105 267 227 18 169 249 109 208 275 68 233 168 55 124 80 240 35 7 212 100 245 98 195 247 107 182 42 185 94 11 255 135 154 221 63 193 134 71 214 8 34 70 202 268 37 110 38 136 140 49 186 92).
	^ PermutationGroup new: 276 generators: {x. y}! !

!PermutationGroup class methodsFor: 'examples' stamp: 'len 2/1/2018 23:25:36'!
J1
	"Janko group J1. This group has order 175560."
	| x y |
	x _ #(262 107 21 213 191 22 133 234 232 151 139 176 202 253 222 16 195 206 68 55 3 6 179 217 216 256 87 70 131 44 105 170 77 104 198 137 243 56 124 223 134 42 174 30 45 51 128 94 250 264 46 183 231 115 20 38 85 233 261 95 235 177 249 91 247 155 67 19 219 28 237 211 84 192 130 251 33 78 260 112 193 156 242 73 57 238 27 143 168 148 64 119 212 48 60 150 199 140 189 180 147 111 159 34 31 162 2 194 166 200 102 80 120 141 54 182 181 225 92 113 254 125 146 39 122 208 221 47 210 75 29 255 7 41 135 175 36 207 11 98 114 240 88 172 185 123 101 90 224 96 10 169 241 190 66 82 214 161 103 236 158 106 239 229 230 109 188 89 152 32 258 144 186 43 136 12 62 245 23 100 117 116 52 205 145 173 228 167 99 154 5 74 81 108 17 196 203 35 97 110 252 13 197 204 184 18 138 126 248 129 72 93 4 157 259 25 24 246 69 227 127 15 40 149 118 226 220 187 164 165 53 9 58 8 61 160 71 86 163 142 153 83 37 244 178 218 65 209 63 49 76 201 14 121 132 26 263 171 215 79 59 1 257 50 266 265).
	y _ #(146 132 3 156 242 107 125 245 174 241 264 248 36 116 47 178 170 197 233 121 1 228 48 201 15 136 212 6 175 77 237 30 226 31 129 44 161 232 219 78 139 9 211 13 222 97 25 173 70 153 186 29 203 35 169 140 260 91 199 108 208 206 11 55 103 65 95 73 151 131 41 221 225 18 143 7 32 159 217 93 181 2 258 163 154 182 38 133 117 33 243 191 122 27 205 20 135 98 229 138 61 194 66 104 149 62 28 164 123 17 137 16 69 37 238 128 247 57 167 134 96 80 193 185 76 83 218 14 54 8 49 82 215 189 46 190 183 188 71 230 231 239 202 224 158 21 119 214 184 250 113 72 200 213 22 166 102 220 40 92 114 257 177 60 179 4 147 168 64 110 171 148 23 42 52 195 84 112 246 19 252 196 111 105 265 209 24 100 120 26 160 39 109 157 266 86 74 204 227 50 187 75 216 207 67 106 198 101 51 141 251 94 85 172 88 53 254 261 192 145 152 240 262 249 68 90 59 155 263 56 210 87 180 12 115 142 34 235 236 45 244 253 58 10 130 165 89 234 144 259 43 81 5 79 223 162 256 126 150 118 127 255 99 63 124 176).
	^ PermutationGroup new: 266 generators: {x. y}! !

!PermutationGroup class methodsFor: 'examples' stamp: 'len 2/1/2018 23:27:01'!
M11
	"The Mathieu group on 11 points. With order 7920, this is the smallest of the 26 sporadic simple groups."
	"ALTERNATIVELY: #((1 2 3 4 5 6 7 8 9 10 11)), #((3 7 11 8) (4 10 5 6)).
	"
	^ self new: 11 generators: {#((1 10) (2 8) (3 11) (5 7)). #((1 4 7 6) (2 11 10 9))}! !

!PermutationGroup class methodsFor: 'examples' stamp: 'len 2/1/2018 23:27:42'!
M12
	"The Mathieu group on 12 points, the second smallest of the 26 sporadic simple groups, with order 95040."
	^ self new: 12 generators: {#((1 2 3 4 5 6 7 8 9 10 11)). #((3 7 11 8) (4 10 5 6)). #((1 12) (2 11) (3 6) (4 8) (5 9) (7 10))}! !

!PermutationGroup class methodsFor: 'examples' stamp: 'len 2/1/2018 23:28:00'!
McL
	"McLaughlin group. This group has order 898128000."
	| x y |
	x _ #(191 182 3 81 55 60 7 66 272 177 192 163 13 242 133 107 17 267 108 218 198 185 211 82 204 195 132 253 207 59 179 154 264 152 92 189 217 197 85 156 41 184 102 50 216 99 181 48 199 44 111 52 158 236 5 210 57 103 30 6 263 62 119 138 127 8 105 137 69 125 144 219 261 74 175 76 269 237 268 80 4 24 232 256 39 104 95 88 234 233 140 35 93 149 87 96 173 160 46 112 123 43 58 86 67 221 16 19 131 176 51 100 262 257 201 116 260 238 63 275 214 225 101 246 70 170 65 128 141 130 109 27 15 196 167 136 68 64 139 91 129 235 224 71 205 249 147 226 94 243 151 34 193 32 228 40 157 53 159 98 231 162 12 215 180 166 135 222 270 126 241 259 97 212 75 110 10 188 31 165 47 2 266 42 22 203 187 178 36 250 1 11 153 194 26 134 38 21 49 200 115 247 186 25 145 206 29 255 251 56 23 174 252 121 164 45 37 20 72 220 106 168 271 143 122 148 274 155 229 240 161 83 90 89 142 54 78 118 254 230 171 14 150 244 258 124 202 248 146 190 209 213 28 239 208 84 114 245 172 117 73 113 61 33 273 183 18 79 77 169 223 9 265 227 120).
	y _ #(24 28 67 168 118 274 98 209 266 271 247 13 71 7 218 170 100 26 223 128 264 116 179 204 40 198 64 272 56 132 255 148 61 241 89 239 54 20 126 177 35 248 139 172 234 214 140 55 134 213 22 107 101 99 113 135 221 57 252 84 163 47 94 162 171 192 142 195 167 145 10 152 14 206 73 91 17 2 245 203 63 205 38 188 191 215 115 52 82 227 180 155 169 173 181 265 250 75 249 4 51 207 156 70 267 273 262 256 97 66 117 76 220 49 158 53 105 19 44 144 269 127 141 185 119 189 102 159 58 50 225 42 164 32 68 230 79 121 193 268 259 31 106 96 9 30 184 114 143 103 150 197 125 186 1 160 147 178 83 151 120 21 90 196 78 59 190 77 110 182 16 153 210 62 200 37 85 240 244 238 34 65 36 108 18 219 251 208 136 46 25 93 8 236 29 15 217 124 111 123 60 130 23 92 41 154 246 201 43 81 5 45 224 69 231 166 254 133 74 235 261 232 211 202 86 88 33 237 228 39 131 212 95 222 48 187 253 112 275 87 233 149 263 80 6 122 138 146 176 243 258 260 270 72 3 157 183 194 175 216 129 226 109 27 161 104 199 174 11 229 12 165 242 137 257).
	^ PermutationGroup new: 275 generators: {x. y}! !

!PermutationGroup class methodsFor: 'examples' stamp: 'len 5/15/2019 01:39:38'!
cyclic: n
	"Answer the cyclic group of order n as a permutation group."
	^ self new: n generators: {{(1 to: n)}}! !

!PermutationGroup class methodsFor: 'examples' stamp: 'len 5/14/2019 14:58:37'!
dihedral: order
	"Answer the dihedral group of order 2n as a permutation group."
	| n G s r |
	order even ifFalse: [self error: 'order should be even'].
	n _ order // 2.
	G _ SymmetricGroup new: n.
	r _ G !! {(1 to: n)}.
	s _ G !! [:i| n - i + 1].
	^ (G span: {s. r}) name: 'Dih', order printString sub! !

!PermutationGroup class methodsFor: 'examples' stamp: 'len 2/1/2018 23:28:37'!
hessian
	"The Hessian group, a finite group of order 216 introduced by Jordan and named after Otto Hesse."
	^ self new: 9 generators: {#((1 2 4) (5 6 8) (3 9 7)). #((4 5 6) (7 9 8))}! !

!PermutationGroup class methodsFor: 'examples' stamp: 'len 2/1/2018 23:29:18'!
klein
	"The Klein four-group (or Vierergruppe) as a permutation group."
	^ self new: 4 generators: {#(2 1 4 3). #(3 4 1 2) ". #(4 3 2 1)"}! !

!PermutationGroup class methodsFor: 'instance creation' stamp: 'len 1/31/2018 21:30:04'!
new: n generators: aCollection
	^ (SymmetricGroup new: n) span: aCollection! !

!PermutationGroup class methodsFor: 'instance creation' stamp: 'len 2/1/2018 23:24:53'!
on: aCollection generators: anotherCollection
	^ (SymmetricGroup on: aCollection) span: anotherCollection! !

!AlternatingGroup methodsFor: 'accessing' stamp: 'len 2/16/2016 05:49'!
size
	^ self degree factorial / 2! !

!AlternatingGroup methodsFor: 'enumerating' stamp: 'len 1/31/2018 21:16:14'!
do: aBlock
	self ambient do: [:each| each even ifTrue: [aBlock value: each]]! !

!AlternatingGroup methodsFor: 'random' stamp: 'len 6/28/2016 08:48'!
atRandom: aRandom bits: bitSize
	| S answer |
	S _ self ambient.
	[(answer _ S atRandom: aRandom bits: bitSize) even] whileFalse.
	^ answer! !

!AlternatingGroup methodsFor: 'testing' stamp: 'len 12/13/2016 07:31:33'!
contains: aPermutation
	"Answer true if the receiver contains the given element of its ambient."
	^ aPermutation even! !

!AlternatingGroup methodsFor: 'testing' stamp: 'len 5/29/2019 04:12:09'!
isSimple
	"A group is 'simple' if the only normal subgroups are the trivial group and itself."
	^ self degree >= 5! !

!AlternatingGroup methodsFor: 'private' stamp: 'len 5/18/2018 19:02:46'!
computeGenerators
	| X |
	X _ self space asArray.
	^ (1 to: self degree - 2) collect: [:i| self ambient cycle: {X at: i. X at: i+1. X at: i+2}]! !

!AlternatingGroup class methodsFor: 'examples' stamp: 'len 5/22/2018 21:40:59'!
example1
	"The group of even permutations on the set of 3 elements {1,2,3}."
	^ AlternatingGroup new: 3! !

!AlternatingGroup class methodsFor: 'examples' stamp: 'len 5/22/2018 21:42:51'!
example2
	"The group of even permutations on the set {a,b,c}."
	^ AlternatingGroup on: #(a b c).! !

!AlternatingGroup class methodsFor: 'instance creation' stamp: 'len 2/1/2018 23:51:38'!
new: anInteger
	^ self new ambient: (SymmetricGroup new: anInteger)! !

!AlternatingGroup class methodsFor: 'instance creation' stamp: 'len 2/1/2018 23:51:52'!
on: aCollection
	^ self new ambient: (SymmetricGroup on: aCollection)! !

!SymmetricGroup methodsFor: 'accessing' stamp: 'len 6/24/2016 08:44'!
ambient
	^ self! !

!SymmetricGroup methodsFor: 'accessing' stamp: 'len 2/1/2018 22:21:22'!
degree
	^ self space size! !

!SymmetricGroup methodsFor: 'accessing' stamp: 'len 2/16/2016 05:50'!
size
	^ self degree factorial! !

!SymmetricGroup methodsFor: 'accessing' stamp: 'len 2/1/2018 23:18:36'!
space
	^ self propertyAt: #space! !

!SymmetricGroup methodsFor: 'comparing' stamp: 'len 5/1/2016 06:32'!
>= anObject
	(anObject isKindOf: PermutationGroup)
		ifTrue: [^ self space >= anObject space].
	^ super >= anObject! !

!SymmetricGroup methodsFor: 'elements' stamp: 'len 5/25/2019 06:25:17'!
!! anObject
	"Coerce anObject to an element of the receiver (a permutation)."
	anObject isEvaluable
		ifTrue: [^ self evaluating: anObject].
	anObject isSequenceable
		ifFalse: [^ super !! anObject].
	(anObject allSatisfy: [:each| each isSequenceable and: [self space includesAllOf: each]]) "cycles"
		ifTrue: [^ self cycles: anObject].
	(self space includesAllOf: anObject)
		ifTrue: [^ self images: (anObject asArray collect: [:each| self spaceToIndex at: each])].
	^ super !! anObject! !

!SymmetricGroup methodsFor: 'elements' stamp: 'len 5/25/2019 06:25:31'!
cycle: anArray
	| map first last |
	anArray size > 1 ifFalse: [^ self identity].
	map _ (1 to: self degree) asArray.
	anArray do: [:each| | i |
		i _ self spaceToIndex at: each.
		first isNil
			ifTrue: [first _ i]
			ifFalse: [map at: last put: i].
		last _ i].
	map at: last put: first.
	^ self images: map! !

!SymmetricGroup methodsFor: 'elements' stamp: 'len 4/30/2019 18:07:59'!
cycles: anArray
	^ anArray inject: self identity into: [:answer :each| answer * (self cycle: each)]! !

!SymmetricGroup methodsFor: 'elements' stamp: 'len 5/25/2019 06:26:00'!
evaluating: aBlock
	^ self images: (self indexToSpace collect: [:each| self spaceToIndex at: (aBlock value: each)])! !

!SymmetricGroup methodsFor: 'elements' stamp: 'len 5/25/2019 06:26:05'!
identity
	^ self propertyAt: #identity ifAbsentPut: [self images: (1 to: self degree) asArray]! !

!SymmetricGroup methodsFor: 'elements' stamp: 'len 5/25/2019 06:26:14'!
images: anArray
	^ Permutation new parent: self; images: anArray! !

!SymmetricGroup methodsFor: 'elements' stamp: 'len 4/30/2019 18:16:46'!
transposing: anObject with: anotherObject
	"Answer the tranposition of anObject with anotherObject."
	^ self cycle: {anObject. anotherObject}! !

!SymmetricGroup methodsFor: 'enumerating' stamp: 'len 5/25/2019 06:25:47'!
do: aBlock
	(1 to: self degree) permutationsDo: [:each| aBlock value: (self images: each copy)]! !

!SymmetricGroup methodsFor: 'operations' stamp: 'len 5/2/2019 10:15:00'!
commutator
	^ AlternatingGroup on: self space! !

!SymmetricGroup methodsFor: 'operations' stamp: 'len 5/24/2019 17:04:24'!
span: aCollection
	^ self species new ambient: self; generators: (aCollection collect: [:each| self !! each])! !

!SymmetricGroup methodsFor: 'random' stamp: 'len 5/25/2019 06:25:25'!
atRandom: aRandom
	^ self images: ((1 to: self degree) asArray shuffledBy: aRandom)! !

!SymmetricGroup methodsFor: 'random' stamp: 'len 4/19/2016 22:45'!
atRandom: aRandom bits: bits
	^ self atRandom: aRandom! !

!SymmetricGroup methodsFor: 'testing' stamp: 'len 12/13/2016 07:31:06'!
contains: aPermutation
	"Answer true if the receiver contains the given element of its ambient."
	^ true! !

!SymmetricGroup methodsFor: 'testing' stamp: 'len 4/30/2019 18:17:43'!
includes: anObject
	^ (anObject isKindOf: Permutation) and: [anObject parent = self]! !

!SymmetricGroup methodsFor: 'testing' stamp: 'len 2/16/2016 05:55'!
isAlmostSimple
	^ self degree >= 5! !

!SymmetricGroup methodsFor: 'testing' stamp: 'len 5/8/2019 13:53:47'!
isStandard
	"Answer true if the domain of the receiver is an interval [1..n]."
	^ self propertyAt: #isStandard ifAbsentPut: [self space = (1 to: self degree) asArray]! !

!SymmetricGroup methodsFor: 'testing' stamp: 'len 5/26/2019 12:24:52'!
isTrivial
	^ self degree = 0! !

!SymmetricGroup methodsFor: 'private' stamp: 'len 5/26/2019 12:25:43'!
computeGenerators
	| X |
	X _ self indexToSpace.
	X isEmpty ifTrue: [^ #()].
	^ (2 to: X size) collect: [:i| (self transposing: X first with: (X at: i))]
"alternatively: Coxeter generators, the set of (i,i+1) all the adjacent transpositions"! !

!SymmetricGroup methodsFor: 'private' stamp: 'len 5/1/2019 02:14:06'!
degree: anInteger
	| space |
	space _ (1 to: anInteger) asArray.
	self propertyAt: #space put: space; propertyAt: #spaceToIndex put: space; propertyAt: #indexToSpace put: space! !

!SymmetricGroup methodsFor: 'private' stamp: 'len 4/30/2019 12:18:10'!
indexToSpace
	^ self propertyAt: #indexToSpace ifAbsentPut: [self space asArray]! !

!SymmetricGroup methodsFor: 'private' stamp: 'len 2/1/2018 23:18:55'!
space: aCollection
	self propertyAt: #space put: aCollection! !

!SymmetricGroup methodsFor: 'private' stamp: 'len 4/30/2019 12:23:20'!
spaceToIndex
	^ self propertyAt: #spaceToIndex ifAbsentPut:
		[| answer |
		answer _ Dictionary new: self degree.
		self indexToSpace withIndexDo: [:x :i| answer at: x put: i].
		answer]! !

!SymmetricGroup class methodsFor: 'examples' stamp: 'len 2/27/2017 08:36:17'!
example1
	"The group of permutations on the set of 3 elements {1,2,3}."
	^ SymmetricGroup new: 3! !

!SymmetricGroup class methodsFor: 'examples' stamp: 'len 2/27/2017 08:36:50'!
example2
	"The group of permutations on the set {a,b,c}."
	^ SymmetricGroup on: #(a b c).! !

!SymmetricGroup class methodsFor: 'instance creation' stamp: 'len 5/1/2019 02:12:05'!
new: anInteger
	^ self new degree: anInteger! !

!SymmetricGroup class methodsFor: 'instance creation' stamp: 'len 2/1/2018 22:24:13'!
on: aCollection
	^ self new space: aCollection! !

!LinearGroup methodsFor: 'accessing' stamp: 'len 9/27/2018 20:58:08'!
action
	"Answer the natural action that sends (f, x) to f(x)."
	^ GroupAction from: (self, self space) to: self space evaluatingWithArguments: [:f :x| f value: x]! !

!LinearGroup methodsFor: 'accessing' stamp: 'len 9/26/2018 23:03:38'!
ambient
	^ self space automorphisms! !

!LinearGroup methodsFor: 'accessing' stamp: 'len 9/25/2018 17:07:47'!
degree
	^ self space rank! !

!LinearGroup methodsFor: 'accessing' stamp: 'len 9/27/2018 20:58:41'!
identity
	^ self space id! !

!LinearGroup methodsFor: 'accessing' stamp: 'len 9/27/2018 21:00:37'!
polynomialAction
	"Answer the action of the receiver on the polynomial ring K[x1...xn]."
	| R X |
	R _ self space coordinateRing.
	X _ R tuple: R rank evaluating: [:i| R x: i].
	^ GroupAction from: (self, R) to: R evaluatingWithArguments: [:a :f| f value: (a matrix over: R) * X]! !

!LinearGroup methodsFor: 'accessing' stamp: 'len 9/25/2018 17:07:38'!
scalars
	^ self space scalars! !

!LinearGroup methodsFor: 'accessing' stamp: 'len 9/26/2018 23:05:05'!
space
	^ self propertyAt: #space! !

!LinearGroup methodsFor: 'copying' stamp: 'len 9/26/2018 23:04:39'!
copyEmpty
	^ self species on: self space! !

!LinearGroup methodsFor: 'invariants' stamp: 'len 2/5/2017 10:58:39'!
hilbertSeries
	"Answer the Hilbert series of the invariant ring of the receiver.
	This is the sum of dim(S_d ^G z^d for d>=0 (by Molien's formula, 1897), i.e. it counts the homogeneous polynomials of a given degree d that are invariants for the group."
	| order |
	order _ self size.
	self scalars characteristic | order ifTrue: [self error: 'group order divisible by characteristic'].
	^ (self elements sum: [:g| g characteristicPolynomial reciprocal]) / order! !

!LinearGroup methodsFor: 'invariants' stamp: 'len 11/29/2016 10:56:28'!
reynolds
	"Answer the Reynolds operator. Properties:
	- K-linear map S -> S^G;
	- restricts to the identity on S^G;
	- it's an S^G-module homomorphisms: R(p*q) = p*R(q) for all invariants p in S^G."
	| order action |
	order _ self size.
	action _ self polynomialAction.
	^ self space coordinateRing to: self invariantsRing evaluating: [:p| (self sum: [:g| action value: {g. p}]) / order]! !

!LinearGroup methodsFor: 'operations' stamp: 'len 9/26/2018 22:52:14'!
span: aCollection
	^ self ambient span: aCollection! !

!LinearGroup methodsFor: 'printing' stamp: 'len 9/25/2018 17:09:21'!
printMatrixGroupOn: aStream
	self shortName isNil ifTrue: [^ super printOn: aStream].
	aStream isText
		ifTrue:
			[aStream nextPutAll: self shortName; nextPutAll: self degree printString sub; nextPut: $(; print: self scalars; nextPut: $)]
		ifFalse:
			[aStream nextPutAll: self shortName; nextPut: $(; print: self scalars; nextPut: $,; print: self degree; nextPut: $)]! !

!LinearGroup methodsFor: 'printing' stamp: 'len 12/8/2016 08:58:51'!
shortName
	^ nil! !

!LinearGroup methodsFor: 'testing' stamp: 'len 9/27/2018 21:01:22'!
includes: anObject
	^ (self ambient includes: anObject) and: [self contains: anObject]! !

!LinearGroup methodsFor: 'testing' stamp: 'len 2/22/2016 00:27'!
isFinite
	^ self scalars isFinite or: [super isFinite]! !

!LinearGroup methodsFor: 'private' stamp: 'len 12/22/2016 21:52:52'!
computeSize
	"Schreier-Sims algorithm."
	| G answer |
	G _ self.
	answer _ 1.
	self space do: [:b| | tree |
		G isTrivial ifTrue: [^ answer].
		tree _ SchreierTree root: b generators: G generators action: G action.
		answer _ answer * tree orbit size.
		G _ tree stabilizer].
	self error: 'what?'.
	^ answer! !

!LinearGroup methodsFor: 'private' stamp: 'len 9/26/2018 23:06:48'!
space: aFreeModule
	self propertyAt: #space put: aFreeModule! !

!LinearGroup methodsFor: 'private' stamp: 'len 9/26/2018 22:03:45'!
species
	^ LinearGroup! !

!LinearGroup class methodsFor: 'examples' stamp: 'len 5/10/2019 09:33:08'!
C3
	"Cyclic matrix group of order 3."
	^ (ZZ/5 ^ 2) automorphisms span: #((0 1 -1 -1))! !

!LinearGroup class methodsFor: 'examples' stamp: 'len 5/10/2019 09:34:09'!
C4
	"Cyclic matrix group of order 4."
	^ (ZZ/7 ^ 2) automorphisms span: #((0 -1 1 0))! !

!LinearGroup class methodsFor: 'examples' stamp: 'len 5/10/2019 09:33:29'!
D8
	"Dihedral group of order 8."
	^ (ZZ/3 ^ 2) automorphisms span: #((0 1 2 0) (1 0 0 2))! !

!LinearGroup class methodsFor: 'examples' stamp: 'len 5/10/2019 09:34:27'!
GL
	"The general linear group of 3x3 invertible matrices with rational coefficients."
	^ (QQ^3) automorphisms! !

!LinearGroup class methodsFor: 'examples' stamp: 'len 5/10/2019 09:35:56'!
klein
	"The Klein four-group (or Vierergruppe) as a linear group."
	^ (ZZ^2) automorphisms span: #((1 0 0 -1) (-1 0 0 1))! !

!LinearGroup class methodsFor: 'instance creation' stamp: 'len 9/25/2018 17:21:17'!
generators: aCollection
	| aMatrix |
	aMatrix _ aCollection anyOne.
	^ self on: aMatrix scalars ^ aMatrix height generators: aCollection! !

!LinearGroup class methodsFor: 'instance creation' stamp: 'len 9/26/2018 23:06:05'!
new: anInteger over: aRing
	^ self on: aRing ^ anInteger! !

!LinearGroup class methodsFor: 'instance creation' stamp: 'len 9/26/2018 23:02:04'!
on: aFreeModule
	^ self new space: aFreeModule! !

!LinearGroup class methodsFor: 'instance creation' stamp: 'len 9/26/2018 22:23:58'!
on: aFreeModule generators: aCollection
	^ (GeneralLinearGroup on: aFreeModule) span: aCollection! !

!GeneralLinearGroup methodsFor: 'accessing' stamp: 'len 6/24/2016 08:44'!
ambient
	^ self! !

!GeneralLinearGroup methodsFor: 'accessing' stamp: 'len 9/27/2018 20:51:34'!
size
	| q n |
	(self scalars isField and: [self scalars isFinite])
		ifFalse: [^ super size].
	q _ self scalars size.
	n _ self dimension .
	^ q ^ (n*(n-1)/2) * ((1 to: n) inject: 1 into: [:x :k| q^k - 1 * x])! !

!GeneralLinearGroup methodsFor: 'comparing' stamp: 'len 9/26/2018 22:04:18'!
>= anObject
	(anObject isKindOf: LinearGroup) ifFalse: [^ super >= anObject].
	^ self scalars >= anObject scalars and: [self degree = anObject degree]! !

!GeneralLinearGroup methodsFor: 'converting' stamp: 'len 5/15/2019 01:46:22'!
toAlgebraicVariety
	| n P det V |
	self scalars isField ifFalse: [self notYetImplemented].
	n _ self degree.
	P _ self scalars polynomialsIn: n squared + 1.
	det _ (P matrix: n coefficients: P generators) determinant.
	V _ (P * (det * (P x: n squared + 1) - P one)) variety.
	^ Function
		from: self to: V
		evaluating: [:M| V !! (M asTuple, M determinant reciprocal)]
		inverseEvaluating: [:p| p scalars matrix: n coefficients: p coordinates]! !

!GeneralLinearGroup methodsFor: 'elements' stamp: 'len 9/28/2018 07:06:24'!
!! anObject
	(anObject isKindOf: SequenceableCollection)
		ifTrue: [^ self space endomorphisms !! (self scalars matrix: self degree coefficients: (anObject collect: [:each| self scalars !! each]))].
	^ self space endomorphisms !! anObject "ifNil: [^ super !! anObject]"! !

!GeneralLinearGroup methodsFor: 'enumerating' stamp: 'len 5/16/2019 12:41:22'!
do: aBlock
	((self hasProperty: #elements) or: [self hasProperty: #generators])
		ifTrue: [^ super do: aBlock].
	self space endomorphisms do: [:each| each isIsomorphism ifTrue: [aBlock value: each]]! !

!GeneralLinearGroup methodsFor: 'operations' stamp: 'len 9/26/2018 23:00:56'!
center
	^ ScalarGroup on: self space! !

!GeneralLinearGroup methodsFor: 'operations' stamp: 'len 9/26/2018 23:01:03'!
commutator
	(self degree = 2 and: [self scalars size = 2])
		ifFalse: [^ SpecialLinearGroup on: self space].
	^ self propertyAt: #commutator! !

!GeneralLinearGroup methodsFor: 'operations' stamp: 'len 9/26/2018 23:00:39'!
orthogonal
	^ OrthogonalGroup on: self space! !

!GeneralLinearGroup methodsFor: 'operations' stamp: 'len 9/26/2018 22:53:03'!
span: aCollection
	^ self copyEmpty generators: (aCollection collect: [:each| self !! each])! !

!GeneralLinearGroup methodsFor: 'operations' stamp: 'len 9/26/2018 23:01:08'!
special
	"Answer the special linear group SL(n) which is a subgroup of the receiver."
	^ SpecialLinearGroup on: self space! !

!GeneralLinearGroup methodsFor: 'printing' stamp: 'len 2/11/2016 05:04'!
shortName
	^ 'GL'! !

!GeneralLinearGroup methodsFor: 'random' stamp: 'len 5/16/2019 12:41:45'!
atRandom: aRandom
	| answer |
	[(answer _ self space endomorphisms atRandom: aRandom) isIsomorphism] whileFalse.
	^ answer! !

!GeneralLinearGroup methodsFor: 'random' stamp: 'len 5/16/2019 12:41:35'!
atRandom: aRandom bits: bitSize
	| answer |
	[(answer _ self space endomorphisms atRandom: aRandom bits: bitSize) isIsomorphism] whileFalse.
	^ answer! !

!GeneralLinearGroup methodsFor: 'testing' stamp: 'len 9/27/2018 20:55:25'!
contains: anElement
	^ true! !

!GeneralLinearGroup methodsFor: 'testing' stamp: 'len 5/16/2019 12:41:03'!
includes: anObject
	^ (anObject isKindOf: FreeModuleMap) and: [anObject domain = self space and: [anObject isAutomorphism]]! !

!OrthogonalGroup methodsFor: 'as yet unclassified' stamp: 'len 9/25/2018 16:54:40'!
affine
	^ EuclideanGroup on: self space! !

!OrthogonalGroup methodsFor: 'as yet unclassified' stamp: 'len 9/27/2018 21:02:26'!
reflectionAt: aVector
	"Answer the orthogonal reflection with mirror hyperplane perpendicular to aVector."

	^ self space endomorphisms
		evaluating: [:v| v - ((self space innerProduct value: {v. aVector}) * 2 / (self space innerProduct value: {aVector. aVector}) * aVector)]! !

!OrthogonalGroup methodsFor: 'operations' stamp: 'len 9/25/2018 17:16:53'!
special
	^ SpecialOrthogonalGroup on: self space! !

!OrthogonalGroup methodsFor: 'printing' stamp: 'len 2/11/2016 05:14'!
shortName
	^ 'O'! !

!OrthogonalGroup methodsFor: 'random' stamp: 'len 9/26/2018 21:57:15'!
atRandom: aRandom
	| answer v |
	answer _ self identity.
	self space dimension "heuristic"
		timesRepeat:
			[[(v _ self space atRandom: aRandom) isZero] whileTrue.
			answer _ answer * (self reflectionAt: v)].
	^ answer! !

!OrthogonalGroup methodsFor: 'random' stamp: 'len 5/6/2019 03:49:45'!
atRandom: aRandom bits: bitSize
	| answer v |
	answer _ self identity.
	self space dimension "heuristic"
		timesRepeat:
			[[(v _ self space atRandom: aRandom bits: bitSize // self space dimension) isZero] whileTrue.
			answer _ answer  (self reflectionAt: v)].
	^ answer! !

!OrthogonalGroup methodsFor: 'testing' stamp: 'len 12/13/2016 07:13:52'!
contains: aMatrix
	"Answer true if the receiver contains the given element of its ambient."
	^ aMatrix isOrthogonal! !

!ScalarGroup methodsFor: 'accessing' stamp: 'len 2/12/2016 02:18'!
dimension
	^ 1! !

!ScalarGroup methodsFor: 'enumerating' stamp: 'len 12/8/2016 11:16:31'!
do: aBlock
	self scalars do: [:each| aBlock value: (self scalars matrix: self degree scalar: each)]! !

!ScalarGroup methodsFor: 'operations' stamp: 'len 9/25/2018 17:17:22'!
special
	^ SpecialScalarGroup on: self space! !

!ScalarGroup methodsFor: 'printing' stamp: 'len 2/11/2016 05:21'!
shortName
	^ 'Z'! !

!ScalarGroup methodsFor: 'random' stamp: 'len 9/27/2018 21:05:06'!
atRandom: aRandom
	| a |
	[a _ self scalars atRandom: aRandom. a isZero] whileTrue.
	^ self identity * a! !

!ScalarGroup methodsFor: 'random' stamp: 'len 9/27/2018 21:06:01'!
atRandom: aRandom bits: bitSize
	| a |
	[a _ self scalars atRandom: aRandom bits: bitSize. a isZero] whileTrue.
	^ self identity * a! !

!ScalarGroup methodsFor: 'testing' stamp: 'len 5/13/2019 14:05:30'!
contains: aFreeModuleMap
	"Answer true if the receiver contains the given element of its ambient."
	^ aFreeModuleMap isScalar! !

!ScalarGroup methodsFor: 'testing' stamp: 'len 12/8/2016 11:16:42'!
isCommutative
	^ self scalars isCommutative! !

!SpecialLinearGroup methodsFor: 'operations' stamp: 'len 5/15/2019 01:51:58'!
asAlgebraicVariety
	| n P det |
	n _ self degree.
	P _ self scalars polynomialsIn: n squared.
	det _ (P matrix: n evaluating: [:i :j| P x: i - 1 * n + j]) determinant.
	^ (P * (det - self scalars one)) variety! !

!SpecialLinearGroup methodsFor: 'operations' stamp: 'len 9/25/2018 17:17:31'!
center
	^ SpecialScalarGroup on: self space! !

!SpecialLinearGroup methodsFor: 'printing' stamp: 'len 2/11/2016 05:20'!
shortName
	^ 'SL'! !

!SpecialLinearGroup methodsFor: 'testing' stamp: 'len 5/13/2019 14:05:35'!
contains: aFreeModuleMap
	"Answer true if the receiver contains the given element of its ambient."
	^ aFreeModuleMap determinant = self scalars one! !

!SpecialOrthogonalGroup methodsFor: 'as yet unclassified' stamp: 'len 9/25/2018 16:54:01'!
affine
	^ SpecialEuclideanGroup on: self space affine! !

!SpecialOrthogonalGroup methodsFor: 'printing' stamp: 'len 2/11/2016 05:20'!
shortName
	^ 'SO'! !

!SpecialOrthogonalGroup methodsFor: 'testing' stamp: 'len 5/13/2019 14:05:42'!
contains: aFreeModuleMap
	"Answer true if the receiver contains the given element of its ambient."
	^ aFreeModuleMap isOrthogonal and: [aFreeModuleMap determinant = self scalars one]! !

!SpecialScalarGroup methodsFor: 'printing' stamp: 'len 2/11/2016 05:38'!
shortName
	^ 'SZ'! !

!SpecialScalarGroup methodsFor: 'testing' stamp: 'len 5/13/2019 14:05:49'!
contains: aFreeModuleMap
	"Answer true if the receiver contains the given element of its ambient."
	^ aFreeModuleMap isScalar and: [aFreeModuleMap determinant = self scalars one]! !

!SpecialScalarGroup methodsFor: 'testing' stamp: 'len 12/8/2016 11:17:14'!
isCommutative
	^ self scalars isCommutative! !

!AffineGroup methodsFor: 'accessing' stamp: 'len 10/17/2016 11:04'!
action
	"Answer the natural action that sends (f, x) to f(x)."
	^ GroupAction from: (self, space) to: space evaluatingWithArguments: [:f :x| f value: x]! !

!AffineGroup methodsFor: 'accessing' stamp: 'len 9/26/2018 22:10:21'!
ambient
	^ GeneralAffineGroup on: self space! !

!AffineGroup methodsFor: 'accessing' stamp: 'len 2/11/2016 21:49'!
identity
	^ space id! !

!AffineGroup methodsFor: 'accessing' stamp: 'len 2/13/2016 07:47'!
scalars
	^ space scalars! !

!AffineGroup methodsFor: 'accessing' stamp: 'len 2/11/2016 05:45'!
space
	^ space! !

!AffineGroup methodsFor: 'accessing-private' stamp: 'len 2/11/2016 05:45'!
space: anAffineSpace
	space _ anAffineSpace! !

!AffineGroup methodsFor: 'operations' stamp: 'len 1/20/2018 22:40:00'!
asSemidirectProduct
	self notYetImplemented
"	^ SemidirectProductGroup left: space direction right: self linear action: self linear id"! !

!AffineGroup methodsFor: 'operations' stamp: 'len 12/28/2016 11:29:15'!
linear
	^ self propertyAt: #linear! !

!AffineGroup methodsFor: 'printing' stamp: 'len 4/18/2016 08:43'!
shortName
	^ self subclassResponsibility! !

!AffineGroup methodsFor: 'testing' stamp: 'len 5/22/2016 22:34'!
includes: anAffineMap
	^ self notYetImplemented! !

!AffineGroup methodsFor: 'private' stamp: 'len 2/12/2016 22:37'!
species
	^ AffineGroup! !

!AffineGroup class methodsFor: 'instance creation' stamp: 'len 2/11/2016 05:45'!
on: anAffineSpace
	^ self new space: anAffineSpace! !

!EuclideanGroup methodsFor: 'accessing' stamp: 'len 2/12/2016 01:40'!
dimension
	| n |
	n _ space dimension.
	^ n * (n + 1) / 2! !

!EuclideanGroup methodsFor: 'operations' stamp: 'len 2/12/2016 18:29'!
linear
	^ space direction automorphisms orthogonal! !

!EuclideanGroup methodsFor: 'operations' stamp: 'len 2/12/2016 18:37'!
special
	"Answer the special Euclidean group SE(A), the group of direct isometries, i.e. isometries preserving orientation, also called 'rigid motions'. This is a subgroup of the receiver."
	^ SpecialEuclideanGroup on: space! !

!EuclideanGroup methodsFor: 'printing' stamp: 'len 4/18/2016 08:40'!
shortName
	^ 'E'! !

!EuclideanGroup methodsFor: 'random' stamp: 'len 5/14/2016 09:08'!
atRandom: aRandom
	^ AffineMap linearPart: (space direction automorphisms orthogonal atRandom: aRandom) translation: (space atRandom: aRandom)! !

!EuclideanGroup methodsFor: 'random' stamp: 'len 5/14/2016 09:08'!
atRandom: aRandom bits: bitSize
	| n |
	n _ bitSize sqrtFloor.
	^ AffineMap linearPart: (space direction automorphisms orthogonal atRandom: aRandom bits: bitSize - n) translation: (space atRandom: aRandom bits: n)! !

!EuclideanGroup methodsFor: 'testing' stamp: 'len 2/12/2016 01:38'!
includes: anAffineMap
	^ anAffineMap domain = space and: [anAffineMap isEndomorphism and: [anAffineMap isIsometry]]! !

!GeneralAffineGroup methodsFor: 'operations' stamp: 'len 2/12/2016 18:28'!
euclidean
	"Answer the Euclidean group E(A), the group of isometries, i.e. distance-preserving morphisms, also called 'motionss'. This is a subgroup of the receiver."
	^ EuclideanGroup on: space! !

!GeneralAffineGroup methodsFor: 'operations' stamp: 'len 2/12/2016 18:30'!
linear
	^ space direction automorphisms! !

!GeneralAffineGroup methodsFor: 'operations' stamp: 'len 2/12/2016 18:49'!
special
	^ SpecialAffineGroup on: space! !

!GeneralAffineGroup methodsFor: 'printing' stamp: 'len 4/18/2016 08:39'!
shortName
	^ 'GA'! !

!GeneralAffineGroup methodsFor: 'random' stamp: 'len 5/20/2018 16:20:50'!
atRandom: aRandom
	^ (space direction automorphisms atRandom: aRandom) + (space atRandom: aRandom)! !

!GeneralAffineGroup methodsFor: 'random' stamp: 'len 5/20/2018 16:21:13'!
atRandom: aRandom bits: bitSize
	| n |
	n _ bitSize sqrtFloor.
	^ (self space automorphisms atRandom: aRandom bits: bitSize - n) + (self space atRandom: aRandom bits: n)! !

!GeneralAffineGroup methodsFor: 'testing' stamp: 'len 5/22/2016 22:35'!
includes: anAffineMap
	^ anAffineMap domain = space and: [anAffineMap isEndomorphism and: [anAffineMap isMonomorphism]]! !

!SpecialAffineGroup methodsFor: 'operations' stamp: 'len 9/25/2018 17:15:59'!
linear
	^ SpecialLinearGroup on: space direction! !

!SpecialAffineGroup methodsFor: 'printing' stamp: 'len 4/18/2016 08:40'!
shortName
	^ 'SA'! !

!SpecialAffineGroup methodsFor: 'testing' stamp: 'len 2/12/2016 18:55'!
includes: anAffineMap
	^ anAffineMap domain = space and: [anAffineMap isEndomorphism and: [anAffineMap matrix determinant = space scalars one]]! !

!SpecialEuclideanGroup methodsFor: 'operations' stamp: 'len 2/12/2016 18:38'!
linear
	^ space direction rotations! !

!SpecialEuclideanGroup methodsFor: 'printing' stamp: 'len 4/18/2016 08:40'!
shortName
	^ 'SE'! !

!SpecialEuclideanGroup methodsFor: 'testing' stamp: 'len 2/12/2016 01:44'!
includes: anAffineMap
	^ anAffineMap domain = space and: [anAffineMap isEndomorphism and: [anAffineMap isIsometry and: [anAffineMap matrix determinant = space scalars one]]]! !

!UnitGroup methodsFor: 'accessing' stamp: 'len 5/6/2019 02:38:25'!
action
	"Answer the natural action that sends (u, x) to x*u, i.e. multiplies ring elements by units."
	^ GroupAction from: (self, self space) to: self space evaluatingWithArguments: [:u :x| x*u]! !

!UnitGroup methodsFor: 'accessing' stamp: 'len 5/6/2019 02:41:34'!
identity
	^ self space one! !

!UnitGroup methodsFor: 'accessing' stamp: 'len 5/6/2019 02:38:35'!
space
	^ self propertyAt: #space! !

!UnitGroup methodsFor: 'enumerating' stamp: 'len 5/6/2019 02:41:07'!
do: aBlock
	self space unitsDo: aBlock! !

!UnitGroup methodsFor: 'testing' stamp: 'len 5/6/2019 02:40:05'!
contains: anElement
	^ self space isUnit: anElement! !

!UnitGroup methodsFor: 'testing' stamp: 'len 5/6/2019 02:40:22'!
includes: anElement
	^ (self space includes: anElement) and: [self space isUnit: anElement]! !

!UnitGroup methodsFor: 'private' stamp: 'len 5/6/2019 02:38:58'!
space: aRing
	self propertyAt: #space put: aRing! !

!UnitGroup class methodsFor: 'instance creation' stamp: 'len 5/6/2019 02:39:49'!
on: aRing
	^ self new space: aRing! !

!ModularIntegerUnitGroup methodsFor: 'accessing' stamp: 'len 5/6/2019 02:41:44'!
generator
	^ self space primitiveRoot! !

!ModularIntegerUnitGroup methodsFor: 'accessing' stamp: 'len 6/11/2018 06:14:25'!
generators
	^ {self generator}! !

!ModularIntegerUnitGroup methodsFor: 'accessing' stamp: 'len 5/6/2019 02:41:40'!
modulus
	^ self space modulus! !

!ModularIntegerUnitGroup methodsFor: 'accessing' stamp: 'len 12/28/2016 11:31:26'!
size
	^ self propertyAt: #size ifAbsentPut: [self modulus phi]! !

!EllipticCurveGroup methodsFor: 'accessing' stamp: 'len 9/28/2018 06:40:54'!
ambient
	^ self! !

!EllipticCurveGroup methodsFor: 'accessing' stamp: 'len 11/10/2016 08:06'!
curve
	^ curve! !

!EllipticCurveGroup methodsFor: 'accessing' stamp: 'len 12/14/2016 22:09:37'!
identity
	"This is the point at infinity."
	^ curve pointAt: (scalars tuple: {scalars zero. scalars one. scalars zero})! !

!EllipticCurveGroup methodsFor: 'accessing' stamp: 'len 11/10/2016 08:06'!
scalars
	^ scalars! !

!EllipticCurveGroup methodsFor: 'accessing' stamp: 'len 4/2/2017 10:31:48'!
torsion
	"Answer the torsion subgroup of the receiver."
	"Henri Cohen, 'A Course in Computational Algebraic Number Theory', Algorithm 7.5.5."
"	| E b2 b4 b6 b8 discriminant |
	E _ self curve equation.
	b2 _ E b2.
	b4 _ E b4.
	b6 _ E b6.
	b8 _ E b8.
	discriminant _ E discriminant.
	points add: self identity.
	..."
	self notYetImplemented! !

!EllipticCurveGroup methodsFor: 'accessing-private' stamp: 'len 11/10/2016 08:11'!
curve: anEllipticCurve
	curve _ anEllipticCurve! !

!EllipticCurveGroup methodsFor: 'accessing-private' stamp: 'len 11/10/2016 08:11'!
scalars: aField
	scalars _ aField! !

!EllipticCurveGroup methodsFor: 'enumerating' stamp: 'len 11/10/2016 08:10'!
do: aBlock
	self curve pointsOver: self scalars do: aBlock! !

!EllipticCurveGroup methodsFor: 'random' stamp: 'len 8/27/2018 22:24:49'!
atRandom: aRandom
	^ curve pointAtRandom: aRandom! !

!EllipticCurveGroup class methodsFor: 'instance creation' stamp: 'len 11/10/2016 08:11'!
on: anEllipticCurve over: aField
	^ self new curve: anEllipticCurve; scalars: aField! !

!DirichletGroup methodsFor: 'as yet unclassified' stamp: 'len 12/28/2016 11:30:39'!
codomain
	"Answer the codomain of the characters."
	^ self propertyAt: #codomain ifAbsentPut: [CyclotomicField new: self domain exponent]! !

!DirichletGroup methodsFor: 'as yet unclassified' stamp: 'len 12/28/2016 11:30:49'!
codomain: aCodomain
	self propertyAt: #codomain put: aCodomain! !

!DirichletGroup methodsFor: 'as yet unclassified' stamp: 'len 12/10/2016 13:34:53'!
decomposition
	| answer |
	answer _ OrderedCollection new.
	self modulus factors withOccurrencesDo:
		[:p :e| answer add: (self class new: p^e to: self codomain)].
	^ answer! !

!DirichletGroup methodsFor: 'as yet unclassified' stamp: 'len 12/28/2016 11:30:54'!
domain
	^ self propertyAt: #domain! !

!DirichletGroup methodsFor: 'as yet unclassified' stamp: 'len 12/10/2016 13:34:31'!
hash
	^ self domain hash hashMultiply + self codomain hash! !

!DirichletGroup methodsFor: 'as yet unclassified' stamp: 'len 12/9/2016 15:49:11'!
modulus
	^ self domain modulus! !

!DirichletGroup methodsFor: 'as yet unclassified' stamp: 'len 12/28/2016 11:30:44'!
modulus: anInteger
	self propertyAt: #domain put: (ZZ / anInteger) units! !

!DirichletGroup class methodsFor: 'instance creation' stamp: 'len 12/9/2016 15:51:30'!
new: anInteger
	^ self new modulus: anInteger! !

!DirichletGroup class methodsFor: 'instance creation' stamp: 'len 12/10/2016 13:26:28'!
new: anInteger to: aCodomain
	^ self new modulus: anInteger; codomain: aCodomain! !

!ArithmeticGroup methodsFor: 'as yet unclassified' stamp: 'len 5/6/2019 04:48:58'!
action
	^ GroupAction from: (self, CC) to: CC evaluatingWithArguments: [:f :z| f value: z]! !

!ArithmeticGroup methodsFor: 'as yet unclassified' stamp: 'len 12/20/2016 12:20:53'!
ambient
	^ ModularGroup new! !

!ArithmeticGroup methodsFor: 'as yet unclassified' stamp: 'len 12/21/2016 16:04:00'!
identity
	^ ModularMap I! !

!ArithmeticGroup methodsFor: 'as yet unclassified' stamp: 'len 12/21/2016 16:02:29'!
orderOf: aModularMap
	| trace |
	aModularMap isIdentity ifTrue: [^ 1].
	"aModularMap negated isIdentity ifTrue: [^ 2]."
	trace _ aModularMap trace.
	(trace <= -2 or: [trace >= 2]) ifTrue: [^ Infinity positive].
	trace == 1 ifTrue: [^ 6].
	trace == -1 ifTrue: [^ 3].
	"trace == 0"
	^ 4! !

!ArithmeticGroup methodsFor: 'as yet unclassified' stamp: 'len 12/19/2016 23:21:34'!
size
	^ Aleph new! !

!ArithmeticGroup methodsFor: 'as yet unclassified' stamp: 'len 12/21/2016 16:01:59'!
upperHalfPlaneAction
	^ GroupAction from: (self, HH) to: HH evaluating: [:f :z| f value: z]! !

!CongruenceSubgroup methodsFor: 'accessing' stamp: 'len 12/28/2016 11:29:40'!
level
	^ self propertyAt: #level! !

!CongruenceSubgroup methodsFor: 'accessing-private' stamp: 'len 12/28/2016 11:29:48'!
level: anInteger
	self propertyAt: #level put: anInteger! !

!CongruenceSubgroup methodsFor: 'as yet unclassified' stamp: 'len 12/15/2016 23:14:57'!
indexOf: aSubgroup
	^ (aSubgroup isKindOf: CongruenceSubgroup) ifTrue: [aSubgroup index / self index] ifFalse: [super indexOf: aSubgroup]! !

!CongruenceSubgroup methodsFor: 'operations' stamp: 'len 12/11/2016 07:51:01'!
curve
	"Answer the modular curve associated to the receiver. This is the orbit space of H/G (the upper half plane modulo the receiver) compactified canonically by adding the cusps."
	^ self notYetImplemented! !

!CongruenceSubgroup methodsFor: 'operations' stamp: 'len 12/7/2016 12:06:58'!
cusps
	"Answer the set of cusps of the receiver, i.e. the set of orbits of P^1(Q) under the action of the group. This set is finite."
	^ self notYetImplemented! !

!CongruenceSubgroup methodsFor: 'operations' stamp: 'len 12/11/2016 07:51:21'!
genus
	^ self curve genus
"(1 + projectiveIndex) / 12 - nu2 / 4 - nu3 / 4 - ncusps/2"! !

!CongruenceSubgroup methodsFor: 'operations' stamp: 'len 12/11/2016 07:57:22'!
widthOf: aCusp
	"Algorithm 1.19 (Width of a cusp) in Stein's 'Modular Forms, A Computational Approach'."
	| gamma |
	aCusp isInfinite
		ifTrue:
			[gamma _ self identity]
		ifFalse:
			[| a b xgcd |
			a _ aCusp numerator.
			b _ aCusp denominator.
			xgcd _ a xgcd: b.
			gamma _ Matrix rows: {ZZ tuple: {a. b}. ZZ tuple: {xgcd at: 2. xgcd at: 3}}].
	"..."! !

!CongruenceSubgroup methodsFor: 'testing' stamp: 'len 6/2/2018 17:59:42'!
isEven
	self flag: #fix. "this makes sense for the homogeneous group only, ~ SL(2,Z)"
	^ self includes: self identity negated! !

!CongruenceSubgroup methodsFor: 'testing' stamp: 'len 6/2/2018 17:59:51'!
isOdd
	self flag: #fix. "this makes sense for the homogeneous group only, ~ SL(2,Z)"
	^ self even not! !

!CongruenceSubgroup class methodsFor: 'instance creation' stamp: 'len 12/7/2016 11:56:57'!
new: anInteger
	^ self new level: anInteger! !

!Gamma0CongruenceSubgroup methodsFor: 'as yet unclassified' stamp: 'len 12/10/2016 12:24:21'!
even
	^ true! !

!Gamma0CongruenceSubgroup methodsFor: 'as yet unclassified' stamp: 'len 12/10/2016 12:09:18'!
index
	"Answer the index of the receiver in the modular group."
	| answer |
	answer _ 1.
	self level factors withOccurrencesDo: [:p :e| answer _ answer * (p ^ e + (p ^ (e - 1)))].
	^ answer
	! !

!Gamma0CongruenceSubgroup methodsFor: 'as yet unclassified' stamp: 'len 12/10/2016 12:19:31'!
numberOfCusps
	| n |
	n _ self level.
	^ n divisors sum: [:d| (d gcd: n // d) phi]! !

!Gamma1CongruenceSubgroup methodsFor: 'as yet unclassified' stamp: 'len 12/10/2016 12:28:30'!
even
	^ self level = 1 or: [self level = 2]! !

!PrincipalCongruenceSubgroup methodsFor: 'as yet unclassified' stamp: 'len 12/15/2016 23:02:54'!
* aGroup
	(aGroup isKindOf: PrincipalCongruenceSubgroup)
		ifFalse: [^ super * aGroup].
	^ self class new: (self level gcd: aGroup level)! !

!PrincipalCongruenceSubgroup methodsFor: 'as yet unclassified' stamp: 'len 5/10/2019 04:33:25'!
/\ aGroup
	"Answer the intersection of the receiver and the argument."
	(aGroup isKindOf: PrincipalCongruenceSubgroup)
		ifFalse: [^ super /\ aGroup].
	^ self class new: (self level lcm: aGroup level)! !

!PrincipalCongruenceSubgroup methodsFor: 'as yet unclassified' stamp: 'len 12/10/2016 11:29:07'!
index
	"Answer the index of the receiver in the modular group."
	| answer |
	answer _ 1.
	self level factors withOccurrencesDo: [:p :e| answer _ answer * (p ^ (e*3 - 2) * (p*p - 1))].
	^ answer! !

!PrincipalCongruenceSubgroup methodsFor: 'as yet unclassified' stamp: 'len 12/10/2016 11:33:56'!
numberOfCusps
	| count |
	self level = 1 ifTrue: [^ 1].
	self level = 2 ifTrue: [^ 3].
	count _ 1.
	self level factors withOccurrencesDo: [:p :e| count _ count * (p ^ (e*2) - (p ^ (e*2 - 2)))].
	^ count // 2! !

!PrincipalCongruenceSubgroup methodsFor: 'as yet unclassified' stamp: 'len 12/10/2016 11:34:29'!
numberOfIrregularCusps
	^ 0! !

!ModularGroup methodsFor: 'as yet unclassified' stamp: 'len 12/24/2016 12:06:20'!
S
	^ ModularMap S! !

!ModularGroup methodsFor: 'as yet unclassified' stamp: 'len 12/24/2016 12:06:24'!
T
	^ ModularMap T! !

!ModularGroup methodsFor: 'as yet unclassified' stamp: 'len 12/24/2016 12:08:05'!
T: n
	^ ModularMap a: 1 b: n c: 0 d: 1! !

!ModularGroup methodsFor: 'as yet unclassified' stamp: 'len 12/21/2016 16:06:26'!
generators
	^ {ModularMap T. ModularMap S}! !

!ModularGroup methodsFor: 'as yet unclassified' stamp: 'len 12/11/2016 07:53:49'!
level
	^ 1! !

!ModularGroup methodsFor: 'as yet unclassified' stamp: 'len 12/11/2016 07:53:46'!
level: anInteger
	^ self shouldNotImplement! !

!ModularGroup methodsFor: 'as yet unclassified' stamp: 'len 5/5/2019 18:32:12'!
reduce: aPoint
	"Given a point in the upper half plane, return an element of the receiver that maps the point to a representative in the standard fundamental domain.
	Reference: Henri Cohen, 'A Course in Computational Algebraic Number Theory', Algorithm 7.4.2."
	| tau A n m |
	tau _ aPoint.
	A _ self identity.
	[n _ tau real rounded.
	tau _ tau - n.
	A _ (self T: n negated)  A.
	m _ tau * tau conjugated.
	m >= 1 ifTrue: [^ {tau. A}].
	tau _ tau conjugated negated / m.
	A _ self S  A] repeat! !

!CoxeterGroup methodsFor: 'as yet unclassified' stamp: 'len 4/18/2016 01:25'!
diagram
	^ diagram! !

!CoxeterGroup methodsFor: 'as yet unclassified' stamp: 'len 4/18/2016 01:24'!
diagram: aGraph
	diagram _ aGraph! !

!CoxeterGroup methodsFor: 'as yet unclassified' stamp: 'len 4/18/2016 01:39'!
gramMatrix
	^ self matrix collect: [:x| -2 * (Float pi / x) cos]! !

!CoxeterGroup methodsFor: 'as yet unclassified' stamp: 'len 4/18/2016 01:39'!
isHyperbolic
	^ (self gramMatrix spectrum count: [:each| each negative]) = 1! !

!CoxeterGroup methodsFor: 'as yet unclassified' stamp: 'len 5/10/2019 09:57:34'!
presentation
	self notYetImplemented
"	| generators relators |
	generators _ diagram values collect: [:each| Word x: each].
	relators _ OrderedCollection new.
	diagram edgesAndLabelsDo: [:each :label|
		label isInfinity
			ifFalse: [relators add: (Word x: each key) * (Word x: each value) ^ (label ifNil: [3])]].
	^ GroupPresentation generators: generators relators: relators"! !

!CoxeterGroup class methodsFor: 'as yet unclassified' stamp: 'len 4/18/2016 01:25'!
diagram: aGraph
	^ self new diagram: aGraph! !

!CoxeterGroup class methodsFor: 'as yet unclassified' stamp: 'len 4/5/2018 15:26:58'!
matrix: aMatrix
	| n graph |
	n _ aMatrix width.
	graph _ Graph unorderedLabeled.
	graph addAll: (1 to: n).
	1 to: n do: [:i|
		1 to: n do: [:j|
			| m |
			m _ aMatrix at: i@j.
			m = 3 ifTrue: [graph addEdgeFrom: i to: j label: nil].
			m > 3 ifTrue: [graph addEdgeFrom: i to: j label: m]]].
	^ self diagram: graph! !

!Semiring methodsFor: 'accessing' stamp: 'len 2/22/2017 21:27:02'!
addition
	^ ((self, self) to: self evaluatingWithArguments: [:x :y| x + y]) name: '+'! !

!Semiring methodsFor: 'accessing' stamp: 'len 10/4/2018 00:12:36'!
additionInverse
	^ (self to: self evaluating: [:each| each negated]) name: '-id'! !

!Semiring methodsFor: 'accessing' stamp: 'len 2/22/2017 21:27:13'!
characteristic
	^ self propertyAt: #characteristic! !

!Semiring methodsFor: 'accessing' stamp: 'len 2/22/2017 21:27:20'!
multiplication
	^ ((self, self) to: self evaluatingWithArguments: [:x :y| x * y]) name: '*'! !

!Semiring methodsFor: 'accessing' stamp: 'len 10/4/2018 00:12:22'!
multiplicationInverse
	^ (self to: self evaluating: [:each| each reciprocal]) name: 'x^-1'! !

!Semiring methodsFor: 'accessing' stamp: 'len 2/22/2017 21:30:29'!
one
	^ self propertyAt: #one ifAbsentPut: [self generators anyOne one]! !

!Semiring methodsFor: 'accessing' stamp: 'len 5/17/2018 18:47:22'!
scalars
	"Because the ring of rational integers is the initial object in the category of rings.
	Subclasses can override."
	^ ZZ! !

!Semiring methodsFor: 'accessing' stamp: 'len 2/22/2017 21:30:34'!
zero
	^ self propertyAt: #zero ifAbsentPut: [self one - self one]! !

!Semiring methodsFor: 'morphic' stamp: 'len 9/22/2018 19:00:23'!
additionTable
	^ MultiplicationTableMorph elements: self elements asArray operation: self addition! !

!Semiring methodsFor: 'morphic' stamp: 'len 9/22/2018 19:00:20'!
multiplicationTable
	^ MultiplicationTableMorph elements: self elements asArray operation: self multiplication! !

!Ring methodsFor: 'accessing' stamp: 'len 9/23/2018 01:53:06'!
dimension
	"Answer the Krull dimension of the receiver. This is the length of the longest ascending chain of prime ideals."
	self isField ifTrue: [^ 0].
	self isPID ifTrue: [^ 1].
	self isIntegralDomain ifTrue: [^ 1].
	self isDedekindDomain ifTrue: [^ 1].
	^ self propertyAt: #dimension! !

!Ring methodsFor: 'accessing' stamp: 'len 6/4/2019 04:56:41'!
euclideanFunction
	"Answer the Euclidean function of the receiver, if it is an Euclidean domain."
	^ self propertyAt: #euclideanFunction! !

!Ring methodsFor: 'accessing' stamp: 'len 5/20/2018 22:37:12'!
maximalIdeal
	"If the receiver is a local ring, answer the unique maximal ideal."
	self isDivisionRing ifTrue: [^ self zeroIdeal].
	self subclassResponsibility! !

!Ring methodsFor: 'accessing' stamp: 'len 4/30/2019 04:14:30'!
one
	^ self propertyAt: #one ifAbsentPut: [self generators anyOne one]! !

!Ring methodsFor: 'converting' stamp: 'len 8/29/2016 16:30'!
asIdeal
	"Answer the receiver R viewed as an ideal of itself."
	^ self * self one! !

!Ring methodsFor: 'converting' stamp: 'len 4/26/2019 12:56:07'!
asSelfModule
	"Answer the receiver R viewed as R-module."
	^ RingModule over: self! !

!Ring methodsFor: 'elements' stamp: 'len 5/23/2018 22:47:35'!
!! anObject
	anObject isInteger ifTrue: [^ self one * anObject].
	anObject isFraction ifTrue: [^ (self one * anObject numerator) / (self one * anObject denominator)].
	(anObject isKindOf: Ideal) ifTrue: [^ self * (anObject generators collect: [:each| self !! each])].
	^ super !! anObject! !

!Ring methodsFor: 'elements-matrices' stamp: 'len 5/15/2019 02:12:12'!
diagonalMatrix: anArray
	^ self matrix: anArray size @ anArray size evaluatingDiagonal: [:i| anArray at: i]! !

!Ring methodsFor: 'elements-matrices' stamp: 'len 3/1/2017 11:26:46'!
identityMatrix: dimension
	^ self matrix: dimension scalar: self one! !

!Ring methodsFor: 'elements-matrices' stamp: 'len 4/4/2018 00:03:12'!
matrix: aCollection
	^ Matrix rows: (aCollection collect: [:each| self tuple: each])! !

!Ring methodsFor: 'elements-matrices' stamp: 'len 12/13/2016 10:15:36'!
matrix: dimension coefficients: aCollection
	| stream |
	stream _ aCollection readStream.
	^ self matrix: dimension evaluating: [:i :j| stream next]! !

!Ring methodsFor: 'elements-matrices' stamp: 'len 12/11/2016 07:40:21'!
matrix: dimension evaluating: aBlock
	| n m |
	dimension isInteger ifTrue: [n _ m _ dimension] ifFalse: [n _ dimension x. m _ dimension y].
	^ Matrix rows: ((1 to: n) collect: [:i| self tuple: m evaluating: [:j| aBlock value: i value: j]])! !

!Ring methodsFor: 'elements-matrices' stamp: 'len 11/5/2016 06:10'!
matrix: dimension evaluatingDiagonal: aBlock
	| zero |
	zero _ self zero.
	^ self matrix: dimension evaluating: [:i :j| i == j ifTrue: [aBlock value: i] ifFalse: [zero]]! !

!Ring methodsFor: 'elements-matrices' stamp: 'len 11/5/2016 06:10'!
matrix: dimension scalar: anElement
	^ self matrix: dimension evaluatingDiagonal: [:i| anElement]! !

!Ring methodsFor: 'elements-matrices' stamp: 'len 3/1/2017 11:26:55'!
zeroMatrix: dimension
	^ self matrix: dimension scalar: self zero! !

!Ring methodsFor: 'elements-operations' stamp: 'len 9/25/2018 00:09:45'!
associatedUnit: anElement
	"Answer a choice for associated unit of anElement."
	(self isUnit: anElement) ifTrue: [^ anElement].
	anElement isZero ifTrue: [^ self one].
	^ self subclassResponsibility! !

!Ring methodsFor: 'elements-operations' stamp: 'len 6/5/2019 13:36:06'!
divide: anElement by: anotherElement
	"Answer the quotient and remainder of the division of anElement by anotherElement."
	^ {anElement // anotherElement. anElement \\ anotherElement}! !

!Ring methodsFor: 'elements-operations' stamp: 'len 6/5/2019 12:31:54'!
valuation: anElement
	"If the receiver is a valuation ring, answer the valuation of anElement."
	self isValuationRing ifFalse: [^ self shouldNotImplement].
	self subclassResponsibility! !

!Ring methodsFor: 'elements-testing' stamp: 'len 6/5/2019 17:18:21'!
isIrreducible: anElement
	"An nonzero element 'a' is called irreducible if a=bc implies that a|b (and then c is a unit) or a|c (and then b is a unit)."
	^ self subclassResponsibility! !

!Ring methodsFor: 'elements-testing' stamp: 'len 9/22/2018 18:59:19'!
isNilpotent: anElement
	"Answer true if anElement^n = 0 for some integer n >= 1."
	^ self nilradical contains: anElement! !

!Ring methodsFor: 'elements-testing' stamp: 'len 6/5/2019 17:17:06'!
isPrime: anElement
	"An nonzero element 'a' is called a prime if a|bc implies that a|b or a|c."
	^ self subclassResponsibility! !

!Ring methodsFor: 'elements-testing' stamp: 'len 9/16/2018 16:43:16'!
isUnit: anElement
	"Answer true if the argument is invertible."
	| one |
	self isDivisionRing ifTrue: [^ anElement isZero not].
	self isFinite ifFalse: [^ self notYetImplemented].
	one _ self one.
	^ self anySatisfy: [:any| anElement * any = one]! !

!Ring methodsFor: 'elements-testing' stamp: 'len 9/16/2018 17:56:27'!
isZeroDivisor: anElement
	"Answer true if there exists a nonzero element that multiplied by the argument is zero."
	self isIntegralDomain ifTrue: [^ anElement isZero].
	self isFinite ifFalse: [^ self notYetImplemented].
	^ self anySatisfy: [:any| any isZero not and: [(anElement * any) isZero]]! !

!Ring methodsFor: 'elements-tuples' stamp: 'len 5/15/2019 13:30:03'!
tuple: anArray
	^ GenericTuple coefficients: anArray over: self! !

!Ring methodsFor: 'elements-tuples' stamp: 'len 3/1/2017 11:28:27'!
tuple: anInteger e: index
	| zero |
	zero _ self zero.
	^ self tuple: anInteger evaluating: [:i| i = index ifTrue: [self one] ifFalse: [zero]]! !

!Ring methodsFor: 'elements-tuples' stamp: 'len 5/8/2019 03:18:46'!
tuple: anInteger evaluating: aBlock
	| array |
	array _ Array new: anInteger.
	1 to: anInteger do: [:i| array at: i put: (aBlock value: i)].
	^ self tuple: array! !

!Ring methodsFor: 'elements-tuples' stamp: 'len 5/15/2019 13:30:03'!
tupleClass
	^ GenericTuple! !

!Ring methodsFor: 'elements-tuples' stamp: 'len 5/4/2019 07:45:16'!
zeroTuple: anInteger
	| zero |
	zero _ self zero.
	^ self tuple: anInteger evaluating: [:i| zero]! !

!Ring methodsFor: 'enumerating' stamp: 'len 9/22/2018 18:58:55'!
idealsDo: aBlock
	^ self subclassResponsibility! !

!Ring methodsFor: 'enumerating' stamp: 'len 9/22/2018 19:00:02'!
primeIdealsDo: aBlock
	self isField ifTrue: [aBlock value: self zeroIdeal. ^ self].
	self idealsDo: [:each| each isPrime ifTrue: [aBlock value: each]]! !

!Ring methodsFor: 'enumerating' stamp: 'len 5/19/2018 16:33:52'!
relevantPrimeIdealsDo: aBlock
	self primeIdealsDo: [:each| each isRelevant ifTrue: [aBlock value: each]]! !

!Ring methodsFor: 'enumerating' stamp: 'len 9/22/2018 19:00:06'!
unitsDo: aBlock
	self do: [:each| (self isUnit: each) ifTrue: [aBlock value: each]]! !

!Ring methodsFor: 'morphisms' stamp: 'len 10/18/2016 19:49'!
conjugation
	"Answer the companion automorphism of the receiver."
	^ self id! !

!Ring methodsFor: 'morphisms' stamp: 'len 10/10/2016 14:13'!
frobenius
	"Answer the Frobenius endomorphism, assuming the receiver is of characteristic p prime."
	| p |
	p _ self characteristic.
	^ self to: self evaluating: self polynomials x ^ p! !

!Ring methodsFor: 'morphisms' stamp: 'len 12/22/2016 22:01:49'!
to: aCodomain
	(aCodomain isRing and: [self isTrivial or: [aCodomain isTrivial]])
		ifTrue: [^ self to: aCodomain evaluating: [:x| aCodomain zero]].
	^ super to: aCodomain! !

!Ring methodsFor: 'morphisms' stamp: 'len 1/11/2018 17:38:20'!
to: aRing evaluating: aBlock
	aRing isRing ifFalse: [^ super to: aRing evaluating: aBlock].
	^ RingMap from: self to: aRing evaluating: aBlock! !

!Ring methodsFor: 'operations' stamp: 'len 4/26/2019 12:48:23'!
* anElementOrArray
	"Answer the ideal generated by the argument."
	(self includes: anElementOrArray)
		ifTrue: [^ self asSelfModule span: {anElementOrArray}].
	anElementOrArray isCollection
		ifTrue: [^ self asSelfModule span: anElementOrArray].
	^ self * (self !! anElementOrArray)! !

!Ring methodsFor: 'operations' stamp: 'len 1/15/2018 22:23:00'!
/ anIdeal
	"Answer the quotient by the given ideal.
	For convenience, the argument can be a single element or a collection of elements as well."
	| I |
	(anIdeal isKindOf: Ideal)
		ifTrue:
			[self = anIdeal scalars ifFalse: [^ DomainError signal: 'ideal belongs to a different ring'].
			I _ anIdeal]
		ifFalse:
			[I _ self * anIdeal].
	^ I quotientRing! !

!Ring methodsFor: 'operations' stamp: 'len 1/22/2017 08:19:59'!
^ n
"	n isInfinity ifTrue: [^ InfiniteTupleSpace over: self]."
	^ n isPoint ifTrue: [MatrixModule new: n over: self] ifFalse: [TupleModule new: n over: self]! !

!Ring methodsFor: 'operations' stamp: 'len 10/18/2016 17:43'!
 aRing
	^ ProductRing components: {self. aRing}! !

!Ring methodsFor: 'operations' stamp: 'len 12/28/2016 12:11:23'!
algebraicClosure
	self isAlgebraicallyClosed ifTrue: [^ self].
	^ self propertyAt: #algebraicClosure! !

!Ring methodsFor: 'operations' stamp: 'len 12/2/2016 11:13:43'!
cyclotomicRing: n
	"Answer the n-th cyclotomic ring on the receiver."
	| Fx phi |
	Fx _ self polynomials.
	phi _ Fx cyclotomic: n. "cyclotomic polynomial of order n"
	^ Fx / phi "answer the quotient ring modulo <phi>"! !

!Ring methodsFor: 'operations' stamp: 'len 6/6/2019 11:31:08'!
extension: aPolynomial
	"Answer the algebraic extension of the receiver defined by the given irreducible polynomial."
"	self isField ifFalse: [DomainError signal: 'not a field']."
	aPolynomial scalars = self ifFalse: [DomainError signal: 'polynomial coefficients not from this ring'].
	aPolynomial parent isUnivariate ifFalse: [DomainError signal: 'not univariate poylnomial'].
	^ AlgebraicExtensionRing polynomial: aPolynomial! !

!Ring methodsFor: 'operations' stamp: 'len 10/31/2016 05:46'!
extensionDegree: anInteger
	"Answer the algebraic extension of the receiver of the given degree. Choose any irreducible polynomial."
	^ self extension: (self polynomials findIrreducibleOfDegree: anInteger)! !

!Ring methodsFor: 'operations' stamp: 'len 4/30/2018 19:19:30'!
fractions
	"Answer the fraction ring of the receiver. If the receiver is an integral domain, the fraction ring will be a field."
	self isField ifTrue: [^ self].
	^ self propertyAt: #fractions ifAbsentPut: [FractionRing on: self]! !

!Ring methodsFor: 'operations' stamp: 'len 1/20/2016 13:42'!
freeAlgebra
	^ FreeAlgebra over: self! !

!Ring methodsFor: 'operations' stamp: 'len 5/11/2019 02:42:50'!
freeAlgebraIn: anIntegerOrCollection
	"Answer the free algebra in the given indeterminates over the receiver."
	anIntegerOrCollection isInteger ifTrue: [^ FreeAlgebra new: anIntegerOrCollection over: self].
	^ (FreeAlgebra new: anIntegerOrCollection size over: self) names: anIntegerOrCollection! !

!Ring methodsFor: 'operations' stamp: 'len 5/4/2019 03:38:05'!
freeModuleIn: aCollection
	"Answer the free module in the given indeterminates over the receiver."
	^ FreeSumsModule on: aCollection over: self! !

!Ring methodsFor: 'operations' stamp: 'len 4/30/2019 04:17:37'!
ideals
	^ Iterator on: self performing: #idealsDo:! !

!Ring methodsFor: 'operations' stamp: 'len 1/23/2018 21:19:27'!
localizationAt: aPrimeIdeal
	"Answer the localization of the receiver at aPrimeIdeal."
	| P |
	P _ (aPrimeIdeal isKindOf: Ideal)
		ifTrue:
			[self = aPrimeIdeal scalars ifFalse: [DomainError signal: 'ideal belongs to a different ring'].
			aPrimeIdeal]
		ifFalse:
			[self * aPrimeIdeal].
	^ LocalizationRing at: P! !

!Ring methodsFor: 'operations' stamp: 'len 11/22/2015 06:26'!
mod: anObject
	^ self / (self * anObject)! !

!Ring methodsFor: 'operations' stamp: 'len 5/21/2018 15:39:32'!
nilradical
	"Answer the ideal consisting of all nilpotent elements, i.e. all x such that there exists some n with x^n = 0. It is the intersection of all prime ideals."
	^ self zeroIdeal radical
	
"alternative:
	| answer |
	answer _ self oneIdeal.
	self primeIdealsDo: [:each| answer _ answer  each].
	^ answer"! !

!Ring methodsFor: 'operations' stamp: 'len 9/26/2016 17:05'!
oneIdeal
	^ self * self one! !

!Ring methodsFor: 'operations' stamp: 'len 5/8/2019 14:56:41'!
opposite
	self isCommutative ifTrue: [^ self].
	^ self propertyAt: #opposite ifAbsentPut: [OppositeRing opposite: self]! !

!Ring methodsFor: 'operations' stamp: 'len 5/15/2019 01:11:18'!
polynomials
	^ self polynomialsIn: #(x)! !

!Ring methodsFor: 'operations' stamp: 'len 2/12/2017 06:07:46'!
polynomialsIn: anIntegerOrCollection
	"Answer the ring of multivariate polynomials over the receiver in the given indeterminates."
	^ self polynomialsIn: anIntegerOrCollection ordering: #grevlex! !

!Ring methodsFor: 'operations' stamp: 'len 5/11/2019 02:41:23'!
polynomialsIn: anIntegerOrCollection ordering: aMonomialOrdering
	"Answer the ring of multivariate polynomials over the receiver over the given indeterminates."
	anIntegerOrCollection isInteger
		ifTrue: [^ PolynomialRing new: anIntegerOrCollection over: self ordering: aMonomialOrdering].
	^ (PolynomialRing new: anIntegerOrCollection size over: self ordering: aMonomialOrdering) names: anIntegerOrCollection! !

!Ring methodsFor: 'operations' stamp: 'len 6/2/2019 16:57:27'!
powerSeries
	^ self polynomials completion! !

!Ring methodsFor: 'operations' stamp: 'len 6/4/2019 18:50:35'!
radical
	"Answer the Jacobson radical J(R) of the receiver R. This is the ideal consisting of all elements that annihilate all simple R-modules. It is the intersection of all maximal ideals."
	| generators |
	self isLocal ifTrue: [^ self maximalIdeal].
	self isFinite ifFalse: [^ self notYetImplemented].
	generators _ Set new.
	self do: [:x| (self allSatisfy: [:y| self isUnit: self one - (x*y)]) ifTrue: [generators add: x]].
	^ self * generators

"alternative:
	| answer |
	answer _ self oneIdeal.
	self maximalIdealsDo: [:each| answer _ answer /\ each].
	^ answer"! !

!Ring methodsFor: 'operations' stamp: 'len 5/21/2018 16:32:33'!
residueField
	"If the receiver is a local ring R with unique maximal ideal M, this returns R/M."
	^ self / self maximalIdeal! !

!Ring methodsFor: 'operations' stamp: 'len 2/13/2017 07:44:41'!
spec
	"Answer the spectrum of the receiver, Spec(R)."
	self isCommutative ifFalse: [^ DomainError signal: 'not a commutative ring'].
	^ AffineScheme coordinateRing: self! !

!Ring methodsFor: 'operations' stamp: 'len 5/2/2019 08:03:00'!
units
	"Answer the multiplicative group of units of the receiver (i.e., elements that have multiplicative inverse).
	This is the natural functor from the cateogry of rings to the category of groups which sends each ring R to its group of units U(R) and each ring homomorphism to the restriction to U(R). This functor has a left adjoint which sends each group G to the integral group ring Z[G]."
	^ UnitGroup on: self! !

!Ring methodsFor: 'operations' stamp: 'len 4/7/2018 21:02:14'!
zeroDivisors
	^ self select: [:each| self isZeroDivisor: each]! !

!Ring methodsFor: 'operations' stamp: 'len 10/13/2016 20:05'!
zeroIdeal
	^ self * #()! !

!Ring methodsFor: 'testing' stamp: 'len 12/28/2016 12:09:46'!
isAlgebraicallyClosed
	^ self propertyAt: #isAlgebraicallyClosed ifAbsent: [false]! !

!Ring methodsFor: 'testing' stamp: 'len 9/22/2018 18:58:52'!
isArtinian
	"Answer true if the receiver is an Artinian ring, i.e. it satisfied the descending chain condition on ideals.
	In the non-commutative case one should talk about 'left Artinian' or 'right Artinian' rings."
	self isIntegralDomain ifTrue: [^ self isField].
	self isFinite ifTrue: [^ true].
	^ self propertyAt: #isArtinian! !

!Ring methodsFor: 'testing' stamp: 'len 6/4/2019 15:32:37'!
isBezout
	"Answer true if the receiver is a Bezout ring, i.e. every finitely generated ideal is principal."
	self isPIR ifTrue: [^ true].
	self propertyAt: #isBezout! !

!Ring methodsFor: 'testing' stamp: 'len 6/4/2019 15:27:20'!
isBezoutDomain
	"An integral domain is Bezout if any finitely generated ideal is principal.
	This is the constructive algebra approximation to PID, adding 'finitely generated'.
	1) Any Bezout domain is coherent;
	2) A Bezout domain is strongly discrete iff we can decide divisibility."
	self isEuclideanDomain ifTrue: [^ true].
	^ self isIntegralDomain and: [self isBezout]! !

!Ring methodsFor: 'testing' stamp: 'len 5/1/2019 17:33:39'!
isCoherent
	"Answer true if the receiver is a coherent ring, i.e. if it is coherent as a module over itself.
	A ring is coherent iff every finitely generated ideal is finitely presented as a module."
	(self isNoetherian or: [self isPruferDomain]) ifTrue: [^ true].
	^ self propertyAt: #isCoherent! !

!Ring methodsFor: 'testing' stamp: 'len 9/24/2018 06:18:18'!
isCommutative
	self isIntegralDomain ifTrue: [^ true].
	^ self propertyAt: #isCommutative! !

!Ring methodsFor: 'testing' stamp: 'len 6/4/2019 05:06:35'!
isDVR
	"Answer true if the receiver is a discrete valuation ring, i.e. a local PID that is not a field."
	^ self isLocal and: [self isPID and: [self isField not]]! !

!Ring methodsFor: 'testing' stamp: 'len 6/4/2019 07:43:57'!
isDedekindDomain
	"A Dedekind domain is an integral domain in which every non-zero proper ideal factors into a product of prime ideals."
	self isPID ifTrue: [^ true].
	^ self propertyAt: #isDedekindDomain! !

!Ring methodsFor: 'testing' stamp: 'len 12/28/2016 12:11:14'!
isDivisionRing
	"A division ring, or skewfield, is a ring where division is possible, i.e. every non-zero element has a multiplicative inverse. The only difference with a field is that a division ring is not requiered to be commutative."
	self isField ifTrue: [^ true].
	^ self propertyAt: #isDivisionRing ifAbsent: [false]! !

!Ring methodsFor: 'testing' stamp: 'len 9/22/2018 18:58:58'!
isEuclidean
	"Answer true if the receiver is an Euclidean ring, i.e. it has division with remainder."
	^ self propertyAt: #isEuclidean ifAbsent: [self isField]! !

!Ring methodsFor: 'testing' stamp: 'len 9/22/2018 18:59:01'!
isEuclideanDomain
	"Answer true if the receiver is an Euclidean domain, i.e. an integral domain that has division with remainder."
	^ self isIntegralDomain and: [self isEuclidean]! !

!Ring methodsFor: 'testing' stamp: 'len 12/28/2016 12:10:52'!
isField
	^ self propertyAt: #isField ifAbsent: [false]! !

!Ring methodsFor: 'testing' stamp: 'len 12/28/2016 12:10:57'!
isGCDDomain
	"A GCD domain is an integral domain with the property that any two non-zero elements have GCD (or equivalently any two non-zero elements have a LCM)."
	^ self propertyAt: #isGCDDomain! !

!Ring methodsFor: 'testing' stamp: 'len 9/17/2018 00:41:55'!
isGaloisField
	^ self isFinite and: [self isField]! !

!Ring methodsFor: 'testing' stamp: 'len 9/19/2018 07:15:55'!
isGaloisRing
	^ false! !

!Ring methodsFor: 'testing' stamp: 'len 1/26/2018 18:58:30'!
isGlobalField
	^ false! !

!Ring methodsFor: 'testing' stamp: 'len 11/2/2016 08:56'!
isInitial
	"In the cateogry of commutative rings with unit, the integers are the initial object. Redefined in Integers."
	^ false! !

!Ring methodsFor: 'testing' stamp: 'len 9/24/2018 06:22:20'!
isIntegralDomain
	"A ring is an integral domain if the product of any two non-zero elements is non-zero."
	self propertyAt: #isIntegralDomain ifPresent: [:aBoolean| ^ aBoolean].
	self isFinite ifTrue: [^ self propertyAt: #isIntegralDomain put: (self zeroDivisors allSatisfy: [:each| each isZero])].
	^ self isField! !

!Ring methodsFor: 'testing' stamp: 'len 12/28/2016 12:10:21'!
isIntegrallyClosedDomain
	"A ring is an integrally closed domain if it is an integral domain whose integral closure in its field of fractions is the ring itself."
	^ self propertyAt: #isIntegrallyClosedDomain ifAbsent: [self isUFD]! !

!Ring methodsFor: 'testing' stamp: 'len 5/20/2018 21:57:40'!
isLocal
	"Answer true if the receiver is a local ring. Subclasses should reimplement."
	^ self isDivisionRing! !

!Ring methodsFor: 'testing' stamp: 'len 1/26/2018 18:58:19'!
isLocalField
	^ false! !

!Ring methodsFor: 'testing' stamp: 'len 1/28/2018 22:20:23'!
isLocalization
	^ false! !

!Ring methodsFor: 'testing' stamp: 'len 6/4/2019 16:08:34'!
isNoetherian
	"Answer true if the receiver is a Noetherian ring, i.e. every ideal is finitely generated."
	self isFinite ifTrue: [^ true].
"	self isField ifTrue: [^ true]. already included in isPID"
	self isPID ifTrue: [^ true].
	self isDedekindDomain ifTrue: [^ true].
	^ self propertyAt: #isNoetherian! !

!Ring methodsFor: 'testing' stamp: 'len 5/5/2019 09:49:30'!
isPID
	"A principal ideal domain (PID) is an integral domain in which every ideal is principal, i.e. can be generated by a single element.
	PIDs are Noetherian, integrally closed, and they are UFDs and Dedekind domains.
	All Euclidean domains and all fields are PIDs."
	self isEuclideanDomain ifTrue: [^ true].
	^ self propertyAt: #isPID! !

!Ring methodsFor: 'testing' stamp: 'len 6/4/2019 15:57:30'!
isPIR
	"A principal ideal ring (PIR) is a ring in which every ideal is principal, i.e. can be generated by a single element."
	"Principal ideal rings are exactly the rings that are both Bezout and Noetherian:"
	^ self isBezout and: [self isNoetherian]! !

!Ring methodsFor: 'testing' stamp: 'len 5/5/2018 00:02:30'!
isPerfectField
	"A field is perfect if either it has characteristic 0 or has characteristic p and every element in the field has a p-th root in the field."
	self isField ifFalse: [^ false].
	(self characteristic = 0 or: [self isFinite]) ifTrue: [^ true].
	self isAlgebraicallyClosed ifTrue: [^ true].
	^ self propertyAt: #isPerfectField! !

!Ring methodsFor: 'testing' stamp: 'len 4/30/2019 08:16:28'!
isPruferDomain
	"A Prufer domain is a semihereditary integral domain, i.e. an integral domain R such that all finitely generated submodules of projective modules over R are again projective. Equivalently, a Prufer domain is a commutative ring without zero divisors in which every non-zero finitely generated ideal is invertible."
	^ self propertyAt: #isPruferDomain! !

!Ring methodsFor: 'testing' stamp: 'len 5/5/2018 00:37:48'!
isReduced
	"A ring is reduced if it has no non-zero nilpotents, i.e. if r^n = 0 for some n >> 0, then r = 0."
	self isIntegralDomain ifTrue: [^ true].
	^ self noneSatisfy: [:any| any squared isZero and: [any isZero not]]
	
"alternatively:
	^ self nilradical isZero"! !

!Ring methodsFor: 'testing' stamp: 'len 11/7/2015 22:01'!
isRing
	^ true! !

!Ring methodsFor: 'testing' stamp: 'len 9/22/2018 18:59:54'!
isSemilocal
	"A ring is called 'semilocal' if it contains a finite number of maximal ideals."
	self isFinite ifTrue: [^ true]. "Finite rings are semilocal."
	self isLocal ifTrue: [^ true]. "Local rings have 1 maximal ideal"
	^ self propertyAt: #isSemilocal! !

!Ring methodsFor: 'testing' stamp: 'len 11/2/2016 03:36'!
isTerminal
	^ self isTrivial! !

!Ring methodsFor: 'testing' stamp: 'len 11/2/2016 03:36'!
isTrivial
	"The trivial ring is the zero ring with a single element 0 = 1."
	^ self size = 1! !

!Ring methodsFor: 'testing' stamp: 'len 9/24/2018 06:17:18'!
isUFD
	"A unique factorization domain (UFD) is a commutative ring in which every non-zero non-unit element can be written as a product of prime elements (or irreducible elements), uniquely up to order and units."
	(self isPID or: [self isEuclideanDomain]) ifTrue: [^ true].
	^ self propertyAt: #isUFD! !

!Ring methodsFor: 'private' stamp: 'len 1/20/2018 18:12:11'!
fractionalIdealClass
	^ FractionalIdeal! !

!Ring methodsFor: 'private' stamp: 'len 10/30/2016 15:44'!
idealClass
	^ Ideal! !

!CompletionRing methodsFor: 'accessing' stamp: 'len 6/6/2019 11:56:17'!
base
	^ self completionIdeal scalars! !

!CompletionRing methodsFor: 'accessing' stamp: 'len 6/6/2019 11:11:18'!
completionIdeal
	^ self propertyAt: #completionIdeal! !

!CompletionRing methodsFor: 'accessing' stamp: 'len 6/6/2019 10:56:36'!
maximalIdeal
	"Answer the unique maximal ideal in the receiver."
	^ self * (self completionIdeal generators collect: [:each| self embed: each])! !

!CompletionRing methodsFor: 'operations' stamp: 'len 6/6/2019 11:59:39'!
jet: anInteger
	"Answer the anInteger-th jet of the receiver, that is the quotient ring isomorphic to the anInteger-th truncation of the receiver."
	^ self base / (self completionIdeal ^ anInteger)! !

!CompletionRing methodsFor: 'testing' stamp: 'len 6/6/2019 10:55:42'!
isLocal
	^ true! !

!CompletionRing methodsFor: 'private' stamp: 'len 6/6/2019 11:11:28'!
completionIdeal: anIdeal
	self propertyAt: #completionIdeal put: anIdeal! !

!CompletionRing class methodsFor: 'instance creation' stamp: 'len 6/6/2019 12:04:12'!
at: anIdeal
	^ self new completionIdeal: anIdeal! !

!AdicIntegerRing methodsFor: 'accessing' stamp: 'len 12/17/2016 20:31:49'!
characteristic
	^ 0! !

!AdicIntegerRing methodsFor: 'accessing' stamp: 'len 6/6/2019 11:19:30'!
fractions
	^ self propertyAt: #fractions ifAbsentPut: [AdicRationalField on: self]! !

!AdicIntegerRing methodsFor: 'accessing' stamp: 'len 6/3/2019 02:57:38'!
maximalIdeal
	^ self * self uniformizer! !

!AdicIntegerRing methodsFor: 'accessing' stamp: 'len 4/22/2019 03:44:26'!
one
	^ self !! 1! !

!AdicIntegerRing methodsFor: 'accessing' stamp: 'len 6/6/2019 12:06:38'!
p
	^ self completionIdeal generator! !

!AdicIntegerRing methodsFor: 'accessing' stamp: 'len 6/2/2019 05:02:07'!
precision
	"Answer the precision bound for the receiver."
	^ self propertyAt: #precision ifAbsent: [Infinity positive]! !

!AdicIntegerRing methodsFor: 'accessing' stamp: 'len 6/2/2019 05:24:00'!
primeSubring
	^ self! !

!AdicIntegerRing methodsFor: 'accessing' stamp: 'len 6/6/2019 12:07:48'!
residueField
	"Answer the prime field Z/pZ isomorphic to the residue field of the receiver, equiped with the canonical projection."
	^ self propertyAt: #residueField ifAbsentPut:
		[| answer |
		(answer _ PrimeField new: self p)
			addMap: (self onto: answer evaluating: [:x| answer !! (x at: 0)]); "TODO: add kernel and section"
			yourself]! !

!AdicIntegerRing methodsFor: 'accessing' stamp: 'len 6/2/2019 16:34:31'!
size
	^ Aleph new! !

!AdicIntegerRing methodsFor: 'accessing' stamp: 'len 6/6/2019 12:08:03'!
uniformizer
	"A uniformizer (or uniformizing parameter, uniformizer element or prime element) is any irreducible element of a DVR, or equivalently a generator of the maximal ideal. All non-zero ideals are generated by some power of the uniformizer."
	^ self !! self p! !

!AdicIntegerRing methodsFor: 'accessing' stamp: 'len 4/22/2019 03:44:30'!
zero
	^ self !! 0! !

!AdicIntegerRing methodsFor: 'comparing' stamp: 'len 6/6/2019 11:18:44'!
= anObject
	(anObject isKindOf: AdicIntegerRing) ifTrue: [^ self p = anObject p and: [self precision = anObject precision]].
	^ super = anObject! !

!AdicIntegerRing methodsFor: 'comparing' stamp: 'len 6/2/2019 11:27:08'!
hash
	^ self p! !

!AdicIntegerRing methodsFor: 'elements' stamp: 'len 6/1/2019 17:17:51'!
!! anObject
	anObject isFraction ifTrue: [^ self fromFraction: anObject].
	anObject isInteger ifTrue: [^ self fromRationalInteger: anObject].
	^ super !! anObject! !

!AdicIntegerRing methodsFor: 'elements' stamp: 'len 6/1/2019 17:00:30'!
digits: aSequence
	^ AdicInteger new digits: aSequence; parent: self! !

!AdicIntegerRing methodsFor: 'elements' stamp: 'len 6/6/2019 12:07:37'!
fromRationalInteger: anInteger
	| p q |
	p _ self p.
	q _ anInteger.
	^ self streaming: [| r | r _ q \\ p. q _ q // p. r]! !

!AdicIntegerRing methodsFor: 'elements' stamp: 'len 6/1/2019 17:00:48'!
streaming: aBlock
	^ self digits: (Sequence streaming: aBlock)! !

!AdicIntegerRing methodsFor: 'operations' stamp: 'len 6/6/2019 12:05:52'!
jet: anInteger
	"Answer the anInteger-th jet of the receiver, that is the quotient ring isomorphic to the anInteger-th truncation of the receiver."
	^ PrimePowerRing new: self p to: anInteger! !

!AdicIntegerRing methodsFor: 'random' stamp: 'len 6/2/2019 09:41:11'!
atRandom: aRandom
	| pp random |
	random _ Random seed: (aRandom nextBits: 31).
	pp _ self p.
	^ self streaming: [(random nextInteger:  pp) - 1]! !

!AdicIntegerRing methodsFor: 'random' stamp: 'len 6/2/2019 09:33:02'!
atRandom: aRandom bits: bitSize
	| n |
	n _ ZZ atRandom: aRandom bits: bitSize.
	n = 0 ifTrue: [n _ 1].
	^ self !! n! !

!AdicIntegerRing methodsFor: 'testing' stamp: 'len 6/2/2019 04:10:34'!
includes: anObject
	^ anObject isElement and: [anObject parent = self]! !

!AdicIntegerRing methodsFor: 'testing' stamp: 'len 6/2/2019 05:03:27'!
isBounded
	"Answer true if the precision of the receiver is bounded."
	^ self precision isFinite! !

!AdicIntegerRing methodsFor: 'testing' stamp: 'len 6/4/2019 17:48:35'!
isDVR
	"Answer true if the receiver is a discrete valuation ring, i.e. a local PID that is not a field."
	^ true! !

!AdicIntegerRing methodsFor: 'testing' stamp: 'len 12/7/2015 01:29'!
isIntegralDomain
	^ true! !

!AdicIntegerRing methodsFor: 'testing' stamp: 'len 6/2/2019 04:27:35'!
isLocal
	^ true! !

!AdicIntegerRing methodsFor: 'testing' stamp: 'len 6/2/2019 05:03:44'!
isUnbounded
	"Answer true if the precision of the receiver is unbounded."
	^ self precision isInfinite! !

!AdicIntegerRing methodsFor: 'testing' stamp: 'len 6/1/2019 01:35:22'!
isUnit: anElement
	"Answer true if the argument is invertible."
	^ (anElement at: 1) isZero not! !

!AdicIntegerRing methodsFor: 'private' stamp: 'len 6/2/2019 05:02:50'!
precision: anInteger
	self propertyAt: #precision put: anInteger! !

!AdicIntegerRing class methodsFor: 'instance creation' stamp: 'len 6/6/2019 12:02:48'!
at: aPrime
	| I |
	I _ aPrime isInteger ifTrue: [ZZ*aPrime] ifFalse: [aPrime].
	^ super at: I! !

!AdicIntegerRing class methodsFor: 'instance creation' stamp: 'len 6/6/2019 12:03:02'!
at: aPrime precision: anInteger
	^ (self at: aPrime) precision: anInteger! !

!PowerSeriesRing methodsFor: 'accessing' stamp: 'len 10/28/2016 14:17'!
characteristic
	^ self scalars characteristic! !

!PowerSeriesRing methodsFor: 'accessing' stamp: 'len 6/6/2019 13:20:02'!
generators
	^ self base generators collect: [:each| self !! each]! !

!PowerSeriesRing methodsFor: 'accessing' stamp: 'len 6/4/2019 05:16:30'!
maximalIdeal
	self scalars isField ifTrue: [^ self * self uniformizer].
	^ self * ((self scalars maximalIdeal generators collect: [:each| self !! each]), {self x})! !

!PowerSeriesRing methodsFor: 'accessing' stamp: 'len 6/6/2019 13:19:57'!
names
	^ self base names! !

!PowerSeriesRing methodsFor: 'accessing' stamp: 'len 6/6/2019 13:20:07'!
names: anArray
	self base names: anArray! !

!PowerSeriesRing methodsFor: 'accessing' stamp: 'len 6/6/2019 13:21:34'!
one
	^ self !! self base one! !

!PowerSeriesRing methodsFor: 'accessing' stamp: 'len 6/6/2019 13:20:12'!
scalars
	^ self base scalars! !

!PowerSeriesRing methodsFor: 'accessing' stamp: 'len 6/3/2019 03:14:32'!
uniformizer
	"A uniformizer (or uniformizing parameter, uniformizer element or prime element) is any irreducible element of a DVR, or equivalently a generator of the maximal ideal. All non-zero ideals are generated by some power of the uniformizer."
	self isDVR ifFalse: [DomainError signal: 'not a DVR'].
	^ self x! !

!PowerSeriesRing methodsFor: 'accessing' stamp: 'len 6/6/2019 13:20:43'!
x
	^ self !! self base x! !

!PowerSeriesRing methodsFor: 'accessing' stamp: 'len 6/6/2019 13:20:48'!
zero
	^ self !! self base zero! !

!PowerSeriesRing methodsFor: 'elements' stamp: 'len 6/6/2019 13:19:40'!
!! anObject
	(self base includes: anObject) ifTrue: [^ self coefficients: (CFiniteSequence to: self scalars initialValues: anObject coefficients periodic: {self scalars zero})].
	(self scalars includes: anObject) ifTrue: [^ self  coefficients: (CFiniteSequence to: self scalars initialValues: {anObject} periodic: {self scalars zero})].
	((anObject isKindOf: Sequence) and: [self scalars = anObject codomain]) ifTrue: [^ self coefficients: anObject].
	^ super !! anObject! !

!PowerSeriesRing methodsFor: 'elements' stamp: 'len 6/2/2019 17:19:24'!
coefficients: aSequence
	^ (PowerSeries coefficients: aSequence) parent: self! !

!PowerSeriesRing methodsFor: 'elements' stamp: 'len 6/3/2019 02:31:17'!
taylorSeriesOf: aFunction at: x0
	| f n |
	f _ aFunction.
	n _ 0.
	^ self coefficients:
		(Sequence
			to: self scalars
			streaming:
				[| value |
				value _ (f value: x0) / n factorial.
				f _ f derivative.
				n _ n + 1.
				value])! !

!PowerSeriesRing methodsFor: 'elements-testing' stamp: 'len 6/5/2019 17:07:20'!
isUnit: aPowerSeries
	"Answer true if the argument is invertible."
	self scalars isField ifTrue: [^ self scalars isUnit: aPowerSeries independentCoefficient].
	^ super isUnit: aPowerSeries! !

!PowerSeriesRing methodsFor: 'morphisms' stamp: 'len 6/6/2019 13:20:37'!
from: aDomain
	aDomain = self base ifTrue: [^ self addMap: ((self base into: self evaluating: [:x| self !! x]) name: 'i')].
	^ super from: aDomain! !

!PowerSeriesRing methodsFor: 'operations' stamp: 'len 6/3/2019 03:08:37'!
fractions
	^ LaurentSeriesRing on: self! !

!PowerSeriesRing methodsFor: 'printing' stamp: 'len 6/6/2019 13:22:18'!
printIndeterminatesOn: aStream
	self base printIndeterminatesOn: aStream! !

!PowerSeriesRing methodsFor: 'testing' stamp: 'len 6/4/2019 05:17:21'!
includes: anObject
	^ anObject isElement and: [anObject parent = self]! !

!PowerSeriesRing methodsFor: 'testing' stamp: 'len 6/4/2019 17:48:43'!
isDVR
	"Answer true if the receiver is a discrete valuation ring, i.e. a local PID that is not a field."
	^ self scalars isField! !

!PowerSeriesRing methodsFor: 'testing' stamp: 'len 6/6/2019 13:20:16'!
isIntegralDomain
	^ self base isIntegralDomain! !

!PowerSeriesRing methodsFor: 'testing' stamp: 'len 6/6/2019 13:28:30'!
isLocal
	^ self scalars isLocal "hm.. if R is not a field or a local ring, then R[[x]] is not a local ring!! should disallow power series rings over non-local coefficients?"! !

!PowerSeriesRing methodsFor: 'testing' stamp: 'len 6/6/2019 13:22:14'!
isMultivariate
	^ self base isMultivariate! !

!PowerSeriesRing methodsFor: 'testing' stamp: 'len 6/4/2019 16:12:02'!
isNoetherian
	"Answer true if the receiver is a Noetherian ring, i.e. every ideal is finitely generated."
	^ self scalars isNoetherian or: [super isNoetherian]! !

!PowerSeriesRing class methodsFor: 'instance creation' stamp: 'len 6/6/2019 13:19:19'!
at: anIdeal
	^ self shouldNotImplement! !

!PowerSeriesRing class methodsFor: 'instance creation' stamp: 'len 6/6/2019 13:18:59'!
on: aPolynomialRing
	^ super at: (aPolynomialRing isLocal ifTrue: [aPolynomialRing] ifFalse: [aPolynomialRing localization]) maximalIdeal! !

!LocalizationRing methodsFor: 'accessing' stamp: 'len 10/28/2016 16:37'!
characteristic
	^ self integers characteristic! !

!LocalizationRing methodsFor: 'accessing' stamp: 'len 5/13/2019 19:03:21'!
generators
	^ self propertyAt: #generators ifAbsentPut: [(self integers generators ifNil: [^ nil]) apply: self integers -> self]! !

!LocalizationRing methodsFor: 'accessing' stamp: 'len 6/6/2019 11:09:02'!
integers
	^ self localizationIdeal scalars! !

!LocalizationRing methodsFor: 'accessing' stamp: 'len 6/6/2019 11:08:37'!
localizationIdeal
	^ self propertyAt: #localizationIdeal! !

!LocalizationRing methodsFor: 'accessing' stamp: 'len 6/6/2019 11:09:55'!
maximalIdeal
	"Answer the unique maximal ideal in the receiver."
	^ self * (self localizationIdeal generators collect: [:each| self embed: each])! !

!LocalizationRing methodsFor: 'accessing' stamp: 'len 10/28/2016 16:39'!
one
	^ self embed: self integers one! !

!LocalizationRing methodsFor: 'accessing' stamp: 'len 10/28/2016 16:39'!
zero
	^ self embed: self integers zero! !

!LocalizationRing methodsFor: 'comparing' stamp: 'len 10/29/2016 10:16'!
< aRing
	"Answer true if the receiver is strictly included in the argument."
	^ self ~= aRing and: [self <= aRing]! !

!LocalizationRing methodsFor: 'comparing' stamp: 'len 6/6/2019 11:06:19'!
<= aRing
	"Answer true if the receiver is included in the argument."
	self == aRing ifTrue: [^ true].
	(aRing isKindOf: Ring) ifFalse: [^ false].
	(aRing isKindOf: LocalizationRing)
		ifTrue: [^ self integers <= aRing integers and: [self localizationIdeal >= aRing localizationIdeal]].
	^ false! !

!LocalizationRing methodsFor: 'comparing' stamp: 'len 6/6/2019 11:06:34'!
= anObject
	self == anObject ifTrue: [^ true].
	^ (anObject isKindOf: LocalizationRing) and: [self localizationIdeal = anObject localizationIdeal]! !

!LocalizationRing methodsFor: 'comparing' stamp: 'len 6/6/2019 11:06:51'!
>= aRing
	"Answer true if the argument is included in the receiver."
	self == aRing ifTrue: [^ true].
	(aRing isKindOf: Ring) ifFalse: [^ false].
	(aRing isKindOf: LocalizationRing)
		ifTrue: [^ self integers >= aRing integers and: [self localizationIdeal <= aRing localizationIdeal]].
	^ self integers >= aRing! !

!LocalizationRing methodsFor: 'comparing' stamp: 'len 6/6/2019 11:07:16'!
hash
	^ self localizationIdeal hash + self integers hash! !

!LocalizationRing methodsFor: 'converting' stamp: 'len 6/6/2019 11:10:08'!
over: aRing
	"Change the base ring."
	^ self class at: (self localizationIdeal over: aRing)! !

!LocalizationRing methodsFor: 'elements' stamp: 'len 5/25/2018 17:36:46'!
!! anObject
	(self integers includes: anObject) ifTrue: [^ self embed: anObject].
	anObject isEvaluable ifTrue: [self integers !! anObject]. "assuming integral elements are the same objects as for the integers ring, just like Smalltalk Integer and Fraction."
	^ super !! anObject! !

!LocalizationRing methodsFor: 'morphisms' stamp: 'len 5/25/2018 17:53:41'!
embed: anObject
	^ anObject! !

!LocalizationRing methodsFor: 'morphisms' stamp: 'len 5/13/2019 19:00:12'!
from: aDomain
	aDomain = self integers ifTrue: [^ self addMap: ((self integers to: self evaluating: [:x| self embed: x]) name: 'i')].
	aDomain -> self integers ifNotNil: [:aMorphism| ^ aMorphism -> self].
	^ super from: aDomain! !

!LocalizationRing methodsFor: 'operations' stamp: 'len 1/19/2017 07:19:45'!
fractions
	^ self integers fractions! !

!LocalizationRing methodsFor: 'random' stamp: 'len 6/6/2019 11:06:59'!
atRandom: aRandom
	| a b |
	a _ self integers atRandom: aRandom.
	[b _ self integers atRandom: aRandom. self localizationIdeal includes: b] whileTrue.
	^ (self embed: a) / (self embed: b)! !

!LocalizationRing methodsFor: 'random' stamp: 'len 6/6/2019 11:07:07'!
atRandom: aRandom bits: bitSize
	| a b |
	bitSize < 2 ifTrue: [^ self embed: (self integers atRandom: aRandom bits: bitSize)].
	a _ self integers atRandom: aRandom bits: bitSize/2.
	[b _ self integers atRandom: aRandom bits: bitSize/2. self localizationIdeal includes: b] whileTrue.
	^ (self embed: a) / (self embed: b)! !

!LocalizationRing methodsFor: 'testing' stamp: 'len 6/6/2019 11:08:13'!
includes: anObject
	^ (self integers includes: anObject) or: [anObject isFractional and: [(self integers includes: anObject numerator) and: [(self localizationIdeal includes: anObject denominator) not]]]! !

!LocalizationRing methodsFor: 'testing' stamp: 'len 9/22/2018 18:55:12'!
isArtinian
	"Answer true if the receiver is an Artinian ring, i.e. it satisfied the descending chain condition on ideals.
	In the non-commutative case, one should talk about 'left Artinian' or 'right Artinian' rings."
	self integers isArtinian ifTrue: [^ true]. "only if commutative?"
	^ super isArtinian! !

!LocalizationRing methodsFor: 'testing' stamp: 'len 10/31/2016 11:27'!
isCommutative
	^ true! !

!LocalizationRing methodsFor: 'testing' stamp: 'len 6/6/2019 11:09:10'!
isDVR
	"Answer true if the receiver is a discrete valuation ring, i.e. a local PID that is not a field."
	"The localization of a Dedekind domain at a non-zero prime ideal is DVR."
	^ self integers isDedekindDomain and: [self localizationIdeal isTrivial not]! !

!LocalizationRing methodsFor: 'testing' stamp: 'len 6/4/2019 07:42:45'!
isDedekindDomain
	"A localization of a Dedekind domain at any multiplicative set is also a Dedekind domain."
	self integers isDedekindDomain ifTrue: [^ true].
	^ super isDedekindDomain! !

!LocalizationRing methodsFor: 'testing' stamp: 'len 9/22/2018 18:55:09'!
isEuclidean
	"Answer true if the receiver is an Euclidean ring, i.e. it has division with remainder."
	self integers isEuclidean ifTrue: [^ true].
	^ super isEuclidean! !

!LocalizationRing methodsFor: 'testing' stamp: 'len 6/6/2019 11:09:20'!
isField
	^ self integers isIntegralDomain and: [self localizationIdeal isZero]! !

!LocalizationRing methodsFor: 'testing' stamp: 'len 10/28/2016 16:06'!
isLocal
	^ true! !

!LocalizationRing methodsFor: 'testing' stamp: 'len 1/28/2018 22:20:01'!
isLocalization
	^ true! !

!LocalizationRing methodsFor: 'testing' stamp: 'len 6/4/2019 16:09:34'!
isNoetherian
	"Answer true if the receiver is a Noetherian ring, i.e. every ideal is finitely generated."
	^ self integers isNoetherian or: [super isNoetherian]! !

!LocalizationRing methodsFor: 'testing' stamp: 'len 6/4/2019 15:14:04'!
isPIR
	"Answer true if the receiver is a principal ideal ring, i.e. all ideals are principal (but it is not necesarily a PID, i.e. it is not necesarily an integral domain)."
	"A localization of a PIR at any multiplicative subset is again a PIR."
	self integers isPIR ifTrue: [^ true].
	^ super isPIR! !

!LocalizationRing methodsFor: 'testing' stamp: 'len 4/28/2018 05:11:31'!
isReduced
	"Answer true if the receiver has no non-zero nilpotent elements, or equivalently if it has no non-zero elements with square zero, i.e. x^2 = 0 implies x = 0."
	self integers isReduced ifTrue: [^ true]. "is it iff?"
	^ super isReduced! !

!LocalizationRing methodsFor: 'testing' stamp: 'len 9/16/2018 18:16:41'!
isTrivial
	^ self integers isTrivial "or: [self maximalIdeal includes: self zero]"! !

!LocalizationRing methodsFor: 'testing' stamp: 'len 6/6/2019 11:09:45'!
isUnit: anElement
	"Answer true if the argument is invertible."
	^ (self localizationIdeal includes: anElement numerator) not! !

!LocalizationRing methodsFor: 'private' stamp: 'len 6/6/2019 11:07:48'!
localizationIdeal: anIdeal
	self propertyAt: #localizationIdeal put: anIdeal! !

!LocalizationRing class methodsFor: 'examples' stamp: 'len 1/23/2018 21:24:50'!
exampleZZLocalizedAt2
	"Answer the localization of the integers at <2>.
	This is the ring of fractions with odd denominator."
	^ ZZ localizationAt: 2! !

!LocalizationRing class methodsFor: 'instance creation' stamp: 'len 6/6/2019 11:10:47'!
at: anIdeal
	^ self new localizationIdeal: anIdeal! !

!FractionRing methodsFor: 'accessing' stamp: 'len 6/3/2019 03:17:26'!
uniformizer
	^ self embed: self integers uniformizer! !

!FractionRing methodsFor: 'comparing' stamp: 'len 10/31/2016 15:20'!
= anObject
	self == anObject ifTrue: [^ true].
	^ (anObject isKindOf: FractionRing) and: [anObject integers = self integers]! !

!FractionRing methodsFor: 'converting' stamp: 'len 1/20/2017 09:07:54'!
over: aRing
	"Change the base ring."
	^ self class on: (self integers over: aRing)! !

!FractionRing methodsFor: 'operations' stamp: 'len 2/28/2017 19:59:48'!
fractions
	^ self! !

!FractionRing methodsFor: 'testing' stamp: 'len 5/25/2018 17:47:54'!
includes: anObject
	| R |
	R _ self integers.
	^ (R includes: anObject) or: [anObject isFractional and: [R includes: anObject numerator]]! !

!FractionRing methodsFor: 'testing' stamp: 'len 6/4/2019 17:48:31'!
isDVR
	"Answer true if the receiver is a discrete valuation ring, i.e. a local PID that is not a field."
	^ self integers isDVR! !

!FractionRing methodsFor: 'testing' stamp: 'len 10/31/2016 15:21'!
isField
	^ self integers isIntegralDomain! !

!FractionRing methodsFor: 'testing' stamp: 'len 10/31/2016 15:21'!
isFractionRing
	^ true! !

!FractionRing class methodsFor: 'examples' stamp: 'len 9/28/2018 19:18:34'!
example1
	"The field of fractions of the rational integers is the field of rational numbers:"
	^ ZZ fractions
! !

!FractionRing class methodsFor: 'instance creation' stamp: 'len 1/23/2018 21:25:31'!
at: anIdeal
	^ self shouldNotImplement! !

!FractionRing class methodsFor: 'instance creation' stamp: 'len 1/23/2018 21:18:50'!
on: anIntegralDomain
	^ super at: anIntegralDomain zeroIdeal! !

!AdicRationalField methodsFor: 'as yet unclassified' stamp: 'len 6/3/2019 17:25:37'!
embed: anAdicInteger
	| v |
	v _ anAdicInteger valuation.
	^ AdicNumber valuation: v unit: anAdicInteger << v! !

!AdicRationalField methodsFor: 'as yet unclassified' stamp: 'len 6/4/2019 04:52:35'!
isLocalField
	^ true! !

!AdicRationalField methodsFor: 'as yet unclassified' stamp: 'len 12/17/2016 20:30:57'!
p
	^ self integers p! !

!AdicRationalField methodsFor: 'as yet unclassified' stamp: 'len 6/2/2019 05:25:32'!
precision
	^ self integers precision! !

!AdicRationalField methodsFor: 'as yet unclassified' stamp: 'len 6/2/2019 05:24:21'!
primeSubfield
	^ self! !

!AdicRationalField methodsFor: 'as yet unclassified' stamp: 'len 6/3/2019 02:50:27'!
uniformizer
	^ self !! self integers uniformizer! !

!RationalField methodsFor: 'accessing' stamp: 'len 9/22/2018 18:58:22'!
degree
	"Answer the degree of the receiver as an algebraic extension (as a number field)."
	^ 1! !

!RationalField methodsFor: 'accessing' stamp: 'len 1/5/2017 20:02:52'!
generators
	^ #(1)! !

!RationalField methodsFor: 'accessing' stamp: 'len 10/14/2016 22:01'!
integers
	^ ZZ! !

!RationalField methodsFor: 'accessing' stamp: 'len 6/6/2019 11:37:19'!
localizationIdeal
	^ ZZ zeroIdeal! !

!RationalField methodsFor: 'accessing' stamp: 'len 4/24/2016 03:00'!
size
	^ Aleph new! !

!RationalField methodsFor: 'accessing' stamp: 'len 5/30/2019 03:40:35'!
valuation
	"Answer the absolute value valuation."
	^ self propertyAt: #valuation ifAbsentPut: [Function from: self to: ZZ evaluating: [:x| x abs]]! !

!RationalField methodsFor: 'comparing' stamp: 'len 6/1/2016 23:56'!
<= aDomain
	^ aDomain isField and: [(aDomain includes: 1) and: [aDomain includes: 0]]! !

!RationalField methodsFor: 'comparing' stamp: 'len 11/10/2015 23:14'!
= anObject
	^ anObject class == self class! !

!RationalField methodsFor: 'comparing' stamp: 'len 6/28/2016 09:27'!
hash
	^ self class hash! !

!RationalField methodsFor: 'elements' stamp: 'len 3/25/2018 16:19:54'!
!! anObject
	(anObject isInteger or: [anObject isFraction]) ifTrue: [^ anObject].
	^ super !! anObject! !

!RationalField methodsFor: 'elements' stamp: 'len 11/2/2015 15:53'!
one
	^ 1! !

!RationalField methodsFor: 'elements' stamp: 'len 11/2/2015 15:53'!
zero
	^ 0! !

!RationalField methodsFor: 'enumerating' stamp: 'len 12/21/2015 22:42'!
do: aBlock
	"Iterate over the rational numbers by breadth-first traversal of the Calkin-Wilf tree. This is an extension of the Calkin-Wilf sequence to include 0 and the negative numbers."
	aBlock value: 0.
	self positiveDo: [:each| aBlock value: each; value: each negated]! !

!RationalField methodsFor: 'enumerating' stamp: 'len 1/4/2017 21:41:47'!
positiveDo: aBlock
	"Iterate over the rational numbers by breadth-first traversal of the Calkin-Wilf tree.
	The nodes of the Calkin-Wilf tree of any given depth level have height strictly greater than the height of their parents."
	| q |
	q _ 1.
	[aBlock value: q. q _ 1 / (2 * q floor - q + 1)] repeat! !

!RationalField methodsFor: 'morphisms' stamp: 'len 5/6/2019 03:35:14'!
automorphisms
	^ Group new elements: {self id}! !

!RationalField methodsFor: 'morphisms' stamp: 'len 1/2/2016 04:15'!
embed: anInteger
	^ anInteger "because in Smalltalk Fractions of denominator 1 are always reduced to their Integer numerator"! !

!RationalField methodsFor: 'morphisms' stamp: 'len 9/25/2018 14:39:28'!
to: aCodomain
	"Answer the canonical morphism from the receiver to aCodomain."
	(aCodomain isRing and: [aCodomain characteristic = 0])
		ifTrue: [^ self to: aCodomain evaluating: [:x| aCodomain one * x numerator / (aCodomain one * x denominator)]].
	^ super to: aCodomain! !

!RationalField methodsFor: 'operations' stamp: 'len 9/23/2018 01:37:20'!
adic: aPrime
	^ (self integers adic: aPrime) fractions! !

!RationalField methodsFor: 'operations' stamp: 'len 6/2/2019 05:00:13'!
adic: aPrime precision: anInteger
	^ (self integers adic: aPrime precision: anInteger) fractions! !

!RationalField methodsFor: 'operations' stamp: 'len 5/18/2016 22:22'!
adjoin: anAlgebraicNumber
	^ NumberField adjoint: anAlgebraicNumber! !

!RationalField methodsFor: 'operations' stamp: 'len 1/20/2018 19:01:07'!
algebraicClosure
	^ CC! !

!RationalField methodsFor: 'operations' stamp: 'len 5/21/2018 16:20:48'!
extension: aPolynomial
	"Answer the algebraic extension of the receiver defined by the given irreducible polynomial."
	aPolynomial scalars = self ifFalse: [DomainError signal: 'polynomial coefficients not from this field'].
	aPolynomial parent isUnivariate ifFalse: [DomainError signal: 'not univariate poylnomial'].
"	aPolynomial degree = 2 ifTrue: [^ QuadraticField polynomial: aPolynomial]."
	^ NumberField polynomial: aPolynomial! !

!RationalField methodsFor: 'operations' stamp: 'len 1/20/2018 19:03:44'!
realClosure
	^ RR! !

!RationalField methodsFor: 'testing' stamp: 'len 1/11/2016 05:56'!
includes: anObject
	^ anObject isNumber and: [anObject isRational or: [anObject isFloat]]! !

!RationalField methodsFor: 'testing' stamp: 'len 1/8/2017 07:50:01'!
isField
	^ true! !

!RationalField methodsFor: 'testing' stamp: 'len 11/7/2015 22:05'!
isFinite
	^ false! !

!RationalField methodsFor: 'testing' stamp: 'len 10/2/2018 01:52:47'!
isOrdered
	^ true! !

!RationalField methodsFor: 'testing' stamp: 'len 2/8/2016 20:26'!
isPrime
	"Q is a prime field (it has no proper subfields)."
	^ true! !

!RationalField methodsFor: 'testing' stamp: 'len 2/11/2016 22:19'!
isReal
	^ true! !

!RationalField methodsFor: 'testing' stamp: 'len 9/16/2018 16:26:21'!
isUnit: anIntegerOrFraction
	"Answer true if the argument is invertible."
	^ anIntegerOrFraction ~= 0! !

!RationalField class methodsFor: 'initialization' stamp: 'len 8/5/2016 21:33'!
initialize
	super initialize.
	Smalltalk at: #QQ put: self new! !

!RationalFunctionField methodsFor: 'accessing' stamp: 'len 10/14/2016 22:59'!
indeterminates
	^ self integers indeterminates! !

!RationalFunctionField methodsFor: 'accessing' stamp: 'len 10/14/2016 23:00'!
rank
	^ self integers rank! !

!RationalFunctionField methodsFor: 'accessing' stamp: 'len 10/14/2016 23:00'!
scalars
	^ self integers scalars! !

!RationalFunctionField methodsFor: 'accessing' stamp: 'len 10/16/2016 09:01'!
size
	^ Aleph new * self scalars size! !

!RationalFunctionField methodsFor: 'elements' stamp: 'len 9/22/2018 22:28:28'!
!! anObject
	(anObject isKindOf: Polynomial)
		ifTrue: [^ self integers !! anObject].
	(anObject isKindOf: RationalFunction)
		ifTrue: [^ self integers !! anObject numerator / (self integers !! anObject denominator)].
	(self scalars includes: anObject) ifTrue: [^ self integers !! anObject].
	^ super !! anObject! !

!RationalFunctionField methodsFor: 'elements' stamp: 'len 10/16/2016 20:12'!
x
	^ self x: 1! !

!RationalFunctionField methodsFor: 'elements' stamp: 'len 10/14/2016 23:00'!
x: anIndeterminate
	^ self embed: (self integers x: anIndeterminate)! !

!RationalFunctionField methodsFor: 'elements' stamp: 'len 10/16/2016 20:12'!
y
	^ self x: 2! !

!RationalFunctionField methodsFor: 'elements' stamp: 'len 10/16/2016 20:13'!
z
	^ self x: 3! !

!RationalFunctionField methodsFor: 'morphisms' stamp: 'len 4/6/2018 23:42:36'!
embed: aPolynomial
	^ RationalFunction numerator: self integers !! aPolynomial denominator: self integers one! !

!RationalFunctionField methodsFor: 'operations' stamp: 'len 5/21/2018 16:21:23'!
extension: aPolynomial
	"Answer the algebraic function field extension of the receiver defined by the given irreducible polynomial."
	aPolynomial scalars = self ifFalse: [DomainError signal: 'polynomial coefficients not from this field'].
	aPolynomial parent isUnivariate ifFalse: [DomainError signal: 'not univariate poylnomial'].
	^ FunctionField polynomial: aPolynomial! !

!RationalFunctionField methodsFor: 'testing' stamp: 'len 9/16/2018 16:26:30'!
isUnit: aRationalFunction
	"Answer true if the argument is invertible."
	^ aRationalFunction isZero not! !

!RationalFunctionField methodsFor: 'testing' stamp: 'len 10/14/2016 22:59'!
isUnivariate
	^ self integers isUnivariate! !

!RationalFunctionField class methodsFor: 'examples' stamp: 'len 5/18/2018 18:38:15'!
example1
	"The field of rational functions in two indeterminates over the rationals:"
	^ (QQ polynomialsIn: #(x y)) fractions! !

!RationalFunctionField class methodsFor: 'examples' stamp: 'len 5/18/2018 18:37:11'!
example2
	"x / y in Q(x,y):"
	| F |
	F _ (QQ polynomialsIn: #(x y)) fractions.
	^ (F x: 1) / (F x: 2)! !

!RationalFunctionField class methodsFor: 'instance creation' stamp: 'len 1/5/2017 09:51:56'!
new: anInteger over: aRing
	^ self over: (aRing polynomialsIn: anInteger)! !

!RationalFunctionField class methodsFor: 'instance creation' stamp: 'len 9/22/2018 22:24:16'!
on: aPolynomialRing
	| R |
	R _ (aPolynomialRing isKindOf: PolynomialRing) ifTrue: [aPolynomialRing] ifFalse: [aPolynomialRing polynomials].
"	R _ R ordering isLocal
		ifTrue: [aPolynomialRing]
		ifFalse: [aPolynomialRing orderedBy: #llex]."
	^ super on: R! !

!LaurentSeriesRing methodsFor: 'as yet unclassified' stamp: 'len 6/4/2019 05:02:19'!
isLocalField
	^ self scalars isGaloisField! !

!LaurentSeriesRing methodsFor: 'as yet unclassified' stamp: 'len 6/3/2019 02:45:08'!
names
	^ self integers names! !

!LaurentSeriesRing methodsFor: 'as yet unclassified' stamp: 'len 6/3/2019 02:45:47'!
names: anArray
	self integers names: anArray! !

!LaurentSeriesRing methodsFor: 'as yet unclassified' stamp: 'len 6/3/2019 02:48:02'!
x
	^ self !! self integers x! !

!ValuationRing methodsFor: 'as yet unclassified' stamp: 'len 6/3/2019 05:20:58'!
fractions
	^ self propertyAt: #fractions! !

!ValuationRing methodsFor: 'as yet unclassified' stamp: 'len 6/3/2019 05:21:14'!
fractions: aFractionField
	^ self propertyAt: #fractions put: aFractionField! !

!ValuationRing methodsFor: 'as yet unclassified' stamp: 'len 6/3/2019 05:34:28'!
integers
	^ self fractions integers! !

!ValuationRing methodsFor: 'as yet unclassified' stamp: 'len 6/3/2019 05:22:40'!
p
	^ self propertyAt: #p! !

!ValuationRing methodsFor: 'as yet unclassified' stamp: 'len 6/3/2019 05:22:46'!
p: aPrime
	self propertyAt: #p put: aPrime! !

!ValuationRing methodsFor: 'as yet unclassified' stamp: 'len 6/3/2019 05:40:25'!
uniformizer
	^ self !! self p! !

!ValuationRing class methodsFor: 'as yet unclassified' stamp: 'len 6/3/2019 05:22:25'!
on: aFractionsField p: aPrime
	^ self new fractions: aFractionsField; p: aPrime! !

!OppositeRing methodsFor: 'accessing' stamp: 'len 5/8/2019 14:52:11'!
generators
	^ opposite generators collect: [:each| self !! each]! !

!OppositeRing methodsFor: 'accessing' stamp: 'len 5/8/2019 14:51:55'!
one
	^ self !! opposite one! !

!OppositeRing methodsFor: 'accessing' stamp: 'len 5/8/2019 14:51:59'!
zero
	^ self !! opposite zero! !

!OppositeRing methodsFor: 'elements' stamp: 'len 5/8/2019 14:44:48'!
!! anElement
	(opposite includes: anElement) ifTrue: [^ OppositeRingElement opposite: anElement inverse].
	^ super !! anElement! !

!OppositeRing methodsFor: 'operations' stamp: 'len 5/8/2019 14:43:21'!
opposite
	^ opposite! !

!OppositeRing methodsFor: 'private' stamp: 'len 5/8/2019 14:43:31'!
opposite: aRing
	opposite _ aRing! !

!OppositeRing class methodsFor: 'instance creation' stamp: 'len 5/8/2019 14:44:25'!
opposite: aRing
	^ self new opposite: aRing! !

!ProductRing methodsFor: 'accessing' stamp: 'len 8/29/2016 04:09'!
arity
	^ components size! !

!ProductRing methodsFor: 'accessing' stamp: 'len 8/29/2016 04:09'!
at: anInteger
	^ components at: anInteger! !

!ProductRing methodsFor: 'accessing' stamp: 'len 5/3/2018 01:54:47'!
characteristic
	^ components inject: 1 into: [:result :each| result lcm: each characteristic]! !

!ProductRing methodsFor: 'accessing' stamp: 'len 2/26/2017 09:47:23'!
size
	^ components product: [:each| each size]! !

!ProductRing methodsFor: 'accessing-private' stamp: 'len 8/29/2016 04:10'!
components
	^ components! !

!ProductRing methodsFor: 'accessing-private' stamp: 'len 11/5/2016 06:41'!
components: anArray
	components _ anArray! !

!ProductRing methodsFor: 'comparing' stamp: 'len 9/16/2018 16:15:02'!
= anObject
	^ (anObject isKindOf: ProductRing) and: [components = anObject components]! !

!ProductRing methodsFor: 'comparing' stamp: 'len 8/29/2016 04:13'!
hash
	^ components hash! !

!ProductRing methodsFor: 'converting' stamp: 'len 8/29/2016 04:11'!
asCartesianProduct
	^ CartesianProduct components: components! !

!ProductRing methodsFor: 'elements' stamp: 'len 9/14/2018 22:18:54'!
!! anObject
	(anObject isSequenceable and: [anObject size = self arity])
		ifTrue: [^ self compose: (components with: anObject collect: [:eachRing :eachElement| eachRing !! eachElement])].
	^ super !! anObject! !

!ProductRing methodsFor: 'elements' stamp: 'len 9/16/2018 16:15:47'!
one
	^ self compose: (components collect: [:each| each one])! !

!ProductRing methodsFor: 'elements' stamp: 'len 9/16/2018 16:15:52'!
zero
	^ self compose: (components collect: [:each| each zero])! !

!ProductRing methodsFor: 'enumerating' stamp: 'len 9/16/2018 16:15:22'!
do: aBlock
	self asCartesianProduct do: [:each| aBlock value: (self compose: each)]! !

!ProductRing methodsFor: 'morphisms' stamp: 'len 9/16/2018 16:15:15'!
compose: anArray
	^ ProductRingElement components: anArray! !

!ProductRing methodsFor: 'morphisms' stamp: 'len 9/16/2018 16:15:19'!
composition
	^ (Function from: self asCartesianProduct to: self evaluating: [:each| self compose: each]) name: Character times asString! !

!ProductRing methodsFor: 'morphisms' stamp: 'len 4/23/2019 02:17:01'!
coprojection: i
	^ ((self at: i) to: self evaluating: [:x| self compose: (components withIndexCollect: [:each :k| k = i ifTrue: [x] ifFalse: [each zero]])]) name: 'i', i printText sub! !

!ProductRing methodsFor: 'morphisms' stamp: 'len 5/22/2018 16:13:43'!
projection: i
	"Answer the canonical projection to the i-th component."
	^ (self to: (self at: i) evaluating: [:x| x at: i]) name: Character pi asText, i printText sub! !

!ProductRing methodsFor: 'random' stamp: 'len 9/16/2018 16:15:07'!
atRandom: aRandom
	^ self compose: (self asCartesianProduct atRandom: aRandom)! !

!ProductRing methodsFor: 'random' stamp: 'len 9/16/2018 16:15:10'!
atRandom: aRandom bits: bits
	^ self compose: (self asCartesianProduct atRandom: aRandom bits: bits)! !

!ProductRing methodsFor: 'testing' stamp: 'len 9/16/2018 16:15:31'!
includes: anObject
	(anObject isKindOf: ProductRingElement) ifFalse: [^ false].
	anObject size = components size ifFalse: [^ false].
	components with: anObject do: [:R :x| (R includes: x) ifFalse: [^ false]].
	^ true! !

!ProductRing methodsFor: 'testing' stamp: 'len 6/4/2019 15:39:05'!
isBezout
	"Answer true if the receiver is a Bezout ring, i.e. every finitely generated ideal is principal."
	"Bezout rings (like PIRs) are closed under products:"
	^ (components allSatisfy: [:each| each isBezout]) or: [super isBezout]! !

!ProductRing methodsFor: 'testing' stamp: 'len 5/1/2019 17:18:47'!
isCoherent
	"Answer true if the receiver is a coherent ring, i.e. if it is coherent as a module over itself."
	^ components allSatisfy: [:each| each isCoherent]! !

!ProductRing methodsFor: 'testing' stamp: 'len 4/8/2018 18:34:22'!
isCommutative
	^ components allSatisfy: [:each| each isCommutative]! !

!ProductRing methodsFor: 'testing' stamp: 'len 9/22/2018 18:57:09'!
isEuclidean
	"Answer true if the receiver is an Euclidean ring, i.e. it has division with remainder."
	(components allSatisfy: [:each| each isEuclidean]) ifTrue: [^ true]. "but how can it be, more than 2 components and it's not an integral domain"
	^ super isEuclidean! !

!ProductRing methodsFor: 'testing' stamp: 'len 9/16/2018 16:15:36'!
isIntegralDomain
	"The product of two or more non-trivial rings always has non-trivial zero divisors."
	| count |
	count _ 0.
	components do: [:each| each isTrivial ifFalse: [(count _ count + 1) > 1 ifTrue: [^ false]]].
	self halt.
	^ true! !

!ProductRing methodsFor: 'testing' stamp: 'len 6/4/2019 15:12:47'!
isPIR
	"Answer true if the receiver is a principal ideal ring, i.e. all ideals are principal (but it is not necesarily a PID, i.e. it is not necesarily an integral domain)."
	"A product ring is a PIR if and only if all its components are PIRs."
	^ components allSatisfy: [:each| each isPIR]! !

!ProductRing methodsFor: 'testing' stamp: 'len 8/29/2016 04:14'!
isProduct
	^ true! !

!ProductRing methodsFor: 'testing' stamp: 'len 4/28/2018 05:12:00'!
isReduced
	"Answer true if the receiver has no non-zero nilpotent elements, or equivalently if it has no non-zero elements with square zero, i.e. x^2 = 0 implies x = 0."
	(components allSatisfy: [:each| each isReduced]) ifTrue: [^ true]. "is it iff?"
	^ super isReduced! !

!ProductRing methodsFor: 'testing' stamp: 'len 9/16/2018 16:25:57'!
isUnit: anElement
	"Answer true if the argument is invertible."
	components with: anElement do: [:each :x| (each isUnit: x) ifFalse: [^ false]].
	^ true! !

!ProductRing methodsFor: 'testing' stamp: 'len 9/16/2018 16:31:39'!
isZeroDivisor: anElement
	"Answer true if there exists a nonzero element that multiplied by the argument is zero."
	components with: anElement do: [:each :x| (each isZeroDivisor: x) ifTrue: [^ true]].
	^ false! !

!ProductRing class methodsFor: 'examples' stamp: 'len 5/22/2018 21:56:13'!
example1
	"The product ring of two finite rings. This is a ring of order 4,
	with 3 zero-divisors and 1 unit, characteristic 2, and two maximal
	(and principal) ideals (so it's not a local ring)."
	^ ZZ/2  (ZZ/2)! !

!ProductRing class methodsFor: 'examples' stamp: 'len 5/22/2018 21:56:51'!
example2
	"The canonical projection to the second component:"
	^ ZZ/2  (ZZ/2) projection: 2! !

!ProductRing class methodsFor: 'instance creation' stamp: 'len 8/29/2016 04:09'!
components: anArray
	^ self new components: anArray! !

!QuotientRing methodsFor: 'accessing' stamp: 'len 1/15/2018 19:04:16'!
base
	^ self relations scalars! !

!QuotientRing methodsFor: 'accessing' stamp: 'len 2/5/2017 06:36:12'!
codimension
	"Answer the Krull codimension of the receiver."
	^ self base dimension - self dimension! !

!QuotientRing methodsFor: 'accessing' stamp: 'len 10/10/2016 16:29'!
generators
	^ (self base generators ifNil: [^ nil]) apply: self projection! !

!QuotientRing methodsFor: 'accessing' stamp: 'len 5/20/2018 22:39:51'!
maximalIdeal
	"If the receiver is a local ring, answer the unique maximal ideal."
	self base isLocal ifTrue: [^ self base maximalIdeal apply: self projection].
	^ super maximalIdeal! !

!QuotientRing methodsFor: 'accessing' stamp: 'len 2/27/2017 20:53:04'!
modulus
	^ self relations generator! !

!QuotientRing methodsFor: 'accessing' stamp: 'len 11/30/2016 18:59:01'!
one
	^ self representative: self base one! !

!QuotientRing methodsFor: 'accessing' stamp: 'len 2/27/2017 20:53:26'!
relation
	^ EquivalenceRelation on: self base evaluating: [:a :b| self relations includes: a - b]! !

!QuotientRing methodsFor: 'accessing' stamp: 'len 2/27/2017 20:46:50'!
relations
	^ self propertyAt: #relations! !

!QuotientRing methodsFor: 'accessing' stamp: 'len 1/9/2018 21:58:01'!
relators
	^ self relations generators! !

!QuotientRing methodsFor: 'accessing' stamp: 'len 11/30/2016 18:58:54'!
zero
	^ self representative: self base zero! !

!QuotientRing methodsFor: 'accessing-private' stamp: 'len 2/27/2017 20:48:00'!
relations: anIdeal
	self propertyAt: #relations put: anIdeal! !

!QuotientRing methodsFor: 'comparing' stamp: 'len 2/27/2017 20:56:21'!
= anObject
	self == anObject ifTrue: [^ true].
	(anObject isKindOf: QuotientRing) ifFalse: [^ false].
	^ self relations = anObject relations! !

!QuotientRing methodsFor: 'comparing' stamp: 'len 2/27/2017 20:53:58'!
hash
	^ self relations hash! !

!QuotientRing methodsFor: 'converting' stamp: 'len 1/15/2018 22:23:25'!
over: aRing
	^ (self relations over: aRing) quotientRing! !

!QuotientRing methodsFor: 'elements' stamp: 'len 5/5/2019 12:39:17'!
associatedUnit: aResidue
	"Answer a choice for associated unit of aResidue."
	^ self project: (self base associatedUnit: aResidue representative)! !

!QuotientRing methodsFor: 'elements-operations' stamp: 'len 9/25/2018 15:35:46'!
reciprocalOf: anElement
	^ self project: ((self relations reciprocalOf: anElement representative) ifNil: [^ nil])! !

!QuotientRing methodsFor: 'enumerating' stamp: 'len 6/5/2019 19:57:24'!
do: aBlock
	| visited |
	self flag: #fix. "does this work in any ring? depends on the implementation of do: in the base ring"
	visited _ Set new.
	self base do: [:each|
		| q |
		visited add: (q _ self project: each) ifPresent: [^ self].
		aBlock value: q]! !

!QuotientRing methodsFor: 'enumerating' stamp: 'len 9/22/2018 18:58:10'!
primeIdealsDo: aBlock
	self isField ifTrue: [aBlock value: self zeroIdeal. ^ self].
	self base primeIdealsDo: [:each| each >= self relations ifTrue: [aBlock value: (each apply: self projection)]]! !

!QuotientRing methodsFor: 'morphisms' stamp: 'len 2/5/2016 19:52'!
conjugation
	"Answer the companion automorphism of the receiver, i.e. the Frobenius automorphism."
	^ self frobenius! !

!QuotientRing methodsFor: 'morphisms' stamp: 'len 5/13/2019 19:07:30'!
from: aDomain
	aDomain = self base ifTrue: [^ self projection].
	aDomain -> self base ifNotNil: [:aMorphism| ^ aMorphism -> self].
	^ super from: aDomain! !

!QuotientRing methodsFor: 'morphisms' stamp: 'len 9/25/2018 15:35:25'!
isUnit: anElement
	"Answer true if the argument is invertible."
	^ (self reciprocalOf: anElement) notNil! !

!QuotientRing methodsFor: 'morphisms' stamp: 'len 5/7/2018 22:52:32'!
lifting
	"Answer the map from the receiver to the base ring lifting the canonical projection."
	^ self projection section! !

!QuotientRing methodsFor: 'morphisms' stamp: 'len 2/27/2017 20:53:22'!
project: anElement
	^ self representative: (self relations reduce: anElement)! !

!QuotientRing methodsFor: 'morphisms' stamp: 'len 12/28/2016 12:12:05'!
projection
	"Answer the natural projection, or quotient map, or canonical homomorphism. This takes elements from the base ring to the corresponding residue class in the quotient ring."
	^ self propertyAt: #projection ifAbsentPut: [self buildProjection]! !

!QuotientRing methodsFor: 'random' stamp: 'len 2/27/2017 20:56:13'!
atRandom: aRandom
	^ self project: (self relations remainderAtRandom: aRandom)
"	^ self project: (self base atRandom: aRandom)"! !

!QuotientRing methodsFor: 'random' stamp: 'len 11/29/2016 14:42:15'!
atRandom: aRandom bits: bitSize
"	^ self atRandom: aRandom"
	^ self project: (self base atRandom: aRandom bits: bitSize)! !

!QuotientRing methodsFor: 'testing' stamp: 'len 5/8/2019 19:39:08'!
includes: anObject
	(anObject isKindOf: Residue) ifFalse: [^ false].
	^ self base includes: anObject representative! !

!QuotientRing methodsFor: 'testing' stamp: 'len 9/22/2018 18:58:16'!
isArtinian
	"Answer true if the receiver is an Artinian ring, i.e. it satisfied the descending chain condition on ideals.
	In the non-commutative case, one should talk about 'left Artinian' or 'right Artinian' rings."
	self base isArtinian ifTrue: [^ true]. "only if commutative?"
	^ super isArtinian! !

!QuotientRing methodsFor: 'testing' stamp: 'len 6/4/2019 15:38:15'!
isBezout
	"Answer true if the receiver is a Bezout ring, i.e. every finitely generated ideal is principal."
	"Bezout rings (like PIRs) are closed under quotients:"
	^ self base isBezout or: [super isBezout]! !

!QuotientRing methodsFor: 'testing' stamp: 'len 11/29/2016 14:41:50'!
isCommutative
	self base isCommutative ifTrue: [^ true]. "if the ring is not commutative, we dont know if the quotient is or not"
	^ super isCommutative! !

!QuotientRing methodsFor: 'testing' stamp: 'len 2/28/2017 20:43:38'!
isField
	"Answer true if the receiver forms a residue field."
	^ self base isTrivial not and: [self base isCommutative and: [self relations isMaximal]]! !

!QuotientRing methodsFor: 'testing' stamp: 'len 6/4/2019 18:21:40'!
isIntegralDomain
	(self base isTrivial not and: [self base isCommutative])
		ifTrue: [^ self relations isPrime].
	self isIntegrallyClosedDomain
		ifTrue: [^ true].
	^ super isIntegralDomain! !

!QuotientRing methodsFor: 'testing' stamp: 'len 5/20/2018 21:59:53'!
isLocal
	^ self base isLocal or: [super isLocal]! !

!QuotientRing methodsFor: 'testing' stamp: 'len 1/12/2018 21:31:43'!
isNoetherian
	^ self base isNoetherian or: [super isNoetherian]! !

!QuotientRing methodsFor: 'testing' stamp: 'len 6/4/2019 15:37:07'!
isPIR
	"Answer true if the receiver is a principal ideal ring, i.e. all ideals are principal (but it is not necesarily a PID, i.e. it is not necesarily an integral domain)."
	"Any quotient of a PIR is again a PIR:"
	^ self base isPIR or: [super isPIR]! !

!QuotientRing methodsFor: 'testing' stamp: 'len 8/10/2016 01:01'!
isQuotient
	^ true! !

!QuotientRing methodsFor: 'testing' stamp: 'len 5/5/2018 00:37:05'!
isReduced
	"Answer true if the receiver has no non-zero nilpotent elements, or equivalently if it has no non-zero elements with square zero, i.e. x^2 = 0 implies x = 0.
	A quotient ring is reduced iff the relations ideal is radical."
	^ self relations isRadical! !

!QuotientRing methodsFor: 'testing' stamp: 'len 2/27/2017 20:53:34'!
isTrivial
	"The trivial ring is the zero ring with a single element 0 = 1."
	^ self relations isOne! !

!QuotientRing methodsFor: 'private' stamp: 'len 5/16/2019 13:32:07'!
buildProjection
	"Answer the natural projection, or quotient map, or canonical homomorphism. This takes elements from the base ring to the corresponding residue class in the quotient ring."
	| answer |
	answer _ self base onto: self evaluating: [:each| self project: each].
	answer name: Character pi asString.
	answer properties
		at: #kernel put: self relations;
		at: #image put: self;
		at: #section put: (self to: self base evaluating: [:each| each representative]).
	^ answer! !

!QuotientRing methodsFor: 'private' stamp: 'len 4/24/2019 11:50:53'!
elementClass
	^ Residue! !

!QuotientRing methodsFor: 'private' stamp: 'len 3/28/2018 19:19:56'!
idealClass
	^ QuotientIdeal! !

!QuotientRing methodsFor: 'private' stamp: 'len 1/5/2017 08:14:45'!
representative: anElement
	"Answer the residue class corresponding to the given representative (which is already reduced)."
	^ self elementClass in: self representative: anElement! !

!QuotientRing class methodsFor: 'examples' stamp: 'len 10/29/2016 10:25'!
exampleZ6
	"The quotient ring of residue classes of integers modulo 6."
	| I |
	I _ ZZ * 6.
	^ ZZ/I "alternatively, you can just write ZZ/6 or ZZ mod: 6."! !

!QuotientRing class methodsFor: 'examples' stamp: 'len 10/29/2016 10:25'!
exampleZ6Elements
	"The elements of the quotient ring of residue classes of integers modulo 6."
	^ (ZZ/6) elements! !

!QuotientRing class methodsFor: 'examples' stamp: 'len 5/22/2018 21:55:40'!
exampleZ6Projection
	"The canonical projection from the integers ring Z
	to the quotient ring of residue classes modulo 6."
	^ (ZZ/6) projection! !

!QuotientRing class methodsFor: 'instance creation' stamp: 'len 2/27/2017 20:48:08'!
mod: anIdeal
	^ self new relations: anIdeal! !

!ModularIntegerRing methodsFor: 'accessing' stamp: 'len 11/29/2016 21:40:34'!
base
	^ ZZ! !

!ModularIntegerRing methodsFor: 'accessing' stamp: 'len 4/25/2016 00:26'!
characteristic
	^ self modulus! !

!ModularIntegerRing methodsFor: 'accessing' stamp: 'len 9/23/2018 01:58:30'!
dimension
	"Answer the Krull dimension of the receiver."
	^ 0! !

!ModularIntegerRing methodsFor: 'accessing' stamp: 'len 11/29/2016 21:41:18'!
modulus
	^ modulus! !

!ModularIntegerRing methodsFor: 'accessing' stamp: 'len 2/27/2017 20:49:49'!
relations
	^ self propertyAt: #relations ifAbsentPut: [ZZ * modulus]! !

!ModularIntegerRing methodsFor: 'accessing' stamp: 'len 4/25/2016 00:27'!
size
	^ self modulus! !

!ModularIntegerRing methodsFor: 'accessing-private' stamp: 'len 11/29/2016 21:47:19'!
modulus: anInteger
	modulus _ anInteger! !

!ModularIntegerRing methodsFor: 'accessing-private' stamp: 'len 2/27/2017 20:48:23'!
relations: anIdeal
	super relations: anIdeal.
	self modulus: anIdeal generator! !

!ModularIntegerRing methodsFor: 'comparing' stamp: 'len 4/26/2018 20:11:02'!
= anObject
	self == anObject ifTrue: [^ true].
	(anObject isKindOf: ModularIntegerRing) ifFalse: [^ false].
	^ self modulus = anObject modulus! !

!ModularIntegerRing methodsFor: 'comparing' stamp: 'len 4/26/2018 20:11:10'!
hash
	^ self modulus hash! !

!ModularIntegerRing methodsFor: 'converting' stamp: 'len 5/26/2019 12:18:23'!
asAbelianGroup
	| answer |
	^ (answer _ AbelianGroup orders: {self modulus})
		addMap: (self to: answer evaluating: [:each| answer !! {each representative}]);
		addMap: (answer to: self evaluating: [:each| self !! (each at: 1)]);
		yourself! !

!ModularIntegerRing methodsFor: 'elements-testing' stamp: 'len 9/16/2018 16:09:03'!
isUnit: anElement
	"Answer true if the argument is invertible."
	^ (anElement representative gcd: self modulus) = 1! !

!ModularIntegerRing methodsFor: 'elements-testing' stamp: 'len 9/16/2018 16:31:52'!
isZeroDivisor: anElement
	"Answer true if there exists a nonzero element that multiplied by the argument is zero.
	An element in a finite ring is either a unit or a zero-divisor."
	^ (self isUnit: anElement) not! !

!ModularIntegerRing methodsFor: 'elements-tuples' stamp: 'len 5/8/2019 04:20:52'!
tuple: anArray
	^ self modulus = 2 ifTrue: [BitTuple coefficients: anArray] ifFalse: [ModularTuple coefficients: anArray over: self]! !

!ModularIntegerRing methodsFor: 'elements-tuples' stamp: 'len 5/4/2019 07:47:29'!
tupleClass
	^ self modulus = 2 ifTrue: [BitTuple] ifFalse: [ModularTuple]! !

!ModularIntegerRing methodsFor: 'enumerating' stamp: 'len 5/21/2018 07:28:56'!
do: aBlock
	0 to: self modulus - 1 do: [:i| aBlock value: (self project: i)]! !

!ModularIntegerRing methodsFor: 'enumerating' stamp: 'len 5/4/2018 23:28:53'!
primeIdealsDo: aBlock
	| p |
"	aBlock value: self * self zero."
	p _ 2.
	[p > modulus]
		whileFalse:
			[p | modulus ifTrue: [aBlock value: self * (self project: p)].
			p _ p nextPrime]

! !

!ModularIntegerRing methodsFor: 'morphisms' stamp: 'len 5/7/2018 22:53:40'!
lifting
	"Answer the map from the receiver to the rational integers lifting the canonical projection."
	| h |
	h _ modulus // 2.
	^ self to: self base evaluating: [:f| | r | (r _ f representative) > h ifTrue: [r - modulus] ifFalse: [r]]! !

!ModularIntegerRing methodsFor: 'morphisms' stamp: 'len 11/30/2016 18:48:51'!
project: anInteger
	^ self representative: anInteger \\ modulus! !

!ModularIntegerRing methodsFor: 'operations' stamp: 'len 5/2/2019 08:03:17'!
units
	"Answer the multiplicative group of units of the receiver (i.e., elements that have multiplicative inverse)."
	^ ModularIntegerUnitGroup on: self! !

!ModularIntegerRing methodsFor: 'random' stamp: 'len 4/25/2016 00:26'!
atRandom: aRandom
	^ self project: (self modulus atRandom: aRandom) - 1! !

!ModularIntegerRing methodsFor: 'random' stamp: 'len 4/19/2016 22:14'!
atRandom: aRandom bits: bitSize
	^ self atRandom: aRandom! !

!ModularIntegerRing methodsFor: 'testing' stamp: 'len 6/9/2018 20:15:48'!
includes: anObject
	^ anObject class = self elementClass and: [anObject modulus = self modulus]! !

!ModularIntegerRing methodsFor: 'testing' stamp: 'len 12/28/2016 12:13:20'!
isField
	^ self propertyAt: #isField ifAbsentPut: [self modulus isPrime]! !

!ModularIntegerRing methodsFor: 'testing' stamp: 'len 5/21/2018 05:09:16'!
isFinite
	^ true! !

!ModularIntegerRing methodsFor: 'testing' stamp: 'len 1/19/2018 22:33:59'!
isIntegralDomain
	^ self isField! !

!ModularIntegerRing methodsFor: 'testing' stamp: 'len 6/4/2019 18:39:42'!
isLocal
	"Z/mZ is local if and only if m is a prime power. See PrimePowerRing."
	^ self modulusFactors asSet size = 1! !

!ModularIntegerRing methodsFor: 'testing' stamp: 'len 9/27/2018 21:29:36'!
isPID
	^ self isIntegralDomain! !

!ModularIntegerRing methodsFor: 'testing' stamp: 'len 6/4/2019 15:09:28'!
isPIR
	"Answer true if the receiver is a principal ideal ring, i.e. all ideals are principal (but it is not necesarily a PID, i.e. it is not necesarily an integral domain)."
	^ true! !

!ModularIntegerRing methodsFor: 'testing' stamp: 'len 9/27/2018 15:54:29'!
isReduced
	"Answer true if the receiver has no non-zero nilpotent elements, or equivalently if it has no non-zero elements with square zero, i.e. x^2 = 0 implies x = 0.
	This is true if the modulus is square-free."
	modulus = 0 ifTrue: [^ true].
	self modulusFactorization withOccurrencesDo: [:p :e| e > 1 ifTrue: [^ false]].
	^ true

"	^ modulus = 0 or: [modulus isSquareFree]"! !

!ModularIntegerRing methodsFor: 'private' stamp: 'len 1/5/2017 08:14:58'!
elementClass
	^ ModularInteger! !

!ModularIntegerRing methodsFor: 'private' stamp: 'len 5/21/2018 04:19:36'!
modulusFactors
	^ self propertyAt: #modulusFactors ifAbsentPut: [self modulus factors]! !

!ModularIntegerRing class methodsFor: 'instance creation' stamp: 'len 11/29/2016 21:46:49'!
new: anInteger
	^ self new modulus: anInteger! !

!PrimePowerRing methodsFor: 'accessing' stamp: 'len 9/22/2018 18:56:21'!
degree
	"Answer the degree of the receiver as an algebraic extension (as a Galois ring)."
	^ 1! !

!PrimePowerRing methodsFor: 'accessing' stamp: 'len 5/21/2018 04:19:07'!
exponent
	^ self propertyAt: #exponent ifAbsentPut: [self modulusFactors size]! !

!PrimePowerRing methodsFor: 'accessing' stamp: 'len 5/21/2018 04:13:20'!
maximalIdeal
	^ self * self p! !

!PrimePowerRing methodsFor: 'accessing' stamp: 'len 5/21/2018 04:18:30'!
p
	^ self propertyAt: #p ifAbsentPut: [self modulusFactors anyOne]! !

!PrimePowerRing methodsFor: 'accessing' stamp: 'len 9/22/2018 18:56:46'!
primeSubfield
	^ self propertyAt: #primeSubfield ifAbsentPut: [PrimeField new: self p]! !

!PrimePowerRing methodsFor: 'accessing' stamp: 'len 6/4/2019 18:34:10'!
residueField
	"Answer the prime field Z/pZ isomorphic to the residue field of the receiver, equiped with the canonical projection."
	^ self propertyAt: #residueField ifAbsentPut:
		[| answer |
		(answer _ PrimeField new: self p)
			addMap: (self onto: answer evaluating: [:x| answer !! x representative]); "TODO: add kernel and section"
			yourself]! !

!PrimePowerRing methodsFor: 'accessing-private' stamp: 'len 9/22/2018 18:56:42'!
p: aPrime to: anInteger
	self modulus: aPrime^anInteger.
	self propertyAt: #modulusFactors put: (Bag new add: aPrime withOccurrences: anInteger; yourself)! !

!PrimePowerRing methodsFor: 'enumerating' stamp: 'len 9/22/2018 18:56:26'!
idealsDo: aBlock
	"The ideals of Z/(p^n)Z are {0} and <p^i> for 0 <= i < n-1."
	| a |
	aBlock value: self * 0.
	a _ self one.
	self exponent timesRepeat:
		[aBlock value: self * a.
		a _ a * self p]! !

!PrimePowerRing methodsFor: 'morphisms' stamp: 'len 6/6/2019 11:18:44'!
from: aDomain
	((aDomain isKindOf: AdicIntegerRing) and: [aDomain p = self p])
		ifTrue: [^ (aDomain onto: self evaluating: [:x| self projectAdicInteger: x]) name: Character pi asString, self exponent asString sub].
	^ super from: aDomain! !

!PrimePowerRing methodsFor: 'morphisms' stamp: 'len 6/3/2019 15:17:18'!
projectAdicInteger: anAdicInteger
	| p x digits |
	p _ self p.
	digits _ anAdicInteger digits.
	x _ 0.
	self exponent to: 1 by: -1 do: [:i| x _ x*p + (digits at: i)].
	^ self project: x! !

!PrimePowerRing methodsFor: 'morphisms' stamp: 'len 6/2/2019 16:47:37'!
to: aCodomain
	"Cannonical projection from Z/(p^n)Z to Z/(p^m)Z, 1 <= m <= n."
	((aCodomain isKindOf: PrimePowerRing) and: [aCodomain p = self p and: [aCodomain exponent < self exponent]])
		ifTrue: [^ (self onto: aCodomain evaluating: [:x| aCodomain project: x representative]) name: Character pi asString].
	^ super to: aCodomain! !

!PrimePowerRing methodsFor: 'operations' stamp: 'len 5/21/2018 16:20:06'!
extension: aPolynomial
	"Answer the Galois overring of the receiver defined by the given irreducible polynomial."
	aPolynomial scalars = self ifFalse: [DomainError signal: 'polynomial coefficients not from this ring'].
	aPolynomial parent isUnivariate ifFalse: [DomainError signal: 'not univariate poylnomial'].
	^ GaloisRing polynomial: aPolynomial! !

!PrimePowerRing methodsFor: 'operations' stamp: 'len 5/21/2018 15:42:20'!
nilradical
	"Answer the ideal consisting of all nilpotent elements, i.e. all x such that there exists some n with x^n = 0. It is the intersection of all prime ideals.
	A finite ring is a Galois ring iff its nilradical is of the form <p> for some prime p. This is also the unique maximal ideal."
	^ self maximalIdeal! !

!PrimePowerRing methodsFor: 'operations' stamp: 'len 5/21/2018 06:56:18'!
zeroDivisors
	"The zero-divisors of a Galois ring Z/<p^k> constitute the unique maximal ideal <p>."
	^ self maximalIdeal! !

!PrimePowerRing methodsFor: 'testing' stamp: 'len 9/16/2018 23:16:07'!
isChainRing
	"A chain ring is a ring whose ideals form a chain under inclusion.
	Prime rings, and more generally Galois rings, are chain rings."
	^ true! !

!PrimePowerRing methodsFor: 'testing' stamp: 'len 5/21/2018 17:11:32'!
isEuclidean
	"Galois rings are euclidean."
	^ true! !

!PrimePowerRing methodsFor: 'testing' stamp: 'len 5/21/2018 04:26:10'!
isField
	^ self exponent = 1! !

!PrimePowerRing methodsFor: 'testing' stamp: 'len 9/22/2018 18:56:29'!
isGaloisRing
	^ true! !

!PrimePowerRing methodsFor: 'testing' stamp: 'len 5/21/2018 04:12:49'!
isLocal
	^ true! !

!PrimePowerRing methodsFor: 'testing' stamp: 'len 9/22/2018 18:56:32'!
isNilpotent: anElement
	"Answer true if anElement^n = 0 for some integer n >= 1."
	^ self isZeroDivisor: anElement! !

!PrimePowerRing methodsFor: 'testing' stamp: 'len 9/22/2018 18:57:35'!
isPIR
	"All nontrivial ideals are of the form <p^i>."
	^ true! !

!PrimePowerRing methodsFor: 'testing' stamp: 'len 9/16/2018 16:24:53'!
isUnit: anElement
	"Answer true if the argument is invertible."
	^ (self p | anElement representative) not! !

!PrimePowerRing methodsFor: 'testing' stamp: 'len 9/16/2018 17:57:54'!
isZeroDivisor: anElement
	"Answer true if there exists a nonzero element that multiplied by the argument is zero."
	^ self p | anElement representative! !

!PrimePowerRing methodsFor: 'as yet unclassified' stamp: 'len 6/5/2019 13:32:28'!
associatedUnit: anElement
	"Answer a choice for associated unit of anElement."
	| p q |
	anElement isZero ifTrue: [^ self one].
	p _ self p.
	q _ anElement representative.
	[p | q] whileTrue: [q _ q // p].
	^ self project: q! !

!PrimePowerRing methodsFor: 'as yet unclassified' stamp: 'len 6/5/2019 13:33:00'!
valuation: anElement
	^ anElement representative valuation: self p! !

!PrimePowerRing class methodsFor: 'examples' stamp: 'len 5/15/2019 06:45:14'!
example1
	"The Galois ring Z/<5^3>:"
	^ PrimePowerRing new: 5 to: 3! !

!PrimePowerRing class methodsFor: 'examples' stamp: 'len 5/21/2018 16:30:41'!
example2
	"Another way to create the Galois ring Z/<5^3>.
	This is less efficient because internally it performs a factorization."
	^ ZZ/(5^3)! !

!PrimePowerRing class methodsFor: 'examples' stamp: 'len 4/19/2019 04:54:57'!
example3
	"The canonical ring homomorphism from a prime ring Z/(p^n)Z to Z/pZ:"
	^ ZZ/(5^3) -> (ZZ/5)! !

!PrimePowerRing class methodsFor: 'instance creation' stamp: 'len 5/21/2018 16:28:00'!
new: p to: n
	n = 1 ifTrue: [^ PrimeField new: p].
	^ self new p: p to: n! !

!PrimeField methodsFor: 'accessing' stamp: 'len 9/22/2018 18:56:03'!
primeSubfield
	^ self! !

!PrimeField methodsFor: 'accessing' stamp: 'len 6/11/2018 06:33:23'!
primitiveRoot
	"When the receiver is a field Z/<p>, answer a primitive root modulo p."
	^ self propertyAt: #primitiveRoot ifAbsentPut: [self computePrimitiveRoot]! !

!PrimeField methodsFor: 'accessing-private' stamp: 'len 5/21/2018 04:28:02'!
p: aPrime to: anInteger
	anInteger = 1 ifFalse: [^ self error: 'exponent must be 1'].
	super p: aPrime to: anInteger! !

!PrimeField methodsFor: 'comparing' stamp: 'len 9/22/2018 18:56:11'!
~ aRing
	"Any two finite fields of the same cardinality are isomorphic."
	^ aRing isField and: [self size = aRing size]! !

!PrimeField methodsFor: 'elements-operations' stamp: 'len 9/25/2018 15:36:26'!
reciprocalOf: anElement
	^ self representative: ((self inverseOfRepresentative: anElement representative) ifNil: [^ nil])! !

!PrimeField methodsFor: 'elements-operations' stamp: 'len 12/29/2016 08:04:45'!
squareRootOf: anElement
	^ self representative: ((self squareRootOfRepresentative: anElement representative) ifNil: [^ nil])! !

!PrimeField methodsFor: 'enumerating' stamp: 'len 5/4/2018 20:12:15'!
primeIdealsDo: aBlock
	aBlock value: self zeroIdeal! !

!PrimeField methodsFor: 'operations' stamp: 'len 5/21/2018 16:20:33'!
extension: aPolynomial
	"Answer the Galois overfield of the receiver defined by the given irreducible polynomial."
	aPolynomial scalars = self ifFalse: [DomainError signal: 'polynomial coefficients not from this field'].
	aPolynomial parent isUnivariate ifFalse: [DomainError signal: 'not univariate poylnomial'].
	^ GaloisField polynomial: aPolynomial! !

!PrimeField methodsFor: 'operations' stamp: 'len 5/2/2018 16:04:38'!
zeroDivisors
	^ {self zero}! !

!PrimeField methodsFor: 'testing' stamp: 'len 10/18/2016 20:46'!
isField
	^ true! !

!PrimeField methodsFor: 'testing' stamp: 'len 9/22/2018 18:56:07'!
isGaloisField
	^ true! !

!PrimeField methodsFor: 'testing' stamp: 'len 9/16/2018 16:24:43'!
isUnit: anElement
	"Answer true if the argument is invertible."
	^ anElement isZero not! !

!PrimeField methodsFor: 'testing' stamp: 'len 9/16/2018 16:31:43'!
isZeroDivisor: anElement
	"Answer true if there exists a nonzero element that multiplied by the argument is zero."
	^ anElement isZero! !

!PrimeField methodsFor: 'private' stamp: 'len 9/2/2018 21:03:24'!
computePrimitiveRoot
	| a order primeFactors |
	modulus = 2 ifTrue: [^ self one].
	order _ modulus - 1.
	primeFactors _ order factors asSet.
	a _ 2.
	[primeFactors anySatisfy: [:pi| (a raisedTo: order / pi modulo: modulus) = 1]]
		whileTrue:
			[a _ a + 1.
			a >= modulus ifTrue: [self error: 'no primitive element, the modulus is not prime']].
	^ self representative: a! !

!PrimeField methodsFor: 'private' stamp: 'len 11/30/2016 19:12:00'!
inverseOfRepresentative: anInteger
	| result |
	anInteger == 0 ifTrue: [^ nil].
	anInteger == 1 ifTrue: [^ 1].
	result _ anInteger xgcd: modulus.
	^ (result at: 2) \\ modulus! !

!PrimeField methodsFor: 'private' stamp: 'len 12/29/2016 08:05:44'!
squareRootOfRepresentative: anInteger
	| algorithm |
	algorithm _ self propertyAt: #squareRootAlgorithm ifAbsentPut: [TonelliShanks new modulus: self modulus].
	^ algorithm squareRootOf: anInteger! !

!SmallPrimeField methodsFor: 'accessing' stamp: 'len 6/9/2018 20:23:46'!
expTable
	^ expTable! !

!SmallPrimeField methodsFor: 'accessing' stamp: 'len 6/9/2018 20:23:52'!
logTable
	^ logTable! !

!SmallPrimeField methodsFor: 'accessing-private' stamp: 'len 11/30/2016 09:43:55'!
modulus: anInteger
	super modulus: anInteger.
	self computeTables! !

!SmallPrimeField methodsFor: 'private' stamp: 'len 9/2/2018 21:27:06'!
computeTables
	| g x |
	expTable _ WordArray new: modulus - 1. "n -> g^n"
	logTable _ WordArray new: modulus - 1. "g^n -> n"
	g _ self primitiveRoot representative.
	x _ 1.
	1 to: modulus - 1 do: [:i|
		"g^n -> n:"
		logTable at: x put: i - 1.
		x _ x * g \\ modulus.
		"n -> g^n:"
		expTable at: i put: x]! !

!SmallPrimeField methodsFor: 'private' stamp: 'len 6/9/2018 23:25:43'!
elementClass
	^ SmallPrimeFieldElement! !

!SmallPrimeField methodsFor: 'private' stamp: 'len 11/30/2016 19:12:33'!
inverseOfRepresentative: anInteger
	anInteger == 0 ifTrue: [^ nil].
	anInteger == 1 ifTrue: [^ 1].
	^ expTable at: modulus - 1 - (logTable at: anInteger)! !

!AffineRing methodsFor: 'accessing' stamp: 'len 11/3/2016 04:30'!
characteristic
	^ self base characteristic! !

!AffineRing methodsFor: 'accessing' stamp: 'len 9/22/2018 18:46:29'!
degree
	^ self relations degree "conflicts with AlgebraicExtension>>degree?"! !

!AffineRing methodsFor: 'accessing' stamp: 'len 2/27/2017 20:57:23'!
dimension
	"Answer the Krull dimension of the receiver. Seen as a field extension, this is its transcendence degree."
	"Derksen, Kemper, 'Computational Invariant Theory', 2002, Algorithm 1.2.4 (Dimension of an ideal)."
	self relations isZero ifTrue: [^ self base dimension].
	self isTrivial ifTrue: [^ -1]. "i.e., the ideal is the whole polynomial ring"
	self scalars isField ifFalse: [self notYetImplemented].
	^ self relations maximallyIndependentIndeterminates size! !

!AffineRing methodsFor: 'accessing' stamp: 'len 10/20/2016 10:51'!
indeterminates
	^ self base indeterminates! !

!AffineRing methodsFor: 'accessing' stamp: 'len 12/28/2017 14:50:03'!
monomials
	"Answer the monoid of monomials of the receiver."
	^ self base monomials! !

!AffineRing methodsFor: 'accessing' stamp: 'len 1/5/2017 08:49:59'!
ordering
	^ self base ordering! !

!AffineRing methodsFor: 'accessing' stamp: 'len 12/30/2016 09:47:01'!
rank
	"Answer the number of indeterminates in the receiver."
	^ self base rank! !

!AffineRing methodsFor: 'accessing' stamp: 'len 12/30/2016 09:46:48'!
scalars
	"Answer the coefficients ring of the receiver."
	^ self base scalars! !

!AffineRing methodsFor: 'accessing' stamp: 'len 2/27/2017 20:57:53'!
vectorSpaceDimension
	"Answer the dimension of the receiver as vector space over the coefficients field."
	self relations isZeroDimensional ifFalse: [^ Infinity positive].
	self notYetImplemented! !

!AffineRing methodsFor: 'converting' stamp: 'len 1/8/2017 22:02:04'!
asModule
"	^ FreeModule
		basis: ((1 to: self degree) collect: [:i| self x ^ (i-1)])
		coordinates: [:aVector| self scalars tuple: self degree evaluating: [:i| aVector representative coefficientAtDegree: i-1]]
		over: self scalars
"
	self notYetImplemented! !

!AffineRing methodsFor: 'converting' stamp: 'len 2/27/2017 20:57:38'!
orderedBy: aMonomialOrdering
	^ self class mod: (self relations orderedBy: aMonomialOrdering)! !

!AffineRing methodsFor: 'elements' stamp: 'len 5/18/2018 21:00:05'!
!! anObject
	(self scalars includes: anObject)
		ifTrue: [^ self project: (self base constant: anObject)].
	^ super !! anObject! !

!AffineRing methodsFor: 'elements' stamp: 'len 10/20/2016 10:50'!
x
	^ self x: 1! !

!AffineRing methodsFor: 'elements' stamp: 'len 10/20/2016 10:50'!
x: anInteger
	^ self project: (self base x: anInteger)! !

!AffineRing methodsFor: 'elements' stamp: 'len 10/20/2016 10:50'!
y
	^ self x: 2! !

!AffineRing methodsFor: 'elements' stamp: 'len 10/20/2016 10:50'!
z
	^ self x: 3! !

!AffineRing methodsFor: 'morphisms' stamp: 'len 12/30/2016 10:05:13'!
embed: anObject
	"Answer the embedding of an element of the coefficients ring into the receiver."
	^ self project: (self base embed: anObject)! !

!AffineRing methodsFor: 'morphisms' stamp: 'len 5/13/2019 19:03:50'!
from: aDomain
	aDomain = self scalars ifTrue: [^ self addMap: ((self scalars to: self evaluating: [:x| self embed: x]) name: 'i')].
	aDomain -> self scalars ifNotNil: [:aMorphism| ^ aMorphism -> self].
	^ super from: aDomain! !

!AffineRing methodsFor: 'operations' stamp: 'len 1/7/2018 17:28:21'!
^ n
	(n isInteger and: [self isMultivariate]) ifFalse: [^ super ^ n].
	^ MultivariateTupleModule new: n over: self! !

!AffineRing methodsFor: 'operations' stamp: 'len 5/14/2019 20:48:34'!
 aRing
	"Answer the tensor product of the receiver with the argument."
	| R relations |
	((aRing isKindOf: AffineRing) and: [aRing scalars = self scalars])
		ifFalse: [^ self notYetImplemented].
	R _ self base  aRing base.
	relations _ OrderedCollection new.
	self relations generators do: [:f| relations add: R !! f].
	aRing relations generators do: [:g| relations add: (R !! g substitute: [:i| i + self base rank])].
	^ R / relations! !

!AffineRing methodsFor: 'operations' stamp: 'len 10/27/2016 18:44'!
hilbertSeries
	"Answer the Hilbert series of the receiver."
	^ self hilbertSeriesAt: (QQ polynomialsIn: #(t)) fractions x! !

!AffineRing methodsFor: 'operations' stamp: 'len 2/27/2017 20:57:29'!
hilbertSeriesAt: t
	"Answer the Hilbert series of the receiver."
	^ (self base hilbertSeriesAt: t) - (self relations hilbertSeriesAt: t)! !

!AffineRing methodsFor: 'operations' stamp: 'len 1/11/2018 18:03:42'!
localization
	"Answer the localization of the receiver at <x1,...,xn>. This is achieved by choosing a local ordering.
	Objects defined in this localization contain geometric information (usually only) about a Zariski neighbourhood of 0 in K^n, while objects in the global ring contain geometric information whish is valid in the whole affine space K^n."
	self isGlobal ifFalse: [DomainError signal: 'the ring is not global'].
	^ self orderedBy: #lglex! !

!AffineRing methodsFor: 'operations' stamp: 'len 2/27/2017 20:57:49'!
proj
	"Answer the projective spectrum of the receiver, Proj(R)."
	self relations isHomogeneous ifFalse: [^ DomainError signal: 'not a quotient by a homogeneous ideal, not properly graded'].
	^ ProjectiveVariety coordinateRing: self! !

!AffineRing methodsFor: 'operations' stamp: 'len 2/22/2017 07:58:22'!
spec
	"Answer the spectrum of the receiver, Spec(R/I) as subscheme of Spec(R)."
	^ AffineVariety coordinateRing: self! !

!AffineRing methodsFor: 'testing' stamp: 'len 2/12/2017 05:49:37'!
isGlobal
	^ self base isGlobal! !

!AffineRing methodsFor: 'testing' stamp: 'len 2/27/2017 20:57:34'!
isGraded
	^ self base isGraded and: [self relations isHomogeneous]! !

!AffineRing methodsFor: 'testing' stamp: 'len 1/7/2018 17:28:33'!
isMultivariate
	^ self base isMultivariate! !

!AffineRing methodsFor: 'testing' stamp: 'len 4/8/2018 18:45:19'!
isUnivariate
	^ self base isUnivariate! !

!AffineRing methodsFor: 'private' stamp: 'len 1/18/2017 22:52:12'!
elementClass
	^ RegularFunction! !

!AlgebraicExtensionRing methodsFor: 'accessing' stamp: 'len 11/3/2016 04:35'!
characteristic
	^ self scalars characteristic! !

!AlgebraicExtensionRing methodsFor: 'accessing' stamp: 'len 9/22/2018 18:46:36'!
degree
	"Answer the degree [E:F] of the relative extension E/F."
	^ self polynomial degree "conflicts with AffineRing>>degree?"! !

!AlgebraicExtensionRing methodsFor: 'accessing' stamp: 'len 1/5/2017 19:19:00'!
degreeOver: aSubfield
	"Answer the degree [E:F] of the relative extension E/F."
	self = aSubfield ifTrue: [^ 1].
	self scalars = aSubfield ifTrue: [^ self degree].
	^ self degree * (self scalars degreeOver: aSubfield)! !

!AlgebraicExtensionRing methodsFor: 'accessing' stamp: 'len 2/27/2017 20:56:46'!
polynomial
	^ self relations generator! !

!AlgebraicExtensionRing methodsFor: 'accessing' stamp: 'len 11/3/2016 04:36'!
size
	^ self scalars size ^ self degree! !

!AlgebraicExtensionRing methodsFor: 'accessing' stamp: 'len 11/3/2016 04:33'!
x
	"Answer the transcendental element of the receiver."
	^ self project: self base x! !

!AlgebraicExtensionRing methodsFor: 'accessing-private' stamp: 'len 2/27/2017 20:48:43'!
polynomial: aPolynomial
	self relations: aPolynomial parent * aPolynomial! !

!AlgebraicExtensionRing methodsFor: 'converting' stamp: 'len 5/11/2019 02:21:44'!
asModule
	^ self propertyAt: #asModule ifAbsentPut:
		[| M |
		M _ self scalars ^ self degree.
		self addMap:
			(self to: M evaluating:
				[:a| self scalars tuple: self degree evaluating: [:i| a representative 	coefficientAtDegree: i-1]]);
			addMap:
			(M to: self evaluating:
				[:v| (1 to: v size) sum: [:i| self x ^ (i-1) * (v at: i)]]).
		M]

"	^ AlgebraicExtensionAsModule on: self"
"	^ FreeModule
		basis: ((1 to: self degree) collect: [:i| self x ^ (i-1)])
		coordinates: [:aVector| self scalars tuple: self degree evaluating: [:i| aVector representative coefficientAtDegree: i-1]]
		over: self scalars"

"
	QQ extension: QQ polynomials x^4 - 2 :: asVectorSpace
"! !

!AlgebraicExtensionRing methodsFor: 'converting' stamp: 'len 5/21/2018 04:46:30'!
asVectorSpace
	self scalars isField ifFalse: [^ DomainError signal].
	^ self asModule! !

!AlgebraicExtensionRing methodsFor: 'morphisms' stamp: 'len 5/6/2019 03:35:42'!
automorphisms
	"Answer the Galous group of the receiver (assuming the receiver is a Galois extension)."
	self isFinite ifTrue: [^ Group new generators: {self frobenius}].
	self flag: #fix. "This is actually isomorphic to the Galois group, not the actual Galois group, it should act on elements of the extension and it's not the full symmetric group."
	^ SymmetricGroup on: (self embeddings collect: [:each| each value: self x])! !

!AlgebraicExtensionRing methodsFor: 'morphisms' stamp: 'len 12/28/2016 12:12:31'!
embeddings
	"Answer the n distinct embeddings of the receiver in the algebraic closure of the base field, where n is the degree of the receiver. In the case of number fields, the embeddings go to the complex algebraic numbers.
	When the receiver is a Galois extension, the embeddings send each element to one of its conjugates, and their images are the same."
	^ self propertyAt: #embeddings ifAbsentPut: [self embeddingsIn: self scalars algebraicClosure]! !

!AlgebraicExtensionRing methodsFor: 'morphisms' stamp: 'len 4/29/2018 17:24:35'!
embeddingsIn: aField
	^ (self polynomial rootsIn: aField) asArray
		collect: [:x| self to: aField evaluating: [:alpha| alpha representative value: x]]! !

!AlgebraicExtensionRing methodsFor: 'testing' stamp: 'len 5/21/2018 04:44:34'!
isField
	^ self scalars isField! !

!AlgebraicExtensionRing methodsFor: 'testing' stamp: 'len 5/21/2018 05:12:35'!
isIntegralDomain
	^ self isField or: [super isIntegralDomain]! !

!AlgebraicExtensionRing methodsFor: 'testing' stamp: 'len 6/6/2019 11:39:01'!
isLocalField
	^ self scalars isLocalField! !

!AlgebraicExtensionRing methodsFor: 'private' stamp: 'len 1/20/2018 18:41:22'!
elementClass
	^ AlgebraicElement! !

!AlgebraicExtensionRing class methodsFor: 'examples' stamp: 'len 2/22/2017 08:47:43'!
example
	^ QQ extension: QQ polynomials x^4 - 2! !

!AlgebraicExtensionRing class methodsFor: 'instance creation' stamp: 'len 5/12/2016 10:05'!
polynomial: aPolynomial
	"Answer a new algebraic field extension K(f) where f is the given polynomial in K[x]. The polynomial must be irreducible, otherwise there would be zero divisors."
	^ self new polynomial: aPolynomial! !

!GaloisRing methodsFor: 'accessing' stamp: 'len 5/9/2019 09:25:41'!
exponent
	^ self scalars exponent! !

!GaloisRing methodsFor: 'accessing' stamp: 'len 5/21/2018 16:59:28'!
maximalIdeal
	^ self * self scalars p! !

!GaloisRing methodsFor: 'accessing' stamp: 'len 5/22/2018 04:08:03'!
p
	^ self scalars p! !

!GaloisRing methodsFor: 'accessing' stamp: 'len 9/22/2018 18:54:23'!
primitiveRoot
	"Answer a primitive root (or basic primitive element) of the receiver.
	For GR(p^n,r), a basic primitive element is an element of multiplicative order p^r - 1, which is a root of a basic primitive polynomial of degree r over Z/(p^n)Z and dividing x^(p^r - 1) - 1 in Z/(p^n)Z[x]. Powers of this element form a Teichmuller set."
	^ self notYetImplemented! !

!GaloisRing methodsFor: 'accessing' stamp: 'len 9/22/2018 18:54:27'!
teichmuller
	"Answer a Teichmuller set of the receiver.
	Any element of GR(p^n,r) can be written as a polynomial in p with coefficients in the Teichmuller set."
	| answer w |
	answer _ OrderedCollection new: self characteristic.
	answer add: self zero; add: self one.
	w _ self primitiveRoot.
	self characteristic - 2 timesRepeat: [answer add: (answer last * w)].
	^ answer! !

!GaloisRing methodsFor: 'enumerating' stamp: 'len 9/22/2018 18:53:46'!
idealsDo: aBlock
	| a |
	aBlock value: self * 0.
	a _ self one.
	self exponent timesRepeat:
		[aBlock value: self * a.
		a _ a * self p]! !

!GaloisRing methodsFor: 'morphisms' stamp: 'len 5/9/2019 09:13:37'!
to: aCodomain
	aCodomain isGaloisRing ifFalse: [^ super to: aCodomain].
	"The subrings of GR(p^n,r) correspond to the positive divisors of r. If aCodomain is a suitable overring, answer an embedding of the receiver into the overring."
	(self characteristic = aCodomain characteristic and: [self degree | aCodomain degree])
		ifTrue: [^ self into: aCodomain evaluating: [:x| aCodomain project: (x representative ^ (self p ^ (aCodomain degree / self degree)))]].
	"Given GR(p^n,r), there's a projection to GR(p^m,r) for all m<=n, with kernel <p^m>. This accounts for all ideals."
	(self p = aCodomain p and: [self degree = aCodomain degree])
		ifTrue: [self scalars -> aCodomain scalars ifNotNil: [:aMorphism| ^ self to: aCodomain evaluating: [:x| aCodomain project: (x representative apply: aMorphism)]]].
	^ super to: aCodomain! !

!GaloisRing methodsFor: 'operations' stamp: 'len 9/16/2018 17:58:11'!
isUnit: anElement
	"Answer true if the argument is invertible."
	^ (self maximalIdeal contains: anElement) not! !

!GaloisRing methodsFor: 'operations' stamp: 'len 9/16/2018 17:58:28'!
isZeroDivisor: anElement
	"Answer true if there exists a nonzero element that multiplied by the argument is zero."
	^ self maximalIdeal contains: anElement! !

!GaloisRing methodsFor: 'operations' stamp: 'len 5/21/2018 15:42:01'!
nilradical
	"Answer the ideal consisting of all nilpotent elements, i.e. all x such that there exists some n with x^n = 0. It is the intersection of all prime ideals.
	A finite ring is a Galois ring iff its nilradical is of the form <p> for some prime p. This is also the unique maximal ideal."
	^ self maximalIdeal! !

!GaloisRing methodsFor: 'operations' stamp: 'len 5/21/2018 06:53:52'!
zeroDivisors
	^ self maximalIdeal! !

!GaloisRing methodsFor: 'testing' stamp: 'len 6/4/2019 15:59:26'!
isBezout
	"Answer true if the receiver is a Bezout ring, i.e. every finitely generated ideal is principal."
	"All non-zero ideals are of the form <p^i>."
	^ true! !

!GaloisRing methodsFor: 'testing' stamp: 'len 9/16/2018 23:15:40'!
isChainRing
	"A chain ring is a ring whose ideals form a chain under inclusion.
	Galois rings are chain rings."
	^ true! !

!GaloisRing methodsFor: 'testing' stamp: 'len 5/21/2018 17:11:23'!
isEuclidean
	"Galois rings are euclidean."
	^ true! !

!GaloisRing methodsFor: 'testing' stamp: 'len 5/21/2018 05:07:00'!
isFinite
	^ true! !

!GaloisRing methodsFor: 'testing' stamp: 'len 5/21/2018 05:06:26'!
isGaloisExtension
	^ true! !

!GaloisRing methodsFor: 'testing' stamp: 'len 9/22/2018 18:54:20'!
isGaloisRing
	^ true! !

!GaloisRing methodsFor: 'testing' stamp: 'len 5/21/2018 16:54:03'!
isLocal
	^ true! !

!GaloisRing class methodsFor: 'class initialization' stamp: 'len 5/15/2019 10:35:45'!
initialize
	super initialize.
	IrreduciblePolynomialsCache _ WeakValueDictionary new! !

!GaloisRing class methodsFor: 'examples' stamp: 'len 5/21/2018 07:19:51'!
example1
	"The Galois ring of characteristic 2^3 and order 2^6."
	^ GaloisRing new: 2 to: 3 to: 6! !

!GaloisRing class methodsFor: 'instance creation' stamp: 'len 5/21/2018 06:50:29'!
new: q to: m
	"Answer the Galois ring of characteristic q and order q^m."
	| factors n p |
	factors _ q factors.
	factors asSet size = 1 ifFalse: [^ self error: 'not power of a prime'].
	n _ factors size.
	p _ factors anyOne.
	^ self new: p to: n to: m! !

!GaloisRing class methodsFor: 'instance creation' stamp: 'len 5/15/2019 10:41:24'!
new: p to: n to: m
	"Answer the Galois ring of characteristic p^n and order p^(n*m)."
	| F f |
	n = 1 ifTrue: [^ GaloisField new: p to: m].
	F _ PrimePowerRing new: p to: n.
	m = 1 ifTrue: [^ F].
	f _ self irreduciblePolynomialOfDegree: m mod: p.
	"Hensel lift to F"
	f _ f lift apply: F projection.
	^ self polynomial: f! !

!GaloisRing class methodsFor: 'private' stamp: 'len 5/15/2019 10:41:16'!
irreduciblePolynomialOfDegree: m mod: p
	^ (IrreduciblePolynomialsCache at: {p. m} ifAbsent: []) ifNil: [IrreduciblePolynomialsCache at: {p. m} put: ((PrimeField new: p) polynomials findIrreducibleOfDegree: m)]! !

!GaloisField methodsFor: 'accessing' stamp: 'len 5/27/2018 04:39:39'!
universalPolynomial
	"Answer the universal polynomial of which all elements of the receiver are roots."
	^ ZZ polynomials !! [:x| x^self size - x]! !

!GaloisField methodsFor: 'comparing' stamp: 'len 9/22/2018 18:53:34'!
~ aRing
	"Any two finite fields of the same cardinality are isomorphic."
	^ aRing isField and: [self size = aRing size]! !

!GaloisField methodsFor: 'morphisms' stamp: 'len 5/6/2019 03:35:29'!
automorphisms
	"Answer the Galous group of the receiver."
	^ Group new generators: {self frobenius}! !

!GaloisField methodsFor: 'testing' stamp: 'len 12/14/2016 10:15:29'!
isAbelianExtension
	"Galois fields are Abelian extensions."
	^ true! !

!GaloisField methodsFor: 'testing' stamp: 'len 9/22/2018 18:53:39'!
isGaloisField
	^ true! !

!GaloisField class methodsFor: 'examples' stamp: 'len 5/21/2018 06:46:16'!
example1
	"The Galois field of order 2^3."
	^ GaloisField new: 8! !

!GaloisField class methodsFor: 'examples' stamp: 'len 5/21/2018 06:46:33'!
example2
	"The Galois field of order 5^3."
	^ GaloisField new: 5 to: 3! !

!GaloisField class methodsFor: 'instance creation' stamp: 'len 12/12/2016 08:40:10'!
new: q
	"Answer the Galois field of order q = p^n."
	| factors n p |
	factors _ q factors.
	factors asSet size = 1 ifFalse: [^ self error: 'not power of a prime'].
	n _ factors size.
	p _ factors anyOne.
	^ self new: p to: n! !

!GaloisField class methodsFor: 'instance creation' stamp: 'len 5/15/2019 10:42:11'!
new: p to: n
	"Answer the Galois field of order q = p^n."
	n = 1 ifTrue: [^ PrimeField new: p].
	^ self polynomial: (self irreduciblePolynomialOfDegree: n mod: p)! !

!QuasiGaloisRing methodsFor: 'testing' stamp: 'len 5/9/2019 09:48:43'!
isFinite
	^ true! !

!QuasiGaloisRing methodsFor: 'testing' stamp: 'len 5/9/2019 09:54:52'!
isIntegralDomain
	^ false! !

!QuasiGaloisRing methodsFor: 'testing' stamp: 'len 5/9/2019 09:48:39'!
isLocal
	^ true! !

!QuasiGaloisRing class methodsFor: 'instance creation' stamp: 'len 5/9/2019 09:52:23'!
new: p to: r to: n
	"Answer Quasi-Galois ring of characteristic p and order p^(r*n)."
	| F f |
	F _ GaloisField new: p to: r.
	n = 1 ifTrue: [^ F].
	f _ F polynomials xTo: n.
	^ self polynomial: f! !

!FunctionField methodsFor: 'as yet unclassified' stamp: 'len 1/5/2017 19:50:45'!
genus
	^ self notYetImplemented! !

!FunctionField methodsFor: 'testing' stamp: 'len 9/22/2018 18:48:55'!
isGlobalField
	^ self scalars isGaloisField! !

!FunctionField methodsFor: 'testing' stamp: 'len 1/5/2017 18:55:12'!
isPerfectField
	"A field is perfect if either it has characteristic 0 or has characteristic p and every element in the field has a p-th root in the field."
	^ self characteristic = 0! !

!NumberField methodsFor: 'accessing' stamp: 'len 4/16/2018 16:04:31'!
adjoint
	^ self propertyAt: #adjoint ifAbsentPut: [self polynomial anyRootIn: CC]! !

!NumberField methodsFor: 'accessing' stamp: 'len 1/10/2016 22:35'!
basis
	^ self integralBasis! !

!NumberField methodsFor: 'accessing' stamp: 'len 12/28/2016 12:12:59'!
discriminant
	"The discriminant of an integral basis is independent of the choice of basis and it's called the discriminant of the field K and denoted d(K)."
	^ self propertyAt: #discriminant ifAbsentPut: [self integralBasis discriminant]! !

!NumberField methodsFor: 'accessing' stamp: 'len 3/4/2017 19:28:09'!
integers
	"Answer the ring of integers of the receiver."
	^ NumberRing on: self! !

!NumberField methodsFor: 'accessing' stamp: 'len 1/11/2016 03:48'!
integralBasis
	^ self notYetImplemented "COHEN 6.1.8"! !

!NumberField methodsFor: 'accessing' stamp: 'len 11/3/2016 04:41'!
scalars
	^ QQ! !

!NumberField methodsFor: 'accessing' stamp: 'len 3/19/2016 09:33'!
signature
	"Answer the signature (r1,r2) of the receiver, i.e. r1 the number of embeddings whose image is real, and 2*r2 the number of non-real complex embeddings."
	^ self polynomial signature! !

!NumberField methodsFor: 'accessing-private' stamp: 'len 12/28/2016 12:12:50'!
adjoint: anAlgebraicNumber
	self propertyAt: #adjoint put: anAlgebraicNumber.
	self polynomial: anAlgebraicNumber minimalPolynomial! !

!NumberField methodsFor: 'morphisms' stamp: 'len 12/23/2016 08:51:42'!
isomorphismTo: aNumberField
	"Field Isomorphism Problem. Answer an isomorphism to aNumberField if there's any, or nil.
	Reference: Henri Cohen, 'A Course In Computational Algebraic Number Theory', Algorithm 4.5.5 and 4.5.6."
	(self polynomial isIrreducible and: [self polynomial isPrimitive])
		ifFalse: [^ self error: 'not irreducible and primitive defining polynomial'].
	(aNumberField polynomial isIrreducible and: [aNumberField polynomial isPrimitive])
		ifFalse: [^ self error: 'not irreducible and primitive defining polynomial'].
	self polynomial degree = aNumberField polynomial degree
		ifFalse: [^ nil].
	"..."
	self notYetImplemented! !

!NumberField methodsFor: 'morphisms' stamp: 'len 11/12/2016 07:14'!
preferedEmbedding
	^ self embeddings detect: [:one| (one value: self x) = self adjoint]! !

!NumberField methodsFor: 'morphisms' stamp: 'len 1/20/2018 19:02:57'!
realEmbeddings
	^ self embeddingsIn: RR! !

!NumberField methodsFor: 'operations' stamp: 'len 1/10/2016 22:34'!
archimedeanPlaces
	^ self notYetImplemented! !

!NumberField methodsFor: 'operations' stamp: 'len 1/10/2016 22:34'!
nonArchimedeanPlaces
	^ self notYetImplemented! !

!NumberField methodsFor: 'operations' stamp: 'len 1/11/2016 03:53'!
regulator
	^ self notYetImplemented! !

!NumberField methodsFor: 'testing' stamp: 'len 1/2/2017 10:53:30'!
isCubic
	^ self degree = 3! !

!NumberField methodsFor: 'testing' stamp: 'len 1/7/2017 21:04:57'!
isGaloisExtension
	self degree = 3 ifTrue: [^ self polynomial discriminant isPerfectSquare].
	self notYetImplemented! !

!NumberField methodsFor: 'testing' stamp: 'len 1/26/2018 18:59:52'!
isGlobalField
	^ true! !

!NumberField methodsFor: 'testing' stamp: 'len 12/10/2016 21:44:21'!
isImaginary
	"Answer true if no embedding into the complex numbers has image contained in the real numbers."
	^ self signature first = 0! !

!NumberField methodsFor: 'testing' stamp: 'len 12/28/2016 12:13:05'!
isMonogenic
	^ self propertyAt: #isMonogenic! !

!NumberField methodsFor: 'testing' stamp: 'len 1/2/2017 10:53:25'!
isQuadratic
	^ self degree = 2! !

!NumberField methodsFor: 'testing' stamp: 'len 12/10/2016 21:44:39'!
isReal
	"Answer true if every embedding into the complex numbers has image contained in the real numbers."
	^ self signature second = 0! !

!NumberField class methodsFor: 'examples' stamp: 'len 2/22/2017 08:50:36'!
example
	^ QQ adjoin: RealAlgebraicNumber sqrt2! !

!NumberField class methodsFor: 'instance creation' stamp: 'len 1/11/2016 02:03'!
adjoint: anAlgebraicNumber
	^ self new adjoint: anAlgebraicNumber! !

!CyclotomicField methodsFor: 'accessing' stamp: 'len 12/10/2016 21:11:10'!
discriminant
	| n phi |
	n _ self order.
	phi _ n phi.
	^ -1 ^ (phi / 2) * (n ^ phi) / (n factors asSet product: [:p| p ^ (phi / (p - 1))])! !

!CyclotomicField methodsFor: 'accessing' stamp: 'len 3/4/2017 19:30:55'!
integers
	"Answer the ring of integers of the receiver."
	^ CyclotomicRing on: self! !

!CyclotomicField methodsFor: 'accessing' stamp: 'len 12/15/2016 08:33:38'!
integralBasis
	^ (0 to: self degree - 1) collect: [:k| self x ^ k]! !

!CyclotomicField methodsFor: 'accessing' stamp: 'len 12/28/2016 12:13:09'!
order
	^ self propertyAt: #order! !

!CyclotomicField methodsFor: 'accessing-private' stamp: 'len 12/28/2016 12:13:15'!
order: anInteger
	anInteger > 2 ifFalse: [^ self error: 'the order of a cyclotomic field must be > 2'].
	self propertyAt: #order put: anInteger.
	self polynomial: ((QQ polynomialsIn: {Character zeta asString, anInteger printString sub}) cyclotomic: anInteger)! !

!CyclotomicField methodsFor: 'morphisms' stamp: 'len 12/10/2016 21:08:51'!
automorphisms
	"this is easy to implement, it's isomorphic to (Z/nZ)*"
	self notYetImplemented! !

!CyclotomicField methodsFor: 'testing' stamp: 'len 12/10/2016 20:13:22'!
isAbelianExtension
	"Cyclotomic fields are Abelian extensions."
	^ true! !

!CyclotomicField methodsFor: 'testing' stamp: 'len 12/10/2016 20:16:17'!
isGaloisExtension
	^ true! !

!CyclotomicField methodsFor: 'testing' stamp: 'len 12/18/2016 21:54:02'!
isMonogenic
	^ true! !

!CyclotomicField class methodsFor: 'examples' stamp: 'len 12/12/2016 17:12:54'!
example
	^ CyclotomicField new: 7! !

!CyclotomicField class methodsFor: 'instance creation' stamp: 'len 12/10/2016 20:42:15'!
new: anInteger
	^ self new order: anInteger! !

!QuadraticField methodsFor: 'accessing' stamp: 'len 12/10/2016 21:33:00'!
discriminant
	| d |
	^ (d _ self d) \\ 4 = 1 ifTrue: [d] ifFalse: [d*4]! !

!QuadraticField methodsFor: 'accessing' stamp: 'len 3/4/2017 19:31:19'!
integers
	"Answer the ring of integers of the receiver."
	^ QuadraticRing on: self! !

!QuadraticField methodsFor: 'accessing' stamp: 'len 11/12/2016 07:31'!
integralBasis
	| w |
	w _ self x + (self embed: self discriminant) / (self embed: 2).
	^ {self one. w}! !

!QuadraticField methodsFor: 'accessing-private' stamp: 'len 12/10/2016 21:27:04'!
polynomial: aPolynomial
	(aPolynomial degree = 2 and: [aPolynomial terms size = 2 and: [aPolynomial independentCoefficient isZero not]])
		ifFalse: [self error: 'malformed polynomial'].
	super polynomial: aPolynomial! !

!QuadraticField methodsFor: 'testing' stamp: 'len 12/18/2016 21:54:14'!
isMonogenic
	^ true! !

!QuadraticField methodsFor: 'testing' stamp: 'len 1/2/2017 10:54:11'!
isQuadratic
	^ true! !

!QuadraticField methodsFor: 'private' stamp: 'len 12/10/2016 21:32:02'!
d
	^ self polynomial independentCoefficient negated! !

!QuadraticField methodsFor: 'private' stamp: 'len 12/23/2016 16:30:50'!
sqrt: anInteger
	| P d |
	d _ anInteger squareFree.
	(d == 0 or: [d == 1]) ifTrue: [DomainError signal: 'not a quadratic field'].
	P _ QQ polynomialsIn: {d == -1 ifTrue: ['i' italic] ifFalse: [Character sqrt asString, d printString]}.
	self polynomial: P x squared - d! !

!QuadraticField class methodsFor: 'examples' stamp: 'len 12/12/2016 17:12:01'!
example
	^ QuadraticField sqrt: -5! !

!QuadraticField class methodsFor: 'instance creation' stamp: 'len 12/14/2016 14:57:22'!
sqrt: anInteger
	^ self new sqrt: anInteger! !

!AdicQuotientRing methodsFor: 'as yet unclassified' stamp: 'len 6/2/2019 05:23:49'!
primeSubring
	^ self! !

!RationalIntegerRing methodsFor: 'accessing' stamp: 'len 11/5/2015 17:34'!
characteristic
	^ 0! !

!RationalIntegerRing methodsFor: 'accessing' stamp: 'len 10/20/2016 03:32'!
dimension
	"Answer the Krull dimension of the receiver."
	^ 1! !

!RationalIntegerRing methodsFor: 'accessing' stamp: 'len 6/4/2019 04:56:05'!
euclideanFunction
	"Answer the Euclidean function of the receiver."
	^ self propertyAt: #euclideanFunction ifAbsentPut: [Function from: self to: self evaluating: [:x| x abs]]! !

!RationalIntegerRing methodsFor: 'accessing' stamp: 'len 4/24/2016 02:58'!
size
	^ Aleph new! !

!RationalIntegerRing methodsFor: 'comparing' stamp: 'len 6/1/2016 23:56'!
<= aDomain
	^ aDomain isRing and: [(aDomain includes: 1) and: [aDomain includes: 0]]! !

!RationalIntegerRing methodsFor: 'comparing' stamp: 'len 11/10/2015 23:14'!
= anObject
	^ anObject class == self class! !

!RationalIntegerRing methodsFor: 'comparing' stamp: 'len 12/14/2015 01:59'!
hash
	^ self class hash! !

!RationalIntegerRing methodsFor: 'converting' stamp: 'len 5/13/2019 15:30:07'!
asAbelianGroup
	| answer |
	^ (answer _ FreeAbelianGroup new: 1)
		addMap: (self to: answer evaluating: [:each| answer !! {each}]);
		addMap: (answer to: self evaluating: [:each| each at: 1]);
		yourself! !

!RationalIntegerRing methodsFor: 'elements' stamp: 'len 3/25/2018 16:18:04'!
!! anObject
	anObject isInteger ifTrue: [^ anObject].
	^ super !! anObject! !

!RationalIntegerRing methodsFor: 'elements' stamp: 'len 9/24/2018 23:38:01'!
associatedUnit: anInteger
	"Answer a choice for associated unit of anInteger."
	^ anInteger < 0 ifTrue: [-1] ifFalse: [1]! !

!RationalIntegerRing methodsFor: 'elements' stamp: 'len 11/5/2015 19:19'!
one
	^ 1! !

!RationalIntegerRing methodsFor: 'elements' stamp: 'len 11/3/2015 20:50'!
zero
	^ 0! !

!RationalIntegerRing methodsFor: 'elements-testing' stamp: 'len 9/22/2018 18:58:26'!
isIrreducible: anInteger
	^ anInteger isPrime! !

!RationalIntegerRing methodsFor: 'elements-testing' stamp: 'len 9/25/2018 15:30:09'!
isPrime: anInteger
	^ anInteger isPrime! !

!RationalIntegerRing methodsFor: 'elements-testing' stamp: 'len 9/16/2018 16:26:36'!
isUnit: anInteger
	"Answer true if the argument is invertible."
	^ anInteger = 1 or: [anInteger = -1]! !

!RationalIntegerRing methodsFor: 'elements-testing' stamp: 'len 9/16/2018 16:31:35'!
isZeroDivisor: anElement
	"Answer true if there exists a nonzero element that multiplied by the argument is zero."
	^ anElement = 0! !

!RationalIntegerRing methodsFor: 'enumerating' stamp: 'len 11/10/2015 17:57'!
do: aBlock
	| i |
	aBlock value: 0.
	i _ 1.
	[ aBlock value: i; value: i negated. i _ i + 1 ] repeat! !

!RationalIntegerRing methodsFor: 'enumerating' stamp: 'len 5/4/2018 19:42:06'!
primeIdealsDo: aBlock
	| p |
	p _ 0.
	[aBlock value: self * p.
	p _ p nextPrime] repeat! !

!RationalIntegerRing methodsFor: 'enumerating' stamp: 'len 9/22/2018 18:58:29'!
unitsDo: aBlock
	aBlock value: 1; value: -1! !

!RationalIntegerRing methodsFor: 'morphisms' stamp: 'len 5/16/2019 13:39:50'!
to: aCodomain
	aCodomain isRing
		ifTrue: [^ aCodomain addMap: (self to: aCodomain evaluating: [:x| aCodomain one * x])].
	^ super to: aCodomain! !

!RationalIntegerRing methodsFor: 'operations' stamp: 'len 5/21/2018 17:29:47'!
% anInteger
	anInteger isPrime ifTrue: [^ PrimeField new: anInteger].
	^ ModularIntegerRing new: anInteger! !

!RationalIntegerRing methodsFor: 'operations' stamp: 'len 5/15/2019 06:45:14'!
/ anInteger
	| factors |
	anInteger isInteger ifFalse: [^ super / anInteger].
	factors _ anInteger factors.
	factors asSet size = 1 ifTrue:
		[^ PrimePowerRing new: factors anyOne to: factors size].
	^ ModularIntegerRing new: anInteger! !

!RationalIntegerRing methodsFor: 'operations' stamp: 'len 6/6/2019 12:03:19'!
adic: aPrime
	^ AdicIntegerRing at: aPrime! !

!RationalIntegerRing methodsFor: 'operations' stamp: 'len 6/6/2019 12:03:33'!
adic: aPrime precision: anInteger
	^ AdicIntegerRing at: aPrime precision: anInteger! !

!RationalIntegerRing methodsFor: 'operations' stamp: 'len 7/15/2016 18:31'!
fractions
	^ QQ! !

!RationalIntegerRing methodsFor: 'operations' stamp: 'len 5/21/2018 22:03:53'!
radical
	"Answer the Jacobson radical J(R) of the receiver R. This is the ideal consisting of all elements that annihilate all simple R-modules. It is the intersection of all maximal ideals."
	^ self zeroIdeal! !

!RationalIntegerRing methodsFor: 'operations' stamp: 'len 5/2/2019 08:03:10'!
units
	"Answer the multiplicative group of units of the receiver (i.e., elements that have multiplicative inverse)."
	^ super units elements: {1. -1}! !

!RationalIntegerRing methodsFor: 'operations' stamp: 'len 5/2/2018 16:06:54'!
zeroDivisors
	^ #(0)! !

!RationalIntegerRing methodsFor: 'random' stamp: 'len 9/22/2018 18:58:33'!
atRandom: aRandom bits: bitSize
	| n |
	bitSize isInfinite ifTrue: [^ self error: 'infinite bitsize'].
	bitSize < 0 ifTrue: [^ self error: 'negative bitsize'].
	self flag: #fix. "maybe this should be more like a flat gaussian distribution around 0?"
	bitSize < 1 ifTrue: [^ 0].
	n _ 2^(bitSize truncated - 1).
	^ (0-n to: n) atRandom: aRandom! !

!RationalIntegerRing methodsFor: 'testing' stamp: 'len 11/23/2015 02:37'!
includes: anObject
	^ anObject isInteger! !

!RationalIntegerRing methodsFor: 'testing' stamp: 'len 6/4/2019 16:15:35'!
isBezout
	"Answer true if the receiver is a Bezout ring, i.e. every finitely generated ideal is principal."
	^ true! !

!RationalIntegerRing methodsFor: 'testing' stamp: 'len 3/27/2018 19:46:01'!
isDedekindDomain
	"A Dedekind domain is an integral domain in which every non-zero proper ideal factors into a product of prime ideals."
	^ true! !

!RationalIntegerRing methodsFor: 'testing' stamp: 'len 11/4/2015 21:52'!
isEuclidean
	^ true! !

!RationalIntegerRing methodsFor: 'testing' stamp: 'len 11/7/2015 21:58'!
isFinite
	^ false! !

!RationalIntegerRing methodsFor: 'testing' stamp: 'len 11/2/2016 03:33'!
isInitial
	^ true! !

!RationalIntegerRing methodsFor: 'testing' stamp: 'len 1/8/2017 07:49:36'!
isIntegralDomain
	^ true! !

!RationalIntegerRing methodsFor: 'testing' stamp: 'len 6/4/2019 16:09:50'!
isNoetherian
	"Answer true if the receiver is a Noetherian ring, i.e. every ideal is finitely generated."
	^ true! !

!RationalIntegerRing methodsFor: 'testing' stamp: 'len 10/2/2018 01:52:16'!
isOrdered
	^ true! !

!RationalIntegerRing methodsFor: 'testing' stamp: 'len 2/11/2016 22:19'!
isReal
	^ true! !

!RationalIntegerRing methodsFor: 'testing' stamp: 'len 4/28/2018 05:12:24'!
isReduced
	"Answer true if the receiver has no non-zero nilpotent elements, or equivalently if it has no non-zero elements with square zero, i.e. x^2 = 0 implies x = 0."
	^ true! !

!RationalIntegerRing methodsFor: 'private' stamp: 'len 12/18/2016 22:30:08'!
idealClass
	^ RationalIntegerIdeal! !

!RationalIntegerRing class methodsFor: 'initialization' stamp: 'len 8/5/2016 21:32'!
initialize
	super initialize.
	Smalltalk at: #ZZ put: self new! !

!ComplexField methodsFor: 'accessing' stamp: 'len 8/6/2016 03:44'!
characteristic
	^ 0! !

!ComplexField methodsFor: 'accessing' stamp: 'len 10/4/2016 08:59'!
conjugation
	^ self to: self evaluating: [:x| x conjugated]! !

!ComplexField methodsFor: 'accessing' stamp: 'len 8/6/2016 03:45'!
one
	^ 1! !

!ComplexField methodsFor: 'accessing' stamp: 'len 5/14/2019 07:25:42'!
size
	^ Aleph new: 1! !

!ComplexField methodsFor: 'accessing' stamp: 'len 8/6/2016 03:45'!
zero
	^ 0! !

!ComplexField methodsFor: 'comparing' stamp: 'len 1/20/2018 19:06:56'!
= anObject
	^ anObject class == self class! !

!ComplexField methodsFor: 'comparing' stamp: 'len 1/20/2018 19:07:07'!
> aDomain
	^ (aDomain isKindOf: RationalField) or: [(aDomain isKindOf: RationalIntegerRing) or: [aDomain isKindOf: RealField]]! !

!ComplexField methodsFor: 'comparing' stamp: 'len 1/20/2018 19:07:25'!
hash
	^ self class hash! !

!ComplexField methodsFor: 'enumerating' stamp: 'len 8/6/2016 03:50'!
do: aBlock
	^ self shouldNotImplement! !

!ComplexField methodsFor: 'testing' stamp: 'len 8/5/2016 21:50'!
includes: anObject
	^ anObject isComplex! !

!ComplexField methodsFor: 'testing' stamp: 'len 8/12/2016 04:48'!
isAlgebraicallyClosed
	^ true! !

!ComplexField methodsFor: 'testing' stamp: 'len 8/5/2016 21:55'!
isComplex
	^ true! !

!ComplexField methodsFor: 'testing' stamp: 'len 10/18/2016 20:43'!
isField
	^ true! !

!ComplexField methodsFor: 'testing' stamp: 'len 1/26/2018 18:57:44'!
isLocalField
	^ true! !

!ComplexField class methodsFor: 'initialization' stamp: 'len 8/5/2016 21:34'!
initialize
	super initialize.
	Smalltalk at: #CC put: self new! !

!RealField methodsFor: 'accessing' stamp: 'len 8/6/2016 03:45'!
characteristic
	^ 0! !

!RealField methodsFor: 'accessing' stamp: 'len 1/19/2017 16:29:14'!
one
	^ 1! !

!RealField methodsFor: 'accessing' stamp: 'len 5/14/2019 07:25:26'!
size
	^ Aleph new: 1! !

!RealField methodsFor: 'accessing' stamp: 'len 1/19/2017 16:29:18'!
zero
	^ 0! !

!RealField methodsFor: 'comparing' stamp: 'len 1/20/2018 18:59:45'!
< aDomain
	^ ((aDomain isKindOf: RationalField) or: [aDomain isKindOf: RationalIntegerRing]) or: [super < aDomain]! !

!RealField methodsFor: 'comparing' stamp: 'len 1/20/2018 18:59:57'!
= anObject
	^ anObject class == self class! !

!RealField methodsFor: 'comparing' stamp: 'len 1/20/2018 19:00:02'!
> aDomain
	^ (aDomain isKindOf: RationalField) or: [aDomain isKindOf: RationalIntegerRing]! !

!RealField methodsFor: 'comparing' stamp: 'len 1/20/2018 19:00:05'!
hash
	^ self class hash! !

!RealField methodsFor: 'enumerating' stamp: 'len 8/6/2016 03:50'!
do: aBlock
	^ self shouldNotImplement! !

!RealField methodsFor: 'morphisms' stamp: 'len 3/25/2018 19:32:22'!
embed: anObject
	(anObject isInteger or: [anObject isFraction]) ifTrue: [^ anObject].
	^ super embed: anObject! !

!RealField methodsFor: 'operations' stamp: 'len 1/20/2018 19:00:26'!
algebraicClosure
	^ CC! !

!RealField methodsFor: 'testing' stamp: 'len 8/5/2016 21:50'!
includes: anObject
	^ anObject isReal! !

!RealField methodsFor: 'testing' stamp: 'len 10/18/2016 20:44'!
isField
	^ true! !

!RealField methodsFor: 'testing' stamp: 'len 1/20/2018 19:01:50'!
isFinite
	^ false! !

!RealField methodsFor: 'testing' stamp: 'len 1/26/2018 18:57:34'!
isLocalField
	^ true! !

!RealField methodsFor: 'testing' stamp: 'len 10/2/2018 01:52:57'!
isOrdered
	^ true! !

!RealField methodsFor: 'testing' stamp: 'len 8/5/2016 21:55'!
isReal
	^ true! !

!RealField class methodsFor: 'initialization' stamp: 'len 8/5/2016 21:33'!
initialize
	super initialize.
	Smalltalk at: #RR put: self new! !

!Order methodsFor: 'accessing' stamp: 'len 12/28/2016 12:13:45'!
basis
	^ self propertyAt: #basis! !

!Order methodsFor: 'accessing' stamp: 'len 1/18/2018 20:14:58'!
degree
	^ self ambient degree! !

!Order methodsFor: 'accessing' stamp: 'len 1/18/2018 20:07:31'!
dimension
	"Answer the Krull dimension of the receiver."
	^ 1! !

!Order methodsFor: 'accessing' stamp: 'len 1/18/2018 20:11:14'!
generators
	"Answer the generators of the receiver as a ring."
	^ self notYetImplemented! !

!Order methodsFor: 'accessing' stamp: 'len 1/18/2018 20:04:17'!
rank
	"Answer the rank of the receiver as Z-module, which is the degree of the number field over Q."
	^ self ambient degree! !

!Order methodsFor: 'comparing' stamp: 'len 10/13/2018 18:07:10'!
< anOrder
	^ (self ambient <= anOrder) or: [(anOrder isKindOf: Order) and: [self asModule < anOrder asModule]]! !

!Order methodsFor: 'comparing' stamp: 'len 10/13/2018 18:07:24'!
<= anOrder
	^ (self ambient <= anOrder) or: [(anOrder isKindOf: Order) and: [self asModule <= anOrder asModule]]! !

!Order methodsFor: 'converting' stamp: 'len 5/7/2019 08:13:31'!
asModule
	^ self notYetImplemented
"	^ OrderAsModule on: self"! !

!Order methodsFor: 'operations' stamp: 'len 1/19/2018 23:52:02'!
integralClosure
	^ self isMaximal ifTrue: [self] ifFalse: [self ambient integers]! !

!Order methodsFor: 'testing' stamp: 'len 10/13/2018 17:48:08'!
isField
	^ false! !

!Order methodsFor: 'testing' stamp: 'len 1/19/2018 23:50:53'!
isIntegrallyClosedDomain
	^ self isMaximal! !

!Order methodsFor: 'testing' stamp: 'len 6/4/2019 16:10:11'!
isNoetherian
	"Answer true if the receiver is a Noetherian ring, i.e. every ideal is finitely generated."
	^ true! !

!NumberRing methodsFor: 'accessing' stamp: 'len 1/18/2018 19:22:57'!
basis
	^ self ambient integralBasis! !

!NumberRing methodsFor: 'operations' stamp: 'len 5/31/2019 05:26:56'!
fractions
	"NOTE: Magma does this differently, the fractions field of a number ring is not its ambient field but an isomorphic field made of formal fractions with denominator a rational integer."
	^ self ambient! !

!NumberRing methodsFor: 'random' stamp: 'len 1/17/2019 03:23:26'!
atRandom: aRandom bits: bitSize
	^ (self ambient atRandom: aRandom bits: bitSize) numerator! !

!NumberRing methodsFor: 'testing' stamp: 'len 12/18/2016 15:02:54'!
isDedekindDomain
	"Rings of integers of number fields are Dedekind domains."
	^ true! !

!NumberRing methodsFor: 'testing' stamp: 'len 1/19/2018 23:48:50'!
isMaximal
	^ true! !

!NumberRing methodsFor: 'testing' stamp: 'len 12/18/2016 15:03:32'!
isPID
	"A Dedekind domain is a UFD iff it is a PID."
	^ self isUFD! !

!NumberRing methodsFor: 'testing' stamp: 'len 12/18/2016 15:03:20'!
isUFD
	"A Dedekind domain is a UFD iff it is a PID."
	^ self isPID! !

!NumberRing class methodsFor: 'instance creation' stamp: 'len 1/18/2018 19:26:33'!
on: aNumberField
	^ self new ambient: aNumberField! !

!QuadraticRing methodsFor: 'elements-testing' stamp: 'len 9/27/2018 16:00:15'!
isPrime: aNumber
	"The norm of a (quadratic) prime is a (rational) integer prime or a prime squared.
	If the norm is a prime, the number is prime."
	| norm factors |
	(norm _ aNumber norm) isPrime ifTrue: [^ true].
	factors _ norm factors.
	(factors size <= 2 and: [factors asSet size = 1]) ifFalse: [^ false].
	self notYetImplemented! !

!QuadraticRing methodsFor: 'elements-testing' stamp: 'len 9/26/2018 21:47:41'!
isUnit: aNumber
	^ aNumber norm abs = 1
"there's also equations, a + bw is a unit if:
	a^2 - Db^2 = 1 for D = 2,3 mod 4
	(a + b/2)^2 - (1/4)Db^2 = 1 for D = 1 mod 4"! !

!QuadraticRing methodsFor: 'testing' stamp: 'len 5/31/2019 05:28:03'!
isEuclidean
	self ambient d negative ifFalse: [self notYetImplemented].
	(#(-11 -7 -3 -2 -1) includes: self ambient d) ifFalse: [^ false].
	self notYetImplemented! !

!QuadraticRing methodsFor: 'testing' stamp: 'len 12/23/2016 16:47:35'!
isIntegralDomain
	^ true! !

!QuadraticRing methodsFor: 'testing' stamp: 'len 1/18/2018 19:25:19'!
isNormEuclidean
	^ #(-11 -7 -3 -2 -1 2 3 5 6 7 11 13 17 19 21 29 33 37 41 57 73) includes: self ambient d! !

!QuadraticRing methodsFor: 'testing' stamp: 'len 5/31/2019 05:27:48'!
isPID
	self ambient d negative ifTrue: [^ #(-1 -2 -3 -7 -11 -19 -43 -67 -163) includes: self ambient d].
	^ self ambient classNumber = 1! !

!GaussianIntegerRing methodsFor: 'as yet unclassified' stamp: 'len 5/31/2019 05:36:51'!
isIrreducible: aNumber
	"A Gaussian integer is irriducible if and only if it is prime."
	^ self isPrime: aNumber! !

!GaussianIntegerRing methodsFor: 'as yet unclassified' stamp: 'len 5/31/2019 05:35:44'!
isPrime: aNumber
	"a+bi is prime if either:
	- one of a, b is zero and absolute value of the other is prime congruent to 3 mod 4;
	- both are nonzero and a^2 + b%2 is prime"
	super isPrime: aNumber! !

!GaussianIntegerRing methodsFor: 'as yet unclassified' stamp: 'len 5/31/2019 05:38:24'!
isUnit: aNumber
	"All the units are: 1, -1, i, -i."
	^ super isUnit: aNumber! !

!MatrixRing methodsFor: 'accessing' stamp: 'len 1/5/2017 08:07:08'!
degree
	^ degree! !

!MatrixRing methodsFor: 'accessing' stamp: 'len 1/5/2017 08:07:03'!
scalars
	^ scalars! !

!MatrixRing methodsFor: 'accessing' stamp: 'len 1/5/2017 20:23:17'!
size
	^ self scalars size ^ self degree squared! !

!MatrixRing methodsFor: 'accessing-private' stamp: 'len 1/5/2017 08:07:47'!
degree: anInteger
	degree _ anInteger! !

!MatrixRing methodsFor: 'accessing-private' stamp: 'len 1/5/2017 08:07:29'!
scalars: aRing
	scalars _ aRing! !

!MatrixRing methodsFor: 'converting' stamp: 'len 1/5/2017 08:08:18'!
asModule
	^ MatrixModule new: self degree @ self degree over: self scalars! !

!MatrixRing methodsFor: 'elements' stamp: 'len 1/5/2017 20:20:36'!
one
	^ self scalar: scalars one! !

!MatrixRing methodsFor: 'elements' stamp: 'len 1/5/2017 20:25:23'!
scalar: aNumber
	| zero |
	zero _ self scalars zero.
	^ self scalars matrix: self degree evaluating: [:i :j| i=j ifTrue: [aNumber] ifFalse: [zero]]! !

!MatrixRing methodsFor: 'elements' stamp: 'len 1/5/2017 20:21:45'!
zero
	^ self scalar: scalars zero! !

!MatrixRing methodsFor: 'enumerating' stamp: 'len 1/5/2017 20:28:05'!
do: aBlock
	self asModule do: aBlock! !

!MatrixRing methodsFor: 'random' stamp: 'len 1/5/2017 20:29:56'!
atRandom: aRandom bits: bitSize
	| n |
	n _ bitSize // self degree.
	^ self scalars matrix: self degree evaluating: [:i :j| self scalars atRandom: aRandom bits: n]! !

!MatrixRing methodsFor: 'testing' stamp: 'len 10/3/2018 03:05:18'!
isCommutative
	^ self degree = 1 and: [self scalars isCommutative]! !

!MatrixRing class methodsFor: 'instance creation' stamp: 'len 1/5/2017 08:09:09'!
new: anInteger over: aRing
	^ self new degree: anInteger; scalars: aRing! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 1/2/2017 10:08:58'!
characteristic
	^ scalars characteristic! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 2/12/2017 07:01:20'!
dimension
	"Answer the Krull dimension of the receiver."
	self isLocal ifTrue: [^ -1].
	self isGlobal ifFalse: [^ self error: 'not a global ring'].
	self scalars isNoetherian ifTrue: [^ self scalars dimension + self rank].
	^ super dimension! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 6/4/2019 04:54:23'!
euclideanFunction
	"Answer the Euclidean function of the receiver, if it is an Euclidean domain."
	^ self propertyAt: #euclideanFunction ifAbsentPut: [self scalars isField ifTrue: [Function from: self to: ZZ evaluating: [:f| f degree]]]! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 10/2/2016 10:34'!
generators
	^ (1 to: self rank) collect: [:i| self x: i]! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 10/27/2016 17:24'!
gradings
	"Answer the degrees of the indeterminates of the receiver."
	^ (1 to: self rank) collect: [:i| 1]! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 6/4/2016 05:12'!
indeterminate
	"Answer the univariate indeterminate."
	^ 1! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 10/22/2016 18:16'!
indeterminates
	^ 1 to: self rank! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 5/20/2018 22:37:19'!
maximalIdeal
	"If the receiver is a local ring, answer the unique maximal ideal."
	self isLocal ifFalse: [DomainError signal: 'the ring is not local'].
	^ self * self generators! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 11/20/2016 14:15:52'!
monomials
	"Answer the monoid of monomials of the receiver."
	^ monomials! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 2/27/2017 07:41:18'!
names
	"Answer the indeterminate names to use when printing polynomials."
	^ monomials names! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 2/27/2017 07:39:19'!
names: aCollection
	"Set indeterminate names to use when printing polynomials."
	monomials names: aCollection! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 11/20/2016 12:07:07'!
ordering
	^ monomials ordering! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 1/2/2017 10:08:31'!
rank
	"The rank of a polynomial ring is the number of indeterminates. Univariate polynomials have rank 1."
	^ monomials rank! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 1/2/2017 10:08:53'!
scalars
	^ scalars! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 4/24/2016 02:59'!
size
	^ Aleph new * self scalars size! !

!PolynomialRing methodsFor: 'comparing' stamp: 'len 7/19/2016 01:12'!
< aDomain
	(aDomain isKindOf: PolynomialRing) ifFalse: [^ false].
	self rank = aDomain rank ifFalse: [^ false].
	self scalars < aDomain scalars ifFalse: [^ false].
	^ true! !

!PolynomialRing methodsFor: 'comparing' stamp: 'len 9/22/2018 23:45:26'!
<= aDomain
	"Answer true if the receiver is included in the argument, i.e. it's a subring of the argument."
	self == aDomain ifTrue: [^ true].
	(aDomain isKindOf: RationalFunctionField) ifTrue: [^ aDomain integers >= self].
	(aDomain isKindOf: PolynomialRing) ifFalse: [^ false].
	self rank = aDomain rank ifFalse: [^ false].
	self scalars <= aDomain scalars ifFalse: [^ false].
	^ true! !

!PolynomialRing methodsFor: 'comparing' stamp: 'len 2/10/2017 20:12:10'!
= anObject
	self == anObject ifTrue: [^ true].
	^ (anObject isKindOf: PolynomialRing) and: [self scalars = anObject scalars and: [self rank = anObject rank "and: [self ordering = anObject ordering]"]]! !

!PolynomialRing methodsFor: 'comparing' stamp: 'len 7/19/2016 01:12'!
> aDomain
	(aDomain isKindOf: PolynomialRing) ifFalse: [^ false].
	self rank = aDomain rank ifFalse: [^ false].
	self scalars > aDomain scalars ifFalse: [^ false].
	^ true! !

!PolynomialRing methodsFor: 'comparing' stamp: 'len 7/19/2016 01:12'!
>= aDomain
	(aDomain isKindOf: PolynomialRing) ifFalse: [^ false].
	self rank = aDomain rank ifFalse: [^ false].
	self scalars >= aDomain scalars ifFalse: [^ false].
	^ true! !

!PolynomialRing methodsFor: 'comparing' stamp: 'len 8/30/2016 07:09'!
~ aPolynomialRing
	"Answer true if the receiver is canonically isomorphic to the argument."
	"R[x][y] ~ R[x,y]"
	self notYetImplemented! !

!PolynomialRing methodsFor: 'comparing' stamp: 'len 10/22/2016 18:09'!
hash
	^ self scalars hash + self rank! !

!PolynomialRing methodsFor: 'converting' stamp: 'len 2/27/2017 07:40:28'!
asMultivariate
	| answer |
	self isUnivariate ifFalse: [^ self].
	answer _ self scalars scalars polynomialsIn: self scalars rank + 1.
	(self names notNil and: [self scalars names notNil])
		ifTrue: [answer names: self scalars names, self names].
	^ answer! !

!PolynomialRing methodsFor: 'converting' stamp: 'len 2/27/2017 07:41:56'!
asUnivariate
	self isUnivariate ifTrue: [^ self].
	self names notNil
		ifTrue: [^ (self scalars polynomialsIn: self names allButLast) polynomialsIn: {self names last}].
	^ (self scalars polynomialsIn: self rank - 1) polynomials! !

!PolynomialRing methodsFor: 'converting' stamp: 'len 11/21/2016 19:31:43'!
asUnivariateIn: anIndeterminate
	anIndeterminate = self rank ifFalse: [^ self error: 'bad indeterminate'].
	^ self asUnivariate! !

!PolynomialRing methodsFor: 'converting' stamp: 'len 2/27/2017 07:42:07'!
copyWithout: anIndeterminate
	"Answer a polynomial ring like the receiver but with one less indeterminate.
	Keep monomial ordering. Also keep indeterminate names if present."
	^ self names
		ifNil: [self scalars polynomialsIn: self rank - 1 ordering: (self ordering copyWithout: anIndeterminate)]
		ifNotNil: [:indeterminates|
			self scalars
				polynomialsIn: (indeterminates copyWithoutIndex: anIndeterminate)
				ordering: (self ordering copyWithout: anIndeterminate)]! !

!PolynomialRing methodsFor: 'converting' stamp: 'len 5/13/2019 22:13:37'!
orderedBy: aMonomialOrdering
	^ self class monomials: (self monomials orderedBy: aMonomialOrdering) over: self scalars! !

!PolynomialRing methodsFor: 'converting' stamp: 'len 5/13/2019 22:13:23'!
over: aRing
	^ self class monomials: self monomials over: aRing! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 5/23/2018 22:47:07'!
!! anObject
	| f parts |
	(anObject isKindOf: Polynomial)
		ifFalse:
			[(anObject isInteger or: [anObject isFraction])
				ifTrue: [^ self constant: self scalars !! anObject].
			(self scalars includes: anObject)
				ifTrue: [^ self constant: anObject].
			anObject isEvaluable
				ifTrue: [^ self evaluating: anObject].
			^ super !! anObject].
	f _ anObject.
	f parent scalars = self scalars ifFalse: [f _ f over: self scalars].
	(f indeterminates allSatisfy: [:each| each <= self rank])
		ifFalse: [self error: 'unknown indeterminates are present'].
	(f isKindOf: UnivariatePolynomial)
		ifTrue:
			[self isUnivariate ifTrue: [^ self coefficients: f coefficients].
			parts _ OrderedCollection new: f coefficients size.
			f coefficients withIndexDo: [:coefficient :i|
				coefficient isZero ifFalse: [parts add: (monomials x: 1 to: i-1) -> coefficient]]]
		ifFalse:
			[parts _ f parts collect: [:each| each copy key: self monomials !! each key]].
	parts sort.
	^ self parts: parts! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 9/25/2018 00:07:11'!
associatedUnit: aPolynomial
	"Answer a choice for associated unit of aPolynomial."
	^ self constant: (self scalars associatedUnit: aPolynomial leadingCoefficient)! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 7/9/2016 03:28'!
coefficient: aNumber degree: anInteger
	^ self coefficients: (self scalars tuple: {aNumber}) >>> anInteger! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 12/22/2017 19:18:07'!
coefficient: aNumber monomial: aMonomial
	^ self isUnivariate
		ifTrue:
			[| n zero coefficients |
			n _ aMonomial degree + 1.
			zero _ aNumber zero.
			coefficients _ self scalars tuple: n evaluating: [:i| i=n ifTrue: [aNumber] ifFalse: [zero]].
			(UnivariatePolynomial coefficients: coefficients) parent: self]
		ifFalse:
			[| parts |
			parts _ aNumber isZero ifTrue: [OrderedCollection new] ifFalse: [OrderedCollection with: aMonomial -> aNumber].
			(MultivariatePolynomial parts: parts) parent: self]! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 2/27/2017 07:42:04'!
coefficient: aNumber x: anIndeterminate to: anInteger
	| i |
	i _ anIndeterminate isInteger
		ifTrue: [anIndeterminate]
		ifFalse: [self names indexOf: anIndeterminate ifAbsent: [^ self error: 'unknown indeterminate']].
	^ self coefficient: aNumber monomial: (monomials x: i to: anInteger)! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 12/22/2017 18:57:03'!
coefficients: aTuple
	| coefficients |
	self isUnivariate ifFalse: [^ self error: 'not univariate ring'].
	coefficients _ aTuple class = self scalars tupleClass
		ifTrue: [aTuple]
		ifFalse: [self scalars tuple: aTuple].
	^ (UnivariatePolynomial coefficients: coefficients) parent: self! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 11/20/2016 13:51:14'!
constant: aNumber
	self isUnivariate ifTrue: [^ self coefficients: (self scalars tuple: {aNumber})].
	^ self coefficient: aNumber monomial: monomials identity! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 5/14/2019 12:35:37'!
evaluating: aBlock
	^ self generate: aBlock! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 5/15/2019 07:38:21'!
findIrreducibleOfDegree: n
	| one x p random |
	one _ self scalars one.
	x _ self x.
	1 to: n-1 do: [:k|
		p _ x^n + (x^k) + one.
		p isIrreducible ifTrue: [^ p]].
	"self error: 'irreducible polynomial not found'"
	random _ Random new.
	[p _ (self atRandom: random maxDegree: n-1) + (x^n).
	p isIrreducible] whileFalse.
	^ p! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 12/19/2015 03:38'!
interpolate: aCollection
	"Answer a polynomial f that for each pair k -> v of the argument evaluates to f(k) = v.
	(Lagrange polynomials.)"
	| answer x |
	self isUnivariate ifFalse: [^ self error: 'not yet implemented'].
	x _ self x.
	answer _ self zero.
	aCollection do: [:a| | p |
		p _ self one.
		aCollection do: [:b|
			a ~~ b ifTrue: [p _ p * ((x - b key) / (a key - b key))]].
		answer _ p * a value + answer].
	^ answer! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 6/26/2016 01:42'!
monomial: aMonomial
	^ self coefficient: self scalars one monomial: aMonomial! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 1/22/2017 20:42:36'!
one
	^ self propertyAt: #one ifAbsentPut: [self constant: self scalars one]! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 12/24/2017 20:39:05'!
parts: aCollection
	self isUnivariate
		ifTrue:
			[| n coefficients |
			n _ 0.
			aCollection do: [:each| n _ n max: each key degree].
			coefficients _ self scalars zeroTuple: n+1.
			aCollection do: [:each| coefficients at: each key degree + 1 put: each value].
			^ self coefficients: coefficients].
	^ (MultivariatePolynomial parts: aCollection) parent: self! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 5/20/2016 03:34'!
x
	^ self x: self indeterminates first! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 3/26/2016 02:44'!
x: anIndeterminate
	^ self x: anIndeterminate to: 1! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 10/22/2016 18:12'!
x: anIndeterminate to: n
	^ self coefficient: self scalars one x: anIndeterminate to: n! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 4/22/2019 04:03:09'!
xTo: degree
	^ self x: 1 to: degree! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 5/20/2016 03:34'!
y
	^ self x: self indeterminates second! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 5/20/2016 03:34'!
z
	^ self x: self indeterminates third! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 1/22/2017 20:42:15'!
zero
	^ self propertyAt: #zero ifAbsentPut: [self constant: self scalars zero]! !

!PolynomialRing methodsFor: 'elements-testing' stamp: 'len 6/4/2019 19:22:30'!
isNilpotent: aPolynomial
	"Answer true if aPolynomial^n = 0 for some integer n >= 1."
	^ aPolynomial coefficients allSatisfy: [:each| self scalars isNilpotent: each]! !

!PolynomialRing methodsFor: 'elements-testing' stamp: 'len 6/5/2019 16:08:27'!
isUnit: aPolynomial
	"Answer true if the argument is invertible."
	aPolynomial isConstant ifTrue: [^ self scalars isUnit: aPolynomial leadingCoefficient].
	self scalars isIntegralDomain ifTrue: [^ false].
	(self scalars isUnit: aPolynomial independentCoefficient) ifFalse: [^ false].
	"this assumes the polynomial is univariate, can it be generalized to multivariate?"
	^ (1 to: aPolynomial degree) allSatisfy: [:i| self scalars isNilpotent: (aPolynomial atDegree: i)]

"the above two lines generalize this:
	((self scalars isKindOf: GaloisRing) or: [self scalars isKindOf: PrimePowerRing])
		ifTrue:
			[| M a |
			M _ self scalars maximalIdeal.
			a _ aPolynomial coefficients.
			(M contains: (a at: 1)) ifTrue: [^ false].
			2 to: a size do: [:i| (M contains: (a at: i)) ifFalse: [^ false]].
			^ true].
	^ self notYetImplemented"! !

!PolynomialRing methodsFor: 'elements-testing' stamp: 'len 6/4/2019 19:21:57'!
isZeroDivisor: aPolynomial
	"Answer true if there exists a nonzero element that multiplied by the argument is zero."
	self isIntegralDomain ifTrue: [^ aPolynomial isZero].
	self scalars isFinite ifFalse: [^ self notYetImplemented].
	^ self scalars anySatisfy: [:any| any isZero not and: [(aPolynomial * any) isZero]]! !

!PolynomialRing methodsFor: 'enumerating' stamp: 'len 1/9/2017 21:30:17'!
allMonomialsOfDegree: anInteger
	^ (self monomials allMonomialsOfDegree: anInteger) collect: [:each| self monomial: each]! !

!PolynomialRing methodsFor: 'enumerating' stamp: 'len 12/21/2015 23:09'!
do: aBlock
	| k |
	self scalars isFinite ifFalse: [^ self notYetImplemented].
	self isUnivariate ifFalse: [^ self notYetImplemented].
	aBlock value: self zero.
	k _ 1.
	[(self scalars ^ k) do: [:t| t last isZero ifFalse: [aBlock value: (self coefficients: t)]].
	k _ k + 1] repeat! !

!PolynomialRing methodsFor: 'examples' stamp: 'len 10/22/2016 18:12'!
chebyshevOfOrder: n
	"Answer the n-th Chebyshev polynomial."

	| answer c m k |
	n <= 0 ifTrue: [^ self one].
	c _ (1 bitShift: n - 1).
	m _ 4.
	k _ n - 1.
	answer _ self coefficient: self scalars one * c degree: n.
	n - 1 to: 1 by: -2 do: [ :each |
		c _ ((c * (each + 1) * each) / (k * m)) negated.
		m _ m + 4.
		k _ k - 1.
		c = 0 ifFalse: [answer _ answer + (self coefficient: self scalars one * c degree: each - 1)]].
	^ answer! !

!PolynomialRing methodsFor: 'examples' stamp: 'len 5/12/2018 16:57:04'!
continuantOfOrder: n
	"Answer the continuant polynomial of order n."
	"(QQ polynomialsIn: #(x y z)) continuantOfOrder: 3"

	n = 0 ifTrue: [^ self one].
	n = 1 ifTrue: [^ self x: 1].
	^ (self continuantOfOrder: n - 1) * (self x: n) + (self continuantOfOrder: n - 2)! !

!PolynomialRing methodsFor: 'examples' stamp: 'len 5/12/2018 17:00:02'!
cyclicIdeal
	"Answer the ideal of cyclic n-roots, used for benchmarks."
	| generators |
	generators _ OrderedCollection new.
	0 to: self rank - 2 do: [:j|
		| g |
		g _ (1 to: self rank) sum: [:i| (i to: i+j) product: [:k| self x: k-1 \\ self rank + 1]].
		generators add: g].
	generators add: self generators product - 1.
	^ self * generators! !

!PolynomialRing methodsFor: 'examples' stamp: 'len 12/10/2016 20:28:19'!
cyclotomic: n
	"Answer the n-th cyclotomic polynomial."
	| one x answer "numerator denominator" product |
	one _ self one.
	x _ self x.
	n = 1 ifTrue: [^ x - one].
	n isPrime
		ifTrue: [answer _ one. n-1 timesRepeat: [answer _ answer * x + one]. ^ answer].
"	numerator _ one.
	denominator _ one.
	n divisorsDo: [:d| | mu |
		mu _ (n/d) moebius.
		mu = 1 ifTrue: [numerator _ numerator * (x^d - one)].
		mu = -1 ifTrue: [denominator _ denominator * (x^d - one)]].
	^ numerator // denominator"
	product _ self one.
	n divisors do: [:each| each = n ifFalse: [product _ product * (self cyclotomic: each)]].
	^ x^n - one // product! !

!PolynomialRing methodsFor: 'examples' stamp: 'len 5/12/2018 16:56:46'!
determinantOfOrder: n
	"Answer the determinant polynomial of order n."
	"QQ polynomials determinantOfOrder: 3"

	n = 0 ifTrue: [^ self zero].
	^ (self ^ (n@n) evaluating: [:i :j| self x: n * (j - 1) + i]) determinant! !

!PolynomialRing methodsFor: 'examples' stamp: 'len 5/12/2018 16:56:34'!
fibonacciOfOrder: n
	"Answer the n-th Fibonacci polynomial."
	"QQ polynomials fibonacciOfOrder: 3"

	n negative ifTrue: [^ self notYetImplemented].
	n = 0 ifTrue: [^ self zero].
	n = 1 ifTrue: [^ self one].
	^ (self fibonacciOfOrder: n - 1) - (self x * (self fibonacciOfOrder: n - 2))! !

!PolynomialRing methodsFor: 'examples' stamp: 'len 5/12/2018 16:58:57'!
katsuraIdeal
	"Answer the Katsura ideal, used for benchmarks."
	| n f generators |
	n _ self rank.
	generators _ OrderedCollection new.
	f _ self !! -1.
	1-n to: n-1 do: [:i| f _ (self x: i abs + 1) + f].
	generators add: f.
	0 to: n-2 do: [:i|
		f _ (self x: i+1) * -1.
		1-n to: n-1 do: [:j| | k |
			k _ (i-j) abs + 1.
			k <= n ifTrue: [f _ (self x: j abs + 1) * (self x: k) + f]].
		generators add: f].
	^ self * generators! !

!PolynomialRing methodsFor: 'examples' stamp: 'len 2/21/2017 18:58:57'!
symmetric: r
	"Answer the r-th symmetric polynomial whose terms are all monomials formed by the product of r distinct indeterminates."
	| answer |
	answer _ self zero.
	(1 to: self rank) combinations: r atATimeDo: [:each| answer _ answer + (each product: [:i| self x: i])].
	^ answer! !

!PolynomialRing methodsFor: 'morphisms' stamp: 'len 1/2/2016 04:13'!
embed: aScalar
	^ self constant: aScalar! !

!PolynomialRing methodsFor: 'morphisms' stamp: 'len 5/13/2019 18:59:03'!
from: aDomain
	aDomain = self scalars ifTrue: [^ self addMap: ((self scalars to: self evaluating: [:x| self constant: x]) name: 'i')].
	aDomain -> self scalars ifNotNil: [:aMorphism| ^ aMorphism -> self].
	((aDomain isKindOf: PolynomialRing) and: [aDomain rank = self rank])
		ifTrue: [aDomain scalars -> self scalars ifNotNil: [:aMorphism| ^ aDomain to: self evaluating: [:f| f apply: aMorphism]]].
	^ super from: aDomain! !

!PolynomialRing methodsFor: 'morphisms' stamp: 'len 1/11/2018 17:40:00'!
to: aRing evaluating: aBlock
	(aRing isKindOf: PolynomialRing) ifFalse: [^ super to: aRing evaluating: aBlock].
	^ PolynomialRingMap from: self to: aRing evaluating: aBlock! !

!PolynomialRing methodsFor: 'operations' stamp: 'len 5/7/2019 17:24:03'!
^ n
	(n isInteger and: [self isMultivariate])
		ifTrue: [^ MultivariateTupleModule new: n over: self].
	^ super ^ n! !

!PolynomialRing methodsFor: 'operations' stamp: 'len 5/14/2019 20:49:59'!
 aRing
	"Answer the tensor product of the receiver and the argument.
	This is implemented for the special case of the argument being another polynomial ring over the same coefficients ring."
	| answer |
	aRing = self scalars ifTrue: [^ self  aRing polynomials].
	((aRing isKindOf: PolynomialRing) and: [aRing scalars = self scalars])
		ifFalse: [^ self notYetImplemented].
	answer _ self scalars polynomialsIn: self rank + aRing rank "ordering: self ordering, aRing ordering".
	(self names notNil and: [aRing names notNil])
		ifTrue:
			[| names xi |
			names _ self names asOrderedCollection.
			aRing names do: [:each|
				xi _ each.
				[names includes: xi] whileTrue: [xi _ xi, ''''].
				names add: xi].
			answer names: names].
	^ answer! !

!PolynomialRing methodsFor: 'operations' stamp: 'len 6/6/2019 13:21:14'!
completion
	"Answer the ring of power series, i.e. the completion of the receiver at 0."
"	self isUnivariate ifFalse: [^ self notYetImplemented]."
	^ PowerSeriesRing on: self! !

!PolynomialRing methodsFor: 'operations' stamp: 'len 10/27/2016 17:25'!
filtrationAt: anInteger
	"Answer the submodule of polynomials of degree <= anInteger."
	^ PolynomialFiltrationModule new polynomials: self; degree: anInteger! !

!PolynomialRing methodsFor: 'operations' stamp: 'len 12/24/2017 22:16:25'!
fractions
	"Answer the field of rational functions, i.e. the localization of the receiver at 0."
	^ self propertyAt: #fractions ifAbsentPut:
		[self scalars isField ifFalse: [^ DomainError signal: 'scalars are not a field'].
		RationalFunctionField on: self]! !

!PolynomialRing methodsFor: 'operations' stamp: 'len 12/24/2017 22:07:17'!
gradingAt: anInteger
	"Answer the submodule of homogeneous polynomials of degree anInteger."
	^ PolynomialGradingModule new polynomials: self; degree: anInteger! !

!PolynomialRing methodsFor: 'operations' stamp: 'len 10/27/2016 18:32'!
hilbertSeries
	^ self hilbertSeriesAt: (QQ polynomialsIn: #(t)) fractions x! !

!PolynomialRing methodsFor: 'operations' stamp: 'len 10/27/2016 18:32'!
hilbertSeriesAt: t
	^ (self gradings product: [:d| 1 - (t ^ d)]) reciprocal! !

!PolynomialRing methodsFor: 'operations' stamp: 'len 6/6/2019 13:17:59'!
localization
	"Answer the localization of the receiver at <x1,...,xn>. This is achieved by choosing a local ordering.
	Objects defined in this localization contain geometric information (usually only) about a Zariski neighbourhood of 0 in K^n, while objects in the global ring contain geometric information valid in the whole affine space K^n."
	self isGlobal ifFalse: [DomainError signal: 'the ring is not global'].
	^ self orderedBy: #lglex! !

!PolynomialRing methodsFor: 'operations' stamp: 'len 9/26/2016 06:46'!
proj
	"Answer the projective space associated to the receiver, Proj(R)."
	^ ProjectiveSpace coordinateRing: self! !

!PolynomialRing methodsFor: 'operations' stamp: 'len 10/31/2016 05:33'!
spec
	"Answer the spectrum of the receiver, Spec(R)."
	^ AffineSpace coordinateRing: self! !

!PolynomialRing methodsFor: 'printing' stamp: 'len 1/2/2017 10:23:51'!
printIndeterminatesOn: aStream
	self ordering indeterminates
		do: [:i| aStream print: (self x: i)]
		separatedBy: [aStream nextPut: $,]! !

!PolynomialRing methodsFor: 'random' stamp: 'len 3/25/2018 16:15:00'!
atRandom: aRandom bits: bitSize
	^ self atRandom: aRandom bits: bitSize maxDegree: ((bitSize raisedTo: (1/self rank)) min: bitSize - 1) truncated! !

!PolynomialRing methodsFor: 'random' stamp: 'len 10/22/2016 18:12'!
atRandom: aRandom bits: bitSize maxDegree: d
	| answer term n |
	self isUnivariate
		ifTrue: [^ self coefficients: (self scalars ^ (d+1) atRandom: aRandom bits: bitSize)].
	answer _ self zero.
	n _ 2 ^ self rank.
	n timesRepeat:
		[term _ ((1 to: d) product: [:i| self x: (self rank atRandom: aRandom) to: (2 atRandom: aRandom) - 1]) * (self scalars atRandom: aRandom bits: bitSize/(self rank*d)).
		answer _ answer + term].
	^ answer! !

!PolynomialRing methodsFor: 'random' stamp: 'len 8/10/2016 06:28'!
atRandom: aRandom maxDegree: d
	self isUnivariate ifFalse: [^ self notYetImplemented].
	^ self coefficients: (self scalars ^ (d+1) evaluating: [:i| self scalars atRandom: aRandom])! !

!PolynomialRing methodsFor: 'random' stamp: 'len 7/5/2016 02:29'!
atRandomBits: bitSize maxDegree: d
	^ Random withDefaultDo: [:aRandom| self atRandom: aRandom bits: bitSize maxDegree: d]! !

!PolynomialRing methodsFor: 'random' stamp: 'len 2/24/2016 23:33'!
atRandomDegree: d
	"Answer a polynomial of degree d choosen at random with a uniform distribution."
	self isUnivariate ifFalse: [^ self notYetImplemented].
	^ self coefficients: (self scalars ^ d) atRandom, self scalars one! !

!PolynomialRing methodsFor: 'random' stamp: 'len 2/25/2016 00:18'!
atRandomMaxDegree: d
	"Answer a polynomial of degree at most d choosen at random with a uniform distribution."
	self isUnivariate ifFalse: [^ self notYetImplemented].
	^ self coefficients: (self scalars ^ (d+1)) atRandom! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 6/4/2016 05:13'!
has: anIndeterminate
	^ self indeterminates includes: anIndeterminate! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 1/23/2017 11:44:49'!
includes: anObject
	^ (anObject isKindOf: Polynomial) and: [anObject parent <= self]! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 5/1/2019 17:33:22'!
isCoherent
	"Answer true if the receiver is a coherent ring, i.e. if it is coherent as a module over itself."
	"If R is a Prufer domain, i.e. a domain which is locally a valuation domain, then R[x1,..,xn] is coherent, i.e. Syzygy modules over R[x1,..,xn] are finitely generated."
	self scalars isPruferDomain ifTrue: [^ true].
	^ super isCoherent! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 10/22/2016 18:10'!
isCommutative
	^ true! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 9/21/2018 16:02:23'!
isEuclidean
	"Answer true if the receiver is an Euclidean ring, i.e. it has division with remainder."
	^ self scalars isEuclidean! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 4/29/2019 04:48:51'!
isGCDDomain
	^ self scalars isField or: [self scalars isUFD]
	"^ self scalars isGCDDomain"! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 2/12/2017 05:48:56'!
isGlobal
	"Answer true if this polynomial ring is global, i.e. it uses a global monomial ordering."
	^ self ordering isGlobal! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 2/12/2017 06:13:48'!
isGraded
	"Answer true if this polynomial ring is graded, i.e. it uses a graded monomial ordering."
	^ self ordering isGraded! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 4/27/2018 06:16:03'!
isIntegralDomain
	^ self scalars isIntegralDomain! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 2/12/2017 05:48:39'!
isLocal
	"Answer true if this polynomial ring is local, i.e. it uses a local monomial ordering."
	^ self ordering isLocal! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 1/7/2018 17:23:04'!
isMultivariate
	^ self rank > 1! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 6/4/2019 16:09:14'!
isNoetherian
	"Answer true if the receiver is a Noetherian ring, i.e. every ideal is finitely generated."
	self scalars isNoetherian ifTrue: [^ true]. "Hilber's basis theorem"
	^ super isNoetherian! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 10/22/2016 18:09'!
isPID
	"Univariate polynomials over a field are principal ideal domains."
	^ self scalars isField and: [self isUnivariate]! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 10/22/2016 18:11'!
isUFD
	self scalars isUFD ifTrue: [^ true]. "proof based on Gauss lemma"
	^ super isUFD! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 10/22/2016 18:16'!
isUnivariate
	^ self rank = 1! !

!PolynomialRing methodsFor: 'private' stamp: 'len 10/30/2016 15:48'!
idealClass
	^ PolynomialIdeal! !

!PolynomialRing methodsFor: 'private' stamp: 'len 2/26/2017 10:37:19'!
monomials: aFreeAbelianMonoid
	monomials _ aFreeAbelianMonoid! !

!PolynomialRing methodsFor: 'private' stamp: 'len 11/20/2016 12:06:41'!
ordering: aMonomialOrdering
	monomials ordering: aMonomialOrdering! !

!PolynomialRing methodsFor: 'private' stamp: 'len 1/2/2017 10:10:53'!
scalars: aRing
	scalars _ aRing! !

!PolynomialRing class methodsFor: 'examples' stamp: 'len 5/22/2018 22:25:28'!
example11
	"Creating a polynomial in Z[x]."
	| R x |
	R _ ZZ polynomials.
	x _ R x.
	^ x^2 - x + 3! !

!PolynomialRing class methodsFor: 'examples' stamp: 'len 5/22/2018 22:25:37'!
example12
	"Creating a polynomial in Z[x] from a tuple of coefficients."
	^ ZZ polynomials coefficients: #(3 -1 1)! !

!PolynomialRing class methodsFor: 'examples' stamp: 'len 5/22/2018 22:26:16'!
example13
	"Creating a polynomial in Z[x] from a block."
	^ ZZ polynomials !! [:x| x^2 - x + 3]! !

!PolynomialRing class methodsFor: 'examples' stamp: 'len 5/22/2018 22:26:52'!
example21
	"Creating a polynomial in Q[x,y]."
	| R x y |
	R _ ZZ polynomialsIn: #(x y). "these are just names for printing"
	x _ R x: 1.
	y _ R x: 2.
	^ x^2 - (x*y) + 1! !

!PolynomialRing class methodsFor: 'examples' stamp: 'len 5/22/2018 22:27:07'!
example22
	"A more compact way to create a polynomial in Q[x,y]."
	^ (ZZ polynomialsIn: #(x y)) !! [:x :y| x^2 - (x*y) + 1]! !

!PolynomialRing class methodsFor: 'examples' stamp: 'len 5/22/2018 22:27:28'!
example23
	"Creating a polynomial in Q[x,y] with local graded lexicographic ordering."
	| R x y |
	R _ ZZ polynomialsIn: #(x y) ordering: #lglex.
	x _ R x: 1.
	y _ R x: 2.
	^ x^2 - (x*y) + 1! !

!PolynomialRing class methodsFor: 'instance creation' stamp: 'len 5/13/2019 22:12:50'!
monomials: aFreeAbelianMonoid over: aRing
	^ self new monomials: aFreeAbelianMonoid; scalars: aRing! !

!PolynomialRing class methodsFor: 'instance creation' stamp: 'len 5/13/2019 22:12:02'!
new: anInteger over: aRing
	^ self monomials: (FreeAbelianMonoid new: anInteger) over: aRing! !

!PolynomialRing class methodsFor: 'instance creation' stamp: 'len 5/13/2019 22:12:22'!
new: anInteger over: aRing ordering: aMonomialOrdering
	^ self monomials: (FreeAbelianMonoid new: anInteger ordering: aMonomialOrdering) over: aRing! !

!LocalRing methodsFor: 'as yet unclassified' stamp: 'len 6/1/2019 12:29:07'!
isIntegral: anElement
	^ anElement valuation >= 0! !

!LocalRing methodsFor: 'as yet unclassified' stamp: 'len 6/1/2019 12:28:58'!
isUnit: anElement
	^ anElement valuation = 0! !

!Module methodsFor: 'accessing' stamp: 'len 12/16/2016 13:26:11'!
addition
	^ ((self, self) to: self evaluatingWithArguments: [:x :y| x + y]) name: '+'! !

!Module methodsFor: 'accessing' stamp: 'len 10/4/2018 00:13:10'!
additionInverse
	^ (self to: self evaluating: [:each| each negated]) name: '-id'! !

!Module methodsFor: 'accessing' stamp: 'len 2/14/2016 18:05'!
characteristic
	^ self scalars characteristic! !

!Module methodsFor: 'accessing' stamp: 'len 4/3/2018 06:34:35'!
null
	"Answer the trivial submodule, i.e. the zero object in the category of R-modules."
	^ self ambient span: #()! !

!Module methodsFor: 'accessing' stamp: 'len 5/16/2019 18:37:32'!
relationMatrix
	^ self propertyAt: #relationMatrix! !

!Module methodsFor: 'accessing' stamp: 'len 10/17/2016 10:49'!
scalarAction
	^ (self, self scalars) to: self evaluatingWithArguments: [:x :y| x * y]! !

!Module methodsFor: 'accessing' stamp: 'len 1/15/2018 19:06:19'!
scalars
	^ self propertyAt: #scalars ifAbsentPut: [self ambient scalars]! !

!Module methodsFor: 'accessing' stamp: 'len 10/4/2018 00:18:21'!
torsion
	"Answer the torsion submodule of the receiver, i.e. the set of elements e such that exists nonzero scalar r with e*r = 0."
	^ self propertyAt: #torsion! !

!Module methodsFor: 'accessing' stamp: 'len 5/14/2019 18:29:23'!
zero
	^ self propertyAt: #zero ifAbsentPut: [self isAmbient ifTrue: [self generators anyOne * self scalars zero] ifFalse: [self ambient zero]]! !

!Module methodsFor: 'comparing' stamp: 'len 1/13/2018 22:41:11'!
= anObject
	self == anObject ifTrue: [^ true].
	(anObject isKindOf: Module) ifFalse: [^ false].
	self scalars = anObject scalars ifFalse: [^ false].
	^ (self generators allSatisfy: [:each| anObject includes: each])
		and: [anObject generators allSatisfy: [:each| self includes: each]]! !

!Module methodsFor: 'comparing' stamp: 'len 1/13/2018 22:42:28'!
hash
	^ self scalars hash! !

!Module methodsFor: 'converting' stamp: 'len 12/18/2016 12:41:32'!
over: aRing
	"Answer the change of base ring of the receiver."
	self notYetImplemented! !

!Module methodsFor: 'enumerating' stamp: 'len 6/5/2019 20:04:26'!
do: aBlock
	| visited |
	self isTrivial ifTrue: [aBlock value: self zero. ^ self].
	visited _ Set new.
	self scalars ^ self generators size do: [:each|
		| x |
		x _ self zero.
		each withIndexDo: [:ai :i| x _ (self x: i) * ai + x].
		visited add: x ifAbsent: [aBlock value: x]]! !

!Module methodsFor: 'morphisms' stamp: 'len 4/22/2019 12:50:31'!
=> aModule
	aModule scalars = self scalars ifFalse: [DomainError signal: 'scalars don''t match'].
	^ HomModule from: self to: aModule! !

!Module methodsFor: 'morphisms' stamp: 'len 5/16/2019 18:34:55'!
into: aModule matrix: aMatrix
	^ self to: aModule matrix: aMatrix! !

!Module methodsFor: 'morphisms' stamp: 'len 5/16/2019 18:36:08'!
onto: aModule matrix: aMatrix
	^ self to: aModule matrix: aMatrix! !

!Module methodsFor: 'morphisms' stamp: 'len 12/22/2016 22:01:19'!
to: aCodomain
	(aCodomain isModule and: [self isTrivial or: [aCodomain isTrivial]])
		ifTrue: [^ self to: aCodomain evaluating: [:x| aCodomain zero]].
	^ super to: aCodomain! !

!Module methodsFor: 'morphisms' stamp: 'len 5/16/2019 18:32:05'!
to: aModule evaluating: aBlock
	aModule isModule ifFalse: [^ super to: aModule evaluating: aBlock].
	aModule scalars = self scalars ifFalse: [DomainError signal].
	self error: 'fail'.
	^ ModuleMap from: self to: aModule evaluating: aBlock! !

!Module methodsFor: 'morphisms' stamp: 'len 5/16/2019 21:07:44'!
to: aModule matrix: aMatrix
	aModule isModule ifFalse: [^ DomainError signal].
	^ ModuleMap from: self to: aModule matrix: aMatrix! !

!Module methodsFor: 'operations' stamp: 'len 4/30/2019 11:43:48'!
* anIdeal
	| newGenerators |
	(anIdeal isKindOf: Ideal) ifFalse: [^ self * (self scalars * anIdeal)]. "<- if it's a number, not an ideal"
	anIdeal isZero
		ifTrue: [^ self null].
	self isVectorSpace
		ifTrue: [^ self].
	anIdeal scalars = self scalars ifFalse: [^ DomainError signal: 'scalars don''t match'].
	newGenerators _ Set new.
	self generators do: [:a| anIdeal generators do: [:b| newGenerators add: a*b]].
	^ self ambient span: newGenerators! !

!Module methodsFor: 'operations' stamp: 'len 4/28/2019 16:32:48'!
+ anObject
	(self ambient includes: anObject) ifTrue: [^ AffineSubspace representative: anObject direction: self].
	(anObject isModule and: [self ambient = anObject ambient])
		ifFalse: [^ super + anObject].
	self isTrivial ifTrue: [^ anObject].
	anObject isTrivial ifTrue: [^ self].
	^ self ambient span: self generators, anObject generators! !

!Module methodsFor: 'operations' stamp: 'len 3/19/2018 17:15:32'!
/ aSubmodule
	^ self notYetImplemented! !

!Module methodsFor: 'operations' stamp: 'len 1/15/2018 18:54:24'!
 aModuleOrIdeal
	"For the receiver N and the argument P two submodules of an R-module M, answer the quotient N : P defined by {a in R | aP is contained in N}.
	For the receiver N, a submodule of an R-module M, and the argument I, an ideal of R, answer the quotient N : I defined by {m in M | I * m is containted in N}."
	self notYetImplemented! !

!Module methodsFor: 'operations' stamp: 'len 5/16/2019 21:07:59'!
 aModule
	| answer n |
	aModule isModule ifFalse: [^ super  aModule].
	n _ self generators size.
	^ (answer _ Module new relationMatrix: self relationMatrix  aModule relationMatrix)
		addCoprojections:
			{self into: answer mapping: [:i| answer x: i].
			aModule into: answer mapping: [:i| answer x: i+n]};
		addProjections:
			{answer onto: self mapping: [:i| i <= n ifTrue: [self x: i] ifFalse: [self identity]].
			answer onto: aModule mapping: [:i| i > n ifTrue: [aModule x: i-n] ifFalse: [aModule identity]]};
		yourself! !

!Module methodsFor: 'operations' stamp: 'len 1/15/2018 18:54:04'!
annihilator
	^ self null  self! !

!Module methodsFor: 'operations' stamp: 'len 4/19/2019 04:40:19'!
dual
	^ self => self scalars asSelfModule! !

!Module methodsFor: 'operations' stamp: 'len 9/28/2018 19:21:39'!
localization
	^ self over: self scalars fractions! !

!Module methodsFor: 'operations' stamp: 'len 9/28/2018 19:04:49'!
localizationAt: aPrimeIdeal
	"Answer the localization of the receiver at aPrimeIdeal."
	^ self over: (self scalars localizationAt: aPrimeIdeal)! !

!Module methodsFor: 'operations' stamp: 'len 4/25/2019 18:31:24'!
reduce: anElement
	"Answer 0 if anElement is in the receiver, and otherwise answer some representative of the coset 'anElement + self' (not necesarily a normal form)."
	^ self notYetImplemented! !

!Module methodsFor: 'operations' stamp: 'len 4/26/2019 07:21:40'!
span: aCollection
	"Answer the submodule spanned by the module elements in aCollection."
	^ self span: aCollection over: self scalars! !

!Module methodsFor: 'operations' stamp: 'len 9/28/2018 19:12:28'!
support
	"The support of an R-module M over a commutative ring R is the set of prime ideals p of R such that the localization of M at p is not the trivial module.
	By definition, the support is a subset of Spec(R)."
	
	"this is not very useful, it's only for finite rings:"
	^ self scalars spectrum reject: [:each| (self localizationAt: each) isTrivial]! !

!Module methodsFor: 'testing' stamp: 'len 4/25/2019 18:32:30'!
contains: anObject
	^ (self reduce: anObject) isZero! !

!Module methodsFor: 'testing' stamp: 'len 4/25/2019 18:32:40'!
includes: anElement
	^ self contains: anElement! !

!Module methodsFor: 'testing' stamp: 'len 10/2/2018 00:44:24'!
isFree
	^ false! !

!Module methodsFor: 'testing' stamp: 'len 12/16/2016 13:55:05'!
isInitial
	^ self isTrivial! !

!Module methodsFor: 'testing' stamp: 'len 1/23/2018 21:56:53'!
isLocal
	^ self scalars isLocal! !

!Module methodsFor: 'testing' stamp: 'len 1/11/2018 18:43:33'!
isModule
	^ true! !

!Module methodsFor: 'testing' stamp: 'len 6/4/2019 16:14:26'!
isNoetherian
	"A module is called Noetherian if every submodule is finitely generated."
	(self isAmbient not and: [self ambient isNoetherian]) ifTrue: [^ true].
	"A ring R is Noetherian if and only if every finitely generated R-module is a Noetherian module:"
	^ self scalars isNoetherian "because the receiver is finitely generated"! !

!Module methodsFor: 'testing' stamp: 'len 12/16/2016 13:55:08'!
isTerminal
	^ self isTrivial! !

!Module methodsFor: 'testing' stamp: 'len 1/10/2018 18:30:48'!
isTorsion
	"Answer true if the receiver is a torsion module."
	^ self torsion = self! !

!Module methodsFor: 'testing' stamp: 'len 1/10/2018 18:31:06'!
isTorsionFree
	"Answer true if the receiver is a torsion-free module."
	^ self torsion isTrivial! !

!Module methodsFor: 'testing' stamp: 'len 5/16/2019 18:35:50'!
isTrivial
	"Answer true if the receiver is the trivial submodule {0}."
	(self generators allSatisfy: [:each| each isZero]) ifTrue: [^ true].
	^ (self relationMatrix \ self relationMatrix transposed identity) notNil! !

!Module methodsFor: 'private' stamp: 'len 1/15/2018 20:13:05'!
generators: aCollection
	super generators: (aCollection asSet reject: [:each| each isZero])! !

!Module methodsFor: 'private' stamp: 'len 5/16/2019 18:37:11'!
relationMatrix: aMatrix
	self propertyAt: #relationMatrix put: aMatrix! !

!Module methodsFor: 'private' stamp: 'len 12/28/2016 11:35:02'!
scalars: aRing
	self propertyAt: #scalars put: aRing! !

!Ideal methodsFor: 'accessing' stamp: 'len 1/15/2018 17:56:11'!
codimension
	"Answer the Krull codimension of the receiver."
	^ self quotientRing codimension! !

!Ideal methodsFor: 'accessing' stamp: 'len 5/5/2018 16:40:17'!
denominator
	^ self scalars one! !

!Ideal methodsFor: 'accessing' stamp: 'len 1/15/2018 22:23:52'!
dimension
	"Answer the Krull dimension of the quotient ring of the base ring by the receiver."
	^ self quotientRing dimension! !

!Ideal methodsFor: 'accessing' stamp: 'len 1/15/2018 19:03:08'!
generator
	| generator |
	self generators size = 1 ifTrue: [^ self generators anyOne].
	self generators size = 0 ifTrue: [^ self scalars zero].
	self scalars isPID ifFalse: [^ self error: 'not a principal ideal domain'].
	self generators do: [:each| generator _ generator isNil ifTrue: [each] ifFalse: [generator gcd: each]].
	self generators: {generator}.
	^ generator! !

!Ideal methodsFor: 'accessing' stamp: 'len 1/23/2018 21:19:38'!
height
	"Answer the height (or codimension, or rank) of the receiver."
	^ (self scalars localizationAt: self) dimension! !

!Ideal methodsFor: 'accessing' stamp: 'len 5/5/2018 16:40:06'!
numerator
	^ self! !

!Ideal methodsFor: 'accessing-private' stamp: 'len 1/15/2018 18:48:36'!
generators: aCollection
	| generators |
	generators _ aCollection asSet reject: [:each| each isZero].
"	generators size = aCollection size ifTrue: [generators _ aCollection]." "keep order if possible"
	(generators size > 1 and: [[self scalars isPID] ifError: [false]])
		ifTrue:
			[| generator |
			generators do: [:each| generator _ generator isNil ifTrue: [each] ifFalse: [generator gcd: each]].
			generators _ {generator}].
	super generators: generators! !

!Ideal methodsFor: 'comparing' stamp: 'len 12/14/2015 18:55'!
< anIdeal
	"Answer true if the receiver is strictly included in the argument."
	^ self ~= anIdeal and: [self <= anIdeal]! !

!Ideal methodsFor: 'comparing' stamp: 'len 10/29/2016 11:26'!
<= anIdeal
	"Answer true if the receiver is included in the argument."
	self == anIdeal ifTrue: [^ true].
	self generators do: [:each| (anIdeal includes: each) ifFalse: [^ false]].
	^ true! !

!Ideal methodsFor: 'comparing' stamp: 'len 9/22/2018 18:54:41'!
= anIdeal
	self == anIdeal ifTrue: [^ true].
	(anIdeal isKindOf: Ideal) ifFalse: [^ false].
	self scalars = anIdeal scalars ifFalse: [^ false].
	self generators = anIdeal generators ifTrue: [^ true].
	^ self <= anIdeal and: [anIdeal <= self]! !

!Ideal methodsFor: 'comparing' stamp: 'len 1/15/2018 18:48:45'!
hash
	^ self scalars hash! !

!Ideal methodsFor: 'converting' stamp: 'len 10/23/2016 21:09'!
asIdeal
	^ self! !

!Ideal methodsFor: 'converting' stamp: 'len 5/23/2018 23:02:06'!
over: aRing
	^ (self scalars over: aRing) !! self! !

!Ideal methodsFor: 'copying' stamp: 'len 4/26/2019 14:10:00'!
copy
	"Answer a copy of the receiver."
	^ self class in: self scalars generators: self generators copy! !

!Ideal methodsFor: 'elements-operations' stamp: 'len 9/25/2018 15:36:14'!
reciprocalOf: anElement
	"This works only for ideals of an euclidean domain given by one generator."
	| euclid |
	self scalars isEuclideanDomain ifFalse: [^ nil].
	euclid _ ExtendedEuclid on: {anElement. self generator}.
	euclid gcd = self scalars one ifFalse: [^ nil].
	^ euclid bezout first! !

!Ideal methodsFor: 'elements-operations' stamp: 'len 2/23/2017 09:25:12'!
reduce: anElement
	"Answer the normal form of anElement with respect to the receiver.
	It is required that:
		(I reduce: x) = (I reduce: y) <=> x-y is in I, and
		x - (I reduce: x) is in I for all x, y in I.
	Subclasses should override."
	self isZero ifTrue: [^ anElement].
	^ anElement \\ self generator! !

!Ideal methodsFor: 'morphisms' stamp: 'len 5/13/2019 17:13:23'!
apply: aMorphism
	"Answer the homomorphic image of the receiver."
	aMorphism isBlock
		ifTrue: [^ self scalars * (self generators collect: aMorphism)].
	aMorphism domain = self scalars
		ifTrue: [^ aMorphism codomain * (self generators collect: aMorphism)].
	^ super apply: aMorphism! !

!Ideal methodsFor: 'operations' stamp: 'len 4/26/2019 14:09:25'!
* anElementOrIdeal
	"The product is included in the intersection: I*J <= I /\ J.
	When the ideals are comaximal, the equality holds."
	^ super * anElementOrIdeal! !

!Ideal methodsFor: 'operations' stamp: 'len 1/15/2018 18:46:03'!
+ anIdeal
	anIdeal scalars = self scalars ifFalse: [^ DomainError signal: 'ideals from different rings'].
	^ self scalars * (self generators asSet copy addAll: anIdeal generators; yourself)! !

!Ideal methodsFor: 'operations' stamp: 'len 1/15/2018 18:46:53'!
/ anIdeal
	"If the receiver is an ideal I in a ring R, and the argument is an ideal J in R, answer the projection of I to the quotient ring R/J."
	| Q |
	((anIdeal isKindOf: Ideal) and: [self scalars = anIdeal scalars]) ifFalse: [^ super / anIdeal].
	Q _ self scalars / anIdeal.
	^ Q * (self generators collect: [:each| Q project: each])! !

!Ideal methodsFor: 'operations' stamp: 'len 5/10/2019 04:27:51'!
/\ anIdeal
	"Answer the intersection of the receiver and the argument."
	^ self scalars * (self generator lcm: anIdeal generator)! !

!Ideal methodsFor: 'operations' stamp: 'len 6/5/2016 22:46'!
\/ anIdeal
	"Join."
	^ self + anIdeal! !

!Ideal methodsFor: 'operations' stamp: 'len 1/5/2018 11:00:18'!
^ anInteger
	"Answer the receiver raised to the power anInteger."
	anInteger <= 0 ifTrue: [self error: 'exponent is not positive'].
	anInteger = 1 ifTrue: [^ self].
"	anInteger = 0 ifTrue: [^ self ring oneIdeal].
	anInteger < 0 ifTrue: [^ (self ^ anInteger negated) reciprocal]."
	^ self squared ^ (anInteger // 2) * (self ^ (anInteger \\ 2))! !

!Ideal methodsFor: 'operations' stamp: 'len 2/23/2017 08:16:26'!
 anIdeal
	"Answer the colon quotient I:J of the receiver I with the argument J."
	self subclassResponsibility! !

!Ideal methodsFor: 'operations' stamp: 'len 1/15/2018 22:22:45'!
quotientRing
	"Answer the quotient ring of the base ring by the receiver."
	"is this ok? this is actually isomorphic to the quotient we mean, but maybe is ok, we have some quotient defined by relations and we just add more relations, also makes sense"
"	self flag: #fix.
	self ring isQuotient
		ifTrue: [^ self ring base / (self ring ideal generators, (self generators collect: [:each| each representative]))]."
	^ QuotientRing mod: self! !

!Ideal methodsFor: 'operations' stamp: 'len 2/13/2017 05:17:30'!
radical
	^ self subclassResponsibility! !

!Ideal methodsFor: 'operations' stamp: 'len 2/14/2017 10:24:02'!
saturation
	"Answer the saturation ideal I:I^infinity of the receiver I."
	^ self saturation: self! !

!Ideal methodsFor: 'operations' stamp: 'len 1/15/2018 18:51:44'!
squareFree
	^ self scalars * (self generators collect: [:each| each squareFree])! !

!Ideal methodsFor: 'operations' stamp: 'len 6/6/2019 12:04:50'!
squared
	^ self * self! !

!Ideal methodsFor: 'random' stamp: 'len 1/15/2018 18:47:58'!
atRandom: aRandom bits: bitSize
	self isZero ifTrue: [^ self scalars zero].
	^ self generators sum: [:each| each * (self scalars atRandom: aRandom bits: bitSize / self generators size)]! !

!Ideal methodsFor: 'testing' stamp: 'len 3/28/2018 19:49:45'!
| anIdeal
	"Answer true if the receiver divides anIdeal."
	^ self >= anIdeal! !

!Ideal methodsFor: 'testing' stamp: 'len 12/13/2016 07:40:07'!
contains: anObject
	self isZero ifTrue: [^ anObject isZero].
	^ (self reduce: anObject) isZero! !

!Ideal methodsFor: 'testing' stamp: 'len 1/15/2018 19:03:20'!
includes: anElement
	^ (self scalars includes: anElement) and: [self contains: anElement]! !

!Ideal methodsFor: 'testing' stamp: 'len 2/6/2017 08:23:37'!
isComaximalWith: anIdeal
	^ (self + anIdeal) isOne! !

!Ideal methodsFor: 'testing' stamp: 'len 5/5/2018 18:59:14'!
isIntegral
	"This is an integral ideal (not a fractional ideal)."
	^ true! !

!Ideal methodsFor: 'testing' stamp: 'len 5/22/2018 17:47:01'!
isMaximal
	"An ideal I of R is called 'maximal' if it is not contained in any other ideal but R itself.
	I is maximal iff R/I is a field."
	self scalars isPID ifFalse: [^ self propertyAt: #isMaximal].
	(self scalars isField not and: [self isZero]) ifTrue: [^ false].
	^ self isPrime! !

!Ideal methodsFor: 'testing' stamp: 'len 4/22/2019 15:16:37'!
isNilIdeal
	"An ideal is called nil-ideal if all its elements are nilpotent."
	^ self generators allSatisfy: [:each| self scalars isNilpotent: each]! !

!Ideal methodsFor: 'testing' stamp: 'len 9/22/2018 18:54:52'!
isNilpotent
	"An ideal I is called nilpotent if there is an integer n >= 1 such that I^n = 0."
	^ self notYetImplemented! !

!Ideal methodsFor: 'testing' stamp: 'len 1/15/2018 18:49:53'!
isOne
	"Answer true if the receiver is the unit ideal <1> that equals the whole ambient ring."
	^ self includes: self scalars one! !

!Ideal methodsFor: 'testing' stamp: 'len 9/22/2018 18:54:55'!
isPrime
	"An ideal I of R is prime iff R/I is an integral domain.
	This method only works for zero ideals or ideals given by one generator. Subclasses should reimplement."
	(self scalars isIntegralDomain and: [self isZero]) ifTrue: [^ true].
	(self scalars isUFD and: [self isPrincipal]) ifTrue: [^ self scalars isIrreducible: self generator].
	^ self subclassResponsibility! !

!Ideal methodsFor: 'testing' stamp: 'len 1/15/2018 18:49:58'!
isPrincipal
	"Answer true if the receiver is generated by a single element."
	self generators size <= 1 ifTrue: [^ true].
	self scalars isPID ifTrue: [^ true].
	^ self propertyAt: #isPrincipal! !

!Ideal methodsFor: 'testing' stamp: 'len 1/16/2018 16:09:50'!
isProper
	^ self isZero not and: [self isOne not]! !

!Ideal methodsFor: 'testing' stamp: 'len 2/13/2017 08:38:58'!
isRadical
	^ self = self radical! !

!Ideal methodsFor: 'testing' stamp: 'len 2/14/2017 10:24:17'!
isSaturated
	^ self = self saturation! !

!Ideal methodsFor: 'testing' stamp: 'len 2/14/2017 10:24:51'!
isSquareFree
	^ self = self squareFree! !

!Ideal methodsFor: 'testing' stamp: 'len 6/4/2019 07:52:22'!
isTrivial
	"Answer true if the receiver is the trivial ideal {0}."
	self flag: #fix. "look at superclass, take into account relationMatrix"
	^ self generators allSatisfy: [:each| each isZero]! !

!Ideal methodsFor: 'testing' stamp: 'len 6/4/2019 07:48:40'!
isZero
	"Answer true if the receiver is the zero ideal {0}."
	^ self isTrivial! !

!Ideal class methodsFor: 'examples' stamp: 'len 5/11/2018 20:52:37'!
example1
	"Creating an ideal of Z:"
	^ ZZ * {12. 18. 60}! !

!Ideal class methodsFor: 'examples' stamp: 'len 5/11/2018 20:53:57'!
example2
	"Creating an ideal in Z/3Z[x,y,z]:"
	| R x y z |
	R _ ZZ/3 polynomialsIn: #(x y z).
	x _ R x.
	y _ R y.
	z _ R z.
	^ R * {x^2 + (y^2). x*y + (y^2) + (y*z). y^2 + (z^2) + z}! !

!Ideal class methodsFor: 'instance creation' stamp: 'len 4/26/2019 14:06:04'!
in: aRingModule generators: aCollection
	^ self new ambient: aRingModule; generators: aCollection! !

!QuotientIdeal methodsFor: 'accessing' stamp: 'len 9/22/2018 18:58:05'!
representative
	"If the receiver is an ideal I of a quotient ring A/J, return the lifting of I to A, this is the ideal in A generated by the representatives in A of the generators of I."
	^ self propertyAt: #representative ifAbsentPut: [self scalars base * (self generators collect: [:each| each representative]) + self scalars relations]! !

!QuotientIdeal methodsFor: 'elements-operations' stamp: 'len 9/25/2018 15:34:44'!
reciprocalOf: anElement
	^ self scalars project: (self representative reciprocalOf: anElement representative)! !

!QuotientIdeal methodsFor: 'elements-operations' stamp: 'len 4/22/2018 00:04:40'!
reduce: anElement
	"Answer the normal form of anElement with respect to the receiver."
	^ self scalars project: (self representative reduce: anElement representative)! !

!QuotientIdeal methodsFor: 'operations' stamp: 'len 5/10/2019 04:33:40'!
/\ anIdeal
	"Answer the intersection of the receiver and the argument."
	^ self representative \/ anIdeal representative / self scalars relations! !

!QuotientIdeal methodsFor: 'operations' stamp: 'len 4/22/2018 00:03:51'!
 anIdeal
	"Answer the colon quotient I:J of the receiver I with the argument J."
	^ self representative  anIdeal representative / self scalars relations! !

!QuotientIdeal methodsFor: 'operations' stamp: 'len 4/22/2018 00:04:35'!
radical
	^ self representative radical / self scalars relations! !

!QuotientIdeal methodsFor: 'testing' stamp: 'len 4/22/2018 00:04:24'!
isPrime
	^ self representative isPrime! !

!QuotientIdeal methodsFor: 'testing' stamp: 'len 4/22/2018 00:04:29'!
isPrincipal
	"Answer true if the receiver is generated by a single element."
	^ self representative isPrincipal! !

!RationalIntegerIdeal methodsFor: 'elements-operations' stamp: 'len 9/25/2018 15:36:39'!
reciprocalOf: anInteger
	| result |
	result _ anInteger xgcd: self generator.
	^ (result at: 1) = 1 ifTrue: [result at: 2]! !

!RationalIntegerIdeal methodsFor: 'operations' stamp: 'len 5/10/2019 04:29:51'!
/\ anIdeal
	"Answer the intersection of the receiver and the argument."
	^ self scalars * (self generator lcm: anIdeal generator)! !

!RationalIntegerIdeal methodsFor: 'operations' stamp: 'len 1/15/2018 22:22:23'!
quotientRing
	"Answer the quotient ring of the base ring by the receiver."
	^ ModularIntegerRing mod: self! !

!RationalIntegerIdeal methodsFor: 'operations' stamp: 'len 5/4/2018 23:46:45'!
radical
	^ self scalars * self generator radical! !

!RationalIntegerIdeal methodsFor: 'random' stamp: 'len 4/19/2016 20:05'!
atRandom: aRandom bits: bitSize
	^ ((0-bitSize//2 to: bitSize//2) atRandom: aRandom) * self generator! !

!RationalIntegerIdeal methodsFor: 'random' stamp: 'len 4/19/2016 22:57'!
remainderAtRandom: aRandom
	^ (self generator abs atRandom: aRandom) - 1! !

!RationalIntegerIdeal methodsFor: 'testing' stamp: 'len 5/15/2018 19:10:53'!
isMaximal
	^ self isZero not and: [self isPrime]! !

!RationalIntegerIdeal methodsFor: 'testing' stamp: 'len 2/28/2017 21:22:28'!
isPrimary
	^ self propertyAt: #isPrimary ifAbsentPut:[self isZero or: [self generator factors asSet size = 1]]! !

!RationalIntegerIdeal methodsFor: 'testing' stamp: 'len 12/28/2016 12:09:18'!
isPrime
	^ self propertyAt: #isPrime ifAbsentPut:[self isZero or: [self generator isPrime]]! !

!RationalIntegerIdeal methodsFor: 'testing' stamp: 'len 2/28/2017 21:23:38'!
isSemiprime
	^ self propertyAt: #isSemiprime ifAbsentPut:[self isZero or: [self generator isSquareFree]]! !

!PolynomialIdeal methodsFor: 'accessing' stamp: 'len 5/8/2018 18:27:56'!
basis
	"Answer a standard basis of the receiver."
	^ self propertyAt: #basis ifAbsentPut: [(Buchberger on: self) basis]! !

!PolynomialIdeal methodsFor: 'accessing' stamp: 'len 1/19/2017 09:33:43'!
basisWithOrdering: aMonomialOrdering
	^ (self orderedBy: aMonomialOrdering) basis! !

!PolynomialIdeal methodsFor: 'accessing' stamp: 'len 2/12/2017 06:52:18'!
degree
	"Answer the degree of the ideal, i.e. the number of monomials that are not multiple of any leading monomial in the Groebner basis."
	| G count leadingMonomials |
	leadingMonomials _ Set new.
	G _ self basis minimal.
	G do: [:each| leadingMonomials add: each leadingMonomial].
	count _ 0.
	G do: [:each|
		each monomialsDo: [:monomial|
			(leadingMonomials noneSatisfy: [:lm| lm | monomial])
					ifTrue: [count _ count + 1]]].
	^ count! !

!PolynomialIdeal methodsFor: 'accessing' stamp: 'len 10/23/2016 11:59'!
depth
	^ self notYetImplemented! !

!PolynomialIdeal methodsFor: 'accessing' stamp: 'len 2/3/2017 07:16:55'!
groebnerBasis
	"Answer a Groebner basis of the receiver."
	self ordering isGlobal ifFalse: [^ self error: 'monomial ordering is not global'].
	^ self basis! !

!PolynomialIdeal methodsFor: 'accessing' stamp: 'len 11/19/2016 10:12:43'!
groebnerBasisWithOrdering: aMonomialOrdering
	^ (self orderedBy: aMonomialOrdering) groebnerBasis! !

!PolynomialIdeal methodsFor: 'accessing' stamp: 'len 1/15/2018 18:55:53'!
maximallyIndependentIndeterminates
	"Answer a maximimally independent set of indeterminates, or nil if the receiver is the full polynomial ring.
	The size of a maximally independent set is defined to be the dimension of the ideal, and it is the Krull dimension of the quotient ring defined by the ideal. Seeing the quotient ring as a field extension, the Krull dimension is its transcendence degree."
	"Derksen, Kemper, 'Computational Invariant Theory', 2002, Algorithm 1.2.4 (Dimension of an ideal)."
	| G leadingMonomials indeterminates |
	self isZero ifTrue: [^ #()].
	G _ self ordering isGraded
		ifTrue: [self groebnerBasis] "what about local orderings?"
		ifFalse: [self groebnerBasisWithOrdering: #grevlex].
	G _ G minimal. "is this necesary?"
	(G anySatisfy: [:any| any isConstant and: [any isZero not]])
		ifTrue: [^ self error: 'not a proper ideal'].

	leadingMonomials _ Set new.
	G do: [:each| leadingMonomials add: each leadingMonomial].
	indeterminates _ self scalars indeterminates.
	1 to: indeterminates size do: [:k|
		indeterminates combinations: k atATimeDo: [:combination|
			(leadingMonomials allSatisfy: [:monomial| combination includesAnyOf: monomial indeterminates])
				ifTrue: [^ indeterminates reject: [:any| combination includes: any]]]].
	self error: 'this shouldn''t be reached'! !

!PolynomialIdeal methodsFor: 'accessing' stamp: 'len 1/15/2018 18:56:02'!
ordering
	^ self scalars ordering! !

!PolynomialIdeal methodsFor: 'accessing' stamp: 'len 1/15/2018 18:57:34'!
univariateExponent
	"Answer the univariate exponent of the receiver.
	Becker, Weispfenning, 'Groebner Bases', Definition 8.24."
	| answer |
	answer _ 1.
	self scalars indeterminates do: [:i| | f mu |
		f _ (self eliminateAllBut: i) generator.
		mu _ 1.
		f factorizationDo: [:p :s| mu _ mu max: s].
		answer _ answer + (mu - 1)].
	^ answer! !

!PolynomialIdeal methodsFor: 'accessing' stamp: 'len 1/15/2018 18:57:42'!
variety
	"Answer the algebraic variety that is the set of zeroes of all polynomials in the receiver."
	^ self isHomogeneous ifTrue: [(self scalars / self radical) proj] ifFalse: [(self scalars / self radical) spec]! !

!PolynomialIdeal methodsFor: 'accessing-private' stamp: 'len 5/22/2018 18:25:09'!
generators: aCollection
	| generators |
	generators _ aCollection.
	(aCollection isKindOf: StandardBasis)
		ifTrue: [self propertyAt: #basis put: aCollection].
	"we normalize polynomial over Z in order to have consistent pseudo-division, but how about polynomials over other rings?"
	(aCollection isEmpty not and: [aCollection anyOne parent scalars isKindOf: RationalIntegerRing])
		ifTrue: [generators _ generators collect: [:each| each * each sign]].
	super generators: generators! !

!PolynomialIdeal methodsFor: 'converting' stamp: 'len 5/23/2018 22:51:15'!
orderedBy: aMonomialOrdering
	^ (self scalars orderedBy: aMonomialOrdering) !! self! !

!PolynomialIdeal methodsFor: 'elements-operations' stamp: 'len 9/25/2018 15:34:21'!
reciprocalOf: aPolynomial
	aPolynomial = self scalars one ifTrue: [^ aPolynomial].
	^ super reciprocalOf: aPolynomial! !

!PolynomialIdeal methodsFor: 'elements-operations' stamp: 'len 9/22/2018 18:55:34'!
reduce: aPolynomial
	"Answer the normal form of anElement with respect to the receiver."
	| f |
	f _ aPolynomial.
	f parent == self scalars ifFalse: [f _ self scalars !! f].
	(f isZero or: [self isZero]) ifTrue: [^ f].
	self isUnivariate ifTrue: [^ f \\ self generator].
	^ self basis reduce: f! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 5/10/2019 04:28:52'!
/\ anIdeal
	"To compute the intersection we introduce a new variable t, then eliminate it from the ideal I*t + J*(1-t)."
	| R S t |
	self isZero ifTrue: [^ self].
	anIdeal isZero ifTrue: [^ anIdeal].
	R _ self scalars.
	S _ R scalars polynomialsIn: R rank + 1.
	t _ S x: S rank.
	^ R !! (S !! self * t + (S !! anIdeal * (t - S one)) eliminate: S rank)! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 5/10/2019 04:33:18'!
 anIdeal
	"Answer the colon quotient I:J of the receiver I with the argument J.
	This is defined as I:J := {r in R | rJ <= I}."
	"Cox IVA 205p"
	"Derksen, Kemper, 'Computational Invariant Theory', 16p."
	| R answer |
	R _ self scalars.
	R isIntegralDomain ifFalse: [^ self error: 'not over an integral domain'].
	answer _ R asIdeal. "<1>"
	anIdeal generators do: [:g|
		answer _ answer /\ (R * ((R * g /\ self) basis apply: [:h| h /// g]))].
	^ answer! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 5/23/2018 22:50:08'!
dehomogenizedIn: anIndeterminate
	"Answer the dehomogenization of the receiver removing the given indeterminate."
	| R S |
	R _ self scalars.
	S _ R copyWithout: anIndeterminate.
	^ S * (self generators collect: [:each| S !! (each dehomogenizedIn: anIndeterminate)])! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 10/31/2016 03:27'!
eliminate: anIndeterminate
	"Answer the elimination ideal computed by eliminating anIndeterminate."
	^ self eliminateAll: {anIndeterminate}

"Alternative algorithm to compute eliminants:
input: ideal I in K[x1..xn] and indet xi
output: univariate eliminant g(xi) or there's no eliminant
1. compute groebner basis G of I in any monomial ordering
2. if no initial term of any element of G is a pure power of xi, then halt, no eliminant
3. compute the sequence 1 mod G, xi mod G, xi^2 mod G, ... until a linear dependence is found
  anxi^n+...+a1xi+a0 mod G = 0
where n is minimal, then output eliminant g(xi) = sum akxi^k
"! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 5/23/2018 22:50:50'!
eliminateAll: aCollection
	"Answer the elimination ideal for the indeterminates in aCollection = {xi}, i.e. the subideal of polynomials without indeterminates {xi}."
	| freeIndeterminates ordering G newGenerators |
	freeIndeterminates _ self ordering indeterminates reject: [:each| aCollection includes: each].
	self ordering isGlobal ifFalse: [self notYetImplemented].
	ordering _ (MonomialOrdering lex: aCollection), (MonomialOrdering grevlex: freeIndeterminates). "if the ideal is homogeneous, should we use use tlex?"
	G _ (self groebnerBasisWithOrdering: ordering) minimal.
	newGenerators _ G asArray select: [:each| (aCollection noneSatisfy: [:none| each has: none])].
	^ self scalars * (newGenerators collect: [:each| self scalars !! each])! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 1/15/2018 18:55:06'!
eliminateAllBut: anIndeterminate
	"Answer the subideal of polynomials with only the given indeterminate."
	^ self eliminateAll: (self scalars indeterminates select: [:each| each ~= anIndeterminate])! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 1/15/2018 18:55:11'!
highestCorner
	"Answer the highest corner of the receiver I.
	This is the unique monomial m such that:
		1) m is not in the leading ideal of I;
		2) if m' < m, then m' is in the leading ideal of I."
	self ordering isGlobal
		ifTrue: [^ self isProper ifTrue: [self scalars monomials identity]].
	"TODO: compute it combinatorially from a standard basis"
	self notYetImplemented! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 10/27/2016 18:42'!
hilbertSeries
	"Answer the Hilbert series of the receiver."
	^ self hilbertSeriesAt: (QQ polynomialsIn: #(t)) fractions x! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 11/24/2016 11:20:12'!
hilbertSeriesAt: t
	"Answer the Hilbert series of the receiver."
	self isHomogeneous ifFalse: [^ self notYetImplemented].
	^ self leadingIdeal hilbertSeriesAt: t! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 5/23/2018 22:51:02'!
homogenized
	"Answer the homogenization of the receiver introducing a new indeterminate."
	| R S G ordering |
	R _ self scalars.
	S _ R scalars polynomialsIn: R rank + 1.
	"Must use a graded monomial ordering such as glex or grevlex:"
	ordering _ MonomialOrdering grevlex: R rank.
	G _ self groebnerBasisWithOrdering: ordering.
	^ S * (G collect: [:each| S !! each homogenizedIn: S rank])! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 1/15/2018 18:55:38'!
leadingIdeal
	"Answer the initial ideal. This is the ideal of all leading monomials of the receiver."
	^ self scalars * self basis leadingTerms! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 1/15/2018 18:55:42'!
localization
	"Answer the localization of the receiver at <x1,...,xn>. This is achieved by choosing a local ordering.
	Objects defined in this localization contain geometric information (usually only) about a Zariski neighbourhood of 0 in K^n, while objects in the global ring contain geometric information whish is valid in the whole affine space K^n."
	self scalars isGlobal ifFalse: [DomainError signal: 'the ring is not global'].
	^ self orderedBy: #lglex! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 1/15/2018 18:56:08'!
predecomposition
	"Becker, Weispfenning, 'Groebner Bases', Table 8.1. Algorithm PREDEC."
	| R answer |
	R _ self scalars.
	answer _ Set with: self.
	R indeterminates do: [:i| | previous |
		previous _ answer.
		answer _ Set new.
		(self eliminateAllBut: i) generator monic factorizationDo: [:p :s|
			previous do: [:G| | H | (H _ G + (p^s)) isProper ifTrue: [answer add: H]]]].
	^ answer! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 1/15/2018 22:22:10'!
quotientRing
	"Answer the quotient ring of the base ring by the receiver."
	^ AffineRing mod: self! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 7/9/2016 05:21'!
radical
	self flag: #fix. "this is not right, maybe only works for Q[x1..xn] and monomial ideals"
	^ self squareFree! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 5/23/2018 22:54:39'!
saturation: anIdeal
	"Answer the saturation ideal I:J^infinity of the receiver I with the argument J."
	"Cox IVA 205p
	Derksen, Kemper, 'Computational Invariant Theory', pag. 16."
	| P t J |
	P _ self scalars scalars polynomialsIn: self scalars rank + 1.
	t _ P x: P rank.
	J _ P !! self.
	(P !! anIdeal asIdeal) generators do: [:each|
		J _ J + (P * (t * each - P one)).
		J _ J eliminate: P rank].
	^ self scalars !! J! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 1/15/2018 18:57:29'!
singular
	"Answer the singular locus of the receiver (or more precisely of the quotient by the receiver). The singular locus is defined as:
		Sing(A) := {P in Spec(A) | the localization of A at P is not regular}.
	If the receiver is not equidimensional, its lower-dimensional components will be contained in the answer whether they are singular or not.
	(See Eisenbud 'Commutative Algebra' Ch. 20, re Fitting ideal.)"
	| R generators n d jacobian J |
	self flag: #fix. "TODO: implement singular locus in general, from 'A Singular Introduction to Commutative Algebra', Algorithm 5.7.8"
	R _ self scalars.
	generators _  self generators asArray.
	n _ R rank.
	d _ self dimension.
	jacobian _ R matrix: n @ generators size evaluating: [:i :j| (generators at: j) derivativeIn: i].
	J _ self scalars * (jacobian minors: n - d).
	^ self + J
"before I did:
	J _ R matrix: n @ generators size evaluating: [:i :j| (generators at: j) derivativeIn: i].
	^ self scalars * ((J minors: n - d) collect: [:each| self reduce: each])
but that seems to be wrong"! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 1/15/2018 18:58:05'!
zeroDimensionalRadical
	"Answer the radical of the receiver, assuming it is zero-dimensional.
	Becker, Weispfenning, 'Groebner Bases', Table 8.3, Algorithm ZRADICAL."
	self dimension = 0 ifFalse: [self error: 'not zero-dimensional'].
	^ self scalars * (self scalars indeterminates collect: [:i| (self eliminateAllBut: i) generator squareFree])! !

!PolynomialIdeal methodsFor: 'random' stamp: 'len 1/15/2018 18:56:53'!
remainderAtRandom: aRandom
	self isPrincipal ifFalse: [^ self error: 'not yet implemented'].
	self scalars isUnivariate ifFalse: [^ self error: 'not yet implemented'].
	^ self scalars coefficients: ((0 to: self generator degree - 1) collect: [:i| self scalars scalars atRandom: aRandom])! !

!PolynomialIdeal methodsFor: 'testing' stamp: 'len 1/26/2017 09:36:18'!
contains: aPolynomial 
	"(Ideal Membership Problem)
	Answer true if the receiver includes aPolynomial.
	This works on any Groebner basis or standard basis (any monomial ordering)."
	^ (self reduce: aPolynomial) isZero! !

!PolynomialIdeal methodsFor: 'testing' stamp: 'len 10/29/2016 11:32'!
isHomogeneous
	^ self generators allSatisfy: [:each| each isHomogeneous]! !

!PolynomialIdeal methodsFor: 'testing' stamp: 'len 10/1/2018 05:23:32'!
isOne
	"Answer true if the receiver is <1>.
	Ref. Algorithmic Algebra, B. Mishra, pag. 142-145."
	(self generators anySatisfy: [:g| g isConstant]) ifTrue: [^ true].
	^ self groebnerBasis anySatisfy: [:g| g isConstant]! !

!PolynomialIdeal methodsFor: 'testing' stamp: 'len 9/22/2018 18:55:38'!
isPrime
	self isZero ifTrue: [^ true].
	(self isPrincipal and: [self scalars isUFD]) ifTrue: [^ self generator isIrreducible].
	^ self notYetImplemented! !

!PolynomialIdeal methodsFor: 'testing' stamp: 'len 5/26/2018 19:40:13'!
isPrincipal
	"Answer true if the receiver is generated by a single polynomial."
	^ self scalars isPID or: [self generators size = 1 or: [self basis reduced size <= 1]]! !

!PolynomialIdeal methodsFor: 'testing' stamp: 'len 1/15/2018 18:55:30'!
isUnivariate
	^ self scalars isUnivariate! !

!PolynomialIdeal methodsFor: 'testing' stamp: 'len 2/12/2017 06:57:19'!
isZeroDimensional
	"Answer true if the receiver is zero-dimensional. Being zero-dimensional means that the quotient ring has non-zero finite dimension as vector space over the coefficients field."
	^ self dimension = 0! !

!PolynomialIdeal methodsFor: 'testing' stamp: 'len 1/15/2018 18:55:34'!
isZeroDimensionalRadical
	"Answer true if the receiver is radical, assuming it is zero-dimensional.
	Becker, Weispfenning, 'Groebner Bases', Table 8.2, Algorithm ZRADICALTEST."
	self dimension = 0 ifFalse: [self error: 'not zero-dimensional'].
	self scalars indeterminates do: [:i| | f |
		f _ (self eliminateAllBut: i) generator.
		(f gcd: (f derivativeIn: i)) isConstant ifFalse: [^ false]].
	^ true! !

!PolynomialIdeal methodsFor: 'testing' stamp: 'len 10/1/2018 05:24:09'!
radicalContains: aPolynomial
	"(Radical Membership Problem)
	Answer true if the radical of the receiver includes aPolynomial.
	Use Rabinowich's trick introducing a new indeterminate."
	| R S t X |
	R _ self scalars.
	S _ R scalars polynomialsIn: R rank + 1.
	t _ S x: R rank + 1.
	X _ OrderedCollection new.
	self generators do: [:g| X add: S !! g].
	X add: S !! aPolynomial * t - S one.
	^ (S * X) isOne! !

!PolynomialIdeal class methodsFor: 'examples' stamp: 'len 5/12/2018 17:10:21'!
cyclic3
	"The ideal of cyclic 3-roots."
	^ (QQ polynomialsIn: #(x y z)) cyclicIdeal! !

!PolynomialIdeal class methodsFor: 'examples' stamp: 'len 5/12/2018 17:13:04'!
katsura3
	"The Katsura ideal in 3 variables with rational coefficients."
	^ (QQ polynomialsIn: #(a b c)) katsuraIdeal! !

!PolynomialIdeal class methodsFor: 'instance creation' stamp: 'len 5/2/2019 09:10:01'!
in: aModule generators: aCollection
	^ ((aModule asRing scalars isField and: [aCollection allSatisfy: [:each| each isMonomial]])
		ifTrue: [MonomialIdeal]
		ifFalse: [PolynomialIdeal]) new ambient: aModule; generators: aCollection! !

!MonomialIdeal methodsFor: 'accessing' stamp: 'len 2/19/2017 09:27:47'!
generatingMonomials
	"Answer the set of monomials corresponding to the polynomials that generate the receiver."
	^ self generators collect: [:each| each monomials anyOne]! !

!MonomialIdeal methodsFor: 'accessing-private' stamp: 'len 2/22/2017 07:46:01'!
generators: aCollection
	| generators |
	generators _ Set new.
	(aCollection asSortedCollection: [:a :b| a degree <= b degree])
		do: [:each| | f |
			f _ each monic.
			"make sure the generating set is minimal (and thus unique):"
			(generators anySatisfy: [:any| any | f]) ifFalse: [generators add: f]].
	super generators: generators! !

!MonomialIdeal methodsFor: 'operations' stamp: 'len 5/10/2019 04:32:54'!
/\ anIdeal
	"Answer the intersection of the receiver and the argument."
	"J. Herzog, 'Monomial Ideals', Proposition 1.2.1."
	| intersection |
	(anIdeal isKindOf: MonomialIdeal)
		ifFalse: [^ super /\ anIdeal].
	self scalars = anIdeal scalars ifFalse: [DomainError signal: 'rings don''t match'].
	intersection _ Set new.
	self generators do: [:each|
		anIdeal generators do: [:other| intersection add: (each lcm: other)]].
	^ self class in: self ambient generators: intersection! !

!MonomialIdeal methodsFor: 'operations' stamp: 'len 5/10/2019 04:33:06'!
 anIdeal
	"Answer the colon quotient I:J of the receiver I with the argument J.
	This is defined as I:J := {r in R | rJ <= I}.
	J. Herzog, 'Monomial Ideals', Proposition 1.2.2."
	| R answer |
	(anIdeal isKindOf: MonomialIdeal)
		ifFalse: [^ super  anIdeal].
	R _ self scalars.
	R isIntegralDomain ifFalse: [^ DomainError signal: 'not over an integral domain']. "is this needed?"
	answer _ R asIdeal. "<1>"
	anIdeal generators do: [:g|
		answer _ answer /\ (self class in: self ambient generators: (self generators collect: [:each| each /// (each gcd: g)]))].
	^ answer! !

!MonomialIdeal methodsFor: 'operations' stamp: 'len 1/15/2018 18:52:38'!
asSimplicialComplex
	"Answer the Stanley-Reisner simplicial complex associated to the receiver.
	This is the simplicial complex formed by the support of all squarefree monomials not in this ideal.
	Fail if this ideal is not squarefree."
	self isSquareFree ifFalse: [^ self error: 'not squarefree'].
	^ (SimplicialComplex on: self scalars indeterminates facets: (self generatingMonomials collect: [:each| each indeterminates])) complement dual! !

!MonomialIdeal methodsFor: 'operations' stamp: 'len 1/15/2018 18:52:44'!
dual
	"Answer the Alexander dual of the receiver.
	If I is the Stanley-Reisner ideal of a simplicial complex S, the Alexander dual of I is defined as the Stanley-Reisner ideal of the dual of S."
	^ self asSimplicialComplex dual stanleyReisnerIdealIn: self scalars! !

!MonomialIdeal methodsFor: 'operations' stamp: 'len 5/2/2019 08:54:46'!
hilbertSeriesAt: t
	"Answer the Hilbert series of the receiver."
	| n m J int |
	self isZero ifTrue: [^ t zero].
	n _ self scalars rank.
	m _ self generators asArray last.
	J _ self class in: self ambient generators: (self generators copyWithout: m).
	int _ self class in: self ambient generators: (J generators collect: [:each| each lcm: m]).
	^ t ^ m degree / ((1 to: n) product: [:i| 1 - (t ^ (self scalars gradings at: i))])
		+ (J hilbertSeriesAt: t)
		- (int hilbertSeriesAt: t)! !

!MonomialIdeal methodsFor: 'operations' stamp: 'len 2/19/2017 10:37:52'!
polarization
	"Answer the polarization of the receiver.
	The polarization is a deformation that assigns to an arbitrary monomial ideal a squarefree monomial ideal in a new set of variables."
	self notYetImplemented	! !

!MonomialIdeal methodsFor: 'operations' stamp: 'len 1/15/2018 18:53:17'!
primaryDecomposition
	"Answer the standard primary decomposition of the receiver.
	This is the unique primary decomposition obtained from an irredundant intersection of irreducible ideals."
	self isSquareFree ifFalse: [^ super primaryDecomposition].
	^ self asSimplicialComplex facets collect: [:each|
		self scalars * (self scalars indeterminates \ each vertices collect: [:i| self scalars x: i])]! !

!MonomialIdeal methodsFor: 'operations' stamp: 'len 2/17/2017 08:17:16'!
radical
	"J. Herzog, 'Monomial Ideals', Proposition 1.2.4."
	^ self squareFree! !

!MonomialIdeal methodsFor: 'printing' stamp: 'len 2/7/2017 02:52:25'!
printStaircase
	| w h matrix |
	w _ self generators max: [:each| (each degreeIn: 1) + 1].
	h _ self generators max: [:each| (each degreeIn: 2) + 1].
	matrix _ (1 to: h) collect: [:x| (1 to: w) collect: [:y| ' ']].
	self basis do: [:each| | x y |
		x _ each degreeIn: 1.
		y _ each degreeIn: 2.
		(matrix at: h-y) at: x+1 put: 'X'].
	^ String streamContents: [:aStream| matrix do: [:line| line do: [:dot| aStream nextPutAll: dot]] separatedBy: [aStream lf]]! !

!MonomialIdeal methodsFor: 'testing' stamp: 'len 2/20/2017 07:46:57'!
isIrreducible
	"Irreducible monomial ideals are those generated by powers of some of the variables."
	^ self generatingMonomials allSatisfy: [:each| each support size = 1]! !

!MonomialIdeal methodsFor: 'testing' stamp: 'len 2/20/2017 07:49:59'!
isPrimary
	"Primary monomial ideals are those containing powers of each of a certain subset of the variables, and generated by elements involving no further variables."
	^ self notYetImplemented! !

!MonomialIdeal methodsFor: 'testing' stamp: 'len 2/20/2017 07:47:09'!
isPrime
	"Prime monomial ideals are those generated by subsets of the variables."
	^ self generatingMonomials allSatisfy: [:each| each degree = 1 and: [each support size = 1]]! !

!MonomialIdeal methodsFor: 'testing' stamp: 'len 2/18/2017 21:07:07'!
isRadical
	^ self isSquareFree! !

!MonomialIdeal methodsFor: 'testing' stamp: 'len 2/18/2017 20:27:47'!
isSquareFree
	"A monomial ideal is squarefree iff each generator in the minimal generating set is squarefree."
	^ self generators allSatisfy: [:each| each isSquareFree]! !

!MonomialIdeal methodsFor: 'private' stamp: 'len 7/7/2016 07:39'!
species
	^ PolynomialIdeal! !

!FractionalIdeal methodsFor: 'accessing' stamp: 'len 1/15/2018 18:44:25'!
ambient
	^ self scalars fractions asSelfModule! !

!FractionalIdeal methodsFor: 'accessing' stamp: 'len 1/19/2018 20:34:49'!
denominator
	"Answer the denominator ideal of the receiver, which is an integral ideal."
	^ (self + self ambient oneIdeal) inverse! !

!FractionalIdeal methodsFor: 'accessing' stamp: 'len 1/19/2018 20:34:29'!
denominator2
	^ self propertyAt: #denominator ifAbsentPut: [self generators collect: [:each| each denominator] andFold: [:a :b| a lcm: b]]! !

!FractionalIdeal methodsFor: 'accessing' stamp: 'len 5/5/2018 05:13:53'!
numerator
	"Answer the numerator ideal of the receiver, which is an integral ideal."
	| denominator |
	denominator _ self denominator.
	^ self scalars * (self generators collect: [:each| each * denominator])! !

!FractionalIdeal methodsFor: 'testing' stamp: 'len 1/19/2018 20:21:40'!
isIntegral
	^ self scalars isUnit: self denominator! !

!FractionalIdeal methodsFor: 'testing' stamp: 'len 1/19/2018 23:43:12'!
isMaximal
	^ self isPrime and: [self isZero not]! !

!FractionalIdeal methodsFor: 'testing' stamp: 'len 5/5/2018 17:02:22'!
isPrime
	^ self factors size = 1! !

!FractionalIdeal methodsFor: 'testing' stamp: 'len 6/6/2019 11:50:21'!
isPrincipal
	"Answer true if the receiver is generated by a single element."
	self generators size <= 1 ifTrue: [^ true].
	self scalars isPID ifTrue: [^ true].
	^ self propertyAt: #isPrincipal! !

!FractionalIdeal class methodsFor: 'instance creation' stamp: 'len 1/15/2018 18:43:33'!
over: aRing generators: aCollection
	^ self new scalars: aRing; generators: aCollection! !

!HomModule methodsFor: 'accessing' stamp: 'len 10/2/2018 01:15:09'!
codomain
	^ codomain! !

!HomModule methodsFor: 'accessing' stamp: 'len 10/2/2018 01:15:31'!
domain
	^ domain! !

!HomModule methodsFor: 'accessing' stamp: 'len 10/2/2018 01:15:39'!
scalars
	^ self domain scalars! !

!HomModule methodsFor: 'converting' stamp: 'len 10/2/2018 01:17:24'!
over: aRing
	"Answer the change of base ring of the receiver."
	^ self class from: (self domain over: aRing) to: (self codomain over: aRing)! !

!HomModule methodsFor: 'elements' stamp: 'len 5/13/2019 14:01:37'!
!! anObject
	anObject isMatrix ifTrue: [^ FreeModuleMap from: domain to: codomain matrix: anObject].
	anObject isEvaluable ifTrue: [^ self evaluating: anObject].
	(self scalars includes: anObject) ifTrue: [^ self scalar: anObject].
	anObject isInteger ifTrue: [^ self scalar: self scalars !! anObject].
	^ super !! anObject! !

!HomModule methodsFor: 'elements' stamp: 'len 10/2/2018 01:17:40'!
evaluating: aBlock
	^ domain to: codomain evaluating: aBlock! !

!HomModule methodsFor: 'elements' stamp: 'len 4/25/2019 16:18:38'!
evaluatingWithArguments: aBlock
	^ domain to: codomain evaluatingWithArguments: aBlock! !

!HomModule methodsFor: 'elements' stamp: 'len 10/2/2018 01:18:06'!
identity
	^ self evaluating: [:x| x]! !

!HomModule methodsFor: 'elements' stamp: 'len 10/2/2018 01:18:14'!
scalar: aNumber
	^ self evaluating: [:x| x * aNumber]! !

!HomModule methodsFor: 'elements' stamp: 'len 10/2/2018 01:18:41'!
zero
	^ self evaluating: [:x| self codomain zero]! !

!HomModule methodsFor: 'operations' stamp: 'len 10/2/2018 01:19:10'!
opposite
	^ self class from: self codomain to: self domain! !

!HomModule methodsFor: 'testing' stamp: 'len 10/2/2018 01:20:18'!
includes: anObject
	^ (anObject isKindOf: ModuleMap) and: [anObject domain = self domain and: [anObject codomain = self codomain]]! !

!HomModule methodsFor: 'testing' stamp: 'len 4/26/2019 12:56:21'!
isDual
	"Answer true if the elements of the receiver are linear forms."
	^ codomain isKindOf: RingModule! !

!HomModule methodsFor: 'testing' stamp: 'len 10/2/2018 01:20:27'!
isEndomorphisms
	^ domain = codomain! !

!HomModule methodsFor: 'testing' stamp: 'len 10/2/2018 01:42:57'!
isFree
	^ domain isFree and: [codomain isFree]! !

!HomModule methodsFor: 'private' stamp: 'len 10/2/2018 01:16:42'!
codomain: aModule
	codomain _ aModule! !

!HomModule methodsFor: 'private' stamp: 'len 10/2/2018 01:16:14'!
domain: aModule
	domain _ aModule! !

!HomModule class methodsFor: 'instance creation' stamp: 'len 10/2/2018 01:14:35'!
from: aModule to: anotherModule
	^ self new
		domain: aModule;
		codomain: anotherModule! !

!QuotientModule methodsFor: 'accessing' stamp: 'len 10/3/2018 05:49:53'!
ambient
	^ self propertyAt: #ambient ifAbsentPut: [self relations ambient = self base ifTrue: [self] ifFalse: [self class base: self base ambient relations: self relations]]! !

!QuotientModule methodsFor: 'accessing' stamp: 'len 5/20/2018 17:03:30'!
base
	^ self propertyAt: #base ifAbsentPut: [self relations ambient]! !

!QuotientModule methodsFor: 'accessing' stamp: 'len 3/13/2018 18:12:23'!
generators
	^ self base generators collect: [:each| self project: each]! !

!QuotientModule methodsFor: 'accessing' stamp: 'len 5/30/2019 13:29:47'!
invariants
	^ self matrix isEmpty ifTrue: [#()] ifFalse: [self matrix elementaryDivisors]! !

!QuotientModule methodsFor: 'accessing' stamp: 'len 5/19/2018 20:09:11'!
matrix
	"Answer the relative matrix of the receiver."
	^ Matrix rows: (self relations basis collect: [:each| (self base coordinatesOf: each) over: self scalars])! !

!QuotientModule methodsFor: 'accessing' stamp: 'len 1/16/2018 18:34:25'!
relation
	^ EquivalenceRelation on: self base evaluating: [:x :y| self relations includes: x - y]! !

!QuotientModule methodsFor: 'accessing' stamp: 'len 2/27/2017 21:31:05'!
relations
	^ self propertyAt: #relations! !

!QuotientModule methodsFor: 'accessing' stamp: 'len 1/9/2018 21:57:47'!
relators
	^ self relations generators! !

!QuotientModule methodsFor: 'accessing' stamp: 'len 2/27/2017 21:32:55'!
scalars
	^ self relations scalars! !

!QuotientModule methodsFor: 'elements' stamp: 'len 1/16/2018 18:33:33'!
zero
	^ self project: self base zero! !

!QuotientModule methodsFor: 'morphisms' stamp: 'len 5/13/2019 19:07:19'!
from: aDomain
	aDomain = self base ifTrue: [^ self projection].
	aDomain -> self base ifNotNil: [:aMorphism| ^ aMorphism -> self].
	^ super from: aDomain! !

!QuotientModule methodsFor: 'morphisms' stamp: 'len 5/7/2018 22:53:04'!
lifting
	"Answer the map from the receiver to the base module lifting the canonical projection."
	^ self projection section! !

!QuotientModule methodsFor: 'morphisms' stamp: 'len 4/28/2019 16:33:22'!
project: anElement
	^ AffineSubspace representative: anElement direction: self relations! !

!QuotientModule methodsFor: 'morphisms' stamp: 'len 1/16/2018 18:29:19'!
projection
	"Answer the natural projection, or quotient map, or canonical homomorphism. This takes elements from the base module or vector space to the corresponding coset (an affine subspace) in the quotient."
	^ self propertyAt: #projection ifAbsentPut: [self buildProjection]! !

!QuotientModule methodsFor: 'operations' stamp: 'len 4/25/2019 18:24:32'!
/ aModule
	"Asnwer the subquotient module."
	"Given modules M1 and M2 (presented by matrices M1 and M2).
	The subquotient module (M1 + M2) / M2, written shorthand as M1/M2, is computed like this:
	- compute a basis B of M2;
	- reduce M1 module B and get N;
	- the syzygy matrix S of M module N is the desired presentation.
	See GAP4 homalg SubfactorModule(M1,M2)."! !

!QuotientModule methodsFor: 'operations' stamp: 'len 5/20/2018 18:32:24'!
annihilator
	"Answer the ideal of the scalars rings that annihilates all the elements in the receiver."
	self isFinite ifFalse: [^ self scalars zeroIdeal].
	^ self scalars * (self invariants inject: self scalars one into: [:result :each| result lcm: each])! !

!QuotientModule methodsFor: 'operations' stamp: 'len 5/19/2018 19:59:36'!
span: aCollection
	"Answer the submodule spanned by the module elements in aCollection."
	^ (self base span: (aCollection apply: self lifting)) apply: self projection! !

!QuotientModule methodsFor: 'operations' stamp: 'len 5/19/2018 20:10:33'!
span: aCollection over: aRing
	"Answer the submodule spanned by the module elements in aCollection over aRing."
	aRing = self scalars ifFalse: [^ DomainError signal].
	^ self span: aCollection! !

!QuotientModule methodsFor: 'testing' stamp: 'len 1/16/2018 18:31:56'!
contains: anAffineSubspace
	^ anAffineSubspace direction = self relations! !

!QuotientModule methodsFor: 'testing' stamp: 'len 4/28/2019 16:33:17'!
includes: anObject
	^ (anObject isKindOf: AffineSubspace) and: [self contains: anObject]! !

!QuotientModule methodsFor: 'testing' stamp: 'len 9/15/2018 05:43:12'!
isFinite
	^ (self invariants includes: 0) not and: [self invariants isEmpty not]! !

!QuotientModule methodsFor: 'testing' stamp: 'len 5/20/2018 13:37:28'!
isNoetherian
	"A module is called Noetherian if every submodule is finitely generated."
	^ self base isNoetherian! !

!QuotientModule methodsFor: 'testing' stamp: 'len 1/16/2018 18:31:21'!
isQuotient
	^ true! !

!QuotientModule methodsFor: 'private' stamp: 'len 5/20/2018 17:02:48'!
base: aModule
	self propertyAt: #base put: aModule! !

!QuotientModule methodsFor: 'private' stamp: 'len 5/16/2019 13:31:57'!
buildProjection
	"Answer the quotient map, the canonical projection from the base module to the quotient module, i.e. the mapping pi:M->M/N that assigns to every x in M the coset x+N."
	| answer |
	answer _ self base onto: self evaluating: [:each| self project: each].
	answer name: Character pi asString.
	answer properties
		at: #kernel put: self relations;
		at: #image put: self;
		at: #section put: (self to: self base evaluating: [:each| each representative]).
	^ answer! !

!QuotientModule methodsFor: 'private' stamp: 'len 2/27/2017 21:31:18'!
relations: aSubmodule
	self propertyAt: #relations put: aSubmodule! !

!QuotientModule class methodsFor: 'instance creation' stamp: 'len 5/20/2018 17:02:20'!
base: aModule relations: aSubmodule
	^ self new base: aModule; relations: aSubmodule! !

!QuotientModule class methodsFor: 'instance creation' stamp: 'len 2/27/2017 21:32:21'!
mod: aSubmodule
	^ self new relations: aSubmodule! !

!FreeModule methodsFor: 'accessing' stamp: 'len 5/13/2019 22:55:22'!
ambient
	^ super ambient
"	^ self propertyAt: #ambient ifAbsentPut: [self scalars isField ifTrue: [self] ifFalse: [self scalars isIntegralDomain ifTrue: [self over: self scalars fractions] ifFalse: [self]]]"! !

!FreeModule methodsFor: 'accessing' stamp: 'len 9/28/2018 18:58:34'!
ambientSpace
	^ self scalars isField ifTrue: [self ambient] ifFalse: [self scalars isIntegralDomain ifTrue: [self ambient over: self scalars fractions]]! !

!FreeModule methodsFor: 'accessing' stamp: 'len 12/28/2016 12:07:59'!
coordinateNames
	^ self propertyAt: #coordinateNames ifAbsent: []! !

!FreeModule methodsFor: 'accessing' stamp: 'len 2/27/2017 21:20:52'!
degree
	"Answer the degree of this free module.
	This is the rank of the ambient module."
	^ self ambient rank! !

!FreeModule methodsFor: 'accessing' stamp: 'len 3/16/2018 19:14:01'!
denominator
	^ self matrix denominator! !

!FreeModule methodsFor: 'accessing' stamp: 'len 10/16/2016 14:45'!
generators
	^ self basis! !

!FreeModule methodsFor: 'accessing' stamp: 'len 4/3/2018 15:53:06'!
gramian
	"Answer the Gramian of the receiver, or Gram matrix.
	If M is the generator matrix of the receiver (>>matrix), and the inner product of the receiver is the dot product, then the Gramian is M * M transposed."
"	^ self matrix * self ambient innerProduct matrix * self matrix transposed"
	| f |
	f _ self ambient innerProduct.
	^ self ambient scalars
		matrix: self rank
		evaluating:
			[:i :j| f value: {(self basis at: i). (self basis at: j)}]! !

!FreeModule methodsFor: 'accessing' stamp: 'len 5/5/2019 17:35:52'!
innerProduct
	"Answer the bilinear form defining the Euclidean inner product."
	^ self propertyAt: #innerProduct ifAbsentPut:
		[BilinearForm
			from: (self, self)
			evaluating: [:each| (self coordinatesOf: each first)  (self coordinatesOf: each second)]]! !

!FreeModule methodsFor: 'accessing' stamp: 'len 4/3/2018 06:37:26'!
matrix
	"Answer the generator matrix of the receiver, i.e. the matrix whose rows are the coordinates of the generators of the receiver in the ambient distinguished basis."
	^ self propertyAt: #matrix ifAbsentPut: [self ambient scalars identityMatrix: self rank] "if the matrix is not set, it means the receiver is a full ambient module (not embedded)"! !

!FreeModule methodsFor: 'accessing' stamp: 'len 9/16/2018 16:13:05'!
names
	"Answer a list of names for use instead of the elements of the basis when printing linear maps, tensors, etc."
	^ self propertyAt: #names ifAbsentPut: [(1 to: self rank) collect: [:i| 'e', i printString sub]]! !

!FreeModule methodsFor: 'accessing' stamp: 'len 12/28/2016 12:08:05'!
norm
	^ self propertyAt: #norm ifAbsentPut:
		[Function from: self to: self scalars "should go to the reals"
			evaluating: [:x| (self innerProduct value: {x. x conjugated}) squareRoot]]! !

!FreeModule methodsFor: 'accessing' stamp: 'len 12/28/2016 12:07:26'!
norm2
	"Answer the squared norm."
	^ self propertyAt: #norm2 ifAbsentPut:
		[Function from: self to: self scalars
			evaluating: [:x| (self innerProduct value: {x. x conjugated})]]! !

!FreeModule methodsFor: 'accessing' stamp: 'len 5/16/2019 18:42:54'!
relationMatrix
	^ self scalars matrix: #()! !

!FreeModule methodsFor: 'accessing' stamp: 'len 12/7/2017 21:04:48'!
size
	| n |
	^ (n _ self rank) = 0 ifTrue: [^ 1] ifFalse: [self scalars size ^ n]! !

!FreeModule methodsFor: 'basis' stamp: 'len 3/18/2018 15:08:12'!
basis
	^ self propertyAt: #basis ifAbsentPut: [self matrix rows collect: [:each| self ambient elementAt: each]]! !

!FreeModule methodsFor: 'basis' stamp: 'len 8/25/2016 21:02'!
codimension
	^ self ambient dimension - self dimension! !

!FreeModule methodsFor: 'basis' stamp: 'len 4/5/2018 04:01:33'!
coordinateMap
	"Answer the isomorphism between the receiver and its coordinates."
	^ self to: self coordinates matrix: self matrix! !

!FreeModule methodsFor: 'basis' stamp: 'len 12/10/2017 21:21:41'!
coordinateRing
	"The coordinate ring of a R-module of rank n (or K-vector space of dimension n) is the polynomial ring R[x1..xn] (or K[x1..xn])."
	^ self propertyAt: #coordinateRing ifAbsentPut: [self scalars polynomialsIn: (self coordinateNames ifNil: [self rank])]! !

!FreeModule methodsFor: 'basis' stamp: 'len 4/5/2018 00:06:14'!
coordinates
	"Answer the coordinate space (or module) of the receiver."
	^ self scalars ^ self rank! !

!FreeModule methodsFor: 'basis' stamp: 'len 4/5/2018 00:11:51'!
coordinatesOf: anElement
	"Answer the coordinates of anElement when expressed as a linear combination of the elements of the distinguished basis of the receiver. Answer nil if anElement is not in the receiver."
	anElement isZero ifTrue: [^ self coordinates zero].
	self isTrivial ifTrue: [^ nil].
	^ self matrix transposed \ (self ambient coordinatesOf: anElement)
"
	^ self matrix transposed \ (self ambient coordinatesOf: anElement)
alternative 1:
	answer _ self matrix leftInverse * (ambient coordinatesOf: anElement).
	^ answer isZero ifFalse: [answer]"
"alternative 2:
	m _ self matrix rowAugmented: (ambient coordinatesOf: anElement).
	reducer _ m transposed reducer.
	coords _ reducer reduced lastColumn.
	^ reducer rank > self size
		ifFalse:
			[answer _ self coordinates zero copy.
			reducer pivots do: [:each| answer at: each x put: (coords at: each y)].
			answer]"! !

!FreeModule methodsFor: 'basis' stamp: 'len 9/3/2018 21:04:35'!
corank
	self isVectorSpace ifTrue: [^ self ambient rank - self rank].
	^ (self ambient / self) rank! !

!FreeModule methodsFor: 'basis' stamp: 'len 7/15/2016 00:04'!
dimension
	"Custom notation for vector spaces."
	^ self rank! !

!FreeModule methodsFor: 'basis' stamp: 'len 9/8/2018 17:38:18'!
discriminant
	^ self gramian determinant
	
"sage defines it like this for free quadratic modules:
	^ (self rank // 2) even ifTrue: [self gramian determinant] ifFalse: [self gramian determinant negated]
"! !

!FreeModule methodsFor: 'basis' stamp: 'len 10/15/2016 16:47'!
e: anInteger
	^ self basis at: anInteger! !

!FreeModule methodsFor: 'basis' stamp: 'len 10/3/2018 05:51:05'!
elementAt: aTuple
	"Answer a module element with the given coordinates in the distinguished basis."
	| answer |
	answer _ self zero.
	self basis with: aTuple do: [:each :xi| answer _ each * xi + answer].
	^ answer! !

!FreeModule methodsFor: 'basis' stamp: 'len 5/15/2019 00:15:22'!
orthonormalBasis
	^ self propertyAt: #orthonormalBasis ifAbsentPut: [self matrix orthonormalized rows collect: [:each| self ambient elementAt: each]]! !

!FreeModule methodsFor: 'basis' stamp: 'len 2/24/2016 02:24'!
rank
	^ self basis size! !

!FreeModule methodsFor: 'basis' stamp: 'len 5/4/2019 03:09:42'!
x: anInteger
	^ self basis at: anInteger! !

!FreeModule methodsFor: 'comparing' stamp: 'len 7/14/2016 23:18'!
< aModule
	"Answer true if the receiver is strictly included in the argument, i.e. it's a proper submodule of the argument."
	^ self rank < aModule rank and: [self <= aModule]! !

!FreeModule methodsFor: 'comparing' stamp: 'len 3/16/2018 19:17:37'!
<= aModule
	"Answer true if the receiver is included in the argument, i.e. it's a submodule of the argument."
	self == aModule ifTrue: [^ true].
	self rank <= aModule rank ifFalse: [^ false].
	self generators do: [:each| (aModule includes: each) ifFalse: [^ false]].
	^ true! !

!FreeModule methodsFor: 'comparing' stamp: 'len 5/20/2018 15:45:33'!
= anObject
	self == anObject ifTrue: [^ true].
	(anObject isKindOf: FreeModule) ifFalse: [^ false].
	self scalars = anObject scalars ifFalse: [^ false].
	self rank = anObject rank ifFalse: [^ false].
	self flag: #fix.
	^ self generators allSatisfy: [:each| anObject includes: each] "or better test echelonized matrices are equal"! !

!FreeModule methodsFor: 'comparing' stamp: 'len 11/3/2016 09:10'!
~ aModule
	"Answer true if the receiver is isomorphic to the argument."
	^ self == aModule or: [aModule isFreeModule and: [self scalars = aModule scalars and: [self rank = aModule rank]]]! !

!FreeModule methodsFor: 'comparing' stamp: 'len 7/14/2016 23:22'!
hash
	^ self scalars hash + self rank hashMultiply! !

!FreeModule methodsFor: 'converting' stamp: 'len 5/26/2019 12:18:23'!
asAbelianGroup
	| answer |
	(self scalars isKindOf: RationalIntegerRing) ifTrue:
		[^ (answer _ FreeAbelianGroup new: self rank)
			addMap: (self to: answer evaluating: [:each| answer !! (self coordinatesOf: each)]);
			addMap: (answer to: self evaluating: [:each| self !! each exponents]);
			yourself].
	(self scalars isKindOf: ModularIntegerRing) ifTrue:
		[^ (answer _ AbelianGroup orders: ((1 to: self rank) collect: [:each| self scalars modulus]))
			addMap: (self to: answer evaluating: [:each| answer !! (self coordinatesOf: each) representatives]);
			addMap: (answer to: self evaluating: [:each| self !! each exponents]);
			yourself].
	^ DomainError signal! !

!FreeModule methodsFor: 'converting' stamp: 'len 5/28/2019 07:52:23'!
asAlgebraicVariety
	| R |
	R _ self scalars polynomialsIn: self ambient rank.
	^ (R * (self annihilatorSpace basis asArray collect: [:each| R !! each])) variety! !

!FreeModule methodsFor: 'converting' stamp: 'len 5/26/2019 12:18:23'!
asElementaryAbelianGroup
	| answer |
	(self scalars isKindOf: PrimeField) ifFalse: [^ DomainError signal].
	^ (answer _ AbelianGroup orders: ((1 to: self rank) collect: [:i| self scalars modulus]))
		addMap: (self to: answer evaluating: [:x| answer !! (self coordinatesOf: x) lift]);
		addMap: (answer to: self evaluating: [:x| self !! x exponents]);
		yourself! !

!FreeModule methodsFor: 'converting' stamp: 'len 5/19/2018 03:53:20'!
asLattice
	| V |
	self scalars fractions = self scalars ifTrue: [^ DomainError signal].
	V _ self over: self scalars fractions.
	^ V ambient span: V basis over: self scalars! !

!FreeModule methodsFor: 'converting' stamp: 'len 3/1/2017 08:53:02'!
asVectorSpace
	self scalars isField ifTrue: [^ self].
	self scalars isIntegralDomain ifTrue: [^ self over: self scalars fractions].
	^ DomainError signal: 'not over an integral domain'! !

!FreeModule methodsFor: 'converting' stamp: 'len 3/1/2017 08:53:41'!
over: aRing
	aRing = self scalars ifTrue: [^ self].
	aRing isPID ifFalse: [^ DomainError signal: 'not a PID']. "or isIntegralDomain?"
	self notYetImplemented
"	V _ self ambient over: aRing fractions.
	self basis collect: [:each| "! !

!FreeModule methodsFor: 'elements' stamp: 'len 5/22/2018 16:54:56'!
!! anObject
	(anObject isSequenceable and: [anObject size = self rank])
		ifTrue: [^ self elementAt: anObject].
	^ super !! anObject! !

!FreeModule methodsFor: 'enumerating' stamp: 'len 4/5/2018 00:07:29'!
do: aBlock
	self coordinates do: [:each| aBlock value: (self elementAt: each)]! !

!FreeModule methodsFor: 'morphisms' stamp: 'len 4/30/2019 04:58:43'!
=> aModule
	aModule scalars = self scalars ifFalse: [DomainError signal: 'scalars don''t match'].
	^ FreeHomModule from: self to: aModule! !

!FreeModule methodsFor: 'morphisms' stamp: 'len 5/13/2019 17:12:23'!
apply: aMorphism
	"Answer the homomorphic image of the receiver."
	^ (aMorphism isBlock ifTrue: [self ambient] ifFalse: [aMorphism codomain ambient]) span: (self basis collect: [:each| aMorphism value: each]) over: self scalars! !

!FreeModule methodsFor: 'morphisms' stamp: 'len 9/25/2018 17:14:33'!
automorphisms
	^ GeneralLinearGroup on: self! !

!FreeModule methodsFor: 'morphisms' stamp: 'len 5/19/2018 17:37:19'!
orthogonalProjection
	"Answer an orthogonal projection onto the receiver."
	| answer A T |
	self propertyAt: #orthogonalProjection ifPresent: [:aLinearMap| ^ aLinearMap].
	self isTrivial ifTrue: [^ self ambient endomorphisms zero].
	A _ self matrix.
	T _ A transposed.
	answer _ self ambient endomorphisms !! (T * (A * T) inverse * A).
	self propertyAt: #orthogonalProjection put: answer.
	^ answer! !

!FreeModule methodsFor: 'morphisms' stamp: 'len 9/25/2018 17:17:02'!
rotations
	^ SpecialOrthogonalGroup on: self! !

!FreeModule methodsFor: 'morphisms' stamp: 'len 5/13/2019 14:00:48'!
to: aModule evaluating: aBlock
	aModule isFreeModule ifFalse: [^ super to: aModule evaluating: aBlock].
	aModule scalars = self scalars ifFalse: [DomainError signal].
	^ FreeModuleMap from: self to: aModule evaluating: aBlock! !

!FreeModule methodsFor: 'morphisms' stamp: 'len 5/13/2019 14:00:48'!
to: aModule matrix: aMatrix
	aModule isFreeModule ifFalse: [^ DomainError signal].
	aModule scalars = self scalars ifFalse: [DomainError signal].
	^ FreeModuleMap from: self to: aModule matrix: aMatrix! !

!FreeModule methodsFor: 'operations' stamp: 'len 4/3/2018 19:20:40'!
* aNumber
	"Answer the receiver scaled by aNumber."
	aNumber isZero
		ifTrue: [^ self null].
	self isVectorSpace
		ifTrue: [^ self].
	(aNumber = self scalars one or: [aNumber = self scalars one negated])
		ifTrue: [^ self].
	self scalars isPID "this means the receiver is a lattice embedded in a vector space over the fraction field"
		ifTrue: [^ self ambient span: (self generators collect: [:each| each * aNumber]) over: self scalars].
	^ DomainError signal! !

!FreeModule methodsFor: 'operations' stamp: 'len 5/15/2019 00:17:14'!
+ anObject
	(self ambient includes: anObject) ifTrue: [^ AffineSubspace representative: anObject direction: self].
	self isTrivial ifTrue: [^ anObject].
	anObject isTrivial ifTrue: [^ self].
	(self scalars isPID and: [self scalars = anObject scalars and: [self ambient = anObject ambient]]) ifFalse: [^ DomainError signal].
	^ self ambient span: self matrix, anObject matrix over: self scalars! !

!FreeModule methodsFor: 'operations' stamp: 'len 4/19/2019 07:15:19'!
/ anObject
	"Answer the quotient of the receiver by the submodule anObject,
	i.e. the module obtained by 'collapsing' the submodule to zero.
	Alternatively, if anObject is an scalar, scale down the receiver by it."
	(self ambient scalars includes: anObject) ifTrue: [^ self * anObject reciprocal].
	(self includes: anObject) ifTrue: [^ self / (self ambient span: {anObject} over: self scalars)].
	anObject isCollection ifTrue: [^ self / (self ambient span: anObject over: self scalars)].
	anObject isFreeModule ifFalse: [^ super / anObject].
	(self scalars isPID and: [self ambient = anObject ambient])
		ifFalse: [^ DomainError signal].
	self isVectorSpace ifTrue:
		[| Q |
		Q _ QuotientSpace mod: anObject.
		self isAmbient ifTrue: [^ Q].
		^ Q span: (self basis collect: [:each| Q project: each])].
	^ QuotientModule base: self relations: anObject! !

!FreeModule methodsFor: 'operations' stamp: 'len 5/14/2019 19:35:08'!
/\ aModule
	"Answer the intersection of the receiver and the argument."
	| M N |
	self ambient = aModule ambient ifFalse: [^ DomainError signal].
	self isTrivial ifTrue: [^ self].
	aModule isTrivial ifTrue: [^ aModule].
	self ambient = aModule ifTrue: [^ self].
	self = aModule ambient ifTrue: [^ aModule].
	(self scalars isPID and: [self scalars = aModule scalars "and: [self ambient = aModule ambient]"]) ifFalse: [^ DomainError signal].
	M _ self matrix.
	N _ (M, aModule matrix) cokernelMatrix.
	N isEmpty ifTrue: [^ self ambient null].
	N _ N copyFrom: 1@1 to: N height @ M height.
	^ self ambient span: N * M over: self scalars! !

!FreeModule methodsFor: 'operations' stamp: 'len 7/14/2016 23:23'!
\/ aModule
	"Join."
	^ self + aModule! !

!FreeModule methodsFor: 'operations' stamp: 'len 12/30/2017 16:33:18'!
 aModule
	"Answer the categorical product, i.e. direct sum of the receiver and the argument."
	^ (aModule isFreeModule and: [aModule scalars = self scalars])
		ifTrue: [self  aModule]
		ifFalse: [super  aModule]! !

!FreeModule methodsFor: 'operations' stamp: 'len 4/28/2019 10:37:09'!
 aFreeModule
	"Answer the direct sum of the receiver and the argument."
	self scalars = aFreeModule scalars ifFalse: [DomainError signal: 'scalars don''t match'].
	^ DirectSumModule components: {self. aFreeModule}! !

!FreeModule methodsFor: 'operations' stamp: 'len 5/14/2019 20:49:06'!
 aFreeModule
	"Answer the tensor product of the receiver with the argument."
	self scalars = aFreeModule scalars ifFalse: [DomainError signal: 'scalars don''t match'].
	^ TensorProductModule components: {self. aFreeModule}! !

!FreeModule methodsFor: 'operations' stamp: 'len 5/28/2019 07:52:08'!
annihilatorSpace
	"Answer the space of all linear forms that are 0 at all vectors in the receiver."
	self isTrivial ifTrue: [^ self ambient dual].
	self isFullRank ifTrue: [^ self ambient dual null].
	^ self ambient dual span: (self matrix extended transposed inverse copyFromRow: self rank + 1 to: self degree)! !

!FreeModule methodsFor: 'operations' stamp: 'len 9/23/2018 00:54:07'!
dual
	^ super dual
"	| extendedMatrix |
	self isEmbedded ifFalse: [^ self hom: self scalars asSelfModule].
	extendedMatrix _ (self matrix, (self ambient scalars identityMatrix: self ambient rank)) transposed imageMatrix.
	^ self ambient dual span: (extendedMatrix transposed inverse copyFromRow: 1 to: self rank) over: self scalars"! !

!FreeModule methodsFor: 'operations' stamp: 'len 10/16/2016 09:43'!
grassmannian: r
	"Answer the set of r-dimensional subspaces of the receiver."
"	self isVectorSpace ifFalse: [DomainError signal: 'not a vector space']."
	self assert: (r <= self dimension and: [r >= 0]).
	^ Grassmannian new: r over: self! !

!FreeModule methodsFor: 'operations' stamp: 'len 4/28/2019 16:32:39'!
hull: aCollection
	"Answer the affine hull (flat) spanned by the vectors in aCollection."
	| vectors x0 |
	vectors _ aCollection asArray.
	x0 _ vectors at: 1.
	^ AffineSubspace
		representative: x0
		direction: (self span: ((2 to: vectors size) collect: [:i| x0 - (vectors at: i)]))! !

!FreeModule methodsFor: 'operations' stamp: 'len 4/2/2018 23:58:24'!
perp
	"Answer the orthogonal complement of the receiver. This is the subspace of all vectors in the ambient that have inner product zero (are orthogonal to) all vectors in the receiver."
	self isTrivial ifTrue: [^ self ambient].
	"if we're in a vector space over the reals or complex numbers, we can get an orthogonal basis"
	((self scalars isKindOf: RealField) or: [self scalars isKindOf: ComplexField])
		ifTrue: [^ self ambient span: (self matrix extended orthogonalized copyFromRow: self rank + 1 to: self degree)].
	"otherwise we use this, but it assumes the associated bilinear form is just the dot product:"
	^ self ambient span: self matrix kernelMatrix
"
alternative:
	| k n |
	k _ self dimension.
	n _ self ambient dimension.
	^ (self basis extended orthogonalized copyFrom: k + 1 to: n) span

alternative 2:
	^ self projection kernel

alternative 3:?
	^ basis dual asArray inject: self space into: [:answer :each| answer intersection: each kernel]	

alternative 4:
	^ self ambient span: (self annihilator basis collect: [:f| f asVector])
"! !

!FreeModule methodsFor: 'operations' stamp: 'len 5/10/2019 04:31:40'!
radical
	^ self /\ self perp! !

!FreeModule methodsFor: 'operations' stamp: 'len 5/14/2019 17:40:04'!
span: anObject
	^ self span: anObject over: self scalars! !

!FreeModule methodsFor: 'operations' stamp: 'len 5/16/2019 00:20:49'!
span: aCollection over: aRing
	"Answer the submodule spanned by the module elements in aCollection over aRing."
	| M |
	self isAmbient ifFalse: [^ self ambient span: (aCollection isMatrix ifTrue: [(aCollection over: self ambient scalars) * self matrix] ifFalse: [aCollection]) over: aRing].
"	self isVectorSpace ifFalse: [^ super span: aCollection over: aRing]."
	M _ aCollection isMatrix ifTrue: [aCollection] ifFalse: [Matrix rows: (aCollection collect: [:each| self coordinatesOf: each])].
	aRing = self scalars
		ifTrue:
			[M _ M echelon.
			M _ Matrix rows: (M rows select: [:each| each isZero not]).
			^ FreeModule new ambient: self; matrix: M].
	(aRing isPID and: [self scalars = aRing fractions])
		ifTrue:
			[(aRing isKindOf: RationalIntegerRing)
				ifTrue:
					[M _ M HNF.
					M _ Matrix rows: (M rows select: [:each| each isZero not]).
					^ Lattice new ambient: self; matrix: M].
			^ FreeModule new ambient: self; matrix: M; scalars: aRing].
	^ DomainError signal! !

!FreeModule methodsFor: 'random' stamp: 'len 4/5/2018 00:06:29'!
atRandom: aRandom
	^ self elementAt: (self coordinates atRandom: aRandom)! !

!FreeModule methodsFor: 'random' stamp: 'len 4/5/2018 00:06:36'!
atRandom: aRandom bits: bitSize
	self rank = 0 ifTrue: [^ self zero].
	^ self elementAt: (self coordinates atRandom: aRandom bits: bitSize)! !

!FreeModule methodsFor: 'testing' stamp: 'len 4/19/2019 07:15:31'!
contains: anElement
	self isTrivial ifTrue: [^ anElement isZero].
	self isAmbient ifTrue: [^ true].
	^ (self coordinatesOf: anElement) notNil! !

!FreeModule methodsFor: 'testing' stamp: 'len 12/12/2017 20:10:11'!
includes: anObject
	^ (self ambient includes: anObject) and: [self contains: anObject]! !

!FreeModule methodsFor: 'testing' stamp: 'len 4/21/2019 10:45:27'!
isCyclic
	^ self rank = 1! !

!FreeModule methodsFor: 'testing' stamp: 'len 4/25/2016 06:39'!
isFinite
	^ self generators isEmpty or: [self scalars isFinite]! !

!FreeModule methodsFor: 'testing' stamp: 'len 10/2/2018 00:45:22'!
isFree
	^ true! !

!FreeModule methodsFor: 'testing' stamp: 'len 12/18/2016 20:24:53'!
isFreeAbelianGroup
	"Answer true if the receiver is a Z-module."
	^ self scalars class = RationalIntegerRing! !

!FreeModule methodsFor: 'testing' stamp: 'len 2/28/2016 07:54'!
isFreeModule
	^ true! !

!FreeModule methodsFor: 'testing' stamp: 'len 1/24/2018 21:02:54'!
isFullRank
	^ self rank = self degree! !

!FreeModule methodsFor: 'testing' stamp: 'len 4/3/2018 19:18:48'!
isLattice
	^ self scalars isField not and: [self scalars isPID and: [self ambient scalars = self scalars fractions]]! !

!FreeModule methodsFor: 'testing' stamp: 'len 1/16/2017 08:12:25'!
isNonDegenerate
	^ self radical isTrivial! !

!FreeModule methodsFor: 'testing' stamp: 'len 7/14/2016 23:58'!
isTrivial
	^ self rank = 0! !

!FreeModule methodsFor: 'testing' stamp: 'len 5/19/2018 20:13:50'!
isVectorSpace
	^ self scalars isField or: [self isTrivial]! !

!FreeModule methodsFor: 'testing' stamp: 'len 12/18/2016 11:13:59'!
torsion
	^ self null! !

!FreeModule methodsFor: 'private' stamp: 'len 5/15/2019 00:19:21'!
matrix: aMatrix
	self propertyAt: #matrix put: aMatrix! !

!DirectSumModule methodsFor: 'accessing' stamp: 'len 10/2/2018 00:50:18'!
arity
	^ components size! !

!DirectSumModule methodsFor: 'accessing' stamp: 'len 10/2/2018 00:50:21'!
at: anInteger
	^ components at: anInteger! !

!DirectSumModule methodsFor: 'accessing' stamp: 'len 10/2/2018 00:50:27'!
scalars
	components do: [:any| ^ any scalars].
	^ nil! !

!DirectSumModule methodsFor: 'basis' stamp: 'len 4/28/2019 10:41:11'!
basis
	^ self propertyAt: #basis ifAbsentPut:
		[| answer |
		answer _ OrderedCollection new.
		components withIndexDo: [:each :i|
			each generators do: [:e| answer add: (self coproject: e at: i)]].
		answer]! !

!DirectSumModule methodsFor: 'basis' stamp: 'len 4/25/2019 16:22:40'!
coordinatesOf: anArray
	| answer |
	components with: anArray do: [:V :v|
		answer _ answer isNil ifTrue: [V coordinatesOf: v] ifFalse: [answer, (V coordinatesOf: v)]].
	^ answer! !

!DirectSumModule methodsFor: 'basis' stamp: 'len 10/3/2018 05:42:22'!
rank
	^ components sum: [:each| each rank]! !

!DirectSumModule methodsFor: 'converting' stamp: 'len 10/2/2018 00:51:38'!
asCartesianProduct
	^ CartesianProduct components: components! !

!DirectSumModule methodsFor: 'converting' stamp: 'len 10/2/2018 00:51:44'!
over: aRing
	"Answer the change of base ring of the receiver."
	^ self class components: (components collect: [:each| each over: aRing])! !

!DirectSumModule methodsFor: 'morphisms' stamp: 'len 4/24/2019 09:28:05'!
coproject: anElement at: i
	^ components withIndexCollect: [:each :k| k = i ifTrue: [anElement] ifFalse: [each zero]]! !

!DirectSumModule methodsFor: 'morphisms' stamp: 'len 4/24/2019 09:29:06'!
coprojection: i
	^ ((self at: i) to: self evaluating: [:x| self coproject: x at: i]) name: 'i', i printText sub! !

!DirectSumModule methodsFor: 'morphisms' stamp: 'len 10/2/2018 00:49:38'!
projection: i
	^ (self to: (self at: i) evaluating: [:x| x at: i]) name: Character pi asText, i printText sub! !

!DirectSumModule methodsFor: 'random' stamp: 'len 4/25/2019 19:04:15'!
atRandom: aRandom bits: bits
	^ self asCartesianProduct atRandom: aRandom bits: bits! !

!DirectSumModule methodsFor: 'testing' stamp: 'len 10/2/2018 00:52:20'!
includes: anObject
	anObject isSequenceable ifFalse: [^ false].
	anObject size = components size ifFalse: [^ false].
	components with: anObject do: [:V :x| (V includes: x) ifFalse: [^ false]].
	^ true! !

!DirectSumModule methodsFor: 'testing' stamp: 'len 10/2/2018 00:52:07'!
isCoproduct
	^ true! !

!DirectSumModule methodsFor: 'testing' stamp: 'len 4/28/2019 10:41:47'!
isProduct
	^ true! !

!DirectSumModule methodsFor: 'private' stamp: 'len 10/2/2018 00:50:56'!
components
	^ components! !

!DirectSumModule methodsFor: 'private' stamp: 'len 10/2/2018 00:50:59'!
components: anArray
	components _ anArray! !

!DirectSumModule class methodsFor: 'instance creation' stamp: 'len 10/2/2018 00:52:39'!
components: anArray
	^ self new components: anArray! !

!FreeHomModule methodsFor: 'accessing' stamp: 'len 11/7/2015 04:34'!
codomain
	^ codomain! !

!FreeHomModule methodsFor: 'accessing' stamp: 'len 11/7/2015 04:34'!
domain
	^ domain! !

!FreeHomModule methodsFor: 'accessing' stamp: 'len 9/16/2018 16:12:30'!
names
	"Answer a list of names for use instead of the elements of the basis when printing linear maps."
	self isDual ifTrue: [^ self domain coordinateNames ifNil: [(1 to: self domain rank) collect: [:i| 'x', i printString sub]]].
	^ super names! !

!FreeHomModule methodsFor: 'accessing' stamp: 'len 10/2/2018 01:15:42'!
scalars
	^ self domain scalars! !

!FreeHomModule methodsFor: 'accessing-private' stamp: 'len 11/7/2015 04:31'!
codomain: aVectorSpace
	codomain _ aVectorSpace! !

!FreeHomModule methodsFor: 'accessing-private' stamp: 'len 11/7/2015 04:31'!
domain: aVectorSpace
	domain _ aVectorSpace! !

!FreeHomModule methodsFor: 'basis' stamp: 'len 5/2/2019 03:22:21'!
basis
	^ self propertyAt: #basis ifAbsentPut:
		[| one zero n m |
		one _ self scalars one.
		zero _ self scalars zero.
		n _ self codomain rank.
		m _ self domain rank.
		(1 to: n * m) collect: [:index|
			self !! (self scalars matrix: n@m evaluating: [:i :j| (i-1)*m + j = index ifTrue: [one] ifFalse: [zero]])]]! !

!FreeHomModule methodsFor: 'basis' stamp: 'len 5/2/2019 03:23:25'!
coordinatesOf: aLinearMap
	"Answer the coordinates of aLinearMap with respect to the domain and codomain basis."

	^ (self matrixOf: aLinearMap) asTuple! !

!FreeHomModule methodsFor: 'converting' stamp: 'len 12/18/2016 12:44:37'!
over: aRing
	"Answer the change of base ring of the receiver."
	^ self class from: (self domain over: aRing) to: (self codomain over: aRing)! !

!FreeHomModule methodsFor: 'elements' stamp: 'len 5/13/2019 14:01:45'!
!! anObject
	anObject isMatrix ifTrue: [^ FreeModuleMap from: domain to: codomain matrix: anObject].
	anObject isEvaluable ifTrue: [^ self evaluating: anObject].
	(self scalars includes: anObject) ifTrue: [^ self scalar: anObject]."<- unneeded"
	anObject isInteger ifTrue: [^ self scalar: self scalars !! anObject]."<- unneeded too"
	^ super !! anObject! !

!FreeHomModule methodsFor: 'elements' stamp: 'len 3/5/2017 17:01:32'!
evaluating: aBlock
	^ domain to: codomain evaluating: aBlock! !

!FreeHomModule methodsFor: 'elements' stamp: 'len 3/5/2017 17:01:08'!
evaluatingWithArguments: aBlock
	^ self domain to: self codomain evaluatingWithArguments: aBlock! !

!FreeHomModule methodsFor: 'elements' stamp: 'len 5/2/2019 07:46:12'!
identity
	^ self propertyAt: #identity ifAbsentPut: [self scalar: self scalars one]! !

!FreeHomModule methodsFor: 'elements' stamp: 'len 5/2/2019 07:45:26'!
scalar: aNumber
	^ self !! (self scalars matrix: self codomain rank @ self domain rank scalar: aNumber)! !

!FreeHomModule methodsFor: 'elements' stamp: 'len 4/3/2018 19:31:28'!
x
	"As for polynomials."
	^ self x: 1! !

!FreeHomModule methodsFor: 'elements' stamp: 'len 4/3/2018 19:30:40'!
x: i
	"As for polynomials."
	self isDual ifFalse: [DomainError signal].
	^ self e: i! !

!FreeHomModule methodsFor: 'elements' stamp: 'len 4/3/2018 19:31:31'!
y
	"As for polynomials."
	^ self x: 2! !

!FreeHomModule methodsFor: 'elements' stamp: 'len 4/3/2018 19:31:36'!
z
	"As for polynomials."
	^ self x: 3! !

!FreeHomModule methodsFor: 'elements' stamp: 'len 5/2/2019 07:46:00'!
zero
	^ self propertyAt: #zero ifAbsentPut: [self scalar: self scalars zero]! !

!FreeHomModule methodsFor: 'morphisms' stamp: 'len 9/23/2018 07:10:08'!
pairing
	"Answer the natural pairing (a bilinear map)."
	^ self propertyAt: #pairing ifAbsentPut: [Function from: (self, self domain) to: self codomain evaluating: [:each| each first value: each second]]! !

!FreeHomModule methodsFor: 'operations' stamp: 'len 9/16/2018 16:12:20'!
opposite
	^ self class from: self codomain to: self domain! !

!FreeHomModule methodsFor: 'testing' stamp: 'len 5/13/2019 14:00:48'!
includes: aLinearMap
	^ (aLinearMap isKindOf: FreeModuleMap) and: [aLinearMap domain = self domain and: [aLinearMap codomain = self codomain]]! !

!FreeHomModule methodsFor: 'testing' stamp: 'len 4/26/2019 12:56:16'!
isDual
	"Answer true if the elements of the receiver are linear forms."
	^ codomain isKindOf: RingModule! !

!FreeHomModule methodsFor: 'testing' stamp: 'len 2/13/2016 00:19'!
isEndomorphisms
	^ domain = codomain! !

!FreeHomModule methodsFor: 'private' stamp: 'len 4/7/2018 06:22:32'!
matrices
	"Answer the vector space of the matrices associated to the transformations of the receiver."
	^ self scalars ^ (self codomain rank @ self domain rank)! !

!FreeHomModule methodsFor: 'private' stamp: 'len 3/18/2018 17:28:15'!
matrixOf: aLinearMap
	"Answer the matrix associated to aLinearMap with respect to the domain and codomain basis."
	(self domain matrix = aLinearMap domain matrix and: [aLinearMap codomain matrix = self codomain matrix])
		ifTrue: [^ aLinearMap matrix].
	^ Matrix columns: (self domain basis collect: [:each| (self codomain coordinatesOf: (aLinearMap value: each))])! !

!FreeHomModule class methodsFor: 'examples' stamp: 'len 5/11/2019 08:54:25'!
example1
	"The vector space of linear transformations
	from 3-tuples to 2-tuples, over the rational numbers."
	^ QQ^3 => (QQ^2)! !

!FreeHomModule class methodsFor: 'examples' stamp: 'len 4/3/2018 19:27:44'!
example2
	"The dual of a vector space. This is the space of linear forms."
	^ (QQ^3) dual! !

!FreeHomModule class methodsFor: 'examples' stamp: 'len 4/3/2018 19:28:07'!
example3
	"The basis of the dual vector space of 2x2 matrices with rational coefficients.
	The elements of the basis are the coordinate functions of the original vector space."
	^ (QQ^(2@2)) dual basis! !

!FreeHomModule class methodsFor: 'instance creation' stamp: 'len 1/13/2018 21:22:46'!
from: aModule to: anotherModule
	^ self new
		domain: aModule;
		codomain: anotherModule! !

!QuotientSpace methodsFor: 'accessing' stamp: 'len 2/27/2017 21:25:33'!
base
	^ self relations ambient! !

!QuotientSpace methodsFor: 'accessing' stamp: 'len 2/27/2017 21:28:31'!
relation
	^ EquivalenceRelation on: self base evaluating: [:x :y| self relations includes: x - y]! !

!QuotientSpace methodsFor: 'accessing' stamp: 'len 2/27/2017 21:29:48'!
relations
	^ self propertyAt: #relations! !

!QuotientSpace methodsFor: 'accessing' stamp: 'len 1/9/2018 21:58:12'!
relators
	^ self relations generators! !

!QuotientSpace methodsFor: 'accessing' stamp: 'len 2/27/2017 21:28:34'!
scalars
	^ self relations scalars! !

!QuotientSpace methodsFor: 'accessing-private' stamp: 'len 2/27/2017 21:29:38'!
relations: aSubspace
	self propertyAt: #relations put: aSubspace! !

!QuotientSpace methodsFor: 'basis' stamp: 'len 4/28/2019 16:32:57'!
basis
	^ self propertyAt: #basis ifAbsentPut: [self relations perp basis collect: [:each| AffineSubspace representative: each direction: self relations]]! !

!QuotientSpace methodsFor: 'basis' stamp: 'len 3/19/2018 16:55:28'!
coordinatesOf: anAffineSubspace
	| v |
	v _ anAffineSubspace representative.
	v _ v - (self relations orthogonalProjection value: v).
	^ self relations perp coordinatesOf: v! !

!QuotientSpace methodsFor: 'elements' stamp: 'len 1/16/2018 18:32:48'!
zero
	^ self project: self base zero! !

!QuotientSpace methodsFor: 'morphisms' stamp: 'len 5/13/2019 19:07:51'!
from: aDomain
	aDomain = self base ifTrue: [^ self projection].
	aDomain -> self base ifNotNil: [:aMorphism| ^ aMorphism -> self].
	^ super from: aDomain! !

!QuotientSpace methodsFor: 'morphisms' stamp: 'len 5/7/2018 22:52:48'!
lifting
	"Answer the map from the receiver to the base space lifting the canonical projection."
	^ self projection section! !

!QuotientSpace methodsFor: 'morphisms' stamp: 'len 4/28/2019 16:33:11'!
project: anElement
	^ AffineSubspace representative: anElement direction: self relations! !

!QuotientSpace methodsFor: 'morphisms' stamp: 'len 12/28/2016 12:08:21'!
projection
	"Answer the natural projection, or quotient map, or canonical homomorphism. This takes elements from the base module or vector space to the corresponding coset (an affine subspace) in the quotient."
	^ self propertyAt: #projection ifAbsentPut: [self buildProjection]! !

!QuotientSpace methodsFor: 'testing' stamp: 'len 2/27/2017 21:26:49'!
contains: anAffineSubspace
	^ anAffineSubspace direction = self relations! !

!QuotientSpace methodsFor: 'testing' stamp: 'len 4/28/2019 16:33:05'!
includes: anObject
	^ (anObject isKindOf: AffineSubspace) and: [self contains: anObject]! !

!QuotientSpace methodsFor: 'testing' stamp: 'len 8/10/2016 01:02'!
isQuotient
	^ true! !

!QuotientSpace methodsFor: 'private' stamp: 'len 5/16/2019 13:32:19'!
buildProjection
	"Answer the quotient map, the canonical projection from the base vector space to the quotient space, i.e. the mapping pi:V->V/S that assigns to every v in V the affine subspace v+S."
	| answer |
	answer _ self base onto: self evaluating: [:each| self project: each].
	answer name: Character pi asString.
	answer properties
		at: #kernel put: self relations;
		at: #image put: self;
		at: #section put: (self to: self base evaluating: [:each| each representative]).
	^ answer! !

!QuotientSpace class methodsFor: 'instance creation' stamp: 'len 2/27/2017 21:29:20'!
mod: aSubspace
	^ self new relations: aSubspace! !

!RingModule methodsFor: 'accessing' stamp: 'len 11/7/2015 02:57'!
scalars
	^ scalars! !

!RingModule methodsFor: 'basis' stamp: 'len 10/2/2018 17:03:09'!
basis
	^ {self scalars one}! !

!RingModule methodsFor: 'basis' stamp: 'len 4/28/2019 05:22:27'!
coordinatesOf: anElement
	"Answer the coordinates of the argument in the canonical basis."
	^ self scalars tuple: {anElement}! !

!RingModule methodsFor: 'converting' stamp: 'len 1/19/2018 23:30:17'!
asRing
	^ self scalars! !

!RingModule methodsFor: 'converting' stamp: 'len 12/18/2016 12:47:39'!
over: aRing
	"Answer the change of base ring of the receiver."
	^ self class over: aRing! !

!RingModule methodsFor: 'elements' stamp: 'len 12/12/2017 18:33:49'!
zero
	^ scalars zero! !

!RingModule methodsFor: 'morphisms' stamp: 'len 5/15/2019 00:51:45'!
from: aDomain
	aDomain = scalars ifTrue: [^ self addMap: (aDomain to: self evaluating: [:x| x])].
	^ super from: aDomain! !

!RingModule methodsFor: 'morphisms' stamp: 'len 5/15/2019 00:51:17'!
to: aCodomain
	aCodomain = scalars ifTrue: [^ self addMap: (self to: aCodomain evaluating: [:x| x])].
	^ super to: aCodomain! !

!RingModule methodsFor: 'operations' stamp: 'len 4/30/2019 08:24:17'!
 aFreeModule
	"Answer the direct sum of the receiver and the argument."
	self scalars = aFreeModule scalars ifFalse: [DomainError signal: 'scalars don''t match'].
	(aFreeModule isKindOf: RingModule) ifTrue: [^ self scalars ^ 2].
	(aFreeModule isKindOf: TupleModule) ifTrue: [^ self scalars ^ (aFreeModule rank + 1)].
	^ super  aFreeModule! !

!RingModule methodsFor: 'operations' stamp: 'len 5/14/2019 10:47:45'!
span: aCollection
	self isVectorSpace ifFalse: [^ self scalars idealClass in: self generators: aCollection].
	^ super span: aCollection! !

!RingModule methodsFor: 'testing' stamp: 'len 12/12/2017 20:13:06'!
includes: anObject
	^ scalars includes: anObject! !

!RingModule methodsFor: 'testing' stamp: 'len 5/1/2019 17:36:58'!
isCoherent
	"A coherent module is an R-module which is finitely generated and such that every finitely generated R-submodule is finitely presented (or equivalently such that the kernel of any (not neccessarily surjective) linear map R^n -> M is finitely generated)."
	"A ring is coherent iff it is a coherent module over itself."
	^ self scalars isCoherent! !

!RingModule methodsFor: 'private' stamp: 'len 1/14/2017 23:14:59'!
scalars: aRing
	scalars _ aRing! !

!RingModule class methodsFor: 'instance creation' stamp: 'len 11/7/2015 03:33'!
over: aField
	^ self new scalars: aField! !

!FreeSumsModule methodsFor: 'accessing' stamp: 'len 5/4/2019 03:09:01'!
coordinateNames
	^ self propertyAt: #coordinateNames ifAbsentPut: [self symbols collect: [:each| 'x', each asString sub]]! !

!FreeSumsModule methodsFor: 'accessing' stamp: 'len 2/27/2017 07:35:28'!
names
	"Answer a list of names for use instead of the elements of the basis when printing linear maps."
	^ self propertyAt: #names ifAbsentPut: [(1 to: self rank) collect: [:i| (self e: i) printText]]! !

!FreeSumsModule methodsFor: 'accessing' stamp: 'len 1/16/2017 08:00:12'!
symbols
	^ self propertyAt: #symbols! !

!FreeSumsModule methodsFor: 'accessing' stamp: 'len 1/16/2017 08:00:27'!
symbols: aCollection
	self propertyAt: #symbols put: aCollection asArray! !

!FreeSumsModule methodsFor: 'basis' stamp: 'len 10/2/2018 17:03:44'!
basis
	^ self symbols collect: [:each| self x: each]! !

!FreeSumsModule methodsFor: 'basis' stamp: 'len 2/25/2017 08:43:42'!
coordinatesOf: anElement
	^ self scalars tuple: self rank evaluating: [:i| anElement at: (self symbols at: i)]! !

!FreeSumsModule methodsFor: 'basis' stamp: 'len 10/2/2018 17:04:17'!
rank
	^ self symbols size! !

!FreeSumsModule methodsFor: 'basis' stamp: 'len 10/2/2018 01:48:50'!
x: anObject
	"Answer the embedding of anObject, assuming it is on the symbols of the receiver."
	^ (Sum coefficients: ((Dictionary new: 1) at: anObject put: self scalars one; yourself)) parent: self! !

!FreeSumsModule methodsFor: 'converting' stamp: 'len 4/3/2018 05:53:52'!
over: aRing
	^ self copy scalars: aRing! !

!FreeSumsModule methodsFor: 'elements' stamp: 'len 1/10/2018 20:41:07'!
!! anObject
	(self symbols includes: anObject) ifTrue: [^ self x: anObject].
	^ super !! anObject! !

!FreeSumsModule methodsFor: 'morphisms' stamp: 'len 5/4/2019 02:53:49'!
coprojection: i
	^ self scalars asSelfModule to: self evaluating: [:aNumber| (self x: i) * aNumber]! !

!FreeSumsModule methodsFor: 'morphisms' stamp: 'len 5/4/2019 02:51:40'!
projection: i
	^ self dual evaluating: [:x| x at: i]! !

!FreeSumsModule methodsFor: 'testing' stamp: 'len 10/2/2018 01:48:54'!
includes: anObject
	(anObject isKindOf: Sum) ifFalse: [^ false].
	anObject parent == self ifTrue: [^ true].
	anObject keysDo: [:each| (self symbols includes: each) ifFalse: [^ false]].
	^ true! !

!FreeSumsModule class methodsFor: 'examples' stamp: 'len 5/4/2019 03:49:08'!
example
	"The free Q-vector space over the set of symbols #a, #b, #c."
	^ QQ freeModuleIn: #(a b c)! !

!FreeSumsModule class methodsFor: 'instance creation' stamp: 'len 2/28/2017 08:37:57'!
new: anInteger over: aRing
	^ self on: (1 to: anInteger) over: aRing! !

!FreeSumsModule class methodsFor: 'instance creation' stamp: 'len 1/16/2017 08:05:50'!
on: aCollection over: aRing
	^ self new scalars: aRing; symbols: aCollection! !

!TupleModule methodsFor: 'accessing' stamp: 'len 11/2/2015 17:34'!
scalars
	^ scalars! !

!TupleModule methodsFor: 'accessing-private' stamp: 'len 10/16/2016 09:25'!
rank: n
	rank _ n! !

!TupleModule methodsFor: 'accessing-private' stamp: 'len 10/16/2016 09:25'!
scalars: aRing
	scalars _ aRing! !

!TupleModule methodsFor: 'basis' stamp: 'len 10/2/2018 17:07:17'!
basis
	^ self propertyAt: #basis ifAbsentPut: [(1 to: rank) collect: [:i| self scalars tuple: rank evaluating: [:k| k = i ifTrue: [scalars one] ifFalse: [scalars zero]]]]! !

!TupleModule methodsFor: 'basis' stamp: 'len 4/4/2018 16:22:45'!
coordinatesOf: aTuple
	^ aTuple scalars == scalars ifTrue: [aTuple] ifFalse: [scalars tuple: aTuple]! !

!TupleModule methodsFor: 'basis' stamp: 'len 4/3/2018 19:00:51'!
elementAt: aTuple
	"Answer the vector with coordinates aTuple in the canonical basis (i.e, the standard basis)."
	^ aTuple scalars == scalars ifTrue: [aTuple] ifFalse: [scalars tuple: aTuple]! !

!TupleModule methodsFor: 'basis' stamp: 'len 10/15/2016 17:08'!
rank
	^ rank! !

!TupleModule methodsFor: 'comparing' stamp: 'len 3/2/2017 10:18:30'!
= anObject
	self == anObject ifTrue: [^ true].
	(anObject isKindOf: TupleModule)
		ifTrue: [^ anObject scalars = self scalars and: [self rank = anObject rank]].
	^ super = anObject! !

!TupleModule methodsFor: 'converting' stamp: 'len 4/24/2016 06:36'!
over: aRing
	^ self copy scalars: aRing! !

!TupleModule methodsFor: 'elements' stamp: 'len 5/4/2019 04:01:08'!
!! anObject
	(anObject isSequenceable and: [anObject size = rank]) ifTrue: [^ scalars tuple: anObject].
	(rank = 1 and: [scalars includes: anObject]) ifTrue: [^ scalars tuple: {anObject}].
	^ super !! anObject! !

!TupleModule methodsFor: 'elements' stamp: 'len 10/15/2016 17:08'!
evaluating: aBlock
	^ scalars tuple: rank evaluating: aBlock! !

!TupleModule methodsFor: 'elements' stamp: 'len 1/20/2018 19:29:49'!
zero
	| contents |
	contents _ Array new: self rank.
	contents atAllPut: self scalars zero.
	^ scalars tuple: contents! !

!TupleModule methodsFor: 'enumerating' stamp: 'len 10/15/2016 17:08'!
do: aBlock
	self upTo: scalars size rank: rank do: aBlock! !

!TupleModule methodsFor: 'enumerating' stamp: 'len 5/2/2018 18:12:39'!
upTo: max rank: n do: aBlock
	| k |
	n = 0 ifTrue: [^ aBlock value: (scalars tuple: #())].
	k _ 1.
	scalars upTo: max do: [:s|
		self upTo: k rank: n-1 do: [:p|
			aBlock value: (p copyWith: s).
			(p includes: s) ifTrue: [scalars upTo: k-1 do: [:t| aBlock value: (p copyWith: t)]]].
		k _ k + 1]! !

!TupleModule methodsFor: 'morphisms' stamp: 'len 4/23/2019 02:17:12'!
coprojection: i
	^ (self scalars asSelfModule to: self evaluating: [:x|
			self scalars tuple: rank evaluating: [:k|
				k = i ifTrue: [x] ifFalse: [scalars zero]]]) name: 'i', i printText sub! !

!TupleModule methodsFor: 'morphisms' stamp: 'len 4/30/2019 08:28:56'!
projection: i
	^ self dual evaluating: [:x| x at: i]! !

!TupleModule methodsFor: 'operations' stamp: 'len 5/4/2019 15:54:47'!
^ anInteger
	^ self scalars ^ (self rank @ anInteger)! !

!TupleModule methodsFor: 'operations' stamp: 'len 4/30/2019 08:26:20'!
 aFreeModule
	"Answer the direct sum of the receiver and the argument."
	self scalars = aFreeModule scalars ifFalse: [DomainError signal: 'scalars don''t match'].
	(aFreeModule isKindOf: RingModule) ifTrue: [^ self scalars ^ (self rank + 1)].
	(aFreeModule isKindOf: TupleModule) ifTrue: [^ self scalars ^ (self rank + aFreeModule rank)].
	^ super  aFreeModule! !

!TupleModule methodsFor: 'random' stamp: 'len 1/20/2018 19:29:46'!
atRandom: aRandom
	^ scalars tuple: self rank evaluating: [:i| scalars atRandom: aRandom]! !

!TupleModule methodsFor: 'random' stamp: 'len 5/19/2018 17:02:01'!
atRandom: aRandom bits: bitSize
	| n |
	self isTrivial ifTrue: [^ self zero].
	n _ bitSize / self rank.
	^ scalars tuple: self rank evaluating: [:i| scalars atRandom: aRandom bits: n]! !

!TupleModule methodsFor: 'testing' stamp: 'len 9/23/2018 01:04:05'!
includes: anObject
	^ anObject isTuple and: [anObject size = self rank and: [anObject scalars = self scalars or: [anObject allSatisfy: [:each| self scalars includes: each]]]]! !

!TupleModule methodsFor: 'testing' stamp: 'len 11/7/2015 22:06'!
isFinite
	^ scalars isFinite! !

!TupleModule class methodsFor: 'instance creation' stamp: 'len 10/16/2016 09:25'!
new: anInteger over: aRing
	^ self new rank: anInteger; scalars: aRing! !

!MultivariateTupleModule methodsFor: 'accessing' stamp: 'len 1/6/2018 21:23:26'!
ordering
	^ ordering! !

!MultivariateTupleModule methodsFor: 'accessing-private' stamp: 'len 1/7/2018 17:07:13'!
ordering: aModuleMonomialOrdering
	ordering _ aModuleMonomialOrdering isSymbol
		ifTrue: [ModuleMonomialOrdering perform: aModuleMonomialOrdering]
		ifFalse: [aModuleMonomialOrdering]! !

!MultivariateTupleModule methodsFor: 'converting' stamp: 'len 1/7/2018 17:07:51'!
orderedBy: aModuleMonomialOrdering
	^ self class new: self rank over: self scalars ordering: aModuleMonomialOrdering! !

!MultivariateTupleModule methodsFor: 'operations' stamp: 'len 1/11/2018 18:03:47'!
localization
	"Answer the localization of the receiver at <x1,...,xn>. This is achieved by choosing a local ordering.
	Objects defined in this localization contain geometric information (usually only) about a Zariski neighbourhood of 0 in K^n, while objects in the global ring contain geometric information whish is valid in the whole affine space K^n."
	self scalars isLocal ifTrue: [^ self].
	^ self class new: self rank over: self scalars localization ordering: self ordering! !

!MultivariateTupleModule class methodsFor: 'instance creation' stamp: 'len 1/7/2018 17:06:19'!
new: anInteger over: aRing
	^ self new: anInteger over: aRing ordering: #top! !

!MultivariateTupleModule class methodsFor: 'instance creation' stamp: 'len 1/7/2018 17:06:03'!
new: anInteger over: aRing ordering: aModuleMonomialOrdering
	^ self new rank: anInteger; scalars: aRing; ordering: aModuleMonomialOrdering! !

!MatrixModule methodsFor: 'accessing' stamp: 'len 4/5/2018 15:34:26'!
coordinateNames
	^ self propertyAt: #coordinateNames ifAbsentPut:
		[(1 to: self height) inject: #() into: [:names :i| names, ((1 to: self width) collect: [:j| 'x', (i printString, ' ', j printString) sub])]]! !

!MatrixModule methodsFor: 'accessing' stamp: 'len 4/5/2018 15:25:13'!
height
	^ height! !

!MatrixModule methodsFor: 'accessing' stamp: 'len 4/5/2018 15:34:35'!
names
	"Answer a list of names for use instead of the elements of the basis when printing linear maps."
	^ self propertyAt: #names ifAbsentPut:
		[(1 to: self height) inject: #() into: [:names :i| names, ((1 to: self width) collect: [:j| 'e', (i printString, ' ', j printString) sub])]]! !

!MatrixModule methodsFor: 'accessing' stamp: 'len 11/3/2015 21:43'!
scalars
	^ scalars! !

!MatrixModule methodsFor: 'accessing' stamp: 'len 4/5/2018 15:25:33'!
width
	^ width! !

!MatrixModule methodsFor: 'basis' stamp: 'len 10/2/2018 16:56:05'!
basis
	^ self propertyAt: #basis ifAbsentPut:
		[| one zero |
		one _ scalars one.
		zero _ scalars zero.
		(1 to: width*height) collect: [:index|
			self evaluating: [:i :j| (i-1)*width + j = index ifTrue: [one] ifFalse: [zero]]]]! !

!MatrixModule methodsFor: 'basis' stamp: 'len 4/4/2018 16:26:22'!
coordinatesOf: aMatrix
	| answer |
	answer _ aMatrix asTuple.
	^ answer scalars == scalars ifTrue: [answer] ifFalse: [scalars tuple: answer]! !

!MatrixModule methodsFor: 'basis' stamp: 'len 4/5/2018 15:25:45'!
elementAt: aTuple
	^ self evaluating: [:i :j| aTuple at: (i-1)*width + j]

"	| answer |
	answer _ self zero.
	aTuple withIndexDo: [:each :i| answer _ (self e: i) * each + answer].
	^ answer"! !

!MatrixModule methodsFor: 'comparing' stamp: 'len 10/13/2018 17:39:22'!
= anObject
	self == anObject ifTrue: [^ true].
	(anObject isKindOf: MatrixModule)
		ifTrue: [^ self scalars = anObject scalars and: [self height = anObject height and: [self width = anObject width]]].
	^ super = anObject! !

!MatrixModule methodsFor: 'converting' stamp: 'len 4/5/2018 15:50:20'!
asRing
	self isSquare ifFalse: [DomainError signal: 'not a module of square matrices'].
	^ MatrixRing new: height over: scalars! !

!MatrixModule methodsFor: 'converting' stamp: 'len 4/23/2016 06:12'!
over: aRing
	^ self copy scalars: aRing! !

!MatrixModule methodsFor: 'elements' stamp: 'len 12/22/2016 22:40:57'!
!! anObject
	(self includes: anObject) ifTrue: [^ anObject copy].
	(self scalars includes: anObject) ifTrue: [^ self scalar: anObject].
	anObject isInteger ifTrue: [^ self scalar: self scalars !! anObject].
	^ super !! anObject! !

!MatrixModule methodsFor: 'elements' stamp: 'len 1/25/2018 19:39:22'!
columns: anArray
	^ Matrix columns: (anArray collect: [:each| self scalars tuple: each])! !

!MatrixModule methodsFor: 'elements' stamp: 'len 3/3/2016 18:57'!
diagonal: aTuple
	^ self evaluatingDiagonal: [:i| aTuple at: i]! !

!MatrixModule methodsFor: 'elements' stamp: 'len 4/5/2018 15:22:04'!
evaluating: aBlock
	^ self rows: ((1 to: height) collect: [:i| self scalars tuple: width evaluating: [:j| aBlock value: i value: j]])! !

!MatrixModule methodsFor: 'elements' stamp: 'len 1/7/2016 06:41'!
evaluatingDiagonal: aBlock
	| zero |
	zero _ self scalars zero.
	^ self evaluating: [:i :j| i == j ifTrue: [aBlock value: i] ifFalse: [zero]]! !

!MatrixModule methodsFor: 'elements' stamp: 'len 11/26/2015 03:42'!
identity
	^ self scalar: scalars one! !

!MatrixModule methodsFor: 'elements' stamp: 'len 11/26/2015 04:36'!
one
	^ self scalar: scalars one! !

!MatrixModule methodsFor: 'elements' stamp: 'len 11/5/2016 06:28'!
rows: anArray
	^ RowMatrix rows: (anArray collect: [:each| self scalars tuple: each])! !

!MatrixModule methodsFor: 'elements' stamp: 'len 2/6/2016 19:57'!
scalar: aNumber
	| zero |
	zero _ scalars zero.
	^ self evaluating: [:i :j| i=j ifTrue: [aNumber] ifFalse: [zero]]! !

!MatrixModule methodsFor: 'elements' stamp: 'len 11/26/2015 04:36'!
zero
	^ self scalar: scalars zero! !

!MatrixModule methodsFor: 'initialization' stamp: 'len 4/5/2018 15:23:32'!
height: n
	height _ n! !

!MatrixModule methodsFor: 'initialization' stamp: 'len 4/23/2016 06:15'!
scalars: aDomain
	scalars _ aDomain! !

!MatrixModule methodsFor: 'initialization' stamp: 'len 4/5/2018 15:23:44'!
width: m
	width _ m! !

!MatrixModule methodsFor: 'operations' stamp: 'len 4/5/2018 15:35:38'!
transposed
	^ self isSquare
		ifTrue: [self]
		ifFalse: [self class new: width @ height over: scalars]! !

!MatrixModule methodsFor: 'testing' stamp: 'len 5/18/2018 20:17:56'!
includes: anObject
	^ anObject isMatrix and: [anObject height = height and: [anObject width = width and: [anObject scalars = scalars]]]! !

!MatrixModule methodsFor: 'testing' stamp: 'len 11/7/2015 22:05'!
isFinite
	^ scalars isFinite! !

!MatrixModule methodsFor: 'testing' stamp: 'len 4/5/2018 15:22:26'!
isSquare
	^ height = width! !

!MatrixModule class methodsFor: 'instance creation' stamp: 'len 4/5/2018 15:23:11'!
new: dimension over: aDomain
	^ self new height: dimension x; width: dimension y; scalars: aDomain! !

!Lattice methodsFor: 'accessing' stamp: 'len 6/3/2018 18:31:34'!
associatedQuadraticForm
	"Answer the quadratic form associated to this lattice."
	^ QuadraticForm from: self ambient matrix: self gramian! !

!Lattice methodsFor: 'accessing' stamp: 'len 12/8/2017 18:29:59'!
innerProduct
	^ self ambient innerProduct! !

!Lattice methodsFor: 'accessing' stamp: 'len 12/8/2017 18:26:50'!
scalars
	^ ZZ! !

!Lattice methodsFor: 'accessing' stamp: 'len 3/28/2018 05:05:34'!
shortVector
	^ self reducedBasis first! !

!Lattice methodsFor: 'basis' stamp: 'len 12/8/2017 18:33:16'!
reducedBasis
	^ self propertyAt: #reducedBasis ifAbsentPut: [(LLL basis: self basis) reducedBasis]! !

!Lattice methodsFor: 'invariants' stamp: 'len 12/8/2017 18:41:52'!
coveringNormalizedThinkness
	"Answer the normalized thickness (or central density) of the covering."
	^ self coveringRadius ^ self rank / self fundamentalVolume! !

!Lattice methodsFor: 'invariants' stamp: 'len 12/28/2016 11:30:25'!
coveringRadius
	^ self propertyAt: #coveringRadius! !

!Lattice methodsFor: 'invariants' stamp: 'len 12/8/2017 18:42:18'!
coveringSphereVolume
	| n Vn pi p |
	pi _ Float pi.
	n _ self rank.
	Vn _ n even
		ifTrue: [pi ^ (n/2) / (n/2) factorial]
		ifFalse: [2^n * pi ^ ((n-1)/2) * ((n-1)/2) factorial / n factorial].
	p _ self coveringRadius.
	^ p ^ n * Vn! !

!Lattice methodsFor: 'invariants' stamp: 'len 12/8/2017 18:42:49'!
coveringThickness
	"Answer the thickness of the covering, i.e. the average number of spheres that contain a point of space. The thickness is also called the density or the sparsity of the covering."
	^ self coveringSphereVolume / self fundamentalVolume! !

!Lattice methodsFor: 'invariants' stamp: 'len 6/2/2018 17:45:04'!
determinant
	"The determinant det(L) of a lattice L is defined as the volume of its fundamental paralleleliped."
	self matrix isSquare ifTrue: [^ self matrix determinant abs].
	^ self gramian determinant squareRoot! !

!Lattice methodsFor: 'invariants' stamp: 'len 3/19/2018 15:28:38'!
determinant2
	"The determinant det(L) of a lattice L is defined as the volume of its fundamental paralleleliped."
	| B |
	B _ self matrix.
	"B square means the lattice is full-rank:"
	^ B isSquare ifTrue: [B determinant abs] ifFalse: [(B transposed * B) determinant squareRoot]! !

!Lattice methodsFor: 'invariants' stamp: 'len 12/10/2015 01:00'!
fundamentalParallelepiped
	^ self notYetImplemented! !

!Lattice methodsFor: 'invariants' stamp: 'len 3/19/2018 15:29:23'!
fundamentalVolume
	"Answer the volume of the fundamental region."
	^ self determinant sqrt! !

!Lattice methodsFor: 'invariants' stamp: 'len 12/8/2017 18:44:28'!
packingCenterDensity
	^ self packingRadius ^ self rank / self fundamentalVolume! !

!Lattice methodsFor: 'invariants' stamp: 'len 12/8/2017 18:44:07'!
packingDensity
	"Answer the density of the lattice packing, i.e. the volume of a sphere / the volume of the fundamental region."
	^ self packingSphereVolume / self fundamentalVolume! !

!Lattice methodsFor: 'invariants' stamp: 'len 12/28/2016 11:30:14'!
packingRadius
	^ self propertyAt: #packingRadius! !

!Lattice methodsFor: 'invariants' stamp: 'len 12/8/2017 18:43:48'!
packingSphereVolume
	| n Vn pi p |
	pi _ Float pi.
	n _ self rank.
	Vn _ n even
		ifTrue: [pi ^ (n/2) / (n/2) factorial]
		ifFalse: [2^n * pi ^ ((n-1)/2) * ((n-1)/2) factorial / n factorial].
	p _ self packingRadius.
	^ p ^ n * Vn! !

!Lattice methodsFor: 'invariants' stamp: 'len 12/28/2016 11:30:19'!
thetaSeries
	"Answer the theta series of the lattice."
	^ self propertyAt: #thetaSeries! !

!Lattice methodsFor: 'operations' stamp: 'len 5/16/2019 12:26:52'!
reciprocal
	"Answer the dual lattice of the receiver (or reciprocal lattice, or polar lattice)."
	| B D |
	B _ self matrix.
	D _ B * (B transposed * B) retraction.
	^ self class basis: D rows! !

!Lattice methodsFor: 'testing' stamp: 'len 6/2/2018 18:01:20'!
isEven
	^ self isIntegral and: [self gramian diagonal allSatisfy: [:each| each even]]! !

!Lattice methodsFor: 'testing' stamp: 'len 4/4/2018 16:01:31'!
isIntegral
	"Answer true if the receiver is integral, i.e. if the inner product of any two lattice vectors is an integer. This is true iff the Gram matrix contains only integer entries. Equivalently, a lattice L is integral if and only if it is contained in its dual L*: L <= L*. Also, an integral lattice L has the property: L <= L* <= L / det(L)."
	self gramian do: [:each| each isInteger ifFalse: [^ false]].
	^ true! !

!Lattice methodsFor: 'testing' stamp: 'len 12/8/2017 18:29:34'!
isRootLattice
	self isIntegral ifFalse: [^ false].
	self basis do: [:v| (self innerProduct value: v value: v) = 2 ifFalse: [^ false]].
	^ true! !

!Lattice methodsFor: 'testing' stamp: 'len 4/7/2018 18:18:44'!
isSelfDual
	"A self-dual lattice is a lattice L that equals it's dual L*, L = L*.
	A (integral) lattice is self-dual iff it is unimodular."
	^ self = self reciprocal
	
"alternative:
	^ self isUnimodular
"! !

!Lattice methodsFor: 'testing' stamp: 'len 12/30/2015 21:51'!
isUnimodular
	^ self isIntegral and: [self determinant abs = 1]! !

!Lattice methodsFor: 'private' stamp: 'len 4/10/2018 16:55:26'!
matrix: aMatrix
	| M |
	M _ aMatrix HNF.
	M _ Matrix rows: (M rows select: [:each| each isZero not]).	
	super matrix: M! !

!Lattice class methodsFor: 'examples' stamp: 'len 12/13/2017 21:33:29'!
A: n
	"Answer the lattice A_n = {(x0,...,xn) in Z^{n+1} : x0 + ... + xn = 0}."
	| t B |
	t _ (-1,1), (QQ ^ (n-1)) zero.
	B _ OrderedCollection new.
	n timesRepeat: [B add: t. t _ t >> 1].
	^ self basis: B! !

!Lattice class methodsFor: 'examples' stamp: 'len 4/5/2018 18:09:29'!
Adual: n
	"Answer the dual of A_n."
	| V B |
	V _ QQ ^ n.
	B _ OrderedCollection new.
	1 to: n do: [:i| B add: (1, (V e: i) negated)].
	B add: (QQ tuple: n+1 evaluating: [:i| i=1 ifTrue: [n negated / (n+1)] ifFalse: [1 / (n+1)]]).
	^ self basis: B! !

!Lattice class methodsFor: 'examples' stamp: 'len 3/19/2018 15:37:24'!
D4
	"Answer the D4 lattice, which is self-dual."
	^ self basis: {(1,0,0,0). (0,1,0,0). (0,0,1,0). (1,1,1,1)/2}! !

!Lattice class methodsFor: 'examples' stamp: 'len 12/13/2017 21:35:13'!
D: n
	"Answer the checkboard lattice D_n = {(x1,...,xn) in Z^n : x0 + ... + xn is even}."
	| t0 t B |
	B _ OrderedCollection new.
	t0 _ (-1,-1), (QQ ^ (n-2)) zero.
	B add: t0.
	t _ (1,-1), (QQ ^ (n-2)) zero.
	n-1 timesRepeat: [B add: t. t _ t >> 1].
	^ self basis: B! !

!Lattice class methodsFor: 'examples' stamp: 'len 12/13/2017 21:35:31'!
Ddual: n
	"Answer the dual of D_n."
	| V B |
	V _ QQ ^ n.
	B _ OrderedCollection new.
	1 to: n-1 do: [:i| B add: (V e: i)].
	B add: (QQ tuple: n evaluating: [:i| 1/2]).
	^ self basis: B! !

!Lattice class methodsFor: 'examples' stamp: 'len 12/13/2017 21:32:24'!
E8
	| t0 t B answer |
	B _ OrderedCollection new.
	t0 _ (2,0,0,0,0,0,0,0).
	B add: t0.
	t _ (-1,1,0,0,0,0,0,0).
	6 timesRepeat: [B add: t. t _ t >> 1].
	B add: (1,1,1,1,1,1,1,1)/2.
	answer _ self basis: B.
	answer properties
		at: #minimalNorm put: 2;
		at: #kissingNumber put: 240;
		at: #CoxeterNumber put: 30;
		at: #packingRadius put: 1/2 sqrt;
		at: #density put: Float pi ^ 4 / 384;
		at: #thickness put: Float pi ^ 4 / 24.
	^ answer! !

!Lattice class methodsFor: 'examples' stamp: 'len 7/15/2016 18:34'!
Z: n
	"Answer the n-dimensional cubic or integer lattice Z^n."
	^ self basis: (QQ ^ n) basis! !

!Lattice class methodsFor: 'examples' stamp: 'len 3/19/2018 15:39:36'!
bcc
	"Answer the body-centered cubic lattice (bcc).
	D*_3 is equivalent to bcc."
	^ self basis: {(2,0,0). (0,2,0). (1,1,1)}! !

!Lattice class methodsFor: 'examples' stamp: 'len 3/19/2018 15:39:50'!
fcc
	"Answer the face-centered cubic lattice (fcc).
	Both A_3 and D_3 are equivalent to the fcc."
	^ self basis: {(-1,-1,0). (1,-1,0). (0,1,-1)}! !

!Lattice class methodsFor: 'examples' stamp: 'len 6/2/2018 18:35:50'!
leech
	"The Leech lattice is the unique even unimodular lattice in R^24 with with no norm 2 vectors."
	| G answer |
	G _ QQ matrix: 24 coefficients:
#(8 4 4 4 4 4 4 2 4 4 4 2 4 2 2 2 4 2 2 2 0 0 0 -3
 4 4 2 2 2 2 2 2 2 2 2 2 2 2 1 1 2 1 1 2 1 0 0 -1
 4 2 4 2 2 2 2 2 2 2 2 2 2 1 2 1 2 2 1 1 1 0 0 -1
 4 2 2 4 2 2 2 2 2 2 2 2 2 1 1 2 2 1 2 1 1 0 0 -1
 4 2 2 2 4 2 2 2 2 2 2 1 2 2 2 2 2 2 2 2 1 0 0 -1
 4 2 2 2 2 4 2 2 2 2 2 1 2 2 1 1 2 1 2 1 0 0 0 -1
 4 2 2 2 2 2 4 2 2 2 2 1 2 1 2 1 2 1 1 2 0 0 0 -1
 2 2 2 2 2 2 2 4 1 1 1 2 1 2 2 2 1 2 2 2 2 0 0 1
 4 2 2 2 2 2 2 1 4 2 2 2 2 2 2 2 2 2 2 2 1 1 1 -1
 4 2 2 2 2 2 2 1 2 4 2 2 2 2 1 1 2 2 1 1 0 1 0 -1
 4 2 2 2 2 2 2 1 2 2 4 2 2 1 2 1 2 1 2 1 0 0 1 -1
 2 2 2 2 1 1 1 2 2 2 2 4 1 2 2 2 1 2 2 2 2 1 1 1
 4 2 2 2 2 2 2 1 2 2 2 1 4 2 2 2 2 1 1 1 1 1 1 -1
 2 2 1 1 2 2 1 2 2 2 1 2 2 4 2 2 1 2 2 2 2 2 1 1
 2 1 2 1 2 1 2 2 2 1 2 2 2 2 4 2 1 2 2 2 2 1 2 1
 2 1 1 2 2 1 1 2 2 1 1 2 2 2 2 4 1 2 2 2 2 1 1 1
 4 2 2 2 2 2 2 1 2 2 2 1 2 1 1 1 4 2 2 2 1 1 1 -1
 2 1 2 1 2 1 1 2 2 2 1 2 1 2 2 2 2 4 2 2 2 2 1 1
 2 1 1 2 2 2 1 2 2 1 2 2 1 2 2 2 2 2 4 2 2 1 2 1
 2 2 1 1 2 1 2 2 2 1 1 2 1 2 2 2 2 2 2 4 2 1 1 1
 0 1 1 1 1 0 0 2 1 0 0 2 1 2 2 2 1 2 2 2 4 2 2 2
 0 0 0 0 0 0 0 0 1 1 0 1 1 2 1 1 1 2 1 1 2 4 2 2
 0 0 0 0 0 0 0 0 1 0 1 1 1 1 2 1 1 1 2 1 2 2 4 2
 -3 -1 -1 -1 -1 -1 -1 1 -1 -1 -1 1 -1 1 1 1 -1 1 1 1 2 2 2 4).
	answer _ self basis: G rows.
	answer properties
		at: #minimalNorm put: 4;
		at: #kissingNumber put: 196560;
		at: #coveringRadius put: 2 sqrt.
	^ answer! !

!Lattice class methodsFor: 'examples' stamp: 'len 6/2/2018 18:34:56'!
leech2
	"Another version of the Leech lattice."
	| G answer |
	G _ QQ matrix: 24 coefficients:
#(4 -2 -2 2 2 2 -1 -1 2 2 -2 2 -2 1 -1 1 1 2 0 -1 0 -2 -2 2
-2 4 0 0 -2 0 -1 2 0 0 2 -1 1 1 -1 1 -2 -2 -1 1 1 2 1 -2
-2 0 4 0 0 -2 0 0 0 0 2 0 0 -2 1 -1 -1 -1 1 -1 -1 1 0 -1
2 0 0 4 0 0 -2 -1 2 2 0 2 -2 1 0 2 -1 0 -1 0 1 -1 -1 0
2 -2 0 0 4 0 -1 -1 1 1 -1 1 -1 0 0 -1 0 2 0 -2 -2 -1 -2 2
2 0 -2 0 0 4 0 0 1 1 -1 1 -1 1 -1 1 1 0 1 0 1 0 -1 1
-1 -1 0 -2 -1 0 4 1 -1 -1 0 -2 2 0 0 0 2 -1 0 0 -1 1 2 -1
-1 2 0 -1 -1 0 1 4 1 1 2 -1 1 0 -1 1 -1 -1 -1 -1 -1 1 1 -1
2 0 0 2 1 1 -1 1 4 2 0 2 -2 1 0 1 -1 0 -1 -2 0 -1 -1 0
2 0 0 2 1 1 -1 1 2 4 0 1 -2 0 -1 1 -1 1 0 -1 -1 -1 -1 1
-2 2 2 0 -1 -1 0 2 0 0 4 0 1 -1 0 1 -1 -2 0 0 0 2 1 -2
2 -1 0 2 1 1 -2 -1 2 1 0 4 -2 0 1 0 0 1 0 -1 1 -2 -2 1
-2 1 0 -2 -1 -1 2 1 -2 -2 1 -2 4 0 -1 0 1 -1 -1 1 0 2 2 -2
1 1 -2 1 0 1 0 0 1 0 -1 0 0 4 -1 1 0 -1 -2 0 0 0 0 0
-1 -1 1 0 0 -1 0 -1 0 -1 0 1 -1 -1 4 -1 -1 0 0 0 0 -1 0 0
1 1 -1 2 -1 1 0 1 1 1 1 0 0 1 -1 4 0 -1 -1 0 1 1 0 -1
1 -2 -1 -1 0 1 2 -1 -1 -1 -1 0 1 0 -1 0 4 1 1 0 0 0 0 0
2 -2 -1 0 2 0 -1 -1 0 1 -2 1 -1 -1 0 -1 1 4 1 -1 -1 -2 -2 2
0 -1 1 -1 0 1 0 -1 -1 0 0 0 -1 -2 0 -1 1 1 4 0 0 0 -1 1
-1 1 -1 0 -2 0 0 -1 -2 -1 0 -1 1 0 0 0 0 -1 0 4 2 0 2 -1
0 1 -1 1 -2 1 -1 -1 0 -1 0 1 0 0 0 1 0 -1 0 2 4 0 1 -1
-2 2 1 -1 -1 0 1 1 -1 -1 2 -2 2 0 -1 1 0 -2 0 0 0 4 1 -2
-2 1 0 -1 -2 -1 2 1 -1 -1 1 -2 2 0 0 0 0 -2 -1 2 1 1 4 -2
2 -2 -1 0 2 1 -1 -1 0 1 -2 1 -2 0 0 -1 0 2 1 -1 -1 -2 -2 4).
	answer _ self basis: G rows.
	answer properties
		at: #minimalNorm put: 4;
		at: #kissingNumber put: 196560;
		at: #coveringRadius put: 2 sqrt.
	^ answer! !

!Lattice class methodsFor: 'instance creation' stamp: 'len 4/5/2018 15:36:39'!
basis: aCollection
	| V M |
	M _ Matrix rows: aCollection asArray.
	V _ M scalars ^ M width.
	^ self new ambient: V; matrix: M! !

!BilinearForms methodsFor: 'accessing' stamp: 'len 11/27/2015 06:32'!
codomain
	^ self scalars! !

!BilinearForms methodsFor: 'accessing' stamp: 'len 4/19/2016 03:39'!
domain
	^ (vectorSpace, vectorSpace)! !

!BilinearForms methodsFor: 'accessing' stamp: 'len 1/8/2016 06:53'!
scalars
	^ vectorSpace scalars! !

!BilinearForms methodsFor: 'accessing-private' stamp: 'len 1/8/2016 06:53'!
vectorSpace: aVectorSpace
	vectorSpace _ aVectorSpace! !

!BilinearForms methodsFor: 'basis' stamp: 'len 10/2/2018 16:49:32'!
basis
	^ self matrices basis collect: [:each|
		BilinearForm
			fromHalf: vectorSpace
			matrix: each]! !

!BilinearForms methodsFor: 'basis' stamp: 'len 1/8/2016 06:43'!
coordinatesOf: aBilinearForm
	"Answer the coordinates of aBilinearForm with respect to the domain canonical basis."
	^ self matrices coordinatesOf: (self matrixOf: aBilinearForm)! !

!BilinearForms methodsFor: 'elements' stamp: 'len 1/8/2016 06:51'!
evaluating: aBlock
	^ BilinearForm from: self domain evaluating: aBlock! !

!BilinearForms methodsFor: 'elements' stamp: 'len 4/23/2016 03:53'!
newFrom: anObject
	^ self evaluating: anObject! !

!BilinearForms methodsFor: 'operations' stamp: 'len 1/8/2016 06:55'!
alternate
	"Answer the subspace of alternating bilinear forms."
	^ self notYetImplemented! !

!BilinearForms methodsFor: 'operations' stamp: 'len 1/8/2016 06:56'!
symmetric
	"Answer the subspace of symmetric bilinear forms."
	^ self notYetImplemented! !

!BilinearForms methodsFor: 'private' stamp: 'len 1/8/2016 06:52'!
matrices
	"Answer the vector space of the matrices associated to the bilinear forms of the receiver."
	^ self scalars ^ (vectorSpace dimension @ vectorSpace dimension)! !

!BilinearForms methodsFor: 'private' stamp: 'len 1/8/2016 06:52'!
matrixOf: aBilinearForm
	"Answer the matrix associated to aBilinearForm with respect to the canonical basis."
	^ self matrices
		evaluating: [:i :j|
			aBilinearForm value: (vectorSpace e: i) value: (vectorSpace e: j)]! !

!BilinearForms class methodsFor: 'instance creation' stamp: 'len 1/8/2016 06:50'!
on: aVectorSpace
	^ self new vectorSpace: aVectorSpace! !

!TensorProductModule methodsFor: 'accessing' stamp: 'len 6/3/2018 20:15:35'!
arity
	^ components size! !

!TensorProductModule methodsFor: 'accessing' stamp: 'len 6/3/2018 20:15:48'!
at: anInteger
	^ components at: anInteger! !

!TensorProductModule methodsFor: 'accessing' stamp: 'len 9/16/2018 16:18:35'!
indices
	^ self propertyAt: #indices ifAbsentPut: [self computeIndices]! !

!TensorProductModule methodsFor: 'accessing' stamp: 'len 9/16/2018 16:18:48'!
scalars
	components do: [:any| ^ any scalars].
	^ nil! !

!TensorProductModule methodsFor: 'accessing' stamp: 'len 9/16/2018 16:18:53'!
type
	"Tensor products of n copies of a vector space and m copies of its dual are of type (n,m)."
	self propertyAt: #type ifAbsentPut: [self computeType]! !

!TensorProductModule methodsFor: 'basis' stamp: 'len 10/2/2018 17:06:27'!
basis
	^ self propertyAt: #basis ifAbsentPut: [self indices collect: [:each| Tensor new parent: self; at: each put: self scalars one; yourself]]! !

!TensorProductModule methodsFor: 'basis' stamp: 'len 9/16/2018 16:18:20'!
coordinatesOf: anElement
	^ self scalars tuple: (self indices collect: [:each| anElement at: each])! !

!TensorProductModule methodsFor: 'basis' stamp: 'len 6/3/2018 20:18:15'!
rank
	^ components product: [:each| each rank]! !

!TensorProductModule methodsFor: 'converting' stamp: 'len 9/15/2018 17:06:12'!
over: aRing
	"Answer the change of base ring of the receiver."
	^ self class components: (components collect: [:each| each over: aRing])! !

!TensorProductModule methodsFor: 'elements' stamp: 'len 9/16/2018 16:17:45'!
!! anObject
	(anObject isSequenceable and: [anObject size = self arity and: [(1 to: self arity) allSatisfy: [:i| (self at: i) includes: (anObject at: i)]]])
		ifTrue: [^ self compose: anObject].
	^ super !! anObject! !

!TensorProductModule methodsFor: 'elements' stamp: 'len 9/16/2018 16:18:26'!
evaluating: aBlock
	| answer |
	answer _ Tensor new parent: self.
	self indices do: [:each| answer at: each put: (aBlock value: each)].
	^ answer! !

!TensorProductModule methodsFor: 'morphisms' stamp: 'len 9/16/2018 16:17:59'!
compose: anArray
	| coordinates answer |
	anArray size = self arity ifFalse: [DomainError signal].
	coordinates _ anArray withIndexCollect: [:each :i| (self at: i) coordinatesOf: each].
	answer _ Tensor new parent: self.
	self indices do: [:each|
		answer at: each put: ((1 to: coordinates size) inject: self scalars one into: [:product :i| product * ((coordinates at: i) at: (each at: i))])].
	^ answer! !

!TensorProductModule methodsFor: 'morphisms' stamp: 'len 9/16/2018 16:18:03'!
composition
	"This is the product of tensors. This is a multilinear map."
	^ (Function from: self asCartesianProduct to: self evaluating: [:each| self compose: each]) name: Character otimes asString! !

!TensorProductModule methodsFor: 'testing' stamp: 'len 9/16/2018 16:18:31'!
includes: anObject
	^ (anObject isKindOf: Tensor) and: [anObject parent = self]! !

!TensorProductModule methodsFor: 'private' stamp: 'len 6/3/2018 20:15:26'!
components
	^ components! !

!TensorProductModule methodsFor: 'private' stamp: 'len 9/16/2018 16:17:53'!
components: anArray
	components _ anArray

"	| algebra indeterminates |
	components _ anArray.
	indeterminates _ OrderedCollection new.
	anArray withIndexDo: [:each :i| 1 to: each rank do: [:j| indeterminates add: 'x', (i printString, ',' j printString) sub]].
	algebra _ components anyOne scalars freeAlgebraIn: indeterminates.
	self propertyAt: #ambientAlgebra put: algebra"! !

!TensorProductModule methodsFor: 'private' stamp: 'len 9/16/2018 16:18:10'!
computeIndices
	| indices |
	indices _ OrderedCollection with: {}.
	components do: [:X| | newIndices |
		newIndices _ OrderedCollection new.
		indices do: [:each| 1 to: X rank do: [:i| newIndices add: each, {i}]].
		indices _ newIndices].
	^ indices! !

!TensorProductModule methodsFor: 'private' stamp: 'len 9/16/2018 16:18:14'!
computeType
	| V W i n |
	V _ components first.
	i _ components findFirst: [:each| each ~= V].
	i = 0 ifTrue: [^ {self arity. 0}].
	W _ components at: i.
	W = V dual ifFalse: [^ nil].
	n _ components findLast: [:each| each ~= W].
	i-1 = n ifFalse: [^ nil].
	^ {n. self arity - n}! !

!TensorProductModule class methodsFor: 'instance creation' stamp: 'len 6/3/2018 20:18:41'!
components: anArray
	^ self new components: anArray! !

!PolynomialFiltrationModule methodsFor: 'accessing' stamp: 'len 7/10/2016 07:39'!
degree
	^ degree! !

!PolynomialFiltrationModule methodsFor: 'accessing' stamp: 'len 4/6/2016 07:04'!
scalars
	^ polynomials scalars! !

!PolynomialFiltrationModule methodsFor: 'accessing-private' stamp: 'len 4/6/2016 07:07'!
degree: anInteger
	degree _ anInteger! !

!PolynomialFiltrationModule methodsFor: 'accessing-private' stamp: 'len 4/6/2016 07:07'!
polynomials: aPolynomials
	polynomials _ aPolynomials! !

!PolynomialFiltrationModule methodsFor: 'basis' stamp: 'len 10/2/2018 16:59:06'!
basis
	^ self propertyAt: #basis ifAbsentPut: [(1 to: degree + 1) collect: [:i| polynomials xTo: i-1]]! !

!PolynomialFiltrationModule methodsFor: 'basis' stamp: 'len 4/12/2016 08:08'!
coordinatesOf: aPolynomial
	| coefficients |
	coefficients _ aPolynomial coefficients.
	^ coefficients, ((1 to: self dimension - coefficients size) collect: [:each| self scalars zero])! !

!PolynomialFiltrationModule methodsFor: 'basis' stamp: 'len 7/10/2016 07:39'!
elementAt: aTuple
	^ polynomials coefficients: aTuple! !

!PolynomialFiltrationModule methodsFor: 'morphisms' stamp: 'len 10/4/2016 12:14'!
differential
	^ self to: self evaluating: [:f| f derivative]! !

!PolynomialFiltrationModule methodsFor: 'morphisms' stamp: 'len 6/19/2016 04:18'!
integral: a to: b
	^ self dual evaluating: [:f| f integral: a to: b]! !

!PolynomialFiltrationModule methodsFor: 'testing' stamp: 'len 12/13/2017 21:50:16'!
includes: anObject
	^ (polynomials includes: anObject) and: [anObject degree <= degree]! !

!PolynomialGradingModule methodsFor: 'accessing' stamp: 'len 6/24/2016 05:51'!
ordering
	^ polynomials ordering! !

!PolynomialGradingModule methodsFor: 'accessing' stamp: 'len 1/19/2017 09:21:59'!
scalars
	^ polynomials scalars! !

!PolynomialGradingModule methodsFor: 'as yet unclassified' stamp: 'len 9/3/2018 21:19:14'!
degree: anInteger
	degree _ anInteger! !

!PolynomialGradingModule methodsFor: 'as yet unclassified' stamp: 'len 9/3/2018 21:19:03'!
polynomials: aPolynomialRing
	polynomials _ aPolynomialRing! !

!PolynomialGradingModule methodsFor: 'basis' stamp: 'len 10/2/2018 17:00:37'!
basis
	^ self propertyAt: #basis ifAbsentPut: [self monomialBasis collect: [:each| polynomials monomial: each]]! !

!PolynomialGradingModule methodsFor: 'basis' stamp: 'len 9/3/2018 21:34:50'!
coordinatesOf: aPolynomial
	^ self scalars tuple: (self monomialBasis collect: [:each| aPolynomial coefficientAt: each])! !

!PolynomialGradingModule methodsFor: 'basis' stamp: 'len 9/3/2018 21:33:51'!
monomialBasis
	^ self propertyAt: #monomialBasis ifAbsentPut: [polynomials monomials allMonomialsOfDegree: degree]! !

!PolynomialGradingModule methodsFor: 'testing' stamp: 'len 12/13/2017 21:51:11'!
includes: anObject
	^ (polynomials includes: anObject) and: [anObject isHomogeneous and: [anObject degree = degree]]! !

!ModularFormSpace methodsFor: 'as yet unclassified' stamp: 'len 12/8/2016 11:57:53'!
scalars
	^ CC! !

!ModularFormSpace methodsFor: 'as yet unclassified' stamp: 'len 12/6/2016 20:49:25'!
weight
	^ weight! !

!ModularFormSpace methodsFor: 'as yet unclassified' stamp: 'len 12/6/2016 20:49:33'!
weight: anInteger
	weight _ anInteger! !

!ModularFormSpace class methodsFor: 'as yet unclassified' stamp: 'len 12/6/2016 20:49:18'!
new: anInteger
	^ self new weight: anInteger! !

!ExteriorPower methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 23:50'!
degree
	^ degree! !

!ExteriorPower methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 23:50'!
degree: anInteger
	degree _ anInteger! !

!ExteriorPower methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 23:54'!
rank
	^ self space rank choose: self degree! !

!ExteriorPower methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 23:50'!
space
	^ space! !

!ExteriorPower methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 23:50'!
space: aFreeModule
	space _ aFreeModule! !

!MultivariateModule methodsFor: 'as yet unclassified' stamp: 'len 12/29/2017 07:28:27'!
basis
	"Answer a Groebner basis of the receiver according to its monomial ordering."
	^ self notYetImplemented! !

!MultivariateModule methodsFor: 'as yet unclassified' stamp: 'len 12/29/2017 07:28:17'!
leadingModule
	"Answer the leading module of the receiver according to its monomial ordering."
	^ self notYetImplemented! !

!MultivariateModule methodsFor: 'as yet unclassified' stamp: 'len 12/29/2017 07:29:05'!
ordering
	"Answer the module monomial ordering of the receiver."
	^ self notYetImplemented! !

!AffineSubspace methodsFor: 'accessing' stamp: 'len 5/5/2018 19:16:56'!
ambient
	^ direction ambient! !

!AffineSubspace methodsFor: 'accessing' stamp: 'len 2/9/2016 21:23'!
codimension
	^ direction codimension! !

!AffineSubspace methodsFor: 'accessing' stamp: 'len 6/4/2016 04:21'!
dimension
	^ representative isNil ifTrue: [-1] ifFalse: [direction dimension]! !

!AffineSubspace methodsFor: 'accessing' stamp: 'len 5/23/2016 19:44'!
direction
	"Answer the 'difference space' or 'direction', a linear subspace parallel to the receiver."
	^ direction! !

!AffineSubspace methodsFor: 'accessing' stamp: 'len 6/4/2016 04:18'!
representative
	^ representative! !

!AffineSubspace methodsFor: 'accessing' stamp: 'len 2/9/2016 21:25'!
scalars
	^ direction scalars! !

!AffineSubspace methodsFor: 'accessing' stamp: 'len 1/2/2017 09:58:26'!
substraction
	"Answer the substraction map on the receiver."
	^ (self, self) to: self direction evaluatingWithArguments: [:a :b| a - b]! !

!AffineSubspace methodsFor: 'accessing' stamp: 'len 1/2/2017 09:59:56'!
translation
	"Answer the translation map on the receiver."
	^ (self, self direction) to: self evaluatingWithArguments: [:a :v| a + v]! !

!AffineSubspace methodsFor: 'accessing-private' stamp: 'len 2/9/2016 21:29'!
direction: aVectorSpace
	direction _ aVectorSpace! !

!AffineSubspace methodsFor: 'accessing-private' stamp: 'len 6/4/2016 04:30'!
representative: aPoint
	representative _ aPoint! !

!AffineSubspace methodsFor: 'comparing' stamp: 'len 12/26/2015 20:01'!
< anAffineSubspace
	"Answer true if the receiver is strictly included in the argument."
	^ self dimension < anAffineSubspace dimension and: [self <= anAffineSubspace]! !

!AffineSubspace methodsFor: 'comparing' stamp: 'len 8/24/2016 22:04'!
<= anAffineSubspace
	"Answer true if the receiver is included in the argument."
	self == anAffineSubspace ifTrue: [^ true].
	self dimension <= anAffineSubspace dimension ifFalse: [^ false].
	self isEmpty ifTrue: [^ true].
	^ (anAffineSubspace includes: representative) and: [direction <= anAffineSubspace direction]! !

!AffineSubspace methodsFor: 'comparing' stamp: 'len 4/28/2019 16:33:28'!
= anObject
	self == anObject ifTrue: [^ true].
	(anObject isKindOf: AffineSubspace) ifFalse: [^ false].
	self isEmpty ifTrue: [^ anObject isEmpty].
	^ direction = anObject direction and: [anObject includes: representative]! !

!AffineSubspace methodsFor: 'comparing' stamp: 'len 2/9/2016 21:25'!
hash
	^ self isEmpty ifTrue: [0] ifFalse: [direction hash]! !

!AffineSubspace methodsFor: 'enumerating' stamp: 'len 6/4/2016 04:30'!
do: aBlock
	direction do: [:each| aBlock value: each + representative]! !

!AffineSubspace methodsFor: 'morphisms' stamp: 'len 5/13/2019 17:12:12'!
apply: aMap
	"Answer the homomorphic image of the receiver."
	(aMap isKindOf: AffineMap)
		ifTrue: [^ self species representative: (aMap value: representative) direction: (direction apply: aMap linearMap)].
	^ self species representative: (aMap value: representative) direction: (direction apply: aMap)! !

!AffineSubspace methodsFor: 'operations' stamp: 'len 6/4/2016 04:24'!
* aScalar
	(self scalars includes: aScalar)
		ifTrue: [^ self class representative: representative * aScalar direction: direction].
	^ super * aScalar "if it's not a scalar"! !

!AffineSubspace methodsFor: 'operations' stamp: 'len 4/28/2019 16:33:33'!
+ anObject
	(anObject isKindOf: AffineSubspace)
		ifTrue: [^ self class representative: representative + anObject representative direction: direction + anObject direction].
	(anObject isKindOf: FreeModule)
		ifTrue: [^ self class representative: representative direction: direction + anObject].
	(direction ambient includes: anObject)
		ifTrue: [^ self class representative: representative + anObject direction: direction].
	DomainError signal! !

!AffineSubspace methodsFor: 'operations' stamp: 'len 6/11/2016 17:03'!
- anObject
	^ self + anObject negated! !

!AffineSubspace methodsFor: 'operations' stamp: 'len 5/4/2018 19:07:31'!
/ aScalar
	^ self * aScalar reciprocal! !

!AffineSubspace methodsFor: 'operations' stamp: 'len 5/10/2019 04:25:30'!
/\ anAffineSubspace
	"Answer the intersection of the receiver and the argument."
	| system |
	self isEmpty ifTrue: [^ self].
	anAffineSubspace isEmpty ifTrue: [^ anAffineSubspace].
	system _ self equations copy.
	anAffineSubspace equations do: [ :each | system add: each].
	^ system solutions! !

!AffineSubspace methodsFor: 'operations' stamp: 'len 9/1/2016 07:42'!
\/ anAffineSubspace
	"Join."
	^ self + anAffineSubspace! !

!AffineSubspace methodsFor: 'operations' stamp: 'len 12/30/2017 16:31:18'!
 anAffineSubspace
	^ self class on: (direction  anAffineSubspace direction)! !

!AffineSubspace methodsFor: 'operations' stamp: 'len 6/4/2016 04:21'!
negated
	^ self class representative: representative negated direction: direction! !

!AffineSubspace methodsFor: 'operations' stamp: 'len 6/4/2016 04:31'!
span
	"Answer the linear span of the receiver."
	(direction includes: representative) ifTrue: [^ direction].
	^ (direction basis copyWith: representative) span! !

!AffineSubspace methodsFor: 'operations' stamp: 'len 6/11/2016 16:55'!
span: aCollection
	"Answer the subspace spanned by the points in aCollection."
	| p |
	p _ aCollection anyOne.
	^ self class representative: p direction: (direction span: ((aCollection copyWithout: p) collect: [:each| each - p]))! !

!AffineSubspace methodsFor: 'random' stamp: 'len 6/4/2016 04:29'!
atRandom: aRandom
	^ (direction atRandom: aRandom) + representative! !

!AffineSubspace methodsFor: 'random' stamp: 'len 6/4/2016 04:30'!
atRandom: aRandom bits: bitSize
	^ (direction atRandom: aRandom bits: bitSize) + representative! !

!AffineSubspace methodsFor: 'testing' stamp: 'len 1/1/2017 21:34:04'!
|| anAffineSubspace
	"Answer true if the receiver and the argument are parallel."
	^ direction <= anAffineSubspace direction or: [direction >= anAffineSubspace direction]! !

!AffineSubspace methodsFor: 'testing' stamp: 'len 9/16/2018 16:10:03'!
contains: anObject
	^ self isEmpty not and: [direction contains: anObject - representative]! !

!AffineSubspace methodsFor: 'testing' stamp: 'len 9/16/2018 16:09:38'!
includes: anObject
	^ (self ambient includes: anObject) and: [self contains: anObject]! !

!AffineSubspace methodsFor: 'testing' stamp: 'len 11/9/2015 16:23'!
isEmpty
	^ self dimension = -1! !

!AffineSubspace methodsFor: 'testing' stamp: 'len 1/5/2016 00:05'!
isHyperplane
	^ self codimension = 1! !

!AffineSubspace methodsFor: 'testing' stamp: 'len 1/5/2016 00:04'!
isLine
	^ self dimension = 1! !

!AffineSubspace methodsFor: 'testing' stamp: 'len 1/5/2016 00:04'!
isPlane
	^ self dimension = 2! !

!AffineSubspace methodsFor: 'testing' stamp: 'len 1/5/2016 00:04'!
isPoint
	^ self dimension = 0! !

!AffineSubspace methodsFor: 'testing' stamp: 'len 6/4/2016 04:29'!
isZero
	^ direction includes: representative! !

!AffineSubspace class methodsFor: 'examples' stamp: 'len 3/5/2017 17:14:07'!
example1
	"Make an affine subspace by translating a subspace by a vector."
	| V S |
	V _ QQ^3.
	S _ V span: {(1,2,3)}.
	^ S + (1,1,1)! !

!AffineSubspace class methodsFor: 'examples' stamp: 'len 5/27/2019 07:09:38'!
example2
	"The preimage of a linear map is an affine subspace."
	| V f |
	V _ QQ^3.
	f _ V endomorphisms evaluatingWithArguments: [:x :y :z| (x+z, (y+z), z)].
	"The preimage of (1,2,3) is the set of all vectors that f sends to (1,2,3):"
	^ f preimage: (1,2,3)! !

!AffineSubspace class methodsFor: 'instance creation' stamp: 'len 12/15/2017 20:00:41'!
representative: aVector direction: aSubspace
"	(aSubspace contains: aVector) ifTrue: [^ AffineLinearSpace on: aSubspace]."
	^ self new direction: aSubspace; representative: aVector! !

!Scheme methodsFor: 'accessing' stamp: 'len 1/13/2017 20:02:34'!
base
	"Answer the base scheme of the receiver."
	^ self propertyAt: #base ifAbsent: [ZZ spec]! !

!Scheme methodsFor: 'accessing' stamp: 'len 10/4/2016 09:19'!
codimension
	^ self ambient dimension - self dimension! !

!Scheme methodsFor: 'accessing' stamp: 'len 10/19/2016 23:15'!
dimension
	^ self subclassResponsibility! !

!Scheme methodsFor: 'accessing' stamp: 'len 1/12/2017 20:38:56'!
genus
	"Answer the geometric genus of the receiver."
	^ self subclassResponsibility! !

!Scheme methodsFor: 'elements' stamp: 'len 3/28/2018 18:09:48'!
!! anObject
	anObject isTuple ifTrue: [^ self pointAt: anObject].
	(anObject isKindOf: RationalPoint) ifTrue: [^ self pointAt: anObject coordinates].
	DomainError signal! !

!Scheme methodsFor: 'operations' stamp: 'len 5/13/2019 17:14:07'!
apply: aMorphism
	"Answer the homomorphic image of the receiver."
	"This is the image of aMorphism applied to the receiver, assuming the receiver is a subscheme of the domain of aMorphism."
	^ (aMorphism restrictedTo: self) image! !

!Scheme methodsFor: 'operations' stamp: 'len 5/10/2019 04:33:44'!
subscheme: anObject
	"Answer the subscheme defined by anObject, as subscheme of the ambient space.
	This makes sense, for example, for closed subschemes of affine or projective space, and anObject can be an element or an ideal of the coordinate ring."
	^ self /\ (self ambient subscheme: anObject)! !

!Scheme methodsFor: 'points' stamp: 'len 11/10/2016 08:16'!
points
	"Answer the rational points of the receiver."
	^ self pointsOver: self ambient scalars! !

!Scheme methodsFor: 'points' stamp: 'len 1/20/2017 09:40:05'!
pointsCount
	^ self pointsCountOver: self scalars! !

!Scheme methodsFor: 'points' stamp: 'len 1/21/2017 12:55:08'!
pointsCount: n
	"If the receiver is defined over a finite field GF(q), answer the number of rational points over GF(q^k) for all k in 1..n."
	^ (1 to: n) collect: [:k| self pointsCountOver: (self scalars extensionDegree: k)]! !

!Scheme methodsFor: 'points' stamp: 'len 12/22/2016 23:04:30'!
pointsCountOver: aRing
	"Naive count of rational points on the receiver."
	| answer |
	answer _ 0.
	self pointsOver: aRing do: [:each| answer _ answer + 1].
	^ answer! !

!Scheme methodsFor: 'points' stamp: 'len 12/22/2016 23:04:41'!
pointsOver: aRing
	"Answer the K-rational points on the receiver, where K is aRing."
	^ PointSet from: aRing spec to: self! !

!Scheme methodsFor: 'points' stamp: 'len 1/13/2017 16:45:27'!
pointsOver: aRing do: aBlock
	"Naive enumeration of rational points on the receiver."
	self ambient pointsOver: aRing do: [:each| (self satisfies: each coordinates) ifTrue: [aBlock value: (self pointAt: each coordinates)]]! !

!Scheme methodsFor: 'testing' stamp: 'len 1/13/2017 16:30:27'!
isAffine
	^ false! !

!Scheme methodsFor: 'testing' stamp: 'len 12/30/2016 15:06:11'!
isCurve
	^ self dimension = 1! !

!Scheme methodsFor: 'testing' stamp: 'len 10/13/2016 19:22'!
isHypersurface
	^ self codimension = 1! !

!Scheme methodsFor: 'testing' stamp: 'len 11/2/2016 12:10'!
isInitial
	^ false! !

!Scheme methodsFor: 'testing' stamp: 'len 10/14/2016 18:13'!
isIntegral
	^ self isReduced and: [self isIrreducible]! !

!Scheme methodsFor: 'testing' stamp: 'len 10/12/2016 19:32'!
isPlanar
	^ self ambient dimension = 2! !

!Scheme methodsFor: 'testing' stamp: 'len 1/13/2017 16:30:59'!
isProjective
	^ false! !

!Scheme methodsFor: 'testing' stamp: 'len 1/13/2017 20:05:16'!
isSingular
	"Answer true if the receiver has s singular point or fails to be equidimensional over an algebraic closure of its base field."
	^ self isSmooth not! !

!Scheme methodsFor: 'testing' stamp: 'len 1/13/2017 17:11:35'!
isSmooth
	"Answer true if the receiver is nonsingular."
	^ self propertyAt: #isSmooth ifAbsentPut: [self singular dimension < 0]! !

!Scheme methodsFor: 'testing' stamp: 'len 1/13/2017 17:11:46'!
isSmoothAt: aTuple
	self propertyAt: #isSmooth ifPresent: [:aBoolean| aBoolean ifTrue: [^ true]].
	(self satisfies: aTuple) ifFalse: [DomainError signal: 'point not in this scheme'].
	^ (self singular satisfies: aTuple) not! !

!Scheme methodsFor: 'testing' stamp: 'len 1/9/2017 16:28:50'!
isSurface
	^ self dimension = 2! !

!Scheme methodsFor: 'testing' stamp: 'len 11/2/2016 12:10'!
isTerminal
	^ false! !

!Grassmannian methodsFor: 'accessing' stamp: 'len 9/16/2018 16:13:19'!
dimension
	^ rank * (space rank - rank)! !

!Grassmannian methodsFor: 'accessing' stamp: 'len 4/21/2016 16:58'!
rank
	^ rank! !

!Grassmannian methodsFor: 'accessing' stamp: 'len 6/29/2016 06:41'!
size
	self space isFinite ifFalse: [^ self space size].
	^ self space dimension choose: self rank q: self space scalars size! !

!Grassmannian methodsFor: 'accessing' stamp: 'len 4/20/2016 23:55'!
space
	^ space! !

!Grassmannian methodsFor: 'comparing' stamp: 'len 4/20/2016 23:55'!
= aGrassmannian
	^ (aGrassmannian isKindOf: Grassmannian) and: [aGrassmannian space = self space]! !

!Grassmannian methodsFor: 'morphisms' stamp: 'len 4/21/2016 16:58'!
dual
	^ space dual grassmannian: space dimension - rank! !

!Grassmannian methodsFor: 'morphisms' stamp: 'len 6/28/2016 23:34'!
pluckerEmbedding
	"Answer the Plucker embedding, a natural embedding of the Grassmannian into a projective space."
	^ self notYetImplemented "need to implement the wedge product"! !

!Grassmannian methodsFor: 'random' stamp: 'len 5/4/2019 08:59:09'!
atRandom: aRandom bits: bits
	| S n |
	S _ space null.
	[S rank < rank]
		whileTrue:
			[| v |
			n _ bits / rank.
			[v _ space atRandom: aRandom bits: n.
			S contains: v] whileTrue: [n _ n * 1.5]. "increase bits until we find a new vector"
			S _ S + (space span: {v})].
	^ S! !

!Grassmannian methodsFor: 'testing' stamp: 'len 5/7/2018 17:55:47'!
contains: aSubspace
	^ space >= aSubspace and: [aSubspace rank = rank]! !

!Grassmannian methodsFor: 'testing' stamp: 'len 5/7/2018 17:56:05'!
includes: aSubspace
	^ aSubspace isFreeModule and: [self contains: aSubspace]! !

!Grassmannian methodsFor: 'private' stamp: 'len 4/21/2016 16:59'!
rank: anInteger
	rank _ anInteger! !

!Grassmannian methodsFor: 'private' stamp: 'len 4/20/2016 23:56'!
space: aVectorSpace
	space _ aVectorSpace! !

!Grassmannian class methodsFor: 'instance creation' stamp: 'len 4/21/2016 17:01'!
new: anInteger over: aSpace
	^ self new space: aSpace; rank: anInteger! !

!AffineScheme methodsFor: 'accessing' stamp: 'len 5/15/2018 17:12:28'!
ambient
	^ self propertyAt: #ambient ifAbsent: [self coordinateRing isQuotient ifTrue: [self coordinateRing base spec] ifFalse: [self]]! !

!AffineScheme methodsFor: 'accessing' stamp: 'len 5/17/2018 18:44:19'!
base
	"Answer the base scheme of the receiver."
	^ self scalars spec! !

!AffineScheme methodsFor: 'accessing' stamp: 'len 1/13/2017 16:59:19'!
coordinateRing
	"Answer the affine coordinate ring."
	^ self propertyAt: #coordinateRing! !

!AffineScheme methodsFor: 'accessing' stamp: 'len 1/13/2017 16:01:28'!
dimension
	"Answer the dimension of the highest dimensional component of the receiver.
	This is the Krull dimension of the coordinate ring."
	^ self coordinateRing dimension! !

!AffineScheme methodsFor: 'accessing' stamp: 'len 4/29/2018 02:31:22'!
functionField
	"Answer the function field (or field of rational functions) of the receiver. This is the fractions field of the coordinate ring and it's noted K(V) (analogous to the coordinate ring noted K[V]).
	This assumes the receiver is reduced (or equivalently, that the coordinate ring R is an integral domain). The definition of function field can be extended to the case of non-reduced schemes as Frac(R/N) where N is the nilradical of R."
	^ self coordinateRing fractions! !

!AffineScheme methodsFor: 'accessing' stamp: 'len 5/15/2018 17:18:12'!
ideal
	"Answer the defining ideal of the receiver."
	^ self coordinateRing isQuotient ifTrue: [self coordinateRing relations] ifFalse: [self coordinateRing zeroIdeal]! !

!AffineScheme methodsFor: 'accessing' stamp: 'len 5/17/2018 18:43:51'!
scalars
	"Answer the base ring of the receiver."
	^ self coordinateRing scalars! !

!AffineScheme methodsFor: 'accessing-private' stamp: 'len 1/13/2017 16:08:53'!
coordinateRing: aCommutativeRing
	self propertyAt: #coordinateRing put: aCommutativeRing! !

!AffineScheme methodsFor: 'comparing' stamp: 'len 5/15/2018 17:20:11'!
< aScheme
	^ self ideal > aScheme ideal! !

!AffineScheme methodsFor: 'comparing' stamp: 'len 5/15/2018 17:20:15'!
<= aScheme
	^ self ideal >= aScheme ideal! !

!AffineScheme methodsFor: 'comparing' stamp: 'len 1/13/2017 16:32:32'!
= anObject
	^ (anObject isKindOf: self species) and: [self coordinateRing = anObject coordinateRing]! !

!AffineScheme methodsFor: 'comparing' stamp: 'len 1/13/2017 16:32:38'!
hash
	^ self coordinateRing hash! !

!AffineScheme methodsFor: 'converting' stamp: 'len 1/13/2017 16:10:18'!
over: aRing
	^ self class coordinateRing: (self coordinateRing over: aRing)! !

!AffineScheme methodsFor: 'enumerating' stamp: 'len 5/4/2018 19:34:21'!
do: aBlock
	self coordinateRing primeIdealsDo: aBlock! !

!AffineScheme methodsFor: 'operations' stamp: 'len 5/10/2019 04:24:04'!
/\ aScheme
	"Answer the intersection of the receiver and the argument."
	self ambient = aScheme ambient ifFalse: [^ DomainError signal: 'ambients don''t match'].
	^ self ambient subscheme: self ideal + aScheme ideal! !

!AffineScheme methodsFor: 'operations' stamp: 'len 5/10/2019 04:30:21'!
\/ aScheme
	"Answer the union of the receiver and the argument."
	self ambient = aScheme ambient ifFalse: [^ DomainError signal: 'ambients don''t match'].
	^ self ambient subscheme: self ideal /\ aScheme ideal

"alternatively:
	^ self class on: self ambient ideal: ideal * aScheme ideal
although the intersection is harder to compute, it behaves better with radicalization, because the intersection of two radical ideals is radical and we don't need to compute radicals again"! !

!AffineScheme methodsFor: 'operations' stamp: 'len 5/10/2019 04:30:27'!
subscheme: anObject
	"Answer the subscheme defined by anObject, as subscheme of the ambient space.
	This makes sense, for example, for closed subschemes of affine or projective space, and anObject can be an element or an ideal of the coordinate ring."
	| I |
	self isAmbient ifFalse: [^ self /\ (self ambient subscheme: anObject)].
	I _ (anObject isKindOf: Ideal)
		ifTrue: [anObject] ifFalse: [self coordinateRing * anObject].
	^ (self coordinateRing / I) spec
		propertyAt: #ambient put: self; yourself! !

!AffineScheme methodsFor: 'testing' stamp: 'len 1/13/2017 20:20:05'!
contains: anIdeal
	"Answer true if the receiver contains the given point (a prime ideal of its coordinate ring)."
	^ true! !

!AffineScheme methodsFor: 'testing' stamp: 'len 1/15/2018 18:45:05'!
includes: anObject
	^ (anObject isKindOf: Ideal) and: [anObject scalars = self coordinateRing and: [anObject isPrime]]! !

!AffineScheme methodsFor: 'testing' stamp: 'len 1/13/2017 16:02:42'!
isAffine
	^ true! !

!AffineScheme methodsFor: 'testing' stamp: 'len 1/13/2017 16:03:38'!
isInitial
	^ self coordinateRing isTerminal! !

!AffineScheme methodsFor: 'testing' stamp: 'len 4/29/2018 02:16:44'!
isIrreducible
	^ self coordinateRing isIntegralDomain! !

!AffineScheme methodsFor: 'testing' stamp: 'len 1/13/2017 16:57:08'!
isNoetherian
	^ self coordinateRing isNoetherian! !

!AffineScheme methodsFor: 'testing' stamp: 'len 4/28/2018 05:08:37'!
isReduced
	^ self coordinateRing isReduced! !

!AffineScheme methodsFor: 'testing' stamp: 'len 1/13/2017 16:03:42'!
isTerminal
	^ self coordinateRing isInitial! !

!AffineScheme methodsFor: 'private' stamp: 'len 2/13/2017 07:44:36'!
species
	^ AffineScheme! !

!AffineScheme class methodsFor: 'examples' stamp: 'len 5/22/2018 22:31:28'!
example1
	"Spec(Z), the prime spectrum of the rational integers.
	This is the initial object in the category of schemes."	
	^ ZZ spec! !

!AffineScheme class methodsFor: 'examples' stamp: 'len 5/22/2018 22:34:02'!
example2
	"Spec(Z/6Z), the prime spectrum of the residue class ring
	of integers modulo 6, as a set it is the set of prime
	ideals of Z/6Z:"
	^ (ZZ/6) spec asSet! !

!AffineScheme class methodsFor: 'instance creation' stamp: 'len 1/13/2017 15:59:43'!
coordinateRing: aRing
	^ self new coordinateRing: aRing! !

!AffineVariety methodsFor: 'accessing' stamp: 'len 2/27/2017 21:01:44'!
ideal
	"Answer the defining ideal of the receiver."
	^ self coordinateRing relations! !

!AffineVariety methodsFor: 'comparing' stamp: 'len 2/13/2017 07:33:16'!
= anObject
	^ (anObject isKindOf: AffineVariety) and: [self ideal = anObject ideal]! !

!AffineVariety methodsFor: 'comparing' stamp: 'len 1/13/2017 16:33:18'!
hash
	^ self ideal hash! !

!AffineVariety methodsFor: 'converting' stamp: 'len 2/22/2017 07:52:56'!
asCurve
	^ self ambient isPlane
		ifTrue: [self as: AffinePlaneCurve]
		ifFalse: [self as: AffineCurve]! !

!AffineVariety methodsFor: 'converting' stamp: 'len 2/22/2017 07:53:40'!
asHypersurface
	^ self ambient isPlane
		ifTrue: [self as: AffinePlaneCurve]
		ifFalse: [self as: AffineHypersurface]! !

!AffineVariety methodsFor: 'morphisms' stamp: 'len 1/15/2018 22:24:45'!
projectiveEmbedding
	"Answer the map that sends the receiver to its projective closure.
	If the receiver was originally constructed as an affine patch of a projective scheme, answer the map to the original projective scheme. Otherwise, the projective closure will be constructed as a projective scheme over the projective closure of the ambient space of the receiver, and the receiver will be its last affine patch."
	| P map patches |
	self propertyAt: #projectiveEmbedding ifPresent: [:aRationalMap| ^ aRationalMap].
	P _ self ideal homogenized quotientRing proj.
	map _ self to: P evaluating: [:x| x homogenizedIn: P ambient rank].
	patches _ Array new: P ambient rank.
	patches at: patches size put: self.
	P propertyAt: #affinePatches put: patches.
	^ self propertyAt: #projectiveEmbedding put: map! !

!AffineVariety methodsFor: 'morphisms' stamp: 'len 1/13/2017 19:17:50'!
to: aScheme evaluating: aBlock
	^ RationalMap from: self to: aScheme evaluating: aBlock! !

!AffineVariety methodsFor: 'morphisms' stamp: 'len 5/15/2018 18:05:24'!
to: aScheme representatives: anArrayOfRationalFunctions
	^ RationalMap from: self to: aScheme representatives: anArrayOfRationalFunctions! !

!AffineVariety methodsFor: 'operations' stamp: 'len 5/20/2018 16:16:00'!
+ aTuple
	"Answer a new affine varieity that is the translation of the receiver by aTuple.
	The origin is mappet to aTuple (any point p on the receiver is mapped to p + aTuple)."
	| dx |
	dx _ self ambient coordinateRing generators - aTuple.
	^ self ambient subscheme: (self ideal apply: [:f| f value: dx])! !

!AffineVariety methodsFor: 'operations' stamp: 'len 5/20/2018 16:16:39'!
- aScheme
	"Answer the difference of the receiver with the argument, whose associated ideal is the ideal (colon) quotient of the respective ideals.
	This is the closure of the result of removing from the receiver the points in the intersection with the argument, counted with multiplicity. (See also the 'complement' >>-)."
	aScheme isTuple ifTrue: [^ self + aScheme negated].
	self ambient = aScheme ambient ifFalse: [^ DomainError signal: 'ambients don''t match'].
	^ self ambient subscheme: self ideal  aScheme ideal! !

!AffineVariety methodsFor: 'operations' stamp: 'len 1/13/2017 16:12:29'!
\ aScheme
	"Answer the (closure of the) complement of the argument in the receiver.
	This is the closure of the result of removing from the receiver *all* points in the intersection with the argument, irrespective of multiplicity. (See also the 'difference' >>\)."
	self ambient = aScheme ambient ifFalse: [^ DomainError signal: 'ambients don''t match'].
	^ self ambient subscheme: (self ideal saturation: aScheme ideal)! !

!AffineVariety methodsFor: 'operations' stamp: 'len 5/14/2019 20:45:37'!
 anAffineVariety
	"Answer the cartesian product of the receiver and the argument."
	self scalars = anAffineVariety scalars ifFalse: [self error: 'scalars don''t match'].
	(anAffineVariety isKindOf: AffineVariety) ifFalse: [self notYetImplemented].
	^ (self coordinateRing  anAffineVariety coordinateRing) spec
		propertyAt: #ambient put: self ambient  anAffineVariety ambient;
		yourself! !

!AffineVariety methodsFor: 'operations' stamp: 'len 1/13/2017 16:14:11'!
decomposition
	"Answer the irreducible components of the receiver."
	^ self ideal associatedPrimes collect: [:each| self subscheme: each]! !

!AffineVariety methodsFor: 'operations' stamp: 'len 5/20/2018 16:19:58'!
multiplicityAt: aTuple
	"Answer the multiplicity at the given point."
	^ ((self - aTuple) ideal basisWithOrdering: #lglex) max: [:each| each order]! !

!AffineVariety methodsFor: 'operations' stamp: 'len 1/13/2017 16:14:39'!
primaryComponents
	"Answer the irredundant primary components of the receiver."
	^ self ideal primaryComponents collect: [:each| self subscheme: each]! !

!AffineVariety methodsFor: 'operations' stamp: 'len 1/13/2017 16:14:48'!
primeComponents
	"Answer the irredundant prime components of the receiver."
	^ self ideal primeComponents collect: [:each| self subscheme: each]! !

!AffineVariety methodsFor: 'operations' stamp: 'len 5/15/2018 16:11:21'!
project: anIndeterminate
	"Answer the projection of the receiver by eliminating the given indeterminate.
	This is the intersection of the receiver with a linear subspace {xi = 0}."
	^ self ambient subscheme: (self ideal eliminate: anIndeterminate)! !

!AffineVariety methodsFor: 'operations' stamp: 'len 10/31/2016 13:15'!
projectiveClosure
	"Answer the projective closure of the receiver. If the receiver is an affine patch of a projective scheme, answer the original projective scheme. Otherwise the projective closure will be a projective scheme over the projective closure of the ambient space of the receiver, and the receiver will be the last affine patch."
	^ self projectiveEmbedding codomain! !

!AffineVariety methodsFor: 'operations' stamp: 'len 2/4/2017 09:05:48'!
projectivized
	"Answer the projectivization of the receiver."
	^ self coordinateRing proj! !

!AffineVariety methodsFor: 'operations' stamp: 'len 1/13/2017 16:36:50'!
reduced
	"Answer the reduced subscheme of the receiver."
	^ self propertyAt: #reducedSubscheme ifAbsentPut: [self ambient subscheme: self ideal radical]! !

!AffineVariety methodsFor: 'operations' stamp: 'len 2/4/2017 08:18:58'!
singular
	"Answer the subscheme defined by the appropriately sized minors of the jacobian matrix of the receiver.
	If the receiver is not equidimensional, its lower-dimensional components will be contained in this scheme whether they are singular or not.
	(See Eisenbud 'Commutative Algebra' Ch. 20, re Fitting ideal.)"
	^ self propertyAt: #singularSubscheme ifAbsentPut: [self subscheme: self ideal singular]! !

!AffineVariety methodsFor: 'operations' stamp: 'len 5/20/2018 16:20:19'!
tangentConeAt: aTuple
	"Answer the affine tangent cone at the given point."
	| R I |
	R _ self ambient coordinateRing.
	I _ (self - aTuple) ideal.
	^ (self ambient subscheme: ((I basisWithOrdering: #lglex) collect: [:each| R !! each leadingForm])) + aTuple! !

!AffineVariety methodsFor: 'operations' stamp: 'len 5/20/2018 16:20:38'!
tangentSpaceAt: aTuple
	"Answer the affine tangent space at the given point."
	| R I |
	R _ self ambient coordinateRing.
	I _ (self - aTuple) ideal.
	^ (self ambient subscheme: (I generators collect: [:f| (1 to: R rank) sum: [:i| (R x: i) * (f derivativeIn: i) independentCoefficient]])) + aTuple! !

!AffineVariety methodsFor: 'points' stamp: 'len 11/7/2016 09:01'!
pointAt: aTuple
	^ AffinePoint on: self coordinates: aTuple! !

!AffineVariety methodsFor: 'testing' stamp: 'len 1/13/2017 20:19:22'!
contains: anIdeal
	"Answer true if the receiver contains the given point (a prime ideal)."
	^ self ideal >= anIdeal! !

!AffineVariety methodsFor: 'testing' stamp: 'len 1/9/2017 16:35:09'!
isComplete
	^ self isFinite! !

!AffineVariety methodsFor: 'testing' stamp: 'len 10/1/2018 05:24:05'!
isEmpty
	"Answer true if the receiver has no points over any algebraic closure of its base field.
	Ref. Algorithmic Algebra, B. Mishra, pag. 142-145."
	self ideal isOne ifTrue: [^ true].
"	(self scalars isField and: [self scalars isAlgebraicallyClosed])
		ifFalse: [self error: 'the ground field is not algebraically closed'].
"	^ false! !

!AffineVariety methodsFor: 'testing' stamp: 'len 1/24/2017 11:58:07'!
isEquidimensional
	"Answer true if the receiver is pure dimensional or equidimensional, i.e. if the dimension of the local ring at p is independent of p."
	^ self singular dimension < 0! !

!AffineVariety methodsFor: 'testing' stamp: 'len 1/15/2018 19:06:55'!
isFinite
	"This works for any Groebner basis, no matter the ordering."
	"Does this work for non integral schemes?"
	self ideal scalars indeterminates do: [:x|
		(self ideal groebnerBasis anySatisfy: [:f| | d m | m _ f leadingMonomial. d _ m degree. d > 0 and: [d = (m degreeIn: x)]])
			ifFalse: [^ false]].
	^ true! !

!AffineVariety methodsFor: 'testing' stamp: 'len 1/13/2017 16:56:17'!
isLinear
	^ self reduced ideal generators allSatisfy: [:each| each isLinear]! !

!AffineVariety methodsFor: 'testing' stamp: 'len 1/13/2017 16:39:08'!
satisfies: aTuple
	"Answer true if the defining equations of the receiver satisfy the argument, assuming it's the coordinates of a rational point in the ambient space."
	^ self ideal generators allSatisfy: [:each| (each value: aTuple) isZero]! !

!AffineVariety methodsFor: 'private' stamp: 'len 2/13/2017 07:33:08'!
species
	^ AffineVariety! !

!AffineVariety class methodsFor: 'examples' stamp: 'len 2/22/2017 08:17:35'!
circle
	"The unit circle in the rational affine plane:"
	| R x y I |
	R _ QQ polynomialsIn: #(x y).
	x _ R x.
	y _ R y.
	I _ R * (x^2 + (y^2) - 1).
	^ (R / I) spec! !

!AffineVariety class methodsFor: 'examples' stamp: 'len 2/22/2017 08:18:13'!
clebschCubic
	"The Clebsch cubic as affine scheme in Q^3.
	This is the unique cubic surface that has Sym(5) as symmetry group."
	| A x y z f |
	A _ AffineSpace new: #(x y z) over: QQ.
	x _ A coordinateRing x.
	y _ A coordinateRing y.
	z _ A coordinateRing z.
	f _ x^3 + (y^3) + (z^3) * 81
			+ (x^2*y + (x^2*z) + (x*(y^2)) + (x*(z^2)) + (y^2*z) + (y*(z^2)) * -189)
			+ (x*y*z * 54)
			+ (x*y + (x*z) + (y*z) * 126)
			+ (x^2 + (y^2) + (z^2) * -9)
			+ 1.
	^ A subscheme: f! !

!AffineVariety class methodsFor: 'examples' stamp: 'len 5/22/2018 22:45:58'!
romanSurface
	"The Roman surface or Steiner surface.
	This is a self-intersecting mapping of the real projective plane into affine 3-space.
	It was discovered by Jakob Steiner when he was in Rome in 1844."
	| A r |
	A _ AffineSpace new: #(x y z) over: QQ.
	r _ 1.
	^ A subscheme: A coordinateRing !! [:x :y :z| x*y^2 + (y*z^2) + (z*x^2) - (x*y*z*r squared)]! !

!AffineVariety class methodsFor: 'examples' stamp: 'len 2/22/2017 08:18:46'!
twistedCubic
	"This is the twisted cubic affine variety, parameterized by (x, x^2, x^3) in C^3."
	| A x y z |
	A _ AffineSpace new: #(x y z) over: QQ algebraicClosure.
	x _ A coordinateRing x.
	y _ A coordinateRing y.
	z _ A coordinateRing z.
	^ A subscheme: {y - (x^2). z - (x^3)}! !

!AffineVariety class methodsFor: 'examples' stamp: 'len 5/22/2018 22:46:08'!
whitneyUmbrella
	"This is Whitney's umbrella in affine space Q^3."
	| A |
	A _ AffineSpace new: #(x y z) over: QQ.
	^ A subscheme: A coordinateRing !! [:x :y :z| x^2*y - (z^2)]! !

!AffineVariety class methodsFor: 'instance creation' stamp: 'len 8/27/2018 21:55:35'!
coordinateRing: anAffineRing
	self == AffineVariety ifFalse: [^ super coordinateRing: anAffineRing].
	(anAffineRing relators size = 1 and: [anAffineRing relators anyOne degree > 0]) ifTrue:
		[anAffineRing rank = 2 ifTrue: [^ AffinePlaneCurve coordinateRing: anAffineRing].
		^ AffineHypersurface coordinateRing: anAffineRing].
	^ super coordinateRing: anAffineRing! !

!AffineVariety class methodsFor: 'instance creation' stamp: 'len 2/13/2017 07:33:50'!
newFrom: anObject
	(anObject isKindOf: AffineVariety) ifTrue: [^ self coordinateRing: anObject coordinateRing].
	^ super newFrom: anObject! !

!AffineCurve methodsFor: 'accessing' stamp: 'len 10/24/2016 18:34'!
dimension
	^ 1! !

!AffineHypersurface methodsFor: 'accessing' stamp: 'len 1/8/2017 17:48:10'!
degree
	"The degree of a hypersurface is the total degree of the defining polynomial."
	^ self polynomial degree! !

!AffineHypersurface methodsFor: 'accessing' stamp: 'len 1/8/2017 17:17:24'!
dimension
	^ self ambient dimension - 1! !

!AffineHypersurface methodsFor: 'accessing' stamp: 'len 1/8/2017 17:17:41'!
polynomial
	^ self ideal generator! !

!AffineHypersurface methodsFor: 'morphic' stamp: 'len 1/22/2017 09:31:15'!
plot
	(self scalars isField and: [self scalars isReal and: [self ambient dimension = 3]])
		ifFalse: [^ DomainError signal].
	^ ImplicitSurfacePlotMorph new polynomial: self polynomial! !

!AffineHypersurface methodsFor: 'operations' stamp: 'len 5/20/2018 16:18:41'!
multiplicityAt: aTuple
	self scalars isField ifFalse: [DomainError signal: 'not over a field'].
	^ (self - aTuple) polynomial order! !

!AffineHypersurface class methodsFor: 'instance creation' stamp: 'len 1/23/2017 11:30:29'!
polynomial: aPolynomial
	^ self coordinateRing: aPolynomial parent / aPolynomial! !

!AffinePlaneCurve methodsFor: 'morphic' stamp: 'len 10/24/2016 21:43'!
plot
	^ self plot: (-5@-5 extent: 10@10)! !

!AffinePlaneCurve methodsFor: 'morphic' stamp: 'len 10/24/2016 21:43'!
plot: aRectangle
	^ ImplicitFunctionPlotMorph new function: self polynomial; box: aRectangle! !

!AffinePlaneCurve methodsFor: 'operations' stamp: 'len 5/20/2018 16:19:29'!
tangentsAt: aTuple
	| f r derivatives |
	f _ (self - aTuple) polynomial.
	r _ f order. "multiplicity at the point"
	derivatives _ (0 to: r) collect: [:k| (f derivative: k in: 1) derivative: r-k in: 2].
	^ (self ambient subscheme: ((0 to: r) sum: [:k| (r choose: k) * (derivatives at: k+1) * (f parent x: 1 to: k) * (f parent x: 2 to: r-k)])) + aTuple! !

!AffinePlaneCurve class methodsFor: 'examples' stamp: 'len 5/22/2018 22:36:16'!
descartesFolium
	"This is the 'Descartes folium'."
	^ AffinePlaneCurve polynomial: (QQ polynomialsIn: #(x y)) !! [:x :y| x^3 + (y^3) - (3*x*y)]! !

!AffinePlaneCurve class methodsFor: 'examples' stamp: 'len 5/22/2018 22:35:53'!
iminus
	^ AffinePlaneCurve polynomial: (QQ polynomialsIn: #(x y)) !! [:x :y| x^3 + (y^3) - x - (2*y) - 1]! !

!AffineSpace methodsFor: 'accessing' stamp: 'len 8/27/2016 19:03'!
ambient
	^ self! !

!AffineSpace methodsFor: 'accessing' stamp: 'len 9/26/2016 17:04'!
ideal
	"Answer the defining ideal of the receiver, considered as a subscheme of itself."
	^ self coordinateRing zeroIdeal! !

!AffineSpace methodsFor: 'accessing' stamp: 'len 10/20/2016 03:43'!
rank
	"Answer the number of affine coordinates, i.e. the number of indeterminates of the coordinate ring. This can be different from the Krull dimension, for example Spec Z[x] has rank 1 and Krull dimension 2."
	^ self coordinateRing rank! !

!AffineSpace methodsFor: 'morphisms' stamp: 'len 12/28/2016 11:34:07'!
projectiveEmbedding
	| P map patches |
	self propertyAt: #projectiveEmbedding ifPresent: [:aRationalMap| ^ aRationalMap].
	P _ ProjectiveSpace new: self rank over: self scalars.
	map _ self to: P evaluating: [:x| x homogenizedIn: P rank].
	patches _ Array new: P ambient rank.
	patches at: patches size put: self.
	P propertyAt: #affinePatches put: patches.
	^ self propertyAt: #projectiveEmbedding put: map! !

!AffineSpace methodsFor: 'operations' stamp: 'len 12/31/2017 13:41:22'!
 anAffineSpace
	"Answer the cartesian product of the receiver and the argument."
	(anAffineSpace isKindOf: AffineSpace)
		ifFalse: [^ super  anAffineSpace].
	^ ProductAffineSpace components: {self. anAffineSpace}! !

!AffineSpace methodsFor: 'operations' stamp: 'len 2/10/2017 07:20:37'!
subscheme: anObject
	| I |
	I _ (anObject isKindOf: Ideal)
		ifTrue: [anObject] ifFalse: [self coordinateRing * anObject].
	^ (self coordinateRing / I) spec
		propertyAt: #ambient put: self; yourself! !

!AffineSpace methodsFor: 'points' stamp: 'len 1/21/2018 14:47:29'!
origin
	^ self pointAt: (self scalars zeroTuple: self rank)! !

!AffineSpace methodsFor: 'points' stamp: 'len 1/22/2017 08:22:56'!
pointsCountOver: aRing
	^ aRing size ^ self rank! !

!AffineSpace methodsFor: 'points' stamp: 'len 1/22/2017 08:23:01'!
pointsOver: aRing do: aBlock
	^ aRing ^ self rank do: [:each| aBlock value: (self pointAt: each)]! !

!AffineSpace methodsFor: 'testing' stamp: 'len 2/22/2017 07:54:37'!
isPlane
	^ self rank = 2! !

!AffineSpace methodsFor: 'testing' stamp: 'len 1/13/2017 17:07:13'!
satisfies: aTuple
	^ true! !

!AffineSpace class methodsFor: 'examples' stamp: 'len 5/17/2018 18:59:49'!
example1
	"The rational affine plane:"
	^ AffineSpace new: 2 over: QQ! !

!AffineSpace class methodsFor: 'examples' stamp: 'len 5/17/2018 19:00:16'!
example2
	"Or assigning names to the indeterminates of the coordinate ring:"
	^ AffineSpace new: #(x y) over: QQ! !

!AffineSpace class methodsFor: 'examples' stamp: 'len 5/17/2018 19:00:37'!
example3
	"And equivalently:"
	^ (QQ polynomialsIn: #(x y)) spec! !

!AffineSpace class methodsFor: 'instance creation' stamp: 'len 10/28/2016 10:39'!
new: rank over: aRing
	^ self coordinateRing: (aRing polynomialsIn: rank)! !

!ProductAffineSpace methodsFor: 'accessing' stamp: 'len 2/10/2017 08:52:19'!
arity
	^ self components size! !

!ProductAffineSpace methodsFor: 'accessing' stamp: 'len 2/10/2017 08:52:13'!
at: anInteger
	^ self components at: anInteger! !

!ProductAffineSpace methodsFor: 'accessing' stamp: 'len 5/14/2019 20:48:00'!
coordinateRing
	^ self propertyAt: #coordinateRing ifAbsentPut: [self components fold: [:A :B| A coordinateRing  B coordinateRing]]! !

!ProductAffineSpace methodsFor: 'accessing-private' stamp: 'len 2/10/2017 08:48:42'!
components
	^ self propertyAt: #components! !

!ProductAffineSpace methodsFor: 'accessing-private' stamp: 'len 2/10/2017 08:48:38'!
components: anArray
	self propertyAt: #components put: anArray! !

!ProductAffineSpace methodsFor: 'morphisms' stamp: 'len 1/5/2018 09:36:19'!
projection: i
	| shift |
	shift _ 0.
	1 to: i-1 do: [:each| shift _ shift + (self at: each) rank].
	^ RationalMap from: self to: (self at: i) polynomials: ((1 to: (self at: i) rank) collect: [:j| self coordinateRing x: j+shift])! !

!ProductAffineSpace methodsFor: 'testing' stamp: 'len 2/10/2017 09:03:47'!
isProduct
	^ true! !

!ProductAffineSpace class methodsFor: 'examples' stamp: 'len 5/17/2018 18:55:22'!
example1
	^ ProductAffineSpace new: #((x y z) (a b)) over: QQ! !

!ProductAffineSpace class methodsFor: 'examples' stamp: 'len 5/17/2018 18:56:00'!
example2
	^ (AffineSpace new: #(x y z) over: QQ)  (AffineSpace new: #(a b) over: QQ)! !

!ProductAffineSpace class methodsFor: 'examples' stamp: 'len 5/17/2018 18:56:23'!
example3
	^ ((AffineSpace new: #(x y z) over: QQ)  (AffineSpace new: #(a b) over: QQ)) coordinateRing! !

!ProductAffineSpace class methodsFor: 'instance creation' stamp: 'len 2/10/2017 08:47:57'!
components: anArray
	^ self new components: anArray! !

!ProductAffineSpace class methodsFor: 'instance creation' stamp: 'len 2/10/2017 08:47:44'!
new: anArray over: aRing
	^ self components: (anArray collect: [:each| AffineSpace new: each over: aRing])! !

!ProjectiveScheme methodsFor: 'as yet unclassified' stamp: 'len 5/19/2018 16:32:56'!
do: aBlock
	self coordinateRing relevantPrimeIdealsDo: aBlock! !

!ProjectiveVariety methodsFor: 'accessing' stamp: 'len 5/17/2018 19:16:43'!
affineCone
	"If the receiver is defined by an homogeneous ideal I, the affine cone is the affine variety defined by I."
	^ self coordinateRing spec! !

!ProjectiveVariety methodsFor: 'accessing' stamp: 'len 2/10/2017 07:46:27'!
ambient
	^ self propertyAt: #ambient ifAbsent: [self coordinateRing base proj]! !

!ProjectiveVariety methodsFor: 'accessing' stamp: 'len 4/29/2018 02:36:33'!
anyPatch
	^ self patch: self ambient rank! !

!ProjectiveVariety methodsFor: 'accessing' stamp: 'len 1/10/2017 21:15:14'!
arithmeticGenus
	"Answer the arithmetic genus of the receiver."
	self ambient isOrdinaryProjectiveSpace ifFalse: [^ self error: 'not ordinary projective space'].
	self notYetImplemented! !

!ProjectiveVariety methodsFor: 'accessing' stamp: 'len 2/10/2017 07:16:14'!
base
	"Answer the base scheme of the receiver."
	^ self scalars spec! !

!ProjectiveVariety methodsFor: 'accessing' stamp: 'len 1/13/2017 17:01:55'!
coordinateRing
	"Answer the homogeneous coordinate ring."
	^ self propertyAt: #coordinateRing! !

!ProjectiveVariety methodsFor: 'accessing' stamp: 'len 10/27/2016 21:44'!
degree
	| t H |
	t _ QQ polynomials fractions x.
	H _ self coordinateRing hilbertSeriesAt: t.
	^ (1 - t) ^ (H orderAt: 1) negated * H value: 1! !

!ProjectiveVariety methodsFor: 'accessing' stamp: 'len 10/27/2016 22:50'!
degree2
	| t H |
	t _ QQ polynomials fractions x.
	H _ self coordinateRing hilbertSeriesAt: t.
	^ (1 - t) ^ self coordinateRing dimension * H value: 1! !

!ProjectiveVariety methodsFor: 'accessing' stamp: 'len 10/20/2016 15:25'!
dimension
	self flag: #fix. "is this right for projective schemes or should use the Hilbert series?"
	^ self coordinateRing dimension - 1! !

!ProjectiveVariety methodsFor: 'accessing' stamp: 'len 5/17/2018 17:12:15'!
functionField
	"If K(X) is the function field of the affine cone, the function field of the projective variety is the subfield of K(X) of homogeneous elements of degree 0 (the grading at degree 0), that is {f/g | f,g in K(X) and g not zero}.
	This is isomorphic to the function field of any affine patch."
	^ self anyPatch functionField! !

!ProjectiveVariety methodsFor: 'accessing' stamp: 'len 2/27/2017 21:02:04'!
ideal
	"Answer the homogeneous ideal defining the receiver."
	^ self coordinateRing relations! !

!ProjectiveVariety methodsFor: 'accessing' stamp: 'len 2/13/2017 21:17:21'!
patch: i
	"Answer the i-th affine patch of the receiver."
	| patches answer map |
	patches _ self propertyAt: #affinePatches ifAbsentPut: [Array new: self ambient rank].
	(patches at: i) ifNotNil: [:anAffineVariety| ^ anAffineVariety].
	answer _ self newPatch: i.
	map _ answer to: self evaluating: [:x| x homogenizedIn: i].
	answer propertyAt: #projectiveEmbedding put: map.
	^ patches at: i put: answer! !

!ProjectiveVariety methodsFor: 'accessing' stamp: 'len 1/12/2017 14:44:25'!
patches
	"Answer all the standard affine patches of the receiver."
	^ (1 to: self ambient rank) collect: [:i| self patch: i]! !

!ProjectiveVariety methodsFor: 'accessing' stamp: 'len 5/17/2018 19:20:23'!
scalars
	"Answer the base ring of the receiver."
	^ self coordinateRing scalars! !

!ProjectiveVariety methodsFor: 'accessing-private' stamp: 'len 1/13/2017 17:02:28'!
coordinateRing: aCommutativeRing
	self propertyAt: #coordinateRing put: aCommutativeRing! !

!ProjectiveVariety methodsFor: 'comparing' stamp: 'len 1/13/2017 17:03:23'!
= anObject
	^ (anObject isKindOf: self species) and: [self saturated coordinateRing = anObject saturated coordinateRing]! !

!ProjectiveVariety methodsFor: 'comparing' stamp: 'len 1/13/2017 17:23:21'!
hash
	^ self saturated coordinateRing hash! !

!ProjectiveVariety methodsFor: 'converting' stamp: 'len 2/22/2017 07:56:24'!
asCurve
	^ self ambient isPlane
		ifTrue: [self as: ProjectivePlaneCurve]
		ifFalse: [self as: ProjectiveCurve]! !

!ProjectiveVariety methodsFor: 'converting' stamp: 'len 2/22/2017 07:56:46'!
asHypersurface
	^ self ambient isPlane
		ifTrue: [self as: ProjectivePlaneCurve]
		ifFalse: [self as: ProjectiveHypersurface]! !

!ProjectiveVariety methodsFor: 'converting' stamp: 'len 1/20/2017 09:11:44'!
over: aRing
	^ self class coordinateRing: (self coordinateRing over: aRing)! !

!ProjectiveVariety methodsFor: 'morphisms' stamp: 'len 1/13/2017 17:04:15'!
to: aScheme evaluating: aBlock
	^ RationalMap from: self to: aScheme evaluating: aBlock! !

!ProjectiveVariety methodsFor: 'morphisms' stamp: 'len 5/17/2018 16:31:31'!
to: aScheme representatives: anArrayOfRationalFunctions
	^ RationalMap from: self to: aScheme representatives: anArrayOfRationalFunctions! !

!ProjectiveVariety methodsFor: 'operations' stamp: 'len 5/10/2019 04:29:17'!
/\ aScheme
	"Answer the intersection of the receiver and the argument."
	self ambient = aScheme ambient ifFalse: [^ DomainError signal: 'ambients don''t match'].
	^ self ambient subscheme: self ideal + aScheme ideal! !

!ProjectiveVariety methodsFor: 'operations' stamp: 'len 5/10/2019 04:33:33'!
\/ aScheme
	"Answer the union of the receiver and the argument."
	self ambient = aScheme ambient ifFalse: [^ DomainError signal: 'ambients don''t match'].
	^ self ambient subscheme: self ideal /\ aScheme ideal

"alternatively:
	^ self class on: self ambient ideal: ideal * aScheme ideal
although the intersection is harder to compute, it behaves better with radicalization, because the intersection of two radical ideals is radical and we don't need to compute radicals again"! !

!ProjectiveVariety methodsFor: 'operations' stamp: 'len 5/14/2019 20:48:10'!
 aProjectiveVariety
	"Answer the cartesian product of the receiver and the argument."
	self scalars = aProjectiveVariety scalars ifFalse: [self error: 'scalars don''t match'].
	(aProjectiveVariety isKindOf: ProjectiveVariety) ifFalse: [self notYetImplemented].
	^ (self coordinateRing  aProjectiveVariety coordinateRing) proj
		propertyAt: #ambient put: self ambient  aProjectiveVariety ambient;
		yourself! !

!ProjectiveVariety methodsFor: 'operations' stamp: 'len 1/13/2017 16:13:44'!
decomposition
	"Answer the irreducible components of the receiver."
	| primes |
	primes _ self ideal associatedPrimes.
	"Since the scheme is projective, remove the primes containing the irrelevant ideal:"
	primes _ primes reject: [:each| self ambient coordinateRing generators anySatisfy: [:xi| each includes: xi]].
	^ primes collect: [:each| self subscheme: each]! !

!ProjectiveVariety methodsFor: 'operations' stamp: 'len 2/10/2017 08:23:03'!
dual
	"Answer the projective dual of the receiver."
	self notYetImplemented! !

!ProjectiveVariety methodsFor: 'operations' stamp: 'len 1/13/2017 17:14:11'!
reduced
	"Answer the reduced subscheme of the receiver."
	^ self propertyAt: #reducedSubscheme ifAbsentPut: [self ambient subscheme: self ideal radical]! !

!ProjectiveVariety methodsFor: 'operations' stamp: 'len 2/4/2017 08:19:18'!
singular
	"Answer the subscheme defined by the appropriately sized minors of the jacobian matrix of the receiver.
	If the receiver is not equidimensional, its lower-dimensional components will be contained in this scheme whether they are singular or not.
	(See Eisenbud 'Commutative Algebra' Ch. 20, re Fitting ideal.)"
	^ self propertyAt: #singularSubscheme ifAbsentPut: [self subscheme: self ideal singular]! !

!ProjectiveVariety methodsFor: 'operations' stamp: 'len 1/11/2017 09:31:12'!
tangentSpaceAt: aTuple
	"Answer the projective tangent space of the receiver at the given point."
	| R |
	self flag: #fix. "this might be wrong, The Geometry of Schemes pag 105"
	R _ self ambient coordinateRing.
	^ self ambient subscheme: (self ideal generators collect: [:f| (1 to: R rank) sum: [:i| (R x: i) * ((f derivativeIn: i) value: aTuple)]])! !

!ProjectiveVariety methodsFor: 'points' stamp: 'len 11/7/2016 13:35'!
pointAt: aTuple
	^ ProjectivePoint on: self coordinates: aTuple! !

!ProjectiveVariety methodsFor: 'testing' stamp: 'len 1/9/2017 16:34:57'!
isComplete
	^ true! !

!ProjectiveVariety methodsFor: 'testing' stamp: 'len 5/17/2018 16:30:03'!
isEmpty
	"Answer true if the receiver has no points over any algebraic closure of its base field."
	^ self dimension = -1! !

!ProjectiveVariety methodsFor: 'testing' stamp: 'len 4/28/2018 05:51:30'!
isIrreducible
	self flag: #fix. "magma does it differently; duplicated in AffineSchema"
	^ self coordinateRing isIntegralDomain! !

!ProjectiveVariety methodsFor: 'testing' stamp: 'len 10/20/2016 15:21'!
isProjective
	^ true! !

!ProjectiveVariety methodsFor: 'testing' stamp: 'len 4/28/2018 05:41:05'!
isReduced
	^ self coordinateRing isReduced! !

!ProjectiveVariety methodsFor: 'testing' stamp: 'len 1/13/2017 17:30:58'!
satisfies: aTuple
	"Answer true if the defining equations of the receiver satisfy the argument, assuming it's the coordinates of a rational point in the ambient space."
	^ self ideal generators allSatisfy: [:each| (each value: aTuple) isZero]! !

!ProjectiveVariety methodsFor: 'private' stamp: 'len 1/12/2017 14:49:14'!
newPatch: i
	^ (self ambient patch: i) subscheme: (self ideal dehomogenizedIn: i)! !

!ProjectiveVariety methodsFor: 'private' stamp: 'len 1/13/2017 17:26:20'!
saturated
	"Ensure the defining ideal of the receiver is saturated.
	This is important for some operations with projective schemes because projective schemes are not in correspondence with homogeneous ideals (like affine schemes), but they are in correspondence with saturated homogeneous ideals."
	(self propertyAt: #isSaturated ifAbsent: [false]) ifTrue: [^ self].
	self coordinateRing: self ambient coordinateRing / self ideal saturation.
	self propertyAt: #isSaturated put: true! !

!ProjectiveVariety methodsFor: 'private' stamp: 'len 2/13/2017 07:38:51'!
species
	^ ProjectiveVariety! !

!ProjectiveVariety class methodsFor: 'examples' stamp: 'len 5/22/2018 22:49:43'!
cayleyCubic
	"The Cayley cubic as projective surface.
	This is the unique cubic surface that has 4 ordinary nodes.
	It is a degeneration of the Clebsh cubic and has Sym(4) as its symmetry group."
	| P |
	P _ ProjectiveSpace new: #(x y z w) over: QQ.
	^ P subscheme: P coordinateRing !! [:x :y :z :w| x*y*z + (x*y*w) + (x*z*w) + (y*z*w)]! !

!ProjectiveVariety class methodsFor: 'examples' stamp: 'len 5/22/2018 22:45:30'!
fermat4
	"The 4th Fermat curve."
	| P |
	P _ ProjectiveSpace new: #(x y z) over: QQ.
	^ P subscheme: P coordinateRing !! [:x :y :z| x^4 + (y^4) - (z^4)]! !

!ProjectiveVariety class methodsFor: 'examples' stamp: 'len 2/22/2017 08:19:34'!
fermat: n
	"The n-th Fermat curve."
	| P |
	P _ ProjectiveSpace new: #(x y z) over: QQ.
	^ P subscheme: (P coordinateRing generate: [:x :y :z| x^n + (y^n) - (z^n)])! !

!ProjectiveVariety class methodsFor: 'examples' stamp: 'len 2/22/2017 08:19:42'!
kleinQuartic
	"This is a projective variety, a curve in P^2(C)."
	| P x y z |
	P _ ProjectiveSpace new: 2 over: QQ.
	x _ P coordinateRing x.
	y _ P coordinateRing y.
	z _ P coordinateRing z.
	^ P subscheme: {x^3*y + (y^3*z) + (z^3*x)}! !

!ProjectiveVariety class methodsFor: 'instance creation' stamp: 'len 8/27/2018 21:57:50'!
coordinateRing: anAffineRing
	self == ProjectiveVariety ifFalse: [^ self new coordinateRing: anAffineRing].
	anAffineRing relators size = 1 ifTrue:
		[| f |
		f _ anAffineRing relators anyOne.
		f degree > 0 ifTrue:
			[anAffineRing rank = 3 ifTrue:
				[f degree = 1 ifTrue: [^ RationalCurve coordinateRing: anAffineRing].
				f degree = 2 ifTrue: [^ Conic coordinateRing: anAffineRing].
				f degree = 3 ifTrue: ["elliptic curve"].
				^ ProjectivePlaneCurve coordinateRing: anAffineRing].
			^ ProjectiveHypersurface coordinateRing: anAffineRing]].
	^ self new coordinateRing: anAffineRing! !

!ProjectiveVariety class methodsFor: 'instance creation' stamp: 'len 2/13/2017 07:39:23'!
newFrom: anObject
	(anObject isKindOf: ProjectiveVariety) ifTrue: [^ self coordinateRing: anObject coordinateRing].
	^ super newFrom: anObject! !

!ProjectiveCurve methodsFor: 'accessing' stamp: 'len 11/9/2016 08:05'!
arithmeticGenus
	self isIrreducible ifFalse: [^ self error: 'not irreducible'].
	^ 1 - (self ideal hilbertPolynomial value: 0)! !

!ProjectiveCurve methodsFor: 'accessing' stamp: 'len 10/13/2016 13:38'!
dimension
	^ 1! !

!ProjectiveCurve methodsFor: 'as yet unclassified' stamp: 'len 4/30/2018 19:16:28'!
divisorOf: aRationalFunction
	"Answer div(f), the divisor with coefficient ord(f,p) for each point p of its support, where ord(f,p) is the order of a point p as zero or pole of the rational function f."
	self notYetImplemented! !

!ProjectiveHypersurface methodsFor: 'accessing' stamp: 'len 1/8/2017 17:39:24'!
degree
	"The degree of a projective hypersurface is the degree of the defining homogeneous polynomial."
	^ self polynomial degree! !

!ProjectiveHypersurface methodsFor: 'accessing' stamp: 'len 1/8/2017 17:21:47'!
dimension
	^ self ambient dimension - 1! !

!ProjectiveHypersurface methodsFor: 'accessing' stamp: 'len 2/10/2017 08:22:53'!
dual
	"Answer the projective dual of the receiver."
	self notYetImplemented! !

!ProjectiveHypersurface methodsFor: 'accessing' stamp: 'len 1/8/2017 17:21:37'!
polynomial
	^ self ideal generator! !

!ProjectiveHypersurface methodsFor: 'as yet unclassified' stamp: 'len 1/11/2017 20:55:49'!
gradient
	| f F |
	f _ self polynomial.
	F _ self ambient functionField.
	"actually should go to the dual projective space"
	^ RationalMap from: self to: self ambient representatives: ((1 to: F rank) collect: [:i| F !! (f derivativeIn: i)])! !

!ProjectiveHypersurface class methodsFor: 'instance creation' stamp: 'len 1/8/2017 17:20:38'!
polynomial: aPolynomial
	^ self coordinateRing: aPolynomial parent / aPolynomial! !

!ProjectivePlaneCurve methodsFor: 'accessing' stamp: 'len 1/10/2018 13:52:10'!
arithmeticGenus
	| n |
	self isIrreducible ifFalse: [^ self notYetImplemented].
	n _ self polynomial degree.
	^ n - 1 * (n - 2) / 2! !

!ProjectivePlaneCurve methodsFor: 'operations' stamp: 'len 5/10/2019 04:33:29'!
flexes
	"This is the subscheme of flexes of the receiver.
	In classic algebraic geometry, a point in a nonsingular plane curve over the complex numbers is a 'flex' if its tangent line has contact of order >= 3 with the curve."
	^ self /\ self hessian! !

!ProjectivePlaneCurve methodsFor: 'operations' stamp: 'len 1/11/2017 13:24:29'!
hessian
	"Answer the Hessian curve associated to the receiver.
	Over an algebraically closed field, the intersection of a plane curve and its Hessian is the subvariety of flexes."
	^ self ambient subscheme: self polynomial hessian determinant! !

!Conic methodsFor: 'accessing' stamp: 'len 1/23/2017 11:31:13'!
coefficients
	^ self propertyAt: #coefficients ifAbsentPut:
		[| f |
		f _ self polynomial orderedBy: #lex.
		(f parent gradingAt: 2) coordinatesOf: f]! !

!Conic methodsFor: 'accessing' stamp: 'len 9/3/2018 21:10:30'!
determinant
	^ self matrix determinant! !

!Conic methodsFor: 'accessing' stamp: 'len 12/25/2016 12:14:47'!
genus
	"Answer the geometric genus of the receiver."
	^ 0! !

!Conic methodsFor: 'accessing' stamp: 'len 9/13/2018 05:48:34'!
matrix
	"Answer the matrix M such that the defining polynomial of this conic is (x,y,z)*M*(x,y,z)^t. The matrix is upper-triangular over characteristic 2, and symmetric otherwise."
	self scalars characteristic = 2
		ifTrue: [^ self upperTriangularMatrix].
	^ self symmetricMatrix! !

!Conic methodsFor: 'accessing' stamp: 'len 12/31/2016 10:07:42'!
parametrization
	"Answer a parametrization of the receiver as a regular map from the projective line."
	| point P1 |
	self scalars isField ifFalse: [^ self error: 'not over a field'].
	self isSmooth ifFalse: [^ self error: 'the conic is not smooth'].
	point _ self anyPoint.
	P1 _ ProjectiveLine over: self scalars.
	"..."! !

!Conic methodsFor: 'morphisms' stamp: 'len 1/7/2017 21:44:28'!
toDiagonal
	"Answer an isomorphism between the receiver and its diagonal form."
	self notYetImplemented! !

!Conic methodsFor: 'points' stamp: 'len 9/4/2018 14:16:51'!
pointAtRandom: aRandom
	"Answer randomly a point of the receiver. Assume the scalars are a finite field."
	| f |
	f _ self parametrization.
	^ f value: (f domain pointAtRandom: aRandom)! !

!Conic methodsFor: 'points' stamp: 'len 1/7/2017 21:28:07'!
pointsCountOver: aRing
	"The number of Z/pZ-rational points of a curve of genus 0 is always p + 1."
	(aRing isKindOf: PrimeField) ifTrue: [^ aRing characteristic + 1].
	^ super pointsCountOver: aRing! !

!Conic methodsFor: 'testing' stamp: 'len 9/4/2018 13:56:26'!
isDiagonal
	"Answer true if the reciever is in diagonal form, i.e. it is defined by a polynomial of the form ax^2 + by^2 + cz^2."
	| coefficients |
	coefficients _ self coefficients.
	^ (coefficients at: 2) isZero and: [(coefficients at: 3) isZero and: [(coefficients at: 5) isZero]]! !

!Conic methodsFor: 'testing' stamp: 'len 1/7/2017 21:48:12'!
isIrreducible
	"In characteristic not 2, this is equivalent to the diagonal form having coefficients a,b,c all not 0."
	^ super isIrreducible! !

!Conic methodsFor: 'testing' stamp: 'len 9/3/2018 20:29:09'!
isSmooth
	"Answer true if the receiver is nonsingular."
	| coefficients p |
	self scalars characteristic = 2 ifFalse: [^ self determinant isZero not].
	coefficients _ self coefficients.
	p _ #(5 3 2) collect: [:i| coefficients at: i].
	(p allSatisfy: [:each| each isZero]) ifTrue: [^ false].
	^ (self polynomial value: p) isZero not! !

!Conic methodsFor: 'private' stamp: 'len 12/26/2016 11:28:39'!
solve: d n: n
	(d < 0 and: [n < 0]) ifTrue: [^ nil].
	d abs > n abs ifTrue: [^ self solve: n n: d].
	d = 1 ifTrue: [^ #(1 1 0)].
	n = 1 ifTrue: [^ #(1 0 1)].
	d = n negated ifTrue: [^ #(0 1 1)].
	d = n ifTrue: [^ (self solve: -1 n: d) ifNotNil: [:xyz| [:x :y :z| {d*z. x. y}] valueWithArguments: xyz]].
	(d isQuadraticResidueModulo: n) ifFalse: [^ nil].
	"... last two steps"! !

!Conic methodsFor: 'private' stamp: 'len 9/13/2018 20:26:57'!
symmetricMatrix
	| T |
	self scalars characteristic = 2
		ifTrue:
			[self isDiagonal ifFalse: [self error: 'not symmetric matrix defined for non-diagonal conic over field of characteristic 2'].
			^ self upperTriangularMatrix].
	T _ self upperTriangularMatrix.
	^ T + T transposed / 2! !

!Conic methodsFor: 'private' stamp: 'len 9/4/2018 14:20:45'!
upperTriangularMatrix
	| stream |
	stream _ self coefficients readStream.
	^ self scalars matrix: 3 evaluating: [:i :j| i > j ifTrue: [self scalars zero] ifFalse: [stream next]]! !

!Conic class methodsFor: 'instance creation' stamp: 'len 9/4/2018 13:55:14'!
coefficients: aTuple
	| R x y z |
	R _ aTuple scalars polynomialsIn: #(x y z).
	x _ R x.
	y _ R y.
	z _ R z.
	aTuple size = 3
		ifTrue: [^ self polynomial: x^2 * (aTuple at: 1) + (y^2 * (aTuple at: 2)) + (z^2 * (aTuple at: 3))].
	aTuple size = 6
		ifTrue: [^ self polynomial: x^2*(aTuple at: 1) + (x*y*(aTuple at: 2)) + (x*z*(aTuple at: 3)) + (y^2*(aTuple at: 4)) + (y*z*(aTuple at: 5)) + (z^2*(aTuple at: 6))].
	^ self error: '3 or 6 coefficients expected'! !

!RationalCurve methodsFor: 'as yet unclassified' stamp: 'len 12/25/2016 12:14:55'!
genus
	"Answer the geometric genus of the receiver."
	^ 0! !

!RationalCurve methodsFor: 'as yet unclassified' stamp: 'len 1/7/2017 21:28:19'!
pointsCountOver: aRing
	"The number of Z/pZ-rational points of a curve of genus 0 is always p + 1."
	(aRing isKindOf: PrimeField) ifTrue: [^ aRing characteristic + 1].
	^ super pointsCountOver: aRing! !

!EllipticCurve methodsFor: 'accessing' stamp: 'len 11/9/2016 13:11'!
equation
	^ equation! !

!EllipticCurve methodsFor: 'accessing' stamp: 'len 11/10/2016 08:03'!
genus
	"Answer the geometric genus of the receiver."
	^ 1! !

!EllipticCurve methodsFor: 'accessing-private' stamp: 'len 1/15/2018 22:24:51'!
equation: aWeierstrassEquation
	equation _ aWeierstrassEquation.
	self coordinateRing: aWeierstrassEquation homogeneousPolynomial asIdeal quotientRing! !

!EllipticCurve methodsFor: 'converting' stamp: 'len 5/21/2018 17:30:18'!
% anInteger
	"Answer the reduction of the receiver modulo anInteger."
	(self scalars isKindOf: RationalField) ifFalse: [^ DomainError signal: 'not over the rationals'].
	^ self over: ZZ % anInteger! !

!EllipticCurve methodsFor: 'converting' stamp: 'len 1/20/2017 09:37:28'!
over: aRing
	^ self class equation: (self equation over: aRing)! !

!EllipticCurve methodsFor: 'operations' stamp: 'len 1/7/2017 21:32:02'!
badPrimes
	"Answer the set of primes for which the receiver doesn't have 'good reduction'."
	^ self discriminant factors asSet! !

!EllipticCurve methodsFor: 'operations' stamp: 'len 11/11/2016 10:02'!
discriminant
	^ self equation discriminant! !

!EllipticCurve methodsFor: 'operations' stamp: 'len 11/10/2016 09:43'!
divisionPolynomial: n
	"Answer the n-th division polynomial."
	^ self divisionPolynomial: n at: self scalars polynomials x! !

!EllipticCurve methodsFor: 'operations' stamp: 'len 12/28/2016 09:23:12'!
divisionPolynomial: n at: x
	"Answer the n-th division polynomial of the receiver evaluated at x."
	^ self notYetImplemented! !

!EllipticCurve methodsFor: 'operations' stamp: 'len 12/28/2016 09:58:01'!
divisionPolynomialNew: n
	"Answer the n-th division polynomial."
	| R w x y |
	R _ ZZ polynomialsIn: #(x y).
	n == 1 ifTrue: [^ R one].
	w _ self equation.
	x _ R x.
	y _ R y.
	n == 2 ifTrue: [^ y*2 + (w a1 * x) + w a3].
	n == 3 ifTrue: [^ x^4 * 3 + (x^3 * w b2) + (x^2 * 3 * w b4) + (x * 3 * w b6) + w b8].
	n == 4 ifTrue: [^ (self divisionPolynomial: 2) * (x^6 * 2 + (x^5 * w b2) + (x^4 * w b4 * 5) + (x^3 * 10 * w b6) + (x^2 * 10 * w b8) + (x * (w b2 * w b8 - (w b4 * w b6))) + (w b4 * w b8 - w b6 squared))].
"	n odd ifTrue: [
		m _ n - 1 // 2.
		^ (self divisionPolynomial: m+2) * ((self divisionPolynomial: m) ^ 3) - (self divisionPolynomial"! !

!EllipticCurve methodsFor: 'operations' stamp: 'len 1/8/2017 20:55:09'!
divisionPolynomials
	"Answer the sequence of division polynomials.
	Reference: Silverman, 'The Arithmetic of Elliptic Curves', Exercise 3.7, pag. 105."
	| R x y phi1 phi2 phi3 phi4 a1 a3 b2 b4 b6 b8 |
	R _ self scalars polynomialsIn: #(x y). x _ R x. y _ R y.
	a1 _ self equation a1.
	a3 _ self equation a3.
	b2 _ self equation b2.
	b4 _ self equation b4.
	b6 _ self equation b6.
	b8 _ self equation b8.
	phi1 _ R one.
	phi2 _ y*2 + (a1 * x) + a3.
	phi3 _ x^4 * 3 + (x^3 * b2) + (x^2 * 3 * b4) + (x * 3 * b6) + b8.
	phi4 _ phi2 * (x^6 * 2 + (x^5 * b2) + (x^4 * b4 * 5) + (x^3 * 10 * b6) + (x^2 * 10 * b8) + (x * (b2 * b8 - (b4 * b6))) + (b4 * b8 - b6 squared)).
	^ Sequence to: R initialValues: {phi1. phi2. phi3. phi4} recurrence: [:phi :n|
		| m |
		n odd
			ifTrue:
				[m _ n - 1 // 2.
				(phi at: m+2) * ((phi at: m) ^ 3) - ((phi at: m - 1) * ((phi at: m + 1) ^ 3))]
			ifFalse:
				[m _ n // 2.
				(phi at: m-1) squared * (phi at: m) * (phi at: m+2) - ((phi at: m-2) * (phi at: m) * (phi at: m+1) squared // phi2)]]! !

!EllipticCurve methodsFor: 'operations' stamp: 'len 1/8/2017 21:07:11'!
multiplicationBy: m
	| F f omega phi psi x |
	psi _ self divisionPolynomials.
	f _ psi at: m.
	x _ psi codomain x.
"	y _ psi codomain y."
	F _ self ambient functionField.
	phi _ x * f squared - ((psi at: m+1) * (psi at: m-1)).
	omega _ (psi at: m+2) * (psi at: m-1) squared - ((psi at: m-2) * (psi at: m+1) squared).
	f _ f value: {F x. F y}.
	omega _ (omega value: {F x. F y}) / (F y * 4).
	phi _ phi value: {F x. F y}.
	^ "self from: self to: self representatives:" {phi / f squared. omega / (f^3). F z}! !

!EllipticCurve methodsFor: 'points' stamp: 'len 5/2/2018 18:15:00'!
pointAt: aTuple
	aTuple size = 2 ifTrue: [^ EllipticCurvePoint on: self coordinates: (aTuple copyWith: aTuple scalars one)].
	^ EllipticCurvePoint on: self coordinates: aTuple! !

!EllipticCurve methodsFor: 'points' stamp: 'len 8/27/2018 22:25:47'!
pointAtRandom: aRandom
	"Answer randomly a point of the receiver. Assume the scalars are a finite field."
	| points |
	[(points _ self pointsAtX: (self scalars atRandom: aRandom)) isEmpty] whileTrue.
	^ points atRandom: aRandom! !

!EllipticCurve methodsFor: 'points' stamp: 'len 8/27/2018 22:08:06'!
pointsAtX: x
	"Answer the points with x coordinate as given by the argument."
	| P |
	P _ self scalars polynomials.
	^ (self polynomial value: {P !! x. P x. P one}) roots collect: [:y| self pointAt: (x,y)]! !

!EllipticCurve methodsFor: 'points' stamp: 'len 12/22/2016 23:19:49'!
pointsOver: aField
	"Answer the group of K-rational points on the receiver."
	^ EllipticCurveGroup on: self over: aField! !

!EllipticCurve methodsFor: 'testing' stamp: 'len 10/25/2016 14:11'!
isSmooth
	^ self discriminant isZero not! !

!EllipticCurve methodsFor: 'private' stamp: 'len 11/10/2016 09:45'!
divisionPolynomial0: n at: x
	"Answer the n-th division polynomial, without the 2-torsion factor if n is even, evaluated at x."
	n = -2 ifTrue: [^ (self divisionPolynomial: -1 at: x) squared].
	n = -1 ifTrue: [^ x^3 * 4 + (x^2 * equation b2) + (x * equation b4 * 2) + equation b6].
	n <= 0 ifTrue: [DomainError signal].
	(n = 1 or: [n = 2]) ifTrue: [^ x one].
	n = 3 ifTrue: [^ x^4 + (x^3 * equation b2) + (x^2 * equation b4 * 3) + (x * equation b6 * 3) + equation b8].
	n = 4 ifTrue: [^ (x^2 * 6 + (x * equation b2) + equation b4) * (self divisionPolynomial: 3 at: x) + (self divisionPolynomial: -2 at: x)].
	^ n even
		ifTrue:
			[| m |
			m _ n - 2 // 2.
			(self divisionPolynomial: m+1 at: x) *
			((self divisionPolynomial: m at: x)^2 * (self divisionPolynomial: m+3 at: x) -
			((self divisionPolynomial: m+2 at: x)^2 * (self divisionPolynomial: m-1 at: x)))]
		ifFalse:
			[| m |
			m _ n - 1 // 2.
			m even
				ifTrue: [(self divisionPolynomial: m at: x)^3 * (self divisionPolynomial: -2 at: x) * (self divisionPolynomial: m+2 at: x) - ((self divisionPolynomial: m+1 at: x)^3 * (self divisionPolynomial: m-1 at: x))]
				ifFalse: [(self divisionPolynomial: m at: x)^3 * (self divisionPolynomial: m+2 at: x) - ((self divisionPolynomial: m+1 at: x)^3 * (self divisionPolynomial: m-1 at: x) * (self divisionPolynomial: -2 at: x))]]! !

!EllipticCurve class methodsFor: 'examples' stamp: 'len 5/22/2018 22:50:35'!
cremona11a1
	"Elliptic curve 11a1, first curve in the Cremona database."
	^ EllipticCurve coefficients: (0,-1,1,-10,-20)! !

!EllipticCurve class methodsFor: 'examples' stamp: 'len 5/22/2018 22:50:41'!
cremona11a2
	"Elliptic curve 11a2 from the Cremona database."
	^ EllipticCurve coefficients: (0,-1,1,-7820,-263580)! !

!EllipticCurve class methodsFor: 'examples' stamp: 'len 5/22/2018 22:50:46'!
cremona11a3
	"Elliptic curve 11a3 from the Cremona database."
	^ EllipticCurve coefficients: (0,-1,1,0,0)! !

!EllipticCurve class methodsFor: 'examples' stamp: 'len 5/22/2018 22:50:50'!
cremona37a
	"Elliptic curve 37a from the Cremona database.
	This is the elliptic curve of rank 1 with smallest conductor."
	^ EllipticCurve coefficients: (0,0,1,-1,0)! !

!EllipticCurve class methodsFor: 'examples' stamp: 'len 5/22/2018 22:50:54'!
cremona389a1
	"Elliptic curve 389a1 from the Cremona database."
	^ EllipticCurve coefficients: (0,1,1,-2,0)! !

!EllipticCurve class methodsFor: 'examples' stamp: 'len 8/24/2018 20:06:52'!
secp256k1
	"Answer the SECP256K1 elliptic curve, used by Bitcoin.
	The group of this curve has order 115792089237316195423570985008687907852837564279074904382605163141518161494337."
	| F |
	F _ PrimeField new: 16rFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F.
	^ self coefficients: ((0,0,0,0,7) over: F)! !

!EllipticCurve class methodsFor: 'instance creation' stamp: 'len 11/9/2016 15:12'!
coefficients: aTuple
	^ self equation: (WeierstrassEquation coefficients: aTuple)! !

!EllipticCurve class methodsFor: 'instance creation' stamp: 'len 11/9/2016 13:10'!
equation: aWeierstrassEquation
	^ self new equation: aWeierstrassEquation! !

!ProjectiveSpace methodsFor: 'accessing' stamp: 'len 8/27/2016 19:03'!
ambient
	^ self! !

!ProjectiveSpace methodsFor: 'accessing' stamp: 'len 10/20/2016 04:11'!
dimension
	^ self coordinateRing dimension - 1! !

!ProjectiveSpace methodsFor: 'accessing' stamp: 'len 1/5/2017 07:58:07'!
gradings
	"Answer the gradings of the coordinate ring of the receiver.
	When all the gradings are 1 this is ordinary projective space, otherwise it is a weighted (or graded) projective space."
	^ self coordinateRing gradings! !

!ProjectiveSpace methodsFor: 'accessing' stamp: 'len 1/13/2017 17:05:53'!
ideal
	"Answer the defining ideal of the receiver, considered as a subscheme of itself."
	^ self coordinateRing zeroIdeal! !

!ProjectiveSpace methodsFor: 'accessing' stamp: 'len 10/20/2016 16:19'!
rank
	^ self coordinateRing rank! !

!ProjectiveSpace methodsFor: 'morphisms' stamp: 'len 12/30/2016 20:22:12'!
automorphisms
	"Answer the group of automorphisms PGL(P), i.e. the linear automorphisms. These are the only regular automorphisms.
	Note that there are more rational automorphisms, the Cremona maps, but they are not included in this group. In the projective plane, the group of birational automorphisms is generated by the linear automorphisms plus the standard quadratic transformation (that takes each coordinate to its reciprocal xi -> 1/xi)."
	self notYetImplemented! !

!ProjectiveSpace methodsFor: 'morphisms' stamp: 'len 12/30/2016 20:33:30'!
quadraticMap
	"Answer the standard quadratic map that takes each coordinate to its reciprocal.
	This is a birational automorphism. In the projective plane, this automorphism together with the linear automorphisms of PGL generate the group of birational automorphisms."
	^ self to: self evaluating: [:x| x apply: [:each| each reciprocal]]! !

!ProjectiveSpace methodsFor: 'morphisms' stamp: 'len 1/9/2017 21:31:38'!
veronese: degree
	"Answer the Veronese map of the given degree from the receiver."
	| F monomials |
	F _ self functionField.
	monomials _ (F integers allMonomialsOfDegree: degree) collect: [:each| F embed: each].
	^ RationalMap from: self to: (ProjectiveSpace new: monomials size - 1 over: self scalars) representatives: monomials! !

!ProjectiveSpace methodsFor: 'operations' stamp: 'len 12/31/2017 13:41:35'!
 aProjectiveSpace
	"Answer the cartesian product of the receiver and the argument."
	(aProjectiveSpace isKindOf: ProjectiveSpace)
		ifFalse: [^ super  aProjectiveSpace].
	^ ProductProjectiveSpace components: {self. aProjectiveSpace}! !

!ProjectiveSpace methodsFor: 'operations' stamp: 'len 1/11/2017 09:22:46'!
subscheme: anObject
	| I |
	I _ (anObject isKindOf: Ideal)
		ifTrue: [anObject] ifFalse: [self coordinateRing * anObject].
	^ (self coordinateRing / I) proj! !

!ProjectiveSpace methodsFor: 'points' stamp: 'len 4/8/2018 18:21:48'!
pointsCountOver: aRing
	aRing isField ifTrue: [^ aRing isFinite ifTrue: [^ self rank choose: 1 q: aRing size] ifFalse: [aRing size]].
	aRing isFinite ifFalse: [^ aRing size].
	(aRing isKindOf: ModularIntegerRing)
		ifTrue:
			[^ aRing modulus ^ (self rank - 1) * (aRing modulus factors asSet product: [:p| (0 to: self rank - 1) sum: [:i| 1 / (p^i)]])].
	^ super pointsCountOver: aRing! !

!ProjectiveSpace methodsFor: 'points' stamp: 'len 5/2/2019 09:52:48'!
pointsOver: aRing do: aBlock
	aRing isField ifTrue: [^ self pointsOverField: aRing do: aBlock].
	(aRing isKindOf: RationalIntegerRing)
		ifTrue: [^ self pointsOverIntegersDo: aBlock].
	self pointsOverRing: aRing do: aBlock! !

!ProjectiveSpace methodsFor: 'points-private' stamp: 'len 5/3/2018 02:49:22'!
pointsOverField: aRing do: aBlock
	| one zero |
	one _ aRing one.
	zero _ aRing zero.
	aRing ^ (self rank - 1) do: [:each|
		(each isZero not and: [(each at: each lastNonZero) = one])
			ifTrue: [aBlock value: (self pointAt: each, zero)].
		aBlock value: (self pointAt: (each, one))].! !

!ProjectiveSpace methodsFor: 'points-private' stamp: 'len 5/2/2019 10:08:33'!
pointsOverIntegersDo: aBlock
	self notYetImplemented! !

!ProjectiveSpace methodsFor: 'points-private' stamp: 'len 5/2/2019 10:09:22'!
pointsOverRing: aRing do: aBlock
	self notYetImplemented! !

!ProjectiveSpace methodsFor: 'testing' stamp: 'len 1/5/2017 07:59:24'!
isOrdinaryProjectiveSpace
	"Answer true if the receiver is the ordinary projective space, which means that it's not weighted (or that all weights or gradings are 1)."
	^ self coordinateRing gradings allSatisfy: [:each| each = 1]! !

!ProjectiveSpace methodsFor: 'testing' stamp: 'len 2/22/2017 07:55:14'!
isPlane
	^ self rank = 3! !

!ProjectiveSpace methodsFor: 'testing' stamp: 'len 1/13/2017 17:07:33'!
satisfies: aTuple
	^ true! !

!ProjectiveSpace methodsFor: 'private' stamp: 'len 1/12/2017 14:47:56'!
newPatch: i
	^ (self coordinateRing copyWithout: i) spec! !

!ProjectiveSpace methodsFor: 'private' stamp: 'len 1/13/2017 17:23:38'!
saturated
	^ self! !

!ProjectiveSpace class methodsFor: 'examples' stamp: 'len 5/17/2018 19:02:08'!
example1
	"The rational projective plane:"
	^ ProjectiveSpace new: 2 over: QQ! !

!ProjectiveSpace class methodsFor: 'examples' stamp: 'len 5/17/2018 19:02:21'!
example2
	"Or assigning names to the indeterminates of the homogeneous coordinate ring:"
	^ ProjectiveSpace new: #(x y z) over: QQ! !

!ProjectiveSpace class methodsFor: 'examples' stamp: 'len 5/17/2018 19:02:44'!
example3
	"And equivalently:"
	^ (QQ polynomialsIn: #(x y z)) proj! !

!ProjectiveSpace class methodsFor: 'instance creation' stamp: 'len 1/12/2017 14:39:20'!
coordinateRing: aPolynomialRing
	^ (aPolynomialRing rank = 1 ifTrue: [ProjectiveLine] ifFalse: [self]) new coordinateRing: aPolynomialRing! !

!ProjectiveSpace class methodsFor: 'instance creation' stamp: 'len 10/31/2016 13:27'!
new: rank over: aRing
	^ self coordinateRing:
		(rank isInteger
			ifTrue: [aRing polynomialsIn: rank+1]
			ifFalse: [aRing polynomialsIn: rank])! !

!ProjectiveLine methodsFor: 'accessing' stamp: 'len 12/4/2016 22:26:45'!
infinity
	| R |
	R _ self scalars.
	^ self pointAt: (R tuple: {R one. R zero})! !

!ProjectiveLine methodsFor: 'accessing' stamp: 'len 12/4/2016 22:26:35'!
one
	| R |
	R _ self scalars.
	^ self pointAt: (R tuple: {R one. R one})! !

!ProjectiveLine methodsFor: 'accessing' stamp: 'len 12/4/2016 22:26:25'!
zero
	| R |
	R _ self scalars.
	^ self pointAt: (R tuple: {R zero. R one})! !

!ProjectiveLine methodsFor: 'elements' stamp: 'len 9/15/2018 17:43:33'!
!! anObject
	(self scalars includes: anObject) ifTrue: [^ self embed: anObject].
	^ super !! anObject! !

!ProjectiveLine methodsFor: 'morphisms' stamp: 'len 12/5/2016 10:27:31'!
embed: anElement
	^ self pointAt: (self scalars tuple: {anElement. self scalars one})! !

!ProjectiveLine methodsFor: 'morphisms' stamp: 'len 5/13/2019 19:01:07'!
from: aDomain
	aDomain = self scalars ifTrue: [^ self addMap: (self scalars to: self evaluating: [:each| self embed: each])].
	aDomain -> self scalars ifNotNil: [:aMorphism| ^ aMorphism -> self].
	^ super from: aDomain! !

!ProjectiveLine methodsFor: 'points' stamp: 'len 12/5/2016 10:24:19'!
pointAt: aTuple
	^ ProjectiveLinePoint on: self coordinates: aTuple! !

!ProjectiveLine methodsFor: 'points-private' stamp: 'len 5/2/2019 10:07:26'!
pointsOverRing: aRing do: aBlock
	| visited |
	visited _ Set new.
	aRing do: [:a| aRing do: [:b|
		| point |
		(aRing anySatisfy: [:c| aRing anySatisfy: [:d| aRing isUnit: a*d - (c*b)]])
			ifTrue: [visited add: (point _ self pointAt: (aRing tuple: {a. b})) ifAbsent: [aBlock value: point]]]]! !

!ProjectiveLine class methodsFor: 'instance creation' stamp: 'len 12/4/2016 22:07:23'!
over: aRing
	^ self coordinateRing: (aRing polynomialsIn: #(x y))! !

!ProjectivePlane methodsFor: 'accessing' stamp: 'len 9/22/2018 18:57:41'!
order
	self scalars isGaloisField ifTrue: [^ self scalars degree].
	^ self notYetImplemented! !

!ProjectivePlane class methodsFor: 'instance creation' stamp: 'len 9/16/2018 16:07:45'!
over: aRing
	^ self coordinateRing: (aRing polynomialsIn: #(x y z))! !

!ProductProjectiveSpace methodsFor: 'accessing' stamp: 'len 2/10/2017 08:52:44'!
arity
	^ self components size! !

!ProductProjectiveSpace methodsFor: 'accessing' stamp: 'len 2/10/2017 08:51:32'!
at: anInteger
	^ self components at: anInteger! !

!ProductProjectiveSpace methodsFor: 'accessing' stamp: 'len 5/14/2019 20:48:05'!
coordinateRing
	^ self propertyAt: #coordinateRing ifAbsentPut: [self components fold: [:A :B| A coordinateRing  B coordinateRing]]! !

!ProductProjectiveSpace methodsFor: 'accessing-private' stamp: 'len 2/10/2017 08:33:40'!
components
	^ self propertyAt: #components! !

!ProductProjectiveSpace methodsFor: 'accessing-private' stamp: 'len 2/10/2017 08:32:52'!
components: anArray
	self propertyAt: #components put: anArray! !

!ProductProjectiveSpace methodsFor: 'as yet unclassified' stamp: 'len 5/17/2018 17:01:34'!
segreEmbedding
	"Answer the Segre embedding into a projective space."
	self notYetImplemented! !

!ProductProjectiveSpace methodsFor: 'testing' stamp: 'len 2/10/2017 09:03:30'!
isProduct
	^ true! !

!ProductProjectiveSpace class methodsFor: 'instance creation' stamp: 'len 2/10/2017 08:32:33'!
components: anArray
	^ self new components: anArray! !

!ProductProjectiveSpace class methodsFor: 'instance creation' stamp: 'len 2/10/2017 08:43:58'!
new: anArray over: aRing
	^ self components: (anArray collect: [:each| ProjectiveSpace new: each over: aRing])! !

!LinearCode methodsFor: 'accessing' stamp: 'len 5/23/2016 19:28'!
ambient
	"Answer the ambient vector space."
	^ self asVectorSpace ambient! !

!LinearCode methodsFor: 'accessing' stamp: 'len 11/21/2016 14:00:50'!
completeWeightEnumerator
	"Answer the complete weight enumerator polynomial."
	| F P |
	F _ self ambient scalars elements asArray.
	P _ ZZ polynomialsIn: F size.
	^ self elements sum: [:each| P monomial: (P monomials exponents: (F collect: [:i| each occurrencesOf: i]))]! !

!LinearCode methodsFor: 'accessing' stamp: 'len 5/12/2016 07:19'!
dimension
	^ self rank! !

!LinearCode methodsFor: 'accessing' stamp: 'len 10/9/2016 09:06'!
distance
	"Answer the Hamming distance function."
	| k V |
	k _ self dimension.
	V _ self ambient.
	^ (V, V) to: ZZ evaluating: [:xy| | x y | x _ V coordinatesOf: xy first. y _ V coordinatesOf: xy second. (1 to: k) count: [:i| (x at: i) ~= (y at: i)]]! !

!LinearCode methodsFor: 'accessing' stamp: 'len 3/19/2018 19:37:35'!
generatorMatrix
	^ self asVectorSpace matrix! !

!LinearCode methodsFor: 'accessing' stamp: 'len 5/23/2016 04:38'!
length
	"Answer the length of a codeword."
	^ self ambient dimension! !

!LinearCode methodsFor: 'accessing' stamp: 'len 12/28/2016 11:32:15'!
minimumDistance
	"Answer the minimum Hamming distance between codewords.
	If the minimum distance is d, the code can correct (d-1)/2 errors."
	^ self propertyAt: #minimumDistance ifAbsentPut: [self computeMinimumDistance]! !

!LinearCode methodsFor: 'accessing' stamp: 'len 5/12/2016 10:12'!
parityCheckMatrix
	^ self dual generatorMatrix! !

!LinearCode methodsFor: 'accessing' stamp: 'len 5/12/2016 07:19'!
rank
	^ self asVectorSpace dimension! !

!LinearCode methodsFor: 'accessing' stamp: 'len 4/3/2016 23:08'!
rate
	^ (self size log: 2) / self length! !

!LinearCode methodsFor: 'accessing' stamp: 'len 2/15/2016 20:33'!
relativeDistance
	^ self minimumDistance / self length! !

!LinearCode methodsFor: 'accessing' stamp: 'len 5/12/2016 07:08'!
size
	"Answer the number of codewords."
	^ self asVectorSpace size! !

!LinearCode methodsFor: 'accessing' stamp: 'len 12/3/2016 09:12:28'!
weight
	"Answer the Hamming weight function."
	| V |
	V _ self ambient.
	^ Function from: V to: ZZ evaluating: [:x| (V coordinatesOf: x) weight]! !

!LinearCode methodsFor: 'accessing' stamp: 'len 2/15/2016 20:44'!
weightDistribution
	| answer w |
	w _ self weight.
	answer _ Bag new.
	self do: [:each| answer add: (w value: each)].
	^ answer! !

!LinearCode methodsFor: 'accessing' stamp: 'len 1/1/2016 00:06'!
weightDistribution: aCodeword
	"Answer the weight distribution wrt aCodeword."
	self notYetImplemented! !

!LinearCode methodsFor: 'accessing' stamp: 'len 7/15/2016 18:27'!
weightEnumerator
	"Answer the Hamming weight enumerator polynomial."
	| P x y weights answer n |
	P _ ZZ polynomialsIn: #(x y).
	x _ P x.
	y _ P y.
	answer _ P zero.
	n _ self ambient dimension.
	weights _ self weightDistribution.
	weights asSet do: [:i| answer _ x ^ (n - i) * (y ^ i) * (weights occurrencesOf: i) + answer].
	^ answer! !

!LinearCode methodsFor: 'accessing-private' stamp: 'len 1/1/2016 06:35'!
subspace: aLinearSubspace
	subspace _ aLinearSubspace! !

!LinearCode methodsFor: 'comparing' stamp: 'len 4/3/2016 23:27'!
<= aLinearCode
	^ self asVectorSpace <= aLinearCode asVectorSpace! !

!LinearCode methodsFor: 'comparing' stamp: 'len 4/3/2016 23:25'!
= aLinearCode
	^ (aLinearCode isKindOf: LinearCode) and: [self asVectorSpace = aLinearCode asVectorSpace]! !

!LinearCode methodsFor: 'comparing' stamp: 'len 4/3/2016 23:25'!
hash
	^ self asVectorSpace hash! !

!LinearCode methodsFor: 'converting' stamp: 'len 5/20/2018 15:59:14'!
asLattice
	"A linear code in a finite field or ring can be lifted to a lattice."
	| S F lift |
	S _ self asVectorSpace.
	F _ S scalars.
	lift _ S to: (S apply: F projection section) evaluating: [:each| each apply: F section].
	^ Lattice basis: (S basis apply: lift)! !

!LinearCode methodsFor: 'converting' stamp: 'len 3/31/2016 02:33'!
asVectorSpace
	^ subspace! !

!LinearCode methodsFor: 'enumerating' stamp: 'len 5/12/2016 07:08'!
do: aBlock
	self asVectorSpace do: aBlock! !

!LinearCode methodsFor: 'graphs' stamp: 'len 11/16/2016 10:08'!
distanceGraph: d
	"Answer the graph of the codewords of the receiver, with two codewords adjacent if their Hamming distance is d."
	| h G |
	h _ self distance. "the Hamming distance function"
	G _ Graph unordered.
	self elements do: [:x|
		self elements do: [:y|
			(h value: {x.y}) = d
				ifTrue: [G addEdgeFrom: x to: y]]].
	^ G! !

!LinearCode methodsFor: 'graphs' stamp: 'len 4/5/2018 15:27:59'!
tannerGraph
	| matrix G |
	matrix _ self parityCheckMatrix.
	G _ Graph unordered.
	1 to: matrix height do: [:i|
		1 to: matrix width do: [:j|
			(matrix at: i@j) isZero not
				ifTrue:
					[| subcode digit |
					subcode _ matrix rowAt: i.
					digit _ matrix columnAt: j.
					G addEdgeFrom: subcode to: digit]]].
	^ G! !

!LinearCode methodsFor: 'morphisms' stamp: 'len 4/20/2016 20:56'!
automorphisms
	"Answer the subgroup of Perm(F^k) (permutation of coordinates) that leave the receiver invariant.
	The automorphisms of a code and it's dual are the same."
	self notYetImplemented! !

!LinearCode methodsFor: 'morphisms' stamp: 'len 2/15/2016 20:26'!
isometries
	"Answer the subgroup of Iso(F^k) that leave the receiver invariant."
	self notYetImplemented! !

!LinearCode methodsFor: 'operations' stamp: 'len 5/12/2016 07:07'!
dual
	"Answer the dual or orthogonal code of the receiver."
	^ LinearCode subspace: self asVectorSpace perp! !

!LinearCode methodsFor: 'random' stamp: 'len 5/12/2016 09:59'!
atRandom: aRandom bits: bitSize
	^ self asVectorSpace atRandom: aRandom bits: bitSize! !

!LinearCode methodsFor: 'testing' stamp: 'len 5/12/2016 07:08'!
includes: aCodeword
	^ self asVectorSpace includes: aCodeword! !

!LinearCode methodsFor: 'testing' stamp: 'len 5/18/2016 06:28'!
isCyclic
	"A code is called a cylic code if for each codeword (c1,...,cn) it also contains the cyclic right shifted word (cn,c1,c2,...,cn-1), i.e. the code is invariant under cylic shifts."
	self do: [:each| (self includes: (each wrap: 1)) ifFalse: [^ false]].
	^ true! !

!LinearCode methodsFor: 'testing' stamp: 'len 5/12/2016 07:30'!
isMaximumDistanceSeparable
	"Any linear [n,k,d] code satisfies k + d <= n + 1 (Singleton bound). If a code satisfies k + d = n + 1 it's called Maximum Distance Separable (MDS)."
	| n k d |
	n _ self length.
	k _ self rank.
	d _ self minimumDistance.
	^ k + d = (n + 1)! !

!LinearCode methodsFor: 'testing' stamp: 'len 5/23/2016 04:38'!
isSelfDual
	self ambient dimension even ifFalse: [^ false].
	self dimension = (self ambient dimension / 2) ifFalse: [^ false].
	^ self = self dual! !

!LinearCode methodsFor: 'testing' stamp: 'len 4/3/2016 23:20'!
isSelfOrthogonal
	^ self asVectorSpace <= self dual asVectorSpace! !

!LinearCode methodsFor: 'private' stamp: 'len 2/15/2016 20:35'!
computeMinimumDistance
	| answer w |
	answer _ Infinity positive.
	w _ self weight.
	self do: [:each| each isZero ifFalse: [answer _ answer min: (w value: each)]].
	^ answer! !

!LinearCode class methodsFor: 'examples' stamp: 'len 1/25/2018 22:40:25'!
G11
	"Answer the perfect ternary Golary code [11,6,5]."
	^ self matrix:
		(Matrix rows: {
			(1,0,0,0,0,0, 1,1,1,1,1) % 3.
			(0,1,0,0,0,0, 0,1,2,2,1) % 3.
			(0,0,1,0,0,0, 1,0,1,2,2) % 3.
			(0,0,0,1,0,0, 2,1,0,1,2) % 3.
			(0,0,0,0,1,0, 2,2,1,0,1) % 3.
			(0,0,0,0,0,1, 1,2,2,1,0) % 3})! !

!LinearCode class methodsFor: 'examples' stamp: 'len 1/25/2018 22:41:28'!
G12
	"Answer the extended ternary Golary code [12,6,6]."
	^ self matrix:
		(Matrix rows: {
			(1,0,0,0,0,0, 0,1,1,1,1,1) % 3.
			(0,1,0,0,0,0, 1,0,1,2,2,1) % 3.
			(0,0,1,0,0,0, 1,1,0,1,2,2) % 3.
			(0,0,0,1,0,0, 1,2,1,0,1,2) % 3.
			(0,0,0,0,1,0, 1,2,2,1,0,1) % 3.
			(0,0,0,0,0,1, 1,1,2,2,1,0) % 3})! !

!LinearCode class methodsFor: 'examples' stamp: 'len 5/30/2019 07:04:04'!
G24
	"Answer the extended binary Golary code [24,12,8].
	Its generator matrix is I|A, where I is the 12x12 identity matrix and A is the complement of the adjacency matrix of the icosahedron."
	| F A |
	F _ ZZ/2.
	A _ Graph icosahedron adjacencyMatrix: (1 to: 12).
	A _ A apply: (Function from: A scalars to: F evaluating: [:x| x = 0 ifTrue: [F one] ifFalse: [F zero]]).
	^ self matrix: (A identity columnAugmented: A)! !

!LinearCode class methodsFor: 'examples' stamp: 'len 1/25/2018 22:42:38'!
H7
	"Answer the [7,4,3] Hamming code, which is the binary cyclic code of length 7 with generator polynomial 1 + x + x^3."
	| generators c |
	generators _ OrderedCollection with: (c _ (1,1,0,1,0,0,0) % 2).
	3 timesRepeat: [generators add: (c _ c >> 1)].
	^ self matrix: (Matrix rows: generators)! !

!LinearCode class methodsFor: 'examples' stamp: 'len 1/25/2018 22:43:18'!
H8
	"Answer the extended Hamming code [8,4,4]."
	^ self matrix:
		(Matrix rows: {
			(1,0,0,0, 0,1,1,1) % 2.
			(0,1,0,0, 1,0,1,1) % 2.
			(0,0,1,0, 1,1,0,1) % 2.
			(0,0,0,1, 1,1,1,0) % 2})! !

!LinearCode class methodsFor: 'examples' stamp: 'len 1/25/2018 22:43:55'!
hadamard8
	"Answer the [8,3,4] Hadamard code."
	^ self matrix:
		(Matrix rows: {
			(0,0,0,0,1,1,1,1) % 2.
			(0,0,1,1,0,0,1,1) % 2.
			(0,1,0,1,0,1,0,1) % 2})! !

!LinearCode class methodsFor: 'examples' stamp: 'len 1/25/2018 22:44:29'!
simplex
	"Answer the [7,3,4] simplex code, which is the dual code of the Hamming code."
	^ self matrix:
		(Matrix rows: {
			(0,0,0,1,1,1,1) % 2.
			(0,1,1,0,0,1,1) % 2.
			(1,0,1,0,1,0,1) % 2})! !

!LinearCode class methodsFor: 'examples' stamp: 'len 5/25/2018 18:44:12'!
tetracode
	"Answer the tetracode, a self dual code of minimum distance 3."
	^ self subspace: ((ZZ/3)^4 span: {(1,1,1,0) % 3. (0,1,2,1) % 3})! !

!LinearCode class methodsFor: 'instance creation' stamp: 'len 1/1/2016 06:02'!
matrix: aMatrix
	"Answer a linear code with generator matrix aMatrix."
	^ self subspace: aMatrix rowSpace! !

!LinearCode class methodsFor: 'instance creation' stamp: 'len 1/1/2016 06:34'!
subspace: aLinearSubspace
	^ self new subspace: aLinearSubspace! !

!CyclicCode2 methodsFor: 'accessing' stamp: 'len 1/23/2017 11:31:35'!
checkPolynomial
	| x one |
	x _ generator parent x.
	one _ generator parent one.
	^ x ^ self length - one / generator! !

!CyclicCode2 methodsFor: 'accessing' stamp: 'len 5/18/2016 07:21'!
dimension
	^ self length - generator degree! !

!CyclicCode2 methodsFor: 'accessing' stamp: 'len 5/17/2016 21:02'!
generator
	^ generator! !

!CyclicCode2 methodsFor: 'accessing-private' stamp: 'len 5/18/2016 07:21'!
generator: aPolynomial
	generator _ aPolynomial.
"
	| n V g x |
	generator _ aPolynomialResidue.
	n _ generator modulus degree.
	V _ generator ispecies asVectorSpaceMaxDegree: n.
	basis _ LinearBasis on: V.
	g _ generator.
	x _ generator representative species x mod: generator modulus.
	[basis includes: g] whileFalse: [basis add: g. g _ g * x].
	self subspace: basis span"! !

!CyclicCode2 methodsFor: 'converting' stamp: 'len 10/29/2016 08:28'!
asIdeal
	^ generator asIdeal! !

!CyclicCode2 methodsFor: 'enumerating' stamp: 'len 5/18/2016 06:30'!
do: aBlock
	self asIdeal do: aBlock! !

!CyclicCode2 methodsFor: 'operations' stamp: 'len 5/18/2016 07:30'!
dual
	^ self class new: self length generator: self generator reversed! !

!CyclicCode2 methodsFor: 'testing' stamp: 'len 5/15/2019 01:42:52'!
includes: aCodeword
	| x |
	x _ generator parent x.
	^ (self checkPolynomial * aCodeword \\ (x ^ self length - x one)) isZero! !

!CyclicCode2 methodsFor: 'testing' stamp: 'len 5/18/2016 07:22'!
isIrreducible
	^ generator isIrreducible! !

!CyclicCode2 class methodsFor: 'examples-todo' stamp: 'len 5/25/2018 18:47:57'!
H7
	"Answer the Hamming code of length 7."
	^ self new: 7 generator: (ZZ/2) polynomials !! [:x| x^3 + x + 1]! !

!CyclicCode2 class methodsFor: 'instance creation' stamp: 'len 5/18/2016 07:20'!
new: n generator: aPolynomial
	| F |
	F _ aPolynomial scalars.
	^ (self new subspace: (F extension: aPolynomial) asVectorSpace) generator: aPolynomial! !

!PolynomialCode methodsFor: 'accessing' stamp: 'len 4/4/2016 20:19'!
generator
	^ generator! !

!PolynomialCode methodsFor: 'accessing' stamp: 'len 5/12/2016 07:20'!
rank
	^ self length - generator degree! !

!PolynomialCode methodsFor: 'accessing' stamp: 'len 1/23/2017 11:44:09'!
size
	^ generator parent scalars size ^ (self length - generator degree)! !

!PolynomialCode methodsFor: 'accessing-private' stamp: 'len 4/4/2016 20:19'!
generator: aPolynomial
	generator _ aPolynomial! !

!PolynomialCode methodsFor: 'encoding/decoding' stamp: 'len 5/12/2016 09:33'!
decode: aPolynomial
	self flag: #fix. "add error-detection and correction"
	^ aPolynomial // generator! !

!PolynomialCode methodsFor: 'encoding/decoding' stamp: 'len 5/12/2016 09:31'!
encode: aPolynomial
	| f |
	f _ aPolynomial shift: generator degree.
	^ f - (f \\ generator)! !

!PolynomialCode methodsFor: 'testing' stamp: 'len 5/12/2016 07:17'!
includes: aCodeword
	^ aCodeword | generator! !

!PolynomialCode methodsFor: 'testing' stamp: 'len 1/23/2017 11:44:04'!
isCyclic
	| n x |
	n _ self length.
	x _ generator parent x.
	^ generator | (x ^ n - x parent one)! !

!PolynomialCode class methodsFor: 'examples' stamp: 'len 5/25/2018 18:46:50'!
G23
	"Answer the perfect binary Golay code [23,12,7]."
	| g |
	g _ (ZZ/2) polynomials !! [:x| x^11 + (x^10) + (x^6) + (x^5) + (x^4) + (x^2) + 1].
	^ self new: 23 generator: g! !

!PolynomialCode class methodsFor: 'examples' stamp: 'len 5/25/2018 18:47:12'!
H7
	"Answer the Hamming code [7,4,3]."
	^ self new: 7 generator: (ZZ/2) polynomials !! [:x| x^3 + x + 1]! !

!PolynomialCode class methodsFor: 'instance creation' stamp: 'len 5/12/2016 07:42'!
generator: aPolynomial
	^ self new: aPolynomial degree generator: aPolynomial! !

!PolynomialCode class methodsFor: 'instance creation' stamp: 'len 3/29/2018 16:43:50'!
new: n generator: aPolynomial
	| V W subspace |
	V _ aPolynomial parent filtrationAt: n - 1.
	W _ aPolynomial parent filtrationAt: n - aPolynomial degree - 1.
	subspace _ V span: (W asArray collect: [:f| aPolynomial * f]).
	^ (self subspace: subspace) generator: aPolynomial! !

!CyclicCode methodsFor: 'as yet unclassified' stamp: 'len 1/23/2017 11:31:24'!
checkPolynomial
	| x one |
	x _ generator parent x.
	one _ generator parent one.
	^ x ^ self length - one / generator! !

!CyclicCode methodsFor: 'as yet unclassified' stamp: 'len 6/29/2016 22:18'!
dual
	^ self class new: self length generator: self generator reversed! !

!CyclicCode methodsFor: 'as yet unclassified' stamp: 'len 5/15/2019 01:42:35'!
includes: aCodeword
	| x |
	x _ generator parent x.
	^ (self checkPolynomial * aCodeword \\ (x ^ self length - x one)) isZero! !

!CyclicCode methodsFor: 'as yet unclassified' stamp: 'len 6/29/2016 22:18'!
isIrreducible
	^ generator isIrreducible! !

!SemistandardTableaux methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 02:31'!
alphabet
	^ alphabet! !

!SemistandardTableaux methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 02:32'!
alphabet: anArray
	alphabet _ anArray! !

!SemistandardTableaux methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 03:25'!
diagram
	^ YoungDiagram shape: shape! !

!SemistandardTableaux methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 03:29'!
shape
	^ shape! !

!SemistandardTableaux methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 03:29'!
shape: aPartition
	shape _ aPartition! !

!SemistandardTableaux class methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 03:28'!
alphabet: anArray shape: aPartition
	^ self new alphabet: anArray; shape: aPartition! !

!SemistandardTableaux class methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 03:28'!
new: anInteger shape: aPartition
	^ self alphabet: (1 to: anInteger) shape: aPartition! !

!StandardTableaux methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 03:24'!
size
	| answer Y |
	answer _ alphabet size factorial.
	Y _ self diagram.
	Y do: [:each|
		answer _ answer / (Y hookLengthAt: each)].
	^ answer
! !

!CellComplex methodsFor: 'accessing' stamp: 'len 2/15/2017 07:32:58'!
cells: n
	"Answer the set of n-cells of the receiver."
	^ Set accumulate: [:aBlock| self cells: n do: aBlock]! !

!CellComplex methodsFor: 'accessing' stamp: 'len 2/17/2017 16:51:20'!
vertices
	| answer |
	self propertyAt: #vertices ifPresent: [:aSet| ^ aSet].
	answer _ Set new.
	self facets do: [:each| answer addAll: each vertices].
	^ self propertyAt: #vertices put: answer! !

!CellComplex methodsFor: 'enumerating' stamp: 'len 2/15/2017 07:51:33'!
cells: n do: aBlock
	"Iterate over the n-cells of the receiver, possibly with repretitions.
	Subclasses should reimplement."
	^ self do: [:each| each dimension = n ifTrue: [aBlock value: each]]! !

!CellComplex methodsFor: 'homology' stamp: 'len 2/24/2017 12:53:20'!
boundaryMap: k over: aRing
	"The k-th boundary map or differential d(k) goes from C(k) to C(k-1).
	Its image is the group of (k-1)-boundaries B(k-1), a subgroup of C(k-1).
	Its kernel is the group of k-cycles Z(k), a subgroup of C(k)."
	^ (self chains: k over: aRing) to: (self chains: k-1 over: aRing) evaluating: [:x| x boundary]! !

!CellComplex methodsFor: 'homology' stamp: 'len 2/25/2017 07:13:30'!
chainComplexOver: aRing
	^ ChainComplex differentials: ((self dimension+1 to: 0 by: -1) collect: [:i| self boundaryMap: i over: aRing])! !

!CellComplex methodsFor: 'homology' stamp: 'len 12/31/2017 13:36:42'!
chains: k over: aRing
	"Answer the group of k-chains."
	k < 0 ifTrue: [^ aRing freeModuleIn: #()].
	^ aRing freeModuleIn: (self cells: k) asArray! !

!CellComplex methodsFor: 'invariants' stamp: 'len 2/19/2017 18:25:22'!
dimension
	self isVoid ifTrue: [^ Infinity negative].
	^ self max: [:each| each dimension]! !

!CellComplex methodsFor: 'invariants' stamp: 'len 2/15/2017 07:37:12'!
euler
	"Answer the Euler characteristic of the receiver."
	^ (0 to: self dimension) sum: [:p| -1^p * (self cells: p) size]! !

!CellComplex methodsFor: 'invariants' stamp: 'len 2/15/2017 15:46:13'!
fPolynomial
	"Answer the f-polynomial of this cell complex. This is the univariate polynomial with coefficients given by the f-vector (in decreasing order of exponents)."
	^ ZZ polynomials coefficients: self fVector reversed! !

!CellComplex methodsFor: 'invariants' stamp: 'len 2/15/2017 15:47:04'!
fVector
	"Answer the f-vector of this cell complex. This is a tuple of integers that count the number of cells of each dimension."
	^ ZZ tuple: self dimension + 2 evaluating: [:i| (self cells: i-2) size]! !

!CellComplex methodsFor: 'invariants' stamp: 'len 2/15/2017 15:48:40'!
gVector
	"Answer the g-vector of this cell complex."
	| h |
	h _ self hVector.
	^ ZZ tuple: h size // 2 + 1 evaluating: [:i| i == 1 ifTrue: [1] ifFalse: [(h at: i) - (h at: i-1)]]! !

!CellComplex methodsFor: 'invariants' stamp: 'len 5/5/2019 18:29:50'!
hPolynomial
	"Answer the h-polynomial of this cell complex. This is the result of composing the f-polynomial with 'x - 1'."
	| f x |
	f _ self fPolynomial.
	x _ f parent x.
	^ f  (x - 1)! !

!CellComplex methodsFor: 'invariants' stamp: 'len 2/15/2017 15:48:22'!
hVector
	"Answer the h-vector of this cell complex. This is the tuple of coefficients of the h-polynomial (in decreasing order of exponents)."
	^ self hPolynomial coefficients reversed! !

!CellComplex methodsFor: 'testing' stamp: 'len 2/25/2017 15:10:35'!
isTrivial
	"Answer true if this is the trivial complex, with only the empty cell."
	^ self size = 1! !

!CellComplex methodsFor: 'testing' stamp: 'len 2/25/2017 15:10:11'!
isVoid
	"Answer true if this is the void complex, that has no cells."
	^ self size = 0! !

!SimplicialComplex methodsFor: 'accessing' stamp: 'len 4/21/2016 04:37'!
edges
	^ self faces: 1! !

!SimplicialComplex methodsFor: 'accessing' stamp: 'len 11/30/2016 14:45:09'!
faces: m
	^ Set accumulate: [:aBlock| self faces: m do: aBlock]! !

!SimplicialComplex methodsFor: 'accessing' stamp: 'len 2/15/2017 08:29:11'!
facets
	"Answer the maximal faces of the receiver."
	^ self propertyAt: #facets! !

!SimplicialComplex methodsFor: 'accessing' stamp: 'len 2/19/2017 08:14:18'!
labelling
	"Answer a dictionary that associates a positive integer number to each vertex.
	For a simplicial complex with n vertices, the labels are 1,2,...,n."
	| V labelling |
	self propertyAt: #labelling ifPresent: [:aDictionary| ^ aDictionary].
	V _ self vertices.
	(V allSatisfy: [:each| each isInteger])
		ifTrue: [V _ V asSortedCollection]
		ifFalse: [V _ V asSortedCollection: [:a :b| a printString <= b printString]].
	labelling _ Dictionary new.
	1 to: V size do: [:each| labelling at: (V at: each) put: each].
	^ self propertyAt: #labelling put: labelling! !

!SimplicialComplex methodsFor: 'accessing' stamp: 'len 2/21/2017 18:59:14'!
nonfaces
	"Answer the set of minimal nonfaces, i.e. simpleces on the vertex set of the receiver which are not faces of the receiver."
	| answer V F |
	self isVoid ifTrue: [Set with: (Simplex vertices: #())].
	answer _ Set new.
	V _ self vertices asArray.
"	1 to: self vertices size do: [:k|"
	1 to: self dimension + 2 do: [:k|
		V combinations: k atATimeDo: [:combination|
			F _ Simplex vertices: combination copy.
			((self contains: F) not and: [answer noneSatisfy: [:none| F >= none]])
				ifTrue: [answer add: F]]].
	^ answer! !

!SimplicialComplex methodsFor: 'accessing' stamp: 'len 4/21/2016 04:38'!
ridges
	^ self faces: self dimension - 2! !

!SimplicialComplex methodsFor: 'accessing' stamp: 'len 2/20/2017 18:52:16'!
support
	"Answer the collection of vertices that belong to any face in the receiver."
	^ self vertices select: [:each| self facets anySatisfy: [:any| any includes: each]]! !

!SimplicialComplex methodsFor: 'accessing-private' stamp: 'len 2/15/2017 16:10:03'!
facets: aCollection
	self propertyAt: #facets put: aCollection! !

!SimplicialComplex methodsFor: 'accessing-private' stamp: 'len 2/24/2017 11:38:54'!
vertices: aCollection
	self propertyAt: #vertices put: aCollection asSet! !

!SimplicialComplex methodsFor: 'enumerating' stamp: 'len 2/15/2017 11:20:19'!
cells: n do: aBlock
	"Iterate over the n-cells of the receiver, possibly with repetitions."
	^ self faces: n do: aBlock! !

!SimplicialComplex methodsFor: 'enumerating' stamp: 'len 2/19/2017 08:22:20'!
collect: aBlock
	^ self species faces: (self elements collect: aBlock)! !

!SimplicialComplex methodsFor: 'enumerating' stamp: 'len 2/14/2017 20:00:17'!
do: aBlock
	-1 to: self dimension do: [:each| (self faces: each) do: aBlock]! !

!SimplicialComplex methodsFor: 'enumerating' stamp: 'len 2/15/2017 07:53:57'!
faces: n do: aBlock
	"Iterate over the n-cells of the receiver, possibly with repetitions."
	self facets do: [:each| each faces: n do: [:face| aBlock value: face]]! !

!SimplicialComplex methodsFor: 'enumerating' stamp: 'len 2/19/2017 10:19:29'!
select: aBlock
	^ self species on: self vertices faces: (self elements select: aBlock)! !

!SimplicialComplex methodsFor: 'homology' stamp: 'len 4/19/2019 04:45:04'!
boundaryMap: k over: aRing
	"The k-th boundary map or differential d(k) goes from C(k) to C(k-1).
	Its image is the group of (k-1)-boundaries B(k-1), a subgroup of C(k-1).
	Its kernel is the group of k-cycles Z(k), a subgroup of C(k)."

	"The boundary of a chain is the linear combination of the boundary of the simplices in the chain. The boundary of a k-chain is a (k-1)-chain."

	| domain codomain |
	domain _ self chains: k over: aRing.
	codomain _ self chains: k-1 over: aRing.
	k = 0 ifTrue: [^ (domain => codomain) zero].
	^ domain to: codomain evaluating: [:x|
		| answer |
		answer _ codomain zero.
		x keysAndValuesDo: [:key :value|
			| V |
			V _ key vertices asArray.
			1 to: V size do: [:i| | F f |
				"F is the facet opposite the i-th vertex:"
				F _ Simplex vertices: (V copyWithoutIndex: i).
				f _ (codomain x: F) * value.
				i odd ifTrue: [answer _ answer + f] ifFalse: [answer _ answer - f]]].
		answer]! !

!SimplicialComplex methodsFor: 'homology' stamp: 'len 5/4/2019 03:50:32'!
chains: k over: aRing
	"Answer the group of k-chains."
	k < 0 ifTrue: [^ aRing freeModuleIn: #()].
	^ aRing freeModuleIn: (self cells: k) asArray! !

!SimplicialComplex methodsFor: 'invariants' stamp: 'len 2/19/2017 18:24:25'!
dimension
	self isVoid ifTrue: [^ Infinity negative].
	^ self facets max: [:each| each dimension]! !

!SimplicialComplex methodsFor: 'morphisms' stamp: 'len 5/13/2019 17:11:54'!
apply: aSimplicialMap
	"Answer the homomorphic image of the receiver."
	^ self species faces: (self facets collect: aSimplicialMap)! !

!SimplicialComplex methodsFor: 'morphisms' stamp: 'len 2/15/2017 11:08:01'!
to: aSimplicialComplex evaluating: aBlock
	^ SimplicialMap from: self to: aSimplicialComplex evaluating: aBlock! !

!SimplicialComplex methodsFor: 'morphisms' stamp: 'len 2/20/2017 18:42:06'!
to: aSimplicialComplex map: aDictionary
	"Answer a simplicial map that maps vertices by aDictionary."
	^ SimplicialMap from: self to: aSimplicialComplex map: aDictionary! !

!SimplicialComplex methodsFor: 'morphisms' stamp: 'len 2/20/2017 18:42:28'!
to: aSimplicialComplex mapping: aBlock
	"Answer a simplicial map that maps vertices by aBlock."
	^ SimplicialMap from: self to: aSimplicialComplex mapping: aBlock! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 2/19/2017 08:20:23'!
* aSimplicialComplex
	"Answer the join of the receiver with the argument."
	| join |
	join _ Set new.
	self facets do: [:each|
		aSimplicialComplex facets do: [:other| join add: each * other]].
	^ self species facets: join! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 2/15/2017 11:15:20'!
- aFace
	"Answer the deletion of a aFace, i.e. the simplicial complex obtained by removing aFace."
	^ self select: [:each| (each <= aFace) not]! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 2/15/2017 11:15:36'!
/ aFace
	"Answer the link of aFace. This is the complex of all faces of simplices in the star that do not intersect aFace."
	^ self notYetImplemented! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 5/10/2019 04:35:35'!
\/ aSimplicialComplex
	^ self species faces: self facets, aSimplicialComplex facets! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 12/29/2017 09:46:31'!
 aSimplicialComplex
	"Answer the direct product of the receiver and the argument."
	| product |
	product _ Set new.
	self facets do: [:each|
		aSimplicialComplex facets do: [:other|
			self pathsFrom: each vertices to: other vertices do: [:path|
				product add: (Simplex vertices: path)]]].
	^ self species faces: product! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 2/20/2017 19:12:40'!
 aSimplicialComplex
	"Answer the wedge product (one-point union) of the receiver with the argument."
	| v0 w0 facets |
	v0 _ self support anyOne.
	w0 _ aSimplicialComplex support anyOne.
	facets _ Set new.
	self facets do: [:each| facets add: (each collect: [:v| v = v0 ifTrue: [{0. 0}] ifFalse: [{1. v}]])].
	aSimplicialComplex facets do: [:each| facets add: (each collect: [:w| w = w0 ifTrue: [{0. 0}] ifFalse: [{2. w}]])].
	^ self species "on: vertices" facets: facets! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 2/19/2017 10:23:45'!
complement
	| V |
	V _ self vertices.
	^ self species on: V facets: (self facets collect: [:each| each complementIn: V])! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 2/15/2017 11:24:20'!
cone
	"Answer the join of the receiver with a new one-vertex simplicial complex."
	^ self * (self species facets: #((0)))! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 2/29/2016 08:25'!
coskeleton: n
	"Answer the n-coskeleton of the receiver."
	^ self notYetImplemented! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 2/19/2017 10:24:04'!
dual
	"Answer the Alexander dual of the receiver.
	This is the simplicial complex made of the complement of all faces *not* in the receiver, and it is generated by the complements of the minimal nonfaces."
	| V |
	V _ self vertices.
	^ self species on: V facets: (self nonfaces collect: [:each| each complementIn: V])! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 2/19/2017 10:14:10'!
facetIdeal
	"Answer the facet ideal of this simplicial complex.
	This is the ideal generated by those squarefree monomials associated to the maximal faces (facets) of the simplicial complex."
	^ self facetIdealIn: (QQ polynomialsIn: self vertices size)! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 2/19/2017 10:13:47'!
facetIdealIn: aRing
	"Answer the facet ideal of this simplicial complex in the given polynomial ring.
	This is the ideal generated by those squarefree monomials associated to the maximal faces (facets) of the simplicial complex."
	| labelling |
	labelling _ self labelling.
	^ aRing * (self facets collect: [:each|
		each vertices inject: aRing one into: [:g :v| g * (aRing x: (labelling at: v))]])! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 2/19/2017 10:18:29'!
openStarOf: aCollection
	"Answer the open star in the receiver of the simplices in aCollection.
	This is just a set of simplices, and not necesarily forms a complex."
	| answer |
	answer _ Set new.
	aCollection do: [:each|
		self do: [:other| (each intersects: other) ifTrue: [answer add: other]]].
	^ answer! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 2/15/2017 11:23:53'!
skeleton: n
	"Answer the n-skeleton of the receiver."
	^ self collect: [:each| each dimension <= n]! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 2/19/2017 10:14:16'!
stanleyReisnerIdeal
	"Answer the Stanley-Reisner ideal of this simplicial complex.
	This is the ideal generated by those squarefree monomials associated to nonfaces of the simplicial complex."
	^ self stanleyReisnerIdealIn: (QQ polynomialsIn: self vertices size)! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 2/19/2017 10:14:20'!
stanleyReisnerIdealIn: aRing
	"Answer the Stanley-Reisner ideal of this simplicial complex in the given polynomial ring.
	This is the ideal generated by those squarefree monomials associated to nonfaces of the simplicial complex."
	| labelling |
	labelling _ self labelling.
	^ aRing * (self nonfaces collect: [:each|
		each vertices inject: aRing one into: [:g :v| g * (aRing x: (labelling at: v))]])! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 2/18/2017 20:07:02'!
stanleyReisnerRing
	^ self stanleyReisnerRingOver: QQ! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 1/15/2018 22:23:09'!
stanleyReisnerRingOver: aRing
	^ (self stanleyReisnerIdealIn: (aRing polynomialsIn: self vertices size)) quotientRing! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 2/19/2017 10:19:06'!
starOf: aCollection
	"Answer the (closed) star in the receiver of the simplices in aCollection.
	This is the closure of the open star."
	^ self species on: self vertices faces: (self openStarOf: aCollection)! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 2/21/2017 11:57:55'!
suspension
	^ self * (self class sphere: 0)! !

!SimplicialComplex methodsFor: 'testing' stamp: 'len 2/15/2017 08:24:23'!
contains: aSimplex
	^ self facets anySatisfy: [:one| one >= aSimplex]! !

!SimplicialComplex methodsFor: 'testing' stamp: 'len 2/15/2017 08:23:17'!
includes: aSimplex
	^ (aSimplex isKindOf: Simplex) and: [self contains: aSimplex]! !

!SimplicialComplex methodsFor: 'testing' stamp: 'len 6/13/2016 16:29'!
isConnected
	^ (self skeleton: 1) asGraph isConnected! !

!SimplicialComplex methodsFor: 'testing' stamp: 'len 2/19/2017 18:22:52'!
isPure
	| d |
	d _ self dimension.
	^ self facets allSatisfy: [:each| each dimension = d]! !

!SimplicialComplex methodsFor: 'testing' stamp: 'len 2/25/2017 15:13:47'!
isTrivial
	"Answer true if this is the trivial complex, with only one face (the empty simplex)."
	^ self facets size = 1 and: [self facets allSatisfy: [:each| each isTrivial]]! !

!SimplicialComplex methodsFor: 'testing' stamp: 'len 2/19/2017 18:23:52'!
isVoid
	"Answer true if this is the void complex, that has no faces."
	^ self facets isEmpty! !

!SimplicialComplex methodsFor: 'private' stamp: 'len 12/29/2017 09:44:46'!
pathsFrom: A to: B do: aBlock
	| x |
	A isEmpty ifTrue: [^ aBlock value: {A}].
	B isEmpty ifTrue: [^ aBlock value: {B}].
	A size = 1 ifTrue:
		[| v |
		v _ A at: 1.
		^ B do: [:w| aBlock value: {{v. w}}]].
	B size = 1 ifTrue:
		[| w |
		w _ B at: 1.
		^ A do: [:v| aBlock value: {{v. w}}]].
	x _ {A last. B last}.
	self pathsFrom: A allButLast to: B do: [:each| aBlock value: (each copyWith: x)].
	self pathsFrom: A to: B allButLast do: [:each| aBlock value: (each copyWith: x)]! !

!SimplicialComplex methodsFor: 'private' stamp: 'len 2/15/2017 11:20:53'!
species
	^ SimplicialComplex! !

!SimplicialComplex class methodsFor: 'examples' stamp: 'len 2/14/2017 20:39:44'!
kleinBottle
	"A minimal triangulation of the Klein bottle."
	^ self facets: #((2 3 7) (1 2 3) (1 3 5) (1 5 7) (1 4 7) (2 4 6) (1 2 6) (1 6 0) (1 4 0) (2 4 0) (3 4 7) (3 4 6) (3 5 6) (5 6 0) (2 5 0) (2 5 7))! !

!SimplicialComplex class methodsFor: 'examples' stamp: 'len 2/14/2017 20:39:57'!
realProjectivePlane
	"A minimal triangulation of the real projective plane."
	^ self facets: #((0 1 2) (0 2 3) (0 1 5) (0 4 5) (0 3 4) (1 2 4) (1 3 4) (1 3 5) (2 3 5) (2 4 5))! !

!SimplicialComplex class methodsFor: 'examples' stamp: 'len 2/20/2017 08:37:36'!
sphere: n
	"A minimal triangulation of the n-sphere."
	^ self facets: ((Simplex new: n+1) faces: n)! !

!SimplicialComplex class methodsFor: 'examples' stamp: 'len 2/14/2017 20:40:24'!
torus
	"A minimal triangulation of the torus."
	^ self facets: #((0 1 2) (1 2 4) (1 3 4) (1 3 6) (0 1 5) (1 5 6) (2 3 5) (2 4 5) (2 3 6) (0 2 6) (0 3 4) (0 3 5) (4 5 6) (0 4 6))! !

!SimplicialComplex class methodsFor: 'instance creation' stamp: 'len 2/19/2017 08:21:09'!
faces: aCollection
	"Answer a new simplicial complex with the given collection of simplices as faces.
	The faces in aCollection are not assumed to be maximal, so we compute a subset of maximal faces (facets)."
	| faces maximalFaces |
	faces _ Set new: aCollection size.
	aCollection do: [:each|
		(each isKindOf: Simplex)
			ifTrue: [faces add: each]
			ifFalse: [faces add: (each as: Simplex)]].
	faces _ faces asSortedCollection: [:a :b| a dimension <= b dimension].
	maximalFaces _ Set new.
	1 to: faces size do: [:i| | face |
		face _ faces at: i.
		((i+1 to: faces size) anySatisfy: [:j| face <= (faces at: j)])
			ifFalse: [maximalFaces add: face]].
	^ self facets: maximalFaces! !

!SimplicialComplex class methodsFor: 'instance creation' stamp: 'len 2/15/2017 16:10:24'!
facets: aCollection
	"Answer a new simplicial complex with the given collection of simplices as facets.
	The faces in aCollection are assumed to be maximal."
	| facets |
	facets _ Set new: aCollection size.
	aCollection do: [:each|
		(each isKindOf: Simplex)
			ifTrue: [facets add: each]
			ifFalse: [facets add: (each as: Simplex)]].
	^ self new facets: facets! !

!SimplicialComplex class methodsFor: 'instance creation' stamp: 'len 2/24/2017 11:47:54'!
on: aVertexSet faces: aCollection
	"Answer a new simplicial complex with the given collection of simplices as faces.
	The faces in aCollection are not assumed to be maximal, so we compute a subset of maximal faces (facets)."
	^ (self faces: aCollection) vertices: aVertexSet! !

!SimplicialComplex class methodsFor: 'instance creation' stamp: 'len 2/24/2017 11:48:00'!
on: aVertexSet facets: aCollection
	"Answer a new simplicial complex with the given collection of simplices as facets.
	The faces in aCollection are assumed to be maximal."
	^ (self facets: aCollection) vertices: aVertexSet! !

!UpperHalfPlane methodsFor: 'testing' stamp: 'len 12/7/2016 12:11:09'!
includes: anObject
	^ anObject isComplex and: [anObject imaginary > 0]! !

!UpperHalfPlane class methodsFor: 'initialization' stamp: 'len 12/6/2016 22:07:33'!
initialize
	super initialize.
	Smalltalk at: #HH put: self new! !

!CoxeterSystem methodsFor: 'as yet unclassified' stamp: 'len 4/5/2018 15:27:04'!
computeDiagram
	| n graph |
	n _ matrix width.
	graph _ Graph unorderedLabeled.
	graph addAll: (1 to: n).
	1 to: n do: [:i|
		1 to: n do: [:j|
			| m |
			m _ matrix at: i@j.
			m = 3 ifTrue: [graph addEdgeFrom: i to: j label: nil].
			m > 3 ifTrue: [graph addEdgeFrom: i to: j label: m]]].
	^ graph! !

!CoxeterSystem methodsFor: 'as yet unclassified' stamp: 'len 4/18/2016 07:54'!
diagram
	^ diagram ifNil: [diagram _ self computeDiagram]! !

!CoxeterSystem methodsFor: 'as yet unclassified' stamp: 'len 4/18/2016 07:57'!
diagram: aGraph
	diagram _ aGraph! !

!CoxeterSystem methodsFor: 'as yet unclassified' stamp: 'len 4/18/2016 07:55'!
matrix
	^ matrix ifNil: [matrix _ self computeMatrix]! !

!CoxeterSystem methodsFor: 'as yet unclassified' stamp: 'len 4/18/2016 07:57'!
matrix: aMatrix
	matrix _ aMatrix! !

!CoxeterSystem methodsFor: 'as yet unclassified' stamp: 'len 5/10/2019 09:57:21'!
presentation
	self notYetImplemented
"	| generators relators |
	generators _ self diagram values collect: [:each| Word x: each].
	relators _ OrderedCollection new.
	self diagram edgesAndLabelsDo: [:each :label|
		label isInfinity
			ifFalse: [relators add: (Word x: each key) * (Word x: each value) ^ (label ifNil: [3])]].
	^ GroupPresentation generators: generators relators: relators"! !

!CoxeterSystem methodsFor: 'as yet unclassified' stamp: 'len 4/18/2016 03:17'!
reflections
	"Answer the conjugates of the generators."
	^ self notYetImplemented! !

!CoxeterSystem methodsFor: 'as yet unclassified' stamp: 'len 4/18/2016 08:02'!
schlafliMatrix
	^ self matrix collect: [:x| -2 * (Float pi / x) cos]! !

!CoxeterSystem methodsFor: 'as yet unclassified' stamp: 'len 4/18/2016 03:28'!
simpleReflections
	^ generators! !

!Algebra methodsFor: 'as yet unclassified' stamp: 'len 10/10/2018 06:38:23'!
multiplication
	^ ((self, self) to: self evaluatingWithArguments: [:x :y| x * y]) name: '*'! !

!Algebra methodsFor: 'as yet unclassified' stamp: 'len 10/10/2018 06:40:07'!
multiplicationInverse
	^ (self to: self evaluating: [:each| each reciprocal]) name: 'x^-1'! !

!FreeAlgebra methodsFor: 'accessing' stamp: 'len 8/25/2016 08:22'!
indeterminates
	^ words symbols! !

!FreeAlgebra methodsFor: 'accessing' stamp: 'len 3/5/2016 04:30'!
rank
	self flag: #fix. "conflicts with FreeModule|rank"
	^ self indeterminates size! !

!FreeAlgebra methodsFor: 'accessing' stamp: 'len 1/20/2016 14:58'!
scalars
	^ scalars! !

!FreeAlgebra methodsFor: 'accessing' stamp: 'len 8/25/2016 08:27'!
words
	^ words! !

!FreeAlgebra methodsFor: 'accessing-private' stamp: 'len 1/20/2016 13:39'!
scalars: aCommutativeRing
	scalars _ aCommutativeRing! !

!FreeAlgebra methodsFor: 'accessing-private' stamp: 'len 8/25/2016 08:24'!
words: aMonoid
	words _ aMonoid! !

!FreeAlgebra methodsFor: 'comparing' stamp: 'len 8/25/2016 08:22'!
= anObject
	self == anObject ifTrue: [^ true].
	^ (anObject isKindOf: FreeAlgebra) and: [anObject scalars = scalars and: [anObject words = words]]! !

!FreeAlgebra methodsFor: 'comparing' stamp: 'len 8/25/2016 08:21'!
hash
	^ scalars hash + words hash hashMultiply! !

!FreeAlgebra methodsFor: 'elements' stamp: 'len 1/10/2018 21:45:38'!
coefficient: aNumber word: aWord
	aNumber isZero ifTrue: [^ self zero].
	^ self coefficients: ((Dictionary new: 1) at: aWord put: aNumber; yourself)! !

!FreeAlgebra methodsFor: 'elements' stamp: 'len 1/10/2018 21:47:02'!
coefficients: aDictionary
	^ (FreePolynomial coefficients: aDictionary) parent: self! !

!FreeAlgebra methodsFor: 'elements' stamp: 'len 1/10/2018 21:45:59'!
constant: aNumber
	^ self coefficient: aNumber word: words identity! !

!FreeAlgebra methodsFor: 'elements' stamp: 'len 1/20/2016 14:06'!
one
	^ self constant: scalars one! !

!FreeAlgebra methodsFor: 'elements' stamp: 'len 8/25/2016 08:21'!
x
	^ self x: self indeterminates first! !

!FreeAlgebra methodsFor: 'elements' stamp: 'len 1/10/2018 12:58:14'!
x: anIndeterminate
	^ self coefficient: scalars one word: (words x: anIndeterminate)! !

!FreeAlgebra methodsFor: 'elements' stamp: 'len 1/10/2018 13:22:40'!
x: anIndeterminate to: anInteger
	^ self coefficient: scalars one word: (words x: anIndeterminate to: anInteger)! !

!FreeAlgebra methodsFor: 'elements' stamp: 'len 8/25/2016 08:22'!
y
	^ self x: self indeterminates second! !

!FreeAlgebra methodsFor: 'elements' stamp: 'len 8/25/2016 08:21'!
z
	^ self x: self indeterminates third! !

!FreeAlgebra methodsFor: 'elements' stamp: 'len 1/10/2018 21:46:27'!
zero
	^ self coefficients: (Dictionary new: 0)! !

!FreeAlgebra methodsFor: 'random' stamp: 'len 3/25/2018 19:36:09'!
atRandom: aRandom bits: bitSize
	^ self atRandom: aRandom bits: bitSize maxDegree: ((bitSize raisedTo: (1/self rank)) min: bitSize - 1) truncated! !

!FreeAlgebra methodsFor: 'random' stamp: 'len 1/10/2018 13:21:35'!
atRandom: aRandom bits: bitSize maxDegree: d
	| answer n term |
	answer _ self zero.
	n _ 2 ^ self rank.
	n timesRepeat:
		[term _ ((1 to: d) product: [:i| self x: (self rank atRandom: aRandom) to: (2 atRandom: aRandom) - 1]) * (self scalars atRandom: aRandom bits: bitSize/(self rank*d)).
		answer _ answer + term].
	^ answer! !

!FreeAlgebra methodsFor: 'testing' stamp: 'len 1/10/2018 21:53:30'!
includes: anObject
	^ (anObject isKindOf: FreePolynomial) and: [anObject parent = self]! !

!FreeAlgebra methodsFor: 'testing' stamp: 'len 3/5/2016 04:24'!
isAssociative
	^ true! !

!FreeAlgebra methodsFor: 'testing' stamp: 'len 8/25/2016 08:29'!
isCommutative
	^ words isCommutative and: [scalars isCommutative]! !

!FreeAlgebra methodsFor: 'testing' stamp: 'len 8/25/2016 08:30'!
isFinite
	^ words isFinite and: [scalars isFinite]! !

!FreeAlgebra class methodsFor: 'instance creation' stamp: 'len 5/11/2019 02:43:48'!
new: aCollection over: aRing
	^ self words: (FreeMonoid new: aCollection) over: aRing! !

!FreeAlgebra class methodsFor: 'instance creation' stamp: 'len 1/20/2016 13:38'!
over: aRing
	^ self new: 1 over: aRing! !

!FreeAlgebra class methodsFor: 'instance creation' stamp: 'len 8/25/2016 08:24'!
words: aMonoid over: aRing
	^ self new words: aMonoid; scalars: aRing! !

!GroupAlgebra methodsFor: 'accessing' stamp: 'len 1/10/2018 22:36:35'!
augmentationIdeal
	^ self augmentation kernel! !

!GroupAlgebra methodsFor: 'accessing' stamp: 'len 5/13/2019 18:56:30'!
generators
	^ (self group generators ifNil: [^ nil]) apply: self group -> self! !

!GroupAlgebra methodsFor: 'accessing' stamp: 'len 8/7/2016 08:36'!
group
	^ group! !

!GroupAlgebra methodsFor: 'accessing' stamp: 'len 8/7/2016 08:40'!
one
	^ self embed: self group identity! !

!GroupAlgebra methodsFor: 'accessing' stamp: 'len 8/7/2016 08:38'!
scalars
	^ scalars! !

!GroupAlgebra methodsFor: 'comparing' stamp: 'len 5/26/2019 08:45:21'!
<= aGroupRing
	(aGroupRing isKindOf: GroupAlgebra) ifFalse: [^ super <= aGroupRing].
	^ self scalars <= aGroupRing scalars and: [self group <= aGroupRing group]! !

!GroupAlgebra methodsFor: 'comparing' stamp: 'len 5/26/2019 08:45:21'!
= anObject
	self == anObject ifTrue: [^ true].
	^ (anObject isKindOf: GroupAlgebra) and: [anObject scalars = scalars and: [anObject group = group]]! !

!GroupAlgebra methodsFor: 'comparing' stamp: 'len 8/25/2016 08:35'!
hash
	^ scalars hash + group hash hashMultiply! !

!GroupAlgebra methodsFor: 'elements' stamp: 'len 9/16/2018 16:13:35'!
!! anObject
	(self group includes: anObject)
		ifTrue: [^ self embed: anObject].
	(self scalars includes: anObject)
		ifTrue: [^ self one * anObject].
	^ super !! anObject! !

!GroupAlgebra methodsFor: 'elements' stamp: 'len 5/26/2019 08:45:37'!
coefficients: aFormalSum
	^ (GroupAlgebraElement coefficients: aFormalSum) parent: self! !

!GroupAlgebra methodsFor: 'morphisms' stamp: 'len 1/10/2018 19:48:10'!
augmentation
	"Answer the augmentation map, a ring homomorphism (an epimorphism) from the receiver to the ring of scalars."
	^ self to: self scalars evaluating: [:f| f augmentation]! !

!GroupAlgebra methodsFor: 'morphisms' stamp: 'len 1/10/2018 20:43:08'!
embed: aGroupElement
	^ self coefficients: ((Dictionary new: 1) at: aGroupElement put: self scalars one; yourself)! !

!GroupAlgebra methodsFor: 'morphisms' stamp: 'len 5/13/2019 18:57:03'!
from: aDomain
	aDomain = self group ifTrue: [^ self addMap: ((self group to: self evaluating: [:g| self embed: g]) name: 'i')].
	aDomain -> self group ifNotNil: [:aMorphism| ^ aMorphism -> self].
	aDomain = self scalars ifTrue: [^ self addMap: ((self scalars to: self evaluating: [:x| self one * x]) name: 'i')].
	aDomain -> self scalars ifNotNil: [:aMorphism| ^ aMorphism -> self].
	^ super from: aDomain! !

!GroupAlgebra methodsFor: 'testing' stamp: 'len 9/16/2018 16:13:45'!
contains: anObject
	anObject coefficients keysAndValuesDo: [:key :value|
		(group includes: key) ifFalse: [^ false].
		(scalars includes: value) ifFalse: [^ false]].
	^ true! !

!GroupAlgebra methodsFor: 'testing' stamp: 'len 5/26/2019 08:45:37'!
includes: anObject
	^ (anObject isKindOf: GroupAlgebraElement) and: [anObject parent = self]! !

!GroupAlgebra methodsFor: 'testing' stamp: 'len 8/25/2016 08:37'!
isCommutative
	^ scalars isCommutative and: [group isCommutative]! !

!GroupAlgebra methodsFor: 'testing' stamp: 'len 8/25/2016 08:38'!
isFinite
	^ scalars isFinite and: [group isFinite]! !

!GroupAlgebra methodsFor: 'private' stamp: 'len 8/7/2016 08:37'!
group: aGroup
	group _ aGroup! !

!GroupAlgebra methodsFor: 'private' stamp: 'len 8/7/2016 08:38'!
scalars: aRing
	scalars _ aRing! !

!GroupAlgebra class methodsFor: 'instance creation' stamp: 'len 8/7/2016 08:39'!
on: aGroup over: aRing
	^ self new group: aGroup; scalars: aRing! !

!MatrixAlgebra methodsFor: 'as yet unclassified' stamp: 'len 10/13/2018 17:39:44'!
= anObject
	self == anObject ifTrue: [^ true].
	(anObject isKindOf: MatrixAlgebra)
		ifTrue: [^ anObject scalars = self scalars and: [self degree = anObject degree]].
	^ super = anObject! !

!MatrixAlgebra methodsFor: 'as yet unclassified' stamp: 'len 10/13/2018 17:38:21'!
basis
	^ self propertyAt: #basis ifAbsentPut:
		[| one zero |
		one _ scalars one.
		zero _ scalars zero.
		(1 to: degree squared) collect: [:index|
			self evaluating: [:i :j| (i-1)*degree + j = index ifTrue: [one] ifFalse: [zero]]]]! !

!MatrixAlgebra methodsFor: 'as yet unclassified' stamp: 'len 10/13/2018 17:36:14'!
degree
	^ degree! !

!MatrixAlgebra methodsFor: 'as yet unclassified' stamp: 'len 10/13/2018 17:36:24'!
degree: anInteger
	degree _ anInteger! !

!MatrixAlgebra methodsFor: 'as yet unclassified' stamp: 'len 10/13/2018 17:36:47'!
scalars
	^ scalars! !

!MatrixAlgebra methodsFor: 'as yet unclassified' stamp: 'len 10/13/2018 17:37:00'!
scalars: aRing
	scalars _ aRing! !

!Element methodsFor: 'accessing' stamp: 'len 9/24/2018 02:08:20'!
parent
	^ self subclassResponsibility! !

!Element methodsFor: 'testing' stamp: 'len 4/19/2019 06:23:55'!
isElement
	"Answer true if the receiver is an element of a Domain, i.e. if it understands the message #parent and answers its parent Domain."
	^ true! !

!Morphism methodsFor: 'accessing' stamp: 'len 11/16/2016 08:39'!
codomain
	^ self subclassResponsibility! !

!Morphism methodsFor: 'accessing' stamp: 'len 11/16/2016 08:35'!
domain
	^ self subclassResponsibility! !

!Morphism methodsFor: 'accessing' stamp: 'len 10/5/2016 11:11'!
identity
	^ self domain id! !

!Morphism methodsFor: 'accessing' stamp: 'len 4/19/2019 04:44:44'!
parent
	"A morphism f:A->B belongs to Hom(A,B)."
	^ self domain => self codomain! !

!Morphism methodsFor: 'operations' stamp: 'len 5/5/2019 18:33:27'!
-> aCodomain
	"Answer the composition with the canonical morphism from the codomain of the receiver to aCodomain. See also Domain>>->."
	^ self codomain -> aCodomain ifNotNil: [:aMorphism| aMorphism  self]! !

!Morphism methodsFor: 'operations' stamp: 'len 5/5/2019 18:33:30'!
=> aCodomain
	"This is the internal hom(-,B) functor, where B is the argument.
	If the receiver is a morphism g:X->Y, answer the morphism hom(g,B):hom(Y,B)->hom(X,B) that sends a morphism f to f  g.
	This is a contravariant functor, and it is often called the 'functor of points' of B.
	See #hom: for the external Hom functor."
	^ self codomain => aCodomain to: self domain => aCodomain evaluating: [:f| f  self]! !

!Morphism methodsFor: 'operations' stamp: 'len 5/10/2019 10:16:14'!
^ anObject
	anObject isInteger ifFalse: [^ self conjugatedBy: anObject].
	^ self  anObject! !

!Morphism methodsFor: 'operations' stamp: 'len 11/6/2016 08:59'!
| aCodomain
	"See also Domain>>|."
	^ self corestrictedTo: aCodomain! !

!Morphism methodsFor: 'operations' stamp: 'len 5/5/2019 18:21:59'!
 aMorphism
	"Answer the composition of the receiver with the argument.
	Given the argument f:X -> Y and the receiver g:Y -> Z, answer gf:X -> Z."
	^ self subclassResponsibility! !

!Morphism methodsFor: 'operations' stamp: 'len 5/10/2019 10:10:50'!
 anInteger
	"Answer the receiver composed with itself anInteger times."
	anInteger = 1 ifTrue: [^ self].
	anInteger = 0 ifTrue: [^ self identity].
	anInteger < 0 ifTrue: [^ self inverse  anInteger negated].
	^ (self  self  (anInteger // 2))  (self  (anInteger \\ 2))! !

!Morphism methodsFor: 'operations' stamp: 'len 8/8/2016 06:42'!
coimage
	^ self domain / self kernel! !

!Morphism methodsFor: 'operations' stamp: 'len 8/8/2016 06:42'!
cokernel
	^ self codomain / self image! !

!Morphism methodsFor: 'operations' stamp: 'len 5/10/2019 10:58:19'!
commutator: aMorphism
	^ self inverse  aMorphism inverse  self  aMorphism! !

!Morphism methodsFor: 'operations' stamp: 'len 5/10/2019 10:14:22'!
conjugatedBy: aMorphism
	^ aMorphism inverse  self  aMorphism! !

!Morphism methodsFor: 'operations' stamp: 'len 5/5/2019 18:33:35'!
hom: aCodomain
	"This is the external Hom(-,B) functor, where B is the argument.
	If the receiver is a morphism g:X->Y, answer the function Hom(g,B):Hom(Y,B)->Hom(X,B) that sends a morphism f to f  g.
	This is a contravariant functor, and it is often called the 'functor of points' of B.
	See also => for the internal hom functor."
	^ (self codomain hom: aCodomain) to: (self domain hom: aCodomain) evaluating: [:f| f  self]! !

!Morphism methodsFor: 'operations' stamp: 'len 11/16/2016 08:34'!
image
	^ self domain apply: self! !

!Morphism methodsFor: 'operations' stamp: 'len 5/16/2019 12:46:03'!
inverse
	"Answer a two-sided inverse of the receiver (i.e., a morphism that is both a retraction and a section) or nil."
	^ self subclassResponsibility! !

!Morphism methodsFor: 'operations' stamp: 'len 5/16/2019 12:22:31'!
retraction
	"Answer a left inverse of the receiver or nil."
	^ self subclassResponsibility! !

!Morphism methodsFor: 'operations' stamp: 'len 5/16/2019 12:22:41'!
section
	"Answer a right inverse of the receiver or nil."
	^ self subclassResponsibility! !

!Morphism methodsFor: 'printing' stamp: 'len 8/8/2016 05:52'!
arrowPrintOn: aStream
	aStream print: self domain; nextPut: $; print: self codomain! !

!Morphism methodsFor: 'printing' stamp: 'len 8/8/2016 05:52'!
arrowPrintString
	| limit limitedString |
	limit _ 100.
	limitedString _ String streamContents: [:s | self arrowPrintOn: s] limitedTo: limit.
	limitedString size < limit ifTrue: [^ limitedString].
	^ limitedString , '...etc...'! !

!Morphism methodsFor: 'testing' stamp: 'len 2/14/2017 08:22:36'!
is: aSymbol
	^ aSymbol == #Morphism or: [super is: aSymbol]! !

!Morphism methodsFor: 'testing' stamp: 'len 8/8/2016 06:02'!
isAutomorphism
	^ self isEndomorphism and: [self isIsomorphism]! !

!Morphism methodsFor: 'testing' stamp: 'len 8/8/2016 06:02'!
isEndomorphism
	^ self domain = self codomain! !

!Morphism methodsFor: 'testing' stamp: 'len 11/16/2016 08:33'!
isIdentity
	^ self = self domain id! !

!Morphism methodsFor: 'testing' stamp: 'len 5/16/2019 12:42:32'!
isIsomorphism
	^ self inverse notNil! !

!Morphism methodsFor: 'testing' stamp: 'len 5/16/2019 13:08:37'!
isSplitEpimorphism
	"A split epimorphism is a morphism that has a section (a right inverse).
	Dualy, a split epimorphism is a morphism that *is* a retraction (a left inverse)."
	^ self section notNil! !

!Morphism methodsFor: 'testing' stamp: 'len 5/16/2019 13:09:16'!
isSplitMonomorphism
	"A split monomorphism is a morphism that has a retraction (a left inverse).
	Dualy, a split monomorphism is a morphism that *is* a section (a right inverse)."
	^ self retraction notNil! !

!Morphism methodsFor: 'testing' stamp: 'len 12/10/2016 12:59:06'!
isTrivial
	^ self kernel = self domain! !

!Morphism class methodsFor: 'examples' stamp: 'len 4/27/2018 21:25:19'!
example1Projection
	"Algebraic structures often come equipped with some canonical morphisms.
	Here we construct the direct product of the ring of rational integers
	with the field of rational numbers, and get the projection to the second component."
	^ ZZ  QQ projection: 2! !

!Morphism class methodsFor: 'examples' stamp: 'len 5/5/2019 18:33:40'!
example21Embedding
	"Here we construct Q[x], the ring of univariate polynomials over the rational numbers.
	It comes equipped with a canonical embedding from the rational numbers to the constant polynomials."
	| R phi F psi |
	R _ QQ polynomials.
	phi _ QQ -> R.
	"Then we construct its field of fractions Q(x) (the rational functions),
	that comes with a cannonical embedding from the polynomial ring to the rational functions with denominator 1 (the localization map)."
	F _ R fractions.
	psi _ R -> F.
	"If we compose them we get an embedding from the rational numbers Q to the field of univariate rational functions Q(x), that sends a number to a constant rational function."
	^ psi  phi! !

!Morphism class methodsFor: 'examples' stamp: 'len 4/22/2019 04:47:24'!
example22EasierEmbedding
	"Another way to construct the canonical embedding from Q to the rational functions over Q."
	^ QQ >-> QQ polynomials fractions! !

!Morphism class methodsFor: 'examples' stamp: 'len 4/22/2019 04:48:39'!
example3CanonicalMorphism
	"Canonical morphisms can be retrieved through the message #->.
	More specific messages #>-> and #->> are also available
	(for monomorphisms and epimorphisms respectively). 
	For example, Z (the ring of integers) is the initial object in
	the category of commutative rings with unit, i.e. there's
	a canonical morphism from Z to any commutative ring:"
	^ ZZ -> (QQ polynomialsIn: #(x y z))! !

!Morphism class methodsFor: 'examples' stamp: 'len 4/19/2019 04:54:26'!
example4CanonicalMorphism
	"The quotient map from a polynomial ring R to a quotient by
	one of its ideals R/I is another example of canonical morphism."
	| R x I |
	R _ QQ polynomials.
	x _ R x.
	I _ R * (x squared + 1).
	^ R -> (R / I)! !

!Morphism class methodsFor: 'examples' stamp: 'len 4/19/2019 04:54:38'!
example5CanonicalMorphism
	"The message #-> can be sent to a Morphism with a Domain as
	argument, or to a Domain with a Morphism as argument.
	This yields canonical constructions.
	For example, given an arbitrary ring homomorphism,
	we can send it *canonically* to a quotient of its codomain."
	| R phi x I |
	R _ (ZZ/5) polynomials. "univariate polynomials over Z/<5>"
	phi _ R frobenius. "the Frobenius endomorphism"
	x _ R x.
	I _ R * (x squared + 1).
	^ phi -> (R / I)! !

!Morphism class methodsFor: 'examples' stamp: 'len 5/11/2019 04:29:00'!
example6GLAsGroupAction
	"The action of the group GL(3,Q) on the Q-vector space of 3-tuples.
	The action is evaluation of a linear map at a tuple."
	^ (QQ^3) automorphisms action! !

!Function methodsFor: 'accessing' stamp: 'len 12/28/2016 11:09:59'!
codomain
	^ self propertyAt: #codomain! !

!Function methodsFor: 'accessing' stamp: 'len 12/28/2016 11:11:41'!
domain
	^ self propertyAt: #domain! !

!Function methodsFor: 'comparing' stamp: 'len 5/10/2019 07:24:00'!
= aFunction
	self == aFunction ifTrue: [^ true].
	(self domain = aFunction domain and: [self codomain = aFunction codomain])
		ifFalse: [^ false].
	self domain isFinite ifFalse: [^ self error: 'infinite domain'].
	self domain do: [:each| (self value: each) = (aFunction value: each) ifFalse: [^ false]].
	^ true! !

!Function methodsFor: 'comparing' stamp: 'len 8/6/2016 10:29'!
hash
	^ self domain hash hashMultiply + self codomain hash! !

!Function methodsFor: 'converting' stamp: 'len 5/15/2019 07:55:04'!
asBlock
	| expression |
	^ (expression _ self expression) isBlock ifTrue: [expression] ifFalse: [[:x| expression value: x]]! !

!Function methodsFor: 'morphic' stamp: 'len 4/24/2016 02:04'!
plot: aCollection
	^ FunctionPlotMorph new evaluationPoints: aCollection; function: self! !

!Function methodsFor: 'operations' stamp: 'len 12/30/2017 19:52:42'!
, aFunction
	"Answer the cartesian product of the receiver with the argument."
	^ Function
		from: (self domain, aFunction domain)
		to: (self codomain, aFunction codomain)
		evaluating: [:each| {self value: (each at: 1). aFunction value: (each at: 2)}]! !

!Function methodsFor: 'operations' stamp: 'len 5/5/2019 18:25:08'!
 aFunction
	"Answer the composition of the receiver with the argument.
	Given the argument f:X -> Y and the receiver g:Y -> Z, answer gf:X -> Z.
	This is, (gf)(x) = g(f(x))."
	self domain >= aFunction codomain ifFalse: [DomainError signal: 'domains don''t match'].
	^ self species from: aFunction domain to: self codomain evaluating: [:x| self value: (aFunction value: x)]! !

!Function methodsFor: 'operations' stamp: 'len 12/30/2017 19:53:33'!
 aFunction
	"Answer the product of the receiver with the argument."
	^ self, aFunction! !

!Function methodsFor: 'operations' stamp: 'len 11/2/2016 04:09'!
corestrictedTo: aCodomain
	^ self species from: self domain to: aCodomain evaluating: [:x| self value: x]! !

!Function methodsFor: 'operations' stamp: 'len 12/28/2016 11:10:34'!
image
	^ self propertyAt: #image ifAbsent: [self domain apply: self]! !

!Function methodsFor: 'operations' stamp: 'len 5/16/2019 12:47:03'!
inverse
	^ self propertyAt: #inverse! !

!Function methodsFor: 'operations' stamp: 'len 4/19/2016 21:40'!
restrictedTo: aDomain
	^ self species from: aDomain to: self codomain evaluating: [:x| self value: x]! !

!Function methodsFor: 'operations' stamp: 'len 10/17/2016 16:16'!
restrictedTo: aDomain corestrictedTo: aCodomain
	^ self species from: aDomain to: aCodomain evaluating: [:x| self value: x]! !

!Function methodsFor: 'operations' stamp: 'len 5/16/2019 12:47:17'!
retraction
	^ self propertyAt: #retraction ifAbsent: [self inverse]! !

!Function methodsFor: 'operations' stamp: 'len 5/16/2019 12:47:24'!
section
	^ self propertyAt: #section ifAbsent: [self inverse]! !

!Function methodsFor: 'operations' stamp: 'len 5/15/2019 07:51:40'!
value: anObject
	^ (self propertyAt: #expression) value: anObject! !

!Function methodsFor: 'operations' stamp: 'len 11/5/2016 09:33'!
valueWithArguments: anArray
	^ self value: (self domain scalars tuple: anArray)! !

!Function methodsFor: 'printing' stamp: 'len 5/16/2019 13:17:31'!
arrowPrintOn: aStream
	aStream
		print: self domain;
		nextPut:
			((self propertyAt: #inverse ifAbsent: []) notNil
				ifTrue: [$]
				ifFalse:
					[(self propertyAt: #retraction ifAbsent: []) notNil
						ifTrue: [$]
						ifFalse:
							[(self propertyAt: #section ifAbsent: []) notNil
								ifTrue: [$]
								ifFalse: [$]]]);
		print: self codomain! !

!Function methodsFor: 'printing' stamp: 'len 12/28/2016 11:10:54'!
name: aString
	self propertyAt: #name put: aString! !

!Function methodsFor: 'properties' stamp: 'len 12/28/2016 12:23:08'!
hasProperty: aSymbol
	^ (properties ifNil: [^ false]) includesKey: aSymbol! !

!Function methodsFor: 'properties' stamp: 'len 12/28/2016 12:23:36'!
properties
	^ properties ifNil: [properties _ IdentityDictionary new]! !

!Function methodsFor: 'properties' stamp: 'len 12/28/2016 11:08:57'!
propertyAt: aSymbol
	^ self propertyAt: aSymbol ifAbsent: [self error: 'no such property']! !

!Function methodsFor: 'properties' stamp: 'len 12/28/2016 12:24:00'!
propertyAt: aSymbol ifAbsent: exceptionBlock
	^ (properties ifNil: [^ exceptionBlock value]) at: aSymbol ifAbsent: exceptionBlock! !

!Function methodsFor: 'properties' stamp: 'len 12/28/2016 12:24:09'!
propertyAt: aSymbol ifAbsentPut: aBlock
	^ self properties at: aSymbol ifAbsentPut: aBlock! !

!Function methodsFor: 'properties' stamp: 'len 12/28/2016 12:24:46'!
propertyAt: aSymbol ifPresent: aBlock
	^ (properties ifNil: [^ nil]) at: aSymbol ifPresent: aBlock! !

!Function methodsFor: 'properties' stamp: 'len 12/28/2016 12:24:55'!
propertyAt: aSymbol put: anObject
	^ self properties at: aSymbol put: anObject! !

!Function methodsFor: 'testing' stamp: 'len 5/10/2019 07:30:02'!
isAbelianGroupHomomorphism
	(self domain isAbelianGroup and: [self codomain isAbelianGroup]) ifFalse: [^ false].
	self domain isFinite ifFalse: [^ self error: 'infinite domain'].
	^ self domain allSatisfy: [:x|
		self domain allSatisfy: [:y|
			(self value: x) + (self value: y) = (self value: x + y)]]! !

!Function methodsFor: 'testing' stamp: 'len 4/16/2016 18:53'!
isBiyective
	^ self isInjective and: [self isSurjective]! !

!Function methodsFor: 'testing' stamp: 'len 8/24/2016 20:37'!
isEpimorphism
	^ self isSurjective! !

!Function methodsFor: 'testing' stamp: 'len 5/19/2018 17:54:16'!
isEvaluable
	^ true! !

!Function methodsFor: 'testing' stamp: 'len 5/10/2019 07:29:16'!
isGroupHomomorphism
	(self domain isGroup and: [self codomain isGroup]) ifFalse: [^ false].
	self domain isFinite ifFalse: [^ self error: 'infinite domain'].
	^ self domain allSatisfy: [:x|
		self domain allSatisfy: [:y|
			(self value: x)(self value: y) = (self value: xy)]]! !

!Function methodsFor: 'testing' stamp: 'len 12/28/2016 11:10:18'!
isIdentity
	^ self propertyAt: #isIdentity ifAbsentPut: [self = self domain id]! !

!Function methodsFor: 'testing' stamp: 'len 5/16/2019 12:14:30'!
isInjective
	^ self retraction notNil! !

!Function methodsFor: 'testing' stamp: 'len 5/10/2019 07:38:30'!
isModuleHomomorphism
	(self domain isModule and: [self codomain isModule]) ifFalse: [^ false].
	self domain scalars = self codomain scalars ifFalse: [^ false].
	self domain isFinite ifFalse: [^ self error: 'infinite domain'].
	^ self domain allSatisfy: [:x|
		self domain allSatisfy: [:y|
			| z |
			(z _ self value: x) + (self value: y) = (self value: x + y) and:
				[self domain scalars allSatisfy: [:r| z * r = (self value: x * r)]]]]! !

!Function methodsFor: 'testing' stamp: 'len 4/16/2016 19:16'!
isMonomorphism
	^ self isInjective! !

!Function methodsFor: 'testing' stamp: 'len 5/10/2019 07:34:08'!
isRingHomomorphism
	(self domain isRing and: [self codomain isRing]) ifFalse: [^ false].
	self domain isFinite ifFalse: [^ self error: 'infinite domain'].
	(self value: self domain one) = self codomain one ifFalse: [^ false].
	^ self domain allSatisfy: [:x|
		self domain allSatisfy: [:y|
			(self value: x) + (self value: y) = (self value: x + y) and:
				[(self value: x) * (self value: y) = (self value: x * y)]]]! !

!Function methodsFor: 'testing' stamp: 'len 5/16/2019 12:16:02'!
isSurjective
	^ self section notNil! !

!Function methodsFor: 'private' stamp: 'len 12/28/2016 11:12:01'!
codomain: aDomain
	self propertyAt: #codomain put: aDomain! !

!Function methodsFor: 'private' stamp: 'len 12/28/2016 11:11:13'!
domain: aDomain
	self propertyAt: #domain put: aDomain! !

!Function methodsFor: 'private' stamp: 'len 12/28/2016 11:11:02'!
expression
	^ self propertyAt: #expression ifAbsent: [self]! !

!Function methodsFor: 'private' stamp: 'len 12/28/2016 11:09:44'!
expression: anExpression
	self propertyAt: #expression put: ((anExpression isKindOf: Function) ifTrue: [anExpression expression] ifFalse: [anExpression])! !

!Function methodsFor: 'private' stamp: 'len 12/3/2015 20:34'!
species
	^ Function! !

!Function class methodsFor: 'examples' stamp: 'len 10/29/2016 07:39'!
example1Function
	"The function 'x^2 + 1' with domain the ring of rational integers
	and codomain the set of natural numbers."
	^ Function from: ZZ to: NN evaluating: [:x| x squared + 1]! !

!Function class methodsFor: 'examples' stamp: 'len 10/29/2016 07:38'!
example2Morphism1
	"This is the most common way to define morphisms.
	QQ^3 is the vector space of 3-tuples with rational coefficients,
	and this defines a linear map on it (an endomorphism)
	by sending the message #to:evaluating: to the vector space."
	^ QQ^3 to: QQ^3 evaluating: [:v| (v x - v y, v x, v z)]! !

!Function class methodsFor: 'examples' stamp: 'len 5/11/2019 04:32:05'!
example2Morphism2
	"Here's another way to define the same morphism,
	by creating Hom(Q^3, Q^3) and sending the message #evaluating: to it."
	^ QQ^3 => (QQ^3) evaluating: [:v| (v x - v y, v x, v z)]! !

!Function class methodsFor: 'examples' stamp: 'len 5/11/2019 04:31:56'!
example2Morphism22
	"Or equivalently, creating Hom(Q^3, Q^3) and sending coercing
	a Smalltalk block into an element of the Hom vector space."
	^ QQ^3 => (QQ^3) !! [:v| (v x - v y, v x, v z)]! !

!Function class methodsFor: 'examples' stamp: 'len 5/11/2019 04:32:50'!
example2Morphism3
	"And yet another way. Here Hom(Q^3, Q^3) is created
	by sending the message #endomorphisms to the vector space."
	^ (QQ^3) endomorphisms !! [:v| (v x - v y, v x, v z)]! !

!Function class methodsFor: 'examples' stamp: 'len 12/2/2016 11:08:54'!
example3Frobenius1
	"One way to define the Frobenius ring homomorphism."
	^ (ZZ / 6) endomorphisms evaluating: [:x| x^6]! !

!Function class methodsFor: 'examples' stamp: 'len 12/2/2016 11:08:57'!
example3Frobenius2
	"The Frobenius ring homomorphism defined by a polynomial."
	| R x |
	R _ ZZ / 6.
	x _ R polynomials x.
	^ R endomorphisms evaluating: x ^ 6! !

!Function class methodsFor: 'instance creation' stamp: 'len 10/10/2016 13:59'!
from: aDomain to: anotherDomain evaluating: anExpression
	^ self new domain: aDomain; codomain: anotherDomain; expression: anExpression! !

!Function class methodsFor: 'instance creation' stamp: 'len 5/16/2019 12:26:38'!
from: aDomain to: anotherDomain evaluating: anExpression inverseEvaluating: anotherExpression
	| answer inverse |
	answer _ self from: aDomain to: anotherDomain evaluating: anExpression.
	inverse _ self from: anotherDomain to: aDomain evaluating: anotherExpression.
	answer propertyAt: #retraction put: inverse.
	inverse propertyAt: #section put: answer.
	^ answer! !

!Function class methodsFor: 'instance creation' stamp: 'len 10/17/2016 10:43'!
from: aDomain to: aCodomain evaluatingWithArguments: aBlock
	^ self from: aDomain to: aCodomain evaluating: [:each| aBlock valueWithArguments: each asArray]! !

!Function class methodsFor: 'instance creation' stamp: 'len 10/2/2016 09:31'!
newFrom: aFunction
	^ self from: aFunction domain to: aFunction codomain evaluating: aFunction! !

!GroupAction methodsFor: 'accessing' stamp: 'len 6/29/2016 08:46'!
degree
	^ self space size! !

!GroupAction methodsFor: 'accessing' stamp: 'len 2/13/2016 06:31'!
fixedPoints
	^ self space select: [:each| self isFixedPoint: each]! !

!GroupAction methodsFor: 'accessing' stamp: 'len 6/22/2016 07:36'!
fixedPointsOf: anElement
	"Dual idea to the stabilizer. The fixed points are the orbits of size 1."
	^ self space select: [:each| (self value: {anElement. each}) = each]! !

!GroupAction methodsFor: 'accessing' stamp: 'len 2/13/2016 08:02'!
group
	^ self domain at: 1! !

!GroupAction methodsFor: 'accessing' stamp: 'len 7/27/2016 07:31'!
kernel
	"This is also the intersection of all the stabilizers."
	^ self group select: [:g| self space allSatisfy: [:x| (self value: {g.x}) = x]]
	"^ self asPermutationRepresentation kernel"! !

!GroupAction methodsFor: 'accessing' stamp: 'len 1/28/2018 22:44:43'!
orbitOf: aPoint
	"Answer the set of points to which aPoint can be 'moved' by elements of the group G.
	All the orbits form a partition of the underlying set (space) X, and it's written X/G and called the quotient of the action. In geometric situations it may be called the orbit space, and in algebraic situations it is called the space of coinvariants (in contrast with the space of invariants, that are the fixed points)."
	| answer |
	self group generators
		ifNotNil: [:S| ^ (SchreierTree root: aPoint generators: S action: self) orbit].
	answer _ Set new.
	self group do: [:each| answer add: (self value: {each. aPoint})].
	^ answer! !

!GroupAction methodsFor: 'accessing' stamp: 'len 5/16/2016 05:28'!
orbits
	"Answer the quotient of the action, also called space of orbits in geometric situations and space of coinvariants in algebraic situations."
	| answer |
	answer _ Set new.
	self space do: [:each| answer add: (self orbitOf: each)].
	^ answer! !

!GroupAction methodsFor: 'accessing' stamp: 'len 1/28/2018 18:00:45'!
reynolds
	"Answer the Reynolds operator, assuming the group acts on a polynomial ring S.
	Properties:
	- K-linear map S -> S^G (it's the G-invariant projection from S to S^G;
	- restricts to the identity on S^G;
	- it's an S^G-module homomorphisms: R(p*q) = p*R(q) for all invariants p in S^G."
	| order |
	order _ self group size.
	^ self space to: self space evaluating: [:p| (self group elements sum: [:g| self value: {g. p}]) / order]! !

!GroupAction methodsFor: 'accessing' stamp: 'len 2/16/2016 04:29'!
space
	"Answer the underlying set X of the action G x X -> X."
	^ self codomain! !

!GroupAction methodsFor: 'accessing' stamp: 'len 11/14/2016 09:30'!
stabilizerOf: aPoint
	"Answer the stabilizer subgroup (or isotropy group or little group) of aPoint, defined as the set of elements that 'fix' aPoint. The stabilizer of fixed points is the whole group, and the kernel of the action homomorphism G -> Sym(X) is the intersection of all stabilizers."
	self group generators
		ifNotNil: [:S| ^ (SchreierTree root: aPoint generators: S action: self) stabilizer].
	^ self group select: [:each| (self value: {each. aPoint}) = aPoint]! !

!GroupAction methodsFor: 'converting' stamp: 'len 5/13/2019 15:48:43'!
asPermutationRepresentation
	| S |
	S _ SymmetricGroup on: self space.
	^ self group to: S evaluating: [:g| S evaluating: [:x| self value: {g.x}]]! !

!GroupAction methodsFor: 'converting' stamp: 'len 5/13/2019 15:49:02'!
asRepresentation
	^ self group
		to: self space automorphisms
		evaluating: [:g| self space to: self space evaluating: [:x| self value: {g.x}]]! !

!GroupAction methodsFor: 'graphs' stamp: 'len 5/25/2016 03:45'!
actionGraph: groupGenerators
	"Answer the action diagram with respect to the given group generators.
	This is similar to a Cayley diagram.
	The connected components of the action diagram are the orbits of the action."
	| G |
	self space isFinite ifFalse: [^ self error: 'not a finite space'].
	G _ Digraph unorderedLabeled.
	groupGenerators do: [:g|
		self space do: [:x|
			G addEdgeFrom: x to: (self value: {g.x}) label: g]].
	^ G! !

!GroupAction methodsFor: 'graphs' stamp: 'len 5/18/2016 21:23'!
actionGraphMorph
	^ self actionGraphMorph: self group generators! !

!GroupAction methodsFor: 'graphs' stamp: 'len 12/19/2016 12:24:08'!
actionGraphMorph: generators
	| G answer colors |
	G _ self actionGraph: generators.
	answer _ G asMorph.
	colors _ DiscretePalette default.
	answer edgesAndLabelsDo: [:each :label| each hideLabel; color: (colors at: label)].
	answer nodesDo: [:each| each color: Color transparent; radius: 0].
	^ answer! !

!GroupAction methodsFor: 'testing' stamp: 'len 12/28/2016 11:12:53'!
isFaithful
	"A group action G x X -> X is faithful (or effective) if the homomorphism G -> Sym(X) has trivial kernel {id}."
	^ self propertyAt: #isFaithful ifAbsentPut: [self kernel isTrivial]! !

!GroupAction methodsFor: 'testing' stamp: 'len 2/13/2016 08:02'!
isFixedPoint: aPoint
	"Answer true if the argument is a fixed point of the receiver."
	self group do: [:each| (self value: {each. aPoint}) = aPoint ifFalse: [^ false]].
	^ true! !

!GroupAction methodsFor: 'testing' stamp: 'len 7/27/2016 07:34'!
isImprimitive
	^ self isPrimitive not! !

!GroupAction methodsFor: 'testing' stamp: 'len 7/27/2016 07:36'!
isPrimitive
	^ self orbits allSatisfy: [:each| each size = 1 or: [each size = self space size]]! !

!GroupAction methodsFor: 'testing' stamp: 'len 7/27/2016 07:30'!
isRegular
	^ self isTransitive and: [(self stabilizerOf: self space anyOne) isTrivial]! !

!GroupAction methodsFor: 'testing' stamp: 'len 7/27/2016 07:28'!
isTransitive
	^ self orbits size = 1! !

!GroupMap methodsFor: 'accessing' stamp: 'len 5/13/2019 15:45:17'!
action
	"If the receiver is a representation (i.e., a group homomorphism to the automorphisms group of some space), answer the associated group action on the representation space."
	^ GroupAction from: (self domain, self space) to: self space evaluatingWithArguments: [:x :y| (self value: x) value: y]! !

!GroupMap methodsFor: 'accessing' stamp: 'len 5/13/2019 15:47:49'!
character
	"If the receiver is a linear representation (i.e., a group homomorphism to the general linear group), answer the character of the receiver."
	"This is a class function, i.e. it's constant on conjugacy classes, because similar matrices (or linear maps) have the same trace."
	self space isModule ifFalse: [^ self error: 'not a linear representation'].
	^ Function from: self domain to: self space scalars evaluating: [:g| (self value: g) trace] "should be a GroupMap?"! !

!GroupMap methodsFor: 'accessing' stamp: 'len 5/13/2019 16:38:15'!
image
	^ self codomain span: ((self domain generators ifNil: [^ super image]) apply: self)! !

!GroupMap methodsFor: 'accessing' stamp: 'len 5/13/2019 16:40:43'!
kernel
	^ self domain select: [:each| (self value: each) = self codomain identity]! !

!GroupMap methodsFor: 'accessing' stamp: 'len 5/27/2019 07:04:40'!
preimage: anElement
	"Answer the preimage of anElement, a Coset."
	^ self kernel * (self preimageRepresentative: anElement)! !

!GroupMap methodsFor: 'accessing' stamp: 'len 5/27/2019 07:05:41'!
preimageRepresentative: anElement
	"Answer a representative of the preimage of anElement.
	Answer nil if anElement is not in the image of the receiver."
	^ self domain detect: [:one| (self value: one) = anElement] ifNone: [^ nil]! !

!GroupMap methodsFor: 'accessing' stamp: 'len 5/13/2019 15:45:33'!
space
	"If the receiver is a representation (i.e., a group homomorphism to the automorphisms group of some space), answer the representation space."
	^ self codomain space! !

!GroupMap methodsFor: 'arithmetic' stamp: 'len 10/10/2016 20:03'!
inverse
	"Answer the compositional inverse of the receiver."
	^ self class
		from: self codomain to: self domain
		evaluating: [:each| self domain detect: [:one| (self value: one) = each]]! !

!GroupMap methodsFor: 'comparing' stamp: 'len 5/13/2019 16:32:40'!
= anObject
	((anObject isKindOf: GroupMap) and: [self domain generators notNil])
		ifFalse: [^ super = anObject].
	(anObject domain = self domain and: [anObject codomain = self codomain])
		ifFalse: [^ false].
	^ self domain generators allSatisfy: [:each| (self value: each) = (anObject value: each)]! !

!GroupMap methodsFor: 'operations' stamp: 'len 5/25/2019 08:19:40'!
value: anElement
	| answer images |
	self propertyAt: #expression ifPresent: [:anExpression| ^ anExpression value: anElement].
	answer _ self codomain identity.
	images _ self images.
	(self domain wordOf: anElement) do: [:i :exponent| answer _ answer  ((images at: i) ^ exponent)].
	^ answer! !

!GroupMap methodsFor: 'testing' stamp: 'len 5/10/2019 07:40:55'!
isGroupHomomorphism
	^ true! !

!GroupMap methodsFor: 'testing' stamp: 'len 11/7/2015 16:46'!
isInjective
	^ self kernel isTrivial! !

!GroupMap methodsFor: 'testing' stamp: 'len 11/7/2015 16:49'!
isSurjective
	^ self image = self codomain! !

!GroupMap methodsFor: 'private' stamp: 'len 5/25/2019 08:13:13'!
images
	^ self propertyAt: #images! !

!GroupMap methodsFor: 'private' stamp: 'len 5/25/2019 08:13:18'!
images: anArray
	self propertyAt: #images put: anArray! !

!GroupMap methodsFor: 'private' stamp: 'len 1/11/2018 18:20:41'!
species
	^ GroupMap! !

!GroupMap methodsFor: 'private' stamp: 'len 5/15/2019 08:00:38'!
verify
	^ super isGroupHomomorphism! !

!GroupMap class methodsFor: 'instance creation' stamp: 'len 5/25/2019 08:15:12'!
from: aGroup to: anotherGroup mapping: aBlock
	^ self new domain: aGroup; codomain: anotherGroup; images: ((1 to: aGroup generators size) collect: [:i| aBlock value: i])! !

!ConjugationMap methodsFor: 'accessing' stamp: 'len 2/12/2016 06:37'!
image
	^ self codomain! !

!ConjugationMap methodsFor: 'accessing' stamp: 'len 2/12/2016 06:37'!
kernel
	^ self domain null! !

!ConjugationMap methodsFor: 'accessing-private' stamp: 'len 5/2/2016 09:31'!
element
	^ element! !

!ConjugationMap methodsFor: 'accessing-private' stamp: 'len 5/5/2019 17:58:52'!
element: anElement
	element _ anElement.
	elementInverse _ element inverse! !

!ConjugationMap methodsFor: 'arithmetic' stamp: 'len 2/12/2016 06:42'!
inverse
	^ self class by: elementInverse in: self domain! !

!ConjugationMap methodsFor: 'comparing' stamp: 'len 5/13/2019 15:50:17'!
= anObject
	(anObject isKindOf: ConjugationMap) ifFalse: [^ super = anObject].
	^ anObject domain = self domain and: [anObject codomain = self codomain and: [self element = anObject element]]! !

!ConjugationMap methodsFor: 'comparing' stamp: 'len 5/2/2016 09:31'!
hash
	^ element hash! !

!ConjugationMap methodsFor: 'operations' stamp: 'len 5/5/2019 18:37:19'!
value: anElement
	^ element  anElement  elementInverse! !

!ConjugationMap class methodsFor: 'instance creation' stamp: 'len 5/12/2016 10:06'!
by: anElement in: aGroup
	^ self new domain: aGroup; codomain: aGroup; element: anElement! !

!DirichletCharacter methodsFor: 'as yet unclassified' stamp: 'len 6/5/2019 11:39:02'!
conductor
	| factors p e answer |
	(self modulus = 1 or: [self isTrivial]) ifTrue: [^ 1].
	(factors _ self modulus factors) asSet size > 1
		ifTrue: [^ self decomposition product: [:each| each conductor]].
	p _ factors anyOne.
	e _ factors size.
	answer _ p ^ ((self size abs: p) + 1).
"	p = 2 and: [e > 2 and: [ ..."
	^ answer! !

!DirichletCharacter methodsFor: 'as yet unclassified' stamp: 'len 12/9/2016 12:28:05'!
even
	^ (self value: -1 % self modulus) = self codomain one! !

!DirichletCharacter methodsFor: 'as yet unclassified' stamp: 'len 12/9/2016 12:28:30'!
isPrimitive
	^ self conductor = self modulus! !

!DirichletCharacter methodsFor: 'as yet unclassified' stamp: 'len 12/9/2016 12:21:35'!
modulus
	^ self domain modulus! !

!DirichletCharacter methodsFor: 'as yet unclassified' stamp: 'len 12/9/2016 12:28:01'!
odd
	^ (self value: -1 % self modulus) = self codomain one negated! !

!GroupRepresentation methodsFor: 'accessing' stamp: 'len 10/17/2016 10:54'!
action
	"Answer the associated group action on the representation space."
	^ GroupAction from: (self domain, self space) to: self space evaluatingWithArguments: [:x :y| (self value: x) value: y]! !

!GroupRepresentation methodsFor: 'accessing' stamp: 'len 8/1/2016 08:48'!
space
	"Answer the representation space."
	^ self codomain space! !

!GroupRepresentation methodsFor: 'invariants' stamp: 'len 3/22/2018 04:48:55'!
character
	"Answer the character of the receiver, assuming it's a linear or matrix representation."
	"This is a class function, i.e. it's constant on conjugacy classes, because similar matrices (or linear maps) have the same trace."
	self space isModule ifFalse: [^ self error: 'not a linear or matrix representation'].
	^ Function from: self domain to: self space scalars evaluating: [:g| (self value: g) trace] "should be a GroupMap?"! !

!AbelianGroupMap methodsFor: 'as yet unclassified' stamp: 'len 4/22/2019 14:41:57'!
codomain
	^ codomain! !

!AbelianGroupMap methodsFor: 'as yet unclassified' stamp: 'len 4/22/2019 14:41:51'!
codomain: anAbelianGroup
	codomain _ anAbelianGroup! !

!AbelianGroupMap methodsFor: 'as yet unclassified' stamp: 'len 4/22/2019 14:41:36'!
domain
	^ domain! !

!AbelianGroupMap methodsFor: 'as yet unclassified' stamp: 'len 4/22/2019 14:41:47'!
domain: anAbelianGroup
	domain _ anAbelianGroup! !

!AbelianGroupMap methodsFor: 'as yet unclassified' stamp: 'len 5/10/2019 07:41:48'!
isAbelianGroupHomomorphism
	^ true! !

!AbelianGroupMap methodsFor: 'as yet unclassified' stamp: 'len 4/22/2019 14:42:02'!
matrix
	^ matrix! !

!AbelianGroupMap methodsFor: 'as yet unclassified' stamp: 'len 4/22/2019 14:42:12'!
matrix: aMatrix
	matrix _ aMatrix! !

!AbelianGroupMap methodsFor: 'as yet unclassified' stamp: 'len 5/6/2019 14:07:14'!
value: anElement
	^ codomain !! (matrix * (ZZ tuple: anElement coordinates))! !

!AbelianGroupMap class methodsFor: 'as yet unclassified' stamp: 'len 5/6/2019 14:08:15'!
from: anAbelianGroup to: anotherAbelianGroup matrix: aMatrix
	^ self new domain: anAbelianGroup; codomain: anotherAbelianGroup; matrix: aMatrix! !

!RingMap methodsFor: 'comparing' stamp: 'len 5/15/2018 18:12:05'!
= aRingMap
	(aRingMap isKindOf: RingMap) ifFalse: [^ super = aRingMap].
	(self domain = aRingMap domain and: [self codomain = aRingMap codomain]) ifFalse: [^ false].
	^ self domain generators allSatisfy: [:each| (self value: each) = (aRingMap value: each)]! !

!RingMap methodsFor: 'converting' stamp: 'len 5/14/2019 18:58:16'!
asAbelianGroupMap
	| A B |
	A _ self domain asAbelianGroup.
	B _ self codomain asAbelianGroup.
	^ A to: B evaluating: [:x| B !! (self value: self domain !! x)]! !

!RingMap methodsFor: 'converting' stamp: 'len 9/28/2018 06:51:12'!
asModuleMap
	^ self domain asModule to: self codomain asModule evaluating: self! !

!RingMap methodsFor: 'operations' stamp: 'len 5/14/2019 20:50:09'!
 aRingMap
	"Apply the tensor product functor."
	^ self notYetImplemented! !

!RingMap methodsFor: 'operations' stamp: 'len 5/15/2018 18:07:31'!
spec
	"This is the Spec functor. Answer the affine scheme homomorphism induced by the receiver, i.e. given a ring homomorphism f:R->S, Spec(f) is a scheme homomorphism Spec(S)->Spec(R)."
	^ self codomain spec to: self domain spec evaluating: [:anIdeal| self preimage: anIdeal]! !

!RingMap methodsFor: 'operations' stamp: 'len 5/2/2019 08:03:52'!
units
	"This is the natural functor from the cateogry of rings to the category of groups which sends each ring R to its group of units U(R) and each ring homomorphism to the restriction to U(R). This functor has a left adjoint which sends each group G to the integral group ring Z[G]."
	^ self domain units to: self codomain units evaluating: [:each| self value: each]! !

!RingMap methodsFor: 'testing' stamp: 'len 5/26/2019 13:51:26'!
isInjective
	(self domain isField and: [self codomain isTrivial not]) ifTrue: [^ true]. "a ring homomorphism from a field to a nontrivial ring is injective."
	^ self kernel isTrivial! !

!RingMap methodsFor: 'testing' stamp: 'len 9/22/2018 19:00:11'!
isLocal
	"A ring homomorphism called 'local' if it is a homomorphism of local rings and carries the maximal ideal to the maximal ideal."
	^ self domain isLocal and: [self codomain isLocal and: [(self domain maximalIdeal apply: self) <= self codomain maximalIdeal]]! !

!RingMap methodsFor: 'testing' stamp: 'len 5/10/2019 07:41:10'!
isRingHomomorphism
	^ true! !

!RingMap methodsFor: 'testing' stamp: 'len 10/5/2016 10:27'!
isZero
	"A ring homomorphism to a non-trivial ring cannot be zero, because 1 maps to 1."
	^ (self value: self domain one) = self codomain zero
"	^ self codomain isTrivial"! !

!RingMap methodsFor: 'private' stamp: 'len 1/11/2018 17:38:33'!
species
	^ RingMap! !

!RingMap methodsFor: 'private' stamp: 'len 5/15/2019 07:24:39'!
verify
	^ super isRingHomomorphism! !

!RingMap class methodsFor: 'examples' stamp: 'len 4/19/2019 04:55:46'!
example1
	"The ring of rational integers is the initial object in the category of rings.
	There's always a unique ring homomorphism from the integers to any given ring:"
	^ ZZ -> (ZZ/6) polynomials! !

!PolynomialRingMap methodsFor: 'as yet unclassified' stamp: 'len 2/12/2017 13:04:30'!
imageContains: aPolynomial
	"As in Magma, algorithm in p. 82 of [AL94]."
	self notYetImplemented! !

!PolynomialRingMap methodsFor: 'as yet unclassified' stamp: 'len 4/27/2018 01:28:13'!
implicitization
	"As implemented in RationalMap. Maybe shouldn't implement it here.
	Magma uses the algorithm in p. 97 of [CLO96]."
	self notYetImplemented! !

!PolynomialRingMap methodsFor: 'operations' stamp: 'len 5/15/2018 17:04:57'!
kernel
	"See RationalMap>>image."
	| A B m n P t embedding generators I |
	self propertyAt: #kernel ifPresent: [:anIdeal| ^ anIdeal].
	A _ self domain.
	B _ self codomain.
	n _ A rank.
	m _ B rank.
	P _ self codomain scalars polynomialsIn: n + m + 1.
	"the embedding mapping the i-th indeterminate to the (i+n)-th indeterminate in the bigger ring:"
	embedding _ A to: P evaluating: [:f| P !! f substitute: [:i| i+n]].
	t _ P x: P rank.
	generators _ OrderedCollection new.
	1 to: n do: [:i|
		generators add: (P x: i) - (embedding value: (self value: (A x: i)))].
	generators add: P one - t.
	I _ P * generators eliminateAll: (n+1 to: P rank).
	^ self propertyAt: #kernel put: A * (I generators collect: [:each| A !! each])! !

!PolynomialRingMap methodsFor: 'operations' stamp: 'len 5/15/2018 18:13:27'!
spec
	"This is the Spec functor. Answer the affine scheme homomorphism induced by the receiver, i.e. given a ring homomorphism f:R->S, Spec(f) is a scheme homomorphism Spec(S)->Spec(R)."
	^ self codomain spec to: self domain spec representatives: ((1 to: self domain rank) collect: [:i| self value: (self domain x: i)])! !

!PolynomialRingMap methodsFor: 'testing' stamp: 'len 2/12/2017 13:02:51'!
isSurjective
	^ self codomain generators allSatisfy: [:each| self imageContains: each]! !

!ModuleMap methodsFor: 'accessing' stamp: 'len 5/16/2019 20:39:49'!
bitSize
	^ matrix bitSize! !

!ModuleMap methodsFor: 'accessing' stamp: 'len 5/16/2019 20:40:32'!
codomain
	^ codomain! !

!ModuleMap methodsFor: 'accessing' stamp: 'len 5/16/2019 20:40:36'!
domain
	^ domain! !

!ModuleMap methodsFor: 'accessing' stamp: 'len 5/16/2019 20:41:21'!
matrix
	^ matrix! !

!ModuleMap methodsFor: 'comparing' stamp: 'len 5/16/2019 20:37:31'!
= anObject
	self == anObject ifTrue: [^ true].
	(anObject isKindOf: ModuleMap) ifFalse: [^ super = anObject].
	^ self domain = anObject domain and: [self codomain = anObject codomain and: [(self - anObject) isZero]]
	
"	(anObject domain = self domain and: [anObject codomain = self codomain])
		ifFalse: [^ false].
	^ (self domain generators ifNil: [self domain]) allSatisfy: [:each| (self value: each) = (anObject value: each)]"! !

!ModuleMap methodsFor: 'converting' stamp: 'len 5/14/2019 19:00:06'!
asAbelianGroupMap
	| A B |
	A _ self domain asAbelianGroup.
	B _ self codomain asAbelianGroup.
	^ A to: B evaluating: [:x| B !! (self value: self domain !! x)]! !

!ModuleMap methodsFor: 'operations' stamp: 'len 5/16/2019 20:57:03'!
* anObject
	^ domain to: codomain matrix: matrix * anObject! !

!ModuleMap methodsFor: 'operations' stamp: 'len 5/16/2019 20:57:21'!
+ aModuleMap
	(aModuleMap isKindOf: ModuleMap) ifFalse: [^ super + aModuleMap].
	(self domain == aModuleMap domain
		and: [self codomain == aModuleMap codomain])
			ifTrue: [^ domain to: codomain matrix: matrix + aModuleMap matrix].
	(self domain = aModuleMap domain and: [self codomain = aModuleMap codomain])
			ifTrue: [^ domain to: codomain evaluating: [:v| (self value: v) + (aModuleMap value: v)]].
	^ DomainError signal: 'domains don''t match'
"	(self domain = aMap domain and: [self codomain = aMap codomain])
		ifFalse: [^ DomainError signal: 'domains don''t match'].
	^ self parent evaluating: [:each| (self value: each) + (aMap value: each)]"! !

!ModuleMap methodsFor: 'operations' stamp: 'len 5/7/2019 08:47:03'!
- aModuleMap
	^ self + aModuleMap negated! !

!ModuleMap methodsFor: 'operations' stamp: 'len 5/16/2019 21:03:36'!
 aModuleMap
	"Answer the composition of the receiver with the argument."
	domain == aModuleMap codomain
		ifTrue: [^ aModuleMap domain to: codomain matrix: matrix  aModuleMap matrix].
	domain >= aModuleMap codomain
		ifTrue: [^ aModuleMap domain to: codomain evaluating: [:each| self value: (aModuleMap value: each)]].
	^ DomainError signal: 'domains don''t match'! !

!ModuleMap methodsFor: 'operations' stamp: 'len 5/16/2019 20:58:12'!
 aModuleMap
	"Answer the direct sum of the receiver and the argument."
	^ domain  aModuleMap domain to: codomain  aModuleMap codomain matrix: matrix  aModuleMap matrix! !

!ModuleMap methodsFor: 'operations' stamp: 'len 5/16/2019 20:58:25'!
 aModuleMap
	"Answer the tensor product of the receiver with the argument."
	^ domain  aModuleMap domain to: codomain  aModuleMap codomain matrix: matrix  aModuleMap matrix! !

!ModuleMap methodsFor: 'operations' stamp: 'len 5/16/2019 20:42:31'!
cokernel
	self notYetImplemented! !

!ModuleMap methodsFor: 'operations' stamp: 'len 5/24/2019 10:14:46'!
colift: aModuleMap
	"Answer the colift of aModuleMap along the receiver.
	A morphism p:M -> C is called 'the' cokernel of f:M -> N (and C 'the' cokernel object of f) if
	  i. f p = 0, and
	  ii. for all L and all morphisms g:N -> L with fg = 0, there exists a unique morphism g0:C -> L such that g = g0 p. g0 is called the 'colift' of g along p."
	self notYetImplemented! !

!ModuleMap methodsFor: 'operations' stamp: 'len 5/30/2019 07:05:02'!
coproduct: aModuleMap
	"Answer the coproduct of the receiver and the argument."
	codomain = aModuleMap codomain ifFalse: [DomainError signal].
	^ domain  aModuleMap domain to: codomain matrix: (matrix rowAugmented: aModuleMap matrix)! !

!ModuleMap methodsFor: 'operations' stamp: 'len 5/16/2019 20:59:53'!
image
	^ self propertyAt: #image ifAbsentPut: [codomain span: (domain generators collect: [:each| self value: each])]! !

!ModuleMap methodsFor: 'operations' stamp: 'len 5/16/2019 20:43:10'!
kernel
	self notYetImplemented! !

!ModuleMap methodsFor: 'operations' stamp: 'len 5/24/2019 10:15:31'!
lift: aModuleMap
	"Answer the lift of aModuleMap along the receiver.
	A morphism k:K -> M is called 'the' kernel of f:M -> N (and K 'the' kernel object of f) if
	  i. k f = 0, and
	  ii. for all L and all morphisms g:L -> M with g f = 0, there exists a unique morphism g0:L -> K such that g = g0 k. g0 is called the 'lift' of g along k."
	self notYetImplemented! !

!ModuleMap methodsFor: 'operations' stamp: 'len 5/16/2019 20:56:50'!
negated
	^ domain to: codomain matrix: matrix negated! !

!ModuleMap methodsFor: 'operations' stamp: 'len 5/30/2019 07:04:43'!
product: aModuleMap
	"Answer the product of the receiver and the argument."
	domain = aModuleMap domain ifFalse: [DomainError signal].
	^ domain to: codomain  aModuleMap codomain matrix: (matrix columnAugmented: aModuleMap matrix)! !

!ModuleMap methodsFor: 'operations' stamp: 'len 5/16/2019 20:52:35'!
projectiveLift: aFreeModuleMap
	"P is called projective if for each morphism f:P->N and each morphism g:M->N with im(f) <= im(g) there exists a projective lift h:P->M of f along g."
	self notYetImplemented! !

!ModuleMap methodsFor: 'testing' stamp: 'len 5/5/2019 18:32:17'!
isIdempotent
	^ self isEndomorphism and: [self  self = self]! !

!ModuleMap methodsFor: 'testing' stamp: 'len 10/10/2016 20:09'!
isIdentity
	self isEndomorphism ifFalse: [^ false].
	^ (self domain generators ifNil: [self domain]) allSatisfy: [:each| (self value: each) = each]! !

!ModuleMap methodsFor: 'testing' stamp: 'len 5/16/2019 20:42:56'!
isInjective
	^ self kernel isTrivial! !

!ModuleMap methodsFor: 'testing' stamp: 'len 5/10/2019 07:41:27'!
isModuleHomomorphism
	^ true! !

!ModuleMap methodsFor: 'testing' stamp: 'len 1/13/2018 21:54:27'!
isProjection
	^ self isIdempotent! !

!ModuleMap methodsFor: 'testing' stamp: 'len 5/16/2019 20:43:02'!
isSurjective
	^ self cokernel isTrivial! !

!ModuleMap methodsFor: 'testing' stamp: 'len 1/13/2018 21:53:54'!
isTrivial
	^ self isZero! !

!ModuleMap methodsFor: 'testing' stamp: 'len 11/2/2016 07:58'!
isZero
	^ self domain generators allSatisfy: [:each| (self value: each) isZero]! !

!ModuleMap methodsFor: 'private' stamp: 'len 5/16/2019 20:40:52'!
codomain: aModule
	codomain _ aModule! !

!ModuleMap methodsFor: 'private' stamp: 'len 5/16/2019 20:40:56'!
domain: aModule
	domain _ aModule! !

!ModuleMap methodsFor: 'private' stamp: 'len 5/16/2019 20:41:10'!
matrix: aMatrix
	matrix _ aMatrix! !

!ModuleMap methodsFor: 'private' stamp: 'len 1/11/2018 18:20:06'!
species
	^ ModuleMap! !

!ModuleMap methodsFor: 'private' stamp: 'len 5/15/2019 08:02:02'!
verify
	^ super isModuleHomomorphism! !

!ModuleMap class methodsFor: 'instance creation' stamp: 'len 5/16/2019 18:38:40'!
from: anFPModule to: anotherFPModule matrix: aMatrix
	^ self new
		domain: anFPModule;
		codomain: anotherFPModule;
		matrix: aMatrix! !

!FreeModuleMap methodsFor: 'accessing' stamp: 'len 2/8/2016 23:58'!
automorphism
	"Answer the field automorphism associated with the receiver, looking at the receiver as a semilinear transformation. This is the identity automorphism."
	^ self domain scalars id! !

!FreeModuleMap methodsFor: 'accessing' stamp: 'len 5/16/2019 21:06:18'!
identity
	^ domain to: codomain matrix: matrix identity! !

!FreeModuleMap methodsFor: 'accessing' stamp: 'len 3/5/2017 09:20:05'!
scalars
	^ matrix scalars! !

!FreeModuleMap methodsFor: 'comparing' stamp: 'len 5/16/2019 20:51:43'!
= anObject
	self == anObject ifTrue: [^ true].
	(anObject isKindOf: FreeModuleMap) ifFalse: [^ super = anObject].
	^ self domain = anObject domain and: [self codomain = anObject codomain and: [self matrix = anObject matrix]]! !

!FreeModuleMap methodsFor: 'comparing' stamp: 'len 4/23/2019 06:54:54'!
hash
	^ self matrix hash! !

!FreeModuleMap methodsFor: 'converting' stamp: 'len 4/29/2019 10:21:07'!
asPolynomial
	"If the receiver is a linear form, answer the receiver as a polynomial in the coordinate ring of the domain."
	| P |
	self isLinearForm ifFalse: [DomainError signal: 'not a linear form'].
	P _ self domain coordinateRing.
	^ (P tuple: P rank evaluating: [:i| P x: i])  (self class from: self domain to: self codomain evaluating: self) matrix asTuple "use matrix in the standard basis"! !

!FreeModuleMap methodsFor: 'converting' stamp: 'len 1/3/2017 08:31:26'!
asRationalMap
	| P polynomials |
	P _ self domain coordinateRing.
	"use matrix in the standard basis:"
	polynomials _ ((self class from: self domain to: self codomain evaluating: self) matrix over: P) * (P tuple: P rank evaluating: [:i| P x: i]).
	^ RationalMap from: P spec to: self codomain coordinateRing spec polynomials: polynomials asArray! !

!FreeModuleMap methodsFor: 'converting' stamp: 'len 5/14/2019 20:46:13'!
asTensor
	"Answer the tensor expansion of the receiver."
	^ self domain dual  self codomain evaluating: [:indices| matrix at: indices second @ indices first]! !

!FreeModuleMap methodsFor: 'operations' stamp: 'len 5/16/2019 21:03:07'!
+ anObject
	(codomain includes: anObject) ifTrue: [^ AffineMap linearMap: self translation: anObject].
	^ super + anObject! !

!FreeModuleMap methodsFor: 'operations' stamp: 'len 5/16/2019 21:04:20'!
adjoint
	"Answer the transpose (or dual, or adjoint) of the receiver.
	The assignment of a linear map f:V->W to its dual f*:W*->V* produces an injective linear map between Hom(V,W) and Hom(W*,V*).
	This is the 'operator adjoint', not to be confused with the 'Hilbert adjoint' that is defined for an operator in an inner product space."
	^ codomain dual to: domain dual matrix: matrix adjoint! !

!FreeModuleMap methodsFor: 'operations' stamp: 'len 2/22/2017 09:05:31'!
characteristicPolynomial
	self isEndomorphism ifFalse: [DomainError signal: 'not an endomorphism'].
	^ matrix characteristicPolynomial! !

!FreeModuleMap methodsFor: 'operations' stamp: 'len 1/23/2018 16:51:35'!
corank
	^ self cokernel rank! !

!FreeModuleMap methodsFor: 'operations' stamp: 'len 2/22/2017 09:05:41'!
determinant
	self isEndomorphism ifFalse: [DomainError signal: 'not an endomorphism'].
	^ matrix determinant! !

!FreeModuleMap methodsFor: 'operations' stamp: 'len 1/23/2018 16:53:39'!
index
	"Answer the index of the receiver, assuming it is an endomorphism.
	This is precisely the Euler characteristic of the 2-term complex 0 -> Domain -> Codomain -> 0."
	^ self kernel rank - self cokernel rank! !

!FreeModuleMap methodsFor: 'operations' stamp: 'len 5/16/2019 21:04:55'!
inverse
	"Answer the inverse of the receiver. Answer nil if the receiver is not an isomorphism."
	^ domain rank = codomain rank ifTrue: [self retraction]! !

!FreeModuleMap methodsFor: 'operations' stamp: 'len 4/2/2018 17:17:59'!
kernel
	^ self propertyAt: #kernel ifAbsentPut: [self isTrivial ifTrue: [self domain] ifFalse: [self domain span: matrix kernelMatrix]]! !

!FreeModuleMap methodsFor: 'operations' stamp: 'len 5/27/2019 07:10:03'!
kernel2
	^ self propertyAt: #kernel ifAbsentPut: [(self preimage: self codomain ambient zero) direction] "!! 3-5 times slower than the other implementaiton"! !

!FreeModuleMap methodsFor: 'operations' stamp: 'len 2/22/2017 09:05:25'!
minimalPolynomial
	self isEndomorphism ifFalse: [DomainError signal: 'not an endomorphism'].
	^ matrix minimalPolynomial! !

!FreeModuleMap methodsFor: 'operations' stamp: 'len 4/5/2018 15:28:12'!
nullity
	"Answer the dimension of the kernel of the receiver."
	^ matrix width - self rank! !

!FreeModuleMap methodsFor: 'operations' stamp: 'len 5/27/2019 07:08:03'!
preimage: anElement
	"Answer the preimage of anElement.
	The answer is an affine subspace (a linear variety or flat)."
	^ self kernel + (self preimageRepresentative: anElement)! !

!FreeModuleMap methodsFor: 'operations' stamp: 'len 5/30/2019 07:05:38'!
preimageRepresentative: anElement
	"Answer a representative of the preimage of anElement.
	Answer nil if anElement is not in the image of the receiver."
	| n B M1 V r j0 d x |
	n _ matrix width.
	B _ codomain coordinatesOf: anElement.
	"1. Compute kernel"
	M1 _ matrix columnAugmented: B.
	V _ M1 kernelMatrix.
	r _ V height.
	"2. Solution exists?"
	j0 _ (1 to: r) detect: [:j| (V at: j@(n+1)) isZero not] ifNone: [^ nil "no solution"].
	d _ (V at: j0@(n+1)) negated.
	x _ self scalars tuple: n evaluating: [:i| (V at: j0@i) / d].
	"K _ V copyFrom: 1@1 to: (r-1)@n. <- this is 'self matrix kernelMatrix', should avoid computing the kernel again, and cache it"
	^ domain elementAt: x! !

!FreeModuleMap methodsFor: 'operations' stamp: 'len 1/8/2016 06:35'!
rank
	^ matrix rank! !

!FreeModuleMap methodsFor: 'operations' stamp: 'len 5/16/2019 12:25:15'!
retraction
	"Answer a left inverse (or retraction) of the receiver.
	Answer nil if the receiver is not a monomorphism."
	^ self propertyAt: #retraction ifAbsentPut: [self computeLeftInverse]! !

!FreeModuleMap methodsFor: 'operations' stamp: 'len 5/16/2019 12:25:30'!
section
	"Answer a right inverse (or section) of the receiver.
	Answer nil if the receiver is not an epimorphism."
	^ self propertyAt: #section ifAbsentPut: [self computeRightInverse]! !

!FreeModuleMap methodsFor: 'operations' stamp: 'len 2/22/2017 09:05:16'!
trace
	self isEndomorphism ifFalse: [DomainError signal: 'not an endomorphism'].
	^ matrix trace! !

!FreeModuleMap methodsFor: 'operations' stamp: 'len 1/21/2018 21:32:58'!
value: anElement
	(domain isTrivial or: [codomain isTrivial])
		ifTrue: [^ codomain ambient zero].
	^ codomain elementAt: matrix * (domain coordinatesOf: anElement)! !

!FreeModuleMap methodsFor: 'spectrum' stamp: 'len 2/6/2016 21:37'!
algebraicMultiplicityAt: anEigenvalue
	^ self characteristicPolynomial multiplicityAt: anEigenvalue! !

!FreeModuleMap methodsFor: 'spectrum' stamp: 'len 2/6/2016 21:25'!
eigenspaceAt: anEigenvalue
	^ (self - (self identity * anEigenvalue)) kernel! !

!FreeModuleMap methodsFor: 'spectrum' stamp: 'len 2/22/2017 08:45:06'!
eigenvalues
	self isEndomorphism ifFalse: [DomainError signal: 'not an endomorphism'].
	^ matrix eigenvalues! !

!FreeModuleMap methodsFor: 'spectrum' stamp: 'len 2/6/2016 21:37'!
geometricMultiplicityAt: anEigenvalue
	^ (self eigenspaceAt: anEigenvalue) dimension! !

!FreeModuleMap methodsFor: 'spectrum' stamp: 'len 2/22/2017 08:45:22'!
spectrum
	self isEndomorphism ifFalse: [DomainError signal: 'not an endomorphism'].
	^ matrix spectrum! !

!FreeModuleMap methodsFor: 'testing' stamp: 'len 9/1/97 23:23'!
isConstant
	"Answer true if the receiver is a constant transformation."

	^ self rank <= 1! !

!FreeModuleMap methodsFor: 'testing' stamp: 'len 1/21/2018 21:41:54'!
isIdentity
	^ self isEndomorphism and: [matrix isIdentity]! !

!FreeModuleMap methodsFor: 'testing' stamp: 'len 1/21/2018 21:42:01'!
isInjective
	^ self rank = self domain rank! !

!FreeModuleMap methodsFor: 'testing' stamp: 'len 5/16/2019 12:41:59'!
isIsomorphism
	^ matrix isInvertible! !

!FreeModuleMap methodsFor: 'testing' stamp: 'len 4/26/2019 12:56:25'!
isLinearForm
	"Answer true if the receiver is a linear form (or linear functional, one-form, covector)."
	^ self codomain isKindOf: RingModule! !

!FreeModuleMap methodsFor: 'testing' stamp: 'len 1/15/2018 20:31:44'!
isLocallySimple
	"Answer true if the receiver is locally simple.
	Given a linear map f:M->N, it is locally simple if there exists a map g:N->M satisfying fgf = f."
	^ self notYetImplemented! !

!FreeModuleMap methodsFor: 'testing' stamp: 'len 2/11/2016 21:33'!
isOrthogonal
	^ matrix isOrthogonal! !

!FreeModuleMap methodsFor: 'testing' stamp: 'len 5/16/2019 20:54:43'!
isScalar
	^ matrix isScalar! !

!FreeModuleMap methodsFor: 'testing' stamp: 'len 5/16/2019 20:54:52'!
isSemisimple
	^ matrix isSemisimple! !

!FreeModuleMap methodsFor: 'testing' stamp: 'len 9/27/2018 20:53:11'!
isSingular
	^ matrix isSingular! !

!FreeModuleMap methodsFor: 'testing' stamp: 'len 1/21/2018 21:36:53'!
isSurjective
	^ self rank = self codomain rank! !

!FreeModuleMap methodsFor: 'testing' stamp: 'len 5/16/2019 20:55:04'!
isUnimodular
	^ matrix isUnimodular! !

!FreeModuleMap methodsFor: 'testing' stamp: 'len 1/8/2016 06:34'!
isZero
	^ matrix isZero! !

!FreeModuleMap methodsFor: 'private' stamp: 'len 5/16/2019 21:05:45'!
computeLeftInverse
	^ self isMonomorphism ifTrue: [codomain to: domain matrix: matrix retraction]! !

!FreeModuleMap methodsFor: 'private' stamp: 'len 5/16/2019 21:05:59'!
computeRightInverse
	^ self isEpimorphism ifTrue: [codomain to: domain matrix: matrix section]! !

!FreeModuleMap methodsFor: 'private' stamp: 'len 5/13/2019 14:00:48'!
species
	^ FreeModuleMap! !

!FreeModuleMap class methodsFor: 'examples' stamp: 'len 2/21/2017 21:08:31'!
example1
	"The transposition of matrices is a linear map:"
	^ QQ^(3@2) to: QQ^(2@3) evaluating: [:A| A transposed]! !

!FreeModuleMap class methodsFor: 'instance creation' stamp: 'len 1/22/2018 19:30:12'!
from: aDomain to: aCodomain evaluating: aBlock
	"Answer a new instance of the receiver using the one argument block aBlock for evaluating each vector in the domain basis."
	| matrix |
	matrix _ Matrix rows: (aDomain basis collect: [:each| aCodomain coordinatesOf: (aBlock value: each)]).
	^ self from: aDomain to: aCodomain matrix: matrix transposed! !

!FreeModuleMap class methodsFor: 'instance creation' stamp: 'len 5/16/2019 02:51:36'!
from: aFreeModule to: anotherFreeModule matrix: aMatrix
	^ self new
		domain: aFreeModule;
		codomain: anotherFreeModule;
		matrix: aMatrix! !

!AffineMap methodsFor: 'accessing' stamp: 'len 1/22/2018 17:20:55'!
bitSize
	^ linearMap bitSize + translation bitSize! !

!AffineMap methodsFor: 'accessing' stamp: 'len 1/22/2018 20:11:17'!
codomain
	^ linearMap codomain! !

!AffineMap methodsFor: 'accessing' stamp: 'len 1/22/2018 17:15:34'!
domain
	^ linearMap domain! !

!AffineMap methodsFor: 'accessing' stamp: 'len 4/7/2018 06:21:34'!
matrix
	| K zero A b |
	K _ linearMap domain scalars.
	zero _ K zero.
	A _ linearMap matrix.
	b _ linearMap codomain coordinatesOf: translation.
	^ K matrix: A extent + (1@1)
		evaluating: [:i :j|
			(i <= A height and: [j <= A width])
				ifTrue: [A at: i@j]
				ifFalse: [j = A width + 1
					ifTrue: [i <= b size ifTrue: [b at: i] ifFalse: [K one]]
					ifFalse: [zero]]]! !

!AffineMap methodsFor: 'comparing' stamp: 'len 1/22/2018 17:12:38'!
= anAffineMap
	^ (anAffineMap isKindOf: AffineMap) and: [linearMap = anAffineMap linearMap and: [translation = anAffineMap translation]]! !

!AffineMap methodsFor: 'comparing' stamp: 'len 1/22/2018 17:13:05'!
hash
	^ linearMap hash + translation hash hashMultiply! !

!AffineMap methodsFor: 'converting' stamp: 'len 5/12/2018 19:16:13'!
asPolynomial
	^ linearMap asPolynomial + (linearMap codomain coordinatesOf: translation) first! !

!AffineMap methodsFor: 'converting' stamp: 'len 5/20/2018 16:18:56'!
asRationalMap
	^ linearMap asRationalMap + (linearMap codomain coordinatesOf: translation)! !

!AffineMap methodsFor: 'operations' stamp: 'len 1/22/2018 17:08:32'!
* aNumber
	^ self class linearMap: linearMap * aNumber translation: translation * aNumber! !

!AffineMap methodsFor: 'operations' stamp: 'len 5/13/2019 14:00:48'!
+ anObject
	(anObject isKindOf: AffineMap)
		ifTrue:
			[^ self class linearMap: linearMap + anObject linearMap translation: translation + anObject translation].
	((anObject isKindOf: FreeModuleMap) and: [linearMap domain = anObject domain and: [linearMap codomain = anObject codomain]])
		ifTrue:
			[^ self class linearMap: linearMap + anObject translation: translation].
	(self codomain includes: anObject)
		ifTrue: [^ self class linearMap: linearMap translation: translation + anObject].
	^ DomainError signal! !

!AffineMap methodsFor: 'operations' stamp: 'len 5/5/2019 18:24:33'!
 anAffineMap
	self domain >= anAffineMap codomain ifFalse: [^ DomainError signal: 'domains don''t match'].
	^ self class from: anAffineMap domain to: self codomain evaluating: [:x| self value: (anAffineMap value: x)]! !

!AffineMap methodsFor: 'operations' stamp: 'len 4/28/2019 16:33:39'!
image
	^ AffineSubspace representative: translation direction: linearMap image! !

!AffineMap methodsFor: 'operations' stamp: 'len 5/16/2019 12:23:12'!
inverse
	"Answer the inverse of the receiver. Answer nil if the receiver is not an isomorphism."
	^ self domain dimension = self codomain dimension ifTrue: [self retraction]! !

!AffineMap methodsFor: 'operations' stamp: 'len 1/22/2018 17:11:14'!
negated
	^ self class linearMap: linearMap negated translation: translation negated! !

!AffineMap methodsFor: 'operations' stamp: 'len 5/27/2019 07:11:03'!
preimage: aPoint
	^ linearMap preimage: aPoint - translation! !

!AffineMap methodsFor: 'operations' stamp: 'len 5/16/2019 12:19:48'!
retraction
	"Answer a left inverse (or retraction) of the receiver.
	Answer nil if the receiver is not a monomorphism."
	^ linearMap retraction ifNotNil: [:aLinearMap| self class linearMap: aLinearMap translation: (aLinearMap value: translation negated)]! !

!AffineMap methodsFor: 'operations' stamp: 'len 5/16/2019 12:20:09'!
section
	"Answer a right inverse (or section) of the receiver.
	Answer nil if the receiver is not an epimorphism."
	^ linearMap section ifNotNil: [:aLinearMap| self class linearMap: aLinearMap translation: (aLinearMap value: translation negated)]! !

!AffineMap methodsFor: 'operations' stamp: 'len 1/22/2018 17:13:52'!
value: aPoint
	^ (linearMap value: aPoint) + translation! !

!AffineMap methodsFor: 'testing' stamp: 'len 2/12/2016 01:37'!
isEuclidean
	"Answer true if the receiver is an Euclidean motion, i.e. if it preserves distances.
	The Euclidean nitions of an affine space A form a group, the Euclidean group E(A) (sometimes called group of motions M(A) or group of isometries ISO(A))."
	^ self isIsometry! !

!AffineMap methodsFor: 'testing' stamp: 'len 1/22/2018 17:14:48'!
isIdentity
	^ translation isZero and: [linearMap isIdentity]! !

!AffineMap methodsFor: 'testing' stamp: 'len 1/22/2018 17:14:54'!
isInjective
	^ linearMap isInjective! !

!AffineMap methodsFor: 'testing' stamp: 'len 1/22/2018 17:14:58'!
isIsometry
	"Answer true if the receiver is an isometry, i.e. if it preserves distances.
	The isometries of an affine space A form a group, the Euclidean group E(A) (sometimes called group of Euclidean motions M(A) or group of isometries ISO(A))."
	^ linearMap isOrthogonal! !

!AffineMap methodsFor: 'testing' stamp: 'len 1/22/2018 17:15:03'!
isSurjective
	^ linearMap isSurjective! !

!AffineMap methodsFor: 'private' stamp: 'len 1/22/2018 17:18:15'!
linearMap
	^ linearMap! !

!AffineMap methodsFor: 'private' stamp: 'len 1/22/2018 17:18:05'!
linearMap: aLinearMap
	linearMap _ aLinearMap! !

!AffineMap methodsFor: 'private' stamp: 'len 1/2/2017 19:56:25'!
translation
	^ translation! !

!AffineMap methodsFor: 'private' stamp: 'len 11/20/2015 15:58'!
translation: aVector
	translation _ aVector! !

!AffineMap class methodsFor: 'instance creation' stamp: 'len 5/13/2019 14:00:48'!
from: aDomain to: aCodomain evaluating: aBlock
	| linearMap translation |
	translation _ aBlock value: aDomain zero.
	linearMap _ FreeModuleMap from: aDomain to: aCodomain evaluating: [:v| (aBlock value: v) - translation].
	^ self linearMap: linearMap translation: translation! !

!AffineMap class methodsFor: 'instance creation' stamp: 'len 1/3/2016 04:38'!
from: anAffineFrame to: anotherAffineFrame matrix: aMatrix
	^ self notYetImplemented! !

!AffineMap class methodsFor: 'instance creation' stamp: 'len 1/22/2018 20:10:57'!
linearMap: aLinearMap translation: aVector
	(aLinearMap codomain includes: aVector)
		ifFalse: [^ DomainError signal: 'translation vector is outside of the codomain'].
	^ self new linearMap: aLinearMap; translation: aVector! !

!QuadraticForm methodsFor: 'accessing' stamp: 'len 3/28/2018 02:47:11'!
at: aPoint
	| i j n |
	i _ aPoint x - 1.
	j _ aPoint y - 1.
	i > j ifTrue: [i _ j. j _ aPoint x - 1].
	n _ self rank.
	^ self coefficients at: i * n - (i-1*i//2) + j - i + 1! !

!QuadraticForm methodsFor: 'accessing' stamp: 'len 3/28/2018 03:01:03'!
bitSize
	^ self coefficients bitSize! !

!QuadraticForm methodsFor: 'accessing' stamp: 'len 12/30/2015 21:16'!
codomain
	^ self scalars! !

!QuadraticForm methodsFor: 'accessing' stamp: 'len 3/28/2018 03:00:51'!
coefficients
	"Answer the coefficients of the receiver in lexicographical order."
	^ coefficients! !

!QuadraticForm methodsFor: 'accessing' stamp: 'len 9/22/2018 18:57:55'!
content
	^ self coefficients content! !

!QuadraticForm methodsFor: 'accessing' stamp: 'len 3/28/2018 03:12:29'!
determinant
	"Answer the determinant of the Hessian matrix of the receiver. This is the determinant of the Gram matrix of twice the receiver."
	^ self hessian determinant! !

!QuadraticForm methodsFor: 'accessing' stamp: 'len 9/22/2018 18:57:51'!
discriminant
	"Note: this invariant is defined differently by different authors."
	self rank odd ifTrue: [^ self determinant / 2].
	(self rank // 2) odd ifTrue: [self determinant negated].
	^ self determinant! !

!QuadraticForm methodsFor: 'accessing' stamp: 'len 9/2/2018 20:54:02'!
gramian
	"Answer the Gramian matrix G for the receiver Q.
	This is a matrix G such that Q(x) = x^t * G * x."
	^ self hessian collect: [:each| each / 2] "assuming we can divide by 2"! !

!QuadraticForm methodsFor: 'accessing' stamp: 'len 6/3/2018 19:06:09'!
hessian
	"Answer the Hessian matrix H for the receiver Q.
	This is a matrix H such that Q(x) = x^t * H * x / 2."
	^ self scalars matrix: self domain rank evaluating: [:i :j| i = j ifTrue: [(self at: i@j)*2] ifFalse: [self at: i@j]]! !

!QuadraticForm methodsFor: 'accessing' stamp: 'len 3/27/2018 23:58:26'!
rank
	^ self domain rank! !

!QuadraticForm methodsFor: 'accessing' stamp: 'len 3/19/2018 20:00:15'!
scalars
	^ self domain scalars! !

!QuadraticForm methodsFor: 'accessing-private' stamp: 'len 3/28/2018 03:06:18'!
coefficients: aTuple
	coefficients _ aTuple! !

!QuadraticForm methodsFor: 'arithmetic' stamp: 'len 3/28/2018 02:59:45'!
* anObject
	^ self class from: self domain coefficients: self coefficients * anObject! !

!QuadraticForm methodsFor: 'arithmetic' stamp: 'len 3/28/2018 15:18:01'!
+ aQuadraticForm
	self domain = aQuadraticForm domain ifFalse: [^ self error: 'domains don''t match'].
	self domain matrix = aQuadraticForm domain matrix ifFalse: [self notYetImplemented].
	^ self class
		from: self domain
		coefficients: self coefficients + aQuadraticForm coefficients! !

!QuadraticForm methodsFor: 'arithmetic' stamp: 'len 3/28/2018 03:00:18'!
 aQuadraticForm
	"Answer the direct sum of the receiver and the argument."
	(aQuadraticForm isKindOf: QuadraticForm) ifFalse: [^ DomainError signal].
	^ self notYetImplemented! !

!QuadraticForm methodsFor: 'arithmetic' stamp: 'len 3/28/2018 02:59:58'!
negated
	^ self class from: self domain coefficients: self coefficients negated! !

!QuadraticForm methodsFor: 'comparing' stamp: 'len 3/28/2018 03:12:11'!
= aQuadraticForm
	(aQuadraticForm isKindOf: QuadraticForm) ifFalse: [^ false].
	^ self coefficients = aQuadraticForm coefficients! !

!QuadraticForm methodsFor: 'comparing' stamp: 'len 9/22/2018 18:57:58'!
~ aQuadraticForm
	"Answer true if the receiver and the argument are integrally equivalent."
	^ self hessian ~ aQuadraticForm hessian! !

!QuadraticForm methodsFor: 'comparing' stamp: 'len 3/28/2018 03:12:33'!
hash
	^ self coefficients hash! !

!QuadraticForm methodsFor: 'converting' stamp: 'len 3/28/2018 03:03:12'!
asPolynomial
	| n P |
	n _ self rank.
	P _ self domain coordinateRing.
	^ self value: (P tuple: n evaluating: [:i| P x: i])! !

!QuadraticForm methodsFor: 'converting' stamp: 'len 6/3/2018 18:44:48'!
associatedBilinearForm
	"Answer the associated symmetric bilinear form (assuming the characteristic is not 2).
	This is, via the polarization identity: B(v,w) := (Q(v+w) - Q(v-w)) / 4."
	^ BilinearForm fromHalf: self domain matrix: self gramian! !

!QuadraticForm methodsFor: 'operations' stamp: 'len 3/28/2018 18:46:47'!
adjoint
	"Answer the adjoint (integral) quadratic form associated to the receiver."
	| A |
	A _ self hessian adjoint.
	self rank odd ifTrue: [A _ A*2].
	^ self class from: self domain hessian: A! !

!QuadraticForm methodsFor: 'operations' stamp: 'len 9/22/2018 18:57:46'!
primitive
	^ self class from: self domain coefficients: self coefficients primitive! !

!QuadraticForm methodsFor: 'operations' stamp: 'len 3/28/2018 18:48:53'!
reciprocal
	^ self adjoint primitive * self content! !

!QuadraticForm methodsFor: 'operations' stamp: 'len 3/28/2018 02:53:34'!
value: aVector
	| v n answer |
	v _ self domain coordinatesOf: aVector.
	n _ self rank.
	answer _ self scalars zero.
	1 to: n do: [:i|
		| vi |
		vi _ v at: i.
		i to: n do: [:j|
			answer _ (self at: i@j) * vi * (v at: j) + answer]].
	^ answer! !

!QuadraticForm methodsFor: 'testing' stamp: 'len 3/28/2018 03:12:40'!
isDiagonal
	"Answer true if the receiver is in diagonal form."
	^ self hessian isDiagonal! !

!QuadraticForm methodsFor: 'testing' stamp: 'len 3/28/2018 01:03:53'!
isPrimitive
	^ self content = self scalars one! !

!QuadraticForm methodsFor: 'testing' stamp: 'len 6/3/2018 18:34:21'!
isRegular
	^ self associatedBilinearForm isNonDegenerate! !

!QuadraticForm class methodsFor: 'instance creation' stamp: 'len 3/28/2018 03:14:10'!
coefficients: aTuple
	"Answer the quadratic form with the given coefficients (in lexicographical order)."
	^ self from: aTuple scalars ^ (aTuple size * 2) sqrtFloor coefficients: aTuple! !

!QuadraticForm class methodsFor: 'instance creation' stamp: 'len 3/28/2018 02:57:27'!
from: aModule coefficients: aTuple
	"Answer the quadratic form associated with the given coefficients (in lexicographical order) in the distinguished basis of the given free module."
	^ self new domain: aModule; coefficients: aTuple! !

!MultilinearMap methodsFor: 'as yet unclassified' stamp: 'len 9/22/2018 21:51:57'!
asTensorMap
	^ self propertyAt: #tensorMap! !

!MultilinearMap methodsFor: 'as yet unclassified' stamp: 'len 9/22/2018 21:53:00'!
tensorMap: aLinearMap
	self propertyAt: #tensorMap put: aLinearMap! !

!MultilinearMap class methodsFor: 'as yet unclassified' stamp: 'len 9/22/2018 22:08:14'!
from: aProductOfModules to: aModule evaluating: aBlock
	| T |
	T _ TensorProductModule components: aProductOfModules components.
	^ self new tensorMap: (T to: aModule evaluating: [:each| aBlock value: each asSimpleTensor])! !

!BilinearMap methodsFor: 'as yet unclassified' stamp: 'len 4/24/2019 08:35:20'!
left
	"Answer the linear map that fixes the first argument."
	| X Y |
	X _ self domain at: 1.
	Y _ self domain at: 2.
	^ X to: Y => self codomain evaluating: [:x| Y evaluating: [:y| self value: x value: y]]! !

!BilinearMap methodsFor: 'as yet unclassified' stamp: 'len 4/24/2019 08:35:14'!
right
	"Answer the linear map that fixes the second argument."
	| X Y |
	X _ self domain at: 1.
	Y _ self domain at: 2.
	^ Y to: X => self codomain evaluating: [:y| X evaluating: [:x| self value: x value: y]]! !

!BilinearForm methodsFor: 'accessing' stamp: 'len 12/28/2015 21:09'!
bitSize
	^ matrix bitSize! !

!BilinearForm methodsFor: 'accessing' stamp: 'len 1/8/2016 06:36'!
codomain
	^ self scalars! !

!BilinearForm methodsFor: 'accessing' stamp: 'len 3/18/2018 18:35:22'!
domain
	^ (halfDomain, halfDomain)! !

!BilinearForm methodsFor: 'accessing' stamp: 'len 3/18/2018 18:37:03'!
halfDomain
	^ halfDomain! !

!BilinearForm methodsFor: 'accessing' stamp: 'len 11/7/2015 23:26'!
matrix
	^ matrix! !

!BilinearForm methodsFor: 'accessing' stamp: 'len 3/18/2018 18:35:37'!
scalars
	^ halfDomain scalars! !

!BilinearForm methodsFor: 'accessing-private' stamp: 'len 3/18/2018 18:34:25'!
halfDomain: aFreeModule
	halfDomain _ aFreeModule! !

!BilinearForm methodsFor: 'accessing-private' stamp: 'len 8/23/97 15:35'!
matrix: aMatrix
	matrix _ aMatrix! !

!BilinearForm methodsFor: 'arithmetic' stamp: 'len 3/18/2018 18:36:07'!
* anObject
	^ self class fromHalf: halfDomain matrix: matrix * anObject! !

!BilinearForm methodsFor: 'arithmetic' stamp: 'len 3/18/2018 18:36:53'!
+ aBilinearForm
	halfDomain = aBilinearForm halfDomain ifFalse: [^ self error: 'domains don''t match'].
	^ self class
		from: halfDomain
		evaluating: [:each| (self value: each) + (aBilinearForm value: each)]! !

!BilinearForm methodsFor: 'arithmetic' stamp: 'len 3/18/2018 18:37:19'!
negated
	^ self class fromHalf: halfDomain matrix: matrix negated! !

!BilinearForm methodsFor: 'converting' stamp: 'len 5/5/2019 17:35:25'!
asPolynomial
	| n P x y |
	n _ matrix height.
	P _ self scalars polynomialsIn: ((1 to: n) collect: [:i| 'x' asText, i printString sub]), ((1 to: n) collect: [:i| 'y' asText, i printString sub]).
	x _ P tuple: n evaluating: [:i| P x: i].
	y _ P tuple: n evaluating: [:i| P x: n+i].
	^ x  ((matrix over: P) * y)! !

!BilinearForm methodsFor: 'converting' stamp: 'len 5/14/2019 20:45:47'!
asTensor
	"Answer the tensor expansion of the receiver."
	^ self halfDomain dual  self halfDomain dual evaluating: [:indices| matrix at: indices second @ indices first]! !

!BilinearForm methodsFor: 'converting' stamp: 'len 9/22/2018 21:49:42'!
asTensorMap
	"Bilinear forms on V are in 1-to-1 correspondence with linear maps from V tensor V to the base field K."
	^ self notYetImplemented! !

!BilinearForm methodsFor: 'converting' stamp: 'len 6/3/2018 18:32:33'!
associatedQuadraticForm
	"Answer the associated quadratic form Q(v) := B(v,v)."
	^ QuadraticForm from: halfDomain matrix: matrix! !

!BilinearForm methodsFor: 'operations' stamp: 'len 10/4/2016 12:27'!
left
	"Answer the linear map from the domain to its dual that fixes the right argument. If the bilinear form is non-degenerate, this map is an isomorphism."
	| V Vdual |
	V _ self domain at: 1.
	Vdual _ V dual.
	^ V to: Vdual evaluating: [:v| Vdual evaluating: [:w| self value: w value: v]]! !

!BilinearForm methodsFor: 'operations' stamp: 'len 1/8/2016 06:06'!
leftRadical
	^ self left kernel! !

!BilinearForm methodsFor: 'operations' stamp: 'len 1/8/2016 06:29'!
rank
	^ matrix rank! !

!BilinearForm methodsFor: 'operations' stamp: 'len 10/4/2016 12:27'!
right
	"Answer the linear map from the domain to its dual that fixes the left argument. If the bilinear form is non-degenerate, this map is an isomorphism."
	| V Vdual |
	V _ self domain at: 2.
	Vdual _ V dual.
	^ V to: Vdual evaluating: [:v| Vdual evaluating: [:w| self value: v value: w]]! !

!BilinearForm methodsFor: 'operations' stamp: 'len 1/8/2016 06:06'!
rightRadical
	^ self right kernel! !

!BilinearForm methodsFor: 'operations' stamp: 'len 3/18/2018 18:38:32'!
skewSymmetricPart
	| two |
	two _ self scalars one * 2.
	^ self class
		fromHalf: halfDomain
		matrix: matrix - matrix transposed / two! !

!BilinearForm methodsFor: 'operations' stamp: 'len 3/18/2018 18:38:47'!
symmetricPart
	| two |
	two _ self scalars one * 2.
	^ self class
		fromHalf: halfDomain
		matrix: matrix + matrix transposed / two! !

!BilinearForm methodsFor: 'operations' stamp: 'len 3/18/2018 18:39:17'!
transposed
	"The transposed of a bilinear form B(x,y) is B(y,x)."
	^ self class fromHalf: halfDomain matrix: matrix transposed! !

!BilinearForm methodsFor: 'operations' stamp: 'len 11/30/2015 05:59'!
value: anArray
	self assert: anArray size = 2.
	^ self value: anArray first value: anArray second! !

!BilinearForm methodsFor: 'operations' stamp: 'len 5/5/2019 17:35:34'!
value: anObject value: anotherObject
	| left right |
	left _ halfDomain coordinatesOf: anObject.
	right _ halfDomain coordinatesOf: anotherObject.
	^ left  (matrix * right)! !

!BilinearForm methodsFor: 'testing' stamp: 'len 1/8/2016 06:30'!
isAlternate
	"A bilinear form B is called 'alternate' if B(v,v) = 0 for all v."
	matrix isSkewSymmetric ifFalse: [^ false].
	matrix diagonalDo: [:each| each isZero ifFalse: [^ false]].
	^ true! !

!BilinearForm methodsFor: 'testing' stamp: 'len 1/8/2016 06:30'!
isAlternating
	"A bilinear form B is called 'alternating' if B(v,v) = 0 for all v."
	matrix isSkewSymmetric ifFalse: [^ false].
	matrix diagonalDo: [:each| each isZero ifFalse: [^ false]].
	^ true! !

!BilinearForm methodsFor: 'testing' stamp: 'len 1/8/2016 06:25'!
isNonDegenerate
	"A bilinear form B is called 'non-degenerate' if B(v,w) = 0 for all w implies v = 0.
	B is non-degenerate iff the left and right radicals are trivial."
	^ self rank = self domain dimension! !

!BilinearForm methodsFor: 'testing' stamp: 'len 1/7/2016 23:40'!
isReflexive
	"A bilinear form B is called 'reflexive' if B(v,w) = 0 implies B(w,v) = 0 for all v,w."
	^ self isSymmetric or: [self isAlternating]! !

!BilinearForm methodsFor: 'testing' stamp: 'len 1/8/2016 06:30'!
isSkewSymmetric
	"A bilinear form B is called 'skew-symmetric' if B(v,w) = -B(w,v) for all v,w."
	^ matrix isSkewSymmetric! !

!BilinearForm methodsFor: 'testing' stamp: 'len 1/8/2016 06:30'!
isSymmetric
	"A bilinear form B is called 'symmetric' if B(v,w) = B(w,v) for all v,w."
	^ matrix isSymmetric! !

!BilinearForm class methodsFor: 'instance creation' stamp: 'len 3/19/2018 20:03:43'!
from: aCartesianProduct evaluating: aBlock 
	| V basis matrix n |
	V _ aCartesianProduct components first.
	basis _ V basis.
	n _ basis size.
	matrix _ V scalars
					matrix: n
					evaluating: [:i :j|
						aBlock value: {(basis at: i). (basis at: j)}].
	^ self fromHalf: V matrix: matrix! !

!BilinearForm class methodsFor: 'instance creation' stamp: 'len 3/19/2018 20:03:04'!
fromHalf: aVectorSpace evaluating: aBlock 
	| basis matrix n |
	basis _ aVectorSpace basis.
	n _ basis size.
	matrix _ aVectorSpace scalars ^ (n@n)
					evaluating: [:i :j|
						aBlock value: {(basis at: i). (basis at: j)}].
	^ self fromHalf: aVectorSpace matrix: matrix! !

!BilinearForm class methodsFor: 'instance creation' stamp: 'len 3/19/2018 20:02:32'!
fromHalf: aFreeModule matrix: aMatrix
	"Answer a new instance of the receiver representing the bilinear form associated to aMatrix in the given bases."
	^ self new halfDomain: aFreeModule; matrix: aMatrix! !

!RationalMap methodsFor: 'accessing' stamp: 'len 12/28/2016 21:54:27'!
at: anInteger
	"Answer the anInteger-th component of the receiver (a rational function, an element of the function field of the domain)."
	^ self representatives at: anInteger! !

!RationalMap methodsFor: 'accessing' stamp: 'len 5/17/2018 18:49:34'!
base
	"Answer the subscheme of the domain where the receiver is indetermined (because some denominator vanishes)."
	self notYetImplemented.
"this is wrong:"
	^ self domain subscheme: (self representatives collect: [:each| each denominator])! !

!RationalMap methodsFor: 'accessing' stamp: 'len 12/28/2016 21:43:15'!
representatives
	"Answer the array of representatives of the components of the receiver, i.e. formal fractions of polynomials or polynomials."
	^ self propertyAt: #representatives! !

!RationalMap methodsFor: 'accessing' stamp: 'len 1/5/2017 09:27:06'!
size
	"Answer the number of components of the receiver."
	^ self codomain ambient rank! !

!RationalMap methodsFor: 'accessing-private' stamp: 'len 12/28/2016 21:54:40'!
representatives: anArray 
	self propertyAt: #representatives put: anArray asArray! !

!RationalMap methodsFor: 'arithmetic' stamp: 'len 1/20/2018 22:05:44'!
* anObject
	^ self species from: self domain to: self codomain representatives: self representatives * anObject! !

!RationalMap methodsFor: 'arithmetic' stamp: 'len 5/20/2018 16:27:16'!
+ aRationalMap
	aRationalMap isTuple
		ifTrue: [^ self species from: self domain to: self codomain representatives: self representatives + aRationalMap].
	(self domain = aRationalMap domain and: [self codomain = aRationalMap codomain])
		ifFalse: [^ DomainError signal].
	^ self species from: self domain to: self codomain representatives: self representatives + aRationalMap representatives! !

!RationalMap methodsFor: 'arithmetic' stamp: 'len 5/5/2019 18:28:17'!
 aRationalMap
	self domain >= aRationalMap codomain ifFalse: [DomainError signal: 'domains don''t match'].
	^ self species from: aRationalMap domain to: self codomain representatives: (self representatives collect: [:each| each value: aRationalMap representatives])! !

!RationalMap methodsFor: 'arithmetic' stamp: 'len 1/20/2018 22:05:58'!
negated
	^ self species from: self domain to: self codomain representatives: self representatives negated! !

!RationalMap methodsFor: 'comparing' stamp: 'len 12/26/2016 09:12:42'!
= aRationalMap
	| I |
	(aRationalMap isKindOf: RationalMap) ifFalse: [^ super = aRationalMap].
	(self domain = aRationalMap domain and: [self codomain = aRationalMap codomain])
		ifFalse: [^ false].
	I _ self domain ideal.
	1 to: self size do: [:i| | f g |
		f _ self at: i.
		g _ aRationalMap at: i.
		(I includes: f numerator * g denominator - (f denominator * g numerator))
			ifFalse: [^ false]].
	^ true! !

!RationalMap methodsFor: 'converting' stamp: 'len 9/28/2018 06:52:42'!
asRingMap
	"Answer the induced ring homomorphism between the coordinate rings.
	This is the adjoint of the Spec functor."
	self isPolynomial ifFalse: [DomainError signal: 'not a polynomial map'].
	^ self codomain coordinateRing to: self domain coordinateRing evaluating: [:f| f value: self representatives]! !

!RationalMap methodsFor: 'operations' stamp: 'len 5/15/2018 16:58:45'!
graph
	^ self domain  self image! !

!RationalMap methodsFor: 'operations' stamp: 'len 5/15/2018 17:05:15'!
image
	"Answer (the Zeriski closure of) the image of the receiver. This is a subscheme of the codomain.
	Performs ideal elimination (a Groebner basis computation with the lexicographical order).
	See PolynomialRingMap>>kernel."
	| A B m n P t embedding generators g I |
	A _ self domain ambient coordinateRing.
	B _ self codomain ambient coordinateRing.
	m _ A rank.
	n _ B rank.
	P _ self domain scalars polynomialsIn: n + m + 1.
	"the embedding mapping the i-th indeterminate to the (i+n)-th indeterminate in the bigger ring:"
	embedding _ A to: P evaluating: [:f| P !! f substitute: [:i| i+n]].
	t _ P x: P rank.
	generators _ OrderedCollection new.
	g _ P one.
	1 to: n do: [:i| | numerator denominator |
		numerator _ embedding value: (self representatives at: i) numerator.
		denominator _ embedding value: (self representatives at: i) denominator.
		generators add: denominator * (P x: i) - numerator.
		g _ g * denominator].
	self domain ideal generators do: [:each| generators add: (embedding value: each)].
	generators add: P one - (g * t).
	I _ P * generators eliminateAll: (n+1 to: P rank).
	^ self codomain subscheme: (I generators collect: [:f| B !! f])! !

!RationalMap methodsFor: 'operations' stamp: 'len 1/13/2017 18:39:06'!
jacobian
	"Answer the Jacobian matrix of the receiver."
	^ self domain ambient coordinateRing
		matrix: self codomain ambient rank @ self domain ambient rank
		evaluating: [:i :j| (self representatives at: i) derivativeIn: j]! !

!RationalMap methodsFor: 'operations' stamp: 'len 1/15/2017 17:24:31'!
projectiveClosure
	^ self class
		from: self domain projectiveClosure
		to: self codomain projectiveClosure
		representatives: (self representatives collect: [:each| each homogenized])! !

!RationalMap methodsFor: 'operations' stamp: 'len 9/28/2018 06:52:21'!
pullback: aScheme
	"Answer the preimage of aScheme. The argument is a subscheme of the codomain, and the answer is a subscheme of the domain."
	^ self domain subscheme: (aScheme ideal apply: self asRingMap)! !

!RationalMap methodsFor: 'operations' stamp: 'len 9/28/2018 06:52:28'!
value: aPoint
	| x value |
	(aPoint isKindOf: Ideal)
		ifTrue: [^ self asRingMap preimage: aPoint].
	x _ aPoint asTuple.
	value _ aPoint scalars tuple: (self representatives collect: [:each| each value: x]).
	(aPoint isKindOf: RationalPoint)
		ifTrue: [^ self codomain pointAt: value].
	^ value! !

!RationalMap methodsFor: 'testing' stamp: 'len 1/15/2017 17:18:42'!
isAffineLinear
	"Answer true if the receiver is an affine linear map (defined by polynomials of degree 1)."
	^ self representatives allSatisfy: [:each| each isAffineLinear]! !

!RationalMap methodsFor: 'testing' stamp: 'len 12/28/2016 21:55:19'!
isConstant
	^ self representatives allSatisfy: [:each| each isConstant]! !

!RationalMap methodsFor: 'testing' stamp: 'len 10/17/2016 16:21'!
isDominant
	"Answer true if the closure of the image of the receiver is the whole codomain."
	^ self image = self codomain! !

!RationalMap methodsFor: 'testing' stamp: 'len 1/15/2017 17:17:24'!
isLinear
	"Answer true if the receiver is a homogeneous linear map (defined by homogeneous linear polynomials, with independent coefficient zero)."
	^ self representatives allSatisfy: [:each| each isLinear]! !

!RationalMap methodsFor: 'testing' stamp: 'len 1/15/2017 17:14:44'!
isPolynomial
	"Answer true if the receiver is a polynomial map."
	^ self representatives allSatisfy: [:each| each denominator isConstant]! !

!RationalMap methodsFor: 'testing' stamp: 'len 1/15/2017 17:23:31'!
isRegular
	"Answer true if the receiver is defined at all points of its domain."
	(self domain ambient isKindOf: AffineSpace) ifTrue: [^ self isPolynomial].
	(self domain ambient isKindOf: ProjectiveSpace) ifTrue: [^ self isConstant].
	^ DomainError signal! !

!RationalMap methodsFor: 'private' stamp: 'len 1/10/2017 18:47:11'!
species
	^ RationalMap! !

!RationalMap class methodsFor: 'examples' stamp: 'len 11/1/2016 16:51'!
example1TwistedCubicTangentParametrization
	"Example from Cox's 'Ideals, Varieties and Algorithms' pag. 234.
	Parametrization of the tangent surface of the twisted cubic."
	| A2 A3 |
	A2 _ AffineSpace new: #(t u) over: QQ.
	A3 _ AffineSpace new: 3 over: QQ.
	^ A2 to: A3 evaluatingWithArguments: [:t :u| {t + u. t^2 + (t*u*2). t^3 + (t^2*u*3)}]! !

!RationalMap class methodsFor: 'examples' stamp: 'len 11/1/2016 16:51'!
example2TwistedCubicTangent
	"The tangent surface of the twisted cubic."
	^ self example1TwistedCubicTangentParametrization image! !

!RationalMap class methodsFor: 'instance creation' stamp: 'len 12/28/2016 21:52:41'!
from: aDomain to: aCodomain evaluating: anExpression
	| F |
	F _ aDomain ambient functionField.
	^ self from: aDomain to: aCodomain representatives: (anExpression value: (F tuple: aDomain ambient rank evaluating: [:i| F x: i]))! !

!RationalMap class methodsFor: 'instance creation' stamp: 'len 1/3/2017 08:30:11'!
from: aDomain to: aCodomain polynomials: anArrayOfPolynomials
	| F |
	F _ aDomain ambient functionField.
	^ self from: aDomain to: aCodomain representatives: (anArrayOfPolynomials collect: [:each| F embed: each])! !

!RationalMap class methodsFor: 'instance creation' stamp: 'len 12/28/2016 21:50:27'!
from: aDomain to: aCodomain representatives: anArrayOfRationalFunctions
	((aDomain isProjective or: [aCodomain isProjective]) and: [anArrayOfRationalFunctions anySatisfy: [:any| any isHomogeneous not]])
		ifTrue: [^ self error: 'not homogeneous'].
	^ self new domain: aDomain; codomain: aCodomain; representatives: anArrayOfRationalFunctions! !

!EllipticCurveIsogeny methodsFor: 'as yet unclassified' stamp: 'len 3/6/2017 16:48:06'!
dual
	"Answer the dual of the receiver. If the receiver is f:E->E' of degree n, its dual is an isogeny g:E'->E such that the compositions are [n] (multiplication by n)."
	^ self notYetImplemented! !

!EllipticCurveIsogeny methodsFor: 'as yet unclassified' stamp: 'len 12/25/2016 08:42:27'!
isSurjective
	^ self isZero not! !

!EllipticCurveIsogeny methodsFor: 'as yet unclassified' stamp: 'len 12/25/2016 08:43:44'!
isZero
	^ self degree = 0! !

!EllipticCurveIsogeny methodsFor: 'as yet unclassified' stamp: 'len 12/28/2016 11:16:46'!
kernelPolynomial
	^ self propertyAt: #kernelPolynomial ifAbsentPut: [self computeKernelPolynomial]! !

!LinearFractionalMap methodsFor: 'accessing' stamp: 'len 12/9/2016 10:07:23'!
a
	^ a! !

!LinearFractionalMap methodsFor: 'accessing' stamp: 'len 12/9/2016 10:07:26'!
b
	^ b! !

!LinearFractionalMap methodsFor: 'accessing' stamp: 'len 12/9/2016 10:07:29'!
c
	^ c! !

!LinearFractionalMap methodsFor: 'accessing' stamp: 'len 12/14/2016 10:34:59'!
codomain
	^ CC! !

!LinearFractionalMap methodsFor: 'accessing' stamp: 'len 12/9/2016 10:07:31'!
d
	^ d! !

!LinearFractionalMap methodsFor: 'accessing' stamp: 'len 12/10/2016 12:05:21'!
domain
	^ CC! !

!LinearFractionalMap methodsFor: 'accessing' stamp: 'len 12/9/2016 16:30:21'!
identity
	^ self class I! !

!LinearFractionalMap methodsFor: 'accessing-private' stamp: 'len 12/9/2016 10:08:43'!
a: aNumber
	a _ aNumber! !

!LinearFractionalMap methodsFor: 'accessing-private' stamp: 'len 12/9/2016 10:08:45'!
b: aNumber
	b _ aNumber! !

!LinearFractionalMap methodsFor: 'accessing-private' stamp: 'len 12/9/2016 10:08:48'!
c: aNumber
	c _ aNumber! !

!LinearFractionalMap methodsFor: 'accessing-private' stamp: 'len 12/9/2016 10:08:50'!
d: aNumber
	d _ aNumber! !

!LinearFractionalMap methodsFor: 'comparing' stamp: 'len 12/10/2016 11:51:23'!
= aMoebiusMap
	aMoebiusMap species = self species ifFalse: [^ super = aMoebiusMap].
	^ a = aMoebiusMap a and: [b = aMoebiusMap b and: [c = aMoebiusMap c and: [d = aMoebiusMap d]]]! !

!LinearFractionalMap methodsFor: 'comparing' stamp: 'len 12/10/2016 11:51:45'!
hash
	^ ((a hash + b hash) hashMultiply + c hash) hashMultiply + d hash! !

!LinearFractionalMap methodsFor: 'converting' stamp: 'len 12/28/2016 10:23:54'!
asMatrix
	^ self domain scalars matrix: 2 coefficients: {a. b. c. d}! !

!LinearFractionalMap methodsFor: 'converting' stamp: 'len 12/28/2016 10:24:10'!
asRationalFunction
	| z |
	z _ (self domain scalars polynomialsIn: #(z)) fractions x.
	^ z * a + b / (z * c + d)! !

!LinearFractionalMap methodsFor: 'operations' stamp: 'len 5/5/2019 18:26:58'!
 aModularMap
	^ self class
		a: a * aModularMap a + (b * aModularMap c)
		b: a * aModularMap b + (b * aModularMap d)
		c: c * aModularMap a + (d * aModularMap c)
		d: c * aModularMap b + (d * aModularMap d)! !

!LinearFractionalMap methodsFor: 'operations' stamp: 'len 12/9/2016 10:14:36'!
inverse
	^ self class a: d b: b negated c: c negated d: a! !

!LinearFractionalMap methodsFor: 'operations' stamp: 'len 12/9/2016 21:50:06'!
trace
	^ a + d! !

!LinearFractionalMap methodsFor: 'operations' stamp: 'len 12/15/2016 17:46:03'!
traceSquared
	^ (a + d) squared! !

!LinearFractionalMap methodsFor: 'operations' stamp: 'len 12/9/2016 10:07:06'!
value: anObject
	^ anObject * a + b / (anObject * c + d)! !

!LinearFractionalMap methodsFor: 'testing' stamp: 'len 12/14/2016 10:31:41'!
isCircular
	^ self trace = 0! !

!LinearFractionalMap methodsFor: 'testing' stamp: 'len 12/15/2016 17:48:21'!
isElliptic
	^ self traceSquared < 4! !

!LinearFractionalMap methodsFor: 'testing' stamp: 'len 12/15/2016 17:48:27'!
isHyperbolic
	^ self traceSquared > 4! !

!LinearFractionalMap methodsFor: 'testing' stamp: 'len 12/10/2016 12:04:59'!
isIdentity
	^ a = 1 and: [b = 0 and: [c = 0 and: [d = 1]]]! !

!LinearFractionalMap methodsFor: 'testing' stamp: 'len 12/15/2016 17:48:33'!
isLoxodromic
	| t |
	^ (t _ self traceSquared) < 0 or: [t > 4]! !

!LinearFractionalMap methodsFor: 'testing' stamp: 'len 12/15/2016 17:48:39'!
isParabolic
	^ self traceSquared = 4! !

!LinearFractionalMap class methodsFor: 'instance creation' stamp: 'len 12/9/2016 16:29:49'!
I
	^ self a: 1 b: 0 c: 0 d: 1! !

!LinearFractionalMap class methodsFor: 'instance creation' stamp: 'len 12/9/2016 16:29:54'!
R
	^ self a: 0 b: 1 c: -1 d: 1! !

!LinearFractionalMap class methodsFor: 'instance creation' stamp: 'len 12/9/2016 16:30:03'!
S
	^ self a: 0 b: -1 c: 1 d: 0! !

!LinearFractionalMap class methodsFor: 'instance creation' stamp: 'len 12/9/2016 16:30:11'!
T
	^ self a: 1 b: 1 c: 0 d: 1! !

!LinearFractionalMap class methodsFor: 'instance creation' stamp: 'len 12/9/2016 10:08:59'!
a: a b: b c: c d: d
	^ self new a: a; b: b; c: c; d: d! !

!LinearFractionalMap class methodsFor: 'instance creation' stamp: 'len 12/10/2016 12:37:18'!
matrix: aMatrix
	^ self a: (aMatrix at: 1@1) b: (aMatrix at: 1@2) c: (aMatrix at: 2@1) d: (aMatrix at: 2@2)! !

!ModularMap methodsFor: 'as yet unclassified' stamp: 'len 1/2/2017 11:20:36'!
asMatrix
	^ ZZ matrix: 2 coefficients: {a. b. c. d}! !

!ModularMap methodsFor: 'as yet unclassified' stamp: 'len 12/14/2016 10:26:46'!
isElliptic
	^ self trace abs < 2! !

!ModularMap methodsFor: 'as yet unclassified' stamp: 'len 12/14/2016 10:26:54'!
isHyperbolic
	^ self trace abs > 2! !

!ModularMap methodsFor: 'as yet unclassified' stamp: 'len 12/14/2016 10:27:12'!
isParabolic
	^ self trace abs = 2! !

!Sequence methodsFor: 'accessing' stamp: 'len 6/4/2019 05:39:30'!
at: anInteger
	^ self at: anInteger ifAbsent: []! !

!Sequence methodsFor: 'accessing' stamp: 'len 6/3/2019 17:30:31'!
at: anInteger ifAbsent: aBlock
	^ anInteger > 0 ifTrue: [super value: anInteger] ifFalse: [aBlock value]! !

!Sequence methodsFor: 'accessing' stamp: 'len 12/28/2016 11:14:04'!
codomain
	^ self propertyAt: #codomain ifAbsent: [ZZ]! !

!Sequence methodsFor: 'accessing' stamp: 'len 12/28/2016 11:13:42'!
domain
	^ self propertyAt: #domain ifAbsent: [NN]! !

!Sequence methodsFor: 'accessing' stamp: 'len 6/1/2019 08:33:57'!
scalars
	"For compatibility with tuples."
	^ self codomain! !

!Sequence methodsFor: 'accessing' stamp: 'len 12/28/2016 11:13:26'!
size
	^ self propertyAt: #size ifAbsent: [Aleph new]! !

!Sequence methodsFor: 'comparing' stamp: 'len 12/5/2015 01:11'!
beginsWith: aSequenceableCollection
	1 to: aSequenceableCollection size do: [:i| (self at: i) = (aSequenceableCollection at: i) ifFalse: [^ false]].
	^ true! !

!Sequence methodsFor: 'comparing' stamp: 'len 12/27/2015 01:29'!
equals: aSequence upTo: n
	^ self beginsWith: (aSequence copyFrom: 1 to: n)! !

!Sequence methodsFor: 'comparing' stamp: 'len 12/27/2015 03:56'!
hash
	^ (self at: 1) hash + (self at: 3) hash + (self at: 5) hash! !

!Sequence methodsFor: 'converting' stamp: 'len 12/2/2016 09:57:05'!
asStream
	^ ReadStream on: self! !

!Sequence methodsFor: 'copying' stamp: 'len 6/1/2019 08:31:20'!
copyFrom: start to: end
	end isInfinite
		ifTrue: [^ self >> (1 - start)].
	^ (start to: end) collect: [:i| self at: i]! !

!Sequence methodsFor: 'copying' stamp: 'len 4/20/2016 21:25'!
first: n
	^ self copyFrom: 1 to: n! !

!Sequence methodsFor: 'enumerating' stamp: 'len 12/3/2015 20:34'!
collect: aBlock
	^ self species evaluating: [:i| aBlock value: (self at: i)]! !

!Sequence methodsFor: 'enumerating' stamp: 'len 4/25/2016 07:08'!
count: aBlock
	^ (self collect: [:each| (aBlock value: each) ifTrue: [1] ifFalse: [0]]) sum! !

!Sequence methodsFor: 'enumerating' stamp: 'len 12/27/2015 03:45'!
do: aBlock
	1 to: self size do: [:each| aBlock value: (self at: each)]! !

!Sequence methodsFor: 'enumerating' stamp: 'len 6/2/2019 04:31:06'!
findFirst: aBlock
	"Return the index of my first element for which aBlock evaluates as true."
	| index |
	index _ 0.
	[(aBlock value: (self at: (index _ index + 1))) ifTrue: [^ index]] repeat! !

!Sequence methodsFor: 'enumerating' stamp: 'len 12/3/2015 23:16'!
select: aBlock
	^ self species evaluating: [:i|
		| k j value |
		k _ 1.
		j _ 1.
		[[aBlock value: (value _ self at: k)] whileFalse: [k _ k + 1]. j < i] whileTrue: [j _ j + 1. k _ k + 1].
		value]! !

!Sequence methodsFor: 'enumerating' stamp: 'len 3/27/2016 04:44'!
withIndexDo: aBlock
	| i |
	i _ 1.
	self do: [:each| aBlock value: each value: i. i _ i + 1]! !

!Sequence methodsFor: 'operations' stamp: 'len 6/4/2019 09:20:19'!
* anObject
	^ (self codomain includes: anObject)
		ifTrue: [self species to: self codomain evaluating: [:n| (self at: n) * anObject]]
		ifFalse: [self species to: self codomain evaluating: [:n| (self at: n) * (anObject at: n)]]! !

!Sequence methodsFor: 'operations' stamp: 'len 6/4/2019 09:21:05'!
+ anObject
	^ (self codomain includes: anObject)
		ifTrue: [self species to: self codomain evaluating: [:n| (self at: n) + anObject]]
		ifFalse: [self species to: self codomain evaluating: [:n| (self at: n) + (anObject at: n)]]! !

!Sequence methodsFor: 'operations' stamp: 'len 5/6/2019 03:53:45'!
- anObject
	^ self + anObject negated! !

!Sequence methodsFor: 'operations' stamp: 'len 5/6/2019 03:51:55'!
/ anObject
	^ self * anObject reciprocal! !

!Sequence methodsFor: 'operations' stamp: 'len 6/1/2019 08:29:43'!
<< anInteger
	^ self >> anInteger negated! !

!Sequence methodsFor: 'operations' stamp: 'len 12/27/2015 02:11'!
average
	^ self species to: self codomain evaluating: [:N| ((1 to: N) sum: [:n| self at: n]) / N]! !

!Sequence methodsFor: 'operations' stamp: 'len 6/4/2019 09:21:51'!
backwardDifference: n at: h
	^ self species
		to: self codomain
		evaluating: [:x| (0 to: n) sum: [:i| (-1)^i * (n choose: i) * (self at: x + (i*h))]]! !

!Sequence methodsFor: 'operations' stamp: 'len 6/4/2019 18:10:01'!
binomialInverseTransform
	^ self species to: self codomain evaluating: [:n| (0 to: n-1) sum: [:k| (n-1 choose: k) * (self at: k+1)]]! !

!Sequence methodsFor: 'operations' stamp: 'len 6/4/2019 18:06:06'!
binomialTransform
	"The binomial transform is its own inverse, it's an involution."
	^ self species to: self codomain evaluating: [:n| (0 to: n-1) sum: [:k| (-1)^(n-1-k) * (n-1 choose: k) * (self at: k+1)]]! !

!Sequence methodsFor: 'operations' stamp: 'len 6/4/2019 09:22:08'!
centralDifference: n at: h
	^ self species
		to: self codomain
		evaluating: [:x| (0 to: n) sum: [:i| (-1)^i * (n choose: i) * (self at: x + ((n/2 - i)*h))]]! !

!Sequence methodsFor: 'operations' stamp: 'len 6/4/2019 05:29:55'!
convolution: aSequence
	^ self species to: self codomain evaluating: [:n| (0 to: n-1) sum: [:i| (self at: 1+i) * (aSequence at: n-i)]]! !

!Sequence methodsFor: 'operations' stamp: 'len 6/1/2019 08:31:04'!
difference
	"Answer the 'difference' sequence of the receiver, or delta, or discrete derivative."
	^ (self << 1) - self! !

!Sequence methodsFor: 'operations' stamp: 'len 12/27/2015 02:11'!
dirichlet: aSequence
	"Answer the Dirichlet convolution of the receiver with the argument, assuming both are arithmetic functions (i.e. functions from the natural numbers to the complex numbers).
	The set of arithmetic functions form a commutative ring (the Dirichlet ring) under pointwise addition and Dirichlet convolution."
	^ self species to: self codomain evaluating: [:n| n divisors sum: [:d| (self at: d) * (aSequence at: n/d)]]! !

!Sequence methodsFor: 'operations' stamp: 'len 6/4/2019 09:22:27'!
forwardDifference: n at: h
	^ self species
		to: self codomain
		evaluating: [:x| (0 to: n) sum: [:i| (-1)^(n-i) * (n choose: i) * (self at: x + ((n-i)*h))]]! !

!Sequence methodsFor: 'operations' stamp: 'len 6/4/2019 09:22:50'!
hadamard: aSequence
	"Answer the entrywise product with the argument, also called Hadamard product."
	^ self class to: self codomain evaluating: [:i| (self at: i) * (aSequence at: i)]! !

!Sequence methodsFor: 'operations' stamp: 'len 12/27/2015 02:11'!
moebiusInverse
	"This is equivalent to the Dirichlet convolution of the Moebius arithmetic function with the receiver.
	If f(n) and g(n) are two arithmetic functions satisfying g = f * 1 (Dirichlet convolution of f with the constant function 1), then the Moebius inversion formula can be used to retrieve f as f = mu * g. It is said that f and g and Moebius transforms of each other."
	^ self species to: self codomain evaluating: [:n| n divisors sum: [:d| d moebius * (self at: n/d)]]! !

!Sequence methodsFor: 'operations' stamp: 'len 6/4/2019 09:24:13'!
negated
	^ self species to: self codomain evaluating: [:n| (self at: n) negated]! !

!Sequence methodsFor: 'operations' stamp: 'len 12/27/2015 19:48'!
product
	"Answer the indefinite product of the receiver."
	^ self species to: self codomain evaluating: [:i| (1 to: i) collect: [:k| self at: k] andFold: [:a :b| a*b]]! !

!Sequence methodsFor: 'operations' stamp: 'len 6/4/2019 09:23:27'!
reciprocal
	^ self species to: self codomain evaluating: [:n| (self at: n) reciprocal]! !

!Sequence methodsFor: 'operations' stamp: 'len 12/27/2015 02:12'!
shift: anInteger
	^ self species to: self codomain evaluating: [:i| self at: i-anInteger]! !

!Sequence methodsFor: 'operations' stamp: 'len 5/6/2019 03:54:25'!
squared
	^ self * self! !

!Sequence methodsFor: 'operations' stamp: 'len 12/27/2015 02:12'!
stirlingInverseTransform
	^ self species to: self codomain evaluating: [:n| (1 to: n) sum: [:k| (n stirling: k) * (self at: k)]]! !

!Sequence methodsFor: 'operations' stamp: 'len 12/27/2015 02:12'!
stirlingTransform
	^ self species to: self codomain evaluating: [:n| (1 to: n) sum: [:k| (n Stirling: k) * (self at: k)]]! !

!Sequence methodsFor: 'operations' stamp: 'len 12/27/2015 19:48'!
sum
	"Answer the indefinite sum of the receiver."
	^ self species to: self codomain evaluating: [:i| (1 to: i) sum: [:k| self at: k]]! !

!Sequence methodsFor: 'operations' stamp: 'len 12/4/2015 04:00'!
value: aNumber
	^ self at: aNumber asInteger! !

!Sequence methodsFor: 'printing' stamp: 'len 4/25/2016 07:23'!
lookup
	^ OEIS default lookup: self! !

!Sequence methodsFor: 'printing' stamp: 'len 12/28/2016 11:13:18'!
printLimit
	^ self propertyAt: #printLimit ifAbsent: [17]! !

!Sequence methodsFor: 'printing' stamp: 'len 12/28/2016 11:13:57'!
printLimit: anInteger
	self propertyAt: #printLimit put: anInteger! !

!Sequence methodsFor: 'printing' stamp: 'len 4/26/2016 06:46'!
printOn: aStream base: base
	(1 to: self printLimit) do: [:i| (self at: i) printOn: aStream base: base] separatedBy: [aStream nextPutAll:', ' ].
	aStream nextPutAll: '...'! !

!Sequence methodsFor: 'printing' stamp: 'len 4/26/2016 06:47'!
printStringBase: base
	^ String streamContents:
		[:aStream| self printOn: aStream base: base]! !

!Sequence methodsFor: 'series' stamp: 'len 6/2/2019 16:58:56'!
bellSeries: p
	^ self codomain powerSeries coefficients: (self species to: self codomain evaluating: [:n| self at: p^(n-1)])! !

!Sequence methodsFor: 'series' stamp: 'len 12/29/2015 04:25'!
dirichletSeries
	"Answer the Dirichlet series generating function of the receiver."
	^ DirichletSeries coefficients: self! !

!Sequence methodsFor: 'series' stamp: 'len 6/2/2019 17:00:18'!
exponentialSeries
	"Answer the exponential generating function of the receiver."
	^ self codomain powerSeries coefficients: (self species to: self codomain evaluating: [:n| (self at: n) / (n-1) factorial])! !

!Sequence methodsFor: 'series' stamp: 'len 12/29/2015 04:26'!
generatingSeries
	"Answer the ordinary generating function of the receiver."
	^ self ordinaryGeneratingSeries! !

!Sequence methodsFor: 'series' stamp: 'len 6/2/2019 17:00:31'!
ordinaryGeneratingSeries
	"Answer the ordinary generating function of the receiver."
	^ self codomain powerSeries coefficients: self! !

!Sequence methodsFor: 'private' stamp: 'len 12/3/2015 20:34'!
species
	^ Sequence! !

!Sequence class methodsFor: 'examples' stamp: 'len 12/4/2015 01:53'!
Omega
	"Number of prime divisors of n counted with multiplicity. A001222."
	^ Sequence evaluating: [:n| n factors size]! !

!Sequence class methodsFor: 'examples' stamp: 'len 2/22/2017 08:24:46'!
aliquot
	"This is the aliquot function a(n) or s(n).
	It is the sum of the proper divisors of n (aliquot parts of n).
	If a(n) = n, n is a perfect number. If a(n) = n - 1, it is almost perfect. If a(n) > n, it is an abundant number."
	^ Sequence evaluating: [:n| n divisors sum - n]! !

!Sequence class methodsFor: 'examples' stamp: 'len 4/16/2016 19:33'!
bbs: s p: p q: q
	"Answer the Blum Blum Shub sequence for the given parameters."
	| lambda m |
	lambda _ p - 1 lcm: q - 1.
	m _ p * q.
	^ self evaluating: [:i| s raisedTo: (2 raisedTo: i modulo: lambda) modulo: m]! !

!Sequence class methodsFor: 'examples' stamp: 'len 6/4/2019 18:03:08'!
bellNumbers
	"The Bell numbers."
	^ Sequence evaluating: [:n| (0 to: n-1) sum: [:k| n-1 Stirling: k]]! !

!Sequence class methodsFor: 'examples' stamp: 'len 12/12/2016 17:08:06'!
bernoulli
	"This is the sequence of Bernoulli numbers (starting at 1), computed via a recurrence."
	^ Sequence to: QQ initialValues: #(1) recurrence: [:f :n| (n>4 and: [n even]) ifTrue: [0] ifFalse: [((0 to: n-2) sum: [:k| (n choose: k) * (f at: k+1)]) / n negated]]! !

!Sequence class methodsFor: 'examples' stamp: 'len 2/22/2017 08:25:39'!
calkinWilf
	"The Calkin-Wilf sequence.
	It enumerates the positive rational numbers by a breadth-first traversal of the Calkin-Wilf tree."
	^ Sequence
		to: QQ
		evaluating:
			[:n| | q |
			q _ 1.
			n-1 timesRepeat: [q _ 1 / (2 * q floor - q + 1)].
			q]! !

!Sequence class methodsFor: 'examples' stamp: 'len 2/22/2017 08:25:48'!
catalanNumbers
	"The Catalan numbers."
	^ Sequence evaluating: [:n| (2*(n-1) choose: n-1) / n]! !

!Sequence class methodsFor: 'examples' stamp: 'len 2/22/2017 08:26:11'!
fibonacci
	"The Fibonacci sequence defined as a recurrence."
	^ Sequence initialValues: #(0 1) recurrence: [:f :n| (f at: n-1) + (f at: n-2)]! !

!Sequence class methodsFor: 'examples' stamp: 'len 2/22/2017 08:26:21'!
harmonicNumbers
	"The harmonic numbers."
	^ Sequence to: QQ evaluating: [:n| (1 to: n) sum: [:k| 1/k]]! !

!Sequence class methodsFor: 'examples' stamp: 'len 7/17/2016 22:10'!
hensel: aPolynomial at: anIntegerRoot mod: p
	"Answer the p-adic expansion by Hensel lemma."
	| x |
	x _ aPolynomial species x.
	^ self recurrence:
		[:f :n|
		n = 1
			ifTrue: [anIntegerRoot]
			ifFalse:
				[| g a |
				g _ (f at: n-1) + (p^(n-1) * x).
				a _ (aPolynomial value: g % (p^n)) roots anyOne representative.
				(g value: a) \\ (p^n)]]! !

!Sequence class methodsFor: 'examples' stamp: 'len 2/22/2017 08:38:27'!
highlyCompositeNumbers
	"The sequence of highly composite numbers."
	^ Sequence recurrence: [:f :n| | i max |
		n = 1
			ifTrue: [1]
			ifFalse:
				[i _ f at: n-1.
				max _ i numberOfDivisors.
				[(i _ i + 1) numberOfDivisors > max] whileFalse. i]]! !

!Sequence class methodsFor: 'examples' stamp: 'len 2/22/2017 08:27:03'!
id
	"The identity sequence."
	^ Sequence evaluating: [:n| n]! !

!Sequence class methodsFor: 'examples' stamp: 'len 2/22/2017 08:27:15'!
liouville
	"The Liouville function."
	| Omega |
	Omega _ Sequence Omega.
	^ Sequence evaluating: [:n| (-1) ^ (Omega at: n)]! !

!Sequence class methodsFor: 'examples' stamp: 'len 2/22/2017 08:27:28'!
mangoldt
	"The von Mangoldt function (float)."
	^ Sequence evaluating: [:n| | factors | factors _ n factors. factors asSet size = 1 ifTrue: [factors anyOne ln] ifFalse: [0]]! !

!Sequence class methodsFor: 'examples' stamp: 'len 2/22/2017 08:27:36'!
mangoldt2
	"The log2 von Mangoldt function."
	^ Sequence evaluating: [:n| | factors | factors _ n factors. factors asSet size = 1 ifTrue: [factors anyOne highBit] ifFalse: [0]]! !

!Sequence class methodsFor: 'examples' stamp: 'len 2/22/2017 08:29:45'!
moebius
	"The Moebius function mu(n).
	This is 0 if n is squarefree, and (-1)^k otherwise (where k is the number of prime factors counted with multiplicity)."
	^ Sequence evaluating: [:n| n moebius]! !

!Sequence class methodsFor: 'examples' stamp: 'len 12/4/2015 01:54'!
omega
	"Number of distinct primes dividing n. A001221."
	^ Sequence evaluating: [:n| n factors asSet size]! !

!Sequence class methodsFor: 'examples' stamp: 'len 2/22/2017 08:38:14'!
one
	"The constant sequence that is always 1."
	^ Sequence constant: 1! !

!Sequence class methodsFor: 'examples' stamp: 'len 2/22/2017 08:38:09'!
partitions
	"The partition function p(n) = number of partition of n. OEIS A000041."
	^ Sequence evaluating: [:n| n partitions size]! !

!Sequence class methodsFor: 'examples' stamp: 'len 2/22/2017 08:38:03'!
phi
	"Euler's totient function."
	^ Sequence evaluating: [:n| n phi]! !

!Sequence class methodsFor: 'examples' stamp: 'len 6/1/2019 13:35:39'!
primeGaps
	"The sequence of prime gaps.
	This is p(n+1) - p(n), the difference between concecutive primes."
	| p |
	p _ 2.
	^ Sequence streaming: [p negated + (p _ p nextPrime)]
"	^ Sequence primes difference"! !

!Sequence class methodsFor: 'examples' stamp: 'len 2/22/2017 08:31:34'!
primes
	"The sequence of primes."
	^ Sequence initialValues: #(2) recurrence: [:f :i| (f at: i-1) nextPrime]
"	^ Sequence evaluating: [:i|
		| n count |
		n _ 2.
		count _ 1.
		[count = i] whileFalse: [n _ n nextPrime. count _ count + 1].
		n]"! !

!Sequence class methodsFor: 'examples' stamp: 'len 2/22/2017 08:32:01'!
sigma
	"The sigma(n) function, defined as the sum of the positive divisors of n.
	The number n is said to be a perfect number iff sigma(n) = 2*n."
	^ Sequence evaluating: [:n| n divisors sum]! !

!Sequence class methodsFor: 'examples' stamp: 'len 12/4/2015 22:44'!
sigma: x
	"Answer the sigma(x,n) function."
	^ Sequence evaluating: [:n| n divisors sum: [:d| d^x]]! !

!Sequence class methodsFor: 'examples' stamp: 'len 12/4/2015 01:54'!
tau
	"Number of divisors of n, also called d(n) and sigma_O(n). A000005."
	^ Sequence evaluating: [:n| n divisors size]! !

!Sequence class methodsFor: 'intance creation' stamp: 'len 7/15/2016 18:29'!
constant: anInteger
	anInteger isInteger
		ifFalse: [^ DomainError signal: 'argument is not integer'].
	^ self to: ZZ constant: anInteger! !

!Sequence class methodsFor: 'intance creation' stamp: 'len 7/15/2016 18:29'!
dynamic: aBlock
	^ self to: ZZ dynamic: aBlock! !

!Sequence class methodsFor: 'intance creation' stamp: 'len 7/15/2016 18:30'!
evaluating: aBlock
	^ self to: ZZ evaluating: aBlock! !

!Sequence class methodsFor: 'intance creation' stamp: 'len 10/10/2016 21:08'!
initialValues: anArray recurrence: aBinaryBlock
	^ self to: ZZ initialValues: anArray recurrence: aBinaryBlock! !

!Sequence class methodsFor: 'intance creation' stamp: 'len 10/10/2016 21:08'!
recurrence: aBinaryBlock
	^ self initialValues: #() recurrence: aBinaryBlock! !

!Sequence class methodsFor: 'intance creation' stamp: 'len 6/1/2019 13:35:29'!
streaming: aBlock
	^ self to: ZZ streaming: aBlock! !

!Sequence class methodsFor: 'intance creation' stamp: 'len 4/19/2016 21:42'!
to: aDomain constant: anObject
	^ self to: aDomain evaluating: [:n| anObject]! !

!Sequence class methodsFor: 'intance creation' stamp: 'len 5/11/2016 23:16'!
to: aDomain dynamic: aBlock
	^ self to: aDomain evaluating:
			[:n| | x |
			x _ 0.
			n timesRepeat: [x _ aBlock value: x].
			x]! !

!Sequence class methodsFor: 'intance creation' stamp: 'len 7/15/2016 18:21'!
to: aDomain evaluating: aBlock
	^ self from: NN to: aDomain evaluating: aBlock! !

!Sequence class methodsFor: 'intance creation' stamp: 'len 10/10/2016 21:07'!
to: aDomain initialValues: anArray recurrence: aBlock
	| cache |
	cache _ OrderedCollection withAll: anArray.
	^ self to: aDomain evaluating:
			[:n|
			"(n isInteger and: [n > 0]) ifFalse: [DomainError signal]."
			[cache size < n] whileTrue: [cache add: (aBlock value: cache value: cache size + 1)].
			cache at: n]! !

!Sequence class methodsFor: 'intance creation' stamp: 'len 10/10/2016 21:08'!
to: aDomain recurrence: aBlock
	^ self to: aDomain initialValues: #() recurrence: aBlock! !

!Sequence class methodsFor: 'intance creation' stamp: 'len 6/1/2019 13:35:57'!
to: aDomain streaming: aBlock
	| cache |
	cache _ OrderedCollection new.
	^ self to: aDomain evaluating:
			[:n|
			"(n isInteger and: [n > 0]) ifFalse: [DomainError signal]."
			[cache size < n] whileTrue: [cache add: aBlock value].
			cache at: n]! !

!CFiniteSequence methodsFor: 'accessing' stamp: 'len 6/4/2019 05:39:53'!
at: n ifAbsent: aBlock
	self order = 0 ifTrue: [^ self codomain zero].
	n <= initialValues size ifTrue: [^ initialValues at: n].
	^ (self matrix ^ (n - self order) * initialValues) last
"	answer _ 0.
	1 to: self order do: [:i |
		answer _ (self at: n - self order + i - 1) * (coefficients at: i) + answer].
	^ answer"! !

!CFiniteSequence methodsFor: 'accessing' stamp: 'len 12/27/2015 01:41'!
characteristicPolynomial
	^ self codomain polynomials coefficients: (coefficients negated copyWith: self codomain one)! !

!CFiniteSequence methodsFor: 'accessing' stamp: 'len 12/27/2015 03:49'!
coefficients
	^ coefficients! !

!CFiniteSequence methodsFor: 'accessing' stamp: 'len 12/27/2015 03:49'!
initialValues
	^ initialValues! !

!CFiniteSequence methodsFor: 'accessing' stamp: 'len 12/28/2016 11:14:12'!
matrix
	^ self propertyAt: #matrix ifAbsentPut: [self characteristicPolynomial companion transposed]! !

!CFiniteSequence methodsFor: 'accessing' stamp: 'len 12/27/2015 02:08'!
minimalPolynomial
	^ self minimal characteristicPolynomial! !

!CFiniteSequence methodsFor: 'accessing' stamp: 'len 12/28/2015 23:45'!
order
	^ coefficients size! !

!CFiniteSequence methodsFor: 'accessing' stamp: 'len 12/27/2015 01:44'!
startIndex
	^ 1! !

!CFiniteSequence methodsFor: 'accessing-private' stamp: 'len 12/3/2015 23:02'!
coefficients: anArray
	coefficients _ anArray! !

!CFiniteSequence methodsFor: 'accessing-private' stamp: 'len 3/28/2018 18:09:29'!
initialValues: anArray
	initialValues _ anArray.
	initialValues isTuple ifFalse: [initialValues _ self codomain tuple: initialValues]! !

!CFiniteSequence methodsFor: 'comparing' stamp: 'len 10/31/2016 04:14'!
= aSequence
	| f g |
	(aSequence isKindOf: CFiniteSequence)
		ifFalse: [^ super = aSequence].
	f _ self minimal.
	g _ aSequence minimal.
	^ f coefficients = g coefficients and: [f initialValues = g initialValues]! !

!CFiniteSequence methodsFor: 'operations' stamp: 'len 12/24/2015 03:35'!
* anObject
	(anObject isKindOf: self class)
		ifTrue: [^ self class to: self codomain evaluating: super * anObject maxOrder: self order * anObject order].
	(self codomain includes: anObject)
		ifTrue: [^ self class to: self codomain evaluating: super * anObject maxOrder: self order].
	^ super * anObject! !

!CFiniteSequence methodsFor: 'operations' stamp: 'len 12/24/2015 03:29'!
+ aSequence
	(aSequence isKindOf: self class) ifFalse: [^ super + aSequence].
	^ self class to: self codomain evaluating: super + aSequence maxOrder: self order + aSequence order! !

!CFiniteSequence methodsFor: 'operations' stamp: 'len 12/24/2015 03:28'!
convolution: aSequence
	(aSequence isKindOf: self class) ifFalse: [^ super convolution: aSequence].
	^ self class to: self codomain evaluating: (super convolution: aSequence) maxOrder: self order * aSequence order! !

!CFiniteSequence methodsFor: 'operations' stamp: 'len 12/28/2016 11:14:22'!
minimal
	^ self propertyAt: #minimal ifAbsentPut: [self class to: self codomain evaluating: self maxOrder: self order]! !

!CFiniteSequence methodsFor: 'operations' stamp: 'len 12/24/2015 03:31'!
negated
	^ self class to: self codomain evaluating: super negated maxOrder: self order! !

!CFiniteSequence methodsFor: 'operations' stamp: 'len 12/24/2015 03:39'!
squared
	| n |
	n _ self order.
	^ self class to: self codomain evaluating: super squared maxOrder: n*(n-1)/2! !

!CFiniteSequence methodsFor: 'operations' stamp: 'len 12/27/2015 19:49'!
sum
	"Answer the indefinite sum of the receiver."
	^ self class to: self codomain evaluating: super sum maxOrder: self order squared! !

!CFiniteSequence methodsFor: 'printing' stamp: 'len 12/27/2015 01:25'!
printLimit
	^ self order + 10 min: super printLimit! !

!CFiniteSequence methodsFor: 'series' stamp: 'len 12/24/2017 22:13:45'!
generatingFunction
	| r s |
	"Answer the generating function of the receiver, which is a rational function that equals its ordinary generating series."
	s _ self characteristicPolynomial reversed.
	r _ self codomain polynomials coefficients:
		((0 to: self order - 1) collect: [:j|
			(self at: j+1) - ((1 to: j) sum: [:i| (s coefficientAtDegree: i) * (self at: j-i+1)])]).
	^ r / s! !

!CFiniteSequence methodsFor: 'testing' stamp: 'len 12/27/2015 02:08'!
isMinimal
	^ self minimalPolynomial = self characteristicPolynomial! !

!CFiniteSequence methodsFor: 'testing' stamp: 'len 4/11/2016 23:10'!
isZero
	^ self minimal order = 0! !

!CFiniteSequence class methodsFor: 'examples' stamp: 'len 2/22/2017 08:37:14'!
fibonacci
	"The Fibonacci sequence defined as a C-finite sequence."
	^ CFiniteSequence initialValues: #(0 1) coefficients: #(1 1)! !

!CFiniteSequence class methodsFor: 'examples' stamp: 'len 2/22/2017 08:37:36'!
geometric: aNumber
	(aNumber isInteger or: [aNumber isFraction])
		ifFalse: [^ DomainError signal: 'argument is not rational'].
	^ CFiniteSequence to: QQ initialValues: #(1) coefficients: {aNumber}! !

!CFiniteSequence class methodsFor: 'examples' stamp: 'len 2/22/2017 08:37:27'!
id
	"The identity sequence id(n) := n, defined by a recurrence."
	^ CFiniteSequence to: QQ initialValues: #(1 2) coefficients: #(-1 2)! !

!CFiniteSequence class methodsFor: 'examples' stamp: 'len 2/22/2017 08:36:33'!
jacobsthalNumbers
	"The Jacobsthal numbers."
	^ CFiniteSequence initialValues: #(0 1) coefficients: #(2 1)! !

!CFiniteSequence class methodsFor: 'examples' stamp: 'len 2/22/2017 08:36:42'!
lucasNumbers
	"The Lucas numbers."
	^ CFiniteSequence initialValues: #(2 1) coefficients: #(1 1)! !

!CFiniteSequence class methodsFor: 'examples' stamp: 'len 2/22/2017 08:36:49'!
pellNumbers
	"The Pell numbers."
	^ CFiniteSequence initialValues: #(0 1) coefficients: #(1 2)! !

!CFiniteSequence class methodsFor: 'instance creation' stamp: 'len 7/15/2016 18:27'!
initialValues: anArray coefficients: anotherArray
	^ self to: ZZ initialValues: anArray coefficients: anotherArray! !

!CFiniteSequence class methodsFor: 'instance creation' stamp: 'len 12/27/2015 19:42'!
to: codomain constant: anObject
	^ self to: codomain initialValues: {anObject} coefficients: {anObject one}! !

!CFiniteSequence class methodsFor: 'instance creation' stamp: 'len 8/6/2016 00:46'!
to: codomain evaluating: aBlock maxOrder: n
	| initialValues bm f |
	initialValues _ (1 to: 2*n) collect: aBlock.
	bm _ ModifiedBerlekampMassey new
		field: (codomain isField ifTrue: [codomain] ifFalse: [codomain fractions]);
		input: initialValues.
	f _ bm minimalPolynomial.
	^ self to: codomain initialValues: (initialValues copyFrom: 1 to: f degree) minimalPolynomial:f! !

!CFiniteSequence class methodsFor: 'instance creation' stamp: 'len 3/30/2016 03:54'!
to: codomain initialValues: anArray characteristicPolynomial: aPolynomial
	^ self to: codomain initialValues: anArray coefficients: aPolynomial tail negated coefficients! !

!CFiniteSequence class methodsFor: 'instance creation' stamp: 'len 11/5/2016 10:27'!
to: aCodomain initialValues: anArray coefficients: anotherArray
	^ self new codomain: aCodomain; initialValues: anArray; coefficients: anotherArray! !

!CFiniteSequence class methodsFor: 'instance creation' stamp: 'len 12/28/2016 12:19:00'!
to: codomain initialValues: anArray minimalPolynomial: aPolynomial
	| answer |
	answer _ self to: codomain initialValues: anArray characteristicPolynomial: aPolynomial.
	answer propertyAt: #minimal put: answer.
	^ answer! !

!CFiniteSequence class methodsFor: 'instance creation' stamp: 'len 6/4/2019 07:19:55'!
to: aCodomain initialValues: initialArray periodic: periodArray
	| coefficients |
	coefficients _ Array new: initialArray size + periodArray size.
	coefficients atAllPut: periodArray first zero.
	coefficients at: initialArray size + 1 put: periodArray first one.
	^ self to: aCodomain initialValues: initialArray asArray, periodArray coefficients: coefficients! !

!CFiniteSequence class methodsFor: 'instance creation' stamp: 'len 12/27/2015 03:41'!
to: codomain periodic: anArray
	| coefficients |
	coefficients _ Array new: anArray size.
	coefficients atAllPut: anArray first zero.
	coefficients at: 1 put: anArray first one.
	^ self to: codomain initialValues: anArray coefficients: coefficients! !

!SimplicialMap methodsFor: 'accessing-private' stamp: 'len 2/20/2017 15:17:40'!
map: aDictionary
	map _ aDictionary! !

!SimplicialMap methodsFor: 'comparing' stamp: 'len 2/20/2017 16:04:20'!
= aSimplicialMap
	self == aSimplicialMap ifTrue: [^ true].
	(aSimplicialMap isKindOf: SimplicialMap)
		ifFalse: [^ false].
	(self domain = aSimplicialMap domain and: [self codomain = aSimplicialMap codomain])
		ifFalse: [^ false].
	^ map = aSimplicialMap map! !

!SimplicialMap methodsFor: 'operations' stamp: 'len 2/20/2017 16:10:51'!
 aSimplicialMap
	"Answer the fibered product of the receiver and the argument."
	self codomain = aSimplicialMap codomain ifFalse: [^ DomainError signal: 'codomains don''t match'].
	^ self domain  aSimplicialMap domain to: self codomain evaluating: [:each| Simplex vertices: (each vertices collect: [:v| {self map value: (v at: 1). aSimplicialMap map value: (v at: 2)}]) asSet]! !

!SimplicialMap methodsFor: 'operations' stamp: 'len 2/20/2017 15:46:09'!
value: aSimplex
	^ Simplex vertices: (aSimplex vertices collect: [:each| map at: each]) asSet! !

!SimplicialMap methodsFor: 'testing' stamp: 'len 2/20/2017 15:55:51'!
isInjective
	^ map asSet size = map size! !

!SimplicialMap methodsFor: 'testing' stamp: 'len 2/20/2017 15:28:04'!
isSurjective
	^ self codomain = self image! !

!SimplicialMap class methodsFor: 'instance creation' stamp: 'len 2/20/2017 18:41:31'!
from: aSimplicialComplex to: anotherSimplicialComplex evaluating: aBlock
	^ self from: aSimplicialComplex to: anotherSimplicialComplex mapping: [:v| (aBlock value: (Simplex vertices: {v})) vertices anyOne]! !

!SimplicialMap class methodsFor: 'instance creation' stamp: 'len 2/20/2017 18:38:40'!
from: aSimplicialComplex to: anotherSimplicialComplex map: aDictionary
	^ self new domain: aSimplicialComplex; codomain: anotherSimplicialComplex; map: aDictionary! !

!SimplicialMap class methodsFor: 'instance creation' stamp: 'len 2/20/2017 18:40:49'!
from: aSimplicialComplex to: anotherSimplicialComplex mapping: aBlock
	| map |
	map _ Dictionary new.
	aSimplicialComplex support do: [:each| map at: each put: (aBlock value: each)].
	^ self from: aSimplicialComplex to: anotherSimplicialComplex map: map! !

!ModularForm methodsFor: 'as yet unclassified' stamp: 'len 12/11/2016 08:26:42'!
codomain
	^ CC! !

!ModularForm methodsFor: 'as yet unclassified' stamp: 'len 12/11/2016 08:26:35'!
domain
	^ HH! !

!ModularForm methodsFor: 'as yet unclassified' stamp: 'len 12/8/2016 22:05:02'!
expansion
	"Answer the q-expansion (Fourier expansion) of the receiver."
	self notYetImplemented! !

!ModularForm methodsFor: 'as yet unclassified' stamp: 'len 12/8/2016 22:04:11'!
group
	^ self notYetImplemented! !

!ModularForm methodsFor: 'as yet unclassified' stamp: 'len 12/8/2016 22:04:15'!
level
	^ self notYetImplemented! !

!ModularForm methodsFor: 'as yet unclassified' stamp: 'len 12/8/2016 22:04:14'!
weight
	^ self notYetImplemented! !

!EisensteinSeries methodsFor: 'as yet unclassified' stamp: 'len 12/6/2016 20:40:21'!
weight
	^ weight! !

!EisensteinSeries methodsFor: 'as yet unclassified' stamp: 'len 12/6/2016 20:42:07'!
weight: anInteger
	(anInteger even and: [anInteger >= 4]) ifFalse: [^ self error: 'the weight must be even >= 4'].
	weight _ anInteger! !

!EisensteinSeries class methodsFor: 'as yet unclassified' stamp: 'len 12/6/2016 20:42:26'!
new: anInteger
	^ self new weight: anInteger! !

!RationalPoint methodsFor: 'accessing' stamp: 'len 2/9/2017 09:54:09'!
ambient
	^ self codomain ambient! !

!RationalPoint methodsFor: 'accessing' stamp: 'len 11/16/2016 08:43'!
codomain
	^ codomain! !

!RationalPoint methodsFor: 'accessing' stamp: 'len 11/16/2016 08:45'!
domain
	^ self scalars spec! !

!RationalPoint methodsFor: 'accessing' stamp: 'len 11/7/2016 16:25'!
scalars
	^ self domain coordinateRing! !

!RationalPoint methodsFor: 'accessing-private' stamp: 'len 11/16/2016 08:43'!
codomain: aScheme
	codomain _ aScheme! !

!RationalPoint methodsFor: 'testing' stamp: 'len 11/7/2016 13:33'!
isAffine
	^ self codomain isAffine! !

!RationalPoint methodsFor: 'testing' stamp: 'len 1/11/2017 13:32:11'!
isFlex
	^ self multiplicity >= 3! !

!RationalPoint methodsFor: 'testing' stamp: 'len 11/7/2016 13:33'!
isProjective
	^ self codomain isProjective! !

!RationalPoint methodsFor: 'testing' stamp: 'len 11/7/2016 08:27'!
isSingular
	^ self isSmooth not! !

!AffinePoint methodsFor: 'accessing' stamp: 'len 11/7/2016 13:16'!
coordinates
	^ coordinates! !

!AffinePoint methodsFor: 'accessing' stamp: 'len 1/7/2017 22:07:07'!
height
	^ coordinates height! !

!AffinePoint methodsFor: 'accessing' stamp: 'len 5/15/2018 16:33:29'!
ideal
	"Answer the prime ideal defining the receiver."
	| R |
	self codomain scalars = self scalars ifFalse: [^ self notYetImplemented].
	R _ self codomain ambient coordinateRing.
	^ R * (R generators - self coordinates)! !

!AffinePoint methodsFor: 'accessing' stamp: 'len 2/8/2017 07:00:30'!
localRing
	"Answer the local ring at this point."
	^ self neighborhood coordinateRing localization! !

!AffinePoint methodsFor: 'accessing' stamp: 'len 4/12/2018 04:17:19'!
multiplicity
	^ self codomain multiplicityAt: coordinates
	"^ self localRing multiplicity"! !

!AffinePoint methodsFor: 'accessing' stamp: 'len 5/20/2018 16:19:38'!
neighborhood
	"Answer a neighborhood centered at the receiver."
	^ self codomain - coordinates! !

!AffinePoint methodsFor: 'accessing' stamp: 'len 11/7/2016 13:31'!
scalars
	^ coordinates scalars! !

!AffinePoint methodsFor: 'accessing' stamp: 'len 4/12/2018 04:17:39'!
tangentCone
	"Answer the affine tangent cone at this point."
	^ self codomain tangentConeAt: coordinates! !

!AffinePoint methodsFor: 'accessing' stamp: 'len 4/12/2018 04:17:46'!
tangentSpace
	"Answer the affine tangent space at this point."
	^ self codomain tangentSpaceAt: coordinates! !

!AffinePoint methodsFor: 'accessing-private' stamp: 'len 11/7/2016 13:16'!
coordinates: aTuple
	coordinates _ aTuple! !

!AffinePoint methodsFor: 'arithmetic' stamp: 'len 12/31/2016 21:07:03'!
+ aTuple
	"Answer the result of translating the receiver by a vector."
	^ self shallowCopy coordinates: self coordinates + aTuple
"	^ self shallowCopy coordinates: self coordinates + ((self codomain asLinearSpace over: self scalars) coordinatesOf: aVector)"! !

!AffinePoint methodsFor: 'arithmetic' stamp: 'len 12/31/2016 21:06:47'!
- anAffinePoint
	"The difference between two affine points is a vector (a tuple)."
	^ self coordinates - anAffinePoint coordinates! !

!AffinePoint methodsFor: 'comparing' stamp: 'len 11/7/2016 03:31'!
= anAffinePoint
	^ self coordinates = anAffinePoint coordinates! !

!AffinePoint methodsFor: 'comparing' stamp: 'len 11/7/2016 03:32'!
hash
	^ self coordinates hash! !

!AffinePoint methodsFor: 'converting' stamp: 'len 9/28/2018 06:51:58'!
asRingMap
	^ self codomain coordinateRing to: self domain coordinateRing evaluating: [:f| f value: self coordinates]! !

!AffinePoint methodsFor: 'converting' stamp: 'len 11/7/2016 13:48'!
asTuple
	^ coordinates! !

!AffinePoint methodsFor: 'converting' stamp: 'len 1/10/2017 20:47:52'!
homogenized
	"Answer the corresponding point in the projective closure."
	^ self codomain projectiveEmbedding value: self! !

!AffinePoint methodsFor: 'testing' stamp: 'len 2/8/2017 07:15:41'!
isSmooth
	^ (self codomain singular satisfies: self coordinates) not! !

!AffinePoint class methodsFor: 'instance creation' stamp: 'len 2/13/2017 21:16:06'!
on: anAffineVariety coordinates: aTuple
	^ self new codomain: anAffineVariety; coordinates: aTuple! !

!ProjectivePoint methodsFor: 'accessing' stamp: 'len 11/7/2016 13:16'!
coordinates
	^ coordinates! !

!ProjectivePoint methodsFor: 'accessing' stamp: 'len 5/3/2018 04:29:36'!
ideal
	"Answer the prime ideal defining the receiver."
	| R m am xm ai generators |
	self codomain scalars = self scalars ifFalse: [^ self notYetImplemented].
	R _ self codomain ambient coordinateRing.
	generators _ OrderedCollection new: coordinates size.
	m _ coordinates lastNonZero.
	am _ coordinates at: m.
	xm _ R x: m.
	1 to: m do: [:i|
		ai _ coordinates at: i.
		ai isZero ifTrue: [generators add: (R x: i)] ifFalse: [generators add: (R x: i) * am - (xm*ai)]].
	m+1 to: coordinates size do: [:i|
		generators add: (R x: i)].
	^ R * generators! !

!ProjectivePoint methodsFor: 'accessing' stamp: 'len 2/8/2017 07:21:43'!
localRing
	"Answer the local ring at this point."
	^ self dehomogenized localRing! !

!ProjectivePoint methodsFor: 'accessing' stamp: 'len 2/13/2017 07:53:19'!
multiplicity
	^ self dehomogenized multiplicity "assuming none of the components of the projective variety lies on the hyperplane at infinity"! !

!ProjectivePoint methodsFor: 'accessing' stamp: 'len 2/9/2017 10:40:03'!
neighborhood
	"Answer an affine neighborhood centered at this point."
	^ self dehomogenized neighborhood! !

!ProjectivePoint methodsFor: 'accessing' stamp: 'len 11/7/2016 13:30'!
scalars
	^ coordinates scalars! !

!ProjectivePoint methodsFor: 'accessing' stamp: 'len 2/9/2017 10:41:07'!
tangentCone
	"Answer the projective tangent cone at this point."
	^ self dehomogenized tangentCone projectiveClosure "this projective closure uses the embedding corresponding to the same affine patch index that was used for dehomogenization"! !

!ProjectivePoint methodsFor: 'accessing-private' stamp: 'len 11/7/2016 13:17'!
coordinates: aTuple
	coordinates _ aTuple! !

!ProjectivePoint methodsFor: 'comparing' stamp: 'len 4/11/2018 06:48:55'!
= aProjectivePoint
	self class = aProjectivePoint class ifFalse: [^ super = aProjectivePoint].
	coordinates size = aProjectivePoint coordinates size ifFalse: [^ false].
	^ self coordinates ~ aProjectivePoint coordinates! !

!ProjectivePoint methodsFor: 'comparing' stamp: 'len 5/3/2018 04:28:40'!
hash
	self scalars isField ifTrue: [^ self hashField].
	self scalars isIntegralDomain ifTrue: [^ self hashIntegralDomain].
	^ self scalars hash "hashMultiply + self coordinates lastNonZeroDivisor"! !

!ProjectivePoint methodsFor: 'comparing' stamp: 'len 5/3/2018 02:49:41'!
hashField
	| hash x |
	hash _ 0.
	x _ coordinates at: coordinates lastNonZero.
	1 to: coordinates size do: [:i | hash _ (hash + ((coordinates at: i) / x) hash) hashMultiply].
	^hash! !

!ProjectivePoint methodsFor: 'comparing' stamp: 'len 5/3/2018 02:50:01'!
hashIntegralDomain
	| Q hash x |
	Q _ self scalars fractions.
	hash _ 0.
	x _ Q embed: (coordinates at: coordinates lastNonZero).
	1 to: coordinates size do: [:i | hash _ (hash + ((Q embed: (coordinates at: i)) / x) hash) hashMultiply].
	^ hash! !

!ProjectivePoint methodsFor: 'converting' stamp: 'len 11/7/2016 13:47'!
asTuple
	^ coordinates! !

!ProjectivePoint methodsFor: 'converting' stamp: 'len 5/3/2018 04:29:29'!
dehomogenized
	"Answer the dehomogenization of the receiver."
	^ self dehomogenizedIn: self coordinates lastNonZero! !

!ProjectivePoint methodsFor: 'converting' stamp: 'len 1/12/2017 14:46:26'!
dehomogenizedIn: anInteger
	"Answer the dehomogenization of the receiver with respect to the anInteger-th coordinate."
	| scalar |
	scalar _ coordinates at: anInteger.
	^ (self codomain patch: anInteger) pointAt:
		(self scalars
			tuple: coordinates size - 1
			evaluating: [:i| (i < anInteger ifTrue: [coordinates at: i] ifFalse: [coordinates at: i + 1]) / scalar])! !

!ProjectivePoint methodsFor: 'printing' stamp: 'len 2/10/2017 09:55:36'!
printInsidesOn: aStream
	| separator |
	separator _ (self coordinates anySatisfy: [:any| any printString isAlphaNumeric not]) ifTrue: [' : '] ifFalse: [':'].
	self coordinates do: [:each| aStream print: each] separatedBy: [aStream nextPutAll: separator].
! !

!ProjectivePoint methodsFor: 'testing' stamp: 'len 2/8/2017 07:19:00'!
isSmooth
	^ (self codomain singular satisfies: self coordinates) not
	
"OR:
	^ self dehomogenized isSmooth
but dehomogenizing requires it be be over a field"
! !

!ProjectivePoint class methodsFor: 'instance creation' stamp: 'len 2/13/2017 21:15:36'!
on: aProjectiveVariety coordinates: aTuple
	^ self new codomain: aProjectiveVariety; coordinates: aTuple! !

!ProjectiveLinePoint methodsFor: 'accessing' stamp: 'len 12/5/2016 10:31:04'!
denominator
	self isInfinity ifTrue: [^ 0].
	^ self value denominator! !

!ProjectiveLinePoint methodsFor: 'accessing' stamp: 'len 12/4/2016 22:21:04'!
infinity
	^ self shallowCopy coordinates: (self scalars tuple: {self scalars one. self scalars zero})! !

!ProjectiveLinePoint methodsFor: 'accessing' stamp: 'len 12/5/2016 10:33:53'!
numerator
	self isInfinity ifTrue: [^ Infinity projective].
	^ self value numerator! !

!ProjectiveLinePoint methodsFor: 'accessing' stamp: 'len 12/4/2016 22:23:56'!
one
	^ self shallowCopy coordinates: (self scalars tuple: {self scalars one. self scalars one})! !

!ProjectiveLinePoint methodsFor: 'accessing' stamp: 'len 12/4/2016 22:10:21'!
value
	^ self coordinates at: 1! !

!ProjectiveLinePoint methodsFor: 'accessing' stamp: 'len 12/4/2016 22:21:41'!
zero
	^ self shallowCopy coordinates: (self scalars tuple: {self scalars zero. self scalars one})! !

!ProjectiveLinePoint methodsFor: 'arithmetic' stamp: 'len 4/8/2018 18:28:32'!
* aCusp
	self isInfinity ifTrue: [aCusp isZero ifTrue: [DomainError signal: 'undefined'] ifFalse: [^ self]].
	aCusp isInfinity ifTrue: [self isZero ifTrue: [DomainError signal: 'undefined'] ifFalse: [^ aCusp]].
	^ self shallowCopy coordinates: (self scalars tuple: {self value * aCusp value. self scalars one})! !

!ProjectiveLinePoint methodsFor: 'arithmetic' stamp: 'len 12/4/2016 22:17:25'!
+ aCusp
	self isInfinity ifTrue: [^ self].
	aCusp isInfinity ifTrue: [^ aCusp].
	^ self shallowCopy coordinates: (self scalars tuple: {self value + aCusp value. self scalars one})! !

!ProjectiveLinePoint methodsFor: 'arithmetic' stamp: 'len 12/4/2016 22:17:46'!
- aCusp
	^ self + aCusp negated! !

!ProjectiveLinePoint methodsFor: 'arithmetic' stamp: 'len 12/4/2016 22:19:44'!
/ aCusp
	^ self * aCusp reciprocal! !

!ProjectiveLinePoint methodsFor: 'arithmetic' stamp: 'len 1/22/2017 08:18:06'!
^ anInteger
	"Answer the receiver raised to the power anInteger."
	anInteger = 1 ifTrue: [^ self].
	anInteger = 0 ifTrue: [^ self one].
	anInteger < 0 ifTrue: [^ self reciprocal ^ anInteger negated].
	^ (self squared ^ (anInteger // 2)) * (self ^ (anInteger \\ 2))! !

!ProjectiveLinePoint methodsFor: 'arithmetic' stamp: 'len 12/4/2016 22:13:31'!
isZero
	^ self isInfinity not and: [self value isZero]! !

!ProjectiveLinePoint methodsFor: 'arithmetic' stamp: 'len 12/4/2016 22:16:53'!
negated
	self isInfinity ifTrue: [^ self].
	^ self shallowCopy coordinates: (self scalars tuple: {self value negated. self scalars one})! !

!ProjectiveLinePoint methodsFor: 'arithmetic' stamp: 'len 12/4/2016 22:20:17'!
reciprocal
	self isInfinity ifTrue: [^ self zero].
	self isZero ifTrue: [^ self infinity].
	^ self shallowCopy coordinates: (self scalars tuple: {self value reciprocal. self scalars one})! !

!ProjectiveLinePoint methodsFor: 'testing' stamp: 'len 5/2/2019 10:38:05'!
|| aPoint
	"Answer true if the receiver is parallel with aPoint.
	Two points [a:b] and [c:d] of a projective line over a ring R are called 'neighbours' or 'parallel' if the matrix:
		[a b]
		[c d]
	is not in GL(2,R), i.e. its determinant ad - cb is not a unit of R.
	Points that are not neighbours are called 'distant'."

	^ (self scalars isUnit: self coordinates x * aPoint coordinates y - (aPoint coordinates x * self coordinates y)) not! !

!ProjectiveLinePoint methodsFor: 'testing' stamp: 'len 12/4/2016 22:09:36'!
isInfinity
	^ (self coordinates at: 2) isZero! !

!EllipticCurvePoint methodsFor: 'accessing' stamp: 'len 11/11/2016 05:22'!
x
	^ self coordinates at: 1! !

!EllipticCurvePoint methodsFor: 'accessing' stamp: 'len 11/11/2016 05:22'!
y
	^ self coordinates at: 2! !

!EllipticCurvePoint methodsFor: 'arithmetic' stamp: 'len 11/11/2016 09:58'!
* anInteger
	anInteger isInteger ifFalse: [^ DomainError signal: 'argument must be integer'].
	anInteger = 1 ifTrue: [^ self].
	anInteger = 0 ifTrue: [^ self zero].
	anInteger < 0 ifTrue: [^ (self * anInteger negated) negated].
	^ anInteger even
		ifTrue: [self doubled * (anInteger // 2)]
		ifFalse: [self doubled * (anInteger // 2) + self]! !

!EllipticCurvePoint methodsFor: 'arithmetic' stamp: 'len 11/11/2016 09:53'!
+ aPoint
	"Answer the sum of the receiver and the argument.
	Reference: Henri Cohen, 'A Course In Computational Algebraic Number Theory', Proposition 7.1.7."
	| W x1 y1 x2 y2 m x3 y3 |
	aPoint isZero ifTrue: [^ self].
	self isZero ifTrue: [^ aPoint].
	W _ self codomain equation.
	x1 _ self x. y1 _ self y.
	x2 _ aPoint x. y2 _ aPoint y.
	(x1 = x2 and: [y1 = (y2 negated - (W a1 * x2) - W a3)]) "self = aPoint negated"
		ifTrue: [^ self zero].
	m _ (x1 = x2 and: [y1 = y2]) "self = aPoint"
		ifTrue: [x1 squared * 3 + (W a2 * x1 * 2) + W a4 - (W a1 * y1) / (y1 * 2 + (W a1 * x1) + W a3)]
		ifFalse: [y1 - y2 / (x1 - x2)].
	x3 _ x1 negated - x2 - W a2 + (m*(m + W a1)).
	y3 _ y1 negated - W a3 - (W a1 * x3) + (m*(x1 - x3)).
	^ self shallowCopy coordinates: (self scalars tuple: {x3. y3. self scalars one})! !

!EllipticCurvePoint methodsFor: 'arithmetic' stamp: 'len 11/9/2016 08:28'!
- aPoint
	^ self + aPoint negated! !

!EllipticCurvePoint methodsFor: 'arithmetic' stamp: 'len 11/11/2016 09:56'!
doubled
	"Answer the receiver times 2, i.e. self + self.
	Reference: Henri Cohen, 'A Course In Computational Algebraic Number Theory', Proposition 7.1.7."
	| W x1 y1 m x3 y3 |
	self isZero ifTrue: [^ self].
	W _ self codomain equation.
	x1 _ self x. y1 _ self y.
	m _ x1 squared * 3 + (W a2 * x1 * 2) + W a4 - (W a1 * y1) / (y1 * 2 + (W a1 * x1) + W a3).
	x3 _ x1*(-2) - W a2 + (m*(m + W a1)).
	y3 _ y1 negated - W a3 - (W a1 * x3) + (m*(x1 - x3)).
	^ self shallowCopy coordinates: (self scalars tuple: {x3. y3. self scalars one})! !

!EllipticCurvePoint methodsFor: 'arithmetic' stamp: 'len 11/11/2016 05:23'!
negated
	| W x |
	self isZero ifTrue: [^ self].
	W _ self codomain equation.
	x _ self x.
	^ self shallowCopy coordinates: (self scalars tuple: {x. self y negated + (W a1 * x) - W a3. self scalars one})! !

!EllipticCurvePoint methodsFor: 'arithmetic' stamp: 'len 11/9/2016 15:19'!
zero
	| R |
	R _ self scalars.
	^ self shallowCopy coordinates: (R tuple: {R zero. R one. R zero})! !

!EllipticCurvePoint methodsFor: 'converting' stamp: 'len 11/11/2016 08:24'!
adaptToInteger: anInteger andSend: selector
	selector = #* ifTrue: [^ self * anInteger].
	self error: 'undefined operation'! !

!EllipticCurvePoint methodsFor: 'testing' stamp: 'len 11/9/2016 13:33'!
isZero
	^ (self coordinates at: 1) isZero and: [(self coordinates at: 3) isZero]! !

!ProductProjectivePoint methodsFor: 'as yet unclassified' stamp: 'len 2/10/2017 09:51:02'!
= aProductProjectivePoint
	self class = aProductProjectivePoint class ifFalse: [^ super = aProductProjectivePoint].
	^ self components = aProductProjectivePoint components! !

!ProductProjectivePoint methodsFor: 'as yet unclassified' stamp: 'len 2/10/2017 09:51:24'!
components
	^ components! !

!ProductProjectivePoint methodsFor: 'as yet unclassified' stamp: 'len 2/10/2017 09:51:33'!
components: anArray
	components _ anArray! !

!ProductProjectivePoint methodsFor: 'as yet unclassified' stamp: 'len 2/10/2017 09:57:48'!
coordinates
	| answer |
	self components do: [:each|
		answer _ answer isNil ifTrue: [each coordinates] ifFalse: [answer, each coordinates]].
	^ answer! !

!ProductProjectivePoint methodsFor: 'as yet unclassified' stamp: 'len 2/10/2017 09:51:17'!
hash
	^ self components hash! !

!GroupElement methodsFor: 'accessing' stamp: 'len 5/10/2019 10:11:51'!
identity
	^ self parent identity! !

!GroupElement methodsFor: 'accessing' stamp: 'len 5/15/2019 03:56:05'!
order
	^ self parent orderOf: self! !

!GroupElement methodsFor: 'operations' stamp: 'len 5/6/2019 03:40:22'!
/ anElement
	^ self  anElement inverse! !

!GroupElement methodsFor: 'operations' stamp: 'len 5/10/2019 10:16:32'!
^ anObject
	anObject isInteger ifFalse: [^ self conjugatedBy: anObject].
	^ self  anObject! !

!GroupElement methodsFor: 'operations' stamp: 'len 5/6/2019 02:50:01'!
 anElement
	^ self subclassResponsibility! !

!GroupElement methodsFor: 'operations' stamp: 'len 5/10/2019 10:10:45'!
 anInteger
	"Answer the receiver composed with itself anInteger times."
	anInteger = 1 ifTrue: [^ self].
	anInteger = 0 ifTrue: [^ self identity].
	anInteger < 0 ifTrue: [^ self inverse  anInteger negated].
	^ (self  self  (anInteger // 2))  (self  (anInteger \\ 2))! !

!GroupElement methodsFor: 'operations' stamp: 'len 5/10/2019 10:57:13'!
commutator: anElement
	^ self inverse  anElement inverse  self  anElement! !

!GroupElement methodsFor: 'operations' stamp: 'len 5/10/2019 10:07:17'!
conjugatedBy: anElement
	^ anElement inverse  self  anElement! !

!GroupElement methodsFor: 'operations' stamp: 'len 5/6/2019 02:49:53'!
inverse
	^ self subclassResponsibility! !

!GroupElement methodsFor: 'testing' stamp: 'len 5/25/2019 06:18:44'!
isIdentity
	^ self = self identity! !

!Monomial methodsFor: 'accessing' stamp: 'len 11/21/2016 15:56:16'!
at: anIndeterminate
	^ exponents at: anIndeterminate! !

!Monomial methodsFor: 'accessing' stamp: 'len 3/16/2016 20:03'!
bitSize
	^ exponents inject: 0 into: [:x :each| x + each bitSize]! !

!Monomial methodsFor: 'accessing' stamp: 'len 3/16/2016 20:05'!
exponents
	^ exponents! !

!Monomial methodsFor: 'accessing' stamp: 'len 2/18/2017 19:54:47'!
indeterminates
	"Answer the list of indeterminates effectively present in this monomial (with non-zero exponent). This is called the 'support' of a monomial."
	^ (1 to: exponents size) select: [:i| (exponents at: i) ~= 0]! !

!Monomial methodsFor: 'accessing' stamp: 'len 6/6/2016 07:00'!
lastIndeterminate
	"Answer the leading indeterminate of the receiver (the last indeterminate effectively present)."
	^ exponents findLast: [:one| one ~= 0]! !

!Monomial methodsFor: 'accessing' stamp: 'len 11/20/2016 11:56:47'!
ordering
	^ parent ordering! !

!Monomial methodsFor: 'accessing' stamp: 'len 1/23/2017 11:35:28'!
parent
	^ parent! !

!Monomial methodsFor: 'accessing' stamp: 'len 2/18/2017 19:54:35'!
support
	"Answer the list of indeterminates effectively present in this monomial (with non-zero exponent)."
	^ self indeterminates! !

!Monomial methodsFor: 'comparing' stamp: 'len 11/20/2016 16:44:54'!
< aMonomial
	^ (self >= aMonomial) not! !

!Monomial methodsFor: 'comparing' stamp: 'len 11/20/2016 16:44:09'!
<= aMonomial
	self == aMonomial ifTrue: [^ true].
	^ (self > aMonomial) not! !

!Monomial methodsFor: 'comparing' stamp: 'len 11/21/2016 19:44:36'!
= aMonomial
	| b |
	self == aMonomial ifTrue: [^ true].
	aMonomial isInteger ifTrue: [^ self degree = aMonomial].
"	^ exponents = aMonomial exponents"
	b _ aMonomial exponents.
	exponents size = b size ifFalse: [^ false].
	1 to: exponents size do: [:i| (exponents at: i) = (b at: i) ifFalse: [^ false]].
	^ true! !

!Monomial methodsFor: 'comparing' stamp: 'len 11/21/2016 08:36:58'!
> aMonomial
	^ (self compare: aMonomial) > 0! !

!Monomial methodsFor: 'comparing' stamp: 'len 11/21/2016 11:19:23'!
>= aMonomial
	self == aMonomial ifTrue: [^ true].
	^ (self compare: aMonomial) >= 0! !

!Monomial methodsFor: 'comparing' stamp: 'len 1/5/2018 11:12:42'!
compare: aMonomial
	"Answer -1 if the receiver is < than the argument, 0 if they are equal, 1 if it is > than the argument."
	^ self ordering compare: self with: aMonomial! !

!Monomial methodsFor: 'comparing' stamp: 'len 11/30/2016 21:59:33'!
hash
	| answer |
	answer _ self lastIndeterminate.
	1 to: exponents size do: [:i|
		| e |
		(e _ exponents at: i) = 0
			ifFalse: [answer _ answer hashMultiply + e hash]].
	^ answer! !

!Monomial methodsFor: 'converting' stamp: 'len 5/23/2018 22:18:46'!
orderedBy: aMonomialOrdering
	^ (self parent orderedBy: aMonomialOrdering) !! self! !

!Monomial methodsFor: 'copying' stamp: 'len 5/14/2019 03:30:59'!
copyWith: anIndeterminate to: anInteger
	^ parent exponents: (exponents copy at: anIndeterminate put: anInteger; yourself)! !

!Monomial methodsFor: 'copying' stamp: 'len 5/14/2019 03:31:04'!
copyWithout: anIndeterminate
	"Answer a copy of the receiver with the given indeterminate removed."
	^ parent exponents: (exponents copy at: anIndeterminate put: 0; yourself)! !

!Monomial methodsFor: 'enumerating' stamp: 'len 5/14/2019 04:00:53'!
do: aBinaryBlock
	exponents withIndexDo: [:each :i| aBinaryBlock value: i value: each]! !

!Monomial methodsFor: 'operations' stamp: 'len 5/13/2019 21:35:37'!
* aMonomial
	^ self  aMonomial! !

!Monomial methodsFor: 'operations' stamp: 'len 5/14/2019 03:30:33'!
/ aMonomial
	"Answer the exact division of the receiver by the argument."
	| b bn c |
	b _ aMonomial exponents.
	bn _ aMonomial exponents size.
	exponents size = bn ifFalse: [^ self error: 'not same size'].
	c _ Array new: bn.
	1 to: bn do: [:i| c at: i put: (exponents at: i) - (b at: i)].
	^ parent exponents: c! !

!Monomial methodsFor: 'operations' stamp: 'len 5/14/2019 03:30:39'!
^ anInteger
	^ parent exponents: exponents * anInteger! !

!Monomial methodsFor: 'operations' stamp: 'len 5/14/2019 03:30:44'!
 aMonomial
	| b bn c |
	b _ aMonomial exponents.
	bn _ aMonomial exponents size.
	exponents size = bn ifFalse: [^ self error: 'not same size'].
	c _ Array new: bn.
	1 to: bn do: [:i| c at: i put: (exponents at: i) + (b at: i)].
	^ parent exponents: c! !

!Monomial methodsFor: 'operations' stamp: 'len 5/14/2019 03:30:53'!
complete: anInteger in: anIndeterminate
	"Answer a copy of the receiver of degree anInteger completing with a power of the indeterminate anotherInteger."
	| n |
	(n _ self degree) = anInteger ifTrue: [^ self].
	^ parent exponents: (exponents copy at: anIndeterminate put: anInteger - n + (self at: anIndeterminate); yourself)! !

!Monomial methodsFor: 'operations' stamp: 'len 5/12/2018 20:02:01'!
degree
	"Answer the total degree of the receiver."
	^ degree ifNil: [degree _ exponents isEmpty ifTrue: [0] ifFalse: [exponents sum]]! !

!Monomial methodsFor: 'operations' stamp: 'len 3/17/2016 00:25'!
degreeIn: anIndeterminate
	"Answer the degree of the receiver in the given indeterminate, i.e. the power to which the indeterminate appears in the receiver."

	^ self at: anIndeterminate! !

!Monomial methodsFor: 'operations' stamp: 'len 5/14/2019 03:31:08'!
dehomogenizedIn: anIndeterminate
	| newExponents |
	newExponents _ Array new: exponents size.
	newExponents replaceFrom: 1 to: anIndeterminate - 1 with: exponents startingAt: 1.
	newExponents replaceFrom: anIndeterminate to: exponents size - 1 with: exponents startingAt: anIndeterminate + 1.
	newExponents at: exponents size put: 0.
	^ parent exponents: newExponents! !

!Monomial methodsFor: 'operations' stamp: 'len 5/15/2019 03:14:30'!
eq: aMonomial
	"Answer the relator for the relation that equates the receiver to the argument."
	^ self  aMonomial inverse! !

!Monomial methodsFor: 'operations' stamp: 'len 5/14/2019 03:31:12'!
gcd: aMonomial
	"Answer the greatest common divisor of the receiver and the argument."
	exponents size <= aMonomial exponents size ifFalse: [^ aMonomial gcd: self].
	^ parent exponents: (exponents withIndexCollect: [:each :i| each min: (aMonomial at: i)])! !

!Monomial methodsFor: 'operations' stamp: 'len 5/14/2019 02:13:57'!
inverse
	(parent isGroup or: [self isIdentity]) ifFalse: [^ DomainError signal: 'not invertible'].
	^ parent exponents: exponents negated! !

!Monomial methodsFor: 'operations' stamp: 'len 5/14/2019 03:31:26'!
lcm: aMonomial
	"Answer the least common multiple of the receiver and the argument."
	exponents size >= aMonomial exponents size ifFalse: [^ aMonomial lcm: self].
	^ parent exponents: (exponents withIndexCollect: [:each :i| each max: (aMonomial at: i)])! !

!Monomial methodsFor: 'operations' stamp: 'len 5/15/2019 04:32:30'!
log: b
	"Answer the discrete logarithm of the receiver in base b. This is, answer an integer k such that b^k equals the receiver."
	self notYetImplemented! !

!Monomial methodsFor: 'operations' stamp: 'len 1/23/2017 11:36:23'!
permutedBy: aPermutation
	"Permute the variables of the receiver. The argument can be an Array (permutation in 'image format'). For example given a monomial in x,z,y, #(1 2 3) doesn't change anything, #(2 1 3) exchanges variables x and y."
	| answer |
	answer _ self parent identity.
	exponents withIndexDo: [:exp :i|
		exp = 0 ifFalse: [answer _ answer * (self parent x: (aPermutation at: i) to: exp)]].
	^ answer! !

!Monomial methodsFor: 'operations' stamp: 'len 5/14/2019 03:31:39'!
root: anInteger
	^ parent exponents: exponents / anInteger! !

!Monomial methodsFor: 'operations' stamp: 'len 5/14/2019 03:31:46'!
root: anInteger in: anIndeterminate
	^ parent exponents: (exponents copy at: anIndeterminate put: (self at: anIndeterminate) / anInteger; yourself)! !

!Monomial methodsFor: 'operations' stamp: 'len 2/9/2017 03:20:49'!
substitute: aBlock
	"Answer the receiver after substituting indeterminates by aBlock."
	| answer |
	answer _ self parent identity.
	exponents withIndexDo: [:exp :i|
		exp = 0 ifFalse: [answer _ answer * (self parent x: (aBlock value: i) to: exp)]].
	^ answer! !

!Monomial methodsFor: 'operations' stamp: 'len 1/21/2017 20:16:54'!
value: anObject
	| answer next |
	1 to: exponents size do: [:i|
		next _ (anObject at: i) ^ (exponents at: i).
		answer _ answer ifNil: [next] ifNotNil: [next * answer]].
	^ answer! !

!Monomial methodsFor: 'operations' stamp: 'len 6/6/2016 04:45'!
without: anIndeterminate
	^ (self has: anIndeterminate) ifFalse: [self] ifTrue: [self copyWithout: anIndeterminate]! !

!Monomial methodsFor: 'printing' stamp: 'len 6/7/2016 21:48'!
printExponent: anInteger on: aStream
	| exponent |
	(exponent _ anInteger printString) = '1'
		ifTrue: [^ self].
	aStream isText
		ifTrue:
			[aStream nextPutAll: exponent super.
			^ self].
	aStream nextPut: $^.
	exponent size = 1
		ifTrue: [aStream nextPutAll: exponent]
		ifFalse: [aStream nextPut: ${; nextPutAll: exponent; nextPut: $}]! !

!Monomial methodsFor: 'printing' stamp: 'len 6/7/2016 21:49'!
printIndeterminate: indeterminate on: aStream
	indeterminate isInteger
		ifFalse: [aStream nextPutAll: indeterminate displayStringOrText. ^ self].
	aStream isText
		ifTrue: [aStream nextPut: $x; nextPutAll: indeterminate printString sub]
		ifFalse:[aStream nextPutAll: '{x', indeterminate printString, '}']! !

!Monomial methodsFor: 'testing' stamp: 'len 5/11/2018 06:54:29'!
| aMonomial
	"Answer true if the receiver divides the argument."
"	self degree > aMonomial degree ifTrue: [^ false]. <- this doesn't seem to help"
	1 to: exponents size do: [:i|
		(exponents at: i) > (aMonomial at: i) ifTrue: [^ false]].
	^ true! !

!Monomial methodsFor: 'testing' stamp: 'len 12/5/2015 22:34'!
has: anIndeterminate
	^ (self at: anIndeterminate) ~= 0! !

!Monomial methodsFor: 'testing' stamp: 'len 6/6/2016 02:50'!
isIdentity
	^ exponents allSatisfy: [:each| each = 0]! !

!Monomial methodsFor: 'testing' stamp: 'len 2/14/2017 10:38:05'!
isPurePower
	"Answer true if the receiver is a power of a single indeterminate."
	| count |
	count _ 0.
	exponents do: [:each| each == 0 ifFalse: [count _ count + 1]. count > 1 ifTrue: [^ false]].
	^ count = 1! !

!Monomial methodsFor: 'testing' stamp: 'len 2/14/2017 10:39:08'!
isSquareFree
	^ exponents allSatisfy: [:each| each == 0 or: [each == 1]]! !

!Monomial methodsFor: 'testing' stamp: 'len 6/6/2016 05:03'!
isUnivariateIn: anIndeterminate
	^ exponents isEmpty or: [(self at: anIndeterminate) = self degree]! !

!Monomial methodsFor: 'private' stamp: 'len 3/16/2016 20:04'!
exponents: anArray
	exponents _ anArray! !

!Monomial methodsFor: 'private' stamp: 'len 2/26/2017 10:37:42'!
parent: aFreeAbelianMonoid
	parent _ aFreeAbelianMonoid! !

!Monomial class methodsFor: 'instance creation' stamp: 'len 11/20/2016 12:01:21'!
exponents: anArray
	^ self basicNew exponents: anArray! !

!Monomial class methodsFor: 'instance creation' stamp: 'len 11/24/2016 10:58:05'!
new
	^ self shouldNotImplement! !

!Monomial class methodsFor: 'instance creation' stamp: 'len 11/20/2016 11:25:52'!
new: anInteger
	^ self exponents: ((Array new: anInteger) atAllPut: 0; yourself)! !

!Monomial class methodsFor: 'instance creation' stamp: 'len 11/24/2016 10:54:53'!
new: anInteger x: i
	"Answer a new instance of the receiver with only one indeterminate: the argument i."
	^ self new: anInteger x: i to: 1! !

!Monomial class methodsFor: 'instance creation' stamp: 'len 11/24/2016 10:54:37'!
new: anInteger x: i to: k
	"Answer a new instance of the receiver with only one indeterminate, xi, raised to n."
	^ self exponents: ((Array new: anInteger) atAllPut: 0; at: i put: k; yourself)! !

!Word methodsFor: 'accessing' stamp: 'len 5/10/2019 10:11:36'!
identity
	^ self class empty! !

!Word methodsFor: 'accessing' stamp: 'len 1/10/2018 11:28:25'!
length
	syllables isEmpty ifTrue: [^ 0].
	^ syllables sum: [:each| each value abs]! !

!Word methodsFor: 'accessing' stamp: 'len 5/10/2019 14:41:44'!
parent
	^ parent! !

!Word methodsFor: 'accessing' stamp: 'len 3/3/2016 05:24'!
syllables
	^ syllables! !

!Word methodsFor: 'comparing' stamp: 'len 1/9/2018 21:32:27'!
< aWord
	^ (self >= aWord) not! !

!Word methodsFor: 'comparing' stamp: 'len 1/9/2018 21:32:46'!
<= aWord
	self == aWord ifTrue: [^ true].
	^ (self > aWord) not! !

!Word methodsFor: 'comparing' stamp: 'len 3/3/2016 05:23'!
= aWord
	^ syllables = aWord syllables! !

!Word methodsFor: 'comparing' stamp: 'len 1/9/2018 21:33:57'!
> aWord
	^ (self compare: aWord) > 0! !

!Word methodsFor: 'comparing' stamp: 'len 1/9/2018 21:34:13'!
>= aWord
	self == aWord ifTrue: [^ true].
	^ (self compare: aWord) >= 0! !

!Word methodsFor: 'comparing' stamp: 'len 1/10/2018 11:40:04'!
compare: aWord
	"Answer -1 if the receiver is < than the argument, 0 if they are equal, 1 if it is > than the argument.
	This is the noncommutative graded-lexicographical ordering."
	| result stream1 stream2 a1 a2 r1 r2 r x1 x2 |
	(result _ (self length - aWord length) sign) = 0 ifFalse: [^ result].
	self isEmpty ifTrue: [^ 0].
	stream1 _ syllables readStream.
	stream2 _ aWord syllables readStream.
	r1 _ 0.
	r2 _ 0.
	[r1 > 0 ifFalse: [a1 _ stream1 next. x1 _ a1 key. r1 _ a1 value].
	r2 > 0 ifFalse: [a2 _ stream2 next. x2 _ a2 key. r2 _ a2 value].
	r _ r1 min: r2.
	x1 < x2 ifTrue: [^ -1].
	x1 = x2 ifFalse: [^ 1].
	r1 _ r1 - r.
	r2 _ r2 - r.
	stream1 atEnd and: [stream2 atEnd]] whileFalse.
	^ 0! !

!Word methodsFor: 'comparing' stamp: 'len 3/3/2016 05:23'!
hash
	^ syllables hash! !

!Word methodsFor: 'copying' stamp: 'len 5/10/2019 17:16:33'!
copyWithout: anInteger
	^ self class syllables: (self syllables select: [:each| each key ~= anInteger])! !

!Word methodsFor: 'enumerating' stamp: 'len 5/10/2019 18:29:24'!
do: aBinaryBlock
	syllables do: [:each| aBinaryBlock value: each key value: each value]! !

!Word methodsFor: 'operations' stamp: 'len 5/5/2019 18:36:08'!
* aWord
	^ self  aWord! !

!Word methodsFor: 'operations' stamp: 'len 5/10/2019 16:12:09'!
/ aWord
	^ self  aWord inverse! !

!Word methodsFor: 'operations' stamp: 'len 5/10/2019 16:13:17'!
 aWord
	| x y |
	self isEmpty ifTrue: [^ aWord].
	aWord isEmpty ifTrue: [^ self].
	parent = aWord parent ifFalse: [DomainError signal: 'words with different parents'].
	syllables last key = aWord syllables first key
		ifFalse: [^ (self class syllables: syllables, aWord syllables) parent: parent].
	x _ syllables as: OrderedCollection.
	y _ aWord syllables as: OrderedCollection.
	[x notEmpty and: [y notEmpty and: [x last key = y first key]]]
		whileTrue:
			[| xn y1 exponent |
			xn _ x removeLast.
			y1 _ y removeFirst.
			(exponent _ xn value + y1 value) = 0
				ifFalse: [^ (self class syllables: (x, {Association key: xn key value: exponent}, y) asArray) parent: parent]].
	^ (self class syllables: (x, y) asArray) parent: parent! !

!Word methodsFor: 'operations' stamp: 'len 5/15/2019 03:14:42'!
eq: aWord
	"Answer the relator for the relation that equates the receiver to the argument."
	^ self  aWord inverse! !

!Word methodsFor: 'operations' stamp: 'len 5/10/2019 16:13:38'!
inverse
	^ (self class syllables: (syllables collect: [:each| Association key: each key value: each value negated]) reversed) parent: parent! !

!Word methodsFor: 'operations' stamp: 'len 5/5/2019 18:35:47'!
reciprocal
	^ self inverse! !

!Word methodsFor: 'operations' stamp: 'len 5/10/2019 16:13:47'!
reversed
	^ (self class syllables: syllables reversed) parent: parent! !

!Word methodsFor: 'operations' stamp: 'len 5/10/2019 16:13:53'!
squared
	^ self  self! !

!Word methodsFor: 'printing' stamp: 'len 7/2/2016 16:29'!
printExponent: anInteger on: aStream
	| exponent |
	(exponent _ anInteger printString) = '1'
		ifTrue: [^ self].
	aStream isText
		ifTrue:
			[aStream nextPutAll: exponent super.
			^ self].
	aStream nextPut: $^.
	exponent size = 1
		ifTrue: [aStream nextPutAll: exponent]
		ifFalse: [aStream nextPut: ${; nextPutAll: exponent; nextPut: $}]! !

!Word methodsFor: 'printing' stamp: 'len 5/13/2019 13:39:13'!
printLetter: letter on: aStream
	letter isInteger
		ifFalse:
			[letter class = self class
				ifTrue: [aStream nextPut: $(; print: letter; nextPut: $)]
				ifFalse: [(aStream isText and: [letter isString])
					ifTrue: [aStream nextPutAll: letter asText]
					ifFalse: [aStream print: letter]].
			^ self].
	aStream isText
		ifTrue: [aStream nextPut: $x; nextPutAll: letter printString sub]
		ifFalse: [aStream nextPutAll: '{x', letter printString, '}']! !

!Word methodsFor: 'testing' stamp: 'len 3/3/2016 05:23'!
isEmpty
	^ syllables isEmpty! !

!Word methodsFor: 'testing' stamp: 'len 1/10/2018 16:54:56'!
isStandard
	"Answer true if the receiver is a standard word, i.e. if the symbols appear in ascending order."
	syllables size < 2 ifTrue: [^ true].
	1 to: syllables size - 1 do: [:i|
		(syllables at: i) key < (syllables at: i+1) key
			ifFalse: [^ false]].
	^ true! !

!Word methodsFor: 'private' stamp: 'len 5/10/2019 14:41:37'!
parent: aDomain
	parent _ aDomain! !

!Word methodsFor: 'private' stamp: 'len 3/3/2016 05:21'!
syllables: anArray
	syllables _ anArray! !

!Word class methodsFor: 'instance creation' stamp: 'len 6/30/2016 02:31'!
empty
	^ self syllables: #()! !

!Word class methodsFor: 'instance creation' stamp: 'len 6/30/2016 02:31'!
new
	^ self shouldNotImplement! !

!Word class methodsFor: 'instance creation' stamp: 'len 6/30/2016 02:30'!
syllables: anArray
	^ self basicNew syllables: anArray! !

!Word class methodsFor: 'instance creation' stamp: 'len 2/12/2016 07:30'!
x: i
	^ self x: i to: 1! !

!Word class methodsFor: 'instance creation' stamp: 'len 3/3/2016 05:24'!
x: i to: k
	"Answer a new instance of the receiver with only one indeterminate, xi, raised to n."
	k = 0 ifTrue: [^ self empty].
	^ self syllables: {i -> k}! !

!Coset methodsFor: 'accessing' stamp: 'len 11/25/2015 02:29'!
representative
	^ representative! !

!Coset methodsFor: 'comparing' stamp: 'len 5/9/2019 11:21:41'!
= aCoset
	^ relations includes: representative  aCoset representative inverse! !

!Coset methodsFor: 'comparing' stamp: 'len 5/9/2019 11:21:32'!
hash
	^ relations hash! !

!Coset methodsFor: 'enumerating' stamp: 'len 5/9/2019 11:20:31'!
do: aBlock
	"Enumerate the elements of the receiver."
	relations do: [:each| aBlock value: each  representative]! !

!Coset methodsFor: 'operations' stamp: 'len 5/9/2019 11:21:25'!
 aCoset
	^ self class representative: representative  aCoset representative relations: relations! !

!Coset methodsFor: 'operations' stamp: 'len 5/9/2019 11:20:46'!
inverse
	^ self class representative: representative inverse relations: relations! !

!Coset methodsFor: 'testing' stamp: 'len 5/9/2019 11:22:04'!
contains: anElement
	^ relations contains: anElement  representative inverse! !

!Coset methodsFor: 'testing' stamp: 'len 5/9/2019 11:21:53'!
includes: anElement
	^ (relations ambient includes: anElement) and: [self contains: anElement]! !

!Coset methodsFor: 'private' stamp: 'len 5/9/2019 11:22:18'!
relations: aSubgroup
	relations _ aSubgroup! !

!Coset methodsFor: 'private' stamp: 'len 11/25/2015 02:29'!
representative: anObject
	representative _ anObject! !

!Coset class methodsFor: 'instance creation' stamp: 'len 5/9/2019 11:22:46'!
representative: anObject relations: aSubgroup
	^ self new representative: anObject; relations: aSubgroup! !

!OppositeGroupElement methodsFor: 'accessing' stamp: 'len 5/9/2019 08:04:46'!
opposite
	^ opposite! !

!OppositeGroupElement methodsFor: 'accessing' stamp: 'len 5/9/2019 08:05:19'!
parent
	^ opposite parent opposite! !

!OppositeGroupElement methodsFor: 'comparing' stamp: 'len 5/9/2019 08:06:35'!
= anElement
	^ self class = anElement class and: [opposite = anElement opposite]! !

!OppositeGroupElement methodsFor: 'comparing' stamp: 'len 5/9/2019 08:06:41'!
hash
	^ opposite hash! !

!OppositeGroupElement methodsFor: 'operations' stamp: 'len 5/9/2019 08:05:01'!
 anElement
	^ self class opposite: anElement opposite  opposite! !

!OppositeGroupElement methodsFor: 'operations' stamp: 'len 5/9/2019 08:05:10'!
inverse
	^ self class opposite: opposite inverse! !

!OppositeGroupElement class methodsFor: 'instance creation' stamp: 'len 5/9/2019 08:05:39'!
opposite: anElement
	^ self new opposite: anElement! !

!SemidirectProductElement methodsFor: 'accessing' stamp: 'len 5/5/98 00:18'!
left
	"Answer the left component of the receiver."
	^ left! !

!SemidirectProductElement methodsFor: 'accessing' stamp: 'len 10/6/2016 15:37'!
parent
	^ parent! !

!SemidirectProductElement methodsFor: 'accessing' stamp: 'len 5/5/98 00:18'!
right
	"Answer the right component of the receiver."
	^ right! !

!SemidirectProductElement methodsFor: 'constants' stamp: 'len 1/23/2017 11:46:24'!
identity
	^ self parent identity! !

!SemidirectProductElement methodsFor: 'operations' stamp: 'len 5/5/2019 18:19:05'!
 aSemidirectProduct
	^ self parent
		project:
			{left  aSemidirectProduct left.
			parent action value: {aSemidirectProduct left. right}  aSemidirectProduct right}! !

!SemidirectProductElement methodsFor: 'operations' stamp: 'len 5/5/2019 18:17:09'!
inverse
	| leftInverse rightInverse |
	leftInverse _ left inverse.
	rightInverse _ right inverse.
	^ parent project: {leftInverse. (parent action value: {leftInverse. rightInverse}) inverse}! !

!SemidirectProductElement methodsFor: 'private' stamp: 'len 5/5/98 00:17'!
left: anObject
	left _ anObject! !

!SemidirectProductElement methodsFor: 'private' stamp: 'len 10/6/2016 15:37'!
parent: aSemidirectProductGroup
	parent _ aSemidirectProductGroup! !

!SemidirectProductElement methodsFor: 'private' stamp: 'len 5/5/98 00:17'!
right: anObject
	right _ anObject! !

!Permutation methodsFor: 'accessing' stamp: 'len 5/25/2019 05:27:21'!
aChange
	"Answer a point changed by the receiver (or nil if there is none)."
	self supportDo: [:each| ^ each].
	^ nil! !

!Permutation methodsFor: 'accessing' stamp: 'len 5/25/2019 06:22:47'!
at: anInteger
	^ images at: anInteger ifAbsent: [anInteger]! !

!Permutation methodsFor: 'accessing' stamp: 'len 5/25/2019 06:19:36'!
at: anInteger put: anotherInteger
	^ images at: anInteger put: anotherInteger! !

!Permutation methodsFor: 'accessing' stamp: 'len 2/8/2018 08:49:09'!
codomain
	^ self domain! !

!Permutation methodsFor: 'accessing' stamp: 'len 5/25/2019 06:19:41'!
degree
	^ images size! !

!Permutation methodsFor: 'accessing' stamp: 'len 4/30/2019 12:30:51'!
domain
	^ parent space! !

!Permutation methodsFor: 'accessing' stamp: 'len 5/25/2019 05:29:24'!
fixedPoints
	"Answer the points fixed by the receiver."
	^ Iterator on: self performing: #fixedPointsDo:! !

!Permutation methodsFor: 'accessing' stamp: 'len 4/30/2019 12:31:23'!
identity
	"Answer the identity permutation."
	^ parent identity! !

!Permutation methodsFor: 'accessing' stamp: 'len 2/8/2018 08:52:14'!
one
	^ self identity! !

!Permutation methodsFor: 'accessing' stamp: 'len 2/8/2018 09:09:16'!
order
	self isIdentity ifTrue: [^ 1].
	^ self cycles inject: 1 into: [:last :each| last lcm: each size]! !

!Permutation methodsFor: 'accessing' stamp: 'len 2/8/2018 08:51:36'!
order2
	| answer next |
	answer _ 1.
	next _ self.
	[next isIdentity] whileFalse: [next _ next * self. answer _ answer + 1].
	^ answer! !

!Permutation methodsFor: 'accessing' stamp: 'len 4/30/2019 12:32:10'!
parent
	^ parent! !

!Permutation methodsFor: 'accessing' stamp: 'len 2/8/2018 09:28:02'!
sign
	| answer |
	answer _ 1.
	self cyclesDo: [:each| each size even ifTrue: [answer _ answer * -1]].
	^ answer

	"^ self transpositions size even ifTrue: [1] ifFalse: [-1]"! !

!Permutation methodsFor: 'accessing' stamp: 'len 5/25/2019 05:26:06'!
support
	"Answer the points changed by the receiver."
	^ Iterator on: self performing: #supportDo:! !

!Permutation methodsFor: 'accessing' stamp: 'len 5/25/2019 05:25:42'!
transpositions
	"Answer the decomposition of the receiver in product of transpositions."
	| answer last value X |
	answer _ OrderedCollection new.
	X _ parent indexToSpace.
	self supportDo: [:each|
		last _ each.
		answer reverseDo: [:one| last _ one at: last].
		(value _ self at: each) = last
			ifFalse: [answer addFirst: (parent transposing: (X at: last) with: (X at: value))]].
	^ answer! !

!Permutation methodsFor: 'accessing' stamp: 'len 5/1/2019 02:37:25'!
type
	"Answer the type of the receiver."
	^ (self cycles asSortedCollection: [:a :b| a size <= b size]) collect: [:each| each size]! !

!Permutation methodsFor: 'actions' stamp: 'len 2/8/2018 08:51:52'!
permute: anArray
	"Answer the permutation of the elements of anArray induced by the receiver."
	| answer |
	answer _ Array new: anArray size.
	1 to: anArray size do: [:i| answer at: i put: (anArray at: (self at: i))].
	^ answer! !

!Permutation methodsFor: 'actions' stamp: 'len 5/1/2019 02:43:35'!
value: anObject
	^ self at: (parent spaceToIndex at: anObject ifAbsent: [^ anObject])! !

!Permutation methodsFor: 'comparing' stamp: 'len 5/25/2019 06:21:34'!
= aPermutation
	^ self class = aPermutation class and: [images = aPermutation images]! !

!Permutation methodsFor: 'comparing' stamp: 'len 5/25/2019 06:22:25'!
hash
	| answer |
	answer _ 0.
	1 to: images size do: [:i| | value |
		(value _ images at: i) = i ifFalse: [answer _ answer bitXor: i hash hashMultiply + value hash]].
	^ answer! !

!Permutation methodsFor: 'converting' stamp: 'len 5/25/2019 06:22:16'!
asArray
	^ images! !

!Permutation methodsFor: 'cycles' stamp: 'len 2/8/2018 08:49:33'!
cycles
	"Answer the cycles of the receiver."
	^ Iterator on: self performing: #cyclesDo:! !

!Permutation methodsFor: 'cycles' stamp: 'len 5/25/2019 05:26:23'!
cyclesDo: aBlock
	"Iterate over the cycles of the receiver."
	| left first next cycle |
	left _ self support copyAs: Set.
	[left size > 0] whileTrue:
		[first _ left anyOne.
		cycle _ OrderedCollection new.
		next _ first.
		[(cycle add: (left remove: (next _ self at: next))) ~= first] whileTrue.
		aBlock value: cycle]! !

!Permutation methodsFor: 'enumerating' stamp: 'len 5/25/2019 06:19:47'!
fixedPointsDo: aBlock
	"Enumerate the points fixed by the receiver."
	1 to: images size do: [:i| (images at: i) = i ifTrue: [aBlock value: i]]! !

!Permutation methodsFor: 'enumerating' stamp: 'len 5/25/2019 06:21:06'!
supportDo: aBlock
	"Enumerate the points changed by the receiver."
	1 to: images size do: [:i| (images at: i) = i ifFalse: [aBlock value: i]]! !

!Permutation methodsFor: 'operations' stamp: 'len 5/5/2019 18:20:17'!
* aPermutation
	"Answer the product (function composition) of the receiver with the argument.
	This is the group operation."
	^ self  aPermutation! !

!Permutation methodsFor: 'operations' stamp: 'len 5/25/2019 06:26:25'!
 aPermutation
	"Answer the product (function composition) of the receiver with the argument.
	This is the group operation."
	| otherImages newImages |
	(images size = aPermutation images size)
		ifFalse: [^ DomainError signal: 'permutation of different degree'].
	otherImages _ aPermutation images.
	newImages _ images class new: images size.
	1 to: images size do: [:i| newImages at: i put: (images at: (otherImages at: i))].
	^ parent images: newImages! !

!Permutation methodsFor: 'operations' stamp: 'len 5/25/2019 06:26:32'!
inverse
	"Answer the compositive inverse of the receiver."
	| values |
	values _ images class new: images size.
	1 to: images size do: [:i| values at: (images at: i) put: i].
	^ parent images: values! !

!Permutation methodsFor: 'testing' stamp: 'len 2/8/2018 08:44:34'!
even
	^ self sign = 1! !

!Permutation methodsFor: 'testing' stamp: 'len 2/8/2018 08:45:31'!
isConjugateWith: aPermutation
	"Answer true if the receiver and the argument are conjugate."

	^ self type = aPermutation type! !

!Permutation methodsFor: 'testing' stamp: 'len 2/8/2018 08:45:37'!
isCycle
	"Answer true if the receiver is a cycle."

	^ self cycles size = 1! !

!Permutation methodsFor: 'testing' stamp: 'len 5/25/2019 05:26:31'!
isIdentity
	"Answer true if the receiver is the identity permutation."

	^ self support size = 0! !

!Permutation methodsFor: 'testing' stamp: 'len 5/25/2019 05:26:46'!
isTransposition
	"Answer true if the receiver is a transposition."

	^ self support size = 2! !

!Permutation methodsFor: 'testing' stamp: 'len 2/8/2018 08:51:17'!
odd
	^ self sign = -1! !

!Permutation methodsFor: 'private' stamp: 'len 5/25/2019 06:22:06'!
images
	^ images! !

!Permutation methodsFor: 'private' stamp: 'len 5/25/2019 06:21:59'!
images: anArray
	images _ anArray! !

!Permutation methodsFor: 'private' stamp: 'len 4/30/2019 12:32:14'!
parent: aSymmetricGroup
	parent _ aSymmetricGroup! !

!RingElement methodsFor: 'accessing' stamp: 'len 9/24/2018 23:38:18'!
associatedUnit
	^ self parent associatedUnit: self! !

!RingElement methodsFor: 'accessing' stamp: 'len 9/24/2018 22:58:07'!
denominator
	^ self one! !

!RingElement methodsFor: 'accessing' stamp: 'len 9/24/2018 22:34:49'!
normalized
	^ self / self associatedUnit! !

!RingElement methodsFor: 'accessing' stamp: 'len 9/24/2018 22:57:58'!
numerator
	^ self! !

!RingElement methodsFor: 'accessing' stamp: 'len 9/24/2018 22:58:16'!
one
	^ self parent one! !

!RingElement methodsFor: 'accessing' stamp: 'len 6/5/2019 14:35:08'!
valuation
	"If the receiver is an element of a valuation ring, answer its valuation."
	^ self parent valuation: self! !

!RingElement methodsFor: 'accessing' stamp: 'len 9/24/2018 22:58:19'!
zero
	^ self parent zero! !

!RingElement methodsFor: 'converting' stamp: 'len 5/11/2019 07:57:02'!
adapt: anObject andSend: selector
	self parent -> anObject parent ifNotNil: [:aMorphism| ^ (aMorphism value: self) perform: selector with: anObject].
	anObject parent -> self parent ifNotNil: [:aMorphism| ^ self perform: selector with: (aMorphism value: anObject)].
	^ DomainError signal: 'coercion failed'! !

!RingElement methodsFor: 'converting' stamp: 'len 5/11/2019 08:29:13'!
adaptToFraction: rcvr andSend: selector
	(#(* + - /) includes: selector)
		ifTrue: [^ self parent !! rcvr perform: selector with: self].
	^ super adaptToFraction: rcvr andSend: selector! !

!RingElement methodsFor: 'converting' stamp: 'len 5/11/2019 08:27:06'!
adaptToInteger: rcvr andSend: selector
	selector = #* ifTrue: [^ self * rcvr].
	selector = #+ ifTrue: [^ self one * rcvr + self].
	selector = #- ifTrue: [^ self one * rcvr - self].
	selector = #/ ifTrue: [^ self one * rcvr / self].
	^ super adaptToInteger: rcvr andSend: selector! !

!RingElement methodsFor: 'operations' stamp: 'len 9/24/2018 02:09:23'!
* aRingElement
	^ self subclassResponsibility! !

!RingElement methodsFor: 'operations' stamp: 'len 9/24/2018 02:08:47'!
+ aRingElement
	^ self subclassResponsibility! !

!RingElement methodsFor: 'operations' stamp: 'len 9/24/2018 02:08:59'!
- aRingElement
	^ self + aRingElement negated! !

!RingElement methodsFor: 'operations' stamp: 'len 9/24/2018 02:10:03'!
/ aRingElement
	^ self * aRingElement reciprocal! !

!RingElement methodsFor: 'operations' stamp: 'len 9/24/2018 22:51:23'!
^ anInteger
	"Answer the receiver raised to the power anInteger."
	anInteger = 1 ifTrue: [^ self].
	anInteger = 0 ifTrue: [^ self one].
	anInteger < 0 ifTrue: [^ (self ^ anInteger negated) reciprocal].
	^ self squared ^ (anInteger // 2) * (self ^ (anInteger \\ 2))! !

!RingElement methodsFor: 'operations' stamp: 'len 5/5/2019 18:35:05'!
 aRingElement
	^ self * aRingElement! !

!RingElement methodsFor: 'operations' stamp: 'len 9/24/2018 22:49:00'!
gcd: aRingElement
	"Answer the greatest common divisor of the receiver and the argument.
	The result is unique (normalized)."
	^ self subclassResponsibility! !

!RingElement methodsFor: 'operations' stamp: 'len 5/5/2019 18:35:19'!
inverse
	^ self reciprocal! !

!RingElement methodsFor: 'operations' stamp: 'len 9/24/2018 22:49:19'!
lcm: aRingElement
	"Answer the greatest common divisor of the receiver and the argument.
	The result is unique (normalized)."
	^ (self / (self gcd: aRingElement) * aRingElement) normalized! !

!RingElement methodsFor: 'operations' stamp: 'len 9/24/2018 02:09:14'!
negated
	^ self subclassResponsibility! !

!RingElement methodsFor: 'operations' stamp: 'len 9/24/2018 02:09:09'!
reciprocal
	^ self subclassResponsibility! !

!RingElement methodsFor: 'operations' stamp: 'len 9/24/2018 22:53:02'!
squared
	^ self * self! !

!RingElement methodsFor: 'testing' stamp: 'len 9/25/2018 15:26:51'!
isIdempotent
	^ self squared = self one! !

!RingElement methodsFor: 'testing' stamp: 'len 9/24/2018 22:27:54'!
isIrreducible
	^ self parent isIrreducible: self! !

!RingElement methodsFor: 'testing' stamp: 'len 9/24/2018 02:12:20'!
isNilpotent
	"Answer true if self^n = 0 for some integer n >= 1."
	^ self parent isNilpotent: self! !

!RingElement methodsFor: 'testing' stamp: 'len 9/24/2018 02:11:01'!
isOne
	^ self = self parent one! !

!RingElement methodsFor: 'testing' stamp: 'len 9/25/2018 15:27:28'!
isPrime
	"Answer true if the receiver is prime."
	^ self parent isPrime: self! !

!RingElement methodsFor: 'testing' stamp: 'len 9/24/2018 02:12:34'!
isUnit
	"Answer true if the receiver is invertible."
	^ self parent isUnit: self! !

!RingElement methodsFor: 'testing' stamp: 'len 9/24/2018 02:10:54'!
isZero
	^ self = self parent zero! !

!RingElement methodsFor: 'testing' stamp: 'len 9/24/2018 02:10:44'!
isZeroDivisor
	^ self parent isZeroDivisor: self! !

!OppositeRingElement methodsFor: 'accessing' stamp: 'len 5/8/2019 14:43:41'!
opposite
	^ opposite! !

!OppositeRingElement methodsFor: 'accessing' stamp: 'len 5/8/2019 14:41:34'!
parent
	^ opposite parent opposite! !

!OppositeRingElement methodsFor: 'arithmetic' stamp: 'len 5/8/2019 14:41:57'!
* anElement
	^ self class opposite: anElement opposite * opposite! !

!OppositeRingElement methodsFor: 'arithmetic' stamp: 'len 5/8/2019 14:42:18'!
+ anElement
	^ self class opposite: opposite + anElement opposite! !

!OppositeRingElement methodsFor: 'arithmetic' stamp: 'len 5/8/2019 14:42:29'!
negated
	^ self class opposite: opposite negated! !

!OppositeRingElement methodsFor: 'comparing' stamp: 'len 5/9/2019 08:04:24'!
= anElement
	^ self class = anElement class and: [opposite = anElement opposite]! !

!OppositeRingElement methodsFor: 'comparing' stamp: 'len 5/9/2019 08:03:56'!
hash
	^ opposite hash! !

!OppositeRingElement methodsFor: 'private' stamp: 'len 5/8/2019 14:43:50'!
opposite: anElement
	opposite _ anElement! !

!OppositeRingElement class methodsFor: 'instance creation' stamp: 'len 5/8/2019 14:44:01'!
opposite: anElement
	^ self new opposite: anElement! !

!ProductRingElement methodsFor: 'accessing' stamp: 'len 5/22/2018 16:10:21'!
at: anInteger
	^ components at: anInteger! !

!ProductRingElement methodsFor: 'accessing' stamp: 'len 5/22/2018 16:10:29'!
size
	^ components size! !

!ProductRingElement methodsFor: 'arithmetic' stamp: 'len 9/16/2018 16:16:11'!
* anObject
	anObject isInteger ifTrue: [^ self class components: components * anObject].
	^ self class components: components * anObject components! !

!ProductRingElement methodsFor: 'arithmetic' stamp: 'len 9/24/2018 23:09:16'!
+ anElement
	^ self class components: components + anElement components! !

!ProductRingElement methodsFor: 'arithmetic' stamp: 'len 5/22/2018 16:12:18'!
negated
	^ self class components: (components collect: [:each| each negated])! !

!ProductRingElement methodsFor: 'arithmetic' stamp: 'len 9/16/2018 16:16:05'!
reciprocal
	^ self class components: (components collect: [:each| each reciprocal ifNil: [^ nil]])! !

!ProductRingElement methodsFor: 'comparing' stamp: 'len 9/16/2018 16:16:01'!
= anObject
	^ self class = anObject class and: [components = anObject components]! !

!ProductRingElement methodsFor: 'comparing' stamp: 'len 5/25/2018 18:50:35'!
hash
	^ components hash! !

!ProductRingElement methodsFor: 'testing' stamp: 'len 5/22/2018 16:24:16'!
isZero
	^ components allSatisfy: [:each| each isZero]! !

!ProductRingElement methodsFor: 'private' stamp: 'len 5/22/2018 16:24:43'!
components
	^ components! !

!ProductRingElement methodsFor: 'private' stamp: 'len 5/22/2018 16:10:02'!
components: anArray
	components _ anArray! !

!ProductRingElement class methodsFor: 'instance creation' stamp: 'len 5/22/2018 16:12:30'!
components: anArray
	^ self new components: anArray! !

!Ratio methodsFor: 'accessing' stamp: 'len 12/28/2015 20:31'!
bitSize
	^ numerator bitSize + denominator bitSize! !

!Ratio methodsFor: 'accessing' stamp: 'len 11/28/2015 06:28'!
denominator
	^ denominator! !

!Ratio methodsFor: 'accessing' stamp: 'len 4/23/2018 20:27:42'!
lift
	^ self numerator lift / self denominator lift! !

!Ratio methodsFor: 'accessing' stamp: 'len 11/28/2015 06:28'!
numerator
	^ numerator! !

!Ratio methodsFor: 'accessing' stamp: 'len 4/23/2018 20:39:56'!
representative
	^ self numerator representative / self denominator representative! !

!Ratio methodsFor: 'arithmetic' stamp: 'len 4/7/2018 00:34:52'!
* anObject
	anObject class == self class
		ifTrue: [^ self class numerator: numerator * anObject numerator denominator: denominator * anObject denominator].
	^ self class numerator: numerator * anObject denominator: denominator! !

!Ratio methodsFor: 'arithmetic' stamp: 'len 4/7/2018 01:03:10'!
+ anObject
	anObject class == self class
		ifTrue: [^ self class
			numerator: numerator * anObject denominator + (denominator * anObject numerator)
			denominator: denominator * anObject denominator].
	^ self class numerator: numerator + (denominator * anObject) denominator: denominator! !

!Ratio methodsFor: 'arithmetic' stamp: 'len 11/28/2015 06:34'!
- anObject
	^ self + anObject negated! !

!Ratio methodsFor: 'arithmetic' stamp: 'len 11/28/2015 06:34'!
/ anObject
	^ self * anObject reciprocal! !

!Ratio methodsFor: 'arithmetic' stamp: 'len 1/22/2017 08:13:41'!
^ anInteger
	anInteger = 1 ifTrue: [^ self].
	anInteger < 0 ifTrue: [^ self reciprocal ^ anInteger negated].
	^ self class
		numerator: numerator ^ anInteger
		denominator: denominator ^ anInteger! !

!Ratio methodsFor: 'arithmetic' stamp: 'len 11/28/2015 06:42'!
negated 
	^ self class
		numerator: numerator negated
		denominator: denominator! !

!Ratio methodsFor: 'arithmetic' stamp: 'len 4/7/2018 00:37:00'!
reciprocal
	^ self class numerator: denominator denominator: numerator! !

!Ratio methodsFor: 'arithmetic' stamp: 'len 4/7/2018 00:37:15'!
squared
	^ self class
		numerator: numerator squared
		denominator: denominator squared! !

!Ratio methodsFor: 'comparing' stamp: 'len 4/7/2018 01:03:54'!
= anObject
	^ anObject class == self class and: [numerator * anObject denominator = (denominator * anObject numerator)] "this is wrong unless the units don't contain any zerodivisor, for example localizations of integral domains"! !

!Ratio methodsFor: 'comparing' stamp: 'len 11/28/2015 06:36'!
hash
	^ 0! !

!Ratio methodsFor: 'constants' stamp: 'len 11/28/2015 06:38'!
one
	^ self class numerator: numerator one denominator: denominator one! !

!Ratio methodsFor: 'constants' stamp: 'len 11/28/2015 06:38'!
zero
	^ self class numerator: numerator zero denominator: denominator one! !

!Ratio methodsFor: 'testing' stamp: 'len 5/25/2018 17:56:07'!
isFractional
	"Answer true if this is an element of a localization, i.e. if it is some kind of fraction and understands #numerator and #denominator."
	^ true! !

!Ratio methodsFor: 'testing' stamp: 'len 11/28/2015 06:36'!
isZero
	^ numerator isZero! !

!Ratio methodsFor: 'private' stamp: 'len 4/5/2018 17:54:53'!
setNumerator: anObject denominator: anotherObject
	numerator _ anObject.
	denominator _ anotherObject! !

!Ratio class methodsFor: 'instance creation' stamp: 'len 4/7/2018 01:22:08'!
numerator: anObject denominator: anotherObject
	| numerator denominator gcd |
	(numerator _ anObject) isZero ifTrue: [^ numerator].
	denominator _ anotherObject.
	gcd _ numerator gcd: denominator.
	numerator _ numerator /// gcd.
	denominator _ denominator /// gcd.
	denominator = denominator one ifTrue: [^ numerator].
	^ self reducedNumerator: numerator denominator: denominator! !

!Ratio class methodsFor: 'instance creation' stamp: 'len 4/7/2018 00:41:16'!
reducedNumerator: anObject denominator: anotherObject
	^ self new setNumerator: anObject denominator: anotherObject! !

!RationalFunction methodsFor: 'accessing' stamp: 'len 4/7/2018 01:07:24'!
indeterminates
	^ Set new addAll: numerator indeterminates; addAll: denominator indeterminates; yourself! !

!RationalFunction methodsFor: 'accessing' stamp: 'len 11/19/2015 19:23'!
scalars
	^ numerator scalars! !

!RationalFunction methodsFor: 'operations' stamp: 'len 4/7/2018 01:05:12'!
degree
	^ numerator degree - denominator degree! !

!RationalFunction methodsFor: 'operations' stamp: 'len 4/7/2018 01:05:41'!
derivative
	"Answer the derivative of the receiver."

	| num gcd |
	num _ denominator * numerator derivative - (numerator * denominator derivative).
	gcd _ denominator gcd: num.
	^ self class numerator: num // gcd denominator: (denominator // gcd) squared * gcd! !

!RationalFunction methodsFor: 'operations' stamp: 'len 4/7/2018 01:06:26'!
homogenized
	"Answer the homogenization of the receiver introducing a new indeterminate."
	| R S |
	R _ numerator parent.
	S _ R scalars polynomialsIn: R rank + 1.
	^ self class numerator: (S !! numerator homogenizedIn: S rank) denominator: (S !! denominator homogenizedIn: S rank)! !

!RationalFunction methodsFor: 'operations' stamp: 'len 4/7/2018 01:06:42'!
homogenizedIn: anIndeterminate
	"Answer the homogenization of the receiver in the given indeterminate."
	^ self class numerator: (numerator homogenizedIn: anIndeterminate) denominator: (denominator homogenizedIn: anIndeterminate)! !

!RationalFunction methodsFor: 'operations' stamp: 'len 4/7/2018 00:59:49'!
reciprocal 
	"Answer the multiplicative inverse of the receiver."

	| mult |
	mult _ numerator leadingCoefficient reciprocal.
"	numerator isConstant ifTrue: [^ denominator * mult]."
	^ self class reducedNumerator: denominator * mult denominator: numerator * mult! !

!RationalFunction methodsFor: 'operations' stamp: 'len 4/7/2018 01:06:56'!
value: anObject
	^ (numerator value: anObject) / (denominator value: anObject)! !

!RationalFunction methodsFor: 'operations' stamp: 'len 11/1/2016 18:41'!
valueWithArguments: anArray
	^ self value: anArray! !

!RationalFunction methodsFor: 'roots and poles' stamp: 'len 3/24/2018 20:30:55'!
allPoles
	^ denominator allRoots! !

!RationalFunction methodsFor: 'roots and poles' stamp: 'len 3/24/2018 20:30:46'!
allPolesIn: aRing
	^ denominator allRootsIn: aRing! !

!RationalFunction methodsFor: 'roots and poles' stamp: 'len 3/24/2018 20:30:17'!
allRoots
	^ numerator allRoots! !

!RationalFunction methodsFor: 'roots and poles' stamp: 'len 3/24/2018 20:30:25'!
allRootsIn: aRing
	"Answer the roots (counted with multiplicity) in the given domain."
	^ numerator allRootsIn: aRing! !

!RationalFunction methodsFor: 'roots and poles' stamp: 'len 12/4/2017 20:39:51'!
orderAt: aNumber
	^ (numerator multiplicityAt: aNumber) - (denominator multiplicityAt: aNumber)! !

!RationalFunction methodsFor: 'roots and poles' stamp: 'len 2/12/2016 02:56'!
poles
	^ denominator roots! !

!RationalFunction methodsFor: 'roots and poles' stamp: 'len 3/24/2018 20:30:38'!
polesIn: aRing
	^ denominator rootsIn: aRing! !

!RationalFunction methodsFor: 'roots and poles' stamp: 'len 2/12/2016 02:56'!
roots
	^ numerator roots! !

!RationalFunction methodsFor: 'roots and poles' stamp: 'len 3/24/2018 20:30:33'!
rootsIn: aRing
	^ numerator rootsIn: aRing! !

!RationalFunction methodsFor: 'testing' stamp: 'len 12/30/2016 20:11:17'!
isAffineLinear
	^ denominator isAffineLinear and: [denominator isConstant]! !

!RationalFunction methodsFor: 'testing' stamp: 'len 11/4/2016 09:49'!
isHomogeneous
	^ self numerator isHomogeneous and: [self denominator isHomogeneous]! !

!RationalFunction methodsFor: 'testing' stamp: 'len 10/17/2016 09:39'!
isLinear
	^ denominator isLinear and: [denominator isConstant]! !

!RationalFunction methodsFor: 'private' stamp: 'len 3/28/2018 15:44:58'!
reduce
	"Reduce the receiver dividing the numerator and the denominator
	by their GCD and making the denominator monic."
	| gcd mult num den |
	(num _ numerator) isZero ifTrue: [denominator _ num one. ^ self].
	den _ denominator.
	gcd _ num gcd: den.
	num _ num /// gcd.
	den _ den /// gcd.
	mult _ den leadingCoefficient reciprocal.
	numerator _ num * mult.
	denominator _ den * mult! !

!RationalFunction methodsFor: 'private' stamp: 'len 9/15/2018 20:36:44'!
setNumerator: f denominator: g
"	g parent isLocal ifFalse: [self halt]."
	super setNumerator: f denominator: g! !

!RationalFunction class methodsFor: 'instance creation' stamp: 'len 5/18/2018 18:47:25'!
numerator: aPolynomial denominator: anotherPolynomial
	| numerator denominator gcd c |
	(numerator _ aPolynomial) isZero ifTrue: [^ numerator].
	denominator _ anotherPolynomial.
	gcd _ numerator gcd: denominator.
	numerator _ numerator /// gcd.
	denominator _ denominator /// gcd.
	"make the denominator monic:"
	c _ denominator leadingCoefficient reciprocal.
	numerator _ numerator * c.
	denominator _ denominator * c.
	denominator = denominator one ifTrue: [^ numerator].
	^ self reducedNumerator: numerator denominator: denominator! !

!ValuationRingElement methodsFor: 'as yet unclassified' stamp: 'len 6/3/2019 05:38:50'!
gcd: anElement
	^ self parent uniformizer ^ (self valuation min: anElement valuation)! !

!ValuationRingElement methodsFor: 'as yet unclassified' stamp: 'len 6/3/2019 05:28:22'!
isFractional
	^ true! !

!ValuationRingElement methodsFor: 'as yet unclassified' stamp: 'len 6/3/2019 05:37:43'!
valuation
	| p a answer |
	p _ self parent p.
	a _ self numerator.
	answer _ 0.
	[p | a] whileTrue: [a _ a // p. answer _ answer + 1].
	^ answer! !

!ValuationRingElement methodsFor: 'as yet unclassified' stamp: 'len 6/3/2019 05:39:33'!
xgcd: anElement
	^ self notYetImplemented! !

!Residue methodsFor: 'accessing' stamp: 'len 12/28/2015 20:32'!
bitSize
	^ representative bitSize! !

!Residue methodsFor: 'accessing' stamp: 'len 4/23/2018 20:38:46'!
lift
	^ self representative! !

!Residue methodsFor: 'accessing' stamp: 'len 11/30/2016 19:16:51'!
modulus
	^ parent modulus! !

!Residue methodsFor: 'accessing' stamp: 'len 11/3/2016 04:43'!
parent
	^ parent! !

!Residue methodsFor: 'accessing' stamp: 'len 2/27/2017 20:50:24'!
relations
	^ parent relations! !

!Residue methodsFor: 'accessing' stamp: 'len 11/25/2015 03:11'!
representative
	^ representative! !

!Residue methodsFor: 'accessing-private' stamp: 'len 10/16/2016 16:01'!
parent: aQuotientRing
	parent _ aQuotientRing! !

!Residue methodsFor: 'accessing-private' stamp: 'len 11/25/2015 03:12'!
representative: anObject
	representative _ anObject! !

!Residue methodsFor: 'comparing' stamp: 'len 5/10/2019 07:48:30'!
= anObject
	(self class = anObject class and: [parent = anObject parent])
		ifTrue: [^ self contains: anObject representative].
	^ self = (parent !! anObject)! !

!Residue methodsFor: 'comparing' stamp: 'len 5/10/2019 08:56:24'!
hash
	^ parent hash! !

!Residue methodsFor: 'conjugation' stamp: 'len 11/3/2016 09:29'!
conjugated
	^ self ^ self parent characteristic! !

!Residue methodsFor: 'conjugation' stamp: 'len 4/20/2016 20:23'!
conjugates
	^ Iterator on: [:aBlock| self conjugatesDo: aBlock]! !

!Residue methodsFor: 'conjugation' stamp: 'len 1/15/2018 19:01:17'!
conjugatesDo: aBlock
	"Iterate over the conjugancy class of the receiver, i.e. all the conjugates including the receiver."
	| alpha |
	alpha _ self.
	[aBlock value: alpha.
	alpha _ alpha ^ self relations scalars characteristic.
	alpha = self] whileFalse! !

!Residue methodsFor: 'constants' stamp: 'len 10/16/2016 15:57'!
one
	^ parent one! !

!Residue methodsFor: 'constants' stamp: 'len 10/16/2016 15:58'!
zero
	^ parent zero! !

!Residue methodsFor: 'converting' stamp: 'len 11/5/2016 04:02'!
, aTuple
	^ (parent tuple: 1 evaluating: [:i| self]), aTuple! !

!Residue methodsFor: 'operations' stamp: 'len 2/14/2017 08:17:55'!
* anObject
	anObject isInteger ifTrue: [^ parent project: representative * anObject].
	(parent includes: anObject)
		ifTrue: [^ parent project: representative * anObject representative].
	^ self * (parent !! anObject)! !

!Residue methodsFor: 'operations' stamp: 'len 2/14/2017 08:18:16'!
+ anObject
	(parent includes: anObject)
		ifTrue: [^ parent project: representative + anObject representative].
	^ self + (parent !! anObject)! !

!Residue methodsFor: 'operations' stamp: 'len 11/1/2016 00:22'!
/// aResidueClass
	"Answer the exact division of the receiver by the argument."
	^ parent project: representative /// aResidueClass representative! !

!Residue methodsFor: 'operations' stamp: 'len 10/24/2016 12:02'!
gcd: aResidueClass
	^ parent project: (representative gcd: aResidueClass representative)! !

!Residue methodsFor: 'operations' stamp: 'len 9/22/2018 18:58:38'!
lcm: aResidueClass
	^ parent project: (representative lcm: aResidueClass representative)! !

!Residue methodsFor: 'operations' stamp: 'len 10/16/2016 15:57'!
negated
	^ parent project: representative negated! !

!Residue methodsFor: 'operations' stamp: 'len 5/24/2019 11:03:06'!
reciprocal
	^ (parent reciprocalOf: self) ifNil: [(ZeroDivide dividend: self one) signal]! !

!Residue methodsFor: 'testing' stamp: 'len 9/15/2018 16:07:02'!
contains: anObject
	^ parent relations contains: anObject - representative! !

!Residue methodsFor: 'testing' stamp: 'len 9/15/2018 16:07:16'!
includes: anObject
	^ (parent base includes: anObject) and: [self contains: anObject]! !

!Residue methodsFor: 'testing' stamp: 'len 11/25/2015 03:10'!
isZero
	"^ (ideal remainderOf: representative) isZero"
	^ representative isZero! !

!Residue class methodsFor: 'instance creation' stamp: 'len 10/16/2016 15:58'!
in: aQuotientRing representative: anObject
	^ self new parent: aQuotientRing; representative: anObject! !

!ModularInteger methodsFor: 'accessing' stamp: 'len 4/21/2016 05:55'!
bitSize
	^ representative bitSize! !

!ModularInteger methodsFor: 'accessing' stamp: 'len 6/3/2019 15:06:31'!
lift
	| m |
	m _ self modulus.
	^ representative <= (m >> 1) ifTrue: [representative] ifFalse: [representative - m]! !

!ModularInteger methodsFor: 'accessing' stamp: 'len 3/29/2016 20:49'!
representative
	^ representative! !

!ModularInteger methodsFor: 'accessing-private' stamp: 'len 3/29/2016 23:52'!
representative: anInteger
	representative _ anInteger! !

!ModularInteger methodsFor: 'as yet unclassified' stamp: 'len 9/25/2018 00:44:40'!
normalized
	^ parent project: (representative gcd: self modulus)! !

!ModularInteger methodsFor: 'comparing' stamp: 'len 9/16/2018 16:14:36'!
= aModularInteger
	self class == aModularInteger class ifFalse: [^ false].
	self == aModularInteger ifTrue: [^ true].
	^ representative = aModularInteger representative and: [parent = aModularInteger parent]! !

!ModularInteger methodsFor: 'comparing' stamp: 'len 3/29/2016 20:48'!
hash
	^ representative hash! !

!ModularInteger methodsFor: 'converting' stamp: 'len 12/2/2016 09:43:47'!
asRational
	"Answer the rational reconstruction of the receiver, or nil if it doesn't exist."
	| N |
	N _ (self modulus // 2) sqrtFloor.
	^ self asRationalMaxNumerator: N maxDenominator: N! !

!ModularInteger methodsFor: 'converting' stamp: 'len 3/6/2017 16:51:02'!
asRational: T
	"Answer the rational reconstruction of the receiver, or nil if not found.
	This is the MQRR (Maximal Quotient Rational Reconstruction) algorithm.
	The parameter T > 0 bounds the size of the possible outputs. If u is the representative of the receiver and m is the modulus, the algorithm returns a rational n/d = u mod m, d > 0, gcd(n,d) = 1 and T*|n|*d < m, or fails.
	The algorithm is almost optimal in the sense that requires that the modulus be only a modest number bits longer than 2*|n|*d. The time complexity is O(log^2 m).
	Reference: 'Maximal Quotient Rational Reconstruction: An Almost Optimal Algorithm for Rational Reconstructoin', Michael Monagan."
	| T2 n d t0 r0 t1 r1 temp answer |
	representative == 0 ifTrue: [^ self modulus > T ifTrue: [0]].
	n _ 0. d _ 0.
	t0 _ 0. r0 _ self modulus.
	t1 _ 1. r1 _ representative.
	T2 _ T.
	[r1 ~~ 0 and: [r0 > T2]]
		whileTrue:
			[| q |
			(q _ r0 // r1) > T2
				ifTrue: [n _ r1. d _ t1. T2 _ q].
			temp _ r0 - (q * r1). r0 _ r1. r1 _ temp.
			temp _ t0 - (q * t1). t0 _ t1. t1 _ temp].
	^ (d ~~ 0 and: [(answer _ n/d) numerator abs = n abs]) ifTrue: [answer]! !

!ModularInteger methodsFor: 'converting' stamp: 'len 12/1/2016 22:06:40'!
asRationalMaxNumerator: N maxDenominator: D
	"Answer the rational reconstruction of the receiver, or nil if it doesn't exist."
	| n d t0 r0 t1 r1 temp answer |
	representative == 0 ifTrue: [^ 0].
	t0 _ 0. r0 _ self modulus.
	t1 _ 1. r1 _ representative.
	[r1 > N]
		whileTrue:
			[| q |
			q _ r0 // r1.
			temp _ r0 - (q * r1). r0 _ r1. r1 _ temp.
			temp _ t0 - (q * t1). t0 _ t1. t1 _ temp].
	n _ r1. d _ t1.
	d <= 0 ifTrue: [n _ n negated. d _ d negated].
	^ (d <= D and: [(answer _ n/d) numerator abs = n abs]) ifTrue: [answer]! !

!ModularInteger methodsFor: 'copying' stamp: 'len 5/7/2019 17:23:01'!
, aTuple
	^ (parent tuple: {self}), aTuple! !

!ModularInteger methodsFor: 'operations' stamp: 'len 11/30/2016 19:19:44'!
+ aModularInteger
	| modulus r |
	aModularInteger isInteger ifTrue: [^ parent project: representative + aModularInteger].
	modulus _ self modulus.
	r _ representative + aModularInteger representative.
	r >= modulus ifTrue: [r _ r - modulus].
	^ self class in: parent representative: r! !

!ModularInteger methodsFor: 'operations' stamp: 'len 11/30/2016 19:20:24'!
- aModularInteger
	| modulus r |
	aModularInteger isInteger ifTrue: [^ parent project: representative - aModularInteger].
	modulus _ self modulus.
	r _ representative + modulus - aModularInteger representative.
	r >= modulus ifTrue: [r _ r - modulus].
	^ self class in: parent representative: r! !

!ModularInteger methodsFor: 'operations' stamp: 'len 6/9/2018 20:29:20'!
/ aModularInteger
	aModularInteger isInteger ifTrue: [^ self * (parent inverseOfRepresentative: aModularInteger)].
	^ self * aModularInteger reciprocal! !

!ModularInteger methodsFor: 'operations' stamp: 'len 1/22/2017 08:16:08'!
^ anInteger
	^ self class in: parent representative: (representative raisedTo: anInteger modulo: self modulus)
"	anInteger = 1 ifTrue: [^ self].
	anInteger = 0 ifTrue: [^ self one].
	anInteger < 0 ifTrue: [^ self reciprocal ^ anInteger negated].
	^ (self * self ^ (anInteger // 2)) * (self ^ (anInteger \\ 2))"! !

!ModularInteger methodsFor: 'operations' stamp: 'len 12/9/2016 22:20:29'!
additiveOrder
	| modulus |
	modulus _ self modulus.
	^ modulus // (representative gcd: modulus)! !

!ModularInteger methodsFor: 'operations' stamp: 'len 5/15/2019 04:42:45'!
log: b
	"Answer the discrete logarithm of the receiver in base b. This is, answer an integer k such that b^k equals the receiver. Note that this is the discrete logarithm problem in the group of units of Z/nZ, which is multiplicative, not in Z/nZ as additive group."
	| m g answer x |
	representative = 0 ifTrue: [^ nil].
	representative = 1 ifTrue: [^ 0].
	m _ parent modulus.
	g _ b representative.
	answer _ 1.
	x _ g.
	[x = representative] whileFalse: [x = 0 ifTrue: [^ nil]. x _ x * g \\ m. answer _ answer + 1].
	^ answer! !

!ModularInteger methodsFor: 'operations' stamp: 'len 12/9/2016 22:34:58'!
multiplicativeOrder
	^ parent units orderOf: self! !

!ModularInteger methodsFor: 'operations' stamp: 'len 11/30/2016 18:56:38'!
negated
	representative = 0 ifTrue: [^ self].
	^ self class in: parent representative: self modulus - representative! !

!ModularInteger methodsFor: 'operations' stamp: 'len 5/24/2019 11:04:14'!
reciprocal
	representative == 1 ifTrue: [^ self].
	^ (parent reciprocalOf: self) ifNil: [(ZeroDivide dividend: self one) signal]! !

!ModularInteger methodsFor: 'operations' stamp: 'len 12/29/2016 08:26:24'!
squareRoot
	"Assuming the receiver is a quadratic residue, answer a square root."
	| p |
	representative == 0 ifTrue: [^ self].
	p _ self modulus.
	p == 2 ifTrue: [^ self].
	(p bitAnd: 3) == 3 ifTrue: [^ self ^ (p + 1 // 4)].
	^ self parent squareRootOf: self! !

!ModularInteger methodsFor: 'testing' stamp: 'len 12/29/2016 07:20:37'!
isQuadraticResidue
	(representative kronecker: self modulus) ~= 1 ifTrue: [^ false].
	(parent isKindOf: PrimeField) ifTrue: [^ true].
	^ self notYetImplemented! !

!ModularInteger methodsFor: 'testing' stamp: 'len 12/4/2016 15:16:58'!
isZero
	^ representative == 0! !

!SmallPrimeFieldElement methodsFor: 'operations' stamp: 'len 9/2/2018 21:50:50'!
* aModularInteger
	| b i p |
	aModularInteger class == self class ifFalse: [^ super * aModularInteger].
	b _ aModularInteger representative.
	(representative = 0 or: [b = 1]) ifTrue: [^ self].
	(representative = 1 or: [b = 0]) ifTrue: [^ aModularInteger].
	i _ (parent logTable at: representative) + (parent logTable at: b).
	i >= (p _ parent modulus) ifTrue: [i _ i - p + 1].
	^ parent representative: (parent expTable at: i)! !

!SmallPrimeFieldElement methodsFor: 'operations' stamp: 'len 9/2/2018 21:48:11'!
/ aModularInteger
	| b i |
	aModularInteger class == self class ifFalse: [^ super / aModularInteger].
	b _ aModularInteger representative.
	(representative = 0 or: [b = 1]) ifTrue: [^ self].
	b = 0 ifTrue: [^ (ZeroDivide dividend: aModularInteger) signal].
	i _ (parent logTable at: representative) - (parent logTable at: b).
	i <= 0 ifTrue: [i _ i + parent modulus - 1].
	^ parent representative: (parent expTable at: i)! !

!RegularFunction methodsFor: 'as yet unclassified' stamp: 'len 11/1/2016 05:16'!
leadingCoefficient
	^ representative leadingCoefficient! !

!RegularFunction methodsFor: 'as yet unclassified' stamp: 'len 12/28/2017 14:48:27'!
leadingMonomial
	^ representative leadingMonomial! !

!RegularFunction methodsFor: 'as yet unclassified' stamp: 'len 11/1/2016 05:18'!
value: anObject
	^ representative value: anObject! !

!RegularFunction methodsFor: 'evaluating' stamp: 'len 11/1/2016 18:57'!
valueWithArguments: anArray
	^ representative valueWithArguments: anArray! !

!AlgebraicElement methodsFor: 'as yet unclassified' stamp: 'len 9/16/2018 16:11:19'!
= anObject
	(self class = anObject class and: [parent = anObject parent])
		ifTrue: [^ representative = anObject representative].
	^ self = (parent !! anObject)! !

!AlgebraicElement methodsFor: 'as yet unclassified' stamp: 'len 5/4/2018 17:19:20'!
characteristicPolynomial
	^ self representation characteristicPolynomial! !

!AlgebraicElement methodsFor: 'as yet unclassified' stamp: 'len 4/6/2018 23:44:03'!
characteristicPolynomial2
	| x |
	x _ QQ algebraicClosure polynomials x.
	^ self parent base !! (self parent embeddings product: [:each| x - (each value: self)])! !

!AlgebraicElement methodsFor: 'as yet unclassified' stamp: 'len 1/17/2019 03:22:33'!
denominator
	^ self * self minimalPolynomial coefficients denominator! !

!AlgebraicElement methodsFor: 'as yet unclassified' stamp: 'len 9/16/2018 16:11:22'!
hash
	^ representative hash! !

!AlgebraicElement methodsFor: 'as yet unclassified' stamp: 'len 5/4/2018 17:18:20'!
minimalPolynomial
	^ self representation minimalPolynomial

"	| x |
	x _ self parent x.
	^ self conjugates product: [:each| x - each] :: as: self parent base"! !

!AlgebraicElement methodsFor: 'as yet unclassified' stamp: 'len 11/3/2016 04:41'!
minimalPolynomial2
	^ (self parent preferedEmbedding value: self) minimalPolynomial! !

!AlgebraicElement methodsFor: 'as yet unclassified' stamp: 'len 5/4/2018 17:20:53'!
norm
	| f |
	f _ self minimalPolynomial.
	^ f independentCoefficient / f leadingCoefficient * (f degree even ifTrue: [1] ifFalse: [-1])
	
"alternatively:
	^ self representation determinant"! !

!AlgebraicElement methodsFor: 'as yet unclassified' stamp: 'len 1/17/2019 03:22:20'!
numerator
	^ self * self denominator! !

!AlgebraicElement methodsFor: 'as yet unclassified' stamp: 'len 5/7/2019 16:49:53'!
representation
	"Answer the representation map defined by multiplication by the receiver."
	| V |
	^ (V _ self parent asVectorSpace) endomorphisms evaluating: [:x| V !! ((self parent !! x) * self)]! !

!AlgebraicElement methodsFor: 'as yet unclassified' stamp: 'len 11/3/2016 04:41'!
symmetricFunction: i
	^ self notYetImplemented! !

!AlgebraicElement methodsFor: 'as yet unclassified' stamp: 'len 5/4/2018 17:20:34'!
trace
	"Answer the absolute trace of the receiver."
	| f |
	f _ self minimalPolynomial.
	^ (f coefficientAtDegree: f degree - 1) negated
	
"alternatively:
	^ self representation trace"! !

!AdicInteger methodsFor: 'accessing' stamp: 'len 6/3/2019 17:26:18'!
<< anInteger
	^ self >> anInteger negated! !

!AdicInteger methodsFor: 'accessing' stamp: 'len 6/5/2019 13:18:16'!
abs
	"Answer the p-adic absolute value (or norm) of the receiver."
	^ self isZero ifTrue: [0] ifFalse: [self p ^ self valuation negated]! !

!AdicInteger methodsFor: 'accessing' stamp: 'len 6/2/2019 10:18:59'!
absolutePrecision
	^ parent precision! !

!AdicInteger methodsFor: 'accessing' stamp: 'len 6/2/2019 16:35:37'!
at: anInteger
	anInteger < 0 ifTrue: [^ 0].
	^ digits at: anInteger + 1! !

!AdicInteger methodsFor: 'accessing' stamp: 'len 6/1/2019 17:30:48'!
digits
	^ digits! !

!AdicInteger methodsFor: 'accessing' stamp: 'len 6/1/2019 17:24:34'!
p
	^ parent p! !

!AdicInteger methodsFor: 'accessing' stamp: 'len 12/17/2016 20:59:36'!
parent
	^ parent! !

!AdicInteger methodsFor: 'accessing' stamp: 'len 6/2/2019 13:54:50'!
relativePrecision
	^ self absolutePrecision! !

!AdicInteger methodsFor: 'accessing' stamp: 'len 6/2/2019 11:30:57'!
valuation
	self isZero ifTrue: [^ Infinity positive].
	^ (digits findFirst: [:x| x isZero not]) - 1
"	i _ 0.
	precision _ parent precision.
	[(digits at: (i _ i + 1)) isZero not ifTrue: [^ i].
	precision > i ifFalse: [^ i]] repeat"! !

!AdicInteger methodsFor: 'arithmetic' stamp: 'len 6/2/2019 11:02:42'!
* anAdic
	| a b n carry  p |
	anAdic class = self class ifFalse: [^ self * (parent !! anAdic)].
	a _ digits.
	b _ anAdic digits.
	p _ self p.
	n _ 1.
	carry _ 0.
	^ parent streaming:
		[| t |
		t _ ((1 to: n) sum: [:i| (a at: i) * (b at: n-i+1)]) + carry.
		n _ n + 1.
		carry _ t // p.
		t \\ p]! !

!AdicInteger methodsFor: 'arithmetic' stamp: 'len 6/1/2019 17:30:18'!
+ anAdic
	| a b n carry  p |
	a _ digits.
	b _ anAdic digits.
	p _ self p.
	n _ 1.
	carry _ 0.
	^ parent streaming:
		[| t |
		t _ (a at: n) + (b at: n) + carry.
		n _ n + 1.
		t < p ifTrue: [carry _ 0. t] ifFalse: [carry _ 1. t - p]]! !

!AdicInteger methodsFor: 'arithmetic' stamp: 'len 6/1/2019 17:30:22'!
- anAdic
	| a b n carry  p |
	a _ digits.
	b _ anAdic digits.
	p _ self p.
	n _ 1.
	carry _ 0.
	^ parent streaming:
		[| t |
		t _ (a at: n) - (b at: n) - carry.
		n _ n + 1.
		t >= 0 ifTrue: [carry _ 0. t] ifFalse: [carry _ 1. t + p]]! !

!AdicInteger methodsFor: 'arithmetic' stamp: 'len 6/2/2019 11:39:02'!
negated
	| n p |
	p _ self p.
	n _ 0.
	^ parent streaming: [n = 0 ifTrue: [p - (digits at: (n _ n + 1))] ifFalse: [p - 1 - (digits at: (n _ n + 1))]]! !

!AdicInteger methodsFor: 'arithmetic' stamp: 'len 6/6/2019 03:43:40'!
reciprocal
	| p a b1 carry |
	p _ self p.
	a _ digits.
	b1 _ (a at: 1) reciprocalModulo: p.
	carry _ 0.
	^ parent digits:
		(Sequence
			initialValues: {b1}
			recurrence:
				[:b :n| | q |
				q _ b1 negated * (((2 to: n) sum: [:i| (a at: i) * (b at: n-i+1)]) + carry).
				carry _ q // p.
				q \\ p])! !

!AdicInteger methodsFor: 'comparing' stamp: 'len 6/3/2019 15:22:35'!
= anAdic
	((anAdic isKindOf: AdicInteger) and: [parent = anAdic parent]) ifFalse: [^ false].
	parent isBounded ifFalse: [^ false].
	"a bounded p-adics that are equal up to their precision are considered equal
	(but maybe it should answer always false, like Magma)"
	1 to: parent precision do: [:i|
		(digits at: i) = (anAdic digits at: i) ifFalse: [^ false]].
	^ true! !

!AdicInteger methodsFor: 'comparing' stamp: 'len 6/3/2019 15:24:04'!
hash
	| answer |
	answer _ 0.
	1 to: 4 do: [:i| "just 4 terms? how to decide how many terms to use?"
		answer _ answer hashMultiply + (digits at: i) hash].
	^ answer! !

!AdicInteger methodsFor: 'printing' stamp: 'len 6/2/2019 11:33:11'!
printOn: aStream withPowersShiftedBy: k
	| printPrecision first |
	self isZero
		ifTrue: [aStream nextPut: $0]
		ifFalse:
			[printPrecision _ 5.
			first _ true.
			self valuation - k to: self valuation + printPrecision - 1 - k do: [:i|
				| x |
				(x _ self digits at: i+1+k) isZero
					ifFalse:
						[first ifFalse: [aStream nextPutAll: ' + '].
						(x ~= 1 or: [i = 0]) ifTrue: [aStream print: x. i ~= 0 ifTrue: [aStream nextPut: Character dot]].
						i ~= 0 ifTrue: [aStream print: self p. i ~= 1 ifTrue: [aStream nextPutAll: i printString super]].
						first _ false]]].
	aStream nextPutAll: ' + ...'
	"parent isBounded
		ifTrue: [aStream nextPutAll: ' + ', 'O' italic; nextPut: $(; print: self p; nextPutAll: parent precision printString super; nextPut: $)]
		ifFalse: [aStream nextPutAll: ' + ...']"! !

!AdicInteger methodsFor: 'testing' stamp: 'len 6/2/2019 10:00:28'!
isZero
	parent isBounded ifFalse: [^ false].
	"a bounded p-adic that is 0 up to its precision is considered 0
	(but maybe it should answers always false, like Magma)"
	1 to: parent precision do: [:i|
		(digits at: i) isZero ifFalse: [^ false]].
	^ true! !

!AdicInteger methodsFor: 'private' stamp: 'len 6/1/2019 16:50:33'!
digits: aSequence
	digits _ aSequence! !

!AdicInteger methodsFor: 'private' stamp: 'len 6/1/2019 16:50:14'!
parent: aPAdicIntegersRing
	parent _ aPAdicIntegersRing! !

!AdicNumber methodsFor: 'accessing' stamp: 'len 6/5/2019 13:19:40'!
abs
	"Answer the p-adic absolute value (or norm) of the receiver."
	^ self isZero ifTrue: [0] ifFalse: [self p ^ valuation negated]! !

!AdicNumber methodsFor: 'accessing' stamp: 'len 6/3/2019 18:20:17'!
absolutePrecision
	^ unit absolutePrecision! !

!AdicNumber methodsFor: 'accessing' stamp: 'len 6/3/2019 18:37:29'!
denominator
	^ valuation < 0 ifTrue: [unit parent !! (self p ^ valuation negated)] ifFalse: [unit one]! !

!AdicNumber methodsFor: 'accessing' stamp: 'len 6/3/2019 18:21:46'!
numerator
	^ valuation <= 0 ifTrue: [unit] ifFalse: [unit >> valuation]! !

!AdicNumber methodsFor: 'accessing' stamp: 'len 6/3/2019 18:21:54'!
p
	^ unit p! !

!AdicNumber methodsFor: 'accessing' stamp: 'len 6/5/2019 11:26:00'!
parent
	^ unit parent fractions! !

!AdicNumber methodsFor: 'accessing' stamp: 'len 6/2/2019 10:46:39'!
relativePrecision
	^ self absolutePrecision - valuation! !

!AdicNumber methodsFor: 'accessing' stamp: 'len 6/3/2019 18:22:52'!
unit
	^ unit! !

!AdicNumber methodsFor: 'accessing' stamp: 'len 6/2/2019 10:48:05'!
valuation
	^ valuation! !

!AdicNumber methodsFor: 'testing' stamp: 'len 6/2/2019 04:09:58'!
isFractional
	^ true! !

!AdicNumber methodsFor: 'private' stamp: 'len 6/3/2019 18:26:19'!
valuation: anInteger unit: anAdicInteger
	valuation _ anInteger.
	unit _ anAdicInteger! !

!AdicNumber class methodsFor: 'instance creation' stamp: 'len 6/3/2019 18:25:44'!
valuation: anInteger unit: anAdicInteger
	^ self new valuation: anInteger unit: anAdicInteger! !

!Polynomial methodsFor: 'accessing' stamp: 'len 4/21/2018 17:52:05'!
denominator
	"Considering the receiver as an element of the fraction ring, answer the denominator."
	^ self one! !

!Polynomial methodsFor: 'accessing' stamp: 'len 4/23/2018 20:34:46'!
lift
	"If the coefficients ring is a quotient R/I, nswer a representative of the receiver over R. See >>%."
	^ self apply: self scalars lifting! !

!Polynomial methodsFor: 'accessing' stamp: 'len 4/21/2018 17:52:16'!
numerator
	"Considering the receiver as an element of the fraction ring, answer the numerator."
	^ self! !

!Polynomial methodsFor: 'accessing' stamp: 'len 10/6/2016 15:34'!
parent
	^ parent! !

!Polynomial methodsFor: 'accessing' stamp: 'len 4/23/2018 21:02:40'!
representative
	"If the coefficients ring is a quotient R/I, nswer a representative of the receiver over R. See >>%."
	^ self apply: self scalars projection section! !

!Polynomial methodsFor: 'accessing' stamp: 'len 10/6/2016 15:34'!
scalars
	^ parent scalars! !

!Polynomial methodsFor: 'accessing-coefficients' stamp: 'len 1/23/2017 11:40:57'!
coefficientAtDegree: anInteger
	"Answer the coefficient of the degree given by the argument. For univiariate polynomials."
	^ self coefficientAt: (self parent monomials x: self leadingIndeterminate to: anInteger)! !

!Polynomial methodsFor: 'accessing-coefficients' stamp: 'len 12/21/2017 22:02:18'!
coefficients
	"Answer the collection of non-zero coefficients of this polynomial (with repetitions)."
	^ Iterator on: self performing: #coefficientsDo:! !

!Polynomial methodsFor: 'accessing-coefficients' stamp: 'len 4/4/2018 21:34:43'!
independentCoefficient
	"Answer the coefficient of the constant monomial of the receiver."

	^ self at: self parent monomials identity! !

!Polynomial methodsFor: 'accessing-indeterminates' stamp: 'len 1/23/2017 11:40:53'!
classIndeterminate
	"Answer the 'class' of the polynomial, i.e. the index of the last indeterminate present in the receiver."
	self flag: #fix. "same as leadingIndeterminate?"
	self parent rank to: 1 by: -1 do: [:i| (self has: i) ifTrue: [^ i]].
	^ 0! !

!Polynomial methodsFor: 'accessing-indeterminates' stamp: 'len 3/1/2016 16:31'!
has: anIndeterminate
	"Answer true if anIndeterminate is effectively present in the receiver."
	^ self monomials anySatisfy: [:any| any has: anIndeterminate]! !

!Polynomial methodsFor: 'accessing-indeterminates' stamp: 'len 2/18/2017 19:52:08'!
indeterminates
	"Answer the indeterminates effectively present in this polynomial."
	^ self parent indeterminates select: [:each| self has: each]! !

!Polynomial methodsFor: 'accessing-indeterminates' stamp: 'len 2/3/2017 07:16:12'!
leadingIndeterminate
	"Answer the main (or leading) indeterminate of the receiver (according to a monomial ordering)."
	| indeterminates |
	indeterminates _ self ordering indeterminates.
	indeterminates reverseDo: [:i| (self has: i) ifTrue: [^ i]].
	^ indeterminates first! !

!Polynomial methodsFor: 'accessing-monomials' stamp: 'len 1/24/2017 12:04:29'!
degree
	"Answer the total degree of the receiver, i.e. the maximum of the degree of its monomials."
	self isZero ifTrue: [^ Infinity negative].
	^ self monomials max: [:each| each degree]! !

!Polynomial methodsFor: 'accessing-monomials' stamp: 'len 3/2/2016 23:47'!
degreeIn: anIndeterminate
	"Answer the degree of the receiver in the given indeterminate."
	self isZero ifTrue: [^ Infinity negative].
	^ self monomials max: [:each| each degreeIn: anIndeterminate]! !

!Polynomial methodsFor: 'accessing-monomials' stamp: 'len 2/6/2017 06:40:57'!
density
	"Answer a measure of the density/sparsity of the receiver."
	self isZero ifTrue: [^ 0].
	^ self coefficients size / (self degree + 1)! !

!Polynomial methodsFor: 'accessing-monomials' stamp: 'len 1/25/2017 07:32:35'!
ecart
	^ self degree - self leadingMonomial degree! !

!Polynomial methodsFor: 'accessing-monomials' stamp: 'len 2/18/2017 19:53:44'!
monomials
	"Answer the collection of monomials effectively present in this polynomial (with non-zero coefficient). This is called the 'support' of a polynomial."
	^ Iterator on: self performing: #monomialsDo:! !

!Polynomial methodsFor: 'accessing-monomials' stamp: 'len 2/3/2017 06:51:05'!
order
	"Answer the minimum degree of the monomials present in the receiver."

	^ self isZero ifTrue: [Infinity negative] ifFalse: [self monomials min: [:each| each degree]]! !

!Polynomial methodsFor: 'accessing-monomials' stamp: 'len 2/3/2017 07:17:54'!
ordering
	"Answer the monomial ordering of the receiver."
	^ self parent ordering! !

!Polynomial methodsFor: 'accessing-monomials' stamp: 'len 2/18/2017 19:54:05'!
support
	"Answer the collection of monomials effectively present in this polynomial (with non-zero coefficient)."
	^ self monomials! !

!Polynomial methodsFor: 'accessing-terms' stamp: 'len 2/7/2017 03:38:56'!
formAt: anInteger
	"Answer the homogeneous component of degree anInteger (an anInteger-form)."
	| answer |
	answer _ self zero.
	self terms do: [:each| each degree = anInteger ifTrue: [answer _ answer + each]].
	^ answer! !

!Polynomial methodsFor: 'accessing-terms' stamp: 'len 2/7/2017 03:56:52'!
leadingForm
	"Answer the homogeneous component of the lowest degree.
	This makes sense for a local ordering."
	self ordering isLocal ifFalse: [self error: 'not a local ordering'].
	^ self isZero
		 ifTrue: [self]
		 ifFalse: [self formAt: self order]! !

!Polynomial methodsFor: 'accessing-terms' stamp: 'len 3/1/2016 22:11'!
leadingTerm
	"Answer the first term of the receiver."

	^ self isZero
		 ifTrue: [self]
		 ifFalse: [self termAt: self leadingMonomial]! !

!Polynomial methodsFor: 'accessing-terms' stamp: 'len 2/10/2017 20:28:17'!
linearForm
	^ self formAt: 1! !

!Polynomial methodsFor: 'accessing-terms' stamp: 'len 12/24/2017 20:10:34'!
parts
	^ Iterator on: self performing: #partsDo:! !

!Polynomial methodsFor: 'accessing-terms' stamp: 'len 3/1/2016 22:08'!
tail
	^ self - self leadingTerm! !

!Polynomial methodsFor: 'accessing-terms' stamp: 'len 12/21/2017 18:25:51'!
termAt: aMonomial
	^ self parent coefficient: (self at: aMonomial) monomial: aMonomial! !

!Polynomial methodsFor: 'accessing-terms' stamp: 'len 11/29/2016 11:49:38'!
terms
	^ Iterator on: self performing: #termsDo:! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 4/22/2018 17:16:56'!
% anInteger
	^ self apply: (self scalars integers % anInteger) projection! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 4/6/2018 23:32:58'!
* anObject
	(anObject isInteger or: [self scalars includes: anObject])
		ifTrue: [^ self multipliedByScalar: anObject].
	(self parent includes: anObject)
		ifTrue: [^ self multipliedByPolynomial: anObject].
	(anObject isKindOf: Monomial)
		ifTrue: [^ self multipliedByMonomial: anObject].
	((anObject isKindOf: Polynomial) and: [anObject scalars includes: self])
		ifTrue: [^ anObject multipliedByScalar: self].
	(anObject isKindOf: RationalFunction)
		ifTrue: [^ anObject * self].
	^ self multipliedByPolynomial: (self parent !! anObject)! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 5/18/2018 21:02:48'!
/ anObject
	(anObject isKindOf: Monomial)
		ifTrue: [^ self dividedByMonomial: anObject].
	(self parent includes: anObject)
		ifTrue: [^ RationalFunction numerator: self denominator: anObject].
	(self scalars includes: anObject) "assumes the content is divisible by anObject"
		ifTrue: [^ self dividedByScalar: anObject].
	^ self * anObject reciprocal! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 4/24/2018 19:38:25'!
// anObject
	"Answer the quotient of the division of the receiver by the argument."

	(self scalars includes: anObject)
		ifTrue: [^ self apply: [:each| each // anObject]].
	^ (self divisionBy: anObject) quotient! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 12/24/2017 19:49:16'!
/// anObject
	"Answer the exact quotient of the division of the receiver by the argument."
	(anObject isKindOf: Monomial)
		ifTrue: [^ self dividedByMonomial: anObject].
	(self scalars includes: anObject)
		ifTrue: [^ self apply: [:each| each /// anObject]].
	^ self exactlyDividedBy: anObject! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 4/24/2018 19:38:28'!
\\ anObject
	"Answer the remainder of the division of the receiver by the argument."

	(self scalars includes: anObject)
		ifTrue: [^ self apply: [:each| each \\ anObject]].
	^ (self divisionBy: anObject) remainder! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 5/5/2019 18:28:02'!
 anObject
	"Answer the composition of the receiver with the argument."
	anObject isBlock ifTrue: [^ [:x| self value: (anObject value: x)]].
	^ self value: anObject! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 5/30/2019 03:49:27'!
abs
	"Answer the Euclidean function at the receiver."
	^ self degree! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 4/24/2018 19:40:24'!
divisionBy: aPolynomial
	"Answer a division algorithm to divide the receiver by aPolynomial."
	aPolynomial isCollection ifTrue: [^ MultivariatePolynomialDivision divide: self by: aPolynomial].
	(self isUnivariate and: [aPolynomial isUnivariate])
		ifFalse: [^ MultivariatePolynomialDivision divide: self by: {aPolynomial}].
	(aPolynomial isMonic or: [self scalars isField])
		ifFalse: [^ self pseudoDivisionBy: aPolynomial].
	^ PolynomialDivision divide: self by: aPolynomial! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 4/24/2018 00:53:03'!
exactlyDividedBy: aPolynomial
	"Answer the exact division of the receiver by the argument."

	self isZero
		ifTrue: [^ self].
	aPolynomial isConstant
		ifTrue: [^ self dividedByScalar: aPolynomial leadingCoefficient].
	(self isUnivariate and: [aPolynomial isUnivariate])
		ifFalse: [^ (MultivariatePolynomialDivision divide: self by: {aPolynomial}) exactQuotient].
	(aPolynomial isMonic or: [self scalars isField])
		ifFalse: [^ (PolynomialPseudoDivision divide: self by: aPolynomial) exactQuotient].
	^ (PolynomialDivision divide: self by: aPolynomial) exactQuotient! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 5/23/2018 22:30:01'!
gcd: aPolynomial
	"Answer the greatest common divisor of the receiver and aPolynomial."
	| a b r |
	self isZero ifTrue: [^ aPolynomial].
	aPolynomial isZero ifTrue: [^ self].
	(self isUnivariate and: [aPolynomial isUnivariate])
		ifFalse: "Multivariate case:"
			[self scalars isUFD ifFalse: [^ DomainError signal: 'not an UFD'].
			(self isConstant or: [aPolynomial isConstant])
				ifTrue: [^ self scalars isField ifTrue: [self one] ifFalse: [self parent constant: (self content gcd: aPolynomial content)]].
			a _ self asUnivariate.
			b _ aPolynomial asUnivariate.
			^ (self parent !! ((a primitive gcd: b primitive) * (a content gcd: b content)) asMultivariate) primitive].
	self scalars isField
		ifFalse: "If it's not a field we use the primitive PRS algorithm:"
			[a _ self primitive.
			b _ aPolynomial primitive.
			[b isZero] whileFalse: [r _ (a pseudoRem: b) primitive. a _ b. b _ r].
			a isConstant ifTrue: [a _ self one].
			^ a * (self content gcd: aPolynomial content)].
	a _ self.
	b _ aPolynomial.
	[(r _ a \\ b) isZero] whileFalse: [a _ b. b _ r].
	^ b * b leadingCoefficient reciprocal! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 9/24/2018 23:53:03'!
lcm: aPolynomial
	"Answer the least common multiple of the receiver and aPolynomial."

	^ ((self exactlyDividedBy: (self gcd: aPolynomial)) * aPolynomial) normalized! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 1/23/2017 11:43:10'!
pgcd: aPolynomial
	"Answer the greatest common divisor of the receiver and aPolynomial using a probabilistic algorithm."
	| f g maps samples n |
	(self parent scalars isKindOf: RationalIntegerRing) ifFalse: [^ DomainError signal: 'polynomial not in Z[x]'].
	f _ self integerPrimitive.
	g _ aPolynomial integerPrimitive.
	n _ f degree max: g degree.
	maps _ OrderedCollection new: n + 1.
	samples _ 1 to: n.
	samples do:
		[:each| maps add: each -> ((f value: each) gcd: (g value: each))].
	^ self parent interpolate: maps! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 4/24/2018 19:39:39'!
pseudoDivisionBy: aPolynomial
	"Answer a pseudo-division algorithm to divide the receiver by aPolynomial."
	self isUnivariate ifFalse: [^ DomainError signal: 'polynomial is not univariate'].
	self scalars isUFD ifFalse: [^ DomainError signal: 'polynomial not over a UFD'].
	^ PolynomialPseudoDivision divide: self by: aPolynomial! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 4/24/2018 19:39:55'!
pseudoDivisionBy: aPolynomial in: anIndeterminate
	^ (self asUnivariateIn: anIndeterminate) pseudoDivisionBy: (aPolynomial asUnivariateIn: anIndeterminate)! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 4/24/2018 19:40:35'!
pseudoQuo: aPolynomial
	"Answer the quotient of the pseudo-division of the receiver by the argument."
	self isUnivariate ifFalse: [^ (self pseudoDivisionBy: aPolynomial in: self leadingIndeterminate) quotient asMultivariate].
	^ (self pseudoDivisionBy: aPolynomial) quotient! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 4/24/2018 19:40:44'!
pseudoRem2: aPolynomial
	"Answer the remainder of the pseudo-division of the receiver by the argument."
	self isUnivariate ifFalse: [^ (self pseudoDivisionBy: aPolynomial in: self leadingIndeterminate) remainder asMultivariate].
	^ (self pseudoDivisionBy: aPolynomial) remainder! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 4/24/2018 19:41:29'!
pseudoRem3: aPolynomial
	"Answer the remainder of the pseudo-division of the receiver by the argument."
	| n d b w k |
	self isUnivariate ifFalse: [^ (self pseudoDivisionBy: aPolynomial in: self leadingIndeterminate) remainder asMultivariate].
	"^ (self pseudoDivisionBy: aPolynomial) remainder"
	self degree < (n _ aPolynomial degree) ifTrue: [^ self].
	w _ self.
	d _ self degree - n + 1.
	b _ aPolynomial leadingCoefficient.
	[k _ w degree - n.
	w _ b * w - ((self parent coefficient: w leadingCoefficient degree: k)*aPolynomial).
	w isZero ifTrue: [^ w].
	w degree < n ifTrue: [^ w * (b ^ k)].
	k > d ifTrue: [w _ w * (b ^ (k - d))]] repeat! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 4/24/2018 19:41:35'!
pseudoRem4: aPolynomial
	"Answer the remainder of the pseudo-division of the receiver by the argument."
	| n b w e k |
	self isUnivariate ifFalse: [^ (self pseudoDivisionBy: aPolynomial in: self leadingIndeterminate) remainder asMultivariate].
	"^ (self pseudoDivisionBy: aPolynomial) remainder"
	self degree < (n _ aPolynomial degree) ifTrue: [^ self].
	w _ self.
	e _ self degree - n + 1.
	b _ aPolynomial leadingCoefficient.
	[k _ w degree - n.
	w _ w * b - ((aPolynomial shift: k) * w leadingCoefficient).
	w isZero ifTrue: [^ w].
	w degree < n ifTrue: [^ w * (b ^ k)].
	k > e ifTrue: [w _ w * (b ^ (k - e))]] repeat! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 4/24/2018 19:40:49'!
pseudoRem: aPolynomial
	"Answer the remainder of the pseudo-division of the receiver by the argument."
	self isUnivariate ifFalse: [^ (self pseudoDivisionBy: aPolynomial in: self leadingIndeterminate) remainder asMultivariate].
	^ (self pseudoDivisionBy: aPolynomial) remainder! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 3/23/2016 08:37'!
raisedTo2: anInteger modulo: anObject
	"Answer the receiver raised to the power anInteger modulo anObject.
	The argument anInteger must be positive."

	| result y n |
	result _ self one.
	n _ anInteger abs.
	y _ self \\ anObject.
	[n > 0]
		whileTrue:
			[n odd ifTrue: [result _ result * y \\ anObject].
			y _ y squared \\ anObject.
			n _ n // 2].
	^ anInteger negative ifTrue: [result reciprocal] ifFalse: [result]! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 4/19/2018 17:29:29'!
raisedTo: anInteger modulo: aPolynomial
	"Answer the receiver raised to the power anInteger modulo aPolynomial.
	The argument anInteger must be positive."

	anInteger = 0 ifTrue: [^ 1].
	anInteger = 1 ifTrue: [^ self \\ aPolynomial].
	^ (self squared \\ aPolynomial raisedTo: anInteger // 2 modulo: aPolynomial) * (self raisedTo: anInteger \\ 2 modulo: aPolynomial) \\ aPolynomial! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 12/24/2017 22:14:08'!
reciprocal
	"Answer the reciprocal of the receiver, possibly as a rational function, assuming the scalars are a field."
	self isConstant ifTrue: [^ self parent constant: self independentCoefficient reciprocal].
	^ self one / self! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 11/11/2015 02:29'!
squared
	^ self * self! !

!Polynomial methodsFor: 'arithmetic-private' stamp: 'len 12/22/2015 21:54'!
karatsubaMultiplyBy: aPolynomial
	"Ref: Zippel pp 119. O(n^1.56)"
	| n h f0 f1 g0 g1 f0g0 f1g1 |
	n _ self degree.
"	self assert: aPolynomial degree = n."
	self assert: self isUnivariate.
	h _ n // 2.
	f0 _ self >> h. f1 _ self - (f0 << h).
	g0 _ aPolynomial >> h. g1 _ aPolynomial - (g0 << h).
	f0g0 _ f0 * g0.
	f1g1 _ f1 * g1.
	^ f0g0 << (2*h) + ((f1+f0)*(g1+g0) - f0g0 - f1g1 << h) + f1g1! !

!Polynomial methodsFor: 'converting' stamp: 'len 1/23/2017 11:39:20'!
asBilinearForm
	(self degree = 2 and: [self isHomogeneous]) ifFalse: [^ self error: 'not homogeneous of degree 2'].
	self parent rank even ifFalse: [^ self error: 'not even rank'].
	^ BilinearForm fromHalf: (self scalars ^ (self parent rank / 2)) evaluating: [:each| self value: each first, each second]! !

!Polynomial methodsFor: 'converting' stamp: 'len 1/23/2017 11:39:28'!
asIdeal
	"Answer the ideal generated by the receiver."
	^ self parent * self! !

!Polynomial methodsFor: 'converting' stamp: 'len 5/22/2018 22:39:50'!
asLinearForm
	self isLinear ifFalse: [^ DomainError signal: 'not a linear polynomial'].
	^ (self scalars ^ self parent rank) dual evaluating: self! !

!Polynomial methodsFor: 'converting' stamp: 'len 5/23/2018 22:21:02'!
asMultivariate
	"Convert a polynomial in R[x][y][z] to a polynomial in R[x,y,z]."
	| R S answer |
	((R _ self scalars) isKindOf: PolynomialRing) ifFalse: [^ self].
	self parent isUnivariate ifFalse: [^ self].
	S _ self parent asMultivariate.
	answer _ S zero.
	self partsDo: [:each|
		answer _ answer + (S !! each value * (S x: R rank + 1 to: each key degree))].
	^ answer! !

!Polynomial methodsFor: 'converting' stamp: 'len 12/21/2017 20:09:56'!
asScalar
	self isConstant ifFalse: [^ self error: 'not a constant polynomial'].
	^ self leadingCoefficient! !

!Polynomial methodsFor: 'converting' stamp: 'len 5/23/2018 22:28:42'!
asUnivariate
	"Answer the receiver as univariate in the last indeterminate, e.g. go from R[x,y,z] to R[x,y][z]."
	| S term n d coefficients |
	self parent isUnivariate ifTrue: [^ self].
	n _ self parent rank.
	S _ self parent asUnivariate.
	(d _ self degreeIn: n) <= 0
		ifTrue: [^ S constant: S scalars !! self].
	coefficients _ Array new: d+1.
	coefficients atAllPut: S scalars zero.
	self partsDo: [:each|
		term _ S scalars coefficient: each value monomial: S scalars monomials !! (each key without: n).
		coefficients at: (each key degreeIn: n)+1 add: term].
	^ S coefficients: coefficients! !

!Polynomial methodsFor: 'converting' stamp: 'len 1/23/2017 11:40:38'!
asUnivariateIn: anIndeterminate
	"Answer the receiver as univariate in the given indeterminate, e.g. go from R[x,y,z] to R[x,y][z]."
	(self parent isUnivariate and: [self parent indeterminate = anIndeterminate]) ifTrue: [^ self].
	anIndeterminate = self parent rank ifFalse: [self error: 'bad indeterminate'].
	^ self asUnivariate! !

!Polynomial methodsFor: 'converting' stamp: 'len 11/17/2016 19:02:41'!
monic
	^ self / self leadingCoefficient! !

!Polynomial methodsFor: 'converting' stamp: 'len 5/23/2018 22:30:47'!
orderedBy: aMonomialOrdering
	"Answer a copy of the receiver with a different monomial ordering."
	^ (self parent orderedBy: aMonomialOrdering) !! self! !

!Polynomial methodsFor: 'enumerating' stamp: 'len 12/24/2017 20:07:32'!
termsDo: aBlock
	self partsDo: [:each| aBlock value: (self parent coefficient: each value monomial: each key)]! !

!Polynomial methodsFor: 'factorization' stamp: 'len 11/28/2016 09:15:07'!
content
	"Answer the GCD of the coefficients of the receiver.
	In a field, it is convenient to define the content as 1.
	For example, 2x^2 + 4 has content 2 in Z[x] and 1 in Q[x]."
	| answer |
	self isZero ifTrue: [^ self scalars zero].
	self scalars isField
		ifTrue:
			[^ self scalars isFractionRing
				ifTrue:
					[| c |
					c _ self coefficients inject: self scalars one into: [:lcm :each| lcm lcm: each denominator].
					(self coefficients inject: self scalars zero into: [:gcd :each| gcd gcd: each * c]) / c]
				ifFalse: [self scalars one]].
	answer _ self scalars zero.
	self coefficients do: [:each| answer _ answer gcd: each].
	^ answer! !

!Polynomial methodsFor: 'factorization' stamp: 'len 12/21/2017 21:56:17'!
integerContent
	"Answer the integer content of the receiver.
	NOTE: the receiver is a polynomial over the rational numbers."

	| num den |
	self isZero ifTrue: [^ self].
	num _ self leadingCoefficient numerator.
	den _ self leadingCoefficient denominator.
	self coefficientsDo: [:each|
		num _ num gcd: each numerator.
		den _ den lcm: each denominator].
	^ (num / den) abs! !

!Polynomial methodsFor: 'factorization' stamp: 'len 12/6/2015 04:15'!
integerPrimitive
	"Answer the integer primitive polynomial associated to the receiver.
	Remove the integer content and the sign.
	NOTE: the receiver is a polynomial over the rational numbers."

	self isZero ifTrue: [^ self].
	^ self / (self integerContent * self sign)! !

!Polynomial methodsFor: 'factorization' stamp: 'len 5/4/2018 19:16:49'!
primitive
	"Answer the primitive part of the receiver."
	self isZero ifTrue: [^ self].
	^ self /// self content! !

!Polynomial methodsFor: 'factorization' stamp: 'len 9/25/2018 00:28:05'!
sign
	"Answer the sign of the receiver, i.e. the sign if its leading coefficient."
	^ self leadingCoefficient sign! !

!Polynomial methodsFor: 'operations' stamp: 'len 1/10/2017 16:29:46'!
dehomogenizedIn: anIndeterminate
	"Answer the dehomogenization of the receiver in the given indeterminate."
	^ self monomialsApply: [:each| each dehomogenizedIn: anIndeterminate]! !

!Polynomial methodsFor: 'operations' stamp: 'len 1/11/2017 14:26:35'!
derivative: n in: anIndeterminate
	"Answer the n-th derivative in the given indeterminate."
	| answer |
	n < 0 ifTrue: [^ self error: 'the order of the derivative should be positive'].
	answer _ self.
	n timesRepeat: [answer _ answer derivativeIn: anIndeterminate].
	^ answer! !

!Polynomial methodsFor: 'operations' stamp: 'len 12/24/2017 20:16:14'!
derivativeIn: anIndeterminate
	| answer |
	answer _ self parent zero.
	self partsDo: [:each| | degree |
		degree _ each key degreeIn: anIndeterminate.
		degree > 0
			ifTrue:
				[answer _ answer + (self parent coefficient: each value * degree monomial: (each key parent exponents: (each key exponents copy at: anIndeterminate put: degree - 1; yourself)))]].
	^ answer! !

!Polynomial methodsFor: 'operations' stamp: 'len 1/23/2017 11:41:39'!
gradient
	^ self parent indeterminates collect: [:each| self derivativeIn: each]! !

!Polynomial methodsFor: 'operations' stamp: 'len 5/2/2018 16:30:02'!
height
	self isZero ifTrue: [^ 1].
	^ self coefficients inject: 1 into: [:x :each| x max: each height]! !

!Polynomial methodsFor: 'operations' stamp: 'len 1/23/2017 11:41:49'!
hessian
	"Answer the Hessian matrix of the receiver."
	self flag: #fix. "optimize"
	^ self parent matrix: self parent rank evaluating: [:i :j| (self derivativeIn: i) derivativeIn: j]! !

!Polynomial methodsFor: 'operations' stamp: 'len 5/23/2018 22:30:27'!
homogenized
	"Answer the homogenization of the receiver introducing a new indeterminate."
	| R S |
	R _ self parent.
	S _ R scalars polynomialsIn: R rank + 1.
	^ S !! self homogenizedIn: S rank! !

!Polynomial methodsFor: 'operations' stamp: 'len 3/22/2016 23:19'!
homogenizedIn: anIndeterminate
	"Answer the homogenization of the receiver in the given indeterminate.
	Assume the indeterminate is in its species (not a new indeterminate)."
	| degree |
	degree _ self degree.
	^ self monomialsApply: [:each| each complete: degree in: anIndeterminate]! !

!Polynomial methodsFor: 'operations' stamp: 'len 5/2/2018 16:21:10'!
length
	self isZero ifTrue: [^ 0].
	^ self coefficients sum: [:each| each height]! !

!Polynomial methodsFor: 'operations' stamp: 'len 3/3/2016 01:01'!
norm
	"Answer the euclidean norm of the receiver."
	^ self norm2 squareRoot! !

!Polynomial methodsFor: 'operations' stamp: 'len 3/2/2016 23:55'!
norm1
	"Answer the 1-norm (or taxicab norm, or Manhattan norm) of the receiver."
	^ self coefficients inject: self scalars zero into: [:x :each| x + each abs]! !

!Polynomial methodsFor: 'operations' stamp: 'len 3/2/2016 23:49'!
norm2
	"Answer the squared norm of the receiver."
	^ self coefficients inject: self scalars zero into: [:x :each| x + each squared]! !

!Polynomial methodsFor: 'operations' stamp: 'len 3/2/2016 23:54'!
normInfinite
	"Answer the infinite norm of the receiver.
	(In finite-dimensional vector spaces it's the same as the maximum norm)."
	^ self normMax! !

!Polynomial methodsFor: 'operations' stamp: 'len 3/2/2016 23:52'!
normMax
	"Answer the maximum norm of the receiver."
	^ self coefficients inject: self scalars zero into: [:x :each| x max: each abs]! !

!Polynomial methodsFor: 'operations' stamp: 'len 2/8/2017 07:58:32'!
permutedBy: aPermutation
	"Permute the variables of the receiver. The argument can be an Array (a permutation in 'image format'). For example given a polynomial in x,z,y, #(1 2 3) doesn't change anything, and #(2 1 3) exchanges variables x and y."
	^ self monomialsApply: [:each| each permutedBy: aPermutation]! !

!Polynomial methodsFor: 'operations' stamp: 'len 2/12/2017 12:26:39'!
s: aPolynomial
	"Answer the S-polynomial of the receiver with the argument."
	| h1 h2 lcm |
	h1 _ self leadingMonomial.
	h2 _ aPolynomial leadingMonomial.
	lcm _ h1 lcm: h2.
	^ self * (lcm / h1) / self leadingCoefficient - (aPolynomial * (lcm / h2) / aPolynomial leadingCoefficient)! !

!Polynomial methodsFor: 'operations' stamp: 'len 2/6/2017 03:06:13'!
squareFree
	"Answer the maximal squarefree divisor of the receiver."
	| g |
	self parent scalars characteristic = 0 ifFalse: [^ DomainError signal: 'field must include Q (i.e., must be of characteristic 0)'].
	g _ self.
	self indeterminates do: [:each| g _ g gcd: (self derivativeIn: each)].
	^ self /// g! !

!Polynomial methodsFor: 'operations' stamp: 'len 2/9/2017 03:18:14'!
substitute: aBlock
	"Answer the receiver after substituting indeterminates by aBlock."
	^ self monomialsApply: [:each| each substitute: aBlock]! !

!Polynomial methodsFor: 'operations' stamp: 'len 1/28/2018 18:24:48'!
value: anObject
	"Answer the value of the receiver at the argument. For multivariate polynomials, a Tuple or Array is expected."
	| answer one |
"	((anObject is: #Tuple) or: [anObject is: #Array])
		ifFalse: [^ self error: 'argument should be tuple or array']."
	anObject size = self parent rank
		ifFalse: [self error: 'the arity of the argument should match the number of indeterminates'].
	answer _ (anObject at: 1) zero.
	one _ answer one.
	self partsDo: [:each|
		| monomial |
		monomial _ each key.
		answer _ (monomial isIdentity ifTrue: [one * each value] ifFalse: [(monomial value: anObject) * each value]) + answer].
	^ answer! !

!Polynomial methodsFor: 'operations' stamp: 'len 11/1/2016 18:40'!
valueWithArguments: anArray
	^ self value: anArray! !

!Polynomial methodsFor: 'printing' stamp: 'len 1/23/2017 11:42:38'!
isBroken
	self monomials do: [:each|
		each indeterminates do: [:i| (self parent has: i) ifFalse: [^ true]].
		each exponents size = self parent rank ifFalse: [^ true]].
	^ self coefficients anySatisfy: [:any| (self parent scalars includes: any) not]! !

!Polynomial methodsFor: 'printing' stamp: 'len 2/25/2017 09:40:48'!
printCoefficient: coefficient on: aStream
	| c |
	((c _ coefficient) printString first = $- "or: [coefficient isNumber and: [coefficient negative]]")
		ifTrue: [aStream nextPut: $-. c _ c negated].
	((c isKindOf: Polynomial) and: [c isMonomial])
		ifTrue: [aStream print: c. ^ self].
	(c printString allSatisfy: [:each| each isAlphaNumeric or: ['{}()/' includes: each]])
		ifTrue: [aStream print: c. ^ self].
	aStream nextPut: $(; print: c; nextPut: $)! !

!Polynomial methodsFor: 'printing' stamp: 'len 5/30/2019 16:14:38'!
printText
	self isBroken ifTrue: [^ super printText addAttribute: TextColor red].
	^ super printText! !

!Polynomial methodsFor: 'remainder sequences' stamp: 'len 3/9/2016 00:07'!
eprs: aPolynomial
	"Answer the (Pseudo) Euclidean Polynomial Remainder Sequence of the receiver with the argument."
	| answer f0 f1 r |
	answer _ OrderedCollection new.
	f1 _ self.
	answer add: f1.
	r _ aPolynomial.
	[r isZero]
		whileFalse:
			[answer add: r.
			f0 _ f1.
			f1 _ r.
			r _ f0 pseudoRem: f1].
	^ answer! !

!Polynomial methodsFor: 'remainder sequences' stamp: 'len 3/9/2016 00:07'!
pprs: aPolynomial
	"Answer the Primitive Polynomial Remainder Sequence of the receiver with the argument."
	| answer f0 f1 r |
	answer _ OrderedCollection new.
	f1 _ self.
	answer add: f1.
	r _ aPolynomial.
	[r isZero]
		whileFalse:
			[answer add: r.
			f0 _ f1.
			f1 _ r.
			r _ (f0 pseudoRem: f1) primitive].
	^ answer! !

!Polynomial methodsFor: 'remainder sequences' stamp: 'len 1/23/2017 11:43:25'!
prs: aPolynomial
	"Answer the Polynomial Remainder Sequence of the receiver with the argument."
	| answer f0 f1 r |
	self parent scalars isField ifFalse: [^ DomainError signal: 'scalars are not a field'].
	answer _ OrderedCollection new.
	f1 _ self.
	answer add: f1.
	r _ aPolynomial.
	[r isZero]
		whileFalse:
			[answer add: r.
			f0 _ f1.
			f1 _ r.
			r _ f0 \\ f1].
	^ answer! !

!Polynomial methodsFor: 'remainder sequences' stamp: 'len 3/9/2016 06:32'!
sprs2: aPolynomial
	"Answer the Subresultant Polynomial Remainder Sequence of the receiver with the argument."
	| delta b phi beta f1 f2 r answer |
	self assert: self scalars isUFD.
	self assert: self degree >= aPolynomial degree.
	delta _ self degree - aPolynomial degree + 1.
	b _ aPolynomial leadingCoefficient.
	phi _ b ^ (delta - 1).
	beta _ (-1) ^ delta.
	answer _ OrderedCollection new.
	answer add: self; add: aPolynomial.
	f1 _ aPolynomial. f2 _ self. "f1 is F_{i-1}, f2 is F_{i-2}, r is F_i"
	[r _ (f2 pseudoRem: f1) / beta.
	r isZero ifTrue: [^ answer].
	answer add: r. f2 _ f1. f1 _ r.
	delta _ f1 degree - r degree + 1.
	beta _ (-1) ^ delta * (phi ^ (delta - 1)) * b.
	b _ r leadingCoefficient.
	phi _ phi * ((b / phi) ^ (delta - 1))] repeat! !

!Polynomial methodsFor: 'remainder sequences' stamp: 'len 5/18/2018 20:52:31'!
sprs: aPolynomial
	"Answer the Subresultant Polynomial Remainder Sequence of the receiver with the argument."
	| delta phi beta f1 f2 r answer |
	self assert: self scalars isUFD.
	self assert: self degree >= aPolynomial degree.
	f2 _ self. f1 _ aPolynomial."f1 is F_{i-1}, f2 is F_{i-2}, r is F_i"
	phi _ self scalars one.
	answer _ OrderedCollection new.
	answer add: f2.
	[f1 isZero]
		whileFalse:
			[answer add: f1.
			delta _ f2 degree - f1 degree + 1.
			beta _ (-1) ^ delta * (phi ^ (delta - 1)) * f2 leadingCoefficient.
			phi _ phi * ((f1 leadingCoefficient / phi) ^ (delta - 1)).
			r _ (f2 pseudoRem: f1) /// beta.
			f2 _ f1. f1 _ r].
	^ answer! !

!Polynomial methodsFor: 'testing' stamp: 'len 12/27/2015 02:44'!
| aPolynomial
	"Answer true if the receiver divides aPolynomial."
	self scalars isField ifTrue: [^ (aPolynomial \\ self) isZero].
	^ (aPolynomial pseudoRem: self) isZero! !

!Polynomial methodsFor: 'testing' stamp: 'len 11/26/2015 01:41'!
is: aSymbol
	^ aSymbol == #Polynomial or: [super is: aSymbol]! !

!Polynomial methodsFor: 'testing' stamp: 'len 12/30/2016 20:10:56'!
isAffineLinear
	^ self degree < 2! !

!Polynomial methodsFor: 'testing' stamp: 'len 5/15/2019 06:45:14'!
isBasicIrreducible
	(self scalars isKindOf: PrimePowerRing) ifFalse: [DomainError signal].
	^ (self apply: self scalars -> self scalars primeSubfield) isIrreducible! !

!Polynomial methodsFor: 'testing' stamp: 'len 2/17/2017 08:07:02'!
isBinomial
	^ self monomials size = 2! !

!Polynomial methodsFor: 'testing' stamp: 'len 11/11/2015 03:24'!
isConstant
	^ self degree < 1! !

!Polynomial methodsFor: 'testing' stamp: 'len 3/1/2016 17:33'!
isHomogeneous
	| n |
	n _ self degree.
	self monomials do: [ :each | each degree = n ifFalse: [^ false]].
	^ true! !

!Polynomial methodsFor: 'testing' stamp: 'len 4/24/2018 15:33:32'!
isIrreducible
	self isConstant ifTrue: [^ false]. "constant polynomials are not reducible nor irreducible"
	self degree = 1 ifTrue: [^ true].
	^ self factors size = 1! !

!Polynomial methodsFor: 'testing' stamp: 'len 12/30/2016 20:11:59'!
isLinear
	^ self degree < 2 and: [self independentCoefficient isZero]! !

!Polynomial methodsFor: 'testing' stamp: 'len 11/25/2015 23:26'!
isMonic
	^ self leadingCoefficient = self scalars one! !

!Polynomial methodsFor: 'testing' stamp: 'len 2/17/2017 08:07:17'!
isMonomial
	^ self monomials size = 1! !

!Polynomial methodsFor: 'testing' stamp: 'len 3/9/2016 02:55'!
isPrimitive
	"A polynomial is primitive if it has content unity."
	^ self content = self scalars one! !

!Polynomial methodsFor: 'testing' stamp: 'len 1/10/2016 23:22'!
isSeparable
	"A polynomial over a field K is separable if it's roots are distinct in an algebraic closure of K."
	^ (self gcd: self derivative) isConstant! !

!Polynomial methodsFor: 'testing' stamp: 'len 2/18/2017 20:33:52'!
isSquareFree
	self isMonomial ifTrue: [^ self monomials anyOne isSquareFree].
	^ self isZero not and: [(self gcd: self derivative) isConstant]! !

!Polynomial methodsFor: 'testing' stamp: 'len 1/23/2017 11:42:42'!
isUnivariate
	^ self parent isUnivariate! !

!Polynomial methodsFor: 'testing' stamp: 'len 1/23/2017 11:42:50'!
isUnivariateIn: anInteger
	"Answer true if the receiver is an univariate polynomial in the anInteger-th indeterminate."
	(anInteger = 1 and: [self parent isUnivariate]) ifTrue: [^ true].
	self monomialsDo: [:each| (each isUnivariateIn: anInteger) ifFalse: [^ false]].
	^ true! !

!Polynomial methodsFor: 'private' stamp: 'len 10/6/2016 15:35'!
parent: aPolynomialRing
	parent _ aPolynomialRing! !

!Polynomial class methodsFor: 'instance creation' stamp: 'len 2/6/2017 05:43:55'!
new
	^ self shouldNotImplement! !

!MultivariatePolynomial methodsFor: 'accessing' stamp: 'len 12/22/2017 17:51:19'!
bitSize
	self isZero ifTrue: [^ 0].
	^ parts sum: [:each| each key bitSize + each value bitSize]! !

!MultivariatePolynomial methodsFor: 'accessing-coefficients' stamp: 'len 12/21/2017 17:44:27'!
at: aMonomial
	^ self at: aMonomial ifAbsent: [self scalars zero]! !

!MultivariatePolynomial methodsFor: 'accessing-coefficients' stamp: 'len 12/22/2017 17:48:48'!
leadingCoefficient
	^ parts isEmpty ifTrue: [self scalars zero] ifFalse: [parts last value]
	"^ self isZero ifTrue: [self scalars zero] ifFalse: [self at: self leadingMonomial]"! !

!MultivariatePolynomial methodsFor: 'accessing-monomials' stamp: 'len 12/22/2017 17:51:10'!
leadingMonomial
	^ parts isEmpty ifFalse: [parts last key]
"
	| answer |
	self monomialsDo: [:each| (answer isNil or: [each > answer]) ifTrue: [answer _ each]].
	^ answer"! !

!MultivariatePolynomial methodsFor: 'accessing-terms' stamp: 'len 5/9/2018 15:41:18'!
leadingTerm
	"Answer the first term of the receiver."

	| leadingPart |
	self isZero ifTrue: [^ self].
	leadingPart _ parts last.
	^ self parent coefficient: leadingPart value monomial: leadingPart key! !

!MultivariatePolynomial methodsFor: 'arithmetic' stamp: 'len 4/6/2018 23:50:16'!
+ anObject
	(self parent includes: anObject)
		ifTrue: [^ self addedWithPolynomial: anObject].
	((self scalars includes: anObject) or: [anObject isInteger])
		ifTrue: [^ self + (self one * anObject)].
	(anObject isKindOf: RationalFunction)
		ifTrue: [^ anObject + self].
	^ DomainError signal! !

!MultivariatePolynomial methodsFor: 'arithmetic' stamp: 'len 4/24/2018 00:51:39'!
exactlyDividedBy: aPolynomial
	"Answer the exact division of the receiver by the argument."
	self isZero ifTrue: [^ self].
	aPolynomial isConstant ifTrue: [^ self dividedByScalar: aPolynomial leadingCoefficient].
	^ (MultivariatePolynomialDivision divide: self by: {aPolynomial}) exactQuotient! !

!MultivariatePolynomial methodsFor: 'arithmetic' stamp: 'len 12/22/2017 17:47:14'!
negated
	"Answer the additive inverse of the receiver."
	^ parent parts: (parts collect: [:each| each key -> each value negated])! !

!MultivariatePolynomial methodsFor: 'comparing' stamp: 'len 12/22/2017 17:51:27'!
= aPolynomial
	self == aPolynomial ifTrue: [^ true].
	aPolynomial class = self class ifTrue: [^ parts = aPolynomial parts].
	^ super = aPolynomial! !

!MultivariatePolynomial methodsFor: 'comparing' stamp: 'len 12/22/2017 17:51:38'!
hash
	^ parts hash! !

!MultivariatePolynomial methodsFor: 'converting' stamp: 'len 12/22/2017 19:06:16'!
over: aRing
	| newParts |
	self scalars = aRing ifTrue: [^ self].
	newParts _ OrderedCollection new: parts size.
	parts do: [:each| | newValue |
		(newValue _ aRing !! each value) isZero
			ifFalse: [newParts add: (each copy value: newValue)]].
	^ (self parent over: aRing) parts: newParts! !

!MultivariatePolynomial methodsFor: 'copying' stamp: 'len 12/22/2017 17:50:59'!
copy
	^ parent parts: (parts collect: [:each| each copy])! !

!MultivariatePolynomial methodsFor: 'deprecated' stamp: 'len 12/21/2017 18:17:42'!
coefficientAt: aMonomial
	"Answer the coefficient of the monomial given by the argument."
	^ self at: aMonomial! !

!MultivariatePolynomial methodsFor: 'deprecated' stamp: 'len 12/21/2017 18:19:15'!
coefficientAt: aMonomial put: value
	^ self at: aMonomial put: value! !

!MultivariatePolynomial methodsFor: 'enumerating' stamp: 'len 12/22/2017 17:51:42'!
coefficientsDo: aBlock
	parts do: [:each| aBlock value: each value]! !

!MultivariatePolynomial methodsFor: 'enumerating' stamp: 'len 12/24/2017 20:32:45'!
monomialsApply: aBlock
	| dictionary newParts |
	dictionary _ Dictionary new: parts size.
	parts do: [:each|
		dictionary at: (aBlock value: each key) add: each value].
	newParts _ OrderedCollection new: dictionary size.
	newParts resetTo: 1.
	dictionary associationsDo: [:each| each value isZero ifFalse: [newParts add: each]].
	newParts sort.
	^ self parent parts: newParts! !

!MultivariatePolynomial methodsFor: 'enumerating' stamp: 'len 12/22/2017 17:49:12'!
monomialsDo: aBlock
	"Iterate over the support of the receiver, i.e. the monomials with non-zero coefficient."
	parts do: [:each| aBlock value: each key]! !

!MultivariatePolynomial methodsFor: 'enumerating' stamp: 'len 12/24/2017 20:10:01'!
partsDo: aBlock
	parts do: aBlock! !

!MultivariatePolynomial methodsFor: 'operations' stamp: 'len 12/22/2017 17:50:37'!
apply: aMorphism
	"Answer a new polynomial with coefficients obtainted by applying aMorphism to the coefficients of the receiver. This morphism is a ring homomorphism from the scalars ring.
	If aMorphism is a block we assume the parent doesn't change, i.e. the block must evaluate to values within the scalars ring of the receiver."

	| newAssociations |
	newAssociations _ OrderedCollection new: parts size.
	parts do: [:each| | newValue |
		(newValue _ aMorphism value: each value) isZero
			ifFalse: [newAssociations add: (each copy value: newValue)]].
	^ (aMorphism isBlock ifTrue: [parent] ifFalse: [parent over: aMorphism codomain]) parts: newAssociations! !

!MultivariatePolynomial methodsFor: 'testing' stamp: 'len 12/22/2017 17:49:16'!
isZero
	^ parts isEmpty! !

!MultivariatePolynomial methodsFor: 'private' stamp: 'len 12/24/2017 19:51:06'!
addedWithPolynomial: aPolynomial
	| newAssociations |
	newAssociations _ OrderedCollection new: parts size + aPolynomial parts size.
	newAssociations resetTo: 1.
	self sum: parts with: aPolynomial parts into: newAssociations.
	^ parent parts: newAssociations! !

!MultivariatePolynomial methodsFor: 'private' stamp: 'len 12/22/2017 17:47:53'!
at: aMonomial add: aNumber
	parts isEmpty ifTrue: [aNumber isZero ifFalse: [parts add: aMonomial -> aNumber]. ^ self].
	parts
		findBinaryIndex: [:each| (each key compare: aMonomial) negated]
		do: [:index| | association newValue |
			association _ parts at: index.
			(newValue _ association value + aNumber) isZero
				ifTrue: [parts removeIndex: index]
				ifFalse: [association value: newValue "associations at: index put: aMonomial -> newValue"]]
		ifNone: [:low :high| aNumber isZero ifFalse: [parts add: aMonomial -> aNumber beforeIndex: high]]! !

!MultivariatePolynomial methodsFor: 'private' stamp: 'len 12/22/2017 17:51:33'!
at: aMonomial ifAbsent: exceptionBlock
	^ parts findBinary: [:each| (each key compare: aMonomial) negated] do: [:each| each value] ifNone: [:high :low| exceptionBlock value]! !

!MultivariatePolynomial methodsFor: 'private' stamp: 'len 12/21/2017 17:44:14'!
at: key ifPresent: presentBlock
	"Lookup the given key in the receiver. If it is present, answer the value of evaluating the given block with the value associated with the key. Otherwise, answer nil."

	| v |
	v _ self at: key ifAbsent: [ ^ nil ].
	^ presentBlock value: v! !

!MultivariatePolynomial methodsFor: 'private' stamp: 'len 12/22/2017 17:49:08'!
at: aMonomial put: aNumber
	parts isEmpty ifTrue: [aNumber isZero ifFalse: [parts add: aMonomial -> aNumber]. ^ self].
	parts
		findBinaryIndex: [:each| (each key compare: aMonomial) negated]
		do: [:index| aNumber isZero ifTrue: [parts removeIndex: index] ifFalse: [(parts at: index) value: aNumber]]
		ifNone: [:low :high| aNumber isZero ifFalse: [parts add: aMonomial -> aNumber beforeIndex: high]].
	^ aNumber! !

!MultivariatePolynomial methodsFor: 'private' stamp: 'len 12/22/2017 17:48:20'!
dividedByMonomial: aMonomial
	"The monomial ordering is preserved by this operation."
	^ parent parts: (parts collect: [:each| each key / aMonomial -> each value])! !

!MultivariatePolynomial methodsFor: 'private' stamp: 'len 5/9/2018 16:36:16'!
dividedByScalar: aNumber
	^ parent parts: (parts collect: [:each| each copy value: each value / aNumber])! !

!MultivariatePolynomial methodsFor: 'private' stamp: 'len 12/22/2017 17:46:56'!
multipliedByMonomial: aMonomial
	"The monomial ordering is preserved by this operation."
	^ parent parts: (parts collect: [:each| each key * aMonomial -> each value])! !

!MultivariatePolynomial methodsFor: 'private' stamp: 'len 12/24/2017 20:01:32'!
multipliedByPolynomial: aPolynomial
	| dictionary newAssociations |
	dictionary _ Dictionary new: parts size + aPolynomial parts size.
	parts do: [:each|
		aPolynomial parts do: [:other|
			dictionary at: each key * other key add: each value * other value]].
	newAssociations _ OrderedCollection new: dictionary size.
	newAssociations resetTo: 1.
	dictionary associationsDo: [:each| each value isZero ifFalse: [newAssociations add: each]].
	newAssociations sort.
	^ self parent parts: newAssociations! !

!MultivariatePolynomial methodsFor: 'private' stamp: 'len 5/9/2018 16:35:03'!
multipliedByScalar: aNumber
	| newAssociations |
	aNumber isZero ifTrue: [^ parent zero].
"	parent scalars isIntegralDomain ifTrue: [^ parent parts: (parts collect: [:each| each copy value: each value * aNumber])]."
	newAssociations _ OrderedCollection new: parts size.
	newAssociations resetTo: 1.
	parts do: [:each| | newValue |
		(newValue _ each value * aNumber) isZero
			ifFalse: [newAssociations add: (each copy value: newValue)]].
	^ parent parts: newAssociations! !

!MultivariatePolynomial methodsFor: 'private' stamp: 'len 12/22/2017 17:52:34'!
parts
	^ parts! !

!MultivariatePolynomial methodsFor: 'private' stamp: 'len 12/22/2017 17:52:46'!
parts: aCollection
	parts _ aCollection! !

!MultivariatePolynomial methodsFor: 'private' stamp: 'len 12/21/2017 18:38:44'!
sum: someAssociations with: otherAssociations into: newAssociations
	| stream1 stream2 |
	stream1 _ someAssociations readStream.
	stream2 _ otherAssociations readStream.
	[stream1 atEnd or: [stream2 atEnd]]
		whileFalse:
			[| cmp |
			cmp _ stream1 peek key compare: stream2 peek key.
			cmp < 0
				ifTrue: [newAssociations add: stream1 next copy]
				ifFalse: [cmp > 0
					ifTrue: [newAssociations add: stream2 next copy]
					ifFalse:
						[| a b newValue |
						a _ stream1 next.
						b _ stream2 next.
						(newValue _ a value + b value) isZero
							ifFalse: [newAssociations add: (a copy value: newValue)]]]].
	[stream1 atEnd] whileFalse: [newAssociations add: stream1 next copy].
	[stream2 atEnd] whileFalse: [newAssociations add: stream2 next copy].
	^ newAssociations! !

!MultivariatePolynomial class methodsFor: 'instance creation' stamp: 'len 12/22/2017 18:22:36'!
parts: aCollection
	^ self basicNew parts: aCollection! !

!UnivariatePolynomial methodsFor: 'accessing' stamp: 'len 12/21/2017 18:20:42'!
bitSize
	^ self coefficients bitSize! !

!UnivariatePolynomial methodsFor: 'accessing' stamp: 'len 12/21/2017 18:26:42'!
coefficients
	^ coefficients! !

!UnivariatePolynomial methodsFor: 'accessing' stamp: 'len 4/23/2018 21:03:45'!
lift
	"If the coefficients ring is a quotient R/I, nswer a representative of the receiver over R. See >>%."
	^ (parent over: parent scalars base) coefficients: coefficients lift! !

!UnivariatePolynomial methodsFor: 'accessing' stamp: 'len 4/23/2018 21:03:56'!
representative
	"If the coefficients ring is a quotient R/I, nswer a representative of the receiver over R. See >>%."
	^ (parent over: parent scalars base) coefficients: coefficients representative! !

!UnivariatePolynomial methodsFor: 'accessing-coefficients' stamp: 'len 12/22/2017 17:55:54'!
at: aMonomial
	^ self atDegree: aMonomial degree! !

!UnivariatePolynomial methodsFor: 'accessing-coefficients' stamp: 'len 12/22/2017 17:55:35'!
atDegree: i
	^ coefficients at: i+1 ifAbsent: [self scalars zero]! !

!UnivariatePolynomial methodsFor: 'accessing-coefficients' stamp: 'len 3/24/2016 03:50'!
degree
	coefficients isEmpty ifTrue: [^ Infinity negative].
	^ coefficients size - 1! !

!UnivariatePolynomial methodsFor: 'accessing-coefficients' stamp: 'len 3/23/2016 00:01'!
independentCoefficient
	^ self coefficientAtDegree: 0! !

!UnivariatePolynomial methodsFor: 'accessing-coefficients' stamp: 'len 3/23/2016 00:01'!
leadingCoefficient
	^ self coefficientAtDegree: self degree! !

!UnivariatePolynomial methodsFor: 'accessing-monomials' stamp: 'len 2/6/2017 05:53:46'!
leadingMonomial
	| answer |
	self monomialsDo: [:each| (answer isNil or: [each > answer]) ifTrue: [answer _ each]].
	^ answer

"this could be faster, but it fails with local orderings for example:
	^ self isZero ifFalse: [self parent monomials x: self parent indeterminate to: self degree]
"! !

!UnivariatePolynomial methodsFor: 'arithmetic' stamp: 'len 4/22/2018 18:03:37'!
% anInteger
	^ (self parent over: self scalars % anInteger) coefficients: self coefficients % anInteger! !

!UnivariatePolynomial methodsFor: 'arithmetic' stamp: 'len 4/6/2018 23:49:45'!
+ anObject
	(self parent includes: anObject)
		ifTrue: [^ self parent coefficients: self coefficients + anObject coefficients].
	((self scalars includes: anObject) or: [anObject isInteger])
		ifTrue: [^ self + (self one * anObject)].
	(anObject isKindOf: RationalFunction)
		ifTrue: [^ anObject + self].
	^ DomainError signal! !

!UnivariatePolynomial methodsFor: 'arithmetic' stamp: 'len 4/6/2018 23:51:14'!
- anObject
	(self parent includes: anObject)
		ifTrue: [^ self parent coefficients: self coefficients - anObject coefficients].
	^ super - anObject! !

!UnivariatePolynomial methodsFor: 'arithmetic' stamp: 'len 4/24/2018 19:38:45'!
// anObject
	"Answer the quotient of the division of the receiver by the argument."

	(self scalars includes: anObject)
		ifTrue: [^ self parent coefficients: self coefficients // anObject].
	^ (self divisionBy: anObject) quotient! !

!UnivariatePolynomial methodsFor: 'arithmetic' stamp: 'len 12/22/2017 18:31:05'!
/// anObject
	"Answer the exact quotient of the division of the receiver by the argument."
	(anObject isKindOf: Monomial)
		ifTrue: [^ self dividedByMonomial: anObject].
	(self scalars includes: anObject)
		ifTrue: [^ self parent coefficients: self coefficients /// anObject].
	^ self exactlyDividedBy: anObject! !

!UnivariatePolynomial methodsFor: 'arithmetic' stamp: 'len 5/26/2018 17:40:00'!
\\ anObject
	"Answer the remainder of the division of the receiver by the argument."

	(self scalars includes: anObject)
		ifTrue: [^ self parent coefficients: self coefficients \\ anObject].
	^ self parent coefficients: (self coefficients polynomialDivisionBy: anObject coefficients) last
	"^ (self divisionBy: anObject) remainder"! !

!UnivariatePolynomial methodsFor: 'arithmetic' stamp: 'len 12/21/2017 22:03:21'!
negated
	"Answer the additive inverse of the receiver."
	^ self parent coefficients: self coefficients negated! !

!UnivariatePolynomial methodsFor: 'arithmetic' stamp: 'len 6/5/2019 17:09:29'!
reciprocal
	^ super reciprocal

	"If not over a field, compute the inverse of the receoiver, provided the receiver is a unit."
"
	don't know when to finish, this is actually the power series expansion and if the independent coefficient is a unit and the other coefficients are all nilpotents this process is finite, but don't know when to end it..
	| a b u |
	self scalars isField ifTrue: [^ super reciprocal].
	a _ coefficients.
	a isEmpty ifTrue: [(ZeroDivide dividend: self one) signal].
	u _ a first reciprocal.
	b _ OrderedCollection new: self degree.
	b add: u.
	2 to: a size do: [:k| b add: ((1 to: k-1) sum: [:i| (b at: k-i) * (a at: i+1)]) negated * u].
	^ self parent coefficients: b"! !

!UnivariatePolynomial methodsFor: 'comparing' stamp: 'len 7/9/2016 03:00'!
= anObject
	(anObject isKindOf: UnivariatePolynomial) ifFalse: [^ false].
	^ self coefficients = anObject coefficients
"	self degree = anObject degree ifFalse: [^ false].
	0 to: self degree do: [:i| (self coefficientAtDegree: i) = (anObject coefficientAtDegree: i) ifFalse: [^ false]].
	^ true"! !

!UnivariatePolynomial methodsFor: 'comparing' stamp: 'len 4/11/2016 05:13'!
hash
	| answer |
	self isZero ifTrue: [^ 0].
	answer _ self degree.
	0 to: self degree do: [:i| answer _ answer + (self coefficientAtDegree: i) hash].
	^ answer! !

!UnivariatePolynomial methodsFor: 'converting' stamp: 'len 12/21/2017 21:52:44'!
over: aRing
	^ (self parent over: aRing) coefficients: (self coefficients over: aRing)! !

!UnivariatePolynomial methodsFor: 'copying' stamp: 'len 12/21/2017 22:06:33'!
copy
	^ self parent coefficients: self coefficients copy! !

!UnivariatePolynomial methodsFor: 'deprecated' stamp: 'len 3/23/2016 04:08'!
coefficientAt: aMonomial
	^ self coefficientAtDegree: aMonomial degree! !

!UnivariatePolynomial methodsFor: 'deprecated' stamp: 'len 3/26/2016 23:44'!
coefficientAt: aMonomial put: value
	coefficients at: aMonomial degree + 1 put: value.
	(value isZero and: [aMonomial degree + 1 = coefficients size])
		ifTrue: [self normalize].
	^ value! !

!UnivariatePolynomial methodsFor: 'deprecated' stamp: 'len 3/22/2016 23:57'!
coefficientAtDegree: i
	^ coefficients at: i+1 ifAbsent: [self scalars zero]! !

!UnivariatePolynomial methodsFor: 'enumerating' stamp: 'len 12/21/2017 21:51:15'!
coefficientsDo: aBlock
	self coefficients do: aBlock! !

!UnivariatePolynomial methodsFor: 'enumerating' stamp: 'len 5/15/2019 01:52:21'!
monomialsApply: aBlock
	| monomials n newCoefficients |
	monomials _ (1 to: coefficients size) collect: [:i|
		(aBlock value: (self parent monomials x: 1 to: i-1)) -> (coefficients at: i)].
	n _ monomials max: [:each| each key degree].
	newCoefficients _ (Array new: n+1) atAllPut: self scalars zero.
	monomials do: [:each| newCoefficients at: each key degree + 1 add: each value].
	^ self parent coefficients: newCoefficients ! !

!UnivariatePolynomial methodsFor: 'enumerating' stamp: 'len 4/22/2019 04:04:20'!
monomialsDo: aBlock
	"Iterate over the support of the receiver, i.e. the monomials with non-zero coefficient."
	1 to: coefficients size do: [:i|
		(coefficients at: i) isZero
			ifFalse: [aBlock value: (self parent monomials x: 1 to: i-1)]]! !

!UnivariatePolynomial methodsFor: 'enumerating' stamp: 'len 4/22/2019 04:04:31'!
partsDo: aBlock
	coefficients withIndexDo: [:value :index| value isZero ifFalse: [aBlock value: (self parent monomials x: 1 to: index-1) -> value]]! !

!UnivariatePolynomial methodsFor: 'factorization' stamp: 'len 5/26/2018 16:35:31'!
distinctDegreeFactorization
	"Answer the distinct-degree factorization of a monic square-free polynomial over a finite field.
	The factorizations is a Dictionary d -> g, where g is the product of all irreducible factors of degree d."
	| answer i f f2 one q x R h |
	answer _ Dictionary new.
	f _ self.
	R _ f parent.
	x _ R x.
	one _ R one.
	q _ R scalars size.
	i _ 1.
	f2 _ f.
	h _ x.
	[f2 degree >= (2*i)]
		whileTrue:
			[ | g | g _ f2 gcd: (h _ h raisedTo: q modulo: f2) - x.
			g ~= one ifTrue: [answer at: i put: g. f2 _ f2 // g].
			i _ i + 1].
	f2 ~= one ifTrue: [answer at: f2 degree put: f2].
	answer isEmpty ifTrue: [answer at: 1 put: f].
	^ answer! !

!UnivariatePolynomial methodsFor: 'factorization' stamp: 'len 5/24/2019 11:10:35'!
equalDegreeFactorization: d
	"Cantor-Zassenhaus algorithm. Answer the equal-degree factorization of a monic squarefree univariate polynomial which has r>=2 pairwise distinct irreducible factors each of degree d."
	| f r q h g one factors c |
	f _ self.
	q _ f scalars size.
	q odd ifFalse: [^ self equalDegreeFactorization2: d].
	r _ f degree / d.
	one _ f parent one.
	factors _ OrderedCollection with: f.
	[factors size < r]
		whileTrue:
			[[h _ (f parent atRandomMaxDegree: 2*d-1). "should be monic? should: d <= deg(h) <= 2d-1"
			h isZero] whileTrue. "ensure it's not 0"
			h _ h monic.
			g _ (h raisedTo: q^d - 1 / 2 modulo: f) - one. "<- most time is spent here"
			factors do: [:u|
				u degree > d
					ifTrue:
						[c _ g gcd: u.
						(c ~= one and: [c ~= u])
							ifTrue: "found non-trivial common factor c"
								[factors _ factors copyWithout: u.
								factors add: c; add: u // c]]]].
	^ factors! !

!UnivariatePolynomial methodsFor: 'factorization' stamp: 'len 9/22/2018 19:00:50'!
factors
	self scalars isGaloisField
		ifTrue: [^ self factorizationFiniteField].
	(self scalars isKindOf: RationalIntegerRing)
		ifTrue: [^ self factorizationIntegers].
	(self scalars isKindOf: RationalField)
		ifTrue: [^ (self integerPrimitive over: ZZ) factorizationIntegers apply: [:each| self parent !! each]].
	^ self notYetImplemented! !

!UnivariatePolynomial methodsFor: 'factorization' stamp: 'len 9/22/2018 19:00:45'!
squareFreeFactorization
	"Answer a square-free factorization of the receiver."
	self scalars isGaloisField
		ifTrue: [^ self squareFreeFactorizationFiniteField].
	self scalars characteristic > 0 "finite ring"
		ifTrue: [^ self notYetImplemented].
	self scalars isField
		ifTrue: [^ self squareFreeFactorizationYun].
	self scalars isUFD
		ifFalse: [^ self notYetImplemented].
	^ (self primitive over: self scalars fractions) squareFreeFactorizationYun apply: [:each| self parent !! each primitive]! !

!UnivariatePolynomial methodsFor: 'factorization-private' stamp: 'len 4/16/2018 20:24:33'!
equalDegreeFactorization2: d
	"Cantor-Zassenhaus algorithm. Answer the equal-degree factorization of a monic squarefree univariate polynomial which has r>=2 pairwise distinct irreducible factors each of degree d."
	| f r h g one factors c |
	f _ self.
"	q _ f parent scalars size.
	q even ifFalse: [^ self error: 'order not even']."
	r _ f degree / d.
	one _ f parent one.
	factors _ OrderedCollection with: f.
	h _ f parent x.
	[factors size < r]
		whileTrue:
			[g _ h.
			d - 1 timesRepeat: [g _ h + g squared \\ f].
			factors do: [:u|
				u degree > d
					ifTrue:
						[c _ g gcd: u.
						(c ~= one and: [c ~= u])
							ifTrue:
								[factors _ factors copyWithout: u.
								factors add: c; add: u // c]]].
			h _ h << 2].
	^ factors! !

!UnivariatePolynomial methodsFor: 'factorization-private' stamp: 'len 4/25/2018 16:52:42'!
factorizationFiniteField
	| answer |
	answer _ Bag new.
	self squareFreeFactorizationFiniteField withOccurrencesDo: [:f :r|
		f distinctDegreeFactorization keysAndValuesDo: [:d :g|
			(g equalDegreeFactorization: d) do: [:each| answer add: each withOccurrences: r]]].
	^ answer! !

!UnivariatePolynomial methodsFor: 'factorization-private' stamp: 'len 4/25/2018 16:53:37'!
factorizationIntegers
	| answer content |
	answer _ Bag new.
	(content _ self content) factorizationDo: [:p :e| answer add: (self parent constant: p) withOccurrences: e].
	(self / (content * self sign)) squareFreeFactorization withOccurrencesDo: [:f :r|
		f factorizationZassenhauss do: [:each| answer add: each withOccurrences: r]].
	^ answer! !

!UnivariatePolynomial methodsFor: 'factorization-private' stamp: 'len 4/25/2018 16:48:20'!
factorizationIntegers2
	| answer f g |
	answer _ Bag new.
	self content factorizationDo: [:p :e| answer add: (self parent constant: p) withOccurrences: e].
	g _ self gcd: self derivative.
	f _ self /// g.
	"TODO: if the receiver is not square-free, we're missing powers of factors"
	(f / (f content * f sign)) factorizationZassenhauss
		withOccurrencesDo: [:each :k|
			answer add: each withOccurrences: k].
	^ answer! !

!UnivariatePolynomial methodsFor: 'factorization-private' stamp: 'len 4/30/2018 05:50:34'!
factorizationZassenhauss
	"Zassenhauss algorithm. Answer the irreducible factors of a square-free primitive polynomial with integer coefficients."
	| f n A b B C gamma df p fp dfp k factors r answer |
	f _ self.
	n _ f degree.
	n = 1 ifTrue: [^ {f}].
	A _ f normMax.
	b _ f leadingCoefficient.
	B _ (n+1) sqrt * (1<<n) * A * b. "float will fail"
	C _ (n+1)^(2*n)*(A^(2*n-1)).
"	gamma _ (2 * (C log: 2)) ceiling."
	gamma _ 2 * C highBit. "+1?"
	df _ f derivative.
	[[p _ (2*gamma*gamma ln) asInteger atRandom nextPrime.
	p | b] whileTrue.
	fp _ f % p.
	dfp _ df % p.
	(fp gcd: dfp) isConstant] whileFalse.
	"modular factorization"
	factors _ fp monic factors.
	r _ factors size. "should repeat this 5 times and choose smallest r"
	r = 1 ifTrue: [^ {f}]. "if irreducible mod p, also irreducible over Z"
	self assert: (self % p - (factors product * b)) isZero.
	"hensel lifting"
	k _ ((2*B+1) log: p) abs ceiling. "p^k > 2B"
	factors _ f henselLift: factors asArray to: k. "lift to p^k" "<- about 20% of time is spent here"
	1 to: k do: [:i|
		self assert: (self - ((factors product: [:fi| fi lift]) * b) % (p^i)) isZero].
	"recombination"
	answer _ Bag new.
	1 to: r do: [:j|
		(factors combinations: j) do: [:each| | g division | "<- about 50% of time is spent in this recombination step"
			g _ (each product * b) lift primitive.
			division _ f divisionBy: g.
			division remainder isZero ifTrue: [answer add: g. f _ division quotient. f isConstant ifTrue: [^ answer]]]].
	^ answer add: f; yourself! !

!UnivariatePolynomial methodsFor: 'factorization-private' stamp: 'len 4/26/2018 00:01:44'!
factorizationZassenhauss2
	"ZassenHauss algorithm. Answer the irreducible factors of a square-free polynomial with integer coefficients."
	| answer f df p fp dfp factors r B e g |
	answer _ Bag new.
	f _ self integerPrimitive.
	"remove x factor"
"	f leadingCoefficient abs > f independentCoefficient abs ifTrue: [f _ f reversed]."
	df _ f derivative.
	B _ f landauMignotteBound.
	"1. Choose a prime p such that gcd(f,df) = 1 mod p:"
	[p _ 1000 atRandom nextPrime.
	fp _ f % p.
	dfp _ df % p.
	(fp gcd: dfp) = fp one] whileFalse.
	"2. Modular factorization: factor f mod p."
	factors _ fp factors.
	r _ factors size. "should repeat this 5 times and choose smallest r"
	r = 1 ifTrue: [^ {f}]. "if irreducible mod p, also irreducible over Z"
	"3. Compute Landau-Mignotte bound and p^a with enough precision for Hensel lifting:"
	e _ (B*2*f leadingCoefficient log: p) ceiling.
	"4. Hensel lift to precision p^a:"
		"..."
	"5. Recombination: try all combinations of factors and find divisors of f:"
	1 to: r do: [:k|
		(factors combinations: k) do: [:each|
			g _ each product.
			g | f ifTrue: [answer add: g]]].
	^ answer! !

!UnivariatePolynomial methodsFor: 'factorization-private' stamp: 'len 4/25/2018 16:23:55'!
henselLift: factors to: k
	| p r mid g h s t m bezout gFactors hFactors |
	p _ factors anyOne scalars characteristic.
	r _ factors size.
	r = 1 ifTrue: "can be optimized, compute inverse modulo p using extended euclid, then lift to p^k with newton iteration algorithm 9.10 (modern computer algebra)"
		[^ {(self % (p^k) / self leadingCoefficient)}].
	mid _ r//2.
	gFactors _ factors copyFrom: 1 to: mid.
	hFactors _ factors copyFrom: mid+1 to: r.
	g _ gFactors product * self leadingCoefficient.
	h _ hFactors product.
	bezout _ (ExtendedEuclid on: {g. h}) bezout.
	s _ bezout first.
	t _ bezout second.
	m _ p.
	k highBit timesRepeat: "Hensel step:"
		[| e division c d b |
		self assert: (self % m - (g*h)) isZero.
		self assert: (s*g + (t*h) - 1) isZero.
		m _ m squared.
		g _ g lift % m. h _ h lift % m. s _ s lift % m. t _ t lift % m.
		e _ self % m - (g*h).
		division _ s*e divisionBy: h.
		c _ division quotient.
		d _ division remainder.
		g _ g + (t*e) + (c*g).
		h _ h + d.
		b _ s*g + (t*h) - 1.
		division _ s*b divisionBy: h.
		c _ division quotient.
		d _ division remainder.
		s _ s - d.
		t _ t - (t*b) - (c*g).
		self assert: (self % m - (g*h)) isZero.
		self assert: (s*g + (t*h) - 1) isZero].
	^ (g lift henselLift: gFactors to: k), (h lift henselLift: hFactors to: k)! !

!UnivariatePolynomial methodsFor: 'factorization-private' stamp: 'len 4/24/2018 01:32:31'!
landauMignotteBound
	"Answer the Landau-Mignotte bounds for the receiver.
	This is an upper bound for the absolute value of the coefficients of any nontrivial factor of a polynomial with integer coefficients. The bound depends on both the degree and the size of the coefficients of the receiver."
	| d h |
	d _ self degree // 2.
	h _ d // 2.
	^ (d - 1 choose: h) * self norm2 + (d - 1 choose: h - 1)! !

!UnivariatePolynomial methodsFor: 'factorization-private' stamp: 'len 4/26/2018 00:04:16'!
squareFreeFactorizationFiniteField
	"Answer the square-free decomposition of a monic polynomial."
	"NOTE: this only works on prime fields. For non-prime fields, after substituting x^p by x we must also apply the inverse of the Frobenius automorphism to the coefficients."
	| answer f one p i g c w y z |
	answer _ Bag new.
	f _ self.
	one _ f one.
	p _ f scalars characteristic.
	(g _ f derivative) isZero
		ifTrue:
			[f _ f monomialsApply: [:m| m root: p]. "not enough if the field is non-prime"
			f squareFreeFactorizationFiniteField
				do: [:each| answer add: each withOccurrences: p].
			^ answer].
	c _ f gcd: g.
	w _ f // c.
	i _ 1.
	[w = one]
		whileFalse:
			[y _ w gcd: c. z _ w // y.
			z ^ i = one ifFalse: [answer add: z withOccurrences: i].
			i _ i + 1.
			w _ y. c _ c // y].
	c = one
		ifFalse:
			[c _ c monomialsApply: [:m| m root: p]. "not enough if the field is non-prime"
			c squareFreeFactorizationFiniteField
				do: [:each| answer add: each withOccurrences: p]].
	^ answer! !

!UnivariatePolynomial methodsFor: 'factorization-private' stamp: 'len 4/26/2018 00:03:55'!
squareFreeFactorizationYun
	"Answer a square-free decomposition of the receiver.
	Use Yun's algorithm. Assume the coefficients are in a unique
	factorization domain or in a field of characteristic 0.
	Yun's algorithm on an input polynomial of degree n uses O(M(n)log(n)) operations in the base field F, where M(n) is the number of operations in F required to multiply two polynomias of degree n in F[x]."

	| p q gcd count answer |
	answer _ Bag new.
	count _ 1.
"	lc _ self leadingCoefficient.
	lc = self scalars one
		ifFalse: [answer add: (self parent constant: lc)].
	p _ self / lc."
	p _ self monic.
	q _ p derivative.
	gcd _ p gcd: q.
	gcd degree > 0
		ifTrue:
			[p _ p // gcd.
			q _ q // gcd - p derivative.
			[q isZero]
				whileFalse:
					[gcd _ p gcd: q.
					gcd degree > 0 ifTrue: [answer add: gcd withOccurrences: count].
					count _ count + 1.
					p _ p // gcd.
					q _ q // gcd - p derivative]].
	^ answer add: p withOccurrences: count; yourself! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 7/9/2016 03:05'!
<< anInteger
	^ self shift: anInteger! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 12/21/2017 20:09:22'!
apply: aMorphism
	"Answer a new polynomial with coefficients obtainted by applying aMorphism to the coefficients of the receiver. This morphism is a ring homomorphism from the scalars ring.
	If aMorphism is a block we assume the parent doesn't change, i.e. the block must evaluate to values within the scalars ring of the receiver."

	aMorphism isBlock
		ifTrue: [^ self parent coefficients: (self coefficients collect: aMorphism)].
	^ (self parent over: aMorphism codomain) coefficients: (self coefficients apply: aMorphism)! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 4/27/2018 07:38:13'!
companion
	"Answer the Frobenius companion matrix of the receiver.
	The companion matrix of a polynomial f in R[x] is the matrix of the 'multiplication by x' map on the R-algebra R[x]/<f>. This is a matrix that has f as both the characteristic and minimal polynomial.
	Also, given a linear recursive sequence with characteristic polynomial f, the transpose companion matrix of f generates the sequence."
	| n one zero |
	self isMonic ifFalse: [^ DomainError signal: 'Undefined for non-monic polynomials'].
	n _ self degree.
	zero _ self scalars zero.
	one _ self scalars one.
	^ self scalars matrix: n@n evaluating: [:i :j| i-1 = j ifTrue: [one] ifFalse: [j < n ifTrue: [zero] ifFalse: [(self coefficientAtDegree: i-1) negated]]]! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 1/23/2017 11:47:41'!
derivative
	| newCoefficients |
	self isZero ifTrue: [^ self].
	newCoefficients _ Array new: self degree.
	1 to: self degree do: [ :i | newCoefficients at: i put: (self coefficientAtDegree: i) * i ].
	^ self parent coefficients: newCoefficients! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 3/26/2016 23:05'!
derivativeIn: anIndeterminate
	^ (self has: anIndeterminate) ifTrue: [self derivative] ifFalse: [self zero]! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 7/9/2016 03:06'!
discriminant
	"Answer the (standard) discriminant of the receiver."
	| n |
	n _ self degree.
	^ (-1) ^ (n*(n-1)/2) / self leadingCoefficient * (self resultant: self derivative)! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 7/9/2016 03:06'!
discriminant0
	"Answer the (normalized) discriminant of the receiver."
	| n |
	n _ self degree.
	^ (-1) ^ (n*(n-1)/2) / (self leadingCoefficient ^ (2*n-1)) * (self resultant: self derivative)! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 1/23/2017 11:47:45'!
even
	"Decompose the receiver in the form f(x^2)x + g(x^2) and answer g(x)."
	^ self parent coefficients: ((1 to: self coefficients size by: 2) collect: [:each| coefficients at: each])! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 1/23/2017 11:48:16'!
odd
	"Decompose the receiver in the form f(x^2)x + g(x^2) and answer f(x)."
	^ self parent coefficients: ((2 to: self coefficients size by: 2) collect: [:each| coefficients at: each])! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 1/25/2018 22:50:45'!
psc2: anInteger with: aPolynomial
	"Answer the anInteger-th principal subresultant coefficient of the receiver with aPolynomial."

	| f g n m t rows tuple |
	f _ self.
	g _ aPolynomial.
	m _ f degree.
	n _ g degree.
	t _ m + n - anInteger - anInteger.
	t <= 0 ifTrue: [^ self scalars one].
	rows _ OrderedCollection new: t.
	tuple _ self scalars tuple: t evaluating: [:i| f coefficientAtDegree: m - i + 1].
	n - anInteger timesRepeat: [rows add: tuple. tuple _ tuple shift: 1].
	tuple _ self scalars tuple: t evaluating: [:i| g coefficientAtDegree: n - i + 1].
	m - anInteger timesRepeat: [rows add: tuple. tuple _ tuple shift: 1].
	^ (Matrix rows: rows) determinant! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 5/4/2018 19:30:29'!
psc3: i with: aPolynomial
	"Answer the anInteger-th principal subresultant coefficient of the receiver with aPolynomial."
	self flag: #fix. "use version 2, more efficient, but must test"
	^ (self subresultant: i with: aPolynomial) leadingCoefficient "WTF, sometimes subresultant returns nil, SemialgebraicSet circle"! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 11/24/2016 12:12:18'!
psc: anInteger with: aPolynomial
	"Answer the anInteger-th principal subresultant coefficient of the receiver with aPolynomial."

	| f g n m t rows tuple |
	f _ self.
	g _ aPolynomial.
	m _ f degree.
	n _ g degree.
	t _ m + n - anInteger - anInteger.
	t <= 0 ifTrue: [^ self scalars one].
	rows _ OrderedCollection new: t.
	tuple _ self scalars tuple: t evaluating: [:i| f coefficientAtDegree: m - i + 1].
	n - anInteger timesRepeat: [rows add: tuple. tuple _ tuple shift: 1].
	tuple _ self scalars tuple: t evaluating: [:i| g coefficientAtDegree: n - i + 1].
	m - anInteger timesRepeat: [rows add: tuple. tuple _ tuple shift: 1].
	^ (Matrix rows: rows) determinant! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 7/9/2016 03:07'!
resultant2: aPolynomial
	"Answer the resultant of the receiver with the argument."
	| f g mult |
	self degree <= aPolynomial degree
		ifTrue: [f _ self. g _ aPolynomial]
		ifFalse: [f _ aPolynomial. g _ self].
	f isConstant ifTrue: [^ (f ^ g degree)].
	f isMonic
		ifTrue:
			[mult _ f leadingCoefficient]
		ifFalse:
			[mult _ f leadingCoefficient ^ g degree.
			f _ f / f leadingCoefficient].
	^ (g value: f companion) determinant * mult! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 7/9/2016 03:07'!
resultant3: aPolynomial
	"Answer the resultant of the receiver with the argument."

	| f g answer negate |
	self degree > aPolynomial degree
		ifTrue: [f _ aPolynomial. g _ self. negate _ true]
		ifFalse: [f _ self. g _ aPolynomial. negate _ false].
	answer _ f isConstant
		ifTrue: [f ^ g degree]
		ifFalse:
			[(f resultant3: g \\ f) * (f leadingCoefficient ^ (g degree - f degree + 1))].
	^ negate ifTrue: [answer negated] ifFalse: [answer]! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 7/9/2016 03:07'!
resultant: aPolynomial
	"Answer the resultant of the receiver with aPolynomial."
	self degree = 0
		ifTrue: [^ aPolynomial ^ self degree].
	aPolynomial degree = 0
		ifTrue:
			[^ (self degree even or: [aPolynomial degree even])
					ifTrue: [(self ^ aPolynomial degree)]
					ifFalse: [(self ^ aPolynomial degree) negated]].
	^ (self sylvester: aPolynomial) determinant! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 1/23/2017 11:48:20'!
reversed
	"Answer the reverse of the receiver."

	^ self parent coefficients: coefficients reversed! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 1/23/2017 11:48:25'!
shift: anInteger
	| n |
	self isZero ifTrue: [^ self].
	n _ self degree + anInteger.
	n >= 0 ifFalse: [^ self zero].
	^ self parent coefficients: coefficients >>> anInteger! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 1/25/2018 22:57:56'!
subresultant: i with: aPolynomial
	"Answer the i-th subresultant of the receiver with aPolynomial."
	| lambda mu n m c rows matrix tuple |
	m _ self degree.
	n _ aPolynomial degree.
	lambda _ m min: n.
	mu _ (m max: n) - 1.
	i = lambda
		ifTrue:
			[m + 1 < n
				ifTrue: [c _ self]
				ifFalse:
					[n + 1 < m
						ifTrue: [c _ aPolynomial] ifFalse: [^ nil]].
			^ c * (c leadingCoefficient ^ ((m - n) abs - 1))].
	(i between: lambda and: mu) ifTrue: [^ self zero].
	(i between: 0 and: lambda - 1) ifFalse: [self error: 'index out of range'].
	rows _ OrderedCollection new.
	tuple _ self scalars tuple: m + n - (2*i) evaluating: [:k| self parent constant: (self coefficientAtDegree: m - k + 1)].
	n - i timesRepeat: [rows add: tuple. tuple _ tuple shift: 1].
	tuple _ self scalars tuple: m + n - (2*i) evaluating: [:k| self parent constant: (aPolynomial coefficientAtDegree: n - k + 1)].
	m - i timesRepeat: [rows add: tuple. tuple _ tuple shift: 1].
	matrix _ Matrix rows: rows.
	1 to: n - i do: [:k|
		matrix at: k @ (m + n - (2*i)) put: (self shift: n - i - k)].
	1 to: m - i do: [:k|
		matrix at: n - i + k @ (m + n - (2*i)) put: (aPolynomial shift: m - i - k)].
	^ matrix determinant! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 7/9/2016 03:08'!
subresultantChain: aPolynomial
	"Answer the Subresultant Chain of the receiver with the argument."
	| n answer |
	n _ self degree > aPolynomial degree ifTrue: [self degree - 1] ifFalse: [aPolynomial degree].
	answer _ OrderedCollection new: n + 2.
	answer add: self; add: aPolynomial.
	n - 1 to: 0 by: -1 do: [:i|
		answer add: (self subresultant: i with: aPolynomial)].
	^ answer! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 11/24/2016 12:14:05'!
sylvester: aPolynomial
	"Answer the Sylvester matrix of the receiver with the argument.
	If p,q polynomials of degrees m and n:
		det S(p,q) = res (p,q)
		deg (gcd(p,q)) = m - n + rank (S(p,q))
	Also the kernel of the transposed Sylvester matrix gives all solutions of the Bezout equation:
		f*p + g*q = 0
	"
	| m n rows tuple |
	m _ self degree.
	n _ aPolynomial degree.
	rows _ OrderedCollection new: m+n.
	tuple _ self scalars tuple: m+n evaluating: [:i| self coefficientAtDegree: m-i+1].
	n timesRepeat: [rows add: tuple. tuple _ tuple shift: 1].
	tuple _ self scalars tuple: m+n evaluating: [:i| aPolynomial coefficientAtDegree: n-i+1].
	m timesRepeat: [rows add: tuple. tuple _ tuple shift: 1].
	^ Matrix rows: rows! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 3/28/2018 18:04:25'!
value: anObject
	"Evaluate the receiver at the given argument using Horner's method."
	| x |
	x _ (anObject isTuple or: [anObject isArray])
		ifTrue: [anObject at: 1] ifFalse: [anObject].
	^ coefficients polynomialValue: x! !

!UnivariatePolynomial methodsFor: 'roots' stamp: 'len 4/10/2018 16:11:32'!
allRoots
	"Answer the roots (counted with multiplicity) in the coefficients ring or field."
	^ self allRootsIn: self scalars! !

!UnivariatePolynomial methodsFor: 'roots' stamp: 'len 4/29/2018 17:20:24'!
allRootsIn: aRing
	"Answer the roots (counted with multiplicity) in the given domain."
	| answer |
	(aRing isKindOf: RealField)
		ifTrue: [^ self allRealRoots].
	(aRing isKindOf: ComplexField)
		ifTrue: [^ self allComplexRoots].
	answer _ Bag new.
	(self over: aRing) factors withOccurrencesDo: [:f :e|
		f degree = 1 ifTrue: [answer add: (f independentCoefficient negated / f leadingCoefficient) withOccurrences: e]].
	^ answer! !

!UnivariatePolynomial methodsFor: 'roots' stamp: 'len 4/16/2018 19:49:43'!
anyRoot
	^ self anyRootIn: self scalars! !

!UnivariatePolynomial methodsFor: 'roots' stamp: 'len 4/24/2018 16:24:11'!
anyRootIn: aRing
	^ (self rootsIn: aRing) anyOne! !

!UnivariatePolynomial methodsFor: 'roots' stamp: 'len 4/16/2018 20:38:44'!
cauchyRootBound
	| max a0 an |
	max _ 0.
	self coefficients do: [:each| max _ max max: each abs].
	a0 _ self independentCoefficient abs.
	an _ self leadingCoefficient abs.
	^ Array with: a0 / (a0 + max) with: an + max / an! !

!UnivariatePolynomial methodsFor: 'roots' stamp: 'len 2/13/2017 07:54:44'!
multiplicityAt: aPoint
	"Answer the multiplicity of aPoint as zero of the receiver."
	| answer f |
	self isZero ifTrue: [^ Infinity positive].
	answer _ 0.
	f _ self.
	[(f value: aPoint) isZero]
		whileTrue:
			[answer _ answer + 1.
			f _ f derivative].
	^ answer! !

!UnivariatePolynomial methodsFor: 'roots' stamp: 'len 2/6/2017 06:44:06'!
orderAt: aPoint
	^ self multiplicityAt: aPoint! !

!UnivariatePolynomial methodsFor: 'roots' stamp: 'len 4/10/2018 16:11:22'!
roots
	"Answer the set of distinct roots in the coefficients ring or field."
	^ self rootsIn: self scalars! !

!UnivariatePolynomial methodsFor: 'roots' stamp: 'len 4/29/2018 17:21:15'!
rootsIn: aRing
	"Answer the distinct roots (not counted with multiplicity) in the given domain."
	^ (self allRootsIn: aRing) asSet! !

!UnivariatePolynomial methodsFor: 'roots' stamp: 'len 11/20/2016 10:22:00'!
signature
	"Answer the signature (r1,r2) of the receiver, where r1 is the number of real roots and 2*r2 is the number of non-real roots. Assume the receiver's coefficients are integers. Throw an error if the receiver is not square-free.
	Ref: COHEN Algorithm 4.1.11 (Sturm)."
	| A B g h s n t r1 d R |
	self isZero ifTrue: [^ #(0 0)].
	A _ self primitive.
	B _ self derivative primitive.
	g _ 1.
	h _ 1.
	s _ A sign.
	n _ A degree.
	t _ n even ifTrue: [s negated] ifFalse: [s].
	r1 _ 1.
	[d _ A degree - B degree.
	R _ A pseudoRem: B.
	R isZero ifTrue: [^ self error: 'polynomial is not square-free'].
	(d odd or: [B leadingCoefficient > 0])
		ifTrue: [R _ R negated].
	"Use Sturm:"
	R sign ~= s ifTrue: [s _ s negated. r1 _ r1 - 1].
	R sign ~= ((-1) ^ R degree * t) ifTrue: [t _ t negated. r1 _ r1 + 1].
	"Finished?"
	R isConstant]
		whileFalse:
			[A _ B.
			B _ R / (h ^ d * g).
			g _ A leadingCoefficient abs.
			h _ h ^ (1 - d) * (g ^ d)].
	^ {r1. n - r1 / 2}! !

!UnivariatePolynomial methodsFor: 'roots' stamp: 'len 5/13/2019 19:02:07'!
zeroAddition: aPolynomial
	"Answer a polynomial whose zeros are the addition of the receiver zeros with the zeros of the argument."
	| f g R S X Y C |
	self degree <= aPolynomial degree
		ifTrue: [f _ self. g _ aPolynomial]
		ifFalse: [g _ self. f _ aPolynomial].
	R _ self parent.
	S _ self scalars polynomialsIn: 2.
	X _ S x: 1.
	Y _ S x: 2.
	f isMonic ifFalse: [f _ f monic]. "otherwise the companion matrix is undefined"
	C _ f companion apply: R scalars -> R.
	^ (((g value: X - Y) asUnivariateIn: 2) value: C) determinant! !

!UnivariatePolynomial methodsFor: 'roots' stamp: 'len 4/30/2018 05:17:16'!
zeroNegation
	"Answer a polynomial whose zeros are the receiver zeros negated."
	^ self parent coefficients:
		(self degree odd "this distinction is made to keep the leading coefficient positive, as a minimal polynomial"
			ifTrue: [self coefficients withIndexCollect: [:each :i| i odd ifTrue: [each negated] ifFalse: [each]]]
			ifFalse: [self coefficients withIndexCollect: [:each :i| i even ifTrue: [each negated] ifFalse: [each]]])! !

!UnivariatePolynomial methodsFor: 'roots' stamp: 'len 5/13/2019 19:02:45'!
zeroProduct: aPolynomial
	"Answer a polynomial whose zeros are the product of the receiver zeros by the zeros of the argument."
	| f g C R |
	self degree <= aPolynomial degree
		ifTrue: [f _ self. g _ aPolynomial]
		ifFalse: [g _ self. f _ aPolynomial].
	f isMonic ifFalse: [f _ f monic]. "otherwise the companion matrix is undefined"
	R _ self parent.
	C _ f companion apply: R scalars -> R.
	^ (g homogenized asUnivariate value: C) determinant! !

!UnivariatePolynomial methodsFor: 'roots' stamp: 'len 4/27/2018 16:25:56'!
zeroRaisedTo: anInteger
	"Answer a polynomial whose zeros are the zeros of the receiver raised to anInteger."
	self notYetImplemented! !

!UnivariatePolynomial methodsFor: 'roots' stamp: 'len 11/20/2016 10:22:25'!
zeroReciprocal
	"Answer a polynomial whose zeros are the reciprocals of the receiver's zeros."

	^ self reversed! !

!UnivariatePolynomial methodsFor: 'roots' stamp: 'len 12/4/2017 10:22:45'!
zeroSquareRoot
	^ self value: self parent x squared! !

!UnivariatePolynomial methodsFor: 'roots-private' stamp: 'len 4/29/2018 18:25:23'!
allComplexRoots
	| answer |
	answer _ Bag new.
	self integerPrimitive factors withOccurrencesDo: [:f :e|
		f degree = 1
			ifTrue:
				[answer add: (f independentCoefficient negated / f leadingCoefficient) withOccurrences: e]
			ifFalse:
				[(ComplexRootIsolator on: f) roots do: [:each|
	 				answer add: (ComplexAlgebraicNumber minimalPolynomial: f approximation: each center radius: each radius) withOccurrences: e]]].
	^ answer! !

!UnivariatePolynomial methodsFor: 'roots-private' stamp: 'len 4/29/2018 17:12:16'!
allRationalRoots
	"Answer the (real) rational roots of the polynomial."
	| roots f n k tau visited fourier |
	roots _ Bag new.
	f _ self integerPrimitive.
	n _ f degree.
	(k _ f order) > 0 ifTrue: [roots add: 0 withOccurrences: k. f _ f shift: k negated].
	f isConstant ifTrue: [^ roots].
	visited _ Set new.
	fourier _ OrderedCollection with: f.
	f independentCoefficient divisorsDo: [:each|
		f leadingCoefficient divisorsDo: [:one|
			tau _ each / one.
			visited add: tau ifAbsent:
					[(f value: tau) isZero
						ifTrue: [roots add: tau withOccurrences: (self multiplicityAt: tau fourier: fourier). roots size = n ifTrue: [^ roots]].
					tau _ tau negated.
					(f value: tau) isZero
						ifTrue: [roots add: tau withOccurrences: (self multiplicityAt: tau fourier: fourier). roots size = n ifTrue: [^ roots]]]]].
	^ roots! !

!UnivariatePolynomial methodsFor: 'roots-private' stamp: 'len 4/29/2018 18:32:01'!
allRealRoots
	| answer |
	answer _ Bag new.
	self integerPrimitive factors withOccurrencesDo: [:f :e|
		f degree = 1
			ifTrue:
				[answer add: (f independentCoefficient negated / f leadingCoefficient) withOccurrences: e]
			ifFalse:
				[(RealRootIsolator on: f) roots do: [:each|
	 				answer add: (RealAlgebraicNumber minimalPolynomial: f bounds: each) withOccurrences: e]]].
	^ answer! !

!UnivariatePolynomial methodsFor: 'roots-private' stamp: 'len 4/24/2018 17:46:40'!
multiplicityAt: aRoot fourier: fourier
	| count |
	count _ 0.
	fourier do: [:each| (each value: aRoot) isZero ifFalse: [^ count]. count _ count + 1].
	[fourier last isConstant]
		whileFalse:
			[((fourier add: fourier last derivative) value: aRoot) isZero ifFalse: [^ count]. count _ count + 1].
	^ count! !

!UnivariatePolynomial methodsFor: 'testing' stamp: 'len 1/23/2017 11:47:49'!
has: anIndeterminate
	^ self degree > 0 and: [self parent has: anIndeterminate]! !

!UnivariatePolynomial methodsFor: 'testing' stamp: 'len 9/22/2018 19:00:42'!
isIrreducible
	| R |
	self isConstant ifTrue: [^ false]. "constant polynomials are not reducible nor irreducible"
	self degree = 1 ifTrue: [^ true].
	R _ self scalars.
	((R isKindOf: RealField) and: [self degree > 2])
		ifTrue: [^ false].
	(R isKindOf: ComplexField)
		ifTrue: [^ self degree = 1].
	R isGaloisField
		ifTrue: [^ self isIrreducibleRabin].
"	(R isKindOf: RationalField)
		ifTrue: [^ self isIrreducibleHeuristic: ...]."
	^ self factors size = 1! !

!UnivariatePolynomial methodsFor: 'testing' stamp: 'len 4/16/2018 20:26:51'!
isIrreducibleBenOr
	"Ben-Or Irreducibility Test algorithm for polynomials in field of characteristic q."
	| q x one |
	q _ self scalars characteristic.
	x _ self parent x.
	one _ self one.
	1 to: self degree // 2 do: [:i|
		(self gcd: x^(q^i) - x \\ self) = one ifTrue: [^ false]].
	^ true! !

!UnivariatePolynomial methodsFor: 'testing' stamp: 'len 4/16/2018 20:38:05'!
isIrreducibleHeuristic2: anInteger
	"Answer an Integer or nil. If the answer is an Integer, the
	receiver is irreducible iff that integer is prime, and in fact the
	integer will be prime with a very high probability (a probabilistic
	test is used here). If the answer is nil, the heuristic test has failed,
	and nothing can be said about the irreducibility of the receiver."

	"This is a probabilistic test for irreudcibility of rational univariate
	polynomials. It works looking for a prime evaluation of the polynomial.
	If it finds such a prime, then it's returned, and nil otherwise. The
	argument anInteger is the upper bound for the looking for primes."

	"Reference: 'A Heuristic Polynomial Irreducibility Test', Michael
	Monagan, J. Symbolic Comp., (1992) Vol. 13, No. 1, pp 47-57."

	| f g bg bound val try gcd |
	f _ self integerPrimitive.
	g _ f reversed.
	(bg _ g norm1 / g leadingCoefficient abs + 1) <
	(bound _ f norm1 / f leadingCoefficient abs + 1)
		ifTrue: [f _ g. bound _ bg].
	bound to: anInteger - 1 / 2 do: [ :each |
		val _ (f value: each) abs.
		gcd _ val gcd: 355929487585205167172661547995662840887819680000.
		(gcd <= (each - bound) squared and: [(try _ val / gcd) isPrime])
			ifTrue: [^ try].
		val _ (f value: each negated) abs.
		gcd _ val gcd: 355929487585205167172661547995662840887819680000.
		(gcd <= (each - bound) squared and: [(try _ val / gcd) isPrime])
			ifTrue: [^ try]
	].
	^ nil! !

!UnivariatePolynomial methodsFor: 'testing' stamp: 'len 4/16/2018 20:38:20'!
isIrreducibleHeuristic: anInteger
	"Answer an Integer or nil. If the answer is an Integer, the
	receiver is irreducible iff that integer is prime, and in fact the
	integer will be prime with a very high probability (a probabilistic
	test is used here). If the answer is nil, the heuristic test has failed,
	and nothing can be said about the irreducibility of the receiver."

	"This is a probabilistic test for irreudcibility of rational univariate
	polynomials. It works looking for a prime evaluation of the polynomial.
	If it finds such a prime, then it's returned, and nil otherwise. The
	argument anInteger is the upper bound for the looking for primes."

	| f val bound interval |
	f _ self integerPrimitive.
	bound _ self cauchyRootBound first floor abs.
	bound even ifTrue: [bound _ 0 max: bound - 1].
	interval _ f independentCoefficient odd
		ifTrue: [bound to: bound + (anInteger // 2)]
		ifFalse: [bound to: bound + anInteger by: 2].
	interval do: [ :each |
		val _ (f value: each) abs.
		val isPrime ifTrue: [^ val].
		val _ (f value: each negated) abs.
		val isPrime ifTrue: [^ val]
	].
	^ nil! !

!UnivariatePolynomial methodsFor: 'testing' stamp: 'len 4/16/2018 20:27:55'!
isIrreducibleRabin
	| Fx x one f n h g q |
	(self independentCoefficient isZero and: [self degree > 1]) ifTrue: [^ false].
	"Rabin's algorithm:"
	f _ self.
	Fx _ f parent.
	q _ Fx scalars size.
	x _ Fx x.
	one _ Fx one.
	n _ f degree.
	n factors asSet do: [:p|
		h _ (x raisedTo: q^(n/p) modulo: f) - x \\ f.
		g _ f gcd: h.
		g ~= one ifTrue: [^ false]].
	g _ (x raisedTo: q^n modulo: f) - x \\ f.
	g isZero ifFalse: [^ false].
	^ true! !

!UnivariatePolynomial methodsFor: 'testing' stamp: 'len 3/27/2016 07:56'!
isUnivariate
	^ true! !

!UnivariatePolynomial methodsFor: 'testing' stamp: 'len 12/21/2017 18:40:41'!
isZero
	^ coefficients isZero! !

!UnivariatePolynomial methodsFor: 'private' stamp: 'len 3/29/2016 20:37'!
coefficients: aTuple
	coefficients _ aTuple.
	self normalize! !

!UnivariatePolynomial methodsFor: 'private' stamp: 'len 11/28/2016 10:07:03'!
dividedByMonomial: aMonomial
	^ self shift: aMonomial degree negated! !

!UnivariatePolynomial methodsFor: 'private' stamp: 'len 12/22/2017 18:11:57'!
dividedByScalar: aNumber
	^ self parent coefficients: self coefficients / aNumber! !

!UnivariatePolynomial methodsFor: 'private' stamp: 'len 4/24/2018 19:38:52'!
exactlyDividedBy2: aPolynomial
	"Answer the exact division of the receiver by the argument.
	Apply the Schonhage-Jabelean algorithm, for polynomials of degree at most 2n and n with coefficients in a field. When necesary conditions don't hold, do the ordinary division.
	Ref: 'Algorithms With Exact Divisions Made Faster', Arnold Schonhage,
	INRIA Research Report Nro. 2381, Algorithms Seminar 1993-1994, p. 51."

	| shift f g m n h l k cg q |
	self flag: #fix. "this has some bug"
	self isZero
		ifTrue: [^ self].
	aPolynomial isConstant
		ifTrue: [^ self / aPolynomial leadingCoefficient].
	(self isUnivariate and: [aPolynomial isUnivariate])
		ifFalse: [^ (MultivariatePolynomialDivision divide: self by: {aPolynomial}) exactQuotient].
	self scalars isField
		ifFalse: [^ (PolynomialPseudoDivision divide: self by: aPolynomial) exactQuotient].
	(shift _ aPolynomial order negated) < 0 ifTrue: [^ (self shift: shift) exactlyDividedBy: (aPolynomial shift: shift)].
	f _ self coefficients.
	g _ aPolynomial coefficients.
	m _ f size.
	n _ g size.
	m = n ifTrue: [^ self parent constant: f last / g last].
 	n * 2 > m ifFalse: [^ (self divisionBy: aPolynomial) exactQuotient].

	h _ f size // 2.
	l _ h // 2.
	k _ h - l.

	q _ Array new: m-n+1.
	
	"Jebelean division for the lowest half:"
	cg _ g first reciprocal. "reciprocal of the independent coefficient"
	0 to: l do: [:i|
		| qi |
		qi _ q at: i+1 put: (f at: i+1) * cg.
		1 to: l-i do: [:j|
			f at: i+j+1 put: (f at: i+j+1) - (qi*(g at: j+1))]]. "optimize negated"
	
	"Schonhage division for the other half:"
	cg _ g last reciprocal. "reciprocal of the leading coefficient"
	m-n to: m-n-k+1 by: -1 do: [:i|
		| qi |
		qi _ q at: i+1 put: (f at: i+n) * cg.
		n-2 to: m-k-i by: -1 do: [:j|
			f at: i+j+1 put: (f at: i+j+1) - (qi*(g at: j+1))]].

	^ self parent coefficients: q! !

!UnivariatePolynomial methodsFor: 'private' stamp: 'len 4/24/2018 00:52:18'!
exactlyDividedBy: aPolynomial
	"Answer the exact division of the receiver by the argument."

	self isZero ifTrue: [^ self].
	aPolynomial isConstant ifTrue: [^ self dividedByScalar: aPolynomial leadingCoefficient].
	(aPolynomial isMonic or: [self scalars isField])
		ifFalse: [^ (PolynomialPseudoDivision divide: self by: aPolynomial) exactQuotient].
	^ (PolynomialDivision divide: self by: aPolynomial) exactQuotient! !

!UnivariatePolynomial methodsFor: 'private' stamp: 'len 11/28/2016 10:05:30'!
multipliedByMonomial: aMonomial
	^ self shift: aMonomial degree! !

!UnivariatePolynomial methodsFor: 'private' stamp: 'len 12/24/2017 19:33:52'!
multipliedByPolynomial: aPolynomial
	^ self parent coefficients: (self coefficients convolution: aPolynomial coefficients)! !

!UnivariatePolynomial methodsFor: 'private' stamp: 'len 12/24/2017 19:32:53'!
multipliedByScalar: aNumber
	^ self parent coefficients: self coefficients * aNumber! !

!UnivariatePolynomial methodsFor: 'private' stamp: 'len 11/22/2016 08:48:49'!
normalize
	| n |
	(n _ coefficients lastNonZero) < coefficients size
		ifTrue: [coefficients _ coefficients copyFrom: 1 to: n]! !

!UnivariatePolynomial class methodsFor: 'instance creation' stamp: 'len 12/22/2017 18:22:09'!
coefficients: aTuple
	^ self basicNew coefficients: aTuple! !

!LaurentSeries methodsFor: 'accessing' stamp: 'len 6/3/2019 18:39:47'!
denominator
	^ valuation < 0 ifTrue: [unit parent !! (self p ^ valuation negated)] ifFalse: [unit one]! !

!LaurentSeries methodsFor: 'accessing' stamp: 'len 6/3/2019 18:39:52'!
numerator
	^ valuation <= 0 ifTrue: [unit] ifFalse: [unit >> valuation]! !

!LaurentSeries methodsFor: 'accessing' stamp: 'len 6/3/2019 18:36:17'!
unit
	^ unit! !

!LaurentSeries methodsFor: 'accessing' stamp: 'len 6/3/2019 02:33:25'!
valuation
	^ valuation! !

!LaurentSeries methodsFor: 'testing' stamp: 'len 9/22/2018 19:13:20'!
isFractional
	^ true! !

!LaurentSeries methodsFor: 'private' stamp: 'len 6/3/2019 18:40:15'!
valuation: anInteger unit: anAdicInteger
	valuation _ anInteger.
	unit _ anAdicInteger! !

!LaurentSeries class methodsFor: 'instance creation' stamp: 'len 6/3/2019 18:40:45'!
valuation: anInteger unit: anAdicInteger
	^ self new valuation: anInteger unit: anAdicInteger! !

!PowerSeries methodsFor: 'accessing' stamp: 'len 12/27/2015 15:45'!
coefficients
	^ coefficients! !

!PowerSeries methodsFor: 'accessing' stamp: 'len 12/27/2015 15:45'!
indeterminate
	^ 1! !

!PowerSeries methodsFor: 'accessing' stamp: 'len 10/28/2016 10:37'!
parent
	^ parent! !

!PowerSeries methodsFor: 'accessing' stamp: 'len 12/28/2015 04:12'!
scalars
	^ coefficients codomain! !

!PowerSeries methodsFor: 'accessing' stamp: 'len 9/22/2018 18:55:44'!
terms
	| P |
	P _ self scalars polynomials.
	^ Sequence to: P evaluating: [:i| P coefficient: (coefficients at: i) degree: i-1]! !

!PowerSeries methodsFor: 'accessing-private' stamp: 'len 12/27/2015 15:46'!
coefficients: aSequence
	coefficients _ aSequence! !

!PowerSeries methodsFor: 'accessing-private' stamp: 'len 10/28/2016 10:38'!
parent: aPowerSeriesRing
	parent _ aPowerSeriesRing! !

!PowerSeries methodsFor: 'arithmetic' stamp: 'len 6/2/2019 17:09:36'!
* anObject
	((anObject isKindOf: PowerSeries) and: [anObject parent = parent])
		ifTrue: [^ parent coefficients: (coefficients convolution: anObject coefficients)].
	(self scalars includes: anObject)
		ifTrue: [^ parent coefficients: coefficients * anObject].
	(anObject isKindOf: Polynomial)
		ifTrue: [^ self * (parent !! anObject)].
	^ DomainError signal! !

!PowerSeries methodsFor: 'arithmetic' stamp: 'len 6/2/2019 17:10:27'!
+ anObject
	(anObject isKindOf: PowerSeries)
		ifTrue: [^ parent coefficients: coefficients + anObject coefficients].
	(self scalars includes: anObject)
		ifTrue: [^ parent coefficients: coefficients + (CFiniteSequence to: self scalars initialValues: {anObject} periodic: {anObject zero})].
	(anObject isKindOf: Polynomial)
		ifTrue: [^ self + (parent !! anObject)].
	^ DomainError signal! !

!PowerSeries methodsFor: 'arithmetic' stamp: 'len 6/2/2019 17:14:04'!
negated
	^ parent coefficients: coefficients negated! !

!PowerSeries methodsFor: 'arithmetic' stamp: 'len 6/5/2019 17:04:52'!
reciprocal
	| b1 a |
	a _ coefficients.
	b1 _ (a at: 1) reciprocal.
	^ parent coefficients:
		(Sequence
			to: self scalars
			initialValues: {b1}
			recurrence:
				[:b :n|
				b1 negated * ((2 to: n) sum: [:i| (a at: i) * (b at: n-i+1)])])! !

!PowerSeries methodsFor: 'comparing' stamp: 'len 6/2/2019 17:14:32'!
= anObject
	^ (anObject isKindOf: PowerSeries) and: [coefficients = anObject coefficients]! !

!PowerSeries methodsFor: 'comparing' stamp: 'len 12/28/2015 19:45'!
hash
	^ coefficients hash! !

!PowerSeries methodsFor: 'converting' stamp: 'len 12/27/2015 19:09'!
asRationalFunction
	^ coefficients generatingFunction! !

!PowerSeries methodsFor: 'operations' stamp: 'len 6/2/2019 17:11:59'!
derivative
	^ parent coefficients: coefficients << 1 * CFiniteSequence identity! !

!PowerSeries methodsFor: 'operations' stamp: 'len 2/29/2016 04:58'!
value: anObject upTo: n
	| answer |
	answer _ anObject zero.
	self terms do: [:each| each degree > n ifTrue: [^ answer]. answer _ answer + (each value: anObject)].
	^ answer! !

!PowerSeries methodsFor: 'testing' stamp: 'len 4/11/2016 23:09'!
isZero
	^ coefficients isZero! !

!PowerSeries class methodsFor: 'examples' stamp: 'len 6/4/2019 08:01:28'!
cos
	"The power series expansion of cos(x)."
	^ QQ powerSeries coefficients:
		(Sequence to: QQ evaluating: [:n| n even ifTrue: [0] ifFalse: [|k| k _ n-1/2. (-1)^k / (2*k) factorial]])! !

!PowerSeries class methodsFor: 'examples' stamp: 'len 6/4/2019 08:02:05'!
exp
	"The power series expansion of exp(x)."
	^ QQ powerSeries
		coefficients: (Sequence to: QQ evaluating: [:n| 1 / n factorial])! !

!PowerSeries class methodsFor: 'examples' stamp: 'len 6/4/2019 08:01:49'!
sin
	"The power series expansion of sin(x)."
	^ QQ powerSeries
		coefficients: (Sequence to: QQ evaluating: [:n| n odd ifTrue: [0] ifFalse: [|k| k _ n/2-1. (-1)^k / (2*k+1) factorial]])! !

!PowerSeries class methodsFor: 'instance creation' stamp: 'len 12/27/2015 16:21'!
coefficients: aSequence
	^ self new coefficients: aSequence! !

!PowerSeries class methodsFor: 'instance creation' stamp: 'len 11/25/2016 10:32:44'!
fromPolynomial: aPolynomial
	^ self coefficients: (CFiniteSequence to: aPolynomial scalars initialValues: aPolynomial coefficients periodic: {aPolynomial scalars zero})! !

!LocalRingElement methodsFor: 'as yet unclassified' stamp: 'len 6/2/2019 13:55:40'!
absolutePrecision
	^ self parent precision! !

!LocalRingElement methodsFor: 'as yet unclassified' stamp: 'len 6/1/2019 12:27:00'!
isIntegral
	^ self valuation >= 0! !

!LocalRingElement methodsFor: 'as yet unclassified' stamp: 'len 6/1/2019 12:26:54'!
isUnit
	^ self valuation = 0! !

!LocalRingElement methodsFor: 'as yet unclassified' stamp: 'len 6/1/2019 12:27:52'!
precision
	^ self subclassResponsibility! !

!LocalRingElement methodsFor: 'as yet unclassified' stamp: 'len 6/1/2019 12:31:56'!
relativePrecision
	^ self absolutePrecision - self valuation! !

!LocalRingElement methodsFor: 'as yet unclassified' stamp: 'len 6/1/2019 12:26:46'!
valuation
	^ self subclassResponsibility! !

!TruncatedAdicNumber methodsFor: 'as yet unclassified' stamp: 'len 6/1/2019 12:46:22'!
digits
	| x p answer |
	x _ unit.
	p _ self parent p.
	answer _ OrderedCollection new.
	[x = 0]
		whileFalse:
			[answer add: x \\ p.
			x _ x // p].
	^ answer! !

!TruncatedAdicNumber methodsFor: 'as yet unclassified' stamp: 'len 6/1/2019 11:49:25'!
precision
	^ precision! !

!TruncatedAdicNumber methodsFor: 'as yet unclassified' stamp: 'len 6/1/2019 11:49:19'!
unit
	^ unit! !

!TruncatedAdicNumber methodsFor: 'as yet unclassified' stamp: 'len 6/1/2019 11:49:09'!
valuation
	^ valuation! !

!ModuleElement methodsFor: 'converting' stamp: 'len 5/11/2019 08:31:05'!
adaptToFraction: rcvr andSend: selector
	selector = #* ifTrue: [^ self * rcvr].
	^ super adaptToNumber: rcvr andSend: selector! !

!ModuleElement methodsFor: 'converting' stamp: 'len 5/11/2019 07:47:44'!
adaptToInteger: rcvr andSend: selector
	selector = #* ifTrue: [^ self * rcvr].
	^ super adaptToInteger: rcvr andSend: selector! !

!ModuleElement methodsFor: 'converting' stamp: 'len 5/11/2019 08:03:08'!
adaptToRealAlgebraic: rcvr andSend: selector
	(selector = #* and: [self scalars includes: rcvr]) ifTrue: [^ self * rcvr].
	^ super adaptToNumber: rcvr andSend: selector! !

!ModuleElement methodsFor: 'operations' stamp: 'len 5/11/2019 07:58:54'!
* aNumber
	^ self subclassResponsibility! !

!ModuleElement methodsFor: 'operations' stamp: 'len 5/11/2019 07:58:35'!
+ anElement
	^ self subclassResponsibility! !

!ModuleElement methodsFor: 'operations' stamp: 'len 5/6/2019 03:41:55'!
- anElement
	^ self + anElement negated! !

!ModuleElement methodsFor: 'operations' stamp: 'len 5/6/2019 03:42:39'!
/ aNumber
	^ self * aNumber reciprocal! !

!ModuleElement methodsFor: 'operations' stamp: 'len 5/11/2019 07:58:41'!
negated
	^ self subclassResponsibility! !

!ModuleElement methodsFor: 'testing' stamp: 'len 5/6/2019 03:43:47'!
isZero
	^ self = self parent zero! !

!Sum methodsFor: 'accessing' stamp: 'len 1/10/2018 21:04:34'!
at: anObject
	^ coefficients at: anObject ifAbsent: [self scalars zero]! !

!Sum methodsFor: 'accessing' stamp: 'len 11/18/2016 10:02:25'!
at: key add: value
	^ coefficients at: key addAndRemoveIfZero: value! !

!Sum methodsFor: 'accessing' stamp: 'len 11/18/2016 17:29:29'!
at: anObject ifAbsent: aBlock
	^ coefficients at: anObject ifAbsent: aBlock! !

!Sum methodsFor: 'accessing' stamp: 'len 11/18/2016 17:29:44'!
at: anObject ifPresent: aBlock
	^ coefficients at: anObject ifPresent: aBlock! !

!Sum methodsFor: 'accessing' stamp: 'len 11/18/2016 17:27:44'!
at: key put: value
	value isZero ifTrue: [coefficients removeKey: key ifAbsent: []. ^ value].
	^ coefficients at: key put: value! !

!Sum methodsFor: 'accessing' stamp: 'len 11/18/2016 09:53:40'!
bitSize
	| answer |
	answer _ 0.
	coefficients keysAndValuesDo: [:key :value| answer _ answer + key bitSize + value bitSize].
	^ answer! !

!Sum methodsFor: 'accessing' stamp: 'len 4/23/2018 21:08:15'!
denominator
	| answer |
	self scalars isLocalization ifFalse: [^ self scalars one].
	answer _ self scalars integers one.
	self do: [:each| answer _ each denominator lcm: answer].
	^ answer! !

!Sum methodsFor: 'accessing' stamp: 'len 11/18/2016 20:33:21'!
keys
	^ coefficients keys! !

!Sum methodsFor: 'accessing' stamp: 'len 4/23/2018 20:28:58'!
lift
	"If the coefficients ring is a quotient R/I, answer a representative of the receiver over R. See >>%."
	^ self apply: self scalars lifting! !

!Sum methodsFor: 'accessing' stamp: 'len 4/23/2018 21:08:38'!
numerator
	self scalars isLocalization ifFalse: [^ self].
	^ self * self denominator over: self scalars integers! !

!Sum methodsFor: 'accessing' stamp: 'len 1/10/2018 21:04:16'!
parent
	^ parent! !

!Sum methodsFor: 'accessing' stamp: 'len 4/23/2018 20:40:20'!
representative
	"If the coefficients ring is a quotient R/I, answer a representative of the receiver over R. See >>%."
	^ self apply: self scalars projection section! !

!Sum methodsFor: 'accessing' stamp: 'len 1/10/2018 19:57:14'!
scalars
	^ parent scalars! !

!Sum methodsFor: 'accessing' stamp: 'len 11/18/2016 09:55:05'!
size
	^ coefficients size! !

!Sum methodsFor: 'accessing' stamp: 'len 1/10/2018 21:09:50'!
zero
	^ parent zero! !

!Sum methodsFor: 'comparing' stamp: 'len 12/21/2017 17:55:47'!
= aFormalSum
	^ coefficients = aFormalSum coefficients! !

!Sum methodsFor: 'comparing' stamp: 'len 11/18/2016 20:11:39'!
hash
	^ coefficients hash! !

!Sum methodsFor: 'converting' stamp: 'len 1/10/2018 21:09:44'!
over: aRing
	| newCoefficients |
	self scalars = aRing ifTrue: [^ self].
	newCoefficients _ Dictionary new: self size.
	self associationsDo: [:each| | newValue |
		(newValue _ aRing !! each value) isZero
			ifFalse: [newCoefficients add: (each copy value: newValue)]].
	^ (self class coefficients: newCoefficients) parent: (parent over: aRing)! !

!Sum methodsFor: 'enumreating' stamp: 'len 11/18/2016 09:54:31'!
associationsDo: aBlock
	coefficients associationsDo: aBlock! !

!Sum methodsFor: 'enumreating' stamp: 'len 1/10/2018 21:43:05'!
coefficientsDo: aBlock
	coefficients do: aBlock! !

!Sum methodsFor: 'enumreating' stamp: 'len 1/10/2018 21:22:05'!
collect: aBlock 
	| newCoefficients |
	newCoefficients _ Dictionary new: self size.
	self associationsDo: [:each| | newValue |
		(newValue _ aBlock value: each value) isZero ifFalse: [newCoefficients at: each key put: newValue]].
	^ (self class coefficients: newCoefficients) parent: parent! !

!Sum methodsFor: 'enumreating' stamp: 'len 11/18/2016 09:54:10'!
collectNoZero: aBlock
	"The result of aBlock must never be zero."
	^ self copy associationsDo: [:each| each value: (aBlock value: each value)]! !

!Sum methodsFor: 'enumreating' stamp: 'len 11/18/2016 20:24:16'!
do: aBlock
	coefficients do: aBlock! !

!Sum methodsFor: 'enumreating' stamp: 'len 11/18/2016 17:45:00'!
keysAndValuesDo: aBlock
	coefficients keysAndValuesDo: aBlock! !

!Sum methodsFor: 'enumreating' stamp: 'len 11/18/2016 17:45:38'!
keysDo: aBlock
	coefficients keysDo: aBlock! !

!Sum methodsFor: 'enumreating' stamp: 'len 11/18/2016 09:57:30'!
withIndexDo: elementAndIndexBlock 
	"Just like with:do: except that the iteration index supplies the second argument to the block."
	coefficients keysAndValuesDo: [:key :value| elementAndIndexBlock value: value value: key]! !

!Sum methodsFor: 'operations' stamp: 'len 11/18/2016 09:51:39'!
* aNumber
	^ self collect: [:each| each*aNumber]! !

!Sum methodsFor: 'operations' stamp: 'len 5/6/2019 02:56:21'!
+ aSum
	| other answer |
	self size <= aSum size
		ifTrue: [answer _ aSum copy. other _ self]
		ifFalse: [answer _ self copy. other _ aSum].
	other associationsDo: [:each| answer at: each key add: each value].
	^ answer! !

!Sum methodsFor: 'operations' stamp: 'len 5/6/2019 02:56:07'!
- aSum
	| answer |
	self size <= aSum size
		ifTrue:
			[answer _ aSum negated.
			self associationsDo: [:each| answer at: each key add: each value]]
		ifFalse:
			[answer _ self copy.
			aSum associationsDo: [:each| answer at: each key add: each value negated]].
	^ answer! !

!Sum methodsFor: 'operations' stamp: 'len 2/6/2017 03:13:39'!
/ aNumber
	^ self collect: [:each| each / aNumber]! !

!Sum methodsFor: 'operations' stamp: 'len 2/6/2017 03:13:44'!
// aNumber
	^ self collect: [:each| each // aNumber]! !

!Sum methodsFor: 'operations' stamp: 'len 2/6/2017 03:13:48'!
/// aNumber
	^ self collect: [:each| each /// aNumber]! !

!Sum methodsFor: 'operations' stamp: 'len 2/6/2017 03:15:23'!
\\ aNumber
	^ self collect: [:each| each \\ aNumber]! !

!Sum methodsFor: 'operations' stamp: 'len 5/6/2019 02:55:32'!
 aSum
	| answer |
	self size <= aSum size ifFalse: [^ aSum  self].
	answer _ self scalars zero.
	coefficients associationsDo: [:each|
		aSum at: each key ifPresent: [:value2| answer _ answer + (each value*value2)]].
	^ answer! !

!Sum methodsFor: 'operations' stamp: 'len 1/10/2018 21:09:39'!
convolution: aFormalSum
	| newCoefficients |
	newCoefficients _ Dictionary new: self size + aFormalSum size.
	self associationsDo: [:each|
		aFormalSum associationsDo: [:other|
			newCoefficients at: each key * other key addAndRemoveIfZero: each value * other value]].
	^ (self class coefficients: newCoefficients) parent: parent! !

!Sum methodsFor: 'operations' stamp: 'len 5/6/2019 02:55:06'!
hadamard: aSum
	"Answer the pointwise product with the argument, also called Hadamard product."
	| answer |
	self size <= aSum size ifFalse: [^ aSum hadamard: self]. "assuming it's commutative"
	answer _ self copyEmpty.
	coefficients associationsDo: [:each| | key |
		key _ each key.
		answer at: key put: each value * (aSum at: key)].
	^ answer! !

!Sum methodsFor: 'operations' stamp: 'len 11/18/2016 09:57:04'!
negated
	^ self collectNoZero: [:each| each negated]! !

!Sum methodsFor: 'printing' stamp: 'len 2/25/2017 09:43:39'!
printCoefficient: coefficient on: aStream
	| c |
	((c _ coefficient) printString first = $- "or: [coefficient isNumber and: [coefficient negative]]")
		ifTrue: [aStream nextPut: $-. c _ c negated].
	((c isKindOf: Polynomial) and: [c isMonomial])
		ifTrue: [aStream print: c. ^ self].
	(c printString allSatisfy: [:each| each isAlphaNumeric or: ['{}()/' includes: each]])
		ifTrue: [aStream print: c. ^ self].
	aStream nextPut: $(; print: c; nextPut: $)! !

!Sum methodsFor: 'printing' stamp: 'len 2/28/2017 08:43:47'!
printLiteral: anObject on: aStream
	((anObject isKindOf: Word) and: [anObject isEmpty])
		ifTrue: [^ self].
	anObject isInteger
		ifTrue:
			[aStream isText
				ifTrue: [aStream nextPut: $x; nextPutAll: anObject printString sub]
				ifFalse: [aStream nextPutAll: '{x', anObject printString, '}'].
			^ self].
	(aStream isText and: [anObject isString])
			ifTrue: [aStream nextPutAll: anObject asText]
			ifFalse: [aStream print: anObject]! !

!Sum methodsFor: 'printing' stamp: 'len 2/25/2017 08:38:18'!
printOn2: aStream
	aStream nextPut: $(.
	(Iterator on: self performing: #associationsDo:)
		do: [:each| aStream print: each] separatedBy: [aStream nextPutAll: ', '].
	aStream nextPut: $)! !

!Sum methodsFor: 'testing' stamp: 'len 11/18/2016 09:56:53'!
isZero
	^ coefficients isEmpty! !

!Sum methodsFor: 'private' stamp: 'len 11/18/2016 20:11:53'!
coefficients
	^ coefficients! !

!Sum methodsFor: 'private' stamp: 'len 9/16/2018 16:12:06'!
coefficients: aDictionary
	coefficients _ aDictionary.
	coefficients associationsDo: [:each| each value isZero ifTrue: [self error: 'the coefficinets dictionary contains zeroes']]! !

!Sum methodsFor: 'private' stamp: 'len 1/10/2018 21:04:09'!
parent: aDomain
	parent _ aDomain! !

!Sum class methodsFor: 'instance creation' stamp: 'len 1/10/2018 19:58:32'!
associations: aCollection
	^ self coefficients: (aCollection as: Dictionary)! !

!Sum class methodsFor: 'instance creation' stamp: 'len 1/10/2018 19:58:43'!
coefficients: aDictionary
	^ self basicNew coefficients: aDictionary! !

!Sum class methodsFor: 'instance creation' stamp: 'len 9/16/2018 16:12:13'!
new
	^ self coefficients: Dictionary new! !

!Sum class methodsFor: 'instance creation' stamp: 'len 1/10/2018 19:58:56'!
new: anInteger
	^ self coefficients: (Dictionary new: anInteger)! !

!Tensor methodsFor: 'converting' stamp: 'len 9/22/2018 22:07:17'!
asSimpleTensor
	"Answer an array of basis elements."
	self size = 1 ifFalse: [^ self error: 'not a simple tensor'].
	self keysAndValuesDo: [:any| ^ (any withIndexCollect: [:i :j| (parent at: j) e: i])].
	^ self halt! !

!Tensor methodsFor: 'operations' stamp: 'len 5/14/2019 20:50:19'!
 aTensor
	^ self parent  aTensor parent compose: {self. aTensor}! !

!Tensor methodsFor: 'printing' stamp: 'len 9/16/2018 16:17:28'!
printLiteral: anArray on: aStream
	(1 to: anArray size) do: [:i| aStream nextPutAll: ((parent at: i) names at: (anArray at: i))] separatedBy: [aStream nextPut: Character otimes]! !

!Divisor methodsFor: 'accessing' stamp: 'len 1/10/2018 21:59:43'!
degree
	| answer |
	answer _ 0.
	self coefficientsDo: [:each| answer _ answer + each].
	^ answer! !

!Divisor methodsFor: 'accessing' stamp: 'len 5/10/2019 04:36:00'!
support
	| answer |
	answer _ nil. "should start from the empty variety"
	self keysDo: [:each| answer _ answer ifNil: [each] ifNotNil: [answer \/ each]].
	^ answer! !

!Divisor methodsFor: 'comparing' stamp: 'len 1/11/2017 16:34:02'!
<= aDivisor
	^ (aDivisor - self) isEffective! !

!Divisor methodsFor: 'comparing' stamp: 'len 1/2/2017 15:43:41'!
= anObject
	^ (anObject isKindOf: Divisor) and: [self ~ anObject]! !

!Divisor methodsFor: 'comparing' stamp: 'len 10/27/2016 10:26'!
>= aDivisor
	^ (self - aDivisor) isEffective! !

!Divisor methodsFor: 'comparing' stamp: 'len 1/2/2017 15:43:29'!
~ aDivisor
	"Answer true if the receiver and the argument are linearly equivalent."
	^ (self - aDivisor) isPrincipal! !

!Divisor methodsFor: 'operations' stamp: 'len 1/10/2018 21:58:23'!
gcd: aDivisor
	| newCoefficients |
	newCoefficients _ Dictionary new.
	self keysAndValuesDo: [:key :value|
		aDivisor at: key ifPresent: [:value2| newCoefficients at: key put: (value min: value2)]].
	^ (self class coefficients: newCoefficients) parent: parent! !

!Divisor methodsFor: 'operations' stamp: 'len 2/25/2017 09:09:10'!
lcm: aDivisor
	| answer |
	answer _ self copy.
	aDivisor keysAndValuesDo: [:key :value|
		answer at: key put: ((self at: key) max: value)].
	^ answer! !

!Divisor methodsFor: 'testing' stamp: 'len 2/25/2017 09:09:25'!
isEffective
	^ self allSatisfy: [:each| each positive]! !

!SimplicialChain methodsFor: 'accessing' stamp: 'len 2/25/2017 09:26:39'!
dimension
	self keysDo: [:any| ^ any dimension].
	^ -1! !

!SimplicialChain methodsFor: 'operations' stamp: 'len 2/25/2017 09:26:29'!
boundary
	"The boundary of a chain is the linear combination of the boundary of the simplices in the chain. The boundary of a k-chain is a (k-1)-chain."
	| answer |
	self dimension <= 0 ifTrue: [^ self zero].
	answer _ self class over: self scalars.
	self keysAndValuesDo: [:key :value|
		| V minusValue |
		V _ key vertices asArray.
		minusValue _ value negated.
		1 to: V size do: [:i| | F |
			"F is the facet opposite the i-th vertex:"
			F _ Simplex vertices: (V copyWithoutIndex: i).
			answer at: F add: (i odd ifTrue: [value] ifFalse: [minusValue])]].
	^ answer! !

!SimplicialChain methodsFor: 'testing' stamp: 'len 2/23/2016 03:33'!
isCycle
	^ self boundary isZero! !

!FreePolynomial methodsFor: 'accessing' stamp: 'len 3/3/2016 05:27'!
degree
	"Answer the total degree of the receiver."
	self isZero ifTrue: [^ Infinity negative].
	^ self monomials max: [:each| each length]! !

!FreePolynomial methodsFor: 'accessing' stamp: 'len 1/10/2018 13:29:49'!
leadingCoefficient
	^ self at: self leadingMonomial! !

!FreePolynomial methodsFor: 'accessing' stamp: 'len 1/10/2018 13:29:36'!
leadingMonomial
	^ self monomials asSortedCollection first! !

!FreePolynomial methodsFor: 'accessing' stamp: 'len 1/10/2018 16:56:38'!
monomials
	^ Iterator on: self performing: #monomialsDo:! !

!FreePolynomial methodsFor: 'accessing' stamp: 'len 1/10/2018 16:56:11'!
monomialsDo: aBlock
	self keysDo: aBlock! !

!FreePolynomial methodsFor: 'accessing' stamp: 'len 1/10/2018 20:07:45'!
one
	^ self parent one! !

!FreePolynomial methodsFor: 'arithmetic' stamp: 'len 1/10/2018 21:49:36'!
* anObject
	((self scalars includes: anObject) or: [anObject isInteger])
		ifTrue: [^ super * anObject].
	(self parent includes: anObject)
		ifTrue: [^ self convolution: anObject].
	(self parent words includes: anObject)
		ifTrue: [^ self multipliedByMonomial: anObject].
	^ DomainError signal! !

!FreePolynomial methodsFor: 'arithmetic' stamp: 'len 2/25/2017 07:53:00'!
^ anInteger
	"Answer the receiver raised to the power anInteger."
	(anInteger isInteger and: [anInteger >= 0])
		ifFalse: [^ DomainError signal: 'undefinted'].
	anInteger = 0 ifTrue: [^ self one].
	anInteger = 1 ifTrue: [^ self].
	^ self squared ^ (anInteger // 2) * (self ^ (anInteger \\ 2))! !

!FreePolynomial methodsFor: 'arithmetic' stamp: 'len 1/10/2018 20:18:46'!
multipliedByMonomial: aWord
	| newCoefficients |
	newCoefficients _ Dictionary new: self size.
	self associationsDo: [:each| newCoefficients at: each key * aWord put: each value].
	^ self parent coefficients: newCoefficients! !

!FreePolynomial methodsFor: 'arithmetic' stamp: 'len 3/2/2016 05:35'!
squared
	^ self * self! !

!FreePolynomial methodsFor: 'testing' stamp: 'len 1/10/2018 16:57:08'!
isStandard
	"Answer true if the receiver is a standard polynomial, i.e. all its monomials are standard words."
	self monomialsDo: [:each| each isStandard ifFalse: [^ false]].
	^ true! !

!GroupAlgebraElement methodsFor: 'accessing' stamp: 'len 1/10/2018 21:44:03'!
one
	^ self parent one! !

!GroupAlgebraElement methodsFor: 'arithmetic' stamp: 'len 1/10/2018 21:39:42'!
* anObject
	((self scalars includes: anObject) or: [anObject isInteger])
		ifTrue: [^ super * anObject].
	(self parent includes: anObject)
		ifTrue: [^ self convolution: anObject].
	(self parent group includes: anObject)
		ifTrue: [^ self multipliedByGroupElement: anObject].
	^ DomainError signal! !

!GroupAlgebraElement methodsFor: 'arithmetic' stamp: 'len 2/25/2017 07:52:41'!
^ anInteger
	"Answer the receiver raised to the power anInteger."
	(anInteger isInteger and: [anInteger >= 0])
		ifFalse: [^ DomainError signal: 'undefinted'].
	anInteger = 0 ifTrue: [^ self one].
	anInteger = 1 ifTrue: [^ self].
	^ self squared ^ (anInteger // 2) * (self ^ (anInteger \\ 2))! !

!GroupAlgebraElement methodsFor: 'arithmetic' stamp: 'len 1/10/2018 21:41:04'!
multipliedByGroupElement: aGroupElement
	| newCoefficients |
	newCoefficients _ Dictionary new: self size.
	self associationsDo: [:each| newCoefficients at: each key * aGroupElement put: each value].
	^ self parent coefficients: newCoefficients! !

!GroupAlgebraElement methodsFor: 'arithmetic' stamp: 'len 2/25/2017 07:56:11'!
squared
	^ self * self! !

!GroupAlgebraElement methodsFor: 'converting' stamp: 'len 9/16/2018 16:13:55'!
asFunction
	^ Function from: parent group to: parent scalars evaluating: [:each| self at: each]! !

!GroupAlgebraElement methodsFor: 'operations' stamp: 'len 1/10/2018 21:42:35'!
augmentation
	| answer |
	answer _ self scalars zero.
	self coefficientsDo: [:each| answer _ answer + each].
	^ answer! !

!GroupAlgebraElement methodsFor: 'operations' stamp: 'len 5/6/2019 02:54:24'!
convolution: aFormalSum
	| newCoefficients |
	newCoefficients _ Dictionary new: self size + aFormalSum size.
	self associationsDo: [:each|
		aFormalSum associationsDo: [:other|
			newCoefficients at: each key  other key addAndRemoveIfZero: each value * other value]].
	^ (self class coefficients: newCoefficients) parent: parent! !

!GroupAlgebraElement methodsFor: 'operations' stamp: 'len 1/11/2018 15:13:06'!
value: aGroupElement
	"The elements of the group ring R[G] are essentially the finite-support functions from G to R."
	^ self at: aGroupElement! !

!GroupAlgebraElement class methodsFor: 'instance creation' stamp: 'len 2/25/2017 09:18:07'!
coefficients: aFormalSum
	^ self basicNew coefficients: aFormalSum! !

!Tuple methodsFor: 'accessing' stamp: 'len 11/18/2016 20:21:46'!
at: index ifAbsent: exceptionBlock
	"Answer the element at my position index. If I do not contain an element
	at index, answer the result of evaluating the argument, exceptionBlock."

	(index between: 1 and: self size) ifTrue: [^ self at: index].
	^ exceptionBlock value! !

!Tuple methodsFor: 'accessing' stamp: 'len 3/29/2016 18:54'!
bitSize
	| answer |
	answer _ 0.
	self do: [:each| answer _ answer + each bitSize].
	^ answer! !

!Tuple methodsFor: 'accessing' stamp: 'len 4/21/2018 23:08:36'!
denominator
	| answer |
	self scalars isLocalization ifFalse: [^ self scalars one].
	answer _ self scalars integers one.
	self do: [:each| answer _ each denominator lcm: answer].
	^ answer! !

!Tuple methodsFor: 'accessing' stamp: 'len 11/5/2016 09:26'!
first
	^ self at: 1! !

!Tuple methodsFor: 'accessing' stamp: 'len 11/6/2016 04:32'!
last
	^ self at: self size! !

!Tuple methodsFor: 'accessing' stamp: 'len 11/12/2016 09:03'!
lastNonZero
	"Answer the index of the last non-zero entry, or 0."
	self size to: 1 by: -1 do: [:i| (self at: i) isZero ifFalse: [^ i]].
	^ 0! !

!Tuple methodsFor: 'accessing' stamp: 'len 5/3/2018 02:46:42'!
lastNonZeroDivisor
	"Answer the index of the last non zero-divisor entry, or 0."
	self size to: 1 by: -1 do: [:i| (self scalars isZeroDivisor: (self at: i)) ifFalse: [^ i]].
	^ 0! !

!Tuple methodsFor: 'accessing' stamp: 'len 4/23/2018 20:34:26'!
lift
	"If the coefficients ring is a quotient R/I, answer a representative of the receiver over R. See >>%."
	^ self apply: self scalars lifting! !

!Tuple methodsFor: 'accessing' stamp: 'len 4/21/2018 23:11:10'!
numerator
	self scalars isLocalization ifFalse: [^ self].
	^ self * self denominator over: self scalars integers! !

!Tuple methodsFor: 'accessing' stamp: 'len 5/8/2019 04:06:02'!
parent
	"Answer the tuple module where the receiver lives."
	^ self scalars ^ self size! !

!Tuple methodsFor: 'accessing' stamp: 'len 5/8/2019 04:06:16'!
scalars
	"Answer the ring of scalars (or ring of coefficients) of the receiver."
	^ self subclassResponsibility! !

!Tuple methodsFor: 'accessing' stamp: 'len 3/29/2016 19:06'!
x
	^ self at: 1! !

!Tuple methodsFor: 'accessing' stamp: 'len 3/29/2016 19:06'!
y
	^ self at: 2! !

!Tuple methodsFor: 'accessing' stamp: 'len 3/29/2016 19:06'!
z
	^ self at: 3! !

!Tuple methodsFor: 'accessing' stamp: 'len 5/26/2018 17:35:54'!
zero
	^ self apply: [:each| each zero]! !

!Tuple methodsFor: 'comparing' stamp: 'len 3/28/2018 18:08:44'!
= anObject
	self == anObject ifTrue: [^ true].
	anObject isTuple ifFalse: [^ false].
	self size = anObject size ifFalse: [^ false].
	1 to: self size do: [:i|
		(self at: i) = (anObject at: i) ifFalse: [^ false]].
	^ true! !

!Tuple methodsFor: 'comparing' stamp: 'len 5/2/2019 09:49:14'!
~ aTuple
	"Answer true if the receiver and the argument are equivalent as homogeneous tuples."
	| index x y |
	self scalars isIntegralDomain ifFalse: [^ self scalars units anySatisfy: [:any| self * any = aTuple]].
	index _ self lastNonZero.
	index = 0 ifTrue: [^ false].
	x _ self at: index.
	y _ aTuple at: index.
	y isZero ifTrue: [^ false].
	1 to: self size do: [:i|
		(self at: i) * y = ((aTuple at: i) * x) ifFalse: [^ false]].
	^ true! !

!Tuple methodsFor: 'comparing' stamp: 'len 11/5/2016 09:41'!
hash
	| hash |
	hash _ 0.
	1 to: self size do: [:i | hash _ (hash + (self at: i) hash) hashMultiply].
	^hash! !

!Tuple methodsFor: 'converting' stamp: 'len 5/30/2019 07:08:25'!
: aTupleOrMatrix
	^ self asColumnMatrix : aTupleOrMatrix! !

!Tuple methodsFor: 'converting' stamp: 'len 11/8/2016 07:19'!
adaptToCollection: aCollection andSend: selector
	self size = aCollection size ifFalse: [^ self error: 'sizes don''t match'].
	^ aCollection withIndexCollect: [:each :index| each perform: selector with: (self at: index)]! !

!Tuple methodsFor: 'converting' stamp: 'len 11/5/2016 09:46'!
asArray
	^ self as: Array! !

!Tuple methodsFor: 'converting' stamp: 'len 3/13/2018 18:48:27'!
asColumnMatrix
	^ Matrix columns: {self}! !

!Tuple methodsFor: 'converting' stamp: 'len 3/13/2018 18:48:37'!
asRowMatrix
	^ Matrix rows: {self}! !

!Tuple methodsFor: 'converting' stamp: 'len 11/7/2016 13:48'!
asTuple
	^ self! !

!Tuple methodsFor: 'converting' stamp: 'len 10/31/2016 13:11'!
homogenized
	^ self homogenizedIn: self size + 1! !

!Tuple methodsFor: 'converting' stamp: 'len 4/11/2018 07:00:03'!
homogenizedIn: anInteger
	^ (self copyFrom: 1 to: anInteger - 1), self scalars one, (self copyFrom: anInteger to: self size)! !

!Tuple methodsFor: 'converting' stamp: 'len 1/3/2017 07:47:52'!
over: aRing
	self scalars = aRing ifFalse: [^ aRing tuple: self size evaluating: [:i| aRing !! (self at: i)]]! !

!Tuple methodsFor: 'converting' stamp: 'len 12/13/2016 16:49:22'!
readStream
	^ ReadStream on: self! !

!Tuple methodsFor: 'enumerating' stamp: 'len 11/5/2016 07:06'!
allSatisfy: aBlock
	"Evaluate aBlock with the elements of the receiver.
	If aBlock returns false for any element return false.
	Otherwise return true."

	self do: [:each | (aBlock value: each) ifFalse: [^ false]].
	^ true! !

!Tuple methodsFor: 'enumerating' stamp: 'len 11/5/2016 09:09'!
anySatisfy: aBlock
	"Evaluate aBlock with the elements of the receiver.
	If aBlock returns true for any element return true.
	Otherwise return false"

	self do:[:item | (aBlock value: item) ifTrue: [^ true]].
	^ false! !

!Tuple methodsFor: 'enumerating' stamp: 'len 11/5/2016 06:46'!
collect: aBlock
	^ self scalars tuple: self size evaluating: [:i| aBlock value: (self at: i)]! !

!Tuple methodsFor: 'enumerating' stamp: 'len 11/5/2016 09:43'!
count: aBlock
	| count |
	count _ 0.
	self do: [:each| (aBlock value: each) ifTrue: [count _ count + 1]].
	^ count! !

!Tuple methodsFor: 'enumerating' stamp: 'len 11/5/2016 06:46'!
do: aBlock
	1 to: self size do: [:each| aBlock value: (self at: each)]! !

!Tuple methodsFor: 'enumerating' stamp: 'len 11/5/2016 09:26'!
do: elementBlock separatedBy: separatorBlock
	| beforeFirst | 
	"Evaluate the elementBlock for all elements in the receiver,
	and evaluate the separatorBlock between."

	beforeFirst _ true.
	self do: [ :element |
		beforeFirst
			ifTrue: [beforeFirst _ false]
			ifFalse: [separatorBlock value].
		elementBlock value: element]! !

!Tuple methodsFor: 'enumerating' stamp: 'len 11/12/2016 08:51'!
findFirst: aBlock
	"Return the index of my first element for which aBlock evaluates as true."

	| index |
	index _ 0.
	[(index _ index + 1) <= self size] whileTrue:
		[(aBlock value: (self at: index)) ifTrue: [^index]].
	^ 0! !

!Tuple methodsFor: 'enumerating' stamp: 'len 11/5/2016 07:05'!
findLast: aBlock
	"Return the index of my last element for which aBlock evaluates as true."

	| index |
	index _ self size + 1.
	[(index _ index - 1) >= 1] whileTrue:
		[(aBlock value: (self at: index)) ifTrue: [^index]].
	^ 0! !

!Tuple methodsFor: 'enumerating' stamp: 'len 11/5/2016 06:48'!
inject: thisValue into: binaryBlock 
	| nextValue |
	nextValue _ thisValue.
	self do: [:each | nextValue _ binaryBlock value: nextValue value: each].
	^ nextValue! !

!Tuple methodsFor: 'enumerating' stamp: 'len 11/6/2016 14:22'!
product
	^ self product: [:each| each]! !

!Tuple methodsFor: 'enumerating' stamp: 'len 12/13/2016 09:55:53'!
product: aBlock
	^ self inject: self scalars one into: [:nextValue :each| nextValue * (aBlock value: each)]! !

!Tuple methodsFor: 'enumerating' stamp: 'len 11/5/2016 06:47'!
reverseDo: aBlock
	self size to: 1 by: -1 do: [:each| aBlock value: (self at: each)]! !

!Tuple methodsFor: 'enumerating' stamp: 'len 11/6/2016 14:22'!
sum
	^ self sum: [:each| each]! !

!Tuple methodsFor: 'enumerating' stamp: 'len 12/13/2016 09:55:29'!
sum: aBlock
	^ self inject: self scalars zero into: [:nextValue :each| nextValue + (aBlock value: each)]! !

!Tuple methodsFor: 'enumerating' stamp: 'len 11/5/2016 06:59'!
withIndexCollect: aBlock
	^ self scalars tuple: self size evaluating: [:i| aBlock value: (self at: i) value: i]! !

!Tuple methodsFor: 'enumerating' stamp: 'len 11/5/2016 06:47'!
withIndexDo: aBlock
	1 to: self size do: [:index| aBlock value: (self at: index) value: index]! !

!Tuple methodsFor: 'operations' stamp: 'len 5/7/2019 17:26:48'!
% anInteger
	| R |
	self flag: #fix. "optimize. this is slow because creates lots of residue class objects"
	R _ ZZ % anInteger.
	^ R tuple: self size evaluating: [:i| R project: (self at: i)]! !

!Tuple methodsFor: 'operations' stamp: 'len 5/16/2019 04:11:35'!
* anObject
	anObject isMatrix ifTrue: [^ (self asRowMatrix * anObject) asTuple].
	anObject isTuple ifTrue: [^ self  anObject].
"	(self scalars includes: anObject) ifFalse: [^ DomainError signal]."
	^ self collect: [:each| each * anObject]! !

!Tuple methodsFor: 'operations' stamp: 'len 11/6/2016 14:21'!
- aTuple
	^ self + aTuple negated! !

!Tuple methodsFor: 'operations' stamp: 'len 5/16/2019 04:00:54'!
/ anObject
	"Answer X such that X * A = B, where B is self and A is the argument.
	If the argument is a scalr, just divide each element of the tuple by it."
	anObject isMatrix ifTrue: [^ anObject solveLeft: self].
	^ self * anObject reciprocal! !

!Tuple methodsFor: 'operations' stamp: 'len 3/29/2016 18:50'!
// aNumber
	^ self collect: [:each| each // aNumber]! !

!Tuple methodsFor: 'operations' stamp: 'len 2/6/2017 03:11:48'!
/// aNumber
	^ self collect: [:each| each /// aNumber]! !

!Tuple methodsFor: 'operations' stamp: 'len 3/29/2016 19:02'!
<< anInteger
	^ self >> anInteger negated! !

!Tuple methodsFor: 'operations' stamp: 'len 3/29/2016 18:45'!
<<< anInteger
	^ self >>> anInteger negated! !

!Tuple methodsFor: 'operations' stamp: 'len 5/4/2019 07:44:27'!
>>> anInteger
	anInteger == 0 ifTrue: [^ self].
	anInteger < 0 ifTrue: [^ self copyFrom: anInteger negated + 1 to: self size].
	^ (self scalars zeroTuple: anInteger), self! !

!Tuple methodsFor: 'operations' stamp: 'len 2/6/2017 03:15:07'!
\\ aNumber
	^ self collect: [:each| each \\ aNumber]! !

!Tuple methodsFor: 'operations' stamp: 'len 4/29/2019 10:20:04'!
 aTuple
	| answer |
	answer _ (self at: 1) * (aTuple at: 1).
	2 to: (self size min: aTuple size) do: [:i| answer _ answer + ((self at: i) * (aTuple at: i))].
	^ answer! !

!Tuple methodsFor: 'operations' stamp: 'len 5/14/2019 20:50:30'!
 aTuple
	^ self scalars matrix: self size @ aTuple size evaluating: [:i :j| (self at: i)*(aTuple at: j)]! !

!Tuple methodsFor: 'operations' stamp: 'len 6/6/2019 09:45:07'!
add: aTuple shifted: delta from: startIndex to: stopIndex
	startIndex to: stopIndex do: [:i| self at: i add: (aTuple at: i-delta)]! !

!Tuple methodsFor: 'operations' stamp: 'len 5/30/2019 07:23:04'!
add: aTuple times: aNumber
	self add: aTuple times: aNumber startingAt: 1! !

!Tuple methodsFor: 'operations' stamp: 'len 6/6/2019 09:45:24'!
add: aTuple times: aNumber from: startIndex to: stopIndex
	startIndex to: stopIndex do: [:i| self at: i add: (aTuple at: i) * aNumber]! !

!Tuple methodsFor: 'operations' stamp: 'len 5/30/2019 07:10:41'!
add: aTuple times: aNumber startingAt: startIndex
	self add: aTuple times: aNumber from: startIndex to: (self size min: aTuple size)! !

!Tuple methodsFor: 'operations' stamp: 'len 11/7/2016 02:24'!
apply: aMorphism
	"Apply a homomorphism to the coefficients of the receiver."
	aMorphism isBlock ifTrue: [^ self collect: aMorphism].
	^ aMorphism codomain tuple: self size evaluating: [:i| aMorphism value: (self at: i)]! !

!Tuple methodsFor: 'operations' stamp: 'len 3/29/2016 18:54'!
conjugated
	^ self collect: [:each| each conjugated]! !

!Tuple methodsFor: 'operations' stamp: 'len 9/22/2018 19:00:32'!
content
	"Answer the GCD of the coefficients of the receiver.
	In a field, it is convenient to define the content as 1."
	| answer |
	self scalars isField
		ifTrue:
			[^ self scalars isFractionRing
				ifTrue:
					[| c |
					c _ self coefficients inject: self scalars one into: [:lcm :each| lcm lcm: each denominator].
					(self coefficients inject: self scalars zero into: [:gcd :each| gcd gcd: each * c]) / c]
				ifFalse: [self scalars one]].
	answer _ self scalars zero.
	self coefficients do: [:each| answer _ answer gcd: each].
	^ answer! !

!Tuple methodsFor: 'operations' stamp: 'len 11/12/2016 08:18'!
hadamard: aTuple
	"Answer the entrywise product with the argument, also called Hadamard product."
	^ self scalars tuple: (self size min: aTuple size) evaluating: [:i| (self at: i) * (aTuple at: i)]! !

!Tuple methodsFor: 'operations' stamp: 'len 11/27/2016 13:25:12'!
height
	| answer |
	answer _ 1.
	self do: [:each| answer _ answer max: each height].
	^ answer! !

!Tuple methodsFor: 'operations' stamp: 'len 1/16/2018 22:02:42'!
multiplyBy: aNumber
	self multiplyBy: aNumber startingAt: 1! !

!Tuple methodsFor: 'operations' stamp: 'len 1/16/2018 22:03:27'!
multiplyBy: aNumber from: startIndex to: stopIndex
	startIndex to: stopIndex do: [:i|
		self at: i put: (self at: i) * aNumber]! !

!Tuple methodsFor: 'operations' stamp: 'len 1/16/2018 22:01:18'!
multiplyBy: aNumber startingAt: startIndex
	self multiplyBy: aNumber from: startIndex to: self size! !

!Tuple methodsFor: 'operations' stamp: 'len 3/29/2016 18:56'!
negated
	^ self collect: [:each| each negated]! !

!Tuple methodsFor: 'operations' stamp: 'len 3/29/2016 19:03'!
norm
	^ self norm2 squareRoot! !

!Tuple methodsFor: 'operations' stamp: 'len 4/29/2019 10:22:16'!
norm2
	^ self  self! !

!Tuple methodsFor: 'operations' stamp: 'len 5/26/2018 17:40:04'!
polynomialDivisionBy: aTuple
	| quo rem lc n m |
	aTuple isZero ifTrue: [^ (ZeroDivide dividend: self) signal].
	quo _ self zero.
	rem _ self copy.
	m _ aTuple lastNonZero. "m = degree(self)+1"
	lc _ aTuple at: m.
	[(n _ rem lastNonZero) >= m] "n = degree(rem)+1"
		whileTrue:
			[| i c |
			i _ n-m+1.
			c _ (rem at: n) / lc.
			quo at: i put: (quo at: i) + c.
			1 to: m do: [:j| rem at: j+i-1 put: (rem at: j+i-1) - ((aTuple at: j)*c)]].
	^ {quo. rem}! !

!Tuple methodsFor: 'operations' stamp: 'len 11/23/2016 05:43:12'!
polynomialValue: anObject
	"Evaluate the receiver (as an univariate polynomial) at the given argument using Horner's method."
	| answer one |
	answer _ anObject zero.
	one _ anObject one.
	self reverseDo: [:each| answer _ anObject * answer + (one * each)].
	^ answer! !

!Tuple methodsFor: 'operations' stamp: 'len 9/22/2018 19:00:28'!
primitive
	"Answer the primitive part of the receiver."
	^ self isZero ifTrue: [self] ifFalse: [self /// self content]! !

!Tuple methodsFor: 'operations' stamp: 'len 11/5/2016 09:27'!
support
	^ (1 to: self size) reject: [:each| (self at: each) isZero]! !

!Tuple methodsFor: 'operations' stamp: 'len 11/12/2016 08:41'!
weight
	"Answer the Hamming weight of the receiver, i.e. the number of entries that are not zero."
	^ self count: [:each| each isZero not]! !

!Tuple methodsFor: 'operations' stamp: 'len 5/15/2019 14:16:18'!
wrap: n
	"Perform a cyclic right shift."
	^ self scalars tuple: self size evaluating: [:i| self at: i-1-n \\ self size + 1]! !

!Tuple methodsFor: 'printing' stamp: 'len 5/30/2019 16:16:24'!
isBroken
	^ (self allSatisfy: [:each| self scalars includes: each]) not! !

!Tuple methodsFor: 'printing' stamp: 'len 5/19/2018 19:44:02'!
printCoefficientsOn: aStream
	| separator |
	separator _ (self anySatisfy: [:any| any printString includesAnyOf: ', ']) ifTrue: [', '] ifFalse: [','].
	self do: [:x| aStream print: x] separatedBy: [aStream nextPutAll: separator]! !

!Tuple methodsFor: 'printing' stamp: 'len 5/30/2019 16:16:44'!
printText
	self isBroken ifTrue: [^ super printText addAttribute: TextColor red].
	^ super printText! !

!Tuple methodsFor: 'testing' stamp: 'len 11/5/2016 09:45'!
includes: anObject 
	"Answer whether anObject is one of the receiver's elements."

	self do: [:each| each = anObject ifTrue: [^ true]].
	^ false! !

!Tuple methodsFor: 'testing' stamp: 'len 3/29/2016 19:04'!
is: aSymbol
	^ aSymbol == #Tuple or: [super is: aSymbol]! !

!Tuple methodsFor: 'testing' stamp: 'len 11/5/2016 07:12'!
isEmpty
	^ self size = 0! !

!Tuple methodsFor: 'testing' stamp: 'len 5/22/2018 16:53:54'!
isSequenceable
	^ true! !

!Tuple methodsFor: 'testing' stamp: 'len 3/28/2018 18:01:30'!
isTuple
	^ true! !

!Tuple methodsFor: 'testing' stamp: 'len 3/29/2016 19:04'!
isZero
	^ self allSatisfy: [:each| each isZero]! !

!Tuple methodsFor: 'testing' stamp: 'len 12/1/2016 17:05:22'!
isZeroAt: anInteger
	^ (self at: anInteger) isZero! !

!Tuple methodsFor: 'private' stamp: 'len 6/6/2019 09:41:21'!
at: anInteger add: anElement
	^ self at: anInteger put: (self at: anInteger) + anElement! !

!BitTuple methodsFor: 'accessing' stamp: 'len 5/8/2019 02:58:37'!
at: anInteger
	^ (bits bitAt: anInteger) = 1 ifTrue: [One] ifFalse: [Zero]! !

!BitTuple methodsFor: 'accessing' stamp: 'len 5/8/2019 03:06:10'!
at: anInteger put: aBit
	| bit |
	anInteger > self size ifTrue: [self error: 'index out of bounds'].
	bit _ aBit.
	bit isInteger ifTrue: [bit _ bit even ifTrue: [Zero] ifFalse: [One]].
"		ifFalse: [(Zero = bit or: [One = bit]) ifFalse: [DomainError signal]]."
	(self at: anInteger) = bit
		ifFalse: [bits _ bits bitXor: 1 << (anInteger - 1)].
	^ bit! !

!BitTuple methodsFor: 'accessing' stamp: 'len 5/8/2019 03:06:26'!
representative
	"Answer a representative integer tuple."
	^ ZZ tuple: self size evaluating: [:i| bits bitAt: i]! !

!BitTuple methodsFor: 'accessing' stamp: 'len 5/4/2018 19:09:27'!
scalars
	^ One parent! !

!BitTuple methodsFor: 'accessing' stamp: 'len 5/8/2019 04:06:57'!
size
	^ size! !

!BitTuple methodsFor: 'comparing' stamp: 'len 5/8/2019 04:09:59'!
= aTuple
	self class = aTuple class ifFalse: [^ super = aTuple].
	^ size = aTuple size and: [bits = aTuple asInteger]! !

!BitTuple methodsFor: 'comparing' stamp: 'len 5/8/2019 03:06:15'!
hash
	^ bits hash! !

!BitTuple methodsFor: 'converting' stamp: 'len 5/8/2019 03:10:19'!
asInteger
	^ bits! !

!BitTuple methodsFor: 'copying' stamp: 'len 5/11/2019 08:55:20'!
, anObject
	anObject isTuple
		ifTrue: [^ self class new: self size + anObject size fromInteger: (bits bitXor: (anObject asInteger bitShift: self size))].
	anObject isArray
		ifTrue: [^ self , (self scalars tuple: anObject)].
	^ self copyWith: anObject! !

!BitTuple methodsFor: 'copying' stamp: 'len 5/8/2019 04:16:32'!
copyFrom: start to: stop 
	"Answer a copy of a subset of the receiver, starting from element at 
	index start until element at index stop."

	| newSize |
	newSize _ stop - start + 1 max: 0.
	start = 1 ifTrue: [^ self class new: newSize fromInteger: bits].
	^ self class new: newSize fromInteger: (bits bitShift: 1 - start)! !

!BitTuple methodsFor: 'copying' stamp: 'len 5/8/2019 04:17:05'!
copyWith: aBit
	| answer |
	answer _ self class new: size+1 fromInteger: bits.
	aBit = One ifTrue: [answer at: size+1 put: One. ^ answer].
	aBit = Zero ifFalse: [DomainError signal].
	^ answer! !

!BitTuple methodsFor: 'enumerating' stamp: 'len 11/5/2016 09:14'!
anySatisfy: aBlock
	"Optimized. There are only two possible elements that could satisfy aBlock (1 or 0)."
	self isEmpty ifTrue: [^ false].
	(self isZero not and: [aBlock value: One]) ifTrue: [^ true].
	^ (aBlock value: Zero) and: [super anySatisfy: [:any| any = Zero]]! !

!BitTuple methodsFor: 'operations' stamp: 'len 5/15/2019 23:57:46'!
* aBit
	aBit isMatrix ifTrue: [^ super * aBit].
	^ ((aBit isInteger and: [aBit even]) or: [aBit isZero]) ifTrue: [self zero] ifFalse: [self]! !

!BitTuple methodsFor: 'operations' stamp: 'len 5/8/2019 04:11:06'!
+ aBitTuple
	^ self class new: (self size max: aBitTuple size) fromInteger: (bits bitXor: aBitTuple asInteger)! !

!BitTuple methodsFor: 'operations' stamp: 'len 3/28/2016 06:51'!
- aBitTuple
	^ self + aBitTuple! !

!BitTuple methodsFor: 'operations' stamp: 'len 5/8/2019 04:15:33'!
>>> anInteger
	^ self class new: (self size + anInteger max: 0) fromInteger: (bits bitShift: anInteger)! !

!BitTuple methodsFor: 'operations' stamp: 'len 5/8/2019 03:09:41'!
 aBitTuple
	^ (bits bitAnd: aBitTuple asInteger) bitParity = 0 ifTrue: [Zero] ifFalse: [One]

"	^ self hadamard: aBitTuple :: sum
"

"	| x |
	x _ self asInteger bitAnd: aBitTuple asInteger.
	[x > 1]
		whileTrue: [x _ x >> (x highBit // 2) bitAnd: x].
	^ x"! !

!BitTuple methodsFor: 'operations' stamp: 'len 5/8/2019 04:15:51'!
convolution: aBitTuple
	| a b c |
	a _ bits.
	b _ aBitTuple asInteger.
	c _ 0.
	1 to: a highBit do: [:i|
		(a bitAt: i) = 1 ifTrue: [c _ c bitXor: b].
		b _ b bitShift: 1].
	^ self class new: (self size + aBitTuple size - 1 max: 0) fromInteger: c! !

!BitTuple methodsFor: 'operations' stamp: 'len 5/8/2019 04:09:42'!
hadamard: aBitTuple
	"Answer the entrywise product with the argument, also called Hadamard product."
	^ self class new: (self size min: aBitTuple size) fromInteger: (bits bitAnd: aBitTuple asInteger)! !

!BitTuple methodsFor: 'operations' stamp: 'len 5/8/2019 03:09:27'!
lift
	"Answer a representative integer tuple."
	^ self representative! !

!BitTuple methodsFor: 'operations' stamp: 'len 3/28/2016 07:30'!
negated
	^ self! !

!BitTuple methodsFor: 'operations' stamp: 'len 3/28/2016 07:27'!
norm
	^ self sum! !

!BitTuple methodsFor: 'operations' stamp: 'len 3/28/2016 07:27'!
norm2
	^ self sum! !

!BitTuple methodsFor: 'operations' stamp: 'len 5/8/2019 03:08:16'!
parity
	"Answer 1 if the receiver has an odd number of bits on, 0 if it has an even number of bits on."
	| n parity |
	bits = 0 ifTrue: [^ 0].
"	n _ bits >> (bits lowBit - 1). skip initial zeros, we could also skip chunks of zeros in the middle"
	n _ bits.
	parity _ 0.
	[n = 0] whileFalse: [parity _ parity bitXor: (n bitAnd: 1). n _ n >> 1].
	^ parity! !

!BitTuple methodsFor: 'operations' stamp: 'len 11/23/2016 05:42:05'!
polynomialValue: anObject
	Zero = anObject ifTrue: [^ self at: 1].
	One = anObject ifFalse: [^ super polynomialValue: anObject].
	^ self sum! !

!BitTuple methodsFor: 'operations' stamp: 'len 5/8/2019 04:10:19'!
reversed
	^ self class new: size fromInteger: (bits bitReverse: size)! !

!BitTuple methodsFor: 'operations' stamp: 'len 5/8/2019 04:09:00'!
shift: anInteger
	^ self class new: size fromInteger: (bits bitShift: anInteger)! !

!BitTuple methodsFor: 'operations' stamp: 'len 5/8/2019 02:58:43'!
sum
	"Answer the sum of the bits, i.e. the parity."
	^ bits bitParity = 0 ifTrue: [Zero] ifFalse: [One]! !

!BitTuple methodsFor: 'operations' stamp: 'len 11/12/2016 08:41'!
weight
	"Answer the Hamming weight of the receiver, i.e. the number of entries that are not zero."
	^ self asInteger bitCount! !

!BitTuple methodsFor: 'operations' stamp: 'len 5/8/2019 04:10:34'!
zero
	^ self class new: size fromInteger: 0! !

!BitTuple methodsFor: 'testing' stamp: 'len 5/8/2019 03:07:48'!
isZero
	^ bits == 0! !

!BitTuple methodsFor: 'testing' stamp: 'len 5/8/2019 03:03:00'!
isZeroAt: anInteger
	^ (bits bitAt: anInteger) == 0! !

!BitTuple methodsFor: 'private' stamp: 'len 5/8/2019 03:03:28'!
bits: anInteger
	bits _ anInteger! !

!BitTuple methodsFor: 'private' stamp: 'len 5/8/2019 04:20:01'!
size: anInteger
	size _ anInteger! !

!BitTuple class methodsFor: 'initialization' stamp: 'len 12/2/2016 11:18:19'!
initialize
	| Z2 |
	super initialize.
	Z2 _ ZZ / 2.
	One _ Z2 one.
	Zero _ Z2 zero! !

!BitTuple class methodsFor: 'instance creation' stamp: 'len 11/5/2016 07:09'!
coefficients: anArray
	| answer |
	answer _ self new: anArray size.
	anArray withIndexDo: [:each :i| answer at: i put: each].
	^ answer! !

!BitTuple class methodsFor: 'instance creation' stamp: 'len 11/5/2016 07:09'!
new
	^ self shouldNotImplement! !

!BitTuple class methodsFor: 'instance creation' stamp: 'len 5/8/2019 04:14:29'!
new: anInteger
	^ self new: anInteger fromInteger: 0! !

!BitTuple class methodsFor: 'instance creation' stamp: 'len 5/8/2019 04:14:07'!
new: anInteger fromInteger: bits
	^ self basicNew bits: bits; size: anInteger! !

!BitTuple class methodsFor: 'instance creation' stamp: 'len 5/8/2019 04:23:48'!
newFrom: anInteger
	anInteger isInteger ifTrue: [^ self new: anInteger highBit fromInteger: anInteger].
	^ super newFrom: anInteger! !

!GenericTuple methodsFor: 'accessing' stamp: 'len 11/5/2016 03:57'!
at: anInteger
	^ coefficients at: anInteger! !

!GenericTuple methodsFor: 'accessing' stamp: 'len 11/5/2016 03:58'!
at: anInteger ifAbsent: aBlock
	^ coefficients at: anInteger ifAbsent: aBlock! !

!GenericTuple methodsFor: 'accessing' stamp: 'len 12/21/2015 22:49'!
last
	^ self at: self size! !

!GenericTuple methodsFor: 'accessing' stamp: 'len 5/8/2019 04:05:30'!
parent
	^ scalars ^ self size! !

!GenericTuple methodsFor: 'accessing' stamp: 'len 5/8/2019 04:05:21'!
scalars
	^ scalars! !

!GenericTuple methodsFor: 'accessing' stamp: 'len 11/5/2016 03:57'!
size
	^ coefficients size! !

!GenericTuple methodsFor: 'converting' stamp: 'len 11/5/2016 03:58'!
asArray
	^ coefficients! !

!GenericTuple methodsFor: 'copying' stamp: 'len 5/7/2019 16:59:03'!
, anObject
	(anObject isTuple or: [anObject isArray])
		ifTrue: [^ self scalars tuple: (coefficients, anObject asArray)].
	^ self scalars tuple: (coefficients copyWith: anObject)! !

!GenericTuple methodsFor: 'copying' stamp: 'len 5/8/2019 04:07:48'!
copy
	^ self class coefficients: coefficients copy over: scalars! !

!GenericTuple methodsFor: 'copying' stamp: 'len 5/7/2019 17:01:26'!
copyFrom: start to: stop
	^ self scalars tuple: (coefficients copyFrom: start to: stop)! !

!GenericTuple methodsFor: 'copying' stamp: 'len 5/7/2019 17:01:47'!
copyWith: anElement
	^ self scalars tuple: (coefficients copyWith: anElement)! !

!GenericTuple methodsFor: 'enumerating' stamp: 'len 11/5/2016 06:08'!
allSatisfy: aBlock
	^ coefficients allSatisfy: aBlock! !

!GenericTuple methodsFor: 'enumerating' stamp: 'len 11/5/2016 09:08'!
anySatisfy: aBlock
	^ coefficients anySatisfy: aBlock! !

!GenericTuple methodsFor: 'enumerating' stamp: 'len 5/8/2019 04:08:11'!
collect: aBlock
	^ self class coefficients: (coefficients collect: aBlock) over: scalars! !

!GenericTuple methodsFor: 'enumerating' stamp: 'len 11/5/2016 03:58'!
do: aBlock
	coefficients do: aBlock! !

!GenericTuple methodsFor: 'enumerating' stamp: 'len 11/12/2016 09:00'!
findFirst: aBlock
	^ coefficients findFirst: aBlock! !

!GenericTuple methodsFor: 'enumerating' stamp: 'len 11/5/2016 06:07'!
findLast: aBlock
	^ coefficients findLast: aBlock! !

!GenericTuple methodsFor: 'enumerating' stamp: 'len 11/5/2016 06:10'!
reverseDo: aBlock
	coefficients reverseDo: aBlock! !

!GenericTuple methodsFor: 'enumerating' stamp: 'len 11/5/2016 03:57'!
withIndexDo: aBlock
	coefficients withIndexDo: aBlock! !

!GenericTuple methodsFor: 'operations' stamp: 'len 5/7/2019 17:01:02'!
+ aTuple
	| zero |
	self size = aTuple size ifTrue: [^ self scalars tuple: self size evaluating: [:i| (self at: i) + (aTuple at: i)]].
	zero _ (self at: 1 ifAbsent: [aTuple at: 1]) zero.
	^ self scalars tuple: (self size max: aTuple size) evaluating: [:i| (self at: i ifAbsent: [zero]) + (aTuple at: i ifAbsent: [zero])]! !

!GenericTuple methodsFor: 'operations' stamp: 'len 5/7/2019 17:01:11'!
- aTuple
	| zero |
	self size = aTuple size ifTrue: [^ self scalars tuple: self size evaluating: [:i| (self at: i) - (aTuple at: i)]].
	zero _ (self at: 1 ifAbsent: [aTuple at: 1]) zero.
	^ self scalars tuple: (self size max: aTuple size) evaluating: [:i| (self at: i ifAbsent: [zero]) - (aTuple at: i ifAbsent: [zero])]! !

!GenericTuple methodsFor: 'operations' stamp: 'len 6/6/2019 10:00:36'!
convolution2: aTuple
	| a aH aHbH aL aLbL b bH bL mid n m |
	self size >= aTuple size ifTrue: [a _ self. b _ aTuple] ifFalse: [a _ aTuple. b _ self].
	n _ a size.
	m _ b size.
	m > 200 ifFalse: [^ self convolution: aTuple].
	mid _ n // 2.
	m > mid ifFalse: [^ self convolution: aTuple].
	aL _ a copyFrom: 1 to: mid.
	aH _ a copyFrom: mid+1 to: n.
	bL _ b copyFrom: 1 to: mid.
	bH _ b copyFrom: mid+1 to: m.
	aLbL _ aL convolution2: bL.
	aHbH _ aH convolution2: bH.
	^ aLbL + ((aL + aH convolution2: bL + bH) - aLbL - aHbH >>> mid) + (aHbH >>> (mid*2))! !

!GenericTuple methodsFor: 'operations' stamp: 'len 5/7/2019 17:04:31'!
convolution: aTuple
	| array |
	self isEmpty ifTrue: [^ self].
	aTuple isEmpty ifTrue: [^ aTuple].
	array _ Array new: self size + aTuple size - 1.
	array atAllPut: self scalars zero.
	self withIndexDo: [:xi :i|
		xi isZero ifFalse:
			[aTuple withIndexDo: [:yj :j|
				array at: i+j-1 add: xi*yj]]].
	^ self scalars tuple: array! !

!GenericTuple methodsFor: 'operations' stamp: 'len 5/8/2019 04:07:58'!
reversed
	^ self class coefficients: coefficients reversed over: scalars! !

!GenericTuple methodsFor: 'operations' stamp: 'len 5/8/2019 04:07:35'!
shift: anInteger
	| newElements zero n |
	anInteger == 0 ifTrue: [^ self].
	newElements _ Array new: self size.
	zero _ (self at: 1) - (self at: 1).
	n _ self size min: anInteger max: self size negated.
	n > 0
		ifTrue:
			[1 to: n do: [:i| newElements at: i put: zero].
			1+n to: self size do: [:i| newElements at: i put: (self at: i-n)]]
		ifFalse:
			[self size + n + 1 to: self size do: [:i| newElements at: i put: zero].
			1 to: self size + n do: [ :i | newElements at: i put: (self at: i-n)]].
	^ self class coefficients: newElements over: scalars! !

!GenericTuple methodsFor: 'testing' stamp: 'len 11/5/2016 03:58'!
includes: anObject
	^ coefficients includes: anObject! !

!GenericTuple methodsFor: 'private' stamp: 'len 11/5/2016 03:58'!
at: anInteger put: anObject
	^ coefficients at: anInteger put: anObject! !

!GenericTuple methodsFor: 'private' stamp: 'len 11/5/2016 03:56'!
coefficients: anArray
	coefficients _ anArray! !

!GenericTuple methodsFor: 'private' stamp: 'len 5/8/2019 04:12:08'!
scalars: aRing
	scalars _ aRing! !

!GenericTuple methodsFor: 'private' stamp: 'len 11/5/2016 03:57'!
swap: i with: j
	coefficients swap: i with: j! !

!GenericTuple class methodsFor: 'instance creation' stamp: 'len 5/8/2019 04:12:51'!
coefficients: anArray over: aRing
	^ self basicNew coefficients: anArray asArray; scalars: aRing! !

!GenericTuple class methodsFor: 'instance creation' stamp: 'len 11/5/2016 07:13'!
new
	^ self shouldNotImplement! !

!ModularTuple methodsFor: 'accessing' stamp: 'len 12/1/2016 16:35:34'!
at: anInteger
	^ scalars representative: (representatives at: anInteger ifAbsent: [^ scalars zero])! !

!ModularTuple methodsFor: 'accessing' stamp: 'len 12/1/2016 16:35:55'!
at: anInteger put: aModularInteger
	aModularInteger isInteger ifTrue: [^ representatives at: anInteger put: aModularInteger \\ scalars modulus].
	representatives at: anInteger put: aModularInteger representative.
	^ aModularInteger! !

!ModularTuple methodsFor: 'accessing' stamp: 'len 1/19/2018 22:04:11'!
lastNonZero
	"Answer the index of the last non-zero entry, or 0."
	representatives size to: 1 by: -1 do: [:i| (representatives at: i) = 0 ifFalse: [^ i]].
	^ 0! !

!ModularTuple methodsFor: 'accessing' stamp: 'len 5/3/2018 02:48:08'!
lastNonZeroDivisor
	"Answer the index of the last non zero divisor entry, or 0."
	| m |
	m _ scalars modulus.
	representatives size to: 1 by: -1 do: [:i| ((representatives at: i) gcd: m) = 1 ifTrue: [^ i]].
	^ 0! !

!ModularTuple methodsFor: 'accessing' stamp: 'len 4/23/2018 21:01:36'!
lift
	"Answer a representative integer tuple."
	| m h |
	m _ scalars modulus.
	h _ m >> 1.
	^ ZZ tuple: self size evaluating: [:i| | r | r _ representatives at: i. r <= h ifTrue: [r] ifFalse: [r - m]]! !

!ModularTuple methodsFor: 'accessing' stamp: 'len 4/23/2018 20:33:12'!
representative
	"Answer a representative integer tuple."
	^ ZZ tuple: representatives! !

!ModularTuple methodsFor: 'accessing' stamp: 'len 12/1/2016 16:36:02'!
scalars
	^ scalars! !

!ModularTuple methodsFor: 'accessing' stamp: 'len 3/31/2016 07:47'!
size
	^ representatives size! !

!ModularTuple methodsFor: 'accessing-private' stamp: 'len 12/1/2016 16:38:58'!
modulus
	^ scalars modulus! !

!ModularTuple methodsFor: 'accessing-private' stamp: 'len 3/31/2016 07:43'!
representatives
	^ representatives! !

!ModularTuple methodsFor: 'accessing-private' stamp: 'len 12/1/2016 16:36:25'!
representatives: anArray
	representatives _ anArray
"	representatives do: [:each| (each between: 0 and: modulus) ifFalse: [self halt]]"! !

!ModularTuple methodsFor: 'accessing-private' stamp: 'len 12/1/2016 16:53:30'!
scalars: aModularIntegers
	scalars _ aModularIntegers! !

!ModularTuple methodsFor: 'comparing' stamp: 'len 12/1/2016 16:42:00'!
= aTuple
	self class = aTuple class ifFalse: [^ super = aTuple halt].
	^ scalars = aTuple scalars and: [representatives = aTuple representatives]! !

!ModularTuple methodsFor: 'comparing' stamp: 'len 6/30/2016 06:52'!
hash
	^ representatives hash! !

!ModularTuple methodsFor: 'copying' stamp: 'len 12/1/2016 16:35:01'!
, anObject
	self class = anObject class
		ifTrue:
			[scalars = anObject scalars ifFalse: [^ DomainError signal].
			^ self class representatives: representatives, anObject representatives over: scalars].
	scalars modulus = anObject modulus ifFalse: [^ DomainError signal].
	^ self class representatives: (representatives copyWith: anObject representative) over: scalars! !

!ModularTuple methodsFor: 'copying' stamp: 'len 12/1/2016 16:43:47'!
copy
	^ self class representatives: representatives copy over: scalars! !

!ModularTuple methodsFor: 'copying' stamp: 'len 12/1/2016 16:36:08'!
copyFrom: start to: stop
	^ self class representatives: (representatives copyFrom: start to: stop) over: scalars! !

!ModularTuple methodsFor: 'copying' stamp: 'len 12/1/2016 16:33:41'!
copyWith: anElement
	^ self class representatives: (representatives copyWith: anElement representative) over: scalars! !

!ModularTuple methodsFor: 'operations' stamp: 'len 5/15/2019 23:58:20'!
* aNumber
	| modulus x array |
	aNumber isMatrix ifTrue: [^ super * aNumber].
	x _ aNumber isInteger ifTrue: [aNumber] ifFalse: [aNumber representative].
	modulus _ scalars modulus.
	array _ representatives copy.
	1 to: self size do: [:i| array at: i put: (array at: i) * x \\ modulus].
	^ self class representatives: array over: scalars! !

!ModularTuple methodsFor: 'operations' stamp: 'len 12/1/2016 16:33:24'!
+ aTuple
	| modulus a an b bn c |
	(an _ self size) <= (bn _ aTuple size) ifFalse: [^ aTuple + self].
	modulus _ scalars modulus.
	a _ representatives.
	b _ aTuple representatives.
	c _ representatives class new: bn.
	1 to: an do: [:i|
		c at: i put: (a at: i) + (b at: i) \\ modulus].
	c replaceFrom: an+1 to: bn with: b startingAt: an+1.
	^ self class representatives: c over: scalars! !

!ModularTuple methodsFor: 'operations' stamp: 'len 4/29/2019 10:19:07'!
 aTuple
	| modulus representatives2 answer |
	(aTuple class = self class and: [scalars = aTuple scalars])
		ifFalse: [^ super  aTuple].
	modulus _ scalars modulus.
	representatives2 _ aTuple representatives.
	answer _ 0.
	1 to: (representatives size min: representatives2 size) do: [:i|
		answer _ (representatives at: i) * (representatives2 at: i) + answer \\ modulus].
	^ scalars representative: answer! !

!ModularTuple methodsFor: 'operations' stamp: 'len 5/30/2019 07:10:24'!
add: aTuple times: aNumber from: startIndex to: stopIndex
	| modulus representatives2 x |
	(self class = aTuple class "and: [scalars = aTuple scalars]")
		ifFalse: [^ super add: aTuple times: aNumber from: startIndex to: stopIndex].
	modulus _ scalars modulus.
	representatives2 _ aTuple representatives.
	x _ aNumber representative.
	0 = x ifTrue: [^ self].
	startIndex to: stopIndex do: [:i|
		representatives at: i put: (representatives2 at: i) * x + (representatives at: i) \\ modulus]! !

!ModularTuple methodsFor: 'operations' stamp: 'len 12/1/2016 16:41:43'!
convolution: aTuple
	| modulus array |
	self isEmpty ifTrue: [^ self].
	aTuple isEmpty ifTrue: [^ aTuple].
	modulus _ scalars modulus.
	array _ representatives class new: self size + aTuple size - 1.
	array atAllPut: 0. "in case it's Array"
	representatives withIndexDo: [:xi :i|
		xi = 0 ifFalse:
			[aTuple representatives withIndexDo: [:yj :j| | index |
				index _ i+j-1.
				array at: index put: xi*yj + (array at: index) \\ modulus]]].
	^ self class representatives: array over: scalars! !

!ModularTuple methodsFor: 'operations' stamp: 'len 12/1/2016 16:39:42'!
hadamard: aTuple
	| modulus array representatives2 |
	(self class = aTuple class and: [scalars = aTuple scalars])
		ifFalse: [^ super hadamard: aTuple].
	modulus _ scalars modulus.
	array _ representatives class new: (self size min: aTuple size).
	representatives2 _ aTuple representatives.
	1 to: array size do: [:i| array at: i put: (representatives at: i) * (representatives2 at: i) \\ modulus].
	^ self class representatives: array over: scalars! !

!ModularTuple methodsFor: 'operations' stamp: 'len 1/16/2018 22:05:42'!
multiplyBy: aNumber from: startIndex to: stopIndex
	| modulus x |
	modulus _ scalars modulus.
	x _ aNumber representative.
	startIndex to: stopIndex do: [:i|
		representatives at: i put: (representatives at: i) * x \\ modulus]! !

!ModularTuple methodsFor: 'operations' stamp: 'len 12/1/2016 16:41:10'!
negated
	| modulus array |
	array _ representatives copy.
	modulus _ scalars modulus.
	1 to: self size do: [:i| array at: i put: (array at: i) negated \\ modulus].
	^ self class representatives: array over: scalars! !

!ModularTuple methodsFor: 'operations' stamp: 'len 5/26/2018 17:54:17'!
polynomialDivisionBy: aTuple
	| quo rem lcInv n m b modulus |
	aTuple isZero ifTrue: [^ (ZeroDivide dividend: self) signal].
	quo _ self zero.
	rem _ self copy.
	m _ aTuple lastNonZero. "m = degree(self)+1"
	lcInv _ (aTuple at: m) reciprocal.
	b _ aTuple representatives.
	modulus _ self modulus.
	[(n _ rem lastNonZero) >= m] "n = degree(rem)+1"
		whileTrue:
			[| i c r |
			i _ n-m+1.
			c _ ((rem at: n) * lcInv) representative.
			quo at: i put: (quo at: i) + c.
			r _ rem representatives.
			1 to: m do: [:j| r at: j+i-1 put: (r at: j+i-1) - ((b at: j)*c) \\ modulus]].
	^ {quo. rem}! !

!ModularTuple methodsFor: 'operations' stamp: 'len 12/1/2016 16:45:01'!
polynomialValue: anObject
	| modulus x answer |
	((anObject isKindOf: ModularInteger) and: [anObject modulus = (modulus _ self modulus)])
		ifFalse: [^ super polynomialValue: anObject].
	x _ anObject representative.
	answer _ 0.
	representatives reverseDo: [:each| answer _ x * answer + each \\ modulus].
	^ scalars representative: answer! !

!ModularTuple methodsFor: 'operations' stamp: 'len 12/1/2016 16:36:42'!
reversed
	^ self class representatives: representatives reversed over: scalars! !

!ModularTuple methodsFor: 'operations' stamp: 'len 12/3/2016 09:13:11'!
weight
	"Answer the Hamming weight of the receiver, i.e. the number of entries that are not zero."
	^ representatives count: [:each| each ~~ 0]! !

!ModularTuple methodsFor: 'testing' stamp: 'len 12/5/2016 17:54:18'!
isZero
	1 to: representatives size do: [:i| (representatives at: i) == 0 ifFalse: [^ false]].
	^ true! !

!ModularTuple methodsFor: 'testing' stamp: 'len 4/27/2018 01:14:29'!
isZeroAt: anInteger
	^ (representatives at: anInteger) == 0! !

!ModularTuple class methodsFor: 'instance creation' stamp: 'len 11/12/2016 17:19'!
arrayClassForModulus: anInteger
	anInteger <= 255 ifTrue: [^ ByteArray].
	anInteger <= 16rFFFFFFFF ifTrue: [^ WordArray].
	^ Array! !

!ModularTuple class methodsFor: 'instance creation' stamp: 'len 12/1/2016 16:48:12'!
coefficients: anArray over: aModularIntegers
	^ self new: anArray size over: aModularIntegers evaluating: [:i| anArray at: i]! !

!ModularTuple class methodsFor: 'instance creation' stamp: 'len 12/1/2016 16:47:15'!
new: anInteger over: aModularIntegers
	| array |
	array _ (self arrayClassForModulus: aModularIntegers modulus) new: anInteger.
	^ self representatives: array over: aModularIntegers! !

!ModularTuple class methodsFor: 'instance creation' stamp: 'len 12/1/2016 16:47:41'!
new: anInteger over: aModularIntegers evaluating: aBlock
	| array |
	array _ (self arrayClassForModulus: aModularIntegers modulus) new: anInteger.
	1 to: anInteger do: [:i| array at: i put: (aBlock value: i) representative].
	^ self representatives: array over: aModularIntegers! !

!ModularTuple class methodsFor: 'instance creation' stamp: 'len 12/1/2016 16:46:28'!
representatives: anArray over: aModularIntegers
	^ self basicNew scalars: aModularIntegers; representatives: anArray! !

!MultivariateTuple methodsFor: 'as yet unclassified' stamp: 'len 12/28/2017 14:35:33'!
coefficientAt: aModuleMonomial
	^ (self at: aModuleMonomial position) at: aModuleMonomial monomial! !

!MultivariateTuple methodsFor: 'as yet unclassified' stamp: 'len 4/4/2018 21:34:03'!
leadingCoefficient
	^ self coefficientAt: self leadingMonomial! !

!MultivariateTuple methodsFor: 'as yet unclassified' stamp: 'len 1/14/2017 21:07:12'!
leadingMonomial
	^ self ordering leadingMonomialOf: self! !

!MultivariateTuple methodsFor: 'as yet unclassified' stamp: 'len 1/14/2017 20:35:06'!
leadingTerm
	^ self termAt: self leadingMonomial! !

!MultivariateTuple methodsFor: 'as yet unclassified' stamp: 'len 1/6/2018 22:05:31'!
ordering
	^ parent ordering! !

!MultivariateTuple methodsFor: 'as yet unclassified' stamp: 'len 1/6/2018 22:05:02'!
parent
	^ parent! !

!MultivariateTuple methodsFor: 'as yet unclassified' stamp: 'len 1/14/2017 21:04:51'!
termAt: aModuleMonomial
	^ (self at: aModuleMonomial position) termAt: aModuleMonomial monomial! !

!Matrix methodsFor: 'accessing' stamp: 'len 7/16/2016 00:05'!
at: aPoint
	"Answer the coefficient at i@j (row i, column j)."
	^ self at: aPoint x at: aPoint y! !

!Matrix methodsFor: 'accessing' stamp: 'len 3/2/2017 19:57:13'!
at: aPoint add: anObject
	self at: aPoint put: (self at: aPoint) + anObject! !

!Matrix methodsFor: 'accessing' stamp: 'len 7/16/2016 00:05'!
at: aPoint put: anObject
	"Answer the coefficient at i@j (row i, column j)."
	^ self at: aPoint x at: aPoint y put: anObject! !

!Matrix methodsFor: 'accessing' stamp: 'len 3/23/2016 00:17'!
bitSize
	^ self rows inject: 0 into: [:x :each| x + each bitSize]! !

!Matrix methodsFor: 'accessing' stamp: 'len 3/5/2016 22:28'!
columnAt: i put: aTuple
	self flag: #fix.
	aTuple withIndexDo: [:each :k| self at: k@i put: each] "note: this will fail with sparse tuples"! !

!Matrix methodsFor: 'accessing' stamp: 'len 4/5/2018 15:28:49'!
columns
	^ (1 to: self width) collect: [:i| self columnAt: i]! !

!Matrix methodsFor: 'accessing' stamp: 'len 1/28/2018 22:23:15'!
denominator
	| answer |
	self scalars isLocalization ifFalse: [^ self scalars one].
	answer _ self scalars integers one.
	self do: [:each| answer _ each denominator lcm: answer].
	^ answer! !

!Matrix methodsFor: 'accessing' stamp: 'len 4/5/2018 15:29:25'!
diagonal
	"Answer the diagonal of the receiver as a tuple."
	^ self scalars
		tuple: (self height min: self width)
		evaluating: [:i| self at: i@i]! !

!Matrix methodsFor: 'accessing' stamp: 'len 4/7/2018 06:20:08'!
extent
	^ self height @ self width! !

!Matrix methodsFor: 'accessing' stamp: 'len 4/5/2018 15:32:32'!
lastColumn
	^ self columnAt: self width! !

!Matrix methodsFor: 'accessing' stamp: 'len 4/23/2018 20:29:24'!
lift
	"If the coefficients ring is a quotient R/I, answer a representative of the receiver over R. See >>%."
	^ self apply: self scalars lifting! !

!Matrix methodsFor: 'accessing' stamp: 'len 1/28/2018 22:23:08'!
numerator
	self scalars isLocalization ifFalse: [^ self].
	^ self * self denominator over: self scalars integers! !

!Matrix methodsFor: 'accessing' stamp: 'len 6/2/2018 17:39:12'!
parent
	^ self scalars ^ (self height @ self width)! !

!Matrix methodsFor: 'accessing' stamp: 'len 3/7/2017 08:34:26'!
pivots
	"Answer the collection of row-style pivot indices. These are the pairs i@j corresponding to the first nonzero entry of each row."
	^ Iterator on: self performing: #pivotsDo:! !

!Matrix methodsFor: 'accessing' stamp: 'len 4/23/2018 20:40:35'!
representative
	"If the coefficients ring is a quotient R/I, answer a representative of the receiver over R. See >>%."
	^ self apply: self scalars projection section! !

!Matrix methodsFor: 'accessing' stamp: 'len 3/23/2016 02:55'!
rowAt: i put: aTuple
	self flag: #fix.
	aTuple withIndexDo: [:each :k| self at: i@k put: each] "note: this will fail with sparse tuples"! !

!Matrix methodsFor: 'accessing' stamp: 'len 4/5/2018 15:42:55'!
rows
	^ (1 to: self height) collect: [:i| self rowAt: i]! !

!Matrix methodsFor: 'accessing' stamp: 'len 11/5/2016 03:24'!
scalars
	^ self subclassResponsibility! !

!Matrix methodsFor: 'comparing' stamp: 'len 5/15/2019 23:48:39'!
= anObject
	anObject isMatrix ifFalse: [^ false].
	self height = anObject height ifFalse: [^ false].
	self width = anObject width ifFalse: [^ false].
	1 to: self height do: [:i|
		1 to: self width do: [:j|
			(self at: i@j) = (anObject at: i@j) ifFalse: [^ false]]].
	^ true! !

!Matrix methodsFor: 'comparing' stamp: 'len 5/28/2019 09:23:46'!
~ aMatrix
	"Answer true if the receiver is similar to aMatrix.
	Two matrices A and B are 'similar' if there exists an invertible matrix P such that B = P^-1 * A * P. This is the conjugacy equivalence relation in GL."
	self isEmpty ifTrue: [^ aMatrix isEmpty].
	aMatrix isEmpty ifTrue: [^ self isEmpty].
	^ self characteristicMatrix SNF diagonal = aMatrix characteristicMatrix SNF diagonal! !

!Matrix methodsFor: 'comparing' stamp: 'len 4/5/2018 15:31:22'!
hash
	| answer |
	answer _ 0.
	1 to: self height do: [:i|
		1 to: self width do: [:j|
			answer _ answer hashMultiply + (self at: i@j) hash]].
	^ answer! !

!Matrix methodsFor: 'constants' stamp: 'len 4/7/2018 06:25:38'!
identity
	^ self scalars matrix: self extent scalar: self scalars one! !

!Matrix methodsFor: 'constants' stamp: 'len 5/5/2019 08:22:47'!
leftIdentity
	self isEmpty ifTrue: [^ self].
	^ self scalars matrix: self height scalar: self scalars one! !

!Matrix methodsFor: 'constants' stamp: 'len 3/2/2016 20:54'!
one
	^ self identity! !

!Matrix methodsFor: 'constants' stamp: 'len 5/5/2019 08:22:27'!
rightIdentity
	self isEmpty ifTrue: [^ self].
	^ self scalars matrix: self width scalar: self scalars one! !

!Matrix methodsFor: 'constants' stamp: 'len 4/7/2018 06:27:07'!
zero
	^ self scalars matrix: self extent scalar: self scalars zero! !

!Matrix methodsFor: 'converting' stamp: 'len 12/23/2015 05:12'!
asTuple
	"Answer the receiver converted to Tuple by concatenating its rows (which is also the coordinates of the receiver in the canonical basis)."
	| answer |
	self rowsDo: [:each| answer _ answer isNil ifTrue: [each] ifFalse: [answer, each]].
	^ answer! !

!Matrix methodsFor: 'copying' stamp: 'len 11/12/2016 07:44'!
copyFrom: aPoint to: anotherPoint
	"Answer the submatrix of the receiver from aPoint to anotherPoint."

	| start |
	start _ aPoint - (1@1).
	^ self scalars
		matrix: anotherPoint - start
		evaluating: [:i :j| self at: start + (i@j)]! !

!Matrix methodsFor: 'copying' stamp: 'len 4/21/2019 13:51:28'!
copyFromColumn: start to: end
	^ Matrix columns: ((start to: end) collect: [:each| self columnAt: each])! !

!Matrix methodsFor: 'copying' stamp: 'len 4/2/2018 05:07:15'!
copyFromRow: start to: end
	^ Matrix rows: ((start to: end) collect: [:each| self rowAt: each])! !

!Matrix methodsFor: 'enumerating' stamp: 'len 3/24/2018 19:27:46'!
allSatisfy: aBlock
	self do: [:each| (aBlock value: each) ifFalse: [^ false]].
	^ true! !

!Matrix methodsFor: 'enumerating' stamp: 'len 4/7/2018 06:25:05'!
collect: aBlock
	^ self scalars matrix: self extent evaluating: [:i :j| aBlock value: (self at: i@j)]! !

!Matrix methodsFor: 'enumerating' stamp: 'len 4/5/2018 15:28:54'!
columnsDo: aBlock
	1 to: self width do: [:i| aBlock value: (self columnAt: i)]! !

!Matrix methodsFor: 'enumerating' stamp: 'len 1/7/2016 23:38'!
diagonalDo: aBlock
	| i |
	i _ 1.
	self rowsDo: [:each| aBlock value: (each at: i). i _ i + 1]! !

!Matrix methodsFor: 'enumerating' stamp: 'len 4/5/2018 15:29:50'!
do: aBlock
	1 to: self height do: [:i|
		1 to: self width do: [:j|
			aBlock value: (self at: i@j)]]! !

!Matrix methodsFor: 'enumerating' stamp: 'len 3/7/2017 08:34:58'!
pivotsDo: aBlock
	"Enumerate the row-style pivot indices. These are the pairs i@j corresponding to the first nonzero entry of each row."
	| i |
	i _ 1.
	self rowsDo: [:each| | j |
		(j _ each findFirst: [:one| one isZero not]) == 0
			ifFalse: [aBlock value: i@j].
		i _ i + 1]! !

!Matrix methodsFor: 'enumerating' stamp: 'len 4/5/2018 15:43:00'!
rowsDo: aBlock
	1 to: self height do: [:i| aBlock value: (self rowAt: i)]! !

!Matrix methodsFor: 'operations' stamp: 'len 4/29/2019 10:24:54'!
* anObject
	anObject isMatrix ifTrue: [^ self  anObject].
	anObject isTuple ifTrue: [^ self value: anObject].
	self isEmpty ifTrue: [^ self].
	(self scalars includes: anObject) ifFalse: [DomainError signal].
	^ self collect: [:each| each * anObject]! !

!Matrix methodsFor: 'operations' stamp: 'len 4/7/2018 06:23:24'!
+ aMatrix
	self checkDimensionMatch: aMatrix.
	self checkScalarsMatch: aMatrix.
	^ self scalars matrix: self extent evaluating: [:i :j| (self at: i@j) + (aMatrix at: i@j)]! !

!Matrix methodsFor: 'operations' stamp: 'len 1/24/2018 21:13:27'!
, aMatrix
	"Answer the receiver augmented with the rows of aMatrix."
	^ self rowAugmented: aMatrix! !

!Matrix methodsFor: 'operations' stamp: 'len 3/23/2016 00:21'!
- aMatrix
	^ self + aMatrix negated! !

!Matrix methodsFor: 'operations' stamp: 'len 5/30/2019 16:21:59'!
/ anObject
	"Answer X such that X * A = B, where B is self and A is aMatrix.
	If the argument is a scalr, just divide each element of the matrix by it."
	anObject isMatrix ifTrue: [^ anObject solveLeft: self].
	^ self * anObject reciprocal! !

!Matrix methodsFor: 'operations' stamp: 'len 5/24/2019 08:32:40'!
: aMatrix
	"Answer the receiver augmented with the columns of aMatrix."
	^ self columnAugmented: aMatrix! !

!Matrix methodsFor: 'operations' stamp: 'len 3/1/2017 09:02:29'!
\ aMatrix
	"Answer X such that A * X = B, where A is self and B is aMatrix.
	The argument can also be a tuple, in which case it is considered as a column matrix.
	This is the 'backlash' operator, as implemented in MATLAB, Octave and Sage."
	^ self solveRight: aMatrix! !

!Matrix methodsFor: 'operations' stamp: 'len 1/22/2017 08:15:54'!
^ anInteger
	"Answer the receiver raised to the power anInteger."
	anInteger = 1 ifTrue: [^ self].
	anInteger = 0 ifTrue: [^ self identity].
	anInteger < 0 ifTrue: [^ self reciprocal ^ anInteger negated].
	^ (self squared ^ (anInteger // 2)) * (self ^ (anInteger \\ 2))! !

!Matrix methodsFor: 'operations' stamp: 'len 4/29/2019 10:17:26'!
 aMatrix
	"Product of matrices."
	| rows columns |
	self isEmpty ifTrue: [^ self].
	aMatrix isEmpty ifTrue: [^ aMatrix].
	self width = aMatrix height ifFalse: [^ DomainError signal: 'matrices dimensions don''t match'].
	self checkScalarsMatch: aMatrix.
	rows _ self rows.
	columns _ aMatrix columns.
	^ self scalars
		matrix: self height @ aMatrix width
		evaluating: [:i :j| (rows at: i)  (columns at: j)]! !

!Matrix methodsFor: 'operations' stamp: 'len 5/29/2019 11:56:42'!
 aMatrix
	"Answer the block sum of the receiver and the argument.
	If the receiver is A and the argument is B, output a matrix of the form:
	  [A 0]
	  [0 B]"
	| z1 z2 |
	self isEmpty ifTrue: [^ aMatrix].
	aMatrix isEmpty ifTrue: [^ self].
	z1 _ self scalars zeroTuple: aMatrix width.
	z2 _ self scalars zeroTuple: self width.
	^ self class rows: (self rows collect: [:each| each, z1]), (aMatrix rows collect: [:each| z2, each])! !

!Matrix methodsFor: 'operations' stamp: 'len 5/14/2019 20:49:47'!
 aMatrix
	^ self kronecker: aMatrix! !

!Matrix methodsFor: 'operations' stamp: 'len 11/5/2016 03:13'!
adjoint
	"Answer the conjugate transpose A* of the receiver A (also called Hermitian conjugate, bedaggered matrix, adjoint matrix or transjugate)."
	self scalars isReal ifTrue: [^ self transposed].
	self scalars isComplex ifTrue: [^ self transposed conjugated].
	^ self error: 'not real or complex matrix'! !

!Matrix methodsFor: 'operations' stamp: 'len 12/22/2015 21:12'!
adjugate
	"Answer the adjugate matrix (or classical adjoint matrix) of the receiver. This is the matrix such that multiplicated at the left by the receiver equals the scalar matrix with the determinant of the receiver in the diagonal."
	^ (self characteristicPolynomial shift: -1) negated value: self! !

!Matrix methodsFor: 'operations' stamp: 'len 3/3/2017 11:39:21'!
antitransposed
	^ RowMatrix rows: (self columns reversed collect: [:each| each reversed])! !

!Matrix methodsFor: 'operations' stamp: 'len 4/7/2018 06:23:31'!
apply: aMorphism
	"Apply a homomorphism to the coefficients of the receiver."
	aMorphism domain = self scalars
		ifTrue: [^ aMorphism codomain matrix: self extent evaluating: [:i :j| aMorphism value: (self at: i@j)]].
	^ DomainError signal! !

!Matrix methodsFor: 'operations' stamp: 'len 4/29/2019 10:21:27'!
berkowitz
	"Answer the coefficients of the characteristic polynomial of the receiver. It's computed by the Berkowitz algorithm, using small space in comparision with classic gaussian elimination."
	| vect C Ar R S Q one |
	one _ self scalars one.
	self height = 1 ifTrue: [^ self scalars tuple: { one negated. (self at: 1@1) }].
	self height = 2 ifTrue:
			[^ self scalars tuple:
				{one.
				((self at: 1@1) + (self at: 2@2)) negated.
				(self at: 1@1) * (self at: 2@2) - ((self at: 1@2) * (self at: 2@1))}].

	vect _ self scalars tuple:
		{one.
		(self at: 2@2) negated - (self at: 1@1).
		(self at: 2@2) * (self at: 1@1) - ((self at: 1@2) * (self at: 2@1))}.

	3 to: self height do: [:r|
		C _ (self scalars ^ (r+1 @ r)) zero.
		Ar _ self copyFrom: 1@1 to: r-1 @ (r-1).

		R _ (self rowAt: r) copyFrom: 1 to: r-1.
		S _ (self columnAt: r) copyFrom: 1 to: r-1.

		C at: 1@1 put: one negated.
		C at: 2@1 put: (self at: r@r).
		C at: 3@1 put: (R  S).

		Q _ Ar * S.

		C at: 4@1 put: (R  Q).

		3 to: r-1 do: [ :i |
			Q _ Ar * Q.
			C at: i+2 @ 1 put: (R  Q)].

		2 to: r do: [ :i |
			0 to: r+1-i do: [ :j |
				C at: i+j @ i put: (C at: j+1 @ 1)]].

		vect _ C * vect].

	^ vect! !

!Matrix methodsFor: 'operations' stamp: 'len 4/5/2018 15:39:48'!
berkowitz: x
	| polcar vect r power |

	r _ self height + 1.
	vect _ self berkowitz.
	polcar _ x zero.
	power _ x one.
	r to: 1 by: -1 do: [ :i |
		polcar _ power * (vect at: i) + polcar.
		power _ power * x].

	^ r odd ifTrue: [polcar] ifFalse: [polcar negated]! !

!Matrix methodsFor: 'operations' stamp: 'len 4/7/2018 06:23:36'!
characteristicMatrix
	"Answer the characteristic matrix A - xI."
	| P x |
	P _ self scalars polynomials.
	x _ P x.
	^ P matrix: self extent
		evaluating: [:i :j|
			i == j
				ifTrue: [(P constant: (self at: i @ j)) - x]
				ifFalse: [P constant: (self at: i @ j)]]! !

!Matrix methodsFor: 'operations' stamp: 'len 4/5/2018 15:49:16'!
characteristicPolynomial
	self isSquare ifFalse: [DomainError signal: 'not a square matrix'].
	^ self scalars polynomials coefficients: self berkowitz reversed! !

!Matrix methodsFor: 'operations' stamp: 'len 4/7/2018 06:23:46'!
characteristicPolynomial2
	| P x |
	P _ self scalars polynomials.
	x _ P x.
	^ (P matrix: self extent
		evaluating: [:i :j| i == j ifTrue: [x - (P constant: (self at: i @ j))] ifFalse: [P constant: (self at: i @ j) negated]]) determinant! !

!Matrix methodsFor: 'operations' stamp: 'len 4/5/2018 15:40:19'!
characteristicPolynomial3
	"COHEN Algorithm 2.2.7. (Characteristic Polynomial and Adjoint Matrix) O(n^4)."
	| n i I C a |
	n _ self height.
	i _ 0. I _ self identity. C _ I. a _ OrderedCollection new: n.
	a add: self scalars one.
	[(i _ i + 1) = n
		ifTrue:
			[a add: (self * C) trace negated / n.
			^ self scalars polynomials coefficients: a reversed. "adj _ (-1)^(n-1) * C"].
	C _ self * C.
	a add: C trace negated / i.
	C _ C + (I * a last)] repeat! !

!Matrix methodsFor: 'operations' stamp: 'len 4/5/2018 15:40:42'!
characteristicPolynomialAndAdjoint
	"COHEN Algorithm 2.2.7. (Characteristic Polynomial and Adjoint Matrix) O(n^4)."
	| n i I C a |
	n _ self height.
	i _ 0. I _ self identity. C _ I. a _ OrderedCollection new: n.
	a add: self scalars one.
	[(i _ i + 1) = n
		ifTrue:
			[a add: (self * C) trace negated / n.
			^ {self scalars polynomials coefficients: a reversed. (-1)^(n-1) * C}].
	C _ self * C.
	a add: C trace negated / i.
	C _ C + (I * a last)] repeat! !

!Matrix methodsFor: 'operations' stamp: 'len 10/13/2016 14:00'!
cofactor: aPoint
	"Answer the cofactor i@j of the receiver."

	^ (aPoint x + aPoint y) even
		ifTrue: [self minor: aPoint]
		ifFalse: [(self minor: aPoint) negated]! !

!Matrix methodsFor: 'operations' stamp: 'len 5/18/2018 20:17:30'!
columnAugmented: aMatrix
	"Answer the receiver augmented with the columns of aMatrix."
	| n |
	self isEmpty ifTrue: [^ aMatrix].
	aMatrix isEmpty ifTrue: [^ self].
	n _ self height.
	aMatrix isTuple
		ifTrue:
			[aMatrix size = n ifFalse: [^ DomainError signal: 'dimensions don''t match'].
			^ Matrix columns: (self columns copyWith: aMatrix)].
	aMatrix height = n ifFalse: [^ DomainError signal: 'dimensions don''t match'].
	^ Matrix columns: self columns, aMatrix columns! !

!Matrix methodsFor: 'operations' stamp: 'len 12/11/2015 00:20'!
comatrix
	"Answer the co-matrix (or cofactor matrix) of the receiver, i.e. the matrix '(a{ij})' where 'a{ij}' is the cofactor 'ij'."
	^ self adjugate transposed! !

!Matrix methodsFor: 'operations' stamp: 'len 6/23/2016 23:27'!
conjugated
	^ self collect: [:each| each conjugated]! !

!Matrix methodsFor: 'operations' stamp: 'len 2/28/2017 21:04:03'!
determinant
	self scalars isField
		ifTrue: [^ (GaussianElimination on: self) determinant].
	([self scalars isIntegralDomain] ifError: [false])
		ifFalse: [self characteristicPolynomial independentCoefficient].
	"^ self determinant2"
	^ self characteristicPolynomial independentCoefficient! !

!Matrix methodsFor: 'operations' stamp: 'len 12/27/2015 02:25'!
determinant1
	^ self characteristicPolynomial independentCoefficient! !

!Matrix methodsFor: 'operations' stamp: 'len 4/5/2018 15:41:59'!
determinant2
	"COHEN Algorithm 2.2.6. (Determinant using Gauss-Bareiss). O(n^3)"
	| n M k c s p i t |
	self assert: self scalars isIntegralDomain.
	self assert: self isSquare.
	n _ self height.
	M _ self copy.
	k _ 0. c _ self scalars one. s _ self scalars one.
	[k _ k + 1.
	k = n ifTrue: [^ s * (M at: n@n)].
	p _ M at: k@k. i _ k.
	p isZero ifTrue: [i _ (k+1 to: n) detect: [:j| (M at: j@k) isZero not] ifNone: [^ self scalars zero]].
	k to: n do: [:j| t _ M at: i@j. M at: i@j put: (M at: k@j). M at: k@j put: t].
	s _ s negated.
	p _ M at: k@k.
	"the division t/c is exact, must use Euclidean division and discard the remainder"
	c | t ifFalse: [self halt].
	k+1 to: n do: [:j| t _ p * (M at: i@j) - ((M at: i@k) * (M at: k@j)). M at: i@j put: t/c].
	c _ p] repeat! !

!Matrix methodsFor: 'operations' stamp: 'len 1/17/2017 09:00:29'!
determinant3
	^ (GaussianElimination on: self) determinant! !

!Matrix methodsFor: 'operations' stamp: 'len 4/26/2018 20:56:17'!
determinantModular
	| B C n r moduli determinants |
	B _ 0.
	self do: [:each| B _ B max: each abs].
	n _ self width.
	C _ (n^n) sqrt * (B^n).
	r _ (C log: 2) ceiling.
	moduli _ OrderedCollection new: r.
	moduli add: 2.
	r - 1 timesRepeat: [moduli add: moduli last nextPrime].
	determinants _ moduli collect: [:each| (self % each) determinant].
	^ (CRT solve: determinants) lift! !

!Matrix methodsFor: 'operations' stamp: 'len 4/5/2018 15:29:05'!
determinantx
	(self height = 2 and: [self width = 2])
		ifTrue: [^ (self at: 1@1) * (self at: 2@2) - ((self at: 2@1) * (self at: 1@2))].
	^ self determinant! !

!Matrix methodsFor: 'operations' stamp: 'len 4/5/2018 15:30:54'!
extended
	"Answer a square full rank matrix, adding rows if needed."
	(self isSquare and: [self isFullRank]) ifTrue: [^ self].
	^ (self, (self scalars identityMatrix: self width)) transposed imageMatrix! !

!Matrix methodsFor: 'operations' stamp: 'len 4/7/2018 06:25:26'!
hadamard: aMatrix
	"Answer the entrywise product of the receiver with the argument (also called Hadamard produect or Schur product)."
	self checkDimensionMatch: aMatrix.
	self checkScalarsMatch: aMatrix.
	^ self scalars matrix: self extent evaluating: [:i :j| (self at: i@j) * (aMatrix at: i@j)]! !

!Matrix methodsFor: 'operations' stamp: 'len 11/5/2015 03:12'!
immanant
	^ self notYetImplemented! !

!Matrix methodsFor: 'operations' stamp: 'len 4/5/2018 15:49:34'!
inverse
	"Answer the multiplicative inverse of the receiver."
	self isSquare ifFalse: [^ DomainError signal: 'not a square matrix'].
	self scalars isField
		ifTrue: [^ (self reductionWith: self identity) extension].
	^ self adjugate / self determinant! !

!Matrix methodsFor: 'operations' stamp: 'len 4/5/2018 15:32:26'!
kronecker: aMatrix
	"Answer the Kronecker product of the receiver by the argument."
	| m n p q |
	self checkScalarsMatch: aMatrix.
	m _ self height.
	n _ self width.
	p _ aMatrix height.
	q _ aMatrix width.
	^ self scalars
		matrix: (m*p) @ (n*q)
		evaluating: [:i :j|
			(self at: (i-1)*m//(m*p)+1 @ ((j-1)*n//(n*q)+1)) *
			(aMatrix at: (i-1)\\p+1 @ ((j-1)\\q+1))]! !

!Matrix methodsFor: 'operations' stamp: 'len 4/5/2018 15:42:49'!
minimal: aTuple
	"Answer the minimal polynomial of aTuple with respect to the receiver."
	| columns power reduction d |
	columns _ OrderedCollection new: self height + 1.
	columns add: aTuple.
	power _ self identity.
	self height timesRepeat: [columns add: (power _ power * self) * aTuple].
	reduction _ (Matrix columns: columns) reduction.
	d _ reduction dependentColumns first.
	^ self scalars polynomials coefficients: (((reduction reduced columnAt: d) negated copyFrom: 1 to: d - 1) asArray copyWith: self scalars one)! !

!Matrix methodsFor: 'operations' stamp: 'len 4/5/2018 15:46:51'!
minimalPolynomial
	| answer |
	self isSquare ifFalse: [DomainError signal: 'not a square matrix'].
	self rowSpace basis do: [:each|
		answer _ answer isNil
			ifTrue: [self minimal: each]
			ifFalse: [answer lcm: (self minimal: each)]].
	^ answer! !

!Matrix methodsFor: 'operations' stamp: 'len 7/8/2016 23:45'!
minimalPolynomial2
	^ self characteristicPolynomial squareFree! !

!Matrix methodsFor: 'operations' stamp: 'len 4/5/2018 15:32:42'!
minor: aPoint
	"Answer the i@j-minor, i.e. the determinant of the matrix obtained by removing row i and column j from the receiver."
	^ (self scalars
		matrix: self height - 1 @ (self width - 1)
		evaluating: [:i :j|
			| x y |
			i < aPoint x ifTrue: [x _ i] ifFalse: [x _ i + 1].
			j < aPoint y ifTrue: [y _ j] ifFalse: [y _ j + 1].
			self at: x@y]) determinant! !

!Matrix methodsFor: 'operations' stamp: 'len 4/5/2018 15:32:51'!
minors: k
	"Answer the list of all the k-minors of the receiver, i.e. the determinants of all matrices obtained by deleting m - k rows and n - k columns."
	| answer |
	answer _ OrderedCollection new.
	(1 to: self height) combinations: k atATimeDo: [:rows|
		(1 to: self width) combinations: k atATimeDo: [:columns|
			answer add: (self scalars matrix: k@k evaluating: [:i :j| self at: (rows at: i) @ (columns at: j)]) determinant]].
	^ answer! !

!Matrix methodsFor: 'operations' stamp: 'len 3/23/2016 00:23'!
negated
	^ self collect: [:each| each negated]! !

!Matrix methodsFor: 'operations' stamp: 'len 4/5/2018 15:33:02'!
nullity
	^ self width - self rank! !

!Matrix methodsFor: 'operations' stamp: 'len 5/3/2018 01:22:45'!
permanent
	| n |
	self isSquare ifFalse: [DomainError signal: 'not a square matrix'].
	n _ self width.
	^ (SymmetricGroup new: n)
			sum: [:aPermutation| (1 to: n) product: [:i| self at: i at: (aPermutation value: i)]]! !

!Matrix methodsFor: 'operations' stamp: 'len 12/11/2015 00:14'!
pseudoInverse
	"Answer the Moore-Penrose pseudoinverse matrix of the receiver."
	^ self notYetImplemented! !

!Matrix methodsFor: 'operations' stamp: 'len 4/6/2017 10:34:28'!
rank
	self isEmpty ifTrue: [^ 0].
	^ self reduction rank! !

!Matrix methodsFor: 'operations' stamp: 'len 12/10/2015 23:51'!
reciprocal
	^ self inverse! !

!Matrix methodsFor: 'operations' stamp: 'len 5/16/2019 12:27:57'!
retraction
	"Answer a left inverse of the receiver."
	| T |
	T _ self transposed.
	^ (T * self) inverse * T! !

!Matrix methodsFor: 'operations' stamp: 'len 5/18/2018 20:17:43'!
rowAugmented: aMatrix
	"Answer the receiver augmented with the rows of aMatrix."
	| m |
	self isEmpty ifTrue: [^ aMatrix].
	aMatrix isEmpty ifTrue: [^ self].
	m _ self width.
	aMatrix isTuple
		ifTrue:
			[aMatrix size = m ifFalse: [^ DomainError signal: 'dimensions don''t match'].
			^ Matrix rows: (self rows copyWith: aMatrix)].
	aMatrix width = m ifFalse: [^ DomainError signal: 'dimensions don''t match'].
	^ Matrix rows: self rows, aMatrix rows! !

!Matrix methodsFor: 'operations' stamp: 'len 5/16/2019 12:28:31'!
section
	"Answer a right inverse of the receiver."
	| T |
	T _ self transposed.
	^ T * (self * T) inverse! !

!Matrix methodsFor: 'operations' stamp: 'len 3/28/2018 18:09:08'!
solveLeft: aMatrix
	"Answer X such that X * A = B, where A is self and B is aMatrix.
	The argument can also be a tuple, in which case it is considered
	as a row matrix and the returned value is also a tuple."
	aMatrix isTuple ifTrue: [^ self transposed solveRight: aMatrix].
	^ (self transposed solveRight: aMatrix transposed) transposed! !

!Matrix methodsFor: 'operations' stamp: 'len 5/30/2019 07:04:22'!
solveRight: aMatrix
	"Answer X such that A * X = B, where A is self and B is aMatrix.
	The argument can also be a tuple, in which case it is considered
	as a column matrix and the returned value is also a tuple."
	| R K A B M X |
	A _ self.
	B _ aMatrix isTuple ifTrue: [Matrix columns: {aMatrix}] ifFalse: [aMatrix].
	R _ self scalars.
	R isIntegralDomain ifFalse: [self notYetImplemented].
	R isField ifTrue: [K _ R] ifFalse: [K _ R fractions. A _ A over: K. B _ B over: K].
	(A isSquare and: [A isFullRank])
		ifTrue: [M _ A columnAugmented: B.
					X _ M echelon copyFrom: 1@(self width + 1) to: M extent]
		ifFalse: [X _ A solveRightGeneral: B].
	A * X = B ifFalse: [^ nil "no solution"].
	R = K ifFalse:
		[(X allSatisfy: [:each| R isUnit: each denominator]) ifFalse: [^ nil "no solutions in R"].
		X _ X over: R].
	^ aMatrix isTuple ifTrue: [X asTuple] ifFalse: [X]! !

!Matrix methodsFor: 'operations' stamp: 'len 4/5/2018 15:33:44'!
solveRightGeneral: aMatrix
	| n m reduction rows |
	m _ aMatrix width.
	n _ self width.
	reduction _ self reductionWith: aMatrix.
	rows _ OrderedCollection new.
	reduction independentColumns withIndexDo: [:column :i|
		column - 1 - rows size timesRepeat: [rows add: (self scalars zeroTuple: m)].
		rows add: (reduction extension rowAt: i)].
	n - rows size timesRepeat: [rows add: (self scalars zeroTuple: m)].
	^ Matrix rows: rows! !

!Matrix methodsFor: 'operations' stamp: 'len 11/3/2015 20:35'!
squared
	^ self * self! !

!Matrix methodsFor: 'operations' stamp: 'len 4/5/2018 15:43:14'!
trace
	| answer |
	self isSquare ifFalse: [^ DomainError signal: 'not a square matrix'].
	answer _ self scalars zero.
	1 to: self height do: [:i| answer _ answer + (self at: i@i)].
	^ answer! !

!Matrix methodsFor: 'operations' stamp: 'len 11/5/2016 03:39'!
transposed
	^ RowMatrix rows: self columns! !

!Matrix methodsFor: 'operations' stamp: 'len 4/29/2019 10:24:43'!
value: aTuple
	(self height = 0 or: [self width = aTuple size])
		ifFalse: [^ DomainError signal: 'dimensions don''t match'].
	self scalars >= aTuple scalars
		ifTrue: [^ self scalars tuple: self height evaluating: [:i| (self rowAt: i)  aTuple]].
	self scalars <= aTuple scalars
		ifTrue: [^ aTuple scalars tuple: self height evaluating: [:i| (self rowAt: i)  aTuple]].
	^ DomainError signal: 'base rings don''t match'! !

!Matrix methodsFor: 'printing' stamp: 'len 5/30/2019 16:18:16'!
isBroken
	^ self isEmpty not and: [(self allSatisfy: [:each| self scalars includes: each]) not]! !

!Matrix methodsFor: 'printing' stamp: 'len 3/2/2017 05:14:04'!
printBitsOn: aStream
	aStream nextPut: $[.
	self rows do: [:row|
		row do: [:bit| aStream nextPut: (bit isZero ifTrue: [$0] ifFalse: [$1])]]
			separatedBy: [aStream nextPut: $]; lf; nextPutAll: ' ['].
	aStream nextPut: $]! !

!Matrix methodsFor: 'printing' stamp: 'len 5/30/2019 16:17:04'!
printText
	self isBroken ifTrue: [^ super printText addAttribute: TextColor red].
	^ super printText! !

!Matrix methodsFor: 'reduction' stamp: 'len 9/28/2018 19:43:09'!
CHNF
	"Answer the column-style Hermite normal form of the receiver."
	| D |
	self isEmpty ifTrue: [^ self].
	(self scalars isKindOf: RationalIntegerRing) ifTrue: [^ (HermiteColumnReduction on: self) reduced].
	(self scalars isKindOf: RationalField) ifFalse: [^ DomainError signal: 'nonrational coefficients'].
	D _ self denominator.
	^ (HermiteColumnReduction on: self * D) reduced / D! !

!Matrix methodsFor: 'reduction' stamp: 'len 5/30/2019 16:04:18'!
HNF
	"Answer the (row-style) Hermite normal form of the receiver."
	self isEmpty ifTrue: [^ self].
	self scalars isLocalization ifTrue: [^ (self numerator HNF over: self scalars) / self denominator].
	^ (HermiteReduction on: self) reduced
"
alternative:
	^ self antitransposed CHNF antitransposed
"! !

!Matrix methodsFor: 'reduction' stamp: 'len 9/16/2018 16:14:30'!
LLL
	"Answer the LLL reduced form of the receiver."
	^ Matrix rows: (LLL basis: self rows) reducedBasis! !

!Matrix methodsFor: 'reduction' stamp: 'len 3/18/2018 14:44:50'!
Q
	"Perform the Gram-Schmidt orthonormalization process on the columns of the receiver and answer Q (from the QR factorization)."
	^ self transposed orthonormalized transposed! !

!Matrix methodsFor: 'reduction' stamp: 'len 3/16/2018 20:17:51'!
QR
	"Answer the QR factorization of the receiver."
	| Q R |
	Q _ self Q.
	R _ Q transposed * self.
	^ {Q. R}! !

!Matrix methodsFor: 'reduction' stamp: 'len 5/29/2019 11:56:03'!
RCF
	"Answer the rational canonical form of the receiver."
	^ self minimalPolynomial factors inject: (self scalars matrix: #()) into: [:matrix :each| matrix  each companion]! !

!Matrix methodsFor: 'reduction' stamp: 'len 5/30/2019 13:28:33'!
SNF
	"Answer the Smith normal form of the receiver.
	This is a naive implementation of Kannan-Bachem algorithm."
	| H a |
	self isEmpty ifTrue: [^ self].
	"Repeatedly compute the Hermite normal form and transposes until a diagonal form is obtained:"
	H _ self HNF.
	[H isDiagonal] whileFalse: [H _ H transposed HNF transposed HNF].
	"Once in diagonal form, substitute neighboring diagonal elements by their gcd and lcm:"
	[a _ H at: 1 at: 1.
	2 to: (H width min: H height) do: [:i| | b gcd |
		b _ H at: i at: i.
		H at: i-1 at: i-1 put: (gcd _ a gcd: b). "gcd"
		H at: i at: i put: (a _ a // gcd * b) "lcm"].
	H isSmithNormalForm] whileFalse.
	^ H! !

!Matrix methodsFor: 'reduction' stamp: 'len 5/28/2019 08:55:44'!
SNF2
	"Answer the Smith normal form of the receiver. Perform first a HNF reduction."
	| H n |
	H _ self HNF.
	n _ H diagonal findLast: [:each| each isZero not].
	^ (H copyFrom: 1@1 to: n@n) SNF  (self scalars zeroMatrix: (H width max: H height) - n)! !

!Matrix methodsFor: 'reduction' stamp: 'len 5/29/2019 16:04:59'!
SNF3
	"Answer the Smith normal form of the receiver."
	self isEmpty ifTrue: [^ self].
	self scalars isPID ifFalse: [^ DomainError signal: 'coefficients ring is not a PID'].
	^ SmithReduction new matrix: self copy; reduced! !

!Matrix methodsFor: 'reduction' stamp: 'len 5/30/2019 03:24:41'!
SNFAfterHNF
	"Answer the Smith normal form of the receiver. Perform first a HNF reduction."
	| H n |
	H _ self HNF.
	n _ H diagonal findLast: [:each| each isZero not].
	^ (H copyFrom: 1@1 to: n@n) SNF  (self scalars zeroMatrix: (H width max: H height) - n)! !

!Matrix methodsFor: 'reduction' stamp: 'len 5/30/2019 07:20:01'!
SNFOneStep
	| L S R zero one j k |
	L _ self leftIdentity.
	R _ self rightIdentity.
	(self isEmpty or: [self isZero]) ifTrue: [^ {L. self. R}].
	S _ self copy.
	zero _ self scalars zero.
	one _ self scalars one.

	"put a non-zero column as first column"
	j _ 1.
	[(S columnAt: j) isZero] whileTrue: [j _ j + 1].
	j > 1 ifTrue: [R at: 1@1 put: zero; at: j@j put: zero; at: 1@j put: one; at: j@1 put: one negated. S _ S * R].

	self assert: self * R = S.

	"put a non-zero value at 1@1:"
	k _ 1.
	[(S at: k@1) isZero] whileTrue: [k _ k + 1].
	k > 1 ifTrue: [L at: 1@1 put: zero; at: k@k put: zero; at: 1@k put: one; at: k@1 put: one negated. S _ L * S].

	self assert: L * self * R = S.

	2 to: S height do: [:i| | a1 ai euclid c d e f M |
		a1 _ S at: 1@1.
		ai _ S at: i@1.
		ai | a1 ifFalse:
			[euclid _ ExtendedEuclid on: {a1. ai}.
			c _ euclid bezout at: 1.
			d _ (euclid bezout at: 2) negated.
			self assert: a1*c - (ai*d) = euclid gcd.
			e _ ai negated / euclid gcd.
			f _ a1 / euclid gcd.
			self assert: d*e + (c*f) = self scalars one.
			M _ S leftIdentity.
			M at: 1@1 put: c; at: 1@i put: d negated; at: i@1 put: e; at: i@i put: f.
			self assert: M determinant = self scalars one.
			S _ M * S.
			L _ M * L.
			self assert: L * self * R = S]].

	"now everything in column 1 is divisible by the pivot at 1@1:"
	2 to: S height do: [:i| | x |
		x _ (S at: i@1) negated / (S at: 1@1).
		S addRow: 1 times: x toRow: i.
		L addRow: 1 times: x toRow: i].

	self assert: L * self * R = S.

	"if anything at the right of the pivot in the first row is not zero, we recurse
	(the algorithm must termiate if the cofficients ring is Noetherian)"
	((j+1 to: self width) allSatisfy: [:jj| (S at: 1@jj) isZero])
		ifFalse:
			[| result |
			result _ S transposed SNFOneStep.
			L _ (result at: 3) * L.
			S _ (result at: 2) transposed.
			R _ R * (result at: 1) transposed].

	^ {L. S. R}! !

!Matrix methodsFor: 'reduction' stamp: 'len 5/5/2019 17:20:22'!
SNFRecursive
	| L S R LL SS RR I result |
	L _ self leftIdentity.
	R _ self rightIdentity.
	(self isEmpty or: [self isZero]) ifTrue: [^ {L. self. R}].

	result _ self SNFOneStep.
	L _ result at: 1.
	S _ result at: 2.
	R _ result at: 3.
	result _ (S copyFrom: 2@2 to: S extent) SNFRecursive.
	LL _ result at: 1.
	SS _ result at: 2.
	RR _ result at: 3.
	
	I _ self scalars identityMatrix: 1.
	L _ I  LL * L.
	S _ (I * (S at: 1@1))  SS.
	R _ R * (I  RR).

	"TODO: fix diagonal"
	
	^ {L. S. R}! !

!Matrix methodsFor: 'reduction' stamp: 'len 3/18/2018 16:17:54'!
echelon
	"Answer the echelon form of the receiver."
	self isEmpty ifTrue: [^ self].
	^ self reduction reduced! !

!Matrix methodsFor: 'reduction' stamp: 'len 5/29/2019 15:54:23'!
elementaryDivisors
	"Answer the diagonal of the Smith normal form."
	self isEmpty ifTrue: [^ #()].
	self scalars isField ifTrue: [^ (1 to: self rank) collect: [:each| self scalars one]].
	^ self SNF diagonal asArray! !

!Matrix methodsFor: 'reduction' stamp: 'len 4/7/2018 06:26:26'!
jordan
	"Answer the Jordan blocks of the receiver's Jordan normal form."
	| spectrum blocks one zero |
	spectrum _ self spectrum.
	spectrum size = self height ifFalse: [^ self error: 'the characteristic polynomial doesn''t split'].
"	I _ matrix species identity."
	blocks _ Bag new.
	one _ self scalars one.
	zero _ self scalars zero.
	spectrum asSet do: [:eigenvalue|
		| multiplicity dimensions X T count |
		multiplicity _ spectrum occurrencesOf: eigenvalue.
		dimensions _ OrderedCollection new.
		X _ self - (self scalars matrix: self extent scalar: eigenvalue).
		T _ X.
		[(dimensions add: T nullity) < multiplicity] whileTrue: [T _ T * X].
		count _ 0.
		dimensions size to: 1 by: -1 do: [:n| | k block |
			k _ (dimensions at: n) - (dimensions at: n-1 ifAbsent: [0]).
			block _ self scalars matrix: n evaluating: [:i :j| i=j ifTrue: [eigenvalue] ifFalse: [j-1=i ifTrue: [one] ifFalse: [zero]]].
			blocks add: block withOccurrences: k - count.
			count _ count + k]].
	^ blocks! !

!Matrix methodsFor: 'reduction' stamp: 'len 4/29/2019 10:22:07'!
orthogonalized
	"Perform the Gram-Schmidt orthogonalization process on the rows of the receiver."
	| orthogonalVectors u uv vv |
	orthogonalVectors _ OrderedCollection new: self height.
	self rows do: [:each|
		u _ each.
		orthogonalVectors do: [:v|
			uv _ u  v.
			vv _ v  v.
			u _ u - (v * uv / vv)].
		orthogonalVectors add: u].
	^ Matrix rows: orthogonalVectors! !

!Matrix methodsFor: 'reduction' stamp: 'len 3/18/2018 14:44:25'!
orthonormalized
	"Perform the Gram-Schmidt orthonormalization process on the rows of the receiver."
	^ Matrix rows: (self orthogonalized rows collect: [:each| each / each norm])! !

!Matrix methodsFor: 'reduction' stamp: 'len 1/19/2018 22:15:38'!
reduction
	^ self reductionWith: nil! !

!Matrix methodsFor: 'reduction' stamp: 'len 3/19/2018 20:55:57'!
reductionWith: aMatrix
	self scalars isField
		ifTrue: [^ GaussianElimination on: self extension: aMatrix].
	(self scalars isKindOf: RationalIntegerRing)
		ifTrue: [^ HermiteReduction on: self extension: aMatrix].
"	self scalars isPID
		ifTrue: [^ SmithReduction on: self extension: aMatrix]."
	self scalars isIntegralDomain
		ifTrue: [^ GaussBareiss on: self extension: aMatrix].
	^ DomainError signal! !

!Matrix methodsFor: 'spectrum' stamp: 'len 4/7/2018 06:25:14'!
eigenspaceAt: anEigenvalue
	^ (self scalars matrix: self extent evaluating: [:i :j| i = j ifTrue: [(self at: i@j) - anEigenvalue] ifFalse: [self at: i@j]]) kernel! !

!Matrix methodsFor: 'spectrum' stamp: 'len 2/6/2016 19:39'!
eigenvalues
	^ self spectrum asSet! !

!Matrix methodsFor: 'spectrum' stamp: 'len 2/22/2017 08:46:13'!
spectralRadius
	(self scalars isReal or: [self scalars isComplex])
		ifFalse: [^ DomainError signal: 'spectral radius is only defined for matrices with complex scalars'].
	^ self spectrum max: [:each| each abs]! !

!Matrix methodsFor: 'spectrum' stamp: 'len 3/27/2018 16:26:17'!
spectrum
	^ self characteristicPolynomial allRoots! !

!Matrix methodsFor: 'subspaces' stamp: 'len 3/2/2017 04:17:51'!
coimage
	"Answer the row space of the receiver, i.e. the space spanned by the row tuples.
	This is perpendicular to the kernel or nullspace, and it's also called coimage."
	^ self transposed image! !

!Matrix methodsFor: 'subspaces' stamp: 'len 3/2/2017 04:20:30'!
cokernel
	"Answer the cokernel or left nullspace of the receiver.
	This is the space of tuples x such that x*A = 0, and it is perpendicular to the column space or image."
	^ self transposed kernel
"
alternative implementation, but much slower:
	^ self image perp
"! !

!Matrix methodsFor: 'subspaces' stamp: 'len 4/5/2018 15:41:35'!
cokernelMatrix
	"Answer the a matrix whose rows span the cokernel (or left kernel) of the receiver.
	If the receiver is A, the output is X such that X*A = 0."
	| reduction kernel |
	"Reduce the agumented matrix [A | I], then a linear basis of the kernel is given by the rows of the extension corresponding to zero rows in the reduced matrix."
	reduction _ self reductionWith: (self scalars identityMatrix: self height).
	kernel _ OrderedCollection new.
	reduction reduced rows withIndexDo: [:row :i|
		row isZero ifTrue: [kernel add: (reduction extension rowAt: i)]].
	^ Matrix rows: kernel! !

!Matrix methodsFor: 'subspaces' stamp: 'len 3/1/2017 12:47:24'!
columnSpace
	"Answer the column space of the receiver, i.e. the space spanned by the column tuples.
	This is perpendicular to the cokernel or left nullspace, and it's also called image."
	^ self image
"	^ self scalars ^ self numberOfRows span: self columns"! !

!Matrix methodsFor: 'subspaces' stamp: 'len 4/5/2018 15:42:04'!
image
	"Answer the column space of the receiver, i.e. the space spanned by the column tuples.
	This is perpendicular to the cokernel or left nullspace, and it's also called image."
	^ self scalars ^ self height span: self imageMatrix! !

!Matrix methodsFor: 'subspaces' stamp: 'len 1/24/2018 22:15:34'!
imageMatrix
	"Answer a matrix whose rows span the image or column space of the receiver."
	| reduction |
	self isEmpty ifTrue: [^ self].
	reduction _ self reduction.
	^ Matrix rows: (reduction independentColumns collect: [:i| self columnAt: i])! !

!Matrix methodsFor: 'subspaces' stamp: 'len 4/5/2018 15:32:07'!
kernel
	^ self scalars ^ self width span: self kernelMatrix
"
alternative implementation, but much slower:
	^ self coimage perp
"! !

!Matrix methodsFor: 'subspaces' stamp: 'len 4/4/2018 00:29:01'!
kernelMatrix
	"Answer the a matrix whose rows span the (right) kernel or nullspace of the receiver.
	If the receiver is A, the output is X such that A*X = 0."
	^ self transposed cokernelMatrix! !

!Matrix methodsFor: 'subspaces' stamp: 'len 3/2/2017 04:17:37'!
rowSpace
	"Answer the row space of the receiver, i.e. the space spanned by the row tuples.
	This is perpendicular to the kernel or nullspace, and it's also called coimage."
	^ self coimage
"	^ self scalars ^ self numberOfColumns span: self rows"! !

!Matrix methodsFor: 'testing' stamp: 'len 11/26/2015 01:40'!
is: aSymbol
	^ aSymbol == #Matrix or: [super is: aSymbol]! !

!Matrix methodsFor: 'testing' stamp: 'len 5/30/2019 04:43:29'!
isDiagonal
	^ self isLowerTriangular and: [self isUpperTriangular]! !

!Matrix methodsFor: 'testing' stamp: 'len 3/7/2017 08:22:30'!
isEchelonForm
	"Answer true if the receiver is in echelon form.
	It must satisfy the following conditions:
	1. All nonzero rows are above any rows of all zeros;
	2. The leading coefficient (or pivot) of each nonzero row is always strictly to the right of the pivot of the row above it."
	| lastPivot |
	lastPivot _ 0@0.
	self pivotsDo: [:each|
		(each y > lastPivot y and: [each x - lastPivot x = 1])
			ifFalse: [^ false].
		lastPivot _ each].
	^ true! !

!Matrix methodsFor: 'testing' stamp: 'len 4/5/2018 15:31:35'!
isFullRank
	^ self rank = (self width min: self height)! !

!Matrix methodsFor: 'testing' stamp: 'len 5/30/2019 04:10:55'!
isHermiteNormalForm
	"Answer true if the receiver is in (row) Hermite normal form.
	It must satisfy the following conditions:
	1. It is upper triangular;
	2. The leading coefficient (or pivot) of a nonzero row is always strictly to the right of the leading coefficient of the row above it, and it is positive;
	3. And the elements below pivots are zero and elements above pivots are nonnegative and strictly smaller than the pivot."
	| lastPivot |
	lastPivot _ 0@0.
	self pivotsDo: [:each| | coefficient |
		(each x <= each y and: [each y > lastPivot y and: [each x - lastPivot x = 1]])
			ifFalse: [^ false].
		coefficient _ self at: each.
		coefficient > 0 ifFalse: [^ false].
		1 to: each x - 1 do: [:i| | v |
			((v _ self at: i@each y) >= 0 and: [v < coefficient])
				ifFalse: [^ false]].
		each x + 1 to: self height do: [:i|
			(self at: i@each y) = 0
				ifFalse: [^ false]].
		lastPivot _ each].
	^ true! !

!Matrix methodsFor: 'testing' stamp: 'len 6/23/2016 23:25'!
isHermitian
	"Answer true if the receiver is Hermitian (or self-adjoint)."
	^ self = self adjoint! !

!Matrix methodsFor: 'testing' stamp: 'len 11/5/2016 03:38'!
isIdentity
	^ self = self identity! !

!Matrix methodsFor: 'testing' stamp: 'len 9/27/2018 21:50:44'!
isInvertible
	^ self scalars isUnit: self determinant! !

!Matrix methodsFor: 'testing' stamp: 'len 4/5/2018 15:31:48'!
isLowerTriangular
	1 to: (self width min: self height) do: [:i|
		i+1 to: self width do: [:j| (self at: i@j) isZero ifFalse: [^ false]]].
	^ true! !

!Matrix methodsFor: 'testing' stamp: 'len 4/2/2018 05:16:26'!
isMatrix
	^ true! !

!Matrix methodsFor: 'testing' stamp: 'len 9/22/2018 18:55:17'!
isNilpotent
	"Answer true if self^n = 0 for some integer n >= 1."
	^ self trace isZero and: [self determinant isZero]! !

!Matrix methodsFor: 'testing' stamp: 'len 12/31/2015 05:52'!
isNormal
	^ self adjoint * self = (self * self adjoint)! !

!Matrix methodsFor: 'testing' stamp: 'len 2/6/2016 20:15'!
isOrthogonal
	"A real square matrix Q is orthogonal if Q^t * Q = I (the transposed is the inverse).
	Equivalently:
		- Q has orthonormal columns and rows;
		- For all v, ||Qv|| = ||v||."
	^ self isSquare and: [(self * self transposed) isIdentity]! !

!Matrix methodsFor: 'testing' stamp: 'len 5/23/2016 19:55'!
isRankDeficient
	^ self isFullRank not! !

!Matrix methodsFor: 'testing' stamp: 'len 4/5/2018 15:42:17'!
isReducedEchelonForm
	"Answer true if the receiver is in reduced (row) echelon form.
	It must satisfy the following conditions:
	1. It is in row echelon form;
	2. And every leading coefficient is 1 and is the only nonzero entry in its column."
	| lastPivot one |
	lastPivot _ 0@0.
	one _ self scalars one.
	self pivotsDo: [:each|
		(each y > lastPivot y and: [each x - lastPivot x = 1])
			ifFalse: [^ false].
		(self at: each) = one ifFalse: [^ false].
		1 to: self height do: [:j|
			(j = each x or: [(self at: j @ each y) isZero]) ifFalse: [^ false]].
		lastPivot _ each].
	^ true! !

!Matrix methodsFor: 'testing' stamp: 'len 4/5/2018 15:42:21'!
isScalar
	self isDiagonal ifFalse: [^ false].
	2 to: self height do: [:i|
		(self at: i@i) = (self at: 1@1) ifFalse: [^ false]].
	^ true! !

!Matrix methodsFor: 'testing' stamp: 'len 3/17/2016 05:12'!
isSemisimple
	^ self minimalPolynomial isSquareFree! !

!Matrix methodsFor: 'testing' stamp: 'len 12/31/2015 05:53'!
isSingular
	"Answer true if the receiver is a singular matrix."
	^ self determinant isZero! !

!Matrix methodsFor: 'testing' stamp: 'len 12/31/2015 05:51'!
isSkewHermitian
	"Answer true if the receiver is skew-Hermitian (or antihermitian)."
	^ self = self adjoint negated! !

!Matrix methodsFor: 'testing' stamp: 'len 3/3/2017 13:44:02'!
isSkewSymmetric
	"Answer true if the receiver is a skew-symmetric (or anti-symmetric) matrix."
	^ self negated = self transposed! !

!Matrix methodsFor: 'testing' stamp: 'len 5/30/2019 04:51:17'!
isSmithNormalForm
	"Answer true if the receiver is in Smith normal form."
	| diagonal previousEntry n0 |
	self isDiagonal ifFalse: [^ false].
	self isEmpty ifTrue: [^ true].
	diagonal _ self diagonal.
	previousEntry _ diagonal first.
	n0 _ diagonal lastNonZero.
	2 to: n0 do: [:i| | thisEntry |
		thisEntry _ diagonal at: i.
		previousEntry | thisEntry ifFalse: [^ false].
		previousEntry _ thisEntry].
	n0+1 to: diagonal size do: [:i|
		(diagonal at: i) isZero ifFalse: [^ false]].
	^ true! !

!Matrix methodsFor: 'testing' stamp: 'len 4/5/2018 15:31:59'!
isSquare
	^ self height = self width! !

!Matrix methodsFor: 'testing' stamp: 'len 3/21/2018 20:35:09'!
isSymmetric
	^ self = self transposed! !

!Matrix methodsFor: 'testing' stamp: 'len 3/2/2017 19:36:13'!
isTriangular
	^ self isLowerTriangular or: [self isUpperTriangular]! !

!Matrix methodsFor: 'testing' stamp: 'len 3/2/2017 21:06:31'!
isUnimodular
	^ self scalars isUnit: self determinant! !

!Matrix methodsFor: 'testing' stamp: 'len 2/6/2016 20:16'!
isUnitary
	"A complex square matrix U is unitary if U* * U = I (the adjoint is the inverse).
	Equivalently:
		- U has orthonormal columns and rows;
		- For all v, ||Uv|| = ||v||."
	^ self isSquare and: [(self * self adjoint) isIdentity]! !

!Matrix methodsFor: 'testing' stamp: 'len 11/2/2015 06:04'!
isUpperTriangular
	^ self transposed isLowerTriangular! !

!Matrix methodsFor: 'testing' stamp: 'len 3/23/2016 00:27'!
isZero
	self do: [:each| each isZero ifFalse: [^ false]].
	^ true! !

!Matrix methodsFor: 'testing' stamp: 'len 12/1/2016 17:03:47'!
isZeroAt: aPoint
	^ (self at: aPoint) isZero! !

!Matrix methodsFor: 'private' stamp: 'len 4/7/2018 06:24:49'!
checkDimensionMatch: aMatrix
	(self width = aMatrix width and: [self height = aMatrix height])
		ifFalse: [^ DomainError signal: 'matrix sizes don''t match']! !

!Matrix methodsFor: 'private' stamp: 'len 5/19/2018 17:04:00'!
checkScalarsMatch: aMatrix
	(self isEmpty or: [self scalars = aMatrix scalars])
		ifFalse: [^ DomainError signal: 'base rings don''t match']! !

!Matrix methodsFor: 'private' stamp: 'len 12/13/2016 09:51:35'!
hadamardBound
	"Answer a bound N on the determinant of the receiver such that |det A| < 2^N.
	Assume the coefficients are real."
	^ (self rows sum: [:row| (row sum: [:each| each squared])]) log2 min: (self columns sum: [:column| (column sum: [:each| each squared])]) log2! !

!Matrix class methodsFor: 'instance creation' stamp: 'len 1/17/2017 08:12:11'!
columns: anArray
	^ ColumnMatrix columns: anArray! !

!Matrix class methodsFor: 'instance creation' stamp: 'len 11/29/2016 11:46:49'!
diagonal: aTuple
	| zero |
	zero _ aTuple scalars zero.
	^ self rows: ((1 to: aTuple size) collect: [:i| aTuple scalars tuple: aTuple size evaluating: [:j| j = i ifTrue: [aTuple at: i] ifFalse: [zero]]])! !

!Matrix class methodsFor: 'instance creation' stamp: 'len 11/11/2016 08:58'!
rows: anArray
	^ RowMatrix rows: anArray! !

!ColumnMatrix methodsFor: 'accessing' stamp: 'len 3/23/2016 02:45'!
addColumn: aTuple
	^ columns add: aTuple! !

!ColumnMatrix methodsFor: 'accessing' stamp: 'len 3/23/2016 02:45'!
at: i at: j
	^ (columns at: j) at: i! !

!ColumnMatrix methodsFor: 'accessing' stamp: 'len 3/23/2016 02:46'!
at: i at: j put: anObject
	^ (columns at: j) at: i put: anObject! !

!ColumnMatrix methodsFor: 'accessing' stamp: 'len 3/23/2016 02:53'!
columnAt: j
	^ columns at: j! !

!ColumnMatrix methodsFor: 'accessing' stamp: 'len 3/23/2016 02:54'!
columnAt: i put: aTuple
	^ columns at: i put: aTuple! !

!ColumnMatrix methodsFor: 'accessing' stamp: 'len 3/23/2016 02:55'!
columns
	^ columns! !

!ColumnMatrix methodsFor: 'accessing' stamp: 'len 3/23/2016 02:56'!
columns: anArray
	columns _ anArray! !

!ColumnMatrix methodsFor: 'accessing' stamp: 'len 4/23/2018 21:09:52'!
denominator
	| answer |
	self scalars isLocalization ifFalse: [^ self scalars one].
	answer _ self scalars integers one.
	columns do: [:each| answer _ each denominator lcm: answer].
	^ answer! !

!ColumnMatrix methodsFor: 'accessing' stamp: 'len 4/5/2018 15:18:03'!
height
	columns isEmpty ifTrue: [^ 0].
	^ columns first size! !

!ColumnMatrix methodsFor: 'accessing' stamp: 'len 4/23/2018 21:06:19'!
lift
	"If the coefficients ring is a quotient R/I, answer a representative of the receiver over R. See >>%."
	^ self class columns: (columns collect: [:each| each lift])! !

!ColumnMatrix methodsFor: 'accessing' stamp: 'len 4/23/2018 21:06:28'!
representative
	"If the coefficients ring is a quotient R/I, answer a representative of the receiver over R. See >>%."
	^ self class columns: (columns collect: [:each| each representative])! !

!ColumnMatrix methodsFor: 'accessing' stamp: 'len 4/22/2016 21:54'!
rowAt: i
	^ self scalars tuple: (columns collect: [:each | each at: i])! !

!ColumnMatrix methodsFor: 'accessing' stamp: 'len 11/5/2016 03:24'!
scalars
	^ columns first scalars! !

!ColumnMatrix methodsFor: 'accessing' stamp: 'len 4/5/2018 15:18:20'!
width
	^ columns size! !

!ColumnMatrix methodsFor: 'converting' stamp: 'len 4/5/2018 01:00:26'!
over: aRing
	(self isEmpty or: [self scalars = aRing]) ifFalse: [^ self class columns: (self columns collect: [:each| each over: aRing])]! !

!ColumnMatrix methodsFor: 'copying' stamp: 'len 1/17/2017 11:11:59'!
copy
	^ self class columns: (columns collect: [:each| each copy])! !

!ColumnMatrix methodsFor: 'enumerating' stamp: 'len 3/24/2018 19:28:43'!
allSatisfy: aBlock
	^ columns allSatisfy: [:each| each allSatisfy: aBlock]! !

!ColumnMatrix methodsFor: 'enumerating' stamp: 'len 11/5/2016 03:43'!
collect: aBlock
	^ self class columns: (columns collect: [:each| each collect: aBlock])! !

!ColumnMatrix methodsFor: 'enumerating' stamp: 'len 3/23/2016 02:57'!
columnsDo: aBlock
	columns do: aBlock! !

!ColumnMatrix methodsFor: 'operations' stamp: 'len 11/5/2016 03:43'!
% anInteger
	^ self class columns: (self columns collect: [:each| each % anInteger])! !

!ColumnMatrix methodsFor: 'operations' stamp: 'len 5/18/2018 20:14:33'!
+ aMatrix
	self checkDimensionMatch: aMatrix.
	self checkScalarsMatch: aMatrix.
	^ self class columns: columns + aMatrix columns! !

!ColumnMatrix methodsFor: 'operations' stamp: 'len 5/18/2018 20:14:38'!
- aMatrix
	self checkDimensionMatch: aMatrix.
	self checkScalarsMatch: aMatrix.
	^ self class columns: columns - aMatrix columns! !

!ColumnMatrix methodsFor: 'operations' stamp: 'len 11/5/2016 03:43'!
negated
	^ self class columns: columns negated! !

!ColumnMatrix methodsFor: 'reduction-operations' stamp: 'len 5/30/2019 07:11:23'!
addColumn: src times: aNumber toColumn: dst
	self addColumn: src times: aNumber toColumn: dst startingAt: 1! !

!ColumnMatrix methodsFor: 'reduction-operations' stamp: 'len 5/30/2019 07:11:05'!
addColumn: src times: aNumber toColumn: dst startingAt: columnIndex
	(columns at: dst) add: (columns at: src) times: aNumber startingAt: columnIndex! !

!ColumnMatrix methodsFor: 'reduction-operations' stamp: 'len 5/30/2019 07:18:45'!
addRow: i times: aNumber toRow: j
	columns do: [:each| each at: j put: (each at: i) * aNumber + (each at: j)]! !

!ColumnMatrix methodsFor: 'reduction-operations' stamp: 'len 1/16/2018 22:10:18'!
multiplyColumn: i by: aNumber
	self multiplyColumn: i by: aNumber startingAt: 1! !

!ColumnMatrix methodsFor: 'reduction-operations' stamp: 'len 1/16/2018 22:10:00'!
multiplyColumn: i by: aNumber startingAt: startIndex
	(columns at: i) multiplyBy: aNumber startingAt: startIndex! !

!ColumnMatrix methodsFor: 'reduction-operations' stamp: 'len 1/16/2018 22:10:27'!
multiplyRow: i by: aNumber
	columns do: [:each| each at: i put: (each at: i) * aNumber]! !

!ColumnMatrix methodsFor: 'reduction-operations' stamp: 'len 3/3/2017 12:11:47'!
swapColumn: i with: j
	columns swap: i with: j! !

!ColumnMatrix methodsFor: 'reduction-operations' stamp: 'len 3/3/2017 12:07:39'!
swapRow: i with: j
	columns do: [:each| each swap: i with: j]! !

!ColumnMatrix methodsFor: 'testing' stamp: 'len 4/6/2017 10:34:51'!
isEmpty
	^ columns isEmpty! !

!ColumnMatrix methodsFor: 'testing' stamp: 'len 3/23/2016 02:44'!
isZero
	^ columns allSatisfy: [:each| each isZero]! !

!ColumnMatrix methodsFor: 'testing' stamp: 'len 12/1/2016 17:05:02'!
isZeroAt: aPoint
	^ (columns at: aPoint y) isZeroAt: aPoint x! !

!ColumnMatrix class methodsFor: 'instance creation' stamp: 'len 7/15/2016 05:08'!
columns: anArray
	^ self basicNew columns: anArray! !

!ColumnMatrix class methodsFor: 'instance creation' stamp: 'len 7/15/2016 05:07'!
new
	^ self columns: OrderedCollection new! !

!ColumnMatrix class methodsFor: 'instance creation' stamp: 'len 1/17/2017 11:13:38'!
newFrom: aMatrix
	^ self columns: (aMatrix columns collect: [:each| each copy])! !

!RowMatrix methodsFor: 'accessing' stamp: 'len 3/23/2016 00:19'!
addRow: aTuple
	^ rows add: aTuple! !

!RowMatrix methodsFor: 'accessing' stamp: 'len 3/23/2016 02:46'!
at: i at: j
	^ (rows at: i) at: j! !

!RowMatrix methodsFor: 'accessing' stamp: 'len 3/23/2016 02:46'!
at: i at: j put: anObject
	^ (rows at: i) at: j put: anObject! !

!RowMatrix methodsFor: 'accessing' stamp: 'len 4/22/2016 21:40'!
columnAt: j
	^ self scalars tuple: rows size evaluating: [:i| (rows at: i) at: j ifAbsent: [self scalars zero]]! !

!RowMatrix methodsFor: 'accessing' stamp: 'len 4/23/2018 21:09:39'!
denominator
	| answer |
	self scalars isLocalization ifFalse: [^ self scalars one].
	answer _ self scalars integers one.
	rows do: [:each| answer _ each denominator lcm: answer].
	^ answer! !

!RowMatrix methodsFor: 'accessing' stamp: 'len 4/5/2018 15:19:15'!
height
	^ rows size! !

!RowMatrix methodsFor: 'accessing' stamp: 'len 4/23/2018 21:05:56'!
lift
	"If the coefficients ring is a quotient R/I, answer a representative of the receiver over R. See >>%."
	^ self class rows: (rows collect: [:each| each lift])! !

!RowMatrix methodsFor: 'accessing' stamp: 'len 4/23/2018 21:05:41'!
representative
	"If the coefficients ring is a quotient R/I, answer a representative of the receiver over R. See >>%."
	^ self class rows: (rows collect: [:each| each representative])! !

!RowMatrix methodsFor: 'accessing' stamp: 'len 3/23/2016 00:16'!
rowAt: i
	^ rows at: i! !

!RowMatrix methodsFor: 'accessing' stamp: 'len 3/23/2016 00:18'!
rowAt: i put: aTuple
	^ rows at: i put: aTuple! !

!RowMatrix methodsFor: 'accessing' stamp: 'len 3/23/2016 00:17'!
rows
	^ rows! !

!RowMatrix methodsFor: 'accessing' stamp: 'len 11/5/2016 03:25'!
scalars
	^ rows first scalars! !

!RowMatrix methodsFor: 'accessing' stamp: 'len 4/5/2018 15:19:20'!
width
	rows isEmpty ifTrue: [^ 0].
	^ rows first size! !

!RowMatrix methodsFor: 'converting' stamp: 'len 4/5/2018 00:59:57'!
over: aRing
	(self isEmpty or: [self scalars = aRing]) ifFalse: [^ self class rows: (self rows collect: [:each| each over: aRing])]! !

!RowMatrix methodsFor: 'copying' stamp: 'len 1/17/2017 11:12:10'!
copy
	^ self class rows: (rows collect: [:each| each copy])! !

!RowMatrix methodsFor: 'enumerating' stamp: 'len 3/24/2018 19:28:25'!
allSatisfy: aBlock
	^ rows allSatisfy: [:each| each allSatisfy: aBlock]! !

!RowMatrix methodsFor: 'enumerating' stamp: 'len 11/5/2016 03:41'!
collect: aBlock
	^ self class rows: (rows collect: [:each| each collect: aBlock])! !

!RowMatrix methodsFor: 'enumerating' stamp: 'len 11/27/2016 13:23:25'!
do: aBlock
	self rowsDo: [:each| each do: aBlock]! !

!RowMatrix methodsFor: 'enumerating' stamp: 'len 3/23/2016 00:18'!
rowsDo: aBlock
	rows do: aBlock! !

!RowMatrix methodsFor: 'initialization' stamp: 'len 3/23/2016 00:20'!
rows: anArray
	rows _ anArray! !

!RowMatrix methodsFor: 'operations' stamp: 'len 11/5/2016 03:40'!
% anInteger
	^ self class rows: (self rows collect: [:each| each % anInteger])! !

!RowMatrix methodsFor: 'operations' stamp: 'len 5/18/2018 20:14:20'!
+ aMatrix
	self checkDimensionMatch: aMatrix.
	self checkScalarsMatch: aMatrix.
	^ self class rows: rows + aMatrix rows! !

!RowMatrix methodsFor: 'operations' stamp: 'len 5/18/2018 20:14:26'!
- aMatrix
	self checkDimensionMatch: aMatrix.
	self checkScalarsMatch: aMatrix.
	^ self class rows: rows - aMatrix rows! !

!RowMatrix methodsFor: 'operations' stamp: 'len 11/5/2016 03:41'!
negated
	^ self class rows: rows negated! !

!RowMatrix methodsFor: 'reduction-operations' stamp: 'len 5/30/2019 07:22:05'!
addColumn: i times: aNumber toColumn: j
	rows do: [:each| each at: j put: (each at: i) * aNumber + (each at: j)]! !

!RowMatrix methodsFor: 'reduction-operations' stamp: 'len 5/30/2019 07:21:28'!
addRow: src times: aNumber toRow: dst
	self addRow: src times: aNumber toRow: dst startingAt: 1! !

!RowMatrix methodsFor: 'reduction-operations' stamp: 'len 5/30/2019 07:21:44'!
addRow: src times: aNumber toRow: dst startingAt: columnIndex
	(rows at: dst) add: (rows at: src) times: aNumber startingAt: columnIndex! !

!RowMatrix methodsFor: 'reduction-operations' stamp: 'len 1/16/2018 22:11:15'!
multiplyColumn: i by: aNumber
	rows do: [:each| each at: i put: (each at: i) * aNumber]! !

!RowMatrix methodsFor: 'reduction-operations' stamp: 'len 1/16/2018 22:08:39'!
multiplyRow: i by: aNumber
	self multiplyRow: i by: aNumber startingAt: 1! !

!RowMatrix methodsFor: 'reduction-operations' stamp: 'len 1/16/2018 22:08:30'!
multiplyRow: i by: aNumber startingAt: startIndex
	(rows at: i) multiplyBy: aNumber startingAt: startIndex! !

!RowMatrix methodsFor: 'reduction-operations' stamp: 'len 3/23/2016 00:20'!
swapColumn: i with: j
	rows do: [:each| each swap: i with: j]! !

!RowMatrix methodsFor: 'reduction-operations' stamp: 'len 3/23/2016 00:17'!
swapRow: i with: j
	rows swap: i with: j! !

!RowMatrix methodsFor: 'testing' stamp: 'len 4/6/2017 10:35:01'!
isEmpty
	^ rows isEmpty! !

!RowMatrix methodsFor: 'testing' stamp: 'len 3/23/2016 00:19'!
isZero
	^ rows allSatisfy: [:each| each isZero]! !

!RowMatrix methodsFor: 'testing' stamp: 'len 12/1/2016 17:04:49'!
isZeroAt: aPoint
	^ (rows at: aPoint x) isZeroAt: aPoint y! !

!RowMatrix class methodsFor: 'instance creation' stamp: 'len 7/15/2016 05:11'!
new
	^ self rows: OrderedCollection new! !

!RowMatrix class methodsFor: 'instance creation' stamp: 'len 1/17/2017 11:13:03'!
newFrom: aMatrix
	^ self rows: (aMatrix rows collect: [:each| each copy])! !

!RowMatrix class methodsFor: 'instance creation' stamp: 'len 7/15/2016 05:12'!
rows: anArray
	^ self basicNew rows: anArray! !

!MonomialOrdering methodsFor: 'accessing' stamp: 'len 7/4/2016 00:40'!
indeterminates
	^ indeterminates! !

!MonomialOrdering methodsFor: 'accessing' stamp: 'len 7/4/2016 00:40'!
rank
	^ indeterminates size! !

!MonomialOrdering methodsFor: 'accessing' stamp: 'len 7/2/2016 23:33'!
type
	^ nil! !

!MonomialOrdering methodsFor: 'comparing' stamp: 'len 2/3/2017 07:12:47'!
= aMonomialOrdering
	self == aMonomialOrdering ifTrue: [^ true].
	aMonomialOrdering isSymbol ifTrue: [^ self type = aMonomialOrdering].
	^ false! !

!MonomialOrdering methodsFor: 'comparing' stamp: 'len 2/3/2017 07:14:12'!
hash
	^ self type hash! !

!MonomialOrdering methodsFor: 'copying' stamp: 'len 10/31/2016 12:37'!
copyWithout: anIndeterminate
	^ self copy indeterminates: (indeterminates copyWithout: indeterminates size)! !

!MonomialOrdering methodsFor: 'operations' stamp: 'len 1/28/2017 10:12:58'!
, aMonomialOrdering
	^ BlockMonomialOrdering blocks: {self. aMonomialOrdering}! !

!MonomialOrdering methodsFor: 'ordering' stamp: 'len 1/28/2017 09:51:49'!
blockCompare: aMonomial with: anotherMonomial
	^ self compare: aMonomial with: anotherMonomial! !

!MonomialOrdering methodsFor: 'ordering' stamp: 'len 11/21/2016 08:42:01'!
compare: aMonomial with: anotherMonomial
	^ self subclassResponsibility! !

!MonomialOrdering methodsFor: 'testing' stamp: 'len 1/26/2017 22:27:21'!
isGlobal
	"Answer true if the receiver is a noetherian or global ordering (as opposed to a local ordering).
	Global orderings satisfy 1 < m for all nontrivial monomials m."
	^ false! !

!MonomialOrdering methodsFor: 'testing' stamp: 'len 10/28/2016 10:43'!
isGraded
	"Answer true if the receiver is a graded (also called total) ordering."
	^ false! !

!MonomialOrdering methodsFor: 'testing' stamp: 'len 1/22/2017 21:53:20'!
isLocal
	"Answer true if the receiver is a local (or non-noetherian) ordering.
	Local orderings satisfy 1 > m for all nontrivial monomials m."
	^ false! !

!MonomialOrdering methodsFor: 'private' stamp: 'len 1/28/2017 10:00:49'!
indeterminates: anArray
	indeterminates _ anArray asArray! !

!MonomialOrdering class methodsFor: 'examples' stamp: 'len 2/12/2017 06:06:37'!
glex: anArray
	^ GradedLexicographicOrdering indeterminates: anArray! !

!MonomialOrdering class methodsFor: 'examples' stamp: 'len 2/12/2017 06:06:43'!
grevlex: anArray
	^ GradedReverseLexicographicOrdering indeterminates: anArray! !

!MonomialOrdering class methodsFor: 'examples' stamp: 'len 7/4/2016 00:45'!
lex: anArray
	^ LexicographicOrdering indeterminates: anArray! !

!MonomialOrdering class methodsFor: 'examples' stamp: 'len 2/12/2017 06:01:42'!
lglex: anArray
	^ LocalGradedLexicographicOrdering indeterminates: anArray! !

!MonomialOrdering class methodsFor: 'examples' stamp: 'len 2/12/2017 06:02:42'!
lgrevlex: anArray
	^ LocalGradedReverseLexicographicOrdering indeterminates: anArray! !

!MonomialOrdering class methodsFor: 'examples' stamp: 'len 1/19/2017 07:28:23'!
llex: anArray
	^ LocalLexicographicOrdering indeterminates: anArray! !

!MonomialOrdering class methodsFor: 'instance creation' stamp: 'len 1/28/2017 10:04:02'!
indeterminates: anArray
	anArray isInteger ifTrue: [^ self new: anArray].
	^ self new indeterminates: anArray! !

!MonomialOrdering class methodsFor: 'instance creation' stamp: 'len 1/28/2017 10:04:09'!
new: anInteger
	^ self new indeterminates: (1 to: anInteger)! !

!BlockMonomialOrdering methodsFor: 'operations' stamp: 'len 1/28/2017 10:13:17'!
, aMonomialOrdering
	^ self species blocks: blocks, aMonomialOrdering! !

!BlockMonomialOrdering methodsFor: 'ordering' stamp: 'len 1/28/2017 09:57:40'!
compare: aMonomial with: anotherMonomial
	| result |
	blocks do: [:each|
		(result _ each blockCompare: aMonomial with: anotherMonomial) == 0 ifFalse: [^ result]].
	^ result! !

!BlockMonomialOrdering methodsFor: 'testing' stamp: 'len 1/28/2017 09:18:31'!
isGlobal
	^ blocks allSatisfy: [:each| each isGlobal]! !

!BlockMonomialOrdering methodsFor: 'testing' stamp: 'len 1/28/2017 09:30:58'!
isLocal
	^ blocks allSatisfy: [:each| each isLocal]! !

!BlockMonomialOrdering methodsFor: 'private' stamp: 'len 1/28/2017 09:43:49'!
blocks: anArray
	blocks _ anArray.
	indeterminates _ Array streamContents: [:aStream| blocks do: [:each| aStream nextPutAll: each indeterminates]]! !

!BlockMonomialOrdering class methodsFor: 'instance creation' stamp: 'len 1/28/2017 09:46:11'!
blocks: anArray
	^ self new blocks: anArray! !

!GradedLexicographicOrdering methodsFor: 'accessing' stamp: 'len 2/12/2017 06:05:25'!
type
	^ #glex! !

!GradedLexicographicOrdering methodsFor: 'ordering' stamp: 'len 1/28/2017 09:55:07'!
blockCompare: aMonomial with: anotherMonomial
	| d1 d2 e1 e2 n1 n2 |
	e1 _ aMonomial exponents.
	e2 _ anotherMonomial exponents.
	n1 _ e1 size.
	n2 _ e2 size.

	d1 _ 0.
	d2 _ 0.
	1 to: indeterminates size do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		xi <= n1 ifTrue: [d1 _ d1 + (e1 at: xi)].
		xi <= n2 ifTrue: [d2 _ d2 + (e2 at: xi)]].
	d1 > d2 ifTrue: [^ 1].
	d1 = d2 ifFalse: [^ -1].

	1 to: indeterminates size do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		a _ xi <= n1 ifTrue: [e1 at: xi] ifFalse: [0].
		b _ xi <= n2 ifTrue: [e2 at: xi] ifFalse: [0].
		a > b ifTrue: [^ 1].
		a = b ifFalse: [^ -1]].
	^ 0! !

!GradedLexicographicOrdering methodsFor: 'ordering' stamp: 'len 11/21/2016 13:43:16'!
compare: aMonomial with: anotherMonomial
	| d1 d2 e1 e2 n1 n2 |
	(d1 _ aMonomial degree) > (d2 _ anotherMonomial degree) ifTrue: [^ 1].
	d1 = d2 ifFalse: [^ -1].
	e1 _ aMonomial exponents.
	e2 _ anotherMonomial exponents.
	n1 _ e1 size.
	n2 _ e2 size.
	1 to: indeterminates size do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		a _ xi <= n1 ifTrue: [e1 at: xi] ifFalse: [0].
		b _ xi <= n2 ifTrue: [e2 at: xi] ifFalse: [0].
		a > b ifTrue: [^ 1].
		a = b ifFalse: [^ -1]].
	^ 0! !

!GradedLexicographicOrdering methodsFor: 'testing' stamp: 'len 1/26/2017 22:27:59'!
isGlobal
	^ true! !

!GradedLexicographicOrdering methodsFor: 'testing' stamp: 'len 7/6/2016 08:27'!
isGraded
	^ true! !

!GradedReverseLexicographicOrdering methodsFor: 'accessing' stamp: 'len 2/12/2017 06:07:37'!
type
	^ #grevlex! !

!GradedReverseLexicographicOrdering methodsFor: 'ordering' stamp: 'len 1/28/2017 09:56:14'!
blockCompare: aMonomial with: anotherMonomial
	| d1 d2 n1 n2 e1 e2 |
	e1 _ aMonomial exponents.
	e2 _ anotherMonomial exponents.
	n1 _ e1 size.
	n2 _ e2 size.
	
	d1 _ 0.
	d2 _ 0.
	1 to: indeterminates size do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		xi <= n1 ifTrue: [d1 _ d1 + (e1 at: xi)].
		xi <= n2 ifTrue: [d2 _ d2 + (e2 at: xi)]].
	d1 > d2 ifTrue: [^ 1].
	d1 = d2 ifFalse: [^ -1].

	indeterminates size to: 1 by: -1 do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		a _ xi <= n1 ifTrue: [e1 at: xi] ifFalse: [0].
		b _ xi <= n2 ifTrue: [e2 at: xi] ifFalse: [0].
		a < b ifTrue: [^ 1].
		a = b ifFalse: [^ -1]].
	^ 0! !

!GradedReverseLexicographicOrdering methodsFor: 'ordering' stamp: 'len 11/21/2016 12:20:07'!
compare: aMonomial with: anotherMonomial
	| d1 d2 n1 n2 e1 e2 |
	(d1 _ aMonomial degree) > (d2 _ anotherMonomial degree) ifTrue: [^ 1].
	d1 = d2 ifFalse: [^ -1].
	e1 _ aMonomial exponents.
	e2 _ anotherMonomial exponents.
	n1 _ e1 size.
	n2 _ e2 size.
	indeterminates size to: 1 by: -1 do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		a _ xi <= n1 ifTrue: [e1 at: xi] ifFalse: [0].
		b _ xi <= n2 ifTrue: [e2 at: xi] ifFalse: [0].
		a < b ifTrue: [^ 1].
		a = b ifFalse: [^ -1]].
	^ 0! !

!GradedReverseLexicographicOrdering methodsFor: 'testing' stamp: 'len 1/26/2017 22:28:06'!
isGlobal
	^ true! !

!GradedReverseLexicographicOrdering methodsFor: 'testing' stamp: 'len 7/6/2016 08:27'!
isGraded
	^ true! !

!LexicographicOrdering methodsFor: 'accessing' stamp: 'len 7/2/2016 23:26'!
type
	^ #lex! !

!LexicographicOrdering methodsFor: 'ordering' stamp: 'len 11/21/2016 13:40:59'!
compare: aMonomial with: anotherMonomial
	| e1 e2 n1 n2 |
	e1 _ aMonomial exponents.
	e2 _ anotherMonomial exponents.
	n1 _ e1 size.
	n2 _ e2 size.
	1 to: indeterminates size do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		a _ xi <= n1 ifTrue: [e1 at: xi] ifFalse: [0].
		b _ xi <= n2 ifTrue: [e2 at: xi] ifFalse: [0].
		a > b ifTrue: [^ 1].
		a = b ifFalse: [^ -1]].
	^ 0! !

!LexicographicOrdering methodsFor: 'testing' stamp: 'len 1/26/2017 22:27:28'!
isGlobal
	^ true! !

!LocalGradedLexicographicOrdering methodsFor: 'accessing' stamp: 'len 2/12/2017 06:02:13'!
type
	^ #lglex! !

!LocalGradedLexicographicOrdering methodsFor: 'ordering' stamp: 'len 1/28/2017 09:56:50'!
blockCompare: aMonomial with: anotherMonomial
	| d1 d2 e1 e2 n1 n2 |
	e1 _ aMonomial exponents.
	e2 _ anotherMonomial exponents.
	n1 _ e1 size.
	n2 _ e2 size.

	d1 _ 0.
	d2 _ 0.
	1 to: indeterminates size do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		xi <= n1 ifTrue: [d1 _ d1 + (e1 at: xi)].
		xi <= n2 ifTrue: [d2 _ d2 + (e2 at: xi)]].
	d1 < d2 ifTrue: [^ 1].
	d1 = d2 ifFalse: [^ -1].

	indeterminates size to: 1 by: -1 do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		a _ xi <= n1 ifTrue: [e1 at: xi] ifFalse: [0].
		b _ xi <= n2 ifTrue: [e2 at: xi] ifFalse: [0].
		a < b ifTrue: [^ 1].
		a = b ifFalse: [^ -1]].
	^ 0! !

!LocalGradedLexicographicOrdering methodsFor: 'ordering' stamp: 'len 1/26/2017 08:46:40'!
compare: aMonomial with: anotherMonomial
	| d1 d2 e1 e2 n1 n2 |
	(d1 _ aMonomial degree) < (d2 _ anotherMonomial degree) ifTrue: [^ 1].
	d1 = d2 ifFalse: [^ -1].
	e1 _ aMonomial exponents.
	e2 _ anotherMonomial exponents.
	n1 _ e1 size.
	n2 _ e2 size.
	indeterminates size to: 1 by: -1 do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		a _ xi <= n1 ifTrue: [e1 at: xi] ifFalse: [0].
		b _ xi <= n2 ifTrue: [e2 at: xi] ifFalse: [0].
		a < b ifTrue: [^ 1].
		a = b ifFalse: [^ -1]].
	^ 0! !

!LocalGradedLexicographicOrdering methodsFor: 'testing' stamp: 'len 1/19/2017 08:09:27'!
isGraded
	^ true! !

!LocalGradedLexicographicOrdering methodsFor: 'testing' stamp: 'len 1/19/2017 08:03:51'!
isLocal
	^ true! !

!LocalGradedReverseLexicographicOrdering methodsFor: 'accessing' stamp: 'len 2/12/2017 06:03:00'!
type
	^ #lgrevlex! !

!LocalGradedReverseLexicographicOrdering methodsFor: 'ordering' stamp: 'len 1/28/2017 09:57:27'!
blockCompare: aMonomial with: anotherMonomial
	| d1 d2 e1 e2 n1 n2 |
	e1 _ aMonomial exponents.
	e2 _ anotherMonomial exponents.
	n1 _ e1 size.
	n2 _ e2 size.

	d1 _ 0.
	d2 _ 0.
	1 to: indeterminates size do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		xi <= n1 ifTrue: [d1 _ d1 + (e1 at: xi)].
		xi <= n2 ifTrue: [d2 _ d2 + (e2 at: xi)]].
	d1 < d2 ifTrue: [^ 1].
	d1 = d2 ifFalse: [^ -1].

	1 to: indeterminates size do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		a _ xi <= n1 ifTrue: [e1 at: xi] ifFalse: [0].
		b _ xi <= n2 ifTrue: [e2 at: xi] ifFalse: [0].
		"a > b ifTrue: [^ 1]." "Magma handbook and Using Algebraic Geometry contradict each other"
		a < b ifTrue: [^ 1].
		a = b ifFalse: [^ -1]].
	^ 0! !

!LocalGradedReverseLexicographicOrdering methodsFor: 'ordering' stamp: 'len 1/28/2017 12:37:48'!
compare1: aMonomial with: anotherMonomial
	"This follows Magma conventions."
	| d1 d2 e1 e2 n1 n2 |
	(d1 _ aMonomial degree) < (d2 _ anotherMonomial degree) ifTrue: [^ 1].
	d1 = d2 ifFalse: [^ -1].
	e1 _ aMonomial exponents.
	e2 _ anotherMonomial exponents.
	n1 _ e1 size.
	n2 _ e2 size.
	1 to: indeterminates size do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		a _ xi <= n1 ifTrue: [e1 at: xi] ifFalse: [0].
		b _ xi <= n2 ifTrue: [e2 at: xi] ifFalse: [0].
		a < b ifTrue: [^ 1].
		a = b ifFalse: [^ -1]].
	^ 0! !

!LocalGradedReverseLexicographicOrdering methodsFor: 'ordering' stamp: 'len 1/28/2017 12:37:26'!
compare2: aMonomial with: anotherMonomial
	"This is Singular's 'ds' ordering (indeterminates are reversed)."
	| d1 d2 e1 e2 n1 n2 |
	(d1 _ aMonomial degree) < (d2 _ anotherMonomial degree) ifTrue: [^ 1].
	d1 = d2 ifFalse: [^ -1].
	e1 _ aMonomial exponents.
	e2 _ anotherMonomial exponents.
	n1 _ e1 size.
	n2 _ e2 size.
	indeterminates size to: 1 by: -1 do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		a _ xi <= n1 ifTrue: [e1 at: xi] ifFalse: [0].
		b _ xi <= n2 ifTrue: [e2 at: xi] ifFalse: [0].
		a < b ifTrue: [^ 1].
		a = b ifFalse: [^ -1]].
	^ 0! !

!LocalGradedReverseLexicographicOrdering methodsFor: 'ordering' stamp: 'len 1/28/2017 12:38:26'!
compare: aMonomial with: anotherMonomial
	"This follows Magma conventions."
	| d1 d2 e1 e2 n1 n2 |
	(d1 _ aMonomial degree) < (d2 _ anotherMonomial degree) ifTrue: [^ 1].
	d1 = d2 ifFalse: [^ -1].
	e1 _ aMonomial exponents.
	e2 _ anotherMonomial exponents.
	n1 _ e1 size.
	n2 _ e2 size.
	1 to: indeterminates size do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		a _ xi <= n1 ifTrue: [e1 at: xi] ifFalse: [0].
		b _ xi <= n2 ifTrue: [e2 at: xi] ifFalse: [0].
		a < b ifTrue: [^ 1].
		a = b ifFalse: [^ -1]].
	^ 0! !

!LocalGradedReverseLexicographicOrdering methodsFor: 'testing' stamp: 'len 11/22/2016 14:56:05'!
isGraded
	^ true! !

!LocalGradedReverseLexicographicOrdering methodsFor: 'testing' stamp: 'len 11/22/2016 14:56:02'!
isLocal
	^ true! !

!LocalLexicographicOrdering methodsFor: 'accessing' stamp: 'len 1/19/2017 07:29:54'!
type
	^ #llex! !

!LocalLexicographicOrdering methodsFor: 'ordering' stamp: 'len 1/28/2017 12:33:32'!
compare1: aMonomial with: anotherMonomial
	"This is Magma's 'llex' ordering."
	| e1 e2 n1 n2 |
	e1 _ aMonomial exponents.
	e2 _ anotherMonomial exponents.
	n1 _ e1 size.
	n2 _ e2 size.
	indeterminates size to: 1 by: -1 do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		a _ xi <= n1 ifTrue: [e1 at: xi] ifFalse: [0].
		b _ xi <= n2 ifTrue: [e2 at: xi] ifFalse: [0].
		a < b ifTrue: [^ 1].
		a = b ifFalse: [^ -1]].
	^ 0! !

!LocalLexicographicOrdering methodsFor: 'ordering' stamp: 'len 1/28/2017 12:33:15'!
compare2: aMonomial with: anotherMonomial
	"This is Singular's 'ls' ordering (indeterminates are reversed)."
	| e1 e2 n1 n2 |
	e1 _ aMonomial exponents.
	e2 _ anotherMonomial exponents.
	n1 _ e1 size.
	n2 _ e2 size.
	1 to: indeterminates size do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		a _ xi <= n1 ifTrue: [e1 at: xi] ifFalse: [0].
		b _ xi <= n2 ifTrue: [e2 at: xi] ifFalse: [0].
		a < b ifTrue: [^ 1].
		a = b ifFalse: [^ -1]].
	^ 0! !

!LocalLexicographicOrdering methodsFor: 'ordering' stamp: 'len 1/28/2017 12:31:30'!
compare: aMonomial with: anotherMonomial
	| e1 e2 n1 n2 |
	e1 _ aMonomial exponents.
	e2 _ anotherMonomial exponents.
	n1 _ e1 size.
	n2 _ e2 size.
	indeterminates size to: 1 by: -1 do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		a _ xi <= n1 ifTrue: [e1 at: xi] ifFalse: [0].
		b _ xi <= n2 ifTrue: [e2 at: xi] ifFalse: [0].
		a < b ifTrue: [^ 1].
		a = b ifFalse: [^ -1]].
	^ 0! !

!LocalLexicographicOrdering methodsFor: 'testing' stamp: 'len 10/28/2016 10:44'!
isLocal
	^ true! !

!WeightedMonomialOrdering methodsFor: 'accessing' stamp: 'len 7/2/2016 23:18'!
weights
	^ weights! !

!WeightedMonomialOrdering methodsFor: 'arithmetic' stamp: 'len 7/3/2016 02:24'!
* aMonomialOrdering
	| newWeights zero |
	newWeights _ OrderedCollection new.
	zero _ aMonomialOrdering weights first zero.
	weights do: [:each| newWeights add: each, zero].
	zero _ weights first zero.
	aMonomialOrdering weights do: [:each| newWeights add: zero, each].
	^ self class
		new: self rank + aMonomialOrdering rank
		weights: newWeights! !

!WeightedMonomialOrdering methodsFor: 'arithmetic' stamp: 'len 7/3/2016 02:50'!
, aMonomialOrdering
	"Answer the concatenation of the recever and the argument."

	self rank = aMonomialOrdering rank ifFalse: [^ self error: 'cannot concatenate monomial orderings of different rank'].
	^ self class
		new: self rank
		weights: (self weights copy addAll: aMonomialOrdering weights; yourself)! !

!WeightedMonomialOrdering methodsFor: 'arithmetic' stamp: 'len 7/3/2016 02:23'!
inverse
	^ self class
		new: self rank
		weights: (self weights collect: [:each| each reversed])! !

!WeightedMonomialOrdering methodsFor: 'arithmetic' stamp: 'len 7/3/2016 02:22'!
reverse
	^ self class
		new: self rank
		weights: (self weights collect: [:each| each negated])! !

!WeightedMonomialOrdering methodsFor: 'copying' stamp: 'len 10/31/2016 12:29'!
copyWithout: anIndeterminate
	^ (super copyWithout: anIndeterminate) weights: (weights copyWithoutIndex: anIndeterminate)! !

!WeightedMonomialOrdering methodsFor: 'ordering' stamp: 'len 4/29/2019 10:22:56'!
compare: aMonomial with: anotherMonomial
	| t1 t2 |
	t1 _ FloatArray new: indeterminates size.
	t2 _ t1 copy.
	1 to: indeterminates size do: [:i| | xi |
		t1 at: i put: (aMonomial at: (xi _ indeterminates at: i)).
		t2 at: i put: (anotherMonomial at: xi)].
	self weights do: [:w|
		| a b |
		a _ w  t1.
		b _ w  t2.
		a = b ifFalse: [^ a > b ifTrue: [1] ifFalse: [-1]]].
	^ 0! !

!WeightedMonomialOrdering methodsFor: 'ordering' stamp: 'len 5/15/2019 01:52:53'!
leadingMonomialOf: aPolynomial
	"Answer the head monomial of aPolynomial according to this ordering."
	| head headTuple |
	headTuple _ FloatArray new: indeterminates size.
	aPolynomial monomialsDo: [:each|
		| t a b |
		t _ FloatArray new: indeterminates size.
		1 to: indeterminates size do: [:i| t at: i put: (each at: (indeterminates at: i))].
		head isNil
			ifTrue: [head _ each. headTuple _ t]
			ifFalse: [(self weights anySatisfy: [:w|
				a _ w  t.
				b _ w  headTuple. "could be precomputed up to some extent"
				a ~= b]) ifTrue: [a > b ifTrue: [head _ each. headTuple _ t]]]].
	^ head! !

!WeightedMonomialOrdering methodsFor: 'private' stamp: 'len 7/2/2016 23:18'!
weights: aCollectionOfTuples
	weights _ aCollectionOfTuples collect: [:each| each as: FloatArray]! !

!WeightedMonomialOrdering class methodsFor: 'instance creation' stamp: 'len 1/11/2018 17:24:12'!
glex: aCollection
	"Answer the total (or graded) lexicographic ordering with the indeterminates of aCollection."
	| weights |
	weights _ OrderedCollection new.
	weights add: (QQ tuple: aCollection size evaluating: [:each| 1]).
	weights addAll: (self lex: aCollection) weights.
	^ self new: aCollection size weights: weights! !

!WeightedMonomialOrdering class methodsFor: 'instance creation' stamp: 'len 1/11/2018 17:24:17'!
grevlex: aCollection
	"Answer the total (or graded) reverse lexicographic ordering with the indeterminates of aCollection."
	| weights |
	weights _ OrderedCollection new.
	weights add: (QQ tuple: aCollection size evaluating: [:each| 1]).
	weights addAll: (self revlex: aCollection) weights.
	^ self new: aCollection size weights: weights! !

!WeightedMonomialOrdering class methodsFor: 'instance creation' stamp: 'len 7/3/2016 02:27'!
indeterminates: indeterminates weights: weights
	weights isSequenceable ifFalse: [self error: 'the indeterminates are unordered'].
	^ self new: indeterminates size weights: (weights collect: [:each| each withIndexCollect: [:x :i| each at: (indeterminates indexOf: i)]])! !

!WeightedMonomialOrdering class methodsFor: 'instance creation' stamp: 'len 11/5/2016 06:18'!
lex: aCollection
	"Answer the lexicographic order with the indeterminates of aCollection."
	| weighs n |
	n _ aCollection size.
	weighs _ (1 to: n) collect: [:i| QQ tuple: n evaluating: [:k| k==i ifTrue:[1] ifFalse: [0]]].
	^ self indeterminates: aCollection weights: weighs! !

!WeightedMonomialOrdering class methodsFor: 'instance creation' stamp: 'len 7/3/2016 02:44'!
new: anInteger weights: anArray
	^ (self new: anInteger) weights: anArray! !

!WeightedMonomialOrdering class methodsFor: 'instance creation' stamp: 'len 7/3/2016 02:43'!
revlex: aCollection
	"Answer the reverse lexicographic ordering with the indeterminates of aCollection."
	^ (self lex: aCollection) reverse! !

!SubgroupSeries methodsFor: 'accessing' stamp: 'len 5/1/98 17:35'!
add: aSubgroup
	^ self subgroups add: aSubgroup! !

!SubgroupSeries methodsFor: 'accessing' stamp: 'len 5/1/98 17:34'!
at: anInteger
	^ self subgroups at: anInteger! !

!SubgroupSeries methodsFor: 'accessing' stamp: 'len 2/8/2016 03:55'!
objects
	^ subgroups! !

!SubgroupSeries methodsFor: 'accessing' stamp: 'len 5/4/2016 06:25'!
size
	^ subgroups size! !

!SubgroupSeries methodsFor: 'accessing' stamp: 'len 5/1/98 17:33'!
subgroups
	^ subgroups! !

!SubgroupSeries methodsFor: 'enumerating' stamp: 'len 5/1/98 17:35'!
do: aBlock
	self subgroups do: aBlock! !

!SubgroupSeries methodsFor: 'initialization' stamp: 'len 5/1/98 17:32'!
initialize
	self subgroups: OrderedCollection new! !

!SubgroupSeries methodsFor: 'testing' stamp: 'len 5/1/98 17:52'!
isAbelian
	"Answer true if the receiver is an abelian tower of subgroups."
	self isNormal ifFalse: [^ false].
	2 to: self size do: [ :each | ((self at: each - 1) / (self at: each)) isAbelian ifFalse: [^ false]].
	^ true! !

!SubgroupSeries methodsFor: 'testing' stamp: 'len 5/3/98 01:07'!
isCyclic
	"Answer true if the receiver is a cyclic tower of subgroups."
	self isNormal ifFalse: [^ false].
	2 to: self size do: [ :each | ((self at: each - 1) / (self at: each)) isCyclic ifFalse: [^ false]].
	^ true! !

!SubgroupSeries methodsFor: 'testing' stamp: 'len 5/1/98 17:47'!
isNormal
	"Answer true if the receiver is a normal tower of subgroups."
	2 to: self size do: [ :each | ((self at: each) isNormalIn: (self at: each - 1)) ifFalse: [^ false]].
	^ true! !

!SubgroupSeries methodsFor: 'private' stamp: 'len 5/1/98 17:33'!
subgroups: aCollection
	subgroups _ aCollection! !

!ProductReplacementRandomGenerator methodsFor: 'accessing' stamp: 'len 5/25/2019 04:34:49'!
generators: aCollection
	generators _ aCollection.
	state _ nil! !

!ProductReplacementRandomGenerator methodsFor: 'generating' stamp: 'len 5/25/2019 04:36:25'!
atRandom: aRandom
	"Product Replacement Algorithm. After the initial precomputation, every new random element takes one multiplication and 1/2 inversion in the group."
	| g h i |
	state isNil ifTrue: "initial precomputation takes about 60 multiplications / inversions in the group"
		[state _ generators asOrderedCollection.
		60 - (state size min: 10) timesRepeat: [self atRandom: aRandom]].
	g _ state atRandom: aRandom.
	[(state at: (i _ state size atRandom: aRandom)) == g and: [state size > 1 "otherwise fails with cyclic groups"]] whileTrue.
	(2 atRandom: aRandom) = 1 ifTrue: [g _ g inverse].
	h _ aRandom nextBoolean ifTrue: [g  (state at: i)] ifFalse: [(state at: i)  g].
	state size < 10 ifTrue: [state add: h] ifFalse: [state at: i put: h].
	^ h! !

!SchreierSims methodsFor: 'accessing' stamp: 'len 6/30/2016 09:02'!
base
	"A base of a group G acting on X is a finite sequence of distinct points B={x1,..,xn} such that the stabilizer of B is {id}, i.e. the only element that fixes all xi is the identity."
	base ifNil: [self run].
	^ base! !

!SchreierSims methodsFor: 'accessing' stamp: 'len 6/30/2016 10:13'!
order
	"Answer the order of the group."
	order ifNil: [self run].
	^ order! !

!SchreierSims methodsFor: 'accessing' stamp: 'len 6/25/2016 20:06'!
strongGeneratingSet
	strongGeneratingSet ifNil: [self run].
	^ strongGeneratingSet! !

!SchreierSims methodsFor: 'accessing-private' stamp: 'len 6/22/2016 07:31'!
action: aGroupAction
	action _ aGroupAction! !

!SchreierSims methodsFor: 'accessing-private' stamp: 'len 6/22/2016 16:32'!
generators: aCollection
	generators _ aCollection asArray! !

!SchreierSims methodsFor: 'computing' stamp: 'len 5/8/2019 19:33:18'!
elementFromImage: anArray
	| image g |
	image _ anArray copy.
	g _ action group identity.
	trees withIndexDo: [:each :i|
		g _ (each trace: (image at: i))  g.
		i to: base size do: [:j| image at: j put: (action value: {each traceInverse: (image at: i). image at: j})]].
	^ g! !

!SchreierSims methodsFor: 'computing' stamp: 'len 6/30/2016 10:02'!
imageOf: anElement
	^ base collect: [:each| action value: {anElement. each}]! !

!SchreierSims methodsFor: 'computing' stamp: 'len 6/30/2016 10:13'!
includes: anElement
	"Answer true if the group includes anElement."
	^ (self strip: anElement) = action group identity! !

!SchreierSims methodsFor: 'computing' stamp: 'len 5/8/2019 19:33:34'!
strip: anElement
	| g |
	g _ anElement.
	trees withIndexDo: [:each :i| | b b2 |
		b _ each root.
		b2 _ action value: {g. b}.
		(each orbits includes: b2)
			ifFalse: [^ {g. i}].
		g _ g  (each traceInverse: b2)].
	^ {g. trees size + 1}! !

!SchreierSims methodsFor: 'computing-private' stamp: 'len 7/1/2016 05:46'!
buildBSGS
	base _ OrderedCollection new.
	strongGeneratingSet _ OrderedCollection new.
	self buildPartialBSGS.
	base size to: 1 by: -1 do: [:i| self schreierSimsStep: i]! !

!SchreierSims methodsFor: 'computing-private' stamp: 'len 7/1/2016 00:39'!
buildPartialBSGS
	| id |
	id _ action group identity.
	generators do: [:each| each = id ifFalse: [strongGeneratingSet add: each]].
	strongGeneratingSet copy do: [:s|
		(base allSatisfy: [:b| (s value: b) = b])
			ifTrue: [base add: (action space detect: [:one| action isFixedPoint: one])].
			s squared = id ifFalse: [base add: s inverse]]! !

!SchreierSims methodsFor: 'computing-private' stamp: 'len 7/19/2016 08:37'!
run
	| G |
	G _ action group.
	order _ 1.
	base _ OrderedCollection new.
	strongGeneratingSet _ OrderedCollection new.
	trees _ OrderedCollection new.
	G action space do: [:b| | tree |
		G isTrivial ifTrue: [^ order].
		tree _ SchreierTree root: b generators: G generators action: G action.
		trees add: tree.
		order _ order * tree orbit size.
		G _ tree stabilizer].
	self error: 'what?'.
	^ order! !

!SchreierTree methodsFor: 'accessing' stamp: 'len 6/24/2016 03:07'!
orbit
	^ orbit! !

!SchreierTree methodsFor: 'accessing' stamp: 'len 5/8/2019 19:32:19'!
stabilizer
	"Answer the stabilizer of the root."
	| stabilizerGenerators id |
	stabilizerGenerators _ Set new.
	id _ action group identity.
	self orbit do: [:i|
		generators do: [:s|
			| g |
			g _ (self traceInverse: (s value: i))  s  (self trace: i).
			g = id ifFalse: [stabilizerGenerators add: g]]].
	^ action group span: stabilizerGenerators! !

!SchreierTree methodsFor: 'accessing' stamp: 'len 5/8/2019 19:32:27'!
trace: aPoint
	"Trace the Schreier spanning tree (v,w) for the orbit containing aPoint.
	Answer the transversal u(aPoint), i.e. an element such that root^u(aPoint) = aPoint.
	This is the representative function, and in particular u(root^h) is a representative of the coset G_root * h, where G_root is the stabilizer at the root of this Schreier tree.
	For an element g in G, there's an h in G_root g = h * u(root^g), and h = h * u(root^h)^-1."
	| alpha u |
	u _ action group identity.
	alpha _ aPoint.
	[(v at: alpha) notNil]
		whileTrue:
			[u _ u  (v at: alpha).
			alpha _ w at: alpha].
	^ u! !

!SchreierTree methodsFor: 'accessing' stamp: 'len 5/8/2019 19:32:35'!
traceInverse: aPoint
	"Calculate inverses of coset representatives. See 'The Schreier-Sims Algorithm' pp 18. Assumes we're using a (strong) generating set that is closed under inversion. This makes backward pointers unnecesary."
	| alpha u |
	u _ action group identity.
	alpha _ aPoint.
	[(v at: alpha) notNil]
		whileTrue:
			[u _ (inverses at: alpha ifAbsentPut: [(v at: alpha) inverse])  u.
			alpha _ w at: alpha].
	^ u! !

!SchreierTree methodsFor: 'initialization' stamp: 'len 11/30/2016 14:45:01'!
root: aPoint generators: anArray action: aGroupAction
	| queue |
	root _ aPoint.
	generators _ anArray.
	action _ aGroupAction.
	v _ Dictionary new. "Schreier vector"
	w _ Dictionary new. "backward pointers"
	inverses _ Dictionary new. "inverses of the Schreier generators from v"
	orbit _ Set with: aPoint.
	v at: aPoint put: nil. "-1"
	w at: aPoint put: nil. "-1"
	queue _ OrderedCollection with: aPoint.
	[| a |
	a _ queue removeFirst.
	1 to: generators size do: [:i|
		| x g |
		g _ generators at: i.
		x _ action value: {g. a}.
		(orbit includes: x)
			ifFalse:
				[orbit add: x.
				queue add: x.
				v at: x put: g.
				w at: x put: a]].
	queue isEmpty] whileFalse! !

!SchreierTree methodsFor: 'private' stamp: 'len 11/14/2016 08:26'!
verify
	^ self stabilizer generators allSatisfy: [:each| (each value: root) = root]! !

!SchreierTree class methodsFor: 'instance creation' stamp: 'len 6/24/2016 03:07'!
root: aPoint generators: anArray action: aGroupAction
	^ self new root: aPoint generators: anArray action: aGroupAction! !

!ComplexAlgebraicNumber methodsFor: 'printing' stamp: 'len 4/30/2018 00:27:26'!
printOn: aStream base: base
	| real imaginary isImaginary |
	minimalPolynomial degree = 2 ifTrue: [^ self printQuadraticOn: aStream base: base].
	self refineTo: self printPrecision.
	real _ approximation real asFloat roundTo: self printPrecision.
	imaginary _ approximation imaginary asFloat roundTo: self printPrecision.
	(isImaginary _ self isImaginary)
		ifFalse: [real printOn: aStream base: base].
	self isReal
		ifFalse:
			[isImaginary ifFalse: [aStream nextPutAll: (0 <= imaginary ifTrue: [' + '] ifFalse: [imaginary _ imaginary negated. ' - '])].
			imaginary printOn: aStream base: base.
			aStream nextPutAll: 'i' italic].
	aStream nextPutAll: '..'! !

!ComplexAlgebraicNumber methodsFor: 'printing' stamp: 'len 1/11/2018 21:07:33'!
printPrecision
"	self absoluteError < 1 ifTrue: [^ self absoluteError asFloat].
	^ 0.001"
	^ 0.00001! !

!ComplexAlgebraicNumber methodsFor: 'printing' stamp: 'len 4/30/2018 05:14:01'!
printQuadraticOn: aStream base: base
	| a b c discriminant z y x1 x2 sign |
	a _ minimalPolynomial atDegree: 2.
	b _ minimalPolynomial atDegree: 1.
	c _ minimalPolynomial atDegree: 0.
	discriminant _ b squared - (4*a*c).
	z _ discriminant squareFree.
	y _ (discriminant / z) sqrt.
	x1 _ b negated + (discriminant negative ifTrue: [discriminant negated sqrt i] ifFalse: [discriminant sqrt]) / (2*a).
	x2 _ b negated - (discriminant negative ifTrue: [discriminant negated sqrt i] ifFalse: [discriminant sqrt]) / (2*a).
	(x1 - approximation) abs <= radius
		ifTrue: [sign _ ' + ']
		ifFalse: [(x2 - approximation) abs <= radius ifTrue: [sign _ ' - '. y _ y negated] ifFalse: [self halt]].
	b = 0 ifFalse:
		[b/(-2*a) printOn: aStream base: base.
		aStream nextPutAll: sign.
		y _ y abs].
	y negative ifTrue: [aStream nextPut: $-. y _ y abs].
	y/(2*a) = 1 ifFalse: [y/(2*a) printOn: aStream base: base].
	z abs = 1 ifFalse:
		[aStream nextPut: $.
		z abs printOn: aStream base: base].
	z negative ifTrue: [aStream nextPutAll: 'i' italic]! !

!ComplexAlgebraicNumber methodsFor: 'arithmetic' stamp: 'len 4/29/2018 17:02:11'!
* aNumber
	| isolator x r |
	aNumber class = self class
		ifFalse: [^ aNumber adaptToAlgebraic: self andSend: #*].
	aNumber isZero ifTrue: [^ aNumber].
	self isZero ifTrue: [^ self].
	isolator _ ComplexRootIsolator on: (minimalPolynomial zeroProduct: aNumber minimalPolynomial) squareFree.
	[x _ approximation * aNumber approximation.
	r _ self absoluteError * aNumber approximation norm2 + (approximation norm2 * aNumber absoluteError).
	isolator atMostOneRootAround: x radius: r]
		whileFalse:
			[self refineWith: aNumber].
	^ self class polynomial: isolator polynomial approximation: x radius: r! !

!ComplexAlgebraicNumber methodsFor: 'arithmetic' stamp: 'len 4/29/2018 17:02:35'!
+ aNumber
	| isolator x r |
	aNumber class = self class
		ifFalse: [^ aNumber adaptToAlgebraic: self andSend: #+].
	aNumber isZero ifTrue: [^ self].
	self isZero ifTrue: [^ aNumber].
	isolator _ ComplexRootIsolator on: (minimalPolynomial zeroAddition: aNumber minimalPolynomial) squareFree.
	[x _ approximation + aNumber approximation.
	r _ self absoluteError + aNumber absoluteError.
	isolator atMostOneRootAround: x radius: r]
		whileFalse:
			[self refineWith: aNumber].
	^ self class polynomial: isolator polynomial approximation: x radius: r! !

!ComplexAlgebraicNumber methodsFor: 'arithmetic' stamp: 'len 1/12/2016 03:38'!
- anObject
	^ self + anObject negated! !

!ComplexAlgebraicNumber methodsFor: 'arithmetic' stamp: 'len 1/12/2016 03:38'!
/ anObject
	^ self * anObject reciprocal! !

!ComplexAlgebraicNumber methodsFor: 'arithmetic' stamp: 'len 1/13/2016 04:01'!
i
	^ self * self class i! !

!ComplexAlgebraicNumber methodsFor: 'arithmetic' stamp: 'len 4/28/2018 07:10:56'!
negated
	"Answer the additive inverse of the receiver."
	^ self class
		minimalPolynomial: minimalPolynomial zeroNegation
		approximation: approximation negated
		radius: radius! !

!ComplexAlgebraicNumber methodsFor: 'arithmetic' stamp: 'len 4/29/2018 17:03:02'!
reciprocal
	"Answer the multiplicative inverse of the receiver."
	| isolator x r |
	self isZero ifTrue: [^ ZeroDivide signal].
	isolator _ ComplexRootIsolator on: minimalPolynomial zeroReciprocal.
	[x _ approximation reciprocal.
	r _ self absoluteError / approximation norm2 * x norm2.
	isolator atMostOneRootAround: x radius: r]
		whileFalse:
			[self refine].
	^ self class minimalPolynomial: isolator polynomial approximation: x radius: r! !

!ComplexAlgebraicNumber methodsFor: 'arithmetic' stamp: 'len 4/29/2018 17:03:28'!
squareRoot
	| isolator x r |
	self isZero ifTrue: [^ self].
	isolator _ ComplexRootIsolator on: minimalPolynomial zeroSquareRoot squareFree.
	[x _ approximation sqrt.
	r _ self absoluteError sqrt.
	isolator atMostOneRootAround: x radius: r]
		whileFalse:
			[self refine].
	^ self class polynomial: isolator polynomial approximation: x radius: r! !

!ComplexAlgebraicNumber methodsFor: 'arithmetic' stamp: 'len 5/4/2018 19:10:55'!
squared
	| x odd even |
	x _ minimalPolynomial parent x.
	odd _ minimalPolynomial odd.
	even _ minimalPolynomial even.
	^ self class
		polynomial: odd squared * x - even squared
		approximation: approximation squared
		radius: radius * approximation norm2 * 2! !

!ComplexAlgebraicNumber methodsFor: 'comparing' stamp: 'len 4/28/2018 16:48:28'!
= anObject
	self == anObject ifTrue: [^ true].
	anObject isNumber ifFalse: [^ false].
	anObject class = self class
		ifFalse: [^ anObject adaptToAlgebraic: self andSend: #=].
	^ minimalPolynomial = anObject minimalPolynomial and: [self bounds intersects: anObject bounds]! !

!ComplexAlgebraicNumber methodsFor: 'comparing' stamp: 'len 4/29/2018 20:09:45'!
hash
	^ minimalPolynomial hash! !

!ComplexAlgebraicNumber methodsFor: 'approximating' stamp: 'len 6/5/2016 19:35'!
absoluteError
	^ radius! !

!ComplexAlgebraicNumber methodsFor: 'approximating' stamp: 'len 3/24/2018 21:01:14'!
approximation
	"Answre a rational or float current approximation of the receiver."
	^ approximation! !

!ComplexAlgebraicNumber methodsFor: 'approximating' stamp: 'len 6/5/2016 20:59'!
bounds
	"Answer a disk in the complex plane where the receiver is located, isolated from all other roots of its minimal polynomial."
	^ ComplexDisk center: approximation radius: radius! !

!ComplexAlgebraicNumber methodsFor: 'approximating' stamp: 'len 5/2/2018 16:47:24'!
refine
	| P Q P2 Q2 m x v c dx y v1 m1 |
	radius _ radius / 2.0.
	P _ minimalPolynomial. "should it be monic?"
	Q _ P.
	P2 _ P derivative.
	Q2 _ P2.
	x _ approximation.
	v _ Q value: x.
	m _ v norm2.
	c _ 0. dx _ v / (Q2 value: x).
	[dx abs >= radius]
		whileTrue:
			[y _ x - dx.
			v1 _ Q value: y.
			m1 _ v1 norm2.
			m1 < m
				ifTrue: [x _ y. v _ v1. m _ m1. c _ 0. dx _ v / (Q2 value: x)]
				ifFalse: [c _ c + 1. dx _ dx / 4. c > 20 ifTrue: [self error: 'failed']]].
	"Polish root:"
	2 timesRepeat: [x _ x - ((P value: x) / (P2 value: x))].
	approximation _ x! !

!ComplexAlgebraicNumber methodsFor: 'approximating' stamp: 'len 12/5/2017 20:05:25'!
refineTo: aNumber
	"Refine the receiver up to get an approximation error < aNumber."
	[self absoluteError > aNumber] whileTrue: [self refine]! !

!ComplexAlgebraicNumber methodsFor: 'approximating' stamp: 'len 3/24/2018 21:00:20'!
refineWith: aComplexAlgebraicNumber
	"Refine the rational interval approximation of either the receiver or the argument, depending on which is less precise at the moment."
	self relativeError > aComplexAlgebraicNumber relativeError
		ifTrue: [self refine]
		ifFalse: [aComplexAlgebraicNumber refine]! !

!ComplexAlgebraicNumber methodsFor: 'approximating' stamp: 'len 4/29/2018 20:17:35'!
relativeError
	"Answer the relative error in the current rational approximation."
	self isZero ifTrue: [^ 0].
	^ self absoluteError / self approximation abs! !

!ComplexAlgebraicNumber methodsFor: 'converting' stamp: 'len 1/13/2016 03:41'!
adaptToFloat: rcvr andSend: selector
	^ rcvr perform: selector with: self asFloat! !

!ComplexAlgebraicNumber methodsFor: 'converting' stamp: 'len 1/13/2016 03:42'!
adaptToFraction: rcvr andSend: selector
	^ (self class fromRational: rcvr) perform: selector with: self! !

!ComplexAlgebraicNumber methodsFor: 'converting' stamp: 'len 1/13/2016 03:42'!
adaptToInteger: rcvr andSend: selector
	^ (self class fromRational: rcvr) perform: selector with: self! !

!ComplexAlgebraicNumber methodsFor: 'converting' stamp: 'len 1/13/2016 03:59'!
asComplexFloat
	"Answer a Float approximation of the receiver."
	self refineTo: 0.000001.
	^ approximation asFloat! !

!ComplexAlgebraicNumber methodsFor: 'converting' stamp: 'len 6/4/2016 22:16'!
asFloat
	"Answer a Float approximation of the receiver."
	self refineTo: 0.000001.
	^ self approximation asFloat! !

!ComplexAlgebraicNumber methodsFor: 'converting' stamp: 'len 4/28/2018 07:09:28'!
asRational
	"Convert the receiver to Fraction or Integer."
	| alpha |
	radius = 0 ifTrue: [^ approximation]. "could be float!!"
	minimalPolynomial degree < 2
		ifTrue:
			[alpha _ minimalPolynomial independentCoefficient negated / minimalPolynomial leadingCoefficient.
			approximation _ alpha. radius _ 0.
			^ alpha].
	(minimalPolynomial rootsIn: QQ)
		do: [:each|
			(each - approximation) abs < radius
				ifTrue: [approximation _ each. radius _ 0. ^ each]].
	self error: 'the number is irrational'! !

!ComplexAlgebraicNumber methodsFor: 'accessing-private' stamp: 'len 1/15/2016 02:07'!
approximation: aNumber radius: anotherNumber
	approximation _ aNumber.
	radius _ anotherNumber! !

!ComplexAlgebraicNumber methodsFor: 'accessing-private' stamp: 'len 5/2/2018 17:14:52'!
minimalPolynomial: aPolynomial
	minimalPolynomial _ aPolynomial integerPrimitive "<- or should it be monic?"! !

!ComplexAlgebraicNumber methodsFor: 'accessing' stamp: 'len 4/30/2018 04:52:43'!
conjugates
	"The conjugates of an algebraic number with minimal polynomial of degree n are all its n-th roots."
	^ (minimalPolynomial rootsIn: CC) "copyWithout: self"! !

!ComplexAlgebraicNumber methodsFor: 'accessing' stamp: 'len 5/2/2018 16:37:43'!
degree
	^ minimalPolynomial degree! !

!ComplexAlgebraicNumber methodsFor: 'accessing' stamp: 'len 4/29/2018 18:46:05'!
denominator
	"The denominator of an algebraic number is the smallest positive integer that multiplied by the algebraic number is an algebraic integer."
	^ minimalPolynomial coefficients inject: 1 into: [:result :each| result lcm: each denominator]! !

!ComplexAlgebraicNumber methodsFor: 'accessing' stamp: 'len 5/2/2018 16:33:35'!
height
	^ self minimalPolynomial height! !

!ComplexAlgebraicNumber methodsFor: 'accessing' stamp: 'len 4/28/2018 07:07:34'!
minimalPolynomial
	^ minimalPolynomial! !

!ComplexAlgebraicNumber methodsFor: 'testing' stamp: 'len 1/13/2016 03:33'!
isAlgebraic
	^ true! !

!ComplexAlgebraicNumber methodsFor: 'testing' stamp: 'len 5/2/2018 17:16:29'!
isAlgebraicInteger
	"An algebraic number is an 'algebraic integer' if it's the root of a monic polynomial in Z[x], in particular if it's minimal polynomial has integer coefficients."
	^ minimalPolynomial isMonic "<- defining the minimal polynomial as integer primitive"

"alternatively, defining the minimal polynomial as monic:
	^ minimalPolynomial coefficients allSatisfy: [:each| each isInteger]
"! !

!ComplexAlgebraicNumber methodsFor: 'testing' stamp: 'len 4/29/2018 23:49:18'!
isImaginary
	^ approximation real abs < radius! !

!ComplexAlgebraicNumber methodsFor: 'testing' stamp: 'len 1/13/2016 03:33'!
isNumber
	^ true! !

!ComplexAlgebraicNumber methodsFor: 'testing' stamp: 'len 4/28/2018 07:05:26'!
isRational
	minimalPolynomial degree < 2 ifTrue: [^ true].
	radius = 0 ifTrue: [^ true].
	(minimalPolynomial rootsIn: QQ)
		do: [:each|
			(each - approximation) abs < radius
				ifTrue: [approximation _ each. radius _ 0. ^ true]].
	^ false! !

!ComplexAlgebraicNumber methodsFor: 'testing' stamp: 'len 4/29/2018 23:49:23'!
isReal
	^ approximation imaginary abs < radius "and: [((RealRootIsolator on: minimalPolynomial) numberOfRootsBetween: approximation real - radius and: approximation real + radius) > 0]"! !

!ComplexAlgebraicNumber methodsFor: 'testing' stamp: 'len 4/28/2018 07:10:14'!
isZero
	^ approximation abs < radius and: [(minimalPolynomial value: 0) = 0]! !

!ComplexAlgebraicNumber methodsFor: 'operations' stamp: 'len 4/30/2018 04:46:52'!
norm
	^ minimalPolynomial independentCoefficient / minimalPolynomial leadingCoefficient * (minimalPolynomial degree even ifTrue: [1] ifFalse: [-1])

"alternatively:
	^ self conjugates product"! !

!ComplexAlgebraicNumber methodsFor: 'operations' stamp: 'len 4/30/2018 06:59:18'!
trace
	"Answer the absolute trace of the receiver."
	^ (minimalPolynomial atDegree: minimalPolynomial degree - 1) negated

"alternatively:
	^ self conjugates sum"! !

!ComplexAlgebraicNumber methodsFor: 'constants' stamp: 'len 6/4/2016 21:18'!
one
	^ 1! !

!ComplexAlgebraicNumber methodsFor: 'constants' stamp: 'len 6/4/2016 21:18'!
zero
	^ 0! !

!ComplexAlgebraicNumber class methodsFor: 'instance creation' stamp: 'len 1/15/2016 02:04'!
approximation: approximateValue radius: approximationError maxDegree: n
	"Answer an algebraic number with the given approximate value, approximation error, with minimal polynomial of degree at most n."
	^ self notYetImplemented! !

!ComplexAlgebraicNumber class methodsFor: 'instance creation' stamp: 'len 4/30/2018 05:38:36'!
fromRational: anIntegerOrFraction
	"Answer an instance of the receiver representing the rational number anIntegerOrFraction."
	| q x |
	q _ anIntegerOrFraction asFraction.
	x _ QQ polynomials x.
	^ self
		minimalPolynomial: x * q denominator - q numerator
 		approximation: anIntegerOrFraction
		radius: 0! !

!ComplexAlgebraicNumber class methodsFor: 'instance creation' stamp: 'len 1/15/2016 02:05'!
minimalPolynomial: aPolynomial approximation: aComplex radius: aNumber
	^ self new
		minimalPolynomial: aPolynomial;
		approximation: aComplex radius: aNumber! !

!ComplexAlgebraicNumber class methodsFor: 'instance creation' stamp: 'len 5/10/2019 08:30:32'!
polynomial: aPolynomial approximation: aComplex radius: aNumber
	| minimalPolynomial |
	minimalPolynomial _ aPolynomial factors detectMin: [:f| (f value: aComplex) abs].
	minimalPolynomial degree = 1 ifTrue: [^ minimalPolynomial independentCoefficient negated / minimalPolynomial leadingCoefficient].
	^ self minimalPolynomial: minimalPolynomial approximation: aComplex radius: aNumber! !

!ComplexAlgebraicNumber class methodsFor: 'examples' stamp: 'len 4/30/2018 01:34:40'!
i
	| x |
	x _ QQ polynomials x.
	^ self minimalPolynomial: x^2 + 1 approximation: 1 i radius: 0! !

!ComplexAlgebraicNumber class methodsFor: 'examples' stamp: 'len 4/30/2018 05:26:21'!
phi
	"Answer the Phidias number or Golden Ratio."
	| x |
	x _ QQ polynomials x.
	^ self minimalPolynomial: x^2 - x - 1 approximation: 2.0 radius: 1! !

!ComplexAlgebraicNumber class methodsFor: 'examples' stamp: 'len 7/15/2016 18:31'!
sqrt2
	"Answer an instance of the receiver representing the square root of 2."

	^ self
		minimalPolynomial: QQ polynomials x squared - 2
 		approximation: 1.5
		radius: 0.1! !

!ComplexAlgebraicNumber class methodsFor: 'examples' stamp: 'len 11/10/2016 10:31'!
sqrt: anIntegerOrFraction
	"Answer a square root of the rational argument."
	^ self
		minimalPolynomial: QQ polynomials x squared - anIntegerOrFraction
 		approximation: (anIntegerOrFraction negative ifTrue: [anIntegerOrFraction negated sqrt i] ifFalse: [anIntegerOrFraction sqrt]) radius: 0.00001! !

!ChainComplex methodsFor: 'accessing' stamp: 'len 5/14/2019 16:44:49'!
<< n
	"Answer the complex with degrees shifted by n."
	^ self >> n negated! !

!ChainComplex methodsFor: 'accessing' stamp: 'len 2/24/2017 19:24:47'!
chains: k
	"Answer the k-chains group or module."
	^ (self d: k) domain! !

!ChainComplex methodsFor: 'accessing' stamp: 'len 5/14/2019 16:41:09'!
d: k
	"Answer the k-th differential or boundary map d(k):C(k)->C(k-1)."
	^ differentials at: differentials size - k + degree! !

!ChainComplex methodsFor: 'accessing' stamp: 'len 4/28/2019 07:03:42'!
differentials
	"Answer the differentials, ordered as d(n) -> ... -> d(1) -> d(0)."
	^ differentials! !

!ChainComplex methodsFor: 'accessing' stamp: 'len 5/14/2019 16:38:47'!
maxDegree
	^ differentials size - 2 + degree! !

!ChainComplex methodsFor: 'accessing' stamp: 'len 5/14/2019 16:38:03'!
scalars
	^ differentials anyOne domain scalars! !

!ChainComplex methodsFor: 'comparing' stamp: 'len 2/20/2017 12:30:30'!
~ aChainComplex
	"Answer true if the receiver is isomorphic to the argument."
	^ self notYetImplemented! !

!ChainComplex methodsFor: 'homology' stamp: 'len 5/14/2019 16:39:15'!
betti
	^ (self degree to: self maxDegree) collect: [:i| self betti: i]! !

!ChainComplex methodsFor: 'homology' stamp: 'len 2/25/2017 07:17:45'!
betti: k
	"Answer the k-th Betti number.
	This is the rank of the k-th homology group.
	For singular homology this gives a measure of the number of k-dimensional holes."
	^ (self homology: k) rank! !

!ChainComplex methodsFor: 'homology' stamp: 'len 2/24/2017 19:36:03'!
boundaries: k
	"Answer the group of k-boundaries B(k), a subgroup of the group of k-chains C(k).
	This is the image of the k+1-th differential d(k+1)."
	^ (self d: k+1) image! !

!ChainComplex methodsFor: 'homology' stamp: 'len 2/24/2017 19:24:57'!
cycles: k
	"Answer the group of k-cycles Z(k), a subgroup of the group of k-chains C(k).
	This is the kernel of the k-th differential d(k)."
	^ (self d: k) kernel! !

!ChainComplex methodsFor: 'homology' stamp: 'len 2/24/2017 19:00:35'!
homology: k
	"Answer the k-th homology group H(k).
	This is the quotient of the k-cycles Z(k) modulo the k-boundaries B(k)."
	^ (self cycles: k) / (self boundaries: k)! !

!ChainComplex methodsFor: 'operations' stamp: 'len 2/20/2017 12:36:55'!
 aChainComplex
	"Answer the cartesian product (direct sum) of the receiver with the argument."
	^ self notYetImplemented! !

!ChainComplex methodsFor: 'operations' stamp: 'len 5/14/2019 20:48:44'!
 aChainComplex
	"Answer the tensor product of the receiver with the argument."
	^ self notYetImplemented! !

!ChainComplex methodsFor: 'operations' stamp: 'len 5/14/2019 16:39:47'!
dual
	"Answer the dual of the receiver. This is the cochain complex, taking dual in all objects and arrows reversed."
	^ self class differentials: (self differentials reversed collect: [:each| each adjoint]) degree: degree! !

!ChainComplex methodsFor: 'testing' stamp: 'len 5/14/2019 16:40:38'!
isExact
	self degree to: self maxDegree do: [:i| (self isExactAt: i) ifFalse: [^ false]].
	^ true! !

!ChainComplex methodsFor: 'testing' stamp: 'len 4/28/2019 15:37:43'!
isExactAt: anInteger
	^ (self d: anInteger) image = (self d: anInteger+1) kernel! !

!ChainComplex methodsFor: 'private' stamp: 'len 5/14/2019 16:35:47'!
differentials: anArray degree: anInteger
	differentials _ anArray.
	degree _ anInteger! !

!ChainComplex methodsFor: 'private' stamp: 'len 5/14/2019 16:41:55'!
verify
	| n |
	n _ self maxDegree.
	(self d: n+1) kernel isTrivial ifFalse: [^ false halt].
	(self d: self degree) image isTrivial ifFalse: [^ false halt].
	n+1 to: self degree + 1 by: -1 do: [:i|
		(self d: i) codomain = (self d: i-1) domain ifFalse: [^ false halt].
		(self d: i) image <= (self d: i-1) kernel ifFalse: [^ false halt]].
	^ true! !

!ChainComplex class methodsFor: 'instance creation' stamp: 'len 5/14/2019 16:35:16'!
differentials: anArray
	^ self differentials: anArray degree: 0! !

!ChainComplex class methodsFor: 'instance creation' stamp: 'len 5/14/2019 16:34:51'!
differentials: anArray degree: anInteger
	^ self new differentials: anArray degree: anInteger! !

!ExactSequence methodsFor: 'testing' stamp: 'len 4/27/2019 11:11:16'!
isExact
	^ true! !

!ExtendedSmithReduction methodsFor: 'as yet unclassified' stamp: 'len 5/5/2019 12:43:36'!
matrix
	^ matrix! !

!ExtendedSmithReduction methodsFor: 'as yet unclassified' stamp: 'len 5/5/2019 12:44:19'!
matrix: aMatrix
	matrix _ aMatrix! !

!ExtendedSmithReduction methodsFor: 'as yet unclassified' stamp: 'len 5/5/2019 14:39:56'!
reduceStep: i mod: D
	| j c euclid B Ai Aj |
	"2. Initialize j for row reduction:"
	[j _ i-1. c _ 0.
	"3. Check zero:"
	[[j >= 1 and: [(S at: i@j) isZero]] whileTrue: [j _ j - 1].
	j >= 1]
		whileTrue: "4. Euclidean step:"
			[euclid _ ExtendedEuclid on: {S at: i@i. S at: i@j}.
"			euclid verifyMinimal ifFalse: [self halt]."
			B _ (Ai _ S columnAt: i) * euclid bezout first + ((Aj _ S columnAt: j) * euclid bezout second).
			S columnAt: j put: Aj * ((S at: i@i) /// euclid gcd) - (Ai * ((S at: i@j) /// euclid gcd)) \\ D.
			S columnAt: i put: B \\ D.
			j _ j - 1].
	"5. Initialize j for column reduction:"
	j _ i-1.
	"6. Check zero (find pivot):"
	[[j >= 1 and: [(S at: j@i) isZero]] whileTrue: [j _ j - 1].
	j >= 1]
		whileTrue: "7. Euclidean step:"
			[euclid _ ExtendedEuclid on: {S at: i@i. S at: j@i}.
"			euclid verifyMinimal ifFalse: [self halt]."
			B _ (Ai _ S rowAt: i) * euclid bezout first + ((Aj _ S rowAt: j) * euclid bezout second).
			S rowAt: j put: Aj * ((S at: i@i) /// euclid gcd) - (Ai * ((S at: j@i) /// euclid gcd)) \\ D.
			S rowAt: i put: B \\ D.
			j _ j - 1.
			c _ c + 1].
	c > 0] whileTrue "8. Repeat stage i?"! !

!ExtendedSmithReduction methodsFor: 'as yet unclassified' stamp: 'len 5/5/2019 14:44:48'!
run
	| n i D b k |
	n _ matrix height.
	L _ matrix leftIdentity.
	R _ matrix rightIdentity.
	S _ matrix copy.
	elementaryDivisors _ OrderedCollection new: n.
	"1. Initialize i:"
	i _ n.
	D _ S determinant.
	(S scalars isKindOf: RationalIntegerRing) ifTrue: [D _ D abs]. "not sure why take abs"
	n = 1 ifTrue: [^ self].
	"2-9. Reduction:"
	[[self reduceStep: i mod: D.
	"9. Check the rest of the matrix:"
	b _ S at: i@i.
	k _ (1 to: i-1) detect: [:k0| ((1 to: i-1) allSatisfy: [:l| b | (S at: k0@l)]) not] ifNone: [].
	k isNil]
		whileFalse:
			[S rowAt: i put: (S rowAt: i) + (S rowAt: k).
			L rowAt: i put: (L rowAt: i) + (L rowAt: k)].
	"10. Next stage:"
	elementaryDivisors add: ((S at: i@i) gcd: D).
	D _ D /// elementaryDivisors last.
	i = 2]
		whileFalse: [i _ i - 1].
	elementaryDivisors add: ((S at: 1@1) gcd: D).
	^ {L. S. R}! !

!HermiteColumnReduction methodsFor: 'as yet unclassified' stamp: 'len 9/28/2018 19:46:17'!
matrix: aMatrix
	matrix _ ColumnMatrix newFrom: aMatrix.
	self run! !

!HermiteColumnReduction methodsFor: 'as yet unclassified' stamp: 'len 5/30/2019 07:11:36'!
reduceStep: k row: i
	| j0 b |
	"2. Row finished?"
	[j0 _ (1 to: k-1)
		detect: [:j| (matrix at: i@j) ~= 0]
		ifNone: [(matrix at: i@k) < 0 ifTrue: [matrix multiplyColumn: k by: -1]. ^ self "go to step 5"].
	"3. Choose non-zero entry with smallest absolute value:"
	j0 _ ((j0 to: k) select: [:j| (matrix at: i@j) ~= 0]) detectMin: [:j| (matrix at: i@j) abs].
	j0 < k ifTrue: [matrix swapColumn: j0 with: k].
	(matrix at: i@k) < 0 ifTrue: [matrix multiplyColumn: k by: -1].
	b _ matrix at: i@k.
	"4. Reduce:"
	1 to: k-1 do: [:j| | q |
		q _ ((matrix at: i@j) / b) rounded.
"		q _ (matrix at: i@j) // b."
		matrix addColumn: k times: q negated toColumn: j]] repeat! !

!HermiteColumnReduction methodsFor: 'as yet unclassified' stamp: 'len 9/28/2018 19:46:34'!
reduced
	^ matrix! !

!HermiteColumnReduction methodsFor: 'as yet unclassified' stamp: 'len 5/30/2019 07:11:48'!
run
	| n m i k l b |
	m _ matrix height.
	n _ matrix width.
	"1. Initialize:"
	i _ m.
	k _ n.
	l _ m > n ifTrue: [m-n+1] ifFalse: [1].
	[self reduceStep: k row: i.
	"5. Final reductions:"
	b _ matrix at: i@k.
	b = 0
		ifTrue:
			[k _ k + 1]
		ifFalse:
			[k+1 to: n do: [:j| | q |
				q _ ((matrix at: i@j) / b) floor. "(matrix at: i@j) // b."
				matrix addColumn: k times: q negated toColumn: j]].
	"6. Finished?"
	i = l] whileFalse: [i _ i - 1. k _ k - 1].
	^ matrix "copyFrom: 1@k to: m@n"! !

!HermiteColumnReduction class methodsFor: 'instance creation' stamp: 'len 9/28/2018 19:47:06'!
on: aMatrix
	^ self new matrix: aMatrix! !

!MatrixReduction methodsFor: 'operations' stamp: 'len 5/30/2019 07:21:15'!
addRow: i0 times: aNumber toRow: i1
	self addRow: i0 times: aNumber toRow: i1 startingAt: 1! !

!MatrixReduction methodsFor: 'operations' stamp: 'len 5/30/2019 07:20:22'!
addRow: i0 times: aNumber toRow: i1 startingAt: startIndex
	matrix addRow: i0 times: aNumber toRow: i1 startingAt: startIndex.
	extension notNil ifTrue: [extension addRow: i0 times: aNumber toRow: i1]! !

!MatrixReduction methodsFor: 'operations' stamp: 'len 1/19/2018 21:38:21'!
multiplyRow: i by: aNumber
	self multiplyRow: i by: aNumber startingAt: 1! !

!MatrixReduction methodsFor: 'operations' stamp: 'len 1/19/2018 21:38:50'!
multiplyRow: i by: aNumber startingAt: startIndex
	matrix multiplyRow: i by: aNumber startingAt: startIndex.
	extension notNil ifTrue: [extension multiplyRow: i by: aNumber].
	determinantFactor _ determinantFactor * aNumber! !

!MatrixReduction methodsFor: 'operations' stamp: 'len 12/27/2015 03:04'!
swapRow: i with: j
	matrix swapRow: i with: j.
	extension notNil ifTrue: [extension swapRow: i with: j].
	determinantFactor _ determinantFactor negated! !

!MatrixReduction methodsFor: 'accessing' stamp: 'len 4/5/2018 15:35:51'!
dependentColumns
	"Answer the collection of indices of dependent columns."
	| independent d answer |
	independent _ self independentColumns.
	d _ 1.
	answer _ OrderedCollection new: matrix width - independent size.
	independent do: [:i| answer addAll: (d to: i-1). d _ i+1].
	answer addAll: (d to: matrix width).
	^ answer! !

!MatrixReduction methodsFor: 'accessing' stamp: 'len 4/5/2018 15:43:28'!
determinant
	"Answer the determinant of the matrix."
	| determinant |
	determinant _ matrix scalars one.
	1 to: matrix height do: [:i|
		determinant _ determinant * (matrix at: i@i)].
	^ determinant / determinantFactor! !

!MatrixReduction methodsFor: 'accessing' stamp: 'len 12/26/2015 05:38'!
extension
	^ extension! !

!MatrixReduction methodsFor: 'accessing' stamp: 'len 3/3/2017 06:08:12'!
independentColumns
	"Answer the collection of indexes of independent columns."
	^ self pivots collect: [:each| each y]! !

!MatrixReduction methodsFor: 'accessing' stamp: 'len 4/5/2018 15:36:11'!
pivots
	| answer i j n |
	answer _ OrderedCollection new: matrix height.
	j _ 1.
	i _ 1.
	n _ matrix width.
	matrix rowsDo: [:row|
		j > n ifTrue: [^ answer].
		((j to: n) detect: [:j0| (row isZeroAt: j0) not] ifNone: [])
			ifNotNil: [:j0| answer add: i@j0. j _ j0 + 1].
		i _ i + 1].
	^ answer! !

!MatrixReduction methodsFor: 'accessing' stamp: 'len 12/26/2015 03:23'!
rank
	^ self pivots size! !

!MatrixReduction methodsFor: 'accessing' stamp: 'len 12/26/2015 03:23'!
reduced
	"Answer the reduced matrix."
	^ matrix! !

!MatrixReduction methodsFor: 'initialization' stamp: 'len 1/19/2018 21:47:11'!
matrix: aMatrix extension: anotherMatrix
	matrix _ RowMatrix newFrom: aMatrix.
	extension _ anotherMatrix ifNotNil: [RowMatrix newFrom: anotherMatrix].
	determinantFactor _ aMatrix scalars one.
	self run! !

!MatrixReduction class methodsFor: 'instance creation' stamp: 'len 12/26/2015 05:41'!
on: aMatrix
	^ self on: aMatrix extension: nil! !

!MatrixReduction class methodsFor: 'instance creation' stamp: 'len 12/26/2015 05:15'!
on: aMatrix extension: anotherMatrix
	^ self new matrix: aMatrix extension: anotherMatrix! !

!GaussianElimination methodsFor: 'private' stamp: 'len 1/19/2018 21:31:10'!
addPivot: aPoint
	currentPivot _ aPoint.
	^ pivots add: aPoint! !

!GaussianElimination methodsFor: 'private' stamp: 'len 4/5/2018 15:37:51'!
nextPivot
	"Advance the position to the next available pivot."
	| col |
	col _ currentPivot y + 1.
	[col <= matrix width]
		whileTrue:
			[1 to: matrix height do: [:each|
				((pivots anySatisfy: [:one| one x = each]) or: [matrix isZeroAt: each @ col])
						ifFalse: [^ self addPivot: each @ col]].
			col _ col + 1].
	^ nil! !

!GaussianElimination methodsFor: 'private' stamp: 'len 1/19/2018 21:59:16'!
pivots
	^ pivots! !

!GaussianElimination methodsFor: 'private' stamp: 'len 5/30/2019 07:19:02'!
reduceStep
	"Perform one step in the reduction of the matrix using the current pivot."
	| row col |
	row _ currentPivot x.
	col _ currentPivot y.
	self multiplyRow: row by: (matrix at: row @ col) reciprocal.
	1 to: matrix height do: [:i|
		(i = row or: [matrix isZeroAt: i @ col])
			ifFalse: [self addRow: row times: (matrix at: i @ col) negated toRow: i]]! !

!GaussianElimination methodsFor: 'private' stamp: 'len 1/19/2018 22:13:04'!
run
	| row |
	row _ 1.
	[self nextPivot isNil]
		whileFalse:
			[self swapRow: row.
			row _ row + 1.
			self reduceStep]! !

!GaussianElimination methodsFor: 'operations' stamp: 'len 5/30/2019 07:21:00'!
addRow: i0 times: aNumber toRow: i1
	self addRow: i0 times: aNumber toRow: i1 startingAt: currentPivot y! !

!GaussianElimination methodsFor: 'operations' stamp: 'len 1/19/2018 21:54:00'!
multiplyRow: i by: aNumber
	self multiplyRow: i by: aNumber startingAt: currentPivot y! !

!GaussianElimination methodsFor: 'operations' stamp: 'len 1/19/2018 23:22:35'!
swapRow: i
	"Swap the anInteger-th row with the row at the current pivot."
	i = currentPivot x ifTrue: [^ self].
	self swapRow: i with: currentPivot x.
	pivots removeLast.
	self addPivot: i @ currentPivot y! !

!GaussianElimination methodsFor: 'initialization' stamp: 'len 4/5/2018 15:37:44'!
matrix: aMatrix extension: anotherMatrix
	pivots _ OrderedCollection new: aMatrix height.
	currentPivot _ 0 @ 0.
	super matrix: aMatrix extension: anotherMatrix! !

!GaussBareiss methodsFor: 'private' stamp: 'len 5/30/2019 07:18:55'!
reduceStep
	"Perform one step reduction of the matrix using the current pivot."
	| row col pivot value |
	row _ currentPivot x.
	col _ currentPivot y.
	pivot _ matrix at: row @ col.
	1 to: matrix height do: [:i|
		(i = row or: [(value _ matrix at: i @ col) isZero])
			ifFalse:
				[self multiplyRow: i by: pivot.
				self addRow: row times: value negated toRow: i]]! !

!HermiteReduction methodsFor: 'private' stamp: 'len 5/30/2019 07:19:29'!
oldreduceStep: k column: j
	"Perform the reduction step on row k and column j."
	| i0 b |
	"2. Column finished?"
	[i0 _ (matrix height to: k+1 by: -1)
		detect: [:i| (matrix at: i@j) ~= 0]
		ifNone: [(matrix at: k@j) < 0 ifTrue: [self multiplyRow: k by: -1]. ^ self "go to step 5"].
	"3. Choose non-zero entry with smallest absolute value:"
	i0 _ ((i0 to: k by: -1) select: [:i| (matrix at: i@j) ~= 0]) detectMin: [:i| (matrix at: i@j) abs].
	i0 > k ifTrue: [self swapRow: i0 with: k].
	(matrix at: k@j) < 0 ifTrue: [self multiplyRow: k by: -1].
	b _ matrix at: k@j.
	"4. Reduce:"
	matrix height to: k+1 by: -1 do: [:i| | q |
		q _ (matrix at: i@j) // b. "q _ ((matrix at: i@j) / b) rounded."
		self addRow: k times: q negated toRow: i]] repeat! !

!HermiteReduction methodsFor: 'private' stamp: 'len 5/30/2019 07:19:44'!
reduceStep: k column: j
	"Perform the reduction step on row k and column j."
	| R i0 b |
	R _ matrix scalars.
	"2. Column finished?"
	[i0 _ (matrix height to: k+1 by: -1)
		detect: [:i| (matrix at: i@j) isZero not]
		ifNone: [self multiplyRow: k by: (R associatedUnit: (matrix at: k@j)) reciprocal. ^ self "go to step 5"].
	"3. Choose non-zero entry with smallest absolute value:"
	i0 _ ((i0 to: k by: -1) select: [:i| (matrix at: i@j) isZero not]) detectMin: [:i| (matrix at: i@j) abs].
	i0 > k ifTrue: [self swapRow: i0 with: k].
	self multiplyRow: k by: (R associatedUnit: (matrix at: k@j)) reciprocal.
	b _ matrix at: k@j.
	"4. Reduce:"
	matrix height to: k+1 by: -1 do: [:i| | q |
		q _ (matrix at: i@j) // b. "q _ ((matrix at: i@j) / b) rounded."
		self addRow: k times: q negated toRow: i]] repeat! !

!HermiteReduction methodsFor: 'private' stamp: 'len 5/30/2019 07:19:53'!
run
	| n m k j l b |
	m _ matrix height.
	n _ matrix width.
	"1. Initialize:"
	k _ 1.
	j _ 1.
	l _ m min: n.
	[self reduceStep: k column: j.
	"5. Final reductions:"
	b _ matrix at: k@j.
	b = 0
		ifTrue:
			[k _ k - 1]
		ifFalse:
			[1 to: k-1 do: [:i| | q |
				q _ (matrix at: i@j) // b.
				self addRow: k times: q negated toRow: i]].
	"6. Finished?"
	j = l] whileFalse: [j _ j + 1. k _ k + 1].
	^ matrix "copyFrom: 1@k to: m@n"! !

!ModularHermiteReduction methodsFor: 'as yet unclassified' stamp: 'len 4/5/2018 15:36:20'!
addColumn: a to: B
	^ (B columnAugmented: a) HNF columnAt: B width + 1! !

!ModularHermiteReduction methodsFor: 'as yet unclassified' stamp: 'len 4/5/2018 15:36:28'!
addRow: b to: H
	| H0 |
	H0 _ H isSquare
		ifTrue: [H]
		ifFalse:
			[H rowAugmented: (H scalars ^ (H width - 1) :: zero, (H rowAugmented: b) determinant)].
	"..."! !

!ModularHermiteReduction methodsFor: 'as yet unclassified' stamp: 'len 7/16/2016 01:28'!
matrix: aMatrix
	matrix _ aMatrix! !

!ModularHermiteReduction methodsFor: 'as yet unclassified' stamp: 'len 3/1/2017 09:06:09'!
probablePivotsOf: aMatrix
	^ aMatrix % (10007 to: 46000) atRandom nextPrime :: reduction pivots
! !

!ModularHermiteReduction methodsFor: 'as yet unclassified' stamp: 'len 7/16/2016 04:35'!
run
"
	HNF _ matrix zero.
	HNF at: 1@1 put: (matrix at: 1@1).
	2 to: matrix numberOfColumns do: [:j|
		a _ matrix columnAt: j.
		x _ self addColumn: a.
		HNF _ addRow: a to: HNF | x
"! !

!SmithReduction methodsFor: 'accessing' stamp: 'len 5/28/2019 08:51:31'!
invariants
	invariants isNil ifTrue: [self run].
	^ invariants! !

!SmithReduction methodsFor: 'accessing' stamp: 'len 5/25/2019 10:28:41'!
matrix
	^ matrix! !

!SmithReduction methodsFor: 'accessing' stamp: 'len 5/25/2019 10:28:41'!
matrix: aMatrix
	matrix _ aMatrix! !

!SmithReduction methodsFor: 'accessing' stamp: 'len 5/28/2019 08:55:12'!
reduced
	^ matrix scalars diagonalMatrix: self invariants! !

!SmithReduction methodsFor: 'private' stamp: 'len 5/25/2019 10:28:41'!
reduceStep: i mod: R
	| j c euclid B Ai Aj |
	"2. Initialize j for row reduction:"
	[j _ i-1. c _ 0.
	"3. Check zero:"
	[[j >= 1 and: [(matrix at: i@j) isZero]] whileTrue: [j _ j - 1].
	j >= 1]
		whileTrue: "4. Euclidean step:"
			[euclid _ ExtendedEuclid on: {matrix at: i@i. matrix at: i@j}.
"			euclid verifyMinimal ifFalse: [self halt]."
			B _ (Ai _ matrix columnAt: i) * euclid bezout first + ((Aj _ matrix columnAt: j) * euclid bezout second).
			matrix columnAt: j put: Aj * ((matrix at: i@i) /// euclid gcd) - (Ai * ((matrix at: i@j) /// euclid gcd)) \\ R.
			matrix columnAt: i put: B \\ R.
			j _ j - 1].
	"5. Initialize j for column reduction:"
	j _ i-1.
	"6. Check zero (find pivot):"
	[[j >= 1 and: [(matrix at: j@i) isZero]] whileTrue: [j _ j - 1].
	j >= 1]
		whileTrue: "7. Euclidean step:"
			[euclid _ ExtendedEuclid on: {matrix at: i@i. matrix at: j@i}.
"			euclid verifyMinimal ifFalse: [self halt]."
			B _ (Ai _ matrix rowAt: i) * euclid bezout first + ((Aj _ matrix rowAt: j) * euclid bezout second).
			matrix rowAt: j put: Aj * ((matrix at: i@i) /// euclid gcd) - (Ai * ((matrix at: j@i) /// euclid gcd)) \\ R.
			matrix rowAt: i put: B \\ R.
			j _ j - 1.
			c _ c + 1].
	c > 0] whileTrue "8. Repeat stage i?"! !

!SmithReduction methodsFor: 'private' stamp: 'len 5/29/2019 15:55:42'!
run
	| n i R b k |
	n _ matrix height.
	invariants _ OrderedCollection new: n.
	"1. Initialize i:"
	i _ n.
	R _ matrix determinant.
"	(matrix scalars isKindOf: RationalIntegerRing) ifTrue: [R _ R abs]." "not sure why take abs"
	R _ R / (matrix scalars associatedUnit: R). "replaces R _ R abs"
	n = 1 ifTrue: [invariants add: R. ^ self].
	"2-9. Reduction:"
	[[self reduceStep: i mod: R.
	"9. Check the rest of the matrix:"
	b _ matrix at: i@i.
	k _ (1 to: i-1) detect: [:k0| ((1 to: i-1) allSatisfy: [:l| b | (matrix at: k0@l)]) not] ifNone: [].
	k isNil]
		whileFalse: [matrix rowAt: i put: (matrix rowAt: i) + (matrix rowAt: k)].
	"10. Next stage:"
	invariants add: ((matrix at: i@i) gcd: R).
	R _ R /// invariants last.
	i = 2]
		whileFalse: [i _ i - 1].
	invariants add: ((matrix at: 1@1) gcd: R).
"	diagonal _ matrix scalars tuple: diagonal"! !

!LLL methodsFor: 'initialization' stamp: 'len 12/26/2015 21:06'!
basis: aCollection
	| d |
	basis _ Array withAll: aCollection.
	d _ basis size.
	delta _ 3/4 "(4/3 + 0.0000000001)^((d-1)/2)"! !

!LLL methodsFor: 'private' stamp: 'len 4/29/2019 10:20:51'!
computeMu
	| n bi oj |
	n _ basis size.
	mu _ ZZ matrix: n@n evaluating: [:i :j|
		bi _ basis at: i.
		oj _ orthogonalBasis at: j.
		(bi  oj) / (oj  oj)]! !

!LLL methodsFor: 'private' stamp: 'len 4/29/2019 10:21:03'!
computeOrthogonalBasis
	| k vi vj vectors |
	vectors _ Array withAll: basis.
	k _ vectors size.
	1 to: k do: [ :i |
		vi _ vectors at: i.
		i+1 to: k do: [ :j |
			vj _ vectors at: j.
			vj _ vj - (vi * ((vj  vi) / (vi  vi))).
			vectors at: j put: vj ] ].
	orthogonalBasis _ vectors! !

!LLL methodsFor: 'private' stamp: 'len 12/26/2015 21:00'!
computeReducedBasis
	| k mukj bj bk a b |
	self computeOrthogonalBasis; computeMu.
	k _ 1.
	[k < basis size] whileTrue:
		[k-1 to: 0 by: -1 do: [ :j |
			mukj _ mu at: k+1 @ (j+1).
			bj _ basis at: j+1.
			bk _ basis at: k+1.
			mukj abs > (1/2) ifTrue:
				[basis at: k+1 put: bk - (bj * mukj rounded).
				self update: k+1]].
		a _ (orthogonalBasis at: k+1) norm2.
		b _ (orthogonalBasis at: k) norm2.
		a >= ((delta - (mu at: k+1 @ k) squared) * b)
			ifTrue: [k _ k + 1]
			ifFalse:
				[basis swap: k+1 with: k.
				self update: k+1.
				k _ k-1 max: 1]].
	^ basis! !

!LLL methodsFor: 'private' stamp: 'len 2/23/2016 07:33'!
update: k
	self flag: #fix. "don't need to recompute all"
	self computeOrthogonalBasis; computeMu! !

!LLL methodsFor: 'accessing' stamp: 'len 12/23/2015 03:01'!
reducedBasis
	orthogonalBasis notNil ifFalse: [self computeReducedBasis].
	^ basis! !

!LLL class methodsFor: 'instance creation' stamp: 'len 12/23/2015 03:04'!
basis: aCollection
	^ self new basis: aCollection! !

!LLL class methodsFor: 'examples' stamp: 'len 10/28/2016 18:21'!
example
	| b1 b2 b3 lll |
	b1 _ (1, 1, 1).
	b2 _ (-1, 0, 2).
	b3 _ (3, 5, 6).
	lll _ self basis: { b1. b2. b3 }.
	^ lll reducedBasis! !

!LLL class methodsFor: 'examples' stamp: 'len 10/29/2016 08:33'!
example2
	"Find polynomial x^2 - x - 1 that has the golden ratio phi as root."
	| r b1 b2 b3 lll |
	r _ 1.618034.
	b1 _ (1, 0, 0, (10000 * r squared)).
	b2 _ (0, 1, 0, (10000 * r)).
	b3 _ (0, 0, 1, 10000).
	lll _ self basis: { b1. b2. b3 }.
	^ lll reducedBasis! !

!ModuleMonomial methodsFor: 'comparing' stamp: 'len 1/5/2018 11:20:58'!
< aModuleMonomial
	^ (self >= aModuleMonomial) not! !

!ModuleMonomial methodsFor: 'comparing' stamp: 'len 1/5/2018 11:21:09'!
<= aModuleMonomial
	self == aModuleMonomial ifTrue: [^ true].
	^ (self > aModuleMonomial) not! !

!ModuleMonomial methodsFor: 'comparing' stamp: 'len 1/5/2018 11:19:20'!
= aModuleMonomial
	^ monomial = aModuleMonomial monomial and: [position = aModuleMonomial position]! !

!ModuleMonomial methodsFor: 'comparing' stamp: 'len 1/5/2018 11:20:49'!
> aModuleMonomial
	^ (self compare: aModuleMonomial) > 0! !

!ModuleMonomial methodsFor: 'comparing' stamp: 'len 1/5/2018 11:21:27'!
>= aModuleMonomial
	self == aModuleMonomial ifTrue: [^ true].
	^ (self compare: aModuleMonomial) >= 0! !

!ModuleMonomial methodsFor: 'comparing' stamp: 'len 1/5/2018 11:22:02'!
compare: aModuleMonomial
	"Answer -1 if the receiver is < than the argument, 0 if they are equal, 1 if it is > than the argument."
	^ self ordering compare: self with: aModuleMonomial! !

!ModuleMonomial methodsFor: 'comparing' stamp: 'len 1/5/2018 11:20:11'!
hash
	^ monomial hash + position hash hashMultiply! !

!ModuleMonomial methodsFor: 'testing' stamp: 'len 1/5/2018 11:23:44'!
| aModuleMonomial
	"Answer true if the receiver divides the argument."
	^ position = aModuleMonomial position and: [monomial | aModuleMonomial monomial]! !

!ModuleMonomial methodsFor: 'accessing' stamp: 'len 1/14/2017 20:20:21'!
monomial
	^ monomial! !

!ModuleMonomial methodsFor: 'accessing' stamp: 'len 1/5/2018 11:22:11'!
ordering
	^ parent ordering! !

!ModuleMonomial methodsFor: 'accessing' stamp: 'len 1/5/2018 11:25:10'!
parent
	^ parent! !

!ModuleMonomial methodsFor: 'accessing' stamp: 'len 1/14/2017 20:20:47'!
position
	^ position! !

!ModuleMonomial methodsFor: 'accessing-private' stamp: 'len 1/14/2017 20:20:31'!
monomial: aMonomial
	monomial _ aMonomial! !

!ModuleMonomial methodsFor: 'accessing-private' stamp: 'len 1/14/2017 20:20:41'!
position: anInteger
	position _ anInteger! !

!ModuleMonomialOrdering methodsFor: 'ordering' stamp: 'len 1/14/2017 20:54:49'!
compare: aModuleMonomial with: anotherModuleMonomial
	^ self subclassResponsibility! !

!ModuleMonomialOrdering methodsFor: 'ordering' stamp: 'len 1/14/2017 21:08:38'!
leadingMonomialOf: aPolynomialTuple
	self subclassResponsibility! !

!ModuleMonomialOrdering methodsFor: 'ordering' stamp: 'len 1/5/2018 11:14:14'!
type
	^ nil! !

!ModuleMonomialOrdering class methodsFor: 'as yet unclassified' stamp: 'len 1/7/2018 17:10:27'!
pos
	^ PositionOverTermOrdering new! !

!ModuleMonomialOrdering class methodsFor: 'as yet unclassified' stamp: 'len 1/7/2018 17:10:09'!
top
	^ TermOverPositionOrdering new! !

!PositionOverTermOrdering methodsFor: 'as yet unclassified' stamp: 'len 1/5/2018 11:16:54'!
compare: aModuleMonomial with: anotherModuleMonomial
	| result |
	(result _ (aModuleMonomial position - anotherModuleMonomial position) sign	) == 0
		ifFalse: [^ result].
	^ aModuleMonomial monomial compare: anotherModuleMonomial monomial! !

!PositionOverTermOrdering methodsFor: 'as yet unclassified' stamp: 'len 1/5/2018 11:15:41'!
type
	^ #pos! !

!SchreyerOrdering methodsFor: 'as yet unclassified' stamp: 'len 1/5/2018 11:25:47'!
type
	^ #schreyer! !

!TermOverPositionOrdering methodsFor: 'as yet unclassified' stamp: 'len 1/14/2017 21:01:40'!
compare: aModuleMonomial with: anotherModuleMonomial
	| result |
	(result _ aModuleMonomial monomial compare: anotherModuleMonomial monomial) == 0
		ifFalse: [^ result].
	^ (aModuleMonomial position - anotherModuleMonomial position) sign! !

!TermOverPositionOrdering methodsFor: 'as yet unclassified' stamp: 'len 1/5/2018 11:15:34'!
type
	^ #top! !

!Buchberger methodsFor: 'as yet unclassified' stamp: 'len 5/7/2018 18:14:03'!
basis
	basis ifNil: [self run].
	^ basis! !

!Buchberger methodsFor: 'as yet unclassified' stamp: 'len 5/7/2018 18:13:47'!
ideal: anIdeal
	ideal _ anIdeal! !

!Buchberger methodsFor: 'as yet unclassified' stamp: 'len 5/15/2018 16:04:26'!
run
	"Buchberger's algorithm.
	Compute a standard basis from the input polynomials with the specified ordering."
	| S i0 |
	basis _ ideal ordering isGlobal ifTrue: [GroebnerBasis new] ifFalse: [StandardBasis new].
	ideal isZero ifTrue: [^ basis].
	ideal scalars scalars isField ifFalse: [^ DomainError signal: 'not over a field'].
	S _ ideal generators copy.
	[i0 _ basis size + 1.
	S _ S asSortedCollection: [:a :b| a leadingMonomial <= b leadingMonomial].
	"Full reduction in this step produces a reduced basis:"
	S do: [:f| | r | (r _ basis reduceFull: f) isZero ifFalse: [basis add: r]].
	S _ OrderedCollection new.
	1 to: basis size do: [:i| | fi hi ci |
		fi _ basis at: i.
		hi _ fi leadingMonomial.
		ci _ fi leadingCoefficient.
		(i+1 max: i0) to: basis size do: [:j| | fj hj cj lcm r |
			fj _ basis at: j.
			hj _ fj leadingMonomial.
			lcm _ hi lcm: hj.
			"Buchberger criterium 1 and 2:"
			(lcm ~= (hi * hj) and: [((1 to: i-1) noneSatisfy: [:k| (basis at: k) leadingMonomial | lcm])])
				ifTrue:
					[cj _ fj leadingCoefficient.
					"Perform only top-reduction here (do full-reduction just before adding to the basis):"
					r _ basis reduce: fi * (lcm / hi) / ci - (fj * (lcm / hj) / cj).
					r isZero
						"ifTrue: [Display fill: (i@k*4 extent: 3@3) fillColor: Color red]"
						ifFalse: [
							"Display fill: (i@k*4 extent: 3@3) fillColor: Color green."
							S add: r]]]].
	S isEmpty] whileFalse! !

!Buchberger class methodsFor: 'instance creation' stamp: 'len 5/7/2018 18:14:18'!
on: anIdeal
	^ self new ideal: anIdeal! !

!ExtendedBuchberger methodsFor: 'as yet unclassified' stamp: 'len 5/7/2018 23:54:08'!
matrix
	matrix ifNil: [self run].
	^ matrix! !

!ExtendedBuchberger methodsFor: 'as yet unclassified' stamp: 'len 5/4/2019 03:38:27'!
run
	"Extended Buchberger algorithm.
	Compute a standard basis from the input polynomials with the specified ordering."
	| R M S combinations division i0 |
	ideal ordering isGlobal ifFalse: [DomainError signal: 'not a global ordering'].
	basis _ GroebnerBasis new.
	combinations _ OrderedCollection new.
	R _ ideal scalars.
	R scalars isField ifFalse: [^ DomainError signal: 'not over a field'].
	M _ FreeSumsModule on: ideal generators over: R.
	S _ ideal generators withIndexCollect: [:each :i| each -> (M e: i)].
	S _ S asSortedCollection: [:a :b| a key leadingMonomial <= b key leadingMonomial].
	[i0 _ basis size + 1.
	S do: [:f| (basis reduce: f key) isZero ifFalse: [basis add: f key. combinations add: f value]].
	S removeAll.
	1 to: basis size do: [:i| | fi hi ci ai |
		fi _ basis at: i.
		hi _ fi leadingMonomial.
		ci _ fi coefficientAt: hi.
		ai _ combinations at: i.
		(i+1 max: i0) to: basis size do: [:k| | fk hk ck lcm r f ak |
			fk _ basis at: k.
			hk _ fk leadingMonomial.
			lcm _ hi lcm: hk.
			"Buchberger criterium 1 and 2:"
			(lcm ~= (hi * hk) and: [((1 to: i-1) noneSatisfy: [:j| (basis at: j) leadingMonomial | lcm])])
				ifTrue:
					[ck _ fk coefficientAt: hk.
					ak _ combinations at: k.
					f _ fi * (lcm / hi) / ci - (fk * (lcm / hk) / ck).
					division _ MultivariatePolynomialDivision divide: f by: basis.
					r _ division remainder.
					r isZero
"						ifTrue: [Display fill: (i@k*4 extent: 3@3) fillColor: Color red]"
						ifFalse:
							["Display fill: (i@k*4 extent: 3@3) fillColor: Color green."
							S add: r -> ((ai * (R one * (lcm / hi) / ci) - (ak * (R one * (lcm / hk) / ck))) - (combinations * division quotients) sum)]]]].
	S isEmpty] whileFalse.
	matrix _ R matrix: combinations size @ ideal generators size evaluating: [:i :j| (combinations at: i) at: (ideal generators at: j)]! !

!ExtendedBuchberger methodsFor: 'as yet unclassified' stamp: 'len 5/10/2018 17:47:12'!
verify
	| S G |
	S _ ideal scalars tuple: ideal generators.
	G _ ideal scalars tuple: self basis.
	^ matrix * S = G! !

!ComplexRootIsolator methodsFor: 'as yet unclassified' stamp: 'len 3/6/2017 16:56:02'!
T2: K at: m radius: r
	| t |
	t _ 0.
	1 to: self derivatives size - 1 do: [:j|
		| f |
		f _ derivatives at: j+1.
		t _ (f value: m) abs * (r ^ j) / j factorial + t].
	^ (derivatives first value: m) abs > (K * t)! !

!ComplexRootIsolator methodsFor: 'as yet unclassified' stamp: 'len 4/24/2018 17:53:58'!
T: K at: m radius: r
	| t |
	t _ 0.
	1 to: self derivatives size do: [:j|
		| f |
		f _ derivatives at: j.
		t _ (f value: m) abs * (r ^ j) / j factorial + t].
	^ (polynomial value: m) abs > (K * t)! !

!ComplexRootIsolator methodsFor: 'as yet unclassified' stamp: 'len 12/4/2017 13:22:20'!
atMostOneRootAround: center radius: radius
	"If this holds, there's at most one root in the givem disk."
	^ self T2: 3/2 at: center radius: radius
"	^ (self rootsIn: aBox) size > 1"! !

!ComplexRootIsolator methodsFor: 'as yet unclassified' stamp: 'len 4/11/2018 21:50:32'!
bigBounds
	"Compute and answer a first estimate of a box containing all the complex roots."
	| bound |
	bound _ self polynomial norm1 / self polynomial leadingCoefficient.
	bound _ bound max: 1.
	^ ComplexBox center: 0.0 radius: bound asFloat! !

!ComplexRootIsolator methodsFor: 'as yet unclassified' stamp: 'len 4/24/2018 17:54:29'!
derivatives
	| f |
	derivatives ifNotNil: [^ derivatives].
	f _ polynomial.
	derivatives _ OrderedCollection new: f degree.
	f degree timesRepeat: [derivatives add: (f _ f derivative)].
	^ derivatives! !

!ComplexRootIsolator methodsFor: 'as yet unclassified' stamp: 'len 4/24/2018 17:54:34'!
eightPointTest: m width: w
	| N NE E SE S SW W NW points values imaginaryCrossings realCrossings |
	N _ 1 i.
	NE _ 20/29 + (21/29) i.
	E _ 1.
	SE _ 20/29 - (21/29) i.
	S _ -1 i.
	SW _ -20/29 - (21/29) i.
	W _ -1.
	NW _ -20/29 + (21/29) i.
	points _ {N. NE. E. SE. S. SW. W. NW} collect: [:p| w*p + m].
	values _ points collect: [:p| polynomial value: p].
	realCrossings _ (1 to: values size) select: [:j| (values at: j) real isZero or: [(values at: j) real * (values atWrap: j+1) real < 0]].
	realCrossings size = 2 ifFalse: [^ false].
	imaginaryCrossings _ (1 to: values size) select: [:j| (values at: j) imaginary isZero or: [(values at: j) imaginary * (values atWrap: j+1) imaginary < 0]].
	imaginaryCrossings size = 2 ifFalse: [^ false].
	realCrossings first < imaginaryCrossings first
		ifTrue: [^ realCrossings second < imaginaryCrossings second].
	^ realCrossings first > imaginaryCrossings first
		and: [realCrossings second > imaginaryCrossings second]! !

!ComplexRootIsolator methodsFor: 'as yet unclassified' stamp: 'len 4/24/2018 18:20:26'!
polynomial
	^ polynomial! !

!ComplexRootIsolator methodsFor: 'as yet unclassified' stamp: 'len 4/29/2018 16:59:47'!
polynomial: aPolynomial
	polynomial _ aPolynomial integerPrimitive! !

!ComplexRootIsolator methodsFor: 'as yet unclassified' stamp: 'len 4/16/2018 16:06:13'!
roots
	"Separate the roots in disks each of them containing one isolated root."
	^ self rootsInBox: self bigBounds! !

!ComplexRootIsolator methodsFor: 'as yet unclassified' stamp: 'len 4/29/2018 16:56:39'!
rootsInBox: aBox
	"Separate the roots in disks each of them containing one isolated root."
	| queue disks |
	queue _ OrderedCollection with: aBox.
	disks _ OrderedCollection new.
	[queue isEmpty]
		whileFalse:
			[| B m delta |
			B _ queue removeFirst.
			m _ B midpoint.
			delta _ B width * 3 / 4. "> B radius, and a dyadic fraction"
			(self T: 1 at: m radius: delta)
				"if holds, then D(m,delta) constains no roots"
				ifFalse:
					[((self T2: 6 at: m radius: 4*delta) and: [self T2: 3/2 at: m radius: 8*delta])
						"if the second holds, then D(m,8*delta) contains at most one root"
						"the first is required so that if two disks overlap, we can discard any one of them"
						ifTrue:
							[(self eightPointTest: m width: B width)
								ifTrue:
									[| D i D2 |
									D _ ComplexDisk center: m radius: 4*delta.
									(i _ (1 to: disks size) detect: [:j| (D2 _ disks at: j) intersects: D] ifNone: [])
									 isNil
										ifTrue: [disks add: D]
										ifFalse: [D2 radius < D radius ifTrue: [disks at: i put: D]]]]
						ifFalse:
							[queue addAll: B quarters]]].
	^ disks! !

!ComplexRootIsolator class methodsFor: 'instance creation' stamp: 'len 4/24/2018 18:01:29'!
on: aPolynomial
	^ self new polynomial: aPolynomial! !

!MultivariatePolynomialDivision methodsFor: 'private' stamp: 'len 5/9/2018 15:44:00'!
divide
	"Perform the division algorithm computing quotients and remainder."
	| p s zero fi q headp headfi t i |
	zero _ dividend zero.
	quotients _ (1 to: divisors size) collect: [:each| zero].
	divisors isEmpty ifTrue: [remainder _ dividend. ^ self].
	remainder _ zero.
	s _ divisors size.
	p _ dividend.
	[p isZero] whileFalse:
		[headp _ p leadingMonomial.
		t _ p leadingTerm.
		i _ 1.
		[headfi _ (fi _ divisors at: i) leadingMonomial.
		headfi | headp or: [(i _ i + 1) > s]] whileFalse.
		i <= s "i.e. found fi such that headfi | headp"
			ifTrue:
				[q _ t / headfi * fi leadingCoefficient reciprocal.
				quotients at: i put: (quotients at: i) + q.
				p _ p - (fi * q)]
			ifFalse:
				[remainder _ remainder + t.
				p _ p - t]]! !

!MultivariatePolynomialDivision methodsFor: 'private' stamp: 'len 4/4/2018 21:33:40'!
divide2
	"Perform the division algorithm computing quotients and remainder."
	| p s zero fi q headp headfi t heads i inverses |
	zero _ dividend zero.
	quotients _ (1 to: divisors size) collect: [:each| zero].
	divisors isEmpty ifTrue: [remainder _ dividend. ^ self].
	remainder _ zero.
	s _ divisors size.
	p _ dividend.
	heads _ Array new: divisors size.
	inverses _ Array new: divisors size.
	[p isZero] whileFalse:
		[headp _ p leadingMonomial.
		t _ p termAt: headp.
		i _ 1.
		[headfi _ (heads at: i) ifNil: [heads at: i put: (fi _ divisors at: i) leadingMonomial].
		(headfi | headp) or: [(i _ i + 1) > s]] whileFalse.
		i <= s "i.e. found fi such that headfi | headp"
			ifTrue:
				[fi _ divisors at: i.
				q _ t / headfi * ((inverses at: i) ifNil: [inverses at: i put: (fi at: headfi) reciprocal]).
				quotients at: i put: (quotients at: i) + q.
				p _ p - (fi * q)]
			ifFalse:
				[remainder _ remainder + t.
				p _ p - t]]! !

!MultivariatePolynomialDivision methodsFor: 'private' stamp: 'len 4/4/2018 21:33:49'!
divide3
	"Perform the division algorithm computing quotients and remainder."
	| p s zero fi q headp headfi t heads i |
	zero _ dividend zero.
	quotients _ (1 to: divisors size) collect: [:each| zero].
	divisors isEmpty ifTrue: [remainder _ dividend. ^ self].
	remainder _ zero.
	s _ divisors size.
	p _ dividend.
	heads _ Array new: divisors size.
	[p isZero] whileFalse:
		[headp _ p leadingMonomial.
		t _ p termAt: headp.
		i _ 1.
		[headfi _ (heads at: i) ifNil: [heads at: i put: (fi _ divisors at: i) leadingMonomial].
		(headfi | headp) or: [(i _ i + 1) > s]] whileFalse.
		i <= s "i.e. found fi such that headfi | headp"
			ifTrue:
				[fi _ divisors at: i.
				q _ t / headfi * (fi at: headfi) reciprocal.
				quotients at: i put: (quotients at: i) + q.
				p _ p - (fi * q)]
			ifFalse:
				[remainder _ remainder + t.
				p _ p - t]]! !

!MultivariatePolynomialDivision methodsFor: 'private' stamp: 'len 5/10/2018 07:23:22'!
verify
	| total |
	total _ self remainder.
	self divisors with: self quotients do: [:f :q| total _ total + (f*q)].
	total = self dividend ifFalse: [^ false].

	self divisors with: self quotients do: [:f :q|
		(q isZero or: [(f*q) leadingMonomial <= self dividend leadingMonomial])
			ifFalse: [^ false]].

	self remainder monomials do: [:each| (self divisors noneSatisfy: [:f| f leadingMonomial | each]) ifFalse: [^ false]].
	^ true! !

!MultivariatePolynomialDivision methodsFor: 'initialization' stamp: 'len 12/6/2015 19:03'!
divide: aPolynomial by: anArrayOfPolynomials
	dividend _ aPolynomial.
	divisors _ anArrayOfPolynomials! !

!MultivariatePolynomialDivision methodsFor: 'accessing' stamp: 'len 12/2/2015 02:48'!
dividend
	^ dividend! !

!MultivariatePolynomialDivision methodsFor: 'accessing' stamp: 'len 12/2/2015 02:48'!
divisors
	^ divisors! !

!MultivariatePolynomialDivision methodsFor: 'accessing' stamp: 'len 2/6/2017 07:47:28'!
exactQuotient
	self remainder isZero ifFalse: [self error: 'not an exact division'].
	^ self quotient! !

!MultivariatePolynomialDivision methodsFor: 'accessing' stamp: 'len 3/9/2016 07:55'!
quotient
	self quotients size = 1 ifFalse: [self error: 'not just one quotient'].
	^ self quotients first! !

!MultivariatePolynomialDivision methodsFor: 'accessing' stamp: 'len 12/6/2015 06:13'!
quotients
	quotients isNil ifTrue: [self divide].
	^ quotients! !

!MultivariatePolynomialDivision methodsFor: 'accessing' stamp: 'len 12/6/2015 06:13'!
remainder
	remainder isNil ifTrue: [self divide].
	^ remainder! !

!MultivariatePolynomialDivision class methodsFor: 'instance creation' stamp: 'len 11/20/2016 15:19:29'!
divide: aPolynomial by: anArrayOfPolynomials
	^ self new divide: aPolynomial by: anArrayOfPolynomials! !

!NumericalComplexRootIsolator methodsFor: 'private' stamp: 'len 1/13/2016 03:01'!
initialValue
	^ 1.3 + 0.314159 i! !

!NumericalComplexRootIsolator methodsFor: 'private' stamp: 'len 5/7/2018 17:35:32'!
roots
	| roots X P Q P2 Q2 n x v m c dx x1 v1 m1 realCoefficients |
	X _ polynomial parent x.
	P _ polynomial.
	Q _ P.
	P2 _ P derivative.
	Q2 _ P2.
	n _ P degree.
	roots _ OrderedCollection new: n.
	realCoefficients _ P coefficients allSatisfy: [:each| (each isKindOf: Number) or: [each imaginary isZero]].
	["Initialize root finding:"
	x _ self initialValue.
	v _ Q value: x.
	m _ v norm2.
	"Initialize recursion:"
	c _ 0. dx _ v / (Q2 value: x).
	[dx abs < tolerance]
		whileFalse:
			[x1 _ x - dx.
			v1 _ Q value: x1.
			m1 _ v1 norm2.
			m1 < m
				ifTrue: [x _ x1. v _ v1. m _ m1. c _ 0. dx _ v / (Q2 value: x)]
				ifFalse: [c _ c + 1. dx _ dx / 4. c > 20 ifTrue: [self error: 'failed']]].
	"Polish root:"
	2 timesRepeat: [x _ x - ((P value: x) / (P2 value: x))].
	"Divide:"
	((realCoefficients not or: [n = 1]) or: [x imaginary abs < tolerance "###"])
		ifTrue: "found one root"
			[x imaginary abs < tolerance ifTrue: [x _ x real]. "###"
			roots add: (ComplexDisk center: x radius: tolerance).
			Q _ Q // (X - x).
			Q2 _ Q derivative. "###"
			n _ n - 1]
		ifFalse: "found a root and (if the root is not real) also found its conjugate"
			[roots
				add: (ComplexDisk center: x radius: tolerance);
				add: (ComplexDisk center: x conjugated radius: tolerance).
			Q _ Q // (X^2 - (X * (x real * 2)) + x abs squared).
			Q2 _ Q derivative. "###"
			n _ n - 2].
	n > 0] whileTrue.
	^ roots! !

!NumericalComplexRootIsolator methodsFor: 'initialization' stamp: 'len 1/15/2016 06:09'!
initialize
	super initialize.
	tolerance _ 0.1! !

!NumericalComplexRootIsolator methodsFor: 'accessing' stamp: 'len 5/10/2019 08:30:57'!
rootNear: aComplex
"	[self roots do: [:each| (each approximation - aComplex) abs < epsilon ifTrue: [^ each]].
	self roots do: [:each| each refine]] repeat"
	^ self roots detectMin: [:each| (each approximation - aComplex) abs]! !

!NumericalComplexRootIsolator methodsFor: 'accessing' stamp: 'len 1/15/2016 05:57'!
tolerance
	^ tolerance! !

!NumericalComplexRootIsolator methodsFor: 'accessing' stamp: 'len 1/15/2016 05:53'!
tolerance: aNumber
	tolerance _ aNumber! !

!NumericalComplexRootIsolator class methodsFor: 'instance creation' stamp: 'len 1/17/2016 01:40'!
polynomial: aPolynomial
	^ self squareFreePolynomial: aPolynomial // (aPolynomial gcd: aPolynomial derivative)! !

!NumericalComplexRootIsolator class methodsFor: 'instance creation' stamp: 'len 1/17/2016 01:41'!
squareFreePolynomial: aPolynomial
	^ super polynomial: aPolynomial! !

!PolynomialDivision methodsFor: 'private' stamp: 'len 4/24/2018 00:47:15'!
divide
	"Compute the quotient and the remainder polynomials."
	| quo rem lc n m term |
	divisor isZero ifTrue: [^ (ZeroDivide dividend: dividend) signal].
	(m _ divisor degree) = 0
		ifTrue: [quotient _ dividend * divisor leadingCoefficient reciprocal.
					remainder _ dividend zero.
					^ self].
	dividend degree < m
		ifTrue: [quotient _ dividend zero. remainder _ dividend.
					^ self].
"	indeterminate _ divisor leadingIndeterminate."
	quo _ dividend parent zero.
	rem _ dividend copy.
	lc _ divisor leadingCoefficient.
	[(n _ rem degree) >= m]
		whileTrue:
			[term _ dividend parent coefficient: rem leadingCoefficient / lc degree: n-m.
			rem _ rem + (divisor * term negated).
			"or optimized as:
			divisor monomialsAndCoefficientsDo: [:key :value|
				rem coefficientAt: key * monomial add: value * minusC]."
			quo _ quo + term.
			" or optimized as:
			quo coefficientAt: monomial add: c"].
	quotient _ quo. remainder _ rem! !

!PolynomialDivision methodsFor: 'private' stamp: 'len 5/26/2018 16:57:26'!
divideNoQuotient
	"Compute the remainder polynomial."
	| rem lc n m term |
	divisor isZero ifTrue: [^ (ZeroDivide dividend: dividend) signal].
	(m _ divisor degree) = 0
		ifTrue: [quotient _ dividend * divisor leadingCoefficient reciprocal.
					remainder _ dividend zero.
					^ self].
	dividend degree < m
		ifTrue: [quotient _ dividend zero. remainder _ dividend.
					^ self].
"	indeterminate _ divisor leadingIndeterminate."
	rem _ dividend copy.
	lc _ divisor leadingCoefficient.
	[(n _ rem degree) >= m]
		whileTrue:
			[term _ dividend parent coefficient: rem leadingCoefficient / lc degree: n-m.
			rem _ rem + (divisor * term negated).
			"or optimized as:
			divisor monomialsAndCoefficientsDo: [:key :value|
				rem coefficientAt: key * monomial add: value * minusC]."].
	remainder _ rem! !

!PolynomialDivision methodsFor: 'initialization' stamp: 'len 12/6/2015 06:19'!
divide: aPolynomial by: anotherPolynomial
	dividend _ aPolynomial.
	divisor _ anotherPolynomial! !

!PolynomialDivision methodsFor: 'accessing' stamp: 'len 12/2/2015 02:43'!
dividend
	^ dividend! !

!PolynomialDivision methodsFor: 'accessing' stamp: 'len 12/2/2015 02:44'!
divisor
	^ divisor! !

!PolynomialDivision methodsFor: 'accessing' stamp: 'len 2/6/2017 07:47:58'!
exactQuotient
	self remainder isZero ifFalse: [self error: 'not an exact division'].
	^ self quotient! !

!PolynomialDivision methodsFor: 'accessing' stamp: 'len 12/6/2015 06:19'!
quotient
	quotient isNil ifTrue: [self divide].
	^ quotient! !

!PolynomialDivision methodsFor: 'accessing' stamp: 'len 5/26/2018 16:55:14'!
remainder
	remainder isNil ifTrue: [self divideNoQuotient].
	^ remainder! !

!PolynomialDivision class methodsFor: 'instance creation' stamp: 'len 1/23/98 16:03'!
divide: aPolynomial by: anotherPolynomial
	"Answer a division algorithm to divide aPolynomial by anotherPolynomial."

	^ self new divide: aPolynomial by: anotherPolynomial! !

!PolynomialPseudoDivision methodsFor: 'accessing' stamp: 'len 3/8/2016 22:39'!
delta
	"Answer an integer delta such that the dividend multiplied by the divisor's leading coeficient raised to the delta equals the product of the quotient by the divisor plus the remainder (the pseudo-division relation)."
	^ self dividend degree - self divisor degree + 1 max: 0! !

!PolynomialPseudoDivision methodsFor: 'accessing' stamp: 'len 12/11/2015 06:55'!
dividend
	^ dividend! !

!PolynomialPseudoDivision methodsFor: 'accessing' stamp: 'len 12/2/2015 02:51'!
divisor
	^ divisor! !

!PolynomialPseudoDivision methodsFor: 'accessing' stamp: 'len 5/16/2019 04:13:07'!
exactQuotient
	"Answer the quotient of an exact division."
	self remainder isZero ifFalse: [self error: 'not an exact division'].
	^ self quotient /// (divisor leadingCoefficient ^ self delta)! !

!PolynomialPseudoDivision methodsFor: 'accessing' stamp: 'len 12/6/2015 07:30'!
quotient
	quotient isNil ifTrue: [self divide].
	^ quotient! !

!PolynomialPseudoDivision methodsFor: 'accessing' stamp: 'len 12/6/2015 07:31'!
remainder
	remainder isNil ifTrue: [self divide].
	^ remainder! !

!PolynomialPseudoDivision methodsFor: 'private' stamp: 'len 1/23/2017 11:44:32'!
divide
	"COHEN Algorithm 3.1.2 (Pseudo-Division)."
	| P m n d e lc s |
	divisor isZero ifTrue: [^ (ZeroDivide dividend: dividend) signal].
	P _ dividend parent.
	(m _ dividend degree) < (n _ divisor degree)
		ifTrue: [quotient _ P zero. remainder _ dividend. ^ self].
	d _ divisor leadingCoefficient.
	remainder _ dividend.
	quotient _ P zero.
	e _ m - n + 1.
	[remainder degree < n
		ifTrue: [| q | q _ d ^ e. quotient _ quotient * q. remainder _ remainder * q. ^ self].
	lc _ remainder leadingCoefficient.
	m _ remainder degree.
	s _ P coefficient: lc degree: remainder degree - n.
	quotient _ quotient * d + s.
	remainder _ remainder * d - (divisor * s).
	e _ e - 1] repeat! !

!PolynomialPseudoDivision methodsFor: 'private' stamp: 'len 7/4/2016 04:37'!
verify
	| a b |
	a _ dividend * (divisor leadingCoefficient ^ self delta).
	b _ self quotient * divisor + self remainder.
	^ a = b! !

!PolynomialPseudoDivision methodsFor: 'initialization' stamp: 'len 12/11/2015 06:56'!
divide: aPolynomial by: anotherPolynomial
	dividend _ aPolynomial.
	divisor _ anotherPolynomial! !

!PolynomialPseudoDivision class methodsFor: 'instance creation' stamp: 'len 12/11/2015 06:57'!
divide: aPolynomial by: anotherPolynomial
	"Answer a pseudo-division algorithm to divide aPolynomial by anotherPolynomial."
	^ self new divide: aPolynomial by: anotherPolynomial! !

!RealRootIsolator methodsFor: 'private' stamp: 'len 4/29/2018 18:29:17'!
bigBounds
	"Compute and answer a first estimate of an interval containing all the real roots."
	| bound |
	bound _ polynomial norm1 / polynomial leadingCoefficient asFloat.
	bound _ bound max: 1.0.
	^ RealInterval closed: bound negated closed: bound! !

!RealRootIsolator methodsFor: 'private' stamp: 'len 4/24/2018 17:59:04'!
computeFourier
	"Compute the Budan-Fourier sequence for the polynomial of the receiver."
	| f |
	f _ polynomial.
	fourier _ (OrderedCollection new: f degree + 1) add: f; yourself.
	f degree timesRepeat: [fourier add: (f _ f derivative)]! !

!RealRootIsolator methodsFor: 'private' stamp: 'len 4/24/2018 17:59:08'!
computeSturm
	"Compute a sturmian sequence for the receiver."
	| f g r |
	f _ polynomial.
	g _ f derivative.
	sturm _ (OrderedCollection new: f degree + 1) add: f; add: g; yourself.
	[g degree > 0]
		whileTrue:
			[r _ sturm add: (f \\ g) negated.
			f _ g.
			g _ r]! !

!RealRootIsolator methodsFor: 'private' stamp: 'len 4/24/2018 17:59:00'!
heuristicDetectOneRootBetween: leftBound and: rightBound
	| first |
	first _ polynomial value: leftBound.
	2 to: 10 do: [:each|
		first ~= (polynomial value: (rightBound - leftBound) / each) sign
			ifTrue: [^ true]].
	^ false! !

!RealRootIsolator methodsFor: 'accessing' stamp: 'len 11/18/97 00:38'!
fourier
	"Answer the Budan-Fourier sequence for the polynomial of the receiver."

	fourier isNil ifTrue: [self computeFourier].
	^ fourier! !

!RealRootIsolator methodsFor: 'accessing' stamp: 'len 4/24/2018 18:20:19'!
polynomial
	^ polynomial! !

!RealRootIsolator methodsFor: 'accessing' stamp: 'len 6/5/2016 04:47'!
roots
	"Answer a collection with the roots of the polynomial."
	roots isNil ifTrue: [self separateRoots].
	^ roots! !

!RealRootIsolator methodsFor: 'accessing' stamp: 'len 8/23/97 18:10'!
sturm
	"Answer a sturm sequence for the polynomial of the receiver."

	sturm isNil ifTrue: [self computeSturm].
	^ sturm! !

!RealRootIsolator methodsFor: 'couting roots' stamp: 'len 4/24/2018 17:59:22'!
lowerBoundNumberOfRootsBetween: leftBound and: rightBound
	"Answer a lower bound for the number of real roots in the open interval (leftBound, rightBound)."
	| answer last sign |
	answer _ 0.
	last _ 0.
	1 to: polynomial degree * 2 do: [:each|
		sign _ (polynomial value: (rightBound - leftBound) / each) sign.
		(last ~= sign and: [sign ~= 0]) ifTrue: [answer _ answer + 1].
		last _ sign].
	^ answer! !

!RealRootIsolator methodsFor: 'couting roots' stamp: 'len 1/16/2016 08:33'!
moreThanOneRootBetween: leftBound and: rightBound
	"Answer true if there are only one root in the interval (leftBound, rightBound]."

	| upper lower |
	sturm isNil "if the Sturm chain was not yet computed, first try some bounds and heuristics"
		ifTrue:
			[(upper _ self upperBoundNumberOfRootsBetween: leftBound and: rightBound) < 2
				ifTrue: [^ false].
			(upper even and: [self heuristicDetectOneRootBetween: leftBound and: rightBound])
				ifTrue: [^ true].
			lower _ self lowerBoundNumberOfRootsBetween: leftBound and: rightBound.
			lower > 1 ifTrue: [^ true].
			(upper even and: [lower > 0]) ifTrue: [^ true]].

	^ (self numberOfRootsBetween: leftBound and: rightBound) > 1! !

!RealRootIsolator methodsFor: 'couting roots' stamp: 'len 4/24/2018 17:59:16'!
numberOfNegativeRoots
	"Answer the number of negative roots."
	| fix |
	fix _ (polynomial value: 0) = 0 ifTrue: [1] ifFalse: [0].
	^ (self numberOfRootsBetween: self bigBounds min and: 0) - fix! !

!RealRootIsolator methodsFor: 'couting roots' stamp: 'len 1/15/2016 02:41'!
numberOfPositiveRoots
	"Answer the number of positive roots."
	^ self numberOfRootsBetween: 0 and: self bigBounds max! !

!RealRootIsolator methodsFor: 'couting roots' stamp: 'len 1/15/2016 02:41'!
numberOfRoots
	"Answer the number of real roots of the receiver."

	| interval |
	interval _ self bigBounds.
	^ self numberOfRootsBetween: interval min and: interval max! !

!RealRootIsolator methodsFor: 'couting roots' stamp: 'len 1/16/2016 08:03'!
numberOfRootsBetween: leftBound and: rightBound
	"Answer the number of real roots in the left open interval (leftBound, rightBound]."

	| leftSignChanges rightSignChanges a b |
	a _ leftBound asFraction.
	b _ rightBound asFraction.
	leftSignChanges _ 0.
	(self sturm collect: [ :each | (each value: a) sign])
		inject: 0 into: [ :lastSign :each |
			(lastSign ~= each and: [each ~= 0])
				ifTrue: [leftSignChanges _ leftSignChanges + 1].
			each].

	rightSignChanges _ 0.
	(self sturm collect: [ :each | (each value: b) sign])
		inject: 0 into: [ :lastSign :each |
			(lastSign ~= each and: [each ~= 0])
				ifTrue: [rightSignChanges _ rightSignChanges + 1].
			each].

	^ leftSignChanges - rightSignChanges! !

!RealRootIsolator methodsFor: 'couting roots' stamp: 'len 1/15/2016 02:42'!
upperBoundNumberOfRoots
	"Answer an upper bound for the number of real roots of the receiver."
	| interval |
	interval _ self bigBounds.
	^ self upperBoundNumberOfRootsBetween: interval min and: interval max! !

!RealRootIsolator methodsFor: 'couting roots' stamp: 'len 11/24/2015 06:10'!
upperBoundNumberOfRootsBetween: leftBound and: rightBound
	"Answer an upper bound for the number of real roots
	in the open interval (leftBound, rightBound)."

	| leftSignChanges rightSignChanges |

	leftSignChanges _ 0.
	(self fourier collect: [ :each | (each value: leftBound) sign])
		inject: 0 into: [ :lastSign :each |
			(lastSign ~= each and: [each ~= 0])
				ifTrue: [leftSignChanges _ leftSignChanges + 1].
			each].

	rightSignChanges _ 0.
	(self fourier collect: [ :each | (each value: rightBound) sign])
		inject: 0 into: [ :lastSign :each |
			(lastSign ~= each and: [each ~= 0])
				ifTrue: [rightSignChanges _ rightSignChanges + 1].
			each].

	^ leftSignChanges - rightSignChanges! !

!RealRootIsolator methodsFor: 'initialization' stamp: 'len 4/24/2018 18:02:05'!
polynomial: aPolynomial
	polynomial _ aPolynomial! !

!RealRootIsolator methodsFor: 'operations' stamp: 'len 4/29/2018 18:27:49'!
separateRoots
	"Separate the roots in intervals each of them including an isolated root."

	| bounds |
	roots _ SortedCollection sortBlock: [ :one :other | one left <= other left].
	bounds _ self bigBounds.
	self separateRootsBetween: bounds min and: bounds max! !

!RealRootIsolator methodsFor: 'operations' stamp: 'len 4/29/2018 18:28:56'!
separateRootsBetween: leftBound and: rightBound
	"Separate the roots in the real interval given by the arguments."
	| r mid |
	r _ self numberOfRootsBetween: leftBound and: rightBound.
	r = 0 ifTrue: [^ self].
	r = 1 ifTrue: [^ roots add: (RealInterval closed: leftBound closed: rightBound)].

	mid _ leftBound + rightBound / 2.0. "2 for exact rationals or 2.0 to use floats."
	self separateRootsBetween: leftBound and: mid.
	self separateRootsBetween: mid and: rightBound! !

!RealRootIsolator class methodsFor: 'instance creation' stamp: 'len 4/24/2018 18:01:20'!
on: aPolynomial
	^ self new polynomial: aPolynomial! !

!BerlekampMassey methodsFor: 'as yet unclassified' stamp: 'len 3/22/2016 23:58'!
run
	| F Fx x C L N m B d b s |
	x _ Fx x.
	C _ Fx one.
	L _ 0. "current number of errors"
	N _ 100. "total number of syndromes"
	B _ C.
	b _ F one. "copy of the last discrepancy d"
	m _ 1. "number of iterations since last update"
	0 to: N do: [:n|
		"calculate discrepancy:"
		d _ (s coefficientAtDegree: n) + ((1 to: L) sum: [:i| (C coefficientAtDegree: i) * (s coefficientAtDegree: n-i)]).
		d = 0
			ifTrue: [m _ m + 1]
			ifFalse: [2*L <= n
				ifTrue:
					[|t|
					t _ C.
					C _ C - ((x^m)*(d/b)*B).
					B _ t.
					L _ n + 1 - L.
					b _ d.
					m _ 1]
				ifFalse:
					[C _ C - ((x^m)*(d/b)*B).
					m _ m + 1]]].
	^ L! !

!CRT methodsFor: 'initialization' stamp: 'len 4/18/2018 06:23:08'!
moduli: anArray
	| one k mj p euclid d |
	moduli _ anArray.
	"Precomputations:"
	one _ moduli first one.
	k _ moduli size.
	C _ Array new: k.
	C at: 1 put: one.
	2 to: k do: [:j|
		mj _ moduli at: j.
		p _ one. 1 to: j-1 do: [:i| p _ p * (moduli at: i) \\ mj].
		euclid _ ExtendedEuclid on: {p. mj}.
		d _ euclid gcd.
		d ~= one ifTrue: [^ self error: 'the moduli are not coprime'].
		euclid verify ifFalse: [self error: 'failed'].
		C at: j put: euclid bezout first]! !

!CRT methodsFor: 'computing' stamp: 'len 4/26/2018 08:16:09'!
solve: remainders
	| k mj y yj x |
	k _ moduli size.
	y _ Array new: k.
	y at: 1 put: (remainders at: 1) \\ (moduli at: 1).
	2 to: k do: [:j|
		mj _ moduli at: j.
		yj _ y at: j-1.
		j-2 to: 1 by: -1 do: [:i| yj _ yj * (moduli at: i) + (y at: i) \\ mj].
		yj _ ((remainders at: j) - yj) * (C at: j) \\ mj.
		y at: j put: yj].
	x _ y at: k.
	k-1 to: 1 by: -1 do: [:i| x _ x * (moduli at: i) + (y at: i)].
	"it would be more correct to return the residue class mod m1*m2*..*mk"
	^ x! !

!CRT class methodsFor: 'instance creation' stamp: 'len 2/23/2016 22:44'!
mod: anArray
	^ self new moduli: anArray! !

!CRT class methodsFor: 'instance creation' stamp: 'len 4/26/2018 20:56:04'!
solve: aCollection
	| x m |
	x _ aCollection first.
	m _ x modulus.
	aCollection allButFirstDo: [:each| | xi mi bezout |
		xi _ each.
		mi _ xi modulus.
		bezout _ (ExtendedEuclid on: {m. mi}) bezout.
		x _ bezout first * m * xi representative + (bezout second * mi * x representative).
		m _ m*mi.
		x _ x % m].
	^ x! !

!DFT methodsFor: 'as yet unclassified' stamp: 'len 5/12/2016 08:20'!
value: aTuple
	^ ring tuple: n evaluating: [:k| (1 to: n) sum: [:j| (aTuple at: j) * (alpha ^ (j*k))]]! !

!ExtendedEuclid methodsFor: 'accessing' stamp: 'len 4/18/2018 06:26:17'!
bezout
	"Answer a tuple of Bezout coefficients for the receiver."
	bezout isNil ifTrue: [self run].
	^ bezout! !

!ExtendedEuclid methodsFor: 'accessing' stamp: 'len 12/23/2015 19:49'!
gcd
	gcd isNil ifTrue: [self run].
	^ gcd! !

!ExtendedEuclid methodsFor: 'accessing-private' stamp: 'len 12/23/2015 20:09'!
elements: anArray
	elements _ anArray! !

!ExtendedEuclid methodsFor: 'private' stamp: 'len 4/18/2018 06:24:55'!
run
	| a b zero one s1 t1 s t r1 r |
	self assert: elements size = 2.
	a _ elements first. b _ elements second.
	zero _ a zero. one _ a one.
	s1 _ zero. s _ one.
	t1 _ one. t _ zero.
	a isInteger
		ifTrue: [r1 _ a abs. r _ b abs]
		ifFalse: [r1 _ a. r _ b].
	[r1 isZero]
		whileFalse:
			[ | q temp |
			q _ r // r1.
			temp _ r1. r1 _ r - (q * r1). r _ temp.
			temp _ s1. s1 _ s - (q * s1). s _ temp.
			temp _ t1. t1 _ t - (q * t1). t _ temp].
	gcd _ r.
	a isInteger ifTrue: [s _ s * b sign. t _ t * a sign].
	(gcd isKindOf: Polynomial) "make the gcd monic, otherwise it's not unique"
		ifTrue:
			[| lc |
			lc _ gcd leadingCoefficient.
			s _ s / lc.
			t _ t / lc.
			gcd _ gcd / gcd leadingCoefficient].
	bezout _ {t. s}! !

!ExtendedEuclid methodsFor: 'private' stamp: 'len 4/18/2018 06:23:25'!
verify
	^ (elements * self bezout) sum = self gcd! !

!ExtendedEuclid methodsFor: 'private' stamp: 'len 4/18/2018 06:23:35'!
verify2
	| a b d u v |
	a _ elements at: 1.
	b _ elements at: 2.
	u _ self bezout at: 1.
	v _ self bezout at: 2.
	d _ self gcd.
	(a abs negated / d < (v * b sign) and: [v * b sign <= 0])
		ifFalse: [^ false].
	b = 0 ifTrue: [^ true].
	(1 <= (u * a sign) and: [u * a sign <= (b abs / d)])
		ifFalse: [^ false].
	^ true! !

!ExtendedEuclid methodsFor: 'private' stamp: 'len 4/18/2018 06:23:44'!
verifyMinimal
	| a b d u v |
	(elements allSatisfy: [:each| each isInteger]) ifFalse: [^ true].
	a _ elements first.
	b _ elements second.
	d _ self gcd.
	u _ self bezout first.
	v _ self bezout last.
	a abs / d negated < (v * b sign) ifFalse: [^ false].
	v * b sign <= 0 ifFalse: [^ false].
	1 <= (u * a sign) ifFalse: [^ false].
	u * a sign <= (b abs / d) ifFalse: [^ false].
	^ true! !

!ExtendedEuclid class methodsFor: 'instance creation' stamp: 'len 12/23/2015 20:09'!
on: anArray
	^ self new elements: anArray! !

!LagrangeGaussReduction methodsFor: 'as yet unclassified' stamp: 'len 12/12/2015 21:55'!
computeShortVector
	| innerProduct a b A B t T n r |
	innerProduct _ vectorSpace innerProduct. "Euclidean inner product"

	"Initialization:"
	a _ v1. b _ v2.
	A _ innerProduct value: {a. a}.
	B _ innerProduct value: {b. b}.
	A < B ifTrue: [b _ v1. a _ v2. t _ A. A _ B. B _ t].
	
	["Euclidean step:"
	n _ innerProduct value: {a. b}.
	r _ (n/B) rounded. "nearest integer"
	T _ A - (2*r*n) + (r*r*B).
	T >= B]
		whileFalse:
			[t _ a - (r*b).
			a _ b.
			b _ t.
			A _ B.
			B _ T].
	
	shortVector _ b! !

!LagrangeGaussReduction methodsFor: 'as yet unclassified' stamp: 'len 12/12/2015 21:55'!
shortVector
	shortVector isNil ifTrue: [self computeShortVector].
	^ shortVector! !

!ModifiedBerlekampMassey methodsFor: 'accessing' stamp: 'len 11/29/2015 16:02'!
field: aField
	field _ aField! !

!ModifiedBerlekampMassey methodsFor: 'accessing' stamp: 'len 12/27/2015 05:01'!
input: anArray
	input _ anArray.
	minimalPolynomial _ nil! !

!ModifiedBerlekampMassey methodsFor: 'accessing' stamp: 'len 12/27/2015 04:59'!
minimalPolynomial
	minimalPolynomial isNil ifTrue: [self run].
	^ minimalPolynomial! !

!ModifiedBerlekampMassey methodsFor: 'private' stamp: 'len 4/24/2018 19:38:22'!
run
	"Modified Berlekamp-Massey from 'The Berlekamp-Massey Algorithm revisited', Nadie Ben Atti, Gema M Diaz-Toca, Henri Lombardi."
	| Fx x R0 R1 V V0 V1 n m |
	n _ input size // 2.
	m _ 2*n - 1.
	Fx _ field polynomials.
	x _ Fx x.
	R0 _ x^(2*n). R1 _ (0 to: m) sum: [:i| x^i*(input at: m-i+1)].
	V0 _ Fx zero. V1 _ Fx one.
	[n <= R1 degree]
		whileTrue:
			[ | division |
			division _ R0 divisionBy: R1.
			V _ V0 - (division quotient * V1).
			V0 _ V1. V1 _ V. R0 _ R1. R1 _ division remainder].
	minimalPolynomial _ V1 / V1 leadingCoefficient! !

!NTT methodsFor: 'accessing' stamp: 'len 4/25/2016 00:28'!
modulus
	^ modulus! !

!NTT methodsFor: 'accessing' stamp: 'len 3/23/2016 21:06'!
primitive
	^ primitive! !

!NTT methodsFor: 'initialization' stamp: 'len 4/25/2016 00:29'!
modulus: anInteger
	self modulus: anInteger primitive: anInteger primitiveRoot! !

!NTT methodsFor: 'initialization' stamp: 'len 4/25/2016 00:29'!
modulus: anInteger primitive: anotherInteger
	modulus _ anInteger.
	primitive _ anotherInteger! !

!NTT methodsFor: 'running' stamp: 'len 5/13/2019 16:17:03'!
inverseValue: input
	"naive algorithm, O(n^2)"
	^ (1 to: input size) collect: [:i| ((1 to: input size) sum: [:j| (primitive negated raisedTo: i*j modulo: modulus) * (input at: j) \\ modulus]) \\ modulus]! !

!NTT methodsFor: 'running' stamp: 'len 5/13/2019 16:17:08'!
value: input
	"naive algorithm, O(n^2)"
	^ (1 to: input size) collect: [:i| ((1 to: input size) sum: [:j| (primitive raisedTo: i*j modulo: modulus) * (input at: j) \\ modulus]) \\ modulus]! !

!NTT class methodsFor: 'instance creation' stamp: 'len 4/25/2016 00:30'!
modulo: anInteger
	"anInteger must be prime"
	^ self new modulus: anInteger! !

!TonelliShanks methodsFor: 'as yet unclassified' stamp: 'len 12/29/2016 08:22:11'!
modulus: anInteger
	| n |
	anInteger == 2 ifTrue: [self error: 'the modulus should be not 2'].
	p _ anInteger.
	e _ (p - 1) lowBit - 1.
	q _ p - 1 bitShift: e negated.
	"find generator of the multiplicative group of units (Z/pZ)*"
	[n _ (p - 1) atRandom.
	(n kronecker: p) == -1] whileFalse.
	z _ n raisedTo: q modulo: p.! !

!TonelliShanks methodsFor: 'as yet unclassified' stamp: 'len 3/6/2017 17:04:50'!
squareRootOf: anInteger
	| a y r x b m b2 t |
	anInteger == 0 ifTrue: [^ anInteger].
	a _ anInteger.
	y _ z. r _ e. x _ a raisedTo: q-1 // 2 modulo: p. b _ a*x squared \\ p. x _ a*x \\ p.
	[b == 1 ifTrue: [^ x].
	b2 _ b. m _ 1. [(b2 _ b2 squared \\ p) == 1] whileFalse: [m _ m + 1].
	(b raisedTo: (2 ^ m) modulo: p) == 1 ifFalse: [self halt].
	(m > 1 and: [(b raisedTo: (2 ^ (m-1)) modulo: p) == 1]) ifTrue: [self halt].
	m = r ifTrue: [^ nil]. "the input is not a quadratic residue modulo p"
	t _ y. r - m - 1 timesRepeat: [t _ t squared \\ p]. "t _ y ^ (2 ^ (r - m - 1)) mod p"
	y _ t squared \\ p. r _ m. x _ x * t \\ p. b _ b * y \\ p] repeat! !

!DirichletSeries methodsFor: 'arithmetic' stamp: 'len 12/28/2015 19:28'!
* anObject
	(self scalars includes: anObject)
		ifTrue: [^ self class coefficients: coefficients * anObject].
	(anObject isKindOf: self class)
		ifTrue: [^ self class coefficients: (coefficients dirichlet: anObject coefficients)].
	^ DomainError signal! !

!DirichletSeries methodsFor: 'arithmetic' stamp: 'len 12/28/2015 19:29'!
+ anObject
	^ self class coefficients: coefficients + anObject coefficients! !

!DirichletSeries methodsFor: 'arithmetic' stamp: 'len 12/28/2015 19:29'!
- anObject
	^ self + anObject negated! !

!DirichletSeries methodsFor: 'arithmetic' stamp: 'len 12/28/2015 19:30'!
/ anObject
	^ self * anObject reciprocal! !

!DirichletSeries methodsFor: 'arithmetic' stamp: 'len 12/28/2015 19:30'!
negated
	^ self class coefficients: coefficients negated! !

!DirichletSeries methodsFor: 'arithmetic' stamp: 'len 12/28/2015 19:30'!
squared
	^ self * self! !

!DirichletSeries methodsFor: 'comparing' stamp: 'len 12/28/2015 19:46'!
= anObject
	^ (anObject isKindOf: DirichletSeries) and: [self coefficients = anObject coefficients]! !

!DirichletSeries methodsFor: 'comparing' stamp: 'len 12/28/2015 19:46'!
hash
	^ coefficients hash! !

!DirichletSeries methodsFor: 'accessing' stamp: 'len 12/28/2015 19:26'!
coefficients
	^ coefficients! !

!DirichletSeries methodsFor: 'accessing' stamp: 'len 12/28/2015 19:26'!
coefficients: aSequence
	coefficients _ aSequence! !

!DirichletSeries methodsFor: 'accessing' stamp: 'len 12/28/2015 19:26'!
indeterminate
	^ 1! !

!DirichletSeries methodsFor: 'accessing' stamp: 'len 12/28/2015 19:26'!
scalars
	^ coefficients codomain! !

!DirichletSeries methodsFor: 'operations' stamp: 'len 6/4/2019 05:32:07'!
value: aNumber upTo: n
	| answer |
	answer _ aNumber zero.
	1 to: n do: [:i|
		| c |
		c _ coefficients at: i.
		answer _ answer + (c / (i ^ aNumber))].
	^ answer! !

!DirichletSeries class methodsFor: 'instance creation' stamp: 'len 12/28/2015 19:54'!
coefficients: aSequence
	^ self new coefficients: aSequence! !

!DirichletSeries class methodsFor: 'examples' stamp: 'len 10/31/2016 04:14'!
zeta
	^ self coefficients: (CFiniteSequence constant: 1)! !

!GraphNode methodsFor: 'comparing' stamp: 'timestamp) (no'!
= anObject
	"Comparison is delegated to the value of the node.
	Argument and receiver are reversed to dereference through other GraphNodes."
	^anObject = value! !

!GraphNode methodsFor: 'comparing' stamp: 'timestamp) (no'!
hash
	^value hash! !

!GraphNode methodsFor: 'statistics' stamp: 'len 5/7/2016 04:09'!
clusteringCoefficient
	| links k |
	links _ Set new.
	self neighborsDo: [:n1 |
		self neighborsDo: [:n2 |
			(n1 ~= n2 and: [n1 hasEdgeTo: n2])
				ifTrue: [links add: {n1 value. n2 value}]]].
	k _ self neighbors size.
	^ links size / (k * (k - 1))! !

!GraphNode methodsFor: 'accessing edges' stamp: 'timestamp) (no'!
degree
	"How many edges does this node have?"
	self subclassResponsibility! !

!GraphNode methodsFor: 'accessing edges' stamp: 'len 5/7/2016 04:14'!
neighbors
	"Return a collection of nodes connected to outgoing edges."
	self subclassResponsibility! !

!GraphNode methodsFor: 'accessing edges' stamp: 'timestamp) (no'!
neighborsAndLabelsDo: aBlock
	"Evaluate aBlock for each node connected to an outgoing edge, and the label on that edge (nil if no label)."
	"The default definition assumes no labels are present."
	self neighborsDo: [ :n | aBlock value: n value: nil]! !

!GraphNode methodsFor: 'accessing edges' stamp: 'timestamp) (no'!
neighborsDo: aBlock
	"Evaluate aBlock for each node connected to an outgoing edge."
	self subclassResponsibility! !

!GraphNode methodsFor: 'testing edges' stamp: 'timestamp) (no'!
hasEdgeTo: anObject
	"Is there an edge from this node to anObject?"
	self subclassResponsibility! !

!GraphNode methodsFor: 'testing edges' stamp: 'len 2/26/2016 20:20'!
hasLoop
	^ self hasEdgeTo: self! !

!GraphNode methodsFor: 'testing edges' stamp: 'timestamp) (no'!
isLeaf
	^self degree = 0! !

!GraphNode methodsFor: 'testing edges' stamp: 'len 2/16/2016 03:39'!
isReflexive
	^ self hasEdgeTo: self! !

!GraphNode methodsFor: 'testing edges' stamp: 'len 5/7/2016 04:09'!
isSimple
	^ self neighbors asSet size = self neighbors size and: [self hasLoop not]! !

!GraphNode methodsFor: 'testing edges' stamp: 'len 2/16/2016 03:40'!
isSymmetric
	self neighborsDo: [:each| (each hasEdgeTo: self) ifFalse: [^ false]].
	^ true! !

!GraphNode methodsFor: 'testing edges' stamp: 'len 2/17/2016 03:37'!
isTransitive
	self neighborsDo: [:each|
		each neighborsDo: [:other| (other hasEdgeTo: self) ifFalse: [^ false]]].
	^ true! !

!GraphNode methodsFor: 'enumerating' stamp: 'len 11/30/2016 14:43:32'!
markDo: aBlock
	"Visit each node in the graph once, applying aBlock.
	A node is only visited after at least one of its predecessors, but not necessarily after all the predecessors."
	| todo visited |
	todo _ Set with: self.
	visited _ Set new.
	[todo isEmpty] whileFalse:
		[| node |
		node _ todo anyOne.
		visited add: node.
		aBlock value: node.
		node neighborsDo:
			[ :child |
				(visited includes: child)
					ifFalse: [todo add: child]].
		todo remove: node]! !

!GraphNode methodsFor: 'enumerating' stamp: 'len 2/14/2003 20:05'!
walkPre: preBlock post: postBlock
	"Recursively walk the subtree rooted at me.  Apply preBlock to each node, then walk the subtree below node, then apply postBlock to the node."
	preBlock value: self.
	self neighborsDo: [ :child | child walkPre: preBlock post: postBlock].
	postBlock value: self! !

!GraphNode methodsFor: 'operations' stamp: 'len 7/20/2016 08:48'!
span
	"Answer the spanning tree of the receiver."
	| tree |
	tree _ RootedDigraph ordered.
	tree roots: (Set with: self).
	self markDo: [:each| tree add: each].
	^ tree! !

!GraphNode methodsFor: 'accessing value' stamp: 'timestamp) (no'!
value
	^value! !

!GraphNode methodsFor: 'accessing value' stamp: 'len 2/14/2016 22:31'!
value: anObject
	value _ anObject! !

!ExplicitGraphNode methodsFor: 'private' stamp: 'len 2/26/2016 22:44'!
addInNeighborNoCheck: aNode
	^ inNeighbors add: aNode! !

!ExplicitGraphNode methodsFor: 'private' stamp: 'len 2/28/2016 17:02'!
setInNeighbors: aCollection
	inNeighbors _ aCollection! !

!ExplicitGraphNode methodsFor: 'private' stamp: 'len 2/28/2016 17:02'!
setNeighbors: aCollection
	outNeighbors _ aCollection! !

!ExplicitGraphNode methodsFor: 'changing edges' stamp: 'len 5/9/2016 17:10'!
addNeighbor: aNode 
	outNeighbors add: aNode.
	aNode addInNeighborNoCheck: self.
	^ aNode
"	self flag: #fix.
	(outNeighbors includes: aNode)
		ifFalse: 
			[outNeighbors add: aNode.
			aNode addInNeighborNoCheck: self].
	^aNode"! !

!ExplicitGraphNode methodsFor: 'changing edges' stamp: 'len 5/7/2016 04:19'!
addNeighbor: aNode at: index 
	"pre: self isOrdered"
	outNeighbors at: index put: aNode.
	aNode addInNeighborNoCheck: self.
	^aNode! !

!ExplicitGraphNode methodsFor: 'changing edges' stamp: 'len 2/26/2016 22:46'!
removeInNeighbor: aNode 
	^ inNeighbors remove: aNode ifAbsent: [aNode]! !

!ExplicitGraphNode methodsFor: 'changing edges' stamp: 'len 2/26/2016 22:54'!
removeNeighbor: aNode
	aNode removeInNeighbor: self.
	^outNeighbors remove: aNode! !

!ExplicitGraphNode methodsFor: 'copying' stamp: 'len 2/28/2016 17:02'!
copy
	^ super copy setNeighbors: outNeighbors copy; setInNeighbors: inNeighbors copy! !

!ExplicitGraphNode methodsFor: 'accessing edges' stamp: 'len 5/7/2016 04:03'!
degree
	"If I am in my neighborhood, don't count the loop edge"

	^ (outNeighbors includes: self) 
		ifTrue: [outNeighbors size - 1]
		ifFalse: [outNeighbors size]! !

!ExplicitGraphNode methodsFor: 'accessing edges' stamp: 'timestamp) (no'!
inDegree
	"If I am in my neighborhood, don't count the loop edge"
	(inNeighbors includes: self)
		ifTrue: [^ inNeighbors size - 1]
		ifFalse: [^ inNeighbors size]
! !

!ExplicitGraphNode methodsFor: 'accessing edges' stamp: 'Samir Saidani 9/25/2003 14:14'!
inNeighbors
	^inNeighbors! !

!ExplicitGraphNode methodsFor: 'accessing edges' stamp: 'len 5/7/2016 04:07'!
neighbors
	^outNeighbors! !

!ExplicitGraphNode methodsFor: 'accessing edges' stamp: 'len 5/7/2016 04:07'!
neighborsDo: aBlock 
	outNeighbors do: aBlock! !

!ExplicitGraphNode methodsFor: 'accessing edges' stamp: 'len 2/15/2016 01:54'!
strictInNeighbors
	(inNeighbors includes: self) ifTrue: [^ inNeighbors copyWithout: self].
	^ inNeighbors! !

!ExplicitGraphNode methodsFor: 'accessing edges' stamp: 'len 5/7/2016 04:15'!
strictNeighbors
	(outNeighbors includes: self) ifTrue: [^ outNeighbors copyWithout: self].
	^ outNeighbors! !

!ExplicitGraphNode methodsFor: 'testing edges' stamp: 'timestamp) (no'!
hasEdgeTo: anObject 
	^outNeighbors includes: anObject! !

!ExplicitGraphNode methodsFor: 'initialize' stamp: 'len 7/14/2016 00:12'!
initializeFixed: arity 
	outNeighbors _ Array new: arity.
	inNeighbors _ Bag new! !

!ExplicitGraphNode methodsFor: 'initialize' stamp: 'len 7/14/2016 00:12'!
initializeOrdered
	outNeighbors _ OrderedCollection new.
	inNeighbors _ Bag new! !

!ExplicitGraphNode methodsFor: 'initialize' stamp: 'len 7/14/2016 00:12'!
initializeUnordered
	outNeighbors _ Bag new.
	inNeighbors _ Bag new! !

!ExplicitGraphNode methodsFor: 'testing' stamp: 'sam 2/9/2004 15:30'!
isAnExtremity
	^ self isFinal | self isInitial | self isExtremal! !

!ExplicitGraphNode methodsFor: 'testing' stamp: 'len 5/7/2016 04:06'!
isExtremal
	"o<-->..."
	^ self degree = 1 and: [self inNeighbors asSet = self neighbors asSet]! !

!ExplicitGraphNode methodsFor: 'testing' stamp: 'len 5/7/2016 04:04'!
isFinal
" o<--..."
	^ self inDegree = 1 and: [self degree = 0]! !

!ExplicitGraphNode methodsFor: 'testing' stamp: 'len 5/7/2016 04:05'!
isInitial
	"o-->..."
	^ self inDegree = 0 and: [self degree = 1]! !

!ExplicitGraphNode methodsFor: 'testing' stamp: 'len 5/10/2019 04:36:13'!
isMiddle
	"..--o--..."
	^ (self inDegree + self degree between: 2 and: 4)
		and: [(self inNeighbors \/ self neighbors) size = 2]! !

!ExplicitGraphNode methodsFor: 'testing' stamp: 'timestamp) (no'!
isOrdered
	^outNeighbors isSequenceable! !

!ExplicitGraphNode class methodsFor: 'instance creation' stamp: 'timestamp) (no'!
arity: n
	"Create a new ordered node with fixed arity n."
	^super new initializeFixed: n! !

!ExplicitGraphNode class methodsFor: 'instance creation' stamp: 'timestamp) (no'!
binary
	"Create a new binary node."
	^super new initializeFixed: 2! !

!ExplicitGraphNode class methodsFor: 'instance creation' stamp: 'len 2/12/2003 21:40'!
binary: value
	"Create a new binary node, and given value."
	^super new initializeFixed: 2; value: value! !

!ExplicitGraphNode class methodsFor: 'instance creation' stamp: 'timestamp) (no'!
new
	"Create a new unordered node."
	^super new initializeUnordered! !

!ExplicitGraphNode class methodsFor: 'instance creation' stamp: 'len 2/12/2003 21:40'!
newOn: value
	"Create a new unordered node, and given value."
	^super new initializeUnordered; value: value! !

!ExplicitGraphNode class methodsFor: 'instance creation' stamp: 'len 2/12/2003 21:40'!
on: value arity: n
	"Create a new ordered node with fixed arity n, and given value."
	^super new initializeFixed: n; value: value! !

!ExplicitGraphNode class methodsFor: 'instance creation' stamp: 'timestamp) (no'!
ordered
	"Create a new ordered node."
	^super new initializeOrdered! !

!ExplicitGraphNode class methodsFor: 'instance creation' stamp: 'len 2/12/2003 21:40'!
ordered: value
	"Create a new ordered node, and given value."
	^super new initializeOrdered; value: value! !

!LabeledExplicitGraphNode methodsFor: 'comparing' stamp: 'len 7/25/2016 08:25'!
= anObject
	anObject class = self class ifTrue: [^ value = anObject value and: [label = anObject label]].
	^ super = anObject! !

!LabeledExplicitGraphNode methodsFor: 'changing edges' stamp: 'timestamp) (no'!
addNeighbor: aNode
	self shouldNotImplement! !

!LabeledExplicitGraphNode methodsFor: 'changing edges' stamp: 'timestamp) (no'!
addNeighbor: aNode at: index
	self shouldNotImplement! !

!LabeledExplicitGraphNode methodsFor: 'changing edges' stamp: 'len 2/15/2016 06:02'!
addNeighbor: aNode at: index label: label
	"pre: self isOrdered"
	outNeighbors at: index put: aNode -> label.
	^ aNode! !

!LabeledExplicitGraphNode methodsFor: 'changing edges' stamp: 'len 5/7/2016 04:21'!
addNeighbor: aNode label: label
	self flag: #fix.
	(outNeighbors includes: aNode) "inefficient"
		ifFalse: 
			[outNeighbors add: aNode -> label.
			aNode addInNeighborNoCheck: self].
	^aNode! !

!LabeledExplicitGraphNode methodsFor: 'changing edges' stamp: 'timestamp) (no'!
removeNeighbor: aNode 
	outNeighbors remove: (outNeighbors detect: [:assoc | assoc key = aNode])! !

!LabeledExplicitGraphNode methodsFor: 'testing edges' stamp: 'timestamp) (no'!
hasEdgeTo: anObject 
	^outNeighbors anySatisfy: [:assoc | assoc key = anObject]! !

!LabeledExplicitGraphNode methodsFor: 'accessing' stamp: 'len 2/19/2016 18:49'!
label
	^ label! !

!LabeledExplicitGraphNode methodsFor: 'accessing' stamp: 'len 2/19/2016 18:49'!
label: anObject
	label _ anObject! !

!LabeledExplicitGraphNode methodsFor: 'accessing edges' stamp: 'timestamp) (no'!
labelOfEdgeTo: anObject 
	"Return the label associated with the edge to anObject; otherwise signal an error."

	^(outNeighbors detect: [:assoc | assoc key = anObject]) value! !

!LabeledExplicitGraphNode methodsFor: 'accessing edges' stamp: 'timestamp) (no'!
labelOfEdgeTo: anObject ifNone: aBlock 
	"Return the label associated with the edge to anObject; return the value of the block is no such edge exists."

	^(outNeighbors detect: [:assoc | assoc key = anObject]
		ifNone: [^aBlock value]) value! !

!LabeledExplicitGraphNode methodsFor: 'accessing edges' stamp: 'len 5/7/2016 04:11'!
neighbors
	^outNeighbors collect: [:assoc | assoc key]! !

!LabeledExplicitGraphNode methodsFor: 'accessing edges' stamp: 'timestamp) (no'!
neighborsAndLabelsDo: aBlock 
	"Evaluate aBlock for each node connected to an outgoing edge, and the label on that edge (nil if no label)."

	^outNeighbors do: [:assoc | aBlock value: assoc key value: assoc value]! !

!LabeledExplicitGraphNode methodsFor: 'accessing edges' stamp: 'timestamp) (no'!
neighborsDo: aBlock 
	^outNeighbors do: [:assoc | aBlock value: assoc key]! !

!ImplicitGraphNode methodsFor: 'accessing edges' stamp: 'len 5/7/2016 04:09'!
neighbors
	^OrderedCollection accumulate: [:incBlock | self neighborsDo: incBlock]! !

!ImplicitGraphNode methodsFor: 'accessing edges' stamp: 'len 5/7/2016 04:09'!
neighborsDo: aBlock 
	self neighbors do: aBlock! !

!ImplicitGraphNode class methodsFor: 'instance creation' stamp: 'len 4/1/2018 15:37:55'!
on: aValue collectionBlock: aBlock
	^ImplicitCollectionGraphNode on: aValue collectionBlock: aBlock! !

!ImplicitGraphNode class methodsFor: 'instance creation' stamp: 'len 4/1/2018 15:37:09'!
on: aValue iterator: anIterator
	^ImplicitIteratorGraphNode on: aValue iterator: anIterator! !

!ImplicitGraphNode class methodsFor: 'instance creation' stamp: 'len 4/1/2018 15:37:19'!
on: aValue iteratorBlock: iteratorBlock
	^ImplicitIteratorGraphNode on: aValue iteratorBlock: iteratorBlock! !

!ImplicitCollectionGraphNode methodsFor: 'initialisation' stamp: 'len 2/28/2016 20:32'!
collectionBlock: aBlock
	collectionBlock _ aBlock! !

!ImplicitCollectionGraphNode methodsFor: 'accessing edges' stamp: 'len 5/7/2016 04:10'!
degree
	^self neighbors size! !

!ImplicitCollectionGraphNode methodsFor: 'accessing edges' stamp: 'len 5/7/2016 04:10'!
neighbors
	^collectionBlock value! !

!ImplicitCollectionGraphNode methodsFor: 'testing edges' stamp: 'len 5/7/2016 04:10'!
hasEdgeTo: anObject 
	^self neighbors includes: anObject! !

!ImplicitCollectionGraphNode class methodsFor: 'instance creation' stamp: 'len 2/15/2016 05:20'!
on: aValue collectionBlock: aBlock 
	^ self new value: aValue; collectionBlock: aBlock! !

!ImplicitIteratorGraphNode methodsFor: 'accessing edges' stamp: 'timestamp) (no'!
degree
	^iterator size! !

!ImplicitIteratorGraphNode methodsFor: 'accessing edges' stamp: 'timestamp) (no'!
neighborsDo: aBlock
	iterator do: aBlock! !

!ImplicitIteratorGraphNode methodsFor: 'testing edges' stamp: 'timestamp) (no'!
hasEdgeTo: anObject
	^iterator includes: anObject! !

!ImplicitIteratorGraphNode methodsFor: 'initialisation' stamp: 'len 2/28/2016 20:32'!
iterator: anIterator
	iterator _ anIterator! !

!ImplicitIteratorGraphNode class methodsFor: 'instance creation' stamp: 'timestamp) (no'!
on: aValue iterator: anIterator
	^(self new) value: aValue ; iterator: anIterator! !

!ImplicitIteratorGraphNode class methodsFor: 'instance creation' stamp: 'timestamp) (no'!
on: aValue iteratorBlock: iteratorBlock
	^self on: aValue iterator: (Iterator on: iteratorBlock)! !

!DAGFrontier methodsFor: 'accessing' stamp: 'timestamp) (no'!
frontier
	^frontier! !

!DAGFrontier methodsFor: 'initialization' stamp: 'timestamp) (no'!
frontier: f bag: remaining
	frontier := f.
	bag := remaining! !

!DAGFrontier methodsFor: 'advancing' stamp: 'len 6/24/2016 17:11'!
remove: frontierObject
	frontier remove: frontierObject.
	frontierObject neighborsDo:
		[ :neighbor |
			(bag remove: neighbor) = 0
				ifTrue: [frontier add: neighbor]].
	^frontierObject! !

!DAGFrontier methodsFor: 'advancing' stamp: 'timestamp) (no'!
removeAll: collection
	collection do: [ :n | self remove: n]! !

!DAGFrontier class methodsFor: 'instance creation' stamp: 'len 2/17/2016 01:20'!
on: rootedGraph
	"Create a frontier object to enumerate the graph."
	| remaining frontier |
	"Build a Bag of non-root nodes, each node once in the Bag for every predecessor."
	frontier _ rootedGraph rootNodes asOrderedCollection.
	remaining _ Bag new.
	rootedGraph nodesDo: [:node| node neighborsDo: [:n| remaining add: n]].
	^ self new frontier: frontier bag: remaining! !

!Dijkstra methodsFor: 'accessing' stamp: 'len 2/15/2016 06:47'!
distanceTo: anObject
	^ distance at: anObject! !

!Dijkstra methodsFor: 'accessing' stamp: 'len 2/13/2003 21:56'!
eccentricity
	"Answer the eccentricity of the source vertex.
	The eccentricity of a vertex is the length of the longest minimal path from that vertex to some vertex in the graph. You can think of the eccentricity of a vertex as the longest distance in the graph from there to somewhere."

	^ distance max! !

!Dijkstra methodsFor: 'accessing' stamp: 'len 2/26/2016 23:18'!
shortestPathTo: anObject
	| answer node predecessorNode |
	anObject = source ifTrue: [^ #()].
	answer _ OrderedCollection new.
	node _ graph nodeAt: anObject.
	[answer add: node value.
	predecessorNode _ predecessor at: node.
	predecessorNode = source]
		whileFalse: [node _ predecessorNode].
	^ answer reversed! !

!Dijkstra methodsFor: 'initialization' stamp: 'len 2/15/2003 18:52'!
graph: aGraph source: aNode
	graph _ aGraph.
	source _ aNode.
	self run! !

!Dijkstra methodsFor: 'private' stamp: 'len 11/30/2016 14:45:52'!
run
	| queue u estimate |
	predecessor _ Dictionary new.
	distance _ Dictionary new.
	graph nodesDo: [:each |
		distance at: each put: Float infinity.
		predecessor at: each put: nil].
	distance at: source put: 0.
	queue _ Heap sortBlock: [:a :b| (distance at: a) <= (distance at: b)].
	queue addAll: graph.
	[queue isEmpty]
		whileFalse:
			[u _ queue removeFirst.
			(graph nodeAt: u) neighborsAndLabelsDo: [:each :weight|
				estimate _ (distance at: u) + 1 "(weight ifNil: [1])".
				(distance at: each) > estimate
					ifTrue: [distance at: each put: estimate.
					predecessor at: each put: u]]]! !

!Dijkstra class methodsFor: 'instance creation' stamp: 'len 2/14/2016 22:38'!
graph: aGraph source: aNode
	^ self new graph: aGraph source: aNode! !

!FloydWarshall methodsFor: 'accessing' stamp: 'len 2/17/2016 07:24'!
diameter
	^ distances max! !

!FloydWarshall methodsFor: 'accessing' stamp: 'len 2/17/2016 07:21'!
distanceFrom: source to: target
	^ distances at: {source. target}! !

!FloydWarshall methodsFor: 'accessing' stamp: 'len 2/17/2016 07:24'!
radius
	^ distances min! !

!FloydWarshall methodsFor: 'initialization' stamp: 'len 2/17/2016 07:04'!
graph: aGraph
	graph _ aGraph.
	self run! !

!FloydWarshall methodsFor: 'private' stamp: 'len 2/17/2016 07:18'!
run
	distances _ Dictionary new.
	graph nodesDo: [:x| distances at: {x.x} put: 0].
	graph edgesAndLabelsDo: [:each :label|
		distances at: {each key. each value} put: (label ifNil: [1])].
	graph nodesDo: [:k|
		graph nodesDo: [:i|
			graph nodesDo: [:j|
				| d |
				(d _ (distances at: {i.k}) + (distances at: {k.j})) > (distances at: {i.j})
				 	ifTrue: [distances at: {i.j} put: d]]]]! !

!FloydWarshall class methodsFor: 'instance creation' stamp: 'len 2/17/2016 07:22'!
graph: aGraph
	^ self new graph: aGraph! !

!YoungDiagram methodsFor: 'as yet unclassified' stamp: 'len 2/21/2017 18:40:23'!
conjugate
	"Answer the Young diagram of the conjugate partition."
	^ self class shape: ((1 to: shape size) collect: [:k| shape findLast: [:i| i >= k]])! !

!YoungDiagram methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 03:17'!
hookLengthAt: aPoint
	| answer |
	answer _ (shape at: aPoint x) - aPoint y. "boxes to the right"
	aPoint x + 1 to: shape size do: [:i|
		(shape at: i) >= aPoint y
			ifFalse: [^ answer].
		answer _ answer + 1].
	^ answer! !

!YoungDiagram methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 03:12'!
shape
	^ shape! !

!YoungDiagram methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 03:12'!
shape: aPartition
	shape _ aPartition! !

!YoungDiagram class methodsFor: 'instance creation' stamp: 'len 8/1/2016 03:13'!
shape: aPartition
	^ self new shape: aPartition! !

!WeierstrassEquation methodsFor: 'invariants' stamp: 'len 11/9/2016 07:08'!
a1
	^ coefficients at: 1! !

!WeierstrassEquation methodsFor: 'invariants' stamp: 'len 11/9/2016 07:08'!
a2
	^ coefficients at: 2! !

!WeierstrassEquation methodsFor: 'invariants' stamp: 'len 11/9/2016 07:08'!
a3
	^ coefficients at: 3! !

!WeierstrassEquation methodsFor: 'invariants' stamp: 'len 11/9/2016 07:08'!
a4
	^ coefficients at: 4! !

!WeierstrassEquation methodsFor: 'invariants' stamp: 'len 11/9/2016 07:08'!
a6
	^ coefficients at: 5! !

!WeierstrassEquation methodsFor: 'invariants' stamp: 'len 11/11/2016 10:16'!
b2
	^ self a1 squared + (self a2 * 4) "NOTE: this is wrong in Silverman 'The Arithmetic Of Elliptic Curves'"! !

!WeierstrassEquation methodsFor: 'invariants' stamp: 'len 11/9/2016 07:23'!
b4
	^ self a4 * 2 + (self a1 * self a3)! !

!WeierstrassEquation methodsFor: 'invariants' stamp: 'len 11/9/2016 07:23'!
b6
	^ self a3 squared + (self a6 * 4)! !

!WeierstrassEquation methodsFor: 'invariants' stamp: 'len 11/9/2016 07:24'!
b8
	^ self a1 squared * self a6 + (self a2 * self a6 * 4) - (self a1 * self a3 * self a4) + (self a2 * self a3 squared) - self a4 squared! !

!WeierstrassEquation methodsFor: 'invariants' stamp: 'len 11/9/2016 07:25'!
c4
	^ self b2 squared - (self b4 * 24)! !

!WeierstrassEquation methodsFor: 'invariants' stamp: 'len 11/9/2016 07:26'!
c6
	^ (self b2 ^ 3) negated + (self b2 * self b4 * 36) - (self b6 * 216)! !

!WeierstrassEquation methodsFor: 'invariants' stamp: 'len 11/9/2016 07:27'!
discriminant
	^ (self b2 squared * self b8) negated - (self b4 ^ 3 * 8) - (self b6 squared * 27) + (self b2 * self b4 * self b6 * 9)! !

!WeierstrassEquation methodsFor: 'invariants' stamp: 'len 11/9/2016 07:28'!
j
	^ self c4 ^ 3 / self discriminant! !

!WeierstrassEquation methodsFor: 'accessing-private' stamp: 'len 11/9/2016 07:08'!
coefficients: aTuple
	coefficients _ aTuple! !

!WeierstrassEquation methodsFor: 'accessing' stamp: 'len 11/9/2016 13:01'!
curve
	^ EllipticCurve equation: self! !

!WeierstrassEquation methodsFor: 'accessing' stamp: 'len 5/23/2018 22:35:52'!
homogeneousPolynomial
	^ (self scalars polynomialsIn: #(x y z)) !! self polynomial homogenizedIn: 3! !

!WeierstrassEquation methodsFor: 'accessing' stamp: 'len 5/22/2018 22:41:13'!
polynomial
	^ (self scalars polynomialsIn: #(x y)) !! [:x :y|
			y^2 + (x*y * self a1) + (y * self a3) - (x^3) - (x^2 * self a2) - (x * self a4) - self a6]! !

!WeierstrassEquation methodsFor: 'accessing' stamp: 'len 11/9/2016 07:16'!
scalars
	^ coefficients scalars! !

!WeierstrassEquation methodsFor: 'converting' stamp: 'len 1/20/2017 09:36:51'!
over: aRing
	^ self class coefficients: (coefficients over: aRing)! !

!WeierstrassEquation class methodsFor: 'instance creation' stamp: 'len 11/9/2016 07:08'!
coefficients: aTuple
	^ self new coefficients: aTuple! !

!ModularSymbol methodsFor: 'as yet unclassified' stamp: 'len 12/21/2016 20:48:11'!
apply: aMorphism
	^ self class alpha: (aMorphism value: alpha) beta: (aMorphism value: beta)! !

!FareySymbol methodsFor: 'as yet unclassified' stamp: 'len 12/19/2016 22:32:21'!
cusps
	^ self notYetImplemented! !

!FareySymbol methodsFor: 'as yet unclassified' stamp: 'len 12/20/2016 20:42:22'!
denominatorAt: i
	i == 0 ifTrue: [^ 0].
	i == (fractions size + 1) ifTrue: [^ 0].
	^ (fractions at: i) denominator! !

!FareySymbol methodsFor: 'as yet unclassified' stamp: 'len 12/20/2016 21:21:44'!
e2
	"Answer the number of inequivalent order-2 elliptic points."
	^ pairings count: [:each| each == #even]! !

!FareySymbol methodsFor: 'as yet unclassified' stamp: 'len 12/20/2016 21:21:53'!
e3
	"Answer the number of inequivalent order-3 elliptic points."
	^ pairings count: [:each| each == #odd]! !

!FareySymbol methodsFor: 'as yet unclassified' stamp: 'len 12/20/2016 21:04:58'!
example
	group _ PrincipalCongruenceSubgroup new: 2.
	fractions _ {0. 1. 2}.
	pairings _ {1. 2. 2. 1}! !

!FareySymbol methodsFor: 'as yet unclassified' stamp: 'len 12/21/2016 16:09:10'!
generators
	^ (1 to: fractions size) collect: [:i| self pairingMapAt: i]! !

!FareySymbol methodsFor: 'as yet unclassified' stamp: 'len 12/20/2016 21:25:43'!
genus
	^ self rank - self numberOfCusps / 2! !

!FareySymbol methodsFor: 'as yet unclassified' stamp: 'len 12/20/2016 21:27:27'!
index
	"Answer the index of the group of the receiver as subgroup of the modular group."
	^ (self size - 1) * 3 + self e3! !

!FareySymbol methodsFor: 'as yet unclassified' stamp: 'len 12/20/2016 20:41:51'!
numeratorAt: i
	i == 0 ifTrue: [^ -1].
	i == (fractions size + 1) ifTrue: [^ 1].
	^ (fractions at: i) numerator! !

!FareySymbol methodsFor: 'as yet unclassified' stamp: 'len 12/20/2016 21:12:26'!
pairingAt: i
	"Answer the pairing between i-1 and i. Each pairing is either a positive integer (a free pairing), #even or #odd."
	^ pairings at: i! !

!FareySymbol methodsFor: 'as yet unclassified' stamp: 'len 3/6/2017 17:01:38'!
pairingMapAt: i
	| a b a1 b1 k ak bk ak1 bk1 |
	a _ self numeratorAt: i-1.
	b _ self denominatorAt: i-1.
	a1 _ self numeratorAt: i.
	b1 _ self denominatorAt: i.
	k _ self pairingAt: i.
	k == #even ifTrue: [^ ModularMap a: a1*b1 + (a*b) b: a*a negated - (a1*a1) c: b*b + (b1*b1) d: a1*b1 negated - (a*b)].
	k == #odd ifTrue: [^ ModularMap a: a1*b1 + (a*b1) + (a*b) b: a*a negated - (a*a1) - (a1*a1) c: b*b + (b*b1) + (b1*b1) d: a1*b1 negated - (a1*b) - (a*b)].
	ak _ self numeratorAt: k.
	bk _ self denominatorAt: k.
	ak1 _ self numeratorAt: k+1.
	bk1 _ self denominatorAt: k+1.
	^ ModularMap a: ak1*b1 + (ak*b) b: ak*ak negated - (ak1*a1) c: bk*b + (bk1*b1) d: a1*bk1 negated - (a*bk)! !

!FareySymbol methodsFor: 'as yet unclassified' stamp: 'len 12/20/2016 21:23:12'!
r
	"Answer the rank of the fundamental group of the uncompactified modular curve G\H, where G denotes de group of the receiver and H is the upper half plane."
	^ pairings count: [:each| each isInteger]! !

!FareySymbol methodsFor: 'as yet unclassified' stamp: 'len 12/20/2016 21:12:07'!
size
	^ fractions size! !

!AutomaticPalette methodsFor: 'as yet unclassified' stamp: 'len 12/18/2016 23:10:48'!
at: anObject
	| i n |
	i _ map at: anObject ifAbsentPut: [map size].
	n _ map size.
	^ Color h: i * 360.0 / (n + 1) + 90.0 \\ 360.0 s: 0.65 v: 0.95! !

!AutomaticPalette methodsFor: 'as yet unclassified' stamp: 'len 7/31/2016 04:44'!
initialize
	map _ Dictionary new! !

!ComplexPalette methodsFor: 'accessing' stamp: 'len 12/9/2016 16:39:28'!
at: aNumber
	aNumber isInfinite ifTrue: [^ infinityColor].
	aNumber isZero ifTrue: [^ zeroColor].
	^ self
		colorHue: ([hueBlock value: aNumber] on: Error do: [^ infinityColor])
		saturation: 1.0
		luminance: ([luminanceBlock value: aNumber] on: Error do: [^ infinityColor])! !

!ComplexPalette methodsFor: 'private' stamp: 'len 12/6/2016 16:43:01'!
colorHue: hue saturation: saturation luminance: luma
	| chroma x hf i r1 g1 b1 m | 

	chroma _ (1 - (2*luma - 1) abs) * saturation.
	hf _ hue \\ 360.
	i _ hf // 60.				"integer part of hue"
	x _ (hf \\ 60) / 60.0.	"fractional part of hue"
	x _ x \\ 2.
	i \\ 2 = 1 ifTrue: [ x _ 1.0 - x ].
	x _ chroma * x.

	0 = i ifTrue: [ r1 _ chroma. g1 _ x. b1 _ 0.0 ].
	1 = i ifTrue: [ r1 _ x. g1 _ chroma. b1 _ 0.0 ].
	2 = i ifTrue: [ r1 _ 0.0. g1 _ chroma. b1 _ x ].
	3 = i ifTrue: [ r1 _ 0.0. g1 _ x. b1 _ chroma ].
	4 = i ifTrue: [ r1 _ x. g1 _ 0.0. b1 _ chroma ].
	5 = i ifTrue: [ r1 _ chroma. g1 _ 0.0. b1 _ x ].

	m _ luma - (chroma / 2) "(0.299*r1) - (0.587*g1) - (0.114*b1)".
	r1 _ r1 + m min: 1.0 max: 0.0.
	g1 _ g1 + m min: 1.0 max: 0.0.
	b1 _ b1 + m min: 1.0 max: 0.0.
	^ Color r: r1 g: g1 b: b1! !

!ComplexPalette methodsFor: 'initialization' stamp: 'len 12/7/2016 22:25:44'!
setGrid: scalePoint
	hueBlock _ [:z| z arg radiansToDegrees \\ 360].
	luminanceBlock _ [:z| (z isZero ifTrue: [1.0] ifFalse: [(z arg / Float twoPi + 0.5 * scalePoint y + 0.999 \\ 1.0) * (z abs ln * scalePoint x \\ 1.0)]) * 0.4 + 0.2].
	zeroColor _ Color white.
	infinityColor _ Color black! !

!ComplexPalette methodsFor: 'initialization' stamp: 'len 12/7/2016 16:20:20'!
setLog
	hueBlock _ [:z| z arg radiansToDegrees \\ 360].
	luminanceBlock _ [:z| z isZero ifTrue: [1.0] ifFalse: [z abs min: 0.6 max: 0.0]].
	zeroColor _ Color white.
	infinityColor _ Color black! !

!ComplexPalette methodsFor: 'initialization' stamp: 'len 12/7/2016 22:15:26'!
setLogReversed
"	hueBlock _ [:z| (z arg + Float pi) radiansToDegrees \\ 360]."
	hueBlock _ [:z| z arg radiansToDegrees \\ 360].
	luminanceBlock _ [:z| z isZero ifTrue: [0.0] ifFalse: [1.0 - (z abs min: 0.6 max: 0.0)]].
	zeroColor _ Color black.
	infinityColor _ Color white! !

!ComplexPalette methodsFor: 'initialization' stamp: 'len 12/18/2016 11:01:21'!
setMagnitude
	hueBlock _ [:z| z arg radiansToDegrees \\ 360].
	luminanceBlock _ [:z| 2.0 ^ z abs negated].
	zeroColor _ Color white.
	infinityColor _ Color black! !

!ComplexPalette methodsFor: 'initialization' stamp: 'len 12/7/2016 21:53:50'!
setPhase
	hueBlock _ [:z| z arg radiansToDegrees \\ 360].
	luminanceBlock _ [:z| 0.5].
	zeroColor _ Color white.
	infinityColor _ Color black! !

!ComplexPalette methodsFor: 'initialization' stamp: 'len 12/7/2016 22:15:20'!
setReversed
	hueBlock _ [:z| z arg radiansToDegrees \\ 360].
"	hueBlock _ [:z| (z arg + Float pi) radiansToDegrees \\ 360]."
	luminanceBlock _ [:z| 1.0 - (2.0 ^ z abs negated)].
	zeroColor _ Color black.
	infinityColor _ Color white! !

!ComplexPalette methodsFor: 'initialization' stamp: 'len 12/7/2016 16:22:40'!
setScaled: scale
	hueBlock _ [:z| z arg radiansToDegrees \\ 360].
	luminanceBlock _ [:z| 2.0 ^ (z abs * scale negated)].
	zeroColor _ Color white.
	infinityColor _ Color black! !

!ComplexPalette class methodsFor: 'as yet unclassified' stamp: 'len 12/18/2016 11:00:55'!
default
	^ self phase! !

!ComplexPalette class methodsFor: 'as yet unclassified' stamp: 'len 12/7/2016 22:06:31'!
grid: scalePoint
	"This is a palette that colors each complex value z assigning a hue depending on its phase arg(z), and luminance depending on both phase and modulus |z|. The result is that of showing a grid of shadows over the Riemann sphere similar to a conformal grid mapping. The argument scalePoint determines the number of meridians and separation between parallels."
	^ self basicNew setGrid: scalePoint! !

!ComplexPalette class methodsFor: 'as yet unclassified' stamp: 'len 12/7/2016 16:18:14'!
log
	^ self basicNew setLog! !

!ComplexPalette class methodsFor: 'as yet unclassified' stamp: 'len 12/7/2016 22:11:32'!
logReversed
	^ self basicNew setLogReversed! !

!ComplexPalette class methodsFor: 'as yet unclassified' stamp: 'len 12/18/2016 11:00:45'!
magnitude
	^ self basicNew setMagnitude! !

!ComplexPalette class methodsFor: 'as yet unclassified' stamp: 'len 12/6/2016 16:51:43'!
new
	^ self default! !

!ComplexPalette class methodsFor: 'as yet unclassified' stamp: 'len 12/7/2016 21:59:06'!
phase
	"This is a palette that colors each complex value z assigning a hue depending only on its phase arg(z), and constant luminance. The modulus |z| is not depicted."
	^ self basicNew setPhase! !

!ComplexPalette class methodsFor: 'as yet unclassified' stamp: 'len 12/7/2016 22:11:44'!
reversed
	^ self basicNew setReversed! !

!ComplexPalette class methodsFor: 'as yet unclassified' stamp: 'len 12/7/2016 16:22:58'!
scaled: aNumber
	^ self basicNew setScaled: aNumber! !

!DiscretePalette methodsFor: 'as yet unclassified' stamp: 'len 2/18/2016 23:38'!
at: anObject
	^ map at: anObject ifAbsentPut: [self newColor]! !

!DiscretePalette methodsFor: 'as yet unclassified' stamp: 'len 2/18/2016 23:42'!
colors: anArray
	colors _ anArray.
	map _ Dictionary new! !

!DiscretePalette methodsFor: 'as yet unclassified' stamp: 'len 7/31/2016 04:32'!
newColor
	| a b answer |
	map size < colors size ifTrue: [^ colors at: map size + 1].
	[a _ colors atRandom.
	[b _ colors atRandom. a = b] whileTrue.
	answer _ a mixed: 0.5 with: b.
	colors includes: answer] whileTrue.
	^ answer! !

!DiscretePalette class methodsFor: 'as yet unclassified' stamp: 'len 2/18/2016 23:42'!
colors: anArray
	^ self new colors: anArray! !

!DiscretePalette class methodsFor: 'as yet unclassified' stamp: 'len 5/2/2016 07:36'!
default
	^ self colors: (#("brightGreen" periwinkle seaGreen hotPink lightYellow cyan lightPink lightOrange  "lightGreen" "lightRed"  "mustard" ) collect: [:each| Color exactColorNamed: each]) "shuffled"! !

!RealPalette methodsFor: 'as yet unclassified' stamp: 'len 8/17/2016 23:35'!
at: aNumber
	| v |
	v _ (aNumber max: min) min: max.
	^ colors at: (colors size - 1 * (v - min) / (max - min)) truncated + 1! !

!RealPalette methodsFor: 'as yet unclassified' stamp: 'len 2/26/2016 06:43'!
colors: anArray
	colors _ anArray! !

!RealPalette methodsFor: 'as yet unclassified' stamp: 'len 8/17/2016 23:33'!
max: aNumber
	max _ aNumber! !

!RealPalette methodsFor: 'as yet unclassified' stamp: 'len 8/17/2016 23:33'!
min: aNumber
	min _ aNumber! !

!RealPalette class methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:56'!
default
	| blue green red |
	red _ QQ polynomials interpolate: {"0 -> 0.0." 40 -> 0. 65 -> 0.8. "90 -> 0." 100 -> 0. 150 -> 0.5. 200 -> 0.9. 215 -> 1. 255 -> 0.95}.
	green _ QQ polynomials interpolate: {0 -> 0.2. 50 -> 0.48. 100 -> 0.68. 150 -> 0.75. 200 -> 0.70. 255 -> 1}.
	blue _ QQ polynomials interpolate: {0 -> 0.5. 35 -> 0.9. 85 -> 0.8. 115 -> 0.7. 150 -> 0.5. 200 -> 0.3. 255 -> 0}.
	^ self new colors: ((0 to: 255) collect: [:x| Color fromArray: ({x < 80 ifTrue: [0] ifFalse: [red value: x]. green value: x. blue value: x} collect: [:y| y abs min: 1.0])]); min: 0.0; max: 1.0! !

!RealPalette class methodsFor: 'as yet unclassified' stamp: 'len 8/18/2016 07:30'!
grayscale
	^ (self new: 100 interpolating: {Color darkGray darker. Color white}) min: 0.0; max: 1.0! !

!RealPalette class methodsFor: 'as yet unclassified' stamp: 'len 8/18/2016 07:21'!
new: anInteger interpolating: anArray
	^ self new colors: ((0 to: anInteger-1) collect: [:i|
			| mu |
			mu _ i * anArray size / (anInteger-1).
			(anArray atPin: mu floor + 1) mixed: mu - mu floor with: (anArray atPin: mu ceiling + 1)])! !

!AdicIntegerResidue methodsFor: 'as yet unclassified' stamp: 'len 6/1/2019 04:28:18'!
digits
	| x p answer |
	x _ representative representative.
	p _ self p.
	answer _ OrderedCollection new.
	[x = 0]
		whileFalse:
			[answer add: x \\ p.
			x _ x // p].
	^ answer
			! !

!AdicIntegerResidue methodsFor: 'as yet unclassified' stamp: 'len 6/1/2019 11:26:34'!
isZero
	^ representative isZero! !

!AdicIntegerResidue methodsFor: 'as yet unclassified' stamp: 'len 6/1/2019 11:23:23'!
precision
	^ representative parent exponent! !

!AdicIntegerResidue methodsFor: 'as yet unclassified' stamp: 'len 6/1/2019 10:46:36'!
reciprocal
	"Answer the multiplicative inverse of the receiver. The valuation of the receiver must be 0."
	self isUnit ifFalse: [(ZeroDivide dividend: self) signal].
	self notYetImplemented! !

!AdicIntegerResidue methodsFor: 'as yet unclassified' stamp: 'len 6/1/2019 04:31:39'!
representative: aModularInteger
	representative _ aModularInteger! !

!AdicIntegerResidue methodsFor: 'as yet unclassified' stamp: 'len 6/1/2019 16:24:15'!
valuation
	self isZero ifTrue: [^ Infinity positive].
	^ (self digits findFirst: [:one| one ~~ 0]) - 1! !

!AlgebraicExtensionAsModule methodsFor: 'basis' stamp: 'len 10/2/2018 16:48:38'!
basis
	^ self propertyAt: #basis ifAbsentPut: [(1 to: extension degree) collect: [:i| extension x ^ (i-1)]]! !

!AlgebraicExtensionAsModule methodsFor: 'basis' stamp: 'len 1/18/2018 19:33:08'!
coordinatesOf: anElement
	"why not just anElement representative coefficients? must complete with 0"
	^ self scalars tuple: self rank evaluating: [:i| anElement representative coefficientAtDegree: i-1]! !

!AlgebraicExtensionAsModule methodsFor: 'initialization' stamp: 'len 5/22/2018 00:51:46'!
extension: anAlgebraicExtension
	extension _ anAlgebraicExtension! !

!AlgebraicExtensionAsModule methodsFor: 'accessing' stamp: 'len 5/22/2018 00:52:33'!
scalars
	^ extension scalars! !

!AlgebraicExtensionAsModule methodsFor: 'elements' stamp: 'len 5/22/2018 00:52:38'!
zero
	^ extension zero! !

!AlgebraicExtensionAsModule class methodsFor: 'instance creation' stamp: 'len 5/22/2018 00:52:06'!
on: anAlgebraicExtension
	^ self new extension: anAlgebraicExtension! !

!GaussianElimination2 methodsFor: 'inquiries' stamp: 'len 11/5/2015 01:24'!
dependentColumns
	| independent |
	independent _ self independentColumns.
	^ (1 to: matrix numberOfColumns) reject: [:j | independent includes: j]! !

!GaussianElimination2 methodsFor: 'inquiries' stamp: 'len 4/5/2018 15:38:02'!
determinant
	matrix isSquare ifFalse: [^ nil].
	^ self rank = matrix height
		ifTrue: [determinant]
		ifFalse: [matrix scalars zero]! !

!GaussianElimination2 methodsFor: 'inquiries'!
independentColumns
	^ pivots collect: [:each | each y]! !

!GaussianElimination2 methodsFor: 'inquiries'!
leftInverse
	^ inverse! !

!GaussianElimination2 methodsFor: 'inquiries'!
rank
	^ pivots size! !

!GaussianElimination2 methodsFor: 'inquiries' stamp: 'len 12/26/2015 04:40'!
reduced
	^ matrix! !

!GaussianElimination2 methodsFor: 'inquiries' stamp: 'len 11/5/2015 00:12'!
rowIndexOfPivotAtColumn: j
	^ (pivots detect: [:one | one y = j]) x! !

!GaussianElimination2 methodsFor: 'accessing'!
extension
	^ extension! !

!GaussianElimination2 methodsFor: 'accessing'!
scalars
	^ matrix scalars! !

!GaussianElimination2 methodsFor: 'extension inquiries'!
extensionDependentColumns
	extension isNil ifTrue: [^ nil].
	^ subreducer dependentColumns! !

!GaussianElimination2 methodsFor: 'extension inquiries'!
extensionIndependentColumns
	extension isNil ifTrue: [^ nil].
	^ subreducer independentColumns! !

!GaussianElimination2 methodsFor: 'extension inquiries'!
extensionIsDependent
	^ self extensionDependentColumns isEmpty not
! !

!GaussianElimination2 methodsFor: 'extension inquiries' stamp: 'len 4/5/2018 15:38:26'!
subextension
	^ extension submatrix: self rowNumber + 1 by: 1 to: matrix height by: extension width! !

!GaussianElimination2 methodsFor: 'extension inquiries'!
subreducer
	^ subreducer! !

!GaussianElimination2 methodsFor: 'computing' stamp: 'len 11/5/2015 01:17'!
killColumn
	| piv |
	piv _ pivots last.
	1 to: piv x - 1 do: [:i | self killRow: i].
	piv x + 1 to: matrix numberOfRows do: [:i | self killRow: i]
! !

!GaussianElimination2 methodsFor: 'computing' stamp: 'len 5/30/2019 07:19:13'!
killRow: i
	| piv r coef pos  j a |
	piv _ pivots last.
	(coef _ (matrix at: i @ piv y) negated) isZero ifTrue: [^ self].
	r _ piv x.

	"Kill the element"
	matrix at: i @ piv y put: matrix scalars zero.

	"Repeat the computation on the row"
	pos _ columns position.
	[columns atEnd]
		whileFalse:
			[j _ columns next.
			a _ matrix at: i @ j.
			matrix at: i @ j put: (matrix at: r @ j) * coef + a].
	columns position: pos.

	"Do the same on the inverse"
	inverse addRow: r times: coef toRow: i.

	"Do the same on the extension, if any"
	extension notNil ifTrue: [extension addRow: r times: coef toRow: i]! !

!GaussianElimination2 methodsFor: 'computing'!
nextColumn
	^ columns atEnd ifFalse: [columns next]! !

!GaussianElimination2 methodsFor: 'computing' stamp: 'len 4/5/2018 15:38:07'!
nextPivot
	| col n r k |
	n _ matrix height.
	r _ self rowNumber + 1.
	[col _ self nextColumn ifNil: [^ nil].
	(k _ (r to: n)
		detect: [:i| (matrix at: i @ col) isZero not]
		ifNone: []) isNil] whileTrue.
	^ k @ col! !

!GaussianElimination2 methodsFor: 'computing' stamp: 'len 11/6/2015 06:18'!
normalize
	| piv factor coef index |
	matrix scalars isField ifFalse: [ ^ self ].
	piv _ pivots last.
	index _ piv x.
	coef _ matrix at: index @ piv y.
	coef = self scalars one ifTrue: [^ self].
	factor _ coef reciprocal.
	matrix multiplyRow: index by: factor.
	inverse multiplyRow: index by: factor.
	extension notNil ifTrue: [extension multiplyRow: index by: factor].
	determinant _ determinant * coef "or multiply by factor?!!!!!!"! !

!GaussianElimination2 methodsFor: 'computing' stamp: 'len 11/4/2015 23:59'!
rowNumber
	^ pivots isEmpty ifTrue: [0] ifFalse: [pivots last x]! !

!GaussianElimination2 methodsFor: 'computing' stamp: 'len 11/5/2015 05:20'!
swap: i
	| r |
	r _ self rowNumber.
	i = r ifTrue: [ ^ self ].
	matrix swapRow: i with: r.
	inverse swapRow: i with: r.
	extension notNil ifTrue: [extension swapRow: i with: r].
	determinant _ determinant negated! !

!GaussianElimination2 methodsFor: 'processing' stamp: 'len 12/26/2015 03:24'!
reduce
	| i piv |
	i _ 0.
	[(piv _ self nextPivot) isNil]
		whileFalse:
			[i _ i + 1.
			pivots add: i @ piv y.
			self
				swap: piv x;
				normalize;
				killColumn].
	extension notNil
		ifTrue:
			[subreducer _ self class on: self subextension].
"	matrix scalars isField
		ifFalse:
			[1 to: (matrix numberOfRows min: matrix numberOfColumns)
				do: [ :k | determinant _ determinant * (matrix at: k at: k) ]]"! !

!GaussianElimination2 methodsFor: 'initialization' stamp: 'len 11/12/2016 09:16'!
setMatrix: aMatrix extension: extMatrix
	aMatrix scalars isField ifFalse: [^ DomainError signal: 'scalars are not a field'].
	matrix _ aMatrix.
	extension _ (extMatrix isKindOf: Tuple)
		ifTrue: [matrix species columns: {extMatrix}]
		ifFalse: [extMatrix].
	columns _ ReadStream on: (1 to: aMatrix numberOfColumns) asArray.
	inverse _ aMatrix species identity.
	pivots _ OrderedCollection new.
	determinant _ aMatrix scalars one.
	self reduce! !

!GaussianElimination2 class methodsFor: 'examples'!
examples
	" MatrixReducer examples "

'

	vandermonde :=
			''1  1   1
			 3  5	7
			 9  25 49'' asMatrix.
	reducer _ MatrixReducer input: vandermonde copy.
	reducer reduce.
	reducer rank.
	reducer det.
	inverse _ reducer leftInverse.
	inverse * vandermonde.
	vandermonde scalars.
	vandermonde columnAmbient.

	extReducer _ MatrixReducer input: vandermonde copy extension: (1, -1, 17).
	extReducer reduce.
	extReducer extension.
	extReducer subextension.
	extReducer extensionDependentColumns.
	extReducer extensionIndependentColumns.
	extReducer extensionIsDependent.
	extReducer extension.
	coordinates _ extReducer extension column: 1.

	columns _ vandermonde columnIndexes
		inject: OrderedCollection new
		into: [:result :j | result add: (vandermonde column: j); yourself].
	basis _ LinearBasis generators: columns ambient: (vandermonde columnAmbient).
	basis coordinatesOf: (1, -1, 17)

' edit
			! !

!GaussianElimination2 class methodsFor: 'instance creation' stamp: 'len 11/5/2015 00:00'!
on: aMatrix
	^ self on: aMatrix extension: nil! !

!GaussianElimination2 class methodsFor: 'instance creation' stamp: 'len 11/5/2015 00:00'!
on: aMatrix extension: extMatrix
	^ self new setMatrix: aMatrix extension: extMatrix! !

!GramSchmidt methodsFor: 'accessing-private' stamp: 'len 12/13/2015 00:31'!
basis: aLinearBasis
	basis _ aLinearBasis! !

!GramSchmidt methodsFor: 'accessing-private' stamp: 'len 12/23/2015 05:09'!
innerProduct: aFunction
	innerProduct _ aFunction! !

!GramSchmidt methodsFor: 'accessing' stamp: 'len 12/23/2015 05:18'!
matrix
	"Answer the matrix computed by the orthogonalization process."
	matrix isNil ifTrue: [matrix _ basis changeTo: self orthogonalBasis].
	^ matrix! !

!GramSchmidt methodsFor: 'accessing' stamp: 'len 12/23/2015 05:18'!
orthogonalBasis
	"Answer the orthogonalized basis."
	orthogonalBasis isNil ifTrue: [self orthogonalize].
	^ orthogonalBasis! !

!GramSchmidt methodsFor: 'accessing' stamp: 'len 12/15/2017 20:52:14'!
orthonormalBasis
	^ LinearBasis on: basis ambient elements: (self orthogonalBasis collect: [:each| each / (innerProduct value: each value: each) squareRoot])! !

!GramSchmidt methodsFor: 'operations' stamp: 'len 12/13/2017 21:21:15'!
orthogonalize
	"Orthogonalize the basis."
	| orthogonalVectors u uv vv |
	orthogonalVectors _ OrderedCollection new.
	basis do: [:each|
		u _ each.
		orthogonalVectors do: [:v|
			uv _ innerProduct value: {u. v}.
			vv _ innerProduct value: {v. v}.
			u _ u - (v * uv / vv)].
		orthogonalVectors add: u].
	orthogonalBasis _ LinearBasis on: basis ambient elements: orthogonalVectors! !

!GramSchmidt class methodsFor: 'instance creation' stamp: 'len 5/23/2016 04:46'!
basis: aLinearBasis
	"Answer a new instance of the receiver to orthogonalize aLinearBasis."
	^ self basis: aLinearBasis innerProduct: aLinearBasis ambient innerProduct! !

!GramSchmidt class methodsFor: 'instance creation' stamp: 'len 12/13/2015 00:24'!
basis: aLinearBasis innerProduct: aFunction
	"Answer a new instance of the receiver to orthogonalize aLinearBasis with the inner product aFunction."
	^ self new basis: aLinearBasis; innerProduct: aFunction! !

!GramSchmidt class methodsFor: 'examples' stamp: 'len 12/12/2017 18:03:04'!
example
	"Compute an orthogonal basis for {(1,1,0); {0,1,1); (1,0,1)}."
	| V basis |
	V _ QQ ^ 3.
	basis _ LinearBasis on: V elements: {(1, 1, 0). (0, 1, 1). (1, 0, 1)}.
	^ (GramSchmidt basis: basis) orthogonalBasis! !

!JordanReduction methodsFor: 'as yet unclassified' stamp: 'len 11/12/2016 07:39'!
block: eigenvalue size: n
	| K one zero |
	K _ matrix scalars.
	one _ K one.
	zero _ K zero.
	^ K matrix: n@n evaluating: [:i :j| i=j ifTrue: [eigenvalue] ifFalse: [j-1=i ifTrue: [one] ifFalse: [zero]]]! !

!JordanReduction methodsFor: 'as yet unclassified' stamp: 'len 3/21/2016 09:13'!
blocks
	blocks isNil ifTrue: [self run].
	^ blocks! !

!JordanReduction methodsFor: 'as yet unclassified' stamp: 'len 3/21/2016 08:40'!
matrix: aMatrix
	matrix _ aMatrix! !

!JordanReduction methodsFor: 'as yet unclassified' stamp: 'len 4/5/2018 15:38:51'!
run
	| spectrum |
	spectrum _ matrix spectrum.
	spectrum size = matrix height ifFalse: [^ self error: 'the characteristic polynomial doesn''t split'].
"	I _ matrix species identity."
	blocks _ Bag new.
	spectrum asSet do: [:eigenvalue|
		| multiplicity dimensions X T count |
		multiplicity _ spectrum occurrencesOf: eigenvalue.
		dimensions _ OrderedCollection new.
		X _ matrix - (matrix scalars matrix: matrix dimension scalar: eigenvalue).
		T _ X.
		[(dimensions add: T nullity) < multiplicity] whileTrue: [T _ T * X].
		count _ 0.
		dimensions size to: 1 by: -1 do: [:i| | k |
			k _ (dimensions at: i) - (dimensions at: i-1 ifAbsent: [0]).
			blocks add: (self block: eigenvalue size: i) withOccurrences: k - count.
			count _ count + k]]! !

!LinearBasisTest methodsFor: 'as yet unclassified' stamp: 'len 4/23/2019 06:32:37'!
testLinearBasisChange
	| V B1 B2 C v |
	V _ QQ^3.
	B1 _ LinearBasis on: V elements: {(1,2,3). (1,1,1)}.
	B2 _ LinearBasis on: V elements: {(2,2,2). (2,3,4)}.
	C _ B1 changeTo: B2.
	v _ B1 elementAt: (3,7).
	self assert: C * (3,7) = (B2 coordinatesOf: v)! !

!LinearBasisTest methodsFor: 'as yet unclassified' stamp: 'len 4/23/2019 06:32:42'!
testLinearBasisCoordinatesOf
	| V basis c |
	V _ QQ ^ 3.
	basis _ LinearBasis on: V elements: {(-1,0,0). (0,0,2)}.
	c _ basis coordinatesOf: (1,0,4).
	self assert: c = (-1,2)! !

!LinearBasisTest methodsFor: 'as yet unclassified' stamp: 'len 4/23/2019 06:32:48'!
testLinearBasisCoordinatesOf2
	| V basis c |
	V _ QQ ^ 3.
	basis _ LinearBasis on: V elements: {(-1,0,0). (0,0,2)}.
	c _ basis coordinatesOf: (1,1,4).
	self assert: c isNil! !

!LinearBasisTest methodsFor: 'as yet unclassified' stamp: 'len 4/23/2019 06:32:54'!
testLinearBasisCoordinatesOf3
	| V B |
	V _ QQ^3.
	B _ LinearBasis on: V elements: {(1,1,1). (1,2,3)}.
	self assert: (B coordinatesOf: (1,1,1)) = (1,0).
	self assert: (B coordinatesOf: (1,2,3)) = (0,1).
	self assert: (B coordinatesOf: (0,1,2)) = (-1,1).
! !

!LinearBasisTest methodsFor: 'as yet unclassified' stamp: 'len 4/23/2019 06:32:59'!
testLinearBasisDual
	| V basis B Bdual I |
	V _ QQ ^ 3.
	basis _ LinearBasis on: V elements: {(-1,0,0). (0,1,2). (0,1,1)}.
	B _ basis matrix.
	Bdual _ basis dual matrix.
	I _ B identity.
	self assert: B determinant = (1 / Bdual determinant).
	self assert: B transposed * Bdual = I! !

!LinearBasisTest methodsFor: 'as yet unclassified' stamp: 'len 4/23/2019 06:33:05'!
testLinearBasisDual2
	| V B Bdual |
	V _ QQ ^ 3.
	B _ LinearBasis on: V elements: {(-1,0,0). (0,1,2). (0,1,1)}.
	Bdual _ B dual.
	self assert: B size = Bdual size.
	1 to: B size do: [:i|
		1 to: Bdual size do: [:j|
			self assert: ((Bdual at: j) value: (B at: i)) = (i = j ifTrue: [1] ifFalse: [0])]]! !

!LinearBasisTest methodsFor: 'as yet unclassified' stamp: 'len 4/23/2019 06:33:09'!
testLinearBasisGenerates
	| V B |
	V _ QQ^3.
	B _ LinearBasis on: V elements: {(1,1,1). (1,2,3)}.
	self assert: (B generates: (1,1,1)).
	self assert: (B generates: (0,1,2)).
	self deny: (B generates: (2,2,3))! !

!LinearBasisTest methodsFor: 'as yet unclassified' stamp: 'len 4/23/2019 06:35:02'!
testOrthogonalization
	| V B |
	V _ QQ ^ 3.
	B _ LinearBasis on: V elements: {(1, 1, 0). (1, 0, 0)}.
	self assert: B orthogonalized isOrthogonal.
	self assert: B extended orthogonalized isOrthogonal! !

!LinearBasisTest methodsFor: 'as yet unclassified' stamp: 'len 4/23/2019 06:35:07'!
testOrthonormalization
	| V B |
	V _ QQ ^ 3.
	B _ LinearBasis on: V elements: {(1, 1, 0). (1, 0, 0)}.
	self assert: B orthonormalized isOrthonormal.
	self assert: B extended orthonormalized isOrthonormal! !

!Maxel methodsFor: 'as yet unclassified' stamp: 'len 2/13/2016 17:55'!
* anInteger
	^ self notYetImplemented! !

!Maxel methodsFor: 'as yet unclassified' stamp: 'len 5/10/2019 04:36:28'!
+ aMaxel
	^ self class pixels: (pixels \/ aMaxel pixels)! !

!Maxel methodsFor: 'as yet unclassified' stamp: 'len 5/10/2019 04:28:20'!
/\ aMaxel
	^ self notYetImplemented! !

!Maxel methodsFor: 'as yet unclassified' stamp: 'len 5/10/2019 04:28:31'!
\/ aMaxel
	^ self notYetImplemented! !

!Maxel methodsFor: 'as yet unclassified' stamp: 'len 2/13/2016 17:46'!
extent
	^ Pixel row: (pixels max: [:each| each row]) column: (pixels max: [:each| each column])! !

!Maxel methodsFor: 'as yet unclassified' stamp: 'len 2/13/2016 17:51'!
isDiagonal
	^ pixels allSatisfy: [:each| each isDiagonal]! !

!Maxel methodsFor: 'as yet unclassified' stamp: 'len 2/13/2016 17:49'!
isEmpty
	^ self size = 0! !

!Maxel methodsFor: 'as yet unclassified' stamp: 'len 2/13/2016 17:47'!
isSymmetric
	^ self transposed = self! !

!Maxel methodsFor: 'as yet unclassified' stamp: 'len 2/13/2016 17:44'!
size
	^ pixels size! !

!Maxel methodsFor: 'as yet unclassified' stamp: 'len 2/13/2016 17:48'!
trasposed
	^ self class pixels: (pixels collect: [:each| each transposed])! !

!Maxel class methodsFor: 'as yet unclassified' stamp: 'len 2/13/2016 17:51'!
pixels: aCollection
	^ self new pixels: aCollection! !

!OEIS methodsFor: 'as yet unclassified' stamp: 'len 4/27/2016 07:02'!
initialize
	entries _ OrderedCollection new.
	'oeis.txt' asFileEntry readStream: [:aStream|
		[aStream atEnd]
			whileFalse:
				[| line |
				line _ aStream nextLine.
				line first = $#
					ifFalse:
						[| name tokens |
						tokens _ line findTokens: ','.
						name _ tokens first allButLast.
						entries add: name -> (tokens allButFirst collect: [:each| each asInteger]) asArray]]].
	entries _ entries asArray sort: [:a :b| a value size >= b value size]! !

!OEIS methodsFor: 'as yet unclassified' stamp: 'len 4/27/2016 07:02'!
longestEntrySize
	^ entries first value size! !

!OEIS methodsFor: 'as yet unclassified' stamp: 'len 4/20/2016 21:41'!
lookup2: anArray
	'oeis.txt' asFileEntry readStream: [:aStream|
		[aStream atEnd]
			whileFalse:
				[| line |
				line _ aStream nextLine.
				line first = $#
					ifFalse:
						[| name tokens |
						tokens _ line findTokens: ','.
						name _ tokens first allButLast.
						((1 to: (tokens size - 1 min: anArray size))
							allSatisfy: [:i| (tokens at: i+1) asInteger = (anArray at: i)])
								ifTrue: [^ name]]]].
		^ nil! !

!OEIS methodsFor: 'as yet unclassified' stamp: 'len 4/27/2016 07:04'!
lookup: anArray
	| array |
	array _ (anArray is: #Sequence) ifTrue: [anArray copyFrom: 1 to: self longestEntrySize] ifFalse: [anArray].
	entries do: [:each|
		each value size = 0 ifTrue: [^ nil].
		((1 to: (each value size min: array size))
			allSatisfy: [:i| (each value at: i) = (array at: i)])
				ifTrue: [^ each key]].			
	^ nil! !

!OEIS class methodsFor: 'as yet unclassified' stamp: 'len 4/25/2016 07:16'!
default
	^ Default ifNil: [Default _ self new]! !

!OrderAsModule methodsFor: 'basis' stamp: 'len 10/2/2018 16:57:14'!
basis
	^ order basis! !

!OrderAsModule methodsFor: 'basis' stamp: 'len 1/16/2017 07:45:46'!
coordinatesOf: anElement
	^ anElement representative coefficients! !

!OrderAsModule methodsFor: 'accessing' stamp: 'len 1/16/2017 07:44:58'!
order
	^ order! !

!OrderAsModule methodsFor: 'accessing' stamp: 'len 1/16/2017 07:45:49'!
scalars
	^ ZZ! !

!OrderAsModule methodsFor: 'accessing-private' stamp: 'len 1/16/2017 07:45:18'!
order: anOrder
	order _ anOrder! !

!OrderAsModule class methodsFor: 'instance creation' stamp: 'len 1/16/2017 07:50:04'!
on: anOrder
	^ self new order: anOrder! !

!Pixel methodsFor: 'as yet unclassified' stamp: 'len 2/13/2016 17:49'!
column
	^ column! !

!Pixel methodsFor: 'as yet unclassified' stamp: 'len 2/13/2016 17:48'!
column: anInteger
	column _ anInteger! !

!Pixel methodsFor: 'as yet unclassified' stamp: 'len 2/13/2016 17:47'!
isDiagonal
	^ row = column! !

!Pixel methodsFor: 'as yet unclassified' stamp: 'len 2/13/2016 17:48'!
row
	^ row! !

!Pixel methodsFor: 'as yet unclassified' stamp: 'len 2/13/2016 17:48'!
row: anInteger
	row _ anInteger! !

!Pixel methodsFor: 'as yet unclassified' stamp: 'len 2/13/2016 17:47'!
transpose
	^ self class row: column column: row! !

!Pixel class methodsFor: 'as yet unclassified' stamp: 'len 2/13/2016 17:50'!
row: anInteger column: anotherInteger
	^ self new row: anInteger; column: anotherInteger! !

!PolynomialInterpolator methodsFor: 'accessing' stamp: 'len 11/17/97 18:21'!
corrector
	"Answer the correction polynoial."

	^ corrector! !

!PolynomialInterpolator methodsFor: 'accessing' stamp: 'len 11/17/97 18:20'!
polynomial
	"Answer the interpolation polynoial."

	^ polynomial! !

!PolynomialInterpolator methodsFor: 'accessing-private' stamp: 'len 11/17/97 18:20'!
corrector: aPolynomial
	corrector _ aPolynomial! !

!PolynomialInterpolator methodsFor: 'accessing-private' stamp: 'len 11/17/97 18:20'!
polynomial: aPolynomial
	polynomial _ aPolynomial! !

!PolynomialInterpolator methodsFor: 'initialization' stamp: 'len 7/19/2016 01:03'!
initialize
	self flag: #fix.
	self polynomial: Polynomial null.
	self corrector: Polynomial identity! !

!PolynomialInterpolator methodsFor: 'operations' stamp: 'len 11/24/2015 06:16'!
map: aNumber to: anotherNumber
	"Change the interpolation polynomial to map aNumber to anotherNumber."

	| f q m |
	f _ self polynomial.
	q _ self corrector.
	m _ anotherNumber - (f value: aNumber) / (q value: aNumber).
	f _ q * m + f.
	q _ q * aNumber negated + (q shift: 1).
	self polynomial: f.
	self corrector: q.
	^ anotherNumber! !

!PolynomialInterpolator class methodsFor: 'instance creation' stamp: 'len 11/17/97 18:30'!
new
	^ super new initialize! !

!QRDecomposition methodsFor: 'as yet unclassified' stamp: 'len 3/21/2016 22:11'!
Q
	Q isNil ifTrue: [self run].
	^ Q! !

!QRDecomposition methodsFor: 'as yet unclassified' stamp: 'len 3/21/2016 22:11'!
R
	R isNil ifTrue: [self run].
	^ R! !

!QRDecomposition methodsFor: 'as yet unclassified' stamp: 'len 3/21/2016 22:06'!
matrix: aMatrix
	matrix _ aMatrix! !

!QRDecomposition methodsFor: 'as yet unclassified' stamp: 'len 4/5/2018 15:44:18'!
run
	| K n basis ortho |
	K _ matrix scalars "algebraicClosure".
	n _ matrix height.
	self flag: #fix. "we're assuming the columns are independent"
	basis _ LinearBasis on: K ^ n elements: matrix columns.
	ortho _ basis orthonormalized.
	Q _ Matrix columns: ortho.
"	zero _ K zero.
	R _ matrix species evaluating: [:i :j| i > j ifTrue: [zero] ifFalse: [(basis at: i) dotProduct: (ortho at: j)]]"
	R _ Q transposed * matrix! !

!QRDecomposition methodsFor: 'as yet unclassified' stamp: 'len 3/21/2016 22:15'!
verify
	^ matrix = (self Q * self R)! !

!Quaternion methodsFor: 'arithmetic' stamp: 'len 11/11/2015 05:29'!
* anObject
	| a0 a1 a2 a3 b0 b1 b2 b3 |
	(anObject isKindOf: Number)
		ifTrue: [^ self class a: a * anObject b: b * anObject c: c * anObject d: d * anObject].
	(anObject isKindOf: Quaternion)
		ifFalse: [^ anObject adaptToQuaternion: self andSend: #*].
	a0 _ self a. a1 _ self b. a2 _ self c. a3 _ self d.
	b0 _ anObject a. b1 _ anObject b. b2 _ anObject c. b3 _ anObject d.
	^ self class
		a: a0 * b0 - (a1 * b1) - (a2 * b2) - (a3 * b3)
		b: a0 * b1 + (a1 * b0) + (a2 * b3) - (a3 * b2)
		c: a0 * b2 + (a2 * b0) + (a3 * b1) - (a1 * b3)
		d: a0 * b3 + (a3 * b0) + (a1 * b2) - (a2 * b1)! !

!Quaternion methodsFor: 'arithmetic' stamp: 'len 11/11/2015 05:30'!
+ anObject
	(anObject isKindOf: Number)
		ifTrue: [^ self class a: a + anObject b: b c: c d: d].
	(anObject isKindOf: Quaternion)
		ifFalse: [^ anObject adaptToQuaternion: self andSend: #+].
	^ self class
		a: self a + anObject a
		b: self b + anObject b
		c: self c + anObject c
		d: self d + anObject d! !

!Quaternion methodsFor: 'arithmetic' stamp: 'len 11/11/2015 05:12'!
- anObject
	^ self + anObject negated! !

!Quaternion methodsFor: 'arithmetic' stamp: 'len 11/11/2015 05:12'!
/ anObject
	^ self * anObject reciprocal! !

!Quaternion methodsFor: 'arithmetic' stamp: 'len 1/22/2017 08:18:42'!
^ anInteger
	"Answer the receiver raised to the power anInteger."
	anInteger = 1 ifTrue: [^ self].
	anInteger = 0 ifTrue: [^ self one].
	anInteger < 0 ifTrue: [^ (self ^ anInteger negated) reciprocal].
	^ self squared ^ (anInteger // 2) * (self ^ (anInteger \\ 2))! !

!Quaternion methodsFor: 'arithmetic' stamp: 'len 5/6/2019 02:59:26'!
 anObject
	^ self * anObject! !

!Quaternion methodsFor: 'arithmetic' stamp: 'len 2/25/98 02:47'!
conjugated
	"Answer the conjugate of the receiver."

	^ self class
		a: self a
		b: self b negated
		c: self c negated
		d: self d negated! !

!Quaternion methodsFor: 'arithmetic' stamp: 'len 2/25/98 03:29'!
i
	"Answer the receiver multiplicated by i."

	^ self class a: self b negated b: self a c: self d d: self c negated! !

!Quaternion methodsFor: 'arithmetic' stamp: 'len 5/6/2019 02:59:39'!
inverse
	"Answer the multiplicative inverse of the receiver."

	^ self reciprocal! !

!Quaternion methodsFor: 'arithmetic' stamp: 'len 2/25/98 03:29'!
j
	"Answer the receiver multiplicated by j."

	^ self class a: self c negated b: self d negated c: self a d: self b! !

!Quaternion methodsFor: 'arithmetic' stamp: 'len 2/25/98 03:30'!
k
	"Answer the receiver multiplicated by k."

	^ self class a: self d negated b: self c c: self b negated d: self a! !

!Quaternion methodsFor: 'arithmetic' stamp: 'len 2/25/98 02:46'!
negated
	"Answer the additive inverse of the receiver."

	^ self class
		a: self a negated
		b: self b negated
		c: self c negated
		d: self d negated! !

!Quaternion methodsFor: 'arithmetic' stamp: 'len 2/25/98 02:58'!
reciprocal
	"Answer the multiplicative inverse of the receiver."

	^ self conjugated / self norm2! !

!Quaternion methodsFor: 'comparing' stamp: 'len 11/11/2015 05:31'!
= anObject
	anObject isNumber ifFalse: [^ false].
	(anObject isKindOf: Number)
		ifTrue: [^ a = anObject and: [b = 0 and: [c = 0 and: [d = 0]]]].
	(anObject isKindOf: Quaternion)
		ifFalse: [^ anObject adaptToQuaternion: self andSend: #=].
	^ self a = anObject a
		and: [self b = anObject b
			and: [self c = anObject c
				and: [self d = anObject d]]]! !

!Quaternion methodsFor: 'comparing' stamp: 'len 6/28/2016 09:27'!
hash
	^ ((a hash hashMultiply + b hash) hashMultiply + c hash) hashMultiply + d hash! !

!Quaternion methodsFor: 'accessing' stamp: 'len 2/25/98 02:43'!
a
	"Answer the 'a' component of the receiver."

	^ a! !

!Quaternion methodsFor: 'accessing' stamp: 'len 2/25/98 02:43'!
b
	"Answer the 'b' component of the receiver."

	^ b! !

!Quaternion methodsFor: 'accessing' stamp: 'len 2/25/98 02:43'!
c
	"Answer the 'c' component of the receiver."

	^ c! !

!Quaternion methodsFor: 'accessing' stamp: 'len 2/25/98 02:43'!
d
	"Answer the 'd' component of the receiver."

	^ d! !

!Quaternion methodsFor: 'accessing-private' stamp: 'len 2/25/98 02:41'!
a: aNumber b: bNumber c: cNumber d: dNumber
	a _ aNumber.
	b _ bNumber.
	c _ cNumber.
	d _ dNumber! !

!Quaternion methodsFor: 'converting' stamp: 'len 11/11/2015 04:55'!
adaptToNumber: rcvr andSend: selector
	"If I am involved in arithmetic with a Number, convert it to a Quaternion."
	^ (Quaternion a: rcvr b: 0 c: 0 d: 0) perform: selector with: self! !

!Quaternion methodsFor: 'converting' stamp: 'len 2/25/98 03:21'!
asQuaternion
	^ self! !

!Quaternion methodsFor: 'testing' stamp: 'len 2/25/98 03:05'!
isNumber
	^ true! !

!Quaternion methodsFor: 'testing' stamp: 'len 4/16/2016 19:18'!
isZero
	"Answer true if the receiver is null."
	^ self a isZero and: [self b isZero and: [self c isZero and: [self d isZero]]]! !

!Quaternion methodsFor: 'mathematical functions' stamp: 'len 2/25/98 02:59'!
norm2
	"Answer the square norm of the receiver."

	^ self a squared + self b squared + self c squared + self d squared! !

!Quaternion methodsFor: 'mathematical functions' stamp: 'len 11/11/2015 05:16'!
squared
	^ self * self! !

!Quaternion methodsFor: 'constants' stamp: 'len 11/19/2015 19:35'!
one
	| zero |
	zero _ a zero.
	^ self class a: a one b: zero c: zero d: zero! !

!Quaternion methodsFor: 'constants' stamp: 'len 11/19/2015 19:35'!
zero
	| zero |
	zero _ a zero.
	^ self class a: zero one b: zero c: zero d: zero! !

!Quaternion class methodsFor: 'instance creation' stamp: 'len 2/25/98 02:42'!
a: aNumber b: bNumber c: cNumber d: dNumber
	"Answer a new instance of the receiver with the given components."

	^ self new a: aNumber b: bNumber c: cNumber d: dNumber! !

!Quaternion class methodsFor: 'examples' stamp: 'len 5/3/98 00:19'!
i
	^ Quaternion a: 0 b: 1 c: 0 d: 0! !

!Quaternion class methodsFor: 'examples' stamp: 'len 5/3/98 00:20'!
j
	^ Quaternion a: 0 b: 0 c: 1 d: 0! !

!Quaternion class methodsFor: 'examples' stamp: 'len 5/3/98 00:20'!
k
	^ Quaternion a: 0 b: 0 c: 0 d: 1! !

!SLP methodsFor: 'as yet unclassified' stamp: 'len 7/26/2016 23:37'!
* aSLP
	^ self class word: (Word syllables: {word -> 1. aSLP word -> 1})! !

!SLP methodsFor: 'as yet unclassified' stamp: 'len 1/22/2017 08:20:37'!
^ anInteger
	anInteger = 0 ifTrue: [^ self class word: Word empty].
	anInteger = 1 ifTrue: [^ self].
	^ self class word: (Word x: word to: anInteger)! !

!SLP methodsFor: 'as yet unclassified' stamp: 'len 7/26/2016 22:59'!
reciprocal
	^ self class word: (Word x: word to: -1)! !

!SLP methodsFor: 'as yet unclassified' stamp: 'len 7/26/2016 23:33'!
value
	| answer |
	answer _ word value.
	[answer isKindOf: Word] whileTrue: [answer _ answer value].
	^ answer! !

!SLP methodsFor: 'as yet unclassified' stamp: 'len 7/26/2016 22:59'!
word
	^ word! !

!SLP methodsFor: 'as yet unclassified' stamp: 'len 7/26/2016 22:58'!
word: aWord
	word _ aWord! !

!SLP class methodsFor: 'as yet unclassified' stamp: 'len 7/26/2016 23:33'!
value: anObject
	^ self word: (Word x: anObject)! !

!SLP class methodsFor: 'as yet unclassified' stamp: 'len 7/26/2016 23:00'!
word: aWord
	^ self new word: aWord! !

!SturmChain methodsFor: 'as yet unclassified' stamp: 'len 11/3/2015 06:50'!
countSignChanges: signs
	| x count |
	x _ signs first.
	count _ 0.
	signs do: [ :each | each sign ~= x ifTrue: [ count _ count + 1 ]. x _ each sign ].
	^ count! !

!SturmChain methodsFor: 'as yet unclassified' stamp: 'len 11/3/2015 06:44'!
numberOfRealRoots
	^ self numberOfSignChangesAtMinusInfinity - self numberOfSignChangesAtInfinity! !

!SturmChain methodsFor: 'as yet unclassified' stamp: 'len 11/3/2015 06:51'!
numberOfSignChangesAt: aNumber
	^ self countSignChanges: (chain collect: [ :each | (each value: aNumber) sign])! !

!SturmChain methodsFor: 'as yet unclassified' stamp: 'len 11/3/2015 06:51'!
numberOfSignChangesAtInfinity
	^ self countSignChanges: (chain collect: [ :each | each leadingCoefficient sign ])! !

!SturmChain methodsFor: 'as yet unclassified' stamp: 'len 11/3/2015 06:51'!
numberOfSignChangesAtMinusInfinity
	^ self countSignChanges: (chain collect: [ :each | each leadingCoefficient sign * (each degree odd ifTrue: [-1] ifFalse: [1])])! !

!SturmChain methodsFor: 'as yet unclassified' stamp: 'len 11/3/2015 20:45'!
polynomial
	^ chain first! !

!SturmChain methodsFor: 'as yet unclassified' stamp: 'len 1/15/2016 06:27'!
polynomial: aPolynomial
	chain _ OrderedCollection with: aPolynomial with: aPolynomial derivative.
	[ chain last degree > 0 ] whileTrue: [ chain add: ((chain at: chain size - 1) \\ chain last) negated ]! !

!SturmChain class methodsFor: 'as yet unclassified' stamp: 'len 11/3/2015 06:46'!
on: aPolynomial
	^ self basicNew setPolynomial: aPolynomial! !

!Subdomain methodsFor: 'comparing' stamp: 'len 4/23/2019 08:32:58'!
< aSubdomain
	"Answer whether the receiver is properly included in the argument."

	^self subclassResponsibility! !

!Subdomain methodsFor: 'comparing' stamp: 'len 4/23/2019 08:32:46'!
<= aSubdomain
	"Answer whether the receiver is included in the argument."

	^ (self > aSubdomain) not! !

!Subdomain methodsFor: 'comparing' stamp: 'len 4/23/2019 08:35:40'!
= aSubdomain
	"Answer true if the receiver is the same subobject as the argument."

	^ self subclassResponsibility! !

!Subdomain methodsFor: 'comparing' stamp: 'len 4/23/2019 08:33:37'!
> aSubdomain
	"Answer whether the argument is properly included in the receiver."

	^ aSubdomain < self! !

!Subdomain methodsFor: 'comparing' stamp: 'len 4/23/2019 08:34:13'!
>= aSubdomain
	"Answer whether the argument is included in the receiver."

	^ aSubdomain <= self! !

!Subdomain methodsFor: 'comparing' stamp: 'len 4/23/2019 08:36:31'!
hash
	^ self ambient hash! !

!Subdomain methodsFor: 'morphisms' stamp: 'len 4/23/2019 04:50:18'!
=> aCodomain
	^ self asMorphism => aCodomain! !

!Subdomain methodsFor: 'morphisms' stamp: 'len 4/23/2019 04:50:11'!
hom: aCodomain
	^ self asMorphism hom: aCodomain! !

!Subdomain methodsFor: 'accessing' stamp: 'len 4/23/2019 04:50:40'!
ambient
	^ self asMorphism codomain! !

!Subdomain methodsFor: 'accessing' stamp: 'len 4/23/2019 04:50:56'!
generators
	^ self asDomain generators apply: self asMorphism! !

!Subdomain methodsFor: 'converting' stamp: 'len 4/23/2019 03:33:07'!
asDomain
	^ representative domain! !

!Subdomain methodsFor: 'converting' stamp: 'len 4/23/2019 03:32:56'!
asMorphism
	^ representative! !

!Subdomain methodsFor: 'testing' stamp: 'len 4/23/2019 04:49:14'!
isTrivial
	^ self asDomain isTrivial! !

!Subdomain class methodsFor: 'instance creation' stamp: 'len 4/23/2019 04:42:28'!
representative: aMorphism
	^ self new representative: aMorphism! !

!WuRittProcess methodsFor: 'as yet unclassified' stamp: 'len 12/30/2015 05:31'!
characteristicSet
	characteristicSet isNil ifTrue: [self run].
	^ characteristicSet! !

!WuRittProcess methodsFor: 'as yet unclassified' stamp: 'len 12/30/2015 05:30'!
polynomials: aCollection
	polynomials _ aCollection! !

!WuRittProcess methodsFor: 'as yet unclassified' stamp: 'len 5/10/2019 04:36:37'!
run
	| F G R F2 r |
	F _ polynomials.
	G _ Set new. R _ Set new.
	[F _ F \/ R. F2 _ R. R _ Set new.
	[F2 notEmpty] whileTrue: ["..."].
	F do: [:f| ((G includes: f) or: [(r _ G pseudoRemainderOf: f) isZero]) ifFalse: [R add: r]].
	R isEmpty] whileFalse.
	^ characteristicSet _ G! !

!CoxeterDiagram methodsFor: 'as yet unclassified' stamp: 'len 2/11/2016 22:11'!
gramMatrix
	^ matrix collect: [:x| -2 * (Float pi / x) cos]! !

!CoxeterDiagram methodsFor: 'as yet unclassified' stamp: 'len 2/11/2016 22:14'!
isConnected
	^ self notYetImplemented! !

!CoxeterDiagram methodsFor: 'as yet unclassified' stamp: 'len 2/11/2016 22:14'!
isElliptic
	^ self notYetImplemented! !

!CoxeterDiagram methodsFor: 'as yet unclassified' stamp: 'len 2/11/2016 22:41'!
isHyperbolic
	^ (self gramMatrix spectrum count: [:each| each negative]) = 1! !

!CoxeterDiagram methodsFor: 'as yet unclassified' stamp: 'len 2/11/2016 22:22'!
isLannerDiagram
	^ self isConnected and: [self isElliptic not and: [self gramMatrix determinant < 0]]! !

!CoxeterDiagram methodsFor: 'as yet unclassified' stamp: 'len 2/11/2016 22:23'!
isParabolic
	| spectrum |
	spectrum _ self gramMatrix spectrum.
	^ (spectrum occurrencesOf: 0) = 1 and: [spectrum allSatisfy: [:each| each >= 0]]! !

!RootSystem methodsFor: 'accessing' stamp: 'len 5/23/2016 05:00'!
ambient
	"Answer the ambient space of the receiver."
	^ ambient! !

!RootSystem methodsFor: 'accessing' stamp: 'len 5/23/2016 04:59'!
rank
	^ ambient dimension! !

!RootSystem methodsFor: 'accessing' stamp: 'len 1/6/2016 04:46'!
roots
	^ roots! !

!RootSystem methodsFor: 'accessing-private' stamp: 'len 5/23/2016 05:00'!
ambient: aVectorSpace
	ambient _ aVectorSpace! !

!RootSystem methodsFor: 'accessing-private' stamp: 'len 2/11/2016 19:21'!
roots: aCollection
	roots _ aCollection! !

!RootSystem methodsFor: 'roots' stamp: 'len 5/23/2016 05:00'!
coroots
	^ roots collect: [:v| v * 2 / (ambient innerProduct value: {v.v})]! !

!RootSystem methodsFor: 'roots' stamp: 'len 1/6/2016 05:01'!
degreeOf: aPositiveRoot
	"Answer the degree of the given positive root."
	^ (self simpleRoots coordinatesOf: aPositiveRoot) asArray sum! !

!RootSystem methodsFor: 'roots' stamp: 'len 1/6/2016 03:52'!
negativeRoots
	^ self positiveRoots negated! !

!RootSystem methodsFor: 'roots' stamp: 'len 6/25/2016 23:08'!
positiveRoots
	| answer |
	answer _ Set new.
	roots do: [:a| (answer includes: a negated)
		ifFalse:
			[answer add: a.
			answer copy do: [:b| (roots includes: a+b) ifTrue: [answer add: b]]]].
	^ answer! !

!RootSystem methodsFor: 'roots' stamp: 'len 1/6/2016 04:51'!
positiveRootsSorted
	^ self positiveRoots asSortedCollection: [:a :b| (self simpleRoots coordinatesOf: b - a) asArray allSatisfy: [:each| each positive]]! !

!RootSystem methodsFor: 'roots' stamp: 'len 12/13/2017 21:56:08'!
simpleRoots
	| M |
	M _ Matrix columns: (self positiveRoots asArray collect: [:each| ambient coordinatesOf: each]).
	^ LinearBasis on: ambient matrix: M imageMatrix! !

!RootSystem methodsFor: 'operations' stamp: 'len 5/5/2019 18:33:56'!
coxeterElement
	| O answer |
	O _ ambient automorphisms orthogonal.
	answer _ ambient id.
	self simpleRoots do: [:each| answer _ answer  (O reflectionAt: each)].
	^ answer! !

!RootSystem methodsFor: 'operations' stamp: 'len 12/13/2017 17:59:02'!
coxeterMatrix
	"Answer the Coxeter matrix of the receiver.
	Given a basis a_i of simple roots, the Coxeter matrix m_ij is defined by <a_i,a_j> = -2 cos(pi / m_ij)."
	| S |
	S _ self normalized simpleRoots.
	^ ambient scalars
		matrix: S size
		evaluating: [:i :j| Float pi / ((ambient innerProduct value: {(S at: i). (S at: j)}) / -2) arcCos]! !

!RootSystem methodsFor: 'operations' stamp: 'len 6/18/2016 17:14'!
coxeterNumber
	^ self weylGroup orderOf: self coxeterElement! !

!RootSystem methodsFor: 'operations' stamp: 'len 5/23/2016 04:59'!
dual
	^ self class on: ambient roots: self coroots! !

!RootSystem methodsFor: 'operations' stamp: 'len 2/11/2016 20:59'!
exponents
	"Answer the 'sequence of exponents' of the root system."
	| h |
	self flag: #fix. "complex eigenvalues, but how about finite fields?"
	h _ self coxeterNumber.
	^ self coxeterElement eigenvalues collect: [:each| each log / (Float pi * 2 i / h)]! !

!RootSystem methodsFor: 'operations' stamp: 'len 5/20/2018 15:59:24'!
lattice
	"Answer the root lattice, the Z-submodule spanned by roots of the receiver."
	^ Lattice basis: self simpleRoots! !

!RootSystem methodsFor: 'operations' stamp: 'len 5/23/2016 05:01'!
normalized
	^ self class on: ambient roots: (roots collect: [:x| x * (2 / (ambient innerProduct value: {x.x}))])! !

!RootSystem methodsFor: 'operations' stamp: 'len 2/10/2016 23:01'!
positiveWeylChamber
	"Answer the positive Weyl chamber that is choosen in the receiver to define the positive roots."
	^ self notYetImplemented! !

!RootSystem methodsFor: 'operations' stamp: 'len 5/20/2018 15:59:29'!
weightLattice
	"Answer the lattice spanned by the weights of the receiver. This lattice is invariant under the Weyl group and also under the map v -> -v. Also, the root lattice is contained in the weight lattice."
	^ Lattice basis: self weights! !

!RootSystem methodsFor: 'operations' stamp: 'len 1/7/2016 05:42'!
weights
	"Answer the fundamental weights of the receiver.
	A vector v is integral iff it can be expressed as integer linear combination of the fundamental weights."
	^ self notYetImplemented! !

!RootSystem methodsFor: 'operations' stamp: 'len 10/17/2016 11:03'!
weylAction
	| W |
	W _ self weylGroup.
	W name: 'W'.
	^ GroupAction from: (W, self roots) to: self roots evaluatingWithArguments: [:f :x| f value: x]! !

!RootSystem methodsFor: 'operations' stamp: 'len 9/27/2018 21:19:17'!
weylGroup
	"Answer the Weyl group of the root system, i.e. the (finite) group of isometries of the ambient vector space generated by reflections through hyperplanes perpendicular to the roots. The Weyl group W(R) is the subgroup of GL(V) (and more specifically O(V)) generated by the reflections {s_r} that act on each root r by -1: s_r(r) = -r."
	| O W |
	O _ ambient automorphisms orthogonal.
	W _ O span: (self roots collect: [:each| O reflectionAt: each]).
"	W name: 'W'."
	^ W! !

!RootSystem methodsFor: 'operations' stamp: 'len 1/6/2016 00:00'!
weylVector
	^ self positiveRoots sum / 2! !

!RootSystem methodsFor: 'testing' stamp: 'len 5/23/2016 04:59'!
isCrystallographic
	^ self roots allSatisfy: [:x|
		self coroots allSatisfy: [:y|
			(ambient innerProduct value: {x. y}) isInteger]]! !

!RootSystem methodsFor: 'testing' stamp: 'len 2/11/2016 21:16'!
isIntegral
	^ self isCrystallographic! !

!RootSystem methodsFor: 'testing' stamp: 'len 2/11/2016 20:46'!
isIrreducible
	^ self coxeterDiagram isConnected! !

!RootSystem methodsFor: 'testing' stamp: 'len 5/23/2016 05:01'!
isNormalized
	^ roots allSatisfy: [:each| (ambient innerProduct value: {each.each}) = 2]! !

!RootSystem class methodsFor: 'examples' stamp: 'len 7/14/2016 00:09'!
A: V
	| roots |
	roots _ Set new.
	1 to: V dimension do: [:i|
		i to: V dimension do: [:j|
			roots add: (V e: i) - (V e: j)]].
	^ self on: V roots: roots! !

!RootSystem class methodsFor: 'examples' stamp: 'len 7/14/2016 00:09'!
B: V
	| roots |
	roots _ Set new.
	1 to: V dimension do: [:i|
		roots add: (V e: i).
		i to: V dimension do: [:j|
			roots add: (V e: i) - (V e: j); add: (V e: i) + (V e: j)]].
	^ self on: V roots: roots! !

!RootSystem class methodsFor: 'examples' stamp: 'len 7/14/2016 00:09'!
C: V
	| roots |
	roots _ Set new.
	1 to: V dimension do: [:i|
		roots add: (V e: i)*2.
		i to: V dimension do: [:j|
			roots add: (V e: i) - (V e: j); add: (V e: i) + (V e: j)]].
	^ self on: V roots: roots! !

!RootSystem class methodsFor: 'examples' stamp: 'len 7/14/2016 00:09'!
D: V
	| roots |
	roots _ Set new.
	1 to: V dimension do: [:i|
		i to: V dimension do: [:j|
			roots add: (V e: i) - (V e: j); add: (V e: i) + (V e: j)]].
	^ self on: V roots: roots! !

!RootSystem class methodsFor: 'examples' stamp: 'len 7/15/2016 18:37'!
example1
	"This is a normalized root system in R^n. The Weyl group associated to it is the symmetric group S_n."
	| V roots |
	V _ QQ ^ 3.
	roots _ Set new.
	1 to: V dimension do: [:i|
		1 to: i-1 do: [:j|
			roots add: (V e: i) - (V e: j); add: (V e: j) - (V e: i)]].
	^ RootSystem on: V roots: roots! !

!RootSystem class methodsFor: 'examples' stamp: 'len 1/20/2018 19:03:50'!
example2
	"This is a normalized root system in R^n. The Weyl group associated to it is the hyperoctahedral group."
	| V roots |
	V _ RR ^ 3.
	roots _ Set new.
	1 to: V dimension do: [:i|
		1 to: i-1 do: [:j|
			roots
				add: (V e: i) * (RealAlgebraicNumber sqrt: 2);
				add: (V e: i) * (RealAlgebraicNumber sqrt: 2) negated;
				add: (V e: i) - (V e: j);
				add: (V e: j) - (V e: i);
				add: (V e: i) + (V e: j);
				add: ((V e: i) + (V e: j)) negated]].
	^ RootSystem on: V roots: roots! !

!RootSystem class methodsFor: 'examples' stamp: 'len 7/15/2016 18:37'!
example3
	"This is a normalized root system in R^n. The Weyl group associated to it is an index 2 subgroup of the hyperoctahedral group."
	| V roots |
	V _ QQ ^ 3.
	roots _ Set new.
	1 to: 3 do: [:i|
		1 to: i-1 do: [:j|
			roots
				add: (V e: i) - (V e: j);
				add: (V e: j) - (V e: i);
				add: (V e: i) + (V e: j);
				add: ((V e: i) + (V e: j)) negated]].
	^ RootSystem on: V roots: roots! !

!RootSystem class methodsFor: 'examples' stamp: 'len 7/15/2016 18:37'!
hexagonal
	^ self A: QQ ^ 2! !

!RootSystem class methodsFor: 'instance creation' stamp: 'len 5/23/2016 05:00'!
on: aVectorSpace roots: aCollection
	^ self new ambient: aVectorSpace; roots: aCollection! !

!Product methodsFor: 'as yet unclassified' stamp: 'len 4/21/2019 03:02:55'!
components
	^ projections collect: [:each| each codomain]! !

!Product methodsFor: 'as yet unclassified' stamp: 'len 4/21/2019 02:47:43'!
projections
	^ projections! !

!Product methodsFor: 'as yet unclassified' stamp: 'len 4/21/2019 02:48:04'!
projections: anArray
	projections _ anArray! !

!DirectSum methodsFor: 'as yet unclassified' stamp: 'len 4/21/2019 03:20:06'!
coprojections
	^ coprojections! !

!DirectSum methodsFor: 'as yet unclassified' stamp: 'len 4/21/2019 03:20:15'!
coprojections: anArray
	coprojections _ anArray! !

!TensorProduct methodsFor: 'as yet unclassified' stamp: 'len 4/23/2019 17:27:55'!
compose: anArray
	"Answer the tensor product composition."
	^ self subclassResponsibility! !

!Object methodsFor: '*domains' stamp: 'len 11/6/2016 09:07'!
adaptToCollection: rcvr andSend: selector
	"If I am involved in arithmetic with a Collection, return a Collection of
	the results of each element combined with me in that expression."

	^ rcvr collect: [:element | element perform: selector with: self]! !

!Object methodsFor: '*domains' stamp: 'len 4/19/2019 06:23:43'!
isElement
	"Answer true if the receiver is an element of a Domain, i.e. if it understands the message #parent and answers its parent Domain."
	^ false! !

!Object methodsFor: '*domains' stamp: 'len 5/19/2018 17:53:50'!
isEvaluable
	^ self isBlock! !

!Object methodsFor: '*domains' stamp: 'len 5/25/2018 17:55:58'!
isFractional
	"Answer true if this is an element of a localization, i.e. if it is some kind of fraction and understands #numerator and #denominator."
	^ false! !

!Object methodsFor: '*domains' stamp: 'len 11/19/2015 17:01'!
isInfinity
	^ false! !

!Object methodsFor: '*domains' stamp: 'len 4/2/2018 05:16:06'!
isMatrix
	^ false! !

!Object methodsFor: '*domains' stamp: 'len 8/5/2016 21:51'!
isReal
	"Answer true if the receiver is a real number."
	^ false! !

!Object methodsFor: '*domains' stamp: 'len 5/22/2018 16:53:19'!
isSequenceable
	"Answer true if the receiver is some sort of ordered tuple of objects, understands #at: and #size and it's indexed by integers starting at 1."
	^ false! !

!Object methodsFor: '*domains' stamp: 'len 3/28/2018 18:01:41'!
isTuple
	^ false! !

!Class methodsFor: '*domains' stamp: 'len 12/1/2016 09:03:19'!
newSubclass
	"Answer a new subclass of the receiver. The new subclass will be unnamed and uncategorized, and if no instances exist it can be subject of garbage collection."
	| newMetaclass |
	newMetaclass _ Metaclass new.
	newMetaclass
		superclass: self class
		methodDictionary: MethodDictionary new
		format: self class format.
	^ newMetaclass new
		superclass: self
		methodDictionary: MethodDictionary new
		format: self format! !

!Magnitude methodsFor: '*domains' stamp: 'len 10/18/2016 13:58'!
isFinite
	^ self isInfinite not! !

!Magnitude methodsFor: '*domains' stamp: 'len 10/18/2016 13:57'!
isInfinite
	^ false! !

!Number methodsFor: '*domains' stamp: 'len 11/5/2016 10:31'!
, anObject
	^ (QQ tuple: {self}), anObject! !

!Number methodsFor: '*domains' stamp: 'len 2/10/2017 15:26:13'!
/// aNumber
	^ self / aNumber! !

!Number methodsFor: '*domains' stamp: 'len 3/25/2018 16:03:52'!
^ aNumber
	aNumber isInteger ifTrue: [^ self raisedToInteger: aNumber].
	aNumber isFraction ifTrue: [^ (self root: aNumber denominator) raisedToInteger: aNumber numerator ].
	0 = aNumber ifTrue: [^ self class one].
	1 = aNumber ifTrue: [^ self].
	0 = self ifTrue: [
		aNumber < 0
			ifTrue: [^ (ZeroDivide dividend: self) signal]
			ifFalse: [^ self]].
	^ (aNumber * self ln) exp! !

!Number methodsFor: '*domains' stamp: 'len 11/19/2015 18:42'!
adaptToQuaternion: rcvr andSend: selector
	^ rcvr perform: selector with: self asQuaternion! !

!Number methodsFor: '*domains' stamp: 'len 11/19/2015 19:41'!
asQuaternion
	^ Quaternion a: self b: self zero c: self zero d: self zero! !

!Number methodsFor: '*domains' stamp: 'len 6/23/2016 23:27'!
conjugated
	"Answer the complex conjugate of the receiver."

	^ self! !

!Number methodsFor: '*domains' stamp: 'len 6/4/2016 21:55'!
imaginary
	^ 0! !

!Number methodsFor: '*domains' stamp: 'len 3/17/2016 03:40'!
isAlgebraic
	^ false! !

!Number methodsFor: '*domains' stamp: 'len 8/5/2016 21:44'!
isComplex
	^ true "real numbers are also complex numbers"! !

!Number methodsFor: '*domains' stamp: 'len 5/13/2019 19:48:56'!
isElement
	^ true! !

!Number methodsFor: '*domains' stamp: 'len 11/19/2015 17:20'!
isRational
	^ false! !

!Number methodsFor: '*domains' stamp: 'len 8/5/2016 21:44'!
isReal
	^ true! !

!Number methodsFor: '*domains' stamp: 'len 1/12/2016 03:18'!
norm
	^ self abs! !

!Number methodsFor: '*domains' stamp: 'len 1/13/2016 02:54'!
norm2
	^ self squared! !

!Number methodsFor: '*domains' stamp: 'len 11/19/2015 20:58'!
one
	^ 1! !

!Number methodsFor: '*domains' stamp: 'len 5/27/2018 03:59:23'!
parent
	^ RR! !

!Number methodsFor: '*domains' stamp: 'len 6/4/2016 21:54'!
real
	^ self! !

!Number methodsFor: '*domains' stamp: 'len 3/25/2018 16:05:30'!
root: anInteger
	anInteger = 2 ifTrue: [^ self squareRoot].
	anInteger = 1 ifTrue: [^ self].
	^ self notYetImplemented! !

!Number methodsFor: '*domains' stamp: 'len 11/19/2015 20:58'!
zero
	^ 0! !

!Float methodsFor: '*domains' stamp: 'len 1/13/2016 03:55'!
adaptToAlgebraic: rcvr andSend: selector
	^ rcvr asComplexFloat perform: selector with: self asComplex! !

!Float methodsFor: '*domains' stamp: 'len 1/13/2016 03:52'!
adaptToRealAlgebraic: rcvr andSend: selector
	^ rcvr asFloat perform: selector with: self! !

!Float methodsFor: '*domains' stamp: 'len 2/25/2016 17:17'!
squareRoot
	^ self sqrt! !

!Fraction methodsFor: '*domains' stamp: 'len 5/21/2018 17:30:09'!
% anInteger
	| R |
	R _ ZZ % anInteger.
	^ (R project: numerator) / (R project: denominator)! !

!Fraction methodsFor: '*domains' stamp: 'len 6/5/2019 14:48:57'!
abs: p
	"Answer the p-adic absolute value of the receiver."
	^ (numerator abs: p) / (denominator abs: p)! !

!Fraction methodsFor: '*domains' stamp: 'len 1/20/2018 19:17:36'!
adaptToAlgebraic: rcvr andSend: selector
	^ rcvr perform: selector with: (ComplexAlgebraicNumber fromRational: self)! !

!Fraction methodsFor: '*domains' stamp: 'len 1/13/2016 03:55'!
adaptToRealAlgebraic: rcvr andSend: selector
	^ rcvr perform: selector with: (RealAlgebraicNumber fromRational: self)! !

!Fraction methodsFor: '*domains' stamp: 'len 2/10/2016 21:13'!
bitSize
	^ numerator bitSize + denominator bitSize! !

!Fraction methodsFor: '*domains' stamp: 'len 1/8/2017 16:37:12'!
height
	^ numerator abs max: denominator! !

!Fraction methodsFor: '*domains' stamp: 'len 5/25/2018 17:56:24'!
isFractional
	"Answer true if this is an element of a localization, i.e. if it is some kind of fraction and understands #numerator and #denominator."
	^ true! !

!Fraction methodsFor: '*domains' stamp: 'len 11/19/2015 17:20'!
isRational
	^ true! !

!Fraction methodsFor: '*domains' stamp: 'len 4/28/2018 16:58:05'!
minimalPolynomial
	^ QQ polynomials x - self! !

!Fraction methodsFor: '*domains' stamp: 'len 5/27/2018 03:59:14'!
parent
	^ QQ! !

!Fraction methodsFor: '*domains' stamp: 'len 1/20/2018 19:17:29'!
squareRoot
	self positive ifTrue: [^ RealAlgebraicNumber sqrt: self].
	^ ComplexAlgebraicNumber sqrt: self! !

!Fraction methodsFor: '*domains' stamp: 'len 6/5/2019 14:50:10'!
valuation: p
	"Answer the p-adic valuation of the receiver."
	^ (numerator valuation: p) - (denominator valuation: p)! !

!Integer methodsFor: '*domains' stamp: 'len 5/21/2018 17:30:01'!
% anInteger
	^ ZZ % anInteger project: self! !

!Integer methodsFor: '*domains' stamp: 'len 11/1/2016 00:23'!
/// anInteger
	"Answer the exact division of the receiver by the argument."
	^ self // anInteger! !

!Integer methodsFor: '*domains' stamp: 'len 8/1/2016 08:54'!
| anInteger
	"Answer true if the receiver divides anInteger."
	^ self ~= 0 and: [anInteger \\ self = 0]! !

!Integer methodsFor: '*domains' stamp: 'len 12/12/2016 09:35:38'!
Stirling: anInteger
	"Answer the Stirling number of the second kind S(n,k).
	Stirling numbers of the second kind count the ways to partition a set of n things into k nonempty subsets."
	(anInteger > self or: [self < 0]) ifTrue: [^ DomainError signal].
	self = anInteger ifTrue: [^ 1].
	anInteger = 0 ifTrue: [^ 0].
	self+1 = anInteger ifTrue: [^ self choose: 2].
	anInteger = 2 ifTrue: [^ 2 ^ (self-1) - 1].
	^ anInteger*(self - 1 Stirling: anInteger) + (self - 1 Stirling: anInteger - 1)! !

!Integer methodsFor: '*domains' stamp: 'len 6/5/2019 14:49:05'!
abs: p
	"Answer the p-adic absolute value of the receiver."
	| powers q |
	self = 0 ifTrue: [^ 0].
	q _ self abs.
	powers _ 1.
	[p | q] whileTrue: [powers _ powers * p. q _ q // p].
	^ powers reciprocal! !

!Integer methodsFor: '*domains' stamp: 'len 1/20/2018 19:17:45'!
adaptToAlgebraic: rcvr andSend: selector
	^ rcvr perform: selector with: (ComplexAlgebraicNumber fromRational: self)! !

!Integer methodsFor: '*domains' stamp: 'len 1/13/2016 03:56'!
adaptToRealAlgebraic: rcvr andSend: selector
	^ rcvr perform: selector with: (RealAlgebraicNumber fromRational: self)! !

!Integer methodsFor: '*domains' stamp: 'len 12/14/2016 14:35:53'!
additiveOrder
	^ self == 0 ifTrue: [1] ifFalse: [Infinity positive]! !

!Integer methodsFor: '*domains' stamp: 'len 7/2/2016 05:45'!
bitCount
	"Answer the number of bits that are set, i.e. the number of 1s in the binary representation."
	| n |
	self = 0 ifTrue: [^ 0].
	self = 1 ifTrue: [^ 1].
	n _ self digitLength * 8. "this will always be >= 32, because SmallInteger implements bitCount"
	n _ n // 2.
	^ (self bitShift: n negated) bitCount + (self bitAnd: (1 bitShift: n) - 1) bitCount! !

!Integer methodsFor: '*domains' stamp: 'len 7/2/2016 05:43'!
bitParity
	"Answer 1 if there are an odd number of bits set, 0 otherwise."
	| n |
	self = 0 ifTrue: [^ 0].
	self = 1 ifTrue: [^ 1].
	n _ self digitLength * 8. "this will always be >= 32, because SmallInteger implements bitParity"
	n _ n // 2.
	^ ((self bitShift: n negated) bitXor: (self bitAnd: (1 bitShift: n) - 1)) bitParity! !

!Integer methodsFor: '*domains' stamp: 'len 7/2/2016 05:43'!
bitParity2
	"Answer 1 if there are an odd number of bits set, 0 otherwise."
	| i n |
	self = 0 ifTrue: [^ 0].
	self = 1 ifTrue: [^ 1].
	i _ self digitLength * 8. "this will always be >= 32, because SmallInteger implements bitParity"
	n _ self.
	[i _ i bitShift: -1.
	i > 30] whileTrue:
		[n _ n bitXor: (n bitShift: i negated)].
	^ (n bitAnd: (1 bitShift: i) - 1) bitParity! !

!Integer methodsFor: '*domains' stamp: 'len 7/1/2016 23:03'!
bitSize
	self negative ifTrue: [^ self negated highBit + 1].
	^ self highBit! !

!Integer methodsFor: '*domains' stamp: 'len 12/12/2016 09:35:09'!
choose: anInteger
	"Answer the binomial coefficient (self anInteger)"
	" 6 choose: 3  "

	(anInteger < 0 or: [anInteger > self]) ifTrue: [^0].
	^(self - anInteger + 1 productTo: self) // anInteger factorial! !

!Integer methodsFor: '*domains' stamp: 'len 6/29/2016 06:40'!
choose: anInteger q: q
	"Answer the q-binomial coefficient of self with anInteger.
	This counts the number of 'anInteger'-dimensional subspaces of a vector space of dimension 'self' over a finite field of order 'q' (power of a prime)."

	(anInteger < 0 or: [anInteger > self]) ifTrue: [^0].
	^ ((0 to: anInteger - 1) inject: 1 into: [:x :i| 1 - (q^(self-i)) * x]) / ((1 to: anInteger) inject: 1 into: [:x :i| 1 - (q^i) * x])! !

!Integer methodsFor: '*domains' stamp: 'len 4/23/2016 19:35'!
count: aBlock
	| answer |
	answer _ 0.
	self timesRepeat: [aBlock value ifTrue: [answer _ answer + 1]].
	^ answer! !

!Integer methodsFor: '*domains' stamp: 'len 11/19/2015 18:29'!
denominator
	^ 1! !

!Integer methodsFor: '*domains' stamp: 'len 12/26/2016 21:24:14'!
divisors
	"Answer the collection of positive divisors of the receiver including 1 and self."
	^ Iterator on: self performing: #divisorsDo:! !

!Integer methodsFor: '*domains' stamp: 'len 12/26/2016 21:23:53'!
divisorsDo: aBlock
	"Iterate over the positive divisors of the receiver, including 1 and self."
	| n sqrt |
	n _ self abs.
	sqrt _ n sqrtFloor.
	1 to: sqrt - 1
		do: [:k| n \\ k = 0 ifTrue: [aBlock value: k; value: n // k]].
	n \\ sqrt = 0
		ifTrue:
			[aBlock value: sqrt.
			sqrt * sqrt = n ifFalse: [aBlock value: n // sqrt]]! !

!Integer methodsFor: '*domains' stamp: 'len 12/26/2016 20:13:44'!
factorizationDo: aBlock
	| n times |
	n _ self abs.
	n <= 1 ifTrue: [^ self].
	n even ifTrue:
		[aBlock value: 2 value: (times _ n lowBit - 1).
		n _ n bitShift: times negated].
	Integer primesUpTo: n sqrtFloor + 1 do: [:p| "tests again 2, but who cares"
		n == 1 ifTrue: [^ self].
		times _ 0.
		[n \\ p == 0] whileTrue: [times _ times + 1. n _ n // p].
		times > 0 ifTrue: [aBlock value: p value: times]].
	n == 1 ifFalse: [aBlock value: n value: 1]! !

!Integer methodsFor: '*domains' stamp: 'len 12/11/2016 19:55:27'!
factors
	"Answer a collection with the prime factors of the receiver (with multiplicity)."
	| answer |
	answer _ Bag new.
	self factorizationDo: [:p :e| answer add: p withOccurrences: e].
	^ answer! !

!Integer methodsFor: '*domains' stamp: 'len 11/19/2016 21:03:03'!
height
	self = 0 ifTrue: [^ 1].
	^ self abs! !

!Integer methodsFor: '*domains' stamp: 'len 12/11/2016 19:58:37'!
isFundamentalDiscriminant
	| m r |
	r _ self \\ 4.
	r == 1 ifTrue: [^ self isSquareFree].
	r == 0 ifFalse: [^ false].
	m _ self // 4.
	r _ m \\ 4.
	^ (r == 2 or: [r == 3]) and: [m isSquareFree]! !

!Integer methodsFor: '*domains' stamp: 'len 1/7/2017 21:04:34'!
isPerfectSquare
	^ self sqrtFloor squared = self! !

!Integer methodsFor: '*domains' stamp: 'len 6/4/2019 15:23:02'!
isPrimePower
	"Answer true if the receiver is of the form p^k for a prime p and a k > 0."
	^ self > 1 and: [self factors asSet size = 1]! !

!Integer methodsFor: '*domains' stamp: 'len 11/19/2015 17:21'!
isRational
	^ true! !

!Integer methodsFor: '*domains' stamp: 'len 12/18/2016 13:06:48'!
isSquareFree
	"Answer true if the factorization of the receiver is squarefree."
	self factorizationDo: [:p :e| e > 1 ifTrue: [^ false]].
	^ true

"
The limit of the density of squarefree positive integers < n is 6 / pi^2 ~ 0.6079271:
(1000 count: [100000 atRandom isSquareFree]) / 1000.0
"! !

!Integer methodsFor: '*domains' stamp: 'len 12/4/2016 15:14:11'!
isZero
	^ self == 0! !

!Integer methodsFor: '*domains' stamp: 'len 4/10/2018 17:29:24'!
jacobi: m
	"Answer the Jacobi symbol of the receiver and the positive odd integer m.
	This is a generalization of the Legendre symbol that allows a composite argument m."

	^ self kronecker: m! !

!Integer methodsFor: '*domains' stamp: 'len 4/10/2018 17:28:55'!
jacobiNew: m
	"Answer the Jacobi symbol of the receiver and the positive odd integer m.
	This is a generalization of the Legendre symbol that allows a composite argument m."

	"this is broken, it should satisfy: (3 jacobiNew: 11) = 1"
	| x y z answer |
	m odd ifFalse: [^ self error: 'the argument must by an odd positive integer'].
	(self gcd: m) = 1 ifFalse: [^ 0].
	x _ self \\ m.
	y _ m.
	answer _ 1.
	[x > 1] whileTrue:
		[[x \\ 4 = 0] whileTrue: [x _ x // 4].
		x \\ 2 = 0
			ifTrue:
				[x _ x // 2.
				y + 2 \\ 8 > 4 ifTrue: [answer _ answer negated]].
		z _ y \\ x.
		y _ x.
		x _ z].
	^ answer! !

!Integer methodsFor: '*domains' stamp: 'len 8/20/97 02:26'!
jacobiOld: n
	"Answer the Jacoby symbol of the receiver and the argument."

	| a minusOne |
"	n odd ifFalse: [^ self error: 'the argument must by an odd positive integer']."
	a _ self \\ n.
	a = 2 ifTrue: [^ (n squared - 1) lowBit > 3 ifTrue: [1] ifFalse: [-1]].
	minusOne _ n - 1.
	a = minusOne ifTrue: [^ minusOne lowBit > 1 ifTrue: [1] ifFalse: [-1]].
	^ (a - 1 * minusOne) lowBit > 2
		ifTrue: [n jacobiOld: a] ifFalse: [(n jacobiOld: a) negated]! !

!Integer methodsFor: '*domains' stamp: 'len 12/29/2016 07:15:13'!
kronecker: anInteger
	"Answer the Kronecker symbol (a | b) for a, b integers. This is the Legendre symbol when b is an odd prime.
	Reference: Henri Cohen, 'A Course in Computatational Algebraic Number Theory', Algorithm 1.4.10."
	| a b v k r |
	a _ self.
	b _ anInteger.
	"1. Test b = 0"
	b == 0 ifTrue: [^ a abs == 1 ifTrue: [1] ifFalse: [0]].
	"2. Remove 2's from b"
	(a even and: [b even]) ifTrue: [^ 0].
	v _ b lowBit - 1.
	b _ b bitShift: v negated.
	"v even ifTrue: [k _ 1] ifFalse: [k _ (-1) ^ (a squared - 1 / 8)]."
	v even ifTrue: [k _ 1] ifFalse: [k _ #(0 1 0 -1 0 -1 0 1) at: (a bitAnd: 7) + 1].
	b < 0 ifTrue: [b _ b negated. a < 0 ifTrue: [k _ k negated]].
	"3. Finished?"
	[a == 0 ifTrue: [^ b == 1 "b is odd and > 0" ifTrue: [k] ifFalse: [0]].
	v _ a lowBit - 1.
	a _ a bitShift: v negated.
	"v odd ifTrue: [k _ (-1) ^ (b squared - 1 / 8) * k]."
	v odd ifTrue: [k _ (#(0 1 0 -1 0 -1 0 1) at: (b bitAnd: 7) + 1) * k].
	"4. Apply reciprocity"
	"k _ (-1) ^ ((a - 1)*(b - 1)/4) * k."
	((a bitAnd: b) bitAnd: 2) == 0 ifFalse: [k _ k negated].
	r _ a abs.
	a _ b \\ r.
	b _ r] repeat! !

!Integer methodsFor: '*domains' stamp: 'len 12/26/2016 22:53:38'!
legendre: p
	"Answer the Legendre symbol (a | p) where p is an odd prime. This is:
		1 if a is a quadratic residue modulo p and a is not 0 modulo p;
		-1 if a is a quadratic non-residue modulo p;
		0 if a is 0 modulo p.
	See also >>jacobi: and >>kronecker:."
	| answer |
	answer _ self raisedToInteger: p - 1 // 2 modulo: p.
	answer > 1 ifTrue: [answer _ answer - p].
	^ answer! !

!Integer methodsFor: '*domains' stamp: 'len 4/28/2018 16:58:43'!
minimalPolynomial
	^ QQ polynomials x - self! !

!Integer methodsFor: '*domains' stamp: 'len 11/28/2015 07:08'!
moebius
	"Answer the Moebius function mu of the receiver."
	| factors |
	factors _ self factors.
	factors asSet size = factors size ifFalse: [^ 0].
	^ factors size even ifTrue: [1] ifFalse: [-1]! !

!Integer methodsFor: '*domains' stamp: 'len 4/30/2019 11:01:13'!
multichoose: anInteger
	"Answer 'd multichoose: n', the number of ways of counting n objects from a set of d elements where repetition is allowed and order does not matter."
	^ self + anInteger - 1 choose: anInteger! !

!Integer methodsFor: '*domains' stamp: 'len 12/14/2016 14:36:14'!
multiplicativeOrder
	^ self == 1 ifTrue: [1] ifFalse: [self == -1 ifTrue: [2] ifFalse: [Infinity positive]]! !

!Integer methodsFor: '*domains' stamp: 'len 12/13/2015 02:00'!
numberOfDivisors
	^ self primeSignature inject: 1 into: [:x :each| x * (each + 1)]! !

!Integer methodsFor: '*domains' stamp: 'len 11/19/2015 18:29'!
numerator
	^ self! !

!Integer methodsFor: '*domains' stamp: 'len 5/27/2018 03:59:04'!
parent
	^ ZZ! !

!Integer methodsFor: '*domains' stamp: 'len 7/2/2016 20:55'!
partitions
	^ Iterator on: self performing: #partitionsDo:! !

!Integer methodsFor: '*domains' stamp: 'len 7/2/2016 20:57'!
partitionsDo: aBlock
	self < 0 ifTrue: [^ DomainError signal: 'negative number'].
	self = 0 ifTrue: [^ aBlock value: #()].
	self - 1 partitionsDo: [:each|
		aBlock value: #(1), each.
		(each size > 0 and: [each size < 2 or: [(each at: 2) > (each at: 1)]])
			ifTrue: [aBlock value: (each copy at: 1 put: (each at: 1) + 1; yourself)]]! !

!Integer methodsFor: '*domains' stamp: 'len 12/10/2016 12:18:54'!
phi
	"Answer Euler's totient function phi of the receiver."
	^ (1 to: self) count: [:each| (self gcd: each) = 1]! !

!Integer methodsFor: '*domains' stamp: 'len 12/3/2016 13:17:26'!
pollard
	"Answer a non trivial factor of the receiver.
	Pollard's p-1 algorithm is used. This works well to find a prime factor p such that p - 1 is smooth."

	| N a x y p count |
	N _ self abs.
	a _ N atRandom.
	x _ N atRandom.
	y _ x.
	count _ 1.
	[x _ x squared + a \\ self.
	y _ (y squared + a \\ self) squared + a \\ self.
	(p _ y - x gcd: self) = 1
		ifFalse: [^ Array with: p with: count].
	count _ count + 1] repeat! !

!Integer methodsFor: '*domains' stamp: 'len 12/3/2016 13:25:38'!
pollard: L
	"Answer a nontrivial factor of the receiver, or nil if fail.
	This is Pollard's p-1 algorithm. It works well with numbers divisible by a prime p such that p - 1 is smooth with some small factor q^k where k*q <= L."
	| N A F |
	N _ self abs.
	A _ (2 to: N-1) atRandom.
	1 to: L do: [:i|
		A _ A raisedTo: i modulo: N.
		(F _ A - 1 gcd: N) = 1
			ifFalse: [^ F]].
	^ nil! !

!Integer methodsFor: '*domains' stamp: 'len 12/13/2015 01:49'!
primeSignature
	| factors |
	factors _ self factors.
	^ (factors asSet asSortedCollection collect: [:each| factors occurrencesOf: each]) asArray! !

!Integer methodsFor: '*domains' stamp: 'len 12/14/2016 14:48:30'!
radical
	"Answer the product of the prime divisors of the receiver."
	| answer |
	answer _ self sign.
	self factorizationDo: [:p :e| answer _ answer * p].
	^ answer! !

!Integer methodsFor: '*domains' stamp: 'len 12/4/2016 13:11:44'!
reciprocalModulo2: n
	"Answer an integer x such that self * x \\ n = 1, with 0 < x < n, or nil if it doesn't exist."
	| xgcd |
	self == 0 ifTrue: [^ nil].
	self == 1 ifTrue: [^ 1].
	xgcd _ self xgcd: n.
	^ (xgcd at: 1) == 1 ifTrue: [^ (xgcd at: 2) \\ n]! !

!Integer methodsFor: '*domains' stamp: 'sqr 1/14/2014 01:30'!
reciprocalModulo: mod
	"Answer an integer x such that self * x \\ n = 1, with 0 < x < n, or nil if x does not exist.
	The algorithm is a non extended euclidean modular inversion called NINV.
	It is described in this article:
		'Using an RSA Accelerator for Modular Inversion'
	by Martin Seysen. See http://www.iacr.org/archive/ches2005/017.pdf"

	| receiver u v f fPlusN b result result2 |
	mod > 1 ifFalse: [^nil].
	receiver := (self >= mod or: [self < 0])
		ifTrue: [self \\ mod] ifFalse: [self].
	b := mod highBit + 1.
	f := 1 bitShift: b.
	v := (receiver bitShift: b) + 1.
	u := mod bitShift: b.
	fPlusN := f + mod.
	[v >= fPlusN] whileTrue:
		[v := u \\\ (u := v)].
	result := v - f.
	result2 := result + mod.
	result2 > 0 ifFalse: [^nil].
	^result positive
		ifTrue: [result]
		ifFalse: [result2]! !

!Integer methodsFor: '*domains' stamp: 'len 12/14/2016 22:03:49'!
squareFree
	"Answer the unique integer z such that the receiver equals z * y^2 with z squarefree and y^2 a perfect square."
	| answer |
	answer _ self sign.
	self factorizationDo: [:p :e| e even ifFalse: [answer _ answer * p]].
	^ answer! !

!Integer methodsFor: '*domains' stamp: 'len 1/20/2018 19:17:41'!
squareRoot
	self positive ifTrue: [^ RealAlgebraicNumber sqrt: self].
	^ ComplexAlgebraicNumber sqrt: self! !

!Integer methodsFor: '*domains' stamp: 'len 12/12/2016 09:35:43'!
stirling: anInteger
	"Answer the Stirling number of the first kind s(n,k).
	Stirling numbers of the first kind count the ways to arrange n objects into k cycles."
	(anInteger > self or: [self < 0]) ifTrue: [^ DomainError signal].
	anInteger = 1 ifTrue: [^ (self - 1) factorial].
	self = anInteger ifTrue: [^ self Stirling: anInteger].
	self+1 = anInteger ifTrue: [^ self choose: 2].
	^ (self-1) * (self-1 stirling: anInteger) + (self-1 stirling: anInteger-1)! !

!Integer methodsFor: '*domains' stamp: 'len 6/5/2019 13:14:56'!
valuation: p
	"Answer the p-adic valuation of the receiver."
	| answer q |
	self = 0 ifTrue: [^ Infinity positive].
	q _ self abs.
	answer _ 0.
	[p | q] whileTrue: [answer _ answer + 1. q _ q // p].
	^ answer! !

!Integer methodsFor: '*domains' stamp: 'len 3/6/2017 16:27:34'!
xgcd: anInteger
	"Extended Euclidean algorithm.
	Answer an array {x. u. v} where self * u + (anInteger * v) = x, and x = (self gcd: anInteger)."
	| a b s1 t1 s t r1 r |
	a _ self. b _ anInteger.
	s1 _ 0. s _ 1.
	t1 _ 1. t _ 0.
	r1 _ a abs. r _ b abs.
	[r1 == 0]
		whileFalse:
			[ | q temp |
			q _ r // r1.
			temp _ r1. r1 _ r - (q * r1). r _ temp.
			temp _ s1. s1 _ s - (q * s1). s _ temp.
			temp _ t1. t1 _ t - (q * t1). t _ temp].
	s _ s * b sign. t _ t * a sign.
	^ {r. t. s}! !

!SmallInteger methodsFor: '*domains' stamp: 'len 11/12/2016 08:38'!
bitCount
	"Answer the number of bits that are set, i.e. the number of 1s in the binary representation."
	| v count |
	v _ self.
	count _ 0.
	[v = 0] whileFalse: [v _ v bitAnd: v - 1. count _ count + 1].
	^ count
	
	"HACKMEM:
	| count |
	self flag: #fix.
	count _ self - ((self >> 1) bitAnd: 8r33333333333) - ((self >> 1) bitAnd: 8r11111111111).
	^ (count + (count >> 3) bitAnd: 8r30707070707) \\ 63
"
! !

!SmallInteger methodsFor: '*domains' stamp: 'len 7/2/2016 05:43'!
bitParity
	"Answer 1 if there are an odd number of bits set, 0 otherwise."
	| v parity |
	v _ self.
	parity _ 0.
	[v = 0] whileFalse: [parity _ parity bitXor: (v bitAnd: 1). v _ v bitShift: -1].
	^ parity

"	n _ self.
	n _ n bitXor: (n bitShift: -16).
	n _ n bitXor: (n bitShift: -8).
	n _ n bitXor: (n bitShift: -4).
	n _ n bitAnd: 16rF.
	^ (16r6996 bitShift: n negated) bitAnd: 1
"! !

!Complex methodsFor: '*domains' stamp: 'len 1/22/2017 08:13:12'!
^ aNumber
	^ self raisedTo: aNumber! !

!Complex methodsFor: '*domains' stamp: 'len 5/13/2019 19:49:08'!
isElement
	^ true! !

!Complex methodsFor: '*domains' stamp: 'len 12/6/2016 13:18:52'!
isInfinite
	^ real isInfinite or: [imaginary isInfinite]! !

!Complex methodsFor: '*domains' stamp: 'len 8/5/2016 21:45'!
isReal
	^ self imaginary isZero! !

!Complex methodsFor: '*domains' stamp: 'len 3/3/2016 01:01'!
norm
	^ (real squared + imaginary squared) squareRoot! !

!Complex methodsFor: '*domains' stamp: 'len 1/11/2016 05:54'!
norm2
	^ real squared + imaginary squared! !

!Complex methodsFor: '*domains' stamp: 'len 12/26/2015 19:56'!
one
	^ self class real: real one imaginary: imaginary zero! !

!Complex methodsFor: '*domains' stamp: 'len 5/27/2018 03:59:33'!
parent
	^ CC! !

!Complex methodsFor: '*domains' stamp: 'len 11/29/2016 11:42:24'!
printOn: aStream
	(real ~= 0 or: [imaginary = 0])
		ifTrue:
			[aStream print: real.
			imaginary = 0
				ifFalse:
					[aStream space.
					imaginary positive
						ifTrue: [aStream nextPut: $+]
						ifFalse: [aStream nextPut: $-].
					aStream space.
					imaginary abs = 1 ifFalse: [aStream print: imaginary abs].
					aStream nextPutAll: 'i' italic]]
		ifFalse:
			[imaginary negative
				ifTrue: [aStream nextPut: $-].
			imaginary abs = 1 ifFalse: [aStream print: imaginary abs].
			aStream nextPutAll: 'i' italic]! !

!Complex methodsFor: '*domains' stamp: 'len 12/26/2015 19:56'!
zero
	^ self class real: real zero imaginary: imaginary zero! !

!BlockClosure methodsFor: '*domains' stamp: 'len 4/24/2016 06:00'!
count
	| count |
	count _ 0.
	self whileTrue: [count _ count + 1].
	^ count! !

!BlockClosure methodsFor: '*domains' stamp: 'len 3/1/2017 17:00:08'!
times: anInteger histogram: binCount
	^ HistogramMorph new: binCount samples: ((1 to: anInteger) collect: [:each| self value])! !

!Collection methodsFor: '*domains' stamp: 'len 5/10/2019 04:26:01'!
/\ aCollection
	^ self intersection: aCollection! !

!Collection methodsFor: '*domains' stamp: 'len 8/12/2016 21:17'!
< aCollection
	"Answer true if the receiver is a proper subcollection of aCollection."
	^ self <= aCollection and: [self size < aCollection size]! !

!Collection methodsFor: '*domains' stamp: 'len 8/12/2016 21:16'!
<= aCollection
	"Answer true if the receiver is a subcollection of aCollection."
	(aCollection isKindOf: self species) ifFalse: [^ false].
	self size <= aCollection size ifFalse: [^ false].
	^ self allSatisfy: [:each| aCollection includes: each]! !

!Collection methodsFor: '*domains' stamp: 'len 8/12/2016 21:11'!
> aCollection
	"Answer true if aCollection is a proper subcollection of the receiver."
	^ aCollection < self! !

!Collection methodsFor: '*domains' stamp: 'len 8/12/2016 21:12'!
>= aCollection
	"Answer true if aCollection is a subcollection of the receiver."
	^ aCollection <= self! !

!Collection methodsFor: '*domains' stamp: 'len 2/19/2017 09:13:36'!
\ aCollection
	"Answer the complement of aCollection in the receiver."
	^ self reject: [:each| aCollection includes: each]! !

!Collection methodsFor: '*domains' stamp: 'len 5/10/2019 04:26:11'!
\/ aCollection
	^ self union: aCollection! !

!Collection methodsFor: '*domains' stamp: 'len 5/6/2019 03:01:10'!
 anObject
	^ anObject adaptToCollection: self andSend: #! !

!Collection methodsFor: '*domains' stamp: 'len 2/18/2003 21:40'!
anyIfNone: aBlock
	"Answer a representative sample of the receiver. This method can
	be helpful when needing to preinfer the nature of the contents of 
	semi-homogeneous collections."

	self do: [:each | ^ each].
	^aBlock value! !

!Collection methodsFor: '*domains' stamp: 'len 4/27/2018 01:29:32'!
apply: aFunction
	^ self collect: aFunction! !

!Collection methodsFor: '*domains' stamp: 'len 5/25/2018 18:10:51'!
atRandom: aRandom bits: bitSize
	^ self atRandom: aRandom! !

!Collection methodsFor: '*domains' stamp: 'len 1/30/2018 21:35:53'!
atRandomBits: anInteger
	^ self atRandom! !

!Collection methodsFor: '*domains' stamp: 'len 2/13/2003 23:19'!
copyEmpty
	^ self species new! !

!Collection methodsFor: '*domains' stamp: 'len 2/13/2003 23:19'!
copyEmpty: anInteger
	^ self species new: anInteger! !

!Collection methodsFor: '*domains' stamp: 'len 2/19/2017 10:40:52'!
intersects: aCollection
	^ self anySatisfy: [:any| aCollection includes: any]! !

!Collection methodsFor: '*domains' stamp: 'len 5/6/2019 02:58:39'!
inverse
	^ self collect: [:a | a inverse]! !

!Collection methodsFor: '*domains' stamp: 'len 6/23/2016 05:29'!
isFinite
	^ true! !

!Collection methodsFor: '*domains' stamp: 'len 6/23/2016 05:29'!
isInfinite
	^ false! !

!Collection methodsFor: '*domains' stamp: 'len 4/25/2016 07:52'!
plot: aFunction
	^ FunctionPlotMorph new evaluationPoints: self; function: aFunction! !

!Collection methodsFor: '*domains' stamp: 'len 5/8/2018 07:15:12'!
printElementsOn: aStream
	aStream nextPut: $(.
	self do: [:element| aStream print: element] separatedBy: [aStream nextPutAll: ', '].
	aStream nextPut: $)! !

!Collection class methodsFor: '*domains-instance creation'!
accumulate: iteratorBlock
	"Return a new instance of myself by evaluating the iteratorBlock.
	Examples:
		| x oc set |
		x := #( 1 2 3 4 1 ).
		oc := OrderedCollection accumulate: [ :incBlock | x do: incBlock].
		Transcript cr; show: oc printString.
		set := Set accumulate: [ :incBlock | x do: incBlock].
		Transcript cr; show: set printString"

	| collection | 
	collection := self new.
	iteratorBlock value: [ :element | collection add: element].
	^collection! !

!Collection class methodsFor: '*domains-instance creation'!
accumulate: iteratorSymbol on: collection
	"Return a new instance of myself by sending the iteratorSymbol to the collection.
	Examples:
		| x oc set |
		x := #( 1 2 3 4 1 ).
		oc := OrderedCollection accumulate: #do: on: x.
		Transcript cr; show: oc printString.
		set := Set accumulate: #do: on: x.
		Transcript cr; show: set printString"

	| newCollection | 
	newCollection := self new.
	collection perform: iteratorSymbol with: [ :element | newCollection add: element].
	^newCollection! !

!SequenceableCollection methodsFor: '*domains' stamp: 'len 8/12/2016 22:01'!
<= aCollection
	"Answer true if the receiver is a subcollection of aCollection."
	(aCollection isKindOf: self species) ifFalse: [^ false].
	self size <= aCollection size ifFalse: [^ false].
	^ (aCollection indexOfSubCollection: self startingAt: 1) > 0! !

!SequenceableCollection methodsFor: '*domains' stamp: 'len 3/23/2016 05:04'!
at: anInteger add: anObject
	^ self at: anInteger put: (self at: anInteger) + anObject! !

!SequenceableCollection methodsFor: '*domains' stamp: 'len 2/21/2017 18:59:40'!
combinations: r
	^ Iterator on: [:aBlock| self combinations: r atATimeDo: [:each| aBlock value: each copy]]! !

!SequenceableCollection methodsFor: '*domains' stamp: 'len 11/22/2016 05:40:12'!
convolution: aCollection
	| answer |
	self isEmpty ifTrue: [^ self].
	aCollection isEmpty ifTrue: [^ aCollection].
	answer _ self species new: self size + aCollection size - 1.
	answer atAllPut: (self at: 1) - (self at: 1).
	1 to: self size do: [:i|
		1 to: aCollection size do: [:k|
			answer at: i+k-1 add: (self at: i) * (aCollection at: k)]].
	^ answer! !

!SequenceableCollection methodsFor: '*domains' stamp: 'len 11/6/2016 09:06'!
isZero
	self do: [:each| each isZero ifFalse: [^ false]].
	^ true! !

!SequenceableCollection methodsFor: '*domains' stamp: 'len 2/21/2017 19:00:52'!
permutations
	^ Iterator on: [:aBlock| self permutationsDo: [:each| aBlock value: each copy]]! !

!SequenceableCollection methodsFor: '*domains' stamp: 'len 11/18/2016 08:42:32'!
permutedBy: aPermutation
	| answer |
	answer _ Array new: self size.
	1 to: self size do: [:i| answer at: (aPermutation at: i) put: (self at: i)].
	^ answer! !

!SequenceableCollection methodsFor: '*domains' stamp: 'len 7/17/2016 22:13'!
plot
	^ FunctionPlotMorph new evaluationPoints: (1 to: self size); function: (Function evaluating: [:n| self at: n])! !

!SequenceableCollection methodsFor: '*domains' stamp: 'len 11/18/2016 08:58:16'!
sum
	| answer |
	answer _ self at: 1.
	2 to: self size do: [:i| answer _ answer + (self at: i)].
	^ answer! !

!Array methodsFor: '*domains' stamp: 'len 11/6/2016 09:26'!
printOn: aStream
	self == Smalltalk specialObjectsArray
		ifTrue: [aStream nextPutAll: 'Smalltalk specialObjectsArray' ]
		ifFalse:
			[aStream nextPut: $(.
			self do: [:each| aStream print: each] separatedBy: [aStream nextPutAll: ', '].
			aStream nextPut: $)]! !

!Float64Array methodsFor: '*domains' stamp: 'len 5/13/2019 21:32:22'!
 anObject
	^ self dot: anObject! !

!FloatArray methodsFor: '*domains' stamp: 'len 5/13/2019 21:32:12'!
 anObject
	^ self dot: anObject! !

!Interval methodsFor: '*domains' stamp: 'len 11/14/2016 13:59'!
isStandard
	"Answer true if the receiver is an interval [1..n]."
	^ start = 1 and: [stop isInteger and: [stop >= 1 and: [stop - start + 1 = count]]]! !

!Interval methodsFor: '*domains' stamp: 'len 11/14/2016 10:15'!
printOn: aStream
	self increment = 1
		ifTrue: [aStream nextPut: $[; print: start; nextPutAll: '..'; print: stop; nextPut: $]]
		ifFalse: [self storeOn: aStream]! !

!Interval methodsFor: '*domains' stamp: 'len 11/14/2016 10:14'!
storeOn: aStream
	aStream nextPut: $(; print: start; nextPutAll: ' to: '; print: stop.
	self increment ~= 1 ifTrue: [aStream nextPutAll: ' by: '; print: self increment].
	aStream nextPut: $)! !

!Bag methodsFor: '*domains' stamp: 'len 4/24/2018 17:42:11'!
apply: aFunction
	| answer |
	answer _ self species new.
	self withOccurrencesDo: [:each :times| answer add: (aFunction value: each) withOccurrences: times].
	^ answer! !

!Bag methodsFor: '*domains' stamp: 'len 12/10/2016 11:26:24'!
withOccurrencesDo: aBlock
	contents associationsDo: [:each| aBlock value: each key value: each value]! !

!Set methodsFor: '*domains' stamp: 'len 4/27/2016 02:28'!
add: newObject ifAbsent: aBlock
	"Include newObject as one of the receiver's elements, but only if
	not already present. Answer newObject."

	| index |
	newObject ifNil: [self error: 'Sets cannot meaningfully contain nil as an element'].
	index _ self findElementOrNil: newObject.
	(array at: index) ifNil: [self atNewIndex: index put: newObject. aBlock value].
	^ newObject! !

!Set methodsFor: '*domains' stamp: 'len 5/12/2016 23:24'!
add: newObject ifPresent: aBlock
	"Include newObject as one of the receiver's elements, but only if
	not already present. Answer newObject."

	| index |
	newObject ifNil: [self error: 'Sets cannot meaningfully contain nil as an element'].
	index _ self findElementOrNil: newObject.
	(array at: index) isNil
		ifTrue: [self atNewIndex: index put: newObject]
		ifFalse: [aBlock value].
	^ newObject! !

!Set methodsFor: '*domains' stamp: 'len 6/13/2016 01:03'!
powerset
	"Answer all subsets of the receiver, including self and {}."
	| e answer |
	self isEmpty ifTrue: [^ OrderedCollection with: self].
	e _ self anyOne.
	answer _ (self copyWithout: e) powerset.
	answer copy do: [:each| answer add: (each copyWith: e)].
	^ answer! !

!Set methodsFor: '*domains' stamp: 'len 11/7/2016 09:28'!
printOn: aStream
	(self isMemberOf: Set)
		ifFalse: [^ super printOn: aStream].
	aStream nextPut: ${.
	self do: [:each| aStream print: each] separatedBy: [aStream nextPutAll: ', '].
	aStream nextPut: $}! !

!Dictionary methodsFor: '*domains' stamp: 'len 11/30/2016 14:47:44'!
at: key add: value
	| index assoc |
	index _ self findElementOrNil: key.
	assoc _ array at: index.
	assoc
		ifNil:
			[value isZero ifFalse: [self atNewIndex: index put: (Association key: key value: value)]]
		ifNotNil:
			[|newValue|
			newValue _ assoc value + value.
			assoc value: newValue.
			^ newValue].
	^ value! !

!Dictionary methodsFor: '*domains' stamp: 'len 11/30/2016 14:47:14'!
at: key addAndRemoveIfZero: value
	| index assoc |
	index _ self findElementOrNil: key.
	assoc _ array at: index.
	assoc
		ifNil:
			[value isZero ifFalse: [self atNewIndex: index put: (Association key: key value: value)]]
		ifNotNil:
			[|newValue|
			newValue _ assoc value + value.
			newValue isZero
				ifTrue:
					[array at: index put: nil.
					tally _ tally - 1.
					self fixCollisionsFrom: index]
				ifFalse: [assoc value: newValue].
			^ newValue].
	^ value! !

!Dictionary methodsFor: '*domains' stamp: 'len 3/6/2017 19:54:46'!
printElementsOn: aStream
	aStream nextPut: ${.
	self keysSortedSafely do:
		[:key | aStream print: key; nextPutAll: '->'; print: (self at: key)] separatedBy: [aStream space].
	aStream nextPut: $}! !

!Point methodsFor: '*domains' stamp: 'len 2/25/2016 17:01'!
norm
	^ (x*x + (y*y)) sqrt! !

!Point methodsFor: '*domains' stamp: 'len 2/25/2016 17:00'!
norm2
	^ x*x + (y*y)! !

!StrikeFont class methodsFor: '*domains-character shapes' stamp: 'len 12/8/2016 12:11:12'!
buildMathFont
	"
	StrikeFont buildMathFont
	"
	#(5 6 7 8 9 10 11 12 13 14 17 22) do: [:pointSize| self buildMathFont: pointSize]! !

!StrikeFont class methodsFor: '*domains-character shapes' stamp: 'len 3/7/2017 08:00:46'!
buildMathFont: pointSize
	| font normal larger muchLarger |
	font _ AbstractFont familyName: 'DejaVu Sans Mono' pointSize: pointSize.
	font characterToGlyphMap at: 96 put: 28. "use left arrow instead of underscore"
	normal _ AbstractFont familyName: 'DejaVu' pointSize: pointSize.
"	#(1 0) detect: [:one| (slightlyLarger _ (AbstractFont familyName: 'DejaVu' pointSize: pointSize+one)) notNil]."
	#(2 1 3 0) detect: [:one| (larger _ (AbstractFont familyName: 'DejaVu' pointSize: pointSize+one)) notNil].
	#(4 3 2 1 0) detect: [:one| (muchLarger _ (AbstractFont familyName: 'DejaVu' pointSize: pointSize+one)) notNil].
	"replace some math glyphs with their normal counterpart, because the monospaced glyphs are far too small (and some are missing):"
	'' do: [:each|
		font takeAllGlyphFor: each from: each in: normal].
"	'' do: [:each|
		font takeAllGlyphFor: each from: each in: slightlyLarger].
"	'' do: [:each|
		font takeAllGlyphFor: each from: each in: larger].
	'' do: [:each|
		font takeAllGlyphFor: each from: each in: muchLarger].
	"make arrows bigger"
	'' do: [:each|
		font takeAllGlyphFor: each from: each in: larger]! !

!StrikeFont class methodsFor: '*domains-character shapes' stamp: 'len 3/7/2017 08:03:34'!
installMathFonts
"
StrikeFont installMathFonts
"
	| family codeFamily |
	StrikeFont install: 'DejaVu'.
	StrikeFont install: 'DejaVu Sans Mono'.
	StrikeFont buildMathFont.
	Character initialize.
	family _ 'DejaVu Sans Mono'.
	codeFamily _ 'DejaVu Sans Mono'.
	Preferences setDefaultFonts: {
		{#setSystemFontTo:. family. 10}.
		{#setListFontTo:. family. 10}.
		{#setMenuFontTo:. family. 9}.
		{#setWindowTitleFontTo:. family. 10}.
		{#setCodeFontTo:. codeFamily. 10}.
		{#setButtonFontTo:. family. 9}}.
	DisplayScreen runningWorld ifNotNil: [ :world | world fontPreferenceChanged ].
! !

!Morph methodsFor: '*domains' stamp: 'len 12/5/2016 11:59:49'!
findA: aClass
	^ self findDeepSubmorphThat: [:each| each isKindOf: aClass] ifAbsent: [self error: 'not found']! !
Digraph initialize!
Naturals initialize!
RationalField initialize!
GaloisRing initialize!
RationalIntegerRing initialize!
ComplexField initialize!
RealField initialize!
UpperHalfPlane initialize!
BitTuple initialize!
