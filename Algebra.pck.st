'From Cuis6.3 [latest update: #6222] on 5 September 2024 at 11:25:45 am'!
'Description This package implements among other things: permutation groups, linear groups, modular integers, finite fields, Galois rings, polynomial rings, affine algebras, number fields, function fields, finitely presented modules, chain complexes, finite (finitely generated as modules) associative algebras, schemes, and coherent sheaves.

References:
[ABPR19] John Abbott; Anna Maria Bigatti; Elisa Palezzato; Lorenzo Robbiano; "Computaing and Using Minimal Polynomials" (2019)
[AL94] William W. Adams; Philippe Loustaunau; "An Introduction To Groebner Bases", GSM Vol 3, AMS (1994)
[Ade73] Murray Adelman; "Abelian categories over additive ones" (1973)
[ABH08] Martin Albrecht, Gregory Bard, William Hard, "Efficient Multiplication of Dense Matrices over GF(2)" (2008)
[ADL06] Nadia Ben Atti, Gema M. Diaz-Toca, Henri Lombardi, "The Berlekamp-Massey Algorithm Revisited" (2006)
[Bar06] Gregory Bard, "Accelerating Cryptanalysis with the Method of Four Russians" (2006)
[BLH11] Mohamed Barakat; Markus Lange-Hegermann; "An Axiomatic Setup for Algorithmic Homological Algebra and an Alternative Approach to Localization" (2017)
[BW93] Thomas Becker; Volker Weispfenning; "Groebner Bases: A Computational Approach to Commutative Algebra" (1993)
[BF15] Bini, G.; Flamini, F. "Finite commutative rings and their applications" (2015)
[BB09] Thomas J. Boothy, Robert W. Bradshaw; "Bitslicing and the Method of Four Russians over Larger Finite Fields" (2009)
[BCS97] Wieb Bosma; John Cannon; Allan Steel; "Lattices of Compatibly Embedded Finite Fields", J. Symbolic Computation (1997) 24, 351-369
[BDPZ07] Brice Boyer; Jean-Guillaume Dumas; Clement Pernet; Wei Zhou; "Memory Efficient Scheduling of Strassen-Winograd''s Matrix Multiplication Algorithm" (2007)
[BK78] R. P. Brent; H. T. Kung; "Fast algorithms for manipulating formal power series" (1978)
[BP19] Martin Bies, Sebastian Posur; "Tensor Products of Finitely Presented Functors" (2019)
[Coh96] Henri Cohen, "A Course in Computational Algebraic Number Theory" (1996)
[Coh+05] Henri Cohen et al, "Handbook of elliptic and hyperelliptic curve cryptography" (2005)
[CLO97] David Cox; John Little; Donals O''Shea; "Ideals, Varieties and Algorithms", UTM, Springer, 1997
[CLO05] David Cox; John Little; Donals O''Shea; "Using Algebraic Geometry", GTM, Springer, 2005
[CZ81] D.G. Cantor; H. Zassenhaus; "A new Algorithm for Factoring Polynomials over Finite Fields" (1981)
[DK02] Harm Derksen; Gregor Kemper; "Computational Invariant Theory" (2002)
[Dix82] John D. Dixon, "Exact Solution of Linear Equations Using p-Adic Expansions" (1982)
[Dum18] Jean-Guillaume Dumas; "On Newton-Raphson iteration for multiplicative inverses modulo prime powers" (2018)
[Ebe89] Wayne Eberly; "Computations for Algebras and Group Representations" (1989)
[Eis95] David Eisenbud; "Commutative Algebra With a View Towards Algebraic Geometry", GTM 150, Springer, 1995
[EH99] David Eisenbud; Joe Harris; "The Geometry of Schemes", GTM 197, Springer, 1999
[ESS02] David Eisenbud; D. Grayson; M. Stillman; B. Sturmfels; "Computations in Algebraic Geometry with Macaulay 2" (2002)
[EIP00] Michele Elia; J. Carmelo Interlando; Reginaldo Palazzo Jr.; "Computing the reciprocal of units in Galois rings" (2000)
[EH19] Christian Eder; Tommy Hofmann; "Efficient Groebner Bases Computation over Principal Ideal Rings" (2019)
[EPP18] Christian Eder; Gerhard Pfister; Adrian Popescu; "Standard Bases over Euclidean Domains" (2018)
[Fie71] D. E. Fields; "Zero divisors and nilpotent elements in power series rings" (1971)
[FH16] Claus Flieker, Tommy Hofmann, "Computing in quotients of rings of integers" (2016)
[Fle69] Fletcher, C. R., "Unique Factorization Rings" (1969)
[Gal78] Steven Galovich, "Unique Factorization Rings with Zero Divisors" (1978)
[GM73] Ganske, G.; McDonald, B.R. "Finite local rings". Rocky Mountain J. Math. 3 (1973), no. 4, 521-540
[GP97] Shuhong Gao; Daniel Panario; "Tests and Constructions of Irreducible Polynomials over Finite Fields" (1997)
[GCL92] Keith O. Geddes, Stephen R. Czapor, and George Labahn; "Algorithms for Computer Algebra" (1992)
[GP08] Gert-Martin Greuel; Gerhard Pfister; "A Singular Introduction to Commutative Algebra" (2008)
[Gra53] Frank Gray, "Pulse Code Communication" (1953)
[Har11] William B. Hart; "A one line factoring algorithm" (2011)
[Har77] Robin Hartshorne; "Algebraic Geometry", GTM 52, Springer, 1977
[HEO05] Derek F. Holt; B. Eick; E. A. O''Brien; "Handbook of Computational Group Theory" (2005)
[HH11] Jurgen Herzog, Takayuki Hibi, "Monomial Ideals" (2011)
[Hil66] Peter Hilton, "Correspondences and Exact Squares" (1966)
[How86] John A. Howell, "Spans in the module (Z/mZ)^s" (1986)
[HLJJ+96] Steven Huss-Lederman; Elain M. Jacobson; Jeremy R. Johnson; Anna Tsao; Thomas Turnbull; "Implementation of Strassen''s Algorithm for Matrix Multiplication" (1996)
[KY86] Mitsuo Kanemitsu; Ken-ichi Yoshida; "Euclidean rings" (1986)
[KSWZ17] Deepak Kapur, Yao Sun, Dingkang Wang, Jie Zhou, "The Generalized Rabinowitsch Trick" (2017)
[Kem11] Gregor Kemper; "A Course in Commutative Algebra", GTM 256, Springer, 2011
[Kle70] Klein, A., Relations in categories", Illinois Journal of Mathematics, 14(4), 536-550 (1970)
[LN16] Patrick Longa, Michael Naehrig; "Speeding up the Number Theoretic Transform for Faster Ideal Lattice-Based Cryptography" (2016)
[MM76] J. M. Masley; H. L. Montgomery; "Cyclotomic fields with unique factorization" (1976)
[Mat11] Keith Matthews, "Solving AX=B using the Hermite normal form" (2011)
[McC42] N. H. McCoy; "Remarks on divisors of zero" (1942)
[McD74] Bernard R. McDonald; "Finite Rings with Identity" (1974)
[Mil04] Victor S. Miller; "The Weil Pairing, and Its Efficient Calculation" (2004)
[Mis93] Mishra, B; "Algorithmic Algebra", Springer, Monographs in Computer Science, 1993
[Mon04] Michael Monagan; "Maximal Quotient Rational Reconstruction: An Almost Optimal Algorithm for Rational Reconstructoin" (2004)
[Mon05] Peter L. Montgomery; "Five, Six, and Seven-Term Karatsuba-Like Formulae" (2005)
[PS09] Clement Pernet; William Stein; "Fast computation of Hermite normal forms of random integer matrices" (2009)
[PH78] S. Pohlig; M. Hellman; "An Improved Algorithm for Computing Logarithms over GF(p) and its Cryptographic Significance" (1978)
[Pol78] J. M. Pollard; "Monte Carlo Methods for Index Computation (mod p)", Mathematics of Computation, Volume 32, 1978
[Pos17] Sebastian Posur; "Linear Systems over Localizations of Rings" (2017)
[Pos17b] Sebastian Posur; "Constructive category theory and applications to equivariant sheaves" (2017)
[Pos17c] Sebastian Posur; "On Free Abelian Categories for Theorem Prooving" (2017)
[Pos19] Sebastian Posur; "Methods of constructive category theory" (2019)
[Pos20] Sebastian Posur; "A constructive approach to Freyd categories" (2020)
[SY09] Michael Sagraloff, Chee K. Yap, "An Efficient and Exact Subdivision Algorithm for Isolating Complex Roots of a Polynomial and its Complexity Analysis" (2009)
[Sam71] Pierre Samuel, "About Euclidean Rings", J. Algebra, 19:282-301, 1971
[San11] Metod Saniga; "Projective Lines over Finite Rings", 2011
[Ser03] Akos Seress; "Permutation Group Algorithms", 2003
[SOoS01] Richard Schroeppel; Hilarie Orman; Sean O''Malley; Oliver Spatscheck; "Fast Key Exchange with Elliptic Curve Systems" (2001)
[Sha71] Daniel Shanks; "Class number, a theory of factorization and genera" (1971)
[Sho09] Victor Shoup; "A Computational Introduction to Number Theory and Algebra" (2009)
[Sil08] Joseph. H. Silverman; "The Arithmetic of Elliptic Curves"; 2nd Edition (2008)
[Sim70] Charles C. Sims, "Computational methods in the study of permutation groups" (1970)
[Sti06] Michael Stillman; "Computing with sheaves and sheaf cohomology in algebraic geometry" (2006)
[SM98] Arne Storjohann, Thom Mulders, "Fast algorithms for linear algebra modulo N" (1998)
[Sto00] Arne Storjohann, "Algorithms for Matrix Canonical Forms" (2000)
[Teo16] Iuliana C. Teodorescu, "Algorithms for finite rings" (2016)
[Vak17] Ravi Vakil, "The Rising Sea: Foundations of Algebraic Geometry" (2017)
[vzGG13] Joachim von zur Gathen; Jurgen Gerhard; "Modern Computer Algebra", 3rd edition (2013)
[War02] Henry S. Warren, "Hacker''s Delight". Addision-Wesley Longman Publishing Co., Inc., Boston, MA, USA, 2002
[Zip93] Richard E. Zippel, "Effective Polynomial Computation" (1993)

[] John Cremona; "Algorithms for Modular Elliptic Curves"
[] Dimitry Kozlov; "Combinatorial Algebraic Topology"
[] Martin Kreuzer; "Computational Commutative Algebra"
[] Henri Lombardi; Claude Quitte; "Commutative Algebra: Constructive Methods, Finite Projective Modules"
[] Ezra Miller; Bernd Sturmfels; "Combinatorial Commutative Algebra"
[] Qing Liu; "Algebraic Geometry and Arithmetic Curves"
'!
!provides: 'Algebra' 1 206!
!requires: 'Graphs' 1 0 nil!
!requires: 'Collections-TwoAndEightByteArrays' 1 1 nil!
!requires: 'Complex' 1 7 nil!
!requires: 'Collections-Extras' 1 1 nil!
!requires: 'GAS' 1 1 nil!
!requires: 'Transfinites' 1 2 nil!
SystemOrganization addCategory: #'Algebra-Categories'!
SystemOrganization addCategory: #'Algebra-Categories-Comma'!
SystemOrganization addCategory: #'Algebra-Categories-Internal'!
SystemOrganization addCategory: #'Algebra-Categories-Abelian'!
SystemOrganization addCategory: #'Algebra-Sets'!
SystemOrganization addCategory: #'Algebra-Monoids'!
SystemOrganization addCategory: #'Algebra-Monoids-Orderings'!
SystemOrganization addCategory: #'Algebra-Groups'!
SystemOrganization addCategory: #'Algebra-Groups-Permutations'!
SystemOrganization addCategory: #'Algebra-Groups-Linear'!
SystemOrganization addCategory: #'Algebra-Rings'!
SystemOrganization addCategory: #'Algebra-Fields-Finite'!
SystemOrganization addCategory: #'Algebra-Fields-Algebraic'!
SystemOrganization addCategory: #'Algebra-Fields-Cyclotomic'!
SystemOrganization addCategory: #'Algebra-Fields-Quadratic'!
SystemOrganization addCategory: #'Algebra-Modules'!
SystemOrganization addCategory: #'Algebra-Modules-Orderings'!
SystemOrganization addCategory: #'Algebra-Modules-Multilinear'!
SystemOrganization addCategory: #'Algebra-Modules-Graded'!
SystemOrganization addCategory: #'Algebra-Algebras-Affine'!
SystemOrganization addCategory: #'Algebra-Algebras-Finite'!
SystemOrganization addCategory: #'Algebra-Algebras-Free'!
SystemOrganization addCategory: #'Algebra-Schemes'!
SystemOrganization addCategory: #'Algebra-Schemes-Affine Space'!
SystemOrganization addCategory: #'Algebra-Schemes-Projective Space'!
SystemOrganization addCategory: #'Algebra-Simplicial Complexes'!
SystemOrganization addCategory: #'Algebra-Algorithms'!
SystemOrganization addCategory: #'Algebra-Algorithms-Arrays'!
SystemOrganization addCategory: #'Algebra-Algorithms-Echelonization'!
SystemOrganization addCategory: #'Algebra-Algorithms-Standard Bases'!


!classDefinition: #BinaryArray category: #'Algebra-Algorithms-Arrays'!
ArrayedCollection subclass: #BinaryArray
	instanceVariableNames: 'words size'
	classVariableNames: 'ByteSquares One Zero'
	poolDictionaries: ''
	category: 'Algebra-Algorithms-Arrays'!
!classDefinition: 'BinaryArray class' category: #'Algebra-Algorithms-Arrays'!
BinaryArray class
	instanceVariableNames: ''!

!classDefinition: #ExtensionPackedArray category: #'Algebra-Algorithms-Arrays'!
ArrayedCollection subclass: #ExtensionPackedArray
	instanceVariableNames: 'coefficients scalars'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algorithms-Arrays'!
!classDefinition: 'ExtensionPackedArray class' category: #'Algebra-Algorithms-Arrays'!
ExtensionPackedArray class
	instanceVariableNames: ''!

!classDefinition: #ExtensionSlicedArray category: #'Algebra-Algorithms-Arrays'!
ArrayedCollection subclass: #ExtensionSlicedArray
	instanceVariableNames: 'slices scalars'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algorithms-Arrays'!
!classDefinition: 'ExtensionSlicedArray class' category: #'Algebra-Algorithms-Arrays'!
ExtensionSlicedArray class
	instanceVariableNames: ''!

!classDefinition: #BinaryExtensionArray category: #'Algebra-Algorithms-Arrays'!
ExtensionSlicedArray subclass: #BinaryExtensionArray
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algorithms-Arrays'!
!classDefinition: 'BinaryExtensionArray class' category: #'Algebra-Algorithms-Arrays'!
BinaryExtensionArray class
	instanceVariableNames: ''!

!classDefinition: #ModularArray category: #'Algebra-Algorithms-Arrays'!
ArrayedCollection subclass: #ModularArray
	instanceVariableNames: 'representatives scalars'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algorithms-Arrays'!
!classDefinition: 'ModularArray class' category: #'Algebra-Algorithms-Arrays'!
ModularArray class
	instanceVariableNames: ''!

!classDefinition: #ProductArray category: #'Algebra-Algorithms-Arrays'!
ArrayedCollection subclass: #ProductArray
	instanceVariableNames: 'components scalars'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algorithms-Arrays'!
!classDefinition: 'ProductArray class' category: #'Algebra-Algorithms-Arrays'!
ProductArray class
	instanceVariableNames: ''!

!classDefinition: #TernaryArray category: #'Algebra-Algorithms-Arrays'!
ArrayedCollection subclass: #TernaryArray
	instanceVariableNames: 'words₀ words₁ size'
	classVariableNames: 'MinusOne One Zero'
	poolDictionaries: ''
	category: 'Algebra-Algorithms-Arrays'!
!classDefinition: 'TernaryArray class' category: #'Algebra-Algorithms-Arrays'!
TernaryArray class
	instanceVariableNames: ''!

!classDefinition: #Simplex category: #'Algebra-Simplicial Complexes'!
Collection subclass: #Simplex
	instanceVariableNames: 'vertices'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Simplicial Complexes'!
!classDefinition: 'Simplex class' category: #'Algebra-Simplicial Complexes'!
Simplex class
	instanceVariableNames: ''!

!classDefinition: #DivisibilityError category: #'Algebra-Rings'!
ArithmeticMessageError subclass: #DivisibilityError
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Rings'!
!classDefinition: 'DivisibilityError class' category: #'Algebra-Rings'!
DivisibilityError class
	instanceVariableNames: ''!

!classDefinition: #Domain category: #'Algebra-Categories'!
Object subclass: #Domain
	instanceVariableNames: 'properties'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Categories'!
!classDefinition: 'Domain class' category: #'Algebra-Categories'!
Domain class
	instanceVariableNames: ''!

!classDefinition: #OppositeObject category: #'Algebra-Categories'!
Domain subclass: #OppositeObject
	instanceVariableNames: 'reverse'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Categories'!
!classDefinition: 'OppositeObject class' category: #'Algebra-Categories'!
OppositeObject class
	instanceVariableNames: ''!

!classDefinition: #Presheaf category: #'Algebra-Categories'!
Domain subclass: #Presheaf
	instanceVariableNames: 'functor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Categories'!
!classDefinition: 'Presheaf class' category: #'Algebra-Categories'!
Presheaf class
	instanceVariableNames: ''!

!classDefinition: #ProductObject category: #'Algebra-Categories'!
Domain subclass: #ProductObject
	instanceVariableNames: 'components'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Categories'!
!classDefinition: 'ProductObject class' category: #'Algebra-Categories'!
ProductObject class
	instanceVariableNames: ''!

!classDefinition: #Structure category: #'Algebra-Categories'!
Domain subclass: #Structure
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Categories'!
!classDefinition: 'Structure class' category: #'Algebra-Categories'!
Structure class
	instanceVariableNames: ''!

!classDefinition: #Category category: #'Algebra-Categories'!
Structure subclass: #Category
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Categories'!
!classDefinition: 'Category class' category: #'Algebra-Categories'!
Category class
	instanceVariableNames: ''!

!classDefinition: #FreeCategory category: #'Algebra-Categories'!
Category subclass: #FreeCategory
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Categories'!
!classDefinition: 'FreeCategory class' category: #'Algebra-Categories'!
FreeCategory class
	instanceVariableNames: ''!

!classDefinition: #FunctorCategory category: #'Algebra-Categories'!
Category subclass: #FunctorCategory
	instanceVariableNames: 'domain codomain'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Categories'!
!classDefinition: 'FunctorCategory class' category: #'Algebra-Categories'!
FunctorCategory class
	instanceVariableNames: ''!

!classDefinition: #OppositeCategory category: #'Algebra-Categories'!
Category subclass: #OppositeCategory
	instanceVariableNames: 'opposite'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Categories'!
!classDefinition: 'OppositeCategory class' category: #'Algebra-Categories'!
OppositeCategory class
	instanceVariableNames: ''!

!classDefinition: #ProductCategory category: #'Algebra-Categories'!
Category subclass: #ProductCategory
	instanceVariableNames: 'components'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Categories'!
!classDefinition: 'ProductCategory class' category: #'Algebra-Categories'!
ProductCategory class
	instanceVariableNames: ''!

!classDefinition: #CommaCategory category: #'Algebra-Categories-Comma'!
Category subclass: #CommaCategory
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Categories-Comma'!
!classDefinition: 'CommaCategory class' category: #'Algebra-Categories-Comma'!
CommaCategory class
	instanceVariableNames: ''!

!classDefinition: #ArrowCategory category: #'Algebra-Categories-Comma'!
CommaCategory subclass: #ArrowCategory
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Categories-Comma'!
!classDefinition: 'ArrowCategory class' category: #'Algebra-Categories-Comma'!
ArrowCategory class
	instanceVariableNames: ''!

!classDefinition: #SliceCategory category: #'Algebra-Categories-Comma'!
CommaCategory subclass: #SliceCategory
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Categories-Comma'!
!classDefinition: 'SliceCategory class' category: #'Algebra-Categories-Comma'!
SliceCategory class
	instanceVariableNames: ''!

!classDefinition: #BimonoidCategory category: #'Algebra-Categories-Internal'!
Category subclass: #BimonoidCategory
	instanceVariableNames: 'base'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Categories-Internal'!
!classDefinition: 'BimonoidCategory class' category: #'Algebra-Categories-Internal'!
BimonoidCategory class
	instanceVariableNames: ''!

!classDefinition: #GroupCategory category: #'Algebra-Categories-Internal'!
Category subclass: #GroupCategory
	instanceVariableNames: 'base'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Categories-Internal'!
!classDefinition: 'GroupCategory class' category: #'Algebra-Categories-Internal'!
GroupCategory class
	instanceVariableNames: ''!

!classDefinition: #ModuleCategory category: #'Algebra-Categories-Internal'!
Category subclass: #ModuleCategory
	instanceVariableNames: 'scalars'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Categories-Internal'!
!classDefinition: 'ModuleCategory class' category: #'Algebra-Categories-Internal'!
ModuleCategory class
	instanceVariableNames: ''!

!classDefinition: #MonoidCategory category: #'Algebra-Categories-Internal'!
Category subclass: #MonoidCategory
	instanceVariableNames: 'base'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Categories-Internal'!
!classDefinition: 'MonoidCategory class' category: #'Algebra-Categories-Internal'!
MonoidCategory class
	instanceVariableNames: ''!

!classDefinition: #ChainComplexesCategory category: #'Algebra-Categories-Abelian'!
Category subclass: #ChainComplexesCategory
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Categories-Abelian'!
!classDefinition: 'ChainComplexesCategory class' category: #'Algebra-Categories-Abelian'!
ChainComplexesCategory class
	instanceVariableNames: ''!

!classDefinition: #FreydCategory category: #'Algebra-Categories-Abelian'!
Category subclass: #FreydCategory
	instanceVariableNames: 'ground'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Categories-Abelian'!
!classDefinition: 'FreydCategory class' category: #'Algebra-Categories-Abelian'!
FreydCategory class
	instanceVariableNames: ''!

!classDefinition: #GradedObjectsCategory category: #'Algebra-Categories-Abelian'!
Category subclass: #GradedObjectsCategory
	instanceVariableNames: 'ground indices'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Categories-Abelian'!
!classDefinition: 'GradedObjectsCategory class' category: #'Algebra-Categories-Abelian'!
GradedObjectsCategory class
	instanceVariableNames: ''!

!classDefinition: #RelationsCategory category: #'Algebra-Categories-Abelian'!
Category subclass: #RelationsCategory
	instanceVariableNames: 'ground'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Categories-Abelian'!
!classDefinition: 'RelationsCategory class' category: #'Algebra-Categories-Abelian'!
RelationsCategory class
	instanceVariableNames: ''!

!classDefinition: #FPModuleCategory category: #'Algebra-Modules'!
Category subclass: #FPModuleCategory
	instanceVariableNames: 'scalars'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Modules'!
!classDefinition: 'FPModuleCategory class' category: #'Algebra-Modules'!
FPModuleCategory class
	instanceVariableNames: ''!

!classDefinition: #CoherentSheavesCategory category: #'Algebra-Schemes'!
Category subclass: #CoherentSheavesCategory
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Schemes'!
!classDefinition: 'CoherentSheavesCategory class' category: #'Algebra-Schemes'!
CoherentSheavesCategory class
	instanceVariableNames: ''!

!classDefinition: #SetObject category: #'Algebra-Sets'!
Structure subclass: #SetObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Sets'!
!classDefinition: 'SetObject class' category: #'Algebra-Sets'!
SetObject class
	instanceVariableNames: ''!

!classDefinition: #CartesianProduct category: #'Algebra-Sets'!
SetObject subclass: #CartesianProduct
	instanceVariableNames: 'components'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Sets'!
!classDefinition: 'CartesianProduct class' category: #'Algebra-Sets'!
CartesianProduct class
	instanceVariableNames: ''!

!classDefinition: #HomSet category: #'Algebra-Sets'!
SetObject subclass: #HomSet
	instanceVariableNames: 'domain codomain'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Sets'!
!classDefinition: 'HomSet class' category: #'Algebra-Sets'!
HomSet class
	instanceVariableNames: ''!

!classDefinition: #RationalPointSet category: #'Algebra-Schemes'!
HomSet subclass: #RationalPointSet
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Schemes'!
!classDefinition: 'RationalPointSet class' category: #'Algebra-Schemes'!
RationalPointSet class
	instanceVariableNames: ''!

!classDefinition: #Naturals category: #'Algebra-Sets'!
SetObject subclass: #Naturals
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Sets'!
!classDefinition: 'Naturals class' category: #'Algebra-Sets'!
Naturals class
	instanceVariableNames: ''!

!classDefinition: #Monoid category: #'Algebra-Monoids'!
Structure subclass: #Monoid
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Monoids'!
!classDefinition: 'Monoid class' category: #'Algebra-Monoids'!
Monoid class
	instanceVariableNames: ''!

!classDefinition: #EndomorphismMonoid category: #'Algebra-Monoids'!
Monoid subclass: #EndomorphismMonoid
	instanceVariableNames: 'space'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Monoids'!
!classDefinition: 'EndomorphismMonoid class' category: #'Algebra-Monoids'!
EndomorphismMonoid class
	instanceVariableNames: ''!

!classDefinition: #FreeAbelianMonoid category: #'Algebra-Monoids'!
Monoid subclass: #FreeAbelianMonoid
	instanceVariableNames: 'rank ordering'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Monoids'!
!classDefinition: 'FreeAbelianMonoid class' category: #'Algebra-Monoids'!
FreeAbelianMonoid class
	instanceVariableNames: ''!

!classDefinition: #FreeMonoid category: #'Algebra-Monoids'!
Monoid subclass: #FreeMonoid
	instanceVariableNames: 'rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Monoids'!
!classDefinition: 'FreeMonoid class' category: #'Algebra-Monoids'!
FreeMonoid class
	instanceVariableNames: ''!

!classDefinition: #Group category: #'Algebra-Groups'!
Structure subclass: #Group
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Groups'!
!classDefinition: 'Group class' category: #'Algebra-Groups'!
Group class
	instanceVariableNames: ''!

!classDefinition: #AbelianGroup category: #'Algebra-Groups'!
Group subclass: #AbelianGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Groups'!
!classDefinition: 'AbelianGroup class' category: #'Algebra-Groups'!
AbelianGroup class
	instanceVariableNames: ''!

!classDefinition: #HomGroup category: #'Algebra-Groups'!
AbelianGroup subclass: #HomGroup
	instanceVariableNames: 'domain codomain'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Groups'!
!classDefinition: 'HomGroup class' category: #'Algebra-Groups'!
HomGroup class
	instanceVariableNames: ''!

!classDefinition: #DivisorGroup category: #'Algebra-Schemes'!
AbelianGroup subclass: #DivisorGroup
	instanceVariableNames: 'scalars space'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Schemes'!
!classDefinition: 'DivisorGroup class' category: #'Algebra-Schemes'!
DivisorGroup class
	instanceVariableNames: ''!

!classDefinition: #AutomorphismGroup category: #'Algebra-Groups'!
Group subclass: #AutomorphismGroup
	instanceVariableNames: 'space'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Groups'!
!classDefinition: 'AutomorphismGroup class' category: #'Algebra-Groups'!
AutomorphismGroup class
	instanceVariableNames: ''!

!classDefinition: #FreeGroup category: #'Algebra-Groups'!
Group subclass: #FreeGroup
	instanceVariableNames: 'rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Groups'!
!classDefinition: 'FreeGroup class' category: #'Algebra-Groups'!
FreeGroup class
	instanceVariableNames: ''!

!classDefinition: #ProductGroup category: #'Algebra-Groups'!
Group subclass: #ProductGroup
	instanceVariableNames: 'components'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Groups'!
!classDefinition: 'ProductGroup class' category: #'Algebra-Groups'!
ProductGroup class
	instanceVariableNames: ''!

!classDefinition: #QuotientGroup category: #'Algebra-Groups'!
Group subclass: #QuotientGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Groups'!
!classDefinition: 'QuotientGroup class' category: #'Algebra-Groups'!
QuotientGroup class
	instanceVariableNames: ''!

!classDefinition: #SemidirectProductGroup category: #'Algebra-Groups'!
Group subclass: #SemidirectProductGroup
	instanceVariableNames: 'left right action'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Groups'!
!classDefinition: 'SemidirectProductGroup class' category: #'Algebra-Groups'!
SemidirectProductGroup class
	instanceVariableNames: ''!

!classDefinition: #PermutationGroup category: #'Algebra-Groups-Permutations'!
Group subclass: #PermutationGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Groups-Permutations'!
!classDefinition: 'PermutationGroup class' category: #'Algebra-Groups-Permutations'!
PermutationGroup class
	instanceVariableNames: ''!

!classDefinition: #AlternatingGroup category: #'Algebra-Groups-Permutations'!
PermutationGroup subclass: #AlternatingGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Groups-Permutations'!
!classDefinition: 'AlternatingGroup class' category: #'Algebra-Groups-Permutations'!
AlternatingGroup class
	instanceVariableNames: ''!

!classDefinition: #SymmetricGroup category: #'Algebra-Groups-Permutations'!
PermutationGroup subclass: #SymmetricGroup
	instanceVariableNames: 'degree'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Groups-Permutations'!
!classDefinition: 'SymmetricGroup class' category: #'Algebra-Groups-Permutations'!
SymmetricGroup class
	instanceVariableNames: ''!

!classDefinition: #LinearGroup category: #'Algebra-Groups-Linear'!
Group subclass: #LinearGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Groups-Linear'!
!classDefinition: 'LinearGroup class' category: #'Algebra-Groups-Linear'!
LinearGroup class
	instanceVariableNames: ''!

!classDefinition: #GeneralLinearGroup category: #'Algebra-Groups-Linear'!
LinearGroup subclass: #GeneralLinearGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Groups-Linear'!
!classDefinition: 'GeneralLinearGroup class' category: #'Algebra-Groups-Linear'!
GeneralLinearGroup class
	instanceVariableNames: ''!

!classDefinition: #OrthogonalGroup category: #'Algebra-Groups-Linear'!
LinearGroup subclass: #OrthogonalGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Groups-Linear'!
!classDefinition: 'OrthogonalGroup class' category: #'Algebra-Groups-Linear'!
OrthogonalGroup class
	instanceVariableNames: ''!

!classDefinition: #ScalarGroup category: #'Algebra-Groups-Linear'!
LinearGroup subclass: #ScalarGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Groups-Linear'!
!classDefinition: 'ScalarGroup class' category: #'Algebra-Groups-Linear'!
ScalarGroup class
	instanceVariableNames: ''!

!classDefinition: #SpecialLinearGroup category: #'Algebra-Groups-Linear'!
LinearGroup subclass: #SpecialLinearGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Groups-Linear'!
!classDefinition: 'SpecialLinearGroup class' category: #'Algebra-Groups-Linear'!
SpecialLinearGroup class
	instanceVariableNames: ''!

!classDefinition: #SpecialOrthogonalGroup category: #'Algebra-Groups-Linear'!
LinearGroup subclass: #SpecialOrthogonalGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Groups-Linear'!
!classDefinition: 'SpecialOrthogonalGroup class' category: #'Algebra-Groups-Linear'!
SpecialOrthogonalGroup class
	instanceVariableNames: ''!

!classDefinition: #SpecialScalarGroup category: #'Algebra-Groups-Linear'!
LinearGroup subclass: #SpecialScalarGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Groups-Linear'!
!classDefinition: 'SpecialScalarGroup class' category: #'Algebra-Groups-Linear'!
SpecialScalarGroup class
	instanceVariableNames: ''!

!classDefinition: #UnitGroup category: #'Algebra-Rings'!
Group subclass: #UnitGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Rings'!
!classDefinition: 'UnitGroup class' category: #'Algebra-Rings'!
UnitGroup class
	instanceVariableNames: ''!

!classDefinition: #Ring category: #'Algebra-Rings'!
Structure subclass: #Ring
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Rings'!
!classDefinition: 'Ring class' category: #'Algebra-Rings'!
Ring class
	instanceVariableNames: ''!

!classDefinition: #EndomorphismRing category: #'Algebra-Rings'!
Ring subclass: #EndomorphismRing
	instanceVariableNames: 'space'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Rings'!
!classDefinition: 'EndomorphismRing class' category: #'Algebra-Rings'!
EndomorphismRing class
	instanceVariableNames: ''!

!classDefinition: #MatrixRing category: #'Algebra-Rings'!
EndomorphismRing subclass: #MatrixRing
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Rings'!
!classDefinition: 'MatrixRing class' category: #'Algebra-Rings'!
MatrixRing class
	instanceVariableNames: ''!

!classDefinition: #FractionRing category: #'Algebra-Rings'!
Ring subclass: #FractionRing
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Rings'!
!classDefinition: 'FractionRing class' category: #'Algebra-Rings'!
FractionRing class
	instanceVariableNames: ''!

!classDefinition: #RationalField category: #'Algebra-Fields-Algebraic'!
FractionRing subclass: #RationalField
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Fields-Algebraic'!
!classDefinition: 'RationalField class' category: #'Algebra-Fields-Algebraic'!
RationalField class
	instanceVariableNames: ''!

!classDefinition: #RationalFunctionField category: #'Algebra-Fields-Algebraic'!
FractionRing subclass: #RationalFunctionField
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Fields-Algebraic'!
!classDefinition: 'RationalFunctionField class' category: #'Algebra-Fields-Algebraic'!
RationalFunctionField class
	instanceVariableNames: ''!

!classDefinition: #IntegerRing category: #'Algebra-Rings'!
Ring subclass: #IntegerRing
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Rings'!
!classDefinition: 'IntegerRing class' category: #'Algebra-Rings'!
IntegerRing class
	instanceVariableNames: ''!

!classDefinition: #LocalRing category: #'Algebra-Rings'!
Ring subclass: #LocalRing
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Rings'!
!classDefinition: 'LocalRing class' category: #'Algebra-Rings'!
LocalRing class
	instanceVariableNames: ''!

!classDefinition: #OppositeRing category: #'Algebra-Rings'!
Ring subclass: #OppositeRing
	instanceVariableNames: 'opposite'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Rings'!
!classDefinition: 'OppositeRing class' category: #'Algebra-Rings'!
OppositeRing class
	instanceVariableNames: ''!

!classDefinition: #ProductRing category: #'Algebra-Rings'!
Ring subclass: #ProductRing
	instanceVariableNames: 'components'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Rings'!
!classDefinition: 'ProductRing class' category: #'Algebra-Rings'!
ProductRing class
	instanceVariableNames: ''!

!classDefinition: #QuotientRing category: #'Algebra-Rings'!
Ring subclass: #QuotientRing
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Rings'!
!classDefinition: 'QuotientRing class' category: #'Algebra-Rings'!
QuotientRing class
	instanceVariableNames: ''!

!classDefinition: #ModularIntegerRing category: #'Algebra-Fields-Finite'!
QuotientRing subclass: #ModularIntegerRing
	instanceVariableNames: 'modulus'
	classVariableNames: 'Cache'
	poolDictionaries: ''
	category: 'Algebra-Fields-Finite'!
!classDefinition: 'ModularIntegerRing class' category: #'Algebra-Fields-Finite'!
ModularIntegerRing class
	instanceVariableNames: ''!

!classDefinition: #PrimePowerRing category: #'Algebra-Fields-Finite'!
ModularIntegerRing subclass: #PrimePowerRing
	instanceVariableNames: 'base'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Fields-Finite'!
!classDefinition: 'PrimePowerRing class' category: #'Algebra-Fields-Finite'!
PrimePowerRing class
	instanceVariableNames: ''!

!classDefinition: #PrimeField category: #'Algebra-Fields-Finite'!
PrimePowerRing subclass: #PrimeField
	instanceVariableNames: ''
	classVariableNames: 'ConwayPolynomials'
	poolDictionaries: ''
	category: 'Algebra-Fields-Finite'!
!classDefinition: 'PrimeField class' category: #'Algebra-Fields-Finite'!
PrimeField class
	instanceVariableNames: ''!

!classDefinition: #BinaryField category: #'Algebra-Fields-Finite'!
PrimeField subclass: #BinaryField
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Fields-Finite'!
!classDefinition: 'BinaryField class' category: #'Algebra-Fields-Finite'!
BinaryField class
	instanceVariableNames: ''!

!classDefinition: #TernaryField category: #'Algebra-Fields-Finite'!
PrimeField subclass: #TernaryField
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Fields-Finite'!
!classDefinition: 'TernaryField class' category: #'Algebra-Fields-Finite'!
TernaryField class
	instanceVariableNames: ''!

!classDefinition: #AffineAlgebra category: #'Algebra-Algebras-Affine'!
QuotientRing subclass: #AffineAlgebra
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algebras-Affine'!
!classDefinition: 'AffineAlgebra class' category: #'Algebra-Algebras-Affine'!
AffineAlgebra class
	instanceVariableNames: ''!

!classDefinition: #ExtensionRing category: #'Algebra-Algebras-Affine'!
AffineAlgebra subclass: #ExtensionRing
	instanceVariableNames: 'modulus'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algebras-Affine'!
!classDefinition: 'ExtensionRing class' category: #'Algebra-Algebras-Affine'!
ExtensionRing class
	instanceVariableNames: ''!

!classDefinition: #GaloisRing category: #'Algebra-Fields-Finite'!
ExtensionRing subclass: #GaloisRing
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Fields-Finite'!
!classDefinition: 'GaloisRing class' category: #'Algebra-Fields-Finite'!
GaloisRing class
	instanceVariableNames: ''!

!classDefinition: #GaloisField category: #'Algebra-Fields-Finite'!
GaloisRing subclass: #GaloisField
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Fields-Finite'!
!classDefinition: 'GaloisField class' category: #'Algebra-Fields-Finite'!
GaloisField class
	instanceVariableNames: ''!

!classDefinition: #FunctionField category: #'Algebra-Fields-Algebraic'!
ExtensionRing subclass: #FunctionField
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Fields-Algebraic'!
!classDefinition: 'FunctionField class' category: #'Algebra-Fields-Algebraic'!
FunctionField class
	instanceVariableNames: ''!

!classDefinition: #NumberField category: #'Algebra-Fields-Algebraic'!
ExtensionRing subclass: #NumberField
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Fields-Algebraic'!
!classDefinition: 'NumberField class' category: #'Algebra-Fields-Algebraic'!
NumberField class
	instanceVariableNames: ''!

!classDefinition: #CyclotomicField category: #'Algebra-Fields-Cyclotomic'!
NumberField subclass: #CyclotomicField
	instanceVariableNames: ''
	classVariableNames: 'Cache'
	poolDictionaries: ''
	category: 'Algebra-Fields-Cyclotomic'!
!classDefinition: 'CyclotomicField class' category: #'Algebra-Fields-Cyclotomic'!
CyclotomicField class
	instanceVariableNames: ''!

!classDefinition: #QuadraticField category: #'Algebra-Fields-Quadratic'!
NumberField subclass: #QuadraticField
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Fields-Quadratic'!
!classDefinition: 'QuadraticField class' category: #'Algebra-Fields-Quadratic'!
QuadraticField class
	instanceVariableNames: ''!

!classDefinition: #JetRing category: #'Algebra-Algebras-Affine'!
AffineAlgebra subclass: #JetRing
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algebras-Affine'!
!classDefinition: 'JetRing class' category: #'Algebra-Algebras-Affine'!
JetRing class
	instanceVariableNames: ''!

!classDefinition: #LaurentPolynomialRing category: #'Algebra-Algebras-Affine'!
AffineAlgebra subclass: #LaurentPolynomialRing
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algebras-Affine'!
!classDefinition: 'LaurentPolynomialRing class' category: #'Algebra-Algebras-Affine'!
LaurentPolynomialRing class
	instanceVariableNames: ''!

!classDefinition: #AlgebraicClosureField category: #'Algebra-Fields-Finite'!
Ring subclass: #AlgebraicClosureField
	instanceVariableNames: 'scalars'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Fields-Finite'!
!classDefinition: 'AlgebraicClosureField class' category: #'Algebra-Fields-Finite'!
AlgebraicClosureField class
	instanceVariableNames: ''!

!classDefinition: #ComplexAlgebraicField category: #'Algebra-Fields-Algebraic'!
Ring subclass: #ComplexAlgebraicField
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Fields-Algebraic'!
!classDefinition: 'ComplexAlgebraicField class' category: #'Algebra-Fields-Algebraic'!
ComplexAlgebraicField class
	instanceVariableNames: ''!

!classDefinition: #RealAlgebraicField category: #'Algebra-Fields-Algebraic'!
Ring subclass: #RealAlgebraicField
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Fields-Algebraic'!
!classDefinition: 'RealAlgebraicField class' category: #'Algebra-Fields-Algebraic'!
RealAlgebraicField class
	instanceVariableNames: ''!

!classDefinition: #AbelianClosureField category: #'Algebra-Fields-Cyclotomic'!
Ring subclass: #AbelianClosureField
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Fields-Cyclotomic'!
!classDefinition: 'AbelianClosureField class' category: #'Algebra-Fields-Cyclotomic'!
AbelianClosureField class
	instanceVariableNames: ''!

!classDefinition: #PolynomialRing category: #'Algebra-Algebras-Affine'!
Ring subclass: #PolynomialRing
	instanceVariableNames: 'monomials scalars'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algebras-Affine'!
!classDefinition: 'PolynomialRing class' category: #'Algebra-Algebras-Affine'!
PolynomialRing class
	instanceVariableNames: ''!

!classDefinition: #FiniteAlgebra category: #'Algebra-Algebras-Finite'!
Ring subclass: #FiniteAlgebra
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algebras-Finite'!
!classDefinition: 'FiniteAlgebra class' category: #'Algebra-Algebras-Finite'!
FiniteAlgebra class
	instanceVariableNames: ''!

!classDefinition: #Order category: #'Algebra-Fields-Algebraic'!
FiniteAlgebra subclass: #Order
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Fields-Algebraic'!
!classDefinition: 'Order class' category: #'Algebra-Fields-Algebraic'!
Order class
	instanceVariableNames: ''!

!classDefinition: #MaximalOrder category: #'Algebra-Fields-Algebraic'!
Order subclass: #MaximalOrder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Fields-Algebraic'!
!classDefinition: 'MaximalOrder class' category: #'Algebra-Fields-Algebraic'!
MaximalOrder class
	instanceVariableNames: ''!

!classDefinition: #CyclotomicRing category: #'Algebra-Fields-Cyclotomic'!
MaximalOrder subclass: #CyclotomicRing
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Fields-Cyclotomic'!
!classDefinition: 'CyclotomicRing class' category: #'Algebra-Fields-Cyclotomic'!
CyclotomicRing class
	instanceVariableNames: ''!

!classDefinition: #EisensteinRing category: #'Algebra-Fields-Cyclotomic'!
CyclotomicRing subclass: #EisensteinRing
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Fields-Cyclotomic'!
!classDefinition: 'EisensteinRing class' category: #'Algebra-Fields-Cyclotomic'!
EisensteinRing class
	instanceVariableNames: ''!

!classDefinition: #GaussianRing category: #'Algebra-Fields-Cyclotomic'!
CyclotomicRing subclass: #GaussianRing
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Fields-Cyclotomic'!
!classDefinition: 'GaussianRing class' category: #'Algebra-Fields-Cyclotomic'!
GaussianRing class
	instanceVariableNames: ''!

!classDefinition: #QuadraticRing category: #'Algebra-Fields-Quadratic'!
MaximalOrder subclass: #QuadraticRing
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Fields-Quadratic'!
!classDefinition: 'QuadraticRing class' category: #'Algebra-Fields-Quadratic'!
QuadraticRing class
	instanceVariableNames: ''!

!classDefinition: #CliffordAlgebra category: #'Algebra-Algebras-Finite'!
FiniteAlgebra subclass: #CliffordAlgebra
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algebras-Finite'!
!classDefinition: 'CliffordAlgebra class' category: #'Algebra-Algebras-Finite'!
CliffordAlgebra class
	instanceVariableNames: ''!

!classDefinition: #GroupAlgebra category: #'Algebra-Algebras-Finite'!
FiniteAlgebra subclass: #GroupAlgebra
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algebras-Finite'!
!classDefinition: 'GroupAlgebra class' category: #'Algebra-Algebras-Finite'!
GroupAlgebra class
	instanceVariableNames: ''!

!classDefinition: #QuaternionAlgebra category: #'Algebra-Algebras-Finite'!
FiniteAlgebra subclass: #QuaternionAlgebra
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algebras-Finite'!
!classDefinition: 'QuaternionAlgebra class' category: #'Algebra-Algebras-Finite'!
QuaternionAlgebra class
	instanceVariableNames: ''!

!classDefinition: #FreeAlgebra category: #'Algebra-Algebras-Free'!
Ring subclass: #FreeAlgebra
	instanceVariableNames: 'scalars monomials'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algebras-Free'!
!classDefinition: 'FreeAlgebra class' category: #'Algebra-Algebras-Free'!
FreeAlgebra class
	instanceVariableNames: ''!

!classDefinition: #Module category: #'Algebra-Modules'!
Structure subclass: #Module
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Modules'!
!classDefinition: 'Module class' category: #'Algebra-Modules'!
Module class
	instanceVariableNames: ''!

!classDefinition: #Ideal category: #'Algebra-Rings'!
Module subclass: #Ideal
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Rings'!
!classDefinition: 'Ideal class' category: #'Algebra-Rings'!
Ideal class
	instanceVariableNames: ''!

!classDefinition: #IntegralIdeal category: #'Algebra-Fields-Algebraic'!
Ideal subclass: #IntegralIdeal
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Fields-Algebraic'!
!classDefinition: 'IntegralIdeal class' category: #'Algebra-Fields-Algebraic'!
IntegralIdeal class
	instanceVariableNames: ''!

!classDefinition: #PolynomialIdeal category: #'Algebra-Algebras-Affine'!
Ideal subclass: #PolynomialIdeal
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algebras-Affine'!
!classDefinition: 'PolynomialIdeal class' category: #'Algebra-Algebras-Affine'!
PolynomialIdeal class
	instanceVariableNames: ''!

!classDefinition: #FreeModule category: #'Algebra-Modules'!
Module subclass: #FreeModule
	instanceVariableNames: 'scalars rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Modules'!
!classDefinition: 'FreeModule class' category: #'Algebra-Modules'!
FreeModule class
	instanceVariableNames: ''!

!classDefinition: #HomModule category: #'Algebra-Modules'!
Module subclass: #HomModule
	instanceVariableNames: 'domain codomain'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Modules'!
!classDefinition: 'HomModule class' category: #'Algebra-Modules'!
HomModule class
	instanceVariableNames: ''!

!classDefinition: #MatrixModule category: #'Algebra-Modules'!
HomModule subclass: #MatrixModule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Modules'!
!classDefinition: 'MatrixModule class' category: #'Algebra-Modules'!
MatrixModule class
	instanceVariableNames: ''!

!classDefinition: #QuotientModule category: #'Algebra-Modules'!
Module subclass: #QuotientModule
	instanceVariableNames: 'relationsMatrix'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Modules'!
!classDefinition: 'QuotientModule class' category: #'Algebra-Modules'!
QuotientModule class
	instanceVariableNames: ''!

!classDefinition: #Scheme category: #'Algebra-Schemes'!
Structure subclass: #Scheme
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Schemes'!
!classDefinition: 'Scheme class' category: #'Algebra-Schemes'!
Scheme class
	instanceVariableNames: ''!

!classDefinition: #Grassmannian category: #'Algebra-Modules'!
Scheme subclass: #Grassmannian
	instanceVariableNames: 'space rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Modules'!
!classDefinition: 'Grassmannian class' category: #'Algebra-Modules'!
Grassmannian class
	instanceVariableNames: ''!

!classDefinition: #AffineScheme category: #'Algebra-Schemes'!
Scheme subclass: #AffineScheme
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Schemes'!
!classDefinition: 'AffineScheme class' category: #'Algebra-Schemes'!
AffineScheme class
	instanceVariableNames: ''!

!classDefinition: #AffineVariety category: #'Algebra-Schemes-Affine Space'!
AffineScheme subclass: #AffineVariety
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Schemes-Affine Space'!
!classDefinition: 'AffineVariety class' category: #'Algebra-Schemes-Affine Space'!
AffineVariety class
	instanceVariableNames: ''!

!classDefinition: #AffineCurve category: #'Algebra-Schemes-Affine Space'!
AffineVariety subclass: #AffineCurve
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Schemes-Affine Space'!
!classDefinition: 'AffineCurve class' category: #'Algebra-Schemes-Affine Space'!
AffineCurve class
	instanceVariableNames: ''!

!classDefinition: #AffineHypersurface category: #'Algebra-Schemes-Affine Space'!
AffineVariety subclass: #AffineHypersurface
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Schemes-Affine Space'!
!classDefinition: 'AffineHypersurface class' category: #'Algebra-Schemes-Affine Space'!
AffineHypersurface class
	instanceVariableNames: ''!

!classDefinition: #AffinePlaneCurve category: #'Algebra-Schemes-Affine Space'!
AffineHypersurface subclass: #AffinePlaneCurve
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Schemes-Affine Space'!
!classDefinition: 'AffinePlaneCurve class' category: #'Algebra-Schemes-Affine Space'!
AffinePlaneCurve class
	instanceVariableNames: ''!

!classDefinition: #AffineSpace category: #'Algebra-Schemes-Affine Space'!
AffineVariety subclass: #AffineSpace
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Schemes-Affine Space'!
!classDefinition: 'AffineSpace class' category: #'Algebra-Schemes-Affine Space'!
AffineSpace class
	instanceVariableNames: ''!

!classDefinition: #ProjectiveScheme category: #'Algebra-Schemes'!
Scheme subclass: #ProjectiveScheme
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Schemes'!
!classDefinition: 'ProjectiveScheme class' category: #'Algebra-Schemes'!
ProjectiveScheme class
	instanceVariableNames: ''!

!classDefinition: #ProjectiveVariety category: #'Algebra-Schemes-Projective Space'!
ProjectiveScheme subclass: #ProjectiveVariety
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Schemes-Projective Space'!
!classDefinition: 'ProjectiveVariety class' category: #'Algebra-Schemes-Projective Space'!
ProjectiveVariety class
	instanceVariableNames: ''!

!classDefinition: #ProjectiveCurve category: #'Algebra-Schemes-Projective Space'!
ProjectiveVariety subclass: #ProjectiveCurve
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Schemes-Projective Space'!
!classDefinition: 'ProjectiveCurve class' category: #'Algebra-Schemes-Projective Space'!
ProjectiveCurve class
	instanceVariableNames: ''!

!classDefinition: #ProjectiveHypersurface category: #'Algebra-Schemes-Projective Space'!
ProjectiveVariety subclass: #ProjectiveHypersurface
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Schemes-Projective Space'!
!classDefinition: 'ProjectiveHypersurface class' category: #'Algebra-Schemes-Projective Space'!
ProjectiveHypersurface class
	instanceVariableNames: ''!

!classDefinition: #ProjectivePlaneCurve category: #'Algebra-Schemes-Projective Space'!
ProjectiveHypersurface subclass: #ProjectivePlaneCurve
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Schemes-Projective Space'!
!classDefinition: 'ProjectivePlaneCurve class' category: #'Algebra-Schemes-Projective Space'!
ProjectivePlaneCurve class
	instanceVariableNames: ''!

!classDefinition: #Conic category: #'Algebra-Schemes-Projective Space'!
ProjectivePlaneCurve subclass: #Conic
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Schemes-Projective Space'!
!classDefinition: 'Conic class' category: #'Algebra-Schemes-Projective Space'!
Conic class
	instanceVariableNames: ''!

!classDefinition: #RationalCurve category: #'Algebra-Schemes-Projective Space'!
ProjectivePlaneCurve subclass: #RationalCurve
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Schemes-Projective Space'!
!classDefinition: 'RationalCurve class' category: #'Algebra-Schemes-Projective Space'!
RationalCurve class
	instanceVariableNames: ''!

!classDefinition: #ProjectiveSpace category: #'Algebra-Schemes-Projective Space'!
ProjectiveVariety subclass: #ProjectiveSpace
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Schemes-Projective Space'!
!classDefinition: 'ProjectiveSpace class' category: #'Algebra-Schemes-Projective Space'!
ProjectiveSpace class
	instanceVariableNames: ''!

!classDefinition: #ProjectiveLine category: #'Algebra-Schemes-Projective Space'!
ProjectiveSpace subclass: #ProjectiveLine
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Schemes-Projective Space'!
!classDefinition: 'ProjectiveLine class' category: #'Algebra-Schemes-Projective Space'!
ProjectiveLine class
	instanceVariableNames: ''!

!classDefinition: #ProjectivePlane category: #'Algebra-Schemes-Projective Space'!
ProjectiveSpace subclass: #ProjectivePlane
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Schemes-Projective Space'!
!classDefinition: 'ProjectivePlane class' category: #'Algebra-Schemes-Projective Space'!
ProjectivePlane class
	instanceVariableNames: ''!

!classDefinition: #CellComplex category: #'Algebra-Simplicial Complexes'!
Structure subclass: #CellComplex
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Simplicial Complexes'!
!classDefinition: 'CellComplex class' category: #'Algebra-Simplicial Complexes'!
CellComplex class
	instanceVariableNames: ''!

!classDefinition: #SimplicialComplex category: #'Algebra-Simplicial Complexes'!
CellComplex subclass: #SimplicialComplex
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Simplicial Complexes'!
!classDefinition: 'SimplicialComplex class' category: #'Algebra-Simplicial Complexes'!
SimplicialComplex class
	instanceVariableNames: ''!

!classDefinition: #Vertex category: #'Algebra-Categories'!
Domain subclass: #Vertex
	instanceVariableNames: 'value neighbors category'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Categories'!
!classDefinition: 'Vertex class' category: #'Algebra-Categories'!
Vertex class
	instanceVariableNames: ''!

!classDefinition: #CommaObject category: #'Algebra-Categories-Comma'!
Domain subclass: #CommaObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Categories-Comma'!
!classDefinition: 'CommaObject class' category: #'Algebra-Categories-Comma'!
CommaObject class
	instanceVariableNames: ''!

!classDefinition: #ArrowObject category: #'Algebra-Categories-Comma'!
CommaObject subclass: #ArrowObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Categories-Comma'!
!classDefinition: 'ArrowObject class' category: #'Algebra-Categories-Comma'!
ArrowObject class
	instanceVariableNames: ''!

!classDefinition: #SliceObject category: #'Algebra-Categories-Comma'!
CommaObject subclass: #SliceObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Categories-Comma'!
!classDefinition: 'SliceObject class' category: #'Algebra-Categories-Comma'!
SliceObject class
	instanceVariableNames: ''!

!classDefinition: #BimonoidObject category: #'Algebra-Categories-Internal'!
Domain subclass: #BimonoidObject
	instanceVariableNames: 'multiplication unit comultiplication counit'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Categories-Internal'!
!classDefinition: 'BimonoidObject class' category: #'Algebra-Categories-Internal'!
BimonoidObject class
	instanceVariableNames: ''!

!classDefinition: #GroupObject category: #'Algebra-Categories-Internal'!
Domain subclass: #GroupObject
	instanceVariableNames: 'multiplication unit inverse'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Categories-Internal'!
!classDefinition: 'GroupObject class' category: #'Algebra-Categories-Internal'!
GroupObject class
	instanceVariableNames: ''!

!classDefinition: #ModuleObject category: #'Algebra-Categories-Internal'!
Domain subclass: #ModuleObject
	instanceVariableNames: 'scalars action'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Categories-Internal'!
!classDefinition: 'ModuleObject class' category: #'Algebra-Categories-Internal'!
ModuleObject class
	instanceVariableNames: ''!

!classDefinition: #MonoidObject category: #'Algebra-Categories-Internal'!
Domain subclass: #MonoidObject
	instanceVariableNames: 'multiplication unit'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Categories-Internal'!
!classDefinition: 'MonoidObject class' category: #'Algebra-Categories-Internal'!
MonoidObject class
	instanceVariableNames: ''!

!classDefinition: #ChainComplex category: #'Algebra-Categories-Abelian'!
Domain subclass: #ChainComplex
	instanceVariableNames: 'differentials shift'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Categories-Abelian'!
!classDefinition: 'ChainComplex class' category: #'Algebra-Categories-Abelian'!
ChainComplex class
	instanceVariableNames: ''!

!classDefinition: #FreydObject category: #'Algebra-Categories-Abelian'!
Domain subclass: #FreydObject
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Categories-Abelian'!
!classDefinition: 'FreydObject class' category: #'Algebra-Categories-Abelian'!
FreydObject class
	instanceVariableNames: ''!

!classDefinition: #GradedObject category: #'Algebra-Categories-Abelian'!
Domain subclass: #GradedObject
	instanceVariableNames: 'grading'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Categories-Abelian'!
!classDefinition: 'GradedObject class' category: #'Algebra-Categories-Abelian'!
GradedObject class
	instanceVariableNames: ''!

!classDefinition: #RelationObject category: #'Algebra-Categories-Abelian'!
Domain subclass: #RelationObject
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Categories-Abelian'!
!classDefinition: 'RelationObject class' category: #'Algebra-Categories-Abelian'!
RelationObject class
	instanceVariableNames: ''!

!classDefinition: #GradedModule category: #'Algebra-Modules-Graded'!
Domain subclass: #GradedModule
	instanceVariableNames: 'relationMatrix generatorDegrees'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Modules-Graded'!
!classDefinition: 'GradedModule class' category: #'Algebra-Modules-Graded'!
GradedModule class
	instanceVariableNames: ''!

!classDefinition: #CoherentSheaf category: #'Algebra-Schemes'!
Domain subclass: #CoherentSheaf
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Schemes'!
!classDefinition: 'CoherentSheaf class' category: #'Algebra-Schemes'!
CoherentSheaf class
	instanceVariableNames: ''!

!classDefinition: #Morphism category: #'Algebra-Categories'!
Object subclass: #Morphism
	instanceVariableNames: 'properties'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Categories'!
!classDefinition: 'Morphism class' category: #'Algebra-Categories'!
Morphism class
	instanceVariableNames: ''!

!classDefinition: #Map category: #'Algebra-Categories'!
Morphism subclass: #Map
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Categories'!
!classDefinition: 'Map class' category: #'Algebra-Categories'!
Map class
	instanceVariableNames: ''!

!classDefinition: #Functor category: #'Algebra-Categories'!
Map subclass: #Functor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Categories'!
!classDefinition: 'Functor class' category: #'Algebra-Categories'!
Functor class
	instanceVariableNames: ''!

!classDefinition: #Function category: #'Algebra-Sets'!
Map subclass: #Function
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Sets'!
!classDefinition: 'Function class' category: #'Algebra-Sets'!
Function class
	instanceVariableNames: ''!

!classDefinition: #Sequence category: #'Algebra-Sets'!
Function subclass: #Sequence
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Sets'!
!classDefinition: 'Sequence class' category: #'Algebra-Sets'!
Sequence class
	instanceVariableNames: ''!

!classDefinition: #GroupAction category: #'Algebra-Groups'!
Function subclass: #GroupAction
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Groups'!
!classDefinition: 'GroupAction class' category: #'Algebra-Groups'!
GroupAction class
	instanceVariableNames: ''!

!classDefinition: #BilinearMap category: #'Algebra-Modules-Multilinear'!
Function subclass: #BilinearMap
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Modules-Multilinear'!
!classDefinition: 'BilinearMap class' category: #'Algebra-Modules-Multilinear'!
BilinearMap class
	instanceVariableNames: ''!

!classDefinition: #BilinearForm category: #'Algebra-Modules-Multilinear'!
BilinearMap subclass: #BilinearForm
	instanceVariableNames: 'space matrix'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Modules-Multilinear'!
!classDefinition: 'BilinearForm class' category: #'Algebra-Modules-Multilinear'!
BilinearForm class
	instanceVariableNames: ''!

!classDefinition: #MonoidMap category: #'Algebra-Monoids'!
Map subclass: #MonoidMap
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Monoids'!
!classDefinition: 'MonoidMap class' category: #'Algebra-Monoids'!
MonoidMap class
	instanceVariableNames: ''!

!classDefinition: #GroupMap category: #'Algebra-Groups'!
Map subclass: #GroupMap
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Groups'!
!classDefinition: 'GroupMap class' category: #'Algebra-Groups'!
GroupMap class
	instanceVariableNames: ''!

!classDefinition: #RingMap category: #'Algebra-Rings'!
Map subclass: #RingMap
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Rings'!
!classDefinition: 'RingMap class' category: #'Algebra-Rings'!
RingMap class
	instanceVariableNames: ''!

!classDefinition: #ModuleMap category: #'Algebra-Modules'!
Map subclass: #ModuleMap
	instanceVariableNames: 'domain codomain'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Modules'!
!classDefinition: 'ModuleMap class' category: #'Algebra-Modules'!
ModuleMap class
	instanceVariableNames: ''!

!classDefinition: #Matrix category: #'Algebra-Modules'!
ModuleMap subclass: #Matrix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Modules'!
!classDefinition: 'Matrix class' category: #'Algebra-Modules'!
Matrix class
	instanceVariableNames: ''!

!classDefinition: #BlockSparseMatrix category: #'Algebra-Modules'!
Matrix subclass: #BlockSparseMatrix
	instanceVariableNames: 'coefficients blockIndices columnIndices rowPointers'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Modules'!
!classDefinition: 'BlockSparseMatrix class' category: #'Algebra-Modules'!
BlockSparseMatrix class
	instanceVariableNames: ''!

!classDefinition: #DenseMatrix category: #'Algebra-Modules'!
Matrix subclass: #DenseMatrix
	instanceVariableNames: 'coefficients'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Modules'!
!classDefinition: 'DenseMatrix class' category: #'Algebra-Modules'!
DenseMatrix class
	instanceVariableNames: ''!

!classDefinition: #SparseMatrix category: #'Algebra-Modules'!
Matrix subclass: #SparseMatrix
	instanceVariableNames: 'coefficients columnIndices rowPointers'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Modules'!
!classDefinition: 'SparseMatrix class' category: #'Algebra-Modules'!
SparseMatrix class
	instanceVariableNames: ''!

!classDefinition: #Submatrix category: #'Algebra-Modules'!
Matrix subclass: #Submatrix
	instanceVariableNames: 'coefficients startIndex stride'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Modules'!
!classDefinition: 'Submatrix class' category: #'Algebra-Modules'!
Submatrix class
	instanceVariableNames: ''!

!classDefinition: #QuadraticForm category: #'Algebra-Modules-Multilinear'!
Map subclass: #QuadraticForm
	instanceVariableNames: 'coefficients'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Modules-Multilinear'!
!classDefinition: 'QuadraticForm class' category: #'Algebra-Modules-Multilinear'!
QuadraticForm class
	instanceVariableNames: ''!

!classDefinition: #SchemeMorphism category: #'Algebra-Schemes'!
Map subclass: #SchemeMorphism
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Schemes'!
!classDefinition: 'SchemeMorphism class' category: #'Algebra-Schemes'!
SchemeMorphism class
	instanceVariableNames: ''!

!classDefinition: #AffineMorphism category: #'Algebra-Schemes'!
SchemeMorphism subclass: #AffineMorphism
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Schemes'!
!classDefinition: 'AffineMorphism class' category: #'Algebra-Schemes'!
AffineMorphism class
	instanceVariableNames: ''!

!classDefinition: #AffinePoint category: #'Algebra-Schemes-Affine Space'!
AffineMorphism subclass: #AffinePoint
	instanceVariableNames: 'codomain coordinates'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Schemes-Affine Space'!
!classDefinition: 'AffinePoint class' category: #'Algebra-Schemes-Affine Space'!
AffinePoint class
	instanceVariableNames: ''!

!classDefinition: #ProjectivePoint category: #'Algebra-Schemes-Projective Space'!
SchemeMorphism subclass: #ProjectivePoint
	instanceVariableNames: 'codomain coordinates'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Schemes-Projective Space'!
!classDefinition: 'ProjectivePoint class' category: #'Algebra-Schemes-Projective Space'!
ProjectivePoint class
	instanceVariableNames: ''!

!classDefinition: #ProjectiveLinePoint category: #'Algebra-Schemes-Projective Space'!
ProjectivePoint subclass: #ProjectiveLinePoint
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Schemes-Projective Space'!
!classDefinition: 'ProjectiveLinePoint class' category: #'Algebra-Schemes-Projective Space'!
ProjectiveLinePoint class
	instanceVariableNames: ''!

!classDefinition: #RationalMap category: #'Algebra-Schemes-Affine Space'!
Map subclass: #RationalMap
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Schemes-Affine Space'!
!classDefinition: 'RationalMap class' category: #'Algebra-Schemes-Affine Space'!
RationalMap class
	instanceVariableNames: ''!

!classDefinition: #SimplicialMap category: #'Algebra-Simplicial Complexes'!
Map subclass: #SimplicialMap
	instanceVariableNames: 'vertexMap'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Simplicial Complexes'!
!classDefinition: 'SimplicialMap class' category: #'Algebra-Simplicial Complexes'!
SimplicialMap class
	instanceVariableNames: ''!

!classDefinition: #OppositeMorphism category: #'Algebra-Categories'!
Morphism subclass: #OppositeMorphism
	instanceVariableNames: 'reverse'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Categories'!
!classDefinition: 'OppositeMorphism class' category: #'Algebra-Categories'!
OppositeMorphism class
	instanceVariableNames: ''!

!classDefinition: #Path category: #'Algebra-Categories'!
Morphism subclass: #Path
	instanceVariableNames: 'domain codomain steps'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Categories'!
!classDefinition: 'Path class' category: #'Algebra-Categories'!
Path class
	instanceVariableNames: ''!

!classDefinition: #ProductMorphism category: #'Algebra-Categories'!
Morphism subclass: #ProductMorphism
	instanceVariableNames: 'components'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Categories'!
!classDefinition: 'ProductMorphism class' category: #'Algebra-Categories'!
ProductMorphism class
	instanceVariableNames: ''!

!classDefinition: #Transformation category: #'Algebra-Categories'!
Morphism subclass: #Transformation
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Categories'!
!classDefinition: 'Transformation class' category: #'Algebra-Categories'!
Transformation class
	instanceVariableNames: ''!

!classDefinition: #CommaMorphism category: #'Algebra-Categories-Comma'!
Morphism subclass: #CommaMorphism
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Categories-Comma'!
!classDefinition: 'CommaMorphism class' category: #'Algebra-Categories-Comma'!
CommaMorphism class
	instanceVariableNames: ''!

!classDefinition: #BimonoidMorphism category: #'Algebra-Categories-Internal'!
Morphism subclass: #BimonoidMorphism
	instanceVariableNames: 'domain codomain carrier'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Categories-Internal'!
!classDefinition: 'BimonoidMorphism class' category: #'Algebra-Categories-Internal'!
BimonoidMorphism class
	instanceVariableNames: ''!

!classDefinition: #GroupMorphism category: #'Algebra-Categories-Internal'!
Morphism subclass: #GroupMorphism
	instanceVariableNames: 'domain codomain carrier'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Categories-Internal'!
!classDefinition: 'GroupMorphism class' category: #'Algebra-Categories-Internal'!
GroupMorphism class
	instanceVariableNames: ''!

!classDefinition: #ModuleMorphism category: #'Algebra-Categories-Internal'!
Morphism subclass: #ModuleMorphism
	instanceVariableNames: 'domain codomain carrier'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Categories-Internal'!
!classDefinition: 'ModuleMorphism class' category: #'Algebra-Categories-Internal'!
ModuleMorphism class
	instanceVariableNames: ''!

!classDefinition: #MonoidMorphism category: #'Algebra-Categories-Internal'!
Morphism subclass: #MonoidMorphism
	instanceVariableNames: 'domain codomain carrier'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Categories-Internal'!
!classDefinition: 'MonoidMorphism class' category: #'Algebra-Categories-Internal'!
MonoidMorphism class
	instanceVariableNames: ''!

!classDefinition: #ChainMap category: #'Algebra-Categories-Abelian'!
Morphism subclass: #ChainMap
	instanceVariableNames: 'components'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Categories-Abelian'!
!classDefinition: 'ChainMap class' category: #'Algebra-Categories-Abelian'!
ChainMap class
	instanceVariableNames: ''!

!classDefinition: #FreydMorphism category: #'Algebra-Categories-Abelian'!
Morphism subclass: #FreydMorphism
	instanceVariableNames: 'datum'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Categories-Abelian'!
!classDefinition: 'FreydMorphism class' category: #'Algebra-Categories-Abelian'!
FreydMorphism class
	instanceVariableNames: ''!

!classDefinition: #GradedMorphism category: #'Algebra-Categories-Abelian'!
Morphism subclass: #GradedMorphism
	instanceVariableNames: 'domain codomain grading'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Categories-Abelian'!
!classDefinition: 'GradedMorphism class' category: #'Algebra-Categories-Abelian'!
GradedMorphism class
	instanceVariableNames: ''!

!classDefinition: #Relation category: #'Algebra-Categories-Abelian'!
Morphism subclass: #Relation
	instanceVariableNames: 'coarrow arrow'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Categories-Abelian'!
!classDefinition: 'Relation class' category: #'Algebra-Categories-Abelian'!
Relation class
	instanceVariableNames: ''!

!classDefinition: #GradedModuleMap category: #'Algebra-Modules-Graded'!
Morphism subclass: #GradedModuleMap
	instanceVariableNames: 'domain codomain matrix'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Modules-Graded'!
!classDefinition: 'GradedModuleMap class' category: #'Algebra-Modules-Graded'!
GradedModuleMap class
	instanceVariableNames: ''!

!classDefinition: #CoherentSheafMorphism category: #'Algebra-Schemes'!
Morphism subclass: #CoherentSheafMorphism
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Schemes'!
!classDefinition: 'CoherentSheafMorphism class' category: #'Algebra-Schemes'!
CoherentSheafMorphism class
	instanceVariableNames: ''!

!classDefinition: #EquivalenceClass category: #'Algebra-Sets'!
Object subclass: #EquivalenceClass
	instanceVariableNames: 'representative equivalence'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Sets'!
!classDefinition: 'EquivalenceClass class' category: #'Algebra-Sets'!
EquivalenceClass class
	instanceVariableNames: ''!

!classDefinition: #Monomial category: #'Algebra-Monoids'!
Object subclass: #Monomial
	instanceVariableNames: 'exponents parent degree'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Monoids'!
!classDefinition: 'Monomial class' category: #'Algebra-Monoids'!
Monomial class
	instanceVariableNames: ''!

!classDefinition: #Word category: #'Algebra-Monoids'!
Object subclass: #Word
	instanceVariableNames: 'syllables parent'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Monoids'!
!classDefinition: 'Word class' category: #'Algebra-Monoids'!
Word class
	instanceVariableNames: ''!

!classDefinition: #MonomialOrdering category: #'Algebra-Monoids-Orderings'!
Object subclass: #MonomialOrdering
	instanceVariableNames: 'indeterminates'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Monoids-Orderings'!
!classDefinition: 'MonomialOrdering class' category: #'Algebra-Monoids-Orderings'!
MonomialOrdering class
	instanceVariableNames: ''!

!classDefinition: #BlockMonomialOrdering category: #'Algebra-Monoids-Orderings'!
MonomialOrdering subclass: #BlockMonomialOrdering
	instanceVariableNames: 'blocks'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Monoids-Orderings'!
!classDefinition: 'BlockMonomialOrdering class' category: #'Algebra-Monoids-Orderings'!
BlockMonomialOrdering class
	instanceVariableNames: ''!

!classDefinition: #GradedLexicographicOrdering category: #'Algebra-Monoids-Orderings'!
MonomialOrdering subclass: #GradedLexicographicOrdering
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Monoids-Orderings'!
!classDefinition: 'GradedLexicographicOrdering class' category: #'Algebra-Monoids-Orderings'!
GradedLexicographicOrdering class
	instanceVariableNames: ''!

!classDefinition: #GradedReverseLexicographicOrdering category: #'Algebra-Monoids-Orderings'!
MonomialOrdering subclass: #GradedReverseLexicographicOrdering
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Monoids-Orderings'!
!classDefinition: 'GradedReverseLexicographicOrdering class' category: #'Algebra-Monoids-Orderings'!
GradedReverseLexicographicOrdering class
	instanceVariableNames: ''!

!classDefinition: #GradedReverseLexicographicWeightedOrdering category: #'Algebra-Monoids-Orderings'!
GradedReverseLexicographicOrdering subclass: #GradedReverseLexicographicWeightedOrdering
	instanceVariableNames: 'weights'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Monoids-Orderings'!
!classDefinition: 'GradedReverseLexicographicWeightedOrdering class' category: #'Algebra-Monoids-Orderings'!
GradedReverseLexicographicWeightedOrdering class
	instanceVariableNames: ''!

!classDefinition: #LexicographicOrdering category: #'Algebra-Monoids-Orderings'!
MonomialOrdering subclass: #LexicographicOrdering
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Monoids-Orderings'!
!classDefinition: 'LexicographicOrdering class' category: #'Algebra-Monoids-Orderings'!
LexicographicOrdering class
	instanceVariableNames: ''!

!classDefinition: #LocalGradedLexicographicOrdering category: #'Algebra-Monoids-Orderings'!
MonomialOrdering subclass: #LocalGradedLexicographicOrdering
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Monoids-Orderings'!
!classDefinition: 'LocalGradedLexicographicOrdering class' category: #'Algebra-Monoids-Orderings'!
LocalGradedLexicographicOrdering class
	instanceVariableNames: ''!

!classDefinition: #LocalGradedReverseLexicographicOrdering category: #'Algebra-Monoids-Orderings'!
MonomialOrdering subclass: #LocalGradedReverseLexicographicOrdering
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Monoids-Orderings'!
!classDefinition: 'LocalGradedReverseLexicographicOrdering class' category: #'Algebra-Monoids-Orderings'!
LocalGradedReverseLexicographicOrdering class
	instanceVariableNames: ''!

!classDefinition: #LocalLexicographicOrdering category: #'Algebra-Monoids-Orderings'!
MonomialOrdering subclass: #LocalLexicographicOrdering
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Monoids-Orderings'!
!classDefinition: 'LocalLexicographicOrdering class' category: #'Algebra-Monoids-Orderings'!
LocalLexicographicOrdering class
	instanceVariableNames: ''!

!classDefinition: #GroupElement category: #'Algebra-Groups'!
Object subclass: #GroupElement
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Groups'!
!classDefinition: 'GroupElement class' category: #'Algebra-Groups'!
GroupElement class
	instanceVariableNames: ''!

!classDefinition: #Coset category: #'Algebra-Groups'!
GroupElement subclass: #Coset
	instanceVariableNames: 'representative parent'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Groups'!
!classDefinition: 'Coset class' category: #'Algebra-Groups'!
Coset class
	instanceVariableNames: ''!

!classDefinition: #ProductGroupElement category: #'Algebra-Groups'!
GroupElement subclass: #ProductGroupElement
	instanceVariableNames: 'parent components'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Groups'!
!classDefinition: 'ProductGroupElement class' category: #'Algebra-Groups'!
ProductGroupElement class
	instanceVariableNames: ''!

!classDefinition: #SemidirectProductElement category: #'Algebra-Groups'!
GroupElement subclass: #SemidirectProductElement
	instanceVariableNames: 'parent left right'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Groups'!
!classDefinition: 'SemidirectProductElement class' category: #'Algebra-Groups'!
SemidirectProductElement class
	instanceVariableNames: ''!

!classDefinition: #Permutation category: #'Algebra-Groups-Permutations'!
Object subclass: #Permutation
	instanceVariableNames: 'images parent'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Groups-Permutations'!
!classDefinition: 'Permutation class' category: #'Algebra-Groups-Permutations'!
Permutation class
	instanceVariableNames: ''!

!classDefinition: #RingElement category: #'Algebra-Rings'!
Object subclass: #RingElement
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Rings'!
!classDefinition: 'RingElement class' category: #'Algebra-Rings'!
RingElement class
	instanceVariableNames: ''!

!classDefinition: #OppositeRingElement category: #'Algebra-Rings'!
RingElement subclass: #OppositeRingElement
	instanceVariableNames: 'opposite'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Rings'!
!classDefinition: 'OppositeRingElement class' category: #'Algebra-Rings'!
OppositeRingElement class
	instanceVariableNames: ''!

!classDefinition: #ProductRingElement category: #'Algebra-Rings'!
RingElement subclass: #ProductRingElement
	instanceVariableNames: 'parent components'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Rings'!
!classDefinition: 'ProductRingElement class' category: #'Algebra-Rings'!
ProductRingElement class
	instanceVariableNames: ''!

!classDefinition: #Ratio category: #'Algebra-Rings'!
RingElement subclass: #Ratio
	instanceVariableNames: 'numerator denominator'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Rings'!
!classDefinition: 'Ratio class' category: #'Algebra-Rings'!
Ratio class
	instanceVariableNames: ''!

!classDefinition: #Germ category: #'Algebra-Rings'!
Ratio subclass: #Germ
	instanceVariableNames: 'parent'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Rings'!
!classDefinition: 'Germ class' category: #'Algebra-Rings'!
Germ class
	instanceVariableNames: ''!

!classDefinition: #Rational category: #'Algebra-Fields-Algebraic'!
Ratio subclass: #Rational
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Fields-Algebraic'!
!classDefinition: 'Rational class' category: #'Algebra-Fields-Algebraic'!
Rational class
	instanceVariableNames: ''!

!classDefinition: #RationalFunction category: #'Algebra-Fields-Algebraic'!
Ratio subclass: #RationalFunction
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Fields-Algebraic'!
!classDefinition: 'RationalFunction class' category: #'Algebra-Fields-Algebraic'!
RationalFunction class
	instanceVariableNames: ''!

!classDefinition: #Residue category: #'Algebra-Rings'!
RingElement subclass: #Residue
	instanceVariableNames: 'representative parent'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Rings'!
!classDefinition: 'Residue class' category: #'Algebra-Rings'!
Residue class
	instanceVariableNames: ''!

!classDefinition: #GaloisRingElement category: #'Algebra-Fields-Finite'!
Residue subclass: #GaloisRingElement
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Fields-Finite'!
!classDefinition: 'GaloisRingElement class' category: #'Algebra-Fields-Finite'!
GaloisRingElement class
	instanceVariableNames: ''!

!classDefinition: #GaloisFieldElement category: #'Algebra-Fields-Finite'!
GaloisRingElement subclass: #GaloisFieldElement
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Fields-Finite'!
!classDefinition: 'GaloisFieldElement class' category: #'Algebra-Fields-Finite'!
GaloisFieldElement class
	instanceVariableNames: ''!

!classDefinition: #ModularInteger category: #'Algebra-Fields-Finite'!
Residue subclass: #ModularInteger
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Fields-Finite'!
!classDefinition: 'ModularInteger class' category: #'Algebra-Fields-Finite'!
ModularInteger class
	instanceVariableNames: ''!

!classDefinition: #PrimePowerResidue category: #'Algebra-Fields-Finite'!
ModularInteger subclass: #PrimePowerResidue
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Fields-Finite'!
!classDefinition: 'PrimePowerResidue class' category: #'Algebra-Fields-Finite'!
PrimePowerResidue class
	instanceVariableNames: ''!

!classDefinition: #PrimeResidue category: #'Algebra-Fields-Finite'!
PrimePowerResidue subclass: #PrimeResidue
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Fields-Finite'!
!classDefinition: 'PrimeResidue class' category: #'Algebra-Fields-Finite'!
PrimeResidue class
	instanceVariableNames: ''!

!classDefinition: #AlgebraicRational category: #'Algebra-Fields-Algebraic'!
Residue subclass: #AlgebraicRational
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Fields-Algebraic'!
!classDefinition: 'AlgebraicRational class' category: #'Algebra-Fields-Algebraic'!
AlgebraicRational class
	instanceVariableNames: ''!

!classDefinition: #CyclotomicRational category: #'Algebra-Fields-Cyclotomic'!
AlgebraicRational subclass: #CyclotomicRational
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Fields-Cyclotomic'!
!classDefinition: 'CyclotomicRational class' category: #'Algebra-Fields-Cyclotomic'!
CyclotomicRational class
	instanceVariableNames: ''!

!classDefinition: #Jet category: #'Algebra-Algebras-Affine'!
Residue subclass: #Jet
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algebras-Affine'!
!classDefinition: 'Jet class' category: #'Algebra-Algebras-Affine'!
Jet class
	instanceVariableNames: ''!

!classDefinition: #LaurentPolynomial category: #'Algebra-Algebras-Affine'!
Residue subclass: #LaurentPolynomial
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algebras-Affine'!
!classDefinition: 'LaurentPolynomial class' category: #'Algebra-Algebras-Affine'!
LaurentPolynomial class
	instanceVariableNames: ''!

!classDefinition: #AlgebraicClosureElement category: #'Algebra-Fields-Finite'!
RingElement subclass: #AlgebraicClosureElement
	instanceVariableNames: 'representative'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Fields-Finite'!
!classDefinition: 'AlgebraicClosureElement class' category: #'Algebra-Fields-Finite'!
AlgebraicClosureElement class
	instanceVariableNames: ''!

!classDefinition: #ComplexAlgebraicNumber category: #'Algebra-Fields-Algebraic'!
RingElement subclass: #ComplexAlgebraicNumber
	instanceVariableNames: 'minimalPolynomial bounds'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Fields-Algebraic'!
!classDefinition: 'ComplexAlgebraicNumber class' category: #'Algebra-Fields-Algebraic'!
ComplexAlgebraicNumber class
	instanceVariableNames: ''!

!classDefinition: #RealAlgebraicNumber category: #'Algebra-Fields-Algebraic'!
ComplexAlgebraicNumber subclass: #RealAlgebraicNumber
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Fields-Algebraic'!
!classDefinition: 'RealAlgebraicNumber class' category: #'Algebra-Fields-Algebraic'!
RealAlgebraicNumber class
	instanceVariableNames: ''!

!classDefinition: #AbelianClosureElement category: #'Algebra-Fields-Cyclotomic'!
RingElement subclass: #AbelianClosureElement
	instanceVariableNames: 'representative'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Fields-Cyclotomic'!
!classDefinition: 'AbelianClosureElement class' category: #'Algebra-Fields-Cyclotomic'!
AbelianClosureElement class
	instanceVariableNames: ''!

!classDefinition: #Polynomial category: #'Algebra-Algebras-Affine'!
RingElement subclass: #Polynomial
	instanceVariableNames: 'parent coefficients'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algebras-Affine'!
!classDefinition: 'Polynomial class' category: #'Algebra-Algebras-Affine'!
Polynomial class
	instanceVariableNames: ''!

!classDefinition: #MultivariatePolynomial category: #'Algebra-Algebras-Affine'!
Polynomial subclass: #MultivariatePolynomial
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algebras-Affine'!
!classDefinition: 'MultivariatePolynomial class' category: #'Algebra-Algebras-Affine'!
MultivariatePolynomial class
	instanceVariableNames: ''!

!classDefinition: #UnivariatePolynomial category: #'Algebra-Algebras-Affine'!
Polynomial subclass: #UnivariatePolynomial
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algebras-Affine'!
!classDefinition: 'UnivariatePolynomial class' category: #'Algebra-Algebras-Affine'!
UnivariatePolynomial class
	instanceVariableNames: ''!

!classDefinition: #FiniteAlgebraElement category: #'Algebra-Algebras-Finite'!
RingElement subclass: #FiniteAlgebraElement
	instanceVariableNames: 'parent moduleElement representation'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algebras-Finite'!
!classDefinition: 'FiniteAlgebraElement class' category: #'Algebra-Algebras-Finite'!
FiniteAlgebraElement class
	instanceVariableNames: ''!

!classDefinition: #AlgebraicInteger category: #'Algebra-Fields-Algebraic'!
FiniteAlgebraElement subclass: #AlgebraicInteger
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Fields-Algebraic'!
!classDefinition: 'AlgebraicInteger class' category: #'Algebra-Fields-Algebraic'!
AlgebraicInteger class
	instanceVariableNames: ''!

!classDefinition: #EisensteinInteger category: #'Algebra-Fields-Cyclotomic'!
AlgebraicInteger subclass: #EisensteinInteger
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Fields-Cyclotomic'!
!classDefinition: 'EisensteinInteger class' category: #'Algebra-Fields-Cyclotomic'!
EisensteinInteger class
	instanceVariableNames: ''!

!classDefinition: #GaussianInteger category: #'Algebra-Fields-Cyclotomic'!
AlgebraicInteger subclass: #GaussianInteger
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Fields-Cyclotomic'!
!classDefinition: 'GaussianInteger class' category: #'Algebra-Fields-Cyclotomic'!
GaussianInteger class
	instanceVariableNames: ''!

!classDefinition: #QuadraticInteger category: #'Algebra-Fields-Quadratic'!
AlgebraicInteger subclass: #QuadraticInteger
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Fields-Quadratic'!
!classDefinition: 'QuadraticInteger class' category: #'Algebra-Fields-Quadratic'!
QuadraticInteger class
	instanceVariableNames: ''!

!classDefinition: #GroupAlgebraElement category: #'Algebra-Algebras-Finite'!
FiniteAlgebraElement subclass: #GroupAlgebraElement
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algebras-Finite'!
!classDefinition: 'GroupAlgebraElement class' category: #'Algebra-Algebras-Finite'!
GroupAlgebraElement class
	instanceVariableNames: ''!

!classDefinition: #Multivector category: #'Algebra-Algebras-Finite'!
FiniteAlgebraElement subclass: #Multivector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algebras-Finite'!
!classDefinition: 'Multivector class' category: #'Algebra-Algebras-Finite'!
Multivector class
	instanceVariableNames: ''!

!classDefinition: #Quaternion category: #'Algebra-Algebras-Finite'!
FiniteAlgebraElement subclass: #Quaternion
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algebras-Finite'!
!classDefinition: 'Quaternion class' category: #'Algebra-Algebras-Finite'!
Quaternion class
	instanceVariableNames: ''!

!classDefinition: #FreePolynomial category: #'Algebra-Algebras-Free'!
RingElement subclass: #FreePolynomial
	instanceVariableNames: 'coefficients parent'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algebras-Free'!
!classDefinition: 'FreePolynomial class' category: #'Algebra-Algebras-Free'!
FreePolynomial class
	instanceVariableNames: ''!

!classDefinition: #FractionalIdeal category: #'Algebra-Fields-Algebraic'!
Object subclass: #FractionalIdeal
	instanceVariableNames: 'numerator denominator'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Fields-Algebraic'!
!classDefinition: 'FractionalIdeal class' category: #'Algebra-Fields-Algebraic'!
FractionalIdeal class
	instanceVariableNames: ''!

!classDefinition: #ModuleElement category: #'Algebra-Modules'!
Object subclass: #ModuleElement
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Modules'!
!classDefinition: 'ModuleElement class' category: #'Algebra-Modules'!
ModuleElement class
	instanceVariableNames: ''!

!classDefinition: #ModuleCoset category: #'Algebra-Modules'!
ModuleElement subclass: #ModuleCoset
	instanceVariableNames: 'representative parent'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Modules'!
!classDefinition: 'ModuleCoset class' category: #'Algebra-Modules'!
ModuleCoset class
	instanceVariableNames: ''!

!classDefinition: #Tuple category: #'Algebra-Modules'!
ModuleElement subclass: #Tuple
	instanceVariableNames: 'coefficients parent'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Modules'!
!classDefinition: 'Tuple class' category: #'Algebra-Modules'!
Tuple class
	instanceVariableNames: ''!

!classDefinition: #MultivariateTuple category: #'Algebra-Modules'!
Tuple subclass: #MultivariateTuple
	instanceVariableNames: 'leadingMonomial'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Modules'!
!classDefinition: 'MultivariateTuple class' category: #'Algebra-Modules'!
MultivariateTuple class
	instanceVariableNames: ''!

!classDefinition: #ModuleMonomial category: #'Algebra-Modules-Orderings'!
Object subclass: #ModuleMonomial
	instanceVariableNames: 'ordering monomial position'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Modules-Orderings'!
!classDefinition: 'ModuleMonomial class' category: #'Algebra-Modules-Orderings'!
ModuleMonomial class
	instanceVariableNames: ''!

!classDefinition: #ModuleMonomialOrdering category: #'Algebra-Modules-Orderings'!
Object subclass: #ModuleMonomialOrdering
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Modules-Orderings'!
!classDefinition: 'ModuleMonomialOrdering class' category: #'Algebra-Modules-Orderings'!
ModuleMonomialOrdering class
	instanceVariableNames: ''!

!classDefinition: #POTMonomialOrdering category: #'Algebra-Modules-Orderings'!
ModuleMonomialOrdering subclass: #POTMonomialOrdering
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Modules-Orderings'!
!classDefinition: 'POTMonomialOrdering class' category: #'Algebra-Modules-Orderings'!
POTMonomialOrdering class
	instanceVariableNames: ''!

!classDefinition: #SchreyerMonomialOrdering category: #'Algebra-Modules-Orderings'!
ModuleMonomialOrdering subclass: #SchreyerMonomialOrdering
	instanceVariableNames: 'weights'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Modules-Orderings'!
!classDefinition: 'SchreyerMonomialOrdering class' category: #'Algebra-Modules-Orderings'!
SchreyerMonomialOrdering class
	instanceVariableNames: ''!

!classDefinition: #TOPMonomialOrdering category: #'Algebra-Modules-Orderings'!
ModuleMonomialOrdering subclass: #TOPMonomialOrdering
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Modules-Orderings'!
!classDefinition: 'TOPMonomialOrdering class' category: #'Algebra-Modules-Orderings'!
TOPMonomialOrdering class
	instanceVariableNames: ''!

!classDefinition: #TOPWMonomialOrdering category: #'Algebra-Modules-Orderings'!
TOPMonomialOrdering subclass: #TOPWMonomialOrdering
	instanceVariableNames: 'weights'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Modules-Orderings'!
!classDefinition: 'TOPWMonomialOrdering class' category: #'Algebra-Modules-Orderings'!
TOPWMonomialOrdering class
	instanceVariableNames: ''!

!classDefinition: #Divisor category: #'Algebra-Schemes'!
Object subclass: #Divisor
	instanceVariableNames: 'coefficients parent'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Schemes'!
!classDefinition: 'Divisor class' category: #'Algebra-Schemes'!
Divisor class
	instanceVariableNames: ''!

!classDefinition: #AdditionChain category: #'Algebra-Algorithms'!
Object subclass: #AdditionChain
	instanceVariableNames: 'values firstIndices secondIndices'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algorithms'!
!classDefinition: 'AdditionChain class' category: #'Algebra-Algorithms'!
AdditionChain class
	instanceVariableNames: ''!

!classDefinition: #BabyStepGiantStep category: #'Algebra-Algorithms'!
Object subclass: #BabyStepGiantStep
	instanceVariableNames: 'group table δ'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algorithms'!
!classDefinition: 'BabyStepGiantStep class' category: #'Algebra-Algorithms'!
BabyStepGiantStep class
	instanceVariableNames: ''!

!classDefinition: #Ball category: #'Algebra-Algorithms'!
Object subclass: #Ball
	instanceVariableNames: 'center radius'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algorithms'!
!classDefinition: 'Ball class' category: #'Algebra-Algorithms'!
Ball class
	instanceVariableNames: ''!

!classDefinition: #BrentKung category: #'Algebra-Algorithms'!
Object subclass: #BrentKung
	instanceVariableNames: 'modulus G P'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algorithms'!
!classDefinition: 'BrentKung class' category: #'Algebra-Algorithms'!
BrentKung class
	instanceVariableNames: ''!

!classDefinition: #CRT category: #'Algebra-Algorithms'!
Object subclass: #CRT
	instanceVariableNames: 'moduli inverses'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algorithms'!
!classDefinition: 'CRT class' category: #'Algebra-Algorithms'!
CRT class
	instanceVariableNames: ''!

!classDefinition: #ComplexBox category: #'Algebra-Algorithms'!
Object subclass: #ComplexBox
	instanceVariableNames: 'real imaginary'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algorithms'!
!classDefinition: 'ComplexBox class' category: #'Algebra-Algorithms'!
ComplexBox class
	instanceVariableNames: ''!

!classDefinition: #ComplexRootIsolator category: #'Algebra-Algorithms'!
Object subclass: #ComplexRootIsolator
	instanceVariableNames: 'polynomial derivatives'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algorithms'!
!classDefinition: 'ComplexRootIsolator class' category: #'Algebra-Algorithms'!
ComplexRootIsolator class
	instanceVariableNames: ''!

!classDefinition: #Division category: #'Algebra-Algorithms'!
Object subclass: #Division
	instanceVariableNames: 'divisor dividend quotient remainder'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algorithms'!
!classDefinition: 'Division class' category: #'Algebra-Algorithms'!
Division class
	instanceVariableNames: ''!

!classDefinition: #ExtendedEuclid category: #'Algebra-Algorithms'!
Object subclass: #ExtendedEuclid
	instanceVariableNames: 'elements gcd bezout'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algorithms'!
!classDefinition: 'ExtendedEuclid class' category: #'Algebra-Algorithms'!
ExtendedEuclid class
	instanceVariableNames: ''!

!classDefinition: #FFT category: #'Algebra-Algorithms'!
Object subclass: #FFT
	instanceVariableNames: 'modulus powers inversePowers inverseN'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algorithms'!
!classDefinition: 'FFT class' category: #'Algebra-Algorithms'!
FFT class
	instanceVariableNames: ''!

!classDefinition: #GrayCode category: #'Algebra-Algorithms'!
Object subclass: #GrayCode
	instanceVariableNames: 'indices increments'
	classVariableNames: 'Cache'
	poolDictionaries: ''
	category: 'Algebra-Algorithms'!
!classDefinition: 'GrayCode class' category: #'Algebra-Algorithms'!
GrayCode class
	instanceVariableNames: ''!

!classDefinition: #LagrangeGaussReduction category: #'Algebra-Algorithms'!
Object subclass: #LagrangeGaussReduction
	instanceVariableNames: 'vectorSpace v1 v2 shortVector'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algorithms'!
!classDefinition: 'LagrangeGaussReduction class' category: #'Algebra-Algorithms'!
LagrangeGaussReduction class
	instanceVariableNames: ''!

!classDefinition: #NewtonInterpolation category: #'Algebra-Algorithms'!
Object subclass: #NewtonInterpolation
	instanceVariableNames: 'points inverses'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algorithms'!
!classDefinition: 'NewtonInterpolation class' category: #'Algebra-Algorithms'!
NewtonInterpolation class
	instanceVariableNames: ''!

!classDefinition: #NumericalComplexRootIsolator category: #'Algebra-Algorithms'!
Object subclass: #NumericalComplexRootIsolator
	instanceVariableNames: 'polynomial tolerance'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algorithms'!
!classDefinition: 'NumericalComplexRootIsolator class' category: #'Algebra-Algorithms'!
NumericalComplexRootIsolator class
	instanceVariableNames: ''!

!classDefinition: #ProductReplacementRandomGenerator category: #'Algebra-Algorithms'!
Object subclass: #ProductReplacementRandomGenerator
	instanceVariableNames: 'generators state'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algorithms'!
!classDefinition: 'ProductReplacementRandomGenerator class' category: #'Algebra-Algorithms'!
ProductReplacementRandomGenerator class
	instanceVariableNames: ''!

!classDefinition: #PseudoDivision category: #'Algebra-Algorithms'!
Object subclass: #PseudoDivision
	instanceVariableNames: 'dividend divisor quotient remainder'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algorithms'!
!classDefinition: 'PseudoDivision class' category: #'Algebra-Algorithms'!
PseudoDivision class
	instanceVariableNames: ''!

!classDefinition: #RealRootIsolator category: #'Algebra-Algorithms'!
Object subclass: #RealRootIsolator
	instanceVariableNames: 'polynomial sturm fourier roots'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algorithms'!
!classDefinition: 'RealRootIsolator class' category: #'Algebra-Algorithms'!
RealRootIsolator class
	instanceVariableNames: ''!

!classDefinition: #SchreierSims category: #'Algebra-Algorithms'!
Object subclass: #SchreierSims
	instanceVariableNames: 'action generators base strongGenerators trees order'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algorithms'!
!classDefinition: 'SchreierSims class' category: #'Algebra-Algorithms'!
SchreierSims class
	instanceVariableNames: ''!

!classDefinition: #SchreierTree category: #'Algebra-Algorithms'!
Object subclass: #SchreierTree
	instanceVariableNames: 'root generators action v inverses w orbit'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algorithms'!
!classDefinition: 'SchreierTree class' category: #'Algebra-Algorithms'!
SchreierTree class
	instanceVariableNames: ''!

!classDefinition: #TonelliShanks category: #'Algebra-Algorithms'!
Object subclass: #TonelliShanks
	instanceVariableNames: 'p q e z'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algorithms'!
!classDefinition: 'TonelliShanks class' category: #'Algebra-Algorithms'!
TonelliShanks class
	instanceVariableNames: ''!

!classDefinition: #Echelonization category: #'Algebra-Algorithms-Echelonization'!
Object subclass: #Echelonization
	instanceVariableNames: 'matrix echelon transformation'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algorithms-Echelonization'!
!classDefinition: 'Echelonization class' category: #'Algebra-Algorithms-Echelonization'!
Echelonization class
	instanceVariableNames: ''!

!classDefinition: #GaussJordanEchelonization category: #'Algebra-Algorithms-Echelonization'!
Echelonization subclass: #GaussJordanEchelonization
	instanceVariableNames: 'determinantFactor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algorithms-Echelonization'!
!classDefinition: 'GaussJordanEchelonization class' category: #'Algebra-Algorithms-Echelonization'!
GaussJordanEchelonization class
	instanceVariableNames: ''!

!classDefinition: #HermiteEchelonization category: #'Algebra-Algorithms-Echelonization'!
Echelonization subclass: #HermiteEchelonization
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algorithms-Echelonization'!
!classDefinition: 'HermiteEchelonization class' category: #'Algebra-Algorithms-Echelonization'!
HermiteEchelonization class
	instanceVariableNames: ''!

!classDefinition: #HowellEchelonization category: #'Algebra-Algorithms-Echelonization'!
Echelonization subclass: #HowellEchelonization
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algorithms-Echelonization'!
!classDefinition: 'HowellEchelonization class' category: #'Algebra-Algorithms-Echelonization'!
HowellEchelonization class
	instanceVariableNames: ''!

!classDefinition: #MultivariateDivision category: #'Algebra-Algorithms-Standard Bases'!
Object subclass: #MultivariateDivision
	instanceVariableNames: 'dividend divisors quotients remainder'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algorithms-Standard Bases'!
!classDefinition: 'MultivariateDivision class' category: #'Algebra-Algorithms-Standard Bases'!
MultivariateDivision class
	instanceVariableNames: ''!

!classDefinition: #StrongBuchberger category: #'Algebra-Algorithms-Standard Bases'!
Object subclass: #StrongBuchberger
	instanceVariableNames: 'matrix generators'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algorithms-Standard Bases'!
!classDefinition: 'StrongBuchberger class' category: #'Algebra-Algorithms-Standard Bases'!
StrongBuchberger class
	instanceVariableNames: ''!

!classDefinition: #Buchberger category: #'Algebra-Algorithms-Standard Bases'!
StrongBuchberger subclass: #Buchberger
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algorithms-Standard Bases'!
!classDefinition: 'Buchberger class' category: #'Algebra-Algorithms-Standard Bases'!
Buchberger class
	instanceVariableNames: ''!

!classDefinition: #ExtendedStrongBuchberger category: #'Algebra-Algorithms-Standard Bases'!
StrongBuchberger subclass: #ExtendedStrongBuchberger
	instanceVariableNames: 'combinations'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algorithms-Standard Bases'!
!classDefinition: 'ExtendedStrongBuchberger class' category: #'Algebra-Algorithms-Standard Bases'!
ExtendedStrongBuchberger class
	instanceVariableNames: ''!

!classDefinition: #ExtendedBuchberger category: #'Algebra-Algorithms-Standard Bases'!
ExtendedStrongBuchberger subclass: #ExtendedBuchberger
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Algebra-Algorithms-Standard Bases'!
!classDefinition: 'ExtendedBuchberger class' category: #'Algebra-Algorithms-Standard Bases'!
ExtendedBuchberger class
	instanceVariableNames: ''!


!BinaryArray commentStamp: '<historical>' prior: 0!
Arrays of elements of the field 𝔽₂ = ℤ/2ℤ. They are stored as bits in an array of 32-bit words.!

!ExtensionPackedArray commentStamp: '<historical>' prior: 0!
Arrays of elements of an extension ring or field stored in packed form.!

!ExtensionSlicedArray commentStamp: '<historical>' prior: 0!
Arrays of elements of an extension ring or field stored in sliced form.!

!BinaryExtensionArray commentStamp: '<historical>' prior: 0!
Arrays of elements of a binary Galois field GF(2^n).!

!ModularArray commentStamp: 'len 11/16/2023 21:54:27' prior: 0!
Arrays of elements of an integer residue class ring ℤ/nℤ.!

!ProductArray commentStamp: '<historical>' prior: 0!
Arrays of elements of a product ring. See ProductRing.!

!TernaryArray commentStamp: '<historical>' prior: 0!
Arrays of elements of the field 𝔽₃ = ℤ/3ℤ. They are stored using 2 bits per element in bitsliced representation with two arrays of 32-bit words. See [BB09].

The element 0 is represented as 00, 1 as 10 and -1 as 11. So the first slice marks whether an element is 0 or a unit, while the second slice indicates the sign.
!

!Simplex commentStamp: '<historical>' prior: 0!
(Abstract) n-simplices.

It is assumed that the vertices are objects that implement a total ordering with #<= (such as integers, strings, monomials), so that they can be ordered to choose an unambiguos orientation.!

!Domain commentStamp: '<historical>' prior: 0!
Objects of a category, i.e. domains and codomains of morphisms in a category. Concrete examples are algebraic structures such as groups, rings and modules. See also Morphism and Category.

Given two objects A and B in the same category, the set Hom(A,B) of morphisms between them is obtained with the message 'B ^ A' (see HomSet), and a more abstract hom-object such as the internal hom [A,B] can be obtained with the message 'A ⇒ B'. The identity morphism is returned by the message 'A id'.

Objects can be equipped with canonical and universal morphisms. For example, field extensions and localizations come with embeddings, quotient objects come with projections, products have projection maps to their components, and coproducts have coprojection maps from their components.

More generally, canonical and universal morphisms are determined by their domain and codomain and can be retrieved by sending the message 'A → B'. For example, for any unital ring R, 'ℤ → R' returns the canonical embedding of ℤ into R. In order for this mechanism to work, subclasses must sometimes extend the messages #to: and #from: to answer canonical and universal morphisms, and #toAll: and #fromAll: to answer projections and coprojections.!

!OppositeObject commentStamp: '<historical>' prior: 0!
Objects of the opposite category (see OppositeCategory).!

!Presheaf commentStamp: '<historical>' prior: 0!
Presheaves on a category C with values on a category D, or D-valued presheaves on C, correspond to functors from Cᵒᵖ to D (i.e., contravariant functors from C to D), and they are objects of the functor category [Cᵒᵖ,D] with natural transformations as morphisms.

While a functor F : Cᵒᵖ → D is a *morphism* in Cat, the corresponding presheaf is an *object* in the functor category [Cᵒᵖ,D].!

!ProductObject commentStamp: '<historical>' prior: 0!
Objects of a product category (see ProductCategory).!

!Structure commentStamp: '<historical>' prior: 0!
Objects with an underlying set of elements (the 'carrier' set). These can be simple sets, or algebraic structures such as groups, rings, modules, etc. These are objects of concrete categories, i.e. they are realized as sets of elements endowed with certain algebraic structure, and their morphisms are structure-preserving functions.

Subclasses can implement Collection-like protocol such as #do:, #includes:, #size, #atRandom:, etc.

A simple coercion mechanism allows the conversion of an element x in X to an element in Y via the message 'Y !! x'. Known canonical or universal morphisms are used for coercion of elements between domains. Subclasses can also extend the coercion mechanism by implementing #adapt: and #newFrom:.

See https://ncatlab.org/nlab/show/structured+set
!

!Category commentStamp: '<historical>' prior: 0!
Categories as defined in the single-sorted version of category theory. Their elements are morphisms of a given type, and their morphisms are functors. See Domain, Morphism and Functor.

Categories are commonly defined as two sets: a set of objects and a set of arrows (or morphisms). However, identifying objects with their identity morphism, one can define categories as a single set of morphisms. With this definition, functors are simply functions preserving composition of morphisms.

See https://ncatlab.org/nlab/show/single-sorted+definition+of+a+category
!

!FreeCategory commentStamp: '<historical>' prior: 0!
Free category ℱ(G) generated by a finite ordered directed multigraph (or quiver) G. The objects are the vertices of  the graph G, and the morphisms are paths on G (including the empty path from a vertex to itself, corresponding to the identity morphism). Note that the graph G can include multiple arrows between two vertices, and multiple loops, and each arrow corresponds to a different morphism (distinct from the identity morphism).

When G has n vertices and no edges, ℱ(G) is the discrete category with n objects, and the only morphisms are identity morphisms.

Functors from free categories can be specified with finite data, i.e. the value at each vertex and edge of the generating graph.

A functor D : J → C can be seen as a diagram, and natural transformations from a constant functor X correspond to cones over D with vertex X. When J (the shape of the diagram) is a free category, natural transformations can be specified with finite data by assigning a morphism to each object of J.

A functor from a free category ℱ(G) → C (typically to a category of vector spaces) is called a 'quiver representation', and natural transformations correspond to homomorphisms of quiver representations.!

!FunctorCategory commentStamp: 'len 6/13/2024 14:06:28' prior: 0!
Category of D-valued presheaves on Cᵒᵖ, denoted by [C,D]. The objects are presheaves corresponding to functors C → D, and the morphisms are natural transformations.!

!OppositeCategory commentStamp: '<historical>' prior: 0!
The opposite category of a given category, with the same objects but reversed arrows.!

!ProductCategory commentStamp: '<historical>' prior: 0!
Product category A₁×···×Aₙ. Objects are tuples of objects (a₁, ..., aₙ), and morphisms are tuples of morphisms (f₁, ..., fₙ), with aᵢ and fᵢ objects and morphisms of Aᵢ.!

!CommaCategory commentStamp: '<historical>' prior: 0!
Given categories A, B and C, and two functors S : A → C (source functor) and T : B → C (target functor) with common codomain C, the comma category (S ↓ T) is formed by taking as objects the triples (a,b,h) with a an object of A (the source), b an object of B (the target) and h : S(a) → T(b) a morphism in C (the arrow), and as morphisms (a,b,h) → (a',b',h') the pairs (f,g) with f : a → a', g : b → b' such that the square formed by h, h', S(f) and T(g) commutes:

	         h
	    Sa  → Tb
	Sf ↓        ↓ Sg
	    Sa' → Tb'
	          h'
!

!ArrowCategory commentStamp: '<historical>' prior: 0!
The arrow category Arr(C) or C^→ of a category C is the category whose objects are the morphisms of C, and whose morphisms are the commuting squares in C. Composition is given simply by placing commutative squares side by side to get a commutative oblong.

This is a particular case of the comma category (S ↓ T), with S = T = id(C) the identity functor of C.

The arrow category Arr(C) is isomorphic to the functor category [2,C] = C^2 (functors from the 'walking arrow category' or 'interval category' 2 = {1 → 2}, also denoted Δ[1], consisting of two objects with a single non-identity arrow).!

!SliceCategory commentStamp: '<historical>' prior: 0!
The slice category or over category (C ↓ c) of a category C over an object c has as objects all morphisms x → c in C, and as morphisms (x → c) → (x' → c) the morphisms x → x' in C such that the triangle commutes:

	x   →   x'
	  ↘   ↙
	     c

This is a particular case of the comma category (S ↓ T), taking as S = id(C) the identity functor of C, and T : 1 → C the functor from the category with one object * and one morphism (the terminal category) that sends * to c.!

!GroupCategory commentStamp: 'len 6/13/2024 14:04:53' prior: 0!
Category of group objects in a cartesian category C, denoted by Grp(C).!

!ModuleCategory commentStamp: 'len 8/30/2024 08:08:16' prior: 0!
Category Mod(A) of right module objects over a monoid object A in a monoidal category C.

Objects are right A-modules, determined by a right action of A on an object X given as a morphism X ⊗ A → X.!

!MonoidCategory commentStamp: '<historical>' prior: 0!
Category of monoid objects in a monoidal category C, denoted by Mon(C).
!

!ChainComplexesCategory commentStamp: '<historical>' prior: 0!
Category of chain complexes over a given additive category of chains. See ChainComplex and ChainMap.!

!FreydCategory commentStamp: '<historical>' prior: 0!
The Freyd category Freyd(C) of an additive category C is a construction that equips C with cokernels in a universal way (i.e., this is the 'cokernel completion'). The objects of Freyd(C) are the morphisms of C, and a morphism between X₀ → X and Y₀ → Y is a morphism X → Y (the 'datum') such that there exists another morphism X₀ → Y₀ (the 'witness') making the square commute, and two morphisms α : X → Y and α' : X → Y are equal if there exists a lift X → Y₀ making the triangle with α - α' : X → Y and Y₀ → Y commute.

If the category C has weak kernels (i.e., kernels that might not be unique), Freyd(C) is an abelian category.

See [Pos20] and [Pos19].!

!GradedObjectsCategory commentStamp: '<historical>' prior: 0!
The category Gr(C) of graded objects in an additive category C. The objects are families of objects of C indexed by the positive integers, interpreted as their formal direct sum X₀ ⊕ X₁ ⊕ ..., and the morphisms are families of morphisms Xᵢ → Yᵢ.!

!RelationsCategory commentStamp: '<historical>' prior: 0!
Category Rel(C) of relations or correspondences in a regular category C. The objects of Rel(C) are the objects of C, and the morphisms from X to Y are relations represented by isomorphism classes of jointly-monic ordered spans X ← Z → Y (and we call X ← Z the 'coarrow' and Z → Y the 'arrow'). Alternatively, morphisms from X to Y could be represented as cospans X → Z ← Y, or 3-arrows X ↩ Z → W ↞ Y.

When C is the category of sets, this is the category Rel of sets and relations.

When C is an abelian category, these are additive relations or generalized morphisms.

See [BLH11], [Pos17b, Section II.1], [Pos19], [Hil66], [Kle70].!

!FPModuleCategory commentStamp: '<historical>' prior: 0!
Category finitely presented right R-modules over a (unital) ring R.!

!CoherentSheavesCategory commentStamp: '<historical>' prior: 0!
Category of coherent sheaves on a given scheme. See CoherentSheaf and CoherentSheafMap.!

!SetObject commentStamp: '<historical>' prior: 0!
Objects in the category of sets (the name 'Set' was already taken in Smalltalk).!

!CartesianProduct commentStamp: '<historical>' prior: 0!
Cartesian products of sets. The elements of the cartesian product of two or more sets are arrays of elements in the sets corresponding to each component of the cartesian product.!

!HomSet commentStamp: '<historical>' prior: 0!
Hom-Set objects Hom(A,B) for domain A and codomain B, i.e. sets of all morphisms between two objects. When A = B this is the set of endomorphisms of A and it is noted End(A).!

!RationalPointSet commentStamp: '<historical>' prior: 0!
Set of K-rational points on a variety X, seen as Hom(Spec(K), X).!

!Naturals commentStamp: 'len 11/10/2023 19:48:57' prior: 0!
The set ℕ of natural numbers 1, 2, 3, ...!

!Monoid commentStamp: '<historical>' prior: 0!
Monoids consist of a set, an associative binary operation (that we implement with multiplicative notation) and an identity element. They are objects in the category of monoids, with MonoidMaps as their morphisms.
!

!EndomorphismMonoid commentStamp: '<historical>' prior: 0!
The monoid End(X) of endomorphisms of some object X.!

!FreeAbelianMonoid commentStamp: '<historical>' prior: 0!
Commutative monoids of monomials in n indeterminates. Elements are instances of Monomial.

The number of indeterminates is called the rank. The indeterminates are referred by index (positive integer numbers), and can be given names that are used when printing.

Monomials have an associated monomial ordering. See MonomialOrdering.

See FreeMonoid for the noncommutative analog.
!

!FreeMonoid commentStamp: '<historical>' prior: 0!
A free monoid is a monoid whose elements are words (see Word) on a finite alphabet or set of indeterminates, together with word concatenation as monoid operation, and the empty word as identity element.

See FreeAbelianMonoid for the commutative analog.
!

!Group commentStamp: '<historical>' prior: 0!
Groups consist of a set with an associative binary operation (that we implement either in multiplicative or additive notation), an inverse map (every element has an inverse), and an identity element. They are objects in the category of groups, with GroupMaps as their morphisms.

Subclasses implement specific types of groups, such as permutation groups and matrix groups.
!

!HomGroup commentStamp: '<historical>' prior: 0!
The (additive) abelian group Hom(A,B) of morphisms from A to B in an Ab-enriched category.!

!DivisorGroup commentStamp: '<historical>' prior: 0!
Group of divisors with rational or integer coefficients of an integral locally Noetherian scheme. See Divisor.!

!AutomorphismGroup commentStamp: '<historical>' prior: 0!
The group Aut(X) of automorphisms of some object X.!

!FreeGroup commentStamp: '<historical>' prior: 0!
A free group is a group whose elements are words (see Word) on a finite alphabet or set of indeterminates, together with word concatenation as monoid operation, and the empty word as identity element. See also FreeMonoid.
!

!ProductGroup commentStamp: '<historical>' prior: 0!
Direct products of groups. Elements are tuples, and the group composition law is defined component-wise.!

!QuotientGroup commentStamp: '<historical>' prior: 0!
Quotient groups (or factor groups) G/N (read "G mod N"), i.e. the quotient of a group G by a normal subgroup N. The elements are the cosets of N (see Coset).!

!SemidirectProductGroup commentStamp: '<historical>' prior: 0!
Semidirect products of groups.!

!PermutationGroup commentStamp: '<historical>' prior: 0!
Permutation groups, i.e. subgroups of the symmetric group Sym(Ω) of permutations on the elements of a finite set or collection Ω (see SymmetricGroup).

The set or collection Ω is refered to as the 'space' of the group, elements of Ω are 'points', while the word 'element' is used for elements of the group itself (permutations). The group acts naturally on Ω by the action that sends a permutation σ and a point x to σ(x).!

!AlternatingGroup commentStamp: '<historical>' prior: 0!
The alternating group Alt(Ω) of even permutations on the elements of a finite set or collection Ω (which we call 'space'). This is a subgroup of Sym(Ω) (see SymmetricGroup).!

!SymmetricGroup commentStamp: '<historical>' prior: 0!
The symmetric group Sym(Ω) of permutations on the elements of a finite set or collection Ω (which we call 'space'). This is the ambient of all PermutationGroups.!

!LinearGroup commentStamp: '<historical>' prior: 0!
Groups of automorphisms of a free R-module V over a commutative ring R. They are subgroups of the general linear group GL(V).!

!GeneralLinearGroup commentStamp: '<historical>' prior: 0!
The general linear group GL(V) of automorphisms of a free R-module V. These are the invertible endomorphisms of V, i.e. the endomorphisms whose determinats are units of R.!

!OrthogonalGroup commentStamp: 'len 6/2/2024 11:28:19' prior: 0!
O(Q), the Orthogonal Group of a quadratic space (V,Q) where Q is a nondegenerate quadratic form on V . This is the subgroup of the group of automorphisms GL(V) consisting of all automorphisms of V that preserve the quadratic form Q.!

!ScalarGroup commentStamp: 'len 9/27/2018 21:49:50' prior: 0!
This is the group of scalar linear maps of a free R-module over a commutative ring R.!

!SpecialLinearGroup commentStamp: 'len 9/27/2018 21:48:40' prior: 0!
SL(V), the Special Linear Group of automorphisms with determinant 1.!

!UnitGroup commentStamp: '<historical>' prior: 0!
Given a ring R, the group of units of R is the set of elements of R that have multiplicative inverse, and they form a group under multiplication. For a field F (or more generally a division ring), the units are all the nonzero elements F \ {0}.

Categorically, this construction is a functor from the cateogory of rings to the category of groups. This functor has a left adjoint which is the integral group ring construction (see GroupAlgebra).!

!Ring commentStamp: '<historical>' prior: 0!
Rings with identity (unital rings). They are associative and contain a multiplicative identity, but they are not necessarily commutative. The initial object is the ring of rational integers ℤ and the terminal object is the trivial ring with 1 = 0.

Rings can be thought as continuous functions on some topological space. In the case of a commutative ring R this space is the prime spectrum Spec(R), the set of prime ideals with the Zariski topology. See AffineScheme.

Rings can be constructed from existing rings, for example by taking quotients by two-sided ideals (see QuotientRing), by direct products (see ProductRing), and in the case of commutative rings by making transcendental extensions (see PolynomialRing), localizations (see FractionRing and LocalRing), etc.!

!EndomorphismRing commentStamp: '<historical>' prior: 0!
The ring End(X) of endomorphisms of some object X in a preadditive category. If X is an R-module over a commutative ring R, this is an R-algebra.!

!MatrixRing commentStamp: '<historical>' prior: 0!
Full matrix algebra, i.e. n²-dimensional associative algebra of square n×n matrices over a ring R under matrix multiplication. This is the endomorphisms algebra of the free module Rⁿ.!

!FractionRing commentStamp: '<historical>' prior: 0!
Total ring of fractions Frac(R) of a commutative ring R, also called the "total quotient ring" of R. The elements are formal fractions a/b with a and b in R and b regular (not a zero divisor), under the equivalence relation a/b ~ c/d if ad = cb. When the ring R is an integral domain, Frac(R) is a field and it is called the "field of fractions" of R. See Ring>>fractions.

The ring of fractions is a particular case of the more general construction of the localization of a ring or module. Frac(R) is the localization of R at the multiplicative set formed by the regular elements of R. The field of fractions of an integral domain is the localization at the zero ideal. See also LocalRing for localizations at prime ideals.!

!RationalField commentStamp: '<historical>' prior: 0!
The field ℚ of rational numbers.!

!RationalFunctionField commentStamp: '<historical>' prior: 0!
The field of fractions of a polynomial ring with coefficients over a field.!

!IntegerRing commentStamp: 'len 11/10/2023 19:49:18' prior: 0!
The ring ℤ of rational integers.!

!LocalRing commentStamp: '<historical>' prior: 0!
Localization of a commutative ring R at a prime ideal p. The elements are 'germs at p' (see Germ), and can be thought as fractions a/b with a and b in R and b not in p. This is a subring of the total ring of fractions Frac(R) (see FractionRing).

The localization of R at a prime ideal P is the stalk of the structure sheaf of Spec(R) at the point p. As the elements of R are thought as functions on the space Spec(R), the elements of the localization at p are thought as germs of functions, i.e. functions that characterize the local behavior of Spec(R) near p.

The localization of R at the prime ideal p is equipped with a canonical map (the localization map) from the ring R, as well as a canonical embedding into the total ring of fractions Frac(R).

The localization of R at the prime ideal p is a local ring, with maximal ideal equal to the extension of the ideal p by the localization map. The quotient by the maximal ideal is called the 'residue field'.!

!OppositeRing commentStamp: '<historical>' prior: 0!
The opposite ring of a given noncommutative ring.!

!ProductRing commentStamp: '<historical>' prior: 0!
Direct products of rings. Elements are tuples (see ProductRingElement) where the i-th component corresponds to an element in the i-th ring of the direct product, and multiplication and addition are defined component-wise.
!

!QuotientRing commentStamp: '<historical>' prior: 0!
Quotient of a commutative ring R modulo an ideal I, written R/I. Elements are residue classes modulo I (see Residue and subclasses).

Given a commutative ring R and an ideal I of R, the quotient ring R/I (read 'R modulo I' or 'R mod I') is the set of cosets (residue clases) of I in R by the equivalence relation a ~ b if a - b is in I. If the ideal is maximal, the resulting quotient ring is a field. If it's only prime, the quotient ring is an integral domain.

The quotient ring R/I is equipped with the projection map that sends elements of R to their residue classes in R/I. The projection map is a canonical homomorphism of rings.!

!ModularIntegerRing commentStamp: '<historical>' prior: 0!
Ring ℤ/nℤ of residue classes of integers modulo n.!

!PrimePowerRing commentStamp: '<historical>' prior: 0!
Residue class ring ℤ/(p^n)ℤ of integers modulo p^n for a prime p.

These are Euclidean rings, and the simplest examples of Galois rings, GR(p^n,1). They are local rings with maximal ideal ⟨p⟩ and residue field isomorphic to ℤ/pℤ. The maximal ideal ⟨p⟩ is also the set of zero divisors as well as nilpotent elements. Other Galois rings are constructed by finite algebraic extensions (see GaloisRing).

These are also the simplest examples of 'chain rings', rings whose ideals form a chain under inclusion. A finite-chain ring is a principal ideal ring, and its maximal ideal is the nilradical (the set of nilpotent elements).

There are canonical projections from ℤ/(p^n)ℤ to ℤ/(p^m)ℤ for any 1 <= m <= n. These projections form a projective system (or inverse system), and the limit is the ring of p-adic integers ℤₚ. There is a canonical projection from ℤₚ to ℤ/(p^n)ℤ, and in this sense ℤ/(p^n)ℤ can be thought of as a truncation or an approximation of precision n of ℤₚ.!

!PrimeField commentStamp: '<historical>' prior: 0!
Residue class field ℤ/pℤ of integers modulo a prime p, or 𝔽ₚ.

These are the simplest examples of Galois fields, GF(p^1). Other Galois fields are constructed by finite algebraic extensions (see GaloisField).!

!BinaryField commentStamp: '<historical>' prior: 0!
Residue class field ℤ/2ℤ of integers modulo 2, or 𝔽₂.
!

!TernaryField commentStamp: '<historical>' prior: 0!
Residue class field ℤ/3ℤ of integers modulo 3, or 𝔽₃.!

!AffineAlgebra commentStamp: '<historical>' prior: 0!
Finitely generated commutative (associative) algebras, implemented as quotients of polynomial rings. They are the coordinate rings of affine varieties (closed subschemes of affine space, see AffineVariety), i.e. they are the rings of regular functions on affine varieties.

When the coefficients ring is a field K and the relations ideal I is maximal, the affine algebra K[X]/I is a field. In this way, affine algebras are multivariate generalizations of number fields and algebraic function fields.

See also PolynomialRing.!

!ExtensionRing commentStamp: '<historical>' prior: 0!
Univariate affine R-algebras of the form R[x]/⟨f⟩ where f is a monic (basic) irreducible polynomial in R[x]. They are also finite R-algebras with underlying module R^n, where n is the degree of f.!

!GaloisRing commentStamp: '<historical>' prior: 0!
The Galois ring GR(p^n,m) is a Galois extension of degree m of the prime power ring ℤ/(p^n)ℤ of characteristic p^n. This is the unique (up to isomorphism) extension of degree m of the ring ℤ/(p^n)ℤ of integers modulo p^n (see PrimePowerRing). When n=1 they are fields (see GaloisField).

Galois rings GR(p^n,m) are local rings with maximal ideal ⟨p⟩, and ⟨p⟩ is also the set of zero divisors. They are also Euclidean rings.

The subrings of GR(p^n,m) correspond to the positive divisors of m.

More generally, any finite local ring can be constructed as a finitely generated GR(p^n,m)-algebra, i.e. a quotient of a polynomial ring (in a number of indeterminates) with coefficients in a Galois ring modulo a primary ideal of the polynomial ring.

Just as prime power rings (see PrimePowerRing) are approximations of the p-adic integer ring ℤₚ, general Galois rings are approximations of the ring of integers of unramified extensions of the p-adic field ℚₚ generated by a (p^m)-th root of unity ζ: GR(p^n,m) = ℤₚ[ζ]/⟨p^n⟩.

For general reference about Galois rings see [GM73] and [BF15].!

!GaloisField commentStamp: '<historical>' prior: 0!
Finite fields GF(p^r) with r>1. These are finite algebraic extensions of prime fields ℤ/pℤ. See also PrimeField.

Galois fields GF(p^r) of a given characteristic p form a lattice of compatibly embedded fields. That is,
GF(p^r) comes with an embedding into GF(p^s) for every r | s, and the embeddings are compatible. See [BCS97].!

!FunctionField commentStamp: '<historical>' prior: 0!
Algebraic function fields, i.e. finite algebraic extensions (absolute or relative) of univariate rational function fields K(t).!

!NumberField commentStamp: '<historical>' prior: 0!
Algebraic number fields, i.e. finite algebraic (absolute or relative) extensions of the rational numbers.!

!CyclotomicField commentStamp: '<historical>' prior: 0!
Cyclotomic fields, i.e. number fields obtained by adjoining a complex primitive root of unity to ℚ. The n-th cyclotomic field is obtained by adjoining a primitive n-th root of unity ζₙ to ℚ, and it is represented uniquely as the extension of ℚ by the n-th cyclotomic polynomial.

Cyclotomic fields come equipped with a choice of embedding into the (algebraic) complex numbers mapping ζₙ to e^(2πi/n). Also, the cyclotomic field of order n comes with an embedding into the cyclotomic field of order m for every n | m, and the embeddings are compatible.

The 3-th cyclotomic field is the field of Eisenstein rationals ℚ(ω), and the 4-th cyclotomic field is the field of Gaussian rationals ℚ(i). See also EisensteinRing and GaussianRing.!

!QuadraticField commentStamp: '<historical>' prior: 0!
Quadratic number fields, i.e. number fields with defining quadratic polynomial of the form x^2 - d, with d a squarefree integer.!

!JetRing commentStamp: '<historical>' prior: 0!
Affine R-algebras of the form Jₖ := R[x₁,...,xₙ]/⟨x₁,...,xₙ⟩^k for an integer k > 0. These are local rings with maximal ideal ⟨x₁,...,xₙ⟩, and their limit (inverse limit) is the ring of formal power series R[[x₁,...,xₙ]]. They are analogous to the prime power rings ℤ/(p^k)ℤ, whose limit is the ring of p-adic integers ℤₚ.

In the particular case of R = ℤ/(p^i)ℤ and n=1, this is the quasi-Galois ring A(p^i,k) = (ℤ/(p^i)ℤ)[x]/⟨x^k⟩.

See also PrimePowerRing.
!

!AlgebraicClosureField commentStamp: '<historical>' prior: 0!
This is the algebraic closure of the finite field 𝔽ₚ constructed as the union of all Galois fields of characteristic p (considered in a lattice of compatibly embedded fields).!

!ComplexAlgebraicField commentStamp: '<historical>' prior: 0!
The field of complex algebraic numbers, i.e. the complex roots of polynomials with rational coefficients.!

!RealAlgebraicField commentStamp: '<historical>' prior: 0!
The field of real algebraic numbers, i.e. the real roots of polynomials with rational coefficients.!

!AbelianClosureField commentStamp: '<historical>' prior: 0!
Abelian closure of ℚ, constructed as the union of all cyclotomic fields ℚ(ζₙ) by the Kronecker-Weber theorem. This is the maximal abelian extension of ℚ and it includes all n-th roots of unity.!

!PolynomialRing commentStamp: '<historical>' prior: 0!
Polynomial ring R[x₁,..,xₙ] in one or many indeterminates over a commutative ring R. These are the finitely generated free commutative (associative) R-algebras.

The number of indeterimnates is called the rank of the polynomial ring. The indeterminates are referred by index (positive integer numbers).

Polynomial rings have an associated monoid of monomials (see FreeAbelianMonoid) with a fixed monomial ordering. This ordering definines the leading term of a polynomial and is used for multivariate division (normal form or reduction) and the computation of Groebner bases and standard bases.

See also AffineAlgebra, RationalFunctionField, AffineSpace.
!

!FiniteAlgebra commentStamp: '<historical>' prior: 0!
Finite (finitely generated as modules) algebras over a commutative ring R. Since they are implemented in the category of rings they are assumed to be associative and unital, but they don't need to be commutative.

An R-algebra is constructed from a R-module, with multiplication given by an associative and unital R-bilinear map. When the module is free of rank n, the multiplication can be given by n³ structure constants (elements of R), or equivalently by n matrices of n×n.

Note that a ring can be a finite algebra without being an instance of this class or any of its subclasses. For example, an affine algebra of Krull dimension 0 is a finite algebra. Being a finite R-algebra essentially means that it understands the message #asModule returning a finitely generated R-module equipped with coercion maps.!

!Order commentStamp: '<historical>' prior: 0!
Order in a global field, i.e. a subring of the global field that is also a full lattice (it generates the global field as a vector space).!

!MaximalOrder commentStamp: '<historical>' prior: 0!
Rings of integers of global fields (i.e. maximal orders). They are the integral closure of the rational integers in a number field or function field. See NumberField and FunctionField.
!

!CyclotomicRing commentStamp: '<historical>' prior: 0!
Rings of integers of cyclotomic number fields. See CyclotomicField.!

!EisensteinRing commentStamp: '<historical>' prior: 0!
The ring of Eisenstein (or Eulerian) integers, ℤ[ω]. This is the ring of integers of the 3-th cyclotomic field defined by the polynomial ω² + ω + 1.!

!GaussianRing commentStamp: '<historical>' prior: 0!
Ring of Gaussian integers ℤ[i]. This is the ring of integers of the field of Gaussian numbers ℚ(i), i.e. the 4-th cyclotomic field.!

!QuadraticRing commentStamp: '<historical>' prior: 0!
Rings of integers of quadratic number fields. See QuadraticField.!

!GroupAlgebra commentStamp: '<historical>' prior: 0!
Group algebra R[G] of a finite group G over a commutative ring R.

Given ring R and a group G, the group ring R[G] can be seen as a ring or as a free R-module with basis one-to-one with G. As a ring, its addition law is that of the free module, and the multiplication extends by linearity from the given group law on the basis.

The elements of the group ring R[G] are finite formal linear combinations of elements of G with coefficients in R, or the finite-support functions from G to R.

When the ring R is commutative, the group ring is also referred to as a group algebra.

Categorically, the group ring construction is left adjoint to the group of units (see UnitsGroup). It's also a 'category algebra' analogous to the monoid ring for monoids and incidence algebra for posets.
!

!QuaternionAlgebra commentStamp: 'len 10/3/2022 08:29:48' prior: 0!
The algebra of quaternions over a ring with given invariants a and b, where a and b are units. This is the 4-dimensional unital algebra generated by elements i, j such that i^2 = a, j^2 = b and ij = -ji.!

!FreeAlgebra commentStamp: '<historical>' prior: 0!
Algebras of noncommutative polynomials in a finite set of indeterminates. These are finitely generated free associative unital algebras, and their elements are FreePolynomials.

This is the noncommutative analogue of a polynomial ring.!

!Module commentStamp: '<historical>' prior: 0!
Finitely presented right R-modules, for a (unital) ring R. These include the particular cases of vector spaces over any computable field, finitely generated abelian groups (i.e. finitely generated ℤ-modules), finitely presented modules over polynomial rings or quotients of polynomial rings, and finitely presented modules over finite associative algebras. Ideals are also modeled as modules.

The implementation relies on the ability to solve systems of linear equations over the coefficients ring R. As long as there are algorithms for solving AX = B and AX = 0 for matrices over R, many important computations with finitely presented R-modules are supported. See [BLH11].

Since the category of ℤ-modules is isomorphic to the category of abelian groups, ℤ-modules are also groups, and group homomorphisms between groups and ℤ-modules are allowed. Similarly, given a commutative ring R, R-modules are also identified with sheaves of modules on Spec(R).

See also ModuleMap and HomModule.!

!Ideal commentStamp: '<historical>' prior: 0!
Finitely generated right ideals of a ring R, i.e. R-submodules of R.!

!IntegralIdeal commentStamp: '<historical>' prior: 0!
Integral ideal of an order in a global field.!

!PolynomialIdeal commentStamp: '<historical>' prior: 0!
Ideal in a polynomial ring. See PolynomialRing.!

!FreeModule commentStamp: '<historical>' prior: 0!
Finite-rank free R-modules on free generators indexed by integers 1 to n. These are modules of n-tuples with coefficients in R.

See also Tuple and Matrix.!

!HomModule commentStamp: '<historical>' prior: 0!
R-module of linear maps from an R-module A to another R-module B, for a commutative ring R. They are the internal Hom(A,B) of the category of R-modules. When A = B, it is denoted End(A).

Note that Hom(A,B) is an R-module if R is commutative, but otherwise it is just a ℤ-module (not necessarily finitely generated), or an S-module if R is an S-algebra.

See Module and ModuleMap.!

!MatrixModule commentStamp: '<historical>' prior: 0!
R-module of matrices with m rows and n columns and cofficients in a commutative ring R, considered as linear maps between free modules of tuples R^n and R^m.

See Matrix and FreeModule.
!

!QuotientModule commentStamp: '<historical>' prior: 0!
Quotient modules M/N (read "M mod N") of a given free module M 'modulo' a submodule N.

The elements of a quotient module M/N are cosets N + x with x in M. See ModuleCoset.
!

!Scheme commentStamp: '<historical>' prior: 0!
A scheme is a topological space equipped with a sheaf of local rings (which makes it a locally ringed space). Subclasses implement particular types of schemes.

See AffineScheme for schemes corresponding to the spectrum Spec(R) of a commutative ring R, and ProjectiveScheme for Proj(R) of a graded commutative ring R.

For schemes defined by polynomial equations in affine or projective space, see subclasses AffineVariety and ProjectiveVariety, which are closed subschemes of affine and projective space respectively.!

!Grassmannian commentStamp: '<historical>' prior: 0!
The Grassmannian Gr(r,Rⁿ) is the set of submodules of rank r of a free module Rⁿ over a PID.!

!AffineScheme commentStamp: '<historical>' prior: 0!
The prime spectrum Spec(R) of a commutative ring R, equipped with a sheaf of local rings (which makes it a locally ringed space). As a topological set, its points are the prime ideals of the coordinate ring R.

The ring R should be thought as the ring of regular functions on Spec(R). Concretely, each element f of R defines a function that takes a point p of Spec(R) (i.e., a prime ideal p of R) to the image of f by the canonical map to the residue field at p.
!

!AffineVariety commentStamp: 'len 10/12/2023 20:56:36' prior: 0!
Closed subschemes of an affine space (see AffineSpace). Their coordinate rings are quotients of multivariate polynomial rings by an ideal (i.e. affine algebras). Their rational points are AffinePoints.

These are schemes, not classical algebraic varieties (they don't need to be reduced, irreducible nor over an algebraically closed field). Here the name 'variety' only means that they are defined by polynomial equations.!

!AffineCurve commentStamp: '<historical>' prior: 0!
Affine algebraic curves, i.e. schemes of dimension 1 over an affine space.!

!AffineHypersurface commentStamp: '<historical>' prior: 0!
Affine algebraic hypersurfaces, i.e. schemes of codimension 1 over an affine space. They can be defined by a single polynomial (the defining ideal is principal).!

!AffinePlaneCurve commentStamp: '<historical>' prior: 0!
Affine plane algebraic curves, i.e. schemes of dimension 1 over an affine plane.!

!AffineSpace commentStamp: '<historical>' prior: 0!
Affine spaces 𝔸^nR as schemes, i.e. Spec R[x₁,...,xₙ] for some commutative ring R. They are seen as schemes over Spec R.

Note that the dimension of an affine space as scheme is the Krull dimension of its coordinate ring, and this can be bigger than the number of indeterminates (see >>#dimension and >>#rank). For affine spaces over fields, the dimension and the rank are equal (because fields have Krull dimension 0).!

!ProjectiveScheme commentStamp: '<historical>' prior: 0!
The projective or homogeneous prime spectrum Proj(R) of a graded commutative ring R, equipped with a sheaf of local rings (making it a locally ringed space). As a topological set, its points are the relevant homogeneous prime ideals of the homogeneous coordinate ring R.

Proj(R) is contained in its affine cone Spec(R). See also AffineScheme.!

!ProjectiveVariety commentStamp: '<historical>' prior: 0!
Projective closed subschemes of a projective space (see ProjectiveSpace). Their homogeneous coordinate rings are quotient rings of multivariate polynomial rings by a homogeneous ideal, i.e. graded affine algebras. Their rational points are ProjectivePoints.

These are schemes, and not classical algebraic varieties (they don't need to be reduced, irreducible nor over an algebraically closed field). Here the name 'variety' only means that they are defined by polynomial equations.!

!ProjectiveCurve commentStamp: '<historical>' prior: 0!
Projective algebraic curves, i.e. projective schemes of dimension 1 over a projective space.!

!ProjectiveHypersurface commentStamp: '<historical>' prior: 0!
Projective algebraic hypersurfaces, i.e. schemes of codimension 1 over a projective space. They can be defined by a single homogeneous polynomial (the defining ideal is principal).!

!ProjectivePlaneCurve commentStamp: '<historical>' prior: 0!
Projective plane algebraic curves, i.e. schemes of dimension 1 over a projective plane.!

!Conic commentStamp: '<historical>' prior: 0!
Projective plane curves of genus 0 and degree 2. They are defined by quadratic polynomials.

Conics, together with rational curves (see RationalCurve), are the only curves of genus 0.

As any genus 0 curve, a conic either has no rational points, or it has infinitely many.!

!RationalCurve commentStamp: '<historical>' prior: 0!
Projective plane curves of genus 0 and degree 1. They are defined by linear polynomials.

Rational curves, together with Conics, are the only curves of genus 0.!

!ProjectiveSpace commentStamp: '<historical>' prior: 0!
Projective spaces ℙ^nR as schemes, i.e. Proj R[x₁,...,xₙ] for some commutative ring R. They are seen as schemes over Spec R.
!

!ProjectiveLine commentStamp: '<historical>' prior: 0!
Projective lines are P^1(R) for some commutative ring R. They are essentially the underlying ring R extended with an additional point at infinity. For example, the complex projective line is the Riemann sphere: the extended complex plane that includes the point at infinity. See also ProjectiveLinePoint.!

!CellComplex commentStamp: '<historical>' prior: 0!
Abstract cell complexes. See subclasses.!

!SimplicialComplex commentStamp: '<historical>' prior: 0!
Abstract simplicial complexes. These are combinatorial objects consisting of a collection of simplices (the 'faces' of the simplicial complex) with the following properties:
- every subface of a face is also in the complex;
- the intersection of two faces is either empty or a common face of both simplices, and it is also in the complex.

An abstract simplicial complex can also be seen as a subset of the power set of some set V, often V={1,...,n}, closed under inclusion.

Simplicial complexes form a category with simplicial maps as morphisms. See SimplicialMap.!

!Vertex commentStamp: '<historical>' prior: 0!
Objects of the free category ℱ(G) of an ordered directed multigraph G. See FreeCategory.!

!CommaObject commentStamp: '<historical>' prior: 0!
Objects of a comma category (see CommaCategory).!

!GroupObject commentStamp: '<historical>' prior: 0!
Group objects in a cartesian category C, i.e. objects of Grp(C).

A 'group object' internal to a cartesian category C with terminal object * is an object G equipped with multiplication μ : G × G → G, unit η : * → G and inverse ι : G → G morphisms satisfying the usual group axioms. Dually, a 'cogroup object' is an object H equipped with comultiplication Δ : H → H × H, counit ε : H → * and inverse ι : H → H morphisms satisfying the dual axioms, and corresponds to an object of Grp(Cᵒᵖ)ᵒᵖ.!

!ModuleObject commentStamp: 'len 8/30/2024 08:04:54' prior: 0!
Right module objects over a monoid object. See ModuleCategory.!

!MonoidObject commentStamp: '<historical>' prior: 0!
Monoid objects in a monoidal category C, i.e. objects of Mon(C).

A 'monoid object' internal to a monoidal category C with unit object 1 is an object A equipped with multiplication μ : A ⊗ A → A and unit η : 1 → A morphisms satisfying the usual associativity and unity axioms. Dually, a 'comonoid object' is an object A equipped with comultiplication Δ : A → A ⊗ A and counit ε : A → 1 morphisms satisfying the coassociativity and counity axioms, and corresponds to an object of Mon(Cᵒᵖ)ᵒᵖ. And a 'bimonoid object' is both a monoid and comonoid object in a compatible way, i.e. multiplication and unit are comonoid morphisms or counit and comultiplication are monoid morphisms.!

!ChainComplex commentStamp: '<historical>' prior: 0!
(Bounded) chain complexes.

A chain complex is a sequence of objects of an additive category C(k) (k-chains) indexed by integers k (degrees), with homomorphisms d(k) : C(k) → C(k-1) (boundary operators or differentials) such that the composition of any two consecutive differentials is the trivial map: d(k)·d(k+1) = 0.

A bounded chain complex is one where only a finite number of C(k) are not 0.

Chain complexes form an additive category (or abelian if the chains are abelian) with chain maps as morphisms. See ChainMap.

See also CochainComplex for the dual notion.!

!FreydObject commentStamp: '<historical>' prior: 0!
Objects of a Freyd category (see FreydCategory).!

!RelationObject commentStamp: '<historical>' prior: 0!
Objects of the category Rel(C) of relations in a regular category C. These just correspond to objects of C. See RelationsCategory.!

!CoherentSheaf commentStamp: '<historical>' prior: 0!
Coherent sheaves of O(X)-modules on a projective scheme X. See also CoherentSheafMap.!

!Morphism commentStamp: '<historical>' prior: 0!
Morphisms between objects of a given category. See also Domain, HomSet and Category.!

!Map commentStamp: '<historical>' prior: 0!
Maps, unlike general morphisms, can be evaluated at elements of the domain (#value:) and they produce elements of the codomain. Every map has an underlying Function that can be obtained with the message #carrier.

In general, maps are defined by specifying a domain, a codomain, and an expression that evaluated at elements of the domain produces elements of the codomain. One such expression can be a Smalltalk block, another map, or any Smalltalk object that admits evaluation (#value:).!

!Functor commentStamp: '<historical>' prior: 0!
A functor between two categories is a function that preserves composition of morphisms. They are morphisms of categories (see Category).

A functor F : C → D between preadditive categories is called 'additive' if for each X,Y it induces homomorphisms of abelian groups Hom(X,Y) → Hom(F(X),F(Y)). Functors between preadditive categories are assumed to be additive.

See https://ncatlab.org/nlab/show/single-sorted+definition+of+a+category
!

!Function commentStamp: '<historical>' prior: 0!
Functions are morphisms in the category of sets.!

!Sequence commentStamp: '<historical>' prior: 0!
Sequences are functions with domain the natural numbers {1,2,...}. They can be evaluated at an index (#value: and #at:), and can also be iterated over like Smalltalk collections (#do:, #collect:, #select:, etc).

Example (the Fibonacci sequence):
	Sequence initialValues: #(0 1) recurrence: [:f :n| (f at: n-1) + (f at: n-2)].

Example (the harmonic numbers):
	Sequence to: ℚ map: [:n| (1 to: n) sum: [:k| 1/k]].
!

!GroupAction commentStamp: '<historical>' prior: 0!
(Left) group actions.

Given a group G and a set X, a (left) group action φ:G×X → X is a function that satisfies:
- Identity: φ(1, x) = x;
- Compatibility: φ(g, φ(h,x)) = φ(g·h, x).

The group G is said to 'act' on X (on the left). The set X is called a (left) G-set (or G-space, G-module, depending on the category of X). Here we just call it 'space'.!

!BilinearMap commentStamp: '<historical>' prior: 0!
Bilinear maps are functions from a cartesian product of two R-modules to (the underlying set of) a R-module, that are linear when fixing one of the arguments.!

!BilinearForm commentStamp: '<historical>' prior: 0!
Bilinear forms are functions from the cartesian square of an R-module to R that are linear when fixing one of the arguments, i.e. that satisfy:
	B(v+cv', w) = B(v, w) + cB(v', w)
	B(v, w+cw') = B(v, w) + cB(v, w')
!

!MonoidMap commentStamp: 'len 4/26/2020 08:57:01' prior: 0!
Monoid homomorphisms. They can be defined by an evaluable expression or Smalltalk block, or by images of generators. See Monoid.!

!GroupMap commentStamp: '<historical>' prior: 0!
Group homomorphisms. They can be defined by an evaluable expression or Smalltalk block, or by images of generators. See Group.!

!RingMap commentStamp: '<historical>' prior: 0!
Homomorphisms of unital rings.

When the rings are finitely generated R-algebras, they can be defined as images of generators. When the domain and codomain are finite R-algebras (i.e., finitely generated as R-modules) they can be defined as R-module maps.!

!ModuleMap commentStamp: '<historical>' prior: 0!
Homomorphisms of finitely presented right R-modules. They are internally represented by a matrix (assuming a choice of finite presentations for the domain and codomain).

See Module and HomModule.!

!Matrix commentStamp: '<historical>' prior: 0!
Matrices with coefficients in a ring R.

A matrix A with m rows and n columns is viewed as a morphism of free modules of tuples R^n → R^m following left action convention: A(x) = A*x; and the composition of A with a matrix B with n rows is A·B, and in this way A(B(x)) = A·B*x.

See also MatrixModule, FreeModule and Tuple.!

!BlockSparseMatrix commentStamp: '<historical>' prior: 0!
Sparse matrices stored in BCSR (Block Compressed Sparse Row) format. They are fast at matrix-tuple multiplication and generally useful over ℤ/2ℤ with small blocks.!

!DenseMatrix commentStamp: '<historical>' prior: 0!
Matrices stored in row-major format. The coefficients are stored starting with the first coefficient of the first row and ending with the last coefficient of the last row.!

!SparseMatrix commentStamp: '<historical>' prior: 0!
Sparse matrices stored in CSR (Compressed Sparse Row) format. They are fast at matrix-tuple multiplication.!

!Submatrix commentStamp: '<historical>' prior: 0!
Submatrix of a dense matrix in row-major format, stored as the array of coefficients of the original matrix, a start index and the row stride (the width of the original matrix).!

!QuadraticForm commentStamp: '<historical>' prior: 0!
Quadratic forms as homogeneous quadratic functions M→R from a finite-rank free R-module to R. Given a basis of M, quadratic forms can be represented as homogeneous quadratic polynomials or as symmetric matrices that define symmetric bilinear forms M×M→R.!

!SchemeMorphism commentStamp: '<historical>' prior: 0!
Morphisms of schemes are morphisms of locally ringed spaces.

A scheme is covered by open affine patches, and a morphism of schemes is locally induced by affine morphisms between affine patches (or dually, ring homomorphisms between the coordinate rings of affine patches).!

!AffineMorphism commentStamp: '<historical>' prior: 0!
Scheme morphism between affine schemes Spec(A) → Spec(B). It is induced by a ring homomorphism B → A.!

!AffinePoint commentStamp: '<historical>' prior: 0!
K-rational points on an affine variety X, seen as morphisms Spec(K) → X.

See also RationalPointSet and AffineVariety.!

!ProjectivePoint commentStamp: '<historical>' prior: 0!
K-rational points on a projective variety X, seen as morphisms Spec(K) → X.

See also RationalPointSet and ProjectiveVariety.!

!ProjectiveLinePoint commentStamp: '<historical>' prior: 0!
Points on the projective line P^1(R) for some ring R. See also ProjectiveLine.!

!RationalMap commentStamp: 'len 6/27/2023 22:05:59' prior: 0!
Rational maps between varieties (closed subschemes of affine or projective space). The domain is assumed to be irreducible. Rational maps are specified by a tuple of rational functions.

Rational maps are partial functions defined in a dense open subset of the domain. The subscheme of the domain where a rational map is undefined is called its base scheme (see >>base).

A rational map is called 'regular' if it defines a morphism of varieties (i.e., for affine varieties it is defined by polynomials). A regular map is called 'dominant' if the image is dense in the codomain.

The category of affine or projective varieties with dominant rational maps and the category of function fields are contravariantly equivalent.!

!SimplicialMap commentStamp: '<historical>' prior: 0!
Morphisms of simplicial complexes. See SimplicialComplex.!

!OppositeMorphism commentStamp: '<historical>' prior: 0!
Morphisms of the opposite category (see OppositeCategory).!

!Path commentStamp: '<historical>' prior: 0!
Morphisms of the free category (or path category) ℱ(G) of an ordered directed multigraph G. See FreeCategory.

A morphism in the free category ℱ(G) is defined as a path, i.e. an ordered list of arrows of G such that two consecutive elements are compatible (the target of each arrow is source of the next).!

!ProductMorphism commentStamp: '<historical>' prior: 0!
Morphisms of a product category (see ProductCategory).!

!Transformation commentStamp: 'len 6/5/2024 18:02:05' prior: 0!
A natural transformation η : F → G between two functors F,G : C → D is a function η' : C → D such that s(η'(x)) = s(F(x)), t(η'(x)) = t(G(x)), and η'(x)·F(y) = G(x)·η'(y) whenever x·y is defined.

A natural transformation can be thought of as a 2-morphism of categories in 2-Cat, and a 1-morphism in the category [C,D] of functors from C to D (or D-valued presheaves on Cᵒᵖ).
!

!CommaMorphism commentStamp: '<historical>' prior: 0!
Morphisms of a comma category (see CommaCategory).!

!ChainMap commentStamp: '<historical>' prior: 0!
A chain map between two chain complexes defined by differentials d(k) : C(k) → C(k-1) and d'(k) : C'(k) → C'(k-1) is a sequence of homomorphisms f(k) : C(k) → C'(k) that commute with the differentials in the two complexes: d'(k)·f(k) = f(k-1)·d(k). They send cycles to cycles and boundaries to boundaries, and this descends to a map in homology H(k) → H'(k).

Chain maps are morphisms in the category of chain complexes. See ChainComplex.!

!FreydMorphism commentStamp: '<historical>' prior: 0!
Morphisms of a Freyd category (see FreydCategory).!

!Relation commentStamp: '<historical>' prior: 0!
A relation from X to Y is represented as an isomorphism class of jointly-monic ordered spans X ← Z → Y, and we call X ← Z the 'coarrow' and Z → Y the 'arrow'. This corresponds to a subobject of X × Y.

These are morphisms in the category Rel(C) of relations in a regular category C. See RelationsCategory.!

!CoherentSheafMorphism commentStamp: '<historical>' prior: 0!
Morphisms of coherent sheaves. See Sheaf.!

!Monomial commentStamp: '<historical>' prior: 0!
Commutative power products of one or many indeterminates. They form a monoid (see FreeAbelianMonoid). Their formal linear combinations over a ring are Polynomials (see also PolynomialRing).

See also Word for the noncommutative analog, and Tuple for an additive analog.!

!Word commentStamp: '<historical>' prior: 0!
Words are noncommutative formal products on a finite ordered list of indeterminates. They are elements of the FreeMonoid, or the FreeGroup when negative exponents are allowed.

See also Monomial for the commutative analog, and Tuple for an additive analog.!

!MonomialOrdering commentStamp: '<historical>' prior: 0!
A monomial ordering is a total order on the set of all monomials in n indeterminates, satisfying the properties:
- respects multiplication: if u <= v, then u*w <= v*w for any other monomial w;
- 1 <= u for any monomial u.

Orderings are used in the computation of Groebner bases and more generally standard bases.!

!BlockMonomialOrdering commentStamp: '<historical>' prior: 0!
Block or product monomial orderings. They are used, for example, to define elimination orderings such that a subset of the indeterminates are always greater than the rest of the indeterminates.!

!GradedLexicographicOrdering commentStamp: '<historical>' prior: 0!
The graded (or total degree) lexicographic ordering first compares the total degree of the monomials, and takes the monomial with largest total degree. If two monomials have the same total degree, the lexicographic ordering is used to break the tie.

The graded lexicographic ordering has the property that for each subring S[x₁...xₙ] <= R, and each homogeneous polynomial f in R, f is in S iff its leading monomial is in S.

Elimination by the graded lexicographic ordering produces elements of an homogeneous ideal which are free of the first variable.!

!GradedReverseLexicographicOrdering commentStamp: '<historical>' prior: 0!
The graded (or total degree) reverse lexicographic ordering first compares the total degree of the monomials, and takes the monomial with largest total degree. If two monomials have the same total degree, the reverse lexicographic ordering is used to break the tie (this is the lexicographic ordering on the reversed list of indeterminates (xₙ...x₁).

The graded reverse lexicographic ordering has the property that for each subring S[x₁...xₙ] <= R, and each homogeneous polynomial f in S[x₁...xᵢ], xᵢ divides f iff it divides the leading monomial.

Elimination by the graded reverse lexicographic ordering produces elements of a homogeneous ideal which are divisible by the last variable.!

!LexicographicOrdering commentStamp: '<historical>' prior: 0!
The lexicographic ordering is the 'dictionary' ordering. The first indeterminate is the greatest.

The lexicographic ordering has the property that for each subring S[x₁...xₙ] <= R, and each polynomial f in R, f is in S iff its leading monomial is in S.

The lexicographic ordering is useful for solving systems of algebraic equations. Elimination by the lexicographic ordering produces elements of an ideal which are free of the first variable.!

!LocalGradedLexicographicOrdering commentStamp: 'len 2/12/2017 06:10:10' prior: 0!
The local graded lexicographic order (lglex) is the negation of the global graded lexicographic order (glex).

This is the order called 'lglex' in Magma. What Singular calls 'Ds', on the other hand, is like this but with the indeterminates reversed.!

!LocalGradedReverseLexicographicOrdering commentStamp: 'len 2/12/2017 06:10:33' prior: 0!
The local graded reverse lexicographic order (lgrevlex) is the negation of the global graded reverse lexicographic order (grevlex).

This is the order called 'lgrevlex' in Magma. What Singular calls 'ds', on the other hand, is like this but with the indeterminates reversed.!

!LocalLexicographicOrdering commentStamp: '<historical>' prior: 0!
The local lexicographic order (llex) is the negation of the global lexicographic order.

This is the order called 'llex' in Magma. What Singular calls 'ls', on the other hand, is like this but with the indeterminates reversed.!

!Coset commentStamp: '<historical>' prior: 0!
Elements of a QuotientGroup.!

!ProductGroupElement commentStamp: '<historical>' prior: 0!
Elements of group direct products, i.e. tuples of group elements. See ProductGroup.!

!SemidirectProductElement commentStamp: '<historical>' prior: 0!
Elements of a semidirect product of groups. See SemidirectProductGroup.!

!Permutation commentStamp: '<historical>' prior: 0!
Permutations are bijective functions on a finite set or collection Ω. They are elements of the symmetric group Sym(Ω). See SymmetricGroup and PermutationGroup.!

!RingElement commentStamp: '<historical>' prior: 0!
Elements of a Ring.!

!OppositeRingElement commentStamp: '<historical>' prior: 0!
Elements of the opposite ring of a given noncommutative ring. See OppositeRing.!

!ProductRingElement commentStamp: '<historical>' prior: 0!
Elements of product rings, i.e. tuples of ring elements. See ProductRing.!

!Ratio commentStamp: '<historical>' prior: 0!
Ordered pairs written a/b, with a and b in a commutative ring R, and satisfying the equivalence relation: a/b = c/d iff a*d = c*b.

They are elements of the fraction field or total ring of fractions Frac(R). See FractionRing.!

!Germ commentStamp: '<historical>' prior: 0!
Elements of localizations of rings at a prime ideal, also called germs. See LocalRing.!

!Rational commentStamp: '<historical>' prior: 0!
Elements of the field of rational numbers. See RationalField.!

!RationalFunction commentStamp: '<historical>' prior: 0!
Rational functions are fractions of polynomials. They are elements of the field of fractions of a polynomial ring over a field (see RationalFunctionField).!

!Residue commentStamp: '<historical>' prior: 0!
Elements of a quotient ring (see QuotientRing). These are residue classes of elements of a commutative ring modulo an ideal.!

!GaloisRingElement commentStamp: '<historical>' prior: 0!
Elements of Galois rings. See GaloisRing.!

!GaloisFieldElement commentStamp: '<historical>' prior: 0!
Elements of Galois fields. See GaloisField.!

!ModularInteger commentStamp: '<historical>' prior: 0!
Residue classes of integers modulo n, i.e. elements of the quotient ring ℤ/nℤ.!

!AlgebraicRational commentStamp: '<historical>' prior: 0!
Elements of number fields or function fields. See NumberField and FunctionField.!

!CyclotomicRational commentStamp: '<historical>' prior: 0!
Elements of the field of Gaussian numbers ℚ[i] that corresponds to the 4-th cyclotomic field. See CyclotomicField.!

!AlgebraicClosureElement commentStamp: '<historical>' prior: 0!
Elements of the algebraic closure of the finite field 𝔽ₚ.!

!ComplexAlgebraicNumber commentStamp: '<historical>' prior: 0!
Complex roots of polynomials with rational coefficients, represented as their minimal polynomial over ℚ and a ball (a closed disk in the complex plane) isolating the root from its conjugates.!

!RealAlgebraicNumber commentStamp: '<historical>' prior: 0!
Real roots of polynomials with rational coefficients, represented as their minimal polynomial over ℚ and a ball (a closed real interval) isolating the root from its conjugates.!

!AbelianClosureElement commentStamp: 'len 11/22/2023 10:25:49' prior: 0!
Elements of the abelian closure of ℚ.!

!Polynomial commentStamp: '<historical>' prior: 0!
Polynomials in one or many indeterminates, with coefficients in a commutative ring. These are elements of a PolynomialRing.

Polynomials are stored as a collection of coefficients. In the case of univariate polynomials they are stored as an array indexed by degree+1, and multivariate polynomials are stored as a sparse dictionary indexed by monomials (which in turn is stored as a list of pairs 'monomial -> coefficient' sorted by the corresponding monomial ordering.

See also PolynomialRing, RationalFunction.!

!MultivariatePolynomial commentStamp: '<historical>' prior: 0!
Polynomials in one or more indeterminates, represented in sparse form.

Multivariate polynomials are internally stored as a list of associations 'monomial -> coefficient'. Zero coefficients are excluded, and the list is kept sorted according to the monomial ordering.!

!UnivariatePolynomial commentStamp: '<historical>' prior: 0!
Univariate polynomials, represented in dense form.

They are stored as a Tuple indexed by degree (the first element of the coefficients tuple corresponds to the independent coefficient of the polynomial).!

!FiniteAlgebraElement commentStamp: '<historical>' prior: 0!
Elements of (associative unital) algebras over a commutative ring R. See FiniteAlgebra.!

!AlgebraicInteger commentStamp: '<historical>' prior: 0!
Elements of maximal orders in number fields or function fields. See MaximalOrder.!

!EisensteinInteger commentStamp: '<historical>' prior: 0!
Elements of the ring of Eisenstein integers ℤ[ω]. See EisensteinRing.!

!GaussianInteger commentStamp: '<historical>' prior: 0!
Elements of the ring of Gaussian integers ℤ[i]. See GaussianRing.!

!QuadraticInteger commentStamp: '<historical>' prior: 0!
Elements of the ring of integers of quadratic fields. See QuadraticRing.!

!GroupAlgebraElement commentStamp: '<historical>' prior: 0!
Linear combinations of group elements. These are elements of GroupAlgebras.!

!Multivector commentStamp: 'len 7/15/2020 06:06:04' prior: 0!
Elements of a Clifford algebra or an exterior algebra. See CliffordAlgebra.!

!Quaternion commentStamp: 'len 7/14/2020 21:25:41' prior: 0!
Elements of a quaternion algebra. See QuaternionAlgebra.!

!FreePolynomial commentStamp: '<historical>' prior: 0!
Polynomials in a finite set of noncommuting indeterminates. They are elements of a free associative algebra (see FreeAlgebra).

A free polynomial is a formal linear combination of Words, that in turn are formal noncommutative products of indeterminates.!

!FractionalIdeal commentStamp: 'len 6/13/2024 14:05:18' prior: 0!
Fractional ideal of a Dedekind domain.

In general, for an integral domain R with fraction field K, a fractional ideal of R is an R-submodule of K. When R is a Dedekind domain, the set of (nonzero) fractional ideals forms a multiplicative commutative group denoted by Div(R). Fractional ideals are represented by a numerator (an integral nonzero ideal of R) and a denominator (an element of R).!

!ModuleCoset commentStamp: '<historical>' prior: 0!
Elements of R-modules. See Module.!

!Tuple commentStamp: '<historical>' prior: 0!
Tuples with coefficients in a ring R, i.e. finite ordered lists of n elements of R indexed by integers 1 to n. They are elements of a free modules Rⁿ (see FreeModule).

Different ways to create the tuple (1,2,4,8) with integer coefficients:
	(1,2,4,8).
	ℤ !!!! #(1 2 4 8).
	ℤ^4 !! #(1 2 4 8).
	ℤ^4 fill: [:i| 2^(i-1)]!

!MultivariateTuple commentStamp: '<historical>' prior: 0!
Tuples with coefficients in a polynomial ring R. They are elements of free modules Rⁿ (see FreeModule).
!

!ModuleMonomial commentStamp: '<historical>' prior: 0!
Monomials of free modules R^n where R is a polynomial ring. They are the formal product of a monomial of R by a basis element.!

!ModuleMonomialOrdering commentStamp: '<historical>' prior: 0!
Monomial orderings for free modules R^n where R is a polynomial ring. They extend the monomial ordering of R to tuples with coefficients in R.!

!POTMonomialOrdering commentStamp: '<historical>' prior: 0!
"Position Over Term" ordering.

Given tuple monomials x[i] and y[i], x[i] < y[j] iff i < j or i = j and x < y.

A Grobner basis computed with the POT ordering is analogous to a matrix echelon form.!

!TOPMonomialOrdering commentStamp: '<historical>' prior: 0!
"Term Over Position" ordering.

Given tuple monomials x[i] and y[i], x[i] < y[j] iff x < y or x = y and i < j.!

!Divisor commentStamp: '<historical>' prior: 0!
Formal sums with integer or rational coefficients of prime divisors (integral closed subschemes of codimension 1, or rational points in the case of curves) of an integral locally Noetherian scheme. See DivisorGroup.!

!AdditionChain commentStamp: '<historical>' prior: 0!
An addition chain computing an integer n is given by a sequence v such that:
	v = (v₀, ..., vₛ), v₀ = 1, vₛ = n
	vᵢ = vⱼ + vₖ for some 0 ≤ j, k < i.

Short addition chains are useful for implementing fast exponentiation with a fixed exponent. See [Coh+05, Section 9.2.1].!

!BabyStepGiantStep commentStamp: 'len 6/4/2023 20:49:45' prior: 0!
This is Daniel Shanks' Baby-Step/Giant-Step algorithm for computing discrete logarithms (see [Sha71]). Given an element α in a group G, and a bound n for the order of α, the algorithm can compute the discrete logarithm of another element β with respect to α, that is it computes i such that (in multiplicative notation) β = αⁱ. The algorithm precomputes a hash table of size √n containing powers of α, that is then used for computing the discrete logarithm of any β.!

!Ball commentStamp: 'len 11/12/2023 22:23:23' prior: 0!
Closed balls in the real line (intervals) or the complex plane (disks), defined by a center point and a radius.!

!BrentKung commentStamp: 'len 6/10/2023 09:52:37' prior: 0!
This is the Brent-Kung modular composition algorithm [BK78]. See also [Coh+05, Algorithm 11.50].!

!CRT commentStamp: '<historical>' prior: 0!
This is the Garner's Chinese Remainder Algorithm. It finds solutions to systems of linear Diophantine equations x = xᵢ (mod mᵢ) for fixed mᵢ and varying xᵢ. and it works over any Euclidean domain.

Input: x₁..xₖ, k elements in a Euclidean domain, and m₁..mₖ pairwise coprime, defining the Diophantine system x = xᵢ (mod mᵢ);
Output: x such that x = xᵢ (mod mᵢ) for 1≤i≤k.
!

!ComplexBox commentStamp: '<historical>' prior: 0!
Closed boxes in the complex plane, defined by two real intervals (for the real and imaginary parts).!

!ComplexRootIsolator commentStamp: '<historical>' prior: 0!
This is the CEVAL algorithm [1] for isolating the complex roots of a squarefree polynomial in ℚ[x].

[SY09] Michael Sagraloff, Chee K. Yap, "An Efficient and Exact Subdivision Algorithm for Isolating Complex Roots of a Polynomial and its Complexity Analysis" (2009)!

!Division commentStamp: '<historical>' prior: 0!
This is the output of the division algorithm. The actual algorithm can be implemented in a method somewhere else, or in a subclass.!

!ExtendedEuclid commentStamp: '<historical>' prior: 0!
This is the extended Euclidean algorithm.

Input: an array of two elements {a,b} in a Euclidean ring
Output: the GCD of a with b, and a pair of Bézout coefficients {u,v} such that a*u + b*v = (a,b).

In the case of integers, if |a|≤|b| the output |u| and |v| are unique and satisfy:
	-|a| / d < v*sign(b) ≤ 0.
	1 ≤ u*sign(a) ≤ |b| / d
where d = gcd(a,b).

For integers, the algorithm takes time O(ln³ N) where |a|,|b| ≤ N. For polynomials of degree n, it is O(n³).!

!FFT commentStamp: '<historical>' prior: 0!
Fast Number Theoretic Transforms, the analog of FFTs over 𝔽ₚ with p = k2ⁿ+1.!

!GrayCode commentStamp: '<historical>' prior: 0!
A n-bit Gray code is all 2ⁿ binary strings of length n, ordered so that each differs by exactly one bit in one position from each of its neighbors. For example, one 3-bit Gray code is {000, 001, 011, 010, 110, 111, 101, 100}. See [Gra53].!

!LagrangeGaussReduction commentStamp: '<historical>' prior: 0!
This is the Lagrange-Gauss reduction algorithm. My instances perform reduction of lattice basis of rank 2, and the algorithm it is essentially Euclid's algorithm.

Input: a vector space V and two independent vectors {v₁,v₂} that generate a lattice;
Output: a short vector in the lattice.
!

!NumericalComplexRootIsolator commentStamp: '<historical>' prior: 0!
This algorithm separates complex roots of polynomials with real or complex coefficients. This is Newton's modified algorithm [1], and the convergence is quadratic. The polynomial is assumed to be squarefree.

Input: a squarefree polynomial of degree n with real or complex coefficients, and a desired minimum absolute error (tolerance);
Output: a collection of the n complex roots of the polynomial.

See [Coh96] Algorithm 3.6.6.!

!ProductReplacementRandomGenerator commentStamp: '<historical>' prior: 0!
Product Replacement Algorithm for generating random elements in a group from a set of generators. Essentially, it performs a random walk on a Cayley graph.!

!PseudoDivision commentStamp: '<historical>' prior: 0!
This is the pseudo-division algorithm for univariate polynomials over an arbitrary commutative ring.

Input: dividend and divisor polynomials f and g in R[x], where R is a commutative ring;
Output: quotient and remainder polynomials q and r in R[x], such that b*f = q*g + r, deg(f) = deg(g) + deg(q), deg(r) < deg(g) and b = LC(g)^max(0,deg(f)-deg(g)+1).

The algorithm performs O(n²) arithmetic operations for dense polynomials of degree n.!

!SchreierTree commentStamp: '<historical>' prior: 0!
Given a finite group G with a generating set S, and an action of G on X, a Schreier tree with root x for S is a representation of the orbit of x: it's a tree rooted at x with the elements of x^G as its vertices, and its edges describing the elements of S needed to get from x to each vertex, i.e. each edge {i,j} in the tree with i closer to the root than j is labeled by a generator s in S moving i to j.

Schreier trees allow for fast computation of stabilizers by Schreier's Lemma: with the notation above, the stabilizer of x is generated by the set of Schreier generators ⟨t(i) * s * t(s(i))⁻¹⟩ where i runs over the orbit of x, s runs over the generating set S, and t(i) is an element of G moving x to i, i.e. a coset representative of i (see >>trace: and >>traceInverse:).

See [Sim70], [HEO05, 4.4.2 The Schreier-Sims Algorithm].!

!TonelliShanks commentStamp: '<historical>' prior: 0!
This is the Tonelli-Shanks algorithm for computing square roots in a prime field ℤ/pℤ (with odd p).

See [Coh96] Algorithm 1.5.1.!

!Echelonization commentStamp: '<historical>' prior: 0!
Abstract superclass for row-style echelonization algorithms. Given a matrix A, they compute a matrix E in reduced row echelon form and a unimodular matrix T such that T*A = E.!

!GaussJordanEchelonization commentStamp: '<historical>' prior: 0!
This is the Gauss-Jordan elimination algorithm. It performs Gaussian elimination on a matrix to compute its reduced row echelon form. It can work with matrices over fields or more general division rings such as the quaternions.

The algorithm performs O(2n³/3) field operations for n by n matrices, but due to exponential growth of intermediate coefficients it can be impractical in many situations (for example over the rationals).!

!HermiteEchelonization commentStamp: '<historical>' prior: 0!
This is the Hermite row reduction algorithm. Given a matrix with coefficients in a Euclidean domain, it reduces the matrix to its row-style Hermite normal form.

The algorithm is essentially Algorithm 2.4.4 in [Coh96] but modified to do row reduction instead of column reduction and generalized to Euclidean domains.!

!HowellEchelonization commentStamp: '<historical>' prior: 0!
This is the Howell row reduction algorithm. Given a matrix with coefficients in a PIR with an extended GCD algorithm to compute Bézout coefficients (for example ℤ/nℤ or other Euclidean ring, possibly with zero divisors), it reduces the matrix to its Howell normal form. See [How86], [Sto00], [SM98], [FH16].!

!MultivariateDivision commentStamp: '<historical>' prior: 0!
This is the multivariate polynomial division algorithm for polynomials over a commutative ring.

Input: dividend f and divisors f₁,..,fₛ in R[x₁..xₖ] with a monomial ordering;
Output: quotients q₁,..,qₛ and remander r in R[x₁..xₖ] such that f = q₁*f₁ + ... + qₛ*fₛ + r, and:
1. LM(qᵢ*fᵢ) <= LM(f);
2. None of the monomials in r is divisible by any LM(fᵢ).

The algorithm performs O(n^k m^k) operations in the coefficients ring R, where n is the total degree of f and m is the maximum total degree of f₁..fₛ.!

!StrongBuchberger commentStamp: '<historical>' prior: 0!
This is the Buchberger algorithm for computing strong Groebner bases over a Euclidean ring (possibly with zero divisors), based on [EPP18] and [EH19].

Input: a matrix over a polynomial ring over a Euclidean ring with a choice of monomial ordering;
Output: a reduced strong standard basis or Groebner basis of the module generated by the columns.

When the monomial ordering is global, the algorithm outputs a Groebner basis. In case of a local monomial ordering, the algorithm uses Mora's normal form and outputs a standard basis.
!

!Buchberger commentStamp: '<historical>' prior: 0!
This is the Buchberger algorithm for computing Groebner bases over a field.

Input: a matrix over a polynomial ring over a field with a choice of monomial ordering;
Output: a reduced standard basis or Groebner basis of the module generated by the columns.

When the monomial ordering is global, the algorithm outputs a Groebner basis. In case of a local monomial ordering, the algorithm uses Mora's normal form and outputs a standard basis.
!

!ExtendedStrongBuchberger commentStamp: '<historical>' prior: 0!
This is the extended Buchberger algorithm for computing strong Groebner bases over a Euclidean ring (possibly with zero divisors), based on [EPP18] and [EH19]. It keeps track of how the polynomials in the Groebner basis arise as linear combinations of the original generators, and produces a matrix that maps the original generators to the Groebner basis.

Input: a matrix over a polynomial ring over a Euclidean ring with a choice of *global* monomial ordering;
Output: a reduced strong Groebner basis of the module generated by the columns, and a 'change of basis' matrix that maps the original generators to the Groebner basis.

See StrongBuchberger for a more general algorithm that works with both global and local monomial orderings.!

!ExtendedBuchberger commentStamp: '<historical>' prior: 0!
This is the extended Buchberger algorithm for computing Groebner bases over a field. It keeps track of how the polynomials in the Groebner basis arise as linear combinations of the original generators, and produces a matrix that maps the original generators to the Groebner basis.

Input: a matrix over a polynomial ring over a field with a choice of *global* monomial ordering;
Output: a reduced Groebner basis of the module generated by the columns, and a 'change of basis' matrix that maps the original generators to the Groebner basis.

See Buchberger for a more general algorithm that works with both global and local monomial orderings.!

!BinaryArray methodsFor: 'accessing' stamp: 'len 5/4/2023 23:40:46'!
at: anInteger
	^ (self bitAt: anInteger) = 1 ifTrue: [One] ifFalse: [Zero]! !

!BinaryArray methodsFor: 'accessing' stamp: 'len 5/4/2023 23:40:46'!
at: anInteger put: aBit
	self bitAt: anInteger put: aBit representative.
	^ aBit! !

!BinaryArray methodsFor: 'accessing' stamp: 'len 5/9/2023 19:05:22'!
atAllPut: anObject
	anObject = Zero ifFalse: [^ super atAllPut: anObject].
	words atAllPut: 0! !

!BinaryArray methodsFor: 'accessing' stamp: 'len 5/9/2023 14:32:05'!
firstNonzeroIndex
	"Answer the index of the first nonzero entry, or nil."
	| wordIndex |
	(wordIndex _ words firstNonzeroIndex) ifNil: [^ nil].
	^ wordIndex - 1 * 32 + (words at: wordIndex) lowBit! !

!BinaryArray methodsFor: 'accessing' stamp: 'len 6/9/2023 12:29:11'!
from: startIndex to: endIndex put: anObject
	anObject = Zero ifFalse: [^ super from: startIndex to: endIndex put: anObject].
	words clearBitsFrom: startIndex to: endIndex.
	^ anObject! !

!BinaryArray methodsFor: 'accessing' stamp: 'len 5/7/2023 17:43:06'!
lastNonzeroIndex
	"Answer the index of the last nonzero entry, or nil."
	| wordIndex |
	(wordIndex _ words lastNonzeroIndex) ifNil: [^ nil].
	^ wordIndex - 1 * 32 + (words at: wordIndex) highBit! !

!BinaryArray methodsFor: 'accessing' stamp: 'len 5/15/2023 17:37:50'!
lift
	^ ℤ new: self size fill: [:i| self bitAt: i]! !

!BinaryArray methodsFor: 'accessing' stamp: 'len 5/15/2023 17:38:12'!
representative
	^ self lift! !

!BinaryArray methodsFor: 'accessing' stamp: 'len 5/15/2023 16:10:01'!
scalars
	^ Zero parent! !

!BinaryArray methodsFor: 'accessing' stamp: 'len 5/7/2023 17:44:33'!
size
	^ size! !

!BinaryArray methodsFor: 'comparing' stamp: 'len 5/7/2023 17:40:50'!
= anObject
	^ self class = anObject class and: [size = anObject size and: [words = anObject words]]! !

!BinaryArray methodsFor: 'comparing' stamp: 'len 5/7/2023 17:42:43'!
hash
	^ words hash! !

!BinaryArray methodsFor: 'converting' stamp: 'len 1/3/2024 08:03:13'!
asForm
	^ Form extent: self size @ 1 depth: -1 bits: words! !

!BinaryArray methodsFor: 'converting' stamp: 'len 5/7/2023 17:41:52'!
asInteger
	| answer |
	answer _ 0.
	words reverseDo: [:each| answer _ answer << 32 bitXor: each].
	^ answer! !

!BinaryArray methodsFor: 'copying' stamp: 'len 5/7/2023 17:42:35'!
copyWith: aBit
	| answer |
	answer _ self class new: self size + 1 words: (size \\ 32 = 0 ifTrue: [words copyWith: 0] ifFalse: [words copy]).
	aBit = One ifTrue: [^ answer at: self size+1 put: One; yourself].
	aBit = Zero ifTrue: [^ answer].
	^ self error: 'not one or zero'! !

!BinaryArray methodsFor: 'copying' stamp: 'len 5/7/2023 17:43:42'!
postCopy
	super postCopy.
	words _ words copy! !

!BinaryArray methodsFor: 'enumerating' stamp: 'len 5/14/2023 18:32:01'!
allSatisfy: aBlock
	"Optimized. There are only two possible elements that could satisfy aBlock (1 or 0)."
	| oneValue zeroValue |
	self isEmpty ifTrue: [^ true].
	((zeroValue _ aBlock value: Zero) and: [self isZero]) ifTrue: [^ true].
	((oneValue _ aBlock value: One) and: [self isAllOnes]) ifTrue: [^ true].
	^ zeroValue & oneValue! !

!BinaryArray methodsFor: 'enumerating' stamp: 'len 5/9/2023 21:06:39'!
anySatisfy: aBlock
	"Optimized. There are only two possible elements that could satisfy aBlock (1 or 0)."
	self isEmpty ifTrue: [^ false].
	^ ((aBlock value: One) and: [self isZero not]) or: [(aBlock value: Zero) and: [self isAllOnes not]]! !

!BinaryArray methodsFor: 'enumerating' stamp: 'len 5/10/2023 10:25:44'!
count: aBlock
	| h answer |
	h _ self weight.
	answer _ 0.
	(h < size and: [aBlock value: Zero]) ifTrue: [answer _ answer + size - h].
	(h > 0 and: [aBlock value: One]) ifTrue: [answer _ answer + h].
	^ answer! !

!BinaryArray methodsFor: 'enumerating' stamp: 'len 5/10/2023 10:33:52'!
detect: aBlock ifNone: exceptionBlock
	self isEmpty ifTrue: [^ exceptionBlock value].
	((aBlock value: One) and: [self isZero not]) ifTrue: [^ One].
	((aBlock value: Zero) and: [self isAllOnes not]) ifTrue: [^ Zero].
	^ exceptionBlock value! !

!BinaryArray methodsFor: 'enumerating' stamp: 'len 5/10/2023 11:07:56'!
indexOf: anElement ifAbsent: exceptionBlock
	anElement = One ifTrue: [^ self firstNonzeroIndex ifNil: exceptionBlock].
	anElement = Zero ifFalse: [^ exceptionBlock value].
	self flag: #fixme. "TODO"
	^ super indexOf: anElement ifAbsent: exceptionBlock! !

!BinaryArray methodsFor: 'enumerating' stamp: 'len 6/19/2023 01:08:05'!
product: aBlock
	| h |
	h := self weight.
	self isEmpty ifTrue: [^ self errorEmptyCollection].
	h = size ifTrue: [^ (aBlock value: One) ^ h].
	h = 0 ifTrue: [^ (aBlock value: Zero) ^ size].
	^ (aBlock value: One) ^ h * ((aBlock value: Zero) ^ (size - h))! !

!BinaryArray methodsFor: 'enumerating' stamp: 'len 5/10/2023 11:00:42'!
sum: aBlock ifEmpty: emptyBlock
	| h |
	self isEmpty ifTrue: [^ emptyBlock value].
	h _ self weight.
	h = 0 ifTrue: [^ (aBlock value: Zero) * size].
	h = size ifTrue: [^ (aBlock value: One) * size].
	^ (aBlock value: Zero) * (size - h) + ((aBlock value: One) * h)! !

!BinaryArray methodsFor: 'enumerating' stamp: 'len 5/16/2023 13:05:53'!
supportDo: aBlock
	words bitSupportDo: aBlock! !

!BinaryArray methodsFor: 'operations' stamp: 'len 6/6/2023 08:48:45'!
* anObject
	anObject isInteger ifTrue: [^ anObject even ifTrue: [self zeros] ifFalse: [self]].
	self class = anObject class ifTrue: [^ self ∧ anObject].
	^ super * anObject! !

!BinaryArray methodsFor: 'operations' stamp: 'len 5/9/2023 14:24:53'!
+ anObject
	| otherWords newWords |
	(anObject class = self class and: [size = anObject size]) ifFalse: [^ super + anObject].
	otherWords _ anObject words.
	newWords _ WordArray new: words size.
	1 to: words size do: [:i| newWords at: i put: ((words at: i) bitXor: (otherWords at: i))].
	^ self class new: size words: newWords! !

!BinaryArray methodsFor: 'operations' stamp: 'len 5/4/2023 23:40:46'!
- anObject
	^ self + anObject! !

!BinaryArray methodsFor: 'operations' stamp: 'len 6/6/2023 13:18:32'!
evaluateFrom: start to: stop at: anElement
	stop < start ifTrue: [^ anElement * Zero].
	Zero = anElement ifTrue: [^ self at: start].
	One = anElement ifTrue: [^ self sumFrom: start to: stop].
	^ super evaluateFrom: start to: stop at: anElement! !

!BinaryArray methodsFor: 'operations' stamp: 'len 5/4/2023 23:40:46'!
negated
	^ self! !

!BinaryArray methodsFor: 'operations' stamp: 'len 5/17/2023 19:12:41'!
not
	"Answer an array whose bits are the logical negation of the receiver's bits."
	| newWords |
	newWords _ words collect: [:each| each bitInvert bitAnd: 16rFFFFFFFF].
	newWords at: words size put: (newWords last bitAnd: (1 << (size - 1 \\ 32 + 1) - 1)).
	^ self class new: size words: newWords! !

!BinaryArray methodsFor: 'operations' stamp: 'len 5/13/2023 07:50:03'!
parity
	"Answer 1 if the receiver has an odd number of bits on, 0 if it has an even number of bits on."
	^ (words inject: 0 into: [:result :each| result bitXor: each]) bitParity32! !

!BinaryArray methodsFor: 'operations' stamp: 'len 5/9/2023 18:37:52'!
product
	^ self isAllOnes ifTrue: [One] ifFalse: [Zero]! !

!BinaryArray methodsFor: 'operations' stamp: 'len 5/12/2023 00:07:06'!
sum
	"Answer the sum of the bits, i.e. the parity."
	^ self parity = 1 ifTrue: [One] ifFalse: [Zero]! !

!BinaryArray methodsFor: 'operations' stamp: 'len 5/15/2023 18:00:41'!
weight
	"Answer the Hamming weight of the receiver, i.e. the number of entries that are not zero."
	^ words bitCount! !

!BinaryArray methodsFor: 'operations' stamp: 'len 5/15/2023 15:17:19'!
∧ anArray
	| otherWords newWords |
	otherWords _ anArray words.
	newWords _ WordArray new: (words size min: otherWords size).
	1 to: newWords size do: [:i| newWords at: i put: ((words at: i) bitAnd: (otherWords at: i))].
	^ self class new: (size min: anArray size) words: newWords! !

!BinaryArray methodsFor: 'operations' stamp: 'len 5/15/2023 15:21:34'!
∨ anArray
	| otherWords newWords |
	otherWords _ anArray words.
	newWords _ WordArray new: (words size max: otherWords size).
	1 to: (words size min: otherWords size) do: [:i| newWords at: i put: ((words at: i ifAbsent: [0]) bitOr: (otherWords at: i ifAbsent: [0]))].
	^ self class new: (size max: anArray size) words: newWords! !

!BinaryArray methodsFor: 'operations' stamp: 'len 5/15/2023 15:15:35'!
⊕ anArray
	^ self + anArray! !

!BinaryArray methodsFor: 'operations-low level' stamp: 'len 12/27/2023 15:40:34'!
· anArray
	| sum |
	self class = anArray class ifFalse: [^ super · anArray].
	sum := 0.
	1 to: (words size min: anArray words size) do: [:i|
		sum := ((words at: i) bitAnd: (anArray words at: i)) bitXor: sum].
	^ sum bitParity32 = 0 ifTrue: [Zero] ifFalse: [One]! !

!BinaryArray methodsFor: 'operations-low level' stamp: 'len 12/28/2023 20:17:29'!
findFirstNonzeroFrom: start to: stop
	"Answer the index of the first nonzero entry between start and stop, or nil."
	^ words lowBitFrom: start to: stop! !

!BinaryArray methodsFor: 'operations-low level' stamp: 'len 12/29/2023 11:05:48'!
findLastNonzeroFrom: start to: stop
	"Answer the index of the last nonzero entry between start and stop, or nil."
	^ words highBitFrom: start to: stop! !

!BinaryArray methodsFor: 'operations-low level' stamp: 'len 5/17/2023 21:32:16'!
karatsubaThreshold
	^ 256! !

!BinaryArray methodsFor: 'operations-low level' stamp: 'len 1/5/2024 09:55:24'!
reduceBy: g
	| n m src dst bitBlt |
	m := g size "lastNonzeroIndex".
	n := self size + 1.
	src := Form extent: g words size * 32 @ 1 depth: -1 bits: g words.
	dst := Form extent: words size * 32 @ 1 depth: -1 bits: words.
	bitBlt := (BitBlt toForm: dst)
		sourceForm: src;
		combinationRule: Form reverse; "dst := dst xor src"
		sourceX: 0; sourceY: 0;
		destX: 0; destY: 0;
		width: m; height: 1.
	[(n := self findLastNonzeroFrom: m to: n-1) notNil]
		whileTrue:
			[bitBlt destX: n - m; copyBits].

"alternative (slower):
	| n m |
	m := g size ""lastNonzeroIndex"".
	n := self size + 1.
	[(n := self findLastNonzeroFrom: m to: n-1) notNil]
		whileTrue:
			[self accumulateFrom: n-m+1 to: n with: g startingAt: 1]"! !

!BinaryArray methodsFor: 'operations-low level' stamp: 'len 1/5/2024 11:18:54'!
reduceBy: g quotient: q
	| n m src dst bitBlt i |
	q ifNil: [^ self reduceBy: g].
	m := g size "lastNonzeroIndex".
	n := self size + 1.
	src := Form extent: g words size * 32 @ 1 depth: -1 bits: g words.
	dst := Form extent: words size * 32 @ 1 depth: -1 bits: words.
	bitBlt := (BitBlt toForm: dst)
		sourceForm: src;
		combinationRule: Form reverse; "dst := dst xor src"
		sourceX: 0; sourceY: 0;
		destX: 0; destY: 0;
		width: m; height: 1.
	[(n := self findLastNonzeroFrom: m to: n-1) notNil]
		whileTrue:
			[i := n-m.
			q words bitAt: i+1 xor: 1.
			bitBlt destX: i; copyBits].

"alternative (slower):
	| n m |
	m := g size ""lastNonzeroIndex"".
	n := self size + 1.
	[(n := self findLastNonzeroFrom: m to: n-1) notNil]
		whileTrue:
			[i := n-m+1.
			q bitAt: i xor: 1.
			self accumulateFrom: i to: n with: g startingAt: 1]"! !

!BinaryArray methodsFor: 'operations-low level' stamp: 'len 2/3/2024 17:01:12'!
replaceFrom: start by: step plusMatrix: anArray1 startingAt: start1 by: step1 width: width1 height: height timesMatrix: anArray2 startingAt: start2 by: step2 width: width
	"Matrix multiplication in O(n^3 / log n) with the Method of Four Russians. See [ABH08], [Bar06]."
	| ℓ G T i |
	(width = 1 and: [step2 = 1 and: [step = 1]]) ifTrue: [^ self replaceFrom: start to: start + height - 1 plusMatrix: anArray1 startingAt: start1 by: step1 width: width1 timesVector: anArray2 startingAt: start2].
	ℓ := (width highBit * 0.75) rounded min: GrayCode cacheSize max: 1.
	G := GrayCode new: ℓ.
	T := (1 to: G size) collect: [:each| self species new: width].
	i := 0.
	[i < width1] whileTrue:
		[width1 - i < ℓ ifTrue: [ℓ := width1 - i. G := GrayCode new: ℓ].
		2 to: G size do: [:t| (T at: t) replaceFrom: 1 to: width with: (T at: t-1) startingAt: 1 plus: anArray2 startingAt: (G incrementAt: t) - 1 + i * step2 + start2].
		0 to: height-1 do: [:j| | bits j₀ |
			bits := anArray1 bits: ℓ at: j * step1 + start1 + i.
			j₀ := j * step + start.
			self replaceFrom: j₀ to: j₀ + width - 1 plus: (T at: (G indexOf: bits)) startingAt: 1].
		i := i + ℓ]! !

!BinaryArray methodsFor: 'operations-low level' stamp: 'len 1/9/2024 10:32:09'!
replaceFrom: start by: step withMatrix: anArray1 startingAt: start1 by: step1 width: width height: height
	words replaceBitsFrom: start by: step withMatrix: anArray1 words startingAt: start1 by: step1 width: width height: height! !

!BinaryArray methodsFor: 'operations-low level' stamp: 'len 2/2/2024 10:27:00'!
replaceFrom: start plus: anArray1 from: start1 to: stop1 convolutionLong: anArray2 from: start2 to: stop2
	| i j x y z n m windowSize ℓ k k₀ |
	windowSize := 30. "so that the convolution doesn't exceed the size of a SmallInteger (60 bits)"
	i := start2.
	[i <= stop2] whileTrue:
		[n := windowSize min: stop2 - i + 1.
		"(n _ (x _ anArray2 bits: n at: i) highBit) = 0"
		(x := anArray2 bits: n at: i) = 0 ifFalse:
			[k₀ := i - start2 - start1 + start.
			j := start1.
			[j <= stop1] whileTrue:
				["m _ windowSize * 2 - n min: stop1 - j + 1."
				m := windowSize min: stop1 - j + 1.
				(y := anArray1 bits: m at: j) = 0 ifFalse:
					[z := x bitConvolution30: y. "this matches the window size"
					k := k₀ + j.
					(ℓ := n+m-1) <= 32
						ifTrue: [	self bits: ℓ at: k xor: z]
						ifFalse:
							[self bits: 32 at: k xor: (z bitAnd: 16rFFFFFFFF).
							self bits: ℓ - 32 at: k + 32 xor: (z bitShift: -32)]].
				j := j + m]].
		i := i + n]! !

!BinaryArray methodsFor: 'operations-low level' stamp: 'len 2/2/2024 10:27:48'!
replaceFrom: start plusAutoconvolutionLong: anArray1 from: start1 to: stop1
	"Autoconvolution in 𝔽₂ is a linear operation. It is just interleaving each bit with a zero, for example 1011 becomes 0100101.
	We implement it with a table lookup as [SOoS01]."
	| i j ℓ in out k |
	i := start.
	j := start1.
	[j <= stop1] whileTrue:
		[ℓ := 30 min: stop1 - j + 1. "we use a window size of 30 bits so that the convolution fits in a SmallInteger"
		in := anArray1 bits: ℓ at: j.
		out := 0.
		k := 0.
		[in = 0] whileFalse:
			[out := out bitXor: ((ByteSquares at: (in bitAnd: 16rFF) + 1) bitShift: k).
			in := in bitShift: -8.
			k := k + 16].
		j := j + ℓ.
		ℓ := ℓ * 2.
		ℓ > 32
			ifTrue:
				[self bits: 32 at: i xor: (out bitAnd: 16rFFFFFFFF).
				self bits: ℓ - 32 at: i + 32 xor: (out bitShift: -32)]
			ifFalse:
				[self bits: ℓ at: i xor: out].
		i := i + ℓ]! !

!BinaryArray methodsFor: 'operations-low level' stamp: 'len 2/3/2024 17:00:50'!
replaceFrom: start to: stop plusMatrix: anArray1 startingAt: start1 by: step1 width: width1 timesVector: anArray2 startingAt: start2
	| k ℓ bits height |
	self flag: #fixme. "TODO: compute bit parity in parallel, special cases of width = 32 or width = 16"
	width1 = 0 ifTrue: [^ self].
	height := stop - start + 1.
	(width1 = 32 and: [height <= 32 and: [start1 = 1 and: [step1 = width1 and: [start2 = 1]]]]) ifTrue:
		[| v |
		v := anArray2 words at: 1.
		bits := 0.
		anArray1 words size to: 1 by: -1 do: [:i| bits := (bits bitShift: 1) bitXor: ((anArray1 words at: i) bitAnd: v) bitParity32].
		self bits: height at: start xor: bits.
		^ self].
	start2 = 1 ifFalse: [^ self notYetImplemented].
	k := start1.
	start to: stop by: 32 do: [:i|
		ℓ := stop-i+1 min: 32.
		bits := 0.
		0 to: ℓ-1 do: [:j|
			| n t s sum |
			n := width1.
			t := k.
			s := 1.
			sum := 0.
			[n >= 32] whileTrue:
				[sum := ((anArray1 bits: 32 at: t) bitAnd: (anArray2 words at: s)) bitXor: sum.
				t := t + 32.
				s := s + 1.
				n := n - 32].
			n > 0 ifTrue: [sum := ((anArray1 bits: n at: t) bitAnd: (anArray2 words at: s)) bitXor: sum].
			sum bitParity32 = 1 ifTrue: [bits := bits bitXor: (1 bitShift: j)].
			k := k + step1].
		self bits: ℓ at: i xor: bits]! !

!BinaryArray methodsFor: 'operations-low level' stamp: 'len 12/28/2023 14:30:12'!
replaceFrom: start to: stop with: replacement startingAt: repStart	
	self assert: stop <= self size.
	self assert: repStart + stop - start <= replacement size.
	words replaceBitsFrom: start to: stop with: replacement words startingAt: repStart! !

!BinaryArray methodsFor: 'operations-low level' stamp: 'len 5/4/2023 23:40:46'!
replaceFrom: start to: stop with: anArray1 startingAt: start1 minus: anArray2 startingAt: start2
	self replaceFrom: start to: stop with: anArray1 startingAt: start1 plus: anArray2 startingAt: start2! !

!BinaryArray methodsFor: 'operations-low level' stamp: 'len 5/15/2023 12:23:19'!
replaceFrom: start to: stop with: anArray1 startingAt: start1 plus: anArray2 startingAt: start2	
	words replaceBitsFrom: start to: stop with: anArray1 words startingAt: start1 xor: anArray2 words startingAt: start2	! !

!BinaryArray methodsFor: 'operations-low level' stamp: 'len 1/8/2024 11:02:05'!
replaceFrom: start to: stop with: anArray1 startingAt: start1 plus: anArray2 startingAt: start2 timesScalar: anElement
	(anElement isZero or: [anElement isInteger and: [anElement even]])
		ifTrue: [^ self replaceFrom: start to: stop with: anArray1 startingAt: start1].
	self replaceFrom: start to: stop with: anArray1 startingAt: start1 plus: anArray2 startingAt: start2! !

!BinaryArray methodsFor: 'operations-low level' stamp: 'len 5/15/2023 12:24:02'!
replaceFrom: start to: stop with: anArray1 startingAt: start1 times: anArray2 startingAt: start2	
	words replaceBitsFrom: start to: stop with: anArray1 words startingAt: start1 and: anArray2 words startingAt: start2	! !

!BinaryArray methodsFor: 'operations-low level' stamp: 'len 1/9/2024 10:47:49'!
replaceFrom: start to: stop with: anArray1 startingAt: start1 timesScalar: anElement
	(anElement isZero or: [anElement isInteger and: [anElement even]])
		ifTrue: [words clearBitsFrom: start to: stop. ^ self].
	self replaceFrom: start to: stop with: anArray1 startingAt: start1! !

!BinaryArray methodsFor: 'operations-low level' stamp: 'len 5/4/2023 23:40:46'!
replaceFrom: start to: stop withNegated: anArray startingAt: srcStart
	self replaceFrom: start to: stop with: anArray startingAt: srcStart! !

!BinaryArray methodsFor: 'operations-low level' stamp: 'len 6/12/2023 08:53:51'!
replaceFrom: start withAutoconvolution: anArray1 from: start1 to: stop1
	"No need to use Karatsuba because autoconvolution over 𝔽₂ is linear and we do it just with a table lookup."
	self replaceFrom: start withAutoconvolutionLong: anArray1 from: start1 to: stop1! !

!BinaryArray methodsFor: 'operations-low level' stamp: 'len 2/1/2024 19:33:46'!
replaceWithMatrix: anArray1 width: width1 timesMatrix: anArray2 width: width2
	(width1 = 0 or: [width2 = 0]) ifTrue: [^ self].
	words atAllPut: 0.
	self replaceFrom: 1 by: width2 plusMatrix: anArray1 startingAt: 1 by: width1 width: width1 height: self size // width2 timesMatrix: anArray2 startingAt: 1 by: width2 width: width2! !

!BinaryArray methodsFor: 'operations-low level' stamp: 'len 5/18/2023 18:10:42'!
replaceWithMatrixTranspose: anArray width: width
	self flag: #fixme. "TODO"
"	words replaceBitsWithMatrixTranspose: anArray words width: width	"
	super replaceWithMatrixTranspose: anArray width: width! !

!BinaryArray methodsFor: 'operations-low level' stamp: 'len 1/11/2024 21:27:30'!
sumFrom: start to: stop
	self flag: #fixme. "TODO"
	^ super sumFrom: start to: stop! !

!BinaryArray methodsFor: 'printing' stamp: 'len 5/29/2023 11:32:46'!
printOn: aStream
	self do: [:each| aStream nextPut: (each isOne ifTrue: [$▪] ifFalse: [$▫])]! !

!BinaryArray methodsFor: 'testing' stamp: 'len 5/9/2023 13:57:50'!
includes: anObject
	anObject = One ifTrue: [^ self isZero not].
	anObject = Zero ifTrue: [^ self isAllOnes not].
	^ false! !

!BinaryArray methodsFor: 'testing' stamp: 'len 5/9/2023 22:41:22'!
isAllOnes
	| r |
	1 to: size // 32 do: [:i| (words at: i) = 16rFFFFFFFF ifFalse: [^ false]].
	^ (r _ size \\ 32) = 0 or: [words last = (16rFFFFFFFF bitShift: r - 32)]! !

!BinaryArray methodsFor: 'testing' stamp: 'len 5/7/2023 17:42:51'!
isZero
	^ words isZero! !

!BinaryArray methodsFor: 'testing' stamp: 'len 5/4/2023 23:40:46'!
isZeroAt: anInteger
	^ (self bitAt: anInteger) = 0! !

!BinaryArray methodsFor: 'private' stamp: 'len 5/15/2023 13:03:56'!
bitAt: anInteger
	anInteger > size ifTrue: [^ self errorOutOfBounds].
	^ words bitAt: anInteger! !

!BinaryArray methodsFor: 'private' stamp: 'len 5/15/2023 16:20:15'!
bitAt: anInteger put: aBit
	anInteger > size ifTrue: [^ self errorOutOfBounds].
	^ words bitAt: anInteger put: aBit! !

!BinaryArray methodsFor: 'private' stamp: 'len 5/17/2023 14:17:30'!
bits: length at: index
	"Read the desired number of bits from the receiver starting at the given index.
	Assume length <= 32."
	^ words bits: length at: index! !

!BinaryArray methodsFor: 'private' stamp: 'len 5/17/2023 14:17:40'!
bits: length at: index put: bits
	"Write the desired number of bits from the receiver starting at the given index.
	Assume length <= 32."
	^ words bits: length at: index put: bits! !

!BinaryArray methodsFor: 'private' stamp: 'len 5/17/2023 20:43:06'!
bits: length at: index xor: bits
	"Write the desired number of bits from the receiver starting at the given index.
	Assume length <= 32."
	^ words bits: length at: index xor: bits! !

!BinaryArray methodsFor: 'private' stamp: 'len 5/4/2023 23:58:57'!
species
	^ self scalars! !

!BinaryArray methodsFor: 'private' stamp: 'len 5/16/2023 21:31:21'!
validate
	super validate.
	size - 1 // 32 + 1 = words size ifFalse: [self error: 'too many words'].
	(size \\ 32 = 0 or: [words last highBit <= (size \\ 32)]) ifFalse: [self error: 'tail is not zero']! !

!BinaryArray methodsFor: 'private' stamp: 'len 5/7/2023 17:45:00'!
words
	^ words! !

!BinaryArray methodsFor: 'private' stamp: 'len 5/16/2023 21:57:57'!
words: aWordArray size: anInteger
	| n |
	n _ aWordArray size.
	anInteger - 1 // 32 + 1 = n ifFalse: [self error: 'too many words'].
	words _ aWordArray.
	size _ anInteger! !

!BinaryArray methodsFor: 'private' stamp: 'len 1/14/2024 10:25:12'!
zeros
	self isEmpty ifTrue: [^ self].
	^ self scalars new: self size! !

!BinaryArray class methodsFor: 'class initialization' stamp: 'len 5/22/2023 22:13:10'!
initialize
	| Z2 |
	super initialize.
	ℤ isNil ifTrue: [^ self].
	Z2 := ℤ / 2.
	One := Z2 one.
	Zero := Z2 zero.
	ByteSquares := (0 to: 255) collect: [:each| each bitAutoconvolution]! !

!BinaryArray class methodsFor: 'instance creation' stamp: 'len 5/7/2023 17:39:47'!
new: anInteger
	^ self new: anInteger words: (WordArray new: anInteger - 1 // 32 + 1)! !

!BinaryArray class methodsFor: 'instance creation' stamp: 'len 5/7/2023 17:39:52'!
new: anInteger words: aWordArray
	^ self basicNew words: aWordArray size: anInteger! !

!BinaryArray class methodsFor: 'instance creation' stamp: 'len 5/7/2023 17:40:02'!
newFrom: anObject
	| n r words |
	anObject isInteger ifFalse: [^ super newFrom: anObject].
	n _ anObject.
	r _ n highBit.
	words _ WordArray new: r - 1 // 32 + 1.
	1 to: words size do: [:i|
		words at: i put: (n bitAnd: 16rFFFFFFFF).
		n _ n >> 32].
	^ self new: r words: words! !

!ExtensionPackedArray methodsFor: 'accessing' stamp: 'len 5/4/2023 23:44:29'!
at: anInteger
	| n startIndex |
	n _ scalars degree.
	startIndex _ anInteger - 1 * n + 1.
	^ scalars coefficients: (coefficients copyFrom: startIndex to: startIndex + n - 1)! !

!ExtensionPackedArray methodsFor: 'accessing' stamp: 'len 5/4/2023 23:44:29'!
at: anInteger put: anElement
	| n startIndex elementCoefficients |
	n _ scalars degree.
	startIndex _ anInteger - 1 * n + 1.
	elementCoefficients _ anElement "representative" coefficients.
	coefficients replaceFrom: startIndex to: startIndex + elementCoefficients size - 1 with: elementCoefficients.
	self assert: elementCoefficients size = n.
"	elementCoefficients size < n
		ifTrue: [coefficients from: startIndex + elementCoefficients size to: startIndex + n - 1 put: scalars scalars zero]."
	^ anElement! !

!ExtensionPackedArray methodsFor: 'accessing' stamp: 'len 5/4/2023 23:44:29'!
scalars
	^ scalars! !

!ExtensionPackedArray methodsFor: 'accessing' stamp: 'len 5/4/2023 23:44:29'!
size
	^ coefficients size // scalars degree! !

!ExtensionPackedArray methodsFor: 'accessing' stamp: 'len 5/4/2023 23:44:29'!
swap: oneIndex with: anotherIndex 
	"Move the element at oneIndex to anotherIndex, and vice-versa."
	| n start1 start2 |
	n _ scalars degree.
	start1 _ oneIndex - 1 * n + 1.
	start2 _ anotherIndex - 1 * n + 1.
	coefficients swapFrom: start1 to: start1 + n - 1 with: coefficients startingAt: start2! !

!ExtensionPackedArray methodsFor: 'comparing' stamp: 'len 5/4/2023 23:44:29'!
= anObject
	^ self class = anObject class and: [coefficients = anObject coefficients and: [scalars = anObject scalars]]! !

!ExtensionPackedArray methodsFor: 'comparing' stamp: 'len 5/4/2023 23:44:29'!
hash
	^ coefficients hash! !

!ExtensionPackedArray methodsFor: 'copying' stamp: 'len 5/4/2023 23:44:29'!
postCopy
	super postCopy.
	coefficients _ coefficients copy! !

!ExtensionPackedArray methodsFor: 'operations' stamp: 'len 5/4/2023 23:44:29'!
>> anInteger
	"Answer the right shift of the receiver by anInteger places.
	The answer is a new array of the same size as the receiver."
	^ self class coefficients: coefficients >> (anInteger * scalars degree) scalars: scalars! !

!ExtensionPackedArray methodsFor: 'operations' stamp: 'len 5/4/2023 23:44:29'!
>>> anInteger
	"Answer the circular right shift of the receiver by anInteger places.
	The answer is a new array of the same size as the receiver."
	^ self class coefficients: coefficients >>> (anInteger * scalars degree) scalars: scalars! !

!ExtensionPackedArray methodsFor: 'operations' stamp: 'len 5/4/2023 23:44:29'!
reversed
	| m n newCoefficients |
	true ifTrue: [^ super reversed].
	n _ scalars degree.
	m _ coefficients size.
	newCoefficients _ coefficients species new: m.
	1 to: m-n+1 by: n do: [:i|
		newCoefficients replaceFrom: i to: i+n-1 with: coefficients startingAt: m-n-i+2].
	^ self class coefficients: newCoefficients scalars: scalars! !

!ExtensionPackedArray methodsFor: 'operations-low level' stamp: 'len 2/2/2024 10:26:33'!
· anArray
	| n tmp j |
	n := scalars degree.
	tmp := scalars scalars zeros: n*2 - 1.
	j := 1.
	1 to: (self size min: anArray size)-1*n+1 by: n do: [:i|
		tmp replaceFrom: 1 plus: coefficients from: i to: i+n-1 convolution: anArray coefficients from: j to: j+n-1.
		j := j + n].
	^ scalars coefficients: (tmp reduceBy: scalars modulus coefficients)! !

!ExtensionPackedArray methodsFor: 'operations-low level' stamp: 'len 5/4/2023 23:44:29'!
findFirstNonzeroFrom: start to: stop
	"Answer the index of the first nonzero entry between start and stop, or nil."
	| n |
	n _ scalars degree.
	^ ((coefficients findFirstNonzeroFrom: start-1*n+1 to: stop*n) ifNil: [^ nil]) - 1 // n + 1! !

!ExtensionPackedArray methodsFor: 'operations-low level' stamp: 'len 5/4/2023 23:44:29'!
findLastNonzeroFrom: start to: stop
	"Answer the index of the last nonzero entry between start and stop, or nil."
	| n |
	n _ scalars degree.
	^ ((coefficients findLastNonzeroFrom: start-1*n+1 to: stop*n) ifNil: [^ nil]) - 1 // n + 1! !

!ExtensionPackedArray methodsFor: 'operations-low level' stamp: 'len 2/2/2024 10:26:33'!
replaceFrom: start by: step plusMatrix: anArray1 startingAt: start1 by: step1 width: width1 height: height timesMatrix: anArray2 startingAt: start2 by: step2 width: width
	| n modulusCoefficients tmp i j |
	n := scalars degree.
	modulusCoefficients := scalars modulus coefficients.
	tmp := scalars scalars zeros: n*2-1.
	i := start.
	j := start1.
	height timesRepeat:
		[| k |
		k := start2.
		i to: i + width - 1 do: [:s|
			tmp replaceFrom: 1 to: n with: coefficients startingAt: s-1*n+1.
			j to: j + width1 - 1 do: [:t|
				| u |
				u := t-j*step2 + k.
				tmp replaceFrom: 1 plus: anArray1 coefficients from: t-1*n+1 to: t*n convolution: anArray2 coefficients from: u-1*n+1 to: u*n].
			tmp reduceBy: modulusCoefficients.
			coefficients replaceFrom: s-1*n+1 to: s*n with: tmp startingAt: 1.
			k := k + 1].
		i := i + step.
		j := j + step1]! !

!ExtensionPackedArray methodsFor: 'operations-low level' stamp: 'len 2/2/2024 10:27:00'!
replaceFrom: start plus: anArray1 from: start1 to: stop1 convolutionLong: anArray2 from: start2 to: stop2
	| n modulusCoefficients tmp |
	n := scalars degree.
	modulusCoefficients := scalars modulus coefficients.
	tmp := scalars scalars new: n*2-1.
	start2 to: stop2 do: [:i|
		(anArray2 isZeroAt: i) ifFalse:
			[| k j1 j2 |
			k := i-start2+start.
			j1 := k-1*n+1.
			j2 := start1-1*n+1.
			k-1*n+1 to: k+stop1-start1-1*n+1 by: n do: [:j|
				tmp replaceFrom: 1 with: anArray1 coefficients from: j2 to: j2+n-1 convolution: anArray2 coefficients from: i-1*n+1 to: i*n.
				tmp reduceBy: modulusCoefficients.
				coefficients replaceFrom: j to: j+n-1 with: coefficients startingAt: j1 plus: tmp startingAt: 1.
				j1 := j1 + n.
				j2 := j2 + n]]]! !

!ExtensionPackedArray methodsFor: 'operations-low level' stamp: 'len 2/3/2024 17:06:21'!
replaceFrom: start to: stop plusMatrix: anArray1 startingAt: start1 by: step1 width: width1 timesVector: anArray2 startingAt: start2
	| n modulusCoefficients tmp j |
	width1 = 0 ifTrue: [^ self].
	n := scalars degree.
	modulusCoefficients := scalars modulus coefficients.
	tmp := scalars scalars zeros: n*2-1.
	j := start1.
	start to: stop do: [:i|
		tmp replaceFrom: 1 to: n with: coefficients startingAt: i-1*n+1.
		j to: j + width1 - 1 do: [:k|
			tmp replaceFrom: 1 plus: anArray1 coefficients from: k-1*n+1 to: k*n convolution: anArray2 coefficients from: k-j*n+start2 to: k-j*n+n+start2-1].
		tmp reduceBy: modulusCoefficients.
		coefficients replaceFrom: i-1*n+1 to: i*n with: tmp startingAt: 1.
		j := j + step1]! !

!ExtensionPackedArray methodsFor: 'operations-low level' stamp: 'len 5/4/2023 23:44:29'!
replaceFrom: start to: stop with: replacement startingAt: repStart
	| n |
	(replacement class = self class and: [scalars = replacement scalars])
		ifFalse: [^ super replaceFrom: start to: stop with: replacement startingAt: repStart].
	n _ scalars degree.
	coefficients replaceFrom: start-1*n+1 to: stop*n with: replacement coefficients startingAt: repStart-1*n+1! !

!ExtensionPackedArray methodsFor: 'operations-low level' stamp: 'len 5/4/2023 23:44:29'!
replaceFrom: start to: stop with: anArray1 startingAt: start1 minus: anArray2 startingAt: start2
	| n |
	n _ scalars degree.
	coefficients
		replaceFrom: start-1*n+1 to: stop*n
		with: anArray1 coefficients startingAt: start1-1*n+1
		minus: anArray2 coefficients startingAt: start2-1*n+1! !

!ExtensionPackedArray methodsFor: 'operations-low level' stamp: 'len 5/4/2023 23:44:29'!
replaceFrom: start to: stop with: anArray1 startingAt: start1 plus: anArray2 startingAt: start2
	| n |
	n _ scalars degree.
	coefficients
		replaceFrom: start-1*n+1 to: stop*n
		with: anArray1 coefficients startingAt: start1-1*n+1
		plus: anArray2 coefficients startingAt: start2-1*n+1! !

!ExtensionPackedArray methodsFor: 'operations-low level' stamp: 'len 1/8/2024 11:09:00'!
replaceFrom: start to: stop with: anArray1 startingAt: start1 plus: anArray2 startingAt: start2 timesScalar: anElement
	| n scalarCoefficients modulusCoefficients tmp j1 j2 |
	n := scalars degree.
	anElement isInteger ifTrue:
		[coefficients replaceFrom: start-1*n+1 to: stop*n with: anArray1 coefficients startingAt: start1-1*n+1 plus: anArray2 coefficients startingAt: start2-1*n+1 timesScalar: anElement.
		^ self].
	modulusCoefficients := scalars modulus coefficients.
	scalarCoefficients := anElement coefficients.
	tmp := scalars scalars new: n*2-1.
	j1 := start1-1*n+1.
	j2 := start2-1*n+1.
	start-1*n+1 to: stop-1*n+1 by: n do: [:i|
		self flag: #fixme.
		"convolution + reduction could be combined in a single method for efficiency:"
		tmp replaceFrom: 1 with: anArray2 coefficients from: j2 to: j2+n-1 convolution: scalarCoefficients from: 1 to: n.
		tmp reduceBy: modulusCoefficients.
		coefficients replaceFrom: i to: i+n-1 with: anArray1 coefficients startingAt: j1 plus: tmp startingAt: 1.
		j1 := j1 + n.
		j2 := j2 + n]! !

!ExtensionPackedArray methodsFor: 'operations-low level' stamp: 'len 5/30/2023 17:45:22'!
replaceFrom: start to: stop with: anArray1 startingAt: start1 times: anArray2 startingAt: start2
	| n modulusCoefficients tmp j1 j2 |
	n := scalars degree.
	modulusCoefficients := scalars modulus coefficients.
	tmp := scalars scalars new: n*2-1.
	j1 := start1-1*n+1.
	j2 := start2-1*n+1.
	start-1*n+1 to: stop-1*n+1 by: n do: [:i|
		tmp replaceFrom: 1 with: anArray1 coefficients from: j1 to: j1+n-1 convolution: anArray2 coefficients from: j2 to: j2+n-1.
		tmp reduceBy: modulusCoefficients.
		coefficients replaceFrom: i to: i+n-1 with: tmp startingAt: 1.
		j1 := j1 + n.
		j2 := j2 + n]! !

!ExtensionPackedArray methodsFor: 'operations-low level' stamp: 'len 5/28/2023 22:42:17'!
replaceFrom: start to: stop with: anArray startingAt: srcStart timesScalar: anElement
	| n scalarCoefficients modulusCoefficients tmp j |
	n := scalars degree.
	anElement isInteger ifTrue:
		[coefficients replaceFrom: start-1*n+1 to: stop*n with: anArray coefficients startingAt: srcStart-1*n+1 timesScalar: anElement.
		^ self].
	modulusCoefficients := scalars modulus coefficients.
	scalarCoefficients := anElement coefficients.
	tmp := scalars scalars new: n*2-1.
	j := srcStart-1*n+1.
	start-1*n+1 to: stop-1*n+1 by: n do: [:i|
		tmp replaceFrom: 1 with: anArray coefficients from: j to: j+n-1 convolution: scalarCoefficients from: 1 to: n.
		tmp reduceBy: modulusCoefficients.
		coefficients replaceFrom: i to: i+n-1 with: tmp startingAt: 1.
		j := j + n]! !

!ExtensionPackedArray methodsFor: 'operations-low level' stamp: 'len 5/4/2023 23:44:29'!
replaceFrom: start to: stop withNegated: anArray startingAt: srcStart
	| n |
	n _ scalars degree.
	coefficients replaceFrom: start-1*n+1 to: stop*n withNegated: anArray coefficients startingAt: srcStart-1*n+1! !

!ExtensionPackedArray methodsFor: 'operations-low level' stamp: 'len 2/2/2024 10:27:00'!
replaceFrom: start with: anArray1 from: start1 to: stop1 convolutionLong: anArray2 from: start2 to: stop2
	| n |
	n := scalars degree.
	coefficients from: start - 1 * n + 1 to: start + stop1 - start1 + stop2 - start2 * n put: scalars scalars zero.
	self replaceFrom: start plus: anArray1 from: start1 to: stop1 convolutionLong: anArray2 from: start2 to: stop2! !

!ExtensionPackedArray methodsFor: 'operations-low level' stamp: 'len 5/4/2023 23:44:29'!
swapFrom: start to: stop with: anArray startingAt: start2
	| n |
	n _ scalars degree.
	coefficients swapFrom: start-1*n+1 to: stop*n with: anArray coefficients startingAt: start2-1*n+1! !

!ExtensionPackedArray methodsFor: 'printing' stamp: 'len 6/11/2023 10:37:46'!
printOn: aStream
	aStream withParentheses: [:aStream2| self do: [:each| aStream2 print: each] separatedBy: [aStream2 nextPutAll: ', ']]! !

!ExtensionPackedArray methodsFor: 'testing' stamp: 'len 5/4/2023 23:44:29'!
isZero
	^ coefficients isZero! !

!ExtensionPackedArray methodsFor: 'testing' stamp: 'len 5/4/2023 23:44:29'!
isZeroAt: anInteger
	| n |
	n _ scalars degree.
	^ (coefficients findFirstNonzeroFrom: anInteger-1*n+1 to: anInteger*n) isNil! !

!ExtensionPackedArray methodsFor: 'private' stamp: 'len 5/4/2023 23:44:29'!
coefficients
	^ coefficients! !

!ExtensionPackedArray methodsFor: 'private' stamp: 'len 5/27/2023 07:58:38'!
coefficients: anArray scalars: anExtensionRing
	coefficients := anArray.
	scalars := anExtensionRing.
	self assert: scalars degree | coefficients size! !

!ExtensionPackedArray methodsFor: 'private' stamp: 'len 5/4/2023 23:44:29'!
species
	^ scalars! !

!ExtensionPackedArray class methodsFor: 'instance creation' stamp: 'len 5/4/2023 23:44:29'!
coefficients: anArray scalars: aGaloisRing
	^ self basicNew coefficients: anArray scalars: aGaloisRing! !

!ExtensionSlicedArray methodsFor: 'accessing' stamp: 'len 5/12/2023 23:23:01'!
at: anInteger
	^ scalars !! (slices collect: [:each| each at: anInteger])! !

!ExtensionSlicedArray methodsFor: 'accessing' stamp: 'len 6/11/2023 01:31:14'!
at: anInteger put: anElement
	slices withIndexDo: [:each :i| each at: anInteger put: (anElement at: i - 1)].
	^ anElement! !

!ExtensionSlicedArray methodsFor: 'accessing' stamp: 'len 6/11/2023 23:09:11'!
atAllPut: anElement
	slices withIndexDo: [:each :i| each atAllPut: (anElement at: i - 1)]! !

!ExtensionSlicedArray methodsFor: 'accessing' stamp: 'len 5/12/2023 23:23:53'!
scalars
	^ scalars! !

!ExtensionSlicedArray methodsFor: 'accessing' stamp: 'len 5/12/2023 23:24:04'!
size
	^ slices first size! !

!ExtensionSlicedArray methodsFor: 'accessing' stamp: 'len 5/12/2023 23:30:53'!
slice: anInteger
	^ slices at: anInteger! !

!ExtensionSlicedArray methodsFor: 'accessing' stamp: 'len 5/12/2023 23:25:06'!
slices
	^ slices! !

!ExtensionSlicedArray methodsFor: 'accessing' stamp: 'len 5/12/2023 23:24:16'!
swap: oneIndex with: anotherIndex 
	slices do: [:each| each swap: oneIndex with: anotherIndex]! !

!ExtensionSlicedArray methodsFor: 'comparing' stamp: 'len 5/12/2023 23:24:46'!
= anObject
	^ self class = anObject class and: [slices = anObject slices and: [scalars = anObject scalars]]! !

!ExtensionSlicedArray methodsFor: 'comparing' stamp: 'len 5/12/2023 23:24:59'!
hash
	^ slices hash! !

!ExtensionSlicedArray methodsFor: 'copying' stamp: 'len 5/12/2023 23:25:45'!
postCopy
	super postCopy.
	slices _ slices collect: [:each| each copy]! !

!ExtensionSlicedArray methodsFor: 'operations-low level' stamp: 'len 5/12/2023 23:34:07'!
findFirstNonzeroFrom: start to: stop
	| answer |
	answer _ nil.
	slices do: [:each| (each findFirstNonzeroFrom: start to: stop) ifNotNil: [:index| answer _ answer isNil ifTrue: [index] ifFalse: [answer min: index]]].
	^ answer! !

!ExtensionSlicedArray methodsFor: 'operations-low level' stamp: 'len 5/12/2023 23:34:17'!
findLastNonzeroFrom: start to: stop
	| answer |
	answer _ nil.
	slices do: [:each| (each findLastNonzeroFrom: start to: stop) ifNotNil: [:index| answer _ answer isNil ifTrue: [index] ifFalse: [answer max: index]]].
	^ answer! !

!ExtensionSlicedArray methodsFor: 'operations-low level' stamp: 'len 5/12/2023 23:41:08'!
replaceFrom: start to: stop with: replacement startingAt: repStart	
	slices withIndexDo: [:each :i|
		each replaceFrom: start to: stop with: (replacement slice: i) startingAt: repStart	]! !

!ExtensionSlicedArray methodsFor: 'operations-low level' stamp: 'len 5/12/2023 23:29:52'!
replaceFrom: start to: stop with: anArray1 startingAt: start1 minus: anArray2 startingAt: start2
	slices withIndexDo: [:each :i|
		each
			replaceFrom: start to: stop
			with: (anArray1 slice: i) startingAt: start1
			minus: (anArray2 slice: i) startingAt: start2]! !

!ExtensionSlicedArray methodsFor: 'operations-low level' stamp: 'len 5/12/2023 23:31:29'!
replaceFrom: start to: stop with: anArray1 startingAt: start1 plus: anArray2 startingAt: start2
	slices withIndexDo: [:each :i|
		each
			replaceFrom: start to: stop
			with: (anArray1 slice: i) startingAt: start1
			plus: (anArray2 slice: i) startingAt: start2]! !

!ExtensionSlicedArray methodsFor: 'operations-low level' stamp: 'len 5/12/2023 23:30:30'!
replaceFrom: start to: stop withNegated: anArray startingAt: srcStart
	slices withIndexDo: [:each :i|
		each
			replaceFrom: start to: stop
			withNegated: (anArray slice: i) startingAt: srcStart]! !

!ExtensionSlicedArray methodsFor: 'operations-low level' stamp: 'len 5/28/2023 23:30:26'!
replaceWithMatrixTranspose: anArray width: width
	slices withIndexDo: [:each :i| each replaceWithMatrixTranspose: (anArray slice: i) width: width]! !

!ExtensionSlicedArray methodsFor: 'operations-low level' stamp: 'len 5/28/2023 23:30:07'!
swapFrom: start to: stop with: anArray startingAt: start2
	slices withIndexDo: [:each :i| each swapFrom: start to: stop with: (anArray slice: i) startingAt: start2]! !

!ExtensionSlicedArray methodsFor: 'printing' stamp: 'len 6/11/2023 10:39:34'!
printOn: aStream
	aStream withParentheses: [:aStream2| self do: [:each| aStream2 print: each] separatedBy: [aStream2 nextPutAll: ', ']]! !

!ExtensionSlicedArray methodsFor: 'testing' stamp: 'len 5/12/2023 23:26:09'!
isZero
	^ slices allSatisfy: [:each| each isZero]! !

!ExtensionSlicedArray methodsFor: 'testing' stamp: 'len 5/12/2023 23:26:22'!
isZeroAt: anInteger
	^ slices allSatisfy: [:each| (each isZeroAt: anInteger)]! !

!ExtensionSlicedArray methodsFor: 'private' stamp: 'len 6/11/2023 01:30:46'!
slices: anArray scalars: anExtensionRing
	slices := anArray.
	scalars := anExtensionRing.
	self assert: slices size = scalars degree! !

!ExtensionSlicedArray methodsFor: 'private' stamp: 'len 5/12/2023 23:27:28'!
species
	^ scalars! !

!ExtensionSlicedArray class methodsFor: 'instance creation' stamp: 'len 5/12/2023 23:28:30'!
slices: anArray scalars: anExtensionRing
	^ self basicNew slices: anArray scalars: anExtensionRing! !

!BinaryExtensionArray methodsFor: 'operations-low level' stamp: 'len 2/1/2024 19:29:36'!
· anArray
	| tmp1 tmp2 tmp3 |
	tmp1 := self scalars scalars new: (self size min: anArray size).
	tmp2 := self scalars scalars new: tmp1 size.
	tmp3 := self scalars scalars zeros: self scalars degree + 1.
	self scalars karatsubaFormula do: [:each|
		tmp1 replaceFrom: 1 to: tmp1 size with: (self slice: each first first) startingAt: 1.
		tmp2 replaceFrom: 1 to: tmp2 size with: (anArray slice: each first first) startingAt: 1.
		each first allButFirstDo: [:i|
			tmp1 replaceFrom: 1 to: tmp1 size plus: (self slice: i) startingAt: 1.
			tmp2 replaceFrom: 1 to: tmp2 size plus: (anArray slice: i) startingAt: 1].
		(tmp1 · tmp2) isZero ifFalse: [each second do: [:i| tmp3 at: i add: 1]]].
	^ self scalars coefficients: tmp3! !

!BinaryExtensionArray methodsFor: 'operations-low level' stamp: 'len 2/1/2024 19:33:46'!
replaceFrom: start by: step plusMatrix: anArray1 startingAt: start1 by: step1 width: width1 height: height timesMatrix: anArray2 startingAt: start2 by: step2 width: width
	| tmp1 tmp2 tmp3 |
	tmp1 := self scalars scalars new: width1 * height.
	tmp2 := self scalars scalars new: width * width1.
	tmp3 := self scalars scalars new: width * height.
	self scalars karatsubaFormula do: [:each|
		tmp1 replaceFrom: 1 by: width1 withMatrix: (anArray1 slice: each first first) startingAt: start1 by: step1 width: width1 height: height.
		tmp2 replaceFrom: 1 by: width withMatrix: (anArray2 slice: each first first) startingAt: start2 by: step2 width: width height: width1.
		each first allButFirstDo: [:i|
			tmp1 replaceFrom: 1 by: width1 plusMatrix: (anArray1 slice: i) startingAt: start1 by: step1 width: width1 height: height.
			tmp2 replaceFrom: 1 by: width plusMatrix: (anArray2 slice: i) startingAt: start2 by: step2 width: width height: width1].
		tmp3 replaceWithMatrix: tmp1 width: width1 timesMatrix: tmp2 width: width.
		each second do: [:i| (self slice: i) replaceFrom: start by: step plusMatrix: tmp3 startingAt: 1 by: width width: width height: height]]! !

!BinaryExtensionArray methodsFor: 'operations-low level' stamp: 'len 2/2/2024 10:27:00'!
replaceFrom: start plus: anArray1 from: start1 to: stop1 convolutionLong: anArray2 from: start2 to: stop2
	| tmp1 tmp2 tmp3 |
	tmp1 := self scalars scalars new: stop1 - start1 + 1.
	tmp2 := self scalars scalars new: stop2 - start2 + 1.
	tmp3 := self scalars scalars new: tmp1 size + tmp2 size - 1.
	self scalars karatsubaFormula do: [:each|
		tmp1 replaceFrom: 1 to: tmp1 size with: (anArray1 slice: each first first) startingAt: start1.
		tmp2 replaceFrom: 1 to: tmp2 size with: (anArray2 slice: each first first) startingAt: start2.
		each first allButFirstDo: [:i|
			tmp1 replaceFrom: 1 to: tmp1 size plus: (anArray1 slice: i) startingAt: start1.
			tmp2 replaceFrom: 1 to: tmp2 size plus: (anArray2 slice: i) startingAt: start2].
		tmp3 replaceFrom: 1 with: tmp1 from: 1 to: tmp1 size convolution: tmp2 from: 1 to: tmp2 size.
		each second do: [:i| (self slice: i) replaceFrom: start to: start + tmp3 size - 1 plus: tmp3 startingAt: 1]]! !

!BinaryExtensionArray methodsFor: 'operations-low level' stamp: 'len 2/3/2024 17:07:46'!
replaceFrom: start to: stop plusMatrix: anArray1 startingAt: start1 by: step1 width: width1 timesVector: anArray2 startingAt: start2
	| height1 tmp1 tmp2 tmp3 |
	height1 := stop - start + 1.
	tmp1 := self scalars scalars new: width1 * height1.
	tmp2 := self scalars scalars new: width1.
	tmp3 := self scalars scalars new: height1.
	self scalars karatsubaFormula do: [:each|
		tmp1 replaceFrom: 1 by: width1 withMatrix: (anArray1 slice: each first first) startingAt: start1 by: step1 width: width1 height: height1.
		tmp2 replaceFrom: 1 to: width1 with: (anArray2 slice: each first first) startingAt: start2.
		each first allButFirstDo: [:i|
			tmp1 replaceFrom: 1 by: width1 plusMatrix: (anArray1 slice: i) startingAt: start1 by: step1 width: width1 height: height1.
			tmp2 replaceFrom: 1 to: width1 plus: (anArray2 slice: i) startingAt: start2].
		tmp3 from: start to: stop put: self scalars scalars zero.
		tmp3 replaceFrom: start to: stop plusMatrix: tmp1 startingAt: 1 by: tmp2 size width: tmp2 size timesVector: tmp2 startingAt: 1.
		each second do: [:i| (self slice: i) replaceFrom: start to: stop plus: tmp3 startingAt: 1]]! !

!BinaryExtensionArray methodsFor: 'operations-low level' stamp: 'len 6/12/2023 12:51:14'!
replaceFrom: start to: stop with: anArray1 startingAt: start1 plus: anArray2 startingAt: start2 timesScalar: anElement
	anElement isInteger ifTrue:
		[slices withIndexDo: [:each :i| each replaceFrom: start to: stop with: (anArray1 slice: i) startingAt: start1 plus: (anArray2 slice: i) startingAt: start2 timesScalar: anElement].
		^ self].
	self flag: #fixme. "optimize this, avoid creating temporary array"
	^ self replaceFrom: start to: stop with: anArray1 startingAt: start1 plus: (anArray2 copyFrom: start2 to: start2 + stop - start) * anElement startingAt: 1! !

!BinaryExtensionArray methodsFor: 'operations-low level' stamp: 'len 2/1/2024 19:31:14'!
replaceFrom: start to: stop with: anArray1 startingAt: start1 times: anArray2 startingAt: start2
	| tmp1 tmp2 tmp3 |
	tmp1 := self scalars scalars new: stop - start + 1.
	tmp2 := self scalars scalars new: stop - start + 1.
	self flag: #fixme. "optimize this, avoid using temporary array tmp3"
	tmp3 := self scalars zeros: stop - start + 1.
	self scalars karatsubaFormula do: [:each|
		tmp1 replaceFrom: 1 to: tmp1 size with: (anArray1 slice: each first first) startingAt: start1.
		tmp2 replaceFrom: 1 to: tmp2 size with: (anArray2 slice: each first first) startingAt: start1.
		each first allButFirstDo: [:i|
			tmp1 replaceFrom: 1 to: tmp1 size plus: (anArray1 slice: i) startingAt: start1.
			tmp2 replaceFrom: 1 to: tmp2 size plus: (anArray2 slice: i) startingAt: start2].
		tmp1 replaceFrom: 1 to: tmp1 size with: tmp1 startingAt: 1 times: tmp2 startingAt: 1.
		each second do: [:i| (tmp3 slice: i) += tmp1]].
	self replaceFrom: start to: stop with: tmp3 startingAt: 1! !

!BinaryExtensionArray methodsFor: 'operations-low level' stamp: 'len 2/1/2024 19:31:31'!
replaceFrom: start to: stop with: anArray1 startingAt: start1 timesScalar: anElement
	| tmp1 tmp2 tmp3 |
	anElement isInteger ifTrue:
		[slices withIndexDo: [:each :i| each replaceFrom: start to: stop with: (anArray1 slice: i) startingAt: start1 timesScalar: anElement].
		^ self].
	tmp1 := self scalars scalars new: stop - start + 1.
	self flag: #fixme. "optimize this, avoid using temporary array tmp3"
	tmp3 := self scalars zeros: stop - start + 1.
	self scalars karatsubaFormula do: [:each|
		tmp2 := anElement at: each first first - 1.
		each first allButFirstDo: [:i| tmp2 := tmp2 + (anElement at: i - 1)].
		tmp2 isZero ifFalse:
			[tmp1 replaceFrom: 1 to: tmp1 size with: (anArray1 slice: each first first) startingAt: start1.
			each first allButFirstDo: [:i| tmp1 replaceFrom: 1 to: tmp1 size plus: (anArray1 slice: i) startingAt: start1].
			each second do: [:i| (tmp3 slice: i) += tmp1]]].
	self replaceFrom: start to: stop with: tmp3 startingAt: 1! !

!ModularArray methodsFor: 'accessing' stamp: 'len 6/21/2023 22:33:30'!
at: anInteger
	^ scalars representative: (representatives at: anInteger)! !

!ModularArray methodsFor: 'accessing' stamp: 'len 5/4/2023 23:44:53'!
at: anInteger put: anElement
	anElement isInteger ifTrue: [^ representatives at: anInteger put: anElement \\ scalars modulus].
	representatives at: anInteger put: anElement representative.
	^ anElement! !

!ModularArray methodsFor: 'accessing' stamp: 'len 5/4/2023 23:44:53'!
atAllPut: aModularInteger
	representatives atAllPut: aModularInteger representative! !

!ModularArray methodsFor: 'accessing' stamp: 'len 5/15/2023 17:39:35'!
lift
	"Answer a balanced representative tuple of integers."
	| m h r |
	m _ scalars modulus.
	h _ m >> 1.
	^ ℤ new: self size fill: [:i| (r _ representatives at: i) <= h ifTrue: [r] ifFalse: [r - m]]! !

!ModularArray methodsFor: 'accessing' stamp: 'len 5/5/2023 17:09:56'!
representative
	"Answer a representative array of integers."
	^ representatives asArray! !

!ModularArray methodsFor: 'accessing' stamp: 'len 5/4/2023 23:44:53'!
scalars
	^ scalars! !

!ModularArray methodsFor: 'accessing' stamp: 'len 5/4/2023 23:44:53'!
size
	^ representatives size! !

!ModularArray methodsFor: 'accessing' stamp: 'len 5/4/2023 23:44:53'!
swap: oneIndex with: anotherIndex 
	"Move the element at oneIndex to anotherIndex, and vice-versa."
	representatives swap: oneIndex with: anotherIndex! !

!ModularArray methodsFor: 'comparing' stamp: 'len 5/4/2023 23:44:53'!
= anObject
	^ self class = anObject class and: [representatives = anObject representatives and: [scalars = anObject scalars]]! !

!ModularArray methodsFor: 'comparing' stamp: 'len 5/4/2023 23:44:53'!
hash
	| answer |
	answer _ 0.
	representatives do: [:each| each = 0 ifFalse: [answer _ answer hashMultiply + each hash]].
	^ answer! !

!ModularArray methodsFor: 'converting' stamp: 'len 12/28/2023 11:15:47'!
asForm
	^ representatives asForm! !

!ModularArray methodsFor: 'copying' stamp: 'len 5/4/2023 23:44:53'!
postCopy
	super postCopy.
	representatives _ representatives copy! !

!ModularArray methodsFor: 'operations' stamp: 'len 6/6/2023 13:25:03'!
evaluateFrom: start to: stop at: anElement
	^ scalars representative: (representatives evaluateFrom: start to: stop at: anElement representative modulo: scalars modulus)! !

!ModularArray methodsFor: 'operations' stamp: 'len 5/4/2023 23:44:53'!
product
	| modulus answer |
	modulus _ scalars modulus.
	answer _ 1.
	representatives do: [:each| answer _ each * answer \\ modulus].
	^ scalars representative: answer! !

!ModularArray methodsFor: 'operations' stamp: 'len 5/4/2023 23:44:53'!
reversed
	^ self class representatives: representatives reversed scalars: scalars! !

!ModularArray methodsFor: 'operations' stamp: 'len 5/11/2023 15:28:11'!
weight
	"Answer the Hamming weight of the receiver, i.e. the number of entries that are not zero."
	^ representatives weight! !

!ModularArray methodsFor: 'operations-low level' stamp: 'len 5/21/2023 00:01:09'!
· anArray
	^ scalars representative: (representatives dot: anArray representatives modulo: scalars modulus)! !

!ModularArray methodsFor: 'operations-low level' stamp: 'len 6/21/2023 23:00:36'!
exponentiate: anArray
	^ scalars representative: (representatives exponentiate: anArray modulo: scalars modulus)! !

!ModularArray methodsFor: 'operations-low level' stamp: 'len 5/4/2023 23:44:53'!
findFirstNonzeroFrom: start to: stop
	"Answer the index of the first nonzero entry between start and stop, or nil."
	^ representatives findFirstNonzeroFrom: start to: stop! !

!ModularArray methodsFor: 'operations-low level' stamp: 'len 5/4/2023 23:44:53'!
findLastNonzeroFrom: start to: stop
	"Answer the index of the last nonzero entry between start and stop, or nil."
	^ representatives findLastNonzeroFrom: start to: stop! !

!ModularArray methodsFor: 'operations-low level' stamp: 'len 5/22/2023 21:11:08'!
partiallyReduceBy: g quotient: q
	representatives
		partiallyReduceBy: g representatives
		quotient: (q ifNotNil: [q representatives])
		modulo: scalars modulus! !

!ModularArray methodsFor: 'operations-low level' stamp: 'len 5/23/2023 10:50:13'!
reduceBy: g quotient: q
	representatives
		reduceBy: g representatives
		leadingInverse: g last inverse representative
		quotient: (q ifNotNil: [q representatives])
		modulo: scalars modulus! !

!ModularArray methodsFor: 'operations-low level' stamp: 'len 2/1/2024 19:36:08'!
replaceFrom: start by: step plusMatrix: anArray1 startingAt: start1 by: step1 width: width1 height: height timesMatrix: anArray2 startingAt: start2 by: step2 width: width
	representatives
		replaceFrom: start by: step
		plusMatrix: anArray1 representatives startingAt: start1 by: step1 width: width1 height: height
		timesMatrix: anArray2 representatives startingAt: start2 by: step2 width: width
		modulo: scalars modulus
! !

!ModularArray methodsFor: 'operations-low level' stamp: 'len 1/5/2024 15:33:50'!
replaceFrom: start by: step withMatrix: anArray1 startingAt: start1 by: step1 width: width height: height
	representatives replaceFrom: start by: step withMatrix: anArray1 representatives startingAt: start1 by: step1 width: width height: height! !

!ModularArray methodsFor: 'operations-low level' stamp: 'len 2/2/2024 10:30:34'!
replaceFrom: start plus: anArray1 from: start1 to: stop1 convolution: anArray2 from: start2 to: stop2
	self replaceFrom: start plus: anArray1 from: start1 to: stop1 convolutionLong: anArray2 from: start2 to: stop2! !

!ModularArray methodsFor: 'operations-low level' stamp: 'len 2/2/2024 10:29:58'!
replaceFrom: start plus: anArray1 from: start1 to: stop1 convolutionKronecker: anArray2 from: start2 to: stop2
	representatives
		replaceFrom: start
		plus: anArray1 representatives from: start1 to: stop1
		convolutionKronecker: anArray2 representatives from: start2 to: stop2
		modulo: scalars modulus! !

!ModularArray methodsFor: 'operations-low level' stamp: 'len 2/2/2024 10:28:42'!
replaceFrom: start plus: anArray1 from: start1 to: stop1 convolutionLong: anArray2 from: start2 to: stop2
	representatives
		replaceFrom: start
		plus: anArray1 representatives from: start1 to: stop1
		convolutionLong: anArray2 representatives from: start2 to: stop2
		modulo: scalars modulus! !

!ModularArray methodsFor: 'operations-low level' stamp: 'len 2/3/2024 17:08:22'!
replaceFrom: start to: stop plusMatrix: anArray1 startingAt: start1 by: step1 width: width1 timesVector: anArray2 startingAt: start2
	representatives
		replaceFrom: start to: stop
		plusMatrix: anArray1 representatives startingAt: start1 by: step1 width: width1
		timesVector: anArray2 representatives startingAt: start2
		modulo: scalars modulus
! !

!ModularArray methodsFor: 'operations-low level' stamp: 'len 5/4/2023 23:44:53'!
replaceFrom: start to: stop with: replacement startingAt: repStart
	(replacement class = self class and: [scalars = replacement scalars])
		ifFalse: [^ super replaceFrom: start to: stop with: replacement startingAt: repStart].
	representatives replaceFrom: start to: stop with: replacement representatives startingAt: repStart! !

!ModularArray methodsFor: 'operations-low level' stamp: 'len 5/4/2023 23:44:53'!
replaceFrom: start to: stop with: anArray1 startingAt: start1 minus: anArray2 startingAt: start2
	representatives
		replaceFrom: start to: stop
		with: anArray1 representatives startingAt: start1
		minus: anArray2 representatives startingAt: start2
		modulo: scalars modulus! !

!ModularArray methodsFor: 'operations-low level' stamp: 'len 5/4/2023 23:44:53'!
replaceFrom: start to: stop with: anArray1 startingAt: start1 plus: anArray2 startingAt: start2
	representatives
		replaceFrom: start to: stop
		with: anArray1 representatives startingAt: start1
		plus: anArray2 representatives startingAt: start2
		modulo: scalars modulus! !

!ModularArray methodsFor: 'operations-low level' stamp: 'len 5/28/2023 22:27:29'!
replaceFrom: start to: stop with: anArray1 startingAt: start1 plus: anArray2 startingAt: start2 timesScalar: anElement
	representatives
		replaceFrom: start to: stop
		with: anArray1 representatives startingAt: start1
		plus: anArray2 representatives startingAt: start2
		timesScalar: (anElement isInteger ifTrue: [anElement \\ scalars modulus] ifFalse: [anElement representative])
		modulo: scalars modulus! !

!ModularArray methodsFor: 'operations-low level' stamp: 'len 5/4/2023 23:44:53'!
replaceFrom: start to: stop with: anArray1 startingAt: start1 times: anArray2 startingAt: start2
	representatives
		replaceFrom: start to: stop
		with: anArray1 representatives startingAt: start1
		times: anArray2 representatives startingAt: start2
		modulo: scalars modulus! !

!ModularArray methodsFor: 'operations-low level' stamp: 'len 5/28/2023 22:21:58'!
replaceFrom: start to: stop with: anArray startingAt: srcStart timesScalar: anElement
	representatives
		replaceFrom: start to: stop
		with: anArray representatives startingAt: srcStart
		timesScalar: (anElement isInteger ifTrue: [anElement \\ scalars modulus] ifFalse: [anElement representative])
		modulo: scalars modulus! !

!ModularArray methodsFor: 'operations-low level' stamp: 'len 5/4/2023 23:44:53'!
replaceFrom: start to: stop withNegated: anArray startingAt: srcStart
	representatives
		replaceFrom: start to: stop
		withNegated: anArray representatives startingAt: srcStart
		modulo: scalars modulus! !

!ModularArray methodsFor: 'operations-low level' stamp: 'len 6/16/2023 18:53:25'!
replaceFrom: start with: anArray1 from: start1 to: stop1 convolution: anArray2 from: start2 to: stop2
	self flag: #fixme. "see when it is faster to use kronecker substitution"
	super replaceFrom: start with: anArray1 from: start1 to: stop1 convolution: anArray2 from: start2 to: stop2
"	representatives replaceFrom: start with: anArray1 representatives from: start1 to: stop1 convolutionKronecker: anArray2 representatives from: start2 to: stop2 modulo: scalars modulus"! !

!ModularArray methodsFor: 'operations-low level' stamp: 'len 5/25/2023 18:13:03'!
replaceFrom: start withAutoconvolution: anArray1 from: start1 to: stop1
	representatives replaceFrom: start withAutoconvolutionKronecker: anArray1 representatives from: start1 to: stop1 modulo: scalars modulus! !

!ModularArray methodsFor: 'operations-low level' stamp: 'len 5/18/2023 17:33:26'!
replaceWithMatrixTranspose: anArray width: width
	representatives replaceWithMatrixTranspose: anArray representatives width: width! !

!ModularArray methodsFor: 'operations-low level' stamp: 'len 1/13/2024 09:44:00'!
sumFrom: start to: stop
	^ scalars representative: (representatives sumFrom: start to: stop modulo: scalars modulus)! !

!ModularArray methodsFor: 'operations-low level' stamp: 'len 5/4/2023 23:44:53'!
swapFrom: start to: stop with: anArray startingAt: start2
	representatives swapFrom: start to: stop with: anArray representatives startingAt: start2! !

!ModularArray methodsFor: 'printing' stamp: 'len 5/16/2023 13:53:43'!
printOn: aStream
	self modulus <= 16
		ifTrue: [representatives do: [:each| each printOn: aStream base: 16]]
		ifFalse: [aStream print: representatives asArray]! !

!ModularArray methodsFor: 'testing' stamp: 'len 5/4/2023 23:44:53'!
isZero
	^ representatives isZero! !

!ModularArray methodsFor: 'testing' stamp: 'len 5/4/2023 23:44:53'!
isZeroAt: anInteger
	^ representatives isZeroAt: anInteger! !

!ModularArray methodsFor: 'private' stamp: 'len 5/4/2023 23:44:53'!
modulus
	^ self scalars modulus! !

!ModularArray methodsFor: 'private' stamp: 'len 5/4/2023 23:44:53'!
representatives
	^ representatives! !

!ModularArray methodsFor: 'private' stamp: 'len 11/16/2023 21:54:39'!
representatives: anArray scalars: aModularIntegerRing
	representatives := anArray.
	scalars := aModularIntegerRing
"	representatives do: [:each| (each between: 0 and: modulus) ifFalse: [self halt]]"! !

!ModularArray methodsFor: 'private' stamp: 'len 5/4/2023 23:44:53'!
species
	^ scalars! !

!ModularArray methodsFor: 'private' stamp: 'len 1/14/2024 10:23:48'!
zeros
	self isEmpty ifTrue: [^ self].
	^ self scalars zeros: self size! !

!ModularArray class methodsFor: 'instance creation' stamp: 'len 11/16/2023 21:54:53'!
representatives: anArray scalars: aModularIntegerRing
	^ self basicNew representatives: anArray scalars: aModularIntegerRing! !

!ProductArray methodsFor: 'accessing' stamp: 'len 5/4/2023 23:39:54'!
at: anInteger
	^ scalars compose: (components collect: [:each| each at: anInteger])! !

!ProductArray methodsFor: 'accessing' stamp: 'len 5/4/2023 23:39:54'!
at: anInteger put: anElement
	components withIndexDo: [:each :i| each at: anInteger put: (anElement at: i)].
	^ anElement! !

!ProductArray methodsFor: 'accessing' stamp: 'len 5/4/2023 23:39:54'!
atAllPut: anElement
	components withIndexDo: [:each :i| each atAllPut: (anElement at: i)]! !

!ProductArray methodsFor: 'accessing' stamp: 'len 5/4/2023 23:39:54'!
projection: anInteger
	^ components at: anInteger! !

!ProductArray methodsFor: 'accessing' stamp: 'len 5/4/2023 23:39:54'!
scalars
	^ scalars! !

!ProductArray methodsFor: 'accessing' stamp: 'len 5/4/2023 23:39:54'!
size
	^ components first size! !

!ProductArray methodsFor: 'accessing' stamp: 'len 5/12/2023 23:24:19'!
swap: oneIndex with: anotherIndex 
	components do: [:each| each swap: oneIndex with: anotherIndex]! !

!ProductArray methodsFor: 'comparing' stamp: 'len 5/4/2023 23:39:54'!
= anObject
	^ self class = anObject class and: [components = anObject components and: [scalars = anObject scalars]]! !

!ProductArray methodsFor: 'comparing' stamp: 'len 5/4/2023 23:39:54'!
hash
	^ components hash! !

!ProductArray methodsFor: 'copying' stamp: 'len 5/4/2023 23:39:54'!
postCopy
	super postCopy.
	components _ components collect: [:each| each copy]! !

!ProductArray methodsFor: 'operations-low level' stamp: 'len 5/20/2023 23:56:10'!
· anArray
	^ scalars compose: (components withIndexCollect: [:each :i| each · (anArray projection: i)])! !

!ProductArray methodsFor: 'operations-low level' stamp: 'len 5/4/2023 23:39:54'!
findFirstNonzeroFrom: start to: stop
	| answer |
	answer _ nil.
	components do: [:each| (each findFirstNonzeroFrom: start to: stop) ifNotNil: [:index| answer _ answer isNil ifTrue: [index] ifFalse: [answer min: index]]].
	^ answer! !

!ProductArray methodsFor: 'operations-low level' stamp: 'len 5/4/2023 23:39:54'!
findLastNonzeroFrom: start to: stop
	| answer |
	answer _ nil.
	components do: [:each| (each findLastNonzeroFrom: start to: stop) ifNotNil: [:index| answer _ answer isNil ifTrue: [index] ifFalse: [answer max: index]]].
	^ answer! !

!ProductArray methodsFor: 'operations-low level' stamp: 'len 5/22/2023 21:08:18'!
partiallyReduceBy: g quotient: q
	components withIndexDo: [:each :i|
		each partiallyReduceBy: (g projection: i) quotient: (q ifNotNil: [q projection: i])]! !

!ProductArray methodsFor: 'operations-low level' stamp: 'len 5/23/2023 10:45:00'!
reduceBy: g quotient: q
	components withIndexDo: [:each :i|
		each
			reduceBy: (g projection: i)
			quotient: (q ifNotNil: [q projection: i])]! !

!ProductArray methodsFor: 'operations-low level' stamp: 'len 2/1/2024 19:33:46'!
replaceFrom: start by: step plusMatrix: anArray1 startingAt: start1 by: step1 width: width1 height: height timesMatrix: anArray2 startingAt: start2 by: step2 width: width
	components withIndexDo: [:each :i|
		each
			replaceFrom: start by: step
			plusMatrix: (anArray1 projection: i) startingAt: start1 by: step1 width: width1 height: height
			timesMatrix: (anArray2 projection: i) startingAt: start2 by: step2 width: width]! !

!ProductArray methodsFor: 'operations-low level' stamp: 'len 1/5/2024 15:32:04'!
replaceFrom: start by: step withMatrix: anArray startingAt: start1 by: step1 width: width height: height
	components withIndexDo: [:each :i|
		each
			replaceFrom: start by: step
			withMatrix: (anArray projection: i) startingAt: start1 by: step1 width: width height: height]! !

!ProductArray methodsFor: 'operations-low level' stamp: 'len 2/3/2024 17:02:32'!
replaceFrom: start to: stop plusMatrix: anArray1 startingAt: start1 by: step1 width: width1 timesVector: anArray2 startingAt: start2
	components withIndexDo: [:each :i|
		each
			replaceFrom: start to: stop
			plusMatrix: (anArray1 projection: i) startingAt: start1 by: step1 width: width1
			timesVector: (anArray2 projection: i) startingAt: start2]! !

!ProductArray methodsFor: 'operations-low level' stamp: 'len 5/12/2023 23:40:24'!
replaceFrom: start to: stop with: replacement startingAt: repStart	
	components withIndexDo: [:each :i|
		each replaceFrom: start to: stop with: (replacement projection: i) startingAt: repStart	]! !

!ProductArray methodsFor: 'operations-low level' stamp: 'len 5/4/2023 23:39:54'!
replaceFrom: start to: stop with: anArray1 startingAt: start1 minus: anArray2 startingAt: start2
	components withIndexDo: [:each :i|
		each
			replaceFrom: start to: stop
			with: (anArray1 projection: i) startingAt: start1
			minus: (anArray2 projection: i) startingAt: start2]! !

!ProductArray methodsFor: 'operations-low level' stamp: 'len 5/4/2023 23:39:54'!
replaceFrom: start to: stop with: anArray1 startingAt: start1 plus: anArray2 startingAt: start2
	components withIndexDo: [:each :i|
		each
			replaceFrom: start to: stop
			with: (anArray1 projection: i) startingAt: start1
			plus: (anArray2 projection: i) startingAt: start2]! !

!ProductArray methodsFor: 'operations-low level' stamp: 'len 5/28/2023 22:28:22'!
replaceFrom: start to: stop with: anArray1 startingAt: start1 plus: anArray2 startingAt: start2 timesScalar: anElement
	anElement isInteger ifTrue:
		[components withIndexDo: [:each :i|
			each
				replaceFrom: start to: stop
				with: (anArray1 projection: i) startingAt: start1
				plus: (anArray2 projection: i) startingAt: start2
				timesScalar: anElement].
		^ self].
	components withIndexDo: [:each :i|
		each
			replaceFrom: start to: stop
			with: (anArray1 projection: i) startingAt: start1
			plus: (anArray2 projection: i) startingAt: start2
			timesScalar: (anElement at: i)]! !

!ProductArray methodsFor: 'operations-low level' stamp: 'len 5/4/2023 23:39:54'!
replaceFrom: start to: stop with: anArray1 startingAt: start1 times: anArray2 startingAt: start2
	components withIndexDo: [:each :i|
		each
			replaceFrom: start to: stop
			with: (anArray1 projection: i) startingAt: start1
			times: (anArray2 projection: i) startingAt: start2]! !

!ProductArray methodsFor: 'operations-low level' stamp: 'len 5/12/2023 22:59:19'!
replaceFrom: start to: stop with: anArray startingAt: srcStart timesScalar: anElement
	anElement isInteger ifTrue:
		[components withIndexDo: [:each :i|
			each
				replaceFrom: start to: stop
				with: (anArray projection: i) startingAt: srcStart
				timesScalar: anElement].
		^ self].
	components withIndexDo: [:each :i|
		each
			replaceFrom: start to: stop
			with: (anArray projection: i) startingAt: srcStart
			timesScalar: (anElement at: i)]! !

!ProductArray methodsFor: 'operations-low level' stamp: 'len 5/4/2023 23:39:54'!
replaceFrom: start to: stop withNegated: anArray startingAt: srcStart
	components withIndexDo: [:each :i|
		each
			replaceFrom: start to: stop
			withNegated: (anArray projection: i) startingAt: srcStart]! !

!ProductArray methodsFor: 'operations-low level' stamp: 'len 5/13/2023 08:34:54'!
replaceFrom: start with: anArray1 from: start1 to: stop1 convolution: anArray2 from: start2 to: stop2
	components withIndexDo: [:each :i|
		each
			replaceFrom: start
			with: (anArray1 projection: i) from: start1 to: stop1
			convolution: (anArray2 projection: i) from: start2 to: stop2]! !

!ProductArray methodsFor: 'operations-low level' stamp: 'len 5/4/2023 23:39:54'!
replaceFrom: start withAutoconvolution: anArray1 from: start1 to: stop1
	components withIndexDo: [:each :i|
		each replaceFrom: start withAutoconvolution: (anArray1 projection: i) from: start1 to: stop1]! !

!ProductArray methodsFor: 'operations-low level' stamp: 'len 5/18/2023 17:33:40'!
replaceWithMatrixTranspose: anArray width: width
	components withIndexDo: [:each :i | each replaceWithMatrixTranspose: (anArray projection: i) width: width]! !

!ProductArray methodsFor: 'operations-low level' stamp: 'len 5/4/2023 23:39:54'!
swapFrom: start to: stop with: anArray startingAt: start2
	components withIndexDo: [:each :i|
		each swapFrom: start to: stop with: (anArray projection: i) startingAt: start2]! !

!ProductArray methodsFor: 'printing' stamp: 'len 6/11/2023 10:37:36'!
printOn: aStream
	aStream withParentheses: [:aStream2| self do: [:each| aStream2 print: each] separatedBy: [aStream2 nextPutAll: ', ']]! !

!ProductArray methodsFor: 'testing' stamp: 'len 5/4/2023 23:39:54'!
isZero
	^ components allSatisfy: [:each| each isZero]! !

!ProductArray methodsFor: 'testing' stamp: 'len 5/4/2023 23:39:54'!
isZeroAt: anInteger
	^ components allSatisfy: [:each| (each isZeroAt: anInteger)]! !

!ProductArray methodsFor: 'private' stamp: 'len 5/4/2023 23:39:54'!
components
	^ components! !

!ProductArray methodsFor: 'private' stamp: 'len 5/4/2023 23:39:54'!
components: anArray scalars: aProductRing
	components _ anArray.
	scalars _ aProductRing! !

!ProductArray methodsFor: 'private' stamp: 'len 5/4/2023 23:39:54'!
species
	^ scalars! !

!ProductArray class methodsFor: 'instance creation' stamp: 'len 5/4/2023 23:39:54'!
components: anArray scalars: aProductRing
	^ self basicNew components: anArray scalars: aProductRing! !

!TernaryArray methodsFor: 'accessing' stamp: 'len 5/17/2023 23:31:09'!
at: anInteger
	anInteger > size ifTrue: [^ self errorOutOfBounds].
	(words₀ bitAt: anInteger) = 0 ifTrue: [^ Zero].
	^ (words₁ bitAt: anInteger) = 0 ifTrue: [One] ifFalse: [MinusOne]! !

!TernaryArray methodsFor: 'accessing' stamp: 'len 5/17/2023 23:31:09'!
at: anInteger put: anElement
	anElement isZero ifTrue: [words₀ bitAt: anInteger put: 0. words₁ bitAt: anInteger put: 0. ^ anElement].
	anElement isOne ifTrue: [words₀ bitAt: anInteger put: 1. words₁ bitAt: anInteger put: 0. ^ anElement].
	anElement = MinusOne ifFalse: [^ self errorImproperStore].
	words₀ bitAt: anInteger put: 1. words₁ bitAt: anInteger put: 1.
	^ anElement! !

!TernaryArray methodsFor: 'accessing' stamp: 'len 5/17/2023 23:31:09'!
atAllPut: anObject
	anObject = Zero ifFalse: [^ super atAllPut: anObject].
	words₀ atAllPut: 0.
	words₁ atAllPut: 0! !

!TernaryArray methodsFor: 'accessing' stamp: 'len 5/17/2023 23:28:37'!
firstNonzeroIndex
	"Answer the index of the first nonzero entry, or nil."
	| wordIndex |
	(wordIndex _ words₀ firstNonzeroIndex) ifNil: [^ nil].
	^ wordIndex - 1 * 32 + (words₀ at: wordIndex) lowBit! !

!TernaryArray methodsFor: 'accessing' stamp: 'len 6/9/2023 12:29:49'!
from: startIndex to: endIndex put: anObject
	anObject = Zero ifFalse: [^ super from: startIndex to: endIndex put: anObject].
	words₀ clearBitsFrom: startIndex to: endIndex.
	words₁ clearBitsFrom: startIndex to: endIndex.
	^ anObject! !

!TernaryArray methodsFor: 'accessing' stamp: 'len 5/17/2023 23:28:37'!
lastNonzeroIndex
	"Answer the index of the last nonzero entry, or nil."
	| wordIndex |
	(wordIndex _ words₀ lastNonzeroIndex) ifNil: [^ nil].
	^ wordIndex - 1 * 32 + (words₀ at: wordIndex) highBit! !

!TernaryArray methodsFor: 'accessing' stamp: 'len 5/15/2023 17:37:21'!
lift
	^ ℤ new: self size fill: [:i| (self at: i) lift]! !

!TernaryArray methodsFor: 'accessing' stamp: 'len 5/15/2023 17:37:12'!
representative
	^ ℤ new: self size fill: [:i| (self at: i) representative]! !

!TernaryArray methodsFor: 'accessing' stamp: 'len 5/15/2023 16:09:52'!
scalars
	^ Zero parent! !

!TernaryArray methodsFor: 'accessing' stamp: 'len 5/15/2023 12:54:06'!
size
	^ size! !

!TernaryArray methodsFor: 'comparing' stamp: 'len 5/17/2023 23:31:35'!
= anObject
	^ self class = anObject class and: [size = anObject size and: [words₀ = anObject words₀ and: [words₁ = anObject words₁]]]! !

!TernaryArray methodsFor: 'comparing' stamp: 'len 5/17/2023 23:31:09'!
hash
	^ words₀ hash hashMultiply + words₁ hash! !

!TernaryArray methodsFor: 'copying' stamp: 'len 5/17/2023 23:31:09'!
postCopy
	super postCopy.
	words₀ _ words₀ copy.
	words₁ _ words₁ copy! !

!TernaryArray methodsFor: 'operations' stamp: 'len 6/6/2023 08:48:56'!
* anObject
	| r |
	anObject isInteger ifFalse: [^ super * anObject].
	(r := anObject \\ 3) = 0 ifTrue: [^ self zeros].
	r = 2 ifTrue: [^ self + self].
	^ self! !

!TernaryArray methodsFor: 'operations' stamp: 'len 5/21/2023 09:29:50'!
*= anObject
	| r |
	anObject isInteger ifFalse: [^ super *= anObject].
	(r := anObject \\ 3) = 0 ifTrue:
		[words₀ clearBitsFrom: 1 to: self size.
		words₁ clearBitsFrom: 1 to: self size.
		^ self].
	r = 2 ifTrue: [^ self += self].
	^ self! !

!TernaryArray methodsFor: 'operations' stamp: 'len 6/6/2023 13:20:14'!
evaluateFrom: start to: stop at: anElement
	stop < start ifTrue: [^ anElement * Zero].
	Zero = anElement ifTrue: [^ self at: start].
	One = anElement ifTrue: [^ self sumFrom: start to: stop].
	"MinusOne = anObject ifTrue: [^ self alternateSumFrom: start to: stop]."
	^ super evaluateFrom: start to: stop at: anElement! !

!TernaryArray methodsFor: 'operations' stamp: 'len 5/17/2023 23:28:37'!
supportDo: aBlock
	words₀ bitSupportDo: aBlock! !

!TernaryArray methodsFor: 'operations' stamp: 'len 5/17/2023 23:28:37'!
weight
	"Answer the Hamming weight of the receiver, i.e. the number of entries that are not zero."
	^ words₀ bitCount! !

!TernaryArray methodsFor: 'operations-low level' stamp: 'len 5/22/2023 18:18:16'!
· anArray
	| n i sum x₀ x₁ y₀ y₁ h₀ h₁ |
	n := words₀ size min: anArray words₀ size.
	i := 1.
	sum := 0.
	[i <= n] whileTrue:
		[x₀ := words₀ at: i. x₁ := words₁ at: i.
		y₀ := anArray words₀ at: i. y₁ := anArray words₁ at: i.
		"Hadamard product:"
		h₀ := x₀ bitAnd: y₀. h₁ := (x₁ bitXor: y₁) bitAnd: h₀.
		"add number of ones and substract number of minus ones:"
		sum := (h₁ bitInvert bitAnd: h₀) bitCount32 - h₁ bitCount32 + sum.
		i := i + 1].
	sum := sum \\ 3.
	sum = 0 ifTrue: [^ Zero].
	sum = 1 ifTrue: [^ One].
	^ MinusOne! !

!TernaryArray methodsFor: 'operations-low level' stamp: 'len 12/29/2023 11:12:06'!
findFirstNonzeroFrom: start to: stop
	"Answer the index of the first nonzero entry between start and stop, or nil."
	^ words₀ lowBitFrom: start to: stop! !

!TernaryArray methodsFor: 'operations-low level' stamp: 'len 12/29/2023 11:12:18'!
findLastNonzeroFrom: start to: stop
	"Answer the index of the last nonzero entry between start and stop, or nil."
	^ words₀ highBitFrom: start to: stop! !

!TernaryArray methodsFor: 'operations-low level' stamp: 'len 2/3/2024 17:02:51'!
replaceFrom: start by: step plusMatrix: anArray1 startingAt: start1 by: step1 width: width1 height: height timesMatrix: anArray2 startingAt: start2 by: step2 width: width
	| ℓ i |
	(width = 1 and: [step2 = 1 and: [step = 1]]) ifTrue: [^ self replaceFrom: start to: start + height - 1 plusMatrix: anArray1 startingAt: start1 by: step1 width: width1 timesVector: anArray2 startingAt: start2].
	i := 0.
	[i < width1] whileTrue:
		[ℓ := 32 min: width1 - i.
		0 to: height-1 do: [:j| | i₀ x₀ x₁ j₀ jₙ |
			i₀ := j * step1 + start1 + i.
			x₀ := anArray1 words₀ bits: ℓ at: i₀.
			x₁ := anArray1 words₁ bits: ℓ at: i₀.
			j₀ := j * step + start.
			jₙ := j₀ + width - 1.
			"ones:"
			(x₁ bitInvert bitAnd: x₀) bitSupportDo: [:k|
				self replaceFrom: j₀ to: jₙ plus: anArray2 startingAt: k-1*step2 + start2].
			"minus ones:"
			(x₁ bitAnd: x₀) bitSupportDo: [:k|
				self replaceFrom: j₀ to: jₙ minus: anArray2 startingAt: k-1*step2 + start2]].
		i := i + ℓ]! !

!TernaryArray methodsFor: 'operations-low level' stamp: 'len 1/9/2024 10:32:45'!
replaceFrom: start by: step withMatrix: anArray1 startingAt: start1 by: step1 width: width height: height
	words₀ replaceBitsFrom: start by: step withMatrix: anArray1 words₀ startingAt: start1 by: step1 width: width height: height.
	words₁ replaceBitsFrom: start by: step withMatrix: anArray1 words₁ startingAt: start1 by: step1 width: width height: height! !

!TernaryArray methodsFor: 'operations-low level' stamp: 'len 2/2/2024 10:27:00'!
replaceFrom: start plus: anArray1 from: start1 to: stop1 convolutionLong: anArray2 from: start2 to: stop2
	| i ℓ x₀ x₁ j j₀ |
	i := start2.
	[i <= stop2] whileTrue:
		[ℓ := 32 min: stop2 - i + 1.
		(x₀ := anArray2 words₀ bits: ℓ at: i) = 0 ifFalse: "if it has some non-zero entries..."
			[x₁ := anArray2 words₁ bits: ℓ at: i.
			j := i-start2+start.
			"ones:"
			(x₁ bitInvert bitAnd: x₀) bitSupportDo: [:k|
				j₀ := j + k - 1.
				self replaceFrom: j₀ to: j₀ + stop1 - start1 plus: anArray1 startingAt: start1].
			"minus ones:"
			(x₁ bitAnd: x₀) bitSupportDo: [:k|
				j₀ := j + k - 1.
				self replaceFrom: j₀ to: j₀ + stop1 - start1 minus: anArray1 startingAt: start1]].
		i := i + ℓ]! !

!TernaryArray methodsFor: 'operations-low level' stamp: 'len 2/3/2024 17:09:51'!
replaceFrom: start to: stop plusMatrix: anArray1 startingAt: start1 by: step1 width: width1 timesVector: anArray2 startingAt: start2
	| ℓ k |
	start2 = 1 ifFalse: [self notYetImplemented].
	width1 = 0 ifTrue: [^ self].
	k := start1.
	start to: stop by: 32 do: [:i|
		| s t x₀ x₁ z₀ z₁ |
		ℓ := 32 min: stop-i+1.
		z₀ := 0.
		z₁ := 0.
		0 to: ℓ-1 do: [:j|
			| n sum r |
			n := width1.
			t := k.
			s := 1.
			sum := 0.
			[n > 0] whileTrue:
				[| h₀ h₁ y₀ y₁ |
				r := n min: 32.
				x₀ := anArray1 words₀ bits: r at: t. x₁ := anArray1 words₁ bits: r at: t.
				y₀ := anArray2 words₀ at: s. y₁ := anArray2 words₁ at: s.
				"Hadamard product:"
				h₀ := x₀ bitAnd: y₀. h₁ := (x₁ bitXor: y₁) bitAnd: h₀.
				"add number of ones and substract number of minus ones:"
				sum := (h₁ bitInvert bitAnd: h₀) bitCount32 - h₁ bitCount32 + sum.
				t := t + r.
				s := s + 1.
				n := n - r].
			(sum := sum \\ 3) = 0 ifFalse:
				[| b |
				b := 1 bitShift: j.
				z₀ := z₀ bitXor: b.
				sum = 1 ifFalse: [z₁ := z₁ bitXor: b]].
			k := k + step1].
		x₀ := words₀ bits: ℓ at: i. x₁ := words₁ bits: ℓ at: i.
		s := x₀ bitXor: z₁. t := x₁ bitXor: z₀.
		words₀ bits: ℓ at: i put: ((s bitXor: x₁) bitOr: (t bitXor: z₁)).
		words₁ bits: ℓ at: i put: (s bitAnd: t)]! !

!TernaryArray methodsFor: 'operations-low level' stamp: 'len 5/17/2023 23:31:47'!
replaceFrom: start to: stop with: replacement startingAt: repStart
	words₀ replaceBitsFrom: start to: stop with: replacement words₀ startingAt: repStart.
	words₁ replaceBitsFrom: start to: stop with: replacement words₁ startingAt: repStart! !

!TernaryArray methodsFor: 'operations-low level' stamp: 'len 5/17/2023 23:32:04'!
replaceFrom: start to: stop with: anArray1 startingAt: start1 minus: anArray2 startingAt: start2	
	| n i₀ i r j k x₀ x₁ y₀ y₁ t |
	(n _ stop - start + 1) > 0 ifFalse: [^ self].
	i₀ _ start - 1.
	i _ (i₀ bitShift: -5) + 1.
	r _ i*32 - i₀ min: n. "r ∈ [1..32]"
	j _ start1.
	k _ start2.
	r = 32 ifFalse:
		[x₀ _ anArray1 words₀ bits: r at: j. x₁ _ anArray1 words₁ bits: r at: j.
		y₀ _ anArray2 words₀ bits: r at: k. y₁ _ anArray2 words₁ bits: r at: k.
		t _ x₀ bitXor: y₀.
		words₀ bits: r at: start put: (t bitOr: (x₁ bitXor: y₁)).
		words₁ bits: r at: start put: ((t bitXor: y₁) bitAnd: (x₁ bitXor: y₀)).
		n _ n - r. j _ j + r. k _ k + r. i _ i + 1].
	[n >= 32] whileTrue:
		[x₀ _ anArray1 words₀ bits: 32 at: j. x₁ _ anArray1 words₁ bits: 32 at: j.
		y₀ _ anArray2 words₀ bits: 32 at: k. y₁ _ anArray2 words₁ bits: 32 at: k.
		t _ x₀ bitXor: y₀.
		words₀ at: i put: (t bitOr: (x₁ bitXor: y₁)).
		words₁ at: i put: ((t bitXor: y₁) bitAnd: (x₁ bitXor: y₀)).
		n _ n - 32. j _ j + 32. k _ k + 32. i _ i + 1].
	n > 0 ifTrue:
		[x₀ _ anArray1 words₀ bits: n at: j. x₁ _ anArray1 words₁ bits: n at: j.
		y₀ _ anArray2 words₀ bits: n at: k. y₁ _ anArray2 words₁ bits: n at: k.
		t _ x₀ bitXor: y₀.
		words₀ bits: n at: i-1*32 + 1 put: (t bitOr: (x₁ bitXor: y₁)).
		words₁ bits: n at: i-1*32 + 1 put: ((t bitXor: y₁) bitAnd: (x₁ bitXor: y₀))]! !

!TernaryArray methodsFor: 'operations-low level' stamp: 'len 5/17/2023 23:32:25'!
replaceFrom: start to: stop with: anArray1 startingAt: start1 plus: anArray2 startingAt: start2	
	| n i₀ i r j k x₀ x₁ y₀ y₁ s t |
	(n _ stop - start + 1) > 0 ifFalse: [^ self].
	i₀ _ start - 1.
	i _ (i₀ bitShift: -5) + 1.
	r _ i*32 - i₀ min: n. "r ∈ [1..32]"
	j _ start1.
	k _ start2.
	r = 32 ifFalse:
		[x₀ _ anArray1 words₀ bits: r at: j. x₁ _ anArray1 words₁ bits: r at: j.
		y₀ _ anArray2 words₀ bits: r at: k. y₁ _ anArray2 words₁ bits: r at: k.
		s _ x₀ bitXor: y₁.
		t _ x₁ bitXor: y₀.
		words₀ bits: r at: start put: ((s bitXor: x₁) bitOr: (t bitXor: y₁)).
		words₁ bits: r at: start put: (s bitAnd: t).
		n _ n - r. j _ j + r. k _ k + r. i _ i + 1].
	[n >= 32] whileTrue:
		[x₀ _ anArray1 words₀ bits: 32 at: j. x₁ _ anArray1 words₁ bits: 32 at: j.
		y₀ _ anArray2 words₀ bits: 32 at: k. y₁ _ anArray2 words₁ bits: 32 at: k.
		s _ x₀ bitXor: y₁.
		t _ x₁ bitXor: y₀.
		words₀ at: i put: ((s bitXor: x₁) bitOr: (t bitXor: y₁)).
		words₁ at: i put: (s bitAnd: t).
		n _ n - 32. j _ j + 32. k _ k + 32. i _ i + 1].
	n > 0 ifTrue:
		[x₀ _ anArray1 words₀ bits: n at: j. x₁ _ anArray1 words₁ bits: n at: j.
		y₀ _ anArray2 words₀ bits: n at: k. y₁ _ anArray2 words₁ bits: n at: k.
		s _ x₀ bitXor: y₁.
		t _ x₁ bitXor: y₀.
		words₀ bits: n at: i-1*32 + 1 put: ((s bitXor: x₁) bitOr: (t bitXor: y₁)).
		words₁ bits: n at: i-1*32 + 1 put: (s bitAnd: t)]! !

!TernaryArray methodsFor: 'operations-low level' stamp: 'len 5/28/2023 22:25:41'!
replaceFrom: start to: stop with: anArray1 startingAt: start1 plus: anArray2 startingAt: start2 timesScalar: anElement
	| r |
	r := anElement isInteger ifTrue: [anElement \\ 3] ifFalse: [anElement representative].
	r = 0 ifTrue: [^ self replaceFrom: start to: stop with: anArray1 startingAt: start1].
	r = 2 ifTrue: [^ self replaceFrom: start to: stop with: anArray1 startingAt: start1 minus: anArray2 startingAt: start2].
	self replaceFrom: start to: stop with: anArray1 startingAt: start1 plus: anArray2 startingAt: start2! !

!TernaryArray methodsFor: 'operations-low level' stamp: 'len 5/17/2023 23:32:34'!
replaceFrom: start to: stop with: anArray1 startingAt: start1 times: anArray2 startingAt: start2
	words₀ replaceBitsFrom: start to: stop with: anArray1 words₀ startingAt: start1 and: anArray2 words₀ startingAt: start2.
	words₁ replaceBitsFrom: start to: stop with: anArray1 words₁ startingAt: start1 xor: anArray2 words₁ startingAt: start2.
	words₁ replaceBitsFrom: start to: stop with: words₁ startingAt: start and: words₀ startingAt: start! !

!TernaryArray methodsFor: 'operations-low level' stamp: 'len 1/9/2024 10:48:08'!
replaceFrom: start to: stop with: anArray1 startingAt: start1 timesScalar: anElement
	| r |
	r := anElement isInteger ifTrue: [anElement \\ 3] ifFalse: [anElement representative].
	r = 0 ifTrue: [words₀ clearBitsFrom: start to: stop. words₁ clearBitsFrom: start to: stop. ^ self].
	r = 2 ifTrue: [^ self replaceFrom: start to: stop withNegated: anArray1 startingAt: start1].
	^ self replaceFrom: start to: stop with: anArray1 startingAt: start1! !

!TernaryArray methodsFor: 'operations-low level' stamp: 'len 5/17/2023 23:32:39'!
replaceFrom: start to: stop withNegated: anArray startingAt: srcStart
	words₀ replaceBitsFrom: start to: stop with: anArray words₀ startingAt: srcStart.
	words₁ replaceBitsFrom: start to: stop with: anArray words₀ startingAt: srcStart xor: anArray words₁ startingAt: srcStart! !

!TernaryArray methodsFor: 'operations-low level' stamp: 'len 5/18/2023 18:47:38'!
replaceWithMatrixTranspose: anArray width: width
	self flag: #fixme. "TODO: implement once we have binary matrix tranpose"
	super replaceWithMatrixTranspose: anArray width: width
"	words₀ replaceBitsWithMatrixTranspose: anArray words₀ width: width	.
	words₁ replaceBitsWithMatrixTranspose: anArray words₁ width: width"! !

!TernaryArray methodsFor: 'printing' stamp: 'len 5/16/2023 13:54:13'!
printOn: aStream
	self do: [:each| aStream print: each]! !

!TernaryArray methodsFor: 'testing' stamp: 'len 5/17/2023 23:28:37'!
isZero
	^ words₀ isZero! !

!TernaryArray methodsFor: 'testing' stamp: 'len 5/17/2023 23:28:37'!
isZeroAt: anInteger
	^ (words₀ bitAt: anInteger) = 0! !

!TernaryArray methodsFor: 'private' stamp: 'len 5/17/2023 23:31:09'!
validate
	super validate.
	words₀ size = words₁ size ifFalse: [self error: 'slices sizes don''t match'].
	size - 1 // 32 + 1 = words₀ size ifFalse: [self error: 'too many words'].
	size \\ 32 = 0 ifTrue: [^ self].
	words₀ last highBit <= (size \\ 32) ifFalse: [self error: 'tail is not zero'].
	words₁ last highBit <= (size \\ 32) ifFalse: [self error: 'tail is not zero']! !

!TernaryArray methodsFor: 'private' stamp: 'len 5/17/2023 23:28:59'!
words₀
	^ words₀! !

!TernaryArray methodsFor: 'private' stamp: 'len 5/17/2023 23:33:41'!
words₀: aWordArray words₁: anotherWordArray size: anInteger
	| n |
	n _ aWordArray size.
	self assert: anotherWordArray size = aWordArray size.
	anInteger - 1 // 32 + 1 = n ifFalse: [self error: 'too many words'].
	words₀ _ aWordArray.
	words₁ _ anotherWordArray.
	size _ anInteger! !

!TernaryArray methodsFor: 'private' stamp: 'len 5/17/2023 23:31:21'!
words₁
	^ words₁! !

!TernaryArray methodsFor: 'private' stamp: 'len 1/14/2024 10:25:04'!
zeros
	self isEmpty ifTrue: [^ self].
	^ self scalars new: self size! !

!TernaryArray class methodsFor: 'class initialization' stamp: 'len 5/15/2023 12:51:36'!
initialize
	| Z3 |
	super initialize.
	ℤ isNil ifTrue: [^ self].
	Z3 _ ℤ / 3.
	One _ Z3 one.
	Zero _ Z3 zero.
	MinusOne _ One negated! !

!TernaryArray class methodsFor: 'instance creation' stamp: 'len 5/17/2023 23:34:43'!
new: anInteger
	| n |
	n _ anInteger - 1 // 32 + 1.
	^ self new: anInteger words₀: (WordArray new: n) words₁: (WordArray new: n)! !

!TernaryArray class methodsFor: 'instance creation' stamp: 'len 5/17/2023 23:36:14'!
new: anInteger words₀: aWordArray words₁: anotherWordArray
	^ self basicNew words₀: aWordArray words₁: anotherWordArray size: anInteger! !

!Simplex methodsFor: 'accessing' stamp: 'len 2/15/2017 08:52:17'!
dimension
	^ vertices size - 1! !

!Simplex methodsFor: 'accessing' stamp: 'len 2/23/2017 10:20:17'!
size
	^ vertices size! !

!Simplex methodsFor: 'accessing' stamp: 'len 2/15/2017 08:56:46'!
vertices
	^ vertices! !

!Simplex methodsFor: 'comparing' stamp: 'len 12/4/2023 10:06:39'!
< x
	self halt! !

!Simplex methodsFor: 'comparing' stamp: 'len 12/4/2023 10:06:28'!
<= x
	self halt! !

!Simplex methodsFor: 'comparing' stamp: 'len 4/21/2020 11:16:56'!
= anObject
	^ self class == anObject class and: [self vertices = anObject vertices]

"before we didn't keep vertices sorted, so we could check of two differently oriented simplices were equal:
	| iv v |
	vertices isEmpty ifTrue: [^ aSimplex vertices isEmpty].
	v _ vertices first.
	iv _ aSimplex vertices indexOf: v ifAbsent: [^ false].
	vertices withIndexDo: [:each :i|
		each = (aSimplex vertices atWrap: i+iv-1) ifFalse: [^ false]].
	^ true"! !

!Simplex methodsFor: 'comparing' stamp: 'len 12/4/2023 10:06:37'!
> x
	self halt! !

!Simplex methodsFor: 'comparing' stamp: 'len 12/4/2023 10:06:31'!
>= x
	self halt! !

!Simplex methodsFor: 'comparing' stamp: 'len 2/15/2017 08:14:56'!
~ aSimplex
	"Answer true if the receiver and the argument are isomorphic."
	^ self dimension = aSimplex dimension! !

!Simplex methodsFor: 'comparing' stamp: 'len 2/23/2017 19:08:39'!
hash
	^ vertices inject: 0 into: [:sum :each| sum + each hash] "this is independent of orientation"! !

!Simplex methodsFor: 'comparing' stamp: 'len 12/10/2023 10:36:24'!
⊆ aSimplex
	"Answer true if the receiver is contained in aSimplex as a face."
	^ vertices size <= aSimplex vertices size and: [aSimplex vertices includesAllOf: vertices]! !

!Simplex methodsFor: 'comparing' stamp: 'len 12/4/2023 10:04:54'!
⊊ aSimplex
	"Answer true if the receiver is strictly contained in aSimplex as a face."
	^ vertices size < aSimplex vertices size and: [aSimplex vertices includesAllOf: vertices]! !

!Simplex methodsFor: 'converting' stamp: 'len 2/14/2017 18:48:50'!
asSkeletonGraph
	| graph F |
	graph _ Graph unordered.
	F _ self faces: self dimension.
	graph addAll: self facets.
	F do: [:x| F do: [:y| graph addEdgeFrom: x to: y]].
	^ graph! !

!Simplex methodsFor: 'enumerating' stamp: 'len 2/24/2017 11:44:43'!
collect: aBlock
	^ self class vertices: (self vertices collect: aBlock) asSet "we don't assume aBlock is injective, so we have to convert to a Set to remove repetitions"! !

!Simplex methodsFor: 'enumerating' stamp: 'len 2/20/2017 18:49:55'!
do: aBlock
	^ self vertices do: aBlock! !

!Simplex methodsFor: 'faces' stamp: 'len 2/23/2016 02:02'!
edges
	^ self faces: 1! !

!Simplex methodsFor: 'faces' stamp: 'len 6/13/2016 00:00'!
faces
	"Answer all faces of the receiver (including the empty set and the receiver)."
	^ Iterator on: [:aBlock| self facesDo: aBlock]! !

!Simplex methodsFor: 'faces' stamp: 'len 2/15/2017 08:09:38'!
faces: n
	"Answer the n-faces of the receiver."
	^ Iterator on: [:aBlock| self faces: n do: aBlock]! !

!Simplex methodsFor: 'faces' stamp: 'len 2/23/2017 18:55:13'!
faces: n do: aBlock
	"Iterate over the n-faces of the receiver."
	n = -1 ifTrue: [^ aBlock value: (self class vertices: #())].
	vertices isEmpty ifTrue: [^ self].
	vertices combinations: n+1 atATimeDo: [:each|
		aBlock value: (self class vertices: each asSet)]! !

!Simplex methodsFor: 'faces' stamp: 'len 6/12/2016 23:59'!
facesDo: aBlock
	"Iterate over all faces of the receiver (including the empty set and the receiver)."
	-1 to: self dimension do: [:i| self faces: i do: aBlock]! !

!Simplex methodsFor: 'faces' stamp: 'len 6/13/2016 00:09'!
facets
	"Answer the boundary faces of the receiver."
	^ self faces: self dimension - 1! !

!Simplex methodsFor: 'faces' stamp: 'len 6/12/2016 23:59'!
properFaces
	"Answer all proper faces of the receiver of any dimension (including the empty set)."
	^ Iterator on: [:aBlock| self properFacesDo: aBlock]! !

!Simplex methodsFor: 'faces' stamp: 'len 6/12/2016 23:59'!
properFacesDo: aBlock
	"Iterate over all proper faces of the receiver (including the empty set)."
	-1 to: self dimension - 1 do: [:i| self faces: i do: aBlock]! !

!Simplex methodsFor: 'faces' stamp: 'len 2/27/2016 08:15'!
ridges
	^ self faces: self dimension - 2! !

!Simplex methodsFor: 'operations' stamp: 'len 2/15/2017 08:55:06'!
* aSimplex
	"Answer the join of the receiver with the argument."
	^ self class vertices: (self vertices collect: [:x| {1. x}]), (aSimplex vertices collect: [:y| {2. y}])! !

!Simplex methodsFor: 'operations' stamp: 'len 2/19/2017 08:24:44'!
closure
	"Answer the simplicial complex with the receiver. By definition of simplicial complex, it also contains all faces of the receiver)."
	^ SimplicialComplex facets: {self}! !

!Simplex methodsFor: 'operations' stamp: 'len 2/19/2017 09:31:02'!
complementIn: aCollection
	"Answer the complement of the receiver in the given vertex set.
	This is the simplex formed by the vertices in aCollection *not* in the receiver."
	^ self class vertices: aCollection \ vertices! !

!Simplex methodsFor: 'operations' stamp: 'len 8/12/2022 13:03:45'!
∩ aSimplex
	"Answer the face common to the receiver and aSimplex, which could be {}."
	^ self class vertices: self vertices ∩ aSimplex vertices! !

!Simplex methodsFor: 'printing' stamp: 'len 2/27/2017 08:21:52'!
printOn: aStream
"	self isTrivial ifTrue: [aStream nextPut: Character emptySet. ^ self]."
	aStream nextPut: ${.
	self vertices do: [:each|
		(each isString and: [aStream isText])
			ifTrue: [aStream nextPutAll: each asText]
			ifFalse: [aStream print: each]] separatedBy: [aStream nextPut: $,].
	aStream nextPut: $}! !

!Simplex methodsFor: 'testing' stamp: 'len 2/20/2017 18:49:36'!
includes: anObject
	^ vertices includes: anObject! !

!Simplex methodsFor: 'testing' stamp: 'len 2/19/2017 10:39:56'!
intersects: aSimplex
	^ self vertices intersects: aSimplex vertices! !

!Simplex methodsFor: 'testing' stamp: 'len 2/19/2017 18:20:51'!
isTrivial
	"Answer true if this is the empty simplex."
	^ vertices isEmpty! !

!Simplex methodsFor: 'private' stamp: 'len 2/20/2017 19:04:07'!
species
	^ Set! !

!Simplex methodsFor: 'private' stamp: 'len 12/10/2023 10:36:24'!
vertices: aCollection
	vertices := (aCollection allSatisfy: [:each| each isArray])
		ifTrue: [aCollection sorted: [:a :b| a ⊆ b]]
		ifFalse: [aCollection sorted]! !

!Simplex class methodsFor: 'instance creation' stamp: 'len 2/15/2017 08:54:40'!
new: n
	"Answer the standard n-simplex {1,...,n}."
	^ self vertices: (1 to: n+1)! !

!Simplex class methodsFor: 'instance creation' stamp: 'len 2/15/2017 08:54:35'!
newFrom: aCollection
	^ self vertices: aCollection! !

!Simplex class methodsFor: 'instance creation' stamp: 'len 2/15/2017 08:54:28'!
vertices: aCollection
	^ self new vertices: aCollection! !

!DivisibilityError methodsFor: 'accessing' stamp: 'len 5/28/2022 11:53:50'!
dividend
	^ self isRightDivision ifTrue: [receiver] ifFalse: [arguments first]! !

!DivisibilityError methodsFor: 'accessing' stamp: 'len 5/28/2022 11:54:13'!
divisor
	^ self isRightDivision ifTrue: [arguments first] ifFalse: [receiver]! !

!DivisibilityError methodsFor: 'testing' stamp: 'len 5/28/2022 11:52:33'!
isLeftDivision
	^ self isRightDivision not! !

!DivisibilityError methodsFor: 'testing' stamp: 'len 5/28/2022 17:52:12'!
isRightDivision
	(#(/ // \\) includes: selector) ifTrue: [^ true].
	selector = #\ ifTrue: [^ false].
	^ self error: 'unknown division selector'! !

!Domain methodsFor: 'accessing' stamp: 'len 4/1/2024 13:32:54'!
at: anInteger
	(self isProduct or: [self isCoproduct]) ifFalse: [^ self error: 'not a product or coproduct'].
	^ self components at: anInteger! !

!Domain methodsFor: 'accessing' stamp: 'len 6/14/2024 11:32:04'!
category
	"Answer the category where the receiver belongs as object."
	^ self id category! !

!Domain methodsFor: 'comparing' stamp: 'len 5/25/2024 11:31:42'!
~ anObject
	"Answer true if the receiver is isomorphic to the argument."
	^ self = anObject! !

!Domain methodsFor: 'internalization' stamp: 'len 6/11/2024 21:01:36'!
carrier
	^ self! !

!Domain methodsFor: 'internalization' stamp: 'len 8/31/2024 08:42:52'!
comodules
	"Answer the category of right comodules over the receiver, assuming the receiver is a comonoid object."
	self assert: self isComonoid.
	^ self reverse modules opposite

	"For a finite dimensional coalgebra C, comodules over C are equivalent to modules over the dual algebra Cᵛ.
	^ self dual modules	"
! !

!Domain methodsFor: 'internalization' stamp: 'len 9/1/2024 16:40:20'!
comultiplication
	"Objects of cartesian monoidal categories are naturally comonoids with the diagonal morphism as comultiplication and the terminal morphism as counit."
	self category isCartesianMonoidal ifTrue: [^ self diagonal].
	^ self subclassResponsibility! !

!Domain methodsFor: 'internalization' stamp: 'len 9/1/2024 16:40:45'!
counit
	"Objects of cartesian monoidal categories are naturally comonoids with the diagonal morphism as comultiplication and the terminal morphism as counit."
	self category isCartesianMonoidal ifTrue: [^ self → self category terminalObject].
	^ self subclassResponsibility! !

!Domain methodsFor: 'internalization' stamp: 'len 9/1/2024 16:50:37'!
isBimonoid
	^ false! !

!Domain methodsFor: 'internalization' stamp: 'len 8/29/2024 15:33:34'!
isCogroup
	^ false! !

!Domain methodsFor: 'internalization' stamp: 'len 8/31/2024 08:47:32'!
isComodule
	^ false! !

!Domain methodsFor: 'internalization' stamp: 'len 9/1/2024 18:54:15'!
isComonoid
	^ self category isCartesianMonoidal! !

!Domain methodsFor: 'internalization' stamp: 'len 8/29/2024 15:32:16'!
isGroup
	^ false! !

!Domain methodsFor: 'internalization' stamp: 'len 8/31/2024 08:47:15'!
isModule
	^ false! !

!Domain methodsFor: 'internalization' stamp: 'len 8/29/2024 15:15:16'!
isMonoid
	^ self category isCocartesianMonoidal! !

!Domain methodsFor: 'internalization' stamp: 'len 8/30/2024 07:48:41'!
modules
	"Answer the category of right modules over the receiver, assuming the receiver is a monoid object."
	self assert: self isMonoid.
	^ self propertyAt: #modules ifAbsentPut: [ModuleCategory over: self]! !

!Domain methodsFor: 'internalization' stamp: 'len 9/1/2024 16:35:38'!
multiplication
	"Objects of cocartesian monoidal categories are naturally monoids with the codiagonal morphism as multiplication and the initial morphism as unit."
	self category isCocartesianMonoidal ifTrue: [^ self codiagonal].
	^ self subclassResponsibility! !

!Domain methodsFor: 'internalization' stamp: 'len 6/11/2024 21:04:52'!
to: aCodomain carrier: aMorphism
	^ aMorphism! !

!Domain methodsFor: 'internalization' stamp: 'len 9/1/2024 16:36:27'!
unit
	"Objects of cocartesian monoidal categories are naturally monoids with the codiagonal morphism as multiplication and the initial morphism as unit."
	self category isCocartesianMonoidal ifTrue: [^ self category initialObject → self].
	^ self subclassResponsibility! !

!Domain methodsFor: 'morphisms' stamp: 'len 6/2/2024 11:32:27'!
^ anObject
	"This is the exponential notation for the hom-set functor. See also #⇒."
	anObject isMorphism ifTrue: [^ anObject domain ^ self to: anObject codomain ^ self map: [:f| anObject · f]].
	^ (self propertyAt: #homsets ifAbsentPut: [WeakIdentityKeyDictionary new])
		at: anObject ifAbsentPut: [^ HomSet from: anObject to: self]! !

!Domain methodsFor: 'morphisms' stamp: 'len 6/9/2022 12:32:49'!
addCoprojections: anArray
	anArray do: [:each| self assert: each codomain == self].
	^ (self propertyAt: #coprojections ifAbsentPut: [Dictionary new])
		at: (anArray collect: [:each| each domain]) put: anArray! !

!Domain methodsFor: 'morphisms' stamp: 'len 10/29/2023 20:42:12'!
addMap: aMorphism
"	(self category includes: aMorphism) ifFalse: [Error signal: 'not a morphism']."
	aMorphism domain == self
		ifTrue: [^ (self propertyAt: #outputs ifAbsentPut: [WeakIdentityKeyDictionary new]) at: aMorphism codomain put: aMorphism].
	aMorphism codomain == self
		ifTrue: [^ (self propertyAt: #inputs ifAbsentPut: [WeakIdentityKeyDictionary new]) at: aMorphism domain put: aMorphism].
	^ self error: 'not a morphism from or to the receiver'! !

!Domain methodsFor: 'morphisms' stamp: 'len 6/9/2022 12:33:15'!
addProjections: anArray
	anArray do: [:each| self assert: each domain == self].
	^ (self propertyAt: #projections ifAbsentPut: [Dictionary new])
		at: (anArray collect: [:each| each codomain]) put: anArray! !

!Domain methodsFor: 'morphisms' stamp: 'len 7/10/2024 10:14:22'!
associatorWith: anObject and: anotherObject
	"If the receiver and the arguments are objects of a monoidal category, answer the associator.
	This is a natural isomorphism (X⊗Y)⊗Z → X⊗(Y⊗Z)."
	^ self subclassResponsibility! !

!Domain methodsFor: 'morphisms' stamp: 'len 12/1/2023 14:12:31'!
automorphisms
	^ self propertyAt: #automorphisms ifAbsentPut: [AutomorphismGroup on: self]! !

!Domain methodsFor: 'morphisms' stamp: 'len 8/23/2024 08:35:04'!
braidingWith: anObject
	"If the receiver and the argument are objects of a braided monoidal category, answer their braiding isomorphism."
	self category isCartesianMonoidal ifTrue: [^ self × anObject ⇉ {self. anObject} into: [:π₁ :π₂| π₂ ⊓ π₁]].
	self category isCocartesianMonoidal ifTrue: [^ self ⊔ anObject ⇇ {self. anObject} into: [:ι₁ :ι₂| ι₂ ⊔ ι₁]].
	^ self subclassResponsibility! !

!Domain methodsFor: 'morphisms' stamp: 'len 7/1/2024 11:10:05'!
codiagonal
	"Answer the codiagonal morphism ∇ : X⊔X → X, if it exists. See also #diagonal.
	The codiagonal morphism always exists in a cocartesian category.
	Note: the codiagonal morphism is also sometimes called 'fold morphism' or 'folding'."
	^ self id ⊔ self id! !

!Domain methodsFor: 'morphisms' stamp: 'len 7/27/2024 10:40:15'!
coevaluation
	"If the receiver is a dualizable object X in a monoidal category with dual object Xᵛ, answer the coevaluation morphism 1 → X ⊗ Xᵛ.
	See also #evaluation and #dual."
	^ self subclassResponsibility! !

!Domain methodsFor: 'morphisms' stamp: 'len 7/31/2024 09:09:31'!
coevaluationWith: anObject
	"If the receiver and the argument are objects in a (right) closed monoidal category, answer the coevaluation morphism Y → [X,Y⊗X]. These morphisms are the components of the unit of the tensor-hom adjunction."
	^ self subclassResponsibility! !

!Domain methodsFor: 'morphisms' stamp: 'len 6/1/2024 07:24:01'!
colift: aMorphism
	"Answer the restriction of aMorphism to the receiver."
	^ self ⇢ aMorphism domain ifNotNil: [:anotherMorphism| anotherMorphism colift: aMorphism]! !

!Domain methodsFor: 'morphisms' stamp: 'len 7/31/2024 09:18:49'!
compositionWith: anObject and: anotherObject
	"If the receiver and the arguments are objects of a (right) closed monoidal category, answer the composition natural isomorphism [Y,Z]⊗[X,Y] → [X,Z]."
	^ (self curryingWith: anObject and: anotherObject) ∘ (((anObject evaluationWith: anotherObject) ∘ ((anObject ⇒ anotherObject) id ⊗ (self evaluationWith: anObject))))! !

!Domain methodsFor: 'morphisms' stamp: 'len 7/28/2024 09:38:55'!
curryingWith: anObject and: anotherObject
	"If the receiver and the arguments are objects of a (right) closed monoidal category, answer the currying natural isomorphism [X⊗Y,Z] → [X,[Y,Z]]."
	^ self subclassResponsibility! !

!Domain methodsFor: 'morphisms' stamp: 'len 6/9/2024 08:04:31'!
diagonal
	"Answer the diagonal morphism Δ : X → X×X, if it exists. See also #codiagonal.
	The diagonal morphism always exists in a cartesian category."
	^ self id ⊓ self id! !

!Domain methodsFor: 'morphisms' stamp: 'len 12/1/2023 16:23:16'!
endomorphisms
	^ self propertyAt: #endomorphisms ifAbsentPut: [EndomorphismMonoid on: self]! !

!Domain methodsFor: 'morphisms' stamp: 'len 7/31/2024 09:25:49'!
evaluation
	"If the receiver is a dualizable object X in a monoidal category with dual object Xᵛ, answer the evaluation morphism Xᵛ ⊗ X → 1.
	See also #coevaluation and #dual."
	^ self evaluationWith: self category unitObject! !

!Domain methodsFor: 'morphisms' stamp: 'len 7/31/2024 09:05:37'!
evaluationWith: anObject
	"If the receiver and the argument are objects in a (right) closed monoidal category, answer the evaluation morphism [X,Y]⊗X → Y. These morphisms are the components of the counit of the tensor-hom adjunction."
	^ self subclassResponsibility! !

!Domain methodsFor: 'morphisms' stamp: 'len 4/3/2024 09:23:41'!
from: aDomain
	"Answer the canonical morphism from aDomain to the receiver."
	^ nil! !

!Domain methodsFor: 'morphisms' stamp: 'len 4/2/2024 06:39:10'!
fromAll: anArray
	"Answer the canonical coprojections from the components of anArray to the receiver."
	(self isCoproduct and: [self components = anArray])
		ifTrue: [^ self addCoprojections: ((1 to: self components size) collect: [:i| self coprojection: i])].
	^ nil! !

!Domain methodsFor: 'morphisms' stamp: 'len 8/4/2024 09:43:30'!
hom: aCodomain
	"If the argument is an object X in the same category as the receiver A, answer the hom-object Hom(A,X) corresponding to the morphisms from A to X. If the category is enriched over a monoidal category V, this is an object of V. In particular, if the category is closed monoidal, this is an object of the same category (which is enriched over itself). 
	By default it is the set of actual morphisms, but subclasses can reimplement to answer a suitable hom-object.
	See also #^ and #⇒."
	^ aCodomain ^ self! !

!Domain methodsFor: 'morphisms' stamp: 'len 5/2/2024 06:31:35'!
id
	"Answer the identity morphism."
	^ self propertyAt: #id ifAbsent: [self subclassResponsibility]! !

!Domain methodsFor: 'morphisms' stamp: 'len 9/1/2024 19:59:31'!
leftUnitor
	"If the receiver is an object X of a monoidal category, answer the left unitor.
	This is a natural isomorphism 1 ⊗ X → X, where 1 is the tensor unit."
	self category isCartesianMonoidal ifTrue: [^ (self category unitObject × self ⇉ {self category unitObject. self}) second].
	self category isCocartesianMonoidal ifTrue: [^ (self category unitObject ⊔ self ⇇ {self category unitObject. self}) second].
	^ self subclassResponsibility! !

!Domain methodsFor: 'morphisms' stamp: 'len 9/1/2024 20:00:02'!
rightUnitor
	"If the receiver is an object X of a monoidal category, answer the right unitor.
	This is a natural isomorphism X ⊗ 1 → X, where 1 is the tensor unit."
	self category isCartesianMonoidal ifTrue: [^ (self × self category unitObject ⇉ {self. self category unitObject}) first].
	self category isCocartesianMonoidal ifTrue: [^ (self ⊔ self category unitObject ⇇ {self. self category unitObject}) first].
	^ self subclassResponsibility! !

!Domain methodsFor: 'morphisms' stamp: 'len 9/1/2024 20:01:11'!
to: aCodomain
	"Answer the canonical morphism from the receiver to aCodomain."
	self = aCodomain ifTrue: [^ self id].
	^ nil! !

!Domain methodsFor: 'morphisms' stamp: 'len 4/6/2024 15:54:37'!
to: aCodomain adapt: anObject
	"Answer a morphism from the receiver to aCodomain induced by anObject, or nil."
	^ nil! !

!Domain methodsFor: 'morphisms' stamp: 'len 7/5/2024 17:11:43'!
to: aCodomain map: aBlock
	self assert: self carrier ~~ self.
	^ self to: aCodomain carrier: (self carrier to: aCodomain carrier map: aBlock)! !

!Domain methodsFor: 'morphisms' stamp: 'len 4/2/2024 06:39:19'!
toAll: anArray
	"Answer the canonical projections from the receiver to the components of anArray."
	(self isProduct and: [anArray = self components])
		ifTrue: [^ self addProjections: ((1 to: self components size) collect: [:i| self projection: i])].
	^ nil! !

!Domain methodsFor: 'morphisms' stamp: 'len 8/15/2024 13:45:23'!
→ aCodomain
	"Answer the canonical morphism from the receiver to aCodomain. See also Morphism>>#→."
	aCodomain isMorphism ifTrue: [^ self == aCodomain domain ifTrue: [aCodomain] ifFalse: [aCodomain ∘ (self → aCodomain domain)]].
	^ self ⇢ aCodomain ifNil: [self error: 'morphism not found']! !

!Domain methodsFor: 'morphisms' stamp: 'len 5/30/2024 13:46:39'!
⇇ anArray
	"If the receiver is the vertex of a cocone under the objects of anArray, answer the arrows of the cocone.
	See also message ⇉."
	self propertyAt: #coprojections ifPresent: [:aDictionary| aDictionary at: anArray ifPresent: [:anArrayOfMorphisms| ^ anArrayOfMorphisms]].
	^ (self fromAll: anArray) ifNil: [self error: 'coprojections not found']! !

!Domain methodsFor: 'morphisms' stamp: 'len 5/30/2024 13:46:11'!
⇉ anArray
	"If the receiver is the vertex of a cone over the objects of anArray, answer the arrows of the cone.
	See also message ⇇."
	self propertyAt: #projections ifPresent: [:aDictionary| aDictionary at: anArray ifPresent: [:anArrayOfMorphisms| ^ anArrayOfMorphisms]].
	^ (self toAll: anArray) ifNil: [self error: 'projections not found']! !

!Domain methodsFor: 'morphisms' stamp: 'len 8/15/2024 13:45:49'!
⇒ anObject
	"This is the hom-object functor. See #^ for the hom-set functor.
	- if the argument is an object X in the same category as the receiver A, answer the hom-object Hom(A,X);
	- if the argument is a morphism g : X → Y, answer the map Hom(A,g) : Hom(A,X) → Hom(A,Y) that sends a morphism f to g·f.
	Subclasses should not override this method. Instead, they can implement #hom: to answer an appropriate hom-object."
	anObject isMorphism ifTrue: [^ self ⇒ anObject domain to: self ⇒ anObject codomain map: [:f| anObject ∘ f]].
	(anObject isKindOf: ChainComplex) ifTrue: [^ ChainComplex differentials: (anObject differentials collect: [:each| self ⇒ each]) shift: anObject shift].
	^ (anObject ^ self) propertyAt: #structure ifAbsentPut: [self hom: anObject]! !

!Domain methodsFor: 'morphisms' stamp: 'len 6/1/2024 06:43:32'!
⇢ aCodomain
	"Answer the canonical morphism from the receiver to aCodomain, or nil."
	self == aCodomain ifTrue: [^ self id].
	self propertyAt: #outputs ifPresent: [:aDictionary| aDictionary at: aCodomain ifPresent: [:aMorphism| ^ aMorphism]].
	aCodomain propertyAt: #inputs ifPresent: [:aDictionary| aDictionary at: self ifPresent: [:aMorphism| ^ aMorphism]].
	^ (self to: aCodomain) ifNil: [aCodomain from: self]! !

!Domain methodsFor: 'operations' stamp: 'len 4/24/2024 16:31:02'!
× aDomain
	"Answer the categorical product of the receiver with the argument."
	^ self subclassResponsibility! !

!Domain methodsFor: 'operations' stamp: 'len 8/30/2024 20:45:18'!
coslice
	"Answer the coslice of the argument under the receiver."
	^ self reverse slice opposite! !

!Domain methodsFor: 'operations' stamp: 'len 8/2/2024 09:39:20'!
dual
	"If the receiver is an object X in a closed category with unit object 1, answer the (right) dual Xᵛ := [X,1].
	See also #evaluation and #coevaluation."
	^ self ⇒ self category unitObject! !

!Domain methodsFor: 'operations' stamp: 'len 5/18/2024 14:59:18'!
reverse
	"Answer the object associated to the receiver in the opposite category.
	The object is equal to the receiver but not identical."
	^ self propertyAt: #reverse ifAbsentPut: [OppositeObject reverse: self]! !

!Domain methodsFor: 'operations' stamp: 'len 7/5/2024 17:49:32'!
slice
	"Answer the slice of the argument over the receiver."
	^ self propertyAt: #slice ifAbsentPut: [SliceCategory over: self]! !

!Domain methodsFor: 'operations' stamp: 'len 7/5/2024 17:41:50'!
↓ aCategory
	"Answer the coslice of the argument under the receiver."
	self assert: (aCategory includes₀: self).
	^ self coslice

"this is a special case of the comma category:
	^ (Cat terminalObject to: aCategory constant: self) ↓ aCategory id
"! !

!Domain methodsFor: 'operations' stamp: 'len 5/23/2024 13:06:37'!
⊓ aDomain
	"Answer the categorical product of the receiver with the argument.
	Note: this is just a synonym, subclasses should reimplement #×."
	^ self × aDomain! !

!Domain methodsFor: 'operations' stamp: 'len 4/24/2024 16:28:29'!
⊔ aDomain
	"Answer the categorical coproduct of the receiver with the argument."
	^ self subclassResponsibility! !

!Domain methodsFor: 'operations' stamp: 'len 6/23/2024 11:33:41'!
⊕ anObject
	"If the receiver and the argument are objects of an additive category, answer their direct sum."
	^ self subclassResponsibility! !

!Domain methodsFor: 'operations' stamp: 'len 7/10/2024 09:04:56'!
⊗ anObject
	"If the receiver and the argument are objects of a monoidal category, answer their tensor product."
	self category isCartesianMonoidal ifTrue: [^ self × anObject].
	self category isCocartesianMonoidal ifTrue: [^ self ⊔ anObject].
	^ self subclassResponsibility! !

!Domain methodsFor: 'properties' stamp: 'len 6/7/2024 13:57:15'!
hasProperty: aSymbol
	^ (properties ifNil: [^ false]) includesKey: aSymbol! !

!Domain methodsFor: 'properties' stamp: 'len 6/7/2024 13:57:15'!
properties
	^ properties ifNil: [properties _ IdentityDictionary new]! !

!Domain methodsFor: 'properties' stamp: 'len 6/7/2024 13:57:15'!
propertyAt: aSymbol
	^ self propertyAt: aSymbol ifAbsent: [self error: 'no such property']! !

!Domain methodsFor: 'properties' stamp: 'len 6/7/2024 13:57:15'!
propertyAt: aSymbol ifAbsent: exceptionBlock
	^ (properties ifNil: [^ exceptionBlock value]) at: aSymbol ifAbsent: exceptionBlock! !

!Domain methodsFor: 'properties' stamp: 'len 6/7/2024 13:57:15'!
propertyAt: aSymbol ifAbsentPut: aBlock
	^ self properties at: aSymbol ifAbsentPut: aBlock! !

!Domain methodsFor: 'properties' stamp: 'len 6/7/2024 13:57:15'!
propertyAt: aSymbol ifPresent: aBlock
	^ (properties ifNil: [^ nil]) at: aSymbol ifPresent: aBlock! !

!Domain methodsFor: 'properties' stamp: 'len 6/7/2024 13:57:15'!
propertyAt: aSymbol put: anObject
	^ self properties at: aSymbol put: anObject! !

!Domain methodsFor: 'random' stamp: 'len 6/2/2024 04:45:57'!
to: aCodomain atRandom: aRandom
	"Answer a morphism from the receiver to aCodomain choosen at random."
	^ self to: aCodomain atRandom: aRandom bits: [aRandom nextBoolean] count + 1! !

!Domain methodsFor: 'random' stamp: 'len 6/2/2024 04:59:43'!
to: aCodomain atRandom: aRandom bits: bitSize
	"Answer a morphism from the receiver to aCodomain choosen at random of at most bitSize bits."
	^ self subclassResponsibility! !

!Domain methodsFor: 'testing' stamp: 'len 8/29/2024 15:19:06'!
isAbelianGroup
	^ false! !

!Domain methodsFor: 'testing' stamp: 'len 5/2/2020 21:33:10'!
isCategory
	^ false! !

!Domain methodsFor: 'testing' stamp: 'len 12/25/2021 12:31:15'!
isCoproduct
	"Answer true if the receiver is a coproduct construction."
	^ false! !

!Domain methodsFor: 'testing' stamp: 'len 4/2/2024 15:16:46'!
isDomain
	"Answer true if the receiver is a 0-cell."
	^ true! !

!Domain methodsFor: 'testing' stamp: 'len 7/8/2024 11:16:20'!
isInitialObject
	^ self ~ self category initialObject! !

!Domain methodsFor: 'testing' stamp: 'len 12/25/2021 12:31:05'!
isProduct
	"Answer true if the receiver is a product construction."
	^ false! !

!Domain methodsFor: 'testing' stamp: 'len 12/25/2021 12:30:37'!
isQuotient
	"Answer true if the receiver is a quotient construction."
	^ false! !

!Domain methodsFor: 'testing' stamp: 'len 5/2/2020 21:33:00'!
isRing
	^ false! !

!Domain methodsFor: 'testing' stamp: 'len 7/31/2020 11:45:28'!
isSet
	^ false! !

!Domain methodsFor: 'testing' stamp: 'len 7/8/2024 11:16:50'!
isTerminalObject
	^ self ~ self category terminalObject! !

!Domain methodsFor: 'testing' stamp: 'len 7/8/2024 11:17:06'!
isUnitObject
	^ self ~ self category unitObject! !

!Domain methodsFor: 'testing' stamp: 'len 5/2/2020 21:33:05'!
isVectorSpace
	^ false! !

!Domain methodsFor: 'testing' stamp: 'len 6/14/2024 15:09:12'!
isZero
	"Answer true if the receiver is the zero object of its category."
	^ self ~ self category zeroObject! !

!Domain class methodsFor: 'initialization' stamp: 'len 7/29/2024 09:26:13'!
initializeAll
	"First initialize transfinites, set globals ∞, ℵ and ω:"
	Ordinal initialize.
	"First initialize the category of sets as global Sets:"
	self initializeSets.
	"And initialize all Morphisms, set globals for categories like Grp, Rings, etc:"
	Morphism withAllSubclassesDo: [:each| (each class selectors includes: #initialize) ifTrue: [each initialize]].
	"Set some globals:"
	Smalltalk
		at: #ℕ put: Naturals new;
		at: #ℤ put: IntegerRing new;
		at: #ℚ put: RationalField new;
		at: #ℝ put: RealAlgebraicField new;
		at: #ℂ put: ComplexAlgebraicField new.
	"Then initialize all Domains:"
	Domain withAllSubclassesDo: [:each| (each class selectors includes: #initialize) ifTrue: [each initialize]].
	"And initialize all Morphisms, set globals for categories like Sets, Grp, Rings, etc:"
	Morphism withAllSubclassesDo: [:each| (each class selectors includes: #initialize) ifTrue: [each initialize]].
	"Finally initialize any other classes that need initialization:"
	BinaryArray initialize.
	TernaryArray initialize.
	"Set some more globals:"
	Smalltalk
		at: #𝔽₂ put: ℤ/2;
		at: #𝔽₃ put: ℤ/3;
		at: #Ab put: ℤ modules. "actually just the subcategory of finitely generated abelian groups"
	"And add some named characters for text input:"
	Character initializeNamedCharactersMap.
	#((iso $↔) (From $⇐) (To $⇒) (coproj $⇇) (proj $⇉) (into $↪) (onto $↠) (on $↷) (#'..to' $⇢)
	(Del $∆) (nabla $∇) "(box $☐ or $◻)" (boxplus $⊞) (boxminus $⊟) (boxtimes $⊠) (boxdot $⊡)
	(triangleup $▵) (triangledown $▿) (triangleleft $◃) (triangleright $▹)
	(bigtriangleup $△) (bigtriangledown $▽))
		do: [:each| Character namedCharactersMap at: each first put: each second].
	#((from gets) (and wedge) (or vee) (xor oplus))
		do: [:each| Character namedCharactersMap at: each first put: (Character namedCharactersMap at: each second)]! !

!Domain class methodsFor: 'initialization' stamp: 'len 8/27/2024 21:57:48'!
initializeSets
	| I T |
	I := #() asSetObject.
	T := #(1) asSetObject.
	Sets := Category new
		propertyAt: #initialObject put: I;
		propertyAt: #terminalObject put: T;
		propertyAt: #isClosedMonoidal put: true;
		propertyAt: #isCartesianMonoidal put: true;
		"propertyAt: #unitObject put: T;"
		yourself.
	Rel := Sets relations! !

!OppositeObject methodsFor: 'comparing' stamp: 'len 4/4/2024 12:27:52'!
= anObject
	^ anObject = reverse! !

!OppositeObject methodsFor: 'comparing' stamp: 'len 4/4/2024 12:27:52'!
hash
	^ reverse hash! !

!OppositeObject methodsFor: 'internalization' stamp: 'len 8/31/2024 08:39:55'!
action
	^ reverse coaction reverse! !

!OppositeObject methodsFor: 'internalization' stamp: 'len 6/9/2024 09:02:28'!
carrier
	^ reverse carrier reverse! !

!OppositeObject methodsFor: 'internalization' stamp: 'len 8/31/2024 08:39:46'!
coaction
	^ reverse action reverse! !

!OppositeObject methodsFor: 'internalization' stamp: 'len 6/9/2024 09:03:07'!
comultiplication
	^ reverse multiplication reverse! !

!OppositeObject methodsFor: 'internalization' stamp: 'len 8/31/2024 18:59:22'!
coopposite
	^ reverse opposite reverse! !

!OppositeObject methodsFor: 'internalization' stamp: 'len 6/9/2024 09:02:49'!
counit
	^ reverse unit reverse! !

!OppositeObject methodsFor: 'internalization' stamp: 'len 6/9/2024 09:18:08'!
isCocommutative
	^ reverse isCommutative! !

!OppositeObject methodsFor: 'internalization' stamp: 'len 8/29/2024 15:33:34'!
isCogroup
	^ reverse isGroup! !

!OppositeObject methodsFor: 'internalization' stamp: 'len 6/10/2024 16:17:10'!
isCommutative
	^ reverse isCocommutative! !

!OppositeObject methodsFor: 'internalization' stamp: 'len 8/31/2024 08:47:55'!
isComodule
	^ reverse isModule! !

!OppositeObject methodsFor: 'internalization' stamp: 'len 8/29/2024 15:15:46'!
isComonoid
	^ reverse isMonoid! !

!OppositeObject methodsFor: 'internalization' stamp: 'len 8/31/2024 08:48:33'!
isGroup
	^ reverse isCogroup! !

!OppositeObject methodsFor: 'internalization' stamp: 'len 8/31/2024 08:48:22'!
isModule
	^ reverse isComodule! !

!OppositeObject methodsFor: 'internalization' stamp: 'len 8/29/2024 15:15:46'!
isMonoid
	^ reverse isComonoid! !

!OppositeObject methodsFor: 'internalization' stamp: 'len 6/10/2024 16:16:16'!
multiplication
	^ reverse comultiplication reverse! !

!OppositeObject methodsFor: 'internalization' stamp: 'len 8/31/2024 18:59:29'!
opposite
	^ reverse coopposite reverse! !

!OppositeObject methodsFor: 'internalization' stamp: 'len 8/31/2024 08:40:07'!
scalars
	^ reverse scalars reverse! !

!OppositeObject methodsFor: 'internalization' stamp: 'len 6/10/2024 19:39:34'!
to: aCodomain carrier: aMorphism
	^ (aCodomain reverse to: reverse carrier: aMorphism reverse) reverse! !

!OppositeObject methodsFor: 'internalization' stamp: 'len 6/10/2024 16:16:06'!
unit
	^ reverse counit reverse! !

!OppositeObject methodsFor: 'morphisms' stamp: 'len 7/8/2024 07:31:31'!
associatorWith: anObject and: anotherObject
	^ (reverse associatorWith: anObject reverse and: anotherObject reverse) reverse! !

!OppositeObject methodsFor: 'morphisms' stamp: 'len 7/8/2024 07:28:29'!
braidingWith: anObject
	^ (reverse braidingWith: anObject reverse) reverse! !

!OppositeObject methodsFor: 'morphisms' stamp: 'len 7/8/2024 07:37:24'!
coevaluation
	^ reverse evaluation reverse! !

!OppositeObject methodsFor: 'morphisms' stamp: 'len 7/8/2024 07:37:19'!
evaluation
	^ reverse coevaluation reverse! !

!OppositeObject methodsFor: 'morphisms' stamp: 'len 4/4/2024 12:35:22'!
id
	^ reverse id reverse! !

!OppositeObject methodsFor: 'morphisms' stamp: 'len 7/8/2024 07:29:13'!
leftUnitor
	^ reverse leftUnitor reverse! !

!OppositeObject methodsFor: 'morphisms' stamp: 'len 7/8/2024 07:29:22'!
rightUnitor
	^ reverse rightUnitor reverse! !

!OppositeObject methodsFor: 'morphisms' stamp: 'len 6/1/2024 07:18:22'!
→ aCodomain
	aCodomain isMorphism ifTrue: [^ super → aCodomain].
	self assert: self class = aCodomain class.
	^ (aCodomain reverse → reverse) reverse! !

!OppositeObject methodsFor: 'morphisms' stamp: 'len 6/10/2024 21:02:38'!
⇇ anArray
	^ reverse ⇉ (anArray collect: [:each| each reverse]) collect: [:each| each reverse]! !

!OppositeObject methodsFor: 'morphisms' stamp: 'len 6/10/2024 21:02:43'!
⇉ anArray
	^ reverse ⇇ (anArray collect: [:each| each reverse]) collect: [:each| each reverse]! !

!OppositeObject methodsFor: 'morphisms' stamp: 'len 6/14/2024 15:10:14'!
⇒ aCodomain
	reverse category enrichmentBase isSymmetricMonoidal ifTrue: [^ aCodomain reverse ⇒ reverse].
	^ super ⇒ aCodomain! !

!OppositeObject methodsFor: 'morphisms' stamp: 'len 6/1/2024 06:24:03'!
⇢ aCodomain
	self assert: self class = aCodomain class.
	^ (aCodomain reverse ⇢ reverse ifNil: [^ nil]) reverse! !

!OppositeObject methodsFor: 'operations' stamp: 'len 5/2/2024 08:09:37'!
× anObject
	^ (reverse ⊔ anObject reverse) reverse! !

!OppositeObject methodsFor: 'operations' stamp: 'len 4/4/2024 12:27:58'!
reverse
	^ reverse! !

!OppositeObject methodsFor: 'operations' stamp: 'len 5/2/2024 08:09:46'!
⊔ anObject
	^ (reverse × anObject reverse) reverse! !

!OppositeObject methodsFor: 'operations' stamp: 'len 5/10/2024 04:52:59'!
⊕ anObject
	^ (reverse ⊕ anObject reverse) reverse! !

!OppositeObject methodsFor: 'operations' stamp: 'len 6/5/2024 06:18:47'!
⊗ anObject
	^ (reverse ⊗ anObject reverse) reverse! !

!OppositeObject methodsFor: 'printing' stamp: 'len 4/4/2024 12:27:52'!
printOn: aStream
	aStream print: reverse! !

!OppositeObject methodsFor: 'testing' stamp: 'len 5/2/2024 07:51:08'!
isCoproduct
	^ reverse isProduct! !

!OppositeObject methodsFor: 'testing' stamp: 'len 5/2/2024 07:51:01'!
isProduct
	^ reverse isCoproduct! !

!OppositeObject methodsFor: 'testing' stamp: 'len 4/6/2024 08:39:39'!
isZero
	^ reverse isZero! !

!OppositeObject methodsFor: 'private' stamp: 'len 6/10/2024 21:02:26'!
components
	^ reverse components collect: [:each| each reverse]! !

!OppositeObject methodsFor: 'private' stamp: 'len 4/4/2024 12:28:07'!
reverse: aDomain
	reverse := aDomain! !

!OppositeObject class methodsFor: 'instance creation' stamp: 'len 4/4/2024 12:28:24'!
reverse: aDomain
	^ self new reverse: aDomain! !

!Presheaf methodsFor: 'accessing' stamp: 'len 6/14/2024 15:02:29'!
category
	^ self domain ⇒ self codomain! !

!Presheaf methodsFor: 'accessing' stamp: 'len 5/30/2024 06:39:35'!
codomain
	^ functor codomain! !

!Presheaf methodsFor: 'accessing' stamp: 'len 6/2/2024 17:18:13'!
domain
	^ functor domain "opposite"! !

!Presheaf methodsFor: 'converting' stamp: 'len 6/7/2024 09:03:05'!
asFunctor
	^ functor! !

!Presheaf methodsFor: 'morphisms' stamp: 'len 7/26/2024 07:59:58'!
coevaluation
	^ self notYetImplemented! !

!Presheaf methodsFor: 'morphisms' stamp: 'len 7/26/2024 07:59:56'!
evaluation
	^ self notYetImplemented! !

!Presheaf methodsFor: 'morphisms' stamp: 'len 7/10/2024 09:15:55'!
hom: aCodomain
	self assert: self class = aCodomain class.
	self assert: (self domain = aCodomain domain and: [self codomain = aCodomain codomain]).
	^ (self domain to: self codomain enrichmentBase map: [:f| (self value: f) ⇒ (aCodomain value: f)]) asPresheaf! !

!Presheaf methodsFor: 'morphisms' stamp: 'len 6/2/2024 15:00:06'!
id
	"Answer the identity natural transformation."
	^ self propertyAt: #id ifAbsentPut: [self to: self transform: [:u| (self value₀: u) id]]! !

!Presheaf methodsFor: 'morphisms' stamp: 'len 6/7/2024 09:04:22'!
to: aPresheaf constant: aMorphism
	"Answer a natural transformation from the receiver to aPresheaf with all components equal to aMorphism."
	self assert: self class = aPresheaf class.
	self assert: (self codomain includes: aMorphism).
	^ self to: aPresheaf transform: [:u| aMorphism]! !

!Presheaf methodsFor: 'morphisms' stamp: 'len 6/7/2024 09:04:15'!
to: aPresheaf transform: aBlock
	"Answer a natural transformation from the receiver to aPresheaf, defined by components by aBlock."
	| components |
	self assert: self class = aPresheaf class.
	self assert: (self domain = aPresheaf domain and: [self codomain = aPresheaf codomain]).
	(self domain isKindOf: FreeCategory) ifFalse: [^ Transformation from: self to: aPresheaf transform: aBlock].
	components := Dictionary new.
	self domain objects do: [:each| components at: each put: (aBlock value: each)].
	^ Transformation from: self to: aPresheaf components: components! !

!Presheaf methodsFor: 'morphisms' stamp: 'len 6/2/2024 15:00:32'!
→ aCodomain
	aCodomain isMorphism ifTrue: [^ super → aCodomain].
	^ self ⇢ aCodomain ifNil: [self to: aCodomain transform: [:u| (self value₀: u) → (aCodomain value₀: u)]]! !

!Presheaf methodsFor: 'morphisms' stamp: 'len 6/2/2024 15:00:50'!
⇇ anArray
	^ anArray withIndexCollect: [:domain :i| domain to: self transform: [:u| (self value₀: u) ⇇ (anArray collect: [:each| each value₀: u]) at: i]]! !

!Presheaf methodsFor: 'morphisms' stamp: 'len 6/2/2024 15:01:05'!
⇉ anArray
	^ anArray withIndexCollect: [:codomain :i| self to: codomain transform: [:u| (self value₀: u) ⇉ (anArray collect: [:each| each value₀: u]) at: i]]! !

!Presheaf methodsFor: 'operations' stamp: 'len 6/7/2024 09:05:27'!
+ aPresheaf
	self assert: self class = aPresheaf class.
	self assert: (self domain = aPresheaf domain and: [self codomain = aPresheaf codomain]).
	^ (self domain to: self codomain map: [:f| (self value: f) + (aPresheaf value: f)]) asPresheaf! !

!Presheaf methodsFor: 'operations' stamp: 'len 6/7/2024 09:05:19'!
× aPresheaf
	self assert: self class = aPresheaf class.
	self assert: (self domain = aPresheaf domain and: [self codomain = aPresheaf codomain]).
	^ (self domain to: self codomain map: [:f| (self value: f) × (aPresheaf value: f)]) asPresheaf! !

!Presheaf methodsFor: 'operations' stamp: 'len 7/26/2024 07:58:37'!
dual
	^ (self domain to: self codomain map₀: [:x| (self value₀: x) dual] map: [:f| (self value: f) dual]) asPresheaf! !

!Presheaf methodsFor: 'operations' stamp: 'len 5/30/2024 08:37:40'!
negated
	^ (self domain to: self codomain map: [:f| f negated]) asPresheaf! !

!Presheaf methodsFor: 'operations' stamp: 'len 6/13/2024 08:39:57'!
reverse
	^ self asFunctor opposite asPresheaf! !

!Presheaf methodsFor: 'operations' stamp: 'len 5/30/2024 06:39:45'!
value: aMorphism
	^ functor value: aMorphism! !

!Presheaf methodsFor: 'operations' stamp: 'len 5/30/2024 06:40:07'!
value₀: anObject
	^ functor value₀: anObject! !

!Presheaf methodsFor: 'operations' stamp: 'len 5/30/2024 08:38:02'!
zero
	^ (self domain to: self codomain map: [:f| f zero]) asPresheaf! !

!Presheaf methodsFor: 'operations' stamp: 'len 6/7/2024 09:05:16'!
⊓ aPresheaf
	self assert: self class = aPresheaf class.
	self assert: (self domain = aPresheaf domain and: [self codomain = aPresheaf codomain]).
	^ (self domain to: self codomain map: [:f| (self value: f) ⊓ (aPresheaf value: f)]) asPresheaf! !

!Presheaf methodsFor: 'operations' stamp: 'len 6/7/2024 09:05:13'!
⊔ aPresheaf
	self assert: self class = aPresheaf class.
	self assert: (self domain = aPresheaf domain and: [self codomain = aPresheaf codomain]).
	^ (self domain to: self codomain map: [:f| (self value: f) ⊔ (aPresheaf value: f)]) asPresheaf! !

!Presheaf methodsFor: 'operations' stamp: 'len 6/7/2024 09:05:09'!
⊕ aPresheaf
	self assert: self class = aPresheaf class.
	self assert: (self domain = aPresheaf domain and: [self codomain = aPresheaf codomain]).
	^ (self domain to: self codomain map: [:f| (self value: f) ⊕ (aPresheaf value: f)]) asPresheaf! !

!Presheaf methodsFor: 'operations' stamp: 'len 6/7/2024 13:28:57'!
⊗ aPresheaf
	self assert: self class = aPresheaf class.
	"The endofunctors category is monoidal with composition as tensor product and the identity functor as tensor unit:"
	(self domain = self codomain and: [aPresheaf domain = self domain and: [aPresheaf codomain = self codomain]])
		ifTrue: [^ (self asFunctor · aPresheaf asFunctor) asPresheaf].
	"A right R-module can be tensores over R with a right Rᵒᵖ-module to obtain an abelian group;
	analogously a functor C → V can be tensored with a functor Cᵒᵖ → V to obtain an object of V (a monoidal category)."
	self assert: (self domain = aPresheaf domain opposite and: [self codomain = aPresheaf codomain and: [self codomain isMonoidal]]).
	"should be the coend... and it should be an object of the codomain...
	and for representable functors we have Hom(-,c) ⊗ F = F(c) ??"
	^ self notYetImplemented! !

!Presheaf methodsFor: 'printing' stamp: 'len 6/2/2024 17:21:59'!
printOn: aStream
	super printOn: aStream.
	aStream nextPutAll: ' : '; print: functor domain "opposite"; space; nextPut: functor arrowCharacter; space; print: functor codomain! !

!Presheaf methodsFor: 'private' stamp: 'len 5/30/2024 06:30:02'!
functor: aFunctor
	functor := aFunctor! !

!Presheaf class methodsFor: 'instance creation' stamp: 'len 5/30/2024 06:29:23'!
functor: aFunctor
	^ self new functor: aFunctor! !

!ProductObject methodsFor: 'accessing' stamp: 'len 8/15/2024 21:27:02'!
category
	^ ProductCategory components: (components collect: [:each| each category])! !

!ProductObject methodsFor: 'comparing' stamp: 'len 4/4/2024 08:21:14'!
= anObject
	^ self class = anObject class and: [components = anObject components]! !

!ProductObject methodsFor: 'comparing' stamp: 'len 4/4/2024 08:21:25'!
hash
	^ components hash! !

!ProductObject methodsFor: 'converting' stamp: 'len 6/26/2024 09:23:12'!
asArray
	^ components! !

!ProductObject methodsFor: 'morphisms' stamp: 'len 8/15/2024 21:32:34'!
associatorWith: anObject and: anotherObject
	^ ProductMorphism components: (components with: anObject components with: anotherObject components collect: [:x :y :z| x associatorWith: y and: z])! !

!ProductObject methodsFor: 'morphisms' stamp: 'len 8/15/2024 21:33:10'!
braidingWith: anObject
	^ ProductMorphism components: (components with: anObject components collect: [:x :y| x braidingWith: y])! !

!ProductObject methodsFor: 'morphisms' stamp: 'len 8/15/2024 21:33:21'!
coevaluation
	^ ProductMorphism components: (components collect: [:x| x coevaluation])! !

!ProductObject methodsFor: 'morphisms' stamp: 'len 8/15/2024 21:33:29'!
coevaluationWith: anObject
	^ ProductMorphism components: (components with: anObject components collect: [:x :y| x coevaluationWith: y])! !

!ProductObject methodsFor: 'morphisms' stamp: 'len 8/15/2024 21:33:36'!
evaluation
	^ ProductMorphism components: (components collect: [:x| x evaluation])! !

!ProductObject methodsFor: 'morphisms' stamp: 'len 8/15/2024 21:33:43'!
evaluationWith: anObject
	^ ProductMorphism components: (components with: anObject components collect: [:x :y| x evaluationWith: y])! !

!ProductObject methodsFor: 'morphisms' stamp: 'len 8/15/2024 21:17:36'!
id
	^ ProductMorphism components: (components collect: [:x| x id])! !

!ProductObject methodsFor: 'morphisms' stamp: 'len 8/15/2024 21:33:51'!
leftUnitor
	^ ProductMorphism components: (components collect: [:x| x leftUnitor])! !

!ProductObject methodsFor: 'morphisms' stamp: 'len 8/15/2024 21:33:57'!
rightUnitor
	^ ProductMorphism components: (components collect: [:x| x rightUnitor])! !

!ProductObject methodsFor: 'morphisms' stamp: 'len 8/15/2024 21:18:16'!
→ aCodomain
	aCodomain isMorphism ifTrue: [^ super → aCodomain].
	^ self ⇢ aCodomain ifNil: [ProductMorphism components: (components with: aCodomain components collect: [:x :y| x → y])]! !

!ProductObject methodsFor: 'morphisms' stamp: 'len 8/15/2024 21:44:42'!
⇇ anArray
	^ self notYetImplemented! !

!ProductObject methodsFor: 'morphisms' stamp: 'len 8/15/2024 21:44:51'!
⇉ anArray
	^ self notYetImplemented! !

!ProductObject methodsFor: 'morphisms' stamp: 'len 8/15/2024 21:10:53'!
⇒ aCodomain
	^ self class components: (components with: aCodomain components collect: [:x :y| x ⇒ y])! !

!ProductObject methodsFor: 'morphisms' stamp: 'len 8/15/2024 21:19:50'!
⇢ aCodomain
	^ ProductMorphism components: (components with: aCodomain components collect: [:x :y| x ⇢ y ifNil: [^ nil]])! !

!ProductObject methodsFor: 'operations' stamp: 'len 8/15/2024 21:11:36'!
× anObject
	^ self class components: (components with: anObject components collect: [:x :y| x × y])! !

!ProductObject methodsFor: 'operations' stamp: 'len 8/15/2024 21:11:31'!
dual
	^ self class components: (components collect: [:X| X dual])! !

!ProductObject methodsFor: 'operations' stamp: 'len 8/15/2024 21:11:26'!
reverse
	^ self class components: (components collect: [:x| x reverse])! !

!ProductObject methodsFor: 'operations' stamp: 'len 8/15/2024 21:10:59'!
⊔ anObject
	^ self class components: (components with: anObject components collect: [:x :y| x ⊔ y])! !

!ProductObject methodsFor: 'operations' stamp: 'len 8/15/2024 21:11:05'!
⊕ anObject
	^ self class components: (components with: anObject components collect: [:x :y| x ⊕ y])! !

!ProductObject methodsFor: 'operations' stamp: 'len 8/15/2024 21:11:11'!
⊗ anObject
	^ self class components: (components with: anObject components collect: [:x :y| x ⊗ y])! !

!ProductObject methodsFor: 'printing' stamp: 'len 4/4/2024 08:20:53'!
printOn: aStream
	aStream print: components! !

!ProductObject methodsFor: 'private' stamp: 'len 4/4/2024 08:21:18'!
components
	^ components! !

!ProductObject methodsFor: 'private' stamp: 'len 8/15/2024 21:12:18'!
components: anArray
	components := anArray! !

!ProductObject class methodsFor: 'instance creation' stamp: 'len 8/15/2024 21:36:25'!
components: anArray
	^ self new components: anArray! !

!Structure methodsFor: 'accessing' stamp: 'len 4/1/2024 14:31:47'!
ambient
	"Domains can be subobjects of other domains, for example subspeces are subobjects of vector spaces.
	Answer the ambient domain of which the receiver is a subobject, equipped with the inclusion morphism."
	^ self propertyAt: #ambient ifAbsent: [self]! !

!Structure methodsFor: 'accessing' stamp: 'len 5/10/2024 13:24:29'!
elements
	"Answer the elements of the receiver as either a Collection or another type of Structure."
	^ self propertyAt: #elements ifAbsent: [Iterator on: self performing: #do:]! !

!Structure methodsFor: 'accessing' stamp: 'len 5/1/2024 12:24:26'!
generator
	self generators size = 1 ifFalse: [self error: 'more than one generator'].
	^ self generators any! !

!Structure methodsFor: 'accessing' stamp: 'len 10/17/2016 18:53'!
generator: anElement
	self generators: {anElement}! !

!Structure methodsFor: 'accessing' stamp: 'len 12/22/2021 14:10:56'!
generatorNamed: anObject
	"Answer the generator indexed or named by anObject."
	^ self generators at: (self names indexOf: anObject)! !

!Structure methodsFor: 'accessing' stamp: 'len 12/28/2016 11:22:22'!
generators
	"Subclases can use this or reimplement it when it makes sense."
	^ self propertyAt: #generators ifAbsent: []! !

!Structure methodsFor: 'accessing' stamp: 'len 12/28/2016 11:19:29'!
generators: aCollection
	"Subclases can use this or reimplement it when it makes sense."
	self propertyAt: #generators put: aCollection asArray! !

!Structure methodsFor: 'accessing' stamp: 'len 8/7/2022 10:37:18'!
names
	"Answer a list of symbolic names for the generators."
	^ self propertyAt: #names ifAbsentPut: [self generators size = 1 ifTrue: [#(x)] ifFalse: [(1 to: self generators size) collect: [:i| 'x', i printString sub]]]! !

!Structure methodsFor: 'accessing' stamp: 'len 6/5/2019 19:55:56'!
size
	^ self propertyAt: #size ifAbsentPut: [self elements size]! !

!Structure methodsFor: 'accessing' stamp: 'len 8/19/2024 09:41:08'!
underlyingSet
	"Answer the carrier set of the receiver. This is the forgetful functor to the category of sets."
	^ self propertyAt: #underlyingSet ifAbsentPut: [SetObject elements: self elementsOrSelf]! !

!Structure methodsFor: 'comparing' stamp: 'len 5/2/2024 07:24:47'!
= anObject
	self == anObject ifTrue: [^ true].
	self propertyAt: #elements ifPresent: [:aCollectionOrDomain| ^ anObject = aCollectionOrDomain].
	(anObject isKindOf: Structure) ifFalse: [^ false].
	anObject propertyAt: #elements ifPresent: [:aCollectionOrDomain| ^ self = aCollectionOrDomain].
	self size = anObject size ifFalse: [^ false].
	self isFinite ifTrue: [self do: [:each| (anObject includes: each) ifFalse: [^ false]]. ^ true].
	^ super = anObject! !

!Structure methodsFor: 'comparing' stamp: 'len 6/15/2022 09:50:57'!
hash
	^ 0! !

!Structure methodsFor: 'comparing' stamp: 'len 5/1/2024 09:52:58'!
⊆ aDomain
	"Answer true if the receiver is a subset of the argument."
	self == aDomain ifTrue: [^ true].
	self ambient = aDomain ifTrue: [^ true].
	self ambient = aDomain ambient ifFalse: [^ false].
	self isFinitelyGenerated ifTrue: [^ self generators allSatisfy: [:each| aDomain contains: each]].
"	aDomain isFinite ifTrue: [^ self size <= aDomain size and: [self allSatisfy: [:each| aDomain includes: each]]].
	self isFinite ifTrue: [^ self allSatisfy: [:each| aDomain includes: each]]."
	^ self subclassResponsibility! !

!Structure methodsFor: 'comparing' stamp: 'len 12/11/2023 20:43:09'!
⊇ aDomain
	"Answer true if the argument is a subset of the receiver."
	^ aDomain ⊆ self! !

!Structure methodsFor: 'comparing' stamp: 'len 12/11/2023 20:43:14'!
⊊ aDomain
	"Answer true if the receiver is a proper subset of the argument (strict inclusion)."
	^ self ~= aDomain and: [self ⊆ aDomain]! !

!Structure methodsFor: 'comparing' stamp: 'len 12/3/2023 20:59:50'!
⊋ aDomain
	"Answer true if the argument is a proper subset of the receiver (strict inclusion)."
	^ aDomain ⊊ self! !

!Structure methodsFor: 'converting' stamp: 'len 4/19/2020 07:08:55'!
asArray
	^ self elements asArray! !

!Structure methodsFor: 'converting' stamp: 'len 8/19/2024 09:41:08'!
asCartesianProduct
	"If the receiver is a product, answer the cartesian product of the carrier sets of its components.
	Note that this is in general different from the carrier set of the receiver, because the elements of the cartesian product are instances of Array."
	self assert: self isProduct.
	^ CartesianProduct components: (self components collect: [:each| each underlyingSet])! !

!Structure methodsFor: 'converting' stamp: 'len 4/19/2020 07:09:10'!
asSet
	^ self elements asSet! !

!Structure methodsFor: 'elements' stamp: 'len 8/19/2024 09:41:08'!
!! anObject
	"Coerce anObject to an element of the receiver."
	(self includes: anObject) ifTrue: [^ anObject].
	anObject isElement ifTrue: [(self adapt: anObject) ifNotNil: [:anElement| ^ anElement]].
	anObject isArray ifTrue: [self underlyingSet propertyAt: #inputs ifPresent: [:aDictionary| aDictionary keysAndValuesDo: [:domain :map| (domain includes: anObject) ifTrue: [^ map value: anObject]]]].
	(self newFrom: anObject) ifNotNil: [:anElement| ^ anElement].
	(anObject isBlock and: [self generators notNil and: [anObject numArgs = self generators size]]) ifTrue: [^ self generate: anObject].
	^ self error: 'coercion failed'! !

!Structure methodsFor: 'elements' stamp: 'len 8/19/2024 09:41:08'!
adapt: anElement
	"Coerce anElement *not* in the receiver to an element of the receiver. Subclasses should extend."
	self isAmbient ifFalse: [(self ambient adapt: anElement) ifNotNil: [:coerced| (self contains: coerced) ifTrue: [^ coerced]]].
	anElement parent isNil ifTrue: [^ nil].
	self id category = anElement parent id category ifTrue: [anElement parent ⇢ self ifNotNil: [:aMorphism| ^ aMorphism value: anElement]].
	anElement parent underlyingSet ⇢ self underlyingSet ifNotNil: [:aMorphism| ^ aMorphism value: anElement].
	^ nil! !

!Structure methodsFor: 'elements' stamp: 'len 8/19/2024 09:41:08'!
addCoercionFrom: aDomain map: aBlock
	^ self underlyingSet addMap: (aDomain underlyingSet to: self underlyingSet map: aBlock)! !

!Structure methodsFor: 'elements' stamp: 'len 8/19/2024 09:41:08'!
addCoercionFrom: aCartesianProduct mapWithArguments: aBlock
	^ self underlyingSet addMap: (aCartesianProduct to: self underlyingSet mapWithArguments: aBlock)! !

!Structure methodsFor: 'elements' stamp: 'len 8/19/2024 09:41:08'!
addCoercionTo: aDomain map: aBlock
	^ self underlyingSet addMap: (self underlyingSet to: aDomain underlyingSet map: aBlock)! !

!Structure methodsFor: 'elements' stamp: 'len 12/26/2016 11:31:05'!
generate: aBlock
	"Answer the result of evaluating aBlock on the generators of the receiver."
	^ aBlock valueWithArguments: self generators asArray! !

!Structure methodsFor: 'elements' stamp: 'len 5/6/2023 18:27:06'!
new: anInteger
	"Answer a new array suitable for storing elements of the receiver.
	Subclasses can answer special kinds of arrays that are more efficient and compact."
	^ Array new: anInteger! !

!Structure methodsFor: 'elements' stamp: 'len 11/23/2022 17:15:51'!
new: anInteger fill: aBlock
	| answer |
	answer _ self new: anInteger.
	1 to: anInteger do: [:i| answer at: i put: self !! (aBlock value: i)].
	^ answer! !

!Structure methodsFor: 'elements' stamp: 'len 4/2/2024 06:39:34'!
newFrom: anObject
	(self isProduct and: [anObject isSequenceable and: [anObject size = self components size]])
		ifTrue: [^ self compose: (self components with: anObject collect: [:eachDomain :eachElement| eachDomain !! eachElement])].
	^ nil! !

!Structure methodsFor: 'elements' stamp: 'len 5/13/2019 14:18:36'!
x: anInteger
	"Answer the anInteger-th generator of the receiver."
	^ self generators at: anInteger! !

!Structure methodsFor: 'enumerating' stamp: 'len 5/2/2024 07:29:58'!
collect: aBlock
	| elements |
	elements := self elementsOrSelf.
	^ Iterator on: [:iteratorBlock| elements do: [:each| iteratorBlock value: (aBlock value: each)]]! !

!Structure methodsFor: 'enumerating' stamp: 'len 12/28/2016 11:21:06'!
do: aBlock
	(self propertyAt: #elements ifAbsent: [self subclassResponsibility]) do: aBlock! !

!Structure methodsFor: 'enumerating' stamp: 'len 5/2/2024 07:26:18'!
select: aBlock
	| elements |
	elements := self elementsOrSelf.
	^ Iterator on: [:iteratorBlock| elements do: [:each| (aBlock value: each) ifTrue: [iteratorBlock value: each]]]! !

!Structure methodsFor: 'enumerating' stamp: 'len 8/1/2016 03:53'!
upTo: maximumNumberOfElements
	| answer |
	answer _ OrderedCollection new.
	self do: [:each|
		answer size >= maximumNumberOfElements ifTrue: [^ answer].
		answer add: each].
	^ answer! !

!Structure methodsFor: 'enumerating' stamp: 'len 7/25/2016 23:46'!
upTo: max do: aBlock
	"Iterate over the elements of the receiver, just like #do:, but stop after max elements."
	| k |
	k _ 1.
	self do: [:each|
		k > max ifTrue: [^ self].
		aBlock value: each.
		k _ k+1]! !

!Structure methodsFor: 'morphisms' stamp: 'len 5/2/2024 14:56:25'!
apply: aMorphism
	self isFinitelyGenerated ifFalse: [^ self collect: aMorphism].
	^ (aMorphism isBlock ifTrue: [self] ifFalse: [aMorphism codomain]) sub: (self generators collect: aMorphism)! !

!Structure methodsFor: 'morphisms' stamp: 'len 4/5/2024 09:10:58'!
id
	^ self propertyAt: #id ifAbsentPut:
		[| answer |
		answer := self isFinitelyGenerated ifTrue: [self to: self images: self generators] ifFalse: [self to: self map: [:x| x]].
		answer properties
			at: #retraction put: answer;
			at: #section put: answer;
			at: #image put: self.
		answer]! !

!Structure methodsFor: 'morphisms' stamp: 'len 4/19/2024 07:08:52'!
into: aCodomain images: anArray
	"Answer an embedding (an injective morphism) into the specified codomain mapping each generator to the corresponding element in anArray."
	^ (self to: aCodomain images: anArray) propertyAt: #arrowCharacter put: $↪; yourself! !

!Structure methodsFor: 'morphisms' stamp: 'len 11/22/2023 20:46:51'!
into: aCodomain map: aBlock
	"Answer an embedding (an injective morphism) onto the specified codomain evaluating as the given block."
	^ (self to: aCodomain map: aBlock) propertyAt: #arrowCharacter put: $↪; yourself! !

!Structure methodsFor: 'morphisms' stamp: 'len 4/19/2024 07:08:43'!
onto: aCodomain images: anArray
	"Answer a projection (a surjective morphism) onto the specified codomain mapping each generator to the corresponding element in anArray."
	^ (self to: aCodomain images: anArray) propertyAt: #arrowCharacter put: $↠; yourself! !

!Structure methodsFor: 'morphisms' stamp: 'len 11/22/2023 20:44:03'!
onto: aCodomain map: aBlock
	"Answer a projection (a surjective morphism) onto the specified codomain evaluating as the given block."
	^ (self to: aCodomain map: aBlock) propertyAt: #arrowCharacter put: $↠; yourself! !

!Structure methodsFor: 'morphisms' stamp: 'len 6/1/2024 06:59:41'!
to: aCodomain
	"Answer the canonical morphism from the receiver to aCodomain."
	self ⊆ aCodomain ifTrue: [^ self into: aCodomain map: [:x| x]].
"	self ambient = aCodomain ifTrue: [^ (self into: aCodomain map: [:x| x]) name: 'ι']."
	self isAmbient ifFalse: [self ambient ⇢ aCodomain ifNotNil: [:aMorphism| ^ self → aMorphism]].
	^ super to: aCodomain! !

!Structure methodsFor: 'morphisms' stamp: 'len 4/19/2024 07:09:48'!
to: aCodomain images: anArrayOrBlock
	"Answer a morphism defined by images of generators, taking the i-th generator of the receiver to the i-th element of anArray (or the value of aBlock at i)."
	^ self subclassResponsibility! !

!Structure methodsFor: 'morphisms' stamp: 'len 6/20/2024 07:35:44'!
to: aCodomain map: aBlock
	"Answer a morphism to the specified codomain, evaluating as the given block.
	If the receiver is finitely generated, the morphism is induced from the values of aBlock at the generators."
	^ self to: aCodomain images: (self generators collect: aBlock)! !

!Structure methodsFor: 'morphisms' stamp: 'len 6/20/2024 07:23:05'!
to: aCodomain mapWithArguments: aBlock
	"When the receiver is n-ary, this method allows to define morphisms by n-ary blocks."
	^ self to: aCodomain map: [:each| aBlock valueWithArguments: each asArray]! !

!Structure methodsFor: 'morphisms' stamp: 'len 4/2/2024 06:39:48'!
toAll: anArray
	"Answer the canonical projections from the receiver to the components of anArray."
	(self isProduct and: [anArray = self components])
		ifTrue: [^ self addProjections: ((1 to: self components size) collect: [:i| self projection: i])].
	self isAmbient ifFalse: [(self ambient toAll: anArray) ifNotNil: [:anArrayOfMorphisms| ^ anArrayOfMorphisms collect: [:each| each · (self → self ambient)]]].
	^ nil! !

!Structure methodsFor: 'operations' stamp: 'len 4/3/2024 08:53:35'!
, aDomain
	^ CartesianProduct components: {self. aDomain}! !

!Structure methodsFor: 'operations' stamp: 'len 4/1/2024 14:54:10'!
∩ aDomain
	"Answer the intersection of the receiver and the argument."
	^ self select: [:each| aDomain includes: each]! !

!Structure methodsFor: 'printing' stamp: 'len 5/2/2024 07:18:27'!
printOn: aStream
	self propertyAt: #elements ifPresent: [:aCollection|
		(aCollection isKindOf: Structure) ifTrue: [aStream print: aCollection. ^ self].
		aStream withBraces: [:aStream2| "Wildberger notation for unordered sets: elements separated by spaces"
			aCollection do: [:each| aStream2 print: each] separatedBy: [aStream2 nextPutAll: ' ']].
		^ self].
	^ super printOn: aStream! !

!Structure methodsFor: 'random' stamp: 'len 5/26/2024 09:04:52'!
atRandom
	^ self atRandom: self newRandom! !

!Structure methodsFor: 'random' stamp: 'len 5/26/2024 09:04:56'!
atRandom: aRandom
	self propertyAt: #elements ifPresent: [:aCollectionOrDomain| ^ aCollectionOrDomain atRandom: aRandom].
	^ self atRandom: aRandom bits: [aRandom nextBoolean] count + 1! !

!Structure methodsFor: 'random' stamp: 'len 6/2/2024 04:58:55'!
atRandom: aRandom bits: bitSize
	"Answer an element of the receiver of at most bitSize bits."
	self propertyAt: #elements ifPresent: [:aCollectionOrDomain| ^ aCollectionOrDomain atRandom: aRandom bits: bitSize].
	^ self asSet atRandom: aRandom! !

!Structure methodsFor: 'random' stamp: 'len 6/2/2024 04:59:37'!
atRandomBits: bitSize
	"Answer an element of the receiver of at most bitSize bits."
	^ self atRandom: self newRandom bits: bitSize! !

!Structure methodsFor: 'random' stamp: 'len 5/16/2023 20:29:55'!
new: anInteger atRandom: aRandom
	^ self new: anInteger fill: [:i| self atRandom: aRandom]! !

!Structure methodsFor: 'random' stamp: 'len 5/16/2023 20:36:19'!
new: anInteger atRandom: aRandom bits: bitSize
	| k |
	anInteger = 0 ifTrue: [^ self new: 0].
	k _ bitSize / anInteger.
	^ self new: anInteger fill: [:i| self atRandom: aRandom bits: k]! !

!Structure methodsFor: 'random' stamp: 'len 4/6/2024 16:21:56'!
to: aCodomain atRandom: aRandom
	"Answer a morphism from the receiver to aCodomain choosen at random."
	self flag: #fix. "this doesnt always make sense:"
	^ self to: aCodomain map: [:each| aCodomain atRandom: (Random seed: each hash)]

"this doesnt always make sense, it works for free structures:
	^ self to: aCodomain images: (self generators collect: [:each| aCodomain atRandom: aRandom])
"! !

!Structure methodsFor: 'random' stamp: 'len 6/2/2024 04:59:31'!
to: aCodomain atRandom: aRandom bits: bitSize
	"Answer a morphism from the receiver to aCodomain choosen at random of at most bitSize bits."
	| n |
	self flag: #fix. "this doesnt always make sense, it works for free objects"
	n := bitSize / (aCodomain generators size max: 1).
	^ self to: aCodomain images: (self generators collect: [:each| aCodomain atRandom: aRandom bits: n])! !

!Structure methodsFor: 'testing' stamp: 'len 4/6/2024 15:45:40'!
contains: anElement
	"Answer true if the receiver contains the given element of its ambient.
	This is similar to #includes: but less checks are needed, because the element is not an arbitrary object."
	self isAmbient ifTrue: [^ true].
	^ self elements includes: anElement! !

!Structure methodsFor: 'testing' stamp: 'len 6/23/2016 07:04'!
includes: anElement
	^ self elements includes: anElement! !

!Structure methodsFor: 'testing' stamp: 'len 4/29/2020 21:16:49'!
isAmbient
	^ self ambient == self! !

!Structure methodsFor: 'testing' stamp: 'len 11/2/2016 08:54'!
isEmpty
	^ self size = 0! !

!Structure methodsFor: 'testing' stamp: 'len 12/28/2016 11:23:17'!
isFinite
	^ self propertyAt: #isFinite ifAbsent: [self size isInfinite not]! !

!Structure methodsFor: 'testing' stamp: 'len 4/6/2024 15:45:45'!
isFinitelyGenerated
	"Answer true if the receiver is finitely generated. See #generators."
	^ false! !

!Structure methodsFor: 'testing' stamp: 'len 6/17/2016 22:20'!
isInfinite
	^ self isFinite not! !

!Structure methodsFor: 'testing' stamp: 'len 12/10/2023 10:46:36'!
isOrdered
	"Answer true if the elements of the receiver are ordered. They must implement the Magnitude protocol (<, >, <=, >=)."
	^ false! !

!Structure methodsFor: 'private' stamp: 'len 4/1/2024 14:30:40'!
ambient: aDomain
	self propertyAt: #ambient put: aDomain! !

!Structure methodsFor: 'private' stamp: 'len 4/1/2024 14:27:58'!
checkIsSibling: aDomain
	self ambient = aDomain ambient ifFalse: [^ self error: 'not a subobject of the receiver''s ambient']! !

!Structure methodsFor: 'private' stamp: 'len 5/2/2024 07:23:30'!
elementsOrSelf
	"If the receiver was constructed from elements of a set or of another structure, answer the original elements.
	Otherwise answer self."
	^ self propertyAt: #elements ifAbsent: [self]! !

!Structure methodsFor: 'private' stamp: 'len 3/11/2021 16:38:21'!
newRandom
	^ Random seed: (Random withDefaultDo: [:aRandom| aRandom nextChunkBits])! !

!Category methodsFor: 'accessing' stamp: 'len 7/15/2024 10:37:23'!
associatorTransformation
	"If the receiver is a monoidal category, answer the associator.
	This is a natural isomorphism (-⊗-)⊗- → -⊗(-⊗-)."
	self flag: #deprecated.
	^ (self × self × self to: self mapWithArguments: [:x :y :z| x ⊗ y ⊗ z])
		to: (self × self × self to: self mapWithArguments: [:x :y :z| x ⊗ (y ⊗ z)])
			transformWithArguments: [:x :y :z| x associatorWith: y and: z]! !

!Category methodsFor: 'accessing' stamp: 'len 8/4/2024 09:45:55'!
enrichmentBase
	"If the receiver is a V-enriched category over a monoidal category V, answer V.
	Ordinary categories are enriched over the category of sets, and closed monoidal categories are enriched over themselves."
	self isClosedMonoidal ifTrue: [^ self].
	^ self propertyAt: #enrichmentBase ifAbsent: [Sets]! !

!Category methodsFor: 'accessing' stamp: 'len 6/13/2024 14:26:32'!
initialObject
	"An initial object in a categort C is an object ∅ of C (also sometimes denoted by I) satisfying the following universal property: for every object x of C there exists a unique morphism ∅ → x. The initial object of a category, if it exists, is unique up to unique isomorphism. If the initial object is also terminal, it is called a zero object or null object and denoted by 0.
	The initial object is the colimit of the empty diagram, and it is the empty coproduct."
	self isAdditive ifTrue: [^ self zeroObject].
	^ self propertyAt: #initialObject ifAbsent: [self subclassResponsibility]! !

!Category methodsFor: 'accessing' stamp: 'len 7/27/2024 10:41:03'!
leftUnitorTransformation
	"If the receiver is a monoidal category, answer the left unitor.
	This is a natural isomorphism 1⊗- → -, where 1 is the tensor unit."
	self flag: #deprecated.
	^ (self to: self map: [:f| self unitObject ⊗ f]) to: self id transform: [:u| u leftUnitor]! !

!Category methodsFor: 'accessing' stamp: 'len 4/19/2024 06:55:12'!
objects
	^ Iterator on: self performing: #do₀:! !

!Category methodsFor: 'accessing' stamp: 'len 7/27/2024 10:41:11'!
rightUnitorTransformation
	"If the receiver is a monoidal category, answer the right unitor.
	This is a natural isomorphism -⊗1 → -, where 1 is the tensor unit."
	self flag: #deprecated.
	^ (self to: self map: [:f| f ⊗ self unitObject]) to: self id transform: [:u| u rightUnitor]! !

!Category methodsFor: 'accessing' stamp: 'len 5/22/2024 10:26:30'!
size₀
	^ self objects size! !

!Category methodsFor: 'accessing' stamp: 'len 6/13/2024 14:22:09'!
terminalObject
	"A terminal object in a categort C is an object * of C (also sometimes denoted by 1, pt or T) satisfying the following universal property: for every object x of C there exists a unique morphism x → *. The terminal object of a category, if it exists, is unique up to unique isomorphism. If the terminal object is also initial, it is called a zero object or null object and denoted by 0.
	The terminal object is the limit of the empty diagram, and it is the empty product."
	self isAdditive ifTrue: [^ self zeroObject].
	^ self propertyAt: #terminalObject ifAbsent: [self subclassResponsibility]! !

!Category methodsFor: 'accessing' stamp: 'len 6/5/2024 17:30:45'!
unitObject
	"If the receiver is a monoidal category, answer the tensor unit."
	self isCartesianMonoidal ifTrue: [^ self terminalObject].
	self isCocartesianMonoidal ifTrue: [^ self initialObject].
	^ self propertyAt: #unitObject ifAbsent: [self subclassResponsibility]! !

!Category methodsFor: 'accessing' stamp: 'len 6/2/2024 11:28:11'!
zeroObject
	"Answer the null or zero object in the receiver, i.e. an object that is both intial and terminal."
	^ self propertyAt: #zeroObject ifAbsentPut: [self assert: self initialObject ~ self terminalObject. self initialObject]! !

!Category methodsFor: 'comparing' stamp: 'len 4/7/2024 15:19:35'!
= anObject
	^ self == anObject! !

!Category methodsFor: 'comparing' stamp: 'len 4/7/2024 15:19:44'!
hash
	^ self identityHash! !

!Category methodsFor: 'elements' stamp: 'len 6/1/2024 07:00:04'!
!! anObject
	anObject isDomain ifTrue: [self !! anObject id ifNotNil: [:aMorphism| ^ aMorphism domain]].
	anObject isMorphism ifTrue: [anObject category ⇢ self ifNotNil: [:aFunctor| ^ aFunctor value: anObject]].
	^ super !! anObject! !

!Category methodsFor: 'enumerating' stamp: 'len 4/19/2024 06:55:32'!
do₀: aBlock
	| visited |
	visited := Set new.
	self do: [:each| visited add: each domain ifAbsent: [aBlock value: each domain]]! !

!Category methodsFor: 'morphisms' stamp: 'len 6/3/2024 10:33:27'!
Yoneda
	"Answer the Yoneda embedding of the receiver.
	If the receiver is C, answer the embedding into the presheaf category [Cᵒᵖ,Sets]. The Yoneda lemma implies that this functor is fully faithful and hence realizes C as a full subcategory of [Cᵒᵖ,Sets]."
	^ (self into: self opposite ⇒ Sets map₀: [:x| (self opposite to: Sets map: [:f| f ^ x reverse]) asPresheaf] map: [:x :y :f| x to: y transform: [:u| (x value₀: u) to: (y value₀: u) map: [:g| g · f]]]) name: 'Y'! !

!Category methodsFor: 'morphisms' stamp: 'len 6/5/2024 17:40:02'!
endofunctors
	^ self endomorphisms! !

!Category methodsFor: 'morphisms' stamp: 'len 6/5/2024 17:39:58'!
endomorphisms
	"Answer the monoidal category of endofunctors, with composition as tensor product."
	^ self propertyAt: #endomorphisms ifAbsentPut: [self ⇒ self]! !

!Category methodsFor: 'morphisms' stamp: 'len 6/5/2024 08:03:52'!
hom: aCodomain
	self assert: aCodomain isCategory.
	^ FunctorCategory from: self to: aCodomain! !

!Category methodsFor: 'morphisms' stamp: 'len 5/7/2024 08:13:52'!
into: aCategory map₀: aBlock map: anotherBlock
	^ (self to: aCategory map₀: aBlock map: anotherBlock) propertyAt: #arrowCharacter put: $↪; yourself! !

!Category methodsFor: 'morphisms' stamp: 'len 5/7/2024 08:14:00'!
onto: aCategory map₀: aBlock map: anotherBlock
	^ (self to: aCategory map₀: aBlock map: anotherBlock) propertyAt: #arrowCharacter put: $↠; yourself! !

!Category methodsFor: 'morphisms' stamp: 'len 5/17/2024 08:39:16'!
to: aCategory constant: anObject
	"Answer the constant functor (or selection functor) Δ(x) : J → C, where J is the receiver, x is anObject and C is aCategory.
	Δ(x) sends objects to x, and morphisms to the identity of x."
	self assert: aCategory isCategory.
	self assert: (aCategory includes₀: anObject).
	^ self to: aCategory map: [:f| anObject id]! !

!Category methodsFor: 'morphisms' stamp: 'len 4/19/2024 07:05:14'!
to: aCategory images: anArray
	"Answer a functor defined by images of generators."
	self assert: aCategory isCategory.
	self assert: self isFinitelyGenerated.
	^ Functor from: self to: aCategory images: anArray! !

!Category methodsFor: 'morphisms' stamp: 'len 5/7/2024 08:13:23'!
to: aCategory map: aBlock
	self assert: aCategory isCategory.
	^ Functor from: self to: aCategory map: aBlock! !

!Category methodsFor: 'morphisms' stamp: 'len 5/7/2024 08:13:31'!
to: aCategory map₀: aBlock map: anotherBlock
	self assert: aCategory isCategory.
	^ Functor from: self to: aCategory map₀: aBlock map: anotherBlock! !

!Category methodsFor: 'morphisms' stamp: 'len 6/10/2024 08:38:38'!
yoneda
	"Answer the enriched Yoneda embedding of the receiver.
	If the receiver is C, and it is enriched over V, answer the embedding into the presheaf category [Cᵒᵖ,V]. The Yoneda lemma implies that this functor is fully faithful and hence realizes C as a full subcategory of [Cᵒᵖ,V]."
	^ (self into: self opposite ⇒ self enrichmentBase map₀: [:x| (self to: self enrichmentBase map: [:f| x ⇒ f]) asPresheaf] map: [:x :y :f| x to: y transform: [:u| (x value₀: u) to: (y value₀: u) map: [:g| g · f]]]) name: 'Y'! !

!Category methodsFor: 'morphisms' stamp: 'len 5/23/2024 16:56:10'!
Δ: aCategory
	"Answer the diagonal functor Δ : C → [J,C], where C is the receiver and J is the argument.
	The diagonal functor assigns to every object x of C the constant functor Δ(x) : J → C that sends any object to x and any morphism to the identity of x, and every morphism f : a → b of C to the natural transformation with all components equal to f."
	^ (self to: self ^ aCategory
		map₀: [:x| aCategory to: self constant: x]
		map: [:x :y :f| x to: y constant: f]) name: 'Δ'! !

!Category methodsFor: 'operations' stamp: 'len 4/8/2024 05:27:24'!
× aCategory
	self assert: aCategory isCategory.
	^ ProductCategory components: {self. aCategory}! !

!Category methodsFor: 'operations' stamp: 'len 4/7/2024 15:09:42'!
Adelman
	self assert: self isAdditive.
	^ self propertyAt: #Adelman ifAbsentPut: [AdelmanCategory on: self]! !

!Category methodsFor: 'operations' stamp: 'len 4/1/2024 14:50:23'!
Freyd
	self assert: self isAdditive.
	^ self propertyAt: #Freyd ifAbsentPut: [FreydCategory on: self]! !

!Category methodsFor: 'operations' stamp: 'len 4/13/2024 05:52:31'!
abelianClosure
	"Answer the free abelian category of the receiver. See [BP19].
	Every additive category admits a universal additive functor into an abelian category A → F, and this F is the 'free abelian category'. Universal means that for any other additive functor A → E, there exists a functor F → E unique up to natural isomorphism that makes the triangle commute. See also AdelmanCategory and [Pos17c]."
	self assert: self isAdditive.
	^ self opposite Freyd opposite Freyd "or, the equivalent category 'self Freyd opposite Freyd opposite'"! !

!Category methodsFor: 'operations' stamp: 'len 4/13/2024 05:48:22'!
additiveClosure
	self assert: self isPreadditive.
	^ AdditiveClosureCategory on: self! !

!Category methodsFor: 'operations' stamp: 'len 6/23/2024 09:09:14'!
arrows
	"Answer the arrow category of the receiver."
	^ self propertyAt: #arrows ifAbsentPut: [ArrowCategory on: self]

"this is a particular case of the comma category:
	^ self id ↓ self id
"! !

!Category methodsFor: 'operations' stamp: 'len 8/30/2024 20:24:49'!
bimonoids
	"Answer the category of bimonoid objects in the receiver."
	^ self propertyAt: #bimonoids ifAbsentPut: [self assert: self isBraidedMonoidal. BimonoidCategory on: self]

"this is equivalent, but a different construction:
	^ self comonoids monoids"! !

!Category methodsFor: 'operations' stamp: 'len 8/30/2024 11:50:03'!
center
	"The center Z(C) of a category C is the commutative monoid of endomorphisms of the unit object in End(C), i.e. endo-natural transformations of the identity in C. If C is an additive category, Z(C) is not just a commutative monoid but also a commutative ring."
	^ self endomorphisms unitObject endomorphisms! !

!Category methodsFor: 'operations' stamp: 'len 8/30/2024 21:57:24'!
cocommutativeBimonoids
	"Answer the category of cocommutative bimonoid objects in the receiver."
	^ self cocommutativeComonoids monoids! !

!Category methodsFor: 'operations' stamp: 'len 6/9/2024 09:24:41'!
cocommutativeComonoids
	"Answer the category of cocommutative comonoid objects on the receiver."
	^ self comonoids comonoids! !

!Category methodsFor: 'operations' stamp: 'len 6/9/2024 14:27:31'!
cogroups
	"Answer the category of cogroup objects in the receiver."
	^ self opposite groups opposite! !

!Category methodsFor: 'operations' stamp: 'len 8/30/2024 21:56:44'!
commutativeBimonoids
	"Answer the category of commutative bimonoid objects in the receiver."
	^ self commutativeMonoids comonoids! !

!Category methodsFor: 'operations' stamp: 'len 6/9/2024 08:50:36'!
commutativeMonoids
	"Answer the category of commutative monoid objects on the receiver."
	^ self monoids monoids! !

!Category methodsFor: 'operations' stamp: 'len 9/1/2024 16:52:38'!
comonoids
	"Answer the category of comonoid objects in the receiver."
	^ self opposite monoids opposite! !

!Category methodsFor: 'operations' stamp: 'len 4/7/2024 15:12:29'!
complexes
	self assert: self isAbelian.
	^ self propertyAt: #ChainComplexes ifAbsentPut: [ChainComplexesCategory over: self]! !

!Category methodsFor: 'operations' stamp: 'len 6/9/2024 08:09:56'!
coproduct: anArray
	"Answer the coproduct of all the objects in anArray, equipped with all the coprojections."
	| answer coprojections |
	answer := self initialObject.
	coprojections := #().
	anArray do: [:each|
		| C |
		C := answer ⊔ each.
		C ⇇ {answer. each} into: [:ι₁ :ι₂| coprojections := (coprojections collect: [:ι| ι₁ · ι]), {ι₂}].
		answer := C].
	answer addCoprojections: coprojections.
	^ answer! !

!Category methodsFor: 'operations' stamp: 'len 9/4/2024 10:10:45'!
graded
	^ self propertyAt: #gradedObjects ifAbsentPut: [GradedObjectsCategory on: self]! !

!Category methodsFor: 'operations' stamp: 'len 6/9/2024 08:55:32'!
groups
	"Answer the category of group objects in the receiver."
	^ self propertyAt: #groups ifAbsentPut: ["self assert: self isCartesian." GroupCategory on: self]! !

!Category methodsFor: 'operations' stamp: 'len 6/5/2024 06:14:07'!
monads
	"Answer the category of monads on the receiver."
	^ self endofunctors monoids! !

!Category methodsFor: 'operations' stamp: 'len 9/1/2024 16:49:20'!
monoids
	"Answer the category of monoid objects in the receiver."
	^ self propertyAt: #monoids ifAbsentPut: [self assert: self isMonoidal. MonoidCategory on: self]! !

!Category methodsFor: 'operations' stamp: 'len 4/3/2024 08:46:39'!
opposite
	^ self propertyAt: #opposite ifAbsentPut: [OppositeCategory opposite: self]! !

!Category methodsFor: 'operations' stamp: 'len 6/2/2024 11:08:55'!
pointed
	"Answer the category of pointed objects of the receiver."
	^ self terminalObject ↓ self! !

!Category methodsFor: 'operations' stamp: 'len 6/2/2024 11:08:43'!
pointedMonoidal
	"Answer the monoidal category of pointed objects of the receiver."
	self assert: self isMonoidal.
	^ self unitObject ↓ self! !

!Category methodsFor: 'operations' stamp: 'len 6/5/2024 17:41:32'!
presheaves
	^ self opposite ⇒ Sets! !

!Category methodsFor: 'operations' stamp: 'len 6/9/2024 08:09:56'!
product: anArray
	"Answer the product of all the objects in anArray, equipped with all the projections."
	| answer projections |
	answer := self terminalObject.
	projections := #().
	anArray do: [:each|
		| P |
		P := answer × each.
		P ⇉ {answer. each} into: [:π₁ :π₂| projections := (projections collect: [:π| π · π₁]), {π₂}].
		answer := P].
	answer addProjections: projections.
	^ answer! !

!Category methodsFor: 'operations' stamp: 'len 8/27/2024 21:57:25'!
relations
"	self assert: self isRegular."
	^ self propertyAt: #relations ifAbsentPut: [RelationsCategory on: self]! !

!Category methodsFor: 'operations' stamp: 'len 6/9/2024 08:09:56'!
sum: anArray
	"Answer the biproduct of all the objects in anArray. equipped with all the projections and coprojections."
	| answer projections coprojections |
	answer := self zeroObject.
	projections := #().
	coprojections := #().
	anArray do: [:each|
		| S |
		S := answer ⊕ each.
		S ⇉ {answer. each} into: [:π₁ :π₂| projections := (projections collect: [:π| π · π₁]), {π₂}].
		S ⇇ {answer. each} into: [:ι₁ :ι₂| coprojections := (coprojections collect: [:ι| ι₁ · ι]), {ι₂}].
		answer := S].
	answer addProjections: projections; addCoprojections: coprojections.
	^ answer! !

!Category methodsFor: 'operations' stamp: 'len 7/5/2024 17:45:19'!
↓ anObject
	"Answer the slice of the receiver over the argument."
	self assert: (self includes₀: anObject).
	^ anObject slice

"this is a special case of the comma category:
	^ self id ↓ (Cat terminalObject to: self constant: anObject id)
"! !

!Category methodsFor: 'operations' stamp: 'len 4/8/2024 05:28:30'!
⊗ aCategory
	"The category of categories is a monoidal category with the product of categories as tensor product."
	^ self × aCategory! !

!Category methodsFor: 'printing' stamp: 'len 8/24/2024 09:45:51'!
printBimonOn: aStream
	aStream nextPutAll: 'Bimon('; print: self; nextPut: $)! !

!Category methodsFor: 'printing' stamp: 'len 8/24/2024 09:46:00'!
printCComonOn: aStream
	aStream nextPutAll: 'CComon('; print: self; nextPut: $)! !

!Category methodsFor: 'printing' stamp: 'len 8/24/2024 09:46:05'!
printCMonOn: aStream
	aStream nextPutAll: 'CMon('; print: self; nextPut: $)! !

!Category methodsFor: 'printing' stamp: 'len 8/24/2024 09:46:15'!
printComonOn: aStream
	aStream nextPutAll: 'Comon('; print: self; nextPut: $)! !

!Category methodsFor: 'printing' stamp: 'len 8/24/2024 09:46:19'!
printMonOn: aStream
	aStream nextPutAll: 'Mon('; print: self; nextPut: $)! !

!Category methodsFor: 'printing' stamp: 'len 4/12/2024 05:22:34'!
printOn: aStream
	Smalltalk associationsDo: [:each| self == each value ifTrue: [aStream nextPutAll: each key asString bold. ^ self]].
	super printOn: aStream! !

!Category methodsFor: 'printing' stamp: 'len 8/24/2024 09:43:58'!
printOpOn: aStream
	aStream print: self; nextPutAll: 'op' super! !

!Category methodsFor: 'random' stamp: 'len 5/26/2024 09:01:54'!
atRandom: aRandom
	| hom |
	[(hom := (self atRandom₀: aRandom) ^ (self atRandom₀: aRandom)) isEmpty] whileTrue.
	^ hom atRandom: aRandom! !

!Category methodsFor: 'random' stamp: 'len 5/26/2024 09:02:17'!
atRandom: aRandom bits: bitSize
	| hom |
	[(hom := (self atRandom₀: aRandom bits: bitSize) ^ (self atRandom₀: aRandom bits: bitSize)) isEmpty] whileTrue.
	^ hom atRandom: aRandom bits: bitSize! !

!Category methodsFor: 'random' stamp: 'len 5/26/2024 09:04:29'!
atRandom₀
	^ self atRandom₀: self newRandom! !

!Category methodsFor: 'random' stamp: 'len 5/26/2024 08:58:56'!
atRandom₀: aRandom
	^ self objects atRandom: aRandom! !

!Category methodsFor: 'random' stamp: 'len 5/26/2024 08:59:41'!
atRandom₀: aRandom bits: bitSize
	^ self atRandom₀: aRandom! !

!Category methodsFor: 'testing' stamp: 'len 4/13/2024 05:15:07'!
includes: anObject
	^ anObject isMorphism and: [anObject category = self]! !

!Category methodsFor: 'testing' stamp: 'len 4/17/2024 06:40:47'!
includes₀: anObject
	"Answer true if the receiver includes the given object as a 0-cell."
	^ anObject isDomain and: [self includes: anObject id]! !

!Category methodsFor: 'testing' stamp: 'len 4/6/2024 08:08:20'!
isAbelian
	"An abelian category is a preabelian category with lifts along monomorphisms and colifts along epimorphisms.
	Alternatively, an abelian category is an additive category such that each morphism has a kernel and cokernel and for each morphism f the induced morphism f̂ of each kernel-cokernel-factorization of f is an isomorphism."
	^ false! !

!Category methodsFor: 'testing' stamp: 'len 5/26/2024 09:37:00'!
isAdditive
	"An additive category is a preadditive category with a zero object and direct sums."
	self isPreabelian ifTrue: [^ true].
	^ self propertyAt: #isAdditive ifAbsent: [false]! !

!Category methodsFor: 'testing' stamp: 'len 8/4/2024 09:19:42'!
isBraidedMonoidal
	"A braided monoidal category is a monoidal category such that X⊗Y ~ Y⊗X, and the isomorphism is called the 'braiding'.
	Objects understand #braidingWith: and answer the isomorphism."
	self isSymmetricMonoidal ifTrue: [^ true].
	^ self propertyAt: #isBraidedMonoidal ifAbsent: [false]! !

!Category methodsFor: 'testing' stamp: 'len 9/1/2024 16:53:01'!
isCartesianMonoidal
	"Answer true if the receiver is a symmetric monoidal category with the product as tensor product and terminal object as unit object.
	In a cartesian monoidal category, all objects become comonoids in a natural way with the diagonal morphism as comultiplication and the terminal morphism as counit."
	^ self propertyAt: #isCartesianMonoidal ifAbsent: [false]! !

!Category methodsFor: 'testing' stamp: 'len 5/2/2020 21:33:26'!
isCategory
	^ true! !

!Category methodsFor: 'testing' stamp: 'len 8/4/2024 09:20:01'!
isClosedMonoidal
	"A (right) closed monoidal category is a monoidal category with an internal hom that is right adjoint to -⊗Y (currying): [X⊗Y,Z] ~ [X,[Y,Z]].
	Objects understand the internal hom #⇒, #evaluationWith:, #coevaluationWith:, #curryingWith:and:, and #compositionWith:and:."
	^ self propertyAt: #isClosedMonoidal ifAbsent: [false]! !

!Category methodsFor: 'testing' stamp: 'len 9/1/2024 16:52:55'!
isCocartesianMonoidal
	"Answer true if the receiver is a symmetric monoidal category with the coproduct as tensor product and initial object as unit object.
	In a cocartesian monoidal category, all objects become monoids in a natural way with the codiagonal morphism as multiplication and the initial morphism as unit."
	^ self propertyAt: #isCocartesianMonoidal ifAbsent: [false]! !

!Category methodsFor: 'testing' stamp: 'len 8/27/2024 21:27:13'!
isDagger
	^ self propertyAt: #isDagger ifAbsent: [false]! !

!Category methodsFor: 'testing' stamp: 'len 8/28/2024 11:15:46'!
isLinear
	"An R-linear category (or R-algebroid) is a category enriched over R-mod, i.e. a category whose hom-sets are R-modules and composition is R-bilinear."
	^ (self enrichmentBase isKindOf: FPModuleCategory) and: [self enrichmentBase isLinear]! !

!Category methodsFor: 'testing' stamp: 'len 8/27/2024 21:14:21'!
isModAbelian
	^ false! !

!Category methodsFor: 'testing' stamp: 'len 7/28/2024 10:00:48'!
isMonoidal
	"A monoidal category is a category equipped with a 'tensor product'.
	Objects and morphisms understand #⊗ for the tensor product, #leftUnitor, #rightUnitor and #associatorWith:and:, and the category understands #unitObject for the tensor unit."
	(self isBraidedMonoidal or: [self isClosedMonoidal]) ifTrue: [^ true].
	^ self propertyAt: #isMonoidal ifAbsent: [false]! !

!Category methodsFor: 'testing' stamp: 'len 5/26/2024 09:37:35'!
isPreabelian
	"A preabelian category is an additive category with kernels and cokernels."
	self isAbelian ifTrue: [^ true].
	^ self propertyAt: #isPreabelian ifAbsent: [false]! !

!Category methodsFor: 'testing' stamp: 'len 5/27/2024 06:46:20'!
isPreadditive
	"A preadditive category or Ab-category is a category whose hom-sets have the structure of abelian groups and the composition of morphisms is bilinear."
	^ self isAdditive or: [self isLinear]! !

!Category methodsFor: 'testing' stamp: 'len 7/26/2024 08:15:27'!
isRigid
	"A (right) rigid category is a monoidal category where every object has a (right) dual.
	Objects understand #dual, #evaluation and #coevaluation, and morphisms understand #dual."
	^ self propertyAt: #isRigid ifAbsent: [false]! !

!Category methodsFor: 'testing' stamp: 'len 7/8/2024 11:16:43'!
isSemicartesian
	^ self isMonoidal and: [self unitObject isTerminalObject]! !

!Category methodsFor: 'testing' stamp: 'len 7/8/2024 11:16:28'!
isSemicocartesian
	^ self isMonoidal and: [self unitObject isInitialObject]! !

!Category methodsFor: 'testing' stamp: 'len 7/28/2024 09:57:21'!
isSymmetricMonoidal
	"A symmetric monoidal category is a braided monoidal category such that the braiding of X with Y is the inverse of the braiding of Y with X."
	(self isCartesianMonoidal or: [self isCocartesianMonoidal]) ifTrue: [^ true].
	^ self propertyAt: #isSymmetricMonoidal ifAbsent: [false]! !

!Category methodsFor: 'private' stamp: 'len 5/22/2024 15:49:39'!
colimitOf: aFunctor
	| J objects morphisms cofactors A B ι f g |
	self assert: aFunctor codomain = self.
	J := aFunctor domain.
	self assert: J isFinitelyGenerated.
	objects := J objects asArray.
	cofactors := objects collect: [:i| aFunctor value₀: i].
	A := self coproduct: cofactors.
	J isDiscrete ifTrue: [^ A].
	morphisms := J asArray.
	B := self coproduct: (morphisms collect: [:α| aFunctor value₀: α domain]).
	ι := A ⇇ cofactors.
	f := B to: A components: (morphisms collect: [:α| ι at: (objects indexOf: α domain)]).
	g := B to: A components: (morphisms collect: [:α| (ι at: (objects indexOf: α codomain)) · (aFunctor value: α)]).
	^ f coequalizer: g! !

!Category methodsFor: 'private' stamp: 'len 5/22/2024 15:43:26'!
limitOf: aFunctor
	| J objects morphisms factors A B π f g |
	self assert: aFunctor codomain = self.
	J := aFunctor domain.
	self assert: J isFinitelyGenerated.
	objects := J objects asArray.
	factors := objects collect: [:i| aFunctor value₀: i].
	A := self product: factors.
	J isDiscrete ifTrue: [^ A].
	morphisms := J asArray.
	B := self product: (morphisms collect: [:α| aFunctor value₀: α codomain]).
	π := A ⇉ factors.
	f := A to: B components: (morphisms collect: [:α| π at: (objects indexOf: α codomain)]).
	g := A to: B components: (morphisms collect: [:α| (aFunctor value: α) · (π at: (objects indexOf: α domain))]).
	^ f equalizer: g! !

!Category methodsFor: 'private' stamp: 'len 5/2/2020 05:07:09'!
species
	^ Category! !

!FreeCategory methodsFor: 'accessing' stamp: 'len 4/14/2024 07:47:38'!
generatingGraph
	^ self propertyAt: #generatingGraph! !

!FreeCategory methodsFor: 'accessing' stamp: 'len 5/22/2024 10:28:23'!
objectAt: aValue
	^ (self propertyAt: #objectsMap) at: aValue! !

!FreeCategory methodsFor: 'accessing' stamp: 'len 5/10/2024 10:50:05'!
size
	self isDiscrete ifTrue: [^ self generatingGraph size].
	self isFinite ifFalse: [^ ℕ size].
	self flag: #fixme. "TODO: implement path enumeration and countring"
	^ super size! !

!FreeCategory methodsFor: 'accessing' stamp: 'len 5/22/2024 10:34:53'!
size₀
	^ self generatingGraph size! !

!FreeCategory methodsFor: 'comparing' stamp: 'len 4/14/2024 14:09:57'!
= anObject
	self == anObject ifTrue: [^ true].
	^ self class = anObject class and: [self generatingGraph = anObject generatingGraph]! !

!FreeCategory methodsFor: 'comparing' stamp: 'len 4/14/2024 14:09:43'!
hash
	^ self generatingGraph hash! !

!FreeCategory methodsFor: 'elements' stamp: 'len 5/22/2024 10:28:30'!
newFrom: anObject
	(self propertyAt: #objectsMap) at: anObject ifPresent: [:aDomain| ^ aDomain].
	^ super newFrom: anObject! !

!FreeCategory methodsFor: 'enumerating' stamp: 'len 5/22/2024 10:28:51'!
do₀: aBlock
	(self propertyAt: #objectsMap) do: aBlock! !

!FreeCategory methodsFor: 'printing' stamp: 'len 6/2/2024 16:43:48'!
printOn: aStream
	| G |
	G := self generatingGraph.
	G isChain ifTrue: [aStream nextPutAll: G size printStringBlackboardBold bold. ^ self].
	aStream nextPutAll: 'ℱ('.
	self generators do: [:each| aStream print: each] separatedBy: [aStream nextPutAll: ', '].
	aStream nextPut: $)! !

!FreeCategory methodsFor: 'random' stamp: 'len 5/26/2024 08:58:17'!
atRandom₀: aRandom
	^ (self propertyAt: #objectsMap) atRandom: aRandom! !

!FreeCategory methodsFor: 'testing' stamp: 'len 4/15/2024 07:45:23'!
isDiscrete
	"A 'discrete category' is a category whose only morphisms are the identity morphisms."
	^ self generatingGraph edges isEmpty! !

!FreeCategory methodsFor: 'testing' stamp: 'len 5/10/2024 10:46:02'!
isEmpty
	^ self generatingGraph isEmpty! !

!FreeCategory methodsFor: 'testing' stamp: 'len 5/9/2024 15:37:40'!
isFinite
	^ self generatingGraph isCyclic not! !

!FreeCategory methodsFor: 'testing' stamp: 'len 4/19/2024 07:22:50'!
isFinitelyGenerated
	self flag: #fix. "temporarily disable this, see Functor>>value:"
	^ false! !

!FreeCategory methodsFor: 'private' stamp: 'len 6/14/2024 15:05:40'!
generatingGraph: aGraph
	| generators objects |
	self propertyAt: #generatingGraph put: aGraph.
	objects := self propertyAt: #objectsMap put: Dictionary new.
	aGraph nodesDo: [:each| objects at: each value put: (Vertex value: each value neighbors: (each neighbors asArray collect: [:node| node value]) category: self)].
	generators := OrderedCollection new.
	aGraph nodesDo: [:each|
		generators add: (objects at: each value) id. "should we include the identities in the generators?"
		each neighbors withIndexDo: [:other :i|
			generators add: ((objects at: each value) to: (objects at: other value) steps: {i})]].
	self propertyAt: #generators put: generators asArray	! !

!FreeCategory class methodsFor: 'instance creation' stamp: 'len 4/14/2024 07:17:19'!
arrows: aCollection
	^ self on: (Digraph ordered addEdges: aCollection; yourself)! !

!FreeCategory class methodsFor: 'instance creation' stamp: 'len 4/30/2024 06:06:12'!
new: anInteger
	"Answer the discrete category with n objects and n morphisms (all morphism are identity morphisms)."
	^ self vertices: (1 to: anInteger)! !

!FreeCategory class methodsFor: 'instance creation' stamp: 'len 4/14/2024 07:10:52'!
on: aGraph
	"Answer a new free category ℱ(G) generated by the directed multigraph G."
	^ self new generatingGraph: aGraph! !

!FreeCategory class methodsFor: 'instance creation' stamp: 'len 4/30/2024 06:03:57'!
vertices: aCollection
	"Answer the discrete category whose objects corresponde to the elements of aCollection, and whose only morphisms are identity morphisms."
	^ self on: (Digraph ordered addAll: aCollection; yourself)! !

!FreeCategory class methodsFor: 'instance creation' stamp: 'len 4/14/2024 07:16:29'!
vertices: aCollection arrows: anotherCollection
	^ self on: (Digraph ordered addAll: aCollection; addEdges: anotherCollection; yourself)! !

!FunctorCategory methodsFor: 'accessing' stamp: 'len 5/30/2024 06:24:43'!
initialObject
	^ self constant: codomain initialObject! !

!FunctorCategory methodsFor: 'accessing' stamp: 'len 5/30/2024 06:24:57'!
terminalObject
	^ self constant: codomain terminalObject! !

!FunctorCategory methodsFor: 'accessing' stamp: 'len 6/5/2024 08:53:04'!
unitObject
	self assert: domain = codomain.
	^ domain id asPresheaf! !

!FunctorCategory methodsFor: 'accessing' stamp: 'len 5/30/2024 06:25:07'!
zeroObject
	^ self constant: codomain zeroObject! !

!FunctorCategory methodsFor: 'elements' stamp: 'len 5/30/2024 06:24:26'!
constant: anObject
	^ (domain to: codomain constant: anObject) asPresheaf! !

!FunctorCategory methodsFor: 'morphisms' stamp: 'len 5/31/2024 08:52:18'!
from: aCategory
	"Yoneda embedding:"
"	(aCategory enrichment = codomain and: [aCategory = domain opposite])
		ifTrue: [^ aCategory into: self map: [:f| (domain domain to: codomain map: [:g| f domain reverse ⇒ g]) to: ((domain domain to: codomain map: [:g| f codomain reverse ⇒ g]) transform: [:x| x]."
	^ super from: aCategory! !

!FunctorCategory methodsFor: 'operations' stamp: 'len 6/13/2024 08:40:44'!
opposite
	^ domain opposite ⇒ codomain opposite! !

!FunctorCategory methodsFor: 'printing' stamp: 'len 6/5/2024 08:53:45'!
printOn: aStream
	domain = codomain
		ifTrue: [aStream nextPutAll: 'End'; nextPut: $(; print: domain; nextPut: $)]
		ifFalse: [aStream nextPut: $[; print: domain; nextPut: $,; print: codomain; nextPut: $]]! !

!FunctorCategory methodsFor: 'testing' stamp: 'len 7/26/2024 07:54:14'!
isAbelian
	^ codomain isAbelian or: [super isAbelian]! !

!FunctorCategory methodsFor: 'testing' stamp: 'len 6/14/2024 10:27:52'!
isMonoidal
	"In fact, it is *strict* monoidal."
	^ domain = codomain! !

!FunctorCategory methodsFor: 'testing' stamp: 'len 7/26/2024 07:54:26'!
isRigid
	^ codomain isRigid or: [super isRigid]! !

!FunctorCategory methodsFor: 'private' stamp: 'len 5/22/2024 11:09:51'!
colimitOf: aFunctor
	"Limite and colimits in a functor category are computed pointwise."
	self notYetImplemented! !

!FunctorCategory methodsFor: 'private' stamp: 'len 3/31/2024 20:39:56'!
domain: aDomain codomain: aCodomain
	domain := aDomain.
	codomain := aCodomain! !

!FunctorCategory methodsFor: 'private' stamp: 'len 5/22/2024 11:09:56'!
limitOf: aFunctor
	"Limite and colimits in a functor category are computed pointwise."
	self notYetImplemented! !

!FunctorCategory class methodsFor: 'instance creation' stamp: 'len 3/31/2024 20:37:38'!
from: aDomain to: aCodomain
	^ self new domain: aDomain codomain: aCodomain! !

!OppositeCategory methodsFor: 'accessing' stamp: 'len 6/10/2024 08:38:38'!
enrichmentBase
	opposite enrichmentBase isSymmetricMonoidal ifTrue: [^ opposite enrichmentBase].
	^ super enrichmentBase! !

!OppositeCategory methodsFor: 'accessing' stamp: 'len 4/15/2024 08:56:28'!
initialObject
	^ opposite terminalObject reverse! !

!OppositeCategory methodsFor: 'accessing' stamp: 'len 6/23/2024 06:27:29'!
size
	^ opposite size! !

!OppositeCategory methodsFor: 'accessing' stamp: 'len 6/25/2024 15:56:43'!
size₀
	^ opposite size₀! !

!OppositeCategory methodsFor: 'accessing' stamp: 'len 4/15/2024 08:56:23'!
terminalObject
	^ opposite initialObject reverse! !

!OppositeCategory methodsFor: 'accessing' stamp: 'len 6/5/2024 06:19:16'!
unitObject
	^ opposite unitObject reverse! !

!OppositeCategory methodsFor: 'accessing' stamp: 'len 5/3/2024 06:50:58'!
zeroObject
	^ opposite zeroObject reverse! !

!OppositeCategory methodsFor: 'comparing' stamp: 'len 4/3/2024 08:31:51'!
= anObject
	^ self class = anObject class and: [opposite = anObject opposite]! !

!OppositeCategory methodsFor: 'comparing' stamp: 'len 4/3/2024 08:31:57'!
hash
	^ opposite hash! !

!OppositeCategory methodsFor: 'elements' stamp: 'len 4/4/2024 12:37:14'!
adapt: anElement
	(opposite includes: anElement) ifTrue: [^ anElement reverse].
	^ super adapt: anElement! !

!OppositeCategory methodsFor: 'internalization' stamp: 'len 6/10/2024 08:53:32'!
base
	^ opposite base opposite! !

!OppositeCategory methodsFor: 'internalization' stamp: 'len 8/31/2024 08:45:57'!
coaction: aMorphism
	^ (opposite action: aMorphism reverse) reverse! !

!OppositeCategory methodsFor: 'internalization' stamp: 'len 7/27/2024 10:41:17'!
comultiplication: Δ counit: ε
	"Answer a comonoid object with the given comultiplication Δ : M → M ⊗ M and counit ε : M → 1."
	^ (opposite multiplication: Δ reverse unit: ε reverse) reverse! !

!OppositeCategory methodsFor: 'internalization' stamp: 'len 8/31/2024 08:43:55'!
scalars
	^ opposite scalars reverse! !

!OppositeCategory methodsFor: 'morphisms' stamp: 'len 8/25/2024 08:29:09'!
from: aCategory
	aCategory = opposite ifTrue: [^ aCategory to: self map₀: [:x| x reverse] map: [:f| f reverse]].
	aCategory ⇢ opposite ifNotNil: [:aFunctor| ^ aCategory to: self map₀: [:x| (aFunctor value₀: x) reverse] map: [:f| (aFunctor value: f) reverse]].
	^ super from: aCategory! !

!OppositeCategory methodsFor: 'morphisms' stamp: 'len 8/25/2024 08:30:50'!
to: aCategory
	opposite = aCategory ifTrue: [^ self to: aCategory map₀: [:x| x reverse] map: [:f| f reverse]].
	opposite ⇢ aCategory ifNotNil: [:aFunctor| ^ self to: aCategory map₀: [:x| aFunctor value₀: x reverse] map: [:f| aFunctor value: f reverse]].
	^ super to: aCategory! !

!OppositeCategory methodsFor: 'operations' stamp: 'len 4/1/2024 08:45:46'!
opposite
	^ opposite! !

!OppositeCategory methodsFor: 'printing' stamp: 'len 8/24/2024 09:43:46'!
printOn: aStream
	opposite printOpOn: aStream! !

!OppositeCategory methodsFor: 'testing' stamp: 'len 4/15/2024 08:16:27'!
isAbelian
	"The opposite of an abelian category is also abelian."
	^ opposite isAbelian! !

!OppositeCategory methodsFor: 'testing' stamp: 'len 4/11/2024 08:48:21'!
isAdditive
	^ opposite isAdditive "is this true?"! !

!OppositeCategory methodsFor: 'testing' stamp: 'len 6/10/2024 19:35:28'!
isBraidedMonoidal
	^ opposite isBraidedMonoidal! !

!OppositeCategory methodsFor: 'testing' stamp: 'len 6/5/2024 17:24:50'!
isCartesianMonoidal
	^ opposite isCocartesianMonoidal! !

!OppositeCategory methodsFor: 'testing' stamp: 'len 6/5/2024 17:24:58'!
isCocartesianMonoidal
	^ opposite isCartesianMonoidal! !

!OppositeCategory methodsFor: 'testing' stamp: 'len 6/23/2024 06:27:17'!
isLinear
	^ opposite isLinear! !

!OppositeCategory methodsFor: 'testing' stamp: 'len 6/5/2024 06:19:31'!
isMonoidal
	^ opposite isMonoidal! !

!OppositeCategory methodsFor: 'testing' stamp: 'len 4/15/2024 08:17:04'!
isPreadditive
	"The opposite of a preadditive category is also preadditive."
	^ opposite isPreadditive! !

!OppositeCategory methodsFor: 'testing' stamp: 'len 7/26/2024 08:06:31'!
isRigid
	^ opposite isRigid! !

!OppositeCategory methodsFor: 'testing' stamp: 'len 7/8/2024 07:25:48'!
isSymmetricMonoidal
	^ opposite isSymmetricMonoidal! !

!OppositeCategory methodsFor: 'private' stamp: 'len 6/10/2024 08:31:12'!
opposite: aCategory
	self assert: opposite isNil.
	opposite := aCategory! !

!OppositeCategory class methodsFor: 'instance creation' stamp: 'len 4/1/2024 08:45:23'!
opposite: aCategory
	^ self new opposite: aCategory! !

!ProductCategory methodsFor: 'accessing' stamp: 'len 4/1/2024 08:59:10'!
components
	^ components! !

!ProductCategory methodsFor: 'accessing' stamp: 'len 8/15/2024 21:14:13'!
initialObject
	^ ProductObject components: (components collect: [:each| each initialObject])! !

!ProductCategory methodsFor: 'accessing' stamp: 'len 4/1/2024 09:43:25'!
size
	^ components product: [:each| each size]! !

!ProductCategory methodsFor: 'accessing' stamp: 'len 6/25/2024 15:57:16'!
size₀
	^ components product: [:each| each size₀]! !

!ProductCategory methodsFor: 'accessing' stamp: 'len 8/15/2024 21:14:03'!
terminalObject
	^ ProductObject components: (components collect: [:each| each terminalObject])! !

!ProductCategory methodsFor: 'accessing' stamp: 'len 8/15/2024 21:13:52'!
unitObject
	^ ProductObject components: (components collect: [:each| each unitObject])! !

!ProductCategory methodsFor: 'accessing' stamp: 'len 8/15/2024 21:13:38'!
zeroObject
	^ ProductObject components: (components collect: [:each| each zeroObject])! !

!ProductCategory methodsFor: 'comparing' stamp: 'len 4/1/2024 08:58:43'!
= anObject
	^ self class = anObject class and: [components = anObject components]! !

!ProductCategory methodsFor: 'comparing' stamp: 'len 4/1/2024 08:58:55'!
hash
	^ components hash! !

!ProductCategory methodsFor: 'elements' stamp: 'len 8/15/2024 21:22:27'!
compose: anArray
	self assert: components size = anArray size.
	components with: anArray do: [:X :f| self assert: (X includes: f)].
	^ ProductMorphism components: anArray! !

!ProductCategory methodsFor: 'elements' stamp: 'len 8/15/2024 21:22:35'!
compose₀: anArray
	self assert: components size = anArray size.
	components with: anArray do: [:X :x| self assert: (X includes₀: x)].
	^ ProductObject components: anArray asArray! !

!ProductCategory methodsFor: 'morphisms' stamp: 'len 4/2/2024 15:23:29'!
projection: i
	"Answer the canonical projection to the i-th component."
	^ (self to: (components at: i) map: [:x| x at: i]) name: 'π', i printString sub! !

!ProductCategory methodsFor: 'operations' stamp: 'len 5/3/2024 06:00:39'!
× aCategory
	self assert: aCategory isCategory.
	^ aCategory class = self class
		ifTrue: [self class components: components, aCategory components]
		ifFalse: [self class components: (components copyWith: aCategory)]! !

!ProductCategory methodsFor: 'operations' stamp: 'len 8/15/2024 13:06:14'!
opposite
	^ self propertyAt: #opposite ifAbsentPut: [self class components: (components collect: [:each| each opposite])]! !

!ProductCategory methodsFor: 'printing' stamp: 'len 4/1/2024 09:13:33'!
printOn: aStream
	components do: [:each| aStream print: each] separatedBy: [aStream nextPut: $×]! !

!ProductCategory methodsFor: 'testing' stamp: 'len 4/1/2024 09:12:30'!
isAbelian
	^ components allSatisfy: [:each| each isAbelian]! !

!ProductCategory methodsFor: 'testing' stamp: 'len 6/30/2024 18:56:13'!
isBraidedMonoidal
	^ components allSatisfy: [:each| each isBraidedMonoidal]! !

!ProductCategory methodsFor: 'testing' stamp: 'len 7/10/2024 09:14:11'!
isClosedMonoidal
	^ components allSatisfy: [:each| each isClosedMonoidal]! !

!ProductCategory methodsFor: 'testing' stamp: 'len 6/23/2024 05:59:03'!
isMonoidal
	^ components allSatisfy: [:each| each isMonoidal]! !

!ProductCategory methodsFor: 'testing' stamp: 'len 4/1/2024 16:25:11'!
isProduct
	^ true! !

!ProductCategory methodsFor: 'testing' stamp: 'len 6/30/2024 18:56:27'!
isSymmetricMonoidal
	^ components allSatisfy: [:each| each isSymmetricMonoidal]! !

!ProductCategory methodsFor: 'private' stamp: 'len 4/1/2024 08:59:05'!
components: anArray
	components := anArray! !

!ProductCategory class methodsFor: 'instance creation' stamp: 'len 4/1/2024 09:43:53'!
components: anArray
	^ self new components: anArray! !

!CommaCategory methodsFor: 'accessing' stamp: 'len 5/17/2024 10:43:50'!
ground
	^ self source codomain! !

!CommaCategory methodsFor: 'accessing' stamp: 'len 4/8/2024 13:14:06'!
source
	^ self propertyAt: #source! !

!CommaCategory methodsFor: 'accessing' stamp: 'len 4/8/2024 13:14:12'!
target
	^ self propertyAt: #target! !

!CommaCategory methodsFor: 'elements' stamp: 'len 6/14/2024 15:01:24'!
source: anObject target: anotherObject arrow: aMorphism
	^ CommaObject source: anObject target: anotherObject arrow: aMorphism category: self! !

!CommaCategory methodsFor: 'morphisms' stamp: 'len 6/2/2024 11:06:04'!
to: aCategory
	"if the source and target domain are the same this is ambiguous!!
	aCategory = self source domain ifTrue: [^ self to: aCategory map₀: [:x| x source] map: [:f| f source]].
	aCategory = self target domain ifTrue: [^ self to: aCategory map₀: [:x| x target] map: [:f| f target]]."
	^ super to: aCategory! !

!CommaCategory methodsFor: 'printing' stamp: 'len 4/26/2024 13:10:06'!
printOn: aStream
	aStream nextPut: $(; print: self source; nextPutAll: ' ↓ '; print: self target; nextPut: $)! !

!CommaCategory class methodsFor: 'instance creation' stamp: 'len 4/8/2024 13:28:15'!
source: aFunctor target: anotherFunctor
	^ self new propertyAt: #source put: aFunctor; propertyAt: #target put: anotherFunctor; yourself! !

!ArrowCategory methodsFor: 'accessing' stamp: 'len 5/18/2024 13:34:27'!
initialObject
	^ self objectAt: self ground initialObject id! !

!ArrowCategory methodsFor: 'accessing' stamp: 'len 5/18/2024 13:34:37'!
terminalObject
	^ self objectAt: self ground terminalObject id! !

!ArrowCategory methodsFor: 'accessing' stamp: 'len 5/20/2024 09:49:49'!
unitObject
	^ self objectAt: self ground unitObject id! !

!ArrowCategory methodsFor: 'accessing' stamp: 'len 5/18/2024 13:34:50'!
zeroObject
	^ self objectAt: self ground zeroObject id! !

!ArrowCategory methodsFor: 'converting' stamp: 'len 5/30/2024 07:59:26'!
asFunctorCategory
	"Answer the functor category [2,C] isomorphic to the receiver Arr(C)."
	^ (FreeCategory arrows: {1 -> 2}) ⇒ self ground! !

!ArrowCategory methodsFor: 'morphisms' stamp: 'len 5/24/2024 16:17:56'!
from: aCategory
	((aCategory isKindOf: CommaCategory) and: [aCategory ground = self ground]) ifTrue: [^ aCategory to: self map₀: [:x| self objectAt: x arrow] map: [:x :y :f| x to: y source: (aCategory source value: f source) target: (aCategory target value: f target)]].
	^ super from: aCategory! !

!ArrowCategory methodsFor: 'printing' stamp: 'len 5/18/2024 13:30:52'!
printOn: aStream
	aStream print: self ground; nextPutAll: '→' super! !

!ArrowCategory methodsFor: 'testing' stamp: 'len 5/18/2024 13:30:45'!
isAbelian
	^ self ground isAbelian! !

!ArrowCategory methodsFor: 'testing' stamp: 'len 5/20/2024 06:38:54'!
isBraidedMonoidal
	^ self ground isBraidedMonoidal! !

!ArrowCategory methodsFor: 'testing' stamp: 'len 7/2/2024 05:59:59'!
isCartesianMonoidal
	^ self ground isCartesianMonoidal! !

!ArrowCategory methodsFor: 'testing' stamp: 'len 7/2/2024 06:00:15'!
isCocartesianMonoidal
	^ self ground isCocartesianMonoidal! !

!ArrowCategory methodsFor: 'testing' stamp: 'len 5/18/2024 13:30:07'!
isMonoidal
	^ self ground isMonoidal! !

!ArrowCategory methodsFor: 'testing' stamp: 'len 7/26/2024 08:07:34'!
isRigid
	^ self ground isRigid! !

!ArrowCategory methodsFor: 'testing' stamp: 'len 5/20/2024 09:39:37'!
isSymmetricMonoidal
	^ self ground isSymmetricMonoidal! !

!ArrowCategory methodsFor: 'private' stamp: 'len 5/23/2024 16:32:46'!
colimitOf: aFunctor
	"Limits and colimits in the arrow category Arr(C) can be computed in [2,C], since Arr(C) ~ [2,C]."
	self notYetImplemented! !

!ArrowCategory methodsFor: 'private' stamp: 'len 5/23/2024 16:32:40'!
limitOf: aFunctor
	"Limits and colimits in the arrow category Arr(C) can be computed in [2,C], since Arr(C) ~ [2,C]."
	self notYetImplemented! !

!ArrowCategory methodsFor: 'private' stamp: 'len 6/23/2024 09:18:57'!
objectAt: aMorphism
	^ ArrowObject arrow: aMorphism! !

!ArrowCategory methodsFor: 'private' stamp: 'len 7/5/2024 17:56:49'!
source: anObject target: anotherObject arrow: aMorphism
	self assert: (anObject = aMorphism domain and: [anotherObject = aMorphism codomain]).
	^ self objectAt: aMorphism! !

!ArrowCategory class methodsFor: 'instance creation' stamp: 'len 4/26/2024 09:14:42'!
on: aCategory
	^ super source: aCategory id target: aCategory id! !

!SliceCategory methodsFor: 'accessing' stamp: 'len 5/18/2024 06:51:51'!
initialObject
	^ self objectAt: self ground initialObject → self targetObject! !

!SliceCategory methodsFor: 'accessing' stamp: 'len 4/30/2024 06:33:04'!
terminalObject
	^ self objectAt: self targetObject id! !

!SliceCategory methodsFor: 'printing' stamp: 'len 4/26/2024 09:12:51'!
printOn: aStream
	aStream print: self source domain; nextPutAll: ' ↓ '; print: self targetObject! !

!SliceCategory methodsFor: 'printing' stamp: 'len 8/30/2024 20:45:47'!
printOpOn: aStream
	aStream print: self targetObject reverse; nextPutAll: ' ↓ '; print: self source domain opposite! !

!SliceCategory methodsFor: 'private' stamp: 'len 7/5/2024 17:56:10'!
objectAt: aMorphism
	self assert: aMorphism codomain = self targetObject.
	^ SliceObject arrow: aMorphism! !

!SliceCategory methodsFor: 'private' stamp: 'len 7/5/2024 17:56:32'!
source: anObject target: anotherObject arrow: aMorphism
	self assert: (anObject = aMorphism domain and: [anotherObject = aMorphism codomain]).
	^ self objectAt: aMorphism! !

!SliceCategory methodsFor: 'private' stamp: 'len 4/30/2024 10:54:00'!
targetObject
	^ self target value₀: self target domain objects any! !

!SliceCategory class methodsFor: 'instance creation' stamp: 'len 7/5/2024 17:50:31'!
over: anObject
	^ super source: anObject category id target: (Cat terminalObject to: anObject category constant: anObject)! !

!BimonoidCategory methodsFor: 'accessing' stamp: 'len 8/30/2024 09:17:39'!
base
	^ base! !

!BimonoidCategory methodsFor: 'accessing' stamp: 'len 8/30/2024 09:11:33'!
unitObject
	^ self propertyAt: #unitObject ifAbsentPut: [self multiplication: base unitObject codiagonal unit: base unitObject id comultiplication: base unitObject diagonal counit: base unitObject id]! !

!BimonoidCategory methodsFor: 'comparing' stamp: 'len 8/31/2024 18:40:27'!
= anObject
	^ self class = anObject class and: [base = anObject base]! !

!BimonoidCategory methodsFor: 'comparing' stamp: 'len 8/31/2024 18:41:19'!
hash
	^ base hash! !

!BimonoidCategory methodsFor: 'elements' stamp: 'len 8/30/2024 08:38:08'!
multiplication: μ unit: η comultiplication: Δ counit: ε
	"Answer a bimonoid object with the given multiplication μ : M ⊗ M → M, unit η : 1 → M, comultiplication Δ : M → M ⊗ M and counit ε : M → 1."
	^ BimonoidObject multiplication: μ unit: η comultiplication: Δ counit: ε! !

!BimonoidCategory methodsFor: 'morphisms' stamp: 'len 8/30/2024 09:18:04'!
to: aCategory
	base = aCategory ifTrue: [^ self to: aCategory map₀: [:x| x carrier] map: [:f| f carrier]].
	base ⇢ aCategory ifNotNil: [:aFunctor| ^ self to: aCategory map₀: [:x| aFunctor value₀: x carrier] map: [:f| aFunctor value: f carrier]].
	^ super to: aCategory! !

!BimonoidCategory methodsFor: 'operations' stamp: 'len 8/31/2024 18:23:51'!
opposite
	^ base opposite bimonoids! !

!BimonoidCategory methodsFor: 'printing' stamp: 'len 8/30/2024 08:46:36'!
printOn: aStream
	base printBimonOn: aStream! !

!BimonoidCategory methodsFor: 'private' stamp: 'len 8/30/2024 09:17:52'!
base: aMonoidalCategory
	base := aMonoidalCategory! !

!BimonoidCategory class methodsFor: 'instance creation' stamp: 'len 8/30/2024 09:18:42'!
on: aMonoidalCategory
	^ self new base: aMonoidalCategory! !

!GroupCategory methodsFor: 'accessing' stamp: 'len 6/9/2024 08:33:30'!
base
	^ base! !

!GroupCategory methodsFor: 'comparing' stamp: 'len 8/31/2024 18:40:38'!
= anObject
	^ self class = anObject class and: [base = anObject base]! !

!GroupCategory methodsFor: 'comparing' stamp: 'len 8/31/2024 18:41:11'!
hash
	^ base hash! !

!GroupCategory methodsFor: 'elements' stamp: 'len 6/9/2024 08:54:14'!
multiplication: μ unit: η inverse: ι
	"Answer a monoid object with the given multiplication μ : G × G → G, unit η : * → G and inverse ι : G → G."
	^ GroupObject multiplication: μ unit: η inverse: ι! !

!GroupCategory methodsFor: 'morphisms' stamp: 'len 8/25/2024 08:42:29'!
to: aCategory
	base = aCategory ifTrue: [^ self to: aCategory map₀: [:x| x carrier] map: [:f| f carrier]].
	base ⇢ aCategory ifNotNil: [:aFunctor| ^ self to: aCategory map₀: [:x| aFunctor value₀: x carrier] map: [:f| aFunctor value: f carrier]].
	((aCategory isKindOf: MonoidCategory) and: [base = aCategory base]) "embedding of Grp(C) into Mon(C)"
		ifTrue: [^ self to: aCategory map₀: [:x| aCategory multiplication: x multiplication unit: x unit] map: [:x :y :f| x to: y carrier: f carrier]].
	^ super to: aCategory! !

!GroupCategory methodsFor: 'printing' stamp: 'len 6/9/2024 08:35:56'!
printOn: aStream
	Smalltalk associationsDo: [:each| self == each value ifTrue: [aStream nextPutAll: each key asString bold. ^ self]].
	aStream nextPutAll: 'Grp('; print: base; nextPut: $)! !

!GroupCategory methodsFor: 'printing' stamp: 'len 8/26/2024 20:21:23'!
printOpOn: aStream
	aStream nextPutAll: 'Cogrp('; print: base opposite; nextPut: $)! !

!GroupCategory methodsFor: 'private' stamp: 'len 6/9/2024 08:53:30'!
base: aCartesianCategory
	self assert: base isNil.
	base := aCartesianCategory! !

!GroupCategory class methodsFor: 'instance creation' stamp: 'len 6/9/2024 08:36:55'!
on: aCartesianCategory
	^ self new base: aCartesianCategory! !

!ModuleCategory methodsFor: 'accessing' stamp: 'len 8/30/2024 21:01:02'!
base
	^ scalars base! !

!ModuleCategory methodsFor: 'accessing' stamp: 'len 6/9/2024 09:52:32'!
scalars
	^ scalars! !

!ModuleCategory methodsFor: 'accessing' stamp: 'len 9/2/2024 10:27:27'!
unitObject
	^ self propertyAt: #unitObject ifAbsentPut: [self action: scalars multiplication]! !

!ModuleCategory methodsFor: 'accessing' stamp: 'len 8/27/2024 21:48:23'!
zeroObject
	scalars isRing ifTrue: [^ scalars ^ 0].
	^ super zeroObject! !

!ModuleCategory methodsFor: 'comparing' stamp: 'len 6/14/2024 10:53:02'!
= anObject
	^ self class = anObject class and: [scalars = anObject scalars]! !

!ModuleCategory methodsFor: 'comparing' stamp: 'len 6/14/2024 10:53:08'!
hash
	^ scalars hash! !

!ModuleCategory methodsFor: 'elements' stamp: 'len 8/30/2024 07:54:34'!
action: aMorphism
	^ ModuleObject scalars: self action: aMorphism! !

!ModuleCategory methodsFor: 'morphisms' stamp: 'len 6/14/2024 10:54:50'!
functors
	"Answer the category of finitely presented functors on the receiver."
	^ self opposite Freyd! !

!ModuleCategory methodsFor: 'morphisms' stamp: 'len 6/14/2024 10:55:15'!
restriction
	"The restriction of scalars functor."
	self assert: self scalars isRing.
	^ self to: self scalars scalars modules map₀: [:each| each restriction] map: [:each| each restriction]! !

!ModuleCategory methodsFor: 'morphisms' stamp: 'len 8/25/2024 09:06:11'!
to: aCategory
	(aCategory class = self class and: [scalars isRing and: [aCategory scalars isRing]]) ifTrue:
		[scalars ⇢ aCategory scalars ifNotNil: [:aMorphism| ^ self to: aCategory map₀: [:each| each ⊗ aCategory scalars] map: [:each| each ⊗ aCategory scalars]].
		scalars scalars = aCategory scalars ifTrue: [^ self restriction]].
	^ super to: aCategory! !

!ModuleCategory methodsFor: 'printing' stamp: 'len 8/27/2024 21:48:41'!
printOn: aStream
	scalars isRing ifFalse: [	aStream nextPutAll: 'Mod('; print: scalars; nextPut: $). ^ self].
"	scalars = ℤ ifTrue: [aStream nextPutAll: 'Ab' bold. ^ self]."
	aStream print: scalars; nextPut: $-; nextPutAll: (scalars isField ifTrue: ['Vect'] ifFalse: ['Mod'])! !

!ModuleCategory methodsFor: 'printing' stamp: 'len 8/31/2024 08:39:09'!
printOpOn: aStream
	aStream nextPutAll: 'Comod('; print: scalars; nextPut: $)! !

!ModuleCategory methodsFor: 'testing' stamp: 'len 8/28/2024 11:23:42'!
isAbelian
	^ self base isModAbelian! !

!ModuleCategory methodsFor: 'private' stamp: 'len 8/31/2024 17:21:31'!
scalars: aMonoid
	scalars := aMonoid! !

!ModuleCategory class methodsFor: 'instance creation' stamp: 'len 8/30/2024 09:35:01'!
over: aMonoid
	^ self new scalars: aMonoid! !

!MonoidCategory methodsFor: 'accessing' stamp: 'len 6/7/2024 08:56:14'!
base
	^ base! !

!MonoidCategory methodsFor: 'accessing' stamp: 'len 8/30/2024 09:12:00'!
unitObject
	^ self propertyAt: #unitObject ifAbsentPut: [self multiplication: base unitObject codiagonal unit: base unitObject id]! !

!MonoidCategory methodsFor: 'comparing' stamp: 'len 8/31/2024 18:40:55'!
= anObject
	^ self class = anObject class and: [base = anObject base]! !

!MonoidCategory methodsFor: 'comparing' stamp: 'len 8/31/2024 18:41:00'!
hash
	^ base hash! !

!MonoidCategory methodsFor: 'elements' stamp: 'len 7/27/2024 10:41:23'!
multiplication: μ unit: η
	"Answer a monoid object with the given multiplication μ : M ⊗ M → M and unit η : 1 → M."
	^ MonoidObject multiplication: μ unit: η! !

!MonoidCategory methodsFor: 'elements' stamp: 'len 8/31/2024 17:00:47'!
multiplication: μ unit: η comultiplication: Δ counit: ε
	"Answer a bimonoid with the given multiplication μ : M ⊗ M → M, unit η : 1 → M, comultiplication Δ : M → M ⊗ M, counit ε : M → 1."
	| C |
	C := base comultiplication: Δ counit: ε.
	^ self multiplication: (C ⊗ C to: C carrier: μ) unit: (base unitObject to: C carrier: η)! !

!MonoidCategory methodsFor: 'morphisms' stamp: 'len 9/1/2024 17:13:08'!
from: aCategory
	"In a cocartesian monoidal category, all objects become monoids in a natural way with the codiagonal morphism as multiplication and the initial morphism as unit:"
	base isCocartesianMonoidal ifFalse: [^ super from: aCategory].
	aCategory = base ifTrue: [^ aCategory to: self map₀: [:x| self multiplication: x codiagonal unit: base initialObject → x] map: [:x :y :f| x to: y carrier: f]].
	aCategory ⇢ base ifNotNil: [:aFunctor| ^ aCategory to: self map₀: [:x| | x′ | x′ := aFunctor value₀: x. self multiplication: x′ codiagonal unit: base initialObject → x′] map: [:x :y :f| x to: y carrier: (aFunctor value: f)]].
	^ super from: aCategory! !

!MonoidCategory methodsFor: 'morphisms' stamp: 'len 8/30/2024 08:45:35'!
to: aCategory
	base = aCategory ifTrue: [^ self to: aCategory map₀: [:x| x carrier] map: [:f| f carrier]].
	base ⇢ aCategory ifNotNil: [:aFunctor| ^ self to: aCategory map₀: [:x| aFunctor value₀: x carrier] map: [:f| aFunctor value: f carrier]].
	^ super to: aCategory! !

!MonoidCategory methodsFor: 'printing' stamp: 'len 8/24/2024 09:41:21'!
printMonOn: aStream
	base printCMonOn: aStream! !

!MonoidCategory methodsFor: 'printing' stamp: 'len 8/31/2024 16:53:21'!
printOn: aStream
	Smalltalk associationsDo: [:each| self == each value ifTrue: [aStream nextPutAll: each key asString bold. ^ self]].
	base opposite class = self class ifTrue: [base opposite base opposite printBimonOn: aStream. ^ self].
	base printMonOn: aStream! !

!MonoidCategory methodsFor: 'printing' stamp: 'len 8/31/2024 18:44:43'!
printOpOn: aStream
	base opposite printComonOn: aStream! !

!MonoidCategory methodsFor: 'testing' stamp: 'len 6/10/2024 14:06:04'!
isMonoidal
	^ base isBraidedMonoidal! !

!MonoidCategory methodsFor: 'testing' stamp: 'len 7/21/2024 10:01:52'!
isSymmetricMonoidal
	"Both Mon(C) and Comon(C) inherit the symmetry from the underlying symmetric monoidal category.
	Note: they don't inherit general braidings."
	^ base isSymmetricMonoidal! !

!MonoidCategory methodsFor: 'private' stamp: 'len 6/7/2024 08:55:17'!
base: aMonoidalCategory
	self assert: base isNil.
	base := aMonoidalCategory! !

!MonoidCategory class methodsFor: 'instance cration' stamp: 'len 6/7/2024 08:55:31'!
on: aMonoidalCategory
	^ self new base: aMonoidalCategory! !

!ChainComplexesCategory methodsFor: 'accessing' stamp: 'len 4/26/2020 17:43:12'!
chains
	^ self propertyAt: #chains! !

!ChainComplexesCategory methodsFor: 'accessing' stamp: 'len 5/20/2024 09:49:49'!
unitObject
	^ self chains unitObject asChainComplex! !

!ChainComplexesCategory methodsFor: 'accessing' stamp: 'len 5/3/2024 06:51:42'!
zeroObject
	^ self chains zeroObject asChainComplex! !

!ChainComplexesCategory methodsFor: 'morphisms' stamp: 'len 6/1/2024 07:00:52'!
from: aCategory
	aCategory = self chains ifTrue: [^ aCategory to: self map: [:each| each domain asChainComplex to: each codomain asChainComplex components: {each}]].
	aCategory ⇢ self chains ifNotNil: [:aFunctor| ^ self chains → self · aFunctor].
	aCategory class = self class ifTrue: [aCategory chains ⇢ self chains ifNotNil: [:aFunctor| ^ self to: aCategory map₀: [:each| each apply: aFunctor] map: [:each| each apply: aFunctor]]].
	^ super from: aCategory! !

!ChainComplexesCategory methodsFor: 'printing' stamp: 'len 4/12/2024 13:47:36'!
printOn: aStream
	aStream nextPutAll: 'Ch', '∙' sub; nextPut: $(; print: self chains; nextPut: $)! !

!ChainComplexesCategory methodsFor: 'testing' stamp: 'len 4/10/2024 11:34:28'!
isAbelian
	^ self chains isAbelian! !

!ChainComplexesCategory methodsFor: 'testing' stamp: 'len 4/10/2024 11:34:40'!
isAdditive
	^ true! !

!ChainComplexesCategory methodsFor: 'testing' stamp: 'len 6/1/2024 10:10:55'!
isClosedMonoidal
	^ self chains isClosedMonoidal! !

!ChainComplexesCategory methodsFor: 'testing' stamp: 'len 6/1/2024 10:11:03'!
isMonoidal
	^ self chains isMonoidal! !

!ChainComplexesCategory methodsFor: 'private' stamp: 'len 4/26/2020 17:43:27'!
chains: anAbelianCategory
	self propertyAt: #chains put: anAbelianCategory! !

!ChainComplexesCategory class methodsFor: 'instance creation' stamp: 'len 6/20/2020 12:40:03'!
over: anAbelianCategory
	^ self new chains: anAbelianCategory! !

!FreydCategory methodsFor: 'accessing' stamp: 'len 4/2/2024 15:39:06'!
ground
	^ ground! !

!FreydCategory methodsFor: 'comparing' stamp: 'len 4/11/2024 13:51:32'!
= anObject
	^ self class = anObject class and: [ground = anObject ground]! !

!FreydCategory methodsFor: 'comparing' stamp: 'len 4/2/2024 15:37:46'!
hash
	^ ground hash! !

!FreydCategory methodsFor: 'morphisms' stamp: 'len 7/23/2024 14:16:58'!
from: aCategory
	aCategory = ground ifTrue: [^ aCategory into: self map₀: [:x| FreydObject value: x id] map: [:x :y :f| x to: y datum: f codomain id]].
	^ super from: aCategory! !

!FreydCategory methodsFor: 'printing' stamp: 'len 7/23/2024 14:12:04'!
printOn: aStream
	aStream nextPutAll: 'Freyd('; print: ground; nextPut: $)! !

!FreydCategory methodsFor: 'testing' stamp: 'len 7/23/2024 14:13:51'!
isAbelian
	^ true "assuming the ground category has weak kernels"! !

!FreydCategory methodsFor: 'testing' stamp: 'len 4/11/2024 13:54:22'!
isAdditive
	^ true "dont need"! !

!FreydCategory methodsFor: 'private' stamp: 'len 4/2/2024 15:39:14'!
ground: anAdditiveCategory
	ground := anAdditiveCategory! !

!FreydCategory class methodsFor: 'instance creation' stamp: 'len 4/2/2024 15:39:56'!
on: anAdditiveCategory
	^ self new ground: anAdditiveCategory! !

!GradedObjectsCategory methodsFor: 'morphisms' stamp: 'len 9/4/2024 10:07:54'!
from: aCategory
	aCategory = ground ifTrue: [^ aCategory to: self map₀: [:x| GradedObject grading: [:i| i=0 ifTrue: [x] ifFalse: [ground zeroObject]]] map: [:x :y :f| x to: y grading: [:i| i=0 ifTrue: [f] ifFalse: [ground zeroObject id]]]].
	^ super from: aCategory! !

!GradedObjectsCategory methodsFor: 'printing' stamp: 'len 9/4/2024 10:10:21'!
printOn: aStream
	aStream nextPutAll: 'Gr('; print: ground; nextPut: $)! !

!GradedObjectsCategory methodsFor: 'testing' stamp: 'len 9/4/2024 09:23:59'!
isAbelian
	^ ground isAbelian! !

!GradedObjectsCategory methodsFor: 'testing' stamp: 'len 9/4/2024 09:31:10'!
isAdditive
	^ true! !

!GradedObjectsCategory methodsFor: 'testing' stamp: 'len 9/4/2024 10:23:16'!
isMonoidal
	^ ground isMonoidal! !

!GradedObjectsCategory methodsFor: 'private' stamp: 'len 9/4/2024 10:01:09'!
ground: anAdditiveCategory
	ground := anAdditiveCategory! !

!GradedObjectsCategory class methodsFor: 'instance creation' stamp: 'len 9/4/2024 10:00:56'!
on: aCategory
	^ self new ground: aCategory! !

!RelationsCategory methodsFor: 'accessing' stamp: 'len 4/2/2024 15:34:02'!
ground
	^ ground! !

!RelationsCategory methodsFor: 'accessing' stamp: 'len 8/29/2024 09:09:15'!
unitObject
	^ RelationObject value: ground unitObject! !

!RelationsCategory methodsFor: 'comparing' stamp: 'len 8/26/2024 20:14:48'!
= anObject
	^ self class = anObject class and: [ground = anObject ground]! !

!RelationsCategory methodsFor: 'comparing' stamp: 'len 4/2/2024 15:33:55'!
hash
	^ ground hash! !

!RelationsCategory methodsFor: 'morphisms' stamp: 'len 8/26/2024 20:06:54'!
from: aCategory
	aCategory = ground ifTrue: [^ aCategory into: self map₀: [:x| RelationObject value: x] map: [:f| Relation arrow: f]].
	^ super from: aCategory! !

!RelationsCategory methodsFor: 'printing' stamp: 'len 8/26/2024 20:17:31'!
printOn: aStream
	Smalltalk associationsDo: [:each| self == each value ifTrue: [aStream nextPutAll: each key asString bold. ^ self]].
	aStream nextPutAll: 'Rel('; print: ground; nextPut: $)! !

!RelationsCategory methodsFor: 'testing' stamp: 'len 8/27/2024 21:27:52'!
isDagger
	^ true! !

!RelationsCategory methodsFor: 'testing' stamp: 'len 8/29/2024 09:08:47'!
isMonoidal
	^ ground isMonoidal! !

!RelationsCategory methodsFor: 'private' stamp: 'len 8/26/2024 20:13:34'!
ground: aCategory
	ground := aCategory! !

!RelationsCategory class methodsFor: 'instance creation' stamp: 'len 8/26/2024 20:13:44'!
on: aCategory
	^ self new ground: aCategory! !

!FPModuleCategory methodsFor: 'accessing' stamp: 'len 8/31/2024 08:45:04'!
base
	^ Ab! !

!FPModuleCategory methodsFor: 'accessing' stamp: 'len 6/9/2024 09:52:32'!
scalars
	^ scalars! !

!FPModuleCategory methodsFor: 'accessing' stamp: 'len 6/14/2024 10:53:19'!
space
	^ scalars spec! !

!FPModuleCategory methodsFor: 'accessing' stamp: 'len 8/27/2024 21:48:12'!
unitObject
	scalars isRing ifTrue: [^ scalars asIdeal].
	^ super unitObject! !

!FPModuleCategory methodsFor: 'accessing' stamp: 'len 8/27/2024 21:48:23'!
zeroObject
	scalars isRing ifTrue: [^ scalars ^ 0].
	^ super zeroObject! !

!FPModuleCategory methodsFor: 'comparing' stamp: 'len 6/14/2024 10:53:02'!
= anObject
	^ self class = anObject class and: [scalars = anObject scalars]! !

!FPModuleCategory methodsFor: 'comparing' stamp: 'len 6/14/2024 10:53:08'!
hash
	^ scalars hash! !

!FPModuleCategory methodsFor: 'elements' stamp: 'len 8/30/2024 07:59:33'!
action: aMorphism
	^ ModuleObject scalars: scalars action: aMorphism! !

!FPModuleCategory methodsFor: 'morphisms' stamp: 'len 6/14/2024 10:54:50'!
functors
	"Answer the category of finitely presented functors on the receiver."
	^ self opposite Freyd! !

!FPModuleCategory methodsFor: 'morphisms' stamp: 'len 6/14/2024 10:55:15'!
restriction
	"The restriction of scalars functor."
	self assert: self scalars isRing.
	^ self to: self scalars scalars modules map₀: [:each| each restriction] map: [:each| each restriction]! !

!FPModuleCategory methodsFor: 'morphisms' stamp: 'len 8/25/2024 09:06:11'!
to: aCategory
	(aCategory class = self class and: [scalars isRing and: [aCategory scalars isRing]]) ifTrue:
		[scalars ⇢ aCategory scalars ifNotNil: [:aMorphism| ^ self to: aCategory map₀: [:each| each ⊗ aCategory scalars] map: [:each| each ⊗ aCategory scalars]].
		scalars scalars = aCategory scalars ifTrue: [^ self restriction]].
	^ super to: aCategory! !

!FPModuleCategory methodsFor: 'printing' stamp: 'len 8/29/2024 15:38:00'!
printBimonOn: aStream
	aStream print: scalars; nextPutAll: '-Bialg'! !

!FPModuleCategory methodsFor: 'printing' stamp: 'len 8/29/2024 15:38:07'!
printCComonOn: aStream
	aStream print: scalars; nextPutAll: '-CCoalg'! !

!FPModuleCategory methodsFor: 'printing' stamp: 'len 8/29/2024 15:38:12'!
printCMonOn: aStream
	aStream print: scalars; nextPutAll: '-CAlg'! !

!FPModuleCategory methodsFor: 'printing' stamp: 'len 8/29/2024 15:38:15'!
printComonOn: aStream
	aStream print: scalars; nextPutAll: '-Coalg'! !

!FPModuleCategory methodsFor: 'printing' stamp: 'len 8/29/2024 15:38:19'!
printMonOn: aStream
	aStream print: scalars; nextPutAll: '-Alg'! !

!FPModuleCategory methodsFor: 'printing' stamp: 'len 8/29/2024 15:38:45'!
printOn: aStream
"	scalars = ℤ ifTrue: [aStream nextPutAll: 'Ab' bold. ^ self]."
	aStream print: scalars; nextPut: $-; nextPutAll: (scalars isField ifTrue: ['Vect'] ifFalse: ['Mod'])! !

!FPModuleCategory methodsFor: 'printing' stamp: 'len 8/31/2024 08:42:08'!
printOpOn: aStream
	aStream print: scalars; nextPutAll: '-Comod'! !

!FPModuleCategory methodsFor: 'testing' stamp: 'len 8/28/2024 11:23:51'!
isAbelian
	^ true! !

!FPModuleCategory methodsFor: 'testing' stamp: 'len 8/28/2024 11:24:33'!
isClosedMonoidal
	^ scalars isCommutative! !

!FPModuleCategory methodsFor: 'testing' stamp: 'len 8/28/2024 11:24:46'!
isLinear
	^ scalars isCommutative or: [scalars isInvolutive]! !

!FPModuleCategory methodsFor: 'testing' stamp: 'len 8/28/2024 11:25:08'!
isRigid
	^ scalars isDedekindDomain "more generally, if scalars is an hereditary ring?"! !

!FPModuleCategory methodsFor: 'testing' stamp: 'len 6/14/2024 10:51:26'!
isSemisimple
	^ scalars isSemisimple! !

!FPModuleCategory methodsFor: 'testing' stamp: 'len 8/28/2024 11:25:20'!
isSymmetricMonoidal
	^ scalars isCommutative! !

!FPModuleCategory methodsFor: 'private' stamp: 'len 8/30/2024 09:35:16'!
scalars: aRing
	self assert: scalars isNil.
	scalars := aRing! !

!FPModuleCategory class methodsFor: 'instance creation' stamp: 'len 8/28/2024 11:20:52'!
over: aRing
	^ self new scalars: aRing! !

!CoherentSheavesCategory methodsFor: 'accessing' stamp: 'len 6/27/2022 13:39:38'!
space
	^ self propertyAt: #space! !

!CoherentSheavesCategory methodsFor: 'accessing' stamp: 'len 5/20/2024 09:49:49'!
unitObject
	^ self space structureSheaf! !

!CoherentSheavesCategory methodsFor: 'comparing' stamp: 'len 6/27/2022 13:43:45'!
= anObject
	^ self class = anObject class and: [self space = anObject space]! !

!CoherentSheavesCategory methodsFor: 'comparing' stamp: 'len 6/27/2022 13:43:51'!
hash
	^ self space hash! !

!CoherentSheavesCategory methodsFor: 'printing' stamp: 'len 4/13/2024 05:09:01'!
printOn: aStream
	aStream nextPutAll: 'Coh('; print: self space; nextPut: $)! !

!CoherentSheavesCategory methodsFor: 'testing' stamp: 'len 6/27/2022 13:39:16'!
isAbelian
	^ true! !

!CoherentSheavesCategory methodsFor: 'testing' stamp: 'len 6/27/2022 13:39:23'!
isMonoidal
	^ true! !

!CoherentSheavesCategory methodsFor: 'private' stamp: 'len 6/27/2022 13:39:49'!
space: aScheme
	self propertyAt: #space put: aScheme! !

!CoherentSheavesCategory class methodsFor: 'instance creation' stamp: 'len 6/27/2022 13:43:10'!
on: aScheme
	^ self new space: aScheme! !

!SetObject methodsFor: 'accessing' stamp: 'len 8/19/2024 09:41:07'!
underlyingSet
	^ self! !

!SetObject methodsFor: 'comparing' stamp: 'len 5/10/2024 05:08:22'!
~ anObject
	"Answer true if the receiver is isomorphic to the argument."
	^ self size = anObject size! !

!SetObject methodsFor: 'comparing' stamp: 'len 5/10/2024 14:39:43'!
⊆ aSet
	"Answer true if the receiver is a subset of the argument."
	self == aSet ifTrue: [^ true].
	self ambient = aSet ifTrue: [^ true].
	self ambient = aSet ambient ifFalse: [^ false]. "really? or use equality of Smalltalk objects to define membership and subsets?"
	self isFinite ifTrue: [^ self elements allSatisfy: [:each| aSet includes: each]].
	^ self notYetImplemented! !

!SetObject methodsFor: 'enumerating' stamp: 'len 7/24/2024 08:39:20'!
collect: aBlock
	| elements |
	elements := self elementsOrSelf.
	(elements isKindOf: Set) ifTrue: [^ SetObject elements: (elements collect: aBlock)].
	^ SetObject elements: (Iterator on: [:iteratorBlock| | visited | visited := Set new. elements do: [:each| | image | image := aBlock value: each. visited add: image ifAbsent: [iteratorBlock value: image]]])! !

!SetObject methodsFor: 'enumerating' stamp: 'len 7/24/2024 08:39:20'!
select: aBlock
	| elements |
	elements := self elementsOrSelf.
	(elements isKindOf: Set) ifTrue: [^ SetObject elements: (elements select: aBlock)].
	^ SetObject elements: (Iterator on: [:iteratorBlock| elements do: [:each| (aBlock value: each) ifTrue: [iteratorBlock value: each]]])! !

!SetObject methodsFor: 'morphisms' stamp: 'len 7/22/2024 10:15:07'!
associatorWith: anObject and: anotherObject
	^ self ⊗ anObject ⊗ anotherObject to: self ⊗ (anObject ⊗ anotherObject) mapWithArguments: [:x :y| {x at: 1. {x at: 2. y}}]! !

!SetObject methodsFor: 'morphisms' stamp: 'len 5/10/2024 05:09:08'!
automorphisms
	self assert: self isFinite.
	^ self propertyAt: #automorphisms ifAbsentPut: [SymmetricGroup on: self]! !

!SetObject methodsFor: 'morphisms' stamp: 'len 7/28/2024 10:13:18'!
curryingWith: anObject and: anotherObject
	^ self ⊗ anObject ⇒ anotherObject to: self ⇒ (anObject ⇒ anotherObject) map: [:f| self to: anObject ⇒ anotherObject map: [:x| anObject to: anotherObject map: [:y| f value: {x. y}]]]! !

!SetObject methodsFor: 'morphisms' stamp: 'len 7/10/2024 08:04:48'!
evaluationWith: anObject
	^ self ⇒ anObject with: self to: anObject map: [:f :x| f value: x]! !

!SetObject methodsFor: 'morphisms' stamp: 'len 6/12/2024 18:49:15'!
from: aDomain
"	aDomain size = 0 ifTrue: [^ aDomain to: self map: [:x| ]]."
	^ super from: aDomain! !

!SetObject methodsFor: 'morphisms' stamp: 'len 6/12/2024 18:49:08'!
to: aCodomain
"	aCodomain size = 1 ifTrue: [^ self to: aCodomain map: [:x| aCodomain elements any]]."
	^ super to: aCodomain! !

!SetObject methodsFor: 'morphisms' stamp: 'len 6/13/2024 14:38:10'!
to: aCodomain constant: anElement
	^ self to: aCodomain map: [:x| anElement]! !

!SetObject methodsFor: 'morphisms' stamp: 'len 6/20/2024 07:20:58'!
to: aCodomain map: aBlock
	^ Function from: self to: aCodomain map: aBlock! !

!SetObject methodsFor: 'morphisms' stamp: 'len 8/30/2024 09:44:47'!
with: aSet to: anotherSet map: aBlock
	^ self × aSet to: anotherSet mapWithArguments: aBlock! !

!SetObject methodsFor: 'operations' stamp: 'len 5/10/2024 14:37:40'!
/ aBlock
	"Answer the quotient set of the receiver by the equivalence relation given by the argument.
	The argument must be a binary block that evaluates to true only for pairs of related elements."
	^ self collect: [:x| EquivalenceClass representative: x equivalence: aBlock]! !

!SetObject methodsFor: 'operations' stamp: 'len 6/1/2024 09:05:31'!
\ anObject
	"Answer the subset of elements of the receiver that are not in the argument."
	^ self select: [:each| (anObject includes: each) not]! !

!SetObject methodsFor: 'operations' stamp: 'len 7/22/2024 10:10:42'!
× anObject
	^ CartesianProduct components: {self. anObject}! !

!SetObject methodsFor: 'operations' stamp: 'len 7/24/2024 08:39:20'!
⊔ aDomain
	"Answer the categorical coproduct of the receiver with the argument."
	"The coproduct in the category of sets is the disjoint union."
	| answer |
	answer := SetObject elements: (Iterator on: [:aBlock| self do: [:x| aBlock value: {1. x}]. aDomain do: [:x| aBlock value: {2. x}]]).
	answer addCoprojections: {self to: answer map: [:x| {1. x}]. aDomain to: answer map: [:x| {2. x}]}.
	^ answer! !

!SetObject methodsFor: 'operations' stamp: 'len 5/10/2024 05:10:51'!
⊗ aDomain
	^ self × aDomain! !

!SetObject methodsFor: 'testing' stamp: 'len 5/10/2024 05:11:12'!
isSet
	^ true! !

!SetObject methodsFor: 'private' stamp: 'len 7/24/2024 08:39:20'!
species
	^ SetObject! !

!SetObject class methodsFor: 'instance creation' stamp: 'len 5/10/2024 13:21:22'!
elements: anObject
	^ self new propertyAt: #elements put: anObject; yourself! !

!CartesianProduct methodsFor: 'accessing' stamp: 'len 11/10/2015 22:13'!
components
	^ components! !

!CartesianProduct methodsFor: 'accessing' stamp: 'len 2/26/2017 09:47:17'!
size
	^ components product: [:each| each size]! !

!CartesianProduct methodsFor: 'comparing' stamp: 'len 9/16/2018 16:11:29'!
= anObject
	^ (anObject isKindOf: CartesianProduct) and: [components = anObject components]! !

!CartesianProduct methodsFor: 'comparing' stamp: 'len 11/10/2015 23:19'!
hash
	^ components hash! !

!CartesianProduct methodsFor: 'elements' stamp: 'len 5/10/2020 16:25:06'!
compose: anArray
	^ anArray asArray! !

!CartesianProduct methodsFor: 'enumerating' stamp: 'len 4/2/2024 06:41:28'!
do: aBlock
	(self components allSatisfy: [:each| each isFinite])
		ifFalse: [^ self upTo: self size rank: self components size do: aBlock].
	self upToComponent: self components size do: aBlock! !

!CartesianProduct methodsFor: 'enumerating' stamp: 'len 11/5/2016 10:29'!
upTo: max rank: n do: aBlock
	| k |
	self notYetImplemented.
	n = 0 ifTrue: [^ aBlock value: #()].
	k _ 1.
	(self at: n) upTo: max do: [:s|
		self upTo: k rank: n-1 do: [:p|
			aBlock value: {p. s}.
			"(self at: n) upTo: k-1 do: [:t| (p includes: s) ifTrue: [aBlock value: (p,t)]]"].
		k _ k + 1]! !

!CartesianProduct methodsFor: 'enumerating' stamp: 'len 3/17/2021 14:29:36'!
upToComponent: k do: aBlock
	k = 0 ifTrue: [aBlock value: #(). ^ self].
	self upToComponent: k-1 do: [:each| (self components at: k) do: [:last| aBlock value: (each copyWith: last)]]! !

!CartesianProduct methodsFor: 'morphisms' stamp: 'len 9/16/2022 07:41:03'!
projection: i
	^ (self to: (self at: i) map: [:x| x at: i]) name: 'π', i printString sub! !

!CartesianProduct methodsFor: 'operations' stamp: 'len 4/1/2024 10:48:17'!
, aDomain
	^ aDomain class = self class
		ifTrue: [self class components: components, aDomain components]
		ifFalse: [self class components: (components copyWith: aDomain)]! !

!CartesianProduct methodsFor: 'printing' stamp: 'len 5/23/2020 07:18:55'!
printOn: aStream
	components do: [:each| aStream print: each] separatedBy: [aStream nextPut: $×]! !

!CartesianProduct methodsFor: 'random' stamp: 'len 4/19/2016 20:28'!
atRandom: aRandom
	^ components collect: [:each| each atRandom: aRandom]! !

!CartesianProduct methodsFor: 'random' stamp: 'len 4/19/2016 20:28'!
atRandom: aRandom bits: bitSize
	| n |
	n _ bitSize / components size.
	^ components collect: [:each| each atRandom: aRandom bits: n]! !

!CartesianProduct methodsFor: 'testing' stamp: 'len 4/21/2020 15:16:12'!
includes: anObject
	anObject isSequenceable ifFalse: [^ false].
	components size = anObject size ifFalse: [^ false].
	components with: anObject do: [:X :x| (X includes: x) ifFalse: [^ false]].
	^ true! !

!CartesianProduct methodsFor: 'testing' stamp: 'len 4/14/2020 21:09:33'!
isProduct
	^ true! !

!CartesianProduct methodsFor: 'private' stamp: 'len 5/1/2024 10:36:29'!
components: anArray
	components := anArray! !

!CartesianProduct class methodsFor: 'examples' stamp: 'len 5/23/2020 08:59:16'!
example
	"The cartesian product of the ring of rational integers
	and the field of rational numbers (as sets).
	An element of this cartesian product is an array with an
	integer in the first component and a rational number
	in the second component."
	^ (ℤ, ℚ)
! !

!CartesianProduct class methodsFor: 'instance creation' stamp: 'len 11/10/2015 22:17'!
components: anArray
	^ self new components: anArray! !

!HomSet methodsFor: 'accessing' stamp: 'len 3/11/2020 11:21:36'!
codomain
	^ codomain! !

!HomSet methodsFor: 'accessing' stamp: 'len 3/11/2020 11:21:42'!
domain
	^ domain! !

!HomSet methodsFor: 'comparing' stamp: 'len 12/4/2023 11:03:13'!
= anObject
	^ self class = anObject class and: [domain = anObject domain and: [codomain = anObject codomain]]! !

!HomSet methodsFor: 'comparing' stamp: 'len 4/30/2020 09:14:39'!
hash
	^ self domain hash hashMultiply + self codomain hash! !

!HomSet methodsFor: 'elements' stamp: 'len 4/6/2024 15:54:37'!
adapt: anElement
	^ (super adapt: anElement) ifNil: [domain to: codomain adapt: anElement]! !

!HomSet methodsFor: 'elements' stamp: 'len 12/4/2023 11:03:35'!
images: anArray
	"Answer a morphism defined by images of generators."
	^ domain to: codomain images: anArray! !

!HomSet methodsFor: 'elements' stamp: 'len 12/4/2023 11:03:42'!
map: aBlock
	^ domain to: codomain map: aBlock! !

!HomSet methodsFor: 'elements' stamp: 'len 12/4/2023 11:14:14'!
mapWithArguments: aBlock
	^ domain to: codomain mapWithArguments: aBlock! !

!HomSet methodsFor: 'elements' stamp: 'len 9/16/2022 07:43:56'!
newFrom: anObject
	anObject isEvaluable ifTrue: [^ self map: anObject].
	^ super newFrom: anObject! !

!HomSet methodsFor: 'printing' stamp: 'len 8/26/2024 14:29:18'!
printOn: aStream
	domain = codomain
		ifTrue: [aStream nextPutAll: 'End'; nextPut: $(; print: domain; nextPut: $)]
		ifFalse: [aStream nextPutAll: 'Hom'; nextPut: $(; print: domain; nextPut: $,; print: codomain; nextPut: $)]! !

!HomSet methodsFor: 'random' stamp: 'len 12/4/2023 11:05:52'!
atRandom: aRandom
	^ domain to: codomain atRandom: aRandom! !

!HomSet methodsFor: 'random' stamp: 'len 12/4/2023 11:05:59'!
atRandom: aRandom bits: bitSize
	^ domain to: codomain atRandom: aRandom bits: bitSize! !

!HomSet methodsFor: 'testing' stamp: 'len 12/4/2023 11:05:29'!
includes: anObject
	^ anObject isMorphism and: [anObject domain = domain and: [anObject codomain = codomain]]! !

!HomSet methodsFor: 'private' stamp: 'len 6/30/2023 15:22:19'!
domain: aDomain codomain: aCodomain
	domain := aDomain.
	codomain := aCodomain! !

!HomSet class methodsFor: 'instance creation' stamp: 'len 6/30/2023 15:22:03'!
from: aDomain to: aCodomain
	^ self new domain: aDomain codomain: aCodomain! !

!RationalPointSet methodsFor: 'accessing' stamp: 'len 7/28/2022 08:06:10'!
scalars
	^ self domain sections! !

!RationalPointSet methodsFor: 'accessing' stamp: 'len 12/28/2016 11:24:20'!
size
	^ self propertyAt: #size ifAbsentPut: [self codomain pointsCountOver: self scalars]! !

!RationalPointSet methodsFor: 'elements' stamp: 'len 5/8/2023 23:39:37'!
newFrom: anObject
	(anObject isSequenceable and: [anObject size = self codomain ambient rank]) ifTrue: [^ self codomain pointAt: self scalars !!!! anObject].
	^ super newFrom: anObject! !

!RationalPointSet methodsFor: 'enumerating' stamp: 'len 11/7/2016 16:25'!
do: aBlock
	self codomain pointsOver: self scalars do: aBlock! !

!RationalPointSet class methodsFor: 'instance creation' stamp: 'len 6/19/2023 13:01:01'!
on: aScheme over: aRing
	^ self from: aRing spec to: aScheme! !

!Naturals methodsFor: 'accessing' stamp: 'len 2/13/2016 20:41'!
identity
	^ 1! !

!Naturals methodsFor: 'accessing' stamp: 'len 12/29/2021 11:55:57'!
size
	^ Cardinal new! !

!Naturals methodsFor: 'comparing' stamp: 'len 12/14/2015 01:55'!
= anObject
	^ self class == anObject class! !

!Naturals methodsFor: 'comparing' stamp: 'len 12/14/2015 01:55'!
hash
	^ self class hash! !

!Naturals methodsFor: 'enumerating' stamp: 'len 12/3/2015 20:12'!
do: aBlock
	| n |
	n _ 1.
	[aBlock value: n. n _ n + 1] repeat! !

!Naturals methodsFor: 'morphisms' stamp: 'len 4/1/2024 14:59:26'!
to: aCodomain map: aBlock
	"Answer a sequence with values in aCodomain."
	self assert: aCodomain isSet.
	^ Sequence to: aCodomain map: aBlock! !

!Naturals methodsFor: 'printing' stamp: 'len 5/23/2020 07:23:35'!
printOn: aStream
	aStream nextPut: $ℕ! !

!Naturals methodsFor: 'random' stamp: 'len 6/30/2016 00:34'!
atRandom: aRandom bits: bitSize
	^ (aRandom nextBits: bitSize truncated) + 1! !

!Naturals methodsFor: 'testing' stamp: 'len 12/5/2015 02:09'!
isFinite
	^ false! !

!Naturals methodsFor: 'testing' stamp: 'len 11/13/2023 10:30:53'!
isOrdered
	^ true! !

!Naturals methodsFor: 'testing' stamp: 'len 2/11/2016 22:19'!
isReal
	^ true! !

!Monoid methodsFor: 'converting' stamp: 'len 12/2/2023 14:36:32'!
asMonoid
	^ self! !

!Monoid methodsFor: 'elements' stamp: 'len 7/14/2024 07:40:09'!
identity
	"Answer the identity element of the receiver."
	self isAmbient ifFalse: [^ self ambient identity].
	^ self propertyAt: #identity ifAbsentPut: [self elements any identity]! !

!Monoid methodsFor: 'internalization' stamp: 'len 8/19/2024 14:39:06'!
carrier
	^ self underlyingSet! !

!Monoid methodsFor: 'internalization' stamp: 'len 6/13/2024 14:40:01'!
multiplication
	^ self carrier × self carrier to: self carrier mapWithArguments: [:x :y| x · y]! !

!Monoid methodsFor: 'internalization' stamp: 'len 6/13/2024 14:54:25'!
to: aCodomain carrier: aFunction
	^ self to: aCodomain map: aFunction! !

!Monoid methodsFor: 'internalization' stamp: 'len 6/13/2024 14:37:31'!
unit
	^ Sets unitObject to: self carrier constant: self identity! !

!Monoid methodsFor: 'morphisms' stamp: 'len 8/19/2024 09:41:08'!
on: anObject action: aBlock
	^ self underlyingSet × anObject underlyingSet to: anObject underlyingSet mapWithArguments: aBlock! !

!Monoid methodsFor: 'morphisms' stamp: 'len 8/29/2024 15:12:42'!
to: aMonoid images: anArray
	"Answer a morphism defined by images of generators."
	self assert: (aMonoid isKindOf: Monoid).
	self assert: self isFinitelyGenerated.
	^ MonoidMap from: self to: aMonoid images: anArray! !

!Monoid methodsFor: 'morphisms' stamp: 'len 8/29/2024 15:12:52'!
to: aMonoid map: aBlock
	self assert: (aMonoid isKindOf: Monoid).
	^ MonoidMap from: self to: aMonoid map: aBlock! !

!Monoid methodsFor: 'morphisms' stamp: 'len 6/1/2024 07:01:23'!
↷ anObject
	"Answer an action of the receiver on anObject."
	^ self ⇢ anObject endomorphisms asMonoid ifNotNil: [:aMorphism| self on: anObject action: [:g :x| (aMorphism value: g) value: x]]! !

!Monoid methodsFor: 'testing' stamp: 'len 10/5/2023 15:50:43'!
isCommutative
	^ self propertyAt: #isCommutative ifAbsentPut:
		[| X |
		X := self generators ifNil: [self].
		X allSatisfy: [:x| X allSatisfy: [:y| x · y = (y · x)]]]! !

!Monoid methodsFor: 'testing' stamp: 'len 8/30/2024 09:23:14'!
isMonoid
	^ true! !

!Monoid methodsFor: 'testing' stamp: 'len 5/13/2019 12:29:33'!
isTrivial
	"Answer true if the receiver is the trivial monoid {id}."
	| generators |
	self propertyAt: #elements ifPresent: [:aCollection| ^ aCollection size = 1].
	generators _ self generators ifNil: [^ self size = 1].
	^ generators allSatisfy: [:each| each = self identity]! !

!Monoid methodsFor: 'private' stamp: 'len 5/2/2020 05:14:38'!
species
	^ Monoid! !

!Monoid class methodsFor: 'instance creation' stamp: 'len 7/14/2024 07:42:06'!
elements: anObject
	self assert: self = Monoid.
	^ self new propertyAt: #elements put: anObject; yourself! !

!EndomorphismMonoid methodsFor: 'accessing' stamp: 'len 1/9/2024 11:05:38'!
codomain
	^ self space! !

!EndomorphismMonoid methodsFor: 'accessing' stamp: 'len 1/9/2024 11:05:36'!
domain
	^ self space! !

!EndomorphismMonoid methodsFor: 'accessing' stamp: 'len 12/1/2023 16:33:34'!
space
	^ space! !

!EndomorphismMonoid methodsFor: 'accessing' stamp: 'len 8/19/2024 09:41:08'!
underlyingSet
	^ (space ^ space) underlyingSet! !

!EndomorphismMonoid methodsFor: 'comparing' stamp: 'len 12/2/2023 08:13:27'!
= anObject
	^ self class = anObject class and: [space = anObject space]! !

!EndomorphismMonoid methodsFor: 'comparing' stamp: 'len 12/2/2023 08:13:33'!
hash
	^ space hash! !

!EndomorphismMonoid methodsFor: 'elements' stamp: 'len 12/1/2023 16:34:30'!
adapt: anElement
	^ (super adapt: anElement) ifNil: [space to: space adapting: anElement]! !

!EndomorphismMonoid methodsFor: 'elements' stamp: 'len 1/9/2024 11:06:02'!
fill: aBlock
	^ self domain to: self codomain fill: aBlock! !

!EndomorphismMonoid methodsFor: 'elements' stamp: 'len 12/1/2023 16:34:37'!
identity
	^ space id! !

!EndomorphismMonoid methodsFor: 'elements' stamp: 'len 12/1/2023 16:34:45'!
images: anArray
	^ space to: space images: anArray! !

!EndomorphismMonoid methodsFor: 'elements' stamp: 'len 12/1/2023 16:35:07'!
map: aBlock
	^ space to: space map: aBlock! !

!EndomorphismMonoid methodsFor: 'elements' stamp: 'len 12/1/2023 16:35:17'!
mapWithArguments: aBlock
	^ space to: space mapWithArguments: aBlock! !

!EndomorphismMonoid methodsFor: 'elements' stamp: 'len 12/1/2023 16:30:10'!
newFrom: anObject
	anObject isEvaluable ifTrue: [^ self map: anObject].
	^ super newFrom: anObject! !

!EndomorphismMonoid methodsFor: 'enumerating' stamp: 'len 8/19/2024 14:39:20'!
do: aBlock
	self underlyingSet do: aBlock! !

!EndomorphismMonoid methodsFor: 'printing' stamp: 'len 12/1/2023 16:36:11'!
printOn: aStream
	aStream nextPutAll: 'End'; nextPut: $(; print: space; nextPut: $)! !

!EndomorphismMonoid methodsFor: 'random' stamp: 'len 8/19/2024 14:39:13'!
atRandom: aRandom
	^ self underlyingSet atRandom: aRandom! !

!EndomorphismMonoid methodsFor: 'random' stamp: 'len 8/19/2024 09:41:08'!
atRandom: aRandom bits: bitSize
	^ self underlyingSet atRandom: aRandom bits: bitSize! !

!EndomorphismMonoid methodsFor: 'testing' stamp: 'len 12/1/2023 16:36:28'!
includes: anObject
	^ anObject isMorphism and: [anObject domain = space and: [anObject isEndomorphism]]! !

!EndomorphismMonoid methodsFor: 'private' stamp: 'len 12/1/2023 16:33:42'!
space: aDomain
	space := aDomain! !

!EndomorphismMonoid class methodsFor: 'instance creation' stamp: 'len 12/1/2023 16:20:38'!
on: aDomain
	^ self new space: aDomain! !

!FreeAbelianMonoid methodsFor: 'accessing' stamp: 'len 5/13/2019 12:26:39'!
generators
	^ self propertyAt: #generators ifAbsentPut: [(1 to: rank) collect: [:i| self x: i to: 1]]! !

!FreeAbelianMonoid methodsFor: 'accessing' stamp: 'len 2/27/2017 07:37:47'!
names: anArray
	"Set indeterminate names to use when printing monomials."
	self propertyAt: #names put: anArray! !

!FreeAbelianMonoid methodsFor: 'accessing' stamp: 'len 11/20/2016 11:03:52'!
ordering
	^ ordering! !

!FreeAbelianMonoid methodsFor: 'accessing' stamp: 'len 6/28/2016 23:37'!
rank
	^ rank! !

!FreeAbelianMonoid methodsFor: 'accessing' stamp: 'len 11/8/2023 13:26:54'!
size
	^ self rank > 0 ifTrue: [ℕ size] ifFalse: [1]! !

!FreeAbelianMonoid methodsFor: 'comparing' stamp: 'len 1/14/2022 11:58:10'!
= anObject
	self == anObject ifTrue: [^ true].
	^ self class == anObject class and: [rank = anObject rank and: [ordering = anObject ordering]]! !

!FreeAbelianMonoid methodsFor: 'comparing' stamp: 'len 3/3/2021 12:37:23'!
hash
	^ self rank hash + self ordering hash! !

!FreeAbelianMonoid methodsFor: 'converting' stamp: 'len 5/13/2019 22:15:42'!
orderedBy: aMonomialOrdering
	| answer |
	answer _ self class new: self rank ordering: aMonomialOrdering.
	self names ifNotNil: [:aCollection| answer names: aCollection].
	^ answer! !

!FreeAbelianMonoid methodsFor: 'converting' stamp: 'len 9/18/2022 06:11:49'!
slice: anArray
	"Answer the submonoid corresponding to a subset of the indeterminates."
	| answer |
	answer _ self class new: (self names ifNil: [anArray size] ifNotNil: [:names| anArray collect: [:i| names at: i]]) ordering: (self ordering slice: anArray).
	answer addMap: (answer to: self images: (anArray collect: [:i| self x: i])).
	^ answer! !

!FreeAbelianMonoid methodsFor: 'elements' stamp: 'len 6/3/2023 20:27:37'!
\ aMonomial
	"Answer aMonomial expressed as a word on the generators."
	^ aMonomial! !

!FreeAbelianMonoid methodsFor: 'elements' stamp: 'len 7/4/2022 12:27:17'!
adapt: anElement
	anElement class = Monomial ifTrue: [^ self newFrom: anElement exponents].
	^ super adapt: anElement! !

!FreeAbelianMonoid methodsFor: 'elements' stamp: 'len 7/4/2022 12:27:31'!
exponents: anArray
	anArray size = rank ifFalse: [self error: 'exponents size doesn''t match rank'].
	^ Monomial exponents: anArray parent: self! !

!FreeAbelianMonoid methodsFor: 'elements' stamp: 'len 12/10/2023 10:40:22'!
identity
	"Answer the identity element of the receiver."
	^ self propertyAt: #identity ifAbsentPut: [Monomial exponents: ((Array new: rank) atAllPut: 0) parent: self]! !

!FreeAbelianMonoid methodsFor: 'elements' stamp: 'len 7/4/2022 12:28:04'!
newFrom: anObject
	| exponents n |
	anObject isSequenceable ifFalse: [^ super newFrom: anObject].
	exponents _ anObject.
	(n _ exponents size) = rank
		ifFalse:
			[n > rank
				ifTrue: [exponents _ exponents copyFrom: 1 to: rank]
				ifFalse: [exponents _ exponents, (ByteArray new: rank - n) "hack"]].
	^ Monomial exponents: exponents parent: self! !

!FreeAbelianMonoid methodsFor: 'elements' stamp: 'len 7/4/2022 12:31:32'!
x: i to: n
	^ Monomial exponents: ((Array new: rank) atAllPut: 0; at: i put: n; yourself) parent: self! !

!FreeAbelianMonoid methodsFor: 'elements' stamp: 'len 7/4/2022 12:33:46'!
x: i to: n x: j to: m
	i = j ifTrue: [^ self x: i to: n+m].
	^ Monomial exponents: ((Array new: rank) atAllPut: 0; at: i put: n; at: j put: m; yourself) parent: self! !

!FreeAbelianMonoid methodsFor: 'elements' stamp: 'len 7/4/2022 12:34:57'!
x: i x: j
	^ self x: i to: 1 x: j to: 1! !

!FreeAbelianMonoid methodsFor: 'enumerating' stamp: 'len 2/21/2017 18:57:11'!
allMonomialsOfDegree: anInteger
	| answer |
	answer _ Set new.
	anInteger partitionsDo: [:partition|
		partition size <= self rank
			ifTrue:
				[(1 to: self rank) combinations: partition size atATimeDo: [:variables|
					partition permutationsDo: [:exponents|
						| monomial |
						monomial _ self identity.
						variables with: exponents do: [:i :r| monomial _ monomial * (self x: i to: r)].
						answer add: monomial]]]].
	^ answer asArray sort reverse! !

!FreeAbelianMonoid methodsFor: 'enumerating' stamp: 'len 6/7/2023 00:25:23'!
allMonomialsUpToDegree: anInteger
	| answer |
	answer := OrderedCollection new.
	0 to: anInteger do: [:n| answer addAll: (self allMonomialsOfDegree: n)].
	^ answer! !

!FreeAbelianMonoid methodsFor: 'enumerating' stamp: 'len 5/23/2020 09:04:52'!
do: aBlock
	ℕ ^ self rank do: [:each| aBlock value: self !! (each asArray collect: [:x| x - 1])]! !

!FreeAbelianMonoid methodsFor: 'operations' stamp: 'len 5/6/2023 18:57:57'!
<< anInteger
	(anInteger = 0 or: [self isTrivial]) ifTrue: [^ self].
	^ self orderedBy: (MonomialOrdering grevlex: self rank weights: ((1 to: self rank) collect: [:i| (ordering weightOf: i) - 1 - anInteger]))! !

!FreeAbelianMonoid methodsFor: 'operations' stamp: 'len 5/4/2023 19:10:40'!
>> anInteger
	^ self << anInteger negated! !

!FreeAbelianMonoid methodsFor: 'operations' stamp: 'len 8/8/2019 11:13:43'!
× aMonoid
	"Answer the direct product (or direct sum) of the receiver and the argument."
	(aMonoid isKindOf: FreeAbelianMonoid) ifTrue: [^ self ⊕ aMonoid].
	^ super × aMonoid! !

!FreeAbelianMonoid methodsFor: 'operations' stamp: 'len 9/16/2022 08:09:59'!
⊕ aMonoid
	"Answer the direct sum of the receiver and the argument as a monoid."
	| answer n n0 m0 |
	(aMonoid isKindOf: FreeAbelianMonoid) ifFalse: [^ super ⊕ aMonoid].
	answer _ self class new: self rank + aMonoid rank ordering: self ordering × aMonoid ordering.
	(self names notNil and: [aMonoid names notNil])
		ifTrue:
			[| names xi |
			names _ self names asOrderedCollection.
			aMonoid names do: [:each|
				xi _ each.
				[names includes: xi] whileTrue: [xi _ xi, ''''].
				names add: xi].
			answer names: names].
	n _ self rank.
	m0 _ (1 to: aMonoid rank) collect: [:i| 0].
	n0 _ (1 to: n) collect: [:i| 0].
	^ answer
		addCoprojections:
			{self into: answer map: [:x| answer exponents: x exponents, m0].
			aMonoid into: answer map: [:x| answer exponents: n0, x exponents]};
		addProjections:
			{answer onto: self map: [:x| self exponents: (x exponents copyFrom: 1 to: n)].
			answer onto: aMonoid map: [:x| aMonoid exponents: (x exponents copyFrom: n+1 to: x exponents size)]};
		yourself! !

!FreeAbelianMonoid methodsFor: 'printing' stamp: 'len 5/13/2019 12:21:50'!
printOn: aStream
	self isTrivial ifTrue: [aStream nextPut: ${; print: self identity; nextPut: $}. ^ self].
	aStream nextPut: $[.
	self generators do: [:each| aStream print: each] separatedBy: [aStream nextPut: $,].
	aStream nextPutAll: ']*'! !

!FreeAbelianMonoid methodsFor: 'random' stamp: 'len 4/1/2024 10:39:55'!
atRandom: aRandom bits: bitSize
	^ self !! ((1 to: self rank) collect: [:i| aRandom nextBits: bitSize])
	
	
	
	! !

!FreeAbelianMonoid methodsFor: 'testing' stamp: 'len 4/25/2020 10:00:13'!
includes: anObject
	^ anObject parent == self! !

!FreeAbelianMonoid methodsFor: 'testing' stamp: 'len 6/30/2016 00:36'!
isCommutative
	^ true! !

!FreeAbelianMonoid methodsFor: 'testing' stamp: 'len 7/8/2022 08:48:20'!
isFinitelyGenerated
	^ true! !

!FreeAbelianMonoid methodsFor: 'testing' stamp: 'len 12/3/2023 14:24:16'!
isOrdered
	^ true! !

!FreeAbelianMonoid methodsFor: 'private' stamp: 'len 1/28/2017 12:07:17'!
ordering: aMonomialOrdering
	ordering _ aMonomialOrdering isSymbol
		ifTrue: [MonomialOrdering perform: (aMonomialOrdering,':') asSymbol with: (1 to: self rank)]
		ifFalse: [aMonomialOrdering]! !

!FreeAbelianMonoid methodsFor: 'private' stamp: 'len 6/28/2016 23:37'!
rank: anInteger
	rank _ anInteger! !

!FreeAbelianMonoid class methodsFor: 'instance creation' stamp: 'len 5/23/2019 17:07:28'!
new: anIntegerOrCollection
	^ self new: anIntegerOrCollection ordering: #grevlex! !

!FreeAbelianMonoid class methodsFor: 'instance creation' stamp: 'len 5/23/2019 17:08:49'!
new: anIntegerOrCollection ordering: aMonomialOrdering
	^ (anIntegerOrCollection isInteger
		ifTrue: [self new rank: anIntegerOrCollection] 
		ifFalse: [self new rank: anIntegerOrCollection size; names: anIntegerOrCollection asArray]) ordering: aMonomialOrdering! !

!FreeMonoid methodsFor: 'accessing' stamp: 'len 12/4/2023 11:25:56'!
generators
	^ self propertyAt: #generators ifAbsentPut: ((1 to: rank) collect: [:i| (Word x: i) parent: self])! !

!FreeMonoid methodsFor: 'accessing' stamp: 'len 5/13/2019 12:59:52'!
names: anArray
	"Set indeterminate names to use when printing words."
	self propertyAt: #names put: anArray! !

!FreeMonoid methodsFor: 'accessing' stamp: 'len 12/4/2023 11:26:05'!
rank
	^ rank! !

!FreeMonoid methodsFor: 'accessing' stamp: 'len 12/4/2023 11:26:12'!
size
	^ rank > 0 ifTrue: [ℕ size] ifFalse: [1]! !

!FreeMonoid methodsFor: 'comparing' stamp: 'len 12/4/2023 11:28:17'!
= anObject
	^ self class = anObject class and: [rank = anObject rank]! !

!FreeMonoid methodsFor: 'comparing' stamp: 'len 12/4/2023 11:28:24'!
hash
	^ rank hash! !

!FreeMonoid methodsFor: 'elements' stamp: 'len 6/3/2023 20:27:57'!
\ aWord
	"Answer aWord expressed as a word on the generators."
	^ aWord! !

!FreeMonoid methodsFor: 'elements' stamp: 'len 6/19/2022 12:29:00'!
identity
	"Answer the identity element of the receiver."
	^ self propertyAt: #identity ifAbsentPut: [Word empty parent: self]! !

!FreeMonoid methodsFor: 'elements' stamp: 'len 7/31/2021 12:26:44'!
syllables: anArray
	^ (Word syllables: anArray) parent: self! !

!FreeMonoid methodsFor: 'elements' stamp: 'len 5/10/2019 17:15:50'!
x: anInteger to: anotherInteger
	^ (Word x: anInteger to: anotherInteger) parent: self! !

!FreeMonoid methodsFor: 'printing' stamp: 'len 5/13/2019 11:09:38'!
printOn: aStream
	self isTrivial ifTrue: [aStream nextPut: ${; print: self identity; nextPut: $}. ^ self].
	aStream nextPut: ${.
	self generators do: [:each| aStream print: each] separatedBy: [aStream nextPut: $,].
	aStream nextPutAll: '}*'! !

!FreeMonoid methodsFor: 'random' stamp: 'len 5/10/2019 18:32:23'!
atRandom: aRandom bits: bitSize
	| answer n |
	answer _ self identity.
	n _ self rank.
	bitSize // n highBit
		timesRepeat:
			[((n + 1) atRandom: aRandom) = 1
				ifFalse: [answer _ (self x: (self rank atRandom: aRandom)) * answer]].
	^ answer! !

!FreeMonoid methodsFor: 'testing' stamp: 'len 12/4/2023 11:25:47'!
contains: aWord
	aWord do: [:i :exp| (rank <= i and: [exp >= 0]) ifFalse: [^ false]].
	^ true! !

!FreeMonoid methodsFor: 'testing' stamp: 'len 4/22/2020 06:10:40'!
includes: anObject
	^ anObject parent == self! !

!FreeMonoid methodsFor: 'testing' stamp: 'len 12/4/2023 11:26:00'!
isCommutative
	^ rank <= 1! !

!FreeMonoid methodsFor: 'testing' stamp: 'len 7/8/2022 08:48:34'!
isFinitelyGenerated
	^ true! !

!FreeMonoid methodsFor: 'testing' stamp: 'len 12/3/2023 14:23:59'!
isOrdered
	^ true! !

!FreeMonoid methodsFor: 'private' stamp: 'len 12/4/2023 11:25:33'!
rank: anInteger
	rank := anInteger! !

!FreeMonoid methodsFor: 'as yet unclassified' stamp: 'len 4/20/2024 11:54:44'!
asCategory
	"Answer the free category with a single object, whose arrows are elements of the receiver."
	| G F |
	G := Digraph orderedLabeled.
	self generators do: [:x| G addEdgeFrom: self to: self label: x].
	F := FreeCategory on: G.
	self flag: #fixme. "TODO: add coercions"
"	F addCoercionFrom: self map: [:x| x ..."
	^ F
! !

!FreeMonoid class methodsFor: 'instance creation' stamp: 'len 5/23/2019 17:06:53'!
new: anIntegerOrCollection
	^ anIntegerOrCollection isInteger
		ifTrue: [self new rank: anIntegerOrCollection] 
		ifFalse: [self new rank: anIntegerOrCollection size; names: anIntegerOrCollection asArray]! !

!Group methodsFor: 'accessing' stamp: 'len 7/22/2023 12:38:52'!
exponent
	"Answer the exponent of the receiver, i.e. the LCM of the orders of its elements."
	^ self propertyAt: #exponent ifAbsentPut: [self computeExponent]! !

!Group methodsFor: 'accessing' stamp: 'len 12/12/2023 19:27:09'!
freeCover
	^ self propertyAt: #freeCover ifAbsentPut:
		[self assert: self isFinitelyGenerated.
		FreeGroup new: self generators size]! !

!Group methodsFor: 'accessing' stamp: 'len 12/3/2023 10:41:04'!
generator
	self isTrivial ifTrue: [^ self identity].
	^ super generator! !

!Group methodsFor: 'accessing' stamp: 'len 6/26/2023 12:55:26'!
null
	"Answer the trivial subgroup, i.e. the zero object in the category of groups."
	^ self ambient sub: #()! !

!Group methodsFor: 'comparing' stamp: 'len 12/10/2023 10:36:24'!
⊆ aGroup
	"Answer true if the receiver is a subgroup of the argument."
	self ambient = aGroup ambient ifFalse: [^ false].
	self isFinitelyGenerated ifTrue: [^ self generators allSatisfy: [:each| aGroup contains: each]].
	^ super ⊆ aGroup! !

!Group methodsFor: 'converting' stamp: 'len 6/26/2023 12:53:19'!
asAbelianGroup
	| generators elementaryDivisors G H |
	self isTrivial ifTrue: [^ ℤ^0].
	generators := self generators.
	elementaryDivisors := OrderedCollection new.
	G := self.
	H := G commutator.
	G size factorization asSet do: [:p| | ranks powers K r |
		ranks := OrderedCollection new.
		[powers := OrderedCollection new.
		generators do: [:g| | x |
			x := g^p.
			(H contains: x) ifFalse: [powers add: x]].
		K := powers isEmpty ifTrue: [H] ifFalse: [H ambient sub: H generators, powers].
		r := G size // K size.
		G := K.
		generators := powers.
		r = 1] whileFalse: [ranks add: (r factorization occurrencesOf: p)].
		ranks isEmpty ifFalse:
			[powers := (Array new: ranks first) atAllPut: 1.
			ranks do: [:i| 1 to: i do: [:j| powers at: j put: (powers at: j) * p]].
			elementaryDivisors addAll: powers]].
	^ ((ℤ^elementaryDivisors size) endomorphisms diagonal: elementaryDivisors sorted) cokernel! !

!Group methodsFor: 'elements' stamp: 'len 12/12/2023 19:29:09'!
\ anElement
	"Answer anElement expressed as a word on the generators. Answer nil if anElement is not in the receiver."
	| F |
	F := self freeCover.
	anElement = self identity ifTrue: [^ F identity].
	self generators indexOf: anElement ifPresent: [:i| F x: i].
	self isCyclic ifTrue: [^ F x: 1 to: ((self logarithmOf: anElement) ifNil: [^ nil])].
	^ self notYetImplemented! !

!Group methodsFor: 'elements' stamp: 'len 8/29/2024 15:17:40'!
elementAt: aWord
	| answer |
	answer := self identity.
	self isAbelianGroup
		ifTrue: [aWord keysAndValuesDo: [:i :e| answer := answer + ((self x: i) * e)]]
		ifFalse: [aWord keysAndValuesDo: [:i :e| answer := answer * ((self x: i) ^ e)]].
	^ answer! !

!Group methodsFor: 'elements' stamp: 'len 8/29/2024 15:17:40'!
identity
	"Answer the identity element of the receiver."
	self isAmbient ifFalse: [^ self ambient identity].
	^ self propertyAt: #identity ifAbsent: "try to determine the identity from other known elements:"
		[(self propertyAt: #elements ifAbsent: [self propertyAt: #generators])
			do: [:each| ^ self propertyAt: #identity put: (self isAbelianGroup ifTrue: [each - each] ifFalse: [each · each inverse])]]! !

!Group methodsFor: 'enumerating' stamp: 'len 8/29/2024 15:17:39'!
do: aBlock
	| generators current previous |
	self propertyAt: #elements ifPresent: [:aCollection| aCollection do: aBlock. ^ self].
	"iterate all elements from the generators:"
	self flag: #fix. "this is too expensive, use a SGS instead"
	generators := self generators.
	generators size = 1 ifTrue:
		[| id g x |
		aBlock value: (id := self identity).
		g := generators any.
		x := g.
		[x = id] whileFalse: [aBlock value: x. x := self isAbelianGroup ifTrue: [x + g] ifFalse: [x · g]].
		^ self].
	current := generators asSet.
	current do: aBlock.
	current add: self identity ifAbsent: [aBlock value: self identity].
	[previous := current.
	current := current copy.
	previous do: [:x|
		generators do: [:y|
			| xy |
			xy := self isAbelianGroup ifTrue: [x + y] ifFalse: [x · y].
			current add: xy ifAbsent: [aBlock value: xy]]].
	previous size < current size] whileTrue.
	self propertyAt: #elements put: current! !

!Group methodsFor: 'graphs' stamp: 'len 8/29/2024 15:17:40'!
cayleyGraph: generators
	"Answer the 'colored' Cayley graph of the receiver for the given set of generators.
	The set of generators is usually assumed to be symmetric (contains all inverses too) and to not contain the identity."
	| G |
	self isFinite ifFalse: [^ self error: 'not a finite group'].
	G := Digraph unorderedLabeled.
	self isAbelianGroup
		ifTrue:
			[self do: [:g|
				generators do: [:x|
					G addEdgeFrom: g to: g + x label: x]]]
		ifFalse:
			[self do: [:g|
				generators do: [:x|
					G addEdgeFrom: g to: g · x label: x]]].
	^ G! !

!Group methodsFor: 'graphs' stamp: 'len 8/29/2024 15:17:40'!
cycleGraph
	| G elements id |
	self isFinite ifFalse: [^ self error: 'not a finite group'].
	G := Graph unordered.
	id := self identity.
	elements := self elements asSet copyWithout: id.
	[elements isEmpty]
		whileFalse:
			[| e g |
			e := elements any.
			g := id.
			[| g2 |
			g2 := self isAbelianGroup ifTrue: [g + e] ifFalse: [g · e].
			(G hasEdgeFrom: g to: g2) ifFalse: [G addEdgeFrom: g to: g2].
			(g := g2) = id] whileFalse: [elements remove: g ifAbsent: []]].
	^ G! !

!Group methodsFor: 'internalization' stamp: 'len 8/19/2024 09:41:08'!
carrier
	^ self underlyingSet! !

!Group methodsFor: 'internalization' stamp: 'len 8/29/2024 15:17:40'!
inverse
	^ self carrier to: self carrier map: (self isAbelianGroup ifTrue: [[:x| x negated]] ifFalse: [[:x| x inverse]])! !

!Group methodsFor: 'internalization' stamp: 'len 8/29/2024 15:17:39'!
multiplication
	^ self carrier × self carrier to: self carrier mapWithArguments: (self isAbelianGroup ifTrue: [[:x :y| x + y]] ifFalse: [[:x :y| x · y]])! !

!Group methodsFor: 'internalization' stamp: 'len 6/13/2024 14:54:12'!
to: aCodomain carrier: aFunction
	^ self to: aCodomain map: aFunction! !

!Group methodsFor: 'internalization' stamp: 'len 6/13/2024 14:49:38'!
unit
	^ Sets terminalObject to: self carrier constant: self identity! !

!Group methodsFor: 'morphisms' stamp: 'len 11/29/2023 13:36:47'!
adjointAction
	self isCommutative ifTrue: [^ self trivialAction].
	^ self on: self action: [:g :x| g inverse · x · g]! !

!Group methodsFor: 'morphisms' stamp: 'len 11/29/2023 13:36:24'!
conjugation
	self isCommutative ifTrue: [^ self trivialAction].
	^ self on: self action: [:g :x| g · x · g inverse]! !

!Group methodsFor: 'morphisms' stamp: 'len 5/3/2024 05:34:27'!
on: anObject action: aBlock
	^ GroupAction from: self on: anObject action: aBlock! !

!Group methodsFor: 'morphisms' stamp: 'len 4/16/2024 18:43:51'!
to: aGroup
	self assert: aGroup isGroup.
	(self isTrivial or: [aGroup isTrivial]) ifTrue: [^ self to: aGroup map: [:x| aGroup identity]].
	^ super to: aGroup! !

!Group methodsFor: 'morphisms' stamp: 'len 6/20/2024 07:32:24'!
to: aGroup images: anArray
	"Answer a morphism defined by images of generators."
	self assert: aGroup isGroup.
	self assert: self isFinitelyGenerated.
	^ GroupMap from: self to: aGroup images: anArray! !

!Group methodsFor: 'morphisms' stamp: 'len 10/13/2023 08:46:49'!
to: aGroup map: aBlock
	self assert: aGroup isGroup.
	^ GroupMap from: self to: aGroup map: aBlock! !

!Group methodsFor: 'morphisms' stamp: 'len 11/29/2023 13:35:51'!
trivialAction
	^ self on: self action: [:g :x| x]! !

!Group methodsFor: 'morphisms' stamp: 'len 6/1/2024 07:01:31'!
↷ anObject
	"Answer an action of the receiver on anObject."
	^ self ⇢ anObject automorphisms ifNotNil: [:aMorphism| self on: anObject action: [:g :x| (aMorphism value: g) value: x]]! !

!Group methodsFor: 'operations' stamp: 'len 6/14/2022 12:52:34'!
* aGroup
	"Answer the free product of the receiver with the argument.
	This is the coproduct in the category of groups."
	^ self notYetImplemented! !

!Group methodsFor: 'operations' stamp: 'len 6/15/2022 09:47:11'!
/ aSubgroup
	"Answer the quotient group (or factor group) of the receiver by the argument.
	Assume aSubgroup is normal in the receiver, otherwise this is just the set of right cosets."
	self == aSubgroup ambient ifFalse: [^ self error: 'not a subgroup of the receiver'].
	^ QuotientGroup relations: aSubgroup
	"Answer the right factor group (or right quotient group) of the receiver by the argument.
	If aSubgroup is not normal in the receiver, this is just the set of left cosets."
"	^ self collect: [:each| LeftCoset on: aSubgroup representative: each]"! !

!Group methodsFor: 'operations' stamp: 'len 6/9/2024 08:09:56'!
× aGroup
	"Answer the direct product of the receiver and the argument. This is the product in the category of groups."
	| F relators |
	aGroup isGroup ifFalse: [^ super × aGroup].
	aGroup isFPGroup ifFalse: [^ ProductGroup components: {self. aGroup}].
	F := self freeCover * aGroup freeCover.
	relators := OrderedCollection new.
	1 to: self freeCover rank do: [:i|
		1 to: aGroup freeCover rank do: [:j|
			relators add: ((F x: i) commutator: (F x: self freeCover rank + j))]].
	F ⇇ {self freeCover. aGroup freeCover} into: [:ι₁ :ι₂|
		relators addAll: (self relators apply: ι₁); addAll: (aGroup relators apply: ι₂)].
	^ F / relators! !

!Group methodsFor: 'operations' stamp: 'len 6/18/2023 23:19:19'!
abelianization
	"Answer the receiver 'made abelian'."
	self isCommutative ifTrue: [^ self].
	^ (self / self commutator)
		propertyAt: #isCommutative put: true;
		yourself! !

!Group methodsFor: 'operations' stamp: 'len 5/10/2024 04:04:52'!
center
	"Answer the subgroup whose memebers are the elements that commute with all the other elements."
	self isCommutative ifTrue: [^ self].
	^ self centralizerOf: self asSet! !

!Group methodsFor: 'operations' stamp: 'len 6/26/2023 12:54:53'!
centralizerOf: aCollection
	self isCommutative ifTrue: [^ self].
	^ self sub: (self select: [:x| aCollection allSatisfy: [:y| x · y = (y · x)]])! !

!Group methodsFor: 'operations' stamp: 'len 5/17/2024 10:53:32'!
commutator
	"Answer the commutator group [G,G] of the receiver G, also called the derived subgroup and notated G'.
	This is the smallest normal subgroup of G such that the quotient G / [G,G] is commutative."
	^ self commutator: self! !

!Group methodsFor: 'operations' stamp: 'len 8/29/2024 15:17:39'!
commutator: aGroup
	"Answer the commutator group [G,H] of the receiver G with the argument H."
	| generators |
	self isCommutative ifTrue: [^ self null].
	self assert: self isAbelianGroup not.
	generators := Set new.
	self generators do: [:x|
		| xInv |
		xInv := x inverse.
		aGroup generators do: [:y| generators add: x · y · xInv · y inverse]].
	^ (self sub: self generators, aGroup generators) normalClosureOf: generators! !

!Group methodsFor: 'operations' stamp: 'len 7/27/2016 07:17'!
conjugacyClassOf: anElement
	^ self conjugation orbitOf: anElement! !

!Group methodsFor: 'operations' stamp: 'len 7/27/2016 07:11'!
conjugacyClasses
	^ self conjugation orbits! !

!Group methodsFor: 'operations' stamp: 'len 12/3/2023 11:07:43'!
fittingSubgroup
	"Answer the Fitting subgroup of the receiver, i.e. the largest nilpotent normal subgroup."
	^ self notYetImplemented! !

!Group methodsFor: 'operations' stamp: 'len 12/3/2023 11:06:58'!
frattiniSubgroup
	"Answer the Frattini subgroup of the receiver, i.e. the intersection of all maximal subgroups."
	^ self notYetImplemented! !

!Group methodsFor: 'operations' stamp: 'len 5/23/2020 09:13:12'!
groupAlgebra
	^ self groupAlgebraOver: ℤ! !

!Group methodsFor: 'operations' stamp: 'len 5/26/2019 08:45:21'!
groupAlgebraOver: aRing
	^ GroupAlgebra on: self over: aRing! !

!Group methodsFor: 'operations' stamp: 'len 5/1/2016 22:59'!
hypoabelianization
	^ self / self perfectCore! !

!Group methodsFor: 'operations' stamp: 'len 12/9/2016 22:44:53'!
index
	"Answer the index of the receiver in its ambient group."
	^ self ambient indexOf: self! !

!Group methodsFor: 'operations' stamp: 'len 2/16/2016 05:21'!
indexOf: aSubgroup
	^ (self / aSubgroup) size! !

!Group methodsFor: 'operations' stamp: 'len 6/23/2023 17:22:29'!
logarithmOf: anElement
	"Assuming the receiver is a cyclic group with a fixed generator α, answer the discrete logarithm of anElement with base α,
	that is i such that αⁱ = anElement (or α*i = anElement in additive notation)."
	^ self logarithmOf: anElement base: self generator! !

!Group methodsFor: 'operations' stamp: 'len 6/23/2023 17:24:52'!
logarithmOf: anElement base: α
	"Answer the discrete logarithm of anElement with base α, that is i such that αⁱ = anElement (or α*i = anElement in additive notation)."
	^ self logarithmOf: anElement base: α order: (self orderOf: α)! !

!Group methodsFor: 'operations' stamp: 'len 8/29/2024 15:17:39'!
logarithmOf: β base: α between: lowerBound and: upperBound
	"Answer the logarithm of β with base α, given lower and upper bounds for the logarithm.
	Use Pollard's Lambda (or Kangaroo) algorithm for discrete logarithm.
	It runs in O(√n) time using O(log n) space, where n = upperBound - lowerBound.
	See [Pol78, Section 3]."
	| additive N table entry k r H c d mem |
	self assert: upperBound >= lowerBound.
	additive := self isAbelianGroup.
	N := (upperBound - lowerBound) sqrtFloor + 1.
	table := Dictionary new. "this table grows with every iteration"
	10 timesRepeat: "why 10?"
		["Random walk setup:"
		k := 0.
		(N - 1) highBit timesRepeat:
			[r := N atRandom.
			table at: k put: r -> (additive ifTrue: [α * r] ifFalse: [α ^ r]).
			k := k + 1].
		self assert: 2^k >= N.
		"First random walk:"
		H := additive ifTrue: [α * upperBound] ifFalse: [α ^ upperBound].
		c := upperBound.
		1 to: N do: [:i|
			entry := table at: H hash \\ k.
			H := additive ifTrue: [H + entry value] ifFalse: [H * entry value].
			c := c + entry key].
		mem := Set with: H.
		"Second random walk:"
		H := β.
		d := 0.
		[c - d >= lowerBound] whileTrue:
			[(upperBound >= (c - d) and: [mem includes: H]) ifTrue: [^ c - d].
			entry := table at: H hash  \\ k.
			H := additive ifTrue: [H + entry value] ifFalse: [H * entry value].
			d := d + entry key]].
	^ nil! !

!Group methodsFor: 'operations' stamp: 'len 6/23/2023 17:26:09'!
logarithmOf: β base: α order: n
	self flag: #fixme. "we can improve this: if we know a factorization of the group order, it's easy to find a factorization of n"
	^ self logarithmOf: β base: α order: n factorization: n factorization! !

!Group methodsFor: 'operations' stamp: 'len 8/29/2024 15:17:40'!
logarithmOf: β base: α order: n factorization: factors
	"Answer the logarithm of β with base α, given the order of α and its factorization.
	Use Pohlig-Hellman algorithm for discrete logarithm.
	The algorithm has worst time complexity O(√n) but it's more efficient if the order is smooth
	(approximately O(√p) where p is the biggest prime factor of n).
	See [PH78]."
	| additive results |
	additive := self isAbelianGroup.
	results := OrderedCollection new.
	factors withOccurrencesDo: [:pᵢ :eᵢ|
		| m αᵢ βᵢ γ bsgs x |
		m := n / (pᵢ^eᵢ).
		"By Lagrange's theorem αᵢ has order pᵢ ^ eᵢ, and by construction βᵢ ∈ ⟨αᵢ⟩:"
		additive ifTrue: [αᵢ := α * m. βᵢ := β * m] ifFalse: [αᵢ := α ^ m. βᵢ := β ^ m].
		"Now compute 0 ≤ xᵢ ≤ pᵢ^eᵢ - 1 such that αᵢ ^ xᵢ = βᵢ:"
		x := 0.
		"By Lagrange's theorem γ has order pᵢ:"
		γ := additive ifTrue: [αᵢ * (pᵢ^(eᵢ - 1))] ifFalse: [αᵢ ^ (pᵢ^(eᵢ - 1))].
		bsgs := BabyStepGiantStep on: self base: γ order: pᵢ.
		0 to: eᵢ - 1 do: [:k|
			| hₖ dₖ |
			"By construction the order of hₖ must divide pᵢ, hence hₖ ∈ ⟨γ⟩:"
			additive
				ifTrue: [hₖ := βᵢ + (αᵢ * x negated) * (pᵢ ^ (eᵢ - 1 - k))]
				ifFalse: [hₖ := βᵢ * (αᵢ ^ x negated) ^ (pᵢ ^ (eᵢ - 1 - k))].
			dₖ := bsgs logarithmOf: hₖ. "this takes time O(√p)"
			x := x + (pᵢ^k * dₖ)].
		results add: ℤ/(pᵢ^eᵢ) !! x].
	results isEmpty ifTrue: [^ 1].
	^ CRT solve: results! !

!Group methodsFor: 'operations' stamp: 'len 12/6/2023 11:21:09'!
maximalAbelianQuotient
	"Answer the largest abelian factor group of the receiver."
	^ self notYetImplemented! !

!Group methodsFor: 'operations' stamp: 'len 10/5/2023 15:40:16'!
normalClosure
	"Answer the normal closure of the receiver in its ambient."
	self isNormal ifTrue: [^ self].
	^ self ambient normalClosureOf: self generators! !

!Group methodsFor: 'operations' stamp: 'len 12/7/2023 16:50:04'!
normalClosureOf: aSubset
	"The normal closure of A <= G in G is the smallest normal subgroup of G that contains A, i.e. the intersection of all normal subgroups that contain A. Equivalently, it is the subgroup generated by the set A^G := {g · a · g^-1 | g ∈ G, a ∈ A}.
	Algorithm from [HEO05, §3.3.3, 74p]."
	| generators N random |
	generators := OrderedCollection withAll: aSubset.
	N := self sub: generators.
	self isCommutative ifTrue: [^ N].
	random := Random new.
	[N ⊲ self]
		whileFalse:
			["Add some new random conjugates to the generators"
			10 timesRepeat: "[Ser03, §5.1.4] suggests adding in batches of 10 for permutation groups"
				[| h g hg |
				g := self atRandom: random.
				h := N atRandom: random.
				hg := g · h · g inverse. "h^g"
				(N includes: hg) ifFalse: [generators add: hg. N := self sub: generators]]].
	^ N! !

!Group methodsFor: 'operations' stamp: 'len 7/17/2023 12:05:52'!
orderOf: anElement
	"Answer the order of the argument in the receiver, i.e. the minimum e such that g^e = 1 (or g*e = 0 in additive notation)."
	^ self orderOf: anElement multiple: self size factorization: self sizeFactorization! !

!Group methodsFor: 'operations' stamp: 'len 6/23/2023 16:20:20'!
orderOf: anElement multiple: anInteger
	"Answer the order of anElement, i.e. the minimum e such that g^e = 1 (or g*e = 0 in additive notation)."
	^ self orderOf: anElement multiple: anInteger factorization: anInteger factorization! !

!Group methodsFor: 'operations' stamp: 'len 8/29/2024 15:17:40'!
orderOf: anElement multiple: anInteger factorization: factors
	"Answer the order of anElement, i.e. the minimum e such that g^e = 1 (or g*e = 0 in additive notation).
	The algorithm takes as argument a multiple of the element's order and its factorization,
	and performs O(log³ n) group operations where n is the specified order multiple anInteger.
	See [Mil04, Algorithm 4] and [HEO05, 73p]."
	| answer id b |
	answer := 1.
	id := self identity.
	self isAbelianGroup
		ifTrue:
			[factors withOccurrencesDo: [:p :r|
				b := anElement * (anInteger / (p ^ r)).
				[b = id] whileFalse: [answer := answer * p. b := b * p]]]
		ifFalse:
			[factors withOccurrencesDo: [:p :r|
				b := anElement ^ (anInteger / (p ^ r)).
				[b = id] whileFalse: [answer := answer * p. b := b ^ p]]].
	^ answer

"alternative, maybe incorrect:
	| id e g1 |
	e := anInteger.
	id := self identity.
	self isAdditiveGroup
		ifTrue:
			[factors withOccurrencesDo: [:p :r|
				e := e / (p ^ r).
				g1 := anElement * e.
				[g1 = id] whileFalse: [g1 := g1 * p. e := e * p]]]
		ifFalse:
			[factors withOccurrencesDo: [:p :r|
				e := e / (p ^ r).
				g1 := anElement ^ e.
				[g1 = id] whileFalse: [g1 := g1 ^ p. e := e * p]]].
	^ e"! !

!Group methodsFor: 'operations' stamp: 'len 12/10/2023 22:28:53'!
perfectCore
	"The perfect core (or perfect radical) of a grop is its largest perfect subgroup."
	| last |
	self derivedSeriesDo: [:each| last := each].
	^ last! !

!Group methodsFor: 'operations' stamp: 'len 12/3/2023 11:08:40'!
radical
	"Answer the solvable radical of the receiver, i.e. the largest solvable normal subgroup."
	^ self notYetImplemented! !

!Group methodsFor: 'operations' stamp: 'len 12/3/2023 11:06:04'!
socle
	"Answer the subgroup generated by all minimal normal subgroups."
	^ self notYetImplemented! !

!Group methodsFor: 'operations' stamp: 'len 12/18/2023 10:10:42'!
sub: aCollection
	"Answer the subgroup generated by aCollection. The collection can contain any objects that can be coerced to the receiver."
	| generators id |
	self isAmbient ifFalse: [^ self ambient sub: aCollection].
	generators := Set new.
	id := self identity.
	aCollection do: [:each| | g |
		g := self !! each.
		g = id ifFalse: [generators add: g]].
	generators := self isOrdered ifTrue: [generators sorted] ifFalse: [generators sorted: [:a :b| a printString <= b printString]].
	^ self species new ambient: self; generators: generators! !

!Group methodsFor: 'operations' stamp: 'len 8/12/2022 13:15:38'!
∩ aGroup
	"Answer the intersection of the receiver and the argument."
	self checkIsSibling: aGroup.
	^ self select: [:each| aGroup includes: each]! !

!Group methodsFor: 'operations' stamp: 'len 5/3/2021 10:42:41'!
⊔ aGroup
	"The coproduct in the category of groups is the free product of groups."
	^ self * aGroup! !

!Group methodsFor: 'operations' stamp: 'len 2/20/2017 22:13:29'!
⊕ aGroup
	"Answer the direct sum of the receiver and the argument."
	^ self × aGroup "finite direct sums of groups are the same as direct products"! !

!Group methodsFor: 'printing' stamp: 'len 8/29/2024 15:17:39'!
printOn: aStream
	| generators |
	(generators := self generators) ifNil: [^ super printOn: aStream].
	"use the original printOn for wrapped objects:"
	self propertyAt: #elements ifPresent: [:elements| (elements isKindOf: Structure) ifTrue: [aStream print: elements. ^ self]].
	generators isEmpty ifTrue: [aStream print: (self isAbelianGroup ifTrue: [0] ifFalse: [1]). ^ self].
	aStream withAngleBrackets: [:aStream2|
		generators do: [:each| aStream2 print: each] separatedBy: [aStream2 nextPutAll: '; ']]! !

!Group methodsFor: 'random' stamp: 'len 5/25/2019 04:43:18'!
atRandom: aRandom
	self propertyAt: #elements ifPresent: [:aCollection| ^ aCollection atRandom: aRandom].
	^ (self propertyAt: #randomGenerator ifAbsentPut: [ProductReplacementRandomGenerator new generators: self generators]) atRandom: aRandom! !

!Group methodsFor: 'random' stamp: 'len 5/25/2019 04:41:49'!
atRandom: aRandom bits: bitSize
	self propertyAt: #elements ifPresent: [:aCollection| ^ aCollection atRandom: aRandom bits: bitSize].
	^ self atRandom: aRandom "assume it's finite"! !

!Group methodsFor: 'series' stamp: 'len 12/10/2023 22:26:07'!
derivedSeries
	^ Iterator on: self performing: #derivedSeriesDo:! !

!Group methodsFor: 'series' stamp: 'len 12/10/2023 22:24:48'!
derivedSeriesDo: aBlock
	"The derived series of a group G is a series of subgroups
		G = G₀ ⊳ G₁ ⊳ ...
	where Gᵢ₊₁ = [Gᵢ, Gᵢ].
	For finite groups the derived series terminates in a perfect group (called the perfect core), which may or may not be trivial."
	| G H |
	G := self.
	[H := G commutator.
	aBlock value: H.
	G size = H size ifTrue: [^ self].
	G := H] repeat! !

!Group methodsFor: 'series' stamp: 'len 12/10/2023 22:25:41'!
lowerCentralSeries
	^ Iterator on: self performing: #lowerCentralSeriesDo:! !

!Group methodsFor: 'series' stamp: 'len 12/10/2023 22:25:10'!
lowerCentralSeriesDo: aBlock
	"The lower central series (or descending central series) of a group G is a descending series of subgroups
		G = G₁ ⊳ G₂ ⊳ ...
	where Gᵢ₊₁ = [Gᵢ, G]."
	| G H |
	G := self.
	[H := G commutator: self.
	aBlock value: H.
	G size = H size ifTrue: [^ self].
	G := H] repeat! !

!Group methodsFor: 'series' stamp: 'len 12/10/2023 22:25:51'!
upperCentralSeries
	^ Iterator on: self performing: #upperCentralSeriesDo:! !

!Group methodsFor: 'series' stamp: 'len 8/29/2024 15:17:39'!
upperCentralSeriesDo: aBlock
	"The upper central series (or ascending central series) of a group G is an ascending series of subgroups
		1 = Z₀ ⊲ Z₁ ⊲ ...
	where Zᵢ₊₁ = {x ∈ G | ∀ y ∈ G : [x,y] ∈ Zᵢ}."
	| Z |
	self assert: self isAbelianGroup not.
	Z := self null.
	[Z := self select: [:x| self allSatisfy: [:y| Z includes: x · y · x inverse]].
	aBlock value: Z.
	Z size = self size] whileFalse! !

!Group methodsFor: 'testing' stamp: 'len 12/1/2023 14:08:19'!
isAutomorphisms
	"Answer true if the elements of the receiver are automorphisms of some object X,
	i.e. if the receiver is Aut(X) or a subgroup of it."
	^ self isAmbient not and: [self ambient isAutomorphisms]! !

!Group methodsFor: 'testing' stamp: 'len 8/29/2024 15:17:39'!
isCommutative
	self isAbelianGroup ifTrue: [^ true]. "all groups implemented with additive notation are abelian"
	^ self propertyAt: #isCommutative ifAbsentPut:
		[| X |
		X := self generators ifNil: [self].
		X allSatisfy: [:x| X allSatisfy: [:y| x · y = (y · x)]]]! !

!Group methodsFor: 'testing' stamp: 'len 12/3/2023 10:11:14'!
isCyclic
	"Answer true if the receiver is generated by one element."
	self isTrivial ifTrue: [^ true].
	self generators ifNotNil: [:aCollection| aCollection size <= 1 ifTrue: [^ true]].
	self do: [:each| (self orderOf: each) = self size ifTrue: [^ true]].
	^ false! !

!Group methodsFor: 'testing' stamp: 'len 10/26/2020 21:15:52'!
isFPGroup
	^ false! !

!Group methodsFor: 'testing' stamp: 'len 11/7/2015 22:01'!
isGroup
	^ true! !

!Group methodsFor: 'testing' stamp: 'len 5/2/2016 02:32'!
isHypoabelian
	^ self perfectCore isTrivial! !

!Group methodsFor: 'testing' stamp: 'len 12/6/2023 11:23:31'!
isMaximal
	"Answer true if the receiver is a maximal subgroup of its ambient."
	^ self isMaximalIn: self ambient! !

!Group methodsFor: 'testing' stamp: 'len 12/6/2023 11:23:56'!
isMaximalIn: aGroup
	"Answer true if the receiver is maximal as subgroup of aGroup."
	^ self notYetImplemented! !

!Group methodsFor: 'testing' stamp: 'len 12/10/2023 22:32:21'!
isNilpotent
	"A nilpotent group G is a group that has an upper central series that terminates with G. Equivalently, its central series is of finite length, or its lower central series terminates with the trivial group."
	| last |
	self lowerCentralSeriesDo: [:each| last := each].
	^ last isTrivial! !

!Group methodsFor: 'testing' stamp: 'len 12/7/2023 16:47:05'!
isNormal
	"Answer true if the receiver is normal in its ambient."
	^ self ⊲ self ambient! !

!Group methodsFor: 'testing' stamp: 'len 12/4/2023 20:18:50'!
isPGroup
	"A finite group is a p-group if its order is a power of a prime."
	^ self isTrivial not and: [self size isPrimePower]! !

!Group methodsFor: 'testing' stamp: 'len 12/3/2023 11:28:16'!
isPerfect
	"A group is perfect if it is not trivial and equals its derived subgroup."
	^ self isTrivial not and: [self = self commutator]! !

!Group methodsFor: 'testing' stamp: 'len 12/3/2023 11:32:12'!
isSimple
	"A group is simple if it has no proper normal subgroup."
	^ self properSubgroups allSatisfy: [:each| each isNormal not]! !

!Group methodsFor: 'testing' stamp: 'len 1/9/2024 10:44:35'!
isSolvable
	(self isFinite and: [self size odd]) ifTrue: [^ true]. "Feit-Thompson theorem: every finite group of odd order is solvable."
	^ self perfectCore isTrivial

"
alternative implementations:
	| G G' |
	G _ self.
	[G isCyclic ifTrue: [^ true].
	G isTrivial ifTrue: [^ false].
	G' _ G commutator.
	G' order = G order ifTrue: [^ false].
	G _ G'] repeat

or:
	| G G' |
	G _ self.
	[G isTrivial ifTrue: [^ true].
	G' _ G commutator.
	G' order = G order ifTrue: [^ false].
	G _ G'] repeat"
! !

!Group methodsFor: 'testing' stamp: 'len 5/1/2020 15:44:22'!
isTrivial
	"Answer true if the receiver is the trivial group {id}."
	| generators |
	self propertyAt: #elements ifPresent: [:aCollection| ^ aCollection size = 1].
	generators _ self generators ifNil: [^ self size = 1].
	^ generators allSatisfy: [:each| each = self identity]! !

!Group methodsFor: 'testing' stamp: 'len 12/7/2023 16:47:38'!
⊲ aGroup
	"Answer true if the receiver is normal as subgroup of aGroup, i.e. if it is a subgroup invariant under conjugation."
	| X Y |
	aGroup isCommutative ifTrue: [^ true].
	X := self generators ifNil: [self].
	Y := aGroup generators ifNil: [aGroup].
	^ Y allSatisfy: [:y|
		| yInverse |
		yInverse := y inverse.
		X allSatisfy: [:x| self includes: y · x · yInverse]]! !

!Group methodsFor: 'testing' stamp: 'len 12/7/2023 16:48:37'!
⊳ aSubgroup
	"Answer true if the argument is normal as subgroup of receiver."
	^ aSubgroup ⊲ self! !

!Group methodsFor: 'private' stamp: 'len 1/28/2018 08:23:20'!
computeExponent
	| answer |
	answer _ 1.
	self do: [:each| answer _ answer lcm: (self orderOf: each)].
	^ answer! !

!Group methodsFor: 'private' stamp: 'len 5/5/2019 17:57:19'!
raise: anElement to: anInteger
	anInteger = 1 ifTrue: [^ anElement].
	anInteger = 0 ifTrue: [^ self identity].
	anInteger < 0 ifTrue: [^ self raise: anElement inverse to: anInteger negated].
	^ (self raise: anElement · anElement to: anInteger // 2) · (self raise: anElement to: anInteger \\ 2)! !

!Group methodsFor: 'private' stamp: 'len 7/17/2023 12:06:21'!
sizeFactorization
	^ self propertyAt: #sizeFactorization ifAbsentPut: [self size factorization]! !

!Group methodsFor: 'private' stamp: 'len 5/1/2016 23:40'!
species
	^ Group! !

!Group class methodsFor: 'examples' stamp: 'len 10/26/2020 21:28:52'!
D
	"Answer the infinite dihedral group as a finitely presented group."
	| F |
	F _ FreeGroup new: #(r f).
	^ F / (F !! [:r :f| {f^2. (r·f)^2}])! !

!Group class methodsFor: 'examples' stamp: 'len 10/26/2020 21:28:52'!
GL2Z
	"Answer GL(2,Z) as a finitely presented group."
	| F |
	F _ FreeGroup new: #(a b j).
	^ F / (F !! [:a :b :j| {a·b·a eq: b·a·b. (a·b·a)^4. j^2. (j·a)^2. (j·b)^2}])! !

!Group class methodsFor: 'examples' stamp: 'len 10/26/2020 21:28:52'!
PSL2Z
	"Answer PSL(2,Z) (the modular group) as a finitely presented group."
	| F |
	F _ FreeGroup new: #(a b).
	^ F / (F !! [:a :b| {a^2. b^3}])! !

!Group class methodsFor: 'examples' stamp: 'len 10/26/2020 21:28:52'!
SL2Z
	"Answer SL(2,Z) as a finitely presented group."
	| F |
	F _ FreeGroup new: #(a b).
	^ F / (F !! [:a :b| {a·b·a eq: b·a·b. (a·b·a)^4}])! !

!Group class methodsFor: 'examples' stamp: 'len 10/26/2020 21:28:52'!
braid: n
	"Answer the braid group on n strands as a finitely presented group."
	| F relators |
	F _ FreeGroup new: n-1.
	relators _ OrderedCollection new.
	1 to: n-1 do: [:i|
		1 to: n-1 do: [:j| (i-1 = j or: [i+1 = j]) ifFalse: [relators add: ((F x: i) commutator: (F x: j))]].
		i < n-1 ifTrue: [relators add: ((F x: i)·(F x: i+1))^3]].
	^ F / relators! !

!Group class methodsFor: 'examples' stamp: 'len 10/26/2020 21:28:52'!
cyclic: n
	"Answer the cyclic group of order n as a finitely presented group."
	| F |
	F _ FreeGroup new: 1.
	^ F / (F !! [:x| x^n])! !

!Group class methodsFor: 'examples' stamp: 'len 10/26/2020 21:28:52'!
dicyclic: n
	"Answer the infinite dihedral group as a finitely presented group."
	| F |
	F _ FreeGroup new: #(r f).
	^ F / (F !! [:r :f| {r^(2*n). r^n·(f^-2). r·f·r·f inverse}])! !

!Group class methodsFor: 'examples' stamp: 'len 10/26/2020 21:28:52'!
dihedral: order
	"Answer the dihedral group of order 2n as a finitely presented group."
	| n F |
	order even ifFalse: [self error: 'order should be even'].
	n _ order // 2.
	F _ FreeGroup new: #(r f).
	^ F / (F !! [:r :f| {r^n. f^2. (r·f)^2}])! !

!Group class methodsFor: 'examples' stamp: 'len 10/26/2020 21:28:52'!
icosahedral
	"Answer the icosahedral group (ismorphic to A5) as a finitely presented group."
	| F |
	F _ FreeGroup new: #(s t).
	^ F / (F !! [:s :t| {s^2. t^3. (s·t)^5}])! !

!Group class methodsFor: 'examples' stamp: 'len 10/26/2020 21:28:52'!
octahedral
	"Answer the octahedral group (ismorphic to S4) as a finitely presented group."
	| F |
	F _ FreeGroup new: #(s t).
	^ F / (F !! [:s :t| {s^2. t^3. (s·t)^4}])! !

!Group class methodsFor: 'examples' stamp: 'len 10/26/2020 21:28:52'!
quaternion
	"Answer the quaternion group as a finitely presented group."
	| F |
	F _ FreeGroup new: #(i j).
	^ F / (F !! [:i :j| {j·i·j·i inverse. i·j·i·j inverse}])! !

!Group class methodsFor: 'examples' stamp: 'len 5/1/2024 09:02:13'!
schnorr: q
	"Answer a Schnorr group of the given prime order q.
	This is a subgroup of the  group of (units of) integers modulo p
	for some prime p (with order p-1)."
	| p r h g F |
	r := 1.
	[(p := q*r + 1) isPrime] whileFalse: [r := r + 1].
	[h := (1 to: p) atRandom.
	(g := h raisedTo: r modulo: p) = 1] whileTrue.
	F := PrimeField new: p.
	^ F units sub: {F !! g}! !

!Group class methodsFor: 'examples' stamp: 'len 10/26/2020 21:28:52'!
symmetric: n
	"Answer the symmetric group on n symbols as a finitely presented group."
	| F relators |
	F _ FreeGroup new: n-1.
	relators _ OrderedCollection new.
	1 to: n-1 do: [:i|
		relators add: (F x: i)^2.
		1 to: n-1 do: [:j| (i-1 = j or: [i+1 = j]) ifFalse: [relators add: ((F x: i) commutator: (F x: j))]].
		i < n-1 ifTrue: [relators add: ((F x: i)·(F x: i+1))^3]].
	^ F / relators! !

!Group class methodsFor: 'examples' stamp: 'len 10/26/2020 21:28:52'!
tetrahedral
	"Answer the tetrahedral group (ismorphic to A4) as a finitely presented group."
	| F |
	F _ FreeGroup new: #(s t).
	^ F / (F !! [:s :t| {s^2. t^3. (s·t)^3}])! !

!Group class methodsFor: 'instance creation' stamp: 'len 7/14/2024 07:43:21'!
elements: anObject
	self assert: self = Group.
	^ self new propertyAt: #elements put: anObject; yourself! !

!AbelianGroup methodsFor: 'as yet unclassified' stamp: 'len 8/26/2024 14:36:42'!
asAbelianGroup
	^ self! !

!AbelianGroup methodsFor: 'as yet unclassified' stamp: 'len 8/29/2024 15:17:39'!
isAbelianGroup
	^ true! !

!AbelianGroup methodsFor: 'as yet unclassified' stamp: 'len 8/26/2024 14:18:54'!
isCommutative
	^ true! !

!AbelianGroup methodsFor: 'as yet unclassified' stamp: 'len 8/26/2024 14:18:39'!
species
	^ AbelianGroup! !

!AbelianGroup methodsFor: 'as yet unclassified' stamp: 'len 8/26/2024 14:19:40'!
zero
	^ self identity! !

!AbelianGroup class methodsFor: 'instance creation' stamp: 'len 7/14/2024 13:30:19'!
elements: anObject
	self assert: self = AbelianGroup.
	^ self new propertyAt: #elements put: anObject; yourself! !

!HomGroup methodsFor: 'accessing' stamp: 'len 6/30/2023 15:19:27'!
codomain
	^ codomain! !

!HomGroup methodsFor: 'accessing' stamp: 'len 6/30/2023 15:19:31'!
domain
	^ domain! !

!HomGroup methodsFor: 'accessing' stamp: 'len 8/19/2024 09:41:08'!
underlyingSet
	^ self propertyAt: #underlyingSet ifAbsentPut: [HomSet from: domain to: codomain]! !

!HomGroup methodsFor: 'comparing' stamp: 'len 12/4/2023 11:10:00'!
= anObject
	^ self class = anObject class and: [domain = anObject domain and: [codomain = anObject codomain]]! !

!HomGroup methodsFor: 'comparing' stamp: 'len 12/4/2023 11:10:19'!
hash
	^ domain hash hashMultiply + codomain hash! !

!HomGroup methodsFor: 'elements' stamp: 'len 12/4/2023 11:07:37'!
adapt: anElement
	^ (super adapt: anElement) ifNil: [domain to: codomain adapting: anElement]! !

!HomGroup methodsFor: 'elements' stamp: 'len 12/4/2023 11:16:36'!
identity
	^ self propertyAt: #identity ifAbsentPut: [self scalar: 0]! !

!HomGroup methodsFor: 'elements' stamp: 'len 12/4/2023 11:09:24'!
images: anArray
	"Answer a morphism defined by images of generators."
	^ domain to: codomain images: anArray! !

!HomGroup methodsFor: 'elements' stamp: 'len 12/4/2023 11:09:33'!
map: aBlock
	^ domain to: codomain map: aBlock! !

!HomGroup methodsFor: 'elements' stamp: 'len 12/4/2023 11:14:29'!
mapWithArguments: aBlock
	^ domain to: codomain mapWithArguments: aBlock! !

!HomGroup methodsFor: 'elements' stamp: 'len 6/30/2023 15:20:39'!
newFrom: anObject
	anObject isEvaluable ifTrue: [^ self map: anObject].
	^ super newFrom: anObject! !

!HomGroup methodsFor: 'elements' stamp: 'len 12/4/2023 11:16:23'!
scalar: anInteger
	^ self map: [:x| x * anInteger]! !

!HomGroup methodsFor: 'printing' stamp: 'len 8/26/2024 14:29:51'!
printOn: aStream
	aStream print: self underlyingSet! !

!HomGroup methodsFor: 'random' stamp: 'len 12/4/2023 11:10:46'!
atRandom: aRandom
	^ domain to: codomain atRandom: aRandom! !

!HomGroup methodsFor: 'random' stamp: 'len 12/4/2023 11:10:53'!
atRandom: aRandom bits: bitSize
	^ domain to: codomain atRandom: aRandom bits: bitSize! !

!HomGroup methodsFor: 'testing' stamp: 'len 12/4/2023 11:11:04'!
includes: anObject
	^ anObject isMorphism and: [anObject domain = domain and: [anObject codomain = codomain]]! !

!HomGroup methodsFor: 'private' stamp: 'len 6/30/2023 15:22:32'!
domain: aDomain codomain: aCodomain
	domain := aDomain.
	codomain := aCodomain! !

!HomGroup class methodsFor: 'instance creation' stamp: 'len 6/30/2023 15:23:15'!
from: aDomain to: aCodomain
	^ self new domain: aDomain codomain: aCodomain! !

!DivisorGroup methodsFor: 'accessing' stamp: 'len 7/25/2022 11:57:29'!
scalars
	^ scalars! !

!DivisorGroup methodsFor: 'accessing' stamp: 'len 7/25/2022 11:57:21'!
space
	^ space! !

!DivisorGroup methodsFor: 'elements' stamp: 'len 11/21/2023 20:15:32'!
adapt: anElement
	((anElement isKindOf: ProjectivePoint) and: [anElement codomain = space])
		ifTrue: [^ Divisor coefficients: (Dictionary new at: anElement put: scalars one; yourself) parent: self].
	"The divisor associated to a rational function is the sum of the order of the rational function at each point:"
	(space functionField includes: anElement)
		ifTrue: [^ self notYetImplemented].
	^ super adapt: anElement! !

!DivisorGroup methodsFor: 'elements' stamp: 'len 6/18/2023 18:38:57'!
identity
	^ Divisor coefficients: Dictionary new parent: self! !

!DivisorGroup methodsFor: 'printing' stamp: 'len 7/25/2022 11:58:39'!
printOn: aStream
	aStream nextPutAll: 'Div'.
	scalars = ℤ ifFalse: [aStream nextPutAll: scalars printString sub].
	aStream nextPut: $(; print: space; nextPut: $)! !

!DivisorGroup methodsFor: 'testing' stamp: 'len 6/18/2023 18:37:36'!
includes: anObject
	^ anObject parent = self! !

!DivisorGroup methodsFor: 'private' stamp: 'len 7/25/2022 12:00:07'!
space: aScheme scalars: aRing
	scalars _ aRing.
	space _ aScheme! !

!DivisorGroup class methodsFor: 'as yet unclassified' stamp: 'len 7/25/2022 11:59:50'!
on: aScheme
	^ self on: aScheme over: ℤ! !

!DivisorGroup class methodsFor: 'as yet unclassified' stamp: 'len 7/25/2022 11:59:31'!
on: aScheme over: aRing
	^ self new space: aScheme scalars: aRing! !

!AutomorphismGroup methodsFor: 'accessing' stamp: 'len 12/4/2023 11:24:14'!
space
	^ space! !

!AutomorphismGroup methodsFor: 'comparing' stamp: 'len 12/4/2023 11:24:06'!
= anObject
	^ self class = anObject class and: [space = anObject space]! !

!AutomorphismGroup methodsFor: 'comparing' stamp: 'len 12/4/2023 11:23:59'!
hash
	^ space hash! !

!AutomorphismGroup methodsFor: 'elements' stamp: 'len 12/4/2023 11:23:30'!
adapt: anElement
	(super adapt: anElement) ifNotNil: [:answer| ^ answer].
	(space endomorphisms adapt: anElement) ifNotNil: [:answer| self assert: answer isIsomorphism. ^ answer].
	^ nil! !

!AutomorphismGroup methodsFor: 'elements' stamp: 'len 12/4/2023 11:23:36'!
identity
	^ space id! !

!AutomorphismGroup methodsFor: 'elements' stamp: 'len 12/4/2023 11:23:42'!
images: anArray
	| answer |
	answer := space endomorphisms images: anArray.
	self assert: answer isIsomorphism.
	^ answer! !

!AutomorphismGroup methodsFor: 'elements' stamp: 'len 12/4/2023 11:23:46'!
map: aBlock
	| answer |
	answer := space endomorphisms map: aBlock.
	self assert: answer isIsomorphism.
	^ answer! !

!AutomorphismGroup methodsFor: 'elements' stamp: 'len 12/4/2023 11:23:50'!
mapWithArguments: aBlock
	| answer |
	answer := space endomorphisms mapWithArguments: aBlock.
	self assert: answer isIsomorphism.
	^ answer! !

!AutomorphismGroup methodsFor: 'enumerating' stamp: 'len 12/4/2023 11:23:19'!
do: aBlock
	space endomorphisms do: [:each| each isIsomorphism ifTrue: [aBlock value: each]]! !

!AutomorphismGroup methodsFor: 'printing' stamp: 'len 12/4/2023 11:23:00'!
printOn: aStream
	aStream nextPutAll: 'Aut('; print: space; nextPut: $)! !

!AutomorphismGroup methodsFor: 'testing' stamp: 'len 12/4/2023 11:22:51'!
includes: anObject
	^ anObject isMorphism and: [anObject domain = space and: [anObject isAutomorphism]]! !

!AutomorphismGroup methodsFor: 'testing' stamp: 'len 12/1/2023 14:08:31'!
isAutomorphisms
	"Answer true if the elements of the receiver are automorphisms of some object X,
	i.e. if the receiver is Aut(X) or a subgroup of it."
	^ true! !

!AutomorphismGroup methodsFor: 'testing' stamp: 'len 12/4/2023 11:22:42'!
isTrivial
	space isGroup ifTrue: [^ space isTrivial or: [space isCyclic and: [space size = 2]]].
	^ super isTrivial! !

!AutomorphismGroup methodsFor: 'private' stamp: 'len 12/4/2023 11:22:25'!
space: aDomain
	space := aDomain! !

!AutomorphismGroup class methodsFor: 'instance creation' stamp: 'len 12/1/2023 14:10:51'!
on: aDomain
	^ self new space: aDomain! !

!FreeGroup methodsFor: 'accessing' stamp: 'len 12/12/2023 18:57:43'!
freeCover
	^ self! !

!FreeGroup methodsFor: 'accessing' stamp: 'len 12/4/2023 11:27:43'!
generators
	^ self propertyAt: #generators ifAbsentPut: ((1 to: rank) collect: [:i| (Word x: i) parent: self])! !

!FreeGroup methodsFor: 'accessing' stamp: 'len 8/2/2020 19:27:29'!
names
	"Answer a list of symbolic names for the generators."
	^ self propertyAt: #names ifAbsent: []! !

!FreeGroup methodsFor: 'accessing' stamp: 'len 5/13/2019 13:01:18'!
names: anArray
	"Set indeterminate names to use when printing words."
	self propertyAt: #names put: anArray! !

!FreeGroup methodsFor: 'accessing' stamp: 'len 6/7/2022 06:26:26'!
presentation
	^ self! !

!FreeGroup methodsFor: 'accessing' stamp: 'len 12/4/2023 11:28:45'!
rank
	^ rank! !

!FreeGroup methodsFor: 'accessing' stamp: 'len 12/12/2023 19:41:00'!
relators
	"Answer the relators of the receiver as FP group."
	^ #()! !

!FreeGroup methodsFor: 'accessing' stamp: 'len 12/4/2023 11:28:57'!
size
	^ rank > 0 ifTrue: [ℕ size] ifFalse: [1]! !

!FreeGroup methodsFor: 'comparing' stamp: 'len 12/4/2023 11:26:57'!
= anObject
	^ self class = anObject class and: [rank = anObject rank]! !

!FreeGroup methodsFor: 'comparing' stamp: 'len 12/4/2023 11:27:50'!
hash
	^ rank hash! !

!FreeGroup methodsFor: 'converting' stamp: 'len 12/6/2023 16:23:20'!
asMonoid
	^ self propertyAt: #asMonoid ifAbsentPut: [FreeMonoid new: self rank]! !

!FreeGroup methodsFor: 'elements' stamp: 'len 6/3/2023 20:28:09'!
\ aWord
	"Answer aWord expressed as a word on the generators."
	^ aWord! !

!FreeGroup methodsFor: 'elements' stamp: 'len 6/19/2022 12:29:07'!
identity
	"Answer the identity element of the receiver."
	^ self propertyAt: #identity ifAbsentPut: [Word empty parent: self]! !

!FreeGroup methodsFor: 'elements' stamp: 'len 7/31/2021 12:27:07'!
syllables: anArray
	^ (Word syllables: anArray) parent: self! !

!FreeGroup methodsFor: 'elements' stamp: 'len 7/31/2021 12:21:06'!
x: anInteger to: anotherInteger
	^ (Word x: anInteger to: anotherInteger) parent: self! !

!FreeGroup methodsFor: 'morphisms' stamp: 'len 10/6/2022 11:36:39'!
coprojection: anIntegerOrList
	| list |
	list _ anIntegerOrList isInteger ifTrue: [{anIntegerOrList}] ifFalse: [anIntegerOrList].
	^ ((self class new: list size) into: self images: (list collect: [:i| self x: i]))
		name: 'ι', anIntegerOrList printString sub! !

!FreeGroup methodsFor: 'morphisms' stamp: 'len 12/4/2023 11:27:38'!
fromAll: anArray
	"Answer the canonical coprojections from the components of anArray to the receiver."
	| i |
	(anArray allSatisfy: [:each| each class = self class]) ifFalse: [^ super fromAll: anArray].
	(anArray sum: [:each| each rank]) = rank ifFalse: [^ super fromAll: anArray].
	i := 1.
	^ anArray collect: [:each| self coprojection: (i to: (i := i + each rank)-1)]! !

!FreeGroup methodsFor: 'morphisms' stamp: 'len 12/4/2023 11:28:38'!
projection: anIntegerOrList
	| list F |
	list := anIntegerOrList isInteger ifTrue: [{anIntegerOrList}] ifFalse: [anIntegerOrList].
	F := self scalars ^ list size.
	^ (self onto: F images: ((1 to: rank) collect: [:i| | j | (j := list indexOf: i) = 0 ifTrue: [F identity] ifFalse: [F x: j]]))
		name: 'π', anIntegerOrList printString sub! !

!FreeGroup methodsFor: 'morphisms' stamp: 'len 12/4/2023 11:29:02'!
toAll: anArray
	"Answer the canonical projections from the receiver to the components of anArray."
	| i |
	(anArray allSatisfy: [:each| each class = self class]) ifFalse: [^ super toAll: anArray].
	(anArray sum: [:each| each rank]) = rank ifFalse: [^ super toAll: anArray].
	i := 1.
	^ anArray collect: [:each| self projection: (i to: (i := i + each rank)-1)]! !

!FreeGroup methodsFor: 'operations' stamp: 'len 12/12/2023 19:31:04'!
* aGroup
	"Answer the free product of the receiver with the argument.
	This is the coproduct in the category of groups."
	| F |
	aGroup isFPGroup ifFalse: [^ super * aGroup].
	(aGroup isKindOf: FreeGroup) ifTrue: [^ self class new: rank + aGroup rank].
	F := self * aGroup freeCover.
	^ F / (aGroup relators apply: (F ⇇ {self. aGroup freeCover}) second)! !

!FreeGroup methodsFor: 'operations' stamp: 'len 6/14/2022 18:10:59'!
/ anObject
	| newRelators answer |
	newRelators _ Set new.
	(self includes: anObject)
		ifTrue: [newRelators add: anObject]
		ifFalse:
			[anObject isCollection
				ifTrue: [anObject do: [:each| newRelators add: self !! each]]
				ifFalse: [^ self notYetImplemented "subgroup?"]].
	answer _ QuotientGroup on: self relators: newRelators.
"	answer addMap: (self onto: answer mapping: [:i| answer x: i])."
	^ answer! !

!FreeGroup methodsFor: 'operations' stamp: 'len 4/20/2024 12:28:37'!
abelianization
	| answer |
	answer := ℤ^rank.
	self addMap: (self to: answer images: answer generators).
	^ answer! !

!FreeGroup methodsFor: 'operations' stamp: 'len 10/27/2020 18:41:39'!
normalClosureOf: aSubset
	^ self shouldNotImplement! !

!FreeGroup methodsFor: 'printing' stamp: 'len 5/29/2023 13:56:25'!
printOn: aStream
	self isTrivial ifTrue: [aStream print: 1. ^ self].
	aStream withAngleBrackets: [:aStream2|
		self generators do: [:each| aStream2 print: each] separatedBy: [aStream2 nextPut: $,]]! !

!FreeGroup methodsFor: 'random' stamp: 'len 12/4/2023 11:27:28'!
atRandom: aRandom bits: bitSize
	| answer |
	answer := self identity.
	bitSize = 0 ifTrue: [^ answer].
	bitSize // rank highBit + 1
		timesRepeat:
			[answer := (self generators atRandom: aRandom)^(#(-1 1) atRandom: aRandom) * answer].
	^ answer! !

!FreeGroup methodsFor: 'testing' stamp: 'len 4/25/2020 10:02:16'!
includes: anObject
	^ anObject parent == self! !

!FreeGroup methodsFor: 'testing' stamp: 'len 12/4/2023 11:28:32'!
isCommutative
	^ rank <= 1! !

!FreeGroup methodsFor: 'testing' stamp: 'len 10/26/2020 21:16:15'!
isFPGroup
	^ true! !

!FreeGroup methodsFor: 'testing' stamp: 'len 7/8/2022 08:48:49'!
isFinitelyGenerated
	^ true! !

!FreeGroup methodsFor: 'testing' stamp: 'len 10/28/2020 08:49:59'!
isNilpotent
	^ self isCommutative! !

!FreeGroup methodsFor: 'testing' stamp: 'len 12/3/2023 14:24:35'!
isOrdered
	^ true! !

!FreeGroup methodsFor: 'testing' stamp: 'len 10/28/2020 08:50:25'!
isSolvable
	^ self isCommutative! !

!FreeGroup methodsFor: 'private' stamp: 'len 12/4/2023 11:28:51'!
rank: anInteger
	rank := anInteger! !

!FreeGroup class methodsFor: 'instance creation' stamp: 'len 5/23/2019 17:11:34'!
new: anIntegerOrCollection
	^ anIntegerOrCollection isInteger
		ifTrue: [self new rank: anIntegerOrCollection] 
		ifFalse: [self new rank: anIntegerOrCollection size; names: anIntegerOrCollection asArray]! !

!ProductGroup methodsFor: 'accessing' stamp: 'len 4/19/2019 07:14:28'!
ambient
	^ self propertyAt: #ambient ifAbsentPut: [(components allSatisfy: [:each| each isAmbient]) ifTrue: [self] ifFalse: [self class components: (components collect: [:each| each ambient])]]! !

!ProductGroup methodsFor: 'accessing' stamp: 'len 2/12/2016 20:00'!
components
	^ components! !

!ProductGroup methodsFor: 'accessing' stamp: 'len 5/26/2024 10:11:01'!
generators
	| generators |
	self propertyAt: #generators ifPresent: [:aCollection| ^ aCollection].
	generators := OrderedCollection new.
	1 to: self arity do: [:i|
		| p |
		p := self projection: i.
		(self at: i) generators do: [:each| generators add: (p value: each)]].
	^ self propertyAt: #generators put: generators asArray! !

!ProductGroup methodsFor: 'accessing' stamp: 'len 2/12/2016 20:10'!
size
	^ components product: [:each| each size]! !

!ProductGroup methodsFor: 'comparing' stamp: 'len 6/15/2022 10:47:47'!
= anObject
	^ (anObject isKindOf: ProductGroup) and: [anObject components = components]! !

!ProductGroup methodsFor: 'comparing' stamp: 'len 2/12/2016 20:05'!
hash
	^ components hash! !

!ProductGroup methodsFor: 'elements' stamp: 'len 4/23/2024 04:45:35'!
compose: anArray
	^ ProductGroupElement components: anArray asArray parent: self! !

!ProductGroup methodsFor: 'elements' stamp: 'len 6/19/2022 12:29:14'!
identity
	"Answer the identity element of the receiver."
	^ self compose: (components collect: [:each| each identity])! !

!ProductGroup methodsFor: 'enumerating' stamp: 'len 5/2/2024 06:43:09'!
do: aBlock
	self asCartesianProduct do: [:each| aBlock value: (self compose: each)]! !

!ProductGroup methodsFor: 'morphisms' stamp: 'len 10/6/2022 11:36:47'!
coprojection: i
	^ ((self at: i) to: self map: [:x| self compose: (components withIndexCollect: [:each :k| k = i ifTrue: [x] ifFalse: [each identity]])]) name: 'ι', i printString sub! !

!ProductGroup methodsFor: 'morphisms' stamp: 'len 9/16/2022 07:54:00'!
projection: i
	^ (self to: (self at: i) map: [:x| x at: i]) name: 'π', i printString sub! !

!ProductGroup methodsFor: 'printing' stamp: 'len 5/23/2020 07:19:05'!
printOn: aStream
	components do: [:each| aStream print: each] separatedBy: [aStream nextPut: $×]! !

!ProductGroup methodsFor: 'random' stamp: 'len 4/23/2024 04:53:28'!
atRandom: aRandom
	^ self compose: (components collect: [:each| each atRandom: aRandom])! !

!ProductGroup methodsFor: 'random' stamp: 'len 4/23/2024 04:55:25'!
atRandom: aRandom bits: bits
	^ self compose: (components collect: [:each| each atRandom: aRandom bits: bits])! !

!ProductGroup methodsFor: 'testing' stamp: 'len 4/25/2020 06:54:01'!
includes: anObject
	^ anObject parent = self! !

!ProductGroup methodsFor: 'testing' stamp: 'len 8/26/2024 17:22:02'!
isCommutative
	^ components allSatisfy: [:each| each isCommutative]! !

!ProductGroup methodsFor: 'testing' stamp: 'len 4/14/2020 21:09:53'!
isCoproduct
	^ true! !

!ProductGroup methodsFor: 'testing' stamp: 'len 4/14/2020 21:09:49'!
isProduct
	^ true! !

!ProductGroup methodsFor: 'private' stamp: 'len 11/5/2016 06:40'!
components: anArray
	components _ anArray! !

!ProductGroup class methodsFor: 'instance creation' stamp: 'len 2/12/2016 20:02'!
components: anArray
	^ self new components: anArray! !

!QuotientGroup methodsFor: 'accessing' stamp: 'len 6/10/2022 11:37:26'!
cover
	^ self propertyAt: #cover! !

!QuotientGroup methodsFor: 'accessing' stamp: 'len 12/12/2023 19:27:38'!
freeCover
	^ self cover freeCover! !

!QuotientGroup methodsFor: 'accessing' stamp: 'len 6/10/2022 11:41:01'!
generators
	^ self propertyAt: #generators ifAbsentPut: [self cover generators collect: [:each| self project: each]]! !

!QuotientGroup methodsFor: 'accessing' stamp: 'len 6/10/2022 11:41:20'!
names
	^ self cover names! !

!QuotientGroup methodsFor: 'accessing' stamp: 'len 6/7/2022 06:26:42'!
presentation
	^ self! !

!QuotientGroup methodsFor: 'accessing' stamp: 'len 6/26/2023 12:55:38'!
relations
	"Answer the relations subgroup, i.e. the normal subgroup by which we quotient."
	^ self propertyAt: #relations ifAbsentPut: [self cover sub: self relators]! !

!QuotientGroup methodsFor: 'accessing' stamp: 'len 10/26/2020 21:04:25'!
relators
	^ self propertyAt: #relators ifAbsent: [self relations generators]! !

!QuotientGroup methodsFor: 'elements' stamp: 'len 6/14/2022 12:54:41'!
\ anElement
	"Answer the argument expressed as a word on the generators."
	self isFPGroup ifTrue: [^ anElement representative].
	^ self notYetImplemented! !

!QuotientGroup methodsFor: 'elements' stamp: 'len 6/19/2022 12:29:17'!
identity
	"Answer the identity element of the receiver."
	^ self project: self cover identity! !

!QuotientGroup methodsFor: 'enumerating' stamp: 'len 6/10/2022 11:40:52'!
do: aBlock
	| visited |
	visited _ Set new.
	self cover do: [:each| | x |
		visited add: (x _ self project: each) ifAbsent: [aBlock value: x]]! !

!QuotientGroup methodsFor: 'morphisms' stamp: 'len 6/1/2024 07:02:40'!
from: aGroup
	aGroup = self cover ifTrue: [^ self projection].
	aGroup ⇢ self cover ifNotNil: [:aMorphism| ^ self projection · aMorphism].
	^ super from: aGroup! !

!QuotientGroup methodsFor: 'morphisms' stamp: 'len 4/23/2024 04:59:14'!
project: anElement
	^ Coset representative: anElement parent: self! !

!QuotientGroup methodsFor: 'morphisms' stamp: 'len 9/16/2022 08:10:04'!
projection
	"Answer the natural projection, or quotient map, or canonical homomorphism from the base group.
	This takes elements from the base group to the corresponding coset in the quotient group."
	^ self propertyAt: #projection ifAbsentPut:
		[(self cover onto: self map: [:each| self project: each])
			name: 'π';
			propertyAt: #kernel put: self relations;
			propertyAt: #image put: self;
			yourself]! !

!QuotientGroup methodsFor: 'operations' stamp: 'len 12/12/2023 19:48:04'!
* aGroup
	"Answer the free product of the receiver with the argument.
	This is the coproduct in the category of groups."
	| F coprojections |
	aGroup isFPGroup ifFalse: [^ super * aGroup].
	F := self cover * aGroup freeCover.
	coprojections := F ⇇ {self cover. aGroup freeCover}.
	^ F / ((self relators apply: coprojections first), (aGroup relators apply: coprojections second))! !

!QuotientGroup methodsFor: 'operations' stamp: 'len 5/8/2023 19:23:32'!
/ anObject
	| newRelators answer |
	newRelators _ Set new addAll: self relators; yourself.
	(self includes: anObject)
		ifTrue: [newRelators add: anObject]
		ifFalse:
			[anObject isCollection
				ifTrue: [newRelators addAll: anObject]
				ifFalse: [^ self notYetImplemented "subgroup?"]].
	^ (answer _ self cover / newRelators)
		addMap: (self onto: answer images: answer generators);
		yourself! !

!QuotientGroup methodsFor: 'printing' stamp: 'len 8/29/2024 15:17:39'!
printOn: aStream
	self generators isEmpty ifTrue: [aStream print: (self isAbelianGroup ifTrue: [0] ifFalse: [1]). ^ self].
	self isFPGroup ifTrue:
		[aStream withAngleBrackets: [:aStream2|
			self generators do: [:each| aStream2 print: each] separatedBy: [aStream2 nextPut: $,].
			self relators isEmpty
				ifFalse:
					[aStream2 nextPutAll: ' | '.
					self relators do: [:each| aStream2 print: each] separatedBy: [aStream2 nextPut: $,]]].
		^ self].
	aStream print: self cover; nextPut: $╱; print: self relations! !

!QuotientGroup methodsFor: 'random' stamp: 'len 6/10/2022 11:40:39'!
atRandom: aRandom bits: bitSize
	^ self project: (self cover atRandom: aRandom bits: bitSize)! !

!QuotientGroup methodsFor: 'testing' stamp: 'len 12/12/2023 20:19:50'!
isCommutative
	self cover isCommutative ifTrue: [^ true].
	self isFPGroup ifTrue: [^ super isCommutative].
	^ self cover commutator ⊆ self relations! !

!QuotientGroup methodsFor: 'testing' stamp: 'len 6/10/2022 11:41:11'!
isCyclic
	^ self cover isCyclic or: [super isCyclic]! !

!QuotientGroup methodsFor: 'testing' stamp: 'len 6/14/2022 12:55:12'!
isFPGroup
	^ self cover isKindOf: FreeGroup! !

!QuotientGroup methodsFor: 'testing' stamp: 'len 6/10/2022 11:41:14'!
isNilpotent
	^ self cover isNilpotent or: [super isNilpotent]! !

!QuotientGroup methodsFor: 'testing' stamp: 'len 12/25/2021 12:32:33'!
isQuotient
	^ true! !

!QuotientGroup methodsFor: 'testing' stamp: 'len 6/10/2022 11:41:17'!
isSolvable
	^ self cover isSolvable or: [super isSolvable]! !

!QuotientGroup methodsFor: 'private' stamp: 'len 6/10/2022 11:37:40'!
cover: aGroup
	self propertyAt: #cover put: aGroup! !

!QuotientGroup methodsFor: 'private' stamp: 'len 2/28/2017 10:15:24'!
relations: aNormalSubgroup
	self propertyAt: #relations put: aNormalSubgroup! !

!QuotientGroup methodsFor: 'private' stamp: 'len 10/26/2020 21:01:48'!
relators: aCollection
	self propertyAt: #relators put: aCollection! !

!QuotientGroup class methodsFor: 'instance creation' stamp: 'len 6/14/2022 18:08:37'!
on: aFreeGroup relators: aCollection
	^ self new cover: aFreeGroup; relators: aCollection! !

!QuotientGroup class methodsFor: 'instance creation' stamp: 'len 6/14/2022 18:12:42'!
relations: aNormalSubgroup
	^ self new cover: aNormalSubgroup ambient; relations: aNormalSubgroup! !

!SemidirectProductGroup methodsFor: 'accessing' stamp: 'len 2/12/2016 06:15'!
action
	^ action! !

!SemidirectProductGroup methodsFor: 'accessing' stamp: 'len 2/16/2016 07:30'!
arity
	^ 2! !

!SemidirectProductGroup methodsFor: 'accessing' stamp: 'len 2/12/2016 06:16'!
left
	^ left! !

!SemidirectProductGroup methodsFor: 'accessing' stamp: 'len 2/12/2016 06:16'!
right
	^ right! !

!SemidirectProductGroup methodsFor: 'accessing' stamp: 'len 2/12/2016 06:55'!
size
	^ left size * right size! !

!SemidirectProductGroup methodsFor: 'elements' stamp: 'len 6/19/2022 12:29:46'!
identity
	"Answer the identity element of the receiver."
	^ self project: {left identity. right identity}! !

!SemidirectProductGroup methodsFor: 'enumerating' stamp: 'len 2/12/2016 06:57'!
do: aBlock
	left do: [:g| right do: [:h| aBlock value: (self project: {g.h})]]! !

!SemidirectProductGroup methodsFor: 'morphisms' stamp: 'len 4/23/2024 04:51:33'!
project: anArray
	"Project a cartesian product of two elements to their semidirect product."
	^ SemidirectProductElement left: (anArray at: 1) right: (anArray at: 2) parent: self! !

!SemidirectProductGroup methodsFor: 'morphisms' stamp: 'len 9/16/2022 07:54:21'!
projection
	"Answer the projection from the cartesian product of two groups to their semidirect product."
	^ ((left, right) to: self map: [:each| self project: each]) name: 'π'! !

!SemidirectProductGroup methodsFor: 'printing' stamp: 'len 4/21/2016 00:16'!
printOn: aStream
	aStream print: left; nextPutAll: ' X| '; print: right! !

!SemidirectProductGroup methodsFor: 'random' stamp: 'len 4/23/2024 04:53:58'!
atRandom: aRandom
	^ self project: {left atRandom: aRandom. right atRandom: aRandom}! !

!SemidirectProductGroup methodsFor: 'random' stamp: 'len 4/23/2024 04:54:23'!
atRandom: aRandom bits: bitSize
	^ self project: {left atRandom: aRandom bits: bitSize. right atRandom: aRandom bits: bitSize}! !

!SemidirectProductGroup methodsFor: 'private' stamp: 'len 2/12/2016 06:17'!
action: anAction
	action _ anAction! !

!SemidirectProductGroup methodsFor: 'private' stamp: 'len 2/12/2016 06:17'!
left: aGroup
	left _ aGroup! !

!SemidirectProductGroup methodsFor: 'private' stamp: 'len 2/12/2016 06:17'!
right: aGroup
	right _ aGroup! !

!SemidirectProductGroup class methodsFor: 'instance creation' stamp: 'len 2/12/2016 06:16'!
left: aGroup right: anotherGroup action: anAction
	^ self new left: aGroup; right: anotherGroup; action: anAction! !

!PermutationGroup methodsFor: 'accessing' stamp: 'len 11/29/2023 13:38:32'!
action
	"Answer the natural action that sends (σ, x) to σ(x)."
	^ self on: self space action: [:σ :x| σ value: x]! !

!PermutationGroup methodsFor: 'accessing' stamp: 'len 2/16/2016 05:48'!
degree
	^ self space size! !

!PermutationGroup methodsFor: 'accessing' stamp: 'len 5/1/2024 10:51:23'!
size
	"Use Schreier-Sims algorithm to compute the order of the group."
	| G answer |
	self propertyAt: #size ifPresent: [:anInteger| ^ anInteger].
	self propertyAt: #elements ifPresent: [:aCollection| ^ aCollection size].
	G := self.
	answer := 1.
	self space do: [:b| | tree |
		G isTrivial ifTrue: [^ self propertyAt: #size put: answer].
		tree := SchreierTree root: b generators: G generators action: G action.
		answer := answer * tree orbit size.
		G := tree stabilizer].
	self halt "this should never be reached"! !

!PermutationGroup methodsFor: 'accessing' stamp: 'len 5/18/2018 19:01:32'!
space
	^ self ambient space! !

!PermutationGroup methodsFor: 'comparing' stamp: 'len 4/1/2024 14:20:04'!
= anObject
	self == anObject ifTrue: [^ true].
	((anObject isKindOf: PermutationGroup) and: [self space = anObject space]) ifFalse: [^ false].
	self generators asSet = anObject generators asSet ifTrue: [^ true].
	self size = anObject size ifFalse: [^ false].
	anObject generators ifNotNil: [:aCollection| ^ aCollection allSatisfy: [:each| self contains: each]].
	self generators ifNotNil: [:aCollection| ^ aCollection allSatisfy: [:each| anObject contains: each]].
	^ super = anObject! !

!PermutationGroup methodsFor: 'comparing' stamp: 'len 12/10/2023 10:36:24'!
⊆ aGroup
	"Answer true if the receiver is a subgroup of the argument."
	(aGroup isKindOf: SymmetricGroup) ifTrue: [^ self space ⊆ aGroup space].
	^ super ⊆ aGroup! !

!PermutationGroup methodsFor: 'converting' stamp: 'len 11/23/2022 21:24:28'!
asLinearGroup
	"Return a matrix group isomorphic to the receiver.
	Assume the space of the receiver is an interval (1 to: n)."
	| M generators |
	M _ (ℚ^self degree) endomorphisms.
	generators _ self generators collect: [:g| M fill: [:i :j| (g at: i) = j ifTrue: [1] ifFalse: [0]]].
	^ LinearGroup generators: generators! !

!PermutationGroup methodsFor: 'operations' stamp: 'len 12/11/2023 19:47:51'!
× aGroup
	"Answer the direct product of the receiver and the argument constructed as a permutation group."
	| S n m G₁ G₂ answer |
	(aGroup isKindOf: PermutationGroup) ifFalse: [^ super × aGroup].
	n := self degree.
	m := aGroup degree.
	S := SymmetricGroup new: n + m.
	G₁ := self generators collect: [:g| S !! (g asArray, (n+1 to: n+m))].
	G₂ := aGroup generators collect: [:g| S !! ((1 to: n), (g asArray collect: [:i| i+n]))].
	^ (answer := S sub: G₁, G₂) "<- assumes the order of the generators is kept"
		addCoprojections:
			{self into: answer images: G₁.
			aGroup into: answer images: G₂};
		addProjections:
			{answer onto: self images: self generators, ((1 to: m) collect: [:i| self identity]).
			answer onto: aGroup images: ((1 to: n) collect: [:i| aGroup identity]), aGroup generators};
		yourself! !

!PermutationGroup methodsFor: 'operations' stamp: 'len 6/21/2023 14:57:01'!
orderOf: aPermutation
	aPermutation isIdentity ifTrue: [^ 1].
	^ aPermutation cycles inject: 1 into: [:last :each| last lcm: each size]! !

!PermutationGroup methodsFor: 'operations' stamp: 'len 5/26/2019 11:26:50'!
reduced
	"Answer a permutation group isomorphic to the receiver but acting on a smaller space (if possible)."
"	support _ Set new.
	self generators do: [:each| support add: each support].
"
	self notYetImplemented! !

!PermutationGroup methodsFor: 'testing' stamp: 'len 12/10/2023 11:36:08'!
contains: aPermutation
	self flag: #fixme. "bug in SchreierSims"
	true ifTrue: [^ super contains: aPermutation].
	"aPermutation isIdentity ifTrue: [^ true]."
	(self generators includes: aPermutation) ifTrue: [^ true].
	^ self schreierSims contains: aPermutation! !

!PermutationGroup methodsFor: 'testing' stamp: 'len 12/10/2023 11:20:51'!
includes: anObject
	^ (self ambient includes: anObject) and: [self contains: anObject]! !

!PermutationGroup methodsFor: 'testing' stamp: 'len 12/1/2023 14:09:23'!
isAutomorphisms
	"Answer true if the elements of the receiver are automorphisms of some object X,
	i.e. if the receiver is Aut(X) or a subgroup of it."
	^ true! !

!PermutationGroup methodsFor: 'testing' stamp: 'len 12/6/2023 11:05:44'!
isFinite
	^ true! !

!PermutationGroup methodsFor: 'testing' stamp: 'len 7/8/2022 08:49:26'!
isFinitelyGenerated
	^ true! !

!PermutationGroup methodsFor: 'testing' stamp: 'len 12/3/2023 13:59:51'!
isOrdered
	^ true! !

!PermutationGroup methodsFor: 'testing' stamp: 'len 2/1/2018 23:13:17'!
isStandard
	"Answer true if the domain of the receiver is an interval [1..n]."
	^ self ambient isStandard! !

!PermutationGroup methodsFor: 'testing' stamp: 'len 5/25/2019 04:47:19'!
isSubgroupOfAn
	"Monte Carlo test."
	| random |
	self flag: #fix.
	self isTransitive ifFalse: [^ false].
	random _ Random new.
	20 timesRepeat: [(self atRandom: random) isPurple ifTrue: [^ true]].
	^ false! !

!PermutationGroup methodsFor: 'private' stamp: 'len 12/10/2023 11:22:01'!
schreierSims
	^ self propertyAt: #schreierSims ifAbsentPut: [SchreierSims new action: self action]! !

!PermutationGroup methodsFor: 'private' stamp: 'len 3/4/2016 20:36'!
species
	^ PermutationGroup! !

!PermutationGroup class methodsFor: 'examples' stamp: 'len 2/1/2018 23:25:24'!
Co3
	"Conway group Co3. This group has order 495766656000."
	| x y |
	x _ #(245 42 112 15 131 7 188 75 132 10 11 187 186 265 22 159 256 43 101 123 134 4 32 209 238 35 45 235 126 5 19 60 66 80 154 251 117 206 71 118 93 87 167 271 221 261 182 155 47 230 172 236 109 191 76 156 73 116 147 23 127 231 38 53 122 210 24 68 86 255 196 139 149 21 111 203 252 72 262 114 214 9 181 174 85 95 2 250 257 243 90 158 170 148 69 105 249 263 16 54 31 115 51 104 125 219 92 46 64 204 8 266 225 34 175 145 161 180 237 241 224 169 269 12 96 129 189 190 29 17 30 82 143 74 168 13 227 217 78 258 220 178 228 146 58 254 273 215 57 106 77 110 50 26 248 260 274 107 99 253 37 25 272 44 52 119 18 201 65 41 233 103 246 200 102 160 198 207 157 40 223 49 267 79 1 136 124 6 61 268 100 70 98 171 121 39 62 211 208 84 135 97 55 152 141 63 142 259 67 33 177 173 14 242 94 113 240 264 150 205 27 183 83 195 216 163 247 133 36 153 197 140 194 120 270 165 166 162 218 138 234 81 91 89 185 212 137 48 202 276 229 151 176 144 192 130 244 232 199 56 108 184 193 239 213 3 222 128 20 28 164 226 59 179 275 88).
	y _ #(204 203 33 236 5 172 77 76 47 146 133 224 229 53 84 16 223 228 130 131 252 190 13 263 242 10 32 196 199 65 246 209 40 99 241 198 269 251 75 118 176 271 183 116 197 238 22 29 178 26 174 129 2 153 272 257 41 12 59 20 27 175 106 159 218 259 137 258 261 164 262 189 45 177 260 85 25 15 226 96 24 1 274 148 264 132 48 117 36 60 171 201 101 253 95 120 142 213 165 51 115 44 103 167 243 66 141 108 88 97 276 30 139 222 166 173 231 3 73 239 56 170 82 162 163 207 145 128 52 104 90 216 220 155 74 237 28 4 113 273 230 270 248 180 206 50 250 78 127 150 54 232 217 121 69 156 6 125 210 86 89 46 184 211 265 93 19 138 23 126 43 188 102 244 219 192 256 83 58 144 181 187 91 158 205 235 147 157 114 9 152 57 39 64 143 67 119 161 87 200 111 79 14 123 21 149 122 191 61 194 266 225 31 81 62 160 151 112 215 254 234 72 17 179 105 267 227 18 169 249 109 208 275 68 233 168 55 124 80 240 35 7 212 100 245 98 195 247 107 182 42 185 94 11 255 135 154 221 63 193 134 71 214 8 34 70 202 268 37 110 38 136 140 49 186 92).
	^ PermutationGroup new: 276 generators: {x. y}! !

!PermutationGroup class methodsFor: 'examples' stamp: 'len 2/1/2018 23:25:36'!
J1
	"Janko group J1. This group has order 175560."
	| x y |
	x _ #(262 107 21 213 191 22 133 234 232 151 139 176 202 253 222 16 195 206 68 55 3 6 179 217 216 256 87 70 131 44 105 170 77 104 198 137 243 56 124 223 134 42 174 30 45 51 128 94 250 264 46 183 231 115 20 38 85 233 261 95 235 177 249 91 247 155 67 19 219 28 237 211 84 192 130 251 33 78 260 112 193 156 242 73 57 238 27 143 168 148 64 119 212 48 60 150 199 140 189 180 147 111 159 34 31 162 2 194 166 200 102 80 120 141 54 182 181 225 92 113 254 125 146 39 122 208 221 47 210 75 29 255 7 41 135 175 36 207 11 98 114 240 88 172 185 123 101 90 224 96 10 169 241 190 66 82 214 161 103 236 158 106 239 229 230 109 188 89 152 32 258 144 186 43 136 12 62 245 23 100 117 116 52 205 145 173 228 167 99 154 5 74 81 108 17 196 203 35 97 110 252 13 197 204 184 18 138 126 248 129 72 93 4 157 259 25 24 246 69 227 127 15 40 149 118 226 220 187 164 165 53 9 58 8 61 160 71 86 163 142 153 83 37 244 178 218 65 209 63 49 76 201 14 121 132 26 263 171 215 79 59 1 257 50 266 265).
	y _ #(146 132 3 156 242 107 125 245 174 241 264 248 36 116 47 178 170 197 233 121 1 228 48 201 15 136 212 6 175 77 237 30 226 31 129 44 161 232 219 78 139 9 211 13 222 97 25 173 70 153 186 29 203 35 169 140 260 91 199 108 208 206 11 55 103 65 95 73 151 131 41 221 225 18 143 7 32 159 217 93 181 2 258 163 154 182 38 133 117 33 243 191 122 27 205 20 135 98 229 138 61 194 66 104 149 62 28 164 123 17 137 16 69 37 238 128 247 57 167 134 96 80 193 185 76 83 218 14 54 8 49 82 215 189 46 190 183 188 71 230 231 239 202 224 158 21 119 214 184 250 113 72 200 213 22 166 102 220 40 92 114 257 177 60 179 4 147 168 64 110 171 148 23 42 52 195 84 112 246 19 252 196 111 105 265 209 24 100 120 26 160 39 109 157 266 86 74 204 227 50 187 75 216 207 67 106 198 101 51 141 251 94 85 172 88 53 254 261 192 145 152 240 262 249 68 90 59 155 263 56 210 87 180 12 115 142 34 235 236 45 244 253 58 10 130 165 89 234 144 259 43 81 5 79 223 162 256 126 150 118 127 255 99 63 124 176).
	^ PermutationGroup new: 266 generators: {x. y}! !

!PermutationGroup class methodsFor: 'examples' stamp: 'len 2/1/2018 23:27:01'!
M11
	"The Mathieu group on 11 points. With order 7920, this is the smallest of the 26 sporadic simple groups."
	"ALTERNATIVELY: #((1 2 3 4 5 6 7 8 9 10 11)), #((3 7 11 8) (4 10 5 6)).
	"
	^ self new: 11 generators: {#((1 10) (2 8) (3 11) (5 7)). #((1 4 7 6) (2 11 10 9))}! !

!PermutationGroup class methodsFor: 'examples' stamp: 'len 2/1/2018 23:27:42'!
M12
	"The Mathieu group on 12 points, the second smallest of the 26 sporadic simple groups, with order 95040."
	^ self new: 12 generators: {#((1 2 3 4 5 6 7 8 9 10 11)). #((3 7 11 8) (4 10 5 6)). #((1 12) (2 11) (3 6) (4 8) (5 9) (7 10))}! !

!PermutationGroup class methodsFor: 'examples' stamp: 'len 2/1/2018 23:28:00'!
McL
	"McLaughlin group. This group has order 898128000."
	| x y |
	x _ #(191 182 3 81 55 60 7 66 272 177 192 163 13 242 133 107 17 267 108 218 198 185 211 82 204 195 132 253 207 59 179 154 264 152 92 189 217 197 85 156 41 184 102 50 216 99 181 48 199 44 111 52 158 236 5 210 57 103 30 6 263 62 119 138 127 8 105 137 69 125 144 219 261 74 175 76 269 237 268 80 4 24 232 256 39 104 95 88 234 233 140 35 93 149 87 96 173 160 46 112 123 43 58 86 67 221 16 19 131 176 51 100 262 257 201 116 260 238 63 275 214 225 101 246 70 170 65 128 141 130 109 27 15 196 167 136 68 64 139 91 129 235 224 71 205 249 147 226 94 243 151 34 193 32 228 40 157 53 159 98 231 162 12 215 180 166 135 222 270 126 241 259 97 212 75 110 10 188 31 165 47 2 266 42 22 203 187 178 36 250 1 11 153 194 26 134 38 21 49 200 115 247 186 25 145 206 29 255 251 56 23 174 252 121 164 45 37 20 72 220 106 168 271 143 122 148 274 155 229 240 161 83 90 89 142 54 78 118 254 230 171 14 150 244 258 124 202 248 146 190 209 213 28 239 208 84 114 245 172 117 73 113 61 33 273 183 18 79 77 169 223 9 265 227 120).
	y _ #(24 28 67 168 118 274 98 209 266 271 247 13 71 7 218 170 100 26 223 128 264 116 179 204 40 198 64 272 56 132 255 148 61 241 89 239 54 20 126 177 35 248 139 172 234 214 140 55 134 213 22 107 101 99 113 135 221 57 252 84 163 47 94 162 171 192 142 195 167 145 10 152 14 206 73 91 17 2 245 203 63 205 38 188 191 215 115 52 82 227 180 155 169 173 181 265 250 75 249 4 51 207 156 70 267 273 262 256 97 66 117 76 220 49 158 53 105 19 44 144 269 127 141 185 119 189 102 159 58 50 225 42 164 32 68 230 79 121 193 268 259 31 106 96 9 30 184 114 143 103 150 197 125 186 1 160 147 178 83 151 120 21 90 196 78 59 190 77 110 182 16 153 210 62 200 37 85 240 244 238 34 65 36 108 18 219 251 208 136 46 25 93 8 236 29 15 217 124 111 123 60 130 23 92 41 154 246 201 43 81 5 45 224 69 231 166 254 133 74 235 261 232 211 202 86 88 33 237 228 39 131 212 95 222 48 187 253 112 275 87 233 149 263 80 6 122 138 146 176 243 258 260 270 72 3 157 183 194 175 216 129 226 109 27 161 104 199 174 11 229 12 165 242 137 257).
	^ PermutationGroup new: 275 generators: {x. y}! !

!PermutationGroup class methodsFor: 'examples' stamp: 'len 5/15/2019 01:39:38'!
cyclic: n
	"Answer the cyclic group of order n as a permutation group."
	^ self new: n generators: {{(1 to: n)}}! !

!PermutationGroup class methodsFor: 'examples' stamp: 'len 6/26/2023 12:55:50'!
dihedral: order
	"Answer the dihedral group of order 2n as a permutation group."
	| n G s r |
	order even ifFalse: [self error: 'order should be even'].
	n := order // 2.
	G := SymmetricGroup new: n.
	r := G !! {(1 to: n)}.
	s := G !! [:i| n - i + 1].
	^ G sub: {s. r}! !

!PermutationGroup class methodsFor: 'examples' stamp: 'len 2/1/2018 23:28:37'!
hessian
	"The Hessian group, a finite group of order 216 introduced by Jordan and named after Otto Hesse."
	^ self new: 9 generators: {#((1 2 4) (5 6 8) (3 9 7)). #((4 5 6) (7 9 8))}! !

!PermutationGroup class methodsFor: 'examples' stamp: 'len 2/1/2018 23:29:18'!
klein
	"The Klein four-group (or Vierergruppe) as a permutation group."
	^ self new: 4 generators: {#(2 1 4 3). #(3 4 1 2) ". #(4 3 2 1)"}! !

!PermutationGroup class methodsFor: 'instance creation' stamp: 'len 6/26/2023 12:55:55'!
new: n generators: aCollection
	^ (SymmetricGroup new: n) sub: aCollection! !

!PermutationGroup class methodsFor: 'instance creation' stamp: 'len 6/26/2023 12:55:59'!
on: aCollection generators: anotherCollection
	^ (SymmetricGroup on: aCollection) sub: anotherCollection! !

!AlternatingGroup methodsFor: 'accessing' stamp: 'len 5/26/2024 10:09:35'!
generators
	^ self propertyAt: #generators ifAbsentPut: [(1 to: self degree - 2) collect: [:i| self ambient cycle: {i. i+1. i+2}]]! !

!AlternatingGroup methodsFor: 'accessing' stamp: 'len 2/16/2016 05:49'!
size
	^ self degree factorial / 2! !

!AlternatingGroup methodsFor: 'enumerating' stamp: 'len 1/31/2018 21:16:14'!
do: aBlock
	self ambient do: [:each| each even ifTrue: [aBlock value: each]]! !

!AlternatingGroup methodsFor: 'printing' stamp: 'len 8/7/2022 10:40:46'!
printOn: aStream
	self isStandard
		ifTrue: [aStream nextPutAll: 'A', self degree printString sub]
		ifFalse: [aStream nextPutAll: 'Alt('; print: self space; nextPut: $)]! !

!AlternatingGroup methodsFor: 'random' stamp: 'len 6/28/2016 08:48'!
atRandom: aRandom bits: bitSize
	| S answer |
	S _ self ambient.
	[(answer _ S atRandom: aRandom bits: bitSize) even] whileFalse.
	^ answer! !

!AlternatingGroup methodsFor: 'testing' stamp: 'len 12/13/2016 07:31:33'!
contains: aPermutation
	"Answer true if the receiver contains the given element of its ambient."
	^ aPermutation even! !

!AlternatingGroup methodsFor: 'testing' stamp: 'len 5/29/2019 04:12:09'!
isSimple
	"A group is 'simple' if the only normal subgroups are the trivial group and itself."
	^ self degree >= 5! !

!AlternatingGroup class methodsFor: 'instance creation' stamp: 'len 2/1/2018 23:51:38'!
new: anInteger
	^ self new ambient: (SymmetricGroup new: anInteger)! !

!AlternatingGroup class methodsFor: 'instance creation' stamp: 'len 2/1/2018 23:51:52'!
on: aCollection
	^ self new ambient: (SymmetricGroup on: aCollection)! !

!SymmetricGroup methodsFor: 'accessing' stamp: 'len 4/25/2020 08:55:49'!
alternatingSubgroup
	^ AlternatingGroup new ambient: self! !

!SymmetricGroup methodsFor: 'accessing' stamp: 'len 6/24/2016 08:44'!
ambient
	^ self! !

!SymmetricGroup methodsFor: 'accessing' stamp: 'len 12/18/2023 10:41:05'!
degree
	^ degree! !

!SymmetricGroup methodsFor: 'accessing' stamp: 'len 12/18/2023 15:54:51'!
freeCover
	^ self propertyAt: #freeCover ifAbsentPut: [FreeGroup new: degree - 1 "see >>computeGenerators"]! !

!SymmetricGroup methodsFor: 'accessing' stamp: 'len 5/26/2024 10:10:19'!
generators
	degree > 1 ifFalse: [^ #()].
	^ self propertyAt: #generators ifAbsentPut: [(2 to: degree) collect: [:i| self transposing: 1 with: i]]

"alternatively: Coxeter generators, the set of (i,i+1) all the adjacent transpositions"! !

!SymmetricGroup methodsFor: 'accessing' stamp: 'len 12/18/2023 15:55:40'!
size
	^ degree factorial! !

!SymmetricGroup methodsFor: 'accessing' stamp: 'len 12/18/2023 10:58:22'!
space
	^ self propertyAt: #space! !

!SymmetricGroup methodsFor: 'comparing' stamp: 'len 4/25/2020 07:43:59'!
= anObject
	(anObject isKindOf: SymmetricGroup) ifFalse: [^ super = anObject].
	^ self space = anObject space! !

!SymmetricGroup methodsFor: 'elements' stamp: 'len 12/12/2023 20:24:08'!
\ aPermutation
	"Answer aPermutation expressed as a word on the generators."
	| F f |
	F := self freeCover.
	f := F identity.
	aPermutation transpositions do: [:each|
		| i j g |
		i := each aChange.
		j := each at: i.
		i > j ifTrue: [| t | t := i. i := j. j := t].
		g := i = 1 ifTrue: [F x: j-1] ifFalse: [(F x: i-1) * (F x: j-1) * (F x: i-1)].
		f := f * g].
	^ F syllables: (f syllables collect: [:each| Association key: each key value: each value \\ 2])! !

!SymmetricGroup methodsFor: 'elements' stamp: 'len 12/18/2023 15:54:05'!
cycle: anArray
	| images first last |
	anArray size > 1 ifFalse: [^ self identity].
	images := (1 to: degree) asArray.
	anArray do: [:i|
		first isNil
			ifTrue: [first := i]
			ifFalse: [images at: last put: i].
		last := i].
	images at: last put: first.
	^ self images: images! !

!SymmetricGroup methodsFor: 'elements' stamp: 'len 12/7/2023 17:01:11'!
cycles: anArray
	^ anArray inject: self identity into: [:last :each| last * (self cycle: each)]! !

!SymmetricGroup methodsFor: 'elements' stamp: 'len 12/18/2023 15:55:00'!
identity
	"Answer the identity element of the receiver."
	^ self propertyAt: #identity ifAbsentPut: [self images: (1 to: degree)]! !

!SymmetricGroup methodsFor: 'elements' stamp: 'len 12/18/2023 11:39:17'!
images: anArray
	^ Permutation
		images: (degree < 16rFF ifTrue: [anArray asByteArray] ifFalse: [anArray asWordArray])
		parent: self! !

!SymmetricGroup methodsFor: 'elements' stamp: 'len 9/16/2022 07:50:45'!
map: aBlock
	^ self images: (self indexToSpace collect: [:each| self spaceToIndex at: (aBlock value: each)])! !

!SymmetricGroup methodsFor: 'elements' stamp: 'len 5/8/2024 09:45:37'!
newFrom: anObject
	anObject isEvaluable ifTrue: [^ self map: anObject].
	anObject isSequenceable ifFalse: [^ super newFrom: anObject].
	(anObject allSatisfy: [:each| each isSequenceable and: [each allSatisfy: [:other| self space includes: other]]]) "cycles"
		ifTrue: [^ self cycles: anObject].
	(anObject allSatisfy: [:each| self space includes: each])
		ifTrue: [^ self images: (anObject asArray collect: [:each| self spaceToIndex at: each])].
	^ super newFrom: anObject! !

!SymmetricGroup methodsFor: 'elements' stamp: 'len 12/18/2023 11:47:36'!
transposing: anInteger with: anotherInteger
	"Answer the tranposition of the two given points (given by their indices)."
	^ self cycle: {anInteger. anotherInteger}! !

!SymmetricGroup methodsFor: 'enumerating' stamp: 'len 12/18/2023 15:56:23'!
do: aBlock
	self isTrivial ifTrue: [aBlock value: self identity. ^ self].
	(1 to: degree) permutationsDo: [:each| aBlock value: (self images: each copy)]! !

!SymmetricGroup methodsFor: 'operations' stamp: 'len 4/25/2020 08:57:00'!
commutator
	^ self alternatingSubgroup! !

!SymmetricGroup methodsFor: 'printing' stamp: 'len 12/18/2023 15:55:35'!
printOn: aStream
	self isStandard
		ifTrue: [aStream nextPutAll: 'S', degree printString sub]
		ifFalse: [aStream nextPutAll: 'Sym('; print: self space; nextPut: $)]! !

!SymmetricGroup methodsFor: 'random' stamp: 'len 12/18/2023 15:53:40'!
atRandom: aRandom
	^ self images: ((1 to: degree) asArray shuffledBy: aRandom)! !

!SymmetricGroup methodsFor: 'random' stamp: 'len 4/19/2016 22:45'!
atRandom: aRandom bits: bits
	^ self atRandom: aRandom! !

!SymmetricGroup methodsFor: 'testing' stamp: 'len 12/13/2016 07:31:06'!
contains: aPermutation
	"Answer true if the receiver contains the given element of its ambient."
	^ true! !

!SymmetricGroup methodsFor: 'testing' stamp: 'len 4/22/2020 06:36:05'!
includes: anObject
	^ anObject parent == self! !

!SymmetricGroup methodsFor: 'testing' stamp: 'len 12/18/2023 15:55:13'!
isAlmostSimple
	^ degree >= 5! !

!SymmetricGroup methodsFor: 'testing' stamp: 'len 5/8/2024 09:41:48'!
isStandard
	"Answer true if the domain of the receiver is the interval [1..n]."
	^ self propertyAt: #isStandard ifAbsentPut: [self spaceToIndex isInterval and: [self spaceToIndex isStandard]]! !

!SymmetricGroup methodsFor: 'testing' stamp: 'len 12/18/2023 15:55:22'!
isTrivial
	^ degree <= 1! !

!SymmetricGroup methodsFor: 'private' stamp: 'len 7/24/2024 08:40:34'!
degree: anInteger
	"Initialize the receiver as the group of permutations of the elements of the interval [1..n]."
	| Ω |
	degree := anInteger.
	Ω := 1 to: anInteger.
	self propertyAt: #space put: Ω asSetObject; propertyAt: #spaceToIndex put: Ω; propertyAt: #indexToSpace put: Ω! !

!SymmetricGroup methodsFor: 'private' stamp: 'len 12/18/2023 11:04:39'!
indexToSpace
	^ self propertyAt: #indexToSpace! !

!SymmetricGroup methodsFor: 'private' stamp: 'len 7/24/2024 08:40:34'!
space: aCollection
	"Initialize the receiver as the group of permutations of the elements of aCollection, assuming no repetitions."
	| indexToSpace spaceToIndex |
	((aCollection isKindOf: Interval) and: [aCollection isStandard])
		ifTrue: [^ self degree: aCollection size].
	degree := aCollection size.
	indexToSpace := aCollection "asSet" asArray.
	spaceToIndex := Dictionary new: degree.
	1 to: degree do: [:i| spaceToIndex at: (indexToSpace at: i) put: i].
	self propertyAt: #space put: aCollection asSetObject; propertyAt: #indexToSpace put: indexToSpace; propertyAt: #spaceToIndex put: spaceToIndex! !

!SymmetricGroup methodsFor: 'private' stamp: 'len 12/18/2023 11:04:25'!
spaceToIndex
	^ self propertyAt: #spaceToIndex! !

!SymmetricGroup class methodsFor: 'instance creation' stamp: 'len 5/1/2019 02:12:05'!
new: anInteger
	^ self new degree: anInteger! !

!SymmetricGroup class methodsFor: 'instance creation' stamp: 'len 12/18/2023 10:55:06'!
on: aCollection
	^ self new space: aCollection! !

!LinearGroup methodsFor: 'accessing' stamp: 'len 11/29/2023 13:39:06'!
action
	"Answer the natural action that sends (f, x) to f(x)."
	^ self on: self space action: [:f :x| f value: x]! !

!LinearGroup methodsFor: 'accessing' stamp: 'len 9/25/2018 17:07:47'!
degree
	^ self space rank! !

!LinearGroup methodsFor: 'accessing' stamp: 'len 11/29/2023 13:40:10'!
polynomialAction
	"Answer the action of the receiver on the polynomial ring K[x₁...xₙ]."
	| R X |
	R := self space coordinateRing.
	X := R !!!! R generators.
	^ self on: R action: [:a :f| f value: (a asMatrix over: R) * X]! !

!LinearGroup methodsFor: 'accessing' stamp: 'len 9/25/2018 17:07:38'!
scalars
	^ self space scalars! !

!LinearGroup methodsFor: 'accessing' stamp: 'len 6/7/2020 06:24:21'!
space
	^ self ambient space! !

!LinearGroup methodsFor: 'comparing' stamp: 'len 4/1/2024 14:20:13'!
= anObject
	self == anObject ifTrue: [^ true].
	((anObject isKindOf: LinearGroup) and: [self space = anObject space]) ifFalse: [^ false].
	self generators asSet = anObject generators asSet ifTrue: [^ true].
	self size = anObject size ifFalse: [^ false].
	anObject generators ifNotNil: [:aCollection| ^ aCollection allSatisfy: [:each| self contains: each]].
	self generators ifNotNil: [:aCollection| ^ aCollection allSatisfy: [:each| anObject contains: each]].
	^ super = anObject! !

!LinearGroup methodsFor: 'operations' stamp: 'len 10/11/2022 10:54:40'!
hilbertSeries
	"Answer the Hilbert series of the invariant ring of the receiver.
	This is the sum of dim(S_d ^G z^d for d>=0 (by Molien's formula, 1897), i.e. it counts the homogeneous polynomials of a given degree d that are invariants for the group."
	| order R |
	order _ self size.
	R _ self scalars polynomials fractions.
	^ (self sum: [:g| (R !! g characteristicPolynomial) reciprocal]) * (self scalars !! order) inverse! !

!LinearGroup methodsFor: 'operations' stamp: 'len 9/16/2022 07:54:07'!
reynolds
	"Answer the Reynolds operator. Properties:
	- K-linear map S -> S^G;
	- restricts to the identity on S^G;
	- it's an S^G-module homomorphisms: R(p*q) = p*R(q) for all invariants p in S^G."
	| order action |
	order _ self size.
	action _ self polynomialAction.
	^ self space coordinateRing to: self invariantsRing map: [:p| (self sum: [:g| action value: {g. p}]) / order]! !

!LinearGroup methodsFor: 'printing' stamp: 'len 3/3/2020 16:11:52'!
printOn: aStream
	self shortName isNil ifTrue: [^ super printOn: aStream].
	aStream isText
		ifTrue:
			[aStream nextPutAll: self shortName; nextPutAll: self degree printString sub; nextPut: $(; print: self scalars; nextPut: $)]
		ifFalse:
			[aStream nextPutAll: self shortName; nextPut: $(; print: self scalars; nextPut: $,; print: self degree; nextPut: $)]! !

!LinearGroup methodsFor: 'printing' stamp: 'len 12/8/2016 08:58:51'!
shortName
	^ nil! !

!LinearGroup methodsFor: 'testing' stamp: 'len 9/27/2018 21:01:22'!
includes: anObject
	^ (self ambient includes: anObject) and: [self contains: anObject]! !

!LinearGroup methodsFor: 'testing' stamp: 'len 12/1/2023 14:09:14'!
isAutomorphisms
	"Answer true if the elements of the receiver are automorphisms of some object X,
	i.e. if the receiver is Aut(X) or a subgroup of it."
	^ true! !

!LinearGroup methodsFor: 'testing' stamp: 'len 2/22/2016 00:27'!
isFinite
	^ self scalars isFinite or: [super isFinite]! !

!LinearGroup methodsFor: 'testing' stamp: 'len 12/2/2023 10:28:06'!
isFinitelyGenerated
	^ true! !

!LinearGroup methodsFor: 'private' stamp: 'len 4/1/2021 12:19:16'!
species
	^ LinearGroup! !

!LinearGroup class methodsFor: 'examples' stamp: 'len 6/26/2023 12:57:14'!
C3
	"Cyclic matrix group of order 3."
	^ (ℤ/5 ^ 2) automorphisms sub: #((0 1 -1 -1))! !

!LinearGroup class methodsFor: 'examples' stamp: 'len 6/26/2023 12:57:19'!
C4
	"Cyclic matrix group of order 4."
	^ (ℤ/7 ^ 2) automorphisms sub: #((0 -1 1 0))! !

!LinearGroup class methodsFor: 'examples' stamp: 'len 6/26/2023 12:57:23'!
D8
	"Dihedral group of order 8."
	^ (ℤ/3 ^ 2) automorphisms sub: #((0 1 2 0) (1 0 0 2))! !

!LinearGroup class methodsFor: 'examples' stamp: 'len 5/23/2020 09:11:37'!
GL
	"The general linear group of 3x3 invertible matrices with rational coefficients."
	^ (ℚ^3) automorphisms! !

!LinearGroup class methodsFor: 'examples' stamp: 'len 6/26/2023 12:57:27'!
klein
	"The Klein four-group (or Vierergruppe) as a linear group."
	^ (ℤ^2) automorphisms sub: #((1 0 0 -1) (-1 0 0 1))! !

!LinearGroup class methodsFor: 'instance creation' stamp: 'len 12/11/2023 10:09:16'!
new: anInteger over: aRing generators: aCollection
	^ (GeneralLinearGroup new: anInteger over: aRing) sub: aCollection! !

!LinearGroup class methodsFor: 'instance creation' stamp: 'len 6/26/2023 12:57:31'!
on: aFreeModule generators: aCollection
	^ (GeneralLinearGroup on: aFreeModule) sub: aCollection! !

!GeneralLinearGroup methodsFor: 'accessing' stamp: 'len 6/24/2016 08:44'!
ambient
	^ self! !

!GeneralLinearGroup methodsFor: 'accessing' stamp: 'len 12/23/2023 10:45:20'!
size
	| q n |
	self scalars isFiniteField ifFalse: [^ super size].
	q := self scalars size.
	n := self dimension.
	^ q ^ (n*(n-1)/2) * ((1 to: n) inject: 1 into: [:x :k| q^k - 1 * x])! !

!GeneralLinearGroup methodsFor: 'accessing' stamp: 'len 6/7/2020 06:24:12'!
space
	^ self propertyAt: #space! !

!GeneralLinearGroup methodsFor: 'comparing' stamp: 'len 7/28/2020 09:24:27'!
= anObject
	(anObject isKindOf: GeneralLinearGroup) ifFalse: [^ super = anObject].
	^ self space = anObject space! !

!GeneralLinearGroup methodsFor: 'converting' stamp: 'len 5/1/2024 12:18:13'!
asAlgebraicVariety
	| n P det V endos |
	self scalars isField ifFalse: [self notYetImplemented].
	n := self degree.
	P := self scalars polynomialsIn: n squared + 1.
	endos := (P^n) endomorphisms.
	det := (endos !! P generators) determinant.
	V := (P * (det * (P x: n squared + 1) - P one)) variety.
	V addCoercionTo: self map: [:p| endos !! p allButLast].
	V addCoercionFrom: self map: [:M| V !! (M asTuple, M determinant inverse)].
	^ V! !

!GeneralLinearGroup methodsFor: 'elements' stamp: 'len 4/9/2020 18:10:41'!
adapt: anElement
	^ (self space endomorphisms adapt: anElement) ifNil: [^ super adapt: anElement]! !

!GeneralLinearGroup methodsFor: 'elements' stamp: 'len 12/10/2023 10:41:55'!
identity
	"Answer the identity element of the receiver."
	^ self space id! !

!GeneralLinearGroup methodsFor: 'elements' stamp: 'len 6/1/2020 12:36:50'!
newFrom: anObject
	(anObject isKindOf: SequenceableCollection)
		ifTrue: [^ self space endomorphisms !! anObject].
	^ super newFrom: anObject! !

!GeneralLinearGroup methodsFor: 'enumerating' stamp: 'len 5/16/2019 12:41:22'!
do: aBlock
	((self hasProperty: #elements) or: [self hasProperty: #generators])
		ifTrue: [^ super do: aBlock].
	self space endomorphisms do: [:each| each isIsomorphism ifTrue: [aBlock value: each]]! !

!GeneralLinearGroup methodsFor: 'operations' stamp: 'len 9/26/2018 23:00:56'!
center
	^ ScalarGroup on: self space! !

!GeneralLinearGroup methodsFor: 'operations' stamp: 'len 9/26/2018 23:01:03'!
commutator
	(self degree = 2 and: [self scalars size = 2])
		ifFalse: [^ SpecialLinearGroup on: self space].
	^ self propertyAt: #commutator! !

!GeneralLinearGroup methodsFor: 'operations' stamp: 'len 5/27/2022 18:30:39'!
special
	"Answer the special linear group SL(n) which is a subgroup of the receiver."
	^ SpecialLinearGroup new ambient: self! !

!GeneralLinearGroup methodsFor: 'printing' stamp: 'len 2/11/2016 05:04'!
shortName
	^ 'GL'! !

!GeneralLinearGroup methodsFor: 'random' stamp: 'len 12/12/2023 20:08:39'!
atRandom: aRandom
	| matrix n |
	self isTrivial ifTrue: [^ self identity].
	self space freeCover rank > 1 ifFalse: [^ self identity * (self scalars units atRandom: aRandom)].
	matrix := self space freeCover id copy.
	n := matrix width.
	n timesRepeat:
		[| i j |
		i := n atRandom: aRandom.
		[j := n atRandom: aRandom. j = i] whileTrue.
		matrix swapRow: i with: j.
		i := n atRandom: aRandom.
		[j := n atRandom: aRandom. j = i] whileTrue.
		matrix addRow: i times: (self scalars atRandom: aRandom) to: j.
		i := n atRandom: aRandom.
		matrix multiplyRow: i by: (self scalars units atRandom: aRandom)].
	^ self space to: self space matrix: matrix! !

!GeneralLinearGroup methodsFor: 'random' stamp: 'len 12/12/2023 20:08:46'!
atRandom: aRandom bits: bitSize
	| matrix n scalarsBitSize |
	self isTrivial ifTrue: [^ self identity].
	self space freeCover rank > 1 ifFalse: [^ self identity * (self scalars units atRandom: aRandom bits: bitSize)].
	matrix := self space freeCover id copy.
	n := matrix width.
	scalarsBitSize := bitSize / n squared max: 1.
	n timesRepeat:
		[| i j |
		i := n atRandom: aRandom.
		[j := n atRandom: aRandom. j = i] whileTrue.
		matrix swapRow: i with: j.
		i := n atRandom: aRandom.
		[j := n atRandom: aRandom. j = i] whileTrue.
		matrix addRow: i times: (self scalars atRandom: aRandom bits: scalarsBitSize) to: j.
		i := n atRandom: aRandom.
		matrix multiplyRow: i by: (self scalars units atRandom: aRandom bits: scalarsBitSize)].
	^ self space to: self space matrix: matrix! !

!GeneralLinearGroup methodsFor: 'testing' stamp: 'len 9/27/2018 20:55:25'!
contains: anElement
	^ true! !

!GeneralLinearGroup methodsFor: 'testing' stamp: 'len 5/29/2020 14:18:10'!
includes: anObject
	^ anObject isMatrix and: [anObject domain = self space and: [anObject isAutomorphism]]! !

!GeneralLinearGroup methodsFor: 'testing' stamp: 'len 5/25/2022 11:00:14'!
isTrivial
	^ self space isTrivial! !

!GeneralLinearGroup methodsFor: 'private' stamp: 'len 6/7/2020 06:24:39'!
space: aFreeModule
	self propertyAt: #space put: aFreeModule! !

!GeneralLinearGroup class methodsFor: 'instance creation' stamp: 'len 6/7/2020 06:27:48'!
new: anInteger over: aRing
	^ self on: aRing ^ anInteger! !

!GeneralLinearGroup class methodsFor: 'instance creation' stamp: 'len 6/7/2020 06:27:38'!
on: aFreeModule
	^ self new space: aFreeModule! !

!OrthogonalGroup methodsFor: 'accessing' stamp: 'len 7/28/2020 09:39:51'!
bilinearForm
	^ self quadraticForm polarization! !

!OrthogonalGroup methodsFor: 'accessing' stamp: 'len 7/28/2020 09:28:38'!
quadraticForm
	^ self propertyAt: #quadraticForm! !

!OrthogonalGroup methodsFor: 'elements' stamp: 'len 9/16/2022 07:44:14'!
reflectionAt: aVector
	"Answer the orthogonal reflection with mirror hyperplane perpendicular to aVector."

	^ self space endomorphisms map: [:v| v - (aVector * ((self bilinearForm value: {v. aVector}) * 2 / (self bilinearForm value: {aVector. aVector})))]! !

!OrthogonalGroup methodsFor: 'etc' stamp: 'len 6/3/2020 05:32:04'!
affine
	self notYetImplemented
	"^ EuclideanGroup on: self space"! !

!OrthogonalGroup methodsFor: 'operations' stamp: 'len 7/28/2020 09:29:03'!
special
	^ SpecialOrthogonalGroup on: self quadraticForm! !

!OrthogonalGroup methodsFor: 'printing' stamp: 'len 7/28/2020 09:28:26'!
printOn: aStream
	aStream nextPutAll: 'O('; print: self quadraticForm; nextPut: $)! !

!OrthogonalGroup methodsFor: 'printing' stamp: 'len 2/11/2016 05:14'!
shortName
	^ 'O'! !

!OrthogonalGroup methodsFor: 'random' stamp: 'len 7/28/2020 10:30:25'!
atRandom: aRandom
	| answer v |
	answer _ self identity.
	self space rank "heuristic"
		timesRepeat:
			[[(v _ self space atRandom: aRandom) isZero] whileTrue.
			answer _ answer * (self reflectionAt: v)].
	^ answer! !

!OrthogonalGroup methodsFor: 'random' stamp: 'len 6/7/2020 06:29:48'!
atRandom: aRandom bits: bitSize
	| answer v |
	answer _ self identity.
	self space rank "heuristic"
		timesRepeat:
			[[(v _ self space atRandom: aRandom bits: bitSize // self space rank) isZero] whileTrue.
			answer _ answer · (self reflectionAt: v)].
	^ answer! !

!OrthogonalGroup methodsFor: 'testing' stamp: 'len 8/9/2020 07:56:08'!
contains: aMatrix
	"Answer true if the receiver contains the given element of its ambient."
	| A |
	A _ self bilinearForm matrix.
	^ aMatrix transpose * A * aMatrix = A! !

!OrthogonalGroup methodsFor: 'private' stamp: 'len 7/28/2020 09:22:51'!
quadraticForm: aQuadraticForm
	self propertyAt: #quadraticForm put: aQuadraticForm.
	self ambient: aQuadraticForm domain automorphisms! !

!OrthogonalGroup class methodsFor: 'instance creation' stamp: 'len 7/28/2020 09:18:30'!
on: aQuadraticForm
	^ self new quadraticForm: aQuadraticForm! !

!ScalarGroup methodsFor: 'accessing' stamp: 'len 2/12/2016 02:18'!
dimension
	^ 1! !

!ScalarGroup methodsFor: 'enumerating' stamp: 'len 6/1/2020 12:14:07'!
do: aBlock
	self scalars do: [:each| each isZero ifFalse: [aBlock value: (self space endomorphisms scalar: each)]]! !

!ScalarGroup methodsFor: 'operations' stamp: 'len 9/25/2018 17:17:22'!
special
	^ SpecialScalarGroup on: self space! !

!ScalarGroup methodsFor: 'printing' stamp: 'len 2/11/2016 05:21'!
shortName
	^ 'Z'! !

!ScalarGroup methodsFor: 'random' stamp: 'len 5/27/2022 13:02:19'!
atRandom: aRandom
	^ self identity * (self scalars units atRandom: aRandom)! !

!ScalarGroup methodsFor: 'random' stamp: 'len 5/27/2022 13:02:52'!
atRandom: aRandom bits: bitSize
	^ self identity * (self scalars units atRandom: aRandom bits: bitSize)! !

!ScalarGroup methodsFor: 'testing' stamp: 'len 7/28/2020 11:05:25'!
contains: aMatrix
	"Answer true if the receiver contains the given element of its ambient."
	^ aMatrix isScalar! !

!ScalarGroup methodsFor: 'testing' stamp: 'len 12/8/2016 11:16:42'!
isCommutative
	^ self scalars isCommutative! !

!SpecialLinearGroup methodsFor: 'accessing' stamp: 'len 12/23/2023 10:56:56'!
size
	| q n |
	self scalars isFiniteField ifFalse: [^ super size].
	q := self scalars size.
	n := self dimension.
	^ q ^ (n*(n-1)/2) * ((2 to: n) inject: 1 into: [:x :k| q^k - 1 * x])! !

!SpecialLinearGroup methodsFor: 'operations' stamp: 'len 5/6/2023 18:17:01'!
asAlgebraicVariety
	| n P det |
	n _ self degree.
	P _ self scalars polynomialsIn: n squared.
	det _ ((P^n) endomorphisms fill: [:i :j| P x: i - 1 * n + j]) determinant.
	^ (P * (det - self scalars one)) variety! !

!SpecialLinearGroup methodsFor: 'operations' stamp: 'len 9/25/2018 17:17:31'!
center
	^ SpecialScalarGroup on: self space! !

!SpecialLinearGroup methodsFor: 'printing' stamp: 'len 2/11/2016 05:20'!
shortName
	^ 'SL'! !

!SpecialLinearGroup methodsFor: 'random' stamp: 'len 12/12/2023 20:08:54'!
atRandom: aRandom
	| matrix n |
	self isTrivial ifTrue: [^ self identity].
	self space freeCover rank > 1 ifFalse: [^ self identity * (self scalars units atRandom: aRandom)].
	matrix := self space freeCover id copy.
	n := matrix width.
	n timesRepeat:
		[| i j |
		i := n atRandom: aRandom.
		[j := n atRandom: aRandom. j = i] whileTrue.
		matrix swapRow: i with: j.
		matrix multiplyRow: i by: self scalars one negated.
		i := n atRandom: aRandom.
		[j := n atRandom: aRandom. j = i] whileTrue.
		matrix addRow: i times: (self scalars atRandom: aRandom) to: j].
	^ self space to: self space matrix: matrix! !

!SpecialLinearGroup methodsFor: 'random' stamp: 'len 12/12/2023 20:09:03'!
atRandom: aRandom bits: bitSize
	| matrix n scalarsBitSize |
	self isTrivial ifTrue: [^ self identity].
	self space freeCover rank > 1 ifFalse: [^ self identity].
	matrix := self space freeCover id copy.
	n := matrix width.
	scalarsBitSize := bitSize / n squared max: 1.
	n timesRepeat:
		[| i j |
		i := n atRandom: aRandom.
		[j := n atRandom: aRandom. j = i] whileTrue.
		matrix swapRow: i with: j.
		matrix multiplyRow: i by: self scalars one negated.
		i := n atRandom: aRandom.
		[j := n atRandom: aRandom. j = i] whileTrue.
		matrix addRow: i times: (self scalars atRandom: aRandom bits: scalarsBitSize) to: j].
	^ self space to: self space matrix: matrix! !

!SpecialLinearGroup methodsFor: 'testing' stamp: 'len 7/28/2020 11:05:34'!
contains: aMatrix
	"Answer true if the receiver contains the given element of its ambient."
	^ aMatrix determinant = self scalars one! !

!SpecialLinearGroup methodsFor: 'testing' stamp: 'len 5/27/2022 18:31:59'!
isTrivial
	^ self ambient isTrivial! !

!SpecialOrthogonalGroup methodsFor: 'accessing' stamp: 'len 6/3/2020 05:32:12'!
affine
	^ self notYetImplemented
"	^ SpecialEuclideanGroup on: self space affine"! !

!SpecialOrthogonalGroup methodsFor: 'accessing' stamp: 'len 7/28/2020 10:46:35'!
bilinearForm
	^ self quadraticForm polarization! !

!SpecialOrthogonalGroup methodsFor: 'accessing' stamp: 'len 7/28/2020 10:46:45'!
quadraticForm
	^ self propertyAt: #quadraticForm! !

!SpecialOrthogonalGroup methodsFor: 'printing' stamp: 'len 7/28/2020 10:47:08'!
printOn: aStream
	aStream nextPutAll: 'SO('; print: self quadraticForm; nextPut: $)! !

!SpecialOrthogonalGroup methodsFor: 'printing' stamp: 'len 2/11/2016 05:20'!
shortName
	^ 'SO'! !

!SpecialOrthogonalGroup methodsFor: 'testing' stamp: 'len 8/9/2020 07:56:48'!
contains: aMatrix
	"Answer true if the receiver contains the given element of its ambient."
	| A |
	A _ self bilinearForm matrix.
	^ aMatrix transpose * A * aMatrix = A and: [aMatrix determinant = self scalars one]! !

!SpecialOrthogonalGroup methodsFor: 'private' stamp: 'len 7/28/2020 10:46:06'!
quadraticForm: aQuadraticForm
	self propertyAt: #quadraticForm put: aQuadraticForm.
	self ambient: aQuadraticForm domain automorphisms! !

!SpecialOrthogonalGroup class methodsFor: 'instance creation' stamp: 'len 7/28/2020 10:45:30'!
on: aQuadraticForm
	^ self new quadraticForm: aQuadraticForm! !

!SpecialScalarGroup methodsFor: 'printing' stamp: 'len 2/11/2016 05:38'!
shortName
	^ 'SZ'! !

!SpecialScalarGroup methodsFor: 'testing' stamp: 'len 7/28/2020 11:05:03'!
contains: aMatrix
	"Answer true if the receiver contains the given element of its ambient."
	^ aMatrix isScalar and: [aMatrix determinant = self scalars one]! !

!SpecialScalarGroup methodsFor: 'testing' stamp: 'len 12/8/2016 11:17:14'!
isCommutative
	^ self scalars isCommutative! !

!UnitGroup methodsFor: 'accessing' stamp: 'len 11/29/2023 20:24:08'!
action
	"Answer the natural action that sends (u, x) to u*x, i.e. multiplies ring elements by units."
	^ self on: self space action: [:u :x| u*x]! !

!UnitGroup methodsFor: 'accessing' stamp: 'len 5/26/2024 10:13:41'!
generators
	self propertyAt: #generators ifPresent: [:aCollection| ^ aCollection].
	(self space isFiniteField or: [(self space isKindOf: ModularIntegerRing) and: [self space hasPrimitiveRoot]])
		 ifTrue: [^ {self space primitiveRoot}].
	^ nil! !

!UnitGroup methodsFor: 'accessing' stamp: 'len 5/30/2022 09:26:54'!
size
	^ self space unitsSize! !

!UnitGroup methodsFor: 'accessing' stamp: 'len 5/6/2019 02:38:35'!
space
	^ self propertyAt: #space! !

!UnitGroup methodsFor: 'elements' stamp: 'len 11/17/2023 16:22:28'!
adapt: anElement
	(self space adapt: anElement) ifNotNil: [:anotherElement|
		self assert: anotherElement isUnit.
		^ anotherElement].
	^ super adapt: anElement! !

!UnitGroup methodsFor: 'elements' stamp: 'len 6/19/2022 12:29:30'!
identity
	"Answer the identity element of the receiver."
	^ self space one! !

!UnitGroup methodsFor: 'enumerating' stamp: 'len 5/6/2019 02:41:07'!
do: aBlock
	self space unitsDo: aBlock! !

!UnitGroup methodsFor: 'printing' stamp: 'len 5/23/2020 07:19:34'!
printOn: aStream
	aStream print: self space; nextPutAll: '×' super ! !

!UnitGroup methodsFor: 'random' stamp: 'len 5/23/2022 13:36:10'!
atRandom: aRandom
	^ self space unitAtRandom: aRandom! !

!UnitGroup methodsFor: 'random' stamp: 'len 5/23/2022 13:36:21'!
atRandom: aRandom bits: bitSize
	^ self space unitAtRandom: aRandom bits: bitSize! !

!UnitGroup methodsFor: 'testing' stamp: 'len 5/4/2020 10:09:03'!
contains: anElement
	^ anElement isUnit! !

!UnitGroup methodsFor: 'testing' stamp: 'len 5/4/2020 10:09:22'!
includes: anElement
	^ (self space includes: anElement) and: [anElement isUnit]! !

!UnitGroup methodsFor: 'private' stamp: 'len 5/6/2019 02:38:58'!
space: aRing
	self propertyAt: #space put: aRing! !

!UnitGroup class methodsFor: 'instance creation' stamp: 'len 5/6/2019 02:39:49'!
on: aRing
	^ self new space: aRing! !

!Ring methodsFor: 'accessing' stamp: 'len 10/14/2023 08:07:39'!
basis
	"If the receiver is a finite algebra, answer a basis of the underlying module coerced to the receiver."
	^ self propertyAt: #basis ifAbsentPut: [self asModule basis collect: [:each| self !! each]]! !

!Ring methodsFor: 'accessing' stamp: 'len 4/26/2020 08:00:29'!
characteristic
	^ self propertyAt: #characteristic! !

!Ring methodsFor: 'accessing' stamp: 'len 10/21/2023 08:28:02'!
dimension
	"Answer the Krull dimension of the receiver.
	This is the length of the longest ascending chain of prime ideals."
	self isField ifTrue: [^ 0].
	self flag: #fixme.
	"self isPID ifTrue: [^ 1]. <- included in isDedekindDomain"
	"self isIntegralDomain ifTrue: [^ 1]. <- not true?"
	self isDedekindDomain ifTrue: [^ 1]. "<- because it's not a field"
	self isTrivial ifTrue: [^ Infinity negative].
	self isFinite ifTrue: [^ 0].
	^ self propertyAt: #dimension! !

!Ring methodsFor: 'accessing' stamp: 'len 8/21/2024 14:50:37'!
freeCover
	^ self propertyAt: #freeCover ifAbsentPut:
		[self assert: self isFinitelyGeneratedAlgebra.
		[self isCommutative ifTrue: [self scalars polynomialsIn: self generators size] ifFalse: [self scalars freeAlgebraIn: self generators size]]]! !

!Ring methodsFor: 'accessing' stamp: 'len 5/9/2024 08:36:10'!
generators
	"Note: the module generators are not necessarily a minimal set of generators as algebra."
	^ self propertyAt: #generators ifAbsent: [self isFiniteAlgebra ifTrue: [self linearGenerators]]! !

!Ring methodsFor: 'accessing' stamp: 'len 10/14/2023 08:08:22'!
linearGenerators
	"If the receiver is a finite algebra, answer the generators of the underlying module coerced to the receiver."
	^ self propertyAt: #linearGenerators ifAbsentPut: [self asModule generators collect: [:each| self !! each]]! !

!Ring methodsFor: 'accessing' stamp: 'len 4/8/2021 12:38:55'!
maximalIdeal
	"If the receiver is a local ring, answer the unique maximal ideal."
	self isDivisionRing ifTrue: [^ self asIdeal null].
	self subclassResponsibility! !

!Ring methodsFor: 'accessing' stamp: 'len 7/14/2024 07:47:49'!
one
	^ self propertyAt: #one ifAbsentPut: [self elements any one]! !

!Ring methodsFor: 'accessing' stamp: 'len 11/1/2023 16:40:20'!
primeSubfield
	self assert: self isField.
	^ self primeSubring fractions! !

!Ring methodsFor: 'accessing' stamp: 'len 11/1/2023 16:39:19'!
primeSubring
	^ ℤ / self characteristic! !

!Ring methodsFor: 'accessing' stamp: 'len 5/23/2020 09:13:12'!
scalars
	"Because the ring of rational integers is the initial object in the category of rings.
	Subclasses can override."
	^ ℤ! !

!Ring methodsFor: 'accessing' stamp: 'len 1/2/2022 10:10:03'!
uniformizer
	"If the receiver is a DVR, answer the uniformizer.
	A uniformizer (or uniformizing parameter, uniformizer element or prime element) is any irreducible element of a DVR, or equivalently a generator of the maximal ideal. All nonzero ideals are generated by some power of the uniformizer."
	self isDVR ifFalse: [^ self error: 'not a DVR'].
	^ self propertyAt: #uniformizer ifAbsentPut: [self maximalIdeal generator normalized]! !

!Ring methodsFor: 'accessing' stamp: 'len 5/30/2022 10:30:34'!
unitsSize
	"Answer the order of the units group."
	| answer |
	self isDivisionRing ifTrue: [^ self size - 1].
	answer _ 0.
	self unitsDo: [:each| answer _ answer + 1].
	^ answer! !

!Ring methodsFor: 'accessing' stamp: 'len 4/26/2020 07:59:55'!
zero
	^ self propertyAt: #zero ifAbsentPut: [self one - self one]! !

!Ring methodsFor: 'computing-matrices' stamp: 'len 12/28/2022 11:11:19'!
basisAndTransformationOf: aMatrix
	| coechelonization E T |
	self isEuclidean ifFalse: [^ self notYetImplemented].
	coechelonization _ aMatrix coechelonAndTransformation.
	E _ coechelonization first copyWithoutZeroColumns.
	T _ coechelonization second copyFromColumn: 1 to: E width.
	^ {E. T}! !

!Ring methodsFor: 'computing-matrices' stamp: 'len 12/28/2022 11:11:26'!
basisOf: aMatrix
	self isEuclidean ifFalse: [^ self notYetImplemented].
	^ aMatrix coechelon copyWithoutZeroColumns! !

!Ring methodsFor: 'computing-matrices' stamp: 'len 5/19/2023 07:08:57'!
echelonAndTransformationOf: aMatrix
	^ (self echelonizationAlgorithm on: aMatrix) echelonAndTransformation! !

!Ring methodsFor: 'computing-matrices' stamp: 'len 5/19/2023 07:11:07'!
echelonOf: aMatrix
	^ (self echelonizationAlgorithm on: aMatrix) echelon! !

!Ring methodsFor: 'computing-matrices' stamp: 'len 10/16/2023 10:00:41'!
matrix: B quotientBy: A
	"Answer X such that AX + N = B, satisfying that if the i-th column of B is a linear combination of the columns of A then the i-th column of N is zero."
	self isField ifTrue: [^ self matrixOverField: B quotientBy: A].
	self isEuclideanDomain ifTrue: [^ self matrixOverEuclideanDomain: B quotientBy: A].
	self isFiniteAlgebra ifTrue: [^ self matrixOverFiniteAlgebra: B quotientBy: A].
	^ self notYetImplemented! !

!Ring methodsFor: 'computing-matrices' stamp: 'len 6/4/2022 21:11:48'!
matrix: B reductionBy: A
	"Answer N such that AX + N = B, satisfying that if the i-th column of B is a linear combination of the columns of A then the i-th column of N is zero."
	^ B - (A * (self matrix: B quotientBy: A))! !

!Ring methodsFor: 'computing-matrices' stamp: 'len 7/10/2023 19:36:39'!
smithNormalFormAndTransformationsOf: aMatrix
	"Answer the Smith normal form S of the argument A and unimodular matrices P and Q such that P*A*Q = S.
	This is a naive implementation of Kannan-Bachem algorithm."
	| HT S a n P Q |
	self isEuclidean ifFalse: [^ self notYetImplemented].
	"Repeatedly compute the Hermite normal form and transpose until a diagonal form is obtained:"
	P := aMatrix codomain id.
	Q := aMatrix domain id.
	HT := aMatrix HNFAndTransformation.
	S := HT first. P := HT second.
	[S isDiagonal] whileFalse:
		[HT := S transpose HNFAndTransformation.
		S := HT first transpose. Q := HT second transpose * Q.
		HT := S HNFAndTransformation.
		S := HT first. P := HT second * P].
	"Normalize the entries in the diagonal:"
	1 to: (S width min: S height) do: [:i|
		| aᵢ u |
		aᵢ := S at: i @ i.
		u := aᵢ normalization.
		u isOne ifFalse:
			[S at: i @ i put: aᵢ * u.
			P multiplyRow: i by: u]].
	S isSmithNormalForm ifTrue: [^ {S. P. Q}].
	"Once in diagonal form, substitute neighboring diagonal elements by their GCD and LCM:"
	n := ((S width min: S height) to: 2 by: -1) detect: [:i| (S isZeroAt: i @ i) not].
	[a := S at: 1 @ 1.
	2 to: n do: [:i| | b xgcd g s t Pᵢ Qᵢ |
		b := S at: i @ i.
		xgcd := a xgcd: b.
		g := xgcd at: 1.
		s := xgcd at: 2.
		t := xgcd at: 3.
		Pᵢ := P domain id.
		Pᵢ at: i-1 @ (i-1) put: s; at: i-1 @ i put: self one; at: i @ (i-1) put: b negated * t / g; at: i @ i put: a / g.
		Qᵢ := Q codomain id.
		Qᵢ at: i-1 @ (i-1) put: self one; at: i-1 @ i put: b negated / g; at: i @ (i-1) put: t; at: i @ i put: a * s / g.
		"Update S:"
		S at: i-1 @ (i-1) put: g. "GCD"
		S at: i @ i put: (a := a // g * b) "LCM".
		"And update P and Q:"
		P := Pᵢ * P.
		Q := Q * Qᵢ].
	S isSmithNormalForm] whileFalse.
	^ {S. P. Q}! !

!Ring methodsFor: 'computing-matrices' stamp: 'len 11/20/2023 11:04:14'!
smithNormalFormOf: aMatrix
	"Answer the Smith normal form of the aMatrix.
	This is a naive implementation of Kannan-Bachem algorithm."
	| S a n |
	aMatrix isEmpty ifTrue: [^ aMatrix].
	self isEuclidean ifFalse: [^ self notYetImplemented].
	"Repeatedly compute the Hermite normal form and transpose until a diagonal form is obtained:"
	S := aMatrix HNF.
	[S isDiagonal] whileFalse: [S := S transpose HNF transpose HNF].
	1 to: (S width min: S height) do: [:i| S at: i @ i put: (S at: i @ i) normalized].
	S isSmithNormalForm ifTrue: [^ S].
	"Once in diagonal form, substitute neighboring diagonal elements by their GCD and LCM:"
	n := ((S width min: S height) to: 2 by: -1) detect: [:i| (S isZeroAt: i @ i) not] ifNone: [^ S].
	[a := S at: 1 @ 1.
	2 to: n do: [:i| | b gcd |
		b := S at: i @ i.
		S at: i-1 @ (i-1) put: (gcd := a gcd: b). "GCD"
		S at: i @ i put: (a := a // gcd * b) normalized "LCM"].
	S isSmithNormalForm] whileFalse.
	^ S! !

!Ring methodsFor: 'computing-matrices' stamp: 'len 10/16/2023 10:01:12'!
syzygiesOf: aMatrix
	"Answer a matrix whose rows span the kernel of the given matrix.
	For a matrix A, the output is X with AX = 0."
	self isEuclideanDomain ifTrue: [^ self syzygiesOverEuclideanDomainOf: aMatrix].
	self isFiniteAlgebra ifTrue: [^ self syzygiesOverFiniteAlgebraOf: aMatrix].
	^ self notYetImplemented! !

!Ring methodsFor: 'computing-matrices-private' stamp: 'len 5/19/2023 07:10:23'!
echelonizationAlgorithm
	self isDivisionRing ifTrue: [^ GaussJordanEchelonization].
	self isEuclideanDomain ifTrue: [^ HermiteEchelonization].
	self isEuclidean ifTrue: [^ HowellEchelonization].
	^ self notYetImplemented! !

!Ring methodsFor: 'computing-matrices-private' stamp: 'len 10/16/2023 09:57:00'!
extendMatrix: aMatrix
	"If the receiver is a finite R-algebra with underlying module free R^d, and given a n*d × m*d matrix with coefficients in R, interpret the matrix as a n × m block matrix with each block corresponding to a representation matrix of an element in the receiver. Answer the corresponding n × m matrix over the receiver. This is a sort of extension of scalars."
	| M d one |
	M := self asModule.
	d := M rank.
	one := M !! self one.
	^ self^(aMatrix width / d) ⇒ (self^(aMatrix height / d)) fill: [:i :j|
		(M endomorphisms fill: [:i0 :j0| aMatrix at: (i-1*d+i0) @ (j-1*d+j0)]) * one]! !

!Ring methodsFor: 'computing-matrices-private' stamp: 'len 12/22/2022 19:07:08'!
matrixOverEuclideanDomain: B quotientBy: A
	"Answer X such that AX + N = B, satisfying that if the i-th column of B is a linear combination of the columns of A then the i-th column of N is zero.
	This is based on [Mat11] but extended to work over any Euclidean domain and also to cover the case of B having more than 1 column.
	[Mat11] Keith Matthews, 'Solving AX=B using the Hermite normal form' (2011)"
	| X E T |
	X _ self^0 → A domain.
	T _ A coechelonTransformation.
	E _ A coechelon.
	B columnsDo: [:b| | G P n |
		G _ E ⊔ b.
		G _ G ⊓ (G domain x: G width).
		P _ G coechelonTransformation.
		n _ P lastRow firstNonzeroIndex.
		X _ X ⊔ (T * ((P columnAt: n) copyFrom: 1 to: A width) negated)].
	^ X! !

!Ring methodsFor: 'computing-matrices-private' stamp: 'len 12/22/2022 18:59:16'!
matrixOverField: B quotientBy: A
	"Answer X such that AX + N = B, satisfying that if the i-th column of B is a linear combination of the columns of A then the i-th column of N is zero.
	The algorithm perform Gauss-Jordan reduction in essentially O(n^3) scalar operations.
	It is can produce coefficient explosion unless the scalar field is finite."
"	| T E X |
	T _ A coechelonTransformation.
	E _ A coechelon.
	^ Matrix to: A domain columns: (B columns collect: [:each| T * (T domain !! (each // E columns))]).
"
	| E X n |
"	A isSquare ifTrue: [	^ A coechelonTransformation * B]."
	E _ (A ⊔ B) echelon.
	n _ A width.
	X _ B domain → (self^0).
	E pivotsDo: [:each|
		each y <= n ifTrue:
			[each y - 1 - X height timesRepeat: [X _ X ⊓ B domain zero].
			X _ X ⊓ ((E rowAt: each x) copyFrom: n+1 to: E width)]].
	A width - X height timesRepeat: [X _ X ⊓ B domain zero].
	^ X! !

!Ring methodsFor: 'computing-matrices-private' stamp: 'len 10/16/2023 09:50:59'!
matrixOverFiniteAlgebra: B quotientBy: A
	"Answer X such that AX + N = B, satisfying that if the i-th column of B is a linear combination of the columns of A then the i-th column of N is zero."
	^ self extendMatrix: (B restriction quotientBy: A restriction)! !

!Ring methodsFor: 'computing-matrices-private' stamp: 'len 12/22/2022 19:05:33'!
syzygiesOverEuclideanDomainOf: aMatrix
	| E T |
	T _ aMatrix coechelonTransformation.
	E _ aMatrix coechelon.
	^ Matrix to: aMatrix domain columns: (((1 to: E width) select: [:i| E isZeroAtColumn: i]) collect: [:i| T columnAt: i])! !

!Ring methodsFor: 'computing-matrices-private' stamp: 'len 1/9/2024 11:00:18'!
syzygiesOverFiniteAlgebraOf: aMatrix
	"Answer a matrix whose rows span the kernel of the given matrix.
	For a matrix A, the output is X with AX = 0."
	| X d |
	aMatrix isZero ifTrue: [^ aMatrix domain id].
	X := aMatrix restriction syzygies.
	d := self asModule rank.
	^ self^X width to: self^(X height / d) fill: [:i :j|
		self !! (self asModule elementAt: ((1 to: d) collect: [:k| X at: (i-1*d+k) @ j]))]! !

!Ring methodsFor: 'computing-polynomials' stamp: 'len 11/27/2023 15:57:22'!
evaluate: aPolynomial at: anArray
	"Answer the result of evaluating aPolynomial at an array of elements of the receiver."
	aPolynomial isUnivariate ifTrue: [^ anArray first evaluate: aPolynomial].
	^ aPolynomial value: anArray! !

!Ring methodsFor: 'computing-polynomials' stamp: 'len 11/23/2023 22:18:20'!
irreduciblePolynomialDegree: n
	"Answer a monic irreducible polynomial of degree n."
	| P one x f random |
	P := self polynomials.
	one := P one.
	x := P x.
	1 to: n-1 do: [:k| (f := x^n + (x^k) + one) isIrreducible ifTrue: [^ f]].
	random := Random new.
	[f := (P atRandom: random maxDegree: n-1) + (x^n).
	f isIrreducible] whileFalse.
	^ f! !

!Ring methodsFor: 'computing-polynomials' stamp: 'len 6/25/2023 09:46:40'!
polynomial: aPolynomial factorizationDo: aBlock
	self isFiniteField ifTrue: [^ self polynomialOverFiniteField: aPolynomial factorizationDo: aBlock].
	^ self subclassResponsibility! !

!Ring methodsFor: 'computing-polynomials' stamp: 'len 12/23/2023 10:29:08'!
polynomial: aPolynomial squarefreeFactorizationDo: aBlock
	self isFiniteField ifTrue: [^ self polynomialOverFiniteField: aPolynomial squarefreeFactorizationDo: aBlock].
	self characteristic > 0 "finite ring" ifTrue: [^ self notYetImplemented].
	self isField ifTrue: [^ self polynomialOverFieldChar0: aPolynomial squarefreeFactorizationDo: aBlock].
	self isUFD ifTrue: [^ (aPolynomial primitivePart over: self fractions) squarefreeFactorizationDo: [:f :r| aBlock value: aPolynomial parent !! f integralPrimitivePart value: r]].
	^ self notYetImplemented! !

!Ring methodsFor: 'computing-polynomials' stamp: 'len 12/29/2023 10:12:11'!
rootsOf: aPolynomial do: aBlock
	"Enumerate the distinct roots of aPolynomial (ignoring multiplicities)."
	self flag: #fixme. "TODO: fine tune this, how big?"
	(self isFinite and: [self isUFD not or: [self size <= 1024]])
		ifTrue: [^ 	self do: [:each| (aPolynomial value: each) isZero ifTrue: [aBlock value: each]]].
	self rootsOf: aPolynomial withMultiplicitiesDo: [:τ :m| aBlock value: τ]! !

!Ring methodsFor: 'computing-polynomials' stamp: 'len 12/23/2023 09:48:00'!
rootsOf: aPolynomial withMultiplicitiesDo: aBlock
	"Enumerate the roots of aPolynomial with multiplicities."
	self isFiniteField ifTrue:
		[(aPolynomial over: self) normalized squarefreeFactorizationDo: [:f :r|
			f distinctDegreeFactorizationDo: [:d :g|
				d = 1 ifTrue: [g equalDegreeFactorization: d do: [:each| aBlock value: each independentCoefficient negated / each leadingCoefficient value: r]]]].
		^ self].
	self isUFR ifTrue:
		[(aPolynomial over: self) factorizationDo: [:f :e|
			f degree = 1 ifTrue: [aBlock value: f independentCoefficient negated / f leadingCoefficient value: e]].
		^ self].
	^ self notYetImplemented! !

!Ring methodsFor: 'computing-polynomials-private' stamp: 'len 11/7/2023 14:17:26'!
polynomialOverFieldChar0: aPolynomial squarefreeFactorizationDo: aBlock
	"Iterate a squarefree decomposition of the receiver.
	Use Yun's algorithm. Assume the coefficients are in a field of characteristic 0.
	Yun's algorithm on an input polynomial of degree n uses O(M(n)log(n)) operations in the base field F, where M(n) is the number of operations in F required to multiply two polynomias of degree n in F[x]."
	| p q gcd count |
	count := 1.
	p := aPolynomial.
	p isMonic ifFalse: [p := p normalized].
	q := p derivative.
	gcd := p gcd: q.
	gcd isConstant ifFalse:
		[p := p // gcd.
		q := q // gcd - p derivative.
		[q isZero] whileFalse:
			[gcd := p gcd: q.
			gcd isConstant ifFalse: [aBlock value: gcd value: count].
			count := count + 1.
			p := p // gcd.
			q := q // gcd - p derivative]].
	aBlock value: p value: count! !

!Ring methodsFor: 'computing-polynomials-private' stamp: 'len 11/5/2023 08:31:14'!
polynomialOverFiniteField: aPolynomial factorizationDo: aBlock
	aPolynomial normalized squarefreeFactorizationDo: [:f :r|
		f distinctDegreeFactorizationDo: [:d :g|
			g equalDegreeFactorization: d do: [:each| aBlock value: each value: r]]]! !

!Ring methodsFor: 'computing-polynomials-private' stamp: 'len 11/30/2023 14:24:10'!
polynomialOverFiniteField: aPolynomial squarefreeFactorizationDo: aBlock
	"Iterate over the squarefree decomposition of a monic polynomial."
	| f p i g c w y z φ |
	self assert: aPolynomial isMonic.
	aPolynomial isConstant ifTrue: [^ self].
	f := aPolynomial.
	p := self characteristic.
	"When the coefficient field is prime, the Frobenius is the identity and we don't need to apply it:"
	φ := self degree = 1 ifFalse: [self frobenius inverse].
	(g := f derivative) isZero ifTrue:
		[f := f applyToMonomials: [:each| each root: p].
		φ ifNotNil: [f := f  apply: φ].
		^ self polynomialOverFiniteField: f squarefreeFactorizationDo: [:h :r| aBlock value: h value: r*p]].
	c := f gcd: g.
	w := f // c.
	i := 1.
	[w isConstant] whileFalse:
		[y := w gcd: c. z := w // y.
		(z ^ i) isConstant ifFalse: [aBlock value: z value: i].
		i := i + 1.
		w := y. c := c // y].
	c isConstant ifFalse:
		[c := c applyToMonomials: [:each| each root: p].
		φ ifNotNil: [f := f  apply: φ].
		self polynomialOverFiniteField: c squarefreeFactorizationDo: [:h :r| aBlock value: h value: r*p]]! !

!Ring methodsFor: 'converting' stamp: 'len 8/30/2024 22:11:00'!
asAbelianGroup
	self isTrivial ifTrue: [^ ℤ^0].
	(self isFiniteAlgebra and: [self scalars = ℤ]) ifTrue: [^ self asModule].
	^ self propertyAt: #asAbelianGroup ifAbsentPut: [AbelianGroup elements: self elementsOrSelf]! !

!Ring methodsFor: 'converting' stamp: 'len 12/15/2021 15:22:26'!
asIdeal
	"Answer the receiver R viewed as R-module (as the unit ideal)."
	^ self propertyAt: #asIdeal ifAbsentPut: [self idealClass new generatorMatrix: (self^1) id]! !

!Ring methodsFor: 'converting' stamp: 'len 8/19/2024 10:04:57'!
asModule
	^ self subclassResponsibility! !

!Ring methodsFor: 'converting' stamp: 'len 4/5/2024 19:09:06'!
asVectorSpace
	self assert: self scalars isField.
	^ self asModule! !

!Ring methodsFor: 'elements' stamp: 'len 8/7/2019 17:49:30'!
!! anObject
	(anObject isKindOf: Ideal) ifTrue: [^ self * (anObject generators collect: [:each| self !! each])].
	^ super !! anObject! !

!Ring methodsFor: 'elements' stamp: 'len 5/6/2023 18:05:51'!
!!!! anArray
	"Answer a tuple over the receiver with coefficients corresponding to the elements of anArray.
	If the elements of anArray are not elements of the receiver, they are coerced."
	^ self ^ anArray size coefficients: (self new: anArray size fill: [:i| anArray at: i])! !

!Ring methodsFor: 'elements' stamp: 'len 5/6/2023 18:04:51'!
!!!!!! aCollection
	^ Matrix rows: (aCollection collect: [:each| self !!!! each])! !

!Ring methodsFor: 'elements' stamp: 'len 9/2/2022 07:35:55'!
adapt: anElement
	anElement isInteger ifTrue: [^ self one * anElement].
	anElement isFraction ifTrue:
		[anElement isIntegral ifTrue: [^ self one * anElement asInteger].
		(self isField and: [self characteristic = 0])
			ifTrue: [^ (self one * anElement numerator) / (self one * anElement denominator)]].
"	(anElement parent isLocalization and: [anElement isIntegral]) ifTrue: [^ self !! anElement numerator]."
	^ super adapt: anElement! !

!Ring methodsFor: 'elements' stamp: 'len 11/28/2023 09:12:36'!
elementAt: aPolynomial
	"If the receiver is a finitely generated algebra, answer the result of evaluating aPolynomial at the generators.
	See also >>#\."
	^ self evaluate: aPolynomial at: self generators! !

!Ring methodsFor: 'elements' stamp: 'len 11/23/2022 21:37:31'!
matrix: shape fill: aBlock
	| n m |
	shape isInteger ifTrue: [n _ m _ shape] ifFalse: [n _ shape x. m _ shape y].
	^ self^m to: self^n fill: aBlock! !

!Ring methodsFor: 'elements' stamp: 'len 5/3/2020 07:42:35'!
newFrom: anObject
	anObject isFraction ifTrue: [^ (self one * anObject numerator) * (self one * anObject denominator) inverse].
	^ super newFrom: anObject! !

!Ring methodsFor: 'elements' stamp: 'len 5/6/2023 18:28:06'!
zeros: anInteger
	"Answer a new array suitable for storing elements of the receiver filled with zeros."
	^ (self new: anInteger) atAllPut: self zero! !

!Ring methodsFor: 'enumerating' stamp: 'len 6/26/2024 08:54:04'!
do: aBlock
	(self isFiniteAlgebra and: [self scalars ~= self]) ifTrue: [self asModule do: [:each| aBlock value: self !! each]. ^ self].
	^ super do: aBlock! !

!Ring methodsFor: 'enumerating' stamp: 'len 10/15/2022 08:47:10'!
idealsDo: aBlock
	| elements I ideals |
	ideals _ Set new.
	self isPIR ifTrue: [^ self do: [:each| I _ self * each. ideals add: I ifAbsent: [aBlock value: I]]].
	(self isCommutative and: [self isFinite]) ifFalse: [^ self subclassResponsibility].
	elements _ self asArray.
	1 to: elements size do: [:k|
		elements combinations: k atATimeDo: [:gens|
			I _ self * gens.
			ideals add: I ifAbsent: [aBlock value: I]]]! !

!Ring methodsFor: 'enumerating' stamp: 'len 10/9/2022 09:33:33'!
maximalIdealsDo: aBlock
	self isField ifTrue: [aBlock value: self asIdeal null. ^ self].
	self isLocal ifTrue: [aBlock value: self maximalIdeal. ^ self].
	self idealsDo: [:each| each isMaximal ifTrue: [aBlock value: each]]! !

!Ring methodsFor: 'enumerating' stamp: 'len 4/8/2021 12:39:23'!
primeIdealsDo: aBlock
	self isField ifTrue: [aBlock value: self asIdeal null. ^ self].
	self isDVR ifTrue: [aBlock value: self asIdeal null; value: self maximalIdeal. ^ self].
	self idealsDo: [:each| each isPrime ifTrue: [aBlock value: each]]! !

!Ring methodsFor: 'enumerating' stamp: 'len 7/16/2022 11:25:10'!
primesDo: aBlock
	self do: [:each| each isPrime ifTrue: [aBlock value: each]]! !

!Ring methodsFor: 'enumerating' stamp: 'len 5/4/2020 10:08:39'!
unitsDo: aBlock
	self do: [:each| each isUnit ifTrue: [aBlock value: each]]! !

!Ring methodsFor: 'internalization' stamp: 'len 8/31/2024 08:58:38'!
algebras
	^ self modules monoids! !

!Ring methodsFor: 'internalization' stamp: 'len 8/30/2024 22:38:03'!
asAlgebra
	| M I |
	M := self asModule.
	I := self scalars asIdeal.
	^ self scalars modules monoids
		multiplication: (M with: M to: M map: [:x :y| self !! x * (self !! y)])
		unit: (I to: M map: [:x| self one * x])
! !

!Ring methodsFor: 'internalization' stamp: 'len 8/31/2024 08:59:03'!
bialgebras
	^ self modules bimonoids! !

!Ring methodsFor: 'internalization' stamp: 'len 8/26/2024 14:22:19'!
carrier
	^ self asAbelianGroup! !

!Ring methodsFor: 'internalization' stamp: 'len 8/31/2024 08:58:54'!
coalgebras
	^ self modules comonoids! !

!Ring methodsFor: 'internalization' stamp: 'len 8/30/2024 22:16:43'!
isMonoid
	"Rings are monoids in the category of abelian groups."
	^ true! !

!Ring methodsFor: 'internalization' stamp: 'len 8/28/2024 11:15:46'!
modules
	^ self propertyAt: #modules ifAbsentPut: [FPModuleCategory over: self]! !

!Ring methodsFor: 'internalization' stamp: 'len 8/30/2024 22:04:37'!
multiplication
	^​ self carrier with: self carrier to: self carrier map: [:x :y| self !! x * (self !! y)]! !

!Ring methodsFor: 'internalization' stamp: 'len 8/30/2024 22:05:54'!
to: aCodomain carrier: anAbelianGroupMap
	^ self to: aCodomain map: anAbelianGroupMap! !

!Ring methodsFor: 'internalization' stamp: 'len 8/30/2024 22:07:44'!
unit
	^​ ℤ carrier to: self carrier map: [:x| self one * x]! !

!Ring methodsFor: 'morphisms' stamp: 'len 10/23/2023 09:40:46'!
frobenius
	"Answer the Frobenius endomorphism, assuming the receiver is of characteristic p prime."
	^ self to: self map: [:x| x ^ self characteristic]! !

!Ring methodsFor: 'morphisms' stamp: 'len 8/21/2024 15:05:23'!
id
	^ self propertyAt: #id ifAbsentPut:
		[self isFinitelyGeneratedAlgebra ifTrue: [self to: self images: self generators] ifFalse: [self to: self map: [:x| x]]]! !

!Ring methodsFor: 'morphisms' stamp: 'len 8/19/2024 18:20:58'!
representation
	"If the receiver is a finite algebra, answer the left regular representation. This is the algebra homomorphism from the receiver to the endomorphisms of the underlying module that takes an element to the endomorphism corresponding to left multiplication by the element."
	^ self propertyAt: #representation ifAbsentPut: [self to: self asModule endomorphisms over: self scalars map: [:x| x representation]]! !

!Ring methodsFor: 'morphisms' stamp: 'len 8/19/2024 18:20:37'!
rightRepresentation
	"If the receiver is a finite algebra, answer the right regular representation. This is the algebra homomorphism from the receiver to the endomorphisms of the underlying module that takes an element to the endomorphism corresponding to right multiplication by the element."
	^ self propertyAt: #rightRepresentation ifAbsentPut: [self to: self asModule endomorphisms over: self scalars map: [:x| x rightRepresentation]]! !

!Ring methodsFor: 'morphisms' stamp: 'len 4/16/2024 18:44:14'!
to: aRing
	self assert: aRing isRing.
	aRing isTrivial ifTrue: [^ self to: aRing map: [:x| aRing zero]].
	^ super to: aRing! !

!Ring methodsFor: 'morphisms' stamp: 'len 8/21/2024 14:56:12'!
to: anAlgebra images: anArray
	self assert: anAlgebra isRing.
	self assert: (self isFinitelyGeneratedAlgebra and: [self generators size = anArray size]).
	self assert: (self scalars ⇢ anAlgebra) notNil.
	^ RingMap from: self to: anAlgebra images: anArray! !

!Ring methodsFor: 'morphisms' stamp: 'len 10/13/2023 08:46:21'!
to: aRing map: aBlock
	self assert: aRing isRing.
"	(self isTrivial or: [(self characteristic = 0 and: [aRing characteristic = 0]) or: [aRing characteristic | self characteristic]]) ifFalse: [DomainError signal]."
	^ RingMap from: self to: aRing map: aBlock! !

!Ring methodsFor: 'morphisms' stamp: 'len 8/20/2024 11:02:21'!
to: anAlgebra moduleMap: aModuleMap
	self assert: (aModuleMap domain == self asModule and: [aModuleMap codomain == anAlgebra asModule]).
	^ RingMap from: self to: anAlgebra moduleMap: aModuleMap! !

!Ring methodsFor: 'morphisms' stamp: 'len 8/20/2024 11:18:28'!
to: anAlgebra over: aRing map: aBlock
	self assert: anAlgebra scalars = aRing.
	(self isFiniteAlgebra and: [anAlgebra isFiniteAlgebra]) ifTrue: [^ self to: anAlgebra moduleMap: (self asModule to: anAlgebra asModule map: [:x| aBlock value: self !! x])].
	^ self to: anAlgebra images: (self generators collect: [:each| anAlgebra !! (aBlock value: each)])! !

!Ring methodsFor: 'morphisms' stamp: 'len 6/26/2024 08:52:30'!
⇒ anObject
	"If the receiver is a finite R-algebra and the argument is an R-module or an R-module homomorphism, this is the 'coextension of scalars' functor. This is right adjoint to the 'restriction of scalars' functor (see #restriction), and dual to the 'extension of scalars' functor (see #⊗)."
	((anObject isKindOf: Module) or: [anObject isKindOf: ModuleMap]) ifTrue: [^ self asModule ⇒ anObject].
	^ super ⇒ anObject! !

!Ring methodsFor: 'operations' stamp: 'len 6/14/2024 02:17:23'!
* anObject
	"If the argument is an element or a collection of elements, answer the ideal generated by the argument. Note that in the case of noncommutative rings the notation is backwards because it answers a right ideal.
	If the argument is an algebra, answer the free product of the receiver with the argument (this is the coproduct in the category of R-algebras)."
	(anObject isKindOf: Ring) ifTrue: [^ self notYetImplemented]. "free product"
	(self includes: anObject) ifTrue: [^ self asIdeal sub: {anObject}].
	anObject isCollection ifTrue: [^ self asIdeal sub: anObject].
	^ self * (self !! anObject)! !

!Ring methodsFor: 'operations' stamp: 'len 12/19/2021 20:08:12'!
/ anIdeal
	"Answer the quotient by the given ideal.
	For convenience, the argument can be a single element or a collection of elements as well."
	(anIdeal isKindOf: Ideal) ifFalse: [^ self / (self * anIdeal)].
	self isCommutative ifFalse: [^ self subclassResponsibility].
	self assert: self = anIdeal scalars.
	anIdeal isTrivial ifTrue: [^ self].
	^ QuotientRing relations: anIdeal! !

!Ring methodsFor: 'operations' stamp: 'len 4/5/2024 19:09:14'!
@ anObject
	"Answer the localization of the receiver at anObject.
	If anObject is an element p of the receiver, answer the localization away from p, i.e. a new ring where p is invertible.
	If anObject is an ideal P of the receiver, and assuming P is prime, answer the localization at P, i.e. the ring of fractions a/b where b is not in P."
	((anObject isKindOf: Ideal) and: [anObject scalars = self])
		ifTrue: [^ self localizationAt: anObject].
	(self includes: anObject)
		ifTrue: [^ self localizationAwayFrom: anObject].
	^ Error signal
! !

!Ring methodsFor: 'operations' stamp: 'len 11/28/2023 09:12:57'!
\ anElement
	"If the receiver is a finitely generated algebra, answer anElement expressed as a (possibly noncommutative) polynomial on the generators.
	See also >>#elementAt:."
	^ self subclassResponsibility! !

!Ring methodsFor: 'operations' stamp: 'len 4/6/2024 15:50:33'!
^ anObject
	anObject isCollection ifTrue: [^ FreeModule new: anObject over: self].
	anObject isInteger ifTrue:
		[^ (self propertyAt: #freeModules ifAbsentPut: [WeakValueDictionary new])
			at: anObject ifAbsentOrNilPut: [FreeModule new: anObject over: self]].
	^ super ^ anObject! !

!Ring methodsFor: 'operations' stamp: 'len 11/24/2022 19:06:20'!
× aRing
	self assert: aRing isRing.
	^ ProductRing components: {self. aRing}! !

!Ring methodsFor: 'operations' stamp: 'len 12/1/2023 18:23:03'!
abelianClosure
	"Answer the maximal abelian extension of the receiver."
	self isFiniteField ifTrue: [^ self algebraicClosure].
	self isAlgebraicallyClosed ifTrue: [^ self].
	^ self notYetImplemented! !

!Ring methodsFor: 'operations' stamp: 'len 12/1/2023 18:23:10'!
algebraicClosure
	"Answer an algebraic closure of the receiver, i.e. an extension of the receiver that is algebraically closed."
	self isAlgebraicallyClosed ifTrue: [^ self].
	^ self notYetImplemented! !

!Ring methodsFor: 'operations' stamp: 'len 10/18/2023 18:31:04'!
center
	"Answer the subalgebra of elements that commute with all the other elements."
	^ self centralizerOf: self! !

!Ring methodsFor: 'operations' stamp: 'len 10/18/2023 17:56:56'!
centralizerOf: aSubalgebra
	"Answer the centralizer of the given subalgebra of the receiver, i.e. the subalgebra of elements commuting with all elements of the argument."
	| M ι rows |
	self isCommutative ifTrue: [^ self].
	(self isFiniteAlgebra and: [aSubalgebra isFiniteAlgebra and: [self scalars = aSubalgebra scalars]]) ifFalse: [^ self notYetImplemented].
	M := self asModule.
	ι := aSubalgebra → self.
	rows := OrderedCollection new.
	self flag: #fixme. "optimize, generalize"
	self linearGenerators do: [:x|
		aSubalgebra linearGenerators do: [:y₀|
			| y |
			y := ι value: y₀.
			rows add: M \ (M !! (x*y - (y*x)))]].
	^ self sub: ((Matrix rows: rows) kernel generators collect: [:each| self !! each])! !

!Ring methodsFor: 'operations' stamp: 'len 10/18/2023 17:57:14'!
commutatorIdealWith: aSubalgebra
	| commutators |
	self assert: (self ambient = aSubalgebra ambient and: [self ambient isFiniteAlgebra]).
	commutators := OrderedCollection new.
	self linearGenerators do: [:x| aSubalgebra linearGenerators do: [:y| commutators add: (x commutator: y)]].
	^ self ambient * commutators! !

!Ring methodsFor: 'operations' stamp: 'len 10/18/2023 17:57:24'!
commutatorModuleWith: aSubalgebra
	| commutators |
	self assert: (self ambient = aSubalgebra ambient and: [self ambient isFiniteAlgebra]).
	commutators := OrderedCollection new.
	self linearGenerators do: [:x| aSubalgebra linearGenerators do: [:y| commutators add: (x commutator: y)]].
	^ self ambient asModule sub: commutators! !

!Ring methodsFor: 'operations' stamp: 'len 6/26/2024 09:10:21'!
dual
	"If the receiver is a finite R-algebra, answer the dual R-coalgebra."
	| one |
	self assert: self isFiniteAlgebra.
	one := self asModule !! self one.
	^ self scalars modules comonoids comultiplication: self multiplication dual counit: (self asModule dual to: self scalars asIdeal map: [:f| f value: one])! !

!Ring methodsFor: 'operations' stamp: 'len 4/3/2024 08:49:32'!
envelopingAlgebra
	^ self opposite ⊗ self! !

!Ring methodsFor: 'operations' stamp: 'len 7/12/2024 08:40:39'!
extension: aPolynomial
	"Answer the algebraic extension defined by the given univariate monic irreducible polynomial."
	| f |
	aPolynomial isBlock ifTrue: [^ self extension: self polynomials !! aPolynomial].
	self assert: aPolynomial parent isUnivariate.
	self assert: aPolynomial isMonic.
	(f := aPolynomial over: self) degree > 1 ifTrue: [^ self extensionClass modulus: f].
	^ self! !

!Ring methodsFor: 'operations' stamp: 'len 11/23/2023 22:18:29'!
extensionDegree: anInteger
	"Answer an algebraic extension of the given degree."
	anInteger = 1 ifTrue: [^ self].
	^ self extension: (self irreduciblePolynomialDegree: anInteger)! !

!Ring methodsFor: 'operations' stamp: 'len 5/7/2022 07:36:28'!
fractions
	"Answer the total ring of fractions of the receiver. If the receiver is an integral domain, the fraction ring will be a field. If the receiver is a finite rings, it is its own total ring of fractions, because an element in a finite ring is either a zero divisor or a unit."
	^ self propertyAt: #fractions ifAbsentPut:
		[self isCommutative ifFalse: [^ self error: 'not a commutative ring'].
		(self isField or: [self isFinite]) ifTrue: [self] ifFalse: [FractionRing on: self]]! !

!Ring methodsFor: 'operations' stamp: 'len 1/20/2016 13:42'!
freeAlgebra
	^ FreeAlgebra over: self! !

!Ring methodsFor: 'operations' stamp: 'len 5/11/2019 02:42:50'!
freeAlgebraIn: anIntegerOrCollection
	"Answer the free algebra in the given indeterminates over the receiver."
	anIntegerOrCollection isInteger ifTrue: [^ FreeAlgebra new: anIntegerOrCollection over: self].
	^ (FreeAlgebra new: anIntegerOrCollection size over: self) names: anIntegerOrCollection! !

!Ring methodsFor: 'operations' stamp: 'len 7/13/2023 16:10:55'!
hilbertPolynomial
	"Answer the Hilbert polynomial of the receiver."
	| h t s scalar st answer |
	h := self hilbertSeries.
	h denominator degree = 0 ifTrue: [^ h denominator parent zero].
	t := h denominator parent x.
	s := h denominator valuation: t - 1.
	scalar := (h denominator independentCoefficient * (s - 1) factorial) asInteger bitInvert.
	st := s - 1 + t.
	answer := h denominator parent zero.
	h numerator coefficients withIndexDo: [:each :i| answer := ((0 to: s - 1) product: [:ν| st - i - ν]) * each + answer].
	^ answer * scalar! !

!Ring methodsFor: 'operations' stamp: 'len 7/13/2023 15:15:16'!
hilbertSeries
	"Answer the Hilbert series of the receiver expressed as a rational function in ℚ(t)."
	^ self hilbertSeriesAt: (ℚ polynomialsIn: #(t)) fractions x! !

!Ring methodsFor: 'operations' stamp: 'len 10/18/2023 17:59:36'!
idealizerOf: aSubalgebra
	"Answer the idealizer of the given subalgebra of the receiver, i.e. the largest subalgebra of the receiver for which the argument is an ideal."
	^ self notYetImplemented! !

!Ring methodsFor: 'operations' stamp: 'len 4/30/2019 04:17:37'!
ideals
	^ Iterator on: self performing: #idealsDo:! !

!Ring methodsFor: 'operations' stamp: 'len 5/10/2020 10:13:24'!
irreducibles
	^ self select: [:each| each isIrreducible]! !

!Ring methodsFor: 'operations' stamp: 'len 11/7/2023 21:40:17'!
jet: k
	"If the receiver is a local ring R, answer the k-th jet R/M^(k+1) at the maximal ideal M."
	^ self jet: k at: self maximalIdeal! !

!Ring methodsFor: 'operations' stamp: 'len 11/7/2023 21:39:05'!
jet: k at: anIdeal
	"Answer the k-th jet R/I^(k+1) of the receiver R at an ideal I."
	^ self / (anIdeal ^ (k+1))! !

!Ring methodsFor: 'operations' stamp: 'len 7/23/2022 13:09:04'!
localizationAt: anIdeal
	"Assuming anIdeal is prime, answer the localization of the receiver at anIdeal, i.e. the ring of fractions a/b where b is not in anIndeal."
	self isCommutative ifFalse: [^ self error: 'not a commutative ring'].
	(anIdeal isTrivial and: [self isIntegralDomain]) ifTrue: [^ self fractions].
	(self isLocal and: [anIdeal = self maximalIdeal]) ifTrue: [^ self].
	^ LocalRing at: anIdeal! !

!Ring methodsFor: 'operations' stamp: 'len 9/16/2022 08:09:35'!
localizationAwayFrom: anElement
	"Answer the localization of the receiver away from anElement, i.e. a new ring where anElement is invertible."
	| P F L |
	anElement isUnit ifTrue: [^ self].
	P _ self polynomials.
	L _ P / (P x * anElement - P one).
	F _ self fractions.
	L addMap: (L into: F map: [:f| F numerator: f numerator denominator: f denominator]). "<- add also retraction"
	^ L! !

!Ring methodsFor: 'operations' stamp: 'len 10/9/2022 09:34:09'!
maximalIdeals
	^ Iterator on: self performing: #maximalIdealsDo:! !

!Ring methodsFor: 'operations' stamp: 'len 10/24/2023 16:07:40'!
nilradical
	"Answer the ideal consisting of all nilpotent elements, i.e. all x such that there exists some n with x^n = 0. It is the intersection of all prime ideals. (See also >>radical.)"
	^ self propertyAt: #nilradical ifAbsentPut: [self asIdeal null radical]! !

!Ring methodsFor: 'operations' stamp: 'len 9/5/2024 07:48:18'!
opposite
	"Answer the opposite ring of the receiver, i.e. the ring with multiplication order reversed."
	(self isCommutative or: [self isInvolutive]) ifTrue: [^ self].
	^ self propertyAt: #opposite ifAbsentPut: [OppositeRing opposite: self]! !

!Ring methodsFor: 'operations' stamp: 'len 5/15/2019 01:11:18'!
polynomials
	^ self polynomialsIn: #(x)! !

!Ring methodsFor: 'operations' stamp: 'len 2/12/2017 06:07:46'!
polynomialsIn: anIntegerOrCollection
	"Answer the ring of multivariate polynomials over the receiver in the given indeterminates."
	^ self polynomialsIn: anIntegerOrCollection ordering: #grevlex! !

!Ring methodsFor: 'operations' stamp: 'len 7/23/2021 10:49:12'!
polynomialsIn: anIntegerOrCollection ordering: aMonomialOrdering
	"Answer the ring of multivariate polynomials over the receiver over the given indeterminates."
	self isCommutative ifFalse: [^ self error: 'not a commutative ring'].
	anIntegerOrCollection isInteger
		ifTrue: [^ PolynomialRing new: anIntegerOrCollection over: self ordering: aMonomialOrdering].
	^ (PolynomialRing new: anIntegerOrCollection size over: self ordering: aMonomialOrdering) names: anIntegerOrCollection! !

!Ring methodsFor: 'operations' stamp: 'len 5/4/2023 19:18:08'!
polynomialsIn: anIntegerOrCollection weights: aCollection
	"Answer the ring of multivariate polynomials over the receiver in the given indeterminates with the given degrees."
	| n |
	n _ anIntegerOrCollection isInteger ifTrue: [anIntegerOrCollection] ifFalse: [anIntegerOrCollection size].
	^ self polynomialsIn: anIntegerOrCollection ordering: (MonomialOrdering grevlex: (1 to: n) weights: aCollection)! !

!Ring methodsFor: 'operations' stamp: 'len 7/5/2019 15:22:18'!
primeIdeals
	^ Iterator on: self performing: #primeIdealsDo:! !

!Ring methodsFor: 'operations' stamp: 'len 7/16/2022 11:27:33'!
primes
	^ Iterator on: [:aBlock| self primesDo: aBlock]! !

!Ring methodsFor: 'operations' stamp: 'len 7/4/2022 19:29:50'!
proj
	"This is the Proj construction. Answer the homogeneous prime spectrum of the receiver as a scheme."
	self assert: self isCommutative.
	^ self propertyAt: #proj ifAbsentPut: [ProjectiveScheme coordinateRing: self]! !

!Ring methodsFor: 'operations' stamp: 'len 8/21/2024 14:55:44'!
radical
	"Answer the Jacobson radical J(R) of the receiver R. This is the ideal consisting of all elements that annihilate all simple R-modules. It is the intersection of all maximal ideals. (See also >>nilradical.)"
	| generators one |
	self isLocal ifTrue: [^ self maximalIdeal].
	(self isCommutative and: [self isFinitelyGeneratedAlgebra and: [self scalars isField or: [self scalars = ℤ]]]) ifTrue: [^ self nilradical].
	self isFinite ifFalse: [^ self notYetImplemented].
	generators := Set new.
	one := self one.
	self do: [:x| (self elements allSatisfy: [:y| (one - (x*y)) isUnit]) ifTrue: [generators add: x]].
	^ self * generators

"alternative:
	| answer |
	answer _ self oneIdeal.
	self maximalIdealsDo: [:each| answer _ answer ∩ each].
	^ answer"! !

!Ring methodsFor: 'operations' stamp: 'len 10/15/2023 13:43:00'!
radicalContains: anElement
	"Answer true if the Jacobson radical J(R) of the receiver R contains anElement."
	"See [Ebe89, Theorem 2.3.2 and Corollary 2.3.3]."
	self isFiniteAlgebra ifTrue: [^ self linearGenerators allSatisfy: [:each| (anElement * each) trace isZero]].
	^ self radical contains: anElement! !

!Ring methodsFor: 'operations' stamp: 'len 6/27/2019 11:14:42'!
reduced
	"Answer the associated reduced ring. This is the quotient by the ideal of all nilpotent elements (the nilradical)."
	^ self / self nilradical! !

!Ring methodsFor: 'operations' stamp: 'len 5/10/2020 10:14:32'!
reducibles
	^ self select: [:each| each isReducible]! !

!Ring methodsFor: 'operations' stamp: 'len 12/19/2021 19:52:34'!
residueField
	"If the receiver is a local ring R with unique maximal ideal M, this returns R/M."
	^ self / self maximalIdeal! !

!Ring methodsFor: 'operations' stamp: 'len 12/1/2023 18:22:52'!
separableClosure
	"Answer the maximal Galois extension of the receiver."
	self isPerfectField ifTrue: [^ self algebraicClosure].
	^ self notYetImplemented! !

!Ring methodsFor: 'operations' stamp: 'len 7/30/2022 12:08:03'!
spec
	"This is the Spec functor. Answer the spectrum of the receiver as an affine scheme."
	self assert: self isCommutative.
	^ self propertyAt: #spec ifAbsentPut: [AffineScheme coordinateRing: self]! !

!Ring methodsFor: 'operations' stamp: 'len 12/18/2023 10:13:16'!
sub: aCollection
	"Answer the subring generated by the argument, which can be either a collection containing any objects that can be coerced to the receiver, or in the case of finite algebras it can be a submodule of the receiver's underlying module."
	self isAmbient ifFalse: [^ self ambient sub: aCollection].
	self isFiniteAlgebra ifFalse: [^ self subclassResponsibility].
	((aCollection isKindOf: Module) and: [aCollection ⊆ self asModule])
		ifTrue: [^ FiniteAlgebra new ambient: self; module: aCollection].
	^ FiniteAlgebra new ambient: self; module: (self asModule sub: aCollection)! !

!Ring methodsFor: 'operations' stamp: 'len 12/23/2023 10:31:04'!
units
	"Answer the multiplicative group of units of the receiver (i.e., elements that have multiplicative inverse).
	This is the natural functor from the cateogry of rings to the category of groups which sends each ring R to its group of units U(R) and each ring homomorphism to the restriction to U(R). This functor has a left adjoint which sends each group G to the integral group ring ℤ[G]."
	^ UnitGroup on: self! !

!Ring methodsFor: 'operations' stamp: 'len 11/22/2023 11:11:20'!
zeroDivisors
	self isIntegralDomain ifTrue: [^ {self zero}].
	^ self select: [:each| each isZeroDivisor]! !

!Ring methodsFor: 'operations' stamp: 'len 10/18/2023 09:48:50'!
∩ aSubring
	"Answer the intersection of the receiver and the argument."
	(self ambient = aSubring ambient and: [self ambient isFiniteAlgebra])
		ifTrue: [^ self ambient sub: self asModule ∩ aSubring asModule].
	^ super ∩ aSubring! !

!Ring methodsFor: 'operations' stamp: 'len 7/6/2021 14:08:40'!
⊕ aRing
	"Answer the direct sum of the receiver with the argument."
	^ self × aRing! !

!Ring methodsFor: 'random' stamp: 'len 6/26/2024 08:54:40'!
atRandom: aRandom
	(self isFiniteAlgebra and: [self scalars ~= self]) ifTrue: [^ self !! (self asModule atRandom: aRandom)].
	^ super atRandom: aRandom! !

!Ring methodsFor: 'random' stamp: 'len 6/26/2024 08:54:23'!
atRandom: aRandom bits: bitSize
	(self isFiniteAlgebra and: [self scalars ~= self]) ifTrue: [^ self !! (self asModule atRandom: aRandom bits: bitSize)].
	^ super atRandom: aRandom bits: bitSize! !

!Ring methodsFor: 'random' stamp: 'len 7/17/2023 19:00:58'!
unitAtRandom: aRandom
	| answer |
	"If it's not a field but it has canonical associates we take the normalization of an element at random:"
	(self hasCanonicalAssociates and: [self isField not]) ifTrue: [^ (self atRandom: aRandom) normalization].
	"If it's a field we do this because it's faster (it doesn't need to compute inverses):"
	[(answer := self atRandom: aRandom) isUnit] whileFalse.
	^ answer! !

!Ring methodsFor: 'random' stamp: 'len 6/5/2022 13:24:26'!
unitAtRandom: aRandom bits: bitSize
	| answer |
	self hasCanonicalAssociates ifTrue: [^ (self atRandom: aRandom bits: bitSize) normalization].
	bitSize > 0 ifFalse: [^ self one].
	bitSize > 1 ifFalse: [^ aRandom nextBoolean ifTrue: [self one] ifFalse: [self one negated]].
	[(answer _ self atRandom: aRandom bits: bitSize) isUnit] whileFalse.
	^ answer! !

!Ring methodsFor: 'testing' stamp: 'len 6/3/2022 07:31:13'!
hasCanonicalAssociates
	"Answer true if this ring is equipped with an algorithm to make a canonical choice of associate for each element.
	See RingElement>>#normalized."
	^ self isField! !

!Ring methodsFor: 'testing' stamp: 'len 12/22/2022 19:39:27'!
hasCanonicalBases
	"Answer true if there's an algorithm to compute canonical bases for modules over the receiver."
	^ self isEuclidean! !

!Ring methodsFor: 'testing' stamp: 'len 12/22/2022 19:39:45'!
hasCanonicalReduction
	"Answer true if this ring is equipped with an algorithm to make a canonical choice of coset representatives modulo an ideal."
	^ self isField! !

!Ring methodsFor: 'testing' stamp: 'len 6/3/2022 07:33:50'!
hasGCD
	"Answer true if the receiver is known to have computable GCDs
	(for example if it's a UFD or an Euclidean ring and implements an algorithm for GCDs)."
	^ self isEuclidean! !

!Ring methodsFor: 'testing' stamp: 'len 10/13/2022 10:24:57'!
isAffineAlgebra
	"Answer true if the receiver is a polynomial ring or a quotient of a polynomial ring."
	^ false! !

!Ring methodsFor: 'testing' stamp: 'len 1/12/2022 18:06:48'!
isAlgebraicallyClosed
	^ false "undefined"! !

!Ring methodsFor: 'testing' stamp: 'len 10/14/2023 09:21:18'!
isAnticommutative
	self isCommutative ifTrue: [^ false].
	(self isAmbient not and: [self ambient isAnticommutative]) ifTrue: [^ true].
	^ self propertyAt: #isAnticommutative ifAbsentPut:
		[self generators allSatisfy: [:x| self generators allSatisfy: [:y| x == y or: [x*y = (y*x) negated]]]]! !

!Ring methodsFor: 'testing' stamp: 'len 10/10/2023 21:44:39'!
isArtinian
	"A ring is called Artinian if it satisfies the descending chain condition on ideals.
	In the noncommutative case, one should talk about 'left Artinian' or 'right Artinian' rings."
	self isFinite ifTrue: [^ true].
	self isIntegralDomain ifTrue: [^ self isField].
	^ self isNoetherian and: [self isZeroDimensional]! !

!Ring methodsFor: 'testing' stamp: 'len 12/21/2022 13:26:56'!
isBezout
	"Answer true if the receiver is a Bezout ring, i.e. every finitely generated ideal is principal."
	self isEuclidean ifTrue: [^ true]. "every Euclidean ring is PIR, i.e. it is Bézout and Noetherian"
"	self isPIR ifTrue: [^ true]. <- could be recursive"
	^ false "undefined"! !

!Ring methodsFor: 'testing' stamp: 'len 12/21/2022 13:27:10'!
isBezoutDomain
	"An integral domain is Bézout if any finitely generated ideal is principal.
	This is the constructive algebra approximation to PID, adding 'finitely generated'.
	1) Any Bezout domain is coherent;
	2) A Bezout domain is strongly discrete iff we can decide divisibility."
	self isEuclideanDomain ifTrue: [^ true].
	^ self isIntegralDomain and: [self isBezout]! !

!Ring methodsFor: 'testing' stamp: 'len 10/14/2023 09:22:25'!
isCentral
	^ self isCommutative or: [self center = (self sub: {self one})]! !

!Ring methodsFor: 'testing' stamp: 'len 11/8/2023 13:20:53'!
isCommutative
	(self isAmbient not and: [self ambient isCommutative]) ifTrue: [^ true].
	^ self propertyAt: #isCommutative ifAbsentPut:
		[self generators allSatisfy: [:x| self generators allSatisfy: [:y| x == y or: [x*y = (y*x)]]]]! !

!Ring methodsFor: 'testing' stamp: 'len 8/7/2019 12:33:03'!
isDVR
	"Answer true if the receiver is a discrete valuation ring, i.e. a local PID that is not a field.
	Equivalently, a DVR is a Noetherian local domain whose maximal ideal is principal and different from {0}."
	^ self isLocal and: [self isPID and: [self isField not]]! !

!Ring methodsFor: 'testing' stamp: 'len 1/12/2022 17:54:34'!
isDedekindDomain
	"A Dedekind domain is an integral domain in which every nonzero proper ideal factors into a product of prime ideals."
	self isPID ifTrue: [^ true].
	^ false "undefined"! !

!Ring methodsFor: 'testing' stamp: 'len 1/12/2022 18:07:56'!
isDivisionRing
	"A division ring, or skewfield, is a ring where division is possible, i.e. every nonzero element has a multiplicative inverse. The only difference with a field is that a division ring is not requiered to be commutative."
	self isField ifTrue: [^ true].
	^ false "undefined"! !

!Ring methodsFor: 'testing' stamp: 'len 6/28/2023 19:04:33'!
isElementaryDivisorRing
	"Answer true if every matrix over the receiver is equivalent to a diagonal matrix.
	Warning: it might be an elementary divisor ring without being Euclidean, but in the constructive setting we may not have a way of testing if it is, or we may not have an algorithm to compute the Smith normal form."
	^ self isEuclidean! !

!Ring methodsFor: 'testing' stamp: 'len 6/3/2022 06:54:43'!
isEuclidean
	"Answer true if the receiver is a Euclidean ring, i.e. it has Euclidean division with remainder."
	self isField ifTrue: [^ true].
	"Warning: it might be Euclidean, but in the constructive setting we may not have a way to testing if it is, or we may not have an implementation of Euclidean division"
	^ false "undefined"! !

!Ring methodsFor: 'testing' stamp: 'len 5/8/2020 18:21:38'!
isEuclideanDomain
	"Answer true if the receiver is a Euclidean domain, i.e. an integral domain that has division with remainder."
	^ self isIntegralDomain and: [self isEuclidean]! !

!Ring methodsFor: 'testing' stamp: 'len 6/3/2022 06:56:14'!
isField
	"Answer true if the receiver is a field.
	Warning: it might be a field, but in the constructive setting we may not have a way of testing if it is a field."
	^ false "undefined"! !

!Ring methodsFor: 'testing' stamp: 'len 10/20/2023 11:06:21'!
isFiniteAlgebra
	"Answer true if the receiver is a finite algebra (i.e., the underlying module is finitely generated)."
	^ false! !

!Ring methodsFor: 'testing' stamp: 'len 7/15/2021 16:07:41'!
isFiniteField
	^ self isFinite and: [self isField]! !

!Ring methodsFor: 'testing' stamp: 'len 8/21/2024 14:52:57'!
isFinitelyGenerated
	^ self isFinitelyGeneratedAlgebra and: [self scalars = ℤ]! !

!Ring methodsFor: 'testing' stamp: 'len 8/21/2024 14:53:22'!
isFinitelyGeneratedAlgebra
	^ false! !

!Ring methodsFor: 'testing' stamp: 'len 6/5/2022 18:24:31'!
isFlat
	"An R-algebra is called flat if it is flat as R-module."
	^ self asModule isFlat! !

!Ring methodsFor: 'testing' stamp: 'len 5/7/2023 23:34:33'!
isGaloisExtension
	"A Galois extension is an algebraic field extension E/F that is normal and separable, or equivalently E/F is algebraic and the field fixed by the automorphism group Aut(E/F) is the base field F. The significance of being a Galois extension is that it has a Galois group and obeys the fundamental theorem of Galois theory."
	^ false "undefined"! !

!Ring methodsFor: 'testing' stamp: 'len 9/19/2018 07:15:55'!
isGaloisRing
	^ false! !

!Ring methodsFor: 'testing' stamp: 'len 1/26/2018 18:58:30'!
isGlobalField
	^ false! !

!Ring methodsFor: 'testing' stamp: 'len 7/6/2022 05:56:51'!
isGraded
	"Answer true if the receiver is a graded ring."
	^ false! !

!Ring methodsFor: 'testing' stamp: 'len 6/3/2022 07:10:34'!
isIntegralDomain
	"A ring is an integral domain if the product of any two nonzero elements is nonzero.
	Warning: it might be an integral domain, but in the constructive setting we may not have a way of testing if it is."
	^ self isField
	
"
	self propertyAt: #isIntegralDomain ifPresent: [:aBoolean| ^ aBoolean].
	self isCommutative ifFalse: [^ false].
	self isFinite ifTrue: [^ self propertyAt: #isIntegralDomain put: (self zeroDivisors allSatisfy: [:each| each isZero])].
"! !

!Ring methodsFor: 'testing' stamp: 'len 6/3/2022 06:55:55'!
isIntegrallyClosedDomain
	"A ring is an integrally closed domain if it is an integral domain whose integral closure in its field of fractions is the ring itself."
	self isUFD ifTrue: [^ true].
	"Warning: it might be an integrally closed domain, but in the constructive setting we may not have a way of testing if it is."
	^ false "undefined"! !

!Ring methodsFor: 'testing' stamp: 'len 7/25/2021 10:08:44'!
isInvolutive
	"Answer true if the receiver is a *-ring (or involutive ring), i.e. it has an involution that is an antiautomorphism.
	Elements of involutive rings must implement the involution with the message #conjugate."
	^ false! !

!Ring methodsFor: 'testing' stamp: 'len 10/14/2023 09:25:07'!
isJordan
	"Answer true if the receiver is a Jordan algebra: it is commutative and satisfies the Jordan identity.
	Since rings are associative, they always satisfy the Jordan identity."
	^ self isCommutative! !

!Ring methodsFor: 'testing' stamp: 'len 5/20/2018 21:57:40'!
isLocal
	"Answer true if the receiver is a local ring. Subclasses should reimplement."
	^ self isDivisionRing! !

!Ring methodsFor: 'testing' stamp: 'len 1/26/2018 18:58:19'!
isLocalField
	^ false! !

!Ring methodsFor: 'testing' stamp: 'len 8/6/2019 18:08:24'!
isLocalization
	"Answer true if the receiver is a localization of a ring (a ring of fractions, a localization at a prime ideal, etc).
	This means that elements of the receiver are formal fractions."
	^ false! !

!Ring methodsFor: 'testing' stamp: 'len 7/27/2021 11:38:22'!
isMultivariate
	^ false! !

!Ring methodsFor: 'testing' stamp: 'len 12/21/2022 13:27:16'!
isNoetherian
	"A ring is called Noetherian if every ideal is finitely generated.
	This is equivalent to the ring satisfying the ascending chain condition (every ascending chain of ideals is finite), and it is also equivalent to the condition that any set of ideals contains a maximal element."
	self isFinite ifTrue: [^ true].
"	self isField ifTrue: [^ true]. already included in isEuclidean"
	self isEuclidean ifTrue: [^ true]. "every Euclidean ring is PIR, i.e. it is Bézout and Noetherian"
	self isPID ifTrue: [^ true].
	self isDedekindDomain ifTrue: [^ true].
	^ false "undefined"! !

!Ring methodsFor: 'testing' stamp: 'len 1/12/2022 18:10:10'!
isPID
	"A principal ideal domain (PID) is an integral domain in which every ideal is principal, i.e. can be generated by a single element.
	PIDs are Noetherian, integrally closed, and they are UFDs and Dedekind domains.
	All Euclidean domains and all fields are PIDs."
	self isEuclideanDomain ifTrue: [^ true].
	self isIntegralDomain ifFalse: [^ false].
	^ false "undefined"! !

!Ring methodsFor: 'testing' stamp: 'len 6/16/2019 14:05:16'!
isPIR
	"A principal ideal ring (PIR) is a ring in which every ideal is principal, i.e. can be generated by a single element.
	In a PIR any two nonzero elements have a well-defined GCD."
	"Principal ideal rings are exactly the rings that are both Bezout and Noetherian:"
	^ self isBezout and: [self isNoetherian]! !

!Ring methodsFor: 'testing' stamp: 'len 11/5/2023 09:25:11'!
isPerfectField
	"A field is perfect if either it has characteristic 0 or has characteristic p and every element in the field has a p-th root in the field (or equivalently, the Frobenius endomorphism is an automorphism)."
	self isField ifFalse: [^ false].
	(self characteristic = 0 or: [self isFinite]) ifTrue: [^ true].
	self isAlgebraicallyClosed ifTrue: [^ true].
	^ false "undefined"! !

!Ring methodsFor: 'testing' stamp: 'len 7/29/2022 10:34:58'!
isPrimeField
	"Answer true if the receiver is a field and it has no proper subfields."
	^ false! !

!Ring methodsFor: 'testing' stamp: 'len 4/12/2021 14:53:51'!
isQuotient
	"Answer true if the receiver is a quotient ring R/I."
	^ false! !

!Ring methodsFor: 'testing' stamp: 'len 8/9/2020 07:59:51'!
isReal
	"Answer true if the receiver is a subring of the real field."
	^ false! !

!Ring methodsFor: 'testing' stamp: 'len 5/13/2022 12:09:13'!
isReduced
	"A ring is called 'reduced' if it has no nonzero nilpotents, i.e. if r^n = 0 for some n >> 0, then r = 0. In other words, its nilradical is trivial."
	self isIntegralDomain ifTrue: [^ true].
	^ self noneSatisfy: [:any| any squared isZero and: [any isZero not]]
	
"alternatively:
	^ self nilradical isTrivial"! !

!Ring methodsFor: 'testing' stamp: 'len 7/5/2021 12:16:28'!
isRing
	^ true! !

!Ring methodsFor: 'testing' stamp: 'len 1/12/2022 17:55:07'!
isSemilocal
	"A ring is called 'semilocal' if it contains a finite number of maximal ideals."
	self isFinite ifTrue: [^ true]. "Finite rings are semilocal."
	self isLocal ifTrue: [^ true]. "Local rings have 1 maximal ideal"
	^ false "undefined"! !

!Ring methodsFor: 'testing' stamp: 'len 10/18/2023 09:37:25'!
isSemisimple
	"A semisimple ring R is one obeying any of the following equivalent conditions:
	- R is Artinian ring with vanishing Jacobson radical;
	- R is a finite product of simple Artinian rings;
	- Every (left or right) R-module is projective.
	A commutative ring is semisimple iff it is both Artinian and reduced." 
	^ self isArtinian and: [self radical isTrivial]! !

!Ring methodsFor: 'testing' stamp: 'len 10/18/2023 09:33:57'!
isSimple
"	self isArtinian ifTrue: [^ self radical isTrivial]."
	^ self compositionFactors allSatisfy: [:each| each isTrivial]! !

!Ring methodsFor: 'testing' stamp: 'len 12/6/2023 09:32:35'!
isTrivial
	"The trivial ring is the zero ring with a single element 0 = 1."
	^ self one = self zero! !

!Ring methodsFor: 'testing' stamp: 'len 6/16/2022 18:27:20'!
isUFD
	"A unique factorization domain (UFD) is a commutative ring in which every nonzero nonunit element can be written as a product of prime elements (or irreducible elements), uniquely up to order and associates."
	^ self isIntegralDomain and: [self isUFR]! !

!Ring methodsFor: 'testing' stamp: 'len 6/16/2022 18:26:37'!
isUFR
	"A unique factorization ring (UFR) is a commutative ring in which every nonzero nonunit element can be written as a product of irreducible elements, uniquely up to order and associates."
	self isPID ifTrue: [^ true].
	^ false "undefined"! !

!Ring methodsFor: 'testing' stamp: 'len 10/10/2023 21:45:47'!
isZeroDimensional
	"Answer true if the receiver has Krull dimension 0."
	^ self dimension = 0! !

!Ring methodsFor: 'private' stamp: 'len 5/31/2023 08:36:58'!
extensionClass
	^ ExtensionRing! !

!Ring methodsFor: 'private' stamp: 'len 4/6/2021 13:28:11'!
idealClass
	^ Ideal! !

!Ring methodsFor: 'private' stamp: 'len 5/14/2023 17:54:27'!
isValidArray: anArray
	^ anArray isArray! !

!Ring methodsFor: 'private' stamp: 'len 6/14/2024 02:17:23'!
species
	^ Ring! !

!Ring class methodsFor: 'instance creation' stamp: 'len 7/14/2024 07:47:09'!
elements: anObject
	self assert: self = Ring.
	^ self new propertyAt: #elements put: anObject; yourself! !

!EndomorphismRing methodsFor: 'accessing' stamp: 'len 1/9/2024 11:05:09'!
codomain
	^ self space! !

!EndomorphismRing methodsFor: 'accessing' stamp: 'len 1/9/2024 11:05:06'!
domain
	^ self space! !

!EndomorphismRing methodsFor: 'accessing' stamp: 'len 12/2/2023 08:15:14'!
one
	^ space id! !

!EndomorphismRing methodsFor: 'accessing' stamp: 'len 5/9/2024 05:56:26'!
scalars
	^ self isFiniteAlgebra ifTrue: [space scalars] ifFalse: [ℤ]! !

!EndomorphismRing methodsFor: 'accessing' stamp: 'len 5/9/2024 08:48:33'!
size
	^ self isFiniteAlgebra ifTrue: [self asModule size] ifFalse: [super size]! !

!EndomorphismRing methodsFor: 'accessing' stamp: 'len 12/2/2023 08:14:48'!
space
	^ space! !

!EndomorphismRing methodsFor: 'accessing' stamp: 'len 8/19/2024 09:41:08'!
underlyingSet
	^ self asMonoid underlyingSet! !

!EndomorphismRing methodsFor: 'comparing' stamp: 'len 12/2/2023 08:13:20'!
= anObject
	^ self class = anObject class and: [space = anObject space]! !

!EndomorphismRing methodsFor: 'comparing' stamp: 'len 12/2/2023 08:13:36'!
hash
	^ space hash! !

!EndomorphismRing methodsFor: 'converting' stamp: 'len 5/9/2024 15:12:39'!
asModule
	^ self propertyAt: #asModule ifAbsentPut:
		[self assert: (space isModule and: [space scalars isCommutative or: [space scalars isInvolutive]]).
		space ⇒ space]! !

!EndomorphismRing methodsFor: 'converting' stamp: 'len 12/2/2023 14:29:39'!
asMonoid
	^ self propertyAt: #asMonoid ifAbsentPut: [EndomorphismMonoid on: space]! !

!EndomorphismRing methodsFor: 'elements' stamp: 'len 4/6/2024 15:54:37'!
adapt: anElement
	^ (super adapt: anElement) ifNil: [space to: space adapt: anElement]! !

!EndomorphismRing methodsFor: 'elements' stamp: 'len 5/9/2024 08:43:09'!
diagonal: anArray
	^ space to: space diagonal: anArray! !

!EndomorphismRing methodsFor: 'elements' stamp: 'len 1/9/2024 11:04:24'!
fill: aBlock
	^ self domain to: self codomain fill: aBlock! !

!EndomorphismRing methodsFor: 'elements' stamp: 'len 12/2/2023 08:15:22'!
images: anArray
	^ space to: space images: anArray! !

!EndomorphismRing methodsFor: 'elements' stamp: 'len 12/2/2023 08:15:27'!
map: aBlock
	^ space to: space map: aBlock! !

!EndomorphismRing methodsFor: 'elements' stamp: 'len 12/2/2023 08:15:32'!
mapWithArguments: aBlock
	^ space to: space mapWithArguments: aBlock! !

!EndomorphismRing methodsFor: 'elements' stamp: 'len 5/9/2024 08:39:51'!
newFrom: anObject
	anObject isEvaluable ifTrue: [^ self map: anObject].
	self isFiniteAlgebra ifTrue: [(self asModule newFrom: anObject) ifNotNil: [:anElement| ^ self !! anElement]].
	^ super newFrom: anObject! !

!EndomorphismRing methodsFor: 'elements' stamp: 'len 5/9/2024 08:44:09'!
scalar: anElement
	^ self map: [:x| x * anElement]! !

!EndomorphismRing methodsFor: 'enumerating' stamp: 'len 8/19/2024 09:41:08'!
do: aBlock
	self underlyingSet do: aBlock! !

!EndomorphismRing methodsFor: 'morphisms' stamp: 'len 6/1/2024 07:03:47'!
from: aRing
	aRing == self scalars ifTrue: [^ self addMap: ((self scalars to: self map: [:x| self one * x]) name: 'ι')].
	aRing ⇢ self scalars ifNotNil: [:aMorphism| ^ self scalars → self · aMorphism].
	^ super from: aRing! !

!EndomorphismRing methodsFor: 'operations' stamp: 'len 12/11/2023 09:50:50'!
units
	"Answer the multiplicative group of units of the receiver (i.e., elements that have multiplicative inverse)."
	^ self space automorphisms! !

!EndomorphismRing methodsFor: 'printing' stamp: 'len 12/2/2023 08:15:43'!
printOn: aStream
	aStream nextPutAll: 'End'; nextPut: $(; print: space; nextPut: $)! !

!EndomorphismRing methodsFor: 'random' stamp: 'len 8/19/2024 09:41:08'!
atRandom: aRandom
	^ self underlyingSet atRandom: aRandom! !

!EndomorphismRing methodsFor: 'random' stamp: 'len 8/19/2024 14:39:27'!
atRandom: aRandom bits: bitSize
	^ self underlyingSet atRandom: aRandom bits: bitSize! !

!EndomorphismRing methodsFor: 'random' stamp: 'len 3/27/2024 14:08:39'!
unitAtRandom: aRandom
	^ self units atRandom: aRandom! !

!EndomorphismRing methodsFor: 'random' stamp: 'len 3/27/2024 14:08:54'!
unitAtRandom: aRandom bits: bitSize
	^ self units atRandom: aRandom bits: bitSize! !

!EndomorphismRing methodsFor: 'testing' stamp: 'len 12/2/2023 08:16:11'!
includes: anObject
	^ anObject isMorphism and: [anObject domain = space and: [anObject isEndomorphism]]! !

!EndomorphismRing methodsFor: 'testing' stamp: 'len 5/9/2024 05:47:13'!
isDivisionRing
	"If a module is simple, its endomorphism ring is a division ring (by Schur's lemma)."
	^ ((self space isKindOf: Module) and: [self space isSimple]) or: [super isDivisionRing]! !

!EndomorphismRing methodsFor: 'testing' stamp: 'len 5/9/2024 15:11:25'!
isFiniteAlgebra
	^ space isModule and: [space scalars isCommutative "or: [space scalars isInvolutive]"]! !

!EndomorphismRing methodsFor: 'private' stamp: 'len 12/2/2023 08:16:21'!
space: aDomain
	space := aDomain! !

!EndomorphismRing class methodsFor: 'instance creation' stamp: 'len 12/2/2023 08:16:35'!
on: aDomain
	^ self new space: aDomain! !

!MatrixRing methodsFor: 'accessing' stamp: 'len 5/9/2024 08:49:43'!
characteristic
	^ space scalars characteristic! !

!MatrixRing methodsFor: 'accessing' stamp: 'len 5/9/2024 07:01:50'!
degree
	^ space rank! !

!MatrixRing methodsFor: 'accessing' stamp: 'len 5/9/2024 08:46:20'!
size
	^ space size squared! !

!MatrixRing methodsFor: 'computing-matrices' stamp: 'len 5/9/2024 07:02:44'!
flattenMatrix: aMatrix
	| R d answer |
	R := self scalars.
	d := self space rank.
	answer := R^(aMatrix width*d) → (R^0).
	1 to: aMatrix height do: [:i|
		| a |
		a := R^0 → (R^d).
		1 to: aMatrix width do: [:j| a := a ⊔ (aMatrix at: i@j)].
		answer := answer ⊓ a].
	^ answer! !

!MatrixRing methodsFor: 'computing-matrices' stamp: 'len 5/9/2024 07:04:19'!
matrix: B quotientBy: A
	"Answer X such that AX + N = B, satisfying that if the i-th column of B is a linear combination of the columns of A then the i-th column of N is zero."
	^ self unflattenMatrix: ((self flattenMatrix: B) quotientBy: (self flattenMatrix: A))! !

!MatrixRing methodsFor: 'computing-matrices' stamp: 'len 5/9/2024 07:03:59'!
unflattenMatrix: aMatrix
	| d |
	d := self space rank.
	^ self^(aMatrix width / d) ⇒ (self^(aMatrix height / d)) fill: [:i :j|
		(self asModule fill: [:i0 :j0| aMatrix at: (i-1*d+i0) @ (j-1*d+j0)])]! !

!MatrixRing methodsFor: 'elements' stamp: 'len 5/9/2024 07:02:03'!
columns: anArray
	^ self asModule columns: anArray! !

!MatrixRing methodsFor: 'elements' stamp: 'len 5/9/2024 07:03:54'!
rows: anArray
	^ self asModule rows: anArray! !

!MatrixRing methodsFor: 'elements' stamp: 'len 5/9/2024 07:15:54'!
scalar: anElement
	^ space to: space scalar: anElement! !

!MatrixRing methodsFor: 'printing' stamp: 'len 5/9/2024 07:03:48'!
printOn: aStream
	aStream nextPutAll: 'ℳ', self degree printString sub, '('; print: self scalars; nextPut: $)! !

!MatrixRing methodsFor: 'testing' stamp: 'len 5/9/2024 07:02:53'!
hasCanonicalAssociates
	^ self scalars isEuclideanDomain! !

!MatrixRing methodsFor: 'testing' stamp: 'len 5/9/2024 07:03:13'!
isCommutative
	^ self degree = 1 and: [self scalars isCommutative]! !

!MatrixRing methodsFor: 'testing' stamp: 'len 5/9/2024 07:03:20'!
isDivisionRing
	self scalars isField ifTrue: [^ self degree = 1].
	^ super isDivisionRing! !

!MatrixRing methodsFor: 'testing' stamp: 'len 5/9/2024 07:03:25'!
isField
	^ self degree = 1 and: [self scalars isField]! !

!MatrixRing methodsFor: 'testing' stamp: 'len 5/9/2024 07:03:30'!
isInvolutive
	^ true! !

!MatrixRing methodsFor: 'testing' stamp: 'len 5/9/2024 07:03:35'!
isPID
	^ self degree = 1 and: [self scalars isPID]! !

!MatrixRing methodsFor: 'testing' stamp: 'len 5/9/2024 07:03:40'!
isSimple
	self scalars isField ifTrue: [^ self degree > 0].
	^ super isSimple! !

!FractionRing methodsFor: 'accessing' stamp: 'len 11/20/2022 11:22:54'!
characteristic
	^ self numerators characteristic! !

!FractionRing methodsFor: 'accessing' stamp: 'len 11/20/2022 11:18:57'!
numerators
	^ self propertyAt: #numerators! !

!FractionRing methodsFor: 'accessing' stamp: 'len 11/20/2022 11:23:56'!
one
	^ self embed: self numerators one! !

!FractionRing methodsFor: 'accessing' stamp: 'len 11/20/2022 11:24:39'!
size
	self numerators isFinite ifFalse: [^ self numerators size].
	^ super size! !

!FractionRing methodsFor: 'accessing' stamp: 'len 11/20/2022 11:24:43'!
uniformizer
	"A uniformizer (or uniformizing parameter, uniformizer element or prime element) is any irreducible element of a DVR, or equivalently a generator of the maximal ideal. All nonzero ideals are generated by some power of the uniformizer."
	^ self embed: self numerators uniformizer! !

!FractionRing methodsFor: 'accessing' stamp: 'len 11/20/2022 11:24:50'!
zero
	^ self embed: self numerators zero! !

!FractionRing methodsFor: 'comparing' stamp: 'len 11/20/2022 11:21:33'!
= anObject
	self == anObject ifTrue: [^ true].
	^ (anObject isKindOf: FractionRing) and: [self numerators = anObject numerators]! !

!FractionRing methodsFor: 'comparing' stamp: 'len 11/20/2022 11:23:22'!
hash
	^ self numerators hash! !

!FractionRing methodsFor: 'computing-matrices' stamp: 'len 12/15/2022 13:05:04'!
matrix: B quotientBy: A
	"Answer X such that AX + N = B, satisfying that if the i-th column of B is a linear combination of the columns of A then the i-th column of N is zero."
	| X d1 d2 |
	X _ self^0 → A domain.
	d1 _ A denominator.
	d2 _ B denominator.
	B numerator columnsDo: [:b| | L i x |
		L _ (b asMatrix ⊔ A numerator) syzygies.
		i _ (1 to: L width) detect: [:k| (L at: 1@k) isZeroDivisor not] ifNone: [].
		x _ i isNil ifTrue: [A domain zero] ifFalse: [((L copyFrom: 2@i to: L height@i) over: self) * (self numerator: d1 negated denominator: d2 * (L at: 1@i))].
		X _ X ⊔ x].
	^ X! !

!FractionRing methodsFor: 'computing-matrices' stamp: 'len 12/15/2022 11:14:40'!
syzygiesOf: aMatrix
	"Answer a matrix whose rows span the kernel of the given matrix.
	For a matrix A, the output is X with AX = 0."
	^ aMatrix numerator syzygies over: self! !

!FractionRing methodsFor: 'converting' stamp: 'len 11/20/2022 11:24:00'!
over: aRing
	"Change the base ring."
	^ self class on: (self numerators over: aRing)! !

!FractionRing methodsFor: 'elements' stamp: 'len 11/20/2022 11:22:24'!
adapt: anElement
	(self numerators includes: anElement) ifTrue: [^ self embed: anElement].
	(self numerators adapt: anElement) ifNotNil: [:numerator| ^ self embed: numerator].
	^ super adapt: anElement! !

!FractionRing methodsFor: 'elements' stamp: 'len 12/29/2021 14:05:14'!
numerator: anElement denominator: anotherElement
	^ (self reducedNumerator: anElement denominator: anotherElement) reduce! !

!FractionRing methodsFor: 'elements' stamp: 'len 11/20/2022 11:24:17'!
reducedNumerator: anElement denominator: anotherElement
	"anotherElement isZeroDivisor ifTrue: [^ self error: 'denominator cannot be a zero divisor']."
	self assert: ((self numerators includes: anElement) and: [self numerators includes: anotherElement]).
	^ Ratio reducedNumerator: anElement denominator: anElement one! !

!FractionRing methodsFor: 'elements' stamp: 'len 3/21/2021 13:28:22'!
x
	^ self x: 1! !

!FractionRing methodsFor: 'elements' stamp: 'len 11/20/2022 11:24:47'!
x: anInteger
	^ self embed: (self numerators x: anInteger)! !

!FractionRing methodsFor: 'morphisms' stamp: 'len 12/29/2021 14:00:44'!
embed: anElement
	^ self reducedNumerator: anElement denominator: anElement one! !

!FractionRing methodsFor: 'morphisms' stamp: 'len 6/1/2024 07:04:09'!
from: aRing
	aRing = self numerators ifTrue: [^ self addMap: ((self numerators to: self map: [:x| self embed: x]) name: 'ι')].
	aRing ⇢ self numerators ifNotNil: [:aMorphism| ^ self numerators → self · aMorphism].
	aRing class = self class ifTrue: [aRing numerators ⇢ self numerators ifNotNil: [:aMorphism| ^ self to: aRing map: [:each| (aMorphism value: each numerator) / (aMorphism value: each denominator)]]].
	^ super from: aRing! !

!FractionRing methodsFor: 'operations' stamp: 'len 2/28/2017 19:59:48'!
fractions
	^ self! !

!FractionRing methodsFor: 'printing' stamp: 'len 11/20/2022 11:24:07'!
printOn: aStream
	aStream nextPutAll: 'Frac('; print: self numerators; nextPut: $)! !

!FractionRing methodsFor: 'random' stamp: 'len 11/20/2022 11:22:35'!
atRandom: aRandom
	| a b |
	a _ self numerators atRandom: aRandom.
	[(b _ self numerators atRandom: aRandom) isZeroDivisor] whileTrue.
	^ (self embed: a) / (self embed: b)! !

!FractionRing methodsFor: 'random' stamp: 'len 11/20/2022 11:22:47'!
atRandom: aRandom bits: bitSize
	| a b |
	bitSize < 2 ifTrue: [^ self embed: (self numerators atRandom: aRandom bits: bitSize)].
	a _ self numerators atRandom: aRandom bits: bitSize/2.
	[(b _ self numerators atRandom: aRandom bits: bitSize/2) isZeroDivisor] whileTrue.
	^ (self embed: a) / (self embed: b)! !

!FractionRing methodsFor: 'testing' stamp: 'len 5/28/2023 17:52:05'!
hasCanonicalAssociates
	^ self numerators hasCanonicalAssociates or: [self isField]! !

!FractionRing methodsFor: 'testing' stamp: 'len 4/25/2020 09:57:00'!
includes: anObject
	^ anObject parent = self! !

!FractionRing methodsFor: 'testing' stamp: 'len 4/28/2021 09:33:18'!
isCommutative
	^ true! !

!FractionRing methodsFor: 'testing' stamp: 'len 11/20/2022 12:30:37'!
isDedekindDomain
	"A localization of a Dedekind domain at any multiplicative set is also a Dedekind domain."
	^ self numerators isDedekindDomain or: [super isDedekindDomain]! !

!FractionRing methodsFor: 'testing' stamp: 'len 11/20/2022 11:23:32'!
isField
	^ self numerators isIntegralDomain! !

!FractionRing methodsFor: 'testing' stamp: 'len 11/20/2022 11:23:34'!
isGraded
	^ self numerators isGraded! !

!FractionRing methodsFor: 'testing' stamp: 'len 8/6/2019 18:08:14'!
isLocalization
	"Answer true if the receiver is a localization of a ring (a ring of fractions, a localization at a prime ideal, etc).
	This means that elements of the receiver are formal fractions."
	^ true! !

!FractionRing methodsFor: 'testing' stamp: 'len 11/20/2022 11:23:37'!
isMultivariate
	^ self numerators isMultivariate! !

!FractionRing methodsFor: 'testing' stamp: 'len 11/20/2022 11:23:40'!
isNoetherian
	"A ring is called Noetherian if every ideal is finitely generated."
	^ self numerators isNoetherian or: [super isNoetherian]! !

!FractionRing methodsFor: 'testing' stamp: 'len 11/20/2022 11:23:42'!
isPIR
	"Answer true if the receiver is a principal ideal ring, i.e. all ideals are principal (but it is not necessarily a PID, i.e. it is not necessarily an integral domain)."
	"A localization of a PIR at any multiplicative subset is again a PIR."
	self numerators isPIR ifTrue: [^ true].
	^ super isPIR! !

!FractionRing methodsFor: 'testing' stamp: 'len 11/20/2022 11:23:46'!
isReduced
	"Answer true if the receiver has no nonzero nilpotent elements, or equivalently if it has no nonzero elements with square zero, i.e. x^2 = 0 implies x = 0."
	^ self numerators isReduced! !

!FractionRing methodsFor: 'testing' stamp: 'len 11/20/2022 11:23:49'!
isTrivial
	^ self numerators isTrivial! !

!FractionRing methodsFor: 'testing' stamp: 'len 11/20/2022 11:23:51'!
isUnivariate
	^ self numerators isUnivariate! !

!FractionRing methodsFor: 'private' stamp: 'len 11/20/2022 11:19:21'!
numerators: aRing
	self propertyAt: #numerators put: aRing! !

!FractionRing class methodsFor: 'instance creation' stamp: 'len 11/20/2022 11:19:29'!
on: aRing
	^ self new numerators: aRing! !

!RationalField methodsFor: 'accessing' stamp: 'len 5/23/2020 09:13:12'!
integers
	^ ℤ! !

!RationalField methodsFor: 'accessing' stamp: 'len 11/14/2023 13:52:43'!
maximalRealSubfield
	^ self! !

!RationalField methodsFor: 'accessing' stamp: 'len 11/20/2022 11:25:27'!
numerators
	^ ℤ! !

!RationalField methodsFor: 'accessing' stamp: 'len 11/8/2023 13:27:19'!
size
	^ ℕ size! !

!RationalField methodsFor: 'comparing' stamp: 'len 6/15/2022 09:53:13'!
= anObject
	^ anObject class = self class! !

!RationalField methodsFor: 'comparing' stamp: 'len 6/28/2016 09:27'!
hash
	^ self class hash! !

!RationalField methodsFor: 'computing-polynomials' stamp: 'len 6/25/2023 12:05:42'!
polynomial: aPolynomial factorizationDo: aBlock
	aPolynomial numerator primitivePart factorizationDo: [:f :r| aBlock value: aPolynomial parent !! f value: r]! !

!RationalField methodsFor: 'computing-polynomials' stamp: 'len 12/23/2023 16:21:31'!
rootsOf: aPolynomial withMultiplicitiesDo: aBlock
	"Enumerate the (real) rational roots of aPolynomial with multiplicities."
	| f n count τ visited fourier m |
	f := aPolynomial scalars = ℚ ifTrue: [aPolynomial integralPrimitivePart over: ℤ] ifFalse: [aPolynomial scalars = ℤ ifTrue: [aPolynomial primitivePart] ifFalse: [^ super rootsOf: aPolynomial withMultiplicitiesDo: aBlock]].
	n := f degree.
	(count := f order) > 0 ifTrue: [aBlock value: 0 asRational value: count. f := f >> count].
	f isConstant ifTrue: [^ self].
	visited := Set new.
	fourier := OrderedCollection with: f derivative.
	f independentCoefficient divisorsDo: [:each|
		f leadingCoefficient divisorsDo: [:one|
			τ := each / one.
			visited add: τ ifAbsent:
					[(f value: τ) isZero ifTrue:
						[aBlock value: τ value: (m := f multiplicityAt: τ fourier: fourier).
						(count := count + m) = n ifTrue: [^ self]].
					τ := τ negated.
					(f value: τ) isZero ifTrue:
						[aBlock value: τ value: (m := f multiplicityAt: τ fourier: fourier).
						(count := count + m) = n ifTrue: [^ self]]]]]! !

!RationalField methodsFor: 'elements' stamp: 'len 7/14/2021 09:50:04'!
reducedNumerator: anInteger denominator: anotherInteger
	self assert: (anInteger isInteger and: [anotherInteger isInteger]).
	^ Rational reducedNumerator: anInteger denominator: anotherInteger! !

!RationalField methodsFor: 'enumerating' stamp: 'len 7/16/2019 16:29:51'!
do: aBlock
	"Iterate over the rational numbers by breadth-first traversal of the Calkin-Wilf tree. This is an extension of the Calkin-Wilf sequence to include 0 and the negative numbers."
	aBlock value: self zero.
	self positiveDo: [:each| aBlock value: each; value: each negated]! !

!RationalField methodsFor: 'enumerating' stamp: 'len 10/11/2022 06:28:03'!
positiveDo: aBlock
	"Iterate over the rational numbers by breadth-first traversal of the Calkin-Wilf tree.
	The nodes of the Calkin-Wilf tree of any given depth level have height strictly greater than the height of their parents."
	| q |
	q _ 1.
	[aBlock value: self !! q. q _ 1 / (2 * q floor - q + 1)] repeat! !

!RationalField methodsFor: 'morphisms' stamp: 'len 7/14/2021 09:44:41'!
embed: anInteger
	^ self reducedNumerator: anInteger denominator: 1! !

!RationalField methodsFor: 'morphisms' stamp: 'len 4/16/2024 18:44:32'!
to: aRing
	"Answer the canonical morphism from the receiver to aCodomain."
	(aRing isField and: [aRing characteristic = 0])
		ifTrue: [^ self to: aRing map: [:x| aRing one * x numerator / (aRing one * x denominator)]].
	^ super to: aRing! !

!RationalField methodsFor: 'operations' stamp: 'len 11/22/2023 16:26:29'!
abelianClosure
	^ self propertyAt: #abelianClosure ifAbsentPut: [AbelianClosureField new]! !

!RationalField methodsFor: 'operations' stamp: 'len 11/20/2023 10:35:21'!
adjoin: aNumber
	| α answer |
	α := ℂ !! aNumber.
	aNumber isRational ifTrue: [^ self].
	answer := self extension: α minimalPolynomial.
	answer addMap: (answer to: ℂ images: {α}).
	^ answer! !

!RationalField methodsFor: 'operations' stamp: 'len 11/8/2023 13:56:31'!
algebraicClosure
	^ ℂ! !

!RationalField methodsFor: 'operations' stamp: 'len 11/22/2023 10:42:54'!
∧ aCyclotomicField
	"Answer the intersection or meet of the receiver and the argument in the lattice of cyclotomic fields, i.e. the maximal cyclotomic subfield of both the receiver and the argument."
	self = aCyclotomicField ifTrue: [^ self].
	self assert: (aCyclotomicField isKindOf: CyclotomicField).
	^ aCyclotomicField ∧ self! !

!RationalField methodsFor: 'operations' stamp: 'len 11/22/2023 10:43:57'!
∨ aCyclotomicField
	"Answer the join of the receiver and the argument in the lattice of cyclotomic fields, i.e. the minimal cyclotomic field that includes both the receiver and the argument as subfields."
	self = aCyclotomicField ifTrue: [^ self].
	self assert: (aCyclotomicField isKindOf: CyclotomicField).
	^ aCyclotomicField ∨ self! !

!RationalField methodsFor: 'printing' stamp: 'len 5/23/2020 07:41:18'!
printOn: aStream
	aStream nextPut: $ℚ! !

!RationalField methodsFor: 'testing' stamp: 'len 5/10/2020 09:37:11'!
includes: anObject
	^ anObject isMemberOf: Rational! !

!RationalField methodsFor: 'testing' stamp: 'len 1/8/2017 07:50:01'!
isField
	^ true! !

!RationalField methodsFor: 'testing' stamp: 'len 11/7/2015 22:05'!
isFinite
	^ false! !

!RationalField methodsFor: 'testing' stamp: 'len 11/5/2023 14:55:57'!
isGlobalField
	^ true! !

!RationalField methodsFor: 'testing' stamp: 'len 11/13/2023 10:31:44'!
isOrdered
	^ true! !

!RationalField methodsFor: 'testing' stamp: 'len 7/29/2022 10:33:29'!
isPrimeField
	"The rational field is a prime field (it has no proper subfields)."
	^ true! !

!RationalField methodsFor: 'testing' stamp: 'len 8/9/2020 08:00:03'!
isReal
	"Answer true if the receiver is a subring of the real field."
	^ true! !

!RationalField methodsFor: 'private' stamp: 'len 7/15/2021 19:10:23'!
extensionClass
	^ NumberField! !

!RationalFunctionField methodsFor: 'accessing' stamp: 'len 11/5/2023 18:21:33'!
constants
	"Answer the constant field of the receiver."
	^ self scalars! !

!RationalFunctionField methodsFor: 'accessing' stamp: 'len 11/5/2023 18:22:36'!
degree
	"Answer the degree of the receiver as an algebraic extension (as a function field)."
	^ 1! !

!RationalFunctionField methodsFor: 'elements' stamp: 'len 11/20/2022 11:25:43'!
reducedNumerator: aPolynomial denominator: anotherPolynomial
	self assert: ((self numerators includes: aPolynomial) and: [self numerators includes: anotherPolynomial]).
	^ RationalFunction reducedNumerator: aPolynomial denominator: anotherPolynomial! !

!RationalFunctionField methodsFor: 'printing' stamp: 'len 11/20/2022 11:25:35'!
printOn: aStream
	aStream print: self scalars.
	aStream nextPut: $(.
	self numerators printIndeterminatesOn: aStream.
	aStream nextPut: $)! !

!RationalFunctionField methodsFor: 'testing' stamp: 'len 11/5/2023 14:57:06'!
isGlobalField
	^ self isUnivariate and: [self scalars isFiniteField]! !

!RationalFunctionField methodsFor: 'private' stamp: 'len 11/5/2023 18:21:07'!
extensionClass
	self isUnivariate ifTrue: [^ FunctionField].
	^ super extensionClass! !

!RationalFunctionField class methodsFor: 'instance creation' stamp: 'len 1/5/2017 09:51:56'!
new: anInteger over: aRing
	^ self over: (aRing polynomialsIn: anInteger)! !

!RationalFunctionField class methodsFor: 'instance creation' stamp: 'len 4/27/2021 15:46:56'!
on: aPolynomialRing
	| R |
	R _ (aPolynomialRing isKindOf: PolynomialRing) ifTrue: [aPolynomialRing] ifFalse: [aPolynomialRing polynomials].
"	R _ R ordering isLocal
		ifTrue: [aPolynomialRing]
		ifFalse: [aPolynomialRing orderedBy: #llex]."
	^ super on: R! !

!IntegerRing methodsFor: 'accessing' stamp: 'len 11/5/2015 17:34'!
characteristic
	^ 0! !

!IntegerRing methodsFor: 'accessing' stamp: 'len 10/20/2016 03:32'!
dimension
	"Answer the Krull dimension of the receiver."
	^ 1! !

!IntegerRing methodsFor: 'accessing' stamp: 'len 11/5/2015 19:19'!
one
	^ 1! !

!IntegerRing methodsFor: 'accessing' stamp: 'len 11/8/2023 13:27:23'!
size
	^ ℕ size! !

!IntegerRing methodsFor: 'accessing' stamp: 'len 5/30/2022 10:03:20'!
unitsSize
	"Answer the order of the units group.
	The rational integers have two units: 1 and -1."
	^ 2! !

!IntegerRing methodsFor: 'accessing' stamp: 'len 11/3/2015 20:50'!
zero
	^ 0! !

!IntegerRing methodsFor: 'comparing' stamp: 'len 6/15/2022 09:52:54'!
= anObject
	^ anObject class = self class! !

!IntegerRing methodsFor: 'comparing' stamp: 'len 12/14/2015 01:59'!
hash
	^ self class hash! !

!IntegerRing methodsFor: 'computing-matrices' stamp: 'len 1/14/2024 10:00:22'!
matrix: B quotientBy: A
	"Answer X such that AX + N = B, satisfying that if the i-th column of B is a linear combination of the columns of A then the i-th column of N is zero.
	Attempt to use Dixon's p-adic method [Dix82] for non-singular square matrices, and fallback to the general method for Euclidean domains if this fails."
	| p 𝔽ₚ C lengths m M T |
	((A isSquare and: [B width > 0]) not or: [A width = 1]) ifTrue: [^ self matrixOverEuclideanDomain: B quotientBy: A].
"	β _ 2.
	A do: [:each| β _ β max: each abs].
	B do: [:each| β _ β max: each abs].
	p _ (β min: 16rFFFFFFFF) atRandom nextPrime."
	"Use 27-bit primes to take advantage of delayed reduction in blocked matrix-matrix multiplication in pure Smalltalk:"
	p := 16r7FFFFFF "16rFFFFFFFF" atRandom nextPrime.
	𝔽ₚ := PrimeField new: p.
	[C := (A over: 𝔽ₚ) inverse] on: Error do: [^ self matrixOverEuclideanDomain: B quotientBy: A].
	lengths := OrderedCollection new: A width + 1.
	lengths add: (B columns max: [:b| b norm sqrtFloor + 1]). "each entry is >= Euclidean length"
	A columnsDo: [:each| lengths add: each norm sqrtFloor + 1].
"	δ := lengths sorted allButFirst product.
	λ := 0.6180339887498949. ""root of x^2 + x - 1""
	m _ ((δ / λ) log / p log * 2) ceiling."
	m := ((lengths sorted allButFirst sum: [:each| each log]) + 0.20898764024997868 / p log * 2) ceiling. "the constant is -log(λ)"
	M := (PrimePowerRing new: p to: m)^B height.
	T := (M scalars modulus // 2) sqrtFloor.
	^ Matrix from: B domain to: A domain columns:
		(B columns collect: [:b|
			| xx bb x reconstruction |
			xx := OrderedCollection new: m.
			bb := b.
			m timesRepeat:
				[xx add: (C*(bb over: 𝔽ₚ)) lift.
				bb := bb - (A*xx last) // p].
			x := (0 to: m - 1) sum: [:i| M !! (xx at: i+1) * (p^i)].
			"self assert: (A over: M scalars) * x = (B over: M scalars) asTuple."
			reconstruction := x asArray collect: [:each| each asRational: T].
			(reconstruction allSatisfy: [:each| each notNil and: [each isIntegral]])
				ifTrue: [M lift fill: [:i| reconstruction at: i]]
				ifFalse: [M lift zero]])! !

!IntegerRing methodsFor: 'computing-polynomials' stamp: 'len 11/5/2023 08:35:54'!
polynomial: aPolynomial factorizationDo: aBlock
	| content |
	(content := aPolynomial content) factorizationDo: [:p :e| aBlock value: (aPolynomial parent constant: p) value: e].
	(aPolynomial // (content * aPolynomial sign)) squarefreeFactorizationDo: [:f :r|
		self polynomial: f factorizationZassenhaussDo: [:each| aBlock value: each value: r]]! !

!IntegerRing methodsFor: 'computing-polynomials' stamp: 'len 11/30/2023 14:29:47'!
polynomial: aPolynomial factorizationZassenhaussDo: aBlock
	"Zassenhauss algorithm. Enumerate the irreducible factors of a squarefree primitive polynomial with integer coefficients."
	| f n A b B C γ df p factors r k |
	aPolynomial isOne ifTrue: [^ self].
	f := aPolynomial.
	n := f degree.
	n = 1 ifTrue: [^ aBlock value: f].
	A := f normMax.
	b := f leadingCoefficient.
	B := (n+1) sqrt * (1<<n) * A * b. "float will fail"
	C := (n+1)^(2*n)*(A^(2*n-1)).
"	γ _ (2 * (C log: 2)) ceiling."
	γ := 2 * C highBit. "+1?"
	df := f derivative.
	r := nil.
	"Try several times to find a factorization with fewer factors:"
	2 timesRepeat: "should try 5 times? 2 seems to be faster than 3, and much faster than 1"
		[| p₀ Zₚ fₚ dfₚ factors₀ r₀ |
		[[(p₀ := (2*γ*γ ln) asInteger atRandom nextPrime) | b] whileTrue.
		Zₚ := PrimeField new: p₀.
		fₚ := f over: Zₚ.
		dfₚ := df over: Zₚ.
		(fₚ gcd: dfₚ) isConstant] whileFalse.
		"Modular factorization:"
		factors₀ := fₚ normalized factorization.
		"If irreducible mod p, also irreducible over ℤ:"
		(r₀ := factors₀ size) = 1 ifTrue: [^ aBlock value: f].
		(r isNil or: [r₀ < r]) ifTrue: [p := p₀. factors := factors₀. r := r₀]].
"	self assert: (self % p - (factors product * b)) isZero."
	"Hensel lifting:" "(about 20% of time is spent here)"
	k := ((2*B+1) log: p) abs ceiling. "p^k > 2B"
	k := 1 << k highBit. "<- in order to do quadratic liftings, maybe shouldn't"
	factors := (f over: (PrimePowerRing new: p to: k)) henselLiftFactors: factors asArray.
	"factors := f henselLift: factors asArray to: (PrimePowerRing new: p to: k)."
"	1 to: k do: [:i| self assert: (f - ((factors product: [:fi| fi lift]) * b) % (p^i)) isZero]."
	"Recombination:" "(about 50% of time is spent in this recombination step)"
	1 to: r do: [:j|
		(factors combinations: j) do: [:each| | g division |
			g := (each product * b) lift primitivePart.
			(division := f divisionBy: g) remainder isZero ifTrue:
				[aBlock value: g.
				(f := division quotient) isConstant ifTrue: [^ self]]]].
	^ aBlock value: f! !

!IntegerRing methodsFor: 'computing-polynomials' stamp: 'len 12/23/2023 16:21:28'!
rootsOf: aPolynomial withMultiplicitiesDo: aBlock
	"Enumerate the integer roots of aPolynomial with multiplicities."
	| f n count fourier m |
	f := aPolynomial scalars = ℚ ifTrue: [aPolynomial integralPrimitivePart over: ℤ] ifFalse: [aPolynomial scalars = ℤ ifTrue: [aPolynomial primitivePart] ifFalse: [^ super rootsOf: aPolynomial withMultiplicitiesDo: aBlock]].
	n := f degree.
	(count := f order) > 0 ifTrue: [aBlock value: 0 asRational value: count. f := f >> count].
	f isConstant ifTrue: [^ self].
	fourier := OrderedCollection with: f derivative.
	f independentCoefficient divisorsDo: [:τ|
		(f value: τ) isZero ifTrue:
			[aBlock value: τ value: (m := f multiplicityAt: τ fourier: fourier).
			(count := count + m) = n ifTrue: [^ self]].
		(f value: τ negated) isZero ifTrue:
			[aBlock value: τ negated value: (m := f multiplicityAt: τ negated fourier: fourier).
			(count := count + m) = n ifTrue: [^ self]]]! !

!IntegerRing methodsFor: 'converting' stamp: 'len 4/30/2021 13:12:57'!
asModule
	^ self asIdeal! !

!IntegerRing methodsFor: 'enumerating' stamp: 'len 11/10/2015 17:57'!
do: aBlock
	| i |
	aBlock value: 0.
	i _ 1.
	[ aBlock value: i; value: i negated. i _ i + 1 ] repeat! !

!IntegerRing methodsFor: 'enumerating' stamp: 'len 10/15/2022 08:49:53'!
idealsDo: aBlock
	| x |
	x _ 0.
	[aBlock value: self * x.
	x _ x + 1] repeat! !

!IntegerRing methodsFor: 'enumerating' stamp: 'len 5/4/2018 19:42:06'!
primeIdealsDo: aBlock
	| p |
	p _ 0.
	[aBlock value: self * p.
	p _ p nextPrime] repeat! !

!IntegerRing methodsFor: 'enumerating' stamp: 'len 7/16/2022 11:26:04'!
primesDo: aBlock
	| p |
	p _ 2.
	[aBlock value: p.
	p _ p nextPrime] repeat! !

!IntegerRing methodsFor: 'enumerating' stamp: 'len 9/22/2018 18:58:29'!
unitsDo: aBlock
	aBlock value: 1; value: -1! !

!IntegerRing methodsFor: 'morphisms' stamp: 'len 4/16/2024 18:44:46'!
to: aRing
	self assert: aRing isRing.
	^ aRing addMap: (self to: aRing map: [:x| aRing one * x])! !

!IntegerRing methodsFor: 'operations' stamp: 'len 5/1/2024 12:25:01'!
/ anInteger
	anInteger isInteger ifTrue:
		[| factors |
		anInteger = 0 ifTrue: [^ self].
		factors := anInteger factorization.
		factors asSet size = 1 ifTrue:
			[^ PrimePowerRing new: factors any to: factors size].
		^ (ModularIntegerRing new: anInteger) modulusFactors: factors].
	(anInteger isKindOf: Ideal) ifFalse: [^ self / (self * anInteger)].
	self = anInteger scalars ifFalse: [^ self error: 'ideal belongs to a different ring'].
	^ self / anInteger generator! !

!IntegerRing methodsFor: 'operations' stamp: 'len 5/23/2020 09:11:37'!
fractions
	^ ℚ! !

!IntegerRing methodsFor: 'operations' stamp: 'len 4/8/2021 12:38:46'!
radical
	"Answer the Jacobson radical J(R) of the receiver R. This is the ideal consisting of all elements that annihilate all simple R-modules. It is the intersection of all maximal ideals."
	^ self asIdeal null! !

!IntegerRing methodsFor: 'operations' stamp: 'len 5/7/2022 07:35:14'!
zeroDivisors
	^ #(0)! !

!IntegerRing methodsFor: 'printing' stamp: 'len 5/23/2020 07:41:41'!
printOn: aStream
	aStream nextPut: $ℤ! !

!IntegerRing methodsFor: 'random' stamp: 'len 7/14/2020 17:33:43'!
atRandom: aRandom bits: bitSize
	| n |
	bitSize isInfinite ifTrue: [^ self error: 'infinite bitsize'].
	bitSize < 0 ifTrue: [^ self error: 'negative bitsize'].
	bitSize = 0 ifTrue: [^ 0].
	bitSize < 1 ifTrue: [^ ((2/bitSize) truncated atRandom: aRandom) = 1 ifTrue: [(-1 to: 1) atRandom: aRandom] ifFalse: [0]].
	n _ 2^(bitSize truncated - 1).
	^ (0-n to: n) atRandom: aRandom! !

!IntegerRing methodsFor: 'testing' stamp: 'len 6/3/2022 06:06:54'!
hasCanonicalAssociates
	^ true! !

!IntegerRing methodsFor: 'testing' stamp: 'len 6/3/2022 20:41:32'!
hasCanonicalReduction
	^ true! !

!IntegerRing methodsFor: 'testing' stamp: 'len 11/23/2015 02:37'!
includes: anObject
	^ anObject isInteger! !

!IntegerRing methodsFor: 'testing' stamp: 'len 12/21/2022 13:27:26'!
isBezout
	"Answer true if the receiver is a Bézout ring, i.e. every finitely generated ideal is principal."
	^ true! !

!IntegerRing methodsFor: 'testing' stamp: 'len 4/28/2021 09:35:15'!
isCommutative
	^ true! !

!IntegerRing methodsFor: 'testing' stamp: 'len 1/2/2022 10:08:56'!
isDedekindDomain
	"A Dedekind domain is an integral domain in which every nonzero proper ideal factors into a product of prime ideals."
	^ true! !

!IntegerRing methodsFor: 'testing' stamp: 'len 12/31/2021 11:50:30'!
isEuclidean
	"Answer true if the receiver is a Euclidean ring, i.e. it has Euclidean division with remainder."
	^ true! !

!IntegerRing methodsFor: 'testing' stamp: 'len 11/7/2015 21:58'!
isFinite
	^ false! !

!IntegerRing methodsFor: 'testing' stamp: 'len 6/26/2024 08:57:16'!
isFiniteAlgebra
	^ true! !

!IntegerRing methodsFor: 'testing' stamp: 'len 1/8/2017 07:49:36'!
isIntegralDomain
	^ true! !

!IntegerRing methodsFor: 'testing' stamp: 'len 3/21/2021 15:10:44'!
isNoetherian
	"A ring is called Noetherian if every ideal is finitely generated."
	^ true! !

!IntegerRing methodsFor: 'testing' stamp: 'len 11/13/2023 10:31:05'!
isOrdered
	^ true! !

!IntegerRing methodsFor: 'testing' stamp: 'len 8/9/2020 08:00:07'!
isReal
	"Answer true if the receiver is a subring of the real field."
	^ true! !

!IntegerRing methodsFor: 'testing' stamp: 'len 1/2/2022 10:09:04'!
isReduced
	"Answer true if the receiver has no nonzero nilpotent elements, or equivalently if it has no nonzero elements with square zero, i.e. x^2 = 0 implies x = 0."
	^ true! !

!LocalRing methodsFor: 'accessing' stamp: 'len 9/8/2023 17:32:19'!
base
	^ self baseIdeal generator! !

!LocalRing methodsFor: 'accessing' stamp: 'len 11/20/2022 11:26:56'!
characteristic
	^ self numerators characteristic! !

!LocalRing methodsFor: 'accessing' stamp: 'len 10/20/2023 11:03:46'!
maximalIdeal
	"Answer the unique maximal ideal in the receiver."
	^ self propertyAt: #maximalIdeal ifAbsentPut: [self baseIdeal ⊗ self]! !

!LocalRing methodsFor: 'accessing' stamp: 'len 9/8/2023 17:33:39'!
numerators
	^ self baseIdeal scalars! !

!LocalRing methodsFor: 'accessing' stamp: 'len 11/20/2022 11:29:46'!
one
	^ self embed: self numerators one! !

!LocalRing methodsFor: 'accessing' stamp: 'len 11/20/2022 11:30:11'!
scalars
	^ self numerators scalars! !

!LocalRing methodsFor: 'accessing' stamp: 'len 11/20/2022 11:30:20'!
size
	self numerators isFinite ifFalse: [^ self numerators size].
	^ super size! !

!LocalRing methodsFor: 'accessing' stamp: 'len 1/9/2022 21:39:40'!
uniformizer
	"A uniformizer (or uniformizing parameter, uniformizer element or prime element) is any irreducible element of a DVR, or equivalently a generator of the maximal ideal. All nonzero ideals are generated by some power of the uniformizer."
	self isDVR ifFalse: [^ self error: 'not a DVR'].
	^ self maximalIdeal generator! !

!LocalRing methodsFor: 'accessing' stamp: 'len 11/20/2022 11:30:26'!
zero
	^ self embed: self numerators zero! !

!LocalRing methodsFor: 'comparing' stamp: 'len 9/8/2023 17:31:44'!
= anObject
	self == anObject ifTrue: [^ true].
	^ (anObject isKindOf: LocalRing) and: [self baseIdeal = anObject baseIdeal]! !

!LocalRing methodsFor: 'comparing' stamp: 'len 9/8/2023 17:33:00'!
hash
	^ self baseIdeal hash! !

!LocalRing methodsFor: 'computing-matrices' stamp: 'len 9/8/2023 17:33:25'!
matrix: B quotientBy: A
	"Answer X such that AX + N = B, satisfying that if the i-th column of B is a linear combination of the columns of A then the i-th column of N is zero."
	| X N d1 d2 |
	X := self^0 → A domain.
	N := A numerator.
	d1 := A denominator.
	d2 := B denominator.
	B numerator columnsDo: [:b| | L i x |
		L := (b asMatrix ⊔ N) syzygies.
		i := (1 to: L width) detect: [:k| (self baseIdeal includes: (L at: 1@k)) not] ifNone: [].
		x := i isNil ifTrue: [A domain zero] ifFalse: [((L copyFrom: 2@i to: L height@i) over: self) * (self numerator: d1 negated denominator: d2 * (L at: 1@i))].
		X := X ⊔ x].
	^ X! !

!LocalRing methodsFor: 'computing-matrices' stamp: 'len 12/15/2022 11:15:05'!
syzygiesOf: aMatrix
	"Answer a matrix whose rows span the kernel of the given matrix.
	For a matrix A, the output is X with AX = 0."
	^ aMatrix numerator syzygies over: self! !

!LocalRing methodsFor: 'converting' stamp: 'len 9/8/2023 17:33:44'!
over: aRing
	"Change the base ring."
	^ self class at: (self baseIdeal over: (self numerators over: aRing))! !

!LocalRing methodsFor: 'elements' stamp: 'len 4/6/2024 15:36:14'!
adapt: anObject
	(self fractions includes: anObject) ifTrue:
		[self assert: (self baseIdeal includes: anObject denominator) not.
		^ self reducedNumerator: anObject numerator denominator: anObject denominator].
	(self numerators includes: anObject) ifTrue:
		[^ self embed: anObject].
	^ super adapt: anObject! !

!LocalRing methodsFor: 'elements' stamp: 'len 12/29/2021 14:14:18'!
numerator: anElement denominator: anotherElement
	^ (self reducedNumerator: anElement denominator: anotherElement) reduce! !

!LocalRing methodsFor: 'elements' stamp: 'len 12/18/2021 06:56:13'!
reducedNumerator: anElement denominator: anotherElement
	^ Germ new parent: self; setNumerator: anElement denominator: anotherElement! !

!LocalRing methodsFor: 'enumerating' stamp: 'len 9/8/2023 17:32:55'!
do: aBlock
	| visited |
	visited := Set new.
	self numerators^2 do: [:each|
		(self baseIdeal includes: each second) ifFalse:
			[| x |
			x := (self !! each first) / (self !! each second).
			visited add: x ifAbsent: [aBlock value: x]]]! !

!LocalRing methodsFor: 'enumerating' stamp: 'len 12/10/2023 10:36:24'!
primeIdealsDo: aBlock
	| P |
	self isField ifTrue: [aBlock value: self asIdeal null. ^ self].
	self isDVR ifTrue: [aBlock value: self asIdeal null; value: self maximalIdeal. ^ self].
	"The prime ideals of the localization of R at a prime ideal P are in one-to-one correspondence with the prime ideals I of R that satisfy I ⊂ P:"
	P := self baseIdeal.
	self numerators primeIdealsDo: [:each| each ⊆ P ifTrue: [aBlock value: each ⊗ self]]! !

!LocalRing methodsFor: 'morphisms' stamp: 'len 11/20/2022 11:27:40'!
embed: anObject
	^ self reducedNumerator: self numerators !! anObject denominator: self numerators one! !

!LocalRing methodsFor: 'morphisms' stamp: 'len 6/1/2024 07:04:17'!
from: aRing
	aRing = self numerators ifTrue: [^ self addMap: ((self numerators to: self map: [:x| self embed: x]) name: 'ι')].
	aRing ⇢ self numerators ifNotNil: [:aMorphism| ^ self numerators → self · aMorphism].
	^ super from: aRing! !

!LocalRing methodsFor: 'morphisms' stamp: 'len 4/16/2024 18:45:29'!
to: aRing
	aRing = self fractions ifTrue: [^ self addMap: ((self onto: self fractions map: [:each| (self fractions !! each numerator) / (self fractions !! each denominator)]) name: 'ι')].
	((aRing isKindOf: LocalRing) and: [aRing baseIdeal ⊆ self baseIdeal]) ifTrue: [^ self to: aRing map: [:each| each copy parent: aRing]].
	^ super to: aRing! !

!LocalRing methodsFor: 'operations' stamp: 'len 11/7/2023 20:59:48'!
/ anIdeal
	"Answer the quotient by the given ideal.
	For convenience, the argument can be a single element or a collection of elements as well."
	self flag: #fixme. "write quotients of localizations as localizations of quotients"
	^ super / anIdeal
"	| answer I Q |
	I := (anIdeal isKindOf: Ideal)
		ifTrue: [anIdeal scalars = self ifTrue: [anIdeal] ifFalse: [self * anIdeal generators]]
		ifFalse: [self * anIdeal].
	Q := self numerators / I numerator.
	answer := Q localizationAt: self baseIdeal ⊗ Q.
	self halt.
	answer == Q ifTrue: [^ answer]. ""For example: (ℤ localizationAt: ℤ*7) / (ℤ * 7)""
	answer addMap:
		((self onto: answer map: [:each| answer embed: (Q !! each numerator)])
			name: 'π';
			propertyAt: #kernel put: I;
			propertyAt: #image put: answer;
			yourself).
	^ answer"! !

!LocalRing methodsFor: 'operations' stamp: 'len 11/20/2022 11:27:49'!
fractions
	^ self numerators fractions! !

!LocalRing methodsFor: 'printing' stamp: 'len 9/8/2023 17:33:55'!
printOn: aStream
	aStream print: self numerators; nextPutAll: self baseIdeal printString sub! !

!LocalRing methodsFor: 'random' stamp: 'len 9/8/2023 17:32:08'!
atRandom: aRandom
	| a b |
	a := self numerators atRandom: aRandom.
	[b := self numerators atRandom: aRandom. self baseIdeal includes: b] whileTrue.
	^ (self embed: a) / (self embed: b)! !

!LocalRing methodsFor: 'random' stamp: 'len 9/8/2023 17:32:14'!
atRandom: aRandom bits: bitSize
	| a b |
	bitSize < 2 ifTrue: [^ self !! (self numerators atRandom: aRandom bits: bitSize)].
	a := self numerators atRandom: aRandom bits: bitSize/2.
	[b := self numerators atRandom: aRandom bits: bitSize/2. self baseIdeal includes: b] whileTrue.
	^ self !! ((self fractions !! a) / (self fractions !! b))! !

!LocalRing methodsFor: 'testing' stamp: 'len 6/3/2022 06:05:08'!
hasCanonicalAssociates
	^ true! !

!LocalRing methodsFor: 'testing' stamp: 'len 4/22/2020 06:11:00'!
includes: anObject
	^ anObject parent == self! !

!LocalRing methodsFor: 'testing' stamp: 'len 11/20/2022 11:28:04'!
isArtinian
	"A ring is called Artinian if it satisfies the descending chain condition on ideals."
	^ self numerators isArtinian or: [super isArtinian]! !

!LocalRing methodsFor: 'testing' stamp: 'len 4/28/2021 09:34:59'!
isCommutative
	^ true! !

!LocalRing methodsFor: 'testing' stamp: 'len 9/8/2023 17:33:06'!
isDVR
	"Answer true if the receiver is a discrete valuation ring, i.e. a local PID that is not a field."
	"The localization of a Dedekind domain at a nonzero prime ideal is a DVR."
	^ self numerators isDedekindDomain and: [self baseIdeal isTrivial not]! !

!LocalRing methodsFor: 'testing' stamp: 'len 11/20/2022 11:28:27'!
isDedekindDomain
	"A localization of a Dedekind domain at any multiplicative set is also a Dedekind domain."
	^ self numerators isDedekindDomain or: [super isDedekindDomain]! !

!LocalRing methodsFor: 'testing' stamp: 'len 11/20/2022 11:28:33'!
isEuclidean
	"Answer true if the receiver is a Euclidean ring, i.e. it has Euclidean division with remainder."
	^ self numerators isEuclidean or: [super isEuclidean]! !

!LocalRing methodsFor: 'testing' stamp: 'len 9/8/2023 17:33:11'!
isField
	^ self numerators isIntegralDomain and: [self baseIdeal isZero]! !

!LocalRing methodsFor: 'testing' stamp: 'len 9/8/2023 17:33:17'!
isGraded
	^ self numerators isGraded and: [self baseIdeal isHomogeneous]! !

!LocalRing methodsFor: 'testing' stamp: 'len 11/20/2022 11:28:46'!
isIntegralDomain
	"The localization of an integral domain at a prime ideal (or even at a multiplicative closed set not containing zero) continues to be an integral domain."
	^ self numerators isIntegralDomain or: [super isIntegralDomain]! !

!LocalRing methodsFor: 'testing' stamp: 'len 11/20/2022 11:28:50'!
isIntegrallyClosedDomain
	"A ring is an integrally closed domain if it is an integral domain whose integral closure in its field of fractions is the ring itself."
	^ self numerators isIntegrallyClosedDomain or: [super isIntegrallyClosedDomain]! !

!LocalRing methodsFor: 'testing' stamp: 'len 10/28/2016 16:06'!
isLocal
	^ true! !

!LocalRing methodsFor: 'testing' stamp: 'len 8/6/2019 18:08:20'!
isLocalization
	"Answer true if the receiver is a localization of a ring (a ring of fractions, a localization at a prime ideal, etc).
	This means that elements of the receiver are formal fractions."
	^ true! !

!LocalRing methodsFor: 'testing' stamp: 'len 11/20/2022 11:28:54'!
isMultivariate
	^ self numerators isMultivariate! !

!LocalRing methodsFor: 'testing' stamp: 'len 11/20/2022 11:28:56'!
isNoetherian
	"A ring is called Noetherian if every ideal is finitely generated."
	^ self numerators isNoetherian or: [super isNoetherian]! !

!LocalRing methodsFor: 'testing' stamp: 'len 11/20/2022 11:29:13'!
isPIR
	"Answer true if the receiver is a principal ideal ring, i.e. all ideals are principal (but it is not necessarily a PID, i.e. it is not necessarily an integral domain)."
	"A localization of a PIR at any multiplicative subset is again a PIR."
	^ self numerators isPIR or: [super isPIR]! !

!LocalRing methodsFor: 'testing' stamp: 'len 11/20/2022 11:29:19'!
isReduced
	"Answer true if the receiver has no nonzero nilpotent elements, or equivalently if it has no nonzero elements with square zero, i.e. x^2 = 0 implies x = 0."
	self numerators isReduced ifTrue: [^ true]. "is it iff?"
	^ super isReduced! !

!LocalRing methodsFor: 'testing' stamp: 'len 11/20/2022 11:29:41'!
isTrivial
	^ self numerators isTrivial! !

!LocalRing methodsFor: 'testing' stamp: 'len 11/20/2022 11:29:31'!
isUnivariate
	^ self numerators isUnivariate! !

!LocalRing methodsFor: 'private' stamp: 'len 9/8/2023 17:30:09'!
baseIdeal
	^ self propertyAt: #baseIdeal! !

!LocalRing methodsFor: 'private' stamp: 'len 9/8/2023 17:29:57'!
baseIdeal: anIdeal
	self propertyAt: #baseIdeal put: anIdeal! !

!LocalRing class methodsFor: 'examples' stamp: 'len 7/23/2022 13:18:04'!
exampleZZLocalizedAt2
	"Answer the local ring of the integers at <2>.
	This is the ring of fractions with odd denominator."
	^ ℤ @ (ℤ * 2)! !

!LocalRing class methodsFor: 'instance creation' stamp: 'len 9/8/2023 17:31:21'!
at: anIdeal
	^ self new baseIdeal: anIdeal! !

!OppositeRing methodsFor: 'accessing' stamp: 'len 4/26/2021 11:19:58'!
generators
	^ opposite generators collect: [:each| self !! each]! !

!OppositeRing methodsFor: 'accessing' stamp: 'len 4/26/2021 11:20:11'!
one
	^ self !! opposite one! !

!OppositeRing methodsFor: 'accessing' stamp: 'len 4/30/2021 13:18:39'!
scalars
	^ opposite scalars! !

!OppositeRing methodsFor: 'accessing' stamp: 'len 4/26/2021 11:20:15'!
zero
	^ self !! opposite zero! !

!OppositeRing methodsFor: 'comparing' stamp: 'len 4/3/2024 08:49:32'!
= anObject
	self == anObject ifTrue: [^ true].
	^ (anObject isKindOf: OppositeRing) and: [opposite = anObject opposite]! !

!OppositeRing methodsFor: 'comparing' stamp: 'len 4/3/2024 08:49:32'!
~ aRing
	"Answer true if the receiver is isomorphic to aRing."
	(aRing isKindOf: OppositeRing) ifTrue: [^ opposite ~ aRing opposite].
	^ super ~ aRing! !

!OppositeRing methodsFor: 'comparing' stamp: 'len 12/20/2021 13:33:14'!
hash
	^ opposite hash! !

!OppositeRing methodsFor: 'computing-matrices' stamp: 'len 12/31/2021 08:19:01'!
syzygiesOf: aMatrix
	"Answer a matrix whose rows span the kernel of the given matrix.
	For a matrix A, the output is X with AX = 0."
	^ (aMatrix transpose over: opposite) cosyzygies over: self! !

!OppositeRing methodsFor: 'converting' stamp: 'len 4/30/2021 13:18:34'!
asModule
	^ opposite asModule! !

!OppositeRing methodsFor: 'elements' stamp: 'len 4/13/2024 09:36:07'!
adapt: anElement
	(opposite includes: anElement) ifTrue: [^ OppositeRingElement opposite: anElement].
	^ super adapt: anElement! !

!OppositeRing methodsFor: 'operations' stamp: 'len 4/3/2024 08:49:32'!
opposite
	^ opposite! !

!OppositeRing methodsFor: 'printing' stamp: 'len 4/26/2021 11:20:22'!
printOn: aStream
	aStream print: opposite; nextPutAll: 'op' super! !

!OppositeRing methodsFor: 'testing' stamp: 'len 10/14/2023 08:12:20'!
isCommutative
	^ false "this class should never be instantiated if the ring is commutative or involutive"! !

!OppositeRing methodsFor: 'testing' stamp: 'len 12/20/2021 13:34:09'!
isDivisionRing
	^ opposite isDivisionRing! !

!OppositeRing methodsFor: 'testing' stamp: 'len 10/18/2023 09:39:21'!
isSemisimple
	^ opposite isSemisimple! !

!OppositeRing methodsFor: 'private' stamp: 'len 12/15/2021 20:39:36'!
opposite: aRing
	opposite _ aRing! !

!OppositeRing class methodsFor: 'instance creation' stamp: 'len 12/15/2021 20:39:46'!
opposite: aRing
	^ self new opposite: aRing! !

!ProductRing methodsFor: 'accessing' stamp: 'len 12/7/2023 17:00:42'!
characteristic
	^ components inject: 1 into: [:last :each| last lcm: each characteristic]! !

!ProductRing methodsFor: 'accessing' stamp: 'len 8/29/2016 04:10'!
components
	^ components! !

!ProductRing methodsFor: 'accessing' stamp: 'len 10/21/2023 08:21:40'!
dimension
	"Answer the Krull dimension of the receiver.
	This is the length of the longest ascending chain of prime ideals."
	^ (components ifEmpty: [^ Infinity negative]) max: [:each| each dimension]! !

!ProductRing methodsFor: 'accessing' stamp: 'len 8/21/2024 14:56:59'!
generators
	^ self propertyAt: #generators ifAbsentPut:
		[self isFinitelyGeneratedAlgebra ifTrue:
			[| zeros generators |
			generators := OrderedCollection new.
			zeros := self zero components.
			1 to: components size do: [:i| (self at: i) generators do: [:each| generators add: (self compose: (zeros copy at: i put: each; yourself))]].
			generators asArray]]! !

!ProductRing methodsFor: 'accessing' stamp: 'len 9/16/2018 16:15:47'!
one
	^ self compose: (components collect: [:each| each one])! !

!ProductRing methodsFor: 'accessing' stamp: 'len 10/17/2023 15:55:01'!
scalars
	| answer |
	self propertyAt: #scalars ifPresent: [:aRing| ^ aRing].
	components isEmpty ifTrue: [^ ℤ].
	answer := components first scalars.
	components allButFirstDo: [:each| each scalars = answer ifFalse: [^ self propertyAt: #scalars put: ℤ]].
	^ self propertyAt: #scalars put: answer! !

!ProductRing methodsFor: 'accessing' stamp: 'len 2/26/2017 09:47:23'!
size
	^ components product: [:each| each size]! !

!ProductRing methodsFor: 'accessing' stamp: 'len 11/25/2022 06:15:43'!
unitsSize
	"Answer the order of the units group."
	^ components product: [:each| each unitsSize]! !

!ProductRing methodsFor: 'accessing' stamp: 'len 9/16/2018 16:15:52'!
zero
	^ self compose: (components collect: [:each| each zero])! !

!ProductRing methodsFor: 'comparing' stamp: 'len 7/6/2023 22:54:33'!
= anObject
	self == anObject ifTrue: [^ true].
	^ (anObject isKindOf: ProductRing) and: [components = anObject components]! !

!ProductRing methodsFor: 'comparing' stamp: 'len 8/29/2016 04:13'!
hash
	^ components hash! !

!ProductRing methodsFor: 'computing-matrices' stamp: 'len 5/1/2024 10:24:33'!
basisAndTransformationOf: aMatrix
	| results |
	results := self ⇉ components collect: [:p| (aMatrix apply: p) basisAndTransformation].
	^ {self matrix: aMatrix height @ (results max: [:each| each first width]) fill: [:i :j| self compose: (results withIndexCollect: [:each :k| each first at: i@j ifAbsent: [(components at: k) zero]])].
		self matrix: aMatrix width @ (results max: [:each| each second width]) fill: [:i :j| self compose: (results withIndexCollect: [:each :k| each second at: i@j ifAbsent: [(components at: k) zero]])]}! !

!ProductRing methodsFor: 'computing-matrices' stamp: 'len 5/1/2024 10:22:22'!
basisOf: aMatrix
	| results |
	results := self ⇉ components collect: [:p| (aMatrix apply: p) basis].
	^ self matrix: aMatrix height @ (results max: [:each| each width]) fill: [:i :j| self compose: (results withIndexCollect: [:each :k| each at: i@j ifAbsent: [(components at: k) zero]])]! !

!ProductRing methodsFor: 'computing-matrices' stamp: 'len 5/1/2024 10:22:46'!
matrix: B quotientBy: A
	"Answer X such that AX + N = B, satisfying that if the i-th column of B is a linear combination of the columns of A then the i-th column of N is zero.
	The algorithm solves the system for each projection and then composes back to the product ring."
	| results |
	results := self ⇉ components collect: [:p| (B apply: p) quotientBy: (A apply: p)].
	^ self matrix: A width @ B width fill: [:i :j| self compose: (results collect: [:each| each at: i@j])]! !

!ProductRing methodsFor: 'computing-matrices' stamp: 'len 5/1/2024 10:23:11'!
smithNormalFormAndTransformationsOf: aMatrix
	"Answer the Smith normal form S of the argument A and the unique unimodular matrices P and Q such that P*A*Q = S."
	| results |
	results := self ⇉ components collect: [:p| (aMatrix apply: p) SNFAndTransformations].
	^ {self matrix: (aMatrix width min: aMatrix height) fill: [:i :j| self compose: (results withIndexCollect: [:each :k| (each at: 1) at: i@j])].
		self matrix: aMatrix height fill: [:i :j| self compose: ((results withIndexCollect: [:each :k| (each at: 2) at: i@j]))].
		self matrix: aMatrix width fill: [:i :j| self compose: ((results withIndexCollect: [:each :k| (each at: 3) at: i@j]))]}! !

!ProductRing methodsFor: 'computing-matrices' stamp: 'len 5/1/2024 10:23:16'!
smithNormalFormOf: aMatrix
	"Answer the Smith normal form of the aMatrix."
	| results |
	results := self ⇉ components collect: [:p| (aMatrix apply: p) SNF].
	^ self matrix: (aMatrix width min: aMatrix height) fill: [:i :j| self compose: (results collect: [:each| each at: i@j])]! !

!ProductRing methodsFor: 'computing-matrices' stamp: 'len 5/1/2024 10:23:56'!
syzygiesOf: aMatrix
	"Answer a matrix whose rows span the kernel of the given matrix.
	For a matrix A, the output is X with AX = 0.
	The algorithm computes syzygies for each projection and then composes back to the product ring."
	| results |
	results := self ⇉ components collect: [:p| (aMatrix apply: p) syzygies].
	^ self matrix: aMatrix width @ (results max: [:each| each width]) fill: [:i :j| self compose: (results withIndexCollect: [:each :k| each at: i@j ifAbsent: [(components at: k) zero]])]! !

!ProductRing methodsFor: 'converting' stamp: 'len 5/1/2024 10:22:12'!
asAbelianGroup
	^ components inject: ℤ^0 into: [:last :each| last ⊕ each asAbelianGroup]
"
	ℤ × (ℤ/3) × (ℤ/4) :: asAbelianGroup
"! !

!ProductRing methodsFor: 'elements' stamp: 'len 4/11/2024 06:07:04'!
compose: anArray
	^ ProductRingElement components: anArray asArray parent: self! !

!ProductRing methodsFor: 'elements' stamp: 'len 5/5/2023 13:00:33'!
new: anInteger
	^ ProductArray components: (components collect: [:each| each new: anInteger]) scalars: self! !

!ProductRing methodsFor: 'elements' stamp: 'len 5/5/2023 13:00:40'!
zeros: anInteger
	^ ProductArray components: (components collect: [:each| each zeros: anInteger]) scalars: self! !

!ProductRing methodsFor: 'enumerating' stamp: 'len 5/2/2024 06:43:24'!
do: aBlock
	self asCartesianProduct do: [:each| aBlock value: (self compose: each)]! !

!ProductRing methodsFor: 'enumerating' stamp: 'len 5/1/2024 10:23:04'!
primeIdealsDo: aBlock
	"The prime ideals of a product ring R x S are of the form I x S for I a prime ideal of R or R x I for I a prime ideal of S."
	| ones |
	ones := self one components.
	1 to: components size do: [:i|
		(self at: i) primeIdealsDo: [:p|
			aBlock value: self * (p generators collect: [:g| self compose: (ones copy at: i put: g; yourself)])]]! !

!ProductRing methodsFor: 'enumerating' stamp: 'len 11/24/2022 18:09:31'!
rank: n unitsDo: aBlock
	n > 1 ifFalse: [^ components first unitsDo: [:u| aBlock value: {u}]].
	(components at: n) unitsDo: [:u| self rank: n-1 unitsDo: [:each| aBlock value: each, {u}]]! !

!ProductRing methodsFor: 'enumerating' stamp: 'len 11/24/2022 18:57:48'!
unitsDo: aBlock
	self rank: components size unitsDo: [:each| aBlock value: (self compose: each)]! !

!ProductRing methodsFor: 'morphisms' stamp: 'len 4/2/2024 15:23:10'!
projection: i
	"Answer the canonical projection to the i-th component."
	^ (self to: (components at: i) map: [:x| x at: i]) name: 'π', i printString sub! !

!ProductRing methodsFor: 'operations' stamp: 'len 5/1/2024 10:22:56'!
nilradical
	"Answer the ideal consisting of all nilpotent elements, i.e. all x such that there exists some n with x^n = 0. It is the intersection of all prime ideals."
	| generators |
	generators := OrderedCollection new.
	components withIndexDo: [:each :i|
		each nilradical generators do: [:g|
			generators add: (self compose: ((1 to: components size) collect: [:j| i=j ifTrue: [g] ifFalse: [(self at: j) zero]]))]].
	^ self * generators! !

!ProductRing methodsFor: 'printing' stamp: 'len 5/23/2020 07:19:14'!
printOn: aStream
	components do: [:each| aStream print: each] separatedBy: [aStream nextPut: $×]! !

!ProductRing methodsFor: 'random' stamp: 'len 4/1/2024 09:49:03'!
atRandom: aRandom
	^ self compose: (components collect: [:each| each atRandom: aRandom])! !

!ProductRing methodsFor: 'random' stamp: 'len 4/1/2024 09:49:30'!
atRandom: aRandom bits: bits
	^ self compose: (components collect: [:each| each atRandom: aRandom bits: bits])! !

!ProductRing methodsFor: 'random' stamp: 'len 5/1/2024 10:24:00'!
unitAtRandom: aRandom
	^ self compose: (components collect: [:each| each unitAtRandom: aRandom])! !

!ProductRing methodsFor: 'random' stamp: 'len 5/1/2024 10:24:05'!
unitAtRandom: aRandom bits: bitSize
	| n |
	n := bitSize / components size.
	^ self compose: (components collect: [:each| each unitAtRandom: aRandom bits: n])! !

!ProductRing methodsFor: 'testing' stamp: 'len 5/1/2024 10:22:40'!
hasCanonicalAssociates
	^ components allSatisfy: [:each| each hasCanonicalAssociates]! !

!ProductRing methodsFor: 'testing' stamp: 'len 5/20/2023 21:05:30'!
hasCanonicalBases
	^ components allSatisfy: [:each| each hasCanonicalBases]! !

!ProductRing methodsFor: 'testing' stamp: 'len 6/18/2022 12:44:28'!
hasGCD
	^ components allSatisfy: [:each| each hasGCD]! !

!ProductRing methodsFor: 'testing' stamp: 'len 4/25/2020 06:08:33'!
includes: anObject
	^ anObject parent = self! !

!ProductRing methodsFor: 'testing' stamp: 'len 12/21/2022 13:27:34'!
isBezout
	"Answer true if the receiver is a Bézout ring, i.e. every finitely generated ideal is principal."
	"Bézout rings (like PIRs) are closed under products:"
	^ (components allSatisfy: [:each| each isBezout]) or: [super isBezout]! !

!ProductRing methodsFor: 'testing' stamp: 'len 4/27/2021 15:32:19'!
isCommutative
	^ components allSatisfy: [:each| each isCommutative]! !

!ProductRing methodsFor: 'testing' stamp: 'len 7/6/2023 20:03:14'!
isElementaryDivisorRing
	"Answer true if every matrix over the receiver is equivalent to a diagonal matrix."
	^ components allSatisfy: [:each| each isElementaryDivisorRing]! !

!ProductRing methodsFor: 'testing' stamp: 'len 5/26/2022 21:04:19'!
isEuclidean
	"Answer true if the receiver is a Euclidean ring, i.e. it has Euclidean division with remainder."
	self flag: #fixme. "answer false for now because the Euclidean division is not fully implemented"
	^ false
"	^ components allSatisfy: [:each| each isEuclidean]"! !

!ProductRing methodsFor: 'testing' stamp: 'len 8/21/2024 14:51:38'!
isFinitelyGeneratedAlgebra
	^ self propertyAt: #isFinitelyGeneratedAlgebra ifAbsentPut:
		[| scalars |
		scalars := self scalars.
		components allSatisfy: [:each| each isFinitelyGeneratedAlgebra and: [each scalars = scalars]]]! !

!ProductRing methodsFor: 'testing' stamp: 'len 5/7/2022 07:37:14'!
isIntegralDomain
	"The product of two or more nontrivial rings always has nontrivial zero divisors."
	| count |
	count _ 0.
	components do: [:each| each isTrivial ifFalse: [(count _ count + 1) > 1 ifTrue: [^ false]]].
	^ true! !

!ProductRing methodsFor: 'testing' stamp: 'len 12/20/2021 12:10:20'!
isInvolutive
	^ components allSatisfy: [:each| each isInvolutive]! !

!ProductRing methodsFor: 'testing' stamp: 'len 1/14/2022 12:45:43'!
isPIR
	"Answer true if the receiver is a principal ideal ring, i.e. all ideals are principal (but it is not necessarily a PID, i.e. it is not necessarily an integral domain)."
	"A product ring is a PIR if and only if all its components are PIRs."
	^ components allSatisfy: [:each| each isPIR]! !

!ProductRing methodsFor: 'testing' stamp: 'len 4/14/2020 21:19:45'!
isProduct
	^ true! !

!ProductRing methodsFor: 'testing' stamp: 'len 1/2/2022 10:08:41'!
isReduced
	"Answer true if the receiver has no nonzero nilpotent elements, or equivalently if it has no nonzero elements with square zero, i.e. x^2 = 0 implies x = 0."
	(components allSatisfy: [:each| each isReduced]) ifTrue: [^ true]. "is it iff?"
	^ super isReduced! !

!ProductRing methodsFor: 'testing' stamp: 'len 12/20/2021 12:11:31'!
isTrivial
	^ components allSatisfy: [:each| each isTrivial]! !

!ProductRing methodsFor: 'testing' stamp: 'len 6/16/2022 18:30:48'!
isUFR
	"A unique factorization ring (UFR) is a commutative ring in which every nonzero nonunit element can be written as a product of irreducible elements, uniquely up to order and associates."
	"The product of a finite number of UFRs is a UFR. In particular, the product of a finite number of UFDs is a UFR [Fle69]."
	^ components allSatisfy: [:each| each isUFR]! !

!ProductRing methodsFor: 'private' stamp: 'len 11/5/2016 06:41'!
components: anArray
	components _ anArray! !

!ProductRing methodsFor: 'private' stamp: 'len 5/14/2023 17:56:07'!
isValidArray: anArray
	^ anArray class = ProductArray and: [anArray scalars = self]! !

!ProductRing class methodsFor: 'instance creation' stamp: 'len 8/29/2016 04:09'!
components: anArray
	^ self new components: anArray! !

!QuotientRing methodsFor: 'accessing' stamp: 'len 6/10/2022 11:46:11'!
codimension
	"Answer the Krull codimension of the receiver."
	^ self cover dimension - self dimension! !

!QuotientRing methodsFor: 'accessing' stamp: 'len 6/10/2022 11:36:39'!
cover
	^ self relations scalars! !

!QuotientRing methodsFor: 'accessing' stamp: 'len 12/12/2023 19:22:12'!
freeCover
	^ self cover freeCover! !

!QuotientRing methodsFor: 'accessing' stamp: 'len 10/14/2022 06:34:05'!
generators
	^ self propertyAt: #generators ifAbsentPut: [(self cover generators ifNil: [^ nil]) collect: self projection]! !

!QuotientRing methodsFor: 'accessing' stamp: 'len 6/10/2022 11:47:20'!
maximalIdeal
	"If the receiver is a local ring, answer the unique maximal ideal."
	self cover isLocal ifTrue: [^ self cover maximalIdeal apply: self projection].
	^ super maximalIdeal! !

!QuotientRing methodsFor: 'accessing' stamp: 'len 5/1/2022 12:43:26'!
modulus
	^ self propertyAt: #modulus ifAbsentPut: [self relations generator]! !

!QuotientRing methodsFor: 'accessing' stamp: 'len 6/10/2022 11:47:30'!
one
	^ self propertyAt: #one ifAbsentPut: [self project: self cover one]! !

!QuotientRing methodsFor: 'accessing' stamp: 'len 2/27/2017 20:46:50'!
relations
	^ self propertyAt: #relations! !

!QuotientRing methodsFor: 'accessing' stamp: 'len 1/9/2018 21:58:01'!
relators
	^ self relations generators! !

!QuotientRing methodsFor: 'accessing' stamp: 'len 6/10/2022 11:48:19'!
scalars
	^ self cover scalars! !

!QuotientRing methodsFor: 'comparing' stamp: 'len 7/6/2023 22:55:00'!
= anObject
	self == anObject ifTrue: [^ true].
	^ (anObject isKindOf: QuotientRing) and: [self relations = anObject relations]! !

!QuotientRing methodsFor: 'comparing' stamp: 'len 2/27/2017 20:53:58'!
hash
	^ self relations hash! !

!QuotientRing methodsFor: 'computing-matrices' stamp: 'len 10/5/2022 17:43:29'!
matrix: B quotientBy: A
	"Answer X such that AX + N = B, satisfying that if the i-th column of B is a linear combination of the columns of A then the i-th column of N is zero."
	| L |
	L _ self relators
		inject: self cover^0 → A codomain lift
		into: [:matrix :each| matrix ⊔ (A codomain lift endomorphisms scalar: each)].
	^ (B lift quotientBy: A lift modulo: L) apply: self projection! !

!QuotientRing methodsFor: 'computing-matrices' stamp: 'len 10/5/2022 17:43:39'!
syzygiesOf: aMatrix
	"Answer a matrix whose rows span the kernel of the given matrix.
	For a matrix A, the output is X with AX = 0."
	| N |
	N _ self relators
		inject: self cover^0 → aMatrix codomain lift
		into: [:matrix :each| matrix ⊔ (aMatrix codomain lift endomorphisms scalar: each)].
	^ (aMatrix lift syzygiesModulo: N) apply: self projection! !

!QuotientRing methodsFor: 'converting' stamp: 'len 6/10/2022 11:47:41'!
over: aRing
	| R |
	R _ self cover over: aRing.
	^ R / (self relations over: R)! !

!QuotientRing methodsFor: 'elements' stamp: 'len 6/16/2023 18:21:32'!
representative: anElement
	"Answer the residue class corresponding to the given representative (which is already reduced)."
	^ self elementClass representative: anElement parent: self! !

!QuotientRing methodsFor: 'enumerating' stamp: 'len 5/27/2023 15:46:34'!
do: aBlock
	| visited |
	self flag: #fixme. "does this work in any ring? depends on the implementation of do: in the cover ring"
	visited := Set new.
	self cover do: [:each|
		| q |
		visited add: (q := self project: each) ifPresent: [^ self].
		aBlock value: q]! !

!QuotientRing methodsFor: 'enumerating' stamp: 'len 2/25/2024 09:12:20'!
primeIdealsDo: aBlock
	| projection I |
	self isField ifTrue: [aBlock value: self asIdeal null. ^ self].
	self isFinite ifTrue: [^ super primeIdealsDo: aBlock].
	"The prime ideals of R/I are in one-to-one correspondence with the prime ideals P in R that satisfy I ⊆ P (or in other words, P divides I):"
	projection := self cover → self.
	I := self relations.
	self cover primeIdealsDo: [:each| I ⊆ each ifTrue: [aBlock value: (each apply: projection)]]! !

!QuotientRing methodsFor: 'morphisms' stamp: 'len 6/1/2024 07:04:29'!
from: aRing
	aRing = self cover ifTrue: [^ self projection].
	aRing ⇢ self cover ifNotNil: [:aMorphism| ^ self projection · aMorphism].
	(aRing class = self class and: [aRing relations ⊆ self relations])
		ifTrue: [^ aRing to: self map: [:x| self project: x representative]].
	^ super from: aRing! !

!QuotientRing methodsFor: 'morphisms' stamp: 'len 2/27/2017 20:53:22'!
project: anElement
	^ self representative: (self relations reduce: anElement)! !

!QuotientRing methodsFor: 'morphisms' stamp: 'len 5/8/2023 19:14:01'!
projection
	"Answer the natural projection, or quotient map, or canonical homomorphism from the cover ring.
	This takes elements from the cover ring to the corresponding residue class in the quotient ring."
	^ self propertyAt: #projection ifAbsentPut:
		[(self cover onto: self map: [:each| self project: each])
			name: 'π';
			propertyAt: #kernel put: self relations;
			propertyAt: #image put: self;
			yourself]! !

!QuotientRing methodsFor: 'operations' stamp: 'len 10/20/2023 10:51:23'!
/ anIdeal
	"Answer the quotient by the given ideal.
	For convenience, the argument can be a single element or a collection of elements as well."
	| answer I |
	I := (anIdeal isKindOf: Ideal)
		ifTrue: [anIdeal scalars = self ifTrue: [anIdeal] ifFalse: [self * anIdeal generators]]
		ifFalse: [self * anIdeal].
	answer := self cover / (self relations + I representative).
	answer addMap:
		((self onto: answer map: [:each| answer project: each representative])
			name: 'π';
			propertyAt: #kernel put: I;
			propertyAt: #image put: answer;
			yourself).
	^ answer! !

!QuotientRing methodsFor: 'printing' stamp: 'len 8/9/2022 10:21:33'!
printOn: aStream
	self isTrivial ifTrue: [aStream nextPutAll: '{0}'. ^ self].
	aStream print: self cover; nextPut: $╱; print: self relations! !

!QuotientRing methodsFor: 'printing' stamp: 'len 11/14/2023 13:23:37'!
printRepresentative: anElement on: aStream
	aStream print: anElement! !

!QuotientRing methodsFor: 'random' stamp: 'len 6/14/2022 17:53:13'!
atRandom: aRandom
	^ self project: (self cover atRandom: aRandom)! !

!QuotientRing methodsFor: 'random' stamp: 'len 6/10/2022 11:46:07'!
atRandom: aRandom bits: bitSize
	^ self project: (self cover atRandom: aRandom bits: bitSize)! !

!QuotientRing methodsFor: 'testing' stamp: 'len 7/7/2023 19:06:25'!
hasCanonicalAssociates
	^ self cover isEuclidean or: [super hasCanonicalAssociates]! !

!QuotientRing methodsFor: 'testing' stamp: 'len 6/10/2022 11:46:28'!
hasCanonicalReduction
	^ self isField or: [self cover hasCanonicalReduction]! !

!QuotientRing methodsFor: 'testing' stamp: 'len 4/22/2020 06:12:13'!
includes: anObject
	^ anObject parent = self! !

!QuotientRing methodsFor: 'testing' stamp: 'len 6/10/2022 11:46:35'!
isArtinian
	"A ring is called Artinian if it satisfies the descending chain condition on ideals."
	^ self cover isArtinian or: [super isArtinian]! !

!QuotientRing methodsFor: 'testing' stamp: 'len 12/21/2022 13:27:43'!
isBezout
	"Answer true if the receiver is a Bézout ring, i.e. every finitely generated ideal is principal."
	"Bézout rings (like PIRs) are closed under quotients:"
	^ self cover isBezout or: [super isBezout]! !

!QuotientRing methodsFor: 'testing' stamp: 'len 6/10/2022 11:46:44'!
isCommutative
	^ self cover isCommutative or: [super isCommutative]! !

!QuotientRing methodsFor: 'testing' stamp: 'len 6/10/2022 11:46:48'!
isElementaryDivisorRing
	"Answer true if every matrix over the receiver is equivalent to a diagonal matrix."
	^ self cover isElementaryDivisorRing! !

!QuotientRing methodsFor: 'testing' stamp: 'len 6/10/2022 11:46:52'!
isEuclidean
	"Answer true if the receiver is a Euclidean ring, i.e. it has Euclidean division with remainder."
	^ self cover isEuclidean or: [super isEuclidean]! !

!QuotientRing methodsFor: 'testing' stamp: 'len 6/14/2022 17:56:49'!
isField
	"Answer true if the receiver is a field.
	Warning: it might be a field, but in the constructive setting we may not have a way of testing if it is a field."
	^ false

"alternative (but we may not be able to test if an ideal is maximal):
	^ self cover isTrivial not and: [self relations isMaximal]"! !

!QuotientRing methodsFor: 'testing' stamp: 'len 8/21/2024 14:54:19'!
isFinitelyGeneratedAlgebra
	^ self cover isFinitelyGeneratedAlgebra! !

!QuotientRing methodsFor: 'testing' stamp: 'len 7/6/2022 05:53:18'!
isGraded
	^ self cover isGraded and: [self relations isHomogeneous]! !

!QuotientRing methodsFor: 'testing' stamp: 'len 6/14/2022 17:56:43'!
isIntegralDomain
	"A ring is an integral domain if the product of any two nonzero elements is nonzero.
	Warning: it might be an integral domain, but in the constructive setting we may not have a way of testing if it is."
	^ super isIntegralDomain

"alternative:
	^ self cover isTrivial not and: [self relations isPrime]
"! !

!QuotientRing methodsFor: 'testing' stamp: 'len 6/10/2022 11:46:55'!
isLocal
	^ self cover isLocal or: [super isLocal]! !

!QuotientRing methodsFor: 'testing' stamp: 'len 7/6/2022 05:53:42'!
isMultivariate
	^ self cover isMultivariate! !

!QuotientRing methodsFor: 'testing' stamp: 'len 6/10/2022 11:46:59'!
isNoetherian
	"A ring is called Noetherian if every ideal is finitely generated."
	^ self cover isNoetherian or: [super isNoetherian]! !

!QuotientRing methodsFor: 'testing' stamp: 'len 6/10/2022 11:47:04'!
isPIR
	"Answer true if the receiver is a principal ideal ring, i.e. all ideals are principal (but it is not necessarily a PID, i.e. it is not necessarily an integral domain)."
	"Any quotient of a PIR is again a PIR:"
	^ self cover isPIR or: [super isPIR]! !

!QuotientRing methodsFor: 'testing' stamp: 'len 4/12/2021 14:54:10'!
isQuotient
	"Answer true if the receiver is a quotient ring R/I."
	^ true! !

!QuotientRing methodsFor: 'testing' stamp: 'len 1/2/2022 10:08:49'!
isReduced
	"Answer true if the receiver has no nonzero nilpotent elements, or equivalently if it has no nonzero elements with square zero, i.e. x^2 = 0 implies x = 0.
	A quotient ring is reduced iff the relations ideal is radical."
	^ self relations isRadical! !

!QuotientRing methodsFor: 'testing' stamp: 'len 2/27/2017 20:53:34'!
isTrivial
	"The trivial ring is the zero ring with a single element 0 = 1."
	^ self relations isOne! !

!QuotientRing methodsFor: 'testing' stamp: 'len 7/6/2022 05:54:43'!
isUnivariate
	^ self cover isUnivariate! !

!QuotientRing methodsFor: 'private' stamp: 'len 4/24/2019 11:50:53'!
elementClass
	^ Residue! !

!QuotientRing methodsFor: 'private' stamp: 'len 11/17/2023 10:51:14'!
modulus: anElement
	self relations: anElement parent * anElement.
	self propertyAt: #modulus put: anElement! !

!QuotientRing methodsFor: 'private' stamp: 'len 2/27/2017 20:48:00'!
relations: anIdeal
	self propertyAt: #relations put: anIdeal! !

!QuotientRing class methodsFor: 'examples' stamp: 'len 5/23/2020 09:13:12'!
exampleZ6
	"The quotient ring of residue classes of integers modulo 6."
	| I |
	I _ ℤ * 6.
	^ ℤ/I "alternatively, you can just write ℤ/6 or ℤ mod: 6."! !

!QuotientRing class methodsFor: 'examples' stamp: 'len 10/11/2022 10:49:01'!
exampleZ6Elements
	"The elements of the quotient ring of residue classes of integers modulo 6."
	^ (ℤ/6) asSet! !

!QuotientRing class methodsFor: 'examples' stamp: 'len 5/23/2020 09:13:12'!
exampleZ6Projection
	"The canonical projection from the integers ring Z
	to the quotient ring of residue classes modulo 6."
	^ (ℤ/6) projection! !

!QuotientRing class methodsFor: 'instance creation' stamp: 'len 11/17/2023 10:50:34'!
modulus: anElement
	^ self new modulus: anElement! !

!QuotientRing class methodsFor: 'instance creation' stamp: 'len 7/31/2019 08:22:46'!
relations: anIdeal
	^ self new relations: anIdeal! !

!ModularIntegerRing methodsFor: 'accessing' stamp: 'len 4/25/2016 00:26'!
characteristic
	^ self modulus! !

!ModularIntegerRing methodsFor: 'accessing' stamp: 'len 6/10/2022 11:36:53'!
cover
	^ ℤ! !

!ModularIntegerRing methodsFor: 'accessing' stamp: 'len 9/23/2018 01:58:30'!
dimension
	"Answer the Krull dimension of the receiver."
	^ 0! !

!ModularIntegerRing methodsFor: 'accessing' stamp: 'len 11/29/2016 21:41:18'!
modulus
	^ modulus! !

!ModularIntegerRing methodsFor: 'accessing' stamp: 'len 4/3/2024 08:57:52'!
primitiveRoot
	"Answer a generator of the group of units.
	For ℤ/pℤ this is a primitive (p-1)-th root of unity."
	| n powers |
	self propertyAt: #primitiveRoot ifPresent: [:anElement| ^ anElement].
	modulus <= 2 ifTrue: [^ self one].
	(modulus isPowerOfTwo and: [modulus >= 8]) ifTrue: [^ self error: 'no primitive root'].
	n := self units size.
	powers := self units sizeFactorization asSet asArray collect: [:p| n / p].
	^ self propertyAt: #primitiveRoot ifAbsentPut: [self units elements detect: [:x| powers noneSatisfy: [:k| (x^k) isOne]]]! !

!ModularIntegerRing methodsFor: 'accessing' stamp: 'len 5/23/2020 09:13:12'!
relations
	^ self propertyAt: #relations ifAbsentPut: [ℤ * modulus]! !

!ModularIntegerRing methodsFor: 'accessing' stamp: 'len 4/25/2016 00:27'!
size
	^ self modulus! !

!ModularIntegerRing methodsFor: 'accessing' stamp: 'len 5/30/2022 10:03:03'!
unitsSize
	"Answer the order of the units group.
	This is Euler's totient function at the modulus of the receiver."
	^ self propertyAt: #unitsSize ifAbsentPut: [self modulus phi]! !

!ModularIntegerRing methodsFor: 'comparing' stamp: 'len 6/5/2022 19:32:02'!
= anObject
	^ self == anObject or: [self class = anObject class and: [modulus = anObject modulus]]! !

!ModularIntegerRing methodsFor: 'comparing' stamp: 'len 6/5/2022 19:29:37'!
hash
	^ modulus hash! !

!ModularIntegerRing methodsFor: 'converting' stamp: 'len 7/12/2023 14:48:51'!
asAbelianGroup
	"Answer the receiver as a ℤ-module."
	| answer |
	self propertyAt: #asAbelianGroup ifPresent: [:aModule| ^ aModule].
	answer := self cover asAbelianGroup / {self modulus}.
	self
		addCoercionTo: answer map: [:each| answer !! {each representative}];
		addCoercionFrom: answer map: [:each| self !! (each representative at: 1)].
	^ self propertyAt: #asAbelianGroup put: answer! !

!ModularIntegerRing methodsFor: 'elements' stamp: 'len 5/16/2023 20:42:02'!
new: anInteger
	^ ModularArray representatives: (self representativesArrayClass new: anInteger) scalars: self! !

!ModularIntegerRing methodsFor: 'elements' stamp: 'len 5/20/2022 10:39:54'!
zeros: anInteger
	modulus <= 16r100000000 ifTrue: [^ self new: anInteger]. "because in this case the arrays are created already filled with 0"
	^ super zeros: anInteger! !

!ModularIntegerRing methodsFor: 'enumerating' stamp: 'len 4/14/2020 13:34:12'!
do: aBlock
	0 to: self modulus - 1 do: [:i| aBlock value: (self representative: i)]! !

!ModularIntegerRing methodsFor: 'enumerating' stamp: 'len 6/20/2019 16:37:09'!
primeIdealsDo: aBlock
	self modulusPrimes do: [:p| aBlock value: self * (self project: p)]

"	| p |
	p _ 2.
	[p > modulus]
		whileFalse:
			[p | modulus ifTrue: [aBlock value: self * (self project: p)].
			p _ p nextPrime]"! !

!ModularIntegerRing methodsFor: 'morphisms' stamp: 'len 11/30/2016 18:48:51'!
project: anInteger
	^ self representative: anInteger \\ modulus! !

!ModularIntegerRing methodsFor: 'morphisms' stamp: 'len 4/16/2024 18:45:45'!
to: aRing
	"Ring homomorphisms from ℤ/nℤ are canonical: they are determined by the image of 1, and the image of 1 must be 1 in order to make it a ring homomorphism."
	(aRing characteristic > 0 and: [aRing characteristic | self characteristic])
		ifTrue: [^ self to: aRing map: [:x| aRing one * x representative]].
	^ super to: aRing! !

!ModularIntegerRing methodsFor: 'operations' stamp: 'len 11/16/2023 21:54:00'!
@ aPrimeIdeal
	"Answer the localization of the receiver at aPrimeIdeal."
	| p |
	(aPrimeIdeal isTrivial and: [self isIntegralDomain]) ifTrue: [^ self fractions].
	p _ aPrimeIdeal generator representative.
	^ PrimePowerRing new: p to: (self modulus valuation: p)! !

!ModularIntegerRing methodsFor: 'operations' stamp: 'len 11/16/2023 21:54:00'!
decomposition
	"Answer the decomposition of the receiver as product of prime power rings."
	^ self propertyAt: #decomposition ifAbsentPut:
		[| components answer crt |
		components _ OrderedCollection new.
		self modulusFactors withOccurrencesDo: [:p :k| components add: (PrimePowerRing new: p to: k)].
		components _ components asArray.
		crt _ CRT moduli: (components collect: [:each| each modulus]).
		(answer _ ProductRing components: components)
			addMap: (answer to: self map: [:x| self project: (crt solve: (x components collect: [:each| each representative]))]);
			addMap: (self to: answer map: [:x| answer compose: (components collect: [:each| each project: x representative])]);
			yourself]! !

!ModularIntegerRing methodsFor: 'printing' stamp: 'len 8/9/2022 10:22:39'!
printOn: aStream
	self isTrivial ifTrue: [aStream nextPutAll: '{0}'. ^ self].
	aStream print: self cover; nextPut: $╱; print: self modulus; print: self cover! !

!ModularIntegerRing methodsFor: 'random' stamp: 'len 5/26/2022 13:07:15'!
atRandom: aRandom
	^ self representative: (self modulus atRandom: aRandom) - 1! !

!ModularIntegerRing methodsFor: 'random' stamp: 'len 4/19/2016 22:14'!
atRandom: aRandom bits: bitSize
	^ self atRandom: aRandom! !

!ModularIntegerRing methodsFor: 'random' stamp: 'len 5/16/2023 20:44:46'!
new: anInteger atRandom: aRandom
	| representatives |
	representatives _ self representativesArrayClass new: anInteger.
	1 to: anInteger do: [:i| representatives at: i put: (aRandom nextInteger: modulus) - 1].
	^ ModularArray representatives: representatives scalars: self! !

!ModularIntegerRing methodsFor: 'random' stamp: 'len 5/16/2023 20:46:26'!
new: anInteger atRandom: aRandom bits: bitSize
	^ self new: anInteger atRandom: aRandom! !

!ModularIntegerRing methodsFor: 'testing' stamp: 'len 5/13/2022 12:16:18'!
hasCanonicalAssociates
	^ true! !

!ModularIntegerRing methodsFor: 'testing' stamp: 'len 11/1/2023 17:03:56'!
hasPrimitiveRoot
	"Answer true if the group of units is cyclic (in which case a generator is called a 'primitive root').
	The group of units of ℤ/nℤ is cyclic iff n = 1, 2, 4, or 2p^k for odd prime p."
	| factors n |
	n := self modulus.
	(n = 1 or: [n = 2 or: [n = 4]]) ifTrue: [^ true].
	n even ifTrue: [n := n // 2].
	n even ifTrue: [^ false].
	factors := self modulusFactors.
	^ (factors asSet copyWithout: 2) size = 1! !

!ModularIntegerRing methodsFor: 'testing' stamp: 'len 4/24/2024 05:17:27'!
includes: anObject
	^ anObject parent = self! !

!ModularIntegerRing methodsFor: 'testing' stamp: 'len 12/31/2021 11:51:36'!
isEuclidean
	"Answer true if the receiver is a Euclidean ring, i.e. it has Euclidean division with remainder."
	^ true! !

!ModularIntegerRing methodsFor: 'testing' stamp: 'len 6/3/2022 07:02:02'!
isField
	"Answer true if the receiver is a field.
	Warning: it might be a field, but we consider it as a general ring without assuming anything."
	^ false

"alternative:
	^ self modulus isPrime"! !

!ModularIntegerRing methodsFor: 'testing' stamp: 'len 5/21/2018 05:09:16'!
isFinite
	^ true! !

!ModularIntegerRing methodsFor: 'testing' stamp: 'len 1/19/2018 22:33:59'!
isIntegralDomain
	^ self isField! !

!ModularIntegerRing methodsFor: 'testing' stamp: 'len 5/9/2023 23:06:37'!
isLocal
	"ℤ/nℤ is local if and only if n is a prime power. See PrimePowerRing."
	^ self modulusFactors asSet size = 1! !

!ModularIntegerRing methodsFor: 'testing' stamp: 'len 9/27/2018 21:29:36'!
isPID
	^ self isIntegralDomain! !

!ModularIntegerRing methodsFor: 'testing' stamp: 'len 1/14/2022 12:45:34'!
isPIR
	"Answer true if the receiver is a principal ideal ring, i.e. all ideals are principal (but it is not necessarily a PID, i.e. it is not necessarily an integral domain)."
	^ true! !

!ModularIntegerRing methodsFor: 'testing' stamp: 'len 1/14/2022 12:04:52'!
isReduced
	"Answer true if the receiver has no nonzero nilpotent elements, or equivalently if it has no nonzero elements with square zero, i.e. x^2 = 0 implies x = 0.
	This is true if the modulus is squarefree."
	modulus = 0 ifTrue: [^ true].
	self modulusFactors withOccurrencesDo: [:p :e| e > 1 ifTrue: [^ false]].
	^ true

"	^ modulus = 0 or: [modulus isSquarefree]"! !

!ModularIntegerRing methodsFor: 'testing' stamp: 'len 5/9/2023 23:07:06'!
isUFR
	"Actually ℤ/nℤ is UFR for any n by the definition of [Fle69], but by [Gal78] only if n is a power of a prime."
	^ true! !

!ModularIntegerRing methodsFor: 'private' stamp: 'len 11/16/2023 21:50:15'!
elementClass
	^ ModularInteger! !

!ModularIntegerRing methodsFor: 'private' stamp: 'len 5/15/2023 17:07:27'!
isValidArray: anArray
	^ anArray class = ModularArray and: [anArray scalars = self]! !

!ModularIntegerRing methodsFor: 'private' stamp: 'len 11/29/2016 21:47:19'!
modulus: anInteger
	modulus _ anInteger! !

!ModularIntegerRing methodsFor: 'private' stamp: 'len 8/5/2021 08:40:30'!
modulusFactors
	^ self propertyAt: #modulusFactors ifAbsentPut: [self modulus factorization]! !

!ModularIntegerRing methodsFor: 'private' stamp: 'len 7/31/2019 08:17:57'!
modulusFactors: aBag
	self propertyAt: #modulusFactors put: aBag! !

!ModularIntegerRing methodsFor: 'private' stamp: 'len 6/16/2019 12:57:35'!
modulusPrimes
	^ self propertyAt: #modulusPrimes ifAbsentPut: [self modulusFactors asSet asArray sort]! !

!ModularIntegerRing methodsFor: 'private' stamp: 'len 2/27/2017 20:48:23'!
relations: anIdeal
	super relations: anIdeal.
	self modulus: anIdeal generator! !

!ModularIntegerRing methodsFor: 'private' stamp: 'len 5/16/2023 20:41:23'!
representativesArrayClass
	^ modulus <= 256 ifTrue: [ByteArray] ifFalse: [modulus <= 16r10000 ifTrue: [DoubleByteArray] ifFalse: [modulus <= 16r100000000 ifTrue: [WordArray] ifFalse: [Array]]]! !

!ModularIntegerRing class methodsFor: 'class initialization' stamp: 'len 5/16/2023 21:52:47'!
initialize
	super initialize.
	Cache _ Array new: 256.
	Cache at: 2 put: (BinaryField new: 2).
	Cache at: 3 put: (TernaryField new: 3)! !

!ModularIntegerRing class methodsFor: 'instance creation' stamp: 'len 11/26/2023 10:00:46'!
modulus: anInteger
	"Answer a new ring ℤ/nℤ keeping a cache for rings with small n."
	anInteger > Cache size ifTrue: [^ super modulus: anInteger].
	^ (Cache at: anInteger) ifNil: [Cache at: anInteger put: (super modulus: anInteger)]! !

!ModularIntegerRing class methodsFor: 'instance creation' stamp: 'len 11/26/2023 10:00:56'!
new: anInteger
	^ self modulus: anInteger! !

!PrimePowerRing methodsFor: 'accessing' stamp: 'len 5/1/2024 12:25:08'!
base
	^ base ifNil: [base := self modulusFactors any]! !

!PrimePowerRing methodsFor: 'accessing' stamp: 'len 9/22/2018 18:56:21'!
degree
	"Answer the degree of the receiver as an algebraic extension (as a Galois ring)."
	^ 1! !

!PrimePowerRing methodsFor: 'accessing' stamp: 'len 5/21/2018 04:19:07'!
exponent
	^ self propertyAt: #exponent ifAbsentPut: [self modulusFactors size]! !

!PrimePowerRing methodsFor: 'accessing' stamp: 'len 9/8/2023 17:03:02'!
maximalIdeal
	^ self * self base! !

!PrimePowerRing methodsFor: 'accessing' stamp: 'len 9/8/2023 17:03:42'!
residueField
	"Answer the prime field ℤ/pℤ isomorphic to the residue field of the receiver, equipped with the canonical projection."
	^ self propertyAt: #residueField ifAbsentPut:
		[| answer |
		(answer := PrimeField new: self base)
			addMap: (self onto: answer map: [:x| answer !! x representative]); "TODO: add kernel and section"
			yourself]! !

!PrimePowerRing methodsFor: 'accessing' stamp: 'len 9/8/2023 17:04:39'!
unitsSize
	"Answer the order of the units group.
	This is Euler's totient function at the modulus of the receiver."
	^ modulus / self base * (self base - 1)! !

!PrimePowerRing methodsFor: 'enumerating' stamp: 'len 9/8/2023 17:02:54'!
idealsDo: aBlock
	"The ideals of ℤ/(p^n)ℤ are {0} and <p^i> for 0 <= i < n-1."
	| a |
	aBlock value: self * 0.
	a := self one.
	self exponent timesRepeat:
		[aBlock value: self * a.
		a := a * self base]! !

!PrimePowerRing methodsFor: 'morphisms' stamp: 'len 4/16/2024 18:38:06'!
from: aRing
	((aRing isKindOf: ModularIntegerRing) and: [self modulus | aRing modulus and: [(self modulus * self base | aRing modulus) not]]) "localization map"
		ifTrue: [^ aRing onto: self map: [:x| self project: x lift]]. 
	^ super from: aRing! !

!PrimePowerRing methodsFor: 'morphisms' stamp: 'len 11/16/2023 21:54:00'!
quadraticLiftingsDo: aBlock
	self exponent > 1 ifTrue:
		[| R |
		self exponent odd ifTrue: [^ self error: 'odd exponent'].
		R := PrimePowerRing new: self base to: self exponent // 2.
		R quadraticLiftingsDo: aBlock.
		aBlock value: (R to: self map: [:x| self project: x lift])]! !

!PrimePowerRing methodsFor: 'morphisms' stamp: 'len 4/16/2024 18:46:02'!
to: aRing
	"Cannonical projection from ℤ/(p^n)ℤ to ℤ/(p^m)ℤ, 1 <= m <= n."
	((aRing isKindOf: PrimePowerRing) and: [aRing base = self base and: [aRing exponent < self exponent]])
		ifTrue: [^ (self onto: aRing map: [:x| aRing project: x representative]) name: 'π'].
	^ super to: aRing! !

!PrimePowerRing methodsFor: 'operations' stamp: 'len 11/26/2023 10:54:59'!
extensionDegree: anInteger
	"Answer a Galois extension of the given degree. This is a Galois ring."
	anInteger = 1 ifTrue: [^ self].
	^ (self propertyAt: #extensions ifAbsentPut: [WeakValueDictionary new])
		at: anInteger ifAbsentOrNilPut:
			[self extension: ((self residueField primitivePolynomialDegree: anInteger) lift apply: self projection)]! !

!PrimePowerRing methodsFor: 'operations' stamp: 'len 5/21/2018 15:42:20'!
nilradical
	"Answer the ideal consisting of all nilpotent elements, i.e. all x such that there exists some n with x^n = 0. It is the intersection of all prime ideals.
	A finite ring is a Galois ring iff its nilradical is of the form <p> for some prime p. This is also the unique maximal ideal."
	^ self maximalIdeal! !

!PrimePowerRing methodsFor: 'operations' stamp: 'len 11/21/2023 15:11:52'!
zeroDivisors
	"The zero divisors of a Galois ring ℤ/(p^k)ℤ constitute the unique maximal ideal ⟨p⟩."
	^ self maximalIdeal! !

!PrimePowerRing methodsFor: 'operations' stamp: 'len 11/22/2023 10:45:10'!
∧ aGaloisRing
	"Answer the intersection or meet of the receiver and the argument in the lattice of Galois rings of a given characteristic p^n, i.e. the maximal subring of both the receiver and the argument."
	self = aGaloisRing ifTrue: [^ self].
	self assert: (aGaloisRing isKindOf: GaloisRing).
	^ aGaloisRing ∧ self! !

!PrimePowerRing methodsFor: 'operations' stamp: 'len 11/22/2023 10:44:44'!
∨ aGaloisRing
	"Answer the join of the receiver and the argument in the lattice of Galois rings of a given characteristic p^n, i.e. the minimal Galois ring that includes both the receiver and the argument as subrings."
	self = aGaloisRing ifTrue: [^ self].
	self assert: (aGaloisRing isKindOf: GaloisRing).
	^ aGaloisRing ∨ self! !

!PrimePowerRing methodsFor: 'printing' stamp: 'len 9/8/2023 17:03:18'!
printOn: aStream
	aStream print: self cover; nextPut: $╱; print: self base; nextPutAll: self exponent printString super; print: self cover! !

!PrimePowerRing methodsFor: 'testing' stamp: 'len 6/25/2019 02:19:48'!
isChainRing
	"A chain ring is a ring whose ideals form a chain under inclusion.
	Prime power rings, and more generally Galois rings, are chain rings."
	^ true! !

!PrimePowerRing methodsFor: 'testing' stamp: 'len 5/21/2018 04:26:10'!
isField
	^ self exponent = 1! !

!PrimePowerRing methodsFor: 'testing' stamp: 'len 9/22/2018 18:56:29'!
isGaloisRing
	^ true! !

!PrimePowerRing methodsFor: 'testing' stamp: 'len 5/21/2018 04:12:49'!
isLocal
	^ true! !

!PrimePowerRing methodsFor: 'testing' stamp: 'len 9/22/2018 18:57:35'!
isPIR
	"All nontrivial ideals are of the form <p^i>."
	^ true! !

!PrimePowerRing methodsFor: 'private' stamp: 'len 11/16/2023 21:52:59'!
elementClass
	^ PrimePowerResidue! !

!PrimePowerRing methodsFor: 'private' stamp: 'len 11/23/2023 22:11:09'!
extensionClass
	^ GaloisRing! !

!PrimePowerRing methodsFor: 'private' stamp: 'len 11/26/2023 10:36:41'!
modulus: aPrime to: anInteger
	self modulus: aPrime^anInteger.
	self propertyAt: #modulusFactors put: (Bag new add: aPrime withOccurrences: anInteger; yourself)! !

!PrimePowerRing methodsFor: 'as yet unclassified' stamp: 'len 11/17/2023 16:45:42'!
polynomial: aPolynomial liftFactors: anArray
	"Answer the Hensel lifting of a factorization over the residue field to a factorization over the receiver."
	| r mid g h s t euclid gFactors hFactors |
"	p _ factors anyOne scalars characteristic."
	r := anArray size.
	r = 1 ifTrue: "can be optimized, compute inverse modulo p using extended euclid, then lift to p^k with newton iteration algorithm 9.10 (modern computer algebra)"
		[^ {aPolynomial * aPolynomial leadingCoefficient inverse}].
	mid := r // 2.
	gFactors := anArray copyFrom: 1 to: mid.
	hFactors := anArray copyFrom: mid+1 to: r.
	g := gFactors product * aPolynomial leadingCoefficient.
	h := hFactors product.
	euclid := g xgcd: h.
	s := euclid at: 2.
	t := euclid at: 3.
"	m _ p."
	self quadraticLiftingsDo: [:phi| "Hensel step:"
		| e division c d b |
"		self assert: (self % m - (g*h)) isZero.
		self assert: (s*g + (t*h) - 1) isZero.
		m _ m squared."
		g := g apply: phi. h := h apply: phi. s := s apply: phi. t := t apply: phi.
		e := (aPolynomial over: phi codomain) - (g*h).
		division := s*e divisionBy: h.
		c := division quotient.
		d := division remainder.
		g := g + (t*e) + (c*g).
		h := h + d.
		b := s*g + (t*h) - 1.
		division := s*b divisionBy: h.
		c := division quotient.
		d := division remainder.
		s := s - d.
		t := t - (t*b) - (c*g).
"		self assert: (self % m - (g*h)) isZero.
		self assert: (s*g + (t*h) - 1) isZero"].
	^ (self polynomial: g liftFactors: gFactors), (self polynomial: h liftFactors: hFactors)! !

!PrimePowerRing class methodsFor: 'instance creation' stamp: 'len 11/26/2023 10:44:08'!
modulus: p to: n
	| m |
	n = 1 ifTrue: [^ PrimeField modulus: p].
	(m := p^n) > Cache size ifTrue: [^ self new modulus: p to: n].
	^ (Cache at: m) ifNil: [Cache at: m put: (self new modulus: p to: n)]! !

!PrimePowerRing class methodsFor: 'instance creation' stamp: 'len 11/26/2023 10:37:47'!
new: p to: n
	^ self modulus: p to: n! !

!PrimeField methodsFor: 'accessing' stamp: 'len 9/8/2023 17:18:47'!
base
	^ modulus! !

!PrimeField methodsFor: 'accessing' stamp: 'len 6/19/2019 14:27:56'!
exponent
	^ 1! !

!PrimeField methodsFor: 'accessing' stamp: 'len 5/30/2022 10:03:15'!
unitsSize
	"Answer the order of the units group.
	This is Euler's totient function at the modulus of the receiver."
	^ modulus - 1! !

!PrimeField methodsFor: 'comparing' stamp: 'len 9/22/2018 18:56:11'!
~ aRing
	"Any two finite fields of the same cardinality are isomorphic."
	^ aRing isField and: [self size = aRing size]! !

!PrimeField methodsFor: 'computing-matrices' stamp: 'len 6/1/2022 20:28:23'!
matrix: B quotientBy: A
	"Answer X such that AX + N = B, satisfying that if the i-th column of B is a linear combination of the columns of A then the i-th column of N is zero."
	^ self matrixOverField: B quotientBy: A! !

!PrimeField methodsFor: 'computing-matrices' stamp: 'len 12/31/2021 14:19:52'!
syzygiesOf: aMatrix
	"Answer a matrix whose rows span the kernel of the given matrix.
	For a matrix A, the output is X with AX = 0."
	^ self syzygiesOverEuclideanDomainOf: aMatrix! !

!PrimeField methodsFor: 'computing-polynomials' stamp: 'len 11/26/2023 09:52:19'!
irreduciblePolynomialDegree: n
	"Answer a monic irreducible polynomial of degree n."
	(modulus <= 255 and: [n <= 255]) ifTrue: [ConwayPolynomials at: {modulus. n} asByteArray ifPresent: [:coefficients| ^ self polynomials !! coefficients]].
	^ (self propertyAt: #irreduciblePolynomialsCache ifAbsentPut: [WeakValueDictionary new])
		at: n ifAbsentOrNilPut: [super irreduciblePolynomialDegree: n]! !

!PrimeField methodsFor: 'computing-polynomials' stamp: 'len 11/23/2023 22:19:11'!
primitivePolynomialDegree: n
	"Answer a monic irreducible primitive polynomial of degree n."
	| m factors P x random a₀ f F |
	(modulus <= 255 and: [n <= 255]) ifTrue: [ConwayPolynomials at: {modulus. n} asByteArray ifPresent: [:coefficients| ^ self polynomials !! coefficients]].
	(self propertyAt: #primitivePolynomialsCache ifAbsentPut: [WeakValueDictionary new])
		at: n ifPresent: [:aPolynomial| ^ aPolynomial].
	m := modulus^n - 1.
	factors := m factorization.
	P := self polynomials.
	x := P x.
	random := Random new.
	[[[a₀ := self atRandom: random. (n even ifTrue: [a₀] ifFalse: [a₀ negated]) isPrimitiveRoot] whileFalse.
	f := (P atRandom: random maxDegree: n-2) << 1 + (x^n) + a₀.
	f isIrreducible] whileFalse.
	F := GaloisField modulus: f.
	(F units orderOf: F x multiple: m factorization: factors) = m] whileFalse.
	^ (self propertyAt: #primitivePolynomialsCache) at: n put: f

"
alternative:
	m := modulus^n - 1.
	factors := m factorization.
	[f := self findIrreduciblePolynomialOfDegree: n.
	F := GaloisField modulus: f.
	(F units orderOf: F x multiple: m factorization: factors) = m] whileFalse.
	^ f"! !

!PrimeField methodsFor: 'computing-polynomials' stamp: 'len 7/14/2023 18:14:44'!
rootsOf: aPolynomial do: aBlock
	"Enumerate the distinct roots of aPolynomial (ignoring multiplicities)."
	^ super rootsOf: aPolynomial do: aBlock

"alternative: (which turns out to be slower)"
	"The polynomial x^p - x has as roots all elements of the receiver, so we compute the roots of the gcd of aPolynomial with x^p - x (which has the same roots as aPolynomial with multiplicity 1)."
"	| f h |
	h := (aPolynomial parent x raisedTo: self p modulo: aPolynomial) - aPolynomial parent x.
	f := aPolynomial gcd: h.
	f equalDegreeFactorization: 1 do: [:each| aBlock value: each independentCoefficient negated / each leadingCoefficient]"! !

!PrimeField methodsFor: 'enumerating' stamp: 'len 4/8/2021 12:38:17'!
primeIdealsDo: aBlock
	aBlock value: self asIdeal null! !

!PrimeField methodsFor: 'enumerating' stamp: 'len 6/19/2019 16:09:42'!
unitsDo: aBlock
	1 to: modulus - 1 do: [:each| aBlock value: (self representative: each)]! !

!PrimeField methodsFor: 'morphisms' stamp: 'len 11/5/2023 09:31:58'!
frobenius
	^ self id! !

!PrimeField methodsFor: 'operations' stamp: 'len 11/22/2023 16:27:11'!
algebraicClosure
	^ self propertyAt: #algebraicClosure ifAbsentPut: [AlgebraicClosureField over: self]! !

!PrimeField methodsFor: 'operations' stamp: 'len 11/26/2023 09:58:31'!
extensionDegree: anInteger
	"Answer an extension field of the given degree."
	anInteger = 1 ifTrue: [^ self].
	^ (self propertyAt: #extensions ifAbsentPut: [WeakValueDictionary new])
		at: anInteger ifAbsentOrNilPut: [self extension: (self irreduciblePolynomialDegree: anInteger)]! !

!PrimeField methodsFor: 'operations' stamp: 'len 5/7/2022 07:34:57'!
zeroDivisors
	^ {self zero}! !

!PrimeField methodsFor: 'printing' stamp: 'len 8/9/2022 08:27:23'!
printOn: aStream
	aStream nextPut: $𝔽; nextPutAll: self modulus printString sub! !

!PrimeField methodsFor: 'testing' stamp: 'len 10/18/2016 20:46'!
isField
	^ true! !

!PrimeField methodsFor: 'testing' stamp: 'len 7/15/2021 16:07:32'!
isFiniteField
	^ true! !

!PrimeField methodsFor: 'testing' stamp: 'len 5/12/2023 21:08:17'!
isPrimeField
	"The ℤ/pℤ is a prime field (it has no proper subfields)."
	^ true! !

!PrimeField methodsFor: 'private' stamp: 'len 11/16/2023 21:53:29'!
elementClass
	^ PrimeResidue! !

!PrimeField methodsFor: 'private' stamp: 'len 7/15/2021 19:11:34'!
extensionClass
	^ GaloisField! !

!PrimeField methodsFor: 'private' stamp: 'len 5/16/2023 21:51:22'!
modulus: anInteger
	self propertyAt: #modulusFactors put: (Bag with: anInteger).
	super modulus: anInteger! !

!PrimeField methodsFor: 'private' stamp: 'len 11/26/2023 10:38:46'!
modulus: aPrime to: anInteger
	self assert: anInteger = 1.
	super modulus: aPrime to: anInteger! !

!PrimeField methodsFor: 'private' stamp: 'len 1/8/2024 10:28:03'!
squareRootOfRepresentative: anInteger
	| algorithm |
	modulus = 2 ifTrue: [^ anInteger].
	algorithm := self propertyAt: #squareRootAlgorithm ifAbsentPut: [TonelliShanks new modulus: modulus].
	^ algorithm squareRootOf: anInteger! !

!PrimeField class methodsFor: 'class initialization' stamp: 'len 7/14/2023 11:41:09'!
initialize
	super initialize.
	"Conway polynomials for all Galois fields of even order <= 2^64 and odd order < 2^16."
	ConwayPolynomials := Dictionary new.
	#(
(#[2 2] #[1 1 1])
(#[2 3] #[1 1 0 1])
(#[2 4] #[1 1 0 0 1])
(#[2 5] #[1 0 1 0 0 1])
(#[2 6] #[1 1 0 1 1 0 1])
(#[2 7] #[1 1 0 0 0 0 0 1])
(#[2 8] #[1 0 1 1 1 0 0 0 1])
(#[2 9] #[1 0 0 0 1 0 0 0 0 1])
(#[2 10] #[1 1 1 1 0 1 1 0 0 0 1])
(#[2 11] #[1 0 1 0 0 0 0 0 0 0 0 1])
(#[2 12] #[1 1 0 1 0 1 1 1 0 0 0 0 1])
(#[2 13] #[1 1 0 1 1 0 0 0 0 0 0 0 0 1])
(#[2 14] #[1 0 0 1 0 1 0 1 0 0 0 0 0 0 1])
(#[2 15] #[1 0 1 0 1 1 0 0 0 0 0 0 0 0 0 1])
(#[2 16] #[1 0 1 1 0 1 0 0 0 0 0 0 0 0 0 0 1])
(#[2 17] #[1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1])
(#[2 18] #[1 1 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 1])
(#[2 19] #[1 1 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1])
(#[2 20] #[1 1 0 0 1 1 1 1 0 1 1 0 0 0 0 0 0 0 0 0 1])
(#[2 21] #[1 0 1 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1])
(#[2 22] #[1 0 0 0 0 1 1 0 1 1 1 1 1 0 0 0 0 0 0 0 0 0 1])
(#[2 23] #[1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1])
(#[2 24] #[1 0 0 1 0 1 0 1 0 1 1 0 0 1 1 1 1 0 0 0 0 0 0 0 1])
(#[2 25] #[1 0 1 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1])
(#[2 26] #[1 1 0 0 1 0 1 1 1 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1])
(#[2 27] #[1 0 1 1 0 1 0 1 0 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1])
(#[2 28] #[1 0 1 0 0 1 1 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1])
(#[2 29] #[1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1])
(#[2 30] #[1 1 1 1 0 1 0 1 0 0 0 1 0 1 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 1])
(#[2 31] #[1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1])
(#[2 32] #[1 0 0 1 1 0 0 1 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1])
(#[2 33] #[1 0 0 1 0 0 1 0 1 0 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1])
(#[2 34] #[1 1 1 0 1 1 1 1 1 0 0 1 1 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1])
(#[2 35] #[1 0 1 0 0 1 0 1 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1])
(#[2 36] #[1 1 0 0 0 1 1 0 1 0 0 0 0 1 1 0 0 1 0 1 1 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 1])
(#[2 37] #[1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1])
(#[2 38] #[1 1 1 0 0 1 0 0 1 1 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1])
(#[2 39] #[1 0 1 0 0 1 1 1 0 1 1 1 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1])
(#[2 40] #[1 1 0 1 0 1 0 0 1 0 0 0 1 1 0 1 1 0 1 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1])
(#[2 41] #[1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1])
(#[2 42] #[1 1 1 0 0 1 1 0 0 1 0 1 1 0 0 0 0 0 1 0 1 0 0 0 1 1 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1])
(#[2 43] #[1 0 0 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1])
(#[2 44] #[1 1 0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 1 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1])
(#[2 45] #[1 0 0 0 0 0 1 0 0 0 0 1 1 0 1 1 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1])
(#[2 46] #[1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1])
(#[2 47] #[1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1])
(#[2 48] #[1 0 0 1 0 0 0 1 1 0 1 1 1 0 0 0 0 1 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1])
(#[2 49] #[1 1 1 1 1 0 1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1])
(#[2 50] #[1 0 1 0 1 0 1 0 1 1 1 0 1 1 1 0 1 1 0 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1])
(#[2 51] #[1 0 0 0 0 0 1 0 0 1 0 0 1 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1])
(#[2 52] #[1 1 0 0 1 0 0 1 0 0 1 0 0 0 1 1 0 1 0 0 0 1 0 1 0 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1])
(#[2 53] #[1 1 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1])
(#[2 54] #[1 1 1 0 1 0 0 1 0 0 0 0 0 1 0 1 1 1 1 0 0 1 0 0 0 1 0 1 0 1 1 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1])
(#[2 55] #[1 0 0 0 1 0 0 1 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1])
(#[2 56] #[1 0 1 1 1 0 0 0 1 1 0 1 0 1 1 0 0 0 0 1 0 0 1 0 0 0 1 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1])
(#[2 57] #[1 1 1 1 1 1 1 0 1 0 1 1 0 1 0 0 1 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1])
(#[2 58] #[1 1 0 1 0 1 1 1 1 0 1 1 1 0 0 0 1 0 1 0 0 0 1 0 1 1 1 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1])
(#[2 59] #[1 1 0 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1])
(#[2 60] #[1 0 1 1 1 1 0 0 1 0 0 0 1 0 0 0 0 1 0 1 0 0 1 0 0 1 1 0 0 0 1 0 1 1 1 0 1 0 0 1 0 1 1 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1])
(#[2 61] #[1 1 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1])
(#[2 62] #[1 1 0 0 0 0 1 0 0 0 0 0 1 1 1 0 1 1 1 1 1 1 0 0 1 1 1 1 1 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1])
(#[2 63] #[1 1 1 1 1 0 0 0 1 1 0 1 0 0 0 1 1 1 0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1])
(#[2 64] #[1 1 1 0 1 1 0 1 0 0 1 1 1 1 0 0 0 0 1 0 1 1 1 1 1 1 1 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1])
(#[3 2] #[2 2 1])
(#[3 3] #[1 2 0 1])
(#[3 4] #[2 0 0 2 1])
(#[3 5] #[1 2 0 0 0 1])
(#[3 6] #[2 2 1 0 2 0 1])
(#[3 7] #[1 0 2 0 0 0 0 1])
(#[3 8] #[2 2 2 0 1 2 0 0 1])
(#[3 9] #[1 1 2 2 0 0 0 0 0 1])
(#[3 10] #[2 1 0 0 2 2 2 0 0 0 1])
(#[5 2] #[2 4 1])
(#[5 3] #[3 3 0 1])
(#[5 4] #[2 4 4 0 1])
(#[5 5] #[3 4 0 0 0 1])
(#[5 6] #[2 0 1 4 1 0 1])
(#[7 2] #[3 6 1])
(#[7 3] #[4 0 6 1])
(#[7 4] #[3 4 5 0 1])
(#[7 5] #[4 1 0 0 0 1])
(#[11 2] #[2 7 1])
(#[11 3] #[9 2 0 1])
(#[11 4] #[2 10 8 0 1])
(#[13 2] #[2 12 1])
(#[13 3] #[11 2 0 1])
(#[13 4] #[2 12 3 0 1])
(#[17 2] #[3 16 1])
(#[17 3] #[14 1 0 1])
(#[19 2] #[2 18 1])
(#[19 3] #[17 4 0 1])
(#[23 2] #[5 21 1])
(#[23 3] #[18 2 0 1])
(#[29 2] #[2 24 1])
(#[29 3] #[27 2 0 1])
(#[31 2] #[3 29 1])
(#[31 3] #[28 1 0 1])
(#[37 2] #[2 33 1])
(#[37 3] #[35 6 0 1])
(#[41 2] #[6 38 1])
(#[43 2] #[3 42 1])
(#[47 2] #[5 45 1])
(#[53 2] #[2 49 1])
(#[59 2] #[2 58 1])
(#[61 2] #[2 60 1])
(#[67 2] #[2 63 1])
(#[71 2] #[7 69 1])
(#[73 2] #[5 70 1])
(#[79 2] #[3 78 1])
(#[83 2] #[2 82 1])
(#[89 2] #[3 82 1])
(#[97 2] #[5 96 1])
(#[101 2] #[2 97 1])
(#[103 2] #[5 102 1])
(#[107 2] #[2 103 1])
(#[109 2] #[6 108 1])
(#[113 2] #[3 101 1])
(#[127 2] #[3 126 1])
(#[131 2] #[2 127 1])
(#[137 2] #[3 131 1])
(#[139 2] #[2 138 1])
(#[149 2] #[2 145 1])
(#[151 2] #[6 149 1])
(#[157 2] #[5 152 1])
(#[163 2] #[2 159 1])
(#[167 2] #[5 166 1])
(#[173 2] #[2 169 1])
(#[179 2] #[2 172 1])
(#[181 2] #[2 177 1])
(#[191 2] #[19 190 1])
(#[193 2] #[5 192 1])
(#[197 2] #[2 192 1])
(#[199 2] #[3 193 1])
(#[211 2] #[2 207 1])
(#[223 2] #[3 221 1])
(#[227 2] #[2 220 1])
(#[229 2] #[6 228 1])
(#[233 2] #[3 232 1])
(#[239 2] #[7 237 1])
(#[241 2] #[7 238 1])
(#[251 2] #[6 242 1])
	) do: [:each| ConwayPolynomials at: each first put: each second]! !

!BinaryField methodsFor: 'computing-polynomials' stamp: 'len 12/29/2023 10:03:28'!
rootsOf: aPolynomial do: aBlock
	"Enumerate the distinct roots of aPolynomial (ignoring multiplicities)."
	aPolynomial isZero ifTrue: [^ self do: aBlock].
	aPolynomial independentCoefficient isZero ifTrue: [aBlock value: self zero].
	(aPolynomial parent scalars = self ifTrue: [aPolynomial coefficients sum] ifFalse: [aPolynomial coefficients sum: [:each| self !! each]]) isZero ifTrue: [aBlock value: self one]! !

!BinaryField methodsFor: 'elements' stamp: 'len 5/16/2023 21:37:14'!
new: anInteger
	^ BinaryArray new: anInteger! !

!BinaryField methodsFor: 'random' stamp: 'len 5/16/2023 21:39:53'!
new: anInteger atRandom: aRandom
	| words |
	words _ WordArray new: anInteger - 1 // 32 + 1.
	1 to: words size do: [:i| words at: i put: (aRandom nextInteger: 16r100000000) - 1].
	anInteger \\ 32 = 0 ifFalse: [words at: words size put: (aRandom nextBits: anInteger \\ 32)].
	^ BinaryArray new: anInteger words: words! !

!BinaryField methodsFor: 'private' stamp: 'len 5/16/2023 21:36:25'!
isValidArray: anArray
	^ anArray class = BinaryArray! !

!BinaryField methodsFor: 'private' stamp: 'len 5/16/2023 21:51:45'!
modulus: anInteger
	self assert: anInteger = 2.
	super modulus: anInteger! !

!TernaryField methodsFor: 'elements' stamp: 'len 5/16/2023 21:37:30'!
new: anInteger
	^ TernaryArray new: anInteger! !

!TernaryField methodsFor: 'random' stamp: 'len 5/17/2023 23:35:06'!
new: anInteger atRandom: aRandom
	| 𝔽₂ x₀ x₁ |
	𝔽₂ _ ℤ/2.
	x₀ _ 𝔽₂ new: anInteger atRandom: aRandom.
	x₁ _ 𝔽₂ new: anInteger atRandom: aRandom.
	x₁ _ x₁ ∧ x₀.
	^ TernaryArray new: anInteger words₀: x₀ words words₁: x₁ words! !

!TernaryField methodsFor: 'private' stamp: 'len 5/16/2023 21:36:38'!
isValidArray: anArray
	^ anArray class = TernaryArray! !

!TernaryField methodsFor: 'private' stamp: 'len 5/16/2023 21:51:54'!
modulus: anInteger
	self assert: anInteger = 3.
	super modulus: anInteger! !

!AffineAlgebra methodsFor: 'accessing' stamp: 'len 10/14/2023 15:11:12'!
basis
	"Answer a basis of the receiver as vector space."
	| G leadingMonomials maxExponents answer |
	self propertyAt: #basis ifPresent: [:anArray| ^ anArray].
	self isTrivial ifTrue: [^ #()].
	"For the general case use a Groebner basis."
	G := self relations gradedBasis.
	leadingMonomials := Set new.
	G do: [:each| leadingMonomials add: each leadingMonomial].
	maxExponents := (Array new: self rank) atAllPut: Infinity positive.
	leadingMonomials do: [:g| g isPurePower ifTrue: [| i | i := g lastIndeterminate. maxExponents at: (i := g lastIndeterminate) put: ((maxExponents at: i) min: (g at: i))]].
	answer := OrderedCollection new.
	self monomialsBelow: maxExponents do: [:f| (leadingMonomials anySatisfy: [:g| g | f]) ifFalse: [answer add: f]].
	^ self propertyAt: #basis put: (answer sorted collect: [:each| self !! each])! !

!AffineAlgebra methodsFor: 'accessing' stamp: 'len 10/24/2023 21:41:06'!
characteristic
	self isTrivial ifTrue: [^ 1].
	self scalars isField ifTrue: [^ self scalars characteristic].
	^ super characteristic! !

!AffineAlgebra methodsFor: 'accessing' stamp: 'len 10/26/2023 13:41:00'!
dimension
	"Answer the Krull dimension of the receiver.
	Seen as a field extension, this is its transcendence degree."
	"See [DK02, Algorithm 1.2.4 (Dimension of an ideal)]."
	self relations isZero ifTrue: [^ self cover dimension].
	self isTrivial ifTrue: [^ Infinity negative]. "i.e., the ideal is the whole polynomial ring"
	self scalars isField ifTrue: [^ self maximallyIndependentIndeterminates size].
	^ super dimension! !

!AffineAlgebra methodsFor: 'accessing' stamp: 'len 6/10/2022 11:50:00'!
indeterminates
	^ self cover indeterminates! !

!AffineAlgebra methodsFor: 'accessing' stamp: 'len 6/29/2023 19:42:15'!
maximallyIndependentIndeterminates
	"Answer a maximimally independent set of indeterminates.
	A set of indeterminats Y is called independent modulo I if the canonical map K[Y] → P/I is injective.
	The size of a maximally independent set is called the 'combinatorial dimension' of the ideal, and it is actually equal to the Krull dimension of the quotient ring P/I defined by the ideal. Seeing the quotient ring as a field extension, the Krull dimension is its transcendence degree."
	"See [DK02], Algorithm 1.2.4 (Dimension of an ideal)."
	| G leadingMonomials indeterminates |
	self relations isTrivial ifTrue: [^ #()].
"	self isTrivial ifTrue: [^ self error: 'trivial quotient']."
	G := self relations gradedBasis.
	"G _ G minimal." "is this necesary?"
	leadingMonomials := Set new.
	G do: [:each| leadingMonomials add: each leadingMonomial].
	indeterminates := self indeterminates.
	1 to: indeterminates size do: [:k|
		indeterminates combinations: k atATimeDo: [:combination|
			(leadingMonomials allSatisfy: [:monomial| combination includesAnyOf: monomial indeterminates])
				ifTrue: [^ indeterminates reject: [:any| combination includes: any]]]].
	^ indeterminates! !

!AffineAlgebra methodsFor: 'accessing' stamp: 'len 6/10/2022 11:50:25'!
monomials
	"Answer the monoid of monomials of the receiver."
	^ self cover monomials! !

!AffineAlgebra methodsFor: 'accessing' stamp: 'len 6/10/2022 11:50:27'!
ordering
	^ self cover ordering! !

!AffineAlgebra methodsFor: 'accessing' stamp: 'len 6/10/2022 11:50:30'!
rank
	"Answer the number of indeterminates in the receiver."
	^ self cover rank! !

!AffineAlgebra methodsFor: 'accessing' stamp: 'len 10/13/2023 16:02:27'!
size
	self propertyAt: #size ifPresent: [:anInteger| ^ anInteger].
	self isTrivial ifTrue: [^ 1].
	self scalars isField ifTrue:
		[^ self isZeroDimensional ifTrue: [self scalars size ^ self basis size] ifFalse: [self cover size]].
	^ super size! !

!AffineAlgebra methodsFor: 'accessing' stamp: 'len 4/5/2024 19:08:20'!
vectorSpaceDimension
	"Answer the dimension of the receiver as vector space over the coefficients field."
	self scalars isField ifFalse: [self error: 'not over a field'].
	self isZeroDimensional ifFalse: [^ Infinity positive].
	^ self hilbertSeries numerator coefficients sum! !

!AffineAlgebra methodsFor: 'converting' stamp: 'len 10/14/2023 15:27:01'!
asModule
	| answer |
	self propertyAt: #asModule ifPresent: [:aModule| ^ aModule].
	(self isUnivariate and: [self relations generators size = 1 and: [self modulus isMonic]])
		ifFalse: [^ self notYetImplemented].
	answer := self scalars ^ self modulus degree.
	self
		addCoercionTo: answer map: [:a| answer elementAt: a representative coefficients];
		addCoercionFrom: answer map: [:v| self representative: (self cover coefficients: v coefficients)].
	^ self propertyAt: #asModule put: answer! !

!AffineAlgebra methodsFor: 'converting' stamp: 'len 7/31/2019 08:21:30'!
orderedBy: aMonomialOrdering
	^ self class relations: (self relations orderedBy: aMonomialOrdering)! !

!AffineAlgebra methodsFor: 'elements' stamp: 'len 6/10/2022 11:49:23'!
adapt: anElement
	(self scalars includes: anElement)
		ifTrue: [^ self project: (self cover constant: anElement)].
	(self monomials includes: anElement)
		ifTrue: [^ self project: (self cover monomial: anElement)].
	^ super adapt: anElement! !

!AffineAlgebra methodsFor: 'elements' stamp: 'len 10/20/2016 10:50'!
x
	^ self x: 1! !

!AffineAlgebra methodsFor: 'elements' stamp: 'len 6/10/2022 11:50:34'!
x: anInteger
	^ self project: (self cover x: anInteger)! !

!AffineAlgebra methodsFor: 'elements' stamp: 'len 10/20/2016 10:50'!
y
	^ self x: 2! !

!AffineAlgebra methodsFor: 'elements' stamp: 'len 10/20/2016 10:50'!
z
	^ self x: 3! !

!AffineAlgebra methodsFor: 'morphisms' stamp: 'len 6/10/2022 11:49:42'!
embed: anElement
	"Answer the embedding of an element of the coefficients ring into the receiver."
	^ self project: (self cover embed: anElement)! !

!AffineAlgebra methodsFor: 'morphisms' stamp: 'len 6/1/2024 07:04:40'!
from: aRing
	aRing == self scalars ifTrue: [^ self addMap: ((self scalars to: self map: [:x| self embed: x]) name: 'ι')].
	aRing ⇢ self scalars ifNotNil: [:aMorphism| ^ self scalars → self · aMorphism].
	^ super from: aRing! !

!AffineAlgebra methodsFor: 'operations' stamp: 'len 10/7/2023 12:31:54'!
\ anElement
	"Answer anElement expressed as a word on the generators."
	^ anElement representative! !

!AffineAlgebra methodsFor: 'operations' stamp: 'len 10/26/2023 13:41:18'!
fractions
	"Answer the total ring of fractions of the receiver, with the receiver an affine algebra R = K[x₁,...,xₙ]/I over a field K.
	The ring of fractions is constructed as an affine algebra over the rational function field whose indeterminates correspond to maximally independent indeterminates of R."
	| K independentIndeterminates dependentIndeterminates F E images k ι |
	self propertyAt: #fractions ifPresent: [:aRing| ^ aRing].
	K := self scalars.
	K isField ifFalse:
		[K isIntegralDomain ifFalse: [^ super fractions].
		^ self propertyAt: #fractions put: (self ⊗ K fractions) fractions].
	independentIndeterminates := self maximallyIndependentIndeterminates.
	independentIndeterminates isEmpty ifTrue: [^ self propertyAt: #fractions put: self]. "is this correct? is it a field?"
	dependentIndeterminates := (1 to: self rank) reject: [:i| independentIndeterminates includes: i].
	F := (K polynomialsIn: (independentIndeterminates collect: [:i| self cover names at: i])) fractions.
	E := F polynomialsIn: (dependentIndeterminates collect: [:i| self cover names at: i]).
	images := Array new: self rank.
	k := 0.
	independentIndeterminates do: [:i| images at: i put: (E constant: (F x: (k := k + 1)))].
	k := 0.
	dependentIndeterminates do: [:i| images at: i put: (E x: (k := k + 1))].
	E addMap: (ι := self cover to: E images: images).
	^ self propertyAt: #fractions put: E / (self relations apply: ι)! !

!AffineAlgebra methodsFor: 'operations' stamp: 'len 6/2/2024 11:28:24'!
frobeniusSpace
	"If the receiver is a zero-dimensional GF(q)-algebra, answer the q-Frobenius space.
	This is a subspace of the receiver corresponding the fixed-points of the q-Frobenius endomorphism,
	namely the set {f ∈ R | f^q - f = 0}. See [ABPR19, Definition 4.12]."
	| q M |
	q := self scalars size.
	M := self asModule.
	^ (M endomorphisms map: [:v| | x | x := self !! v. M !! (x^q - x)]) kernel! !

!AffineAlgebra methodsFor: 'operations' stamp: 'len 6/10/2022 11:49:57'!
hilbertSeriesAt: t
	"Answer the Hilbert series of the receiver."
	^ (self cover hilbertSeriesAt: t) - (self relations hilbertSeriesAt: t)! !

!AffineAlgebra methodsFor: 'operations' stamp: 'len 10/26/2023 13:43:20'!
normalization
	"Answer the integral closure of the receiver in its field of fractions."
	^ self notYetImplemented
	! !

!AffineAlgebra methodsFor: 'operations' stamp: 'len 4/5/2024 19:08:30'!
proj
	"This is the Proj construction. Answer the subscheme of projective space with the receiver as its homogeneous coordinate ring."
	self relations isHomogeneous ifFalse: [^ self error: 'not a quotient by a homogeneous ideal, not properly graded'].
	^ self propertyAt: #proj ifAbsentPut: [ProjectiveVariety coordinateRing: self]! !

!AffineAlgebra methodsFor: 'operations' stamp: 'len 7/25/2022 11:32:48'!
spec
	"This is the Spec functor. Answer the spectrum of the receiver as a subscheme of affine space."
	^ self propertyAt: #spec ifAbsentPut: [AffineVariety coordinateRing: self]! !

!AffineAlgebra methodsFor: 'operations' stamp: 'len 8/19/2024 09:41:08'!
⊗ aRing
	"Answer the tensor product of the receiver with the argument.
	This is the coproduct in the category of commutative R-algebras."
	| R relators answer ι₁ ι₂ |
	aRing isAffineAlgebra ifFalse:
		[self scalars ⇢ aRing ifNotNil: [^ self over: aRing].
		^ super ⊗ aRing].
	aRing scalars = self scalars ifFalse:
		[self scalars ⇢ aRing scalars ifNotNil: [^ (self over: aRing scalars) ⊗ aRing].
		aRing scalars ⇢ self scalars ifNotNil: [^ self ⊗ (aRing over: self scalars)].
		^ super ⊗ aRing].
	relators := OrderedCollection new.
	R := self freeCover ⊗ aRing freeCover.
	self relators do: [:f| relators add: R !! f].
	aRing relators do: [:g| relators add: (R !! g substitute: [:i| i + self rank])].
	answer := R / relators.
	ι₁ := self into: answer images: (answer generators first: self rank).
	ι₂ := aRing into: answer images: (answer generators last: aRing rank).
	answer addCoprojections: {ι₁. ι₂}.
	answer addCoercionFrom: self underlyingSet × aRing underlyingSet mapWithArguments: [:f :g| (ι₁ value: f) * (ι₂ value: g)].
	^ answer! !

!AffineAlgebra methodsFor: 'printing' stamp: 'len 5/31/2023 09:18:14'!
printOn: aStream
	super printOn: aStream
"	(self isUnivariate and: [self generators size = 1])
		ifTrue: [aStream print: self scalars; nextPut: $(; print: self modulus; nextPut: $)]
		ifFalse: [super printOn: aStream]"! !

!AffineAlgebra methodsFor: 'testing' stamp: 'len 10/13/2022 10:24:33'!
isAffineAlgebra
	^ true! !

!AffineAlgebra methodsFor: 'testing' stamp: 'len 10/10/2023 21:49:22'!
isArtinian
	"A ring is called Artinian if it satisfies the descending chain condition on ideals.
	Given an affine K-algebra A, the following are equivalent:
	- the Krull dimension of A is 0;
	- A is algebraic over K;
	- dimension of A as a K-vector space is finite;
	- A is Artinian."
	self scalars isField ifTrue: [^ self isZeroDimensional].
	^ super isArtinian! !

!AffineAlgebra methodsFor: 'testing' stamp: 'len 10/10/2023 21:54:25'!
isFiniteAlgebra
	"Answer true if the receiver is a finite algebra (i.e., the underlying module is finitely generated).
	For an affine algebra over a field, being zero-dimensional (Krull dimension 0) means that it has nonzero finite dimension as vector space over the coefficients field."
	^ self scalars isField and: [self isZeroDimensional]! !

!AffineAlgebra methodsFor: 'testing' stamp: 'len 8/21/2024 14:54:37'!
isFinitelyGeneratedAlgebra
	^ true! !

!AffineAlgebra methodsFor: 'private' stamp: 'len 7/19/2021 20:21:38'!
monomialsBelow: exponents do: aBlock
	exponents isEmpty ifTrue: [^ aBlock value: self monomials identity].
	self monomialsBelow: exponents allButLast do: [:each|
		0 to: exponents last - 1 do: [:i| aBlock value: each*(self monomials x: exponents size to: i)]]! !

!ExtensionRing methodsFor: 'accessing' stamp: 'len 5/12/2023 22:40:20'!
basis
	"Answer a basis of the receiver as vector space."
	"If the receiver is a simple algebraic field extension, answer the power basis of the receiver.
	The coordinates of an element correspond to coefficients of the polynomial representing the element."
	^ self propertyAt: #basis ifAbsentPut: [(0 to: self degree - 1) collect: [:k| self x ^ k]]! !

!ExtensionRing methodsFor: 'accessing' stamp: 'len 10/25/2023 07:59:04'!
characteristic
	self isTrivial ifTrue: [^ 1].
	^ self scalars characteristic! !

!ExtensionRing methodsFor: 'accessing' stamp: 'len 6/3/2023 19:36:37'!
degree
	"If the receiver is a field extension, answer the degree [E:F] of the relative extension E/F."
	^ self modulus degree! !

!ExtensionRing methodsFor: 'accessing' stamp: 'len 6/21/2023 15:19:12'!
degreeOver: aSubfield
	"Answer the degree [E:F] of the relative extension E/F."
	self = aSubfield ifTrue: [^ 1].
	self scalars = aSubfield ifTrue: [^ self degree].
	self flag: #fixme. "this is wrong:"
	^ self degree * (self scalars degreeOver: aSubfield)! !

!ExtensionRing methodsFor: 'accessing' stamp: 'len 11/15/2023 14:59:59'!
galoisClosure
	"The Galois closure of a finite simple extension E(α) is the splitting field of the minimal polynomial of α over E."
	^ self modulus splittingField! !

!ExtensionRing methodsFor: 'accessing' stamp: 'len 11/17/2023 10:53:09'!
modulus
	^ modulus! !

!ExtensionRing methodsFor: 'accessing' stamp: 'len 10/9/2023 09:41:37'!
size
	^ self scalars size ^ self modulus degree! !

!ExtensionRing methodsFor: 'comparing' stamp: 'len 11/18/2023 12:59:01'!
~ aRing
	((aRing isKindOf: ExtensionRing) and: [self scalars = aRing scalars and: [self degree = aRing degree]]) ifFalse: [^ super ~ aRing].
	self modulus rootsIn: aRing do: [:each| ^ true].
	^ false! !

!ExtensionRing methodsFor: 'computing-polynomials' stamp: 'len 6/25/2023 09:48:35'!
polynomial: aPolynomial factorizationDo: aBlock
	self isGlobalField ifTrue: [^ (self factorizationOverGlobalFieldOf: aPolynomial) withOccurrencesDo: aBlock].
	^ super polynomial: aPolynomial factorizationDo: aBlock! !

!ExtensionRing methodsFor: 'computing-polynomials-private' stamp: 'len 7/12/2024 09:10:34'!
factorizationOverGlobalFieldOf: aPolynomial
	"See [Coh96, Algorithm 3.6.4 (Polynomial Factorization over Number Fields)]."
	| u v S x y g k N answer |
	"1. Reduce to squarefree:"
	u := aPolynomial / (v := aPolynomial gcd: aPolynomial derivative).
	"2. Initialize search:"
	S := self scalars polynomialsIn: 2. x := S x. y := S y.
	g := S zero.
	u coefficients withIndexDo: [:each :i| g := (each representative value: y) * (x^(i-1)) + g].
	"3. Search for squarefree norm polynomial:"
	k := 0.
	[N := ((self modulus value: y) asUnivariateIn: 2) resultant: ((g value: {x - (y*k). y}) asUnivariateIn: 2).
	N isSquarefree] whileFalse: [k := k + 1].
	"4 and 5. Factor norm polynomial and find factors over the number field:"
	answer := Bag new.
	N factorization withOccurrencesDo: [:f :e|
		answer add: (u gcd: (f value: (u parent x + (self x * k)))) withOccurrences: e].
	"Count multiplicities in the original polynomial (that was not necessarily squarefree):"
	v order > 0 ifTrue: [answer add: v parent x withOccurrences: v order. v := v >> v order].
	[v isConstant] whileFalse: [v := v / (answer add: (answer detect: [:one| one | v]))].
	^ answer! !

!ExtensionRing methodsFor: 'converting' stamp: 'len 11/6/2023 09:54:07'!
asAbsolute
	self isAbsolute ifTrue: [^ self].
	self notYetImplemented! !

!ExtensionRing methodsFor: 'converting' stamp: 'len 10/14/2023 15:27:12'!
asModule
	| answer |
	self propertyAt: #asModule ifPresent: [:aModule| ^ aModule].
	answer := self scalars ^ self degree.
	self
		addCoercionTo: answer map: [:a| answer coefficients: a coefficients];
		addCoercionFrom: answer map: [:v| self coefficients: v coefficients].
	^ self propertyAt: #asModule put: answer! !

!ExtensionRing methodsFor: 'elements' stamp: 'len 5/27/2023 08:02:19'!
coefficients: anArray
	^ self representative: (self cover coefficients: anArray)! !

!ExtensionRing methodsFor: 'elements' stamp: 'len 5/27/2023 08:01:49'!
new: anInteger
	^ ExtensionPackedArray coefficients: (self scalars new: anInteger * self degree) scalars: self! !

!ExtensionRing methodsFor: 'elements' stamp: 'len 6/11/2023 10:36:05'!
newFrom: anObject
	anObject isSequenceable ifTrue: [^ self project: self cover !! anObject].
	^ super newFrom: anObject! !

!ExtensionRing methodsFor: 'elements' stamp: 'len 5/27/2023 08:01:59'!
zeros: anInteger
	^ ExtensionPackedArray coefficients: (self scalars zeros: anInteger * self degree) scalars: self! !

!ExtensionRing methodsFor: 'enumerating' stamp: 'len 9/6/2023 16:56:26'!
do: aBlock
	^ self asModule do: [:each| aBlock value: self !! each]! !

!ExtensionRing methodsFor: 'morphisms' stamp: 'len 5/12/2023 22:42:35'!
embeddings
	"Answer the n distinct embeddings of the receiver in the algebraic closure of the base field, where n is the degree of the receiver. In the case of number fields, the embeddings go to the complex algebraic numbers.
	When the receiver is a Galois extension, the embeddings send each element to one of its conjugates, and their images are the same."
	^ self propertyAt: #embeddings ifAbsentPut:
		[self embeddingsIn: self scalars algebraicClosure]! !

!ExtensionRing methodsFor: 'morphisms' stamp: 'len 5/12/2023 22:42:12'!
embeddingsIn: aField
	^ (self modulus rootsIn: aField) asArray
		collect: [:x| self to: aField map: [:alpha| alpha representative value: x]]! !

!ExtensionRing methodsFor: 'morphisms' stamp: 'len 10/31/2023 09:55:36'!
project: anElement
	^ self representative: anElement \\ self modulus! !

!ExtensionRing methodsFor: 'printing' stamp: 'len 11/14/2023 14:20:04'!
indeterminateName
	| i E |
	self isAbsolute ifTrue: [^ 'α'].
	i := 2.
	E := self scalars.
	[E isAbsolute] whileFalse: [i := i + 1. E := E scalars].
	^ 'α', i printString sub! !

!ExtensionRing methodsFor: 'printing' stamp: 'len 11/14/2023 13:35:32'!
printRepresentative: aPolynomial on: aStream
	aStream print: (self scalars polynomialsIn: {self indeterminateName} ordering: #lgrevlex) !! aPolynomial! !

!ExtensionRing methodsFor: 'random' stamp: 'len 9/8/2023 17:51:44'!
atRandom: aRandom
	^ self coefficients: (self scalars new: self degree atRandom: aRandom)! !

!ExtensionRing methodsFor: 'random' stamp: 'len 9/8/2023 17:52:06'!
atRandom: aRandom bits: bitSize
	^ self coefficients: (self scalars new: self degree atRandom: aRandom bits: bitSize)! !

!ExtensionRing methodsFor: 'testing' stamp: 'len 11/22/2023 20:30:55'!
isAbelianExtension
	"An abelian extension is a Galois extension with abelian Galois group."
	^ self isGaloisExtension and: [self automorphisms isCommutative]! !

!ExtensionRing methodsFor: 'testing' stamp: 'len 11/14/2023 14:13:07'!
isAbsolute
	^ self isRelative not! !

!ExtensionRing methodsFor: 'testing' stamp: 'len 11/22/2023 20:30:37'!
isCyclicExtension
	"A cyclic extension is a Galois extension with cyclic Galois group."
	^ self isGaloisExtension and: [self automorphisms isCyclic]! !

!ExtensionRing methodsFor: 'testing' stamp: 'len 10/27/2023 10:38:37'!
isField
	^ self scalars isField or: [super isField] "assuming the modulus is irreducible"! !

!ExtensionRing methodsFor: 'testing' stamp: 'len 9/8/2023 17:42:07'!
isFiniteAlgebra
	^ true! !

!ExtensionRing methodsFor: 'testing' stamp: 'len 11/22/2023 20:30:12'!
isGaloisExtension
	"A Galois extension is an algebraic field extension E/F that is normal and separable, or equivalently E/F is algebraic and the field fixed by the automorphism group Aut(E/F) is the base field F. The significance of being a Galois extension is that it has a Galois group and obeys the fundamental theorem of Galois theory."
	^ false "undefined"! !

!ExtensionRing methodsFor: 'testing' stamp: 'len 11/6/2023 09:57:42'!
isGlobalField
	^ self scalars isGlobalField! !

!ExtensionRing methodsFor: 'testing' stamp: 'len 11/14/2023 14:12:38'!
isRelative
	^ self scalars isKindOf: ExtensionRing! !

!ExtensionRing methodsFor: 'testing' stamp: 'len 10/27/2023 10:38:54'!
isSimple
	^ self scalars isField or: [super isSimple] "assuming the modulus is irreducible"! !

!ExtensionRing methodsFor: 'private' stamp: 'len 5/27/2023 08:01:10'!
isValidArray: anArray
	^ anArray class = ExtensionPackedArray and: [anArray scalars = self]! !

!ExtensionRing methodsFor: 'private' stamp: 'len 11/17/2023 10:45:50'!
modulus: aPolynomial
	self assert: aPolynomial isMonic.
	modulus := aPolynomial! !

!ExtensionRing methodsFor: 'private' stamp: 'len 6/10/2023 18:30:19'!
powersTable
	"Answer a table with the coefficients for x^n to: x^(2n-2), where n is the degree of the receiver.
	This table is used for reducing the product of two elements."
	^ self propertyAt: #powersTable ifAbsentPut:
		[| n table tmp |
		n := self degree.
		table := self scalars new: n * (n - 1).
		n + 1 to: n * 2 - 1 do: [:i|
			tmp := self scalars zeros: i.
			tmp at: i put: self scalars one. "x^(i-1)"
			tmp reduceBy: self modulus coefficients.
			table replaceFrom: i - n - 1 * n + 1 to: i - n * n with: tmp startingAt: 1].
		table]! !

!ExtensionRing methodsFor: 'private' stamp: 'len 11/17/2023 10:47:05'!
relations
	^ self propertyAt: #relations ifAbsentPut: [modulus parent * modulus]! !

!ExtensionRing methodsFor: 'private' stamp: 'len 11/17/2023 10:46:39'!
relations: anIdeal
	super relations: anIdeal.
	self modulus: anIdeal generator! !

!GaloisRing methodsFor: 'accessing' stamp: 'len 9/8/2023 17:07:46'!
base
	^ self scalars base! !

!GaloisRing methodsFor: 'accessing' stamp: 'len 5/9/2019 09:25:41'!
exponent
	^ self scalars exponent! !

!GaloisRing methodsFor: 'accessing' stamp: 'len 9/8/2023 17:10:05'!
maximalIdeal
	^ self * self base! !

!GaloisRing methodsFor: 'accessing' stamp: 'len 4/3/2024 09:00:55'!
primitiveElement
	"Answer a basic primitive element of the receiver.
	For GR(p^n,r), a 'basic primitive element' is an element of multiplicative order p^r - 1,
	which is a root of a basic primitive polynomial of degree r over ℤ/(p^n)ℤ dividing x^(p^r - 1) - 1.
	Powers of this element form a Tëichmuller set.
	For a Galois field GF(q) with q = p^r, this is a primitive (q-1)-th root of unity and generates the group of units."
	| e m |
	self propertyAt: #primitiveElement ifPresent: [:anElement| ^ anElement].
	e := self base ^ self degree - 1.
	e | (m := self x multiplicativeOrder) ifTrue: [^ self propertyAt: #primitiveElement put: self x ^ (m // e)].
	^ self propertyAt: #primitiveElement put: (self units elements detect: [:one| one multiplicativeOrder = e])! !

!GaloisRing methodsFor: 'accessing' stamp: 'len 10/5/2022 18:34:07'!
residueField
	"Answer the Galois field GF(p,r) isomorphic to the residue field of the receiver, equipped with the canonical projection."
	^ self propertyAt: #residueField ifAbsentPut:
		[GaloisField modulus: (self modulus apply: self scalars → self scalars residueField)]! !

!GaloisRing methodsFor: 'accessing' stamp: 'len 10/26/2023 11:25:59'!
teichmullerSet
	"Answer a Tëichmuller set of the receiver.
	Any element of GR(p^n,r) can be written uniquely as a polynomial in p with coefficients in the Tëichmuller set, and this is called the 'multiplicative representation' or 'p-adic representation' (or 'p-adic expansion')."
	| T ξ |
	self propertyAt: #teichmullerSet ifPresent: [:anArray| ^ anArray].
	T := OrderedCollection new: self characteristic.
	T add: self zero; add: self one.
	ξ := self primitiveElement.
	self characteristic - 2 timesRepeat: [T add: T last * ξ].
	^ self propertyAt: #teichmullerSet put: T asArray! !

!GaloisRing methodsFor: 'accessing' stamp: 'len 9/8/2023 17:10:47'!
unitsSize
	"The group of units of GR(p^n,r) is the direct product G₁ × G₂, with G₁ the group of (p^r - 1)-th roots of unity, and G₂ a cyclic group of order p^r - 1."
	| p n r |
	p := self base.
	n := self exponent.
	r := self degree.
	^ p ^ r - 1 * (p ^ (n - 1 * r))! !

!GaloisRing methodsFor: 'enumerating' stamp: 'len 9/8/2023 17:09:50'!
idealsDo: aBlock
	"The ideals of GR(p^n,m) are {0} and <p^i> for 0 <= i < n-1."
	| a |
	aBlock value: self * 0.
	a := self one.
	self exponent timesRepeat:
		[aBlock value: self * a.
		a := a * self base]! !

!GaloisRing methodsFor: 'morphisms' stamp: 'len 12/4/2023 11:43:59'!
automorphismGroup
	"Answer the group of automorphisms as an abstract group."
	^ self propertyAt: #automorphismGroup ifAbsentPut: [(ℤ/self degree) asAbelianGroup]! !

!GaloisRing methodsFor: 'morphisms' stamp: 'len 12/1/2023 14:15:34'!
automorphisms
	"Answer the Galois group of the receiver over  ℤ/pⁿℤ, i.e. the group of ℤ/pⁿℤ-algebra automorphisms.
	This is the cyclic group generated by the generalized Frobenius automorphism."
	^ self propertyAt: #automorphisms ifAbsentPut: [(AutomorphismGroup on: self) generators: {self generalizedFrobenius}]! !

!GaloisRing methodsFor: 'morphisms' stamp: 'len 8/19/2024 18:18:45'!
generalizedFrobenius
	"Answer the generalized Frobenius automorphism.
	For Galois fields, this is just the classic Frobenius automorphism."
	^ self to: self over: self scalars map: [:x| x generalizedFrobenius]! !

!GaloisRing methodsFor: 'morphisms' stamp: 'len 10/28/2023 12:14:13'!
generalizedTrace
	"Answer the generalized trace homomorphism.
	For Galois fields this is just the classic trace homomorphism."
	self flag: #fixme. "should be an algebra map"
	^ self to: self scalars map: [:x| x generalizedTrace]! !

!GaloisRing methodsFor: 'morphisms' stamp: 'len 6/1/2024 07:04:50'!
to: aRing
	(super to: aRing) ifNotNil: [:aMorphism| ^ aMorphism].
	((aRing isKindOf: GaloisRing) and: [self base = aRing base]) ifFalse: [^ nil].
	"There's a projection from GR(p^n,r) to GR(p^m,r) for all m<=n, with kernel <p^m>. This accounts for all ideals.
	Note: Here we assume both Galois rings are defined with the same basic irreducible polynomial."
	self degree = aRing degree
		ifTrue: [^ self scalars ⇢ aRing scalars ifNotNil: [:aMorphism| self onto: aRing map: [:x| aRing project: (x representative apply: aMorphism)]]].
	"The subrings of GR(p^n,r) are GR(p^n,k) where k divides r. If aCodomain is a suitable overring, answer an embedding of the receiver into the overring."
	(self characteristic = aRing characteristic and: [self degree | aRing degree])
		ifTrue: [^ self addEmbeddingInto: aRing].
	^ nil! !

!GaloisRing methodsFor: 'operations' stamp: 'len 11/26/2023 10:48:56'!
extensionDegree: anInteger
	"Answer a Galois extension of the given degree.
	This is currently constructed as an absolute extension."
	anInteger = 1 ifTrue: [^ self].
	^ self scalars extensionDegree: anInteger * self degree! !

!GaloisRing methodsFor: 'operations' stamp: 'len 5/21/2018 15:42:01'!
nilradical
	"Answer the ideal consisting of all nilpotent elements, i.e. all x such that there exists some n with x^n = 0. It is the intersection of all prime ideals.
	A finite ring is a Galois ring iff its nilradical is of the form <p> for some prime p. This is also the unique maximal ideal."
	^ self maximalIdeal! !

!GaloisRing methodsFor: 'operations' stamp: 'len 5/7/2022 07:33:53'!
zeroDivisors
	^ self maximalIdeal! !

!GaloisRing methodsFor: 'operations' stamp: 'len 11/22/2023 10:45:31'!
∧ aGaloisRing
	"Answer the intersection or meet of the receiver and the argument in the lattice of Galois rings of a given characteristic p^n, i.e. the maximal subring of both the receiver and the argument."
	| n |
	(self = aGaloisRing or: [self scalars = aGaloisRing]) ifTrue: [^ aGaloisRing].
	self assert: self scalars = aGaloisRing scalars.
	n := self degree gcd: aGaloisRing degree.
	n = self degree ifTrue: [^ self].
	n = aGaloisRing degree ifTrue: [^ aGaloisRing].
	^ self class new: self base to: self exponent to: n! !

!GaloisRing methodsFor: 'operations' stamp: 'len 11/22/2023 10:45:44'!
∨ aGaloisRing
	"Answer the join of the receiver and the argument in the lattice of Galois rings of a given characteristic p^n, i.e. the minimal Galois ring that includes both the receiver and the argument as subrings."
	| n |
	(self = aGaloisRing or: [self scalars = aGaloisRing]) ifTrue: [^ self].
	self assert: self scalars = aGaloisRing scalars.
	n := self degree lcm: aGaloisRing degree.
	n = self degree ifTrue: [^ self].
	n = aGaloisRing degree ifTrue: [^ aGaloisRing].
	^ self class new: self base to: self exponent to: n! !

!GaloisRing methodsFor: 'printing' stamp: 'len 11/14/2023 13:40:12'!
indeterminateName
	^ 'ξ'! !

!GaloisRing methodsFor: 'printing' stamp: 'len 9/8/2023 17:10:19'!
printOn: aStream
	aStream nextPutAll: 'GR('; print: self scalars base; nextPutAll: self scalars exponent printString super; nextPut: $,; print: self degree; nextPut: $)! !

!GaloisRing methodsFor: 'testing' stamp: 'len 6/3/2022 06:06:27'!
hasCanonicalAssociates
	^ true! !

!GaloisRing methodsFor: 'testing' stamp: 'len 11/22/2023 20:11:16'!
isAbelianExtension
	^ true! !

!GaloisRing methodsFor: 'testing' stamp: 'len 12/21/2022 13:27:47'!
isBezout
	"Answer true if the receiver is a Bézout ring, i.e. every finitely generated ideal is principal."
	"All nonzero ideals are of the form <p^i>."
	^ true! !

!GaloisRing methodsFor: 'testing' stamp: 'len 9/16/2018 23:15:40'!
isChainRing
	"A chain ring is a ring whose ideals form a chain under inclusion.
	Galois rings are chain rings."
	^ true! !

!GaloisRing methodsFor: 'testing' stamp: 'len 11/22/2023 20:09:08'!
isCyclicExtension
	^ true! !

!GaloisRing methodsFor: 'testing' stamp: 'len 6/3/2022 07:05:55'!
isEuclidean
	"Answer true if the receiver is a Euclidean ring, i.e. it has Euclidean division with remainder.
	Galois rings are Euclidean."
	^ true! !

!GaloisRing methodsFor: 'testing' stamp: 'len 3/25/2021 15:04:26'!
isField
	^ self exponent = 1! !

!GaloisRing methodsFor: 'testing' stamp: 'len 5/21/2018 05:07:00'!
isFinite
	^ true! !

!GaloisRing methodsFor: 'testing' stamp: 'len 5/21/2018 05:06:26'!
isGaloisExtension
	^ true! !

!GaloisRing methodsFor: 'testing' stamp: 'len 9/22/2018 18:54:20'!
isGaloisRing
	^ true! !

!GaloisRing methodsFor: 'testing' stamp: 'len 7/16/2021 10:08:25'!
isIntegralDomain
	^ self isField! !

!GaloisRing methodsFor: 'testing' stamp: 'len 5/21/2018 16:54:03'!
isLocal
	^ true! !

!GaloisRing methodsFor: 'private' stamp: 'len 5/9/2022 11:06:27'!
elementClass
	^ GaloisRingElement! !

!GaloisRing methodsFor: 'private' stamp: 'len 9/8/2023 17:10:00'!
inversionExponent
	"If an element u is a unit of GR(p^m,r), and N = (p^r - 1)*(p^(m-1)), then u^N = 1.
	This means that the inverse of u can be computed as u^(N-1). See [EIP00]."
	^ self propertyAt: #inversionExponent ifAbsentPut: [self base ^ self degree - 1 * (self base ^ (self exponent - 1)) - 1]! !

!GaloisRing methodsFor: 'private-embeddings' stamp: 'len 5/1/2024 12:25:14'!
addEmbeddingInto: aGaloisRing
	"Assuming the receiver and the argument have the same characteristic and the degree of the receiver divides the degree of the argument, create and add an embedding of the receiver into the argument compatible with all the other existing embeddings."
	| α answer |
	self flag: #fixme. "make it compatible"
	α := (self modulus apply: self scalars → aGaloisRing) roots any.
	answer := self to: aGaloisRing images: {α}.
	self addMap: answer.
	aGaloisRing addMap: answer.
	^ answer! !

!GaloisRing class methodsFor: 'instance creation' stamp: 'len 11/26/2023 10:52:06'!
new: q to: m
	"Answer the Galois ring of characteristic q (a power of a prime) and order q^m."
	^ (PrimePowerRing new: q) extensionDegree: m! !

!GaloisRing class methodsFor: 'instance creation' stamp: 'len 11/26/2023 10:50:42'!
new: p to: n to: m
	"Answer the Galois ring of characteristic p^n and order p^(n*m)."
	^ (PrimePowerRing new: p to: n) extensionDegree: m! !

!GaloisField methodsFor: 'accessing' stamp: 'len 11/7/2023 11:07:55'!
normalElement
	"If the receiver is GF(q^n) over GF(q), an element α such that α, α^q, ..., α^(q^(n-1)) is a basis."
	| answer |
	[(answer := self atRandom) isNormal] whileFalse.
	^ answer! !

!GaloisField methodsFor: 'accessing' stamp: 'len 7/17/2023 18:52:02'!
primitiveElement
	"Answer primitive element of the receiver. For a Galois field GF(q) with q = p^r, this is a primitive (q-1)-th root of unity and generates the group of units."
	^ super primitiveElement

"The following turns out to be slower that the implementation in the superclass:
	| n α answer |
	self propertyAt: #primitiveElement ifPresent: [:anElement| ^ anElement].	
	n := self units size.
	self x multiplicativeOrder = n ifTrue: [^ self propertyAt: #primitiveElement put: self x].
	answer := self one.
	self units sizeFactorization withOccurrencesDo: [:pᵢ :dᵢ|
		[α := self units atRandom. (α ^ (n / pᵢ)) isOne] whileFalse.
		answer := answer * (α ^ (n / (pᵢ ^ dᵢ)))].
	^ self propertyAt: #primitiveElement put: answer"! !

!GaloisField methodsFor: 'accessing' stamp: 'len 6/5/2023 19:45:16'!
primitiveRoot
	^ self primitiveElement! !

!GaloisField methodsFor: 'accessing' stamp: 'len 5/9/2022 11:18:24'!
residueField
	"Answer the Galois field GF(p,r) isomorphic to the residue field of the receiver, equipped with the canonical projection."
	^ self! !

!GaloisField methodsFor: 'accessing' stamp: 'len 5/23/2020 09:13:12'!
universalPolynomial
	"Answer the universal polynomial of which all elements of the receiver are roots."
	^ ℤ polynomials !! [:x| x^self size - x]! !

!GaloisField methodsFor: 'comparing' stamp: 'len 9/22/2018 18:53:34'!
~ aRing
	"Any two finite fields of the same cardinality are isomorphic."
	^ aRing isField and: [self size = aRing size]! !

!GaloisField methodsFor: 'computing-matrices' stamp: 'len 6/1/2022 20:28:56'!
matrix: B quotientBy: A
	"Answer X such that AX + N = B, satisfying that if the i-th column of B is a linear combination of the columns of A then the i-th column of N is zero."
	^ self matrixOverField: B quotientBy: A! !

!GaloisField methodsFor: 'computing-matrices' stamp: 'len 12/31/2021 08:18:56'!
syzygiesOf: aMatrix
	"Answer a matrix whose rows span the kernel of the given matrix.
	For a matrix A, the output is X with AX = 0."
	^ self syzygiesOverEuclideanDomainOf: aMatrix! !

!GaloisField methodsFor: 'elements' stamp: 'len 6/11/2023 21:34:38'!
new: anInteger
"	self size <= self zechMaximumOrder ifTrue: [^ self zechTable new: anInteger]."
	(self characteristic = 2 and: [self degree < 8]) ifTrue: [^ BinaryExtensionArray slices: ((1 to: self degree) collect: [:i| self scalars new: anInteger]) scalars: self].
	^ super new: anInteger! !

!GaloisField methodsFor: 'elements' stamp: 'len 6/11/2023 21:34:17'!
zeros: anInteger
"	self size <= self zechMaximumOrder ifTrue: [^ self zechTable new: anInteger]."
	(self characteristic = 2 and: [self degree < 8]) ifTrue: [^ BinaryExtensionArray slices: ((1 to: self degree) collect: [:i| self scalars zeros: anInteger]) scalars: self].
	^ super zeros: anInteger! !

!GaloisField methodsFor: 'morphisms' stamp: 'len 12/1/2023 14:15:42'!
automorphisms
	"Answer the Galois group of the receiver over 𝔽ₚ, i.e. the group of 𝔽ₚ-algebra automorphisms.
	This is the cyclic group generated by the Frobenius automorphism."
	^ self propertyAt: #automorphisms ifAbsentPut: [(AutomorphismGroup on: self) generators: {self frobenius}]! !

!GaloisField methodsFor: 'morphisms' stamp: 'len 8/19/2024 18:19:09'!
frobenius
	"Answer the Frobenius automorphism."
	^ self propertyAt: #frobenius ifAbsentPut: [self to: self over: self scalars map: [:x| x frobenius]]! !

!GaloisField methodsFor: 'operations' stamp: 'len 11/21/2023 15:45:57'!
algebraicClosure
	^ self scalars algebraicClosure! !

!GaloisField methodsFor: 'printing' stamp: 'len 5/6/2023 15:24:37'!
printOn: aStream
	aStream nextPut: $𝔽; nextPutAll: (self characteristic printString, self degree printStringSuperscript) sub
"	aStream nextPutAll: 'GF('; print: self characteristic; nextPutAll: self degree printString super; nextPut: $)"! !

!GaloisField methodsFor: 'testing' stamp: 'len 6/9/2019 09:35:56'!
isField
	^ true! !

!GaloisField methodsFor: 'testing' stamp: 'len 7/15/2021 16:07:16'!
isFiniteField
	^ true! !

!GaloisField methodsFor: 'private' stamp: 'len 5/9/2022 11:07:10'!
elementClass
	^ GaloisFieldElement! !

!GaloisField methodsFor: 'private' stamp: 'len 6/11/2023 21:31:31'!
isValidArray: anArray
"	self size <= self zechMaximumOrder ifTrue: [^ anArray class = ZechArray and: [anArray scalars = self]]."
	(self characteristic = 2 and: [self degree < 8]) ifTrue: [^ anArray class = BinaryExtensionArray and: [anArray scalars = self]].
	^ super isValidArray: anArray! !

!GaloisField methodsFor: 'private' stamp: 'len 6/12/2023 12:33:38'!
karatsubaFormula
	"See [Mon05] and https://github.com/malb/m4rie/src/karatsuba.c."
	| unreducedFormula powers |
	self propertyAt: #karatsubaFormula ifPresent: [:anArray| ^ anArray].
	self characteristic = 2 ifFalse: [^ self notYetImplemented].
	unreducedFormula := #(
		(((1 2) (2)) ((1) (1 2)) ((2) (2 3)))
		(((1 2) (2)) ((1 3) (3)) ((2 3) (4)) ((1) (1 2 3)) ((2) (2 3 4)) ((3) (3 4 5)))
		(((1 2 3 4) (4)) ((1 2) (2 4)) ((1 3) (3 4)) ((2 4) (4 5)) ((3 4) (4 6)) ((1) (1 2 3 4)) ((2) (2 3 4 5)) ((3) (3 4 5 6)) ((4) (4 5 6 7)))
		(((1) (1 2 3 5 6 7)) ((2) (2 5)) ((4) (5 8)) ((5) (3 4 5 7 8 9)) ((1 5) (3 4 6 7)) ((1 2) (2 3 5 6)) ((4 5) (4 5 7 8)) ((2 3 5) (3 5)) ((1 3 4) (5 7)) ((1 2 4 5) (4 6)) ((1 2 3 5) (3 6)) ((1 3 4 5) (4 7)) ((1 2 3 4 5) (4 5 6)))
		(((1) (1 2 6 7)) ((2) (2 4 5 6 7 8)) ((5) (4 6 8 10)) ((6) (6 7 10 11)) ((5 6) (4 5 9 10)) ((1 2) (2 3 5 8)) ((4 5) (4 7 8 9)) ((2 3) (3 4 7 8)) ((2 5) (5 6)) ((3 4) (4 5 7 8)) ((4 5 6) (4 5 7 9)) ((1 2 3) (3 8)) ((1 4 6) (6 8)) ((1 3 6) (4 5 6 7)) ((1 3 4 6) (4 5 6 8)) ((1 2 4 5) (5 7)) ((1 2 3 4 5 6) (7)))
		(((1 2 3 4 5 6 7) (6 7 8)) ((2 3 4 6 7) (7 10)) ((1 2 4 5 6) (4 7)) ((1 3 4 5 7) (4 10)) ((1 3 4 6 7) (4 8)) ((1 2 4 5 7) (6 10)) ((2 3 5 6) (4 6 8 10)) ((1 2) (2 4 8 10)) ((1 3) (3 6 7 10)) ((1 5) (5 8)) ((2 4) (4 5 7 8)) ((3 7) (6 9)) ((4 6) (6 7 9 10)) ((5 7) (4 7 8 11)) ((6 7) (4 6 10 12)) ((1) (1 2 3 5 6 7)) ((2) (2 3 5 6)) ((3) (3 4 5 7 8 9)) ((4) (5 6 8 9)) ((5) (5 6 7 9 10 11)) ((6) (8 9 11 12)) ((7) (7 8 9 11 12 13)))
		) at: self degree - 1.
	powers := (0 to: self degree * 2 - 2) collect: [:i| (self project: self cover x^i) coefficients support asArray].
	^ self propertyAt: #karatsubaFormula put:
		(unreducedFormula collect: [:each|
			| reduction |
			reduction := Bag new.
			each second do: [:i| reduction addAll: (powers at: i)].
			{each first. (reduction asSet select: [:i| (reduction occurrencesOf: i) odd]) asArray sort}])! !

!GaloisField methodsFor: 'private-embeddings' stamp: 'len 5/31/2024 15:01:10'!
addEmbeddingInto: aGaloisField
	"Create and add an embedding of the receiver into the argument compatible with all the other existing embeddings.
	Assume the receiver and the argument have the same characteristic and the degree of the receiver divides the degree of the argument.
	See [BCS97]."
	| μ f g α answer |
	"If the fields are isomorphic, first check if the embedding in the other direction exists, and if it does just compute the inverse:"
	self degree = aGaloisField degree ifTrue:
		[(aGaloisField embeddingInto: self) ifNotNil: [:aMorphism| ^ self addMap: aMorphism inverse]].
	"Compute a compatible embedding:"
	μ := aGaloisField polynomials zero.
	self subfields keysDo: [:d|
		(aGaloisField subfields includesKey: d) ifTrue:
			[f := (self subfields at: d) first.
			g := (aGaloisField subfields at: d) first.
			μ := μ gcd: ((self x minimalPolynomialAlong: f) apply: g)]].
	"If there's no common subfield, there's no compatibility condition to fulfill:"
	μ isZero ifTrue: [μ := self modulus apply: self scalars → aGaloisField].
	α := μ roots any.
	answer := self to: aGaloisField images: {α}.
	self addOverfield: answer.
	aGaloisField addSubfield: answer.
	"Add all the embeddings induced by the new embedding:"
	self addTransitiveClosure: answer.
	^ answer! !

!GaloisField methodsFor: 'private-embeddings' stamp: 'len 11/3/2023 14:04:02'!
addOverfield: aMorphism
	^ self addMap: aMorphism! !

!GaloisField methodsFor: 'private-embeddings' stamp: 'len 10/29/2023 21:22:36'!
addSubfield: aMorphism
	(self subfields at: aMorphism domain degree ifAbsentPut: [OrderedCollection new: 1]) add: aMorphism.
	^ self addMap: aMorphism! !

!GaloisField methodsFor: 'private-embeddings' stamp: 'len 11/6/2023 10:56:09'!
addTransitiveClosure: aMorphism
	"After addinng a new embedding, add all the induced embeddings.
	See [BCS97]."
	self assert: aMorphism domain == self.
	self subfields keysDo: [:d|
		| alreadyPresent φ |
		alreadyPresent := aMorphism codomain subfields at: d ifPresent: [:aCollection| aCollection collect: [:each| each domain]] ifAbsent: [#()].
		(self subfields at: d) do: [:g|
			(alreadyPresent includes: g domain) ifFalse:
				[φ := aMorphism · g.
				aMorphism codomain addSubfield: φ.
				g domain addOverfield: φ	]]].
	aMorphism codomain overfields do: [:each| each domain addTransitiveClosure: each]! !

!GaloisField methodsFor: 'private-embeddings' stamp: 'len 5/31/2024 15:02:33'!
embeddingInto: aGaloisField
	"Answer the existing compatible embedding from the receiver into aGaloisField if it is already set, or nil."
	self propertyAt: #outputs ifPresent: [:aDictionary| aDictionary at: aGaloisField ifPresent: [:aMorphism| ^ aMorphism]].
	aGaloisField propertyAt: #inputs ifPresent: [:aDictionary| aDictionary at: self ifPresent: [:aMorphism| ^ aMorphism]].
	^ nil! !

!GaloisField methodsFor: 'private-embeddings' stamp: 'len 11/3/2023 14:03:45'!
overfields
	^ Iterator on: [:aBlock| self propertyAt: #outputs ifPresent: [:aDictionary| aDictionary do: [:each| (each codomain isKindOf: GaloisField) ifTrue: [aBlock value: each]]]]! !

!GaloisField methodsFor: 'private-embeddings' stamp: 'len 10/29/2023 21:17:45'!
subfields
	^ self propertyAt: #subfields ifAbsentPut: [Dictionary new]

"	^ Iterator on: [:aBlock| self propertyAt: #inputs ifPresent: [:aDictionary| aDictionary do: [:each| (each domain isKindOf: GaloisField) ifTrue: [aBlock value: each]]]]"! !

!GaloisField class methodsFor: 'instance creation' stamp: 'len 5/1/2024 12:25:30'!
new: q
	"Answer the Galois field of order q = p^n."
	| factors n p |
	factors := q factorization.
	factors asSet size = 1 ifFalse: [^ self error: 'not power of a prime'].
	n := factors size.
	p := factors any.
	^ self new: p to: n! !

!GaloisField class methodsFor: 'instance creation' stamp: 'len 11/26/2023 09:42:12'!
new: p to: r
	"Answer the Galois field of order q = p^r."
	^ (PrimeField new: p) extensionDegree: r! !

!GaloisField class methodsFor: 'instance creation' stamp: 'len 10/11/2023 20:43:54'!
new: p to: n to: r
	self assert: n = 1.
	^ self new: p to: r! !

!FunctionField methodsFor: 'accessing' stamp: 'len 11/5/2023 18:20:03'!
constants
	"Answer the constant field of the receiver."
	^ self scalars constants! !

!FunctionField methodsFor: 'accessing' stamp: 'len 1/5/2017 19:50:45'!
genus
	^ self notYetImplemented! !

!FunctionField methodsFor: 'testing' stamp: 'len 6/9/2019 09:35:47'!
isField
	^ true! !

!FunctionField methodsFor: 'private' stamp: 'len 11/5/2023 08:05:19'!
elementClass
	^ AlgebraicRational! !

!FunctionField methodsFor: 'private' stamp: 'len 7/15/2021 19:12:04'!
extensionClass
	^ FunctionField! !

!NumberField methodsFor: 'accessing' stamp: 'len 7/12/2021 13:17:44'!
classNumber
	^ self propertyAt: #classNumber! !

!NumberField methodsFor: 'accessing' stamp: 'len 6/3/2023 11:04:17'!
conductor
	"Answer the order of the smallest cyclotomic field containing the receiver."
	^ self notYetImplemented! !

!NumberField methodsFor: 'accessing' stamp: 'len 6/13/2024 14:05:13'!
discriminant
	"The discriminant of an integral basis is independent of the choice of basis and it's called the discriminant of the field K and denoted by d(K)."
	^ self propertyAt: #discriminant ifAbsentPut:
		[| B |
		B := self integralBasis.
		(self asVectorSpace endomorphisms fill: [:i :j| ((B at: i) * (B at: j)) trace]) determinant]! !

!NumberField methodsFor: 'accessing' stamp: 'len 7/15/2021 16:52:28'!
integers
	"Answer the ring of integers of the receiver."
	^ self propertyAt: #integers ifAbsentPut: [MaximalOrder on: self]! !

!NumberField methodsFor: 'accessing' stamp: 'len 5/22/2022 11:09:06'!
integralBasis
	^ self notYetImplemented "[Coh96] 6.1.8"! !

!NumberField methodsFor: 'accessing' stamp: 'len 7/10/2021 11:56:01'!
integralBasisMatrix
	"Answer the matrix that sends power basis coordinates to integral basis coordinates."
	^ self propertyAt: #integralBasisMatrix ifAbsentPut: [self asVectorSpace endomorphisms columns: (self integralBasis collect: [:each| self asVectorSpace !! each])]! !

!NumberField methodsFor: 'accessing' stamp: 'len 10/26/2023 18:03:25'!
primitiveElement
	"Answer a primitive element, i.e. an element that generates this field over ℚ.
	Note that the 'primitive element' in a Galois ring or field is a different notion."
	^ self !! self asAbsolute generator! !

!NumberField methodsFor: 'accessing' stamp: 'len 11/19/2023 11:04:27'!
signature
	"Answer the signature (r₁,r₂) of the receiver, i.e. r₁ the number of embeddings whose image is real, and 2r₂ the number of non-real complex embeddings."
	^ self modulus signature! !

!NumberField methodsFor: 'elements' stamp: 'len 5/8/2023 16:40:37'!
adapt: anElement
	((anElement isKindOf: AlgebraicInteger) and: [anElement parent fractions = self])
		ifTrue: [^ self representative: (self cover coefficients: (self integralBasisMatrix * anElement asModuleElement) coefficients)].
	^ super adapt: anElement! !

!NumberField methodsFor: 'morphisms' stamp: 'len 11/19/2023 11:17:32'!
embeddingsInto: aNumberField do: aBlock
	"Subfield problem: given two number fields K and L, determine whether K is isomorphic to a subfield of L and enumerate the possible embeddings. See for example [Coh96, §4.5]."
	self flag: #deprecated.
	((aNumberField isKindOf: NumberField) and: [self scalars = aNumberField scalars and: [self degree | aNumberField degree]]) ifFalse: [^ self].
	self modulus rootsIn: aNumberField do: [:each| aBlock value: (self into: aNumberField images: {each})]! !

!NumberField methodsFor: 'morphisms' stamp: 'len 6/1/2024 07:05:30'!
to: aRing
	| α answer |
	(super to: aRing) ifNotNil: [:aMorphism| ^ aMorphism].
	"Subfield problem: given two number fields K and L, determine whether K is isomorphic to a subfield of L and produce an embedding. See for example [Coh96, §4.5]."
	((aRing isKindOf: NumberField) and: [self scalars = aRing scalars and: [self degree | aRing degree]]) ifFalse: [^ nil].
	"If both fields are embedded in ℂ in we can disambiguate between all possible embeddings:"
	self ⇢ ℂ ifNotNil: [:ι₁|
		aRing ⇢ ℂ ifNotNil: [:ι₂|
			α := ι₁ value: self generator.
			self modulus rootsIn: aRing do: [:each| (ι₂ value: each) = α ifTrue: [^ self into: aRing images: {each}]].
			^ nil]].
	"Otherwise, if there's only one possible embedding we answer that one:"
	answer := nil.
	self modulus rootsIn: aRing do: [:each| answer isNil ifFalse: [^ nil]. answer := self into: aRing images: {each}].
	^ answer! !

!NumberField methodsFor: 'operations' stamp: 'len 6/1/2024 07:26:09'!
algebraicClosure
	"If there's a distinguished embedding into ℂ, the algebraic closure is just ℂ:"
	self ⇢ ℂ ifNotNil: [^ ℂ].
	^ super algebraicClosure! !

!NumberField methodsFor: 'operations' stamp: 'len 1/10/2016 22:34'!
archimedeanPlaces
	^ self notYetImplemented! !

!NumberField methodsFor: 'operations' stamp: 'len 11/19/2023 11:08:19'!
different
	"Answer the different ideal of this number field. This is a fractional ideal of the ring of integers."
	^ self notYetImplemented! !

!NumberField methodsFor: 'operations' stamp: 'len 1/10/2016 22:34'!
nonArchimedeanPlaces
	^ self notYetImplemented! !

!NumberField methodsFor: 'operations' stamp: 'len 1/11/2016 03:53'!
regulator
	^ self notYetImplemented! !

!NumberField methodsFor: 'testing' stamp: 'len 6/9/2019 09:36:07'!
isField
	^ true! !

!NumberField methodsFor: 'testing' stamp: 'len 6/26/2023 01:33:46'!
isGaloisExtension
	self degree = 3 ifTrue: [^ self modulus discriminant isSquare].
	self notYetImplemented! !

!NumberField methodsFor: 'testing' stamp: 'len 12/28/2016 12:13:05'!
isMonogenic
	^ self propertyAt: #isMonogenic! !

!NumberField methodsFor: 'testing' stamp: 'len 11/20/2023 16:00:27'!
isReal
	^ self isTotallyReal! !

!NumberField methodsFor: 'testing' stamp: 'len 11/19/2023 11:26:26'!
isTotallyImaginary
	"Answer true if no embedding into ℂ has image contained in ℝ."
	^ self signature first = 0! !

!NumberField methodsFor: 'testing' stamp: 'len 11/19/2023 11:26:10'!
isTotallyReal
	"Answer true if every embedding into ℂ has image contained in ℝ."
	^ self signature second = 0! !

!NumberField methodsFor: 'private' stamp: 'len 10/9/2023 10:08:30'!
elementClass
	^ AlgebraicRational! !

!NumberField methodsFor: 'private' stamp: 'len 7/15/2021 19:12:19'!
extensionClass
	^ NumberField! !

!CyclotomicField methodsFor: 'accessing' stamp: 'len 11/23/2023 09:56:29'!
classNumber
	self conductor <= 22 ifTrue: [^ 1].
	self conductor = 23 ifTrue: [^ 3].
	self conductor <= 28 ifTrue: [^ 1].
	^ super classNumber! !

!CyclotomicField methodsFor: 'accessing' stamp: 'len 11/23/2023 09:55:56'!
conductor
	^ self propertyAt: #conductor! !

!CyclotomicField methodsFor: 'accessing' stamp: 'len 11/23/2023 09:56:39'!
discriminant
	| n phi |
	n := self conductor.
	phi := n phi.
	^ -1 ^ (phi / 2) * (n ^ phi) / (n factorization asSet product: [:p| p ^ (phi / (p - 1))])! !

!CyclotomicField methodsFor: 'accessing' stamp: 'len 11/23/2023 10:03:22'!
i
	self assert: 4 | self conductor.
	^ self x ^ (self conductor / 4)! !

!CyclotomicField methodsFor: 'accessing' stamp: 'len 11/23/2023 09:57:25'!
integers
	"Answer the ring of integers of the receiver."
	^ self propertyAt: #integers ifAbsentPut: [
		(self conductor = 3 ifTrue: [EisensteinRing] ifFalse: [self conductor = 4 ifTrue: [GaussianRing] ifFalse: [CyclotomicRing]]) on: self]! !

!CyclotomicField methodsFor: 'accessing' stamp: 'len 7/10/2021 12:10:16'!
integralBasis
	^ self basis! !

!CyclotomicField methodsFor: 'accessing' stamp: 'len 10/9/2023 09:06:14'!
maximalRealSubfield
	"Answer the intersection of the receiver with the real numbers."
	| α f answer |
	α := self x + self x inverse.
	(f := α minimalPolynomial) degree > 1 ifFalse: [^ ℚ].
	answer := ℚ extension: f.
	answer addMap: ((answer into: self images: {α}) name: 'ι').
	^ answer! !

!CyclotomicField methodsFor: 'accessing' stamp: 'len 11/23/2023 09:57:55'!
quadraticSubfield
	"If the receiver is the cyloctomic field ℚ(ζₚ) of prime order p, answer the unique quadratic subfield of the receiver."
	^ self propertyAt: #quadraticSubfield ifAbsentPut:
		[| p r d |
		r := (p := self conductor) \\ 4.
		d := r = 1 ifTrue: [p] ifFalse: [r = 3 ifTrue: [p negated] ifFalse: [^ self error: 'not prime order']].
		QuadraticField new: d]! !

!CyclotomicField methodsFor: 'morphisms' stamp: 'len 12/4/2023 11:44:21'!
automorphismGroup
	"Answer the group of automorphisms as an abstract group."
	^ self propertyAt: #automorphismGroup ifAbsentPut:
		[| answer |
		answer := (ℤ / self conductor) units.
		self endomorphisms 	addCoercionFrom: answer space map: [:a| self to: self images: {self x ^ a representative}].
		answer]! !

!CyclotomicField methodsFor: 'morphisms' stamp: 'len 4/16/2024 18:47:33'!
to: aRing
	((aRing isKindOf: CyclotomicField) and: [self conductor | aRing conductor])
		ifTrue: [^ self into: aRing images: {aRing x ^ (aRing conductor / self conductor)}].
	aRing = ℂ ifTrue: [^ self into: aRing images: {self generatorAsComplex}].
	^ super to: aRing! !

!CyclotomicField methodsFor: 'operations' stamp: 'len 11/23/2023 09:58:36'!
∧ aCyclotomicField
	"Answer the intersection or meet of the receiver and the argument in the lattice of cyclotomic fields, i.e. the maximal cyclotomic subfield of both the receiver and the argument."
	| n |
	(self = aCyclotomicField or: [ℚ = aCyclotomicField]) ifTrue: [^ aCyclotomicField].
	n := self conductor gcd: aCyclotomicField conductor.
	n = self conductor ifTrue: [^ self].
	n = aCyclotomicField conductor ifTrue: [^ aCyclotomicField].
	^ n > 2 ifTrue: [self class new: n] ifFalse: [ℚ]! !

!CyclotomicField methodsFor: 'operations' stamp: 'len 11/23/2023 09:58:52'!
∨ aCyclotomicField
	"Answer the join of the receiver and the argument in the lattice of cyclotomic fields, i.e. the minimal cyclotomic field that includes both the receiver and the argument as subfields."
	| n |
	(self = aCyclotomicField or: [ℚ = aCyclotomicField]) ifTrue: [^ self].
	n := self conductor lcm: aCyclotomicField conductor.
	n = self conductor ifTrue: [^ self].
	n = aCyclotomicField conductor ifTrue: [^ aCyclotomicField].
	^ self class new: n! !

!CyclotomicField methodsFor: 'printing' stamp: 'len 11/23/2023 09:57:11'!
indeterminateName
	| n |
	^ (n := self conductor) = 3 ifTrue: ['ω'] ifFalse: [n = 4 ifTrue: ['i' italic] ifFalse: ['ζ', n printString sub]]! !

!CyclotomicField methodsFor: 'printing' stamp: 'len 5/6/2023 15:10:09'!
printOn: aStream
	aStream print: self scalars; nextPut: $(; print: self x; nextPut: $)! !

!CyclotomicField methodsFor: 'testing' stamp: 'len 11/22/2023 20:11:35'!
isAbelianExtension
	^ true! !

!CyclotomicField methodsFor: 'testing' stamp: 'len 11/22/2023 20:31:53'!
isCyclicExtension
	^ true! !

!CyclotomicField methodsFor: 'testing' stamp: 'len 12/10/2016 20:16:17'!
isGaloisExtension
	^ true! !

!CyclotomicField methodsFor: 'testing' stamp: 'len 11/17/2023 13:40:42'!
isInvolutive
	^ true! !

!CyclotomicField methodsFor: 'testing' stamp: 'len 12/18/2016 21:54:02'!
isMonogenic
	^ true! !

!CyclotomicField methodsFor: 'private' stamp: 'len 11/6/2023 07:42:25'!
elementClass
	^ CyclotomicRational! !

!CyclotomicField methodsFor: 'private' stamp: 'len 11/23/2023 09:56:54'!
generatorAsComplex
	^ self propertyAt: #generatorAsComplex ifAbsentPut: [ComplexAlgebraicNumber minimalPolynomial: self modulus bounds: (Ball center: (Float pi * 2 i / self conductor) exp radius: Float pi / self conductor)]! !

!CyclotomicField class methodsFor: 'class initialization' stamp: 'len 11/29/2023 10:13:51'!
initialize
	super initialize.
	Cache := WeakValueDictionary new! !

!CyclotomicField class methodsFor: 'examples' stamp: 'len 12/12/2016 17:12:54'!
example
	^ CyclotomicField new: 7! !

!CyclotomicField class methodsFor: 'instance creation' stamp: 'len 11/29/2023 10:14:07'!
new: anInteger
	anInteger > 2 ifFalse: [^ self error: 'the order of a cyclotomic field must be > 2'].
	^ Cache at: anInteger ifAbsentOrNilPut:
		[(self modulus: (ℚ polynomials cyclotomicOfOrder: anInteger))
			propertyAt: #conductor put: anInteger;
			yourself]! !

!QuadraticField methodsFor: 'accessing' stamp: 'len 11/16/2023 19:11:25'!
conductor
	^ self discriminant abs! !

!QuadraticField methodsFor: 'accessing' stamp: 'len 12/10/2016 21:33:00'!
discriminant
	| d |
	^ (d _ self d) \\ 4 = 1 ifTrue: [d] ifFalse: [d*4]! !

!QuadraticField methodsFor: 'accessing' stamp: 'len 7/10/2021 11:48:27'!
integers
	"Answer the ring of integers of the receiver."
	^ self propertyAt: #integers ifAbsentPut: [QuadraticRing on: self]! !

!QuadraticField methodsFor: 'accessing' stamp: 'len 12/17/2021 14:24:58'!
integralBasis
	^ {self one. self d \\ 4 = 1 ifTrue: [self one + self x / 2] ifFalse: [self x]}! !

!QuadraticField methodsFor: 'accessing' stamp: 'len 11/19/2023 11:29:46'!
maximalRealSubfield
	^ self isTotallyReal ifTrue: [self] ifFalse: [self scalars maximalRealSubfield "or just ℚ if we assume all quadratic fields are absolute"]! !

!QuadraticField methodsFor: 'morphisms' stamp: 'len 4/16/2024 18:47:49'!
to: aRing
	aRing = ℂ ifTrue: [^ self into: aRing images: {self generatorAsComplex}].
	(aRing = ℝ and: [self isTotallyReal]) ifTrue: [^ self into: aRing images: {self generatorAsComplex asReal}].
	^ super to: aRing! !

!QuadraticField methodsFor: 'printing' stamp: 'len 11/14/2023 13:47:23'!
indeterminateName
	| d |
	d := self d.
	d = -1 ifTrue: [^ 'i' italic].
	d < 0 ifTrue: [^ 'i' italic, '√', d abs printString].
	^ '√', d printString! !

!QuadraticField methodsFor: 'printing' stamp: 'len 12/23/2016 16:31:16'!
printOn: aStream
	aStream print: self scalars; nextPut: $(; print: self x; nextPut: $)! !

!QuadraticField methodsFor: 'testing' stamp: 'len 11/22/2023 20:23:20'!
isAbelianExtension
	^ true! !

!QuadraticField methodsFor: 'testing' stamp: 'len 12/18/2016 21:54:14'!
isMonogenic
	^ true! !

!QuadraticField methodsFor: 'private' stamp: 'len 7/16/2021 11:08:48'!
d
	^ self modulus independentCoefficient asInteger negated! !

!QuadraticField methodsFor: 'private' stamp: 'len 11/13/2023 10:39:21'!
generatorAsComplex
	^ self propertyAt: #generatorAsComplex ifAbsentPut: [(ℂ !! self d) sqrt]! !

!QuadraticField class methodsFor: 'examples' stamp: 'len 6/3/2023 11:23:42'!
example
	"The Gaussian numbers, i.e. complex numbers with real and imaginary parts both rational."
	^ QuadraticField new: -1! !

!QuadraticField class methodsFor: 'instance creation' stamp: 'len 4/5/2024 19:07:57'!
new: anInteger
	| d |
	d := anInteger squarefreePart.
	(d = 0 or: [d = 1]) ifTrue: [self error: 'not a quadratic field'].
"	P := ℚ polynomialsIn: {d = -1 ifTrue: ['i' italic] ifFalse: ['√', d printString]}."
	^ self modulus: ℚ polynomials x squared - d! !

!JetRing methodsFor: 'as yet unclassified' stamp: 'len 9/6/2023 16:10:38'!
baseIdeal
	^ self propertyAt: #baseIdeal! !

!JetRing methodsFor: 'as yet unclassified' stamp: 'len 9/6/2023 16:11:05'!
baseIdeal: anIdeal order: anInteger
	self propertyAt: #baseIdeal put: anIdeal.
	self propertyAt: #order put: anInteger! !

!JetRing methodsFor: 'as yet unclassified' stamp: 'len 11/21/2023 15:18:44'!
elementClass
	^ Jet! !

!JetRing methodsFor: 'as yet unclassified' stamp: 'len 4/16/2024 18:39:09'!
from: aRing
"	((aDomain isKindOf: PowerSeriesRing) and: [aDomain baseIdeal = self baseIdeal])
		ifTrue: [^ (aDomain onto: self map: [:x| self project: x representative]) name: 'π', self exponent printString sub]."
"originally in PrimePowerRing:"
"	((aDomain isKindOf: ModularIntegerRing) and: [self modulus | aDomain modulus and: [(self modulus * self p | aDomain modulus) not]])" "localization map"
		"ifTrue: [^ aDomain onto: self map: [:x| self project: x lift]]. "
	^ super from: aRing! !

!JetRing methodsFor: 'as yet unclassified' stamp: 'len 11/3/2023 14:17:11'!
isIntegralDomain
	^ false! !

!JetRing methodsFor: 'as yet unclassified' stamp: 'len 9/6/2023 16:21:53'!
isLocal
	^ true! !

!JetRing methodsFor: 'as yet unclassified' stamp: 'len 11/21/2023 15:20:59'!
isQuasiGaloisRing
	^ self rank = 1 and: [self scalars isKindOf: PrimePowerRing]! !

!JetRing methodsFor: 'as yet unclassified' stamp: 'len 9/6/2023 16:23:07'!
maximalIdeal
	^ self * self generators! !

!JetRing methodsFor: 'as yet unclassified' stamp: 'len 11/21/2023 15:19:50'!
nilradical
	self isQuasiGaloisRing ifTrue: [^ self maximalIdeal].
	^ super nilradical! !

!JetRing methodsFor: 'as yet unclassified' stamp: 'len 9/6/2023 16:11:23'!
order
	^ self propertyAt: #order! !

!JetRing methodsFor: 'as yet unclassified' stamp: 'len 9/6/2023 16:13:40'!
printOn: aStream
	aStream print: self cover; nextPut: $╱; print: self baseIdeal; print: self order printString super! !

!JetRing methodsFor: 'as yet unclassified' stamp: 'len 9/6/2023 16:11:57'!
relations
	^ self propertyAt: #relations ifAbsentPut: [self baseIdeal ^ self order]! !

!JetRing methodsFor: 'as yet unclassified' stamp: 'len 11/21/2023 15:20:16'!
zeroDivisors
	self isQuasiGaloisRing ifTrue: [^ self maximalIdeal].
	^ super zeroDivisors! !

!JetRing class methodsFor: 'as yet unclassified' stamp: 'len 9/6/2023 16:32:38'!
new: anInteger baseIdeal: anIdeal
	^ self new baseIdeal: anIdeal order: anInteger! !

!LaurentPolynomialRing methodsFor: 'as yet unclassified' stamp: 'len 1/15/2022 17:59:24'!
elementClass
	^ LaurentPolynomial! !

!LaurentPolynomialRing methodsFor: 'as yet unclassified' stamp: 'len 1/15/2022 17:21:38'!
printIndeterminatesOn: aStream
	self indeterminates
		do: [:i| aStream print: (self x: i)]
		separatedBy: [aStream nextPut: $,]! !

!LaurentPolynomialRing methodsFor: 'as yet unclassified' stamp: 'len 1/15/2022 17:18:36'!
printOn: aStream
	aStream print: self scalars; nextPut: $[.
	self printIndeterminatesOn: aStream.
	aStream nextPut: $]! !

!LaurentPolynomialRing class methodsFor: 'as yet unclassified' stamp: 'len 1/15/2022 17:58:08'!
monomials: aFreeAbelianMonoid over: aRing
	| h R |
	aFreeAbelianMonoid rank even ifFalse: [^ self error: 'should have an even number of indeterminates'].
	h _ aFreeAbelianMonoid rank / 2.
	R _ PolynomialRing monomials: aFreeAbelianMonoid over: aRing.
	^ self relations: R * ((1 to: h) collect: [:i| (R x: i) * (R x: i+h) - 1])! !

!LaurentPolynomialRing class methodsFor: 'as yet unclassified' stamp: 'len 1/15/2022 18:02:14'!
new: anInteger over: aRing
	^ self monomials: (FreeAbelianMonoid new: anInteger*2) over: aRing! !

!LaurentPolynomialRing class methodsFor: 'as yet unclassified' stamp: 'len 1/15/2022 18:02:43'!
new: anInteger over: aRing ordering: aMonomialOrdering
	^ self monomials: (FreeAbelianMonoid new: anInteger*2 ordering: aMonomialOrdering) over: aRing! !

!AlgebraicClosureField methodsFor: 'accessing' stamp: 'len 11/21/2023 15:42:31'!
characteristic
	^ scalars characteristic! !

!AlgebraicClosureField methodsFor: 'accessing' stamp: 'len 11/22/2023 16:27:31'!
one
	^ AlgebraicClosureElement representative: self scalars one! !

!AlgebraicClosureField methodsFor: 'accessing' stamp: 'len 11/21/2023 15:43:54'!
primeSubring
	^ self scalars! !

!AlgebraicClosureField methodsFor: 'accessing' stamp: 'len 11/21/2023 15:40:29'!
scalars
	^ scalars! !

!AlgebraicClosureField methodsFor: 'accessing' stamp: 'len 11/21/2023 15:42:37'!
size
	^ ℕ size! !

!AlgebraicClosureField methodsFor: 'accessing' stamp: 'len 11/22/2023 16:27:31'!
zero
	^ AlgebraicClosureElement representative: self scalars zero! !

!AlgebraicClosureField methodsFor: 'comparing' stamp: 'len 11/21/2023 15:42:24'!
= anObject
	^ self class = anObject class and: [scalars = anObject scalars]! !

!AlgebraicClosureField methodsFor: 'comparing' stamp: 'len 11/21/2023 15:51:44'!
hash
	^ scalars hash! !

!AlgebraicClosureField methodsFor: 'morphisms' stamp: 'len 4/16/2024 18:39:21'!
from: aRing
	(aRing isFiniteField and: [self characteristic = aRing characteristic]) ifTrue: [^ aRing into: self map: [:x| AlgebraicClosureElement representative: x]].
	^ super from: aRing! !

!AlgebraicClosureField methodsFor: 'printing' stamp: 'len 11/21/2023 15:51:14'!
printOn: aStream
	aStream nextPutAll: '𝔽̄'; nextPutAll: self characteristic printString sub! !

!AlgebraicClosureField methodsFor: 'random' stamp: 'len 11/22/2023 16:27:31'!
atRandom: aRandom bits: bitSize
	| K n |
	n := bitSize // self characteristic max: 1.
	K := GaloisField new: self characteristic to: n.
	^ AlgebraicClosureElement representative: (K atRandom: aRandom)! !

!AlgebraicClosureField methodsFor: 'testing' stamp: 'len 11/22/2023 16:27:31'!
includes: anElement
	^ anElement class = AlgebraicClosureElement and: [anElement representative parent characteristic = self characteristic]! !

!AlgebraicClosureField methodsFor: 'testing' stamp: 'len 11/21/2023 15:40:43'!
isAlgebraicallyClosed
	^ true! !

!AlgebraicClosureField methodsFor: 'testing' stamp: 'len 11/22/2023 11:08:43'!
isCommutative
	^ true! !

!AlgebraicClosureField methodsFor: 'testing' stamp: 'len 11/22/2023 11:12:33'!
isField
	^ true! !

!AlgebraicClosureField methodsFor: 'testing' stamp: 'len 11/26/2023 13:38:02'!
isGaloisExtension
	^ true! !

!AlgebraicClosureField methodsFor: 'private' stamp: 'len 11/21/2023 15:40:23'!
scalars: aPrimeField
	scalars := aPrimeField! !

!AlgebraicClosureField class methodsFor: 'instance creation' stamp: 'len 11/21/2023 15:40:06'!
over: aPrimeField
	^ self new scalars: aPrimeField! !

!ComplexAlgebraicField methodsFor: 'accessing' stamp: 'len 11/7/2023 14:35:41'!
characteristic
	^ 0! !

!ComplexAlgebraicField methodsFor: 'accessing' stamp: 'len 11/8/2023 13:59:56'!
maximalRealSubfield
	"Answer the intersection of the receiver with the real numbers."
	^ ℝ! !

!ComplexAlgebraicField methodsFor: 'accessing' stamp: 'len 11/13/2023 10:35:28'!
one
	^ ComplexAlgebraicNumber fromRational: 1! !

!ComplexAlgebraicField methodsFor: 'accessing' stamp: 'len 11/8/2023 13:04:34'!
scalars
	^ ℚ! !

!ComplexAlgebraicField methodsFor: 'accessing' stamp: 'len 11/8/2023 13:28:20'!
size
	^ ℕ size! !

!ComplexAlgebraicField methodsFor: 'computing-polynomials' stamp: 'len 6/1/2024 07:26:28'!
rootsOf: aPolynomial withMultiplicitiesDo: aBlock
	aPolynomial parent scalars ⇢ ℚ ifNotNil:
		[(aPolynomial over: ℚ) factorizationDo: [:f :e| (ComplexRootIsolator on: f) roots do: [:each| aBlock value: (ComplexAlgebraicNumber minimalPolynomial: f normalized bounds: each) value: e]].
		^ self].
	^ super rootsOf: aPolynomial withMultiplicitiesDo: aBlock! !

!ComplexAlgebraicField methodsFor: 'elements' stamp: 'len 11/10/2023 14:32:58'!
i
	^ ComplexAlgebraicNumber minimalPolynomial: ℚ polynomials x squared + 1 bounds: (Ball center: 1 i radius: 0)! !

!ComplexAlgebraicField methodsFor: 'elements' stamp: 'len 11/10/2023 14:32:58'!
phi
	"Answer the Phidias number or Golden Ratio Φ ≈ 1.618033988749895."
	| x |
	x := ℚ polynomials x.
	^ ComplexAlgebraicNumber minimalPolynomial: x^2 - x - 1 bounds: (Ball center: 3/2 radius: 1/2)! !

!ComplexAlgebraicField methodsFor: 'elements' stamp: 'len 11/10/2023 14:32:58'!
sqrt: aRational
	"Answer a square root of the rational argument."
	| r |
	aRational positive ifFalse: [^ (self sqrt: aRational negated) * self i].
	r := (aRational max: 1) / 2.
	^ ComplexAlgebraicNumber
		minimalPolynomial: ℚ polynomials x squared - aRational
 		bounds: (Ball center: r radius: r)! !

!ComplexAlgebraicField methodsFor: 'morphisms' stamp: 'len 4/16/2024 18:39:34'!
from: aRing
	aRing = ℝ ifTrue: [^ aRing into: self map: [:x| x asComplex]].
	^ super from: aRing! !

!ComplexAlgebraicField methodsFor: 'printing' stamp: 'len 11/7/2023 21:41:59'!
printOn: aStream
	aStream nextPut: $ℂ! !

!ComplexAlgebraicField methodsFor: 'random' stamp: 'len 11/13/2023 10:35:37'!
atRandom: aRandom bits: bitSize
	| f |
	f := ℚ polynomials atRandom: aRandom bits: bitSize.
	f isConstant ifTrue: [^ ComplexAlgebraicNumber fromRational: f independentCoefficient].
	^ (f rootsIn: self) atRandom: aRandom! !

!ComplexAlgebraicField methodsFor: 'testing' stamp: 'len 11/8/2023 13:29:55'!
includes: anElement
	^ anElement class = ComplexAlgebraicNumber! !

!ComplexAlgebraicField methodsFor: 'testing' stamp: 'len 11/7/2023 14:36:12'!
isAlgebraicallyClosed
	^ true! !

!ComplexAlgebraicField methodsFor: 'testing' stamp: 'len 11/8/2023 13:21:31'!
isCommutative
	^ true! !

!ComplexAlgebraicField methodsFor: 'testing' stamp: 'len 11/7/2023 14:35:45'!
isField
	^ true! !

!ComplexAlgebraicField methodsFor: 'testing' stamp: 'len 11/26/2023 13:38:32'!
isGaloisExtension
	^ true! !

!ComplexAlgebraicField methodsFor: 'testing' stamp: 'len 11/9/2023 18:26:24'!
isInvolutive
	^ true! !

!RealAlgebraicField methodsFor: 'accessing' stamp: 'len 11/7/2023 14:35:26'!
characteristic
	^ 0! !

!RealAlgebraicField methodsFor: 'accessing' stamp: 'len 11/14/2023 13:52:32'!
maximalRealSubfield
	^ self! !

!RealAlgebraicField methodsFor: 'accessing' stamp: 'len 11/8/2023 13:05:14'!
scalars
	^ ℚ! !

!RealAlgebraicField methodsFor: 'accessing' stamp: 'len 11/8/2023 13:28:29'!
size
	^ ℕ size! !

!RealAlgebraicField methodsFor: 'computing-polynomials' stamp: 'len 6/1/2024 07:26:36'!
rootsOf: aPolynomial withMultiplicitiesDo: aBlock
	aPolynomial parent scalars ⇢ ℚ ifNotNil:
		[(aPolynomial over: ℚ) factorizationDo: [:f :e| (RealRootIsolator on: f) roots do: [:each| aBlock value: (RealAlgebraicNumber minimalPolynomial: f normalized bounds: each) value: e]].
		^ self].
	^ super rootsOf: aPolynomial withMultiplicitiesDo: aBlock! !

!RealAlgebraicField methodsFor: 'elements' stamp: 'len 11/13/2023 10:35:10'!
one
	^ RealAlgebraicNumber fromRational: 1! !

!RealAlgebraicField methodsFor: 'elements' stamp: 'len 11/10/2023 14:41:02'!
phi
	"Answer the Phidias number or Golden Ratio Φ ≈ 1.618033988749895."
	| x |
	x := ℚ polynomials x.
	^ RealAlgebraicNumber minimalPolynomial: x^2 - x - 1 bounds: (Ball center: 3/2 radius: 1/2)! !

!RealAlgebraicField methodsFor: 'elements' stamp: 'len 4/5/2024 19:07:47'!
sqrt: aRational
	"Answer a square root of the rational argument."
	| r |
	aRational positive ifFalse: [^ self error: 'negative square root'].
	r := (aRational max: 1) / 2.
	^ RealAlgebraicNumber
		minimalPolynomial: ℚ polynomials x squared - aRational
 		bounds: (Ball center: r radius: r)! !

!RealAlgebraicField methodsFor: 'operations' stamp: 'len 11/8/2023 13:58:58'!
algebraicClosure
	^ ℂ! !

!RealAlgebraicField methodsFor: 'printing' stamp: 'len 11/7/2023 21:42:10'!
printOn: aStream
	aStream nextPut: $ℝ! !

!RealAlgebraicField methodsFor: 'random' stamp: 'len 11/13/2023 10:35:20'!
atRandom: aRandom bits: bitSize
	| f |
	[f := ℚ polynomials atRandom: aRandom bits: bitSize.
	f isConstant ifTrue: [^ RealAlgebraicNumber fromRational: f independentCoefficient].
	f degree odd] whileFalse.
	^ (f rootsIn: self) atRandom: aRandom! !

!RealAlgebraicField methodsFor: 'testing' stamp: 'len 11/10/2023 14:09:58'!
includes: anElement
	^ anElement class = RealAlgebraicNumber! !

!RealAlgebraicField methodsFor: 'testing' stamp: 'len 11/8/2023 13:21:22'!
isCommutative
	^ true! !

!RealAlgebraicField methodsFor: 'testing' stamp: 'len 11/7/2023 14:35:30'!
isField
	^ true! !

!RealAlgebraicField methodsFor: 'testing' stamp: 'len 11/13/2023 10:31:58'!
isOrdered
	^ true! !

!RealAlgebraicField methodsFor: 'testing' stamp: 'len 11/7/2023 14:35:03'!
isReal
	^ true! !

!AbelianClosureField methodsFor: 'accessing' stamp: 'len 11/21/2023 16:12:11'!
characteristic
	^ 0! !

!AbelianClosureField methodsFor: 'accessing' stamp: 'len 11/22/2023 16:26:50'!
one
	^ AbelianClosureElement representative: self scalars one! !

!AbelianClosureField methodsFor: 'accessing' stamp: 'len 11/21/2023 16:10:26'!
scalars
	^ ℚ! !

!AbelianClosureField methodsFor: 'accessing' stamp: 'len 11/21/2023 16:10:36'!
size
	^ ℕ size! !

!AbelianClosureField methodsFor: 'accessing' stamp: 'len 11/22/2023 16:26:50'!
zero
	^ AbelianClosureElement representative: self scalars zero! !

!AbelianClosureField methodsFor: 'morphisms' stamp: 'len 4/16/2024 18:39:59'!
from: aRing
	(aRing isKindOf: CyclotomicField) ifTrue: [^ aRing into: self map: [:x| AbelianClosureElement representative: x]].
	((aRing isKindOf: NumberField) and: [aRing scalars = self scalars and: [aRing isAbelianExtension]])
		ifTrue: [^ aRing → (CyclotomicField new: aRing conductor) → self].
	^ super from: aRing! !

!AbelianClosureField methodsFor: 'morphisms' stamp: 'len 4/16/2024 18:47:59'!
to: aRing
	aRing = ℂ ifTrue: [^ self into: aRing map: [:x| ℂ !! x representative]].
	^ super to: aRing! !

!AbelianClosureField methodsFor: 'operations' stamp: 'len 11/23/2023 09:48:59'!
algebraicClosure
	^ self scalars algebraicClosure! !

!AbelianClosureField methodsFor: 'printing' stamp: 'len 11/21/2023 16:08:02'!
printOn: aStream
	aStream nextPutAll: 'ℚ', 'ab' super! !

!AbelianClosureField methodsFor: 'random' stamp: 'len 11/23/2023 10:11:31'!
atRandom: aRandom bits: bitSize
	| K n |
	n := [aRandom nextBoolean] count + 2.
	K := n > 2 ifTrue: [CyclotomicField new: n] ifFalse: [ℚ].
	^ AbelianClosureElement representative: (K atRandom: aRandom bits: bitSize)! !

!AbelianClosureField methodsFor: 'testing' stamp: 'len 11/22/2023 16:26:50'!
includes: anElement
	^ anElement class = AbelianClosureElement! !

!AbelianClosureField methodsFor: 'testing' stamp: 'len 11/22/2023 11:08:34'!
isCommutative
	^ true! !

!AbelianClosureField methodsFor: 'testing' stamp: 'len 11/22/2023 11:12:21'!
isField
	^ true! !

!AbelianClosureField methodsFor: 'testing' stamp: 'len 11/26/2023 13:43:54'!
isGaloisExtension
	^ true! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 1/2/2017 10:08:58'!
characteristic
	^ scalars characteristic! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 10/21/2023 08:20:01'!
dimension
	"Answer the Krull dimension of the receiver."
	(self ordering isGlobal and: [self scalars isNoetherian]) ifTrue: [^ self scalars dimension + self rank].
	^ super dimension! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 12/12/2023 19:21:46'!
freeCover
	^ self! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 3/19/2021 16:17:21'!
generators
	"Answer the generators of the receiver as an algebra over the coefficients ring."
	^ (1 to: self rank) collect: [:i| self x: i]! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 6/4/2016 05:12'!
indeterminate
	"Answer the univariate indeterminate."
	^ 1! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 10/22/2016 18:16'!
indeterminates
	^ 1 to: self rank! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 1/14/2022 11:54:36'!
maximalIdeal
	"If the receiver is a local ring, answer the unique maximal ideal."
	self isLocal ifFalse: [self error: 'the ring is not local'].
	^ self * self generators! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 11/20/2016 14:15:52'!
monomials
	"Answer the monoid of monomials of the receiver."
	^ monomials! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 2/27/2017 07:41:18'!
names
	"Answer the indeterminate names to use when printing polynomials."
	^ monomials names! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 7/26/2020 13:13:46'!
names: anArray
	"Set indeterminate names to use when printing polynomials."
	monomials names: anArray! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 1/22/2017 20:42:36'!
one
	^ self propertyAt: #one ifAbsentPut: [self constant: self scalars one]! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 11/20/2016 12:07:07'!
ordering
	^ monomials ordering! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 1/2/2017 10:08:31'!
rank
	"The rank of a polynomial ring is the number of indeterminates. Univariate polynomials have rank 1."
	^ monomials rank! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 12/12/2023 19:39:52'!
relations
	"Answer the relations of the receiver as affine algebra."
	^ self asIdeal null! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 12/12/2023 19:40:05'!
relators
	"Answer the relators of the receiver as affine algebra."
	^ #()! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 1/2/2017 10:08:53'!
scalars
	^ scalars! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 4/28/2022 07:43:53'!
size
	^ monomials size * scalars size! !

!PolynomialRing methodsFor: 'comparing' stamp: 'len 4/28/2022 07:44:36'!
= anObject
	self == anObject ifTrue: [^ true].
	^ self class = anObject class and: [scalars = anObject scalars and: [monomials = anObject monomials]]! !

!PolynomialRing methodsFor: 'comparing' stamp: 'len 8/30/2016 07:09'!
~ aPolynomialRing
	"Answer true if the receiver is canonically isomorphic to the argument."
	"R[x][y] ~ R[x,y]"
	self notYetImplemented! !

!PolynomialRing methodsFor: 'comparing' stamp: 'len 4/28/2022 07:45:40'!
hash
	^ scalars hash + monomials hash hashMultiply! !

!PolynomialRing methodsFor: 'computing-matrices' stamp: 'len 6/12/2023 09:34:31'!
basisAndTransformationOf: aMatrix
	"Andswer a standard basis of the module generated by the columns of aMatrix and a transformation matrix that maps the original generators to the basis."
	self scalars isEuclidean ifTrue:
		[| buchberger |
		buchberger := (self scalars isField ifTrue: [ExtendedBuchberger] ifFalse: [ExtendedStrongBuchberger]) on: aMatrix.
		^ {buchberger basis. buchberger transformation}].
	(self scalars isKindOf: PolynomialRing)
		ifTrue: [^ (aMatrix apply: self → self flatten) basisAndTransformation collect: [:each| each apply: self flatten → self]].
	^ self notYetImplemented! !

!PolynomialRing methodsFor: 'computing-matrices' stamp: 'len 6/12/2023 09:33:03'!
basisOf: aMatrix
	"Compute a standard basis from the columns of aMatrix with the specified ordering.
	When the monomial ordering is global, the algorithm outputs a Groebner basis. In case of a local monomial ordering, the algorithm uses Mora's normal form and outputs a standard basis."
	self scalars isEuclidean ifTrue:
		[^ ((self scalars isField ifTrue: [Buchberger] ifFalse: [StrongBuchberger]) on: aMatrix) basis].
	(self scalars isKindOf: PolynomialRing)
		ifTrue: [^ (aMatrix apply: self → self flatten) basis apply: self flatten → self].
	^ self notYetImplemented! !

!PolynomialRing methodsFor: 'computing-matrices' stamp: 'len 6/10/2023 17:34:11'!
matrix: B quotientBy: A
	"Answer X such that AX + N = B, satisfying that if the i-th column of B is a linear combination of the columns of A then the i-th column of N is zero."
	| G T C basis |
	self isEuclideanDomain ifTrue: [^ self matrixOverEuclideanDomain: B quotientBy: A].
	(self scalars isKindOf: PolynomialRing)
		ifTrue: [^ ((B apply: self → self flatten) quotientBy: (A apply: self → self flatten)) apply: self flatten → self].
	T := A basisTransformation.
	G := A basis.
	A height = 1
		ifTrue: [C := B asTuple asArray. basis := G asTuple asArray]
		ifFalse: [C := B columns. basis := G columns].
	^ Matrix to: A domain columns: (C collect: [:each| T * (T domain !! (each // basis))])! !

!PolynomialRing methodsFor: 'computing-matrices' stamp: 'len 6/10/2023 17:34:05'!
matrix: B reductionBy: A
	"Answer N such that AX + N = B, satisfying that if the i-th column of B is a linear combination of the columns of A then the i-th column of N is zero."
	| G C basis |
	self isEuclideanDomain ifTrue: [^ super matrix: B reductionBy: A].
	(self scalars isKindOf: PolynomialRing)
		ifTrue: [^ ((B apply: self → self flatten) reductionBy: (A apply: self → self flatten)) apply: self flatten → self].
	G := A basis.
	A height = 1
		ifTrue:
			[basis := G asTuple asArray.
			C := (B asTuple asArray collect: [:each| A codomain !! (each reductionFullBy: basis)])]
		ifFalse:
			[basis := G columns.
			C := (B columns collect: [:each| each reductionFullBy: basis])].
	^ Matrix to: B codomain columns: C
		! !

!PolynomialRing methodsFor: 'computing-matrices' stamp: 'len 6/12/2023 16:55:38'!
syzygiesOf: aMatrix
	"Answer a matrix whose rows span the kernel of the given matrix.
	For a matrix A, the output is X with AX = 0."
	| G T S syzygies |
	self isEuclideanDomain ifTrue: [^ self syzygiesOverEuclideanDomainOf: aMatrix].
	(self scalars isKindOf: PolynomialRing)
		ifTrue: [^ (aMatrix apply: self → self flatten) syzygies apply: self flatten → self].
	T := aMatrix basisTransformation.
	G := aMatrix basis.
"	self assert: aMatrix*T = G."
	syzygies := OrderedCollection new.
	1 to: G width - 1 do: [:i|
		| gi hi |
		gi := G columnAt: i.
		hi := gi leadingMonomial.
		i+1 to: G width do: [:j|
			| gj hj q s |
			gj := G columnAt: j.
			hj := gj leadingMonomial.
			(hi lcm: hj) ifNotNil: [:lcm|
				| ri rj |
				ri := lcm / hi.
				rj := lcm / hj.
				q := G domain !! (gi * ri - (gj * rj) // G columns).
				s := (G domain x: i monomial: ri) - (G domain x: j monomial: rj) - q.
				s := T * s.
				s isZero ifFalse: [syzygies add: s]]]].
	S := Matrix to: G domain columns: (aMatrix columns collect: [:each| G domain !! (each // G columns)]).
"	self assert: G*S = aMatrix."
	^ Matrix to: aMatrix domain columns: syzygies, ((aMatrix domain id - (T*S)) columns select: [:each| each isZero not])! !

!PolynomialRing methodsFor: 'converting' stamp: 'len 5/16/2023 22:15:54'!
asMultivariate
	"If the receiver is a univariate polynomial ring with coefficients in a polynomial ring R[x₁..xₙ][y], answer a new multivariate polynomial ring R[x₁,...,xₙ,y]."
	| answer |
	self isUnivariate ifFalse: [^ self].
	(self scalars isKindOf: PolynomialRing) ifFalse: [^ self].
	self propertyAt: #asMultivariate ifPresent: [:aPolynomialRing| ^ aPolynomialRing].
	answer _ self class monomials: self scalars monomials × self monomials over: self scalars scalars.
	answer propertyAt: #asUnivariate put: self.
	^ self propertyAt: #asMultivariate put: answer! !

!PolynomialRing methodsFor: 'converting' stamp: 'len 3/6/2021 15:24:13'!
asUnivariate
	self isUnivariate ifTrue: [^ self].
	^ self propertyAt: #asUnivariate ifAbsentPut: [self asUnivariateIn: self rank]! !

!PolynomialRing methodsFor: 'converting' stamp: 'len 4/28/2021 14:49:51'!
asUnivariateIn: anIndeterminate
	| answer |
	(anIndeterminate > 0 and: [anIndeterminate <= self rank]) ifFalse: [^ self error: 'undefined undeterminate'].
	answer _ self extract: {anIndeterminate}.
	answer propertyAt: #asMultivariate put: self.
	^ answer! !

!PolynomialRing methodsFor: 'converting' stamp: 'len 6/27/2023 22:51:31'!
dehomogenization
	"Answer a polynomial ring with one fewer indeterminate, used for dehomogenization of polynomials."
	^ self propertyAt: #dehomogenization! !

!PolynomialRing methodsFor: 'converting' stamp: 'len 9/18/2022 06:28:44'!
extract: anArray
	"Given a subset Y of the indeterminates of the receiver R[X], answer R[X\Y][Y] equipped with coercion maps."
	| complement F E |
	complement _ self indeterminates reject: [:i| anArray includes: i].
	F _ self class monomials: (monomials slice: complement) over: self scalars.
	E _ self class monomials: (monomials slice: anArray) over: F.
	E addMap: (E to: self images: (anArray collect: [:i| self x: i])).
	E addMap: (self to: E images: ((1 to: self rank) collect: [:i|
		| k |
		(k _ complement indexOf: i) > 0
			ifTrue: [E constant: (F x: k)] ifFalse: [E x: (anArray indexOf: i)]])).
	^ E! !

!PolynomialRing methodsFor: 'converting' stamp: 'len 6/20/2024 07:44:40'!
flatten
	"Given a polynomial ring over a polynomial ring R[X][Y], answer the flattened polynomial ring R[X∪Y] equipped with coercion maps."
	| n answer |
	(self scalars isKindOf: PolynomialRing) ifFalse: [^ self].
	^ self propertyAt: #flatten ifAbsentPut:
		[n := self scalars rank.
		answer := self scalars scalars polynomialsIn: n + self rank.
		answer addMap: (self scalars to: answer images: (answer generators copyFrom: 1 to: n)).
		answer addMap: (self to: answer images: (answer generators copyFrom: n+1 to: n+self rank)).
		answer addMap: (answer to: self images: (self scalars generators collect: [:x| self constant: x]), self generators).
		answer]! !

!PolynomialRing methodsFor: 'converting' stamp: 'len 6/27/2023 22:49:31'!
homogenization
	"Answer a graded polynomial ring with one more indeterminate, used for homogenization of polynomials."
	^ self propertyAt: #homogenization ifAbsentPut:
		[| answer |
		answer := scalars polynomialsIn: self rank + 1 ordering: #grevlex.
		answer propertyAt: #dehomogenization put: self.
		answer addCoercionFrom: self map: [:f| (answer associations: f associations) homogenizedIn: self rank + 1].
		answer addCoercionTo: self map: [:f| self associations: (f dehomogenizedIn: self rank + 1) associations].
		answer]! !

!PolynomialRing methodsFor: 'converting' stamp: 'len 6/10/2022 11:51:11'!
lift
	^ self propertyAt: #lift ifAbsentPut: [self class monomials: monomials over: scalars cover]! !

!PolynomialRing methodsFor: 'converting' stamp: 'len 12/23/2023 15:23:39'!
numerators
	scalars isLocalization ifFalse: [^ self].
	^ self propertyAt: #numerators ifAbsentPut: [self over: scalars numerators]! !

!PolynomialRing methodsFor: 'converting' stamp: 'len 5/13/2019 22:13:37'!
orderedBy: aMonomialOrdering
	^ self class monomials: (self monomials orderedBy: aMonomialOrdering) over: self scalars! !

!PolynomialRing methodsFor: 'converting' stamp: 'len 5/13/2019 22:13:23'!
over: aRing
	^ self class monomials: self monomials over: aRing! !

!PolynomialRing methodsFor: 'converting' stamp: 'len 3/5/2021 17:58:04'!
slice: anArray
	"Given a subset Y of the indeterminates of the receiver R[X], answer the subring R[Y] equipped with the embedding map."
	^ self class monomials: (monomials slice: anArray) over: self scalars! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 6/16/2023 19:23:16'!
adapt: anElement
	(anElement isInteger or: [anElement isFraction])
		ifTrue: [^ self constant: scalars !! anElement].
	(scalars includes: anElement)
		ifTrue: [^ self constant: anElement].
	(monomials includes: anElement)
		ifTrue: [^ self monomial: anElement].
	(anElement parent class = self class and: [self isUnivariate and: [anElement parent isUnivariate]])
		ifTrue: [^ self newFrom: anElement coefficients].
	(super adapt: anElement) ifNotNil: [:aPolynomial| ^ aPolynomial].
	(anElement parent class = self class) ifFalse: [^ nil].
	(anElement indeterminates allSatisfy: [:each| each <= self rank]) ifFalse: [^ nil]. "unknown indeterminates present"
	^ self associations: anElement associations! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 8/21/2022 08:15:14'!
associations: aCollection
	"Answer a polynomial created from a list of  'monomial -> coefficient' associations.
	Assume no repeated monomials."
	| associations |
	self isUnivariate
		ifTrue:
			[| n coefficients |
			n _ 0.
			aCollection do: [:each| n _ n max: each key degree].
			coefficients _ scalars zeros: n+1.
			aCollection do: [:each| coefficients at: each key degree + 1 put: each value].
			^ self coefficients: coefficients].
	associations _ OrderedCollection new: aCollection size.
	associations resetTo: 1.
	aCollection do: [:each| | coefficient |
		"WARNING: this assumes no repeated monomials"
		(coefficient _ scalars !! each value) isZero ifFalse: [associations add: (monomials !! each key) -> coefficient]].
	associations sort.
	^ MultivariatePolynomial coefficients: (SortedDictionary associations: associations) parent: self! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 10/28/2023 09:27:57'!
coefficient: anElement monomial: aMonomial
	anElement isZero ifTrue: [^ self zero].
	self isUnivariate ifTrue: [^ self coefficient: anElement xTo: aMonomial degree].
	^ self associations: {aMonomial -> anElement}! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 7/1/2022 06:03:23'!
coefficient: anElement x: anIndeterminate to: anInteger
	| i |
	i _ anIndeterminate isInteger
		ifTrue: [anIndeterminate]
		ifFalse: [self names indexOf: anIndeterminate ifAbsent: [^ self error: 'unknown indeterminate']].
	^ self coefficient: anElement monomial: (monomials x: i to: anInteger)! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 10/28/2023 09:26:20'!
coefficient: aScalar xTo: anInteger
	| c coefficients |
	c := scalars !! aScalar.
	c isZero ifTrue: [^ self zero].
	coefficients := scalars zeros: anInteger + 1.
	coefficients at: anInteger + 1 put: c.
	^ self coefficients: coefficients! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 5/14/2023 18:33:36'!
coefficients: anArray
	self isUnivariate ifFalse: [^ self error: 'not univariate ring'].
"	(scalars isValidArray: anArray) ifFalse: [^ self error: 'invalid array']."
	^ UnivariatePolynomial coefficients: anArray parent: self! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 7/10/2023 16:45:49'!
constant: aScalar
	self isUnivariate ifTrue: [^ aScalar isZero ifTrue: [self coefficients: (scalars new: 0)] ifFalse: [self coefficients: (scalars new: 1 fill: [:i| aScalar])]].
	^ aScalar isZero ifTrue: [self associations: #()] ifFalse: [self associations: {monomials identity -> aScalar}]! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 12/19/2015 03:38'!
interpolate: aCollection
	"Answer a polynomial f that for each pair k -> v of the argument evaluates to f(k) = v.
	(Lagrange polynomials.)"
	| answer x |
	self isUnivariate ifFalse: [^ self error: 'not yet implemented'].
	x _ self x.
	answer _ self zero.
	aCollection do: [:a| | p |
		p _ self one.
		aCollection do: [:b|
			a ~~ b ifTrue: [p _ p * ((x - b key) / (a key - b key))]].
		answer _ p * a value + answer].
	^ answer! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 9/16/2022 07:51:04'!
map: aBlock
	^ self generate: aBlock! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 4/20/2022 10:11:47'!
monomial: aMonomial
	^ self coefficient: scalars one monomial: aMonomial! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 5/8/2023 16:50:04'!
newFrom: anObject
	anObject isSequenceable ifTrue: [^ self coefficients: (scalars new: anObject size fill: [:i| anObject at: i])].
	anObject isEvaluable ifTrue: [^ self map: anObject].
	^ super newFrom: anObject! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 5/20/2016 03:34'!
x
	^ self x: self indeterminates first! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 3/21/2021 13:26:32'!
x: anInteger
	^ self x: anInteger to: 1! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 7/4/2022 12:47:12'!
x: i to: n
	^ self monomial: (monomials x: i to: n)! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 7/4/2022 12:47:02'!
x: i to: n x: j to: m
	^ self monomial: (monomials x: i to: n x: j to: m)! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 7/4/2022 12:47:41'!
x: i x: j
	^ self x: i to: 1 x: j to: 1! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 10/28/2023 09:27:00'!
xTo: anInteger
	^ self coefficient: self scalars one xTo: anInteger! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 5/20/2016 03:34'!
y
	^ self x: self indeterminates second! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 5/20/2016 03:34'!
z
	^ self x: self indeterminates third! !

!PolynomialRing methodsFor: 'enumerating' stamp: 'len 5/8/2023 16:50:58'!
do: aBlock
	| k |
	self scalars isFinite ifFalse: [^ self notYetImplemented].
	self isUnivariate ifFalse: [^ self notYetImplemented].
	aBlock value: self zero.
	k _ 1.
	[self scalars ^ k do: [:t| t last isZero ifFalse: [aBlock value: (self coefficients: t coefficients)]].
	k _ k + 1] repeat! !

!PolynomialRing methodsFor: 'enumerating' stamp: 'len 11/24/2022 17:57:24'!
unitsDo: aBlock
	self scalars isIntegralDomain ifTrue:
		[self scalars unitsDo: [:each| aBlock value: (self constant: each)].
		^ self].
	super unitsDo: aBlock! !

!PolynomialRing methodsFor: 'examples' stamp: 'len 10/28/2023 09:27:49'!
chebyshevOfOrder: n
	"Answer the n-th Chebyshev polynomial."
	| answer c m k |
	n <= 0 ifTrue: [^ self one].
	c := (1 bitShift: n - 1).
	m := 4.
	k := n - 1.
	answer := self coefficient: self scalars one * c xTo: n.
	n - 1 to: 1 by: -2 do: [ :each |
		c := ((c * (each + 1) * each) / (k * m)) negated.
		m := m + 4.
		k := k - 1.
		c = 0 ifFalse: [answer := answer + (self coefficient: self scalars one * c xTo: each - 1)]].
	^ answer! !

!PolynomialRing methodsFor: 'examples' stamp: 'len 5/23/2020 10:07:53'!
continuantOfOrder: n
	"Answer the continuant polynomial of order n."
	"(ℚ polynomialsIn: #(x y z)) continuantOfOrder: 3"

	n = 0 ifTrue: [^ self one].
	n = 1 ifTrue: [^ self x: 1].
	^ (self continuantOfOrder: n - 1) * (self x: n) + (self continuantOfOrder: n - 2)! !

!PolynomialRing methodsFor: 'examples' stamp: 'len 6/7/2022 11:16:20'!
cyclicIdeal
	"Answer the ideal of cyclic n-roots, used for benchmarks."
	^ self * self cyclicIdealGenerators! !

!PolynomialRing methodsFor: 'examples' stamp: 'len 6/10/2023 10:42:02'!
cyclicIdealGenerators
	"Answer generators of the ideal of cyclic n-roots, used for benchmarks."
	| answer |
	answer := Array new: self rank.
	0 to: self rank - 2 do: [:j|
		| g |
		g := (1 to: self rank) sum: [:i| (i to: i+j) product: [:k| self x: k-1 \\ self rank + 1]].
		answer at: j+1 put: g].
	answer at: self rank put: self generators product - 1.
	^ answer! !

!PolynomialRing methodsFor: 'examples' stamp: 'len 11/28/2023 08:52:08'!
cyclotomicOfOrder: n
	"Answer the n-th cyclotomic polynomial."
	| "numerator denominator" product |
	n = 1 ifTrue: [^ self x - self one].
	n isPrime ifTrue: [^ self coefficients: ((self scalars new: n) atAllPut: self scalars one)].
"	numerator _ one.
	denominator _ one.
	n divisorsDo: [:d| | mu |
		mu _ (n/d) moebius.
		mu = 1 ifTrue: [numerator _ numerator * (x^d - one)].
		mu = -1 ifTrue: [denominator _ denominator * (x^d - one)]].
	^ numerator // denominator"
	product := self one.
	n divisors do: [:each| each = n ifFalse: [product := product * (self cyclotomicOfOrder: each)]].
	^ self x^n - self one // product! !

!PolynomialRing methodsFor: 'examples' stamp: 'len 9/16/2022 07:44:28'!
determinantOfOrder: n
	"Answer the determinant polynomial of order n."
	"ℚ polynomials determinantOfOrder: 3"

	n = 0 ifTrue: [^ self zero].
	^ self ^ (n@n map: [:i :j| self x: n * (j - 1) + i]) determinant! !

!PolynomialRing methodsFor: 'examples' stamp: 'len 5/23/2020 10:08:09'!
fibonacciOfOrder: n
	"Answer the n-th Fibonacci polynomial."
	"ℚ polynomials fibonacciOfOrder: 3"

	n negative ifTrue: [^ self notYetImplemented].
	n = 0 ifTrue: [^ self zero].
	n = 1 ifTrue: [^ self one].
	^ (self fibonacciOfOrder: n - 1) - (self x * (self fibonacciOfOrder: n - 2))! !

!PolynomialRing methodsFor: 'examples' stamp: 'len 6/7/2022 11:17:27'!
katsuraIdeal
	"Answer the Katsura ideal, used for benchmarks."
	^ self * self katsuraIdealGenerators! !

!PolynomialRing methodsFor: 'examples' stamp: 'len 6/7/2022 11:17:10'!
katsuraIdealGenerators
	"Answer the Katsura ideal, used for benchmarks."
	| n f answer |
	n _ self rank.
	answer _ OrderedCollection new.
	f _ self !! -1.
	1-n to: n-1 do: [:i| f _ (self x: i abs + 1) + f].
	answer add: f.
	0 to: n-2 do: [:i|
		f _ (self x: i+1) * -1.
		1-n to: n-1 do: [:j| | k |
			k _ (i-j) abs + 1.
			k <= n ifTrue: [f _ (self x: j abs + 1) * (self x: k) + f]].
		answer add: f].
	^ answer! !

!PolynomialRing methodsFor: 'examples' stamp: 'len 11/28/2023 08:52:55'!
symmetricOfOrder: r
	"Answer the r-th symmetric polynomial whose terms are all monomials formed by the product of r distinct indeterminates."
	| answer |
	answer := self zero.
	(1 to: self rank) combinations: r atATimeDo: [:each| answer := answer + (each product: [:i| self x: i])].
	^ answer! !

!PolynomialRing methodsFor: 'morphisms' stamp: 'len 1/2/2016 04:13'!
embed: aScalar
	^ self constant: aScalar! !

!PolynomialRing methodsFor: 'morphisms' stamp: 'len 6/1/2024 07:05:52'!
from: aRing
	aRing = self scalars ifTrue: [^ self addMap: ((self scalars to: self map: [:x| self constant: x]) name: 'ι')].
	aRing ⇢ self scalars ifNotNil: [:aMorphism| ^ aRing to: self map: [:x| self constant: (aMorphism value: x)]].
	(aRing isKindOf: PolynomialRing)
		ifTrue: [aRing scalars ⇢ self scalars ifNotNil: [:aRingMap|
				aRing monomials ⇢ self monomials ifNotNil: [:aMonoidMap|
					^ aRing to: self map: [:f|
						| answer |
						answer := self zero.
						f associationsDo: [:each| answer := answer + (self coefficient: (aRingMap value: each value) monomial: (aMonoidMap value: each key))].
						answer]]]].
	^ super from: aRing! !

!PolynomialRing methodsFor: 'operations' stamp: 'len 10/23/2023 09:04:47'!
/ anIdeal
	"Answer the quotient by the given ideal.
	For convenience, the argument can be a single element or a collection of elements as well."
	(anIdeal isKindOf: Ideal) ifFalse: [^ self / (self * anIdeal)].
	self assert: self = anIdeal scalars.
	anIdeal isTrivial ifTrue: [^ self].
	^ AffineAlgebra relations: anIdeal! !

!PolynomialRing methodsFor: 'operations' stamp: 'len 5/4/2023 19:12:13'!
<< anInteger
	(anInteger = 0 or: [self isTrivial]) ifTrue: [^ self].
	^ self class monomials: self monomials << anInteger over: self scalars! !

!PolynomialRing methodsFor: 'operations' stamp: 'len 5/4/2023 18:19:01'!
>> anInteger
	^ self << anInteger negated! !

!PolynomialRing methodsFor: 'operations' stamp: 'len 10/7/2023 12:32:12'!
\ anElement
	"Answer anElement expressed as a word on the generators."
	^ anElement! !

!PolynomialRing methodsFor: 'operations' stamp: 'len 10/29/2023 09:18:14'!
berlekampMassey: anArray
	"This is a modified Berlekamp-Massey algorithm based on [ADL06, Algorithm 2].
	Input: a₁..a₂ₙ the first 2n coefficients of a linear recursive sequence over a field K (the coefficient field of the reciever) of order at most n (the minimal polynomial has degree bound n);
	Output: the minimal polynomial of the sequence."
	| x R₀ R₁ V V₀ V₁ n m |
	n := anArray size // 2.
	m := 2*n - 1.
	x := self x.
	self flag: #fixme. "optimize"
	R₀ := x^(2*n). R₁ := (0 to: m) sum: [:i| x^i*(anArray at: m-i+1)].
	V₀ := self zero. V₁ := self one.
	[n <= R₁ degree]
		whileTrue:
			[ | division |
			division := R₀ divisionBy: R₁.
			V := V₀ - (division quotient * V₁).
			V₀ := V₁. V₁ := V. R₀ := R₁. R₁ := division remainder].
	^ V₁ / V₁ leadingCoefficient! !

!PolynomialRing methodsFor: 'operations' stamp: 'len 5/8/2023 16:51:52'!
filtrationAt: anInteger
	"Answer the submodule of polynomials of degree <= anInteger."
	| answer basis |
	self isUnivariate ifTrue:
		[^ (answer _ self scalars ^ (anInteger + 1))
			addCoercionFrom: self map: [:f| answer elementAt: f coefficients];
			addCoercionTo: self map: [:v| self coefficients: v coefficients];
			yourself].
	basis _ self monomials allMonomialsUpToDegree: anInteger.
	^ (answer _ self scalars ^ basis size)
		addCoercionFrom: self map: [:f| answer elementAt: (basis collect: [:each| f at: each])];
		addCoercionTo: self map: [:v| (1 to: basis size) sum: [:i| self coefficient: (v at: i) monomial: (basis at: i)]];
		yourself! !

!PolynomialRing methodsFor: 'operations' stamp: 'len 3/3/2021 13:03:29'!
fractions
	"Answer the field of rational functions, i.e. the localization of the receiver at 0."
	^ self propertyAt: #fractions ifAbsentPut:
		[self scalars isField
			ifTrue: [RationalFunctionField on: self]
			ifFalse: [self scalars isIntegralDomain
				ifTrue: [RationalFunctionField on: (self over: self scalars fractions)]
				ifFalse: [^ super fractions]]]! !

!PolynomialRing methodsFor: 'operations' stamp: 'len 9/16/2022 08:23:59'!
gradingAt: anInteger
	"Answer the submodule of homogeneous polynomials of degree anInteger."
	| answer monomialBasis |
	monomialBasis _ self monomials allMonomialsOfDegree: anInteger.
	^ (answer _ self scalars ^ monomialBasis size)
		addCoercionFrom: self map: [:f| answer !! (monomialBasis collect: [:each| f at: each])];
		addCoercionTo: self map: [:v| | f | f _ self zero. v with: monomialBasis do: [:coefficient :monomial| f _ (self coefficient: coefficient monomial: monomial) + f]. f];
		yourself! !

!PolynomialRing methodsFor: 'operations' stamp: 'len 7/8/2022 11:32:12'!
hilbertSeriesAt: t
	self isGraded ifFalse: [^ self error: 'not a graded ring'].
	^ (self indeterminates product: [:i| 1 - (t ^ (self ordering weightOf: i))]) reciprocal! !

!PolynomialRing methodsFor: 'operations' stamp: 'len 6/27/2023 23:52:27'!
proj
	"This is the Proj construction. Answer the projective space with the receiver as homogeneous coordinate ring."
	^ self propertyAt: #proj ifAbsentPut: [ProjectiveSpace coordinateRing: self]! !

!PolynomialRing methodsFor: 'operations' stamp: 'len 5/10/2020 12:12:23'!
radical
	"Answer the Jacobson radical J(R) of the receiver R. This is the ideal consisting of all elements that annihilate all simple R-modules. It is the intersection of all maximal ideals. In a polynomial ring, it is the same as the nilradical."
	^ self nilradical! !

!PolynomialRing methodsFor: 'operations' stamp: 'len 12/11/2021 19:13:41'!
spec
	"This is the Spec functor. Answer the spectrum of the receiver as an affine scheme, i.e. affine space with coordinate ring the receiver."
	^ self propertyAt: #spec ifAbsentPut: [AffineSpace coordinateRing: self]! !

!PolynomialRing methodsFor: 'operations' stamp: 'len 8/19/2024 09:41:08'!
⊗ aRing
	"Answer the tensor product (over the scalars of the receiver) of the receiver with the argument.
	This is the coproduct in the category of commutative R-algebras."
	| R answer ι₁ ι₂ |
	aRing = self scalars ifTrue: [^ self].
	aRing isAffineAlgebra ifFalse:
		[self scalars ⇢ aRing ifNotNil: [^ self over: aRing].
		^ super ⊗ aRing].
	aRing scalars = self scalars ifFalse:
		[self scalars ⇢ aRing scalars ifNotNil: [^ (self over: aRing scalars) ⊗ aRing].
		aRing scalars ⇢ self scalars ifNotNil: [^ self ⊗ (aRing over: self scalars)].
		^ super ⊗ aRing].
	R := self class monomials: self monomials × aRing monomials over: self scalars.
	answer := (aRing isKindOf: PolynomialRing)
		ifTrue: [R]
		ifFalse: [R / (aRing relations generators collect: [:f| R !! f substitute: [:i| i + self rank]])].
	ι₁ := self into: answer images: (answer generators first: self rank).
	ι₂ := aRing into: answer images: (answer generators last: aRing rank).
	answer addCoprojections: {ι₁. ι₂}.
	answer addCoercionFrom: self underlyingSet × aRing underlyingSet mapWithArguments: [:f :g| (ι₁ value: f) * (ι₂ value: g)].
	^ answer! !

!PolynomialRing methodsFor: 'printing' stamp: 'len 6/19/2022 12:08:26'!
printIndeterminatesOn: aStream
	self indeterminates
		do: [:i| aStream print: (monomials x: i)]
		separatedBy: [aStream nextPut: $,]! !

!PolynomialRing methodsFor: 'printing' stamp: 'len 2/12/2017 06:49:02'!
printOn: aStream
	aStream print: self scalars; nextPut: $[.
	self printIndeterminatesOn: aStream.
	aStream nextPut: $].
	self ordering isLocal ifTrue: [aStream nextPutAll: self maximalIdeal printText sub]! !

!PolynomialRing methodsFor: 'random' stamp: 'len 6/30/2023 12:45:24'!
atRandom: aRandom bits: bitSize
	^ self atRandom: aRandom bits: bitSize maxDegree: (bitSize ^ (1/(self rank+1)) min: bitSize - 1) truncated! !

!PolynomialRing methodsFor: 'random' stamp: 'len 6/21/2023 15:16:36'!
atRandom: aRandom bits: bitSize maxDegree: d
	self isUnivariate ifTrue: [^ self coefficients: (scalars new: d+1 atRandom: aRandom bits: bitSize)].
	^ self atRandom: aRandom bits: bitSize maxDegree: d maxTerms: 2 ^ self rank! !

!PolynomialRing methodsFor: 'random' stamp: 'len 6/21/2023 15:16:15'!
atRandom: aRandom bits: bitSize maxDegree: d maxTerms: n
	| answer term |
	d = 0 ifTrue: [^ self constant: (scalars atRandom: aRandom bits: bitSize)].
	answer := self zero.
	(n atRandom: aRandom) timesRepeat:
		[term := self one.
		((0 to: d) atRandom: aRandom) timesRepeat: [term := term * (self generators atRandom: aRandom)].
		term := term * (scalars atRandom: aRandom bits: bitSize/(self rank*d)).
		answer := answer + term].
	^ answer! !

!PolynomialRing methodsFor: 'random' stamp: 'len 6/21/2023 15:15:58'!
atRandom: aRandom degree: anInteger
	"Answer a monic polynomial of degree anInteger choosen at random."
	self isUnivariate ifFalse: [^ self notYetImplemented].
	^ self coefficients: (scalars new: anInteger atRandom: aRandom), self scalars one! !

!PolynomialRing methodsFor: 'random' stamp: 'len 6/21/2023 15:15:24'!
atRandom: aRandom maxDegree: d
	self isUnivariate ifTrue: [^ self coefficients: (scalars new: d+1 atRandom: aRandom)].
	^ self atRandom: aRandom maxDegree: d maxTerms: 2 ^ self rank! !

!PolynomialRing methodsFor: 'random' stamp: 'len 6/21/2023 15:15:18'!
atRandom: aRandom maxDegree: d maxTerms: n
	| answer term |
	d = 0 ifTrue: [^ self constant: (scalars atRandom: aRandom)].
	answer := self zero.
	(n atRandom: aRandom) timesRepeat:
		[term := self one.
		((0 to: d) atRandom: aRandom) timesRepeat: [term := term * (self generators atRandom: aRandom)].
		term := term * (scalars atRandom: aRandom).
		answer := answer + term].
	^ answer! !

!PolynomialRing methodsFor: 'random' stamp: 'len 6/10/2023 11:30:22'!
atRandomBits: bitSize maxDegree: anInteger
	^ self atRandom: self newRandom bits: bitSize maxDegree: anInteger! !

!PolynomialRing methodsFor: 'random' stamp: 'len 6/9/2023 23:14:13'!
atRandomDegree: anInteger
	"Answer a monic polynomial of degree anInteger choosen at random."
	^ self atRandom: self newRandom degree: anInteger! !

!PolynomialRing methodsFor: 'random' stamp: 'len 6/10/2023 11:30:07'!
atRandomMaxDegree: anInteger
	"Answer a polynomial of degree at most anInteger choosen at random."
	^ self atRandom: self newRandom maxDegree: anInteger! !

!PolynomialRing methodsFor: 'random' stamp: 'len 5/25/2022 19:34:42'!
unitAtRandom: aRandom
	| answer |
	answer _ self constant: (self scalars units atRandom: aRandom).
	(self scalars isIntegralDomain or: [self monomials isTrivial]) ifTrue: [^ answer].
	[aRandom nextBoolean] whileTrue: 
		[| m |
		[(m _ self monomials atRandom: aRandom) isIdentity] whileTrue.
		answer _ (self coefficient: (self scalars nilradical atRandom: aRandom) monomial: m) + answer].
	^ answer! !

!PolynomialRing methodsFor: 'random' stamp: 'len 5/25/2022 19:35:01'!
unitAtRandom: aRandom bits: bitSize
	| answer |
	answer _ self constant: (self scalars units atRandom: aRandom bits: bitSize).
	(self scalars isIntegralDomain or: [self monomials isTrivial]) ifTrue: [^ answer].
	[aRandom nextBoolean] whileTrue: 
		[| m |
		[(m _ self monomials atRandom: aRandom bits: ((bitSize log: 2) max: 2)) isIdentity] whileTrue.
		answer _ (self coefficient: (self scalars nilradical atRandom: aRandom bits: bitSize) monomial: m) + answer].
	^ answer! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 12/24/2023 08:38:23'!
has: anIndeterminate
	^ anIndeterminate between: 1 and: self rank! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 6/3/2023 20:39:03'!
hasCanonicalAssociates
	^ self scalars isIntegralDomain and: [self scalars hasCanonicalAssociates]! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 6/17/2023 17:09:29'!
hasCanonicalBases
	"Answer true if there's an algorithm to compute canonical bases for modules over the receiver."
	^ (self scalars isEuclidean or: [(self scalars isKindOf: PolynomialRing) and: [self scalars hasCanonicalBases]]) and: [self ordering isGlobal]! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 6/3/2022 20:41:51'!
hasCanonicalReduction
	^ self scalars hasCanonicalReduction! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 6/13/2023 23:40:23'!
hasGCD
	"Answer true if the receiver is known to have computable GCDs
	(for example if it's a UFD or an Euclidean ring and implements an algorithm for GCDs)."
	^ self scalars hasGCD "and: [self scalars isUFD]"! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 5/8/2023 00:19:26'!
includes: anObject
	^ anObject parent = self! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 10/13/2022 10:25:26'!
isAffineAlgebra
	^ true! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 12/21/2022 13:27:50'!
isBezout
	"Answer true if the receiver is a Bézout ring, i.e. every finitely generated ideal is principal."
	^ self isEuclidean! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 4/28/2021 09:37:55'!
isCommutative
	^ true! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 12/23/2023 10:31:53'!
isEuclidean
	"Answer true if the receiver is a Euclidean ring, i.e. it has Euclidean division with remainder."
	self isUnivariate ifFalse: [^ false].
	self scalars isField ifTrue: [^ true].
	"TODO: ℤ/6ℤ[x] is a PIR (and thus Euclidean), ℤ/8ℤ is not a PIR. For R a finite commutative ring, the polynomial ring R[x] is a PIR iff R is a direct product of finite fields. Also R[x] is a PIR iff it is isomorphic to a direct product of PIDs."
	^ super isEuclidean! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 8/21/2024 14:54:56'!
isFinitelyGeneratedAlgebra
	^ true! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 2/12/2017 06:13:48'!
isGraded
	"Answer true if this polynomial ring is graded, i.e. it uses a graded monomial ordering."
	^ self ordering isGraded! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 4/27/2018 06:16:03'!
isIntegralDomain
	^ self scalars isIntegralDomain! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 2/12/2017 05:48:39'!
isLocal
	"Answer true if this polynomial ring is local, i.e. it uses a local monomial ordering."
	^ self ordering isLocal! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 7/27/2021 11:38:09'!
isMultivariate
	^ true! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 5/8/2023 22:53:10'!
isNoetherian
	"A ring is called Noetherian if every ideal is finitely generated."
	^ self scalars isNoetherian ifTrue: [^ true] "Hilber's basis theorem"! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 10/22/2016 18:09'!
isPID
	"Univariate polynomials over a field are principal ideal domains."
	^ self scalars isField and: [self isUnivariate]! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 12/23/2023 10:32:11'!
isPIR
	"A principal ideal ring (PIR) is a ring in which every ideal is principal, i.e. can be generated by a single element.
	In a PIR any two nonzero elements have a well-defined GCD."
	"Principal ideal rings are exactly the rings that are both Bézout and Noetherian:"
	self isUnivariate ifFalse: [^ false].
	self scalars isField ifTrue: [^ true].
	"TODO: ℤ/6ℤ[x] is a PIR (and thus Euclidean), ℤ/8ℤ[x] is not a PIR. For R a finite commutative ring, the polynomial ring R[x] is a PIR iff R is a direct product of finite fields. Also R[x] is a PIR iff it is isomorphic to a direct product of PIDs."
	(self scalars isKindOf: ModularIntegerRing) ifTrue: [^ self scalars isReduced].
	(self scalars isKindOf: GaloisRing) ifTrue: [^ self scalars exponent = 1].
	^ super isPIR! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 3/4/2021 18:23:48'!
isTrivial
	"The trivial ring is the zero ring with a single element 0 = 1."
	^ self scalars isTrivial! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 6/16/2022 18:43:12'!
isUFR
	self scalars isUFR ifTrue: [^ true]. "proof based on Gauss lemma"
	^ super isUFR! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 10/22/2016 18:16'!
isUnivariate
	^ self rank = 1! !

!PolynomialRing methodsFor: 'private' stamp: 'len 4/6/2021 13:24:56'!
idealClass
	^ PolynomialIdeal! !

!PolynomialRing methodsFor: 'private' stamp: 'len 2/26/2017 10:37:19'!
monomials: aFreeAbelianMonoid
	monomials _ aFreeAbelianMonoid! !

!PolynomialRing methodsFor: 'private' stamp: 'len 11/20/2016 12:06:41'!
ordering: aMonomialOrdering
	monomials ordering: aMonomialOrdering! !

!PolynomialRing methodsFor: 'private' stamp: 'len 1/2/2017 10:10:53'!
scalars: aRing
	scalars _ aRing! !

!PolynomialRing class methodsFor: 'instance creation' stamp: 'len 5/13/2019 22:12:50'!
monomials: aFreeAbelianMonoid over: aRing
	^ self new monomials: aFreeAbelianMonoid; scalars: aRing! !

!PolynomialRing class methodsFor: 'instance creation' stamp: 'len 5/13/2019 22:12:02'!
new: anInteger over: aRing
	^ self monomials: (FreeAbelianMonoid new: anInteger) over: aRing! !

!PolynomialRing class methodsFor: 'instance creation' stamp: 'len 5/13/2019 22:12:22'!
new: anInteger over: aRing ordering: aMonomialOrdering
	^ self monomials: (FreeAbelianMonoid new: anInteger ordering: aMonomialOrdering) over: aRing! !

!FiniteAlgebra methodsFor: 'accessing' stamp: 'len 10/24/2023 21:42:04'!
characteristic
	| P |
	self isTrivial ifTrue: [^ 1].
	self asModule isFree ifTrue: [^ self scalars characteristic].
	^ (P := self primeSubring) isFinite ifTrue: [P size] ifFalse: [0]! !

!FiniteAlgebra methodsFor: 'accessing' stamp: 'len 10/14/2023 08:11:30'!
generators
	"Note: the module generators are not necessarily a minimal set of generators as algebra."
	^ self propertyAt: #generators ifAbsent: [self linearGenerators]! !

!FiniteAlgebra methodsFor: 'accessing' stamp: 'len 6/14/2024 15:17:55'!
multiplicationBilinearMap
	"Answer the multiplication as a bilinear map on the underlying module."
	^ self propertyAt: #multiplicationBilinearMap ifAbsentPut: [BilinearMap from: self asModule, self asModule to: self asModule mapWithArguments: [:x :y| (self !! x) * (self !! y)]]! !

!FiniteAlgebra methodsFor: 'accessing' stamp: 'len 7/14/2021 16:54:27'!
rank
	^ self asModule rank! !

!FiniteAlgebra methodsFor: 'accessing' stamp: 'len 6/11/2020 06:39:27'!
scalars
	^ self asModule scalars! !

!FiniteAlgebra methodsFor: 'accessing' stamp: 'len 6/27/2020 09:07:47'!
size
	^ self asModule size! !

!FiniteAlgebra methodsFor: 'accessing' stamp: 'len 6/17/2020 14:43:06'!
zero
	^ self !! self asModule zero! !

!FiniteAlgebra methodsFor: 'comparing' stamp: 'len 11/20/2023 11:02:43'!
= anObject
	^ self == anObject or: [(anObject isKindOf: FiniteAlgebra) and: [self ambient asModule = anObject ambient asModule and: [self asModule = anObject asModule]]]! !

!FiniteAlgebra methodsFor: 'comparing' stamp: 'len 5/1/2024 10:04:04'!
⊆ anAlgebra
	"Answer true if the receiver is a subalgebra of the argument."
	(anAlgebra isKindOf: FiniteAlgebra) ifTrue: [^ self ambient = anAlgebra ambient and: [self asModule ⊆ anAlgebra asModule]].
	^ super ⊆ anAlgebra! !

!FiniteAlgebra methodsFor: 'converting' stamp: 'len 6/11/2020 11:38:33'!
asModule
	^ self propertyAt: #asModule! !

!FiniteAlgebra methodsFor: 'elements' stamp: 'len 6/6/2022 11:01:51'!
adapt: anElement
	self isAmbient ifFalse: [^ super adapt: anElement].
	(self asModule includes: anElement) ifTrue: [^ self fromModuleElement: anElement].
	(self scalars includes: anElement) ifTrue: [^ self one * anElement].
	^ super adapt: anElement! !

!FiniteAlgebra methodsFor: 'elements' stamp: 'len 6/29/2022 07:31:05'!
fromModuleElement: anElement
	^ FiniteAlgebraElement parent: self moduleElement: anElement! !

!FiniteAlgebra methodsFor: 'elements' stamp: 'len 10/16/2023 21:04:46'!
newFrom: anObject
	(anObject isSequenceable and: [anObject size = self rank])
		ifTrue: [^ self fromModuleElement: (self asModule elementAt: anObject)].
	^ super newFrom: anObject! !

!FiniteAlgebra methodsFor: 'morphisms' stamp: 'len 6/1/2024 07:06:00'!
from: aRing
	aRing == self scalars ifTrue: [^ self addMap: ((self scalars to: self map: [:x| self one * x]) name: 'ι')].
	aRing ⇢ self scalars ifNotNil: [:aMorphism| ^ self scalars → self · aMorphism].
	^ super from: aRing! !

!FiniteAlgebra methodsFor: 'morphisms' stamp: 'len 6/26/2024 09:03:33'!
id
	^ self propertyAt: #id ifAbsentPut: [self to: self moduleMap: self asModule id]! !

!FiniteAlgebra methodsFor: 'morphisms' stamp: 'len 4/16/2024 18:48:09'!
to: aRing
	aRing = self asModule endomorphisms ifTrue: [^ self addMap: (self to: aRing map: [:x| x representation])].
	^ super to: aRing! !

!FiniteAlgebra methodsFor: 'morphisms' stamp: 'len 6/26/2024 09:03:52'!
to: anAlgebra images: anArray
	"Answer a morphism defined by images of generators."
	((anAlgebra isKindOf: FiniteAlgebra) and: [anAlgebra scalars = self scalars]) ifFalse: [^ super to: anAlgebra images: anArray].
	^ self to: anAlgebra moduleMap: (self asModule to: anAlgebra asModule images: (anArray collect: [:each| each asModuleElement]))! !

!FiniteAlgebra methodsFor: 'morphisms' stamp: 'len 6/26/2024 09:04:02'!
to: aRing map: aBlock
	((aRing isKindOf: FiniteAlgebra) and: [self scalars = aRing scalars]) ifTrue: [^ self to: aRing moduleMap: (self asModule to: aRing asModule map: [:x| (aBlock value: self !! x) asModuleElement])].
	^ super to: aRing map: aBlock! !

!FiniteAlgebra methodsFor: 'operations' stamp: 'len 6/26/2023 12:57:43'!
/ anIdeal
	"Answer the quotient by the given two-sided ideal.
	For convenience, the argument can be a single element or a collection of elements as well."
	| Q π answer |
	(anIdeal isKindOf: Ideal) ifFalse: [^ self / (self * anIdeal)].
	self assert: self = anIdeal scalars.
	anIdeal isTrivial ifTrue: [^ self].
	Q := self asModule / (self asModule sub: anIdeal generators).
	π := self asModule → Q.
	^ (answer := self species one: Q !! (self asModule !! self one) multiplication: (BilinearMap from: (Q, Q) to: Q mapWithArguments: [:x :y| (self !! x) * (self !! y)]))
		addMap: (self to: answer map: [:x| answer !! (π value: x asModuleElement)]);
		yourself! !

!FiniteAlgebra methodsFor: 'operations' stamp: 'len 6/29/2022 07:30:41'!
× anAlgebra
	"Answer the direct product of the receiver with the argument."
	((anAlgebra isKindOf: FiniteAlgebra) and: [self scalars = anAlgebra scalars]) ifTrue: [^ self ⊕ anAlgebra].
	^ super × anAlgebra! !

!FiniteAlgebra methodsFor: 'operations' stamp: 'len 7/6/2021 14:43:18'!
centroid
	"Answer the centroid of the receiver as a subalgebra of the algebra of endomorphisms."
	^ self notYetImplemented! !

!FiniteAlgebra methodsFor: 'operations' stamp: 'len 10/18/2023 18:28:49'!
decomposition
	"Answer a list of idecomposable two-sided ideals whose direct sum is isomorphic to the receiver (as algebra), equipped with projection maps."
	"See W. Eberly and M. Giesbrecht, 'Efficient Decomposition of Associative Algebras' (1996)."
	self flag: #fixme.
	"- this message name conflicts with ModularIntegerRing>>decomposition;
	- should return a list of ideals or a list (or a product) of subalgebras?
	- can also implement centralIdempotents
	- there's also composition series and composition factors (for more general distributive algebras?)
	"
	^ self notYetImplemented! !

!FiniteAlgebra methodsFor: 'operations' stamp: 'len 1/30/2022 05:37:57'!
derivations
	"Answer the derivation algebra of the receiver as a Lie subalgebra of the algebra of endomorphisms."
	^ self notYetImplemented! !

!FiniteAlgebra methodsFor: 'operations' stamp: 'len 6/14/2024 15:18:39'!
opposite
	(self isCommutative or: [self isInvolutive]) ifTrue: [^ self].
	^ self propertyAt: #opposite ifAbsentPut: [(self species one: self asModule !! self one multiplication: (BilinearMap on: self asModule mapWithArguments: [:x :y| self multiplicationBilinearMap value: y value: x])) propertyAt: #opposite put: self; yourself]! !

!FiniteAlgebra methodsFor: 'operations' stamp: 'len 12/18/2023 10:13:05'!
sub: aCollection
	"Answer the subalgebra generated by the argument, which can be either a collection containing any objects that can be coerced to the receiver, or a submodule of the reciver's underlying module."
	self isAmbient ifFalse: [^ self ambient sub: aCollection].
	((aCollection isKindOf: Module) and: [aCollection ⊆ self asModule])
		ifTrue: [^ self species new ambient: self; module: aCollection].
	^ self species new ambient: self; module: (self asModule sub: (aCollection collect: [:each| each asModuleElement]))! !

!FiniteAlgebra methodsFor: 'operations' stamp: 'len 6/14/2024 15:19:20'!
⊕ anAlgebra
	"Answer the direct sum of the receiver with the argument."
	| answer multiplication one coprojections projections |
	((anAlgebra isKindOf: FiniteAlgebra) and: [self scalars = anAlgebra scalars]) ifFalse: [^ super ⊕ anAlgebra].
	multiplication := self multiplicationBilinearMap ⊕ anAlgebra multiplicationBilinearMap.
	projections := multiplication domain first ⇉ {self asModule. anAlgebra asModule}.
	coprojections := multiplication domain first ⇇ {self asModule. anAlgebra asModule}.
	one := (coprojections first value: self asModule !! self one) + (coprojections second value: anAlgebra asModule !! anAlgebra one).
	answer := self species one: one multiplication: multiplication.
	answer
		addProjections: (projections with: {self. anAlgebra} collect: [:π :codomain| answer ⇒ codomain !! π]);
		addCoprojections: (coprojections with: {self. anAlgebra} collect: [:i :domain| domain ⇒ answer !! i]).
	^ answer! !

!FiniteAlgebra methodsFor: 'printing' stamp: 'len 7/7/2020 06:45:00'!
printOn: aStream
	self isAmbient ifTrue: [aStream print: self asModule. ^ self].
	self isTrivial ifTrue: [aStream print: 0. ^ self].
	aStream nextPut: $<.
	self generators do: [:each| aStream print: each] separatedBy: [aStream nextPutAll: '; '].
	aStream nextPut: $>! !

!FiniteAlgebra methodsFor: 'testing' stamp: 'len 7/7/2020 07:32:23'!
contains: anElement
	self isAmbient ifTrue: [^ true].
	^ self asModule contains: anElement asModuleElement! !

!FiniteAlgebra methodsFor: 'testing' stamp: 'len 7/7/2020 07:31:51'!
includes: anObject
	self isAmbient ifTrue: [^ anObject parent = self].
	^ (self ambient includes: anObject) and: [self contains: anObject]! !

!FiniteAlgebra methodsFor: 'testing' stamp: 'len 10/15/2022 09:57:26'!
isField
	^ super isField

"alternative:
	self isFinite ifFalse: [^ super isField].
	^ self propertyAt: #isField
		ifAbsentPut:
		[self isCommutative and: [self characteristic isPrime and: [(self to: self map: [:x| x ^ self characteristic]) isInjective]]]"! !

!FiniteAlgebra methodsFor: 'testing' stamp: 'len 9/8/2023 17:42:21'!
isFiniteAlgebra
	^ true! !

!FiniteAlgebra methodsFor: 'testing' stamp: 'len 8/21/2024 14:55:07'!
isFinitelyGeneratedAlgebra
	^ true! !

!FiniteAlgebra methodsFor: 'testing' stamp: 'len 6/2/2022 13:06:09'!
isNoetherian
	"Finite algebras are Noetherian because they are finitely generated as modules."
	^ true! !

!FiniteAlgebra methodsFor: 'testing' stamp: 'len 6/11/2020 12:20:40'!
isTrivial
	^ self asModule isTrivial! !

!FiniteAlgebra methodsFor: 'private' stamp: 'len 12/18/2022 20:04:34'!
module: aModule
	self propertyAt: #asModule put: aModule.
	self addCoercionTo: aModule map: [:each| each asModuleElement]! !

!FiniteAlgebra methodsFor: 'private' stamp: 'len 6/14/2024 15:18:18'!
one: aModuleElement multiplication: aBilinearMap
	| V |
	V := aBilinearMap domain at: 1.
	self module: V.
	self propertyAt: #multiplicationBilinearMap put: aBilinearMap.
	self propertyAt: #one put: (self fromModuleElement: aModuleElement)! !

!FiniteAlgebra methodsFor: 'private' stamp: 'len 6/29/2022 07:30:41'!
species
	^ FiniteAlgebra! !

!FiniteAlgebra class methodsFor: 'instance creation' stamp: 'len 11/4/2022 09:38:10'!
one: aModuleElement multiplication: aBilinearMap
	^ self new one: aModuleElement multiplication: aBilinearMap! !

!Order methodsFor: 'morphisms' stamp: 'len 6/1/2024 07:06:07'!
to: aRing
	aRing = self ambient fractions ifTrue: [^ self addMap: (self to: aRing map: [:x| aRing !! x])].
	self ambient fractions ⇢ aRing ifNotNil: [:aMorphism| ^ aMorphism · (self → self ambient fractions)].
	^ super to: aRing! !

!Order methodsFor: 'testing' stamp: 'len 7/15/2021 16:31:59'!
isField
	^ false! !

!Order methodsFor: 'testing' stamp: 'len 1/1/2022 11:50:53'!
isIntegralDomain
	^ true! !

!Order methodsFor: 'testing' stamp: 'len 7/15/2021 16:31:42'!
isIntegrallyClosedDomain
	^ true! !

!Order methodsFor: 'private' stamp: 'len 7/7/2023 12:11:17'!
idealClass
	^ IntegralIdeal! !

!Order methodsFor: 'private' stamp: 'len 7/15/2021 15:44:21'!
species
	^ Order! !

!MaximalOrder methodsFor: 'accessing' stamp: 'len 7/10/2021 11:37:20'!
degree
	^ self fractions degree! !

!MaximalOrder methodsFor: 'elements' stamp: 'len 5/30/2022 12:37:28'!
adapt: anElement
	(self fractions includes: anElement) ifTrue:
		[| coordinates |
		coordinates _ self fractions integralBasisMatrix \ (self fractions asVectorSpace !! anElement).
		^ (coordinates allSatisfy: [:each| each isIntegral]) ifTrue: [self fromModuleElement: (self asModule elementAt: coordinates)]].
	^ super adapt: anElement! !

!MaximalOrder methodsFor: 'elements' stamp: 'len 7/15/2021 16:51:25'!
fromModuleElement: anElement
	^ AlgebraicInteger parent: self moduleElement: anElement! !

!MaximalOrder methodsFor: 'operations' stamp: 'len 7/10/2021 11:37:54'!
fractions
	"Answer the abient number field.
	NOTE: Magma does this differently, the fractions field of a number ring is not its ambient field but an isomorphic field made of formal fractions with denominator a rational integer."
	^ self propertyAt: #fractions! !

!MaximalOrder methodsFor: 'printing' stamp: 'len 8/9/2022 10:29:38'!
printOn: aStream
	aStream nextPut: $𝕆; nextPut: $(; print: self fractions; nextPut: $)! !

!MaximalOrder methodsFor: 'random' stamp: 'len 6/25/2023 11:39:34'!
unitAtRandom: aRandom
	| f |
	[f := self scalars polynomials atRandom: aRandom maxDegree: self degree - 2.
	f := f << 1 + (self scalars units atRandom: aRandom) + (self scalars polynomials x: 1 to: self degree).
	f := f over: self fractions.
	f roots do: [:each| ^ self !! each]] repeat! !

!MaximalOrder methodsFor: 'random' stamp: 'len 6/25/2023 11:39:46'!
unitAtRandom: aRandom bits: bitSize
	| f |
	[f := self scalars polynomials atRandom: aRandom bits: bitSize maxDegree: self degree - 2.
	f := f << 1 + (self scalars units atRandom: aRandom) + (self scalars polynomials x: 1 to: self degree).
	f := f over: self fractions.
	f roots do: [:each| ^ self !! each]] repeat! !

!MaximalOrder methodsFor: 'testing' stamp: 'len 7/15/2021 16:51:30'!
isDedekindDomain
	"Rings of integers of number fields or function fields are Dedekind domains."
	^ true! !

!MaximalOrder methodsFor: 'testing' stamp: 'len 1/4/2022 15:11:18'!
isInvolutive
	^ self fractions isInvolutive! !

!MaximalOrder methodsFor: 'testing' stamp: 'len 12/23/2021 19:18:20'!
isPID
	"A Dedekind domain is a UFD iff it is a PID."
	self flag: #fix. "for now ignore the PID structure"
	^ super isPID
"	^ self fractions classNumber = 1"! !

!MaximalOrder methodsFor: 'testing' stamp: 'len 7/12/2021 13:19:16'!
isPIR
	^ self isPID! !

!MaximalOrder methodsFor: 'testing' stamp: 'len 6/16/2022 18:25:19'!
isUFR
	"A Dedekind domain is a UFR iff it is a PID."
	^ self isPID! !

!MaximalOrder methodsFor: 'private' stamp: 'len 11/5/2022 13:55:03'!
fractions: aNumberField
	| M B |
	self propertyAt: #fractions put: aNumberField.
	self propertyAt: #asModule put: (M _ aNumberField scalars integers ^ aNumberField degree).
	B _ aNumberField integralBasisMatrix.
	self one: (self !! aNumberField one) asModuleElement multiplication:
		(BilinearMap from: M, M to: M mapWithArguments: [:x :y|
			(self !! ((aNumberField !! (B * x)) * (aNumberField !! (B * y)))) asModuleElement])! !

!MaximalOrder class methodsFor: 'instance creation' stamp: 'len 7/10/2021 11:38:54'!
on: aNumberField
	^ self new fractions: aNumberField! !

!CyclotomicRing methodsFor: 'operations' stamp: 'len 11/23/2023 09:59:17'!
cyclotomicUnits
	"Answer the group of cyclotomic units of the receiver.
	This is a finite index subgroup of the unit group."
	| m ζ C d |
	m := self fractions conductor.
	m isPrimePower ifFalse: [^ self notYetImplemented].
	ζ := self !! self fractions x.
	C := Set new.
	C add: ζ; add: ζ negated.
	d := ζ - 1.
	1 to: m do: [:i| C add: ζ^i - 1 / d].
	C := C reject: [:each| each isZero].
	^ self units sub: C! !

!CyclotomicRing methodsFor: 'printing' stamp: 'len 7/10/2021 11:36:14'!
printOn: aStream
	aStream print: ℤ; nextPut: $[; print: self fractions x; nextPut: $]! !

!CyclotomicRing methodsFor: 'testing' stamp: 'len 11/23/2023 09:59:23'!
isPID
	"See [MM76]."
	^ #(1 3 4 5 7 8 9 11 12 13 15 16 17 19 20 21 24 25 27 28 32 33 35 36 40 44 45 48 60 84) includes: self fractions conductor! !

!CyclotomicRing class methodsFor: 'instance creation' stamp: 'len 6/3/2023 11:17:31'!
new: anInteger
	^ self on: (CyclotomicField new: anInteger)! !

!EisensteinRing methodsFor: 'accessing' stamp: 'len 10/17/2022 11:58:28'!
unitsSize
	"Answer the order of the units group."
	^ 6! !

!EisensteinRing methodsFor: 'accessing' stamp: 'len 10/17/2022 12:02:00'!
ω
	^ self !! self fractions x! !

!EisensteinRing methodsFor: 'elements' stamp: 'len 10/17/2022 09:51:11'!
fromModuleElement: anElement
	^ EisensteinInteger parent: self moduleElement: anElement! !

!EisensteinRing methodsFor: 'enumerating' stamp: 'len 10/17/2022 11:59:17'!
unitsDo: aBlock
	^ self unitsList do: aBlock! !

!EisensteinRing methodsFor: 'random' stamp: 'len 10/17/2022 11:59:47'!
unitAtRandom: aRandom
	^ self unitsList atRandom: aRandom! !

!EisensteinRing methodsFor: 'random' stamp: 'len 10/17/2022 11:59:59'!
unitAtRandom: aRandom bits: bitSize
	^ self unitAtRandom: aRandom! !

!EisensteinRing methodsFor: 'testing' stamp: 'len 5/28/2023 17:56:08'!
hasCanonicalAssociates
	^ true! !

!EisensteinRing methodsFor: 'testing' stamp: 'len 10/17/2022 09:48:33'!
isEuclidean
	"Answer true if the receiver is a Euclidean ring, i.e. it has Euclidean division with remainder."
	^ true! !

!EisensteinRing methodsFor: 'private' stamp: 'len 10/17/2022 12:01:31'!
unitsList
	^ self propertyAt: #unitsList ifAbsentPut: [{self one. self one negated. self ω. self ω negated. self ω squared. self ω squared negated}]! !

!EisensteinRing class methodsFor: 'instance creation' stamp: 'len 6/3/2023 11:20:46'!
new
	^ self on: (CyclotomicField new: 3)! !

!EisensteinRing class methodsFor: 'instance creation' stamp: 'len 6/3/2023 11:20:06'!
on: anEisensteinField
	^ super new fractions: anEisensteinField! !

!GaussianRing methodsFor: 'elements' stamp: 'len 1/4/2022 12:25:38'!
fromModuleElement: anElement
	^ GaussianInteger parent: self moduleElement: anElement! !

!GaussianRing methodsFor: 'elements' stamp: 'len 1/4/2022 14:52:19'!
i
	^ self real: 0 imaginary: 1! !

!GaussianRing methodsFor: 'elements' stamp: 'len 1/4/2022 14:48:59'!
real: anInteger imaginary: anotherInteger
	^ self fromModuleElement: (self asModule elementAt: {anInteger. anotherInteger})! !

!GaussianRing methodsFor: 'testing' stamp: 'len 6/3/2022 06:00:46'!
hasCanonicalAssociates
	^ true! !

!GaussianRing methodsFor: 'testing' stamp: 'len 6/3/2022 20:42:03'!
hasCanonicalReduction
	^ true! !

!GaussianRing methodsFor: 'testing' stamp: 'len 6/3/2022 07:08:30'!
isEuclidean
	"Answer true if the receiver is a Euclidean ring, i.e. it has Euclidean division with remainder."
	^ true! !

!GaussianRing class methodsFor: 'instance creation' stamp: 'len 11/5/2023 21:31:57'!
new
	^ self on: (CyclotomicField new: 4)! !

!GaussianRing class methodsFor: 'instance creation' stamp: 'len 6/3/2023 11:25:42'!
on: aGaussianField
	^ super new fractions: aGaussianField! !

!QuadraticRing methodsFor: 'accessing' stamp: 'len 11/8/2023 13:27:33'!
unitsSize
	"Answer the order of the units group."
	| d |
	(d := self fractions d) < 0 ifFalse: [^ ℕ size].
	d = -1 ifTrue: [^ 4].
	d = -3 ifTrue: [^ 6].
	^ 2! !

!QuadraticRing methodsFor: 'elements' stamp: 'len 1/4/2022 12:25:51'!
fromModuleElement: anElement
	^ QuadraticInteger parent: self moduleElement: anElement! !

!QuadraticRing methodsFor: 'enumerating' stamp: 'len 5/30/2022 12:46:40'!
unitsDo: aBlock
	self fractions d < 0 ifFalse: [^ super unitsDo: aBlock].
	^ self unitsList do: aBlock! !

!QuadraticRing methodsFor: 'printing' stamp: 'len 7/10/2021 11:37:11'!
printOn: aStream
	| K a |
	K _ self fractions.
	a _ K d \\ 4 = 1 ifTrue: [K x + K one / (K one * 2)] ifFalse: [K x].
	aStream print: ℤ; nextPut: $[; print: a; nextPut: $]! !

!QuadraticRing methodsFor: 'random' stamp: 'len 5/30/2022 12:46:13'!
unitAtRandom: aRandom
	self fractions d < 0 ifFalse: [^ super unitAtRandom: aRandom].
	^ self unitsList atRandom: aRandom! !

!QuadraticRing methodsFor: 'random' stamp: 'len 5/30/2022 12:46:45'!
unitAtRandom: aRandom bits: bitSize
	self fractions d < 0 ifFalse: [^ super unitAtRandom: aRandom bits: bitSize].
	^ self unitsList atRandom: aRandom! !

!QuadraticRing methodsFor: 'testing' stamp: 'len 5/28/2023 19:24:03'!
hasCanonicalAssociates
	^ self unitsSize isFinite! !

!QuadraticRing methodsFor: 'testing' stamp: 'len 6/3/2022 07:08:19'!
isEuclidean
	"Answer true if the receiver is a Euclidean ring, i.e. it has Euclidean division with remainder.
	Warning: it might be Euclidean, but in the constructive setting we may not have a way to testing if it is, or we may not have an implementation of Euclidean division."
	^ false
	
"	self fractions d negative ifFalse: [self notYetImplemented].
	(#(-11 -7 -3 -2 -1) includes: self fractions d) ifFalse: [^ false].
	self notYetImplemented"
! !

!QuadraticRing methodsFor: 'testing' stamp: 'len 7/10/2021 11:36:41'!
isNormEuclidean
	^ #(-11 -7 -3 -2 -1 2 3 5 6 7 11 13 17 19 21 29 33 37 41 57 73) includes: self fractions d! !

!QuadraticRing methodsFor: 'testing' stamp: 'len 6/3/2023 11:57:45'!
isPID
	self fractions d negative ifTrue: [^ #(-1 -2 -3 -7 -11 -19 -43 -67 -163) includes: self fractions d].
	^ super isPID! !

!QuadraticRing methodsFor: 'private' stamp: 'len 5/30/2022 12:46:34'!
unitsList
	| d list |
	self propertyAt: #unitsList ifPresent: [:aCollection| ^ aCollection].
	(d _ self fractions d < 0) ifFalse: [^ self error: 'infinite units'].
	list _ OrderedCollection new.
	list add: self one; add: self one negated.
	d = -1 ifTrue:
		[| i |
		i _ self !! self fractions x.
		list add: i; add: i negated].
	d = -3 ifTrue:
		[| x |
		x _ self fractions x.
		list add: self !! (1 + x / 2); add: self !! (1 - x / 2); add: self !! (-1 + x / 2); add: self !! (-1 - x / 2)].
	^ self propertyAt: #unitsList put: list asArray! !

!QuadraticRing class methodsFor: 'instance creation' stamp: 'len 6/3/2023 11:24:47'!
new: anInteger
	^ self on: (QuadraticField new: anInteger)! !

!CliffordAlgebra methodsFor: 'accessing' stamp: 'len 7/5/2020 09:59:31'!
degree
	^ self space rank! !

!CliffordAlgebra methodsFor: 'accessing' stamp: 'len 9/18/2023 12:14:14'!
evenSubalgebra
	"Answer the subalgebra of the receiver spanned by the product of an even number of basis elements of the receiver. This are the fixed points of the main involution."
	^ self sub: (((1 to: self asModule rank) select: [:i| (i-1) bitParity = 0]) collect: [:i| self basis at: i])! !

!CliffordAlgebra methodsFor: 'accessing' stamp: 'len 7/7/2020 10:44:05'!
generators
	^ self propertyAt: #generators ifAbsentPut: [(0 to: self degree - 1) collect: [:i| self basis at: 1 << i + 1]]! !

!CliffordAlgebra methodsFor: 'accessing' stamp: 'len 9/18/2023 12:14:22'!
grade: anInteger
	"Answer the subalgebra of grade anInteger."
	^ self sub: (((1 to: self asModule rank) select: [:i| (i - 1) bitCount = anInteger]) collect: [:i| self basis at: i])! !

!CliffordAlgebra methodsFor: 'accessing' stamp: 'len 11/5/2022 13:45:22'!
one
	^ self basis first! !

!CliffordAlgebra methodsFor: 'accessing' stamp: 'len 7/22/2020 13:18:15'!
orthogonalBasis
	"Answer an orthogonal basis of the vector space V that the receiver acts on.
	The embedding of V in the receiver is built such that the i-th element of the orthogonal basis is sent to the (2^(i-1) + 1)-th element of the basis of the receiver."
	^ self propertyAt: #orthogonalBasis! !

!CliffordAlgebra methodsFor: 'accessing' stamp: 'len 7/19/2020 20:14:50'!
pseudoscalar
	"Answer the unit pseudoscalar."
	^ self basis last! !

!CliffordAlgebra methodsFor: 'accessing' stamp: 'len 7/20/2020 06:33:54'!
pseudoscalarInverse
	^ self propertyAt: #pseudoscalarInverse ifAbsentPut: [self pseudoscalar inverse]! !

!CliffordAlgebra methodsFor: 'accessing' stamp: 'len 7/28/2020 11:00:15'!
quadraticForm
	"Answer the quadratic form associated to the receiver."
	^ self propertyAt: #quadraticForm! !

!CliffordAlgebra methodsFor: 'accessing' stamp: 'len 7/28/2020 11:00:59'!
space
	"Answer the space this Clifford algebra acts on."
	^ self quadraticForm domain! !

!CliffordAlgebra methodsFor: 'elements' stamp: 'len 7/16/2020 09:30:59'!
fromModuleElement: anElement
	^ Multivector parent: self moduleElement: anElement! !

!CliffordAlgebra methodsFor: 'morphisms' stamp: 'len 9/16/2022 07:57:21'!
antiautomorphism
	"Answer the main antiautomorphism of the receiver. This is the map that reverses the multiplication."
	^ self to: self map: [:x| x transpose]! !

!CliffordAlgebra methodsFor: 'morphisms' stamp: 'len 9/16/2022 07:57:26'!
involution
	"Answer the main involution of the receiver. This is an automorphism J such that J(u) = u if u is in the even subalgebra, and J(u) = -u if u is in the odd subspace."
	^ self to: self map: [:x| x reflection]! !

!CliffordAlgebra methodsFor: 'printing' stamp: 'len 8/12/2022 13:36:55'!
printOn: aStream
	aStream
		nextPutAll: (self isExteriorAlgebra ifTrue: ['⋀'] ifFalse: ['Cl']);
		nextPut: $(; print: self space; nextPutAll: ', '; print: self quadraticForm; nextPut: $)! !

!CliffordAlgebra methodsFor: 'testing' stamp: 'len 7/7/2020 19:48:03'!
isCommutative
	^ self space rank < 2! !

!CliffordAlgebra methodsFor: 'testing' stamp: 'len 7/28/2020 11:00:32'!
isExteriorAlgebra
	^ self quadraticForm isZero! !

!CliffordAlgebra methodsFor: 'testing' stamp: 'len 7/21/2021 16:01:40'!
isInvolutive
	^ true! !

!CliffordAlgebra methodsFor: 'private' stamp: 'len 4/11/2024 05:43:14'!
quadraticForm: aQuadraticForm
	| V n basis C T table |
	self propertyAt: #quadraticForm put: aQuadraticForm.
	V := aQuadraticForm domain.
	n := V rank.
	basis := aQuadraticForm polarization orthogonalizationOf: V basis.
	self propertyAt: #orthogonalBasis put: basis.
	C := V scalars ^ (2 ^ n).
	self module: C.
	"The embedding of V in the receiver is built such that the i-th element of the computed orthogonal basis is sent to the (2^(i-1) + 1)-th element of the basis of the receiver:"
	T := (V to: C images: ((1 to: n) collect: [:i| C basis at: 1 << (i-1) + 1])) · (V endomorphisms images: basis) inverse.
	self addCoercionFrom: V map: [:v| self fromModuleElement: (T value: v)].
	"Compute the multiplication table of the basis elements:"
	table := (0 to: self rank - 1) collect: [:x|
		(0 to: self rank - 1) collect: [:y|
			| scalar index |
			scalar := self scalars one.
			index := x.
			1 to: self degree do: [:i|
				(y bitAt: i) = 1 ifTrue:
					[(index >> i) bitParity = 1 ifTrue: [scalar := scalar negated].
					(index bitAt: i) = 1 ifTrue: [scalar := scalar * (aQuadraticForm value: (basis at: i))].
					index := index bitXor: 1 << (i - 1)]].
			{index + 1. scalar}]].
	self propertyAt: #basisMultiplicationTable put: table! !

!CliffordAlgebra class methodsFor: 'instance creation' stamp: 'len 7/28/2020 10:59:55'!
on: aQuadraticForm
	^ self new quadraticForm: aQuadraticForm! !

!GroupAlgebra methodsFor: 'accessing' stamp: 'len 11/23/2022 21:25:15'!
eta
	| one |
	one _ self scalars one.
	^ self asModule fill: [:i| one]! !

!GroupAlgebra methodsFor: 'accessing' stamp: 'len 7/14/2020 11:46:46'!
generators
	^ (self group generators ifNil: [^ nil]) collect: [:each| self !! each]! !

!GroupAlgebra methodsFor: 'accessing' stamp: 'len 7/14/2020 11:38:18'!
group
	^ self propertyAt: #group! !

!GroupAlgebra methodsFor: 'accessing' stamp: 'len 7/14/2020 11:46:00'!
one
	^ self !! self group identity! !

!GroupAlgebra methodsFor: 'elements' stamp: 'len 12/22/2021 14:11:49'!
adapt: anElement
	(self group includes: anElement)
		ifTrue: [^ self !! (self asModule generatorNamed: anElement)].
	(self scalars includes: anElement)
		ifTrue: [^ self one * anElement].
	^ super adapt: anElement! !

!GroupAlgebra methodsFor: 'elements' stamp: 'len 7/25/2021 10:20:09'!
fromModuleElement: anElement
	^ GroupAlgebraElement parent: self moduleElement: anElement! !

!GroupAlgebra methodsFor: 'internalization' stamp: 'len 6/16/2024 08:28:07'!
antipode
	| indexToGroupElement |
	indexToGroupElement := self propertyAt: #indexToGroupElement.
	^ self propertyAt: #antipode ifAbsentPut: [self asModule to: self asModule images: (indexToGroupElement collect: [:each| self !! each inverse])]! !

!GroupAlgebra methodsFor: 'internalization' stamp: 'len 8/31/2024 18:25:47'!
asBialgebra
	| M I |
	M := self asModule.
	I := self scalars asIdeal.
	^ self scalars bialgebras
		multiplication: (M with: M to: M map: [:x :y| self !! x * (self !! y)])
		unit: (I to: M map: [:x| self one * x])
		comultiplication: self comultiplication
		counit: self counit
		"antipode: self antipode"! !

!GroupAlgebra methodsFor: 'internalization' stamp: 'len 8/31/2024 14:25:32'!
comultiplication
	self flag: #fixme. "this is a bimonoid in Ab, it should be a map of abelian groups"
	^ self asModule to: self asModule ⊗ self asModule map: [:x| (x ⊗ x) asTuple]! !

!GroupAlgebra methodsFor: 'internalization' stamp: 'len 8/19/2024 14:00:44'!
counit
	^ self asModule to: self scalars asIdeal map: [:x| self scalars one]

"or without assuming this is evaluated at each canonical basis element:
	^ self asModule to: self scalars asIdeal map: [:x| x sum]"! !

!GroupAlgebra methodsFor: 'morphisms' stamp: 'len 6/26/2024 09:04:09'!
involution
	^ self propertyAt: #involution ifAbsentPut: [self to: self moduleMap: self antipode]! !

!GroupAlgebra methodsFor: 'printing' stamp: 'len 8/7/2016 08:38'!
printOn: aStream
	aStream print: self scalars; nextPut: $[; print: self group; nextPut: $]! !

!GroupAlgebra methodsFor: 'testing' stamp: 'len 7/14/2020 11:27:08'!
isCommutative
	^ self group isCommutative! !

!GroupAlgebra methodsFor: 'testing' stamp: 'len 7/31/2021 12:44:56'!
isField
	^ self scalars isField and: [self group isTrivial] "??? is this right?"! !

!GroupAlgebra methodsFor: 'testing' stamp: 'len 7/21/2021 16:26:50'!
isInvolutive
	^ true! !

!GroupAlgebra methodsFor: 'private' stamp: 'len 6/16/2024 10:02:49'!
group: aGroup scalars: aRing
	| indexToGroupElement groupElementToIndex V |
	aGroup isFinite ifFalse: [^ self notYetImplemented].
	self propertyAt: #group put: aGroup.
	indexToGroupElement := aGroup asArray.
	"make sure the identity element is at the first index:"
	indexToGroupElement swap: 1 with: (indexToGroupElement indexOf: aGroup identity).
	groupElementToIndex := Dictionary new.
	indexToGroupElement withIndexDo: [:g :i| groupElementToIndex at: g put: i].
	V := aRing^indexToGroupElement.
	self module: V.
	self propertyAt: #indexToGroupElement put: indexToGroupElement.
	self propertyAt: #groupElementToIndex put: groupElementToIndex! !

!GroupAlgebra class methodsFor: 'instance creation' stamp: 'len 7/14/2020 11:43:10'!
on: aGroup over: aRing
	^ self new group: aGroup scalars: aRing! !

!QuaternionAlgebra methodsFor: 'accessing' stamp: 'len 7/2/2020 13:06:25'!
generators
	^ self propertyAt: #generators ifAbsentPut: [{self i. self j}]! !

!QuaternionAlgebra methodsFor: 'accessing' stamp: 'len 7/2/2020 13:05:58'!
i
	^ self basis at: 2! !

!QuaternionAlgebra methodsFor: 'accessing' stamp: 'len 7/14/2020 10:08:51'!
invariants
	"Answer the invariants a,b of this quaternion algebra."
	^ self propertyAt: #invariants ifAbsentPut: [{self i squared asScalar. self j squared asScalar}]! !

!QuaternionAlgebra methodsFor: 'accessing' stamp: 'len 7/2/2020 13:06:04'!
j
	^ self basis at: 3! !

!QuaternionAlgebra methodsFor: 'accessing' stamp: 'len 7/2/2020 13:06:12'!
k
	^ self basis at: 4! !

!QuaternionAlgebra methodsFor: 'elements' stamp: 'len 7/16/2020 09:31:53'!
fromModuleElement: anElement
	^ Quaternion parent: self moduleElement: anElement! !

!QuaternionAlgebra methodsFor: 'printing' stamp: 'len 10/6/2022 11:20:21'!
printOn: aStream
	(self invariants allSatisfy: [:each| each = self scalars one])
		ifTrue: [aStream nextPut: $𝕃]
		ifFalse:
			[aStream nextPut: $ℍ.
			(self invariants allSatisfy: [:each| each = self scalars one negated])
				ifFalse: [aStream nextPutAll: (self invariants first printString, ',', self invariants second printString) sub]].
	aStream nextPut: $(; print: self scalars; nextPut: $)
"	aStream print: self invariants; nextPutAll: self scalars printString sub"! !

!QuaternionAlgebra methodsFor: 'testing' stamp: 'len 6/11/2020 19:36:38'!
isCentral
	^ true! !

!QuaternionAlgebra methodsFor: 'testing' stamp: 'len 6/11/2020 19:30:56'!
isCommutative
	"Quaternion algebras are always noncommutative."
	^ false! !

!QuaternionAlgebra methodsFor: 'testing' stamp: 'len 11/22/2023 20:51:51'!
isDivisionRing
	"A division ring, or skewfield, is a ring where division is possible, i.e. every nonzero element has a multiplicative inverse. The only difference with a field is that a division ring is not requiered to be commutative.
	An algebra is called a 'division algebra' if ax=b and xa=b have unique solutions for nonzero a.
	If the receiver is not a division algebra, it is isomorphic to the algebra of 2×2 matrices."
	self scalars = ℚ ifTrue: [^ self discriminant ~= self scalars one].
	^ super isDivisionRing! !

!QuaternionAlgebra methodsFor: 'testing' stamp: 'len 7/21/2021 16:01:23'!
isInvolutive
	^ true! !

!QuaternionAlgebra methodsFor: 'testing' stamp: 'len 6/11/2020 19:36:34'!
isSimple
	^ true! !

!QuaternionAlgebra class methodsFor: 'instance creation' stamp: 'len 4/5/2024 19:07:35'!
over: aRing invariants: anArray
	"Given invariants a and b, answer the quaternion algebra over aRing (of characteristic not 2) generated by i and j such that:
		i^2 = a,
		j^2 = b,
		ji = -ij."
	| a b V u i j k |
	(anArray size = 2 and: [(a := aRing !! (anArray at: 1)) isUnit and: [(b := aRing !! (anArray at: 2)) isUnit]])
		ifFalse: [^ Error signal].
	V := aRing^4.
	u := V x: 1.
	i := V x: 2.
	j := V x: 3.
	k := V x: 4.
	^ super one: V generators first multiplication: (BilinearMap on: V table:
		{
		{u. i. j. k}.
		{i. u*a. k. j*a}.
		{j. k*-1. u*b. i*b*-1}.
		{k. j*a*-1.  i*b. u*a*b*-1}})! !

!FreeAlgebra methodsFor: 'accessing' stamp: 'len 4/28/2022 07:44:16'!
characteristic
	^ scalars characteristic! !

!FreeAlgebra methodsFor: 'accessing' stamp: 'len 8/23/2024 08:48:46'!
freeCover
	^ self! !

!FreeAlgebra methodsFor: 'accessing' stamp: 'len 7/1/2022 11:34:41'!
generators
	"Answer the generators of the receiver as an algebra over the coefficients ring."
	^ (1 to: self rank) collect: [:i| self x: i]! !

!FreeAlgebra methodsFor: 'accessing' stamp: 'len 4/28/2022 07:42:05'!
indeterminates
	^ 1 to: self rank! !

!FreeAlgebra methodsFor: 'accessing' stamp: 'len 6/29/2022 06:35:49'!
monomials
	^ monomials! !

!FreeAlgebra methodsFor: 'accessing' stamp: 'len 6/29/2022 06:37:30'!
names
	"Answer the indeterminate names to use when printing polynomials."
	^ monomials names! !

!FreeAlgebra methodsFor: 'accessing' stamp: 'len 6/29/2022 06:37:34'!
names: anArray
	"Set indeterminate names to use when printing polynomials."
	monomials names: anArray! !

!FreeAlgebra methodsFor: 'accessing' stamp: 'len 4/28/2022 07:54:11'!
one
	^ self propertyAt: #one ifAbsentPut: [self constant: self scalars one]! !

!FreeAlgebra methodsFor: 'accessing' stamp: 'len 6/29/2022 06:37:38'!
rank
	^ monomials rank! !

!FreeAlgebra methodsFor: 'accessing' stamp: 'len 1/20/2016 14:58'!
scalars
	^ scalars! !

!FreeAlgebra methodsFor: 'accessing' stamp: 'len 6/29/2022 06:37:42'!
size
	^ monomials size * scalars size! !

!FreeAlgebra methodsFor: 'comparing' stamp: 'len 6/29/2022 06:36:12'!
= anObject
	self == anObject ifTrue: [^ true].
	^ self class = anObject class and: [scalars = anObject scalars and: [monomials = anObject monomials]]! !

!FreeAlgebra methodsFor: 'comparing' stamp: 'len 6/29/2022 06:37:16'!
hash
	^ scalars hash + monomials hash hashMultiply! !

!FreeAlgebra methodsFor: 'elements' stamp: 'len 6/29/2022 06:37:00'!
adapt: anElement
	(anElement isInteger or: [anElement isFraction])
		ifTrue: [^ self constant: scalars !! anElement].
	(scalars includes: anElement)
		ifTrue: [^ self constant: anElement].
	(monomials includes: anElement)
		ifTrue: [^ self coefficient: scalars one word: anElement].
	(super adapt: anElement) ifNotNil: [:aPolynomial| ^ aPolynomial].
	(anElement isKindOf: FreePolynomial) ifFalse: [^ nil].
	(anElement indeterminates allSatisfy: [:each| each <= self rank]) ifFalse: [^ nil]. "unknown indeterminates present"
	^ self associations: anElement associations! !

!FreeAlgebra methodsFor: 'elements' stamp: 'len 8/21/2022 08:15:14'!
associations: aCollection
	"Answer a polynomial created from a list of  'monomial -> coefficient' associations.
	Assume no repeated monomials."
	| associations |
	associations _ OrderedCollection new: aCollection size.
	associations resetTo: 1.
	aCollection do: [:each| | coefficient |
		"WARNING: this assumes no repeated monomials"
		(coefficient _ scalars !! each value) isZero ifFalse: [associations add: (monomials !! each key) -> coefficient]].
	associations sort.
	^ FreePolynomial coefficients: (SortedDictionary associations: associations) parent: self! !

!FreeAlgebra methodsFor: 'elements' stamp: 'len 4/28/2022 07:47:34'!
coefficient: aNumber word: aWord
	aNumber isZero ifTrue: [^ self zero].
	^ self associations: {aWord -> aNumber}! !

!FreeAlgebra methodsFor: 'elements' stamp: 'len 6/29/2022 06:37:12'!
constant: aNumber
	^ self associations: {monomials identity -> aNumber}! !

!FreeAlgebra methodsFor: 'elements' stamp: 'len 8/25/2016 08:21'!
x
	^ self x: self indeterminates first! !

!FreeAlgebra methodsFor: 'elements' stamp: 'len 4/28/2022 07:48:58'!
x: anInteger
	^ self x: anInteger to: 1! !

!FreeAlgebra methodsFor: 'elements' stamp: 'len 6/29/2022 06:37:47'!
x: anIndeterminate to: anInteger
	^ self coefficient: scalars one word: (monomials x: anIndeterminate to: anInteger)! !

!FreeAlgebra methodsFor: 'elements' stamp: 'len 8/25/2016 08:22'!
y
	^ self x: self indeterminates second! !

!FreeAlgebra methodsFor: 'elements' stamp: 'len 8/25/2016 08:21'!
z
	^ self x: self indeterminates third! !

!FreeAlgebra methodsFor: 'printing' stamp: 'len 6/3/2023 12:16:55'!
printOn: aStream
	aStream print: scalars.
	aStream withAngleBrackets: [:aStream2|
		self indeterminates
			do: [:i| aStream2 print: (self x: i)]
			separatedBy: [aStream2 nextPut: $,]]! !

!FreeAlgebra methodsFor: 'random' stamp: 'len 6/30/2023 12:45:08'!
atRandom: aRandom bits: bitSize
	^ self atRandom: aRandom bits: bitSize maxDegree: (bitSize ^ (1/self rank) min: bitSize - 1) truncated! !

!FreeAlgebra methodsFor: 'random' stamp: 'len 1/10/2018 13:21:35'!
atRandom: aRandom bits: bitSize maxDegree: d
	| answer n term |
	answer _ self zero.
	n _ 2 ^ self rank.
	n timesRepeat:
		[term _ ((1 to: d) product: [:i| self x: (self rank atRandom: aRandom) to: (2 atRandom: aRandom) - 1]) * (self scalars atRandom: aRandom bits: bitSize/(self rank*d)).
		answer _ answer + term].
	^ answer! !

!FreeAlgebra methodsFor: 'testing' stamp: 'len 4/28/2022 07:50:45'!
includes: anObject
	^ anObject parent = self! !

!FreeAlgebra methodsFor: 'testing' stamp: 'len 6/29/2022 06:37:21'!
isCommutative
	^ monomials isCommutative and: [scalars isCommutative]! !

!FreeAlgebra methodsFor: 'testing' stamp: 'len 6/29/2022 06:37:25'!
isFinite
	^ monomials isFinite and: [scalars isFinite]! !

!FreeAlgebra methodsFor: 'testing' stamp: 'len 8/21/2024 14:50:48'!
isFinitelyGeneratedAlgebra
	^ true! !

!FreeAlgebra methodsFor: 'private' stamp: 'len 6/29/2022 06:38:04'!
monomials: aFreeMonoid
	monomials _ aFreeMonoid! !

!FreeAlgebra methodsFor: 'private' stamp: 'len 1/20/2016 13:39'!
scalars: aCommutativeRing
	scalars _ aCommutativeRing! !

!FreeAlgebra class methodsFor: 'instance creation' stamp: 'len 6/29/2022 06:38:21'!
monomials: aFreeMonoid over: aRing
	^ self new monomials: aFreeMonoid; scalars: aRing! !

!FreeAlgebra class methodsFor: 'instance creation' stamp: 'len 6/29/2022 06:38:30'!
new: anIntegerOrCollection over: aRing
	^ self monomials: (FreeMonoid new: anIntegerOrCollection) over: aRing! !

!Module methodsFor: 'accessing' stamp: 'len 12/17/2022 10:02:44'!
basis
	^ self propertyAt: #basis ifAbsentPut: [self basisMatrix columns collect: [:each| self ambient elementAt: each]]! !

!Module methodsFor: 'accessing' stamp: 'len 1/13/2022 11:59:03'!
basisMatrix
"	(self isFreelyGenerated and: [self scalars isPID]) ifTrue: [^ self generatorMatrix]."
	^ self propertyAt: #basisMatrix ifAbsentPut: [self generatorMatrix basis]! !

!Module methodsFor: 'accessing' stamp: 'len 12/12/2023 19:55:47'!
coordinateRing
	^ self freeCover coordinateRing! !

!Module methodsFor: 'accessing' stamp: 'len 3/14/2020 17:35:03'!
corank
	^ self ambient rank - self rank! !

!Module methodsFor: 'accessing' stamp: 'len 3/11/2020 18:55:41'!
discriminant
	^ self gramian determinant
	
"sage defines it like this for free quadratic modules:
	^ (self rank // 2) even ifTrue: [self gramian determinant] ifFalse: [self gramian determinant negated]
"! !

!Module methodsFor: 'accessing' stamp: 'len 8/29/2024 15:27:14'!
exponent
	"Answer the exponent of the receiver, i.e. the maximum order of an element."
	self assert: self isAbelianGroup.
	^ self invariants inject: 1 into: [:last :each| last lcm: each]

"alternative:
	^ (ℤ asAbelianGroup to: self endomorphisms asModule map: [:n| self to: self map: [:g| g*n]]) kernel generator"

"alternative:
	^ self annihilator generartor"! !

!Module methodsFor: 'accessing' stamp: 'len 12/12/2023 19:02:13'!
freeCover
	"Answer a free cover of the receiver. This is the domain of the generator matrix and the codomain of the relations matrix."
	^ self generatorMatrix domain! !

!Module methodsFor: 'accessing' stamp: 'len 4/20/2024 08:40:38'!
freeResolution
	"Answer a free resolution of the receiver."
	| differentials M |
	differentials := OrderedCollection new.
	differentials add: self ambient → self ambient null.
	differentials add: self → self ambient.
	M := self.
	[M relations isTrivial]
		whileFalse:
			[differentials add: M relations freeCover → M freeCover. "relationsMatrix?"
			M := M relations].
	differentials add: differentials last domain null → differentials last domain.
	^ ChainComplex differentials: differentials reversed! !

!Module methodsFor: 'accessing' stamp: 'len 3/13/2021 12:17:45'!
generator
	self isTrivial ifTrue: [^ self zero].
	^ super generator! !

!Module methodsFor: 'accessing' stamp: 'len 10/26/2020 15:26:48'!
generatorMatrix
	^ self propertyAt: #generatorMatrix! !

!Module methodsFor: 'accessing' stamp: 'len 7/5/2023 16:29:10'!
generators
	^ self propertyAt: #generators ifAbsentPut: [self generatorMatrix columns collect: [:each| self ambient elementAt: each]]! !

!Module methodsFor: 'accessing' stamp: 'len 9/18/2022 07:15:27'!
gramian
	"Answer the Gramian of the receiver, or Gram matrix.
	If M is the generator matrix of the receiver, and the inner product of the receiver is the dot product, then the Gramian is M transposed * M."
	| M |
	M _ self generatorMatrix.
	^ M transpose * self ambient innerProduct matrix * M

"	^ self matrix * self ambient innerProduct matrix * self matrix transposed"
"	| f |
	f _ self ambient innerProduct.
	^ self ambient scalars
		matrix: self rank
		map:
			[:i :j| f value: {(self basis at: i). (self basis at: j)}]"! !

!Module methodsFor: 'accessing' stamp: 'len 6/10/2022 11:05:57'!
invariants
	"Answer the Smith normal form abelian invariants of the reciever, each dividing the next.
	Each infinite cylic factor is represented by 0."
	^ self propertyAt: #invariants ifAbsentPut:
		[| M elementaryDivisors |
		M _ self relationsMatrix.
		elementaryDivisors _ M elementaryDivisors.
		((elementaryDivisors size + 1 to: M height) collect: [:each| self scalars zero]), (elementaryDivisors copyWithout: self scalars one)]! !

!Module methodsFor: 'accessing' stamp: 'len 10/23/2023 09:13:33'!
length
	"The 'length' of a module is the length of the longest chain of submodules.
	The trivial module is the only module with length 0, and a simple modules are the modules with length 1."
	self isVectorSpace ifTrue: [^ self rank].
	self isTrivial ifTrue: [^ 0].
	^ self notYetImplemented "^ self base length - self relations length ? or should we compute it as the length of the composition series?"! !

!Module methodsFor: 'accessing' stamp: 'len 6/26/2023 12:59:15'!
null
	"Answer the trivial submodule, i.e. the zero object in the category of R-modules."
	^ self ambient sub: #()! !

!Module methodsFor: 'accessing' stamp: 'len 4/20/2024 13:17:48'!
presentation
	^ self propertyAt: #presentation ifAbsentPut:
		[| answer |
		answer := self relationsMatrix cokernel.
		self addMap: (self to: answer validMatrix: answer freeCover id); addMap: (answer to: self validMatrix: answer freeCover id).
		answer]! !

!Module methodsFor: 'accessing' stamp: 'len 10/20/2020 18:51:17'!
primaryBasis
	"Answer a list of generators whose orders are the primary invariants of the receiver.
	See >>primaryInvariants."
	self notYetImplemented! !

!Module methodsFor: 'accessing' stamp: 'len 7/9/2023 18:17:12'!
primaryInvariants
	"Answer the primary abelian invariants of the receiver, consisting of prime powers qᵢ such that the torsion subgroup of the receiver is isomorphic to the direct sum of all the ℤ/qᵢℤ. Each infinite cyclic factor is represented by 0."
	| answer |
	self propertyAt: #primaryInvariants ifPresent: [:aBag| ^ aBag].
	answer := Bag new.
	self flag: #fixme.
	"this can be improved because each invariant divides the next:"
	self invariants do: [:each|
		each isZero
			ifTrue: [answer add: each]
			ifFalse: [each factorization withOccurrencesDo: [:p :k| answer add: p^k]]].
	^ self propertyAt: #primaryInvariants put: answer! !

!Module methodsFor: 'accessing' stamp: 'len 4/12/2024 16:31:34'!
projectiveCover
	"A category is said to have 'enough projectives' if for every object A there is an epimorphism P ↠ A from projective object P.
	Free modules are projective, so a free cover is also a projective cover:"
	^ self freeCover! !

!Module methodsFor: 'accessing' stamp: 'len 4/15/2024 08:26:54'!
projectiveResolution
	"Free modules are projective, so a free resolution is also a projective resolution:"
	^ self freeResolution! !

!Module methodsFor: 'accessing' stamp: 'len 12/12/2023 19:58:04'!
rank
	"The rank of a finitely generated R-module M is the rank of M ⊗ Frac(R), where Frac(R) is the total fraction ring of R.
	Note that the rank doesn't need to exist. When R is an integral domain Frac(R) is a field and the rank is defined.
	See [GP08, Definition 7.2.1]."
	| i F |
	self isTrivial ifTrue: [^ 0].
	self isFreelyGenerated ifTrue: [^ self freeCover rank].
	self scalars isPID ifTrue: [^ self invariants count: [:each| each isZero]].
	"self scalars isIntegralDomain ifTrue: [^ (self over: self scalars fractions) rank]."
	self propertyAt: #rank ifPresent: [:anInteger| ^ anInteger].
	i := 0.
	[(F := self fittingIdeal: i) isTrivial] whileTrue: [i := i + 1].
	F isOne ifTrue: [^ self propertyAt: #rank put: i].
	^ self error: 'rank undefined'! !

!Module methodsFor: 'accessing' stamp: 'len 6/10/2022 11:21:48'!
relations
	"Answer the first syzygies module of the generators of the receiver.
	If the receiver is a module generated by n generators {f1,...,fn}, the syzygies module is the submodule of R^n whose elements are all the n-tuples (a1,...,an) with a1*f1 + ... + an*fn = 0."
	^ self relationsMatrix image! !

!Module methodsFor: 'accessing' stamp: 'len 6/10/2022 09:51:18'!
relationsMatrix
	^ self propertyAt: #relationsMatrix ifAbsentPut:
		[self isAmbient ifTrue: [^ self subclassResponsibility].
		self generatorMatrix syzygiesModulo: self ambient relationsMatrix]! !

!Module methodsFor: 'accessing' stamp: 'len 6/10/2022 11:58:14'!
relators
	^ self relations generators! !

!Module methodsFor: 'accessing' stamp: 'len 12/12/2023 19:58:36'!
scalars
	^ self freeCover scalars! !

!Module methodsFor: 'accessing' stamp: 'len 8/29/2024 15:27:49'!
size
	self isTrivial ifTrue: [^ 1].
	self isAbelianGroup ifTrue: [^ (self invariants includes: 0) ifTrue: [ℕ size] ifFalse: [self invariants product]].
	self isFree ifTrue: [^ self scalars size ^ self rank].
	^ super size! !

!Module methodsFor: 'accessing' stamp: 'len 7/9/2023 18:16:36'!
torsion
	"Answer the torsion submodule of the receiver, i.e. the set of elements e such that there is a non-zero-divisor scalar r with e*r = 0.
	For an abelian group, this is the submodule of elements of finite order."
	| SPQ S P |
	self isFreelyGenerated ifTrue: [^ self null].
	self scalars isPID ifFalse: [^ self notYetImplemented].
	self isFinite ifTrue: [^ self].
	SPQ := self relationsMatrix SNFAndTransformations.
	S := SPQ first.
	P := SPQ second.
	^ self sub: (((1 to: S height) select: [:i| (S rowAt: i) isZero not]) collect: [:i| self elementAt: (P rowAt: i)])! !

!Module methodsFor: 'accessing' stamp: 'len 7/9/2023 18:16:30'!
torsionFree
	"Answer the torsion-free submodule.
	For an abelian group, this is the subgroup of elements of infinite order (and the identity)."
	| SPQ S P |
	self isFinite ifTrue: [^ self null].
	self scalars isPID ifFalse: [^ self notYetImplemented].
	SPQ := self relationsMatrix SNFAndTransformations.
	S := SPQ first.
	P := SPQ second.
	^ self sub: (((1 to: S height) select: [:i| (S rowAt: i) isZero]) collect: [:i| self elementAt: (P rowAt: i)])! !

!Module methodsFor: 'comparing' stamp: 'len 12/4/2023 09:43:36'!
= anObject
	self == anObject ifTrue: [^ true].
	(anObject isKindOf: Module) ifFalse: [^ false].
	self ambient = anObject ambient ifFalse: [^ false].
	(self scalars hasCanonicalBases and: [self ambient isFreelyGenerated]) ifTrue: [^ self generatorMatrix = anObject generatorMatrix].
	self generatorMatrix = anObject generatorMatrix ifTrue: [^ true].
	self flag: #fix. "reimplement, see Module>>#sub:, compute all together, also Module>>#⊂"
	^ (self generators allSatisfy: [:each| anObject contains: each])
		and: [anObject generators allSatisfy: [:each| self contains: each]]! !

!Module methodsFor: 'comparing' stamp: 'len 10/30/2023 19:16:50'!
~ aModule
	"Answer true if the receiver is isomorphic to the argument."
	self = aModule ifTrue: [^ true].
	self scalars = aModule scalars ifFalse: [^ false].
	(self generatorMatrix = aModule generatorMatrix and: [self relationsMatrix = aModule relationsMatrix]) ifTrue: [^ true].
	self scalars isElementaryDivisorRing ifTrue: [^ self invariants = aModule invariants].
"	(self ⇒ aModule) atRandom isIsomorphism ifTrue: [^ true]."
	self notYetImplemented! !

!Module methodsFor: 'comparing' stamp: 'len 1/13/2018 22:42:28'!
hash
	^ self scalars hash! !

!Module methodsFor: 'comparing' stamp: 'len 12/10/2023 10:36:24'!
⊆ aModule
	"Answer true if the receiver a submodule of the argument."
	self == aModule ifTrue: [^ true].
	self ambient = aModule ifTrue: [^ true].
	self ambient = aModule ambient ifFalse: [^ false].
	self flag: #fix. "reimplement, see Module>>#sub:, compute all together, also Module>>#="
	^ self generators allSatisfy: [:each| aModule contains: each]! !

!Module methodsFor: 'converting' stamp: 'len 8/29/2024 15:26:41'!
asAbelianGroup
	self isAbelianGroup ifTrue: [^ self].
	self flag: #fix. "should implement for ℤ/m-modules and other finite ℤ-algebras."
	^ self propertyAt: #asAbelianGroup ifAbsentPut: [AbelianGroup elements: self elementsOrSelf]! !

!Module methodsFor: 'converting' stamp: 'len 11/23/2022 17:08:20'!
asAlgebraicVariety
	| R X |
	R _ self scalars polynomialsIn: self ambient rank.
	X _ R !!!! R generators.
	^ (R * (self annihilatorSpace basis asArray collect: [:each| (each asMatrix over: R) * X at: 1])) variety! !

!Module methodsFor: 'converting' stamp: 'len 10/5/2022 18:37:41'!
asChainComplex
	^ ChainComplex differentials: {self null → self. self → self null}! !

!Module methodsFor: 'converting' stamp: 'len 4/5/2024 19:07:13'!
asElementaryAbelianGroup
	self assert: (self scalars isKindOf: PrimeField).
	^ self asAbelianGroup! !

!Module methodsFor: 'converting' stamp: 'len 8/29/2024 15:27:00'!
asFPGroup
	| F relators answer |
	self assert: self isAbelianGroup.
	F := FreeGroup new: self invariants size.
	relators := OrderedCollection new.
	self invariants withIndexDo: [:k :i| k ~= 0 ifTrue: [relators add: (F x: i)^k]].
	1 to: F rank do: [:i| 1 to: F rank do: [:j| i ~= j ifTrue: [relators add: ((F x: i) commutator: (F x: j))]]].
	^ (answer := F / relators)
		addMap: (self to: answer images: answer generators);
		addMap: (answer to: self images: self generators);
		yourself! !

!Module methodsFor: 'converting' stamp: 'len 6/15/2023 13:36:01'!
asModule
	^ self! !

!Module methodsFor: 'converting' stamp: 'len 10/20/2020 18:32:27'!
asPermutationGroup
	| answer |
	self isTorsion ifFalse: [self error: 'infinite abelian groups are not isomorphic to finite permutation groups'].
	answer _ SymmetricGroup new: 0.
	self invariants do: [:each| answer _ answer × (PermutationGroup cyclic: each)].
	"TODO: add isomorphisms"
	^ answer! !

!Module methodsFor: 'converting' stamp: 'len 5/13/2022 07:01:57'!
asRepresentation
	"If this is a module over a finite algebra, answer the equivalent representation."
	^ self notYetImplemented! !

!Module methodsFor: 'converting' stamp: 'len 6/1/2024 07:28:06'!
over: aRing
	"Answer the change of base ring of the receiver."
	^ self apply: self scalars → aRing! !

!Module methodsFor: 'elements' stamp: 'len 12/12/2023 19:53:41'!
\ anElement
	"Answer coordinates of anElement expressed as a linear combination of the elements of the distinguished generating set of the receiver. Answer nil if anElement is not in the receiver."
	anElement isZero ifTrue: [^ self freeCover zero].
	self isTrivial ifTrue: [^ nil].
	^ (self generatorMatrix lift: (self ambient \ anElement) asMatrix modulo: self ambient relationsMatrix) ifNotNil: [:answer| answer asTuple]

"
	^ self matrix transposed \ (self ambient coordinatesOf: anElement)
alternative 1:
	answer _ self matrix leftInverse * (ambient coordinatesOf: anElement).
	^ answer isZero ifFalse: [answer]"
"alternative 2:
	m _ self matrix rowAugmented: (ambient coordinatesOf: anElement).
	reducer _ m transposed reducer.
	coords _ reducer reduced lastColumn.
	^ reducer rank > self size
		ifFalse:
			[answer _ self coordinates zero copy.
			reducer pivots do: [:each| answer at: each x put: (coords at: each y)].
			answer]"! !

!Module methodsFor: 'elements' stamp: 'len 5/5/2023 18:47:53'!
elementAt: anArray
	| answer |
	answer _ self zero.
	self isTrivial ifTrue: [^ self zero].
	1 to: anArray size do: [:i| answer _ (self x: i) * (anArray at: i) + answer].
	^ answer! !

!Module methodsFor: 'elements' stamp: 'len 6/19/2022 12:30:26'!
identity
	"Answer the identity element of the receiver seen as an additive group."
	^ self zero! !

!Module methodsFor: 'elements' stamp: 'len 11/23/2022 17:08:35'!
newFrom: anObject
	(anObject isSequenceable and: [anObject size = self generators size])
		ifTrue: [^ self elementAt: self scalars !!!! anObject].
	^ super newFrom: anObject! !

!Module methodsFor: 'elements' stamp: 'len 5/1/2024 12:25:39'!
zero
	^ self propertyAt: #zero ifAbsentPut: [self isAmbient ifTrue: [self generators any * self scalars zero] ifFalse: [self ambient zero]]! !

!Module methodsFor: 'elements-testing' stamp: 'len 9/16/2022 07:45:35'!
isZeroDivisor: aScalar
	"Answer true if there exists a nonzero element that multiplied by the argument is zero.
	A Singular Introduction to Commutative Algebra, 2.8.5 Radical and Zerodivisors of Modules."
	^ (self endomorphisms map: [:x| x*aScalar]) kernel isTrivial not

"slow alternative for finite rings:
	^ self anySatisfy: [:any| any isZero not and: [(any * aNumber) isZero]]
"! !

!Module methodsFor: 'enumerating' stamp: 'len 12/12/2023 19:57:33'!
do: aBlock
	| visited |
	self isTrivial ifTrue: [aBlock value: self zero. ^ self].
	visited := Set new.
	self freeCover do: [:each|
		| x |
		x := self elementAt: each.
		visited add: x ifAbsent: [aBlock value: x]]! !

!Module methodsFor: 'internalization' stamp: 'len 8/30/2024 22:22:20'!
action
	^ self carrier with: self scalars carrier to: self carrier map: [:x :r| (self !! x) * (self scalars !! r)]! !

!Module methodsFor: 'internalization' stamp: 'len 8/30/2024 22:22:01'!
carrier
	^ self asAbelianGroup! !

!Module methodsFor: 'morphisms' stamp: 'len 6/26/2023 12:59:05'!
apply: aMorphism
	aMorphism isBlock
		ifTrue: [^ self ambient sub: (self generators collect: aMorphism)].
	(aMorphism domain = self scalars and: [self isAmbient not])
		ifTrue: [^ (self ambient apply: aMorphism) sub: (self generatorMatrix apply: aMorphism)].
	aMorphism domain == self
		ifTrue: [^ aMorphism image].
"	aMorphism domain == self ambient ifTrue: [^ (self → self ambient → aMorphism) image]."
	^ aMorphism codomain sub: (self generators collect: aMorphism)! !

!Module methodsFor: 'morphisms' stamp: 'len 7/29/2024 09:49:44'!
associatorWith: anObject and: anotherObject
	^ (self ⊗ anObject ⊗ anotherObject) id! !

!Module methodsFor: 'morphisms' stamp: 'len 6/25/2024 15:31:54'!
braidingWith: anObject
	^ self with: anObject to: anObject ⊗ self map: [:x :y| {y. x}]! !

!Module methodsFor: 'morphisms' stamp: 'len 7/29/2024 09:47:40'!
coevaluation
	"V ⊗ Vᵛ ~ End(V) canonically. Making this identification, the coevaluation map is just sending 1 to the identity morphism of V. See #⊗."
	self flag: #fixme. "this is wrong because we no longer identify tensor products of modules with hom modules"
	^ self scalars asIdeal to: self ⇒ self images: {self id}! !

!Module methodsFor: 'morphisms' stamp: 'len 7/31/2024 21:02:31'!
coevaluationWith: aModule
	^ self notYetImplemented! !

!Module methodsFor: 'morphisms' stamp: 'len 5/9/2024 07:06:56'!
endomorphisms
	^ self propertyAt: #endomorphisms ifAbsentPut: [EndomorphismRing on: self]! !

!Module methodsFor: 'morphisms' stamp: 'len 7/10/2024 08:02:32'!
evaluation
	^ self evaluationWith: self scalars asIdeal! !

!Module methodsFor: 'morphisms' stamp: 'len 7/10/2024 08:01:04'!
evaluationWith: aModule
	^ self ⇒ aModule with: self to: aModule map: [:f :x| f value: x]! !

!Module methodsFor: 'morphisms' stamp: 'len 6/1/2024 07:06:14'!
from: aModule
	(self isAmbient not and: [self ambient isQuotient]) ifTrue:
		[aModule ⇢ self ambient ifNotNil: [:aMorphism| ^ self → self ambient \ aMorphism]].
	^ super from: aModule! !

!Module methodsFor: 'morphisms' stamp: 'len 6/2/2024 10:16:56'!
hom: aCodomain
	self assert: (aCodomain isModule and: [self scalars = aCodomain scalars]).
	"If the scalars are commutative or involutive, this is the internal hom:"
	(self scalars isCommutative or: [self scalars isInvolutive]) ifTrue: [^ HomModule from: self to: aCodomain].
	"TODO: if scalars are a finite R-algebra, answer an R-module"
"	^ HomGroup from: self to: aCodomain]."
	^ super hom: aCodomain! !

!Module methodsFor: 'morphisms' stamp: 'len 4/5/2024 09:11:20'!
id
	^ self propertyAt: #id ifAbsentPut: [self to: self validMatrix: self freeCover id]! !

!Module methodsFor: 'morphisms' stamp: 'len 6/27/2024 08:30:55'!
leftUnitor
	^ self scalars asIdeal with: self to: self map: [:r :x| x*r]! !

!Module methodsFor: 'morphisms' stamp: 'len 6/14/2022 12:11:19'!
orthogonalProjection
	"Answer an orthogonal projection onto the receiver (with respect to the standard inner product)."
	| F T |
	self isTrivial ifTrue: [^ self ambient endomorphisms zero].
	F _ self generatorMatrix.
	T _ F transpose.
	^ self ambient endomorphisms !! (F * (T * F) inverse * T)! !

!Module methodsFor: 'morphisms' stamp: 'len 6/27/2024 08:31:28'!
rightUnitor
	^ self with: self scalars asIdeal to: self map: [:x :r| x*r]! !

!Module methodsFor: 'morphisms' stamp: 'len 8/29/2024 15:28:46'!
to: aModule
	((aModule isModule or: [self isGroup and: [aModule isGroup]]) and: [self isTrivial or: [aModule isTrivial]])
		ifTrue: [^ self to: aModule map: [:x| aModule identity]].
	^ super to: aModule! !

!Module methodsFor: 'morphisms' stamp: 'len 4/6/2024 15:54:37'!
to: aCodomain adapt: anObject
	(anObject isMatrix and: [anObject domain = self freeCover and: [anObject codomain = aCodomain freeCover]]) ifTrue: [^ self to: aCodomain matrix: anObject].
	^ super to: aCodomain adapt: anObject! !

!Module methodsFor: 'morphisms' stamp: 'len 6/20/2024 07:34:11'!
to: aCodomain images: anArray
	"Answer a morphism defined by images of generators."
	(aCodomain isModule and: [aCodomain scalars = self scalars])
		ifTrue: [^ self to: aCodomain matrix: (self freeCover to: aCodomain freeCover images: (anArray collect: [:each| aCodomain \ (aCodomain !! each)]))].
	(self isGroup and: [aCodomain isGroup])
		ifTrue: [^ GroupMap from: self to: aCodomain images: anArray].
	^ Error signal! !

!Module methodsFor: 'morphisms' stamp: 'len 4/1/2024 15:01:06'!
to: aCodomain map: aBlock
	(aCodomain isModule and: [aCodomain scalars = self scalars])
		ifTrue: [^ self to: aCodomain matrix: (self freeCover to: aCodomain freeCover images: (self generators collect: [:each| aCodomain \ (aCodomain !! (aBlock value: each))]))].
	self assert: (self isGroup and: [aCodomain isGroup]).
	^ GroupMap from: self to: aCodomain map: aBlock! !

!Module methodsFor: 'morphisms' stamp: 'len 12/11/2023 20:44:52'!
to: aModule matrix: aMatrix
	^ self to: aModule matrix: (aMatrix reductionBy: aModule relationsMatrix) ifInvalid: [self error: 'invalid morphism']! !

!Module methodsFor: 'morphisms' stamp: 'len 12/10/2023 10:36:24'!
to: aModule matrix: aMatrix ifInvalid: exceptionBlock
	"A matrix induces a valid module homomorphism iff it sends syzygies to syzygies:"
	(aMatrix * self relationsMatrix) image ⊆ aModule relationsMatrix image ifFalse: [^ exceptionBlock value].
	^ self to: aModule validMatrix: aMatrix! !

!Module methodsFor: 'morphisms' stamp: 'len 12/12/2023 20:00:03'!
to: aModule validMatrix: aMatrix
	self assert: aMatrix domain = self freeCover.
	self assert: aMatrix codomain = aModule freeCover.
"	(aMatrix * self relationsMatrix) image <= aModule relationsMatrix image ifFalse: [^ self halt]."
	^ ModuleMap from: self to: aModule matrix: aMatrix! !

!Module methodsFor: 'morphisms' stamp: 'len 6/25/2024 15:23:11'!
with: aModule to: anotherModule map: aBlock
	"Answer a morphism from X ⊗ Y to Z induced by the values of aBlock at each pair of generators of X and Y."
	| images |
	self assert: (self isFreelyGenerated and: [aModule isFreelyGenerated]).
	images := OrderedCollection new.
	self generators do: [:x| aModule generators do: [:y| images add: (aBlock value: x value: y)]].
	^ self ⊗ aModule to: anotherModule images: images! !

!Module methodsFor: 'operations' stamp: 'len 10/26/2023 14:01:37'!
* anIdeal
	| newGenerators |
	"If it's not an ideal, it must be a scalar:"
	(anIdeal isKindOf: Ideal) ifFalse: [^ self * (self scalars * anIdeal)].
	self assert: self scalars = anIdeal scalars.
	anIdeal isTrivial ifTrue: [^ self null].
	self isVectorSpace ifTrue: [^ self].
	anIdeal isOne ifTrue: [^ self].
	"This is wrong, only works for finitely generated modules without relations:"
	newGenerators := Set new.
	self generators do: [:a| anIdeal generators do: [:b| newGenerators add: a*b]].
	^ self ambient sub: newGenerators! !

!Module methodsFor: 'operations' stamp: 'len 6/26/2023 12:58:32'!
+ aSubmodule
	self checkIsSibling: aSubmodule.
	self isTrivial ifTrue: [^ aSubmodule].
	aSubmodule isTrivial ifTrue: [^ self].
	^ self ambient sub: self generatorMatrix ⊔ aSubmodule generatorMatrix! !

!Module methodsFor: 'operations' stamp: 'len 8/17/2024 20:32:46'!
/ aSubmodule
	"Answer the quotient of the receiver by aSubmodule,
	i.e. the module obtained by 'collapsing' the submodule to zero.
	Alternatively, if the argument is a scalar, scale down the receiver by it."
	| R P i j u answer |
	(self scalars includes: aSubmodule) ifTrue: [^ self ambient sub: self generatorMatrix / aSubmodule].
	aSubmodule isCollection ifTrue: [^ self / (self ambient sub: aSubmodule)].
	self checkIsSibling: aSubmodule.
	self isAmbient ifFalse:
		[| π |
		π := self ambient → (self ambient / aSubmodule).
		answer := self apply: π.
		answer addMap: (self onto: answer map: [:x| π value: x]).
		^ answer].
	"The receiver is an ambient module:"
	aSubmodule isTrivial ifTrue: [^ self].
	aSubmodule = self ifTrue: [^ self null].
	self generatorMatrix isIdentity ifFalse: [^ self notYetImplemented].
	R := self relationsMatrix ⊔ aSubmodule generatorMatrix.
	self scalars hasCanonicalBases ifTrue: [R := R basis].
	"Remove units from the relations matrix because they are redundant.
	By Nakayama's lemma, over a local ring or a graded ring whose degree 0 component is a field this gives a presentation with a minimal set of generators (see [GP08, pag 127] and [BLH11, Remark 4.4])."
	P := R codomain id copy.
	self scalars isCommutative ifTrue:
		[R := R transpose. "We transpose temporarily in order to work with row operations."
		j := 1.
		[j <= R height] whileTrue:
			[(i := (1 to: R width) findFirst: [:k| (u := R at: j@k) isUnit]) > 0
				ifTrue:
					["Make the entry at j@i be 1:"
					R multiplyRow: j by: u inverse.
					"Put zeros in the relations matrix in row i at columns before and after j:"
					1 to: R height do: [:k| k ~= j ifTrue: [R addRow: j times: (R at: k@i) negated to: k]].
					"Put zeros in the projection matrix in column j at rows before and after i:"
					1 to: P height do: [:k| k ~= i ifTrue: [P addRow: i times: (R at: j@k) negated to: k]].
					"Remove the j-th relation the i-th generator:"
					R := R copyWithoutRowAndColumn: j@i.
					P := P copyWithoutRow: i]
				ifFalse:
					[j := j + 1]].
		R := R transpose].
	answer := R isZero ifTrue: [FreeModule new: R codomain rank over: R scalars] ifFalse: [QuotientModule relationsMatrix: R].
	answer addMap: ((self to: answer validMatrix: P) name: 'π').
	^ answer! !

!Module methodsFor: 'operations' stamp: 'len 6/6/2022 09:54:24'!
: aModuleOrIdeal
	"Answer the conductor P : N of the argument N into the receiver P (also called colon quotient).
	This is defined as the ideal {a in R | aN <= P}.
	For the receiver P a submodule of an R-module M, and the argument I an ideal of R, answer the conductor P : I of I into P defined as the submodule {m in M | Im <= P}."
	self notYetImplemented! !

!Module methodsFor: 'operations' stamp: 'len 11/7/2023 21:17:15'!
@ aPrimeIdeal
	"Answer the localization of the receiver at aPrimeIdeal."
	^ self ⊗ (self scalars @ aPrimeIdeal)! !

!Module methodsFor: 'operations' stamp: 'len 4/5/2024 19:07:22'!
^⊕ anInteger
	anInteger = 1 ifTrue: [^ self].
	anInteger = 0 ifTrue: [^ self null].
	anInteger < 0 ifTrue: [^ Error signal].
	^ anInteger even ifTrue: [self ⊕ self ^⊕ (anInteger // 2)] ifFalse: [self  ⊕ self ^ (anInteger // 2) ⊕ self]! !

!Module methodsFor: 'operations' stamp: 'len 6/9/2022 07:05:18'!
× aModule
	"Answer the categorical product, i.e. direct sum of the receiver and the argument."
	^ self ⊕ aModule! !

!Module methodsFor: 'operations' stamp: 'len 12/7/2023 17:00:04'!
annihilator
	"Answer the ideal of elements of the scalar ring that annihilate all the elements in the receiver.
	For an R-module M, Ann(M) is the kernel of the natural map R → End(M), and can also be computed as the colon quotient {0} : M."
	self scalars isEuclideanDomain ifTrue:
		[self isFinite ifFalse: [^ self scalars asIdeal null].
		^ self scalars * (self invariants inject: self scalars one into: [:last :each| last lcm: each])].
	self flag: #fixme. "it should be 	^ (self scalars → self endomorphisms) kernel"
	^ (self scalars asIdeal → self endomorphisms asModule) kernel

"alternative:
	^ self null : self
"
! !

!Module methodsFor: 'operations' stamp: 'len 6/12/2024 18:13:27'!
annihilatorSpace
	"Answer the space of all linear forms that are 0 at all vectors in the receiver.
	See also >>complement."
	^ (self → self ambient) dual kernel! !

!Module methodsFor: 'operations' stamp: 'len 12/4/2023 09:42:13'!
complement
	"Answer the complement of the receiver in its ambient with respect to the standard inner product (i.e., the dot product). See also >>annihilatorSpace.
	This is the subspace of all vectors in the ambient that have dot product zero (are orthogonal to) all vectors in the receiver."
	^ (self → self ambient) transpose kernel

"
if we're in a vector space over the reals or complex numbers, we can get an orthogonal basis:
	((self scalars isKindOf: RealField) or: [self scalars isKindOf: ComplexField])
		ifTrue: [^ self ambient sub: (self matrix extended orthogonalized copyFromRow: self rank + 1 to: self degree)].

alternative 2:
	| k n |
	k _ self dimension.
	n _ self ambient dimension.
	^ (self basis extended orthogonalized copyFrom: k + 1 to: n) span

alternative 2':
	^ self orthogonalProjection kernel

alternative 3:?
	^ basis dual asArray inject: self space into: [:answer :each| answer intersection: each kernel]	

alternative 4:
	^ self ambient sub: (self annihilator basis collect: [:f| f asVector])
"! !

!Module methodsFor: 'operations' stamp: 'len 7/17/2020 10:34:24'!
decomposition
	"Answer a list of idecomposable submodules whose direct sum is isomorphic to the receiver, together with projection maps."
	^ self notYetImplemented! !

!Module methodsFor: 'operations' stamp: 'len 4/12/2024 16:33:13'!
eliminate: anIndeterminate
	"Answer the elimination submodule computed by eliminating anIndeterminate."
	^ self eliminateAll: {anIndeterminate}

"Alternative algorithm to compute eliminants of ideals:
input: ideal I in K[x₁...xₙ] and indet xᵢ
output: univariate eliminant g(xᵢ) or there's no eliminant
1. compute groebner basis G of I in any monomial ordering
2. if no initial term of any element of G is a pure power of xi, then halt, no eliminant
3. compute the sequence 1 mod G, xᵢ mod G, xᵢ² mod G, ... until a linear dependence is found
  aₙxᵢⁿ+...+a₁xᵢ+a₀ mod G = 0
where n is minimal, then output eliminant g(xᵢ) = Σₖ aₖxᵢ^k
"! !

!Module methodsFor: 'operations' stamp: 'len 7/27/2021 08:27:56'!
eliminateAllBut: anIndeterminate
	"Answer the submodule with only the given indeterminate."
	^ self eliminateAll: (self scalars indeterminates select: [:each| each ~= anIndeterminate])! !

!Module methodsFor: 'operations' stamp: 'len 4/15/2024 08:25:45'!
ext: aModule
	^ (self freeResolution ⇒ aModule) cohomology! !

!Module methodsFor: 'operations' stamp: 'len 5/1/2021 11:27:42'!
exteriorAlgebra
	| T |
	T _ self tensorAlgebra.
	^ T / (T generators collect: [:each| each squared])! !

!Module methodsFor: 'operations' stamp: 'len 6/15/2023 16:46:38'!
fittingIdeal: anInteger
	"Answer the i-th Fitting ideal of the receiver.
	See [GP08, 7.2 Fitting Ideals]."
	| M n |
	M := self relationsMatrix.
	(n := M height - anInteger) <= 0 ifTrue: [^ self scalars asIdeal].
	(n > M height or: [n > M width]) ifTrue: [^ self scalars zero asIdeal].
	^ self scalars * (M minors: n)! !

!Module methodsFor: 'operations' stamp: 'len 4/5/2024 19:06:45'!
grassmannian: r
	"Answer the set of r-dimensional subspaces of the receiver."
"	self isVectorSpace ifFalse: [DomainError signal: 'not a vector space']."
	self scalars isPID ifFalse: [^ self error: 'not a module over a PID'].
	self assert: (r <= self rank and: [r >= 0]).
	^ Grassmannian new: r over: self! !

!Module methodsFor: 'operations' stamp: 'len 10/24/2023 16:06:21'!
jacobsonRadical
	"Answer the Jacobson radical of the receiver, defined as the intersection of its maximal submodules.
	This is dual to the 'socle' of a module, defined as the sum of its simple submodules.
	Note: not to be confused with the radical √I of an ideal I."
	^ self * self scalars radical! !

!Module methodsFor: 'operations' stamp: 'len 6/26/2023 12:59:10'!
leadingSubmodule
	"Answer the initial submodule. This is the submodule of all leading terms of the receiver."
	| leadingTerms |
	leadingTerms := OrderedCollection new.
	self basis do: [:each| | t | t := each leadingTerm. (t \\ leadingTerms) isZero ifFalse: [leadingTerms add: t]].
	^ self ambient sub: leadingTerms! !

!Module methodsFor: 'operations' stamp: 'len 8/29/2024 15:27:41'!
orderOf: anElement
	"Answer the order of the argument in the receiver, i.e. the minimum e such that x*e = 0."
	self assert: self isAbelianGroup.
	^ (ℤ asAbelianGroup to: self map: [:n| anElement*n]) kernel generator

"alternative:
	| h factors id e g1 |
	self isFinite ifFalse:
		[(self torsion includes: anElement) ifFalse: [^ 0].
		^ self torsion orderOf: anElement]."
	"[Coh96] Algorithm 1.4.3 (Order of an Element):"
"	h := self size.
	factors := self propertyAt: #sizeFactorization ifAbsentPut: [h factorization].
	e := h.
	id := self identity.
	factors asSet do: [:p|
		e := e / (p ^ (factors occurrencesOf: p)).
		g1 := anElement * e.
		[g1 = id] whileFalse: [g1 := g1 * p. e := e * p]].
	^ e"! !

!Module methodsFor: 'operations' stamp: 'len 10/6/2022 11:50:40'!
reduce: anElement
	"Answer zero if anElement is in the receiver, and otherwise answer some representative of the coset 'anElement + self' (not necessarily a normal form).
	It is required that:
		(M reduce: x) = (M reduce: y) ⟺ x - y ∈ M, and
		∀ x, y ∈ M, x - (M reduce: x) ∈ M."
	self isAmbient ifTrue: [^ self zero].
	self isTrivial ifTrue: [^ anElement].
	^ self ambient elementAt: ((self ambient \ anElement) asMatrix reductionBy: self generatorMatrix modulo: self ambient relationsMatrix) asTuple! !

!Module methodsFor: 'operations' stamp: 'len 10/19/2023 13:37:42'!
restriction
	"This is the 'restriction of scalars' functor.
	If the receiver is a module over a finite R-algebra, answer a module over R.
	This functor is right adjoint to 'extension of scalars' (see #⊗) and left adjoint to 'coextension of scalars' (see #⇒)."
	^ self notYetImplemented! !

!Module methodsFor: 'operations' stamp: 'len 6/26/2023 12:59:19'!
saturation
	"If the receiver is a submodule of Rⁿ for a Euclidean domain R, the saturation is the intersection of Rⁿ with the Frac(R)-span of any basis of the receiver. See [PS09, Section 8]."
	(self scalars isEuclideanDomain and: [self ambient isFreelyGenerated])
		ifFalse: [^ self error: 'not a submodule of a free module over a Euclidean domain'].
	^ self ambient sub: (self basisMatrix HNF copyWithoutZeroRows \ self basisMatrix transpose) transpose! !

!Module methodsFor: 'operations' stamp: 'len 10/26/2023 10:54:05'!
socle
	"The socle of a module is the sum of its simple submodules, i.e. it is the largest semisimple submodule. A module is semisimple if and only if its socle is the whole module.
	This is dual to the Jacobson radical of a module, defined as the intersection of its maximal submodules.
	If R is a finite-dimensional algebra and M is a finitely generated R-module, then the socle of M consists precisely of the elements annihilated by the Jacobson radical of R."
	self notYetImplemented! !

!Module methodsFor: 'operations' stamp: 'len 12/18/2023 10:14:17'!
sub: aCollectionOrMatrix
	"Answer the submodule generated by the argument, which can be either a collection containing any objects that can be coerced to the receiver, or a generator matrix relative to the receiver's presentation."
	| generators G |
	aCollectionOrMatrix isMatrix
		ifTrue:
			[self isAmbient ifFalse: [^ self ambient sub: self generatorMatrix * aCollectionOrMatrix].
			G := aCollectionOrMatrix copyWithoutZeroColumns]
		ifFalse:
			[self isAmbient ifFalse: [^ self ambient sub: aCollectionOrMatrix].
			generators := (aCollectionOrMatrix asArray collect: [:each| self !! each]) select: [:each| each isZero not].
			G := Matrix to: self freeCover columns: (generators collect: [:each| self \ each])].
	self scalars hasCanonicalBases ifTrue: [G := G basis].
	self isFreelyGenerated ifFalse: [G := (G reductionBy: self relationsMatrix) 	copyWithoutZeroColumns].
	(self freeCover id reductionBy: G modulo: self relationsMatrix) isZero ifTrue: [^ self].
	^ self species new ambient: self; generatorMatrix: G! !

!Module methodsFor: 'operations' stamp: 'len 4/13/2021 10:24:17'!
support
	"The support of an R-module M over a commutative ring R is the set of prime ideals p of R such that the localization of M at p is not the trivial module.
	By definition, the support is a subset of Spec(R)."
	^ (self scalars / self annihilator) spec

"This is not very useful, just works with small finite rings:
	^ self scalars spectrum reject: [:each| (self localizationAt: each) isTrivial]"! !

!Module methodsFor: 'operations' stamp: 'len 5/1/2021 11:25:59'!
tensorAlgebra
	^ self propertyAt: #tensorAlgebra ifAbsentPut: [self scalars freeAlgebraIn: (self coordinateNames ifNil: [self rank])]! !

!Module methodsFor: 'operations' stamp: 'len 10/26/2023 10:47:41'!
top
	"Answer the top of the receiver M, defined as the quotient by the Jacobson radical M / J(M)."
	^ self propertyAt: #top ifAbsentPut: [self / self jacobsonRadical]! !

!Module methodsFor: 'operations' stamp: 'len 4/15/2024 08:25:54'!
tor: aModule
	^ (self relations freeResolution ⊗ aModule) homology! !

!Module methodsFor: 'operations' stamp: 'len 8/4/2020 14:25:07'!
transversal
	^ self complement generators! !

!Module methodsFor: 'operations' stamp: 'len 10/11/2023 08:17:19'!
∧ aSubmodule
	^ self ∩ aSubmodule! !

!Module methodsFor: 'operations' stamp: 'len 10/11/2023 08:17:41'!
∨ aSubmodule
	^ self + aSubmodule! !

!Module methodsFor: 'operations' stamp: 'len 5/1/2024 10:24:56'!
∩ aSubmodule
	"Answer the intersection of the receiver and the argument."
	self checkIsSibling: aSubmodule.
	self isAmbient ifTrue: [^ aSubmodule].
	aSubmodule isAmbient ifTrue: [^ self].
	self isTrivial ifTrue: [^ self].
	aSubmodule isTrivial ifTrue: [^ aSubmodule].
	^ (self → self ambient ∧ (aSubmodule → self ambient) ⇉ {self. aSubmodule}) any image! !

!Module methodsFor: 'operations' stamp: 'len 5/3/2021 10:44:12'!
⊔ aModule
	"The coproduct in the category of R-modules is the direct sum."
	^ self ⊕ aModule! !

!Module methodsFor: 'operations' stamp: 'len 12/12/2023 19:54:41'!
⊕ aModule
	"Answer the direct sum of the receiver and the argument."
	| R answer ρ |
	R := self relationsMatrix ⊕ aModule relationsMatrix.
	answer := R cokernel.
	ρ := R codomain → answer.
	answer
		addCoprojections: (R codomain ⇇ {self freeCover. aModule freeCover} with: {self. aModule} collect: [:ι :X| X to: answer map: [:x| ρ value: (ι value: X \ x)]]);
		addProjections: (R codomain ⇉ {self freeCover. aModule freeCover} with: {self. aModule} collect: [:π :Y| answer to: Y map: [:x| Y elementAt: (π value: ρ \ x)]]).
	^ answer! !

!Module methodsFor: 'operations' stamp: 'len 8/19/2024 09:41:08'!
⊗ anObject
	"Answer the tensor product of the receiver with the argument, if the argument is another module or a module homomorphism.
	If the argument is a ring, answer the extension of scalars."
	| answer M N T π |
	(anObject isKindOf: Ring) ifTrue: [^ self apply: self scalars → anObject].
	(anObject isKindOf: ModuleMap) ifTrue: [^ self id ⊗ anObject].
	self assert: self scalars = anObject scalars.
	self scalars isCommutative ifFalse: [^ super ⊗ anObject].
	M := self relationsMatrix.
	N := anObject relationsMatrix.
	T := M ⊗ N codomain id ⊔ (M codomain id ⊗ N).
	answer := T cokernel.
	π := T codomain → answer.
	answer addCoercionFrom: self underlyingSet × anObject underlyingSet mapWithArguments: [:x :y| π value: (self \ x ⊗ (anObject \ y)) asTuple].
	^ answer! !

!Module methodsFor: 'printing' stamp: 'len 12/20/2021 17:50:52'!
printGeneratorsOn: aStream
	self isTrivial ifTrue: [aStream print: self zero. ^ self].
	self generators do: [:each| aStream print: each] separatedBy: [aStream nextPutAll: '; ']! !

!Module methodsFor: 'printing' stamp: 'len 5/29/2023 13:59:03'!
printOn: aStream
	self isTrivial ifTrue: [aStream print: 0. ^ self].
	aStream withAngleBrackets: [:aStream2| self printGeneratorsOn: aStream2].
	self ambient isQuotient ifTrue: [aStream nextPut: $╱; print: self ambient relations]! !

!Module methodsFor: 'random' stamp: 'len 12/12/2023 19:54:49'!
atRandom: aRandom
	^ self elementAt: (self freeCover atRandom: aRandom)! !

!Module methodsFor: 'random' stamp: 'len 12/12/2023 19:55:41'!
atRandom: aRandom bits: bitSize
	^ self elementAt: (self freeCover atRandom: aRandom bits: bitSize)! !

!Module methodsFor: 'testing' stamp: 'len 1/3/2022 20:58:43'!
contains: anElement
	self isAmbient ifTrue: [^ true].
	self isTrivial ifTrue: [^ anElement isZero].
	^ (self reduce: anElement) isZero! !

!Module methodsFor: 'testing' stamp: 'len 4/22/2020 06:11:40'!
includes: anObject
	self isAmbient ifTrue: [^ anObject parent = self].
	^ (self ambient includes: anObject) and: [self contains: anObject]! !

!Module methodsFor: 'testing' stamp: 'len 8/29/2024 15:17:39'!
isAbelianGroup
	^ self scalars = ℤ! !

!Module methodsFor: 'testing' stamp: 'len 3/21/2021 15:14:23'!
isArtinian
	"A module is called Artinian if it satisfies the descending chain condition."
	(self isAmbient not and: [self ambient isArtinian]) ifTrue: [^ true].
	^ self scalars isArtinian "because the receiver is finitely generated"! !

!Module methodsFor: 'testing' stamp: 'len 8/29/2024 15:27:20'!
isCyclic
	self generators size = 1 ifTrue: [^ true].
	self isAbelianGroup ifTrue: [^ self invariants size <= 1].
	(self isFreelyGenerated or: [self scalars isPID]) ifTrue: [^ self rank = 1].
	^ self notYetImplemented! !

!Module methodsFor: 'testing' stamp: 'len 10/19/2023 10:25:47'!
isDecomposable
	^ self decomposition size > 1! !

!Module methodsFor: 'testing' stamp: 'len 3/15/2020 16:55:43'!
isDual
	"Answer true if the receiver is the module of linear forms Hom(M,R) for an R-module M."
	^ false! !

!Module methodsFor: 'testing' stamp: 'len 5/12/2023 21:09:30'!
isElementaryAbelian
	"Answer true if the receiver is isomorphic to a direct sum of n copies of a cyclic group of prime order, i.e. isomorphic to (ℤ/pℤ)^n for some prime p and natural number n."
	self notYetImplemented! !

!Module methodsFor: 'testing' stamp: 'len 4/27/2020 01:48:43'!
isFaithful
	"A module is called 'faithful' if its annihilator is trivial."
	^ self annihilator isTrivial! !

!Module methodsFor: 'testing' stamp: 'len 6/15/2023 16:41:33'!
isFinite
	self scalars isFinite ifTrue: [^ true].
	self scalars isPID ifTrue: [^ self invariants noneSatisfy: [:any| any isZero]].
	self isFreelyGenerated ifTrue: [^ self generators isEmpty].
	^ self notYetImplemented! !

!Module methodsFor: 'testing' stamp: 'len 7/8/2022 10:25:13'!
isFinitelyGenerated
	^ true! !

!Module methodsFor: 'testing' stamp: 'len 6/29/2023 19:42:59'!
isFlat
	"A module M is called flat if, for every injective homomorphism i:N→L, the induced map i⊗M:N⊗M→L⊗M is again injective.
	Equivalently, M is flat if -⊗M is an exact functor.
	See [GP08, 7.3. Flatness]."
	| i F |
	self isFreelyGenerated ifTrue: [^ true].
	i := 0.
	[(F := self fittingIdeal: i) isTrivial] whileTrue: [i := i + 1].
	^ F isOne! !

!Module methodsFor: 'testing' stamp: 'len 8/29/2024 15:27:25'!
isFree
	"Answer true if the receiver is a free module."
	self isFreelyGenerated ifTrue: [^ true].
	self isAbelianGroup ifTrue: [^ false]. "not freely generated f.g. abelian group is not free"
	(self isAmbient not and: [self ambient isFree and: [self scalars isPID]]) ifTrue: [^ true].
	"Quillen-Suslin theorem: every projective module over a PID or a polynomial ring over a field is free:"
	(self scalars isPID or: [(self scalars isKindOf: PolynomialRing) and: [self scalars scalars isField]]) ifTrue: [^ self isProjective].
	"Kaplansky's theorem:"
	self scalars isLocal ifTrue: [^ self isProjective].
	^ self notYetImplemented! !

!Module methodsFor: 'testing' stamp: 'len 6/10/2022 11:06:03'!
isFreelyGenerated
	"Answer true if the receiver is free on free generators."
"	self isTrivial ifTrue: [^ true]."
	(self isAmbient not and: [self ambient isFreelyGenerated and: [self scalars isPID]]) ifTrue: [^ true].
	^ self relationsMatrix isTrivial! !

!Module methodsFor: 'testing' stamp: 'len 3/6/2020 20:16:10'!
isFullRank
	^ self rank = self degree! !

!Module methodsFor: 'testing' stamp: 'len 7/13/2022 12:06:17'!
isGraded
	"A submodule is graded if it contains all the homogeneous components of each element."
	^ self scalars isGraded and: [self generators allSatisfy: [:each| each isHomogeneous]]! !

!Module methodsFor: 'testing' stamp: 'len 8/29/2024 15:21:57'!
isGroup
	^ self isAbelianGroup! !

!Module methodsFor: 'testing' stamp: 'len 4/20/2024 08:35:08'!
isInjective
	"A module M is called injective if Hom(-,M) is an exact functor."
	^ self notYetImplemented! !

!Module methodsFor: 'testing' stamp: 'len 1/23/2018 21:56:53'!
isLocal
	^ self scalars isLocal! !

!Module methodsFor: 'testing' stamp: 'len 6/5/2022 18:28:25'!
isLocallyFree
	"A finitely generated module over a Noetherian ring is locally free precisely if it is flat."
	self scalars isNoetherian ifFalse: [^ self notYetImplemented].
	^ self isFlat! !

!Module methodsFor: 'testing' stamp: 'len 7/3/2023 22:59:41'!
isMixed
	"An abelian group is mixed if it is neither a torsion group nor free."
	^ self isTorsion not and: [self isFree not]! !

!Module methodsFor: 'testing' stamp: 'len 1/11/2018 18:43:33'!
isModule
	^ true! !

!Module methodsFor: 'testing' stamp: 'len 7/26/2021 15:23:04'!
isMonomial
	"Answer true if the receiver is generated by monomials."
	^ self scalars scalars isField and: [self generators allSatisfy: [:each| each isMonomial]]! !

!Module methodsFor: 'testing' stamp: 'len 10/18/2023 18:46:42'!
isNoetherian
	"A module is called Noetherian if every submodule is finitely generated.
	This is equivalent to the module satisfying the ascending chain condition (every ascending chain of submodules is finite), and it is also equivalent to the condition that any set of submodules contains a maximal element."
	"A ring R is Noetherian if and only if every finitely generated R-module is a Noetherian module. Also, every finitely presented module is finitely generated:"
	^ self scalars isNoetherian or: [self isTrivial]! !

!Module methodsFor: 'testing' stamp: 'len 4/20/2024 08:47:21'!
isProjective
	"A module M is called projective if Hom(M,-) is an exact functor."
	self isFreelyGenerated ifTrue: [^ true]. "free modules are projective"
	self scalars isNoetherian ifTrue: [^ self isFlat]. "because every finitely presented module that is flat is also projective"
	self isFlat ifFalse: [^ false].
	^ self notYetImplemented! !

!Module methodsFor: 'testing' stamp: 'len 7/3/2023 22:07:57'!
isReflexive
	"Answer true if the receiver is a reflexive module."
	^ (self → self dual dual) isBijective! !

!Module methodsFor: 'testing' stamp: 'len 10/24/2023 16:05:39'!
isSemisimple
	"A module is 'semisimple' (or 'completely reducible') if it is the direct sum of simple (irreducible) submodules.
	A finitely generated module is semisimple if and only if it is artinian and its Jacobson radical is zero."
	(self isAmbient not and: [self ambient isSemisimple]) ifTrue: [^ true].
	self isVectorSpace ifTrue: [^ true].
	^ self isArtinian and: [self jacobsonRadical isTrivial] "because the receiver is finitely generated"! !

!Module methodsFor: 'testing' stamp: 'len 8/29/2024 15:27:30'!
isSimple
	"A nontrivial module is 'simple' if it has no nontrivial proper submodules, i.e. the only submodules are the trivial module and itself.
	A nontrivial group is 'simple' if the only normal subgroups are the trivial group and itself."
	self isTrivial ifTrue: [^ false]. "The trivial module is not simple."
	self isAbelianGroup ifTrue: [^ self isTorsion and: [self isCyclic and: [self size isPrime]]].
	^ self length = 1! !

!Module methodsFor: 'testing' stamp: 'len 8/29/2024 15:27:36'!
isTorsion
	"Answer true if the receiver is a torsion module.
	An abelian group is called 'torsion' or 'periodic' if every element has finite order."
	self isAbelianGroup ifTrue: [^ self invariants noneSatisfy: [:each| each = 0]].
	^ self torsion = self! !

!Module methodsFor: 'testing' stamp: 'len 7/3/2023 22:48:08'!
isTorsionFree
	"Answer true if the receiver is a torsion-free module, i.e. its torsion submodule is trivial.
	An abelian group is called 'torsion-free' if every nonzero element has infinite order."
	^ self torsion isTrivial! !

!Module methodsFor: 'testing' stamp: 'len 7/3/2023 21:21:57'!
isTorsionless
	"Answer true if the receiver is a torsionless (or semi-reflexive) module."
	^ (self → self dual dual) isInjective! !

!Module methodsFor: 'testing' stamp: 'len 6/11/2022 08:22:43'!
isTrivial
	"Answer true if the receiver is the trivial submodule {0}."
	^ self generatorMatrix isZero! !

!Module methodsFor: 'testing' stamp: 'len 3/5/2020 17:45:29'!
isVectorSpace
	^ self scalars isField or: [self isTrivial]! !

!Module methodsFor: 'testing' stamp: 'len 4/10/2024 12:10:53'!
isZero
	"Answer true if the receiver is the zero object, i.e. the trivial module {0}."
	^ self isTrivial! !

!Module methodsFor: 'private' stamp: 'len 10/26/2020 16:25:33'!
generatorMatrix: aMatrix
	self propertyAt: #generatorMatrix put: aMatrix! !

!Module methodsFor: 'private' stamp: 'len 5/2/2020 05:14:06'!
species
	^ Module! !

!Ideal methodsFor: 'accessing' stamp: 'len 10/30/2023 19:01:02'!
denominator
	"If the coefficient ring is a localization, return the LCM of the denominators of the generators."
	self scalars isLocalization ifFalse: [^ self scalars one].
	^ self propertyAt: #denominator ifAbsentPut:
		[self generators inject: self scalars numerators one into: [:d :each| each denominator lcm: d]]! !

!Ideal methodsFor: 'accessing' stamp: 'len 12/15/2021 15:17:28'!
generators
	^ self propertyAt: #generators ifAbsentPut: [self generatorMatrix asTuple asArray]! !

!Ideal methodsFor: 'accessing' stamp: 'len 12/22/2021 14:18:14'!
height
	"Answer the height (or codimension, or rank) of the receiver.
	This is the length of the longest ascending chain of prime ideals containing it.
	The height of a prime ideal is also the Krull dimension of the ring localization at that ideal."
	self isPrime ifFalse: [^ self notYetImplemented].
	^ (self scalars @ self) dimension! !

!Ideal methodsFor: 'accessing' stamp: 'len 12/25/2021 12:44:56'!
norm
	"Answer the ideal norm of the receiver, i.e. the order of the quotient ring."
	^ (self scalars / self) size! !

!Ideal methodsFor: 'accessing' stamp: 'len 10/30/2023 10:34:07'!
numerator
	"If the coefficient ring is a localization, return the product of the receiver by the LCM of the denominators of the generators, as a module over the numerators of the localization ring."
	self scalars isLocalization ifFalse: [^ self scalars one].
	^ self propertyAt: #numerator ifAbsentPut:
		[| d |
		d := self scalars !! self denominator.
		self scalars numerators * (self generators collect: [:each| (each * d) numerator])]! !

!Ideal methodsFor: 'accessing' stamp: 'len 8/3/2021 14:55:43'!
ordering
	^ self scalars ordering! !

!Ideal methodsFor: 'accessing' stamp: 'len 10/5/2022 18:38:50'!
relationsMatrix
	self isAmbient ifTrue: [^ self propertyAt: #relationsMatrix ifAbsentPut: [self scalars^0 → self generatorMatrix domain]].
	^ super relationsMatrix! !

!Ideal methodsFor: 'accessing' stamp: 'len 6/10/2022 11:45:06'!
representative
	"If the receiver is an ideal I of a quotient ring A/J, return a lifting of I to A."
	^ self propertyAt: #representative ifAbsentPut: [self scalars cover * (self generators collect: [:each| each representative]) + self scalars relations]! !

!Ideal methodsFor: 'comparing' stamp: 'len 12/15/2021 16:25:32'!
= anObject
	((anObject isKindOf: Ideal) and: [self scalars = anObject scalars]) ifFalse: [^ false].
	self isAmbient ifTrue: [^ anObject isOne].
	anObject isAmbient ifTrue: [^ self isOne].
	^ super = anObject! !

!Ideal methodsFor: 'comparing' stamp: 'len 12/10/2023 10:35:50'!
| anIdeal
	"Answer true if the receiver divides the argument."
	^ self ⊇ anIdeal! !

!Ideal methodsFor: 'comparing' stamp: 'len 5/23/2022 11:35:10'!
⊥ anIdeal
	"Answer true if the receiver and the argument are comaximal.
	Two ideals I and J in a commutative ring R are called coprime or comaximal when I + J = R."
	^ (self + anIdeal) isOne! !

!Ideal methodsFor: 'converting' stamp: 'len 10/23/2016 21:09'!
asIdeal
	^ self! !

!Ideal methodsFor: 'converting' stamp: 'len 8/3/2021 14:48:38'!
orderedBy: aMonomialOrdering
	^ (self scalars orderedBy: aMonomialOrdering) !! self! !

!Ideal methodsFor: 'converting' stamp: 'len 6/14/2023 22:44:36'!
over: aRing
	^ aRing * (self generators collect: [:each| aRing !! each])! !

!Ideal methodsFor: 'elements' stamp: 'len 12/12/2023 20:00:18'!
\ anElement
	"Answer coordinates of anElement expressed as a linear combination of the elements of the distinguished generating set of the receiver. Answer nil if anElement is not in the receiver."
	self isAmbient ifTrue: [^ self freeCover elementAt: {anElement}].
	^ super \ anElement! !

!Ideal methodsFor: 'elements' stamp: 'len 11/10/2023 19:41:51'!
adapt: anElement
	(self includes: anElement) ifTrue: [^ anElement].
	^ (super adapt: anElement) ifNil: [self scalars adapt: anElement]! !

!Ideal methodsFor: 'morphisms' stamp: 'len 6/14/2023 22:48:31'!
apply: aMorphism
	aMorphism isBlock
		ifTrue: [^ self scalars * (self generators collect: aMorphism)].
	aMorphism domain = self scalars
		ifTrue: [^ aMorphism codomain * (self generators collect: aMorphism)].
	^ super apply: aMorphism! !

!Ideal methodsFor: 'operations' stamp: 'len 8/12/2022 13:37:05'!
* anElementOrIdeal
	"The product is included in the intersection: I*J <= I ∩ J.
	When the ideals are comaximal, the equality holds."
	^ super * anElementOrIdeal! !

!Ideal methodsFor: 'operations' stamp: 'len 11/7/2023 21:12:28'!
: anIdeal
	"Answer the conductor I : J of the argument J into the receiver I (also called colon quotient).
	This is defined as I : J := {r in R | rJ <= I} and it is isomorphic to Hom(R/I, R/J)."
	self isAmbient ifTrue: [^ self].
	self scalars isQuotient ifTrue: [^ self representative : anIdeal representative ⊗ self scalars].
	^ super : anIdeal! !

!Ideal methodsFor: 'operations' stamp: 'len 4/6/2024 08:24:19'!
^ anInteger
	"Answer the receiver raised to the power anInteger."
	anInteger isInteger ifFalse: [^ super ^ anInteger].
	anInteger = 0 ifTrue: [^ self scalars asIdeal].
	anInteger = 1 ifTrue: [^ self].
	self assert: anInteger positive.
	^ anInteger even ifTrue: [self squared ^ (anInteger // 2)] ifFalse: [self squared ^ (anInteger // 2) * self]! !

!Ideal methodsFor: 'operations' stamp: 'len 6/21/2022 09:17:05'!
associatedPrimes
	"The set of associated primes of an ideal I is defines as:
		Ass(I) := {P <= R | P is prime and P = I : <b> for some b in A}."
	^ self notYetImplemented! !

!Ideal methodsFor: 'operations' stamp: 'len 6/15/2022 10:04:10'!
leadingIdeal
	"Answer the initial ideal. This is the ideal of all leading terms of the receiver."
	^ self leadingSubmodule! !

!Ideal methodsFor: 'operations' stamp: 'len 11/7/2023 21:13:04'!
radical
	"Answer the radical ideal √I of the receiver I. This is the ideal such that an element x is in √I if and only if some power of x is in I.
	Note: not to be confused with the Jacobson radical of a module."
	self scalars isQuotient ifTrue: [^ self representative radical ⊗ self scalars].
	((self isTrivial and: [self scalars isIntegralDomain]) or: [self isOne]) ifTrue: [^ self].
	(self generators size = 1 and: [self scalars isUFR]) ifTrue: [^ self scalars * self generator radical].
	^ self subclassResponsibility! !

!Ideal methodsFor: 'operations' stamp: 'len 10/6/2022 11:49:54'!
reduce: anElement
	"Answer zero if anElement is in the receiver, and otherwise answer some representative of the coset 'anElement + self' (not necessarily a normal form).
	It is required that:
		(I reduce: x) = (I reduce: y) ⟺ x - y ∈ I, and
		∀ x, y ∈ I, x - (I reduce: x) ∈ I.
	Subclasses should override."
	self isAmbient ifTrue: [^ self zero].
	(anElement isZero or: [self isTrivial]) ifTrue: [^ anElement].
"	self scalars isQuotient ifTrue: [^ self scalars project: (self representative reduce: anElement representative)]."
	self scalars isEuclidean ifTrue: [^ anElement \\ self generator].
	^ super reduce: anElement! !

!Ideal methodsFor: 'operations' stamp: 'len 6/7/2022 12:53:51'!
saturation: anIdeal
	"Answer the saturation ideal I : J^∞ of the receiver I with the argument J."
	^ self subclassResponsibility! !

!Ideal methodsFor: 'operations' stamp: 'len 6/6/2019 12:04:50'!
squared
	^ self * self! !

!Ideal methodsFor: 'operations' stamp: 'len 7/3/2023 00:44:55'!
sub: aCollectionOrMatrix
	| generator generators |
	aCollectionOrMatrix isMatrix ifTrue: [^ super sub: aCollectionOrMatrix].
	generators := aCollectionOrMatrix asSet select: [:each| each isZero not].
	self scalars isEuclidean ifTrue:
		[generator := self scalars zero.
		generators do: [:each| generator := generator gcd: each].
		(self isAmbient and: [generator isOne]) ifTrue: [^ self].
		^ super sub: {generator}].
	(self isAmbient and: [generators anySatisfy: [:any| any isUnit]]) ifTrue: [^ self].
	^ super sub: generators! !

!Ideal methodsFor: 'operations' stamp: 'len 8/12/2022 13:09:06'!
∩ anIdeal
	"Answer the intersection of the receiver and the argument."
	self isAmbient ifTrue: [^ anIdeal].
	anIdeal isAmbient ifTrue: [^ self].
	self scalars isEuclidean ifTrue: [^ self scalars * (self generator lcm: anIdeal generator)].
	^super ∩ anIdeal! !

!Ideal methodsFor: 'printing' stamp: 'len 7/1/2022 10:48:22'!
printGeneratorsOn: aStream
	self isTrivial ifTrue: [aStream print: self zero. ^ self].
	self generators "asSortedCollection: [:a :b| a printString <= b printString])"
		do: [:each| aStream print: each] separatedBy: [aStream nextPutAll: ', ']! !

!Ideal methodsFor: 'printing' stamp: 'len 4/9/2024 08:39:26'!
printOn: aStream
	self isTrivial ifTrue: [^ super printOn: aStream].
	self isOne ifTrue: [aStream print: self scalars. ^ self].
	(self scalars isKindOf: ModularIntegerRing) ifTrue: [aStream print: self generator; print: self scalars. ^ self].
	self scalars = ℤ ifTrue: [aStream print: self generator; nextPut: $ℤ. ^ self].
	aStream withAngleBrackets: [:aStream2| self printGeneratorsOn: aStream2]! !

!Ideal methodsFor: 'testing' stamp: 'len 12/15/2021 20:55:08'!
contains: anElement
	^ self isAmbient or: [(self reduce: anElement) isZero]! !

!Ideal methodsFor: 'testing' stamp: 'len 12/15/2021 14:52:19'!
includes: anObject
	^ (self scalars includes: anObject) and: [self contains: anObject]! !

!Ideal methodsFor: 'testing' stamp: 'len 6/21/2022 09:19:48'!
isEquidimensional
	"Answer true if the receiver is pure dimensional or equidimensional, i.e. if all associated primes have the same dimension."
	^ (self associatedPrimes collect: [:each| each dimension]) asSet size <= 1! !

!Ideal methodsFor: 'testing' stamp: 'len 5/7/2022 07:27:46'!
isFree
	"Answer true if the receiver is a free module.
	An ideal is a free module iff it is principal and generated by a non-zero-divisor."
	^ self isPrincipal and: [self generator isZeroDivisor not]! !

!Ideal methodsFor: 'testing' stamp: 'len 7/13/2022 12:04:42'!
isHomogeneous
	^ self isGraded! !

!Ideal methodsFor: 'testing' stamp: 'len 5/5/2018 18:59:14'!
isIntegral
	"This is an integral ideal (not a fractional ideal)."
	^ true! !

!Ideal methodsFor: 'testing' stamp: 'len 10/12/2023 18:11:11'!
isMaximal
	"A proper ideal I of R is called 'maximal' if it is not contained in any other proper ideal.
	I is maximal iff the quotient ring R/I is a field.
	Every maximal ideal is prime.
	In a PID every nonzero prime ideal is maximal.
	In a zero-dimensional ring (in particular an artinian ring) every prime ideal is maximal."
	self scalars isQuotient ifTrue: [^ self representative isMaximal].
	self scalars isPID ifTrue:
		[self scalars isField ifTrue: [^ self isZero].
		^ self isZero not and: [self isPrime]].
	self scalars isArtinian ifTrue: [^ self isPrime].
	self isPrime ifFalse: [^ false].
	^ false "undefined"! !

!Ideal methodsFor: 'testing' stamp: 'len 10/12/2023 18:12:02'!
isMinimalPrime
	self scalars isIntegralDomain ifTrue: [^ self isZero].
	self scalars isArtinian ifTrue: [^ self isMaximal].
	^ self notYetImplemented! !

!Ideal methodsFor: 'testing' stamp: 'len 7/30/2019 05:29:37'!
isNilIdeal
	"An ideal is called nil-ideal if all its elements are nilpotent."
	^ self generators allSatisfy: [:each| each isNilpotent]! !

!Ideal methodsFor: 'testing' stamp: 'len 5/8/2020 15:30:19'!
isNilpotent
	"An ideal I is called nilpotent if there is an integer n >= 1 such that I^n = 0."
	self generators size = 1 ifTrue: [^ self generator isNilpotent].
	^ self notYetImplemented! !

!Ideal methodsFor: 'testing' stamp: 'len 8/3/2021 14:57:25'!
isOne
	"Answer true if the receiver is the unit ideal <1> (the whole ring)."
	^ self contains: self scalars one! !

!Ideal methodsFor: 'testing' stamp: 'len 6/25/2023 00:29:51'!
isPrimary
	"An ideal I of a commutative ring is called 'primary' if for all x*y in I, x or y^n (n>0) is also in I."
	self scalars = ℤ ifTrue: [^ self isTrivial or: [self generator isPrimePower]].
	^ self notYetImplemented! !

!Ideal methodsFor: 'testing' stamp: 'len 10/12/2023 18:07:36'!
isPrime
	"An ideal I of R is prime iff R/I is an integral domain.
	Every maximal ideal is prime.
	In a PID every nonzero prime ideal is maximal.
	In a zero-dimensional ring every prime ideal is maximal."
	self scalars isQuotient ifTrue: [^ self representative isPrime].
	(self scalars isIntegralDomain and: [self isZero]) ifTrue: [^ true].
	(self scalars isUFD and: [self isPrincipal]) ifTrue: [^ self generator isIrreducible].
	self isOne ifTrue: [^ false].
	(self scalars isCommutative and: [self scalars isFinite])
		ifTrue: [^ self scalars allSatisfy: [:a|
					self scalars allSatisfy: [:b|
						(self includes: a*b) not or: [(self includes: a) or: [self includes: b]]	]]].
	"This method only works for zero ideals or ideals given by one generator; subclasses should reimplement."
	self flag: #fix.
	^ false "undefined"! !

!Ideal methodsFor: 'testing' stamp: 'len 2/20/2024 13:54:48'!
isPrincipal
	"Answer true if the receiver is generated by a single element."
	self generators size <= 1 ifTrue: [^ true].
	self scalars hasCanonicalBases ifTrue: [^ false].
	self scalars isPIR ifTrue: [^ true].
	(self scalars isQuotient and: [self representative isPrincipal]) ifTrue: [^ true].
	(self scalars isLocalization and: [self numerator isPrincipal]) ifTrue: [^ true].
	^ self notYetImplemented! !

!Ideal methodsFor: 'testing' stamp: 'len 1/16/2018 16:09:50'!
isProper
	^ self isZero not and: [self isOne not]! !

!Ideal methodsFor: 'testing' stamp: 'len 10/24/2023 16:07:52'!
isRadical
	"Answer true if the receiver I is a radical ideal, i.e. I = √I."
	^ self = self radical! !

!Ideal methodsFor: 'testing' stamp: 'len 2/14/2017 10:24:17'!
isSaturated
	^ self = self saturation! !

!Ideal methodsFor: 'testing' stamp: 'len 6/6/2022 11:48:53'!
isSemiprime
	"An ideal I of a commutative ring is called 'semiprime' if for all x^k (k>0) in I, also x is in I.
	Equivalently, for all y not in I, y^k (k>0) is also not in I."
	self scalars = ℤ ifTrue: [^ self isTrivial or: [self generator isSquarefree]].
	^ self notYetImplemented! !

!Ideal methodsFor: 'testing' stamp: 'len 10/24/2023 16:08:09'!
radicalContains: anElement
	"Answer true if the radical of the receiver includes anElement, i.e. if some power of anElement is in the receiver."
	^ self radical contains: anElement! !

!Ideal methodsFor: 'private' stamp: 'len 7/15/2021 12:09:46'!
species
	^ self scalars idealClass! !

!IntegralIdeal methodsFor: 'as yet unclassified' stamp: 'len 7/6/2023 19:33:44'!
asFractionalIdeal
	self assert: self isZero not.
	self assert: self scalars isDedekindDomain.
	^ FractionalIdeal numerator: self denominator: self scalars one! !

!IntegralIdeal methodsFor: 'as yet unclassified' stamp: 'len 7/6/2023 22:02:30'!
minimum
	^ self basisMatrix at: 1@1 "assuming it's HNF"! !

!IntegralIdeal methodsFor: 'as yet unclassified' stamp: 'len 7/6/2023 19:43:30'!
norm
	self scalars isDedekindDomain ifFalse: [^ super norm].
	^ self basisMatrix determinant! !

!IntegralIdeal methodsFor: 'as yet unclassified' stamp: 'len 7/6/2023 21:51:56'!
primitiveElement
	"Answer an element in the receiver such that it is not in the square of the receiver.
	If the receiver is an ideal in a maximal order, one of the two generators of a two-element representation is a primitive element.
	Alternatively, if the receiver is represented by a basis in HNF, one of the basis elements is primitive. But it's usually faster to compute a two-element representation."
	| S |
	self assert: self isTrivial not.
	self assert: self scalars isDedekindDomain.
	S := self squared.
	^ self twoGenerators detect: [:one| (S includes: one) not]
	
"
alternative:
	^ self basis detect: [:one| (S includes: one) not]
"! !

!IntegralIdeal methodsFor: 'as yet unclassified' stamp: 'len 7/6/2023 19:35:09'!
twoGenerators
	^ self notYetImplemented! !

!IntegralIdeal methodsFor: 'as yet unclassified' stamp: 'len 12/10/2023 10:36:24'!
valuation: p
	"Answer the p-adic valuation of the receiver, where p is an invertible prime ideal."
	| I answer |
	self isZero ifTrue: [^ Infinity positive].
	answer := 0.
	I := p.
	[self ⊆ I] whileTrue: [I := I * p. answer := answer + 1].
	^ answer! !

!PolynomialIdeal methodsFor: 'accessing' stamp: 'len 1/13/2022 10:31:49'!
degree
	"Answer the degree of the ideal, i.e. the number of monomials that are not multiple of any leading monomial in the Groebner basis."
	| G count leadingMonomials |
	leadingMonomials _ Set new.
	G _ self basis "minimal".
	G do: [:each| leadingMonomials add: each leadingMonomial].
	count _ 0.
	G do: [:each|
		each monomialsDo: [:monomial|
			(leadingMonomials noneSatisfy: [:lm| lm | monomial])
					ifTrue: [count _ count + 1]]].
	^ count! !

!PolynomialIdeal methodsFor: 'accessing' stamp: 'len 5/4/2023 22:47:10'!
gradedBasis
	^ self propertyAt: #gradedBasis ifAbsentPut: [(self scalars isGraded ifTrue: [self] ifFalse: [self orderedBy: #grevlex]) basis]! !

!PolynomialIdeal methodsFor: 'accessing' stamp: 'len 4/6/2021 13:14:53'!
minimalMonomialGeneratingSet
	^ self propertyAt: #minimalMonomialGeneratingSet ifAbsentPut:
		[| answer |
		answer _ Set new.
		(self generators asSortedCollection: [:a :b| a degree <= b degree])
			do: [:each|
				"make sure the generating set is minimal (and thus unique):"
				(answer anySatisfy: [:any| any | each]) ifFalse: [answer add: each].
		answer]]! !

!PolynomialIdeal methodsFor: 'accessing' stamp: 'len 7/30/2021 12:35:23'!
univariateExponent
	"Answer the univariate exponent of the receiver.
	See [BW93], Definition 8.24."
	| answer |
	answer _ 1.
	self scalars indeterminates do: [:i| | f mu |
		f _ (self eliminateAllBut: i) generator.
		mu _ 1.
		f factorizationDo: [:p :s| mu _ mu max: s].
		answer _ answer + (mu - 1)].
	^ answer! !

!PolynomialIdeal methodsFor: 'accessing' stamp: 'len 10/24/2023 16:09:10'!
variety
	"Answer the algebraic variety that is the set of zeroes of all polynomials in the receiver."
	^ self isHomogeneous ifTrue: [(self scalars / self radical) proj] ifFalse: [(self scalars / self radical) spec]! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 8/12/2022 13:17:21'!
: anIdeal
	"Answer the conductor I : J of the argument J into the receiver I (also called colon quotient).
	This is defined as I : J := {r in R | rJ <= I} and it is isomorphic to Hom(R/I, R/J)."
	"See [CLO97] pag. 205, [DK02] pag. 16, [HH11] Proposition 1.2.2."
	| R answer |
	R _ self scalars.
	R isIntegralDomain ifFalse: [^ super : anIdeal].
	answer _ R asIdeal. "<1>"
	(self isMonomial and: [anIdeal isMonomial])
		ifTrue:
			[anIdeal minimalMonomialGeneratingSet do: [:g|
				answer _ answer ∩ (R * (self minimalMonomialGeneratingSet collect: [:each| each / (each gcd: g)]))]]
		ifFalse:
			[anIdeal generators do: [:g|
				answer _ answer ∩ (R * ((R * g ∩ self) basis apply: [:h| h / g]))]].
	^ answer! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 4/6/2021 12:48:38'!
alexanderDual
	"Answer the Alexander dual of the receiver.
	If I is the Stanley-Reisner ideal of a simplicial complex S, the Alexander dual of I is defined as the Stanley-Reisner ideal of the dual of S."
	^ self asSimplicialComplex dual stanleyReisnerIdealIn: self scalars! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 6/25/2023 19:41:47'!
asSimplicialComplex
	"Answer the Stanley-Reisner simplicial complex associated to the receiver.
	This is the simplicial complex formed by the support of all squarefree monomials not in this ideal.
	Fail if this ideal is not squarefree."
	self isMonomial ifFalse: [^ self error: 'not a monomial ideal'].
	self isRadical ifFalse: [^ self error: 'not squarefree'].
	^ (SimplicialComplex on: self scalars indeterminates facets: (self minimalMonomialGeneratingSet collect: [:each| each indeterminates])) complement dual! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 3/6/2021 14:04:35'!
dehomogenizedIn: anIndeterminate
	"Answer the dehomogenization of the receiver removing the given indeterminate."
	| R S |
	R _ self scalars.
	S _ R slice: (R indeterminates select: [:i| i ~= anIndeterminate]).
	^ S * (self generators collect: [:each| S !! (each dehomogenizedIn: anIndeterminate)])! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 10/21/2023 21:51:39'!
eliminateAll: aCollection
	"Answer the elimination ideal for the indeterminates in aCollection = {xᵢ}, i.e. the subideal of polynomials without indeterminates {xᵢ}."
	| freeIndeterminates G newGenerators |
	freeIndeterminates := self scalars ordering indeterminates reject: [:each| aCollection includes: each].
	self scalars ordering isGlobal ifFalse: [self notYetImplemented].
	"if the ideal is homogeneous, should we use use glex?"
	G := (self orderedBy: (MonomialOrdering lex: aCollection), (MonomialOrdering grevlex: freeIndeterminates)) basis.
	newGenerators := G asArray select: [:each| (aCollection noneSatisfy: [:none| each has: none])].
	^ self scalars * (newGenerators collect: [:each| self scalars !! each])! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 8/3/2021 14:43:11'!
highestCorner
	"Answer the highest corner of the receiver I.
	This is the unique monomial m such that:
		1) m is not in the leading ideal of I;
		2) if m' < m, then m' is in the leading ideal of I."
	self scalars ordering isGlobal
		ifTrue: [^ self isProper ifTrue: [self scalars monomials identity]].
	"TODO: compute it combinatorially from a standard basis"
	self notYetImplemented! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 5/23/2020 09:10:45'!
hilbertSeries
	"Answer the Hilbert series of the receiver expressed as a rational function in Q(t)."
	^ self hilbertSeriesAt: (ℚ polynomialsIn: #(t)) fractions x! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 7/6/2022 11:20:42'!
hilbertSeriesAt: t
	"Answer the Hilbert series corresponding to the quotient by the receiver."
	| R n m J int |
	self isZero ifTrue: [^ t zero].
	self isMonomial ifFalse: 
		[self isHomogeneous ifFalse: [^ self notYetImplemented].
		^ self leadingIdeal hilbertSeriesAt: t].
	"For monomial ideals:"
	R _ self scalars.
	n _ R rank.
	m _ self generators asArray last.
	J _ R * (self generators copyWithout: m).
	int _ R * (J generators collect: [:each| each lcm: m]).
	^ t ^ m degree / ((1 to: n) product: [:i| 1 - (t ^ (R ordering weightOf: i))])
		+ (J hilbertSeriesAt: t)
		- (int hilbertSeriesAt: t)! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 6/27/2023 18:57:56'!
homogenized
	"Answer the homogenization of the receiver introducing a new indeterminate."
	"Must use a graded monomial ordering such as glex or grevlex:"
	^ self scalars homogenization * (self gradedBasis collect: [:each| each homogenized])! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 4/6/2021 12:52:17'!
polarization
	"Answer the polarization of the receiver.
	The polarization is a deformation that assigns to an arbitrary monomial ideal a squarefree monomial ideal in a new set of variables."
	self isMonomial ifFalse: [^ self error: 'not a monomial ideal'].
	self notYetImplemented	! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 12/17/2021 14:44:19'!
predecomposition
	"See [BW93], Table 8.1, Algorithm PREDEC."
	| R answer |
	R _ self scalars.
	answer _ Set with: self.
	R indeterminates do: [:i| | previous |
		previous _ answer.
		answer _ Set new.
		(self eliminateAllBut: i) generator normalized factorizationDo: [:p :s|
			previous do: [:G| | H | (H _ G + (p^s)) isProper ifTrue: [answer add: H]]]].
	^ answer! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 6/25/2023 19:42:47'!
primaryDecomposition
	"Answer the standard primary decomposition of the receiver.
	This is the unique primary decomposition obtained from an irredundant intersection of irreducible ideals."
	(self isMonomial and: [self isRadical]) ifFalse: [^ super primaryDecomposition].
	^ self asSimplicialComplex facets collect: [:each|
		self scalars * (self scalars indeterminates \ each vertices collect: [:i| self scalars x: i])]! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 10/24/2023 16:11:19'!
radical
	self isMonomial ifTrue: [^ self scalars * (self generators collect: [:each| each radical])]. "[HH11] Proposition 1.2.4"
	(self scalars scalars characteristic > 0 and: [self scalars scalars isPerfectField]) ifTrue: [^ self radicalMatsumoto].
	self isZeroDimensional ifTrue: [^ self radicalZeroDimensional].
	self flag: #fixme. "this is not right, maybe only works for ℚ[x₁...xₙ] and monomial ideals"
	^ self scalars * (self generators collect: [:each| each radical])! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 6/3/2022 21:27:56'!
reduce: anElement
	(anElement isZero or: [self isTrivial]) ifTrue: [^ anElement].
	(self scalars isEuclidean or: [self generators size = 1 and: [self generator isMonic and: [self generator isUnivariate]]]) ifTrue: [^ anElement \\ self generator].
	^ anElement reductionFullBy: self basis
"	^ super reduce: anElement"! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 6/20/2023 20:43:55'!
saturation
	"Answer the saturation ideal I : J^∞ of the receiver I, where J is the irrelevant ideal generated by the indeterminates."
	^ self saturation: self scalars * self scalars generators! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 6/20/2023 20:42:32'!
saturation: anIdeal
	"Answer the saturation ideal I : J^∞ of the receiver I with the argument J."
	"See [CLO97] pag. 205, [DK02] pag. 16."
	| P t J |
	P := self scalars scalars polynomialsIn: self scalars rank + 1.
	t := P x: P rank.
	J := P !! self.
	anIdeal generators do: [:each|
		J := J + (P * (t * (P !! each) - P one)).
		J := J eliminate: P rank].
	^ self scalars * (J generators collect: [:each| self scalars !! each])! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 5/6/2023 18:18:59'!
singular
	"Answer the singular locus of the receiver (or more precisely of the quotient by the receiver). The singular locus is defined as:
		Sing(A) := {P in Spec(A) | the localization of A at P is not regular}.
	If the receiver is not equidimensional, its lower-dimensional components will be contained in the answer whether they are singular or not.
	(See [Eis95] Ch. 20, re Fitting ideal.)"
	| R generators n d jacobian J |
	self flag: #fix. "TODO: implement singular locus in general, from 'A Singular Introduction to Commutative Algebra', Algorithm 5.7.8"
	R _ self scalars.
	generators _  self generators asArray.
	n _ R rank.
	d _ (R/self) dimension.
	jacobian _ R ^ generators size to: R^n fill: [:i :j| (generators at: j) derivativeIn: i].
	J _ self scalars * (jacobian minors: n - d).
	^ self + J
"before I did:
	J _ R matrix: n @ generators size map: [:i :j| (generators at: j) derivativeIn: i].
	^ self scalars * ((J minors: n - d) collect: [:each| self reduce: each])
but that seems to be wrong"! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 10/26/2023 14:02:51'!
∩ anIdeal
	| R S t |
	self assert: self scalars = anIdeal scalars.
	self isTrivial ifTrue: [^ self].
	anIdeal isTrivial ifTrue: [^ anIdeal].
	(self isMonomial and: [anIdeal isMonomial])
		ifTrue: "[HH11] Proposition 1.2.1."
			[| generators |
			generators := Set new.
			self minimalMonomialGeneratingSet do: [:each|
				anIdeal minimalMonomialGeneratingSet do: [:other| generators add: (each lcm: other)]].
			^ self scalars * generators].
	"To compute I ∩ J we introduce a new variable t, then eliminate it from the ideal I·t + J·(1-t):"
	R := self scalars.
	S := R scalars polynomialsIn: R rank + 1.
	t := S x: S rank.
	^ R !! (S !! self * t + (S !! anIdeal * (t - S one)) eliminate: S rank)! !

!PolynomialIdeal methodsFor: 'printing' stamp: 'len 1/13/2022 10:32:19'!
printStaircase
	| w h matrix |
	w _ self generators max: [:each| (each degreeIn: 1) + 1].
	h _ self generators max: [:each| (each degreeIn: 2) + 1].
	matrix _ (1 to: h) collect: [:x| (1 to: w) collect: [:y| ' ']].
	self basis do: [:each| | x y |
		x _ each degreeIn: 1.
		y _ each degreeIn: 2.
		(matrix at: h-y) at: x+1 put: 'X'].
	^ String streamContents: [:aStream| matrix do: [:line| line do: [:dot| aStream nextPutAll: dot]] separatedBy: [aStream lf]]! !

!PolynomialIdeal methodsFor: 'testing' stamp: 'len 5/1/2024 12:25:44'!
isIrreducible
	"Irreducible monomial ideals are those generated by powers of some of the variables."
	self isMonomial ifTrue: [^ self minimalMonomialGeneratingSet allSatisfy: [:each| each monomials any support size = 1]].
	^ super isIrreducible! !

!PolynomialIdeal methodsFor: 'testing' stamp: 'len 10/25/2023 07:43:48'!
isMaximal
	"A proper ideal I of R is called 'maximal' if it is not contained in any other proper ideal.
	See [ABPR19, Algorithm 4.16 IsMaximal]."
	| K Q d μ ℓ |
	(K := self scalars scalars) isPerfectField ifFalse: [^ super isMaximal].
	self isZeroDimensional ifFalse: [^ false].
	Q := self scalars / self.
	d := Q asModule rank.
	Q generators do: [:xᵢ|
		μ := xᵢ minimalPolynomial.
		μ isIrreducible ifFalse: [^ false].
		μ degree = d ifTrue: [^ true]].
	"If K is a finite field GF(q), compute the q-Frobenius space and check if dimension is 1:" 
	K isFinite ifTrue: [^ Q frobeniusSpace rank = 1].
	"If K is infinite, test random linear forms:"
	[ℓ := Q generators sum: [:each| each * K atRandom].
	μ := ℓ minimalPolynomial.
	μ isIrreducible ifFalse: [^ false].
	μ degree = d ifTrue: [^ true]] repeat! !

!PolynomialIdeal methodsFor: 'testing' stamp: 'len 10/21/2023 13:44:37'!
isPrimary
	"An ideal I of a commutative ring is called 'primary' if for all x*y in I, x or y^n (n>0) is also in I."
	self isZeroDimensional ifTrue: [^ self isPrimaryZeroDimensional].
	"Primary monomial ideals are those containing powers of each of a certain subset of the variables, and generated by elements involving no further variables."
	self flag: #fixme. "TODO: implement for monomial ideals"
	^ super isPrimary! !

!PolynomialIdeal methodsFor: 'testing' stamp: 'len 5/1/2024 12:26:09'!
isPrime
	"Prime monomial ideals are those generated by subsets of the variables."
	self isMonomial ifTrue: [^ self minimalMonomialGeneratingSet allSatisfy: [:each| each degree = 1 and: [each monomials any support size = 1]]].
	"TODO: 	[AL94, Algorithm 4.4.1]"
	^ super isPrime! !

!PolynomialIdeal methodsFor: 'testing' stamp: 'len 10/20/2023 10:04:21'!
isRadical
	self isMonomial ifTrue: [^ self generators allSatisfy: [:each| each isSquarefree]].
	self isZeroDimensional ifTrue: [^ self isRadicalZeroDimensional].
	^ super isRadical! !

!PolynomialIdeal methodsFor: 'testing' stamp: 'len 10/10/2023 21:44:36'!
isZeroDimensional
	^ self propertyAt: #isZeroDimensional ifAbsentPut: [(self scalars / self) isZeroDimensional]! !

!PolynomialIdeal methodsFor: 'testing' stamp: 'len 3/4/2021 13:43:02'!
radicalContains: aPolynomial
	"(Radical Membership Problem)
	Answer true if the radical of the receiver includes aPolynomial.
	Use Rabinowitsch's trick introducing a new indeterminate."
	| R S t X |
	R _ self scalars.
	S _ R scalars polynomialsIn: R rank + 1.
	t _ S x: R rank + 1.
	X _ OrderedCollection new.
	self generators do: [:g| X add: S !! g].
	X add: S !! aPolynomial * t - S one.
	^ (S * X) isOne! !

!PolynomialIdeal methodsFor: 'private' stamp: 'len 5/1/2024 12:26:01'!
isPrimaryZeroDimensional
	"See [ABPR19, Algorithm 4.19 IsPrimary0Dim]."
	| J Q d μ factorization K ℓ |
	J := self.
	Q := self scalars / J.
	d := Q asModule rank.
	Q generators do: [:xᵢ|
		μ := xᵢ minimalPolynomial.
		"If μ is not the power of an irreducible factor, return false:"
		(factorization := μ factorization) asSet size = 1 ifFalse: [^ false].
		μ degree = d ifTrue: [^ true].
		factorization size = 1 ifFalse: "is it square-free?"
			[μ := factorization any. "get the square-free part"
			J := J + (self scalars * (μ value: xᵢ)).
			Q := self scalars / J.
			d := Q asModule rank.
			μ degree = d ifTrue: [^ true]]].
	K := self scalars scalars.
	"If K is a finite field GF(q), compute the q-Frobenius space and check if dimension is 1:" 
	K isFinite ifTrue: [^ (self scalars / self) frobeniusSpace rank = 1].
	"If K is infinite, test random linear forms:"
	[ℓ := Q generators sum: [:each| each * K atRandom].
	μ := ℓ minimalPolynomial.
	μ isIrreducible ifFalse: [^ false].
	μ degree = d ifTrue: [^ true]] repeat! !

!PolynomialIdeal methodsFor: 'private' stamp: 'len 7/30/2021 12:34:27'!
isRadicalZeroDimensional
	"Answer true if the receiver is radical, assuming its quotient is zero-dimensional.
	See [BW93], Table 8.2, Algorithm ZRADICALTEST."
	self scalars indeterminates do: [:i| | f |
		f _ (self eliminateAllBut: i) generator.
		(f gcd: (f derivativeIn: i)) isConstant ifFalse: [^ false]].
	^ true! !

!PolynomialIdeal methodsFor: 'private' stamp: 'len 10/21/2023 13:55:23'!
isRadicalZeroDimensional2
	"Answer true if the receiver is radical, assuming it is zero-dimensional.
	See [ABPR19, Algorithm 4.7 IsRadical0Dim]."
	| Q d |
	Q := self scalars / self.
	d := Q asModule rank.
	Q generators do: [:xᵢ| | μ |
		μ := xᵢ minimalPolynomial.
		μ isSquarefree ifFalse: [^ false].
		μ degree = d ifTrue: [^ true]].
	^ true! !

!PolynomialIdeal methodsFor: 'private' stamp: 'len 12/10/2023 10:36:24'!
radicalMatsumoto
	"Matsumoto's algorithm for computing the radical ideal over a perfect field of characteristic p > 0.
	See [DK02, Algorithm 1.5.1]."
	| R K p n S I J L I₂ |
	R := self scalars.
	K := R scalars.
	p := K characteristic.
	n := R rank.
	S := K polynomialsIn: n * 2 ordering: (MonomialOrdering lex: (1 to: n)), (MonomialOrdering grevlex: (n+1 to: n*2)).
	I := self.
	[J := S * ((I generators collect: [:each| S !! each]), ((1 to: R rank) collect: [:i| (S x: i) ^ p - (S x: n + i)])).
	L := (J eliminateAll: (1 to: n)) generators.
	L := L collect: [:each| (each substitute: [:i| i - n]) apply: [:coefficient| coefficient root: p]].
	I₂ := R * L.
	I₂ ⊆ I ifTrue: [^ I].
	I := I₂] repeat! !

!PolynomialIdeal methodsFor: 'private' stamp: 'len 10/24/2023 16:08:47'!
radicalZeroDimensional
	"Answer the radical of the receiver, assuming it is zero-dimensional.
	See [BW93] Table 8.3, Algorithm ZRADICAL."
	^ self scalars * (self scalars indeterminates collect: [:i| (self eliminateAllBut: i) generator radical])! !

!PolynomialIdeal methodsFor: 'private' stamp: 'len 10/24/2023 16:08:55'!
radicalZeroDimensional2
	"Answer the radical of the receiver, assuming it is zero-dimensional over a perfect field.
	See [ABPR19, Algorithm 4.8 Radical0Dim]."
	| R n J Q d |
	R := self scalars.
	n := R rank.
	J := self.
	Q := R / J.
	d := Q asModule rank.
	1 to: n do: [:i| | xᵢ μ |
		xᵢ := Q x: i.
		μ := xᵢ minimalPolynomial.
		μ isSquarefree ifFalse:
			[μ := μ radical.
			J := J + (R * (μ value: xᵢ)).
			Q := Q / J.
			d := Q asModule rank].
		μ degree = d ifTrue: [^ J]].
	^ J! !

!PolynomialIdeal class methodsFor: 'examples' stamp: 'len 5/23/2020 09:11:37'!
cyclic3
	"The ideal of cyclic 3-roots."
	^ (ℚ polynomialsIn: #(x y z)) cyclicIdeal! !

!PolynomialIdeal class methodsFor: 'examples' stamp: 'len 5/23/2020 09:11:37'!
katsura3
	"The Katsura ideal in 3 variables with rational coefficients."
	^ (ℚ polynomialsIn: #(a b c)) katsuraIdeal! !

!FreeModule methodsFor: 'accessing' stamp: 'len 3/19/2020 19:03:02'!
ambient
	^ self! !

!FreeModule methodsFor: 'accessing' stamp: 'len 4/8/2021 12:20:37'!
at: anInteger
	(anInteger between: 1 and: rank) ifFalse: [^ self error: 'index out of range'].
	^ self scalars asIdeal! !

!FreeModule methodsFor: 'accessing' stamp: 'len 8/7/2020 21:17:31'!
basis
	^ self generators! !

!FreeModule methodsFor: 'accessing' stamp: 'len 4/2/2024 06:31:09'!
components
	^ self propertyAt: #components ifAbsentPut: [Array new: rank withAll: self scalars asIdeal]! !

!FreeModule methodsFor: 'accessing' stamp: 'len 12/28/2016 12:07:59'!
coordinateNames
	^ self propertyAt: #coordinateNames ifAbsent: []! !

!FreeModule methodsFor: 'accessing' stamp: 'len 10/20/2023 16:53:27'!
coordinateRing
	"The coordinate ring of a free R-module of rank n (or K-vector space of dimension n) is the polynomial ring R[x₁...xₙ] (or K[x₁...xₙ])."
	^ self propertyAt: #coordinateRing ifAbsentPut: [self scalars polynomialsIn: (self coordinateNames ifNil: [self rank])]! !

!FreeModule methodsFor: 'accessing' stamp: 'len 12/12/2023 19:07:10'!
freeCover
	"Answer a free cover of the receiver. This is the domain of the generator matrix and the codomain of the relations matrix."
	^ self! !

!FreeModule methodsFor: 'accessing' stamp: 'len 10/25/2020 10:57:45'!
generatorMatrix
	^ self id! !

!FreeModule methodsFor: 'accessing' stamp: 'len 12/22/2021 14:13:13'!
generatorNamed: anObject
	"Answer the generator indexed or named by anObject."
	^ self generators at: ((self propertyAt: #nameToIndex) at: anObject)! !

!FreeModule methodsFor: 'accessing' stamp: 'len 5/5/2023 16:57:56'!
generators
	^ self propertyAt: #generators ifAbsentPut:
		[| zeros |
		zeros _ scalars zeros: rank.
		(1 to: rank) collect: [:i| self coefficients: (zeros copy at: i put: scalars one; yourself)]]! !

!FreeModule methodsFor: 'accessing' stamp: 'len 9/16/2022 08:19:41'!
innerProduct
	"Answer the bilinear form defining the Euclidean inner product."
	^ self propertyAt: #innerProduct ifAbsentPut: [BilinearForm on: self mapWithArguments: [:x :y| x · y]]! !

!FreeModule methodsFor: 'accessing' stamp: 'len 7/24/2020 08:51:53'!
keys
	"The tuple module R^n is indexed by integers 1 to n."
	^ 1 to: rank! !

!FreeModule methodsFor: 'accessing' stamp: 'len 8/7/2022 10:44:18'!
names
	"Answer a list of symbolic names for the generators."
	^ self propertyAt: #names ifAbsent: [(1 to: rank) collect: [:i| 'e', i printString sub]]! !

!FreeModule methodsFor: 'accessing' stamp: 'len 12/22/2021 14:12:44'!
names: anArray
	"Set a list of symbolic names for the generators."
	self propertyAt: #names put: anArray.
	self propertyAt: #nameToIndex put: (Dictionary accumulate: [:aBlock| anArray withIndexDo: [:each :i| aBlock value: (Association key: each value: i)]])! !

!FreeModule methodsFor: 'accessing' stamp: 'len 5/5/2023 00:38:57'!
ordering
	"Answer the module monomial ordering of the receiver."
	^ self propertyAt: #ordering ifAbsentPut: [ModuleMonomialOrdering top]! !

!FreeModule methodsFor: 'accessing' stamp: 'len 6/7/2022 05:42:58'!
presentation
	^ self! !

!FreeModule methodsFor: 'accessing' stamp: 'len 3/3/2020 15:53:00'!
rank
	^ rank! !

!FreeModule methodsFor: 'accessing' stamp: 'len 6/7/2022 05:43:13'!
relations
	^ self null! !

!FreeModule methodsFor: 'accessing' stamp: 'len 10/5/2022 18:38:54'!
relationsMatrix
	^ self propertyAt: #relationsMatrix ifAbsentPut: [scalars^0 → self]! !

!FreeModule methodsFor: 'accessing' stamp: 'len 3/1/2020 18:30:46'!
scalars
	^ scalars! !

!FreeModule methodsFor: 'accessing' stamp: 'len 12/18/2016 11:13:59'!
torsion
	^ self null! !

!FreeModule methodsFor: 'comparing' stamp: 'len 7/27/2021 11:37:50'!
= anObject
	^ self == anObject or: [self class = anObject class and: [scalars = anObject scalars and: [rank = anObject rank and: [scalars isMultivariate not or: [self ordering = anObject ordering]]]]]! !

!FreeModule methodsFor: 'converting' stamp: 'len 6/15/2023 11:24:28'!
apply: aMorphism
	(aMorphism isBlock not and: [aMorphism domain = self scalars]) ifTrue: [^ self over: aMorphism codomain].
	^ super apply: aMorphism! !

!FreeModule methodsFor: 'converting' stamp: 'len 4/5/2024 19:05:57'!
asVectorSpace
	self scalars isField ifTrue: [^ self].
	self scalars isIntegralDomain ifTrue: [^ self over: self scalars fractions].
	^ self error: 'not over an integral domain'! !

!FreeModule methodsFor: 'converting' stamp: 'len 11/23/2022 21:21:10'!
lift
	^ self propertyAt: #lift ifAbsentPut: [scalars cover ^ rank]! !

!FreeModule methodsFor: 'converting' stamp: 'len 12/23/2023 15:23:26'!
numerators
	scalars isLocalization ifFalse: [^ self].
	^ self propertyAt: #numerators ifAbsentPut: [scalars numerators ^ rank]! !

!FreeModule methodsFor: 'converting' stamp: 'len 5/5/2023 00:59:35'!
orderedBy: aModuleMonomialOrdering
	^ self class new: self rank over: self scalars ordering: aModuleMonomialOrdering! !

!FreeModule methodsFor: 'converting' stamp: 'len 12/2/2022 14:37:28'!
over: aRing
	^ aRing ^ rank! !

!FreeModule methodsFor: 'copying' stamp: 'len 5/5/2023 16:54:11'!
copyFrom: start to: stop
	stop - start + 1 = rank ifFalse: [^ scalars ^ (stop - start + 1 max: 0)]! !

!FreeModule methodsFor: 'elements' stamp: 'len 4/26/2021 11:36:37'!
\ anElement
	"Answer coordinates of anElement expressed as a linear combination of the elements of the distinguished generating set of the receiver. Answer nil if anElement is not in the receiver."
	^ anElement! !

!FreeModule methodsFor: 'elements' stamp: 'len 5/5/2023 17:27:35'!
adapt: anElement
	(rank = 1 and: [scalars includes: anElement])
		ifTrue: [^ self elementAt: {anElement}].
	anElement isTuple ifTrue: [^ self elementAt: anElement coefficients].
	^ super adapt: anElement! !

!FreeModule methodsFor: 'elements' stamp: 'len 10/15/2023 13:30:53'!
coefficients: anArray
	"Answer the element with the given coefficients.
	Assume that the argument is an array of elements of the ring of scalars."
	^ self elementClass coefficients: anArray parent: self! !

!FreeModule methodsFor: 'elements' stamp: 'len 10/15/2023 13:34:16'!
elementAt: anArray
	"Answer the element with the given coordinates."
	anArray size = rank ifFalse: [^ super elementAt: anArray].
	(anArray isTuple and: [anArray scalars = self scalars]) ifTrue: [^ self coefficients: anArray coefficients].
	^ self fill: [:i| anArray at: i]! !

!FreeModule methodsFor: 'elements' stamp: 'len 5/5/2023 16:51:50'!
fill: aBlock
	^ self coefficients: (scalars new: rank fill: aBlock)! !

!FreeModule methodsFor: 'elements' stamp: 'len 11/23/2022 21:25:22'!
newFrom: anObject
	(anObject isSequenceable and: [anObject size = rank])
		ifTrue: [^ self elementAt: anObject].
	anObject isBlock ifTrue: [^ self fill: anObject].
	^ super newFrom: anObject! !

!FreeModule methodsFor: 'elements' stamp: 'len 11/23/2022 21:25:34'!
x: anInteger monomial: aMonomial
	^ self fill: [:i| i = anInteger ifTrue: [scalars monomial: aMonomial] ifFalse: [scalars zero]]! !

!FreeModule methodsFor: 'elements' stamp: 'len 5/5/2023 16:52:03'!
zero
	^ self coefficients: (scalars zeros: rank)! !

!FreeModule methodsFor: 'enumerating' stamp: 'len 5/5/2023 18:59:24'!
do: aBlock
	"Iterate over all tuples without repetitions.
	The ring of scalars can be infinite, in which case if the receiver is nontrivial the iteration never ends. However, following the ordering of the iteration on the ring of scalars implemented in #do:, it is guaramteed that at some point in finite time all tuples of elements up to a given element will have been covered."
	rank = 0 ifTrue: [^ aBlock value: self zero].
	scalars isFinite ifFalse: [^ self upTo: scalars size do: aBlock].
	scalars do: [:s| (self copyFrom: 1 to: rank - 1) do: [:p| aBlock value: (self coefficients: (p coefficients copyWith: s))]]! !

!FreeModule methodsFor: 'enumerating' stamp: 'len 5/5/2023 19:02:39'!
upTo: max do: aBlock
	| k |
	rank = 0 ifTrue: [^ aBlock value: self zero].
	k _ 1.
	scalars upTo: max do: [:s|
		(self copyFrom: 1 to: rank - 1) upTo: k do: [:p|
			aBlock value: (self coefficients: (p coefficients copyWith: s)).
			(p includes: s) ifTrue: [scalars upTo: k-1 do: [:t| aBlock value: (self coefficients: (p coefficients copyWith: t))]]].
		k _ k + 1]! !

!FreeModule methodsFor: 'morphisms' stamp: 'len 12/1/2023 14:15:01'!
automorphisms
	^ self propertyAt: #automorphisms ifAbsentPut: [GeneralLinearGroup on: self]! !

!FreeModule methodsFor: 'morphisms' stamp: 'len 5/8/2023 19:50:32'!
coprojection: anIntegerOrList
	anIntegerOrList isInteger
		ifTrue: [^ (self scalars asIdeal into: self images: {self x: anIntegerOrList}) name: 'ι', anIntegerOrList printString sub].
	^ (self scalars ^ anIntegerOrList size into: self images: (anIntegerOrList collect: [:i| self x: i]))
		name: 'ι', anIntegerOrList printString sub! !

!FreeModule methodsFor: 'morphisms' stamp: 'len 5/9/2024 07:06:38'!
endomorphisms
	^ self propertyAt: #endomorphisms ifAbsentPut: [MatrixRing on: self]! !

!FreeModule methodsFor: 'morphisms' stamp: 'len 10/28/2020 13:56:35'!
fromAll: anArray
	"Answer the canonical coprojections from the components of anArray to the receiver."
	| i |
	(anArray allSatisfy: [:each| each class = self class and: [each scalars = self scalars]]) ifFalse: [^ super fromAll: anArray].
	(anArray sum: [:each| each rank]) = rank ifFalse: [^ super fromAll: anArray].
	i _ 1.
	^ anArray collect: [:each| self coprojection: (i to: (i _ i + each rank)-1)]! !

!FreeModule methodsFor: 'morphisms' stamp: 'len 6/2/2024 10:17:13'!
hom: aCodomain
	(aCodomain isKindOf: FreeModule) ifFalse: [^ super hom: aCodomain].
	self assert: self scalars = aCodomain scalars.
	^ MatrixModule from: self to: aCodomain! !

!FreeModule methodsFor: 'morphisms' stamp: 'len 4/10/2024 03:53:49'!
id
	| coefficients one |
	coefficients := scalars zeros: rank squared.
	one := scalars one.
	1 to: rank squared by: rank+1 do: [:i| coefficients at: i put: one].
	^ self to: self coefficients: coefficients! !

!FreeModule methodsFor: 'morphisms' stamp: 'len 5/8/2023 19:50:09'!
projection: anIntegerOrList
	anIntegerOrList isInteger
		ifTrue: [^ (self onto: self scalars asIdeal map: [:x| x at: anIntegerOrList]) name: 'π', anIntegerOrList printString sub].
	^ (self onto: self scalars ^ anIntegerOrList size map: [:x| anIntegerOrList collect: [:i| x at: i]])
		name: 'π', anIntegerOrList printString sub! !

!FreeModule methodsFor: 'morphisms' stamp: 'len 9/25/2018 17:17:02'!
rotations
	^ SpecialOrthogonalGroup on: self! !

!FreeModule methodsFor: 'morphisms' stamp: 'len 4/16/2024 18:48:58'!
to: aModule
	(aModule isDual and: [aModule domain = self])
		ifTrue: [^ self to: aModule map: [:x| aModule map: [:y| self innerProduct value: x value: y]]].
	^ super to: aModule! !

!FreeModule methodsFor: 'morphisms' stamp: 'len 4/10/2024 03:47:09'!
to: aCodomain coefficients: anArray
	"Answer a dense matrix with the given coefficients.
	Assume that the argument is an array of elements of the ring of scalars."
	^ DenseMatrix from: self to: aCodomain coefficients: anArray! !

!FreeModule methodsFor: 'morphisms' stamp: 'len 11/27/2022 13:24:05'!
to: aCodomain columns: anArray
	^ self to: aCodomain fill: [:i :j| (anArray at: j) at: i]! !

!FreeModule methodsFor: 'morphisms' stamp: 'len 4/10/2024 03:55:34'!
to: aCodomain diagonal: anArray
	| answer |
	answer := self zeroTo: aCodomain.
	anArray withIndexDo: [:each :i| answer at: i@i put: scalars !! each].
	^ answer! !

!FreeModule methodsFor: 'morphisms' stamp: 'len 4/5/2024 19:05:40'!
to: aModule fill: aBlock
	self assert: (aModule class = self class and: [aModule scalars = self scalars]).
	^ Matrix from: self to: aModule fill: aBlock! !

!FreeModule methodsFor: 'morphisms' stamp: 'len 6/20/2024 07:34:44'!
to: aModule images: anArray
	"Answer a morphism defined by images of generators."
	((aModule isKindOf: FreeModule) and: [aModule scalars = self scalars])
		ifFalse: [^ super to: aModule images: anArray].
	^ Matrix from: self to: aModule columns: (anArray collect: [:each| aModule \ (aModule !! each)])! !

!FreeModule methodsFor: 'morphisms' stamp: 'len 5/31/2020 11:33:58'!
to: aModule matrix: aMatrix
	(aModule class = self class and: [self scalars = aModule scalars]) ifTrue: [^ Matrix from: self to: aModule rows: aMatrix rows].
	^ super to: aModule matrix: aMatrix! !

!FreeModule methodsFor: 'morphisms' stamp: 'len 4/6/2021 14:45:23'!
to: aModule matrix: aMatrix ifInvalid: exceptionBlock
	(aModule class = self class and: [self scalars = aModule scalars]) ifTrue: [^ Matrix from: self to: aModule rows: aMatrix rows].
	^ super to: aModule matrix: aMatrix ifInvalid: exceptionBlock! !

!FreeModule methodsFor: 'morphisms' stamp: 'len 11/27/2022 13:21:20'!
to: aCodomain rows: anArray
	^ self to: aCodomain fill: [:i :j| (anArray at: i) at: j]! !

!FreeModule methodsFor: 'morphisms' stamp: 'len 5/9/2024 07:14:37'!
to: aCodomain scalar: anElement
	| answer |
	self assert: (aCodomain isKindOf: FreeModule).
	answer := self zeroTo: aCodomain.
	anElement isZero ifFalse:
		[1 to: (rank min: aCodomain rank) do: [:i| answer at: i@i put: anElement]].
	^ answer! !

!FreeModule methodsFor: 'morphisms' stamp: 'len 4/6/2021 14:28:50'!
to: aModule validMatrix: aMatrix
	(aModule class = self class and: [self scalars = aModule scalars]) ifTrue: [^ Matrix from: self to: aModule rows: aMatrix rows].
	^ super to: aModule validMatrix: aMatrix! !

!FreeModule methodsFor: 'morphisms' stamp: 'len 10/28/2020 12:14:05'!
toAll: anArray
	"Answer the canonical projections from the receiver to the components of anArray."
	| i |
	(anArray allSatisfy: [:each| each class = self class and: [each scalars = self scalars]]) ifFalse: [^ super toAll: anArray].
	(anArray sum: [:each| each rank]) = rank ifFalse: [^ super toAll: anArray].
	i _ 1.
	^ anArray collect: [:each| self projection: (i to: (i _ i + each rank)-1)]! !

!FreeModule methodsFor: 'morphisms' stamp: 'len 4/10/2024 03:52:47'!
zeroTo: aCodomain
	^ self to: aCodomain coefficients: (scalars zeros: rank * aCodomain rank)! !

!FreeModule methodsFor: 'operations' stamp: 'len 4/5/2024 19:06:18'!
^⊕ anInteger
	anInteger = 1 ifTrue: [^ self].
	anInteger = 0 ifTrue: [^ self null].
	anInteger < 0 ifTrue: [^ Error signal].
	^ scalars ^ (rank * anInteger)! !

!FreeModule methodsFor: 'operations' stamp: 'len 10/19/2023 13:35:54'!
restriction
	"This is the 'restriction of scalars' functor.
	If the receiver is a module over a finite R-algebra, answer a module over R.
	This functor is right adjoint to 'extension of scalars' (see #⊗) and left adjoint to 'coextension of scalars' (see #⇒)."
	^ self scalars scalars ^ (self rank * self scalars asModule rank)! !

!FreeModule methodsFor: 'operations' stamp: 'len 8/23/2024 08:52:21'!
⊕ aModule
	(aModule isKindOf: FreeModule) ifFalse: [^ super ⊕ aModule].
	self assert: self scalars = aModule scalars.
	^ scalars ^ (rank + aModule rank)! !

!FreeModule methodsFor: 'printing' stamp: 'len 5/28/2020 17:56:15'!
printOn: aStream
	self isTrivial ifTrue: [^ super printOn: aStream].
	aStream print: self scalars; nextPutAll: self rank printString super! !

!FreeModule methodsFor: 'random' stamp: 'len 5/16/2023 20:36:35'!
atRandom: aRandom
	^ self coefficients: (scalars new: rank atRandom: aRandom)! !

!FreeModule methodsFor: 'random' stamp: 'len 5/16/2023 20:36:00'!
atRandom: aRandom bits: bitSize
	^ self coefficients: (scalars new: rank atRandom: aRandom bits: bitSize)! !

!FreeModule methodsFor: 'random' stamp: 'len 4/10/2024 03:58:38'!
to: aCodomain atRandom: aRandom
	(aCodomain isKindOf: FreeModule) ifFalse: [^ super to: aCodomain atRandom: aRandom].
	^ self to: aCodomain coefficients: (scalars new: rank * aCodomain rank atRandom: aRandom)! !

!FreeModule methodsFor: 'random' stamp: 'len 4/10/2024 03:58:54'!
to: aCodomain atRandom: aRandom bits: bitSize
	(aCodomain isKindOf: FreeModule) ifFalse: [^ super to: aCodomain atRandom: aRandom bits: bitSize].
	^ self to: aCodomain coefficients: (scalars new: rank * aCodomain rank atRandom: aRandom bits: bitSize)! !

!FreeModule methodsFor: 'testing' stamp: 'len 5/5/2023 15:51:27'!
includes: anObject
	^ anObject parent == self! !

!FreeModule methodsFor: 'testing' stamp: 'len 5/31/2020 10:40:45'!
isCoproduct
	^ true! !

!FreeModule methodsFor: 'testing' stamp: 'len 3/16/2021 16:22:58'!
isFreelyGenerated
	"Answer true if the receiver is free on free generators."
	^ true! !

!FreeModule methodsFor: 'testing' stamp: 'len 7/13/2022 12:06:03'!
isGraded
	^ scalars isGraded! !

!FreeModule methodsFor: 'testing' stamp: 'len 5/31/2020 10:40:37'!
isProduct
	^ true! !

!FreeModule methodsFor: 'testing' stamp: 'len 3/7/2020 18:07:16'!
isTrivial
	^ rank = 0 or: [scalars isTrivial]! !

!FreeModule methodsFor: 'private' stamp: 'len 5/5/2023 15:48:58'!
elementClass
	^ scalars isMultivariate ifTrue: [MultivariateTuple] ifFalse: [Tuple]! !

!FreeModule methodsFor: 'private' stamp: 'len 5/5/2023 01:00:00'!
ordering: aModuleMonomialOrdering
	self propertyAt: #ordering put:
		(aModuleMonomialOrdering isSymbol
			ifTrue: [ModuleMonomialOrdering perform: aModuleMonomialOrdering]
			ifFalse: [aModuleMonomialOrdering])! !

!FreeModule methodsFor: 'private' stamp: 'len 3/1/2020 18:31:01'!
rank: n
	rank _ n! !

!FreeModule methodsFor: 'private' stamp: 'len 3/1/2020 18:31:06'!
scalars: aRing
	scalars _ aRing! !

!FreeModule class methodsFor: 'instance creation' stamp: 'len 7/26/2020 13:11:35'!
new: anIntegerOrCollection over: aRing
	^ (anIntegerOrCollection isInteger or: [anIntegerOrCollection = Infinity positive])
		ifTrue: [self new rank: anIntegerOrCollection; scalars: aRing]
		ifFalse: [self new rank: anIntegerOrCollection size; names: anIntegerOrCollection asArray; scalars: aRing]! !

!FreeModule class methodsFor: 'instance creation' stamp: 'len 5/18/2020 19:12:01'!
new: anIntegerOrCollection over: aRing ordering: aModuleMonomialOrdering
	^ (self new: anIntegerOrCollection over: aRing) ordering: aModuleMonomialOrdering! !

!HomModule methodsFor: 'accessing' stamp: 'len 3/4/2020 18:44:10'!
ambient
	^ self! !

!HomModule methodsFor: 'accessing' stamp: 'len 10/2/2018 01:15:09'!
codomain
	^ codomain! !

!HomModule methodsFor: 'accessing' stamp: 'len 10/2/2018 01:15:31'!
domain
	^ domain! !

!HomModule methodsFor: 'accessing' stamp: 'len 6/10/2022 11:06:54'!
generatorMatrix
	^ self relationsMatrix codomain id! !

!HomModule methodsFor: 'accessing' stamp: 'len 6/10/2022 11:08:33'!
generators
	self propertyAt: #generators ifPresent: [:anArray| ^ anArray].
	self computePresentation.
	^ self propertyAt: #generators! !

!HomModule methodsFor: 'accessing' stamp: 'len 12/4/2023 11:12:38'!
rank
	self isFreelyGenerated ifTrue: [^ domain rank * codomain rank].
	^ self notYetImplemented! !

!HomModule methodsFor: 'accessing' stamp: 'len 6/10/2022 09:54:12'!
relationsMatrix
	self propertyAt: #relationsMatrix ifPresent: [:aMatrix| ^ aMatrix].
	self computePresentation.
	^ self propertyAt: #relationsMatrix! !

!HomModule methodsFor: 'accessing' stamp: 'len 12/4/2023 11:13:02'!
scalars
	self flag: #fixme. "not correct over noncommutative rings"
	^ domain scalars! !

!HomModule methodsFor: 'accessing' stamp: 'len 8/19/2024 09:41:08'!
underlyingSet
	^ self propertyAt: #underlyingSet ifAbsentPut: [HomSet from: domain to: codomain]! !

!HomModule methodsFor: 'comparing' stamp: 'len 8/14/2020 17:06:01'!
= anObject
	^ self == anObject or: [self class = anObject class and: [domain = anObject domain and: [codomain = anObject codomain]]]! !

!HomModule methodsFor: 'converting' stamp: 'len 8/26/2024 14:30:02'!
asRing
	self assert: domain = codomain.
	^ domain endomorphisms! !

!HomModule methodsFor: 'converting' stamp: 'len 12/23/2023 15:27:04'!
numerators
	self scalars isLocalization ifFalse: [^ self].
	^ self propertyAt: #numerators ifAbsentPut: [domain numerators ⇒ codomain numerators]! !

!HomModule methodsFor: 'converting' stamp: 'len 12/2/2022 14:38:36'!
over: aRing
	"Answer the change of base ring of the receiver."
	^ (domain over: aRing) ⇒ (codomain over: aRing)! !

!HomModule methodsFor: 'elements' stamp: 'len 12/12/2023 20:00:36'!
\ anElement
	"Answer coordinates of anElement expressed as a linear combination of the elements of the distinguished generating set of the receiver. Answer nil if anElement is not in the receiver."
	self isTrivial ifTrue: [^ anElement isZero ifTrue: [self freeCover zero]].
	^ anElement asMatrix asTuple! !

!HomModule methodsFor: 'elements' stamp: 'len 4/6/2024 15:54:37'!
adapt: anElement
	(self scalars includes: anElement) ifTrue: [^ self scalar: anElement].
	anElement isInteger ifTrue: [^ self scalar: self scalars !! anElement].
	(self isDual and: [anElement isKindOf: Polynomial]) ifTrue: [^ self map: [:x| anElement value: (domain \ x)]].
	^ (super adapt: anElement) ifNil: [	domain to: codomain adapt: anElement]! !

!HomModule methodsFor: 'elements' stamp: 'len 12/1/2023 13:57:03'!
images: anArray
	^ domain to: codomain images: anArray! !

!HomModule methodsFor: 'elements' stamp: 'len 9/16/2022 07:51:18'!
map: aBlock
	^ domain to: codomain map: aBlock! !

!HomModule methodsFor: 'elements' stamp: 'len 9/16/2022 07:52:32'!
mapWithArguments: aBlock
	^ domain to: codomain mapWithArguments: aBlock! !

!HomModule methodsFor: 'elements' stamp: 'len 3/3/2020 16:39:37'!
matrix: aMatrix
	^ domain to: codomain matrix: aMatrix! !

!HomModule methodsFor: 'elements' stamp: 'len 6/15/2023 11:46:18'!
newFrom: anObject
	anObject isEvaluable ifTrue: [^ self map: anObject].
	^ super newFrom: anObject! !

!HomModule methodsFor: 'elements' stamp: 'len 11/27/2022 11:38:48'!
scalar: anElement
	^ self map: [:x| x * anElement]! !

!HomModule methodsFor: 'elements' stamp: 'len 9/16/2022 07:46:14'!
zero
	^ self map: [:x| codomain zero]! !

!HomModule methodsFor: 'morphisms' stamp: 'len 6/15/2023 11:24:42'!
apply: aMorphism
	(aMorphism isBlock not and: [aMorphism domain = self scalars]) ifTrue: [^ self over: aMorphism codomain].
	^ super apply: aMorphism! !

!HomModule methodsFor: 'morphisms' stamp: 'len 8/26/2024 14:30:12'!
from: aModule
	domain = codomain ifTrue:
		[aModule = self scalars asIdeal ifTrue: [^ self addMap: (aModule to: self map: [:x| self scalar: x])]. "inclusion of scalars"
		"aDomain ⇢ self scalars asIdeal ifNotNil: [:aMorphism| ^ aMorphism → self]"].
	(self isDual and: [domain isDual and: [domain domain == aModule]])
		ifTrue: [^ self addMap: (aModule to: self images: self generators)].
	^ super from: aModule! !

!HomModule methodsFor: 'morphisms' stamp: 'len 8/26/2024 14:30:58'!
to: aModule
	domain = codomain ifTrue:
		[aModule = self scalars asIdeal ifTrue: [^ self addMap: (self to: aModule map: [:f| f trace])].
		"self scalars asIdeal ⇢ aCodomain ifNotNil: [:aMorphism| ^ self → aMorphism]"].
	(self isDual and: [domain isDual and: [domain domain = aModule]])
		ifTrue: [^ self addMap: (self to: aModule images: aModule generators)].
	^ super to: aModule! !

!HomModule methodsFor: 'operations' stamp: 'len 12/4/2023 11:19:32'!
symmetricAlgebra
	(self isDual and: [domain isFreelyGenerated]) ifTrue: [^ domain coordinateRing].
	^ self notYetImplemented! !

!HomModule methodsFor: 'printing' stamp: 'len 8/26/2024 14:30:45'!
printOn: aStream
	self isTrivial ifTrue: [^ super printOn: aStream].
	self isDual ifTrue: [aStream print: domain; nextPutAll: '∨' super. ^ self].
	aStream print: self underlyingSet! !

!HomModule methodsFor: 'testing' stamp: 'len 3/6/2020 21:04:55'!
includes: anObject
	^ (anObject isKindOf: ModuleMap) and: [anObject domain = domain and: [anObject codomain = codomain]]! !

!HomModule methodsFor: 'testing' stamp: 'len 4/8/2021 12:49:26'!
isDual
	"Answer true if the receiver is the module of linear forms Hom(M,R) for an R-module M."
	^ codomain = self scalars asIdeal! !

!HomModule methodsFor: 'testing' stamp: 'len 7/26/2021 10:44:09'!
isFreelyGenerated
	"Answer true if the receiver is free on free generators."
	^ (domain isFreelyGenerated and: [codomain isFreelyGenerated]) or: [super isFreelyGenerated]! !

!HomModule methodsFor: 'testing' stamp: 'len 7/25/2021 12:41:17'!
isTrivial
	"Answer true if the receiver is the trivial submodule {0}."
	^ domain isTrivial or: [codomain isTrivial or: [super isTrivial]]! !

!HomModule methodsFor: 'private' stamp: 'len 12/12/2023 20:00:52'!
computeFreeGenerators
	self propertyAt: #generators put: ((domain freeCover ⇒ codomain freeCover) generators collect: [:each| domain to: codomain matrix: each])! !

!HomModule methodsFor: 'private' stamp: 'len 12/12/2023 20:01:27'!
computeGeneratorsFromMatrixCoordinates: anArray
	| H |
	H := domain freeCover ⇒ codomain freeCover.
	self propertyAt: #generators ifAbsentPut: [(anArray collect: [:x| domain to: codomain matrix: (H elementAt: x)])]! !

!HomModule methodsFor: 'private' stamp: 'len 12/4/2023 11:21:18'!
computePresentation
	"From 'A Singular Introduction to Commutative Algebra', pag 124, example 2.1.26 (computation of Hom)."
	| M N B C D E F |
	(domain isFreelyGenerated and: [codomain isFreelyGenerated]) ifTrue:
		[self computeFreeGenerators.
		self propertyAt: #relationsMatrix put: self scalars^0 → (self scalars^(domain rank * codomain rank)).
		^ self].
	M := domain relationsMatrix.
	N := codomain relationsMatrix.
	C := (M codomain ⇒ N) asMatrix.
"	self domain isFreelyGenerated ifTrue:
		[self computeFreeGenerators.
		self propertyAt: #relationsMatrix put: C syzygies.
		^ self]."
	B := (M domain ⇒ N) asMatrix.
	F := (M ⇒ N codomain) asMatrix.
	D := F syzygiesModulo: B.
	self computeGeneratorsFromMatrixCoordinates: D columns.
	E := D syzygiesModulo: C.
	self assert: E codomain rank = D width.
	self propertyAt: #relationsMatrix put: E! !

!HomModule methodsFor: 'private' stamp: 'len 6/17/2023 17:48:25'!
domain: aModule codomain: anotherModule
	domain := aModule.
	codomain := anotherModule! !

!HomModule class methodsFor: 'instance creation' stamp: 'len 6/17/2023 17:48:41'!
from: aModule to: anotherModule
	^ self new domain: aModule codomain: anotherModule! !

!MatrixModule methodsFor: 'accessing' stamp: 'len 11/23/2022 21:26:05'!
generators
	^ self propertyAt: #generators ifAbsentPut:
		[| n m B one zero |
		n _ codomain rank.
		m _ domain rank.
		B _ OrderedCollection new: n*m.
		one _ domain scalars one.
		zero _ domain scalars zero.
		1 to: n do: [:i0|
			1 to: m do: [:j0|
				B add: (self fill: [:i :j| (i=i0 and: [j=j0]) ifTrue: [one] ifFalse: [zero]])]].
		B asArray]! !

!MatrixModule methodsFor: 'accessing' stamp: 'len 7/16/2020 09:43:34'!
height
	^ self codomain rank! !

!MatrixModule methodsFor: 'accessing' stamp: 'len 8/7/2022 10:44:41'!
names
	"Answer a list of symbolic names for the generators."
	^ self propertyAt: #names ifAbsentPut: [(1 to: self rank) collect: [:each| 'e', ((each - 1 // self width + 1) printString, ',', (each - 1 \\ self width + 1) printString) sub]]! !

!MatrixModule methodsFor: 'accessing' stamp: 'len 10/5/2022 18:39:09'!
relationsMatrix
	^ self propertyAt: #relationsMatrix ifAbsentPut: [self scalars^0 → (self scalars^(self domain rank * self codomain rank))]! !

!MatrixModule methodsFor: 'accessing' stamp: 'len 7/16/2020 09:43:28'!
width
	^ self domain rank! !

!MatrixModule methodsFor: 'elements' stamp: 'len 4/10/2024 03:56:36'!
coefficients: anArray
	^ domain to: codomain coefficients: anArray! !

!MatrixModule methodsFor: 'elements' stamp: 'len 11/27/2022 13:24:19'!
columns: anArray
	^ domain to: codomain columns: anArray! !

!MatrixModule methodsFor: 'elements' stamp: 'len 4/10/2024 03:56:18'!
diagonal: anArray
	^ domain to: codomain diagonal: anArray! !

!MatrixModule methodsFor: 'elements' stamp: 'len 10/15/2023 13:33:57'!
elementAt: anArray
	"Answer the element with the given coordinates."
	anArray size = self rank ifFalse: [^ super elementAt: anArray].
	(anArray isTuple and: [anArray scalars = self scalars]) ifTrue: [^ self coefficients: anArray coefficients].
	^ self coefficients: (self scalars new: anArray size fill: [:i| anArray at: i])! !

!MatrixModule methodsFor: 'elements' stamp: 'len 11/23/2022 21:36:38'!
fill: aBlock
	^ domain to: codomain fill: aBlock! !

!MatrixModule methodsFor: 'elements' stamp: 'len 11/27/2022 13:21:34'!
rows: anArray
	^ domain to: codomain rows: anArray! !

!MatrixModule methodsFor: 'elements' stamp: 'len 4/10/2024 03:56:54'!
scalar: anElement
	^ domain to: codomain scalar: anElement! !

!MatrixModule methodsFor: 'elements' stamp: 'len 4/10/2024 03:57:06'!
zero
	^ domain zeroTo: codomain! !

!MatrixModule methodsFor: 'printing' stamp: 'len 7/16/2020 09:35:55'!
printOn: aStream
	aStream print: self scalars; nextPutAll: (self height printString, '×', self width printString) super! !

!MatrixModule methodsFor: 'random' stamp: 'len 4/10/2024 03:59:49'!
atRandom: aRandom
	^ domain to: codomain atRandom: aRandom! !

!MatrixModule methodsFor: 'random' stamp: 'len 4/10/2024 04:00:05'!
atRandom: aRandom bits: bitSize
	^ domain to: codomain atRandom: aRandom bits: bitSize! !

!MatrixModule methodsFor: 'testing' stamp: 'len 3/11/2021 13:11:24'!
isTrivial
	"Answer true if the receiver is the trivial submodule {0}."
	^ domain isTrivial or: [codomain isTrivial]! !

!QuotientModule methodsFor: 'accessing' stamp: 'len 3/19/2020 20:30:28'!
ambient
	^ self! !

!QuotientModule methodsFor: 'accessing' stamp: 'len 12/12/2023 19:34:39'!
cover
	^ self freeCover! !

!QuotientModule methodsFor: 'accessing' stamp: 'len 12/12/2023 19:08:44'!
freeCover
	"Answer a free cover of the receiver. This is the domain of the generator matrix and the codomain of the relations matrix."
	^ relationsMatrix codomain! !

!QuotientModule methodsFor: 'accessing' stamp: 'len 6/15/2023 16:14:00'!
generatorMatrix
	^ self relationsMatrix codomain id! !

!QuotientModule methodsFor: 'accessing' stamp: 'len 6/10/2022 11:44:42'!
generators
	^ self propertyAt: #generators ifAbsentPut: [self cover generators collect: [:each| self project: each]]! !

!QuotientModule methodsFor: 'accessing' stamp: 'len 6/7/2022 05:49:25'!
presentation
	^ self! !

!QuotientModule methodsFor: 'accessing' stamp: 'len 6/10/2022 11:31:37'!
relationsMatrix
	^ relationsMatrix! !

!QuotientModule methodsFor: 'comparing' stamp: 'len 6/19/2022 07:38:04'!
= anObject
	^ self == anObject or: [self class = anObject class and: [self relations = anObject relations]]! !

!QuotientModule methodsFor: 'elements' stamp: 'len 6/10/2022 11:35:40'!
\ anElement
	"Answer coordinates of anElement expressed as a linear combination of the elements of the distinguished generating set of the receiver. Answer nil if anElement is not in the receiver."
	^ anElement representative! !

!QuotientModule methodsFor: 'elements' stamp: 'len 10/30/2023 19:12:41'!
elementAt: anArray
	^ self project: (self cover elementAt: anArray)! !

!QuotientModule methodsFor: 'elements' stamp: 'len 5/3/2024 14:56:56'!
representative: anElement
	"Answer the coset corresponding to the given representative (which is already reduced)."
	^ ModuleCoset representative: anElement parent: self! !

!QuotientModule methodsFor: 'elements' stamp: 'len 6/10/2022 11:33:05'!
zero
	^ self representative: self cover zero! !

!QuotientModule methodsFor: 'morphisms' stamp: 'len 6/15/2023 11:16:10'!
apply: aMorphism
	aMorphism isBlock ifTrue: [^ super apply: aMorphism].
	aMorphism domain = self scalars ifTrue: [^ (self relationsMatrix apply: aMorphism) cokernel].
	^ super apply: aMorphism! !

!QuotientModule methodsFor: 'morphisms' stamp: 'len 4/16/2024 18:41:28'!
from: aModule
	(aModule isQuotient and: [aModule relations ⊆ self relations])
		ifTrue: [^ aModule to: self map: [:x| self ambient project: x representative]].	
	^ super from: aModule! !

!QuotientModule methodsFor: 'morphisms' stamp: 'len 3/18/2020 17:43:28'!
project: anElement
	^ self representative: (self relations reduce: anElement)! !

!QuotientModule methodsFor: 'printing' stamp: 'len 8/9/2022 10:21:02'!
printOn: aStream
	self isTrivial ifTrue: [aStream print: 0. ^ self].
	aStream print: self cover; nextPut: $╱; print: self relations! !

!QuotientModule methodsFor: 'testing' stamp: 'len 4/22/2020 06:12:03'!
includes: anObject
	^ anObject parent = self! !

!QuotientModule methodsFor: 'testing' stamp: 'len 7/13/2022 12:19:42'!
isGraded
	"A quotient of a graded module by a graded submodule is graded."
	^ self relations isGraded! !

!QuotientModule methodsFor: 'testing' stamp: 'len 6/10/2022 11:44:48'!
isNoetherian
	"A module is called Noetherian if every submodule is finitely generated."
	^ self cover isNoetherian! !

!QuotientModule methodsFor: 'testing' stamp: 'len 12/25/2021 12:32:19'!
isQuotient
	^ true! !

!QuotientModule methodsFor: 'testing' stamp: 'len 6/10/2022 11:44:52'!
isSemisimple
	"A module over a (not necessarily commutative) unital ring is said to be 'semisimple' (or 'completely reducible') if it is the direct sum of simple (irreducible) submodules."
	^ self cover isSemisimple or: [super isSemisimple]! !

!QuotientModule methodsFor: 'private' stamp: 'len 6/10/2022 11:31:11'!
relationsMatrix: aMatrix
	relationsMatrix _ aMatrix! !

!QuotientModule class methodsFor: 'instance creation' stamp: 'len 6/10/2022 11:30:06'!
relationsMatrix: aMatrix
	^ self new relationsMatrix: aMatrix! !

!Scheme methodsFor: 'accessing' stamp: 'len 3/15/2021 10:08:44'!
base
	"Answer the base scheme of the receiver."
	^ ℤ spec! !

!Scheme methodsFor: 'accessing' stamp: 'len 10/4/2016 09:19'!
codimension
	^ self ambient dimension - self dimension! !

!Scheme methodsFor: 'accessing' stamp: 'len 12/13/2021 17:17:22'!
dimension
	"Answer the dimension of the highest dimensional component of the receiver."
	^ self decomposition max: [:each| each dimension]! !

!Scheme methodsFor: 'accessing' stamp: 'len 6/18/2023 18:36:12'!
divisors
	^ DivisorGroup on: self over: ℤ! !

!Scheme methodsFor: 'accessing' stamp: 'len 5/1/2024 12:26:14'!
functionField
	"Answer the function field (or field of rational functions) of the receiver.
	If the receiver is integral, this is the local ring at the generic point, or equivalently the function field of any nonempty affine open subscheme."
	^ self patches any functionField! !

!Scheme methodsFor: 'accessing' stamp: 'len 1/12/2017 20:38:56'!
genus
	"Answer the geometric genus of the receiver."
	^ self subclassResponsibility! !

!Scheme methodsFor: 'accessing' stamp: 'len 12/15/2021 12:49:15'!
patches
	"Answer an affine cover of the receiver."
	^ self propertyAt: #patches! !

!Scheme methodsFor: 'accessing' stamp: 'len 7/30/2022 12:05:31'!
sections
	"Answer the ring of regular functions, or ring of global sections of the structure sheaf."
	^ self subclassResponsibility! !

!Scheme methodsFor: 'categories' stamp: 'len 4/13/2024 05:06:23'!
sheaves
	^ self propertyAt: #CoherentSheaves ifAbsentPut: [CoherentSheavesCategory on: self]! !

!Scheme methodsFor: 'operations' stamp: 'len 6/14/2023 13:17:45'!
apply: aMorphism
	"This is the image of aMorphism applied to the receiver, assuming the receiver is a subscheme of the domain of aMorphism."
	^ (self → aMorphism) image! !

!Scheme methodsFor: 'operations' stamp: 'len 6/26/2023 14:37:25'!
sub: anObject
	"Answer the subscheme defined by anObject, as subscheme of the ambient space.
	This makes sense, for example, for closed subschemes of affine or projective space, and anObject can be an element or an ideal of the coordinate ring."
	self isAmbient ifTrue: [^ self subclassResponsibility].
	^ self ∩ (self ambient sub: anObject)! !

!Scheme methodsFor: 'points' stamp: 'len 6/20/2023 11:40:08'!
points
	"Answer the rational points of the receiver."
	^ self scalars spec ⇒ self! !

!Scheme methodsFor: 'points' stamp: 'len 6/19/2023 12:39:13'!
pointsCountOver: aRing
	"Naive count of rational points on the receiver."
	| answer |
	answer := 0.
	self pointsOver: aRing do: [:each| answer := answer + 1].
	^ answer! !

!Scheme methodsFor: 'points' stamp: 'len 6/19/2023 13:02:56'!
pointsOver: aRing
	"Answer the K-rational points on the receiver, where K is aRing."
	^ RationalPointSet on: self over: aRing! !

!Scheme methodsFor: 'random' stamp: 'len 7/12/2023 18:15:30'!
pointOver: aRing atRandom: aRandom
	| points P |
	self isAmbient ifTrue: [^ self subclassResponsibility].
	points := aRing spec ⇒ self ambient.
	[P := points atRandom: aRandom.
	self satisfies: P coordinates] whileFalse.
	^ self !! P! !

!Scheme methodsFor: 'testing' stamp: 'len 7/11/2022 12:48:51'!
isAffine
	^ false! !

!Scheme methodsFor: 'testing' stamp: 'len 3/15/2021 13:49:38'!
isConnected
	"A scheme is called 'connected' if its underlying topological space is connected, i.e. it is not empty and the only subsets that are both open and closed and only itself and the empty set.
	A connected scheme is also irreducible, but not the other way around.
	Examples:
		Spec(K[x]/<x^2>) is irreducible but not reduced;
		Spec(K[x,y]/<x,y>) is reducible and reduced;
		Spec(K[x]/<x^2 - x>) is not connected and it is reduced."
	^ self subclassResponsibility! !

!Scheme methodsFor: 'testing' stamp: 'len 12/30/2016 15:06:11'!
isCurve
	^ self dimension = 1! !

!Scheme methodsFor: 'testing' stamp: 'len 12/20/2021 18:11:06'!
isEmpty
	^ self patches allSatisfy: [:each| each isEmpty]! !

!Scheme methodsFor: 'testing' stamp: 'len 10/13/2016 19:22'!
isHypersurface
	^ self codimension = 1! !

!Scheme methodsFor: 'testing' stamp: 'len 3/15/2021 13:38:07'!
isIntegral
	"A scheme is called 'integral' if it is reduced and irreducible."
	^ self isReduced and: [self isIrreducible]! !

!Scheme methodsFor: 'testing' stamp: 'len 3/15/2021 13:48:58'!
isIrreducible
	"A scheme is called 'irreducible' if its underlying topological space is irreducible, i.e. it is not empty and it is not the union of two proper closed subsets.
	Examples:
		Spec(K[x]/<x^2>) is irreducible but not reduced;
		Spec(K[x,y]/<x,y>) is reducible and reduced;
		Spec(K[x]/<x^2 - x>) is not connected and it is reduced."
	^ self subclassResponsibility! !

!Scheme methodsFor: 'testing' stamp: 'len 12/15/2021 19:33:20'!
isNoetherian
	^ self patches allSatisfy: [:each| each isNoetherian]! !

!Scheme methodsFor: 'testing' stamp: 'len 10/12/2016 19:32'!
isPlanar
	^ self ambient dimension = 2! !

!Scheme methodsFor: 'testing' stamp: 'len 1/13/2017 16:30:59'!
isProjective
	^ false! !

!Scheme methodsFor: 'testing' stamp: 'len 12/15/2021 19:29:06'!
isReduced
	"A scheme is called 'reduced' if all its stalks are reduced (i.e., their nilradicals are 0).
	This is a local property, i.e. the following are equivalent:
	1) S is reduced;
	2) The stalk at P is reduced for all P;
	3) Every open affine subscheme of S is reduced;
	4) S has a cover by reduced open affine subschemes.
	Examples:
		Spec(K[x]/<x^2>) is irreducible but not reduced;
		Spec(K[x,y]/<x,y>) is reducible and reduced;
		Spec(K[x]/<x^2 - x>) is not connected and it is reduced."
	^ self patches allSatisfy: [:each| each isReduced]! !

!Scheme methodsFor: 'testing' stamp: 'len 12/20/2021 18:20:01'!
isSingular
	"Answer true if the receiver has a singular point or fails to be equidimensional over an algebraic closure of its base field."
	^ self isSmooth not! !

!Scheme methodsFor: 'testing' stamp: 'len 12/15/2021 19:31:12'!
isSmooth
	"Answer true if the receiver is nonsingular."
	^ self patches allSatisfy: [:each| each isSmooth]! !

!Scheme methodsFor: 'testing' stamp: 'len 1/9/2017 16:28:50'!
isSurface
	^ self dimension = 2! !

!Scheme methodsFor: 'private' stamp: 'len 12/13/2021 17:20:19'!
species
	^ Scheme! !

!Grassmannian methodsFor: 'accessing' stamp: 'len 9/16/2018 16:13:19'!
dimension
	^ rank * (space rank - rank)! !

!Grassmannian methodsFor: 'accessing' stamp: 'len 4/21/2016 16:58'!
rank
	^ rank! !

!Grassmannian methodsFor: 'accessing' stamp: 'len 3/14/2020 17:32:50'!
size
	space isFinite ifFalse: [^ space size].
	^ space rank choose: rank q: space scalars size! !

!Grassmannian methodsFor: 'accessing' stamp: 'len 4/20/2016 23:55'!
space
	^ space! !

!Grassmannian methodsFor: 'comparing' stamp: 'len 4/20/2016 23:55'!
= aGrassmannian
	^ (aGrassmannian isKindOf: Grassmannian) and: [aGrassmannian space = self space]! !

!Grassmannian methodsFor: 'morphisms' stamp: 'len 3/14/2020 17:32:30'!
dual
	^ space dual grassmannian: space rank - rank! !

!Grassmannian methodsFor: 'printing' stamp: 'len 11/10/2016 08:45'!
printOn: aStream
	aStream nextPutAll: 'Gr('; print: rank; nextPut: $,; print: space; nextPut: $)! !

!Grassmannian methodsFor: 'random' stamp: 'len 6/26/2023 12:59:46'!
atRandom: aRandom bits: bits
	| S n |
	S := space null.
	[S rank < rank]
		whileTrue:
			[| v |
			n := bits / rank.
			[v := space atRandom: aRandom bits: n.
			S contains: v] whileTrue: [n := n * 1.5]. "increase bits until we find a new vector"
			S := S + (space sub: {v})].
	^ S! !

!Grassmannian methodsFor: 'testing' stamp: 'len 12/10/2023 10:35:50'!
contains: aSubmodule
	^ space ⊇ aSubmodule and: [aSubmodule rank = rank]! !

!Grassmannian methodsFor: 'testing' stamp: 'len 4/1/2021 10:16:57'!
includes: anObject
	^ (anObject isKindOf: Module) and: [anObject ambient = space ambient and: [self contains: anObject]]! !

!Grassmannian methodsFor: 'private' stamp: 'len 4/21/2016 16:59'!
rank: anInteger
	rank _ anInteger! !

!Grassmannian methodsFor: 'private' stamp: 'len 4/20/2016 23:56'!
space: aVectorSpace
	space _ aVectorSpace! !

!Grassmannian class methodsFor: 'instance creation' stamp: 'len 4/21/2016 17:01'!
new: anInteger over: aSpace
	^ self new space: aSpace; rank: anInteger! !

!AffineScheme methodsFor: 'accessing' stamp: 'len 8/13/2022 10:48:55'!
@ aPoint
	"Answer the local ring corresponding to the stalk of the structure sheaf at aPoint.
	For Spec(R) a point is a prime ideal of R."
	^ self coordinateRing @ (self !! aPoint) asIdeal! !

!AffineScheme methodsFor: 'accessing' stamp: 'len 7/30/2022 12:10:50'!
ambient
	^ self propertyAt: #ambient ifAbsent: [self coordinateRing isQuotient ifTrue: [self coordinateRing cover spec ambient] ifFalse: [self]]! !

!AffineScheme methodsFor: 'accessing' stamp: 'len 7/9/2019 08:17:49'!
base
	"Answer the base scheme of the receiver."
	^ self scalars spec! !

!AffineScheme methodsFor: 'accessing' stamp: 'len 7/30/2022 12:07:06'!
coordinateRing
	"Answer the ring of regular functions, or ring of global sections of the structure sheaf."
	^ self propertyAt: #coordinateRing! !

!AffineScheme methodsFor: 'accessing' stamp: 'len 7/30/2022 12:11:28'!
dimension
	"Answer the dimension of the highest dimensional component of the receiver.
	This is the Krull dimension of the coordinate ring."
	^ self coordinateRing dimension! !

!AffineScheme methodsFor: 'accessing' stamp: 'len 6/13/2024 14:06:50'!
functionField
	"Answer the function field (or field of rational functions) of the receiver. This is the fraction field of the coordinate ring and it's notated K(V) (analogous to the coordinate ring denoted by K[V]).
	This assumes the receiver is reduced. The definition of function field can be extended to the case of nonreduced schemes as Frac(R/N) where N is the nilradical of R."
	^ self coordinateRing fractions! !

!AffineScheme methodsFor: 'accessing' stamp: 'len 7/30/2022 12:12:03'!
genericPoint
	"If the receiver is an integral scheme, answer the generic point."
	self isIntegral ifFalse: [^ self error: 'not integral scheme'].
	^ self !! self coordinateRing asIdeal null! !

!AffineScheme methodsFor: 'accessing' stamp: 'len 7/29/2022 10:28:51'!
idealSheaf
	^ self asIdeal! !

!AffineScheme methodsFor: 'accessing' stamp: 'len 12/15/2021 12:49:42'!
patches
	"Answer an affine cover of the receiver."
	^ {self}! !

!AffineScheme methodsFor: 'accessing' stamp: 'len 7/30/2022 12:12:37'!
scalars
	^ self coordinateRing scalars! !

!AffineScheme methodsFor: 'accessing' stamp: 'len 7/30/2022 12:06:07'!
sections
	"Answer the ring of regular functions, or ring of global sections of the structure sheaf."
	^ self coordinateRing! !

!AffineScheme methodsFor: 'accessing' stamp: 'len 7/30/2022 12:12:40'!
structureSheaf
	^ self coordinateRing asIdeal! !

!AffineScheme methodsFor: 'categories' stamp: 'len 4/5/2024 09:44:26'!
sheaves
	^ self coordinateRing modules! !

!AffineScheme methodsFor: 'comparing' stamp: 'len 7/30/2022 12:10:27'!
= anObject
	^ (anObject isKindOf: self species) and: [self coordinateRing = anObject coordinateRing]! !

!AffineScheme methodsFor: 'comparing' stamp: 'len 7/30/2022 12:12:06'!
hash
	^ self coordinateRing hash! !

!AffineScheme methodsFor: 'comparing' stamp: 'len 12/10/2023 10:36:24'!
⊆ aScheme
	^ self asIdeal ⊇ aScheme asIdeal! !

!AffineScheme methodsFor: 'converting' stamp: 'len 7/30/2022 12:11:13'!
asIdeal
	"Answer the defining ideal of the receiver. This is an ideal of the ambient coordinate ring."
	^ self coordinateRing isQuotient ifTrue: [self coordinateRing relations] ifFalse: [self coordinateRing asIdeal null]! !

!AffineScheme methodsFor: 'converting' stamp: 'len 7/30/2022 12:08:28'!
over: aRing
	^ (self coordinateRing over: aRing) spec! !

!AffineScheme methodsFor: 'elements' stamp: 'len 7/30/2022 12:10:16'!
!! anObject
	((anObject isKindOf: Ideal) and: [anObject scalars = self coordinateRing]) "assume it's prime"
		ifTrue: [^ anObject].
	^ super !! anObject! !

!AffineScheme methodsFor: 'enumerating' stamp: 'len 7/30/2022 12:11:33'!
do: aBlock
	self coordinateRing primeIdealsDo: [:each| aBlock value: self !! each]! !

!AffineScheme methodsFor: 'morphisms' stamp: 'len 6/1/2024 07:06:55'!
from: aScheme
	(aScheme isKindOf: AffineScheme) ifTrue:
		[self coordinateRing ⇢ aScheme coordinateRing ifNotNil: [:aMorphism| ^ aMorphism spec]].
	^ super from: aScheme! !

!AffineScheme methodsFor: 'morphisms' stamp: 'len 10/5/2022 17:01:25'!
fromAll: anArray
	(anArray allSatisfy: [:each| each isKindOf: AffineScheme]) ifTrue:
		[(self coordinateRing ⇉ (anArray collect: [:each| each coordinateRing])) ifNotNil: [:anArrayOfMorphisms| ^ anArrayOfMorphisms collect: [:each| each spec]]].
	^ super fromAll: anArray! !

!AffineScheme methodsFor: 'morphisms' stamp: 'len 6/2/2024 10:17:39'!
hom: aCodomain
	aCodomain scalars ⇢ self coordinateRing ifNotNil: [^ aCodomain pointsOver: self coordinateRing].
	^ super hom: aCodomain! !

!AffineScheme methodsFor: 'morphisms' stamp: 'len 7/30/2022 12:12:09'!
id
	^ self coordinateRing id spec! !

!AffineScheme methodsFor: 'morphisms' stamp: 'len 6/1/2024 07:07:04'!
to: aScheme
	(aScheme isKindOf: AffineScheme) ifTrue:
		[aScheme coordinateRing ⇢ self coordinateRing ifNotNil: [:aMorphism| ^ aMorphism spec]].
	^ super to: aScheme! !

!AffineScheme methodsFor: 'morphisms' stamp: 'len 10/5/2022 17:30:19'!
toAll: anArray
	(anArray allSatisfy: [:each| each isKindOf: AffineScheme]) ifTrue:
		[self coordinateRing ⇇ (anArray collect: [:each| each coordinateRing]) ifNotNil: [:anArrayOfMorphisms| ^ anArrayOfMorphisms collect: [:each| each spec]]].
	^ super toAll: anArray! !

!AffineScheme methodsFor: 'operations' stamp: 'len 7/12/2023 01:04:57'!
× aScheme
	"Answer the fiber product of the receiver and the argument."
	(aScheme isKindOf: AffineScheme) ifFalse: [^ super × aScheme].
	^ (self coordinateRing ⊗ aScheme coordinateRing) spec! !

!AffineScheme methodsFor: 'operations' stamp: 'len 6/26/2023 14:40:37'!
decomposition
	"Answer the irreducible components of the receiver."
	^ self asIdeal associatedPrimes collect: [:each| self sub: each]! !

!AffineScheme methodsFor: 'operations' stamp: 'len 10/24/2023 16:09:32'!
reduced
	"Answer the reduced subscheme of the receiver."
	^ self propertyAt: #reducedSubscheme ifAbsentPut: [self ambient sub: self asIdeal radical]! !

!AffineScheme methodsFor: 'operations' stamp: 'len 6/26/2023 14:37:52'!
sub: anObject
	| I |
	I := (anObject isKindOf: Ideal) ifTrue: [anObject] ifFalse: [self coordinateRing * anObject].
	^ (self coordinateRing / I) spec! !

!AffineScheme methodsFor: 'operations' stamp: 'len 4/5/2024 19:05:11'!
∩ aScheme
	"Answer the intersection of the receiver and the argument."
	self ambient = aScheme ambient ifFalse: [^ self error: 'ambients don''t match'].
	^ self ambient sub: self asIdeal + aScheme asIdeal! !

!AffineScheme methodsFor: 'operations' stamp: 'len 4/5/2024 19:05:18'!
∪ aScheme
	"Answer the union of the receiver and the argument."
	self ambient = aScheme ambient ifFalse: [^ self error: 'ambients don''t match'].
	^ self ambient sub: self asIdeal ∩ aScheme asIdeal

"alternatively:
	^ self class on: self ambient ideal: ideal * aScheme ideal
although the intersection is harder to compute, it behaves better with radicalization, because the intersection of two radical ideals is radical and we don't need to compute radicals again"! !

!AffineScheme methodsFor: 'printing' stamp: 'len 7/30/2022 12:12:34'!
printOn: aStream
	aStream nextPutAll: 'Spec '; print: self coordinateRing! !

!AffineScheme methodsFor: 'testing' stamp: 'len 6/26/2023 17:03:34'!
includes: anObject
	^ (anObject isKindOf: Ideal) and: [anObject scalars = self coordinateRing and: [anObject isPrime]]! !

!AffineScheme methodsFor: 'testing' stamp: 'len 1/13/2017 16:02:42'!
isAffine
	^ true! !

!AffineScheme methodsFor: 'testing' stamp: 'len 3/15/2021 14:01:49'!
isConnected
	"A scheme is called 'connected' if its underlying topological space is connected, i.e. it is not empty and the only subsets that are both open and closed and only itself and the empty set.
	A connected scheme is also irreducible, but not the other way around.
	An affine scheme Spec(R) is connected iff R is nontrivial and has no idempotents (elements with x^2 = x) other than 0 and 1."
	^ self subclassResponsibility! !

!AffineScheme methodsFor: 'testing' stamp: 'len 7/30/2022 12:12:21'!
isEmpty
	^ self coordinateRing isTrivial! !

!AffineScheme methodsFor: 'testing' stamp: 'len 7/30/2022 12:12:25'!
isIntegral
	"A scheme is called 'integral' if it is reduced and irreducible.
	An affine scheme Spec(R) is integral iff R is an integral domain."
	^ self coordinateRing isIntegralDomain! !

!AffineScheme methodsFor: 'testing' stamp: 'len 6/26/2023 13:10:42'!
isIrreducible
	"A scheme is called 'irreducible' if its underlying topological space is irreducible, i.e. it is not empty and it is not the union of two proper closed subsets."
	self coordinateRing isIntegralDomain ifTrue: [^ true]. "i.e., the scheme is integral"
	^ self coordinateRing nilradical isPrime! !

!AffineScheme methodsFor: 'testing' stamp: 'len 7/30/2022 12:12:28'!
isNoetherian
	^ self coordinateRing isNoetherian! !

!AffineScheme methodsFor: 'testing' stamp: 'len 7/30/2022 12:12:30'!
isReduced
	"A scheme is called 'reduced' if all its stalks are reduced (i.e., their nilradicals are 0)."
	^ self coordinateRing isReduced! !

!AffineScheme methodsFor: 'testing' stamp: 'len 10/11/2023 20:45:28'!
isZeroDimensional
	^ self coordinateRing isZeroDimensional! !

!AffineScheme methodsFor: 'private' stamp: 'len 7/30/2022 12:07:23'!
coordinateRing: aRing
	self propertyAt: #coordinateRing put: aRing! !

!AffineScheme methodsFor: 'private' stamp: 'len 2/13/2017 07:44:36'!
species
	^ AffineScheme! !

!AffineScheme methodsFor: 'as yet unclassified' stamp: 'len 6/1/2024 07:27:34'!
to: aCodomain atRandom: aRandom
	aCodomain scalars ⇢ self coordinateRing ifNotNil: [^ aCodomain pointOver: self coordinateRing atRandom: aRandom].
	^ super to: aCodomain atRandom: aRandom! !

!AffineScheme class methodsFor: 'instance creation' stamp: 'len 7/30/2022 12:07:51'!
coordinateRing: aRing
	^ self new coordinateRing: aRing! !

!AffineVariety methodsFor: 'accessing' stamp: 'len 8/13/2022 10:57:22'!
asIdeal
	"Answer the defining ideal of the receiver. This is an ideal of the ambient coordinate ring."
	^ self coordinateRing relations! !

!AffineVariety methodsFor: 'converting' stamp: 'len 2/22/2017 07:52:56'!
asCurve
	^ self ambient isPlane
		ifTrue: [self as: AffinePlaneCurve]
		ifFalse: [self as: AffineCurve]! !

!AffineVariety methodsFor: 'converting' stamp: 'len 2/22/2017 07:53:40'!
asHypersurface
	^ self ambient isPlane
		ifTrue: [self as: AffinePlaneCurve]
		ifFalse: [self as: AffineHypersurface]! !

!AffineVariety methodsFor: 'elements' stamp: 'len 5/8/2023 22:56:03'!
!! anObject
	anObject isTuple ifTrue: [^ self pointAt: anObject].
	(anObject isKindOf: AffinePoint) ifTrue: [^ self pointAt: anObject coordinates].
	^ super !! anObject! !

!AffineVariety methodsFor: 'morphisms' stamp: 'len 9/16/2022 07:35:56'!
to: aCodomain map: aBlock
	^ RationalMap from: self to: aCodomain map: aBlock! !

!AffineVariety methodsFor: 'morphisms' stamp: 'len 7/9/2022 13:59:58'!
to: aCodomain representatives: anArrayOfRationalFunctions
	^ RationalMap from: self to: aCodomain representatives: anArrayOfRationalFunctions! !

!AffineVariety methodsFor: 'operations' stamp: 'len 6/26/2023 14:40:59'!
+ aTuple
	"Answer a new affine varieity that is the translation of the receiver by aTuple.
	The origin is mappet to aTuple (any point p on the receiver is mapped to p + aTuple)."
	| dx |
	dx := self ambient coordinateRing generators - aTuple asArray.
	^ self ambient sub: (self asIdeal apply: [:f| f value: dx])! !

!AffineVariety methodsFor: 'operations' stamp: 'len 4/5/2024 19:04:39'!
- aScheme
	"Answer the difference of the receiver with the argument, whose associated ideal is the ideal (colon) quotient of the respective ideals.
	This is the closure of the result of removing from the receiver the points in the intersection with the argument, counted with multiplicity. (See also the 'complement' >>\)."
	aScheme isTuple ifTrue: [^ self + aScheme negated].
	self ambient = aScheme ambient ifFalse: [^ self error: 'ambients don''t match'].
	^ self ambient sub: self asIdeal : aScheme asIdeal! !

!AffineVariety methodsFor: 'operations' stamp: 'len 4/5/2024 19:04:30'!
\ aScheme
	"Answer the (closure of the) complement of the argument in the receiver.
	This is the closure of the result of removing from the receiver *all* points in the intersection with the argument, irrespective of multiplicity. (See also the 'difference' >>-)."
	self ambient = aScheme ambient ifFalse: [^ self error: 'ambients don''t match'].
	^ self ambient sub: (self asIdeal saturation: aScheme asIdeal)! !

!AffineVariety methodsFor: 'operations' stamp: 'len 1/13/2022 10:30:44'!
multiplicityAt: aTuple
	"Answer the multiplicity at the given point."
	^ ((self - aTuple) asIdeal orderedBy: #lglex) basis max: [:each| each order]! !

!AffineVariety methodsFor: 'operations' stamp: 'len 6/26/2023 14:41:15'!
primaryComponents
	"Answer the irredundant primary components of the receiver."
	^ self asIdeal primaryComponents collect: [:each| self sub: each]! !

!AffineVariety methodsFor: 'operations' stamp: 'len 6/26/2023 14:41:19'!
primeComponents
	"Answer the irredundant prime components of the receiver."
	^ self asIdeal primeComponents collect: [:each| self sub: each]! !

!AffineVariety methodsFor: 'operations' stamp: 'len 6/26/2023 14:41:23'!
project: anIndeterminate
	"Answer the projection of the receiver by eliminating the given indeterminate.
	This is the intersection of the receiver with a linear subspace {xi = 0}."
	^ self ambient sub: (self asIdeal eliminate: anIndeterminate)! !

!AffineVariety methodsFor: 'operations' stamp: 'len 6/28/2023 00:11:02'!
projectiveClosure
	"Answer the projective closure of the receiver. If the receiver is an affine patch of a projective variety, answer the original projective variety. Otherwise the projective closure will be a projective variety over the projective closure of the ambient space of the receiver, and the receiver will be the last affine patch."
	| P i PX patches |
	self propertyAt: #projectiveClosure ifPresent: [:aProjectiveVariety| ^ aProjectiveVariety].
	P := self ambient projectiveClosure.
	i := P patches identityIndexOf: self ambient.
	PX := P sub: (self asIdeal generators collect: [:each| P coordinateRing !! each homogenizedIn: i]).
	self addMap: (self to: PX map: [:x| x homogenizedAt: i]).
	patches := Array new: P ambient rank.
	patches at: i put: self.
	PX propertyAt: #patches put: patches.
	^ self propertyAt: #projectiveClosure put: PX! !

!AffineVariety methodsFor: 'operations' stamp: 'len 2/4/2017 09:05:48'!
projectivized
	"Answer the projectivization of the receiver."
	^ self coordinateRing proj! !

!AffineVariety methodsFor: 'operations' stamp: 'len 7/12/2023 12:29:11'!
restriction
	"If the receiver is defined over an algebraic field extension L/k, answer the Weil restriction as a scheme over k."
	| R L K d n S p α v generators |
	self propertyAt: #restriction ifPresent: [:aScheme| ^ aScheme].
	R := self coordinateRing.
	L := R scalars.
	(d := L degree) = 1 ifTrue: [^ self].
	K := L scalars.
	n := R cover rank.
	S := K polynomialsIn: n*d + 1.
	α := S generators last.
	p := R scalars modulus value: α.
	v := (1 to: n) collect: [:i| (0 to: d-1) sum: [:j| α^j * (S x: d*(i-1) + j + 1)]].
	generators := OrderedCollection new.
	R relations generators do: [:g|
		((g associations sum: [:each| (each key value: v) * (each value representative value: α)]) \\ p) asUnivariate coefficients do: [:each| generators add: each]].
	^ self propertyAt: #restriction put: (self ambient restriction coordinateRing / generators) spec! !

!AffineVariety methodsFor: 'operations' stamp: 'len 6/26/2023 14:41:34'!
singular
	"Answer the subscheme defined by the appropriately sized minors of the jacobian matrix of the receiver.
	If the receiver is not equidimensional, its lower-dimensional components will be contained in this scheme whether they are singular or not.
	(See Eisenbud 'Commutative Algebra' Ch. 20, re Fitting ideal.)"
	^ self propertyAt: #singularSubscheme ifAbsentPut: [self sub: self asIdeal singular]! !

!AffineVariety methodsFor: 'operations' stamp: 'len 6/26/2023 14:41:38'!
tangentConeAt: aTuple
	"Answer the affine tangent cone at the given point."
	| R I |
	R := self ambient coordinateRing.
	I := (self - aTuple) asIdeal.
	^ (self ambient sub: ((I orderedBy: #lglex) basis collect: [:each| R !! each initialForm])) + aTuple! !

!AffineVariety methodsFor: 'operations' stamp: 'len 6/26/2023 14:41:41'!
tangentSpaceAt: aTuple
	"Answer the affine tangent space at the given point."
	| R I |
	R := self ambient coordinateRing.
	I := (self - aTuple) asIdeal.
	^ (self ambient sub: (I generators collect: [:f| (1 to: R rank) sum: [:i| (R x: i) * (f derivativeIn: i) independentCoefficient]])) + aTuple! !

!AffineVariety methodsFor: 'points' stamp: 'len 6/27/2023 15:13:41'!
pointAt: aTuple
	self assert: aTuple size = self ambient rank.
	^ AffinePoint on: self coordinates: aTuple! !

!AffineVariety methodsFor: 'points' stamp: 'len 6/21/2023 23:21:24'!
pointsOver: aRing do: aBlock
	"Naive enumeration of rational points on the receiver."
	| generators |
	generators := self asIdeal generators.
	self ambient pointsOver: aRing do: [:each| (generators allSatisfy: [:g| (g value: each coordinates) isZero]) ifTrue: [aBlock value: (self pointAt: each coordinates)]]! !

!AffineVariety methodsFor: 'testing' stamp: 'len 1/9/2017 16:35:09'!
isComplete
	^ self isFinite! !

!AffineVariety methodsFor: 'testing' stamp: 'len 1/24/2017 11:58:07'!
isEquidimensional
	"Answer true if the receiver is pure dimensional or equidimensional, i.e. if the dimension of the local ring at p is independent of p."
	^ self singular dimension < 0! !

!AffineVariety methodsFor: 'testing' stamp: 'len 1/13/2022 10:30:24'!
isFinite
	"This works for any Groebner basis, no matter the ordering."
	"Does this work for non integral schemes?"
	self asIdeal scalars indeterminates do: [:x|
		(self asIdeal basis anySatisfy: [:f| | d m | m _ f leadingMonomial. d _ m degree. d > 0 and: [d = (m degreeIn: x)]])
			ifFalse: [^ false]].
	^ true! !

!AffineVariety methodsFor: 'testing' stamp: 'len 12/15/2021 11:58:52'!
isLinear
	^ self reduced asIdeal generators allSatisfy: [:each| each isLinear]! !

!AffineVariety methodsFor: 'testing' stamp: 'len 12/15/2021 19:30:29'!
isSmooth
	"Answer true if the receiver is nonsingular."
	^ self propertyAt: #isSmooth ifAbsentPut: [self singular dimension < 0]! !

!AffineVariety methodsFor: 'testing' stamp: 'len 12/15/2021 11:59:34'!
satisfies: aTuple
	"Answer true if the defining equations of the receiver satisfy the argument, assuming it's the coordinates of a rational point in the ambient space."
	^ self asIdeal generators allSatisfy: [:each| (each value: aTuple) isZero]! !

!AffineVariety methodsFor: 'private' stamp: 'len 7/25/2022 11:32:48'!
species
	^ AffineVariety! !

!AffineVariety class methodsFor: 'examples' stamp: 'len 6/23/2023 19:52:24'!
circle
	"The unit circle in the affine plane:"
	| R x y I |
	R := ℤ polynomialsIn: #(x y).
	x := R x.
	y := R y.
	I := R * (x^2 + (y^2) - 1).
	^ (R / I) spec! !

!AffineVariety class methodsFor: 'examples' stamp: 'len 6/26/2023 14:41:11'!
clebschCubic
	"The Clebsch cubic as affine scheme in Q^3.
	This is the unique cubic surface that has Sym(5) as symmetry group."
	| A x y z f |
	A := AffineSpace new: #(x y z) over: ℚ.
	x := A coordinateRing x.
	y := A coordinateRing y.
	z := A coordinateRing z.
	f := x^3 + (y^3) + (z^3) * 81
			+ (x^2*y + (x^2*z) + (x*(y^2)) + (x*(z^2)) + (y^2*z) + (y*(z^2)) * -189)
			+ (x*y*z * 54)
			+ (x*y + (x*z) + (y*z) * 126)
			+ (x^2 + (y^2) + (z^2) * -9)
			+ 1.
	^ A sub: f! !

!AffineVariety class methodsFor: 'examples' stamp: 'len 6/26/2023 14:41:29'!
romanSurface
	"The Roman surface or Steiner surface.
	This is a self-intersecting mapping of the real projective plane into affine 3-space.
	It was discovered by Jakob Steiner when he was in Rome in 1844."
	| A r |
	A := AffineSpace new: #(x y z) over: ℤ.
	r := 1.
	^ A sub: A coordinateRing !! [:x :y :z| x*y^2 + (y*z^2) + (z*x^2) - (x*y*z*r squared)]! !

!AffineVariety class methodsFor: 'examples' stamp: 'len 6/26/2023 14:41:46'!
twistedCubic
	"This is the twisted cubic affine variety, parameterized by (x, x^2, x^3)."
	| A x y z |
	A := AffineSpace new: #(x y z) over: ℚ.
	x := A coordinateRing x.
	y := A coordinateRing y.
	z := A coordinateRing z.
	^ A sub: {y - (x^2). z - (x^3)}! !

!AffineVariety class methodsFor: 'examples' stamp: 'len 6/26/2023 14:41:50'!
whitneyUmbrella
	"This is Whitney's umbrella in affine space Q^3."
	| A |
	A := AffineSpace new: #(x y z) over: ℚ.
	^ A sub: A coordinateRing !! [:x :y :z| x^2*y - (z^2)]! !

!AffineVariety class methodsFor: 'instance creation' stamp: 'len 5/1/2024 12:26:20'!
coordinateRing: anAffineAlgebra
	self == AffineVariety ifFalse: [^ super coordinateRing: anAffineAlgebra].
	(anAffineAlgebra relators size = 1 and: [anAffineAlgebra relators any degree > 0]) ifTrue:
		[anAffineAlgebra rank = 2 ifTrue: [^ AffinePlaneCurve coordinateRing: anAffineAlgebra].
		^ AffineHypersurface coordinateRing: anAffineAlgebra].
	^ super coordinateRing: anAffineAlgebra! !

!AffineVariety class methodsFor: 'instance creation' stamp: 'len 7/25/2022 11:32:48'!
newFrom: anObject
	(anObject isKindOf: AffineVariety) ifTrue: [^ self coordinateRing: anObject coordinateRing].
	^ super newFrom: anObject! !

!AffineCurve methodsFor: 'accessing' stamp: 'len 10/24/2016 18:34'!
dimension
	^ 1! !

!AffineCurve methodsFor: 'accessing' stamp: 'len 7/13/2023 14:40:38'!
genus
	"Answer the geometric genus of the receiver."
	^ self functionField genus! !

!AffineHypersurface methodsFor: 'accessing' stamp: 'len 1/8/2017 17:48:10'!
degree
	"The degree of a hypersurface is the total degree of the defining polynomial."
	^ self polynomial degree! !

!AffineHypersurface methodsFor: 'accessing' stamp: 'len 1/8/2017 17:17:24'!
dimension
	^ self ambient dimension - 1! !

!AffineHypersurface methodsFor: 'accessing' stamp: 'len 12/15/2021 11:56:51'!
polynomial
	^ self asIdeal generator! !

!AffineHypersurface methodsFor: 'operations' stamp: 'len 4/5/2024 19:04:20'!
multiplicityAt: aTuple
	self assert: self scalars isField.
	^ (self - aTuple) polynomial order! !

!AffineHypersurface class methodsFor: 'instance creation' stamp: 'len 1/23/2017 11:30:29'!
polynomial: aPolynomial
	^ self coordinateRing: aPolynomial parent / aPolynomial! !

!AffinePlaneCurve methodsFor: 'operations' stamp: 'len 6/26/2023 14:41:54'!
tangentsAt: aTuple
	| f r derivatives |
	f := (self - aTuple) polynomial.
	r := f order. "multiplicity at the point"
	derivatives := (0 to: r) collect: [:k| (f derivative: k in: 1) derivative: r-k in: 2].
	^ (self ambient sub: ((0 to: r) sum: [:k| (r choose: k) * (derivatives at: k+1) * (f parent x: 1 to: k) * (f parent x: 2 to: r-k)])) + aTuple! !

!AffinePlaneCurve class methodsFor: 'examples' stamp: 'len 5/23/2020 09:11:37'!
descartesFolium
	"This is the 'Descartes folium'."
	^ AffinePlaneCurve polynomial: (ℚ polynomialsIn: #(x y)) !! [:x :y| x^3 + (y^3) - (3*x*y)]! !

!AffinePlaneCurve class methodsFor: 'examples' stamp: 'len 5/23/2020 09:11:37'!
iminus
	^ AffinePlaneCurve polynomial: (ℚ polynomialsIn: #(x y)) !! [:x :y| x^3 + (y^3) - x - (2*y) - 1]! !

!AffineSpace methodsFor: 'accessing' stamp: 'len 8/27/2016 19:03'!
ambient
	^ self! !

!AffineSpace methodsFor: 'accessing' stamp: 'len 12/15/2021 11:55:33'!
asIdeal
	"Answer the defining ideal of the receiver, considered as a subscheme of itself."
	^ self coordinateRing asIdeal null! !

!AffineSpace methodsFor: 'accessing' stamp: 'len 12/23/2023 10:32:26'!
rank
	"Answer the number of affine coordinates, i.e. the number of indeterminates of the coordinate ring. This can be different from the Krull dimension, for example Spec ℤ[x] has rank 1 and Krull dimension 2."
	^ self coordinateRing rank! !

!AffineSpace methodsFor: 'operations' stamp: 'len 6/27/2023 23:59:14'!
projectiveClosure
	"Answer the projective closure of the receiver.
	If the receiver is already an affine patch of a projective space, answer the original projective space."
	| P patches |
	self propertyAt: #projectiveClosure ifPresent: [:aProjectiveSpace| ^ aProjectiveSpace].
	P := (self scalars polynomialsIn: self rank + 1) proj.
	self addMap: (self to: P map: [:x| x homogenizedAt: P rank]).
	patches := Array new: P ambient rank.
	patches at: patches size put: self.
	P propertyAt: #patches put: patches.
	^ self propertyAt: #projectiveClosure put: P! !

!AffineSpace methodsFor: 'operations' stamp: 'len 7/12/2023 12:29:01'!
restriction
	"If the receiver is defined over an algebraic field extension L/k, answer the Weil restriction as a scheme over k."
	self scalars degree = 1 ifTrue: [^ self].
	^ self propertyAt: #restriction ifAbsentPut: [self class new: self rank * self scalars degree over: self scalars scalars]! !

!AffineSpace methodsFor: 'points' stamp: 'len 5/28/2020 14:53:40'!
origin
	^ self pointAt: (self scalars^self rank) zero! !

!AffineSpace methodsFor: 'points' stamp: 'len 1/22/2017 08:22:56'!
pointsCountOver: aRing
	^ aRing size ^ self rank! !

!AffineSpace methodsFor: 'points' stamp: 'len 5/28/2020 18:03:10'!
pointsOver: aRing do: aBlock
	^ aRing ^ self rank do: [:each| aBlock value: (self pointAt: each)]! !

!AffineSpace methodsFor: 'points' stamp: 'len 6/1/2024 07:28:45'!
to: aCodomain atRandom: aRandom
	(aCodomain isKindOf: AffineScheme) ifFalse: [^ super to: aCodomain atRandom: aRandom].
	self scalars ⇢ aCodomain coordinateRing ifNil: [^ super to: aCodomain atRandom: aRandom].
	^ self pointAt: ((aCodomain coordinateRing^self rank) atRandom: aRandom)! !

!AffineSpace methodsFor: 'printing' stamp: 'len 10/8/2022 19:27:12'!
printOn: aStream
	aStream nextPut: $𝔸.
	self rank = 1 ifFalse: [aStream nextPutAll: self rank printString super].
	aStream nextPut: $(; print: self scalars; nextPut: $)! !

!AffineSpace methodsFor: 'random' stamp: 'len 7/12/2023 18:08:05'!
pointOver: aRing atRandom: aRandom
	^ self pointAt: (aRing^self rank atRandom: aRandom)! !

!AffineSpace methodsFor: 'testing' stamp: 'len 2/22/2017 07:54:37'!
isPlane
	^ self rank = 2! !

!AffineSpace methodsFor: 'testing' stamp: 'len 1/13/2017 17:07:13'!
satisfies: aTuple
	^ true! !

!AffineSpace class methodsFor: 'instance creation' stamp: 'len 6/28/2023 17:04:11'!
new: rank over: aRing
	^ (aRing polynomialsIn: rank) spec! !

!ProjectiveScheme methodsFor: 'accessing' stamp: 'len 7/30/2022 11:40:36'!
@ aPoint
	"Answer the local ring corresponding to the stalk of the structure sheaf at aPoint.
	For the Proj(R) aPoint is a relevant homogeneous prime ideal of R,
	which is also a point of the affine cone Spec(R)."
	^ self affineCone @ aPoint! !

!ProjectiveScheme methodsFor: 'accessing' stamp: 'len 6/10/2022 11:52:18'!
ambient
	^ self propertyAt: #ambient ifAbsent: [self coordinateRing isQuotient ifTrue: [self coordinateRing cover proj] ifFalse: [self]]! !

!ProjectiveScheme methodsFor: 'accessing' stamp: 'len 12/20/2021 12:47:23'!
base
	"Answer the base scheme of the receiver."
	^ self scalars spec! !

!ProjectiveScheme methodsFor: 'accessing' stamp: 'len 12/20/2021 12:37:10'!
coordinateRing
	"Answer the homogeneous coordinate ring."
	^ self propertyAt: #coordinateRing! !

!ProjectiveScheme methodsFor: 'accessing' stamp: 'len 4/13/2024 05:04:11'!
idealSheaf
	^ CoherentSheaf module: self asIdeal on: self ambient! !

!ProjectiveScheme methodsFor: 'accessing' stamp: 'len 12/20/2021 12:47:35'!
scalars
	^ self coordinateRing scalars! !

!ProjectiveScheme methodsFor: 'accessing' stamp: 'len 7/30/2022 12:09:58'!
sections
	"Answer the ring of regular functions, or ring of global sections of the structure sheaf."
	^ self coordinateRing scalars! !

!ProjectiveScheme methodsFor: 'accessing' stamp: 'len 4/13/2024 05:04:11'!
structureSheaf
	^ CoherentSheaf module: self coordinateRing asIdeal on: self! !

!ProjectiveScheme methodsFor: 'comparing' stamp: 'len 6/20/2023 20:22:34'!
= anObject
	^ (anObject isKindOf: self species) and: [self coordinateRing = anObject coordinateRing or: [self saturated coordinateRing = anObject saturated coordinateRing]]! !

!ProjectiveScheme methodsFor: 'comparing' stamp: 'len 12/20/2021 12:38:27'!
hash
	^ self saturated coordinateRing hash! !

!ProjectiveScheme methodsFor: 'converting' stamp: 'len 7/29/2022 08:09:16'!
asIdeal
	"Answer the defining ideal of the receiver. This is a homogeneous ideal of the ambient homogeneous coordinate ring."
	^ self coordinateRing isQuotient ifTrue: [self coordinateRing relations] ifFalse: [self coordinateRing asIdeal null]! !

!ProjectiveScheme methodsFor: 'converting' stamp: 'len 12/20/2021 12:30:44'!
over: aRing
	^ self class coordinateRing: (self coordinateRing over: aRing)! !

!ProjectiveScheme methodsFor: 'elements' stamp: 'len 7/27/2022 09:50:21'!
!! anObject
	((anObject isKindOf: Ideal) and: [anObject scalars = self coordinateRing and: [anObject isHomogeneous]]) "assume it's prime and relevant"
		ifTrue: [^ anObject].
	^ super !! anObject! !

!ProjectiveScheme methodsFor: 'enumerating' stamp: 'len 12/20/2021 12:38:03'!
do: aBlock
	self coordinateRing relevantHomogeneousPrimeIdealsDo: aBlock! !

!ProjectiveScheme methodsFor: 'operations' stamp: 'len 12/20/2021 12:35:38'!
affineCone
	"If the receiver is defined by an homogeneous ideal I, the affine cone is the affine variety defined by I."
	^ self coordinateRing spec! !

!ProjectiveScheme methodsFor: 'operations' stamp: 'len 10/24/2023 16:09:40'!
reduced
	"Answer the reduced subscheme of the receiver."
	^ self propertyAt: #reducedSubscheme ifAbsentPut: [self ambient sub: self asIdeal radical]! !

!ProjectiveScheme methodsFor: 'operations' stamp: 'len 12/20/2021 12:41:21'!
saturated
	"Ensure the defining ideal of the receiver is saturated.
	This is important for some operations with projective schemes because projective schemes are not in correspondence with homogeneous ideals (like affine schemes), but they are in correspondence with saturated homogeneous ideals."
	(self propertyAt: #isSaturated ifAbsent: [false]) ifTrue: [^ self].
	self coordinateRing: self ambient coordinateRing / self asIdeal saturation.
	self propertyAt: #isSaturated put: true! !

!ProjectiveScheme methodsFor: 'operations' stamp: 'len 4/5/2024 19:04:06'!
∩ aScheme
	"Answer the intersection of the receiver and the argument."
	self ambient = aScheme ambient ifFalse: [^ self error: 'ambients don''t match'].
	^ self ambient sub: self asIdeal + aScheme asIdeal! !

!ProjectiveScheme methodsFor: 'operations' stamp: 'len 4/5/2024 19:03:58'!
∪ aScheme
	"Answer the union of the receiver and the argument."
	self ambient = aScheme ambient ifFalse: [^ self error: 'ambients don''t match'].
	^ self ambient sub: self asIdeal ∩ aScheme asIdeal

"alternatively:
	^ self class on: self ambient ideal: ideal * aScheme ideal
although the intersection is harder to compute, it behaves better with radicalization, because the intersection of two radical ideals is radical and we don't need to compute radicals again"! !

!ProjectiveScheme methodsFor: 'printing' stamp: 'len 12/20/2021 12:31:33'!
printOn: aStream
	aStream nextPutAll: 'Proj '; print: self coordinateRing! !

!ProjectiveScheme methodsFor: 'testing' stamp: 'len 12/20/2021 12:39:35'!
isIntegral
	"A scheme is called 'integral' if it is reduced and irreducible."
	^ self coordinateRing isIntegralDomain "is this correct for Proj?"! !

!ProjectiveScheme methodsFor: 'testing' stamp: 'len 12/20/2021 12:39:19'!
isIrreducible
	"A scheme is called 'irreducible' if its underlying topological space is irreducible, i.e. it is not empty and it is not the union of two proper closed subsets."
	self isIntegral ifTrue: [^ true].
	^ super isIrreducible! !

!ProjectiveScheme methodsFor: 'testing' stamp: 'len 7/11/2022 12:49:51'!
isProjective
	^ true! !

!ProjectiveScheme methodsFor: 'testing' stamp: 'len 12/20/2021 12:39:05'!
isReduced
	"A scheme is called 'reduced' if all its stalks are reduced (i.e., their nilradicals are 0)."
	^ self coordinateRing isReduced! !

!ProjectiveScheme methodsFor: 'private' stamp: 'len 12/20/2021 12:52:14'!
coordinateRing: aGradedRing
	self propertyAt: #coordinateRing put: aGradedRing! !

!ProjectiveScheme methodsFor: 'private' stamp: 'len 12/20/2021 12:32:29'!
species
	^ ProjectiveScheme! !

!ProjectiveScheme class methodsFor: 'instance creation' stamp: 'len 12/20/2021 12:28:12'!
coordinateRing: aGradedRing
	^ self new coordinateRing: aGradedRing! !

!ProjectiveVariety methodsFor: 'accessing' stamp: 'len 1/10/2017 21:15:14'!
arithmeticGenus
	"Answer the arithmetic genus of the receiver."
	self ambient isOrdinaryProjectiveSpace ifFalse: [^ self error: 'not ordinary projective space'].
	self notYetImplemented! !

!ProjectiveVariety methodsFor: 'accessing' stamp: 'len 5/23/2020 09:11:37'!
degree
	| t H |
	t _ ℚ polynomials fractions x.
	H _ self coordinateRing hilbertSeriesAt: t.
	^ (1 - t) ^ (H orderAt: 1) negated * H value: 1! !

!ProjectiveVariety methodsFor: 'accessing' stamp: 'len 5/23/2020 09:11:37'!
degree2
	| t H |
	t _ ℚ polynomials fractions x.
	H _ self coordinateRing hilbertSeriesAt: t.
	^ (1 - t) ^ self coordinateRing dimension * H value: 1! !

!ProjectiveVariety methodsFor: 'accessing' stamp: 'len 10/20/2016 15:25'!
dimension
	self flag: #fix. "is this right for projective schemes or should use the Hilbert series?"
	^ self coordinateRing dimension - 1! !

!ProjectiveVariety methodsFor: 'accessing' stamp: 'len 7/25/2022 12:03:58'!
functionField
	"If K(X) is the function field of the affine cone, the function field of the projective variety is the subfield of K(X) of homogeneous elements of degree 0, that is fractions f/g with f,g in K(X) homogeneous of the same degree and g not zero.
	This is isomorphic to the function field of any affine patch."
	^ (self patch: self ambient rank) functionField! !

!ProjectiveVariety methodsFor: 'accessing' stamp: 'len 6/27/2023 23:57:48'!
patch: i
	"Answer the i-th affine patch of the receiver."
	| patches answer |
	patches := self propertyAt: #patches ifAbsentPut: [Array new: self ambient rank].
	(patches at: i) ifNotNil: [:anAffineVariety| ^ anAffineVariety].
	answer := self newPatch: i.
	answer addMap: (answer to: self map: [:x| x homogenizedAt: i]).
	answer propertyAt: #projectiveClosure put: self.
	^ patches at: i put: answer! !

!ProjectiveVariety methodsFor: 'accessing' stamp: 'len 1/12/2017 14:44:25'!
patches
	"Answer all the standard affine patches of the receiver."
	^ (1 to: self ambient rank) collect: [:i| self patch: i]! !

!ProjectiveVariety methodsFor: 'converting' stamp: 'len 2/22/2017 07:56:24'!
asCurve
	^ self ambient isPlane
		ifTrue: [self as: ProjectivePlaneCurve]
		ifFalse: [self as: ProjectiveCurve]! !

!ProjectiveVariety methodsFor: 'converting' stamp: 'len 2/22/2017 07:56:46'!
asHypersurface
	^ self ambient isPlane
		ifTrue: [self as: ProjectivePlaneCurve]
		ifFalse: [self as: ProjectiveHypersurface]! !

!ProjectiveVariety methodsFor: 'elements' stamp: 'len 5/8/2023 22:55:36'!
!! anObject
	anObject isTuple ifTrue: [^ self pointAt: anObject].
	(anObject isKindOf: ProjectivePoint) ifTrue: [^ self pointAt: anObject coordinates].
	^ super !! anObject! !

!ProjectiveVariety methodsFor: 'morphisms' stamp: 'len 9/16/2022 07:36:14'!
to: aCodomain map: aBlock
	^ RationalMap from: self to: aCodomain map: aBlock! !

!ProjectiveVariety methodsFor: 'morphisms' stamp: 'len 7/9/2022 14:00:08'!
to: aCodomain representatives: anArrayOfRationalFunctions
	^ RationalMap from: self to: aCodomain representatives: anArrayOfRationalFunctions! !

!ProjectiveVariety methodsFor: 'operations' stamp: 'len 7/26/2022 19:31:32'!
× aProjectiveVariety
	"Answer the cartesian product of the receiver and the argument."
	(aProjectiveVariety isKindOf: ProjectiveVariety) ifFalse: [self notYetImplemented].
	self scalars = aProjectiveVariety scalars ifFalse: [self error: 'scalars don''t match'].
	^ (self coordinateRing ⊗ aProjectiveVariety coordinateRing) proj
		propertyAt: #ambient put: self ambient × aProjectiveVariety ambient;
		yourself! !

!ProjectiveVariety methodsFor: 'operations' stamp: 'len 6/26/2023 14:42:15'!
decomposition
	"Answer the irreducible components of the receiver."
	| primes |
	primes := self asIdeal associatedPrimes.
	"Since the scheme is projective, remove the primes containing the irrelevant ideal:"
	primes := primes reject: [:each| self ambient coordinateRing generators anySatisfy: [:xi| each includes: xi]].
	^ primes collect: [:each| self sub: each]! !

!ProjectiveVariety methodsFor: 'operations' stamp: 'len 2/10/2017 08:23:03'!
dual
	"Answer the projective dual of the receiver."
	self notYetImplemented! !

!ProjectiveVariety methodsFor: 'operations' stamp: 'len 6/26/2023 14:42:37'!
singular
	"Answer the subscheme defined by the appropriately sized minors of the jacobian matrix of the receiver.
	If the receiver is not equidimensional, its lower-dimensional components will be contained in this scheme whether they are singular or not.
	(See Eisenbud 'Commutative Algebra' Ch. 20, re Fitting ideal.)"
	^ self propertyAt: #singularSubscheme ifAbsentPut: [self sub: self asIdeal singular]! !

!ProjectiveVariety methodsFor: 'operations' stamp: 'len 6/26/2023 14:42:41'!
tangentSpaceAt: aTuple
	"Answer the projective tangent space of the receiver at the given point."
	| R |
	self flag: #fix. "this might be wrong, The Geometry of Schemes pag 105"
	R := self ambient coordinateRing.
	^ self ambient sub: (self asIdeal generators collect: [:f| (1 to: R rank) sum: [:i| (R x: i) * ((f derivativeIn: i) value: aTuple)]])! !

!ProjectiveVariety methodsFor: 'points' stamp: 'len 6/27/2023 15:12:06'!
pointAt: aTuple
	self assert: aTuple size = self ambient rank.
	^ ProjectivePoint on: self coordinates: aTuple! !

!ProjectiveVariety methodsFor: 'points' stamp: 'len 6/21/2023 23:21:30'!
pointsOver: aRing do: aBlock
	"Naive enumeration of rational points on the receiver."
	| generators |
	generators := self asIdeal generators.
	self ambient pointsOver: aRing do: [:each| (generators allSatisfy: [:g| (g value: each coordinates) isZero]) ifTrue: [aBlock value: (self pointAt: each coordinates)]]! !

!ProjectiveVariety methodsFor: 'testing' stamp: 'len 1/9/2017 16:34:57'!
isComplete
	^ true! !

!ProjectiveVariety methodsFor: 'testing' stamp: 'len 6/27/2023 17:33:40'!
isEmpty
	"Answer true if the receiver has no points over any algebraic closure of its base field."
	self flag: #fixme.
	^ self dimension <= -1 "or <???"! !

!ProjectiveVariety methodsFor: 'testing' stamp: 'len 12/15/2021 19:30:53'!
isSmooth
	"Answer true if the receiver is nonsingular."
	^ self propertyAt: #isSmooth ifAbsentPut: [self singular dimension < 0]! !

!ProjectiveVariety methodsFor: 'testing' stamp: 'len 12/15/2021 12:01:25'!
satisfies: aTuple
	"Answer true if the defining equations of the receiver satisfy the argument, assuming it's the coordinates of a rational point in the ambient space."
	^ self asIdeal generators allSatisfy: [:each| (each value: aTuple) isZero]! !

!ProjectiveVariety methodsFor: 'private' stamp: 'len 6/26/2023 14:42:33'!
newPatch: i
	^ (self ambient patch: i) sub: (self asIdeal dehomogenizedIn: i)! !

!ProjectiveVariety methodsFor: 'private' stamp: 'len 7/25/2022 11:33:02'!
species
	^ ProjectiveVariety! !

!ProjectiveVariety class methodsFor: 'examples' stamp: 'len 6/26/2023 14:42:12'!
cayleyCubic
	"The Cayley cubic as projective surface.
	This is the unique cubic surface that has 4 ordinary nodes.
	It is a degeneration of the Clebsh cubic and has Sym(4) as its symmetry group."
	| P |
	P := ProjectiveSpace new: #(x y z w) over: ℚ.
	^ P sub: P coordinateRing !! [:x :y :z :w| x*y*z + (x*y*w) + (x*z*w) + (y*z*w)]! !

!ProjectiveVariety class methodsFor: 'examples' stamp: 'len 6/26/2023 14:42:20'!
fermat4
	"The 4th Fermat curve."
	| P |
	P := ProjectiveSpace new: #(x y z) over: ℚ.
	^ P sub: P coordinateRing !! [:x :y :z| x^4 + (y^4) - (z^4)]! !

!ProjectiveVariety class methodsFor: 'examples' stamp: 'len 6/26/2023 14:42:24'!
fermat: n
	"The n-th Fermat curve."
	| P |
	P := ProjectiveSpace new: #(x y z) over: ℚ.
	^ P sub: (P coordinateRing !! [:x :y :z| x^n + (y^n) - (z^n)])! !

!ProjectiveVariety class methodsFor: 'examples' stamp: 'len 6/26/2023 14:42:27'!
kleinQuartic
	"This is a projective variety, a curve in P^2(C)."
	| P x y z |
	P := ProjectiveSpace new: 2 over: ℚ.
	x := P coordinateRing x.
	y := P coordinateRing y.
	z := P coordinateRing z.
	^ P sub: {x^3*y + (y^3*z) + (z^3*x)}! !

!ProjectiveVariety class methodsFor: 'instance creation' stamp: 'len 5/1/2024 12:26:26'!
coordinateRing: anAffineAlgebra
	self == ProjectiveVariety ifFalse: [^ self new coordinateRing: anAffineAlgebra].
	anAffineAlgebra relators size = 1 ifTrue:
		[| f |
		f := anAffineAlgebra relators any.
		f degree > 0 ifTrue:
			[anAffineAlgebra rank = 3 ifTrue:
				[f degree = 1 ifTrue: [^ RationalCurve coordinateRing: anAffineAlgebra].
				f degree = 2 ifTrue: [^ Conic coordinateRing: anAffineAlgebra].
				f degree = 3 ifTrue: ["elliptic curve"].
				^ ProjectivePlaneCurve coordinateRing: anAffineAlgebra].
			^ ProjectiveHypersurface coordinateRing: anAffineAlgebra]].
	^ self new coordinateRing: anAffineAlgebra! !

!ProjectiveVariety class methodsFor: 'instance creation' stamp: 'len 7/25/2022 11:33:02'!
newFrom: anObject
	(anObject isKindOf: ProjectiveVariety) ifTrue: [^ self coordinateRing: anObject coordinateRing].
	^ super newFrom: anObject! !

!ProjectiveCurve methodsFor: 'accessing' stamp: 'len 7/13/2023 16:13:04'!
arithmeticGenus
	"Answer the arithmetic genus of the receiver, assuming it is an irreducible curve."
	^ 1 - (self coordinateRing hilbertPolynomial value: 0)! !

!ProjectiveCurve methodsFor: 'accessing' stamp: 'len 10/13/2016 13:38'!
dimension
	^ 1! !

!ProjectiveCurve methodsFor: 'as yet unclassified' stamp: 'len 4/30/2018 19:16:28'!
divisorOf: aRationalFunction
	"Answer div(f), the divisor with coefficient ord(f,p) for each point p of its support, where ord(f,p) is the order of a point p as zero or pole of the rational function f."
	self notYetImplemented! !

!ProjectiveHypersurface methodsFor: 'accessing' stamp: 'len 1/8/2017 17:39:24'!
degree
	"The degree of a projective hypersurface is the degree of the defining homogeneous polynomial."
	^ self polynomial degree! !

!ProjectiveHypersurface methodsFor: 'accessing' stamp: 'len 1/8/2017 17:21:47'!
dimension
	^ self ambient dimension - 1! !

!ProjectiveHypersurface methodsFor: 'accessing' stamp: 'len 2/10/2017 08:22:53'!
dual
	"Answer the projective dual of the receiver."
	self notYetImplemented! !

!ProjectiveHypersurface methodsFor: 'accessing' stamp: 'len 12/15/2021 12:00:42'!
polynomial
	^ self asIdeal generator! !

!ProjectiveHypersurface methodsFor: 'as yet unclassified' stamp: 'len 1/11/2017 20:55:49'!
gradient
	| f F |
	f _ self polynomial.
	F _ self ambient functionField.
	"actually should go to the dual projective space"
	^ RationalMap from: self to: self ambient representatives: ((1 to: F rank) collect: [:i| F !! (f derivativeIn: i)])! !

!ProjectiveHypersurface class methodsFor: 'instance creation' stamp: 'len 1/8/2017 17:20:38'!
polynomial: aPolynomial
	^ self coordinateRing: aPolynomial parent / aPolynomial! !

!ProjectivePlaneCurve methodsFor: 'accessing' stamp: 'len 7/13/2023 14:57:13'!
arithmeticGenus
	"Answer the arithmetic genus of the receiver, assuming it is an irreducible curve."
	| n |
	n := self polynomial degree.
	^ n - 1 * (n - 2) / 2! !

!ProjectivePlaneCurve methodsFor: 'accessing' stamp: 'len 6/22/2023 17:15:54'!
hasseWeilBounds
	"Assuming the receiver is a nonsingular curve defined over a finite field K, answer the Hasse-Weil bounds for the number of K-rational points."
	| q rq |
	(self isSingular not and: [self scalars isFiniteField]) ifFalse: [^ self error: 'the Hasse-Weil bound is defined only for nonsingular curves over finite fields'].
	q := self scalars size.
	rq := (self genus squared * 4 * q) sqrtFloor.
	^ q+1-rq to: q+1+rq! !

!ProjectivePlaneCurve methodsFor: 'operations' stamp: 'len 8/12/2022 13:12:07'!
flexes
	"This is the subscheme of flexes of the receiver.
	In classic algebraic geometry, a point in a nonsingular plane curve over the complex numbers is a 'flex' if its tangent line has contact of order >= 3 with the curve."
	^ self ∩ self hessian! !

!ProjectivePlaneCurve methodsFor: 'operations' stamp: 'len 6/26/2023 14:42:45'!
hessian
	"Answer the Hessian curve associated to the receiver.
	Over an algebraically closed field, the intersection of a plane curve and its Hessian is the subvariety of flexes."
	^ self ambient sub: self polynomial hessian determinant! !

!ProjectivePlaneCurve methodsFor: 'testing' stamp: 'len 6/25/2023 17:31:46'!
isIrreducible
	"A scheme is called 'irreducible' if its underlying topological space is irreducible, i.e. it is not empty and it is not the union of two proper closed subsets."
	^ self polynomial isIrreducible! !

!Conic methodsFor: 'accessing' stamp: 'len 5/28/2020 18:19:49'!
coefficients
	^ self propertyAt: #coefficients ifAbsentPut:
		[| f |
		f _ self polynomial orderedBy: #lex.
		(f parent gradingAt: 2) !! f]! !

!Conic methodsFor: 'accessing' stamp: 'len 9/3/2018 21:10:30'!
determinant
	^ self matrix determinant! !

!Conic methodsFor: 'accessing' stamp: 'len 12/25/2016 12:14:47'!
genus
	"Answer the geometric genus of the receiver."
	^ 0! !

!Conic methodsFor: 'accessing' stamp: 'len 9/13/2018 05:48:34'!
matrix
	"Answer the matrix M such that the defining polynomial of this conic is (x,y,z)*M*(x,y,z)^t. The matrix is upper-triangular over characteristic 2, and symmetric otherwise."
	self scalars characteristic = 2
		ifTrue: [^ self upperTriangularMatrix].
	^ self symmetricMatrix! !

!Conic methodsFor: 'accessing' stamp: 'len 12/31/2016 10:07:42'!
parametrization
	"Answer a parametrization of the receiver as a regular map from the projective line."
	| point P1 |
	self scalars isField ifFalse: [^ self error: 'not over a field'].
	self isSmooth ifFalse: [^ self error: 'the conic is not smooth'].
	point _ self anyPoint.
	P1 _ ProjectiveLine over: self scalars.
	"..."! !

!Conic methodsFor: 'morphisms' stamp: 'len 1/7/2017 21:44:28'!
toDiagonal
	"Answer an isomorphism between the receiver and its diagonal form."
	self notYetImplemented! !

!Conic methodsFor: 'points' stamp: 'len 9/4/2018 14:16:51'!
pointAtRandom: aRandom
	"Answer randomly a point of the receiver. Assume the scalars are a finite field."
	| f |
	f _ self parametrization.
	^ f value: (f domain pointAtRandom: aRandom)! !

!Conic methodsFor: 'points' stamp: 'len 8/6/2022 07:12:55'!
pointsCountOver: aRing
	"The number of ℤ/pℤ-rational points of a curve of genus 0 is always p + 1."
	(aRing isKindOf: PrimeField) ifTrue: [^ aRing characteristic + 1].
	^ super pointsCountOver: aRing! !

!Conic methodsFor: 'testing' stamp: 'len 9/4/2018 13:56:26'!
isDiagonal
	"Answer true if the reciever is in diagonal form, i.e. it is defined by a polynomial of the form ax^2 + by^2 + cz^2."
	| coefficients |
	coefficients _ self coefficients.
	^ (coefficients at: 2) isZero and: [(coefficients at: 3) isZero and: [(coefficients at: 5) isZero]]! !

!Conic methodsFor: 'testing' stamp: 'len 1/7/2017 21:48:12'!
isIrreducible
	"In characteristic not 2, this is equivalent to the diagonal form having coefficients a,b,c all not 0."
	^ super isIrreducible! !

!Conic methodsFor: 'testing' stamp: 'len 9/3/2018 20:29:09'!
isSmooth
	"Answer true if the receiver is nonsingular."
	| coefficients p |
	self scalars characteristic = 2 ifFalse: [^ self determinant isZero not].
	coefficients _ self coefficients.
	p _ #(5 3 2) collect: [:i| coefficients at: i].
	(p allSatisfy: [:each| each isZero]) ifTrue: [^ false].
	^ (self polynomial value: p) isZero not! !

!Conic methodsFor: 'private' stamp: 'len 12/26/2016 11:28:39'!
solve: d n: n
	(d < 0 and: [n < 0]) ifTrue: [^ nil].
	d abs > n abs ifTrue: [^ self solve: n n: d].
	d = 1 ifTrue: [^ #(1 1 0)].
	n = 1 ifTrue: [^ #(1 0 1)].
	d = n negated ifTrue: [^ #(0 1 1)].
	d = n ifTrue: [^ (self solve: -1 n: d) ifNotNil: [:xyz| [:x :y :z| {d*z. x. y}] valueWithArguments: xyz]].
	(d isQuadraticResidueModulo: n) ifFalse: [^ nil].
	"... last two steps"! !

!Conic methodsFor: 'private' stamp: 'len 12/15/2022 11:21:11'!
symmetricMatrix
	| T |
	self scalars characteristic = 2
		ifTrue:
			[self isDiagonal ifFalse: [self error: 'symmetric matrix ia undefined for non-diagonal conic over field of characteristic 2'].
			^ self upperTriangularMatrix].
	T _ self upperTriangularMatrix.
	^ T + T transpose / (self scalars !! 2)! !

!Conic methodsFor: 'private' stamp: 'len 5/12/2023 22:57:23'!
upperTriangularMatrix
	| stream |
	stream _ self coefficients asArray readStream.
	^ (self scalars^3) endomorphisms fill: [:i :j| i > j ifTrue: [self scalars zero] ifFalse: [stream next]]! !

!Conic class methodsFor: 'instance creation' stamp: 'len 9/4/2018 13:55:14'!
coefficients: aTuple
	| R x y z |
	R _ aTuple scalars polynomialsIn: #(x y z).
	x _ R x.
	y _ R y.
	z _ R z.
	aTuple size = 3
		ifTrue: [^ self polynomial: x^2 * (aTuple at: 1) + (y^2 * (aTuple at: 2)) + (z^2 * (aTuple at: 3))].
	aTuple size = 6
		ifTrue: [^ self polynomial: x^2*(aTuple at: 1) + (x*y*(aTuple at: 2)) + (x*z*(aTuple at: 3)) + (y^2*(aTuple at: 4)) + (y*z*(aTuple at: 5)) + (z^2*(aTuple at: 6))].
	^ self error: '3 or 6 coefficients expected'! !

!RationalCurve methodsFor: 'as yet unclassified' stamp: 'len 12/25/2016 12:14:55'!
genus
	"Answer the geometric genus of the receiver."
	^ 0! !

!RationalCurve methodsFor: 'as yet unclassified' stamp: 'len 8/6/2022 07:13:04'!
pointsCountOver: aRing
	"The number of ℤ/pℤ-rational points of a curve of genus 0 is always p + 1."
	(aRing isKindOf: PrimeField) ifTrue: [^ aRing characteristic + 1].
	^ super pointsCountOver: aRing! !

!ProjectiveSpace methodsFor: 'accessing' stamp: 'len 8/27/2016 19:03'!
ambient
	^ self! !

!ProjectiveSpace methodsFor: 'accessing' stamp: 'len 12/15/2021 11:56:23'!
asIdeal
	"Answer the defining ideal of the receiver, considered as a subscheme of itself."
	^ self coordinateRing asIdeal null! !

!ProjectiveSpace methodsFor: 'accessing' stamp: 'len 10/20/2016 04:11'!
dimension
	^ self coordinateRing dimension - 1! !

!ProjectiveSpace methodsFor: 'accessing' stamp: 'len 10/20/2016 16:19'!
rank
	^ self coordinateRing rank! !

!ProjectiveSpace methodsFor: 'morphisms' stamp: 'len 11/22/2023 20:16:53'!
automorphisms
	"Answer the group of automorphisms PGL(P), i.e. the linear automorphisms. These are the only regular automorphisms.
	Note that there are more rational automorphisms, the Cremona maps, but they are not included in this group. In the projective plane, the group of birational automorphisms is generated by the linear automorphisms plus the standard quadratic transformation (that takes each coordinate to its reciprocal xᵢ ↦ 1/xᵢ)."
	self notYetImplemented! !

!ProjectiveSpace methodsFor: 'morphisms' stamp: 'len 9/16/2022 07:59:07'!
quadraticMap
	"Answer the standard quadratic map that takes each coordinate to its inverse.
	This is a birational automorphism. In the projective plane, this automorphism together with the linear automorphisms of PGL generate the group of birational automorphisms."
	^ self to: self map: [:x| x apply: [:each| each inverse]]! !

!ProjectiveSpace methodsFor: 'morphisms' stamp: 'len 5/30/2023 20:08:51'!
veronese: degree
	"Answer the Veronese map of the given degree from the receiver."
	| F monomials |
	F := self functionField.
	monomials := (F numerators monomials allMonomialsOfDegree: degree) collect: [:each| F embed: F numerators !! each].
	^ RationalMap from: self to: (ProjectiveSpace new: monomials size - 1 over: self scalars) representatives: monomials! !

!ProjectiveSpace methodsFor: 'operations' stamp: 'len 6/26/2023 14:38:05'!
sub: anObject
	| I |
	I := (anObject isKindOf: Ideal) ifTrue: [anObject] ifFalse: [self coordinateRing * anObject].
	^ (self coordinateRing / I) proj! !

!ProjectiveSpace methodsFor: 'points' stamp: 'len 12/23/2023 10:47:07'!
pointsCountOver: aRing
	aRing isField ifTrue: [^ aRing isFinite ifTrue: [self rank choose: 1 q: aRing size] ifFalse: [aRing size]].
	aRing isFinite ifFalse: [^ aRing size].
	(aRing isKindOf: ModularIntegerRing) ifTrue:
		[^ aRing modulus ^ (self rank - 1) * (aRing modulus factorization asSet product: [:p| (0 to: self rank - 1) sum: [:i| 1 / (p^i)]])].
	^ super pointsCountOver: aRing! !

!ProjectiveSpace methodsFor: 'points' stamp: 'len 6/15/2022 09:52:12'!
pointsOver: aRing do: aBlock
	aRing isField ifTrue: [^ self pointsOverField: aRing do: aBlock].
	aRing = ℤ ifTrue: [^ self pointsOverIntegersDo: aBlock].
	self pointsOverRing: aRing do: aBlock! !

!ProjectiveSpace methodsFor: 'points-private' stamp: 'len 5/6/2023 19:12:49'!
pointsOverField: aRing do: aBlock
	| one zero V |
	one _ aRing one.
	zero _ aRing zero.
	V _ aRing ^ self rank.
	aRing ^ (self rank - 1) do: [:each| | d |
		((d _ each lastNonzeroIndex) notNil and: [(each at: d) = one])
			ifTrue: [aBlock value: (self pointAt: V !! (each coefficients copyWith: zero))].
		aBlock value: (self pointAt: V !! (each coefficients copyWith: one))]! !

!ProjectiveSpace methodsFor: 'points-private' stamp: 'len 5/19/2022 05:49:23'!
pointsOverIntegersDo: aBlock
	ℤ ^ self rank do: [:each| | d |
		((d _ each lastNonzeroIndex) notNil and: [(each at: d) notNil and: [each content = 1]])
			ifTrue: [aBlock value: each]]! !

!ProjectiveSpace methodsFor: 'points-private' stamp: 'len 5/28/2020 18:09:02'!
pointsOverRing: aRing do: aBlock
	| visited point |
	visited _ Set new.
	aRing ^ self rank do: [:each|
		each isUnimodular
			ifTrue: [visited add: (point _ self pointAt: each) ifAbsent: [aBlock value: point]]]! !

!ProjectiveSpace methodsFor: 'printing' stamp: 'len 10/8/2022 19:27:41'!
printOn: aStream
	aStream nextPut: $ℙ.
	self rank = 2 ifFalse: [aStream nextPutAll: (self rank - 1) printString super].
	aStream nextPut: $(; print: self scalars; nextPut: $)! !

!ProjectiveSpace methodsFor: 'random' stamp: 'len 7/12/2023 18:09:53'!
pointOver: aRing atRandom: aRandom
	| coordinates |
	[(coordinates := aRing^self rank atRandom: aRandom) isZero] whileTrue.
	^ self pointAt: coordinates! !

!ProjectiveSpace methodsFor: 'testing' stamp: 'len 7/6/2022 11:18:05'!
isOrdinaryProjectiveSpace
	"Answer true if the receiver is the ordinary projective space, which means that it's not weighted (or that all weights or gradings are 1)."
	^ self coordinateRing ordering isGradedWeighted not! !

!ProjectiveSpace methodsFor: 'testing' stamp: 'len 2/22/2017 07:55:14'!
isPlane
	^ self rank = 3! !

!ProjectiveSpace methodsFor: 'testing' stamp: 'len 1/13/2017 17:07:33'!
satisfies: aTuple
	^ true! !

!ProjectiveSpace methodsFor: 'private' stamp: 'len 3/6/2021 14:05:36'!
newPatch: i
	^ (self coordinateRing slice: (self coordinateRing indeterminates select: [:each| each ~= i])) spec! !

!ProjectiveSpace methodsFor: 'private' stamp: 'len 1/13/2017 17:23:38'!
saturated
	^ self! !

!ProjectiveSpace class methodsFor: 'instance creation' stamp: 'len 6/27/2023 23:50:31'!
coordinateRing: aPolynomialRing
	^ (aPolynomialRing rank = 2 ifTrue: [ProjectiveLine] ifFalse: [aPolynomialRing rank = 3 ifTrue: [ProjectivePlane] ifFalse: [self]]) new coordinateRing: aPolynomialRing! !

!ProjectiveSpace class methodsFor: 'instance creation' stamp: 'len 6/28/2023 17:03:10'!
new: rank over: aRing
	^ (rank isInteger
		ifTrue: [aRing polynomialsIn: rank+1]
		ifFalse: [aRing polynomialsIn: rank]) proj! !

!ProjectiveLine methodsFor: 'accessing' stamp: 'len 6/27/2023 15:09:30'!
infinity
	^ self pointAt: self scalars !!!! #(1 0)! !

!ProjectiveLine methodsFor: 'accessing' stamp: 'len 6/27/2023 15:09:45'!
one
	^ self pointAt: self scalars !!!! #(1 1)! !

!ProjectiveLine methodsFor: 'accessing' stamp: 'len 6/27/2023 15:10:05'!
zero
	^ self pointAt: self scalars !!!! #(0 1)! !

!ProjectiveLine methodsFor: 'elements' stamp: 'len 4/9/2020 18:14:26'!
adapt: anElement
	(self scalars includes: anElement) ifTrue: [^ self embed: anElement].
	^ super adapt: anElement! !

!ProjectiveLine methodsFor: 'morphisms' stamp: 'len 6/27/2023 15:10:16'!
embed: anElement
	^ self pointAt: self scalars !!!! {anElement. 1}! !

!ProjectiveLine methodsFor: 'morphisms' stamp: 'len 6/1/2024 07:07:11'!
from: aDomain
	self flag: #fix. "this is wrong, wrong category!!"
	aDomain = self scalars ifTrue: [^ self addMap: (self scalars to: self map: [:each| self embed: each])].
	aDomain ⇢ self scalars ifNotNil: [:aMorphism| ^ self scalars → self · aMorphism].
	^ super from: aDomain! !

!ProjectiveLine methodsFor: 'points' stamp: 'len 6/27/2023 15:13:14'!
pointAt: aTuple
	self assert: aTuple size = 2.
	^ ProjectiveLinePoint on: self coordinates: aTuple! !

!ProjectiveLine methodsFor: 'points-private' stamp: 'len 4/1/2024 14:43:36'!
pointsOverRing: aRing do: aBlock
	| visited |
	visited := Set new.
	aRing do: [:a|
		aRing do: [:b|
			| point |
			(aRing elements anySatisfy: [:c| aRing elements anySatisfy: [:d| (a*d - (c*b)) isUnit]])
				ifTrue: [visited add: (point := self pointAt: aRing !!!! {a. b}) ifAbsent: [aBlock value: point]]]]! !

!ProjectiveLine class methodsFor: 'instance creation' stamp: 'len 6/28/2023 17:03:33'!
over: aRing
	^ self new: #(x y) over: aRing! !

!ProjectivePlane methodsFor: 'accessing' stamp: 'len 7/15/2021 16:05:18'!
order
	self scalars isFiniteField ifTrue: [^ self scalars degree].
	^ self notYetImplemented! !

!ProjectivePlane class methodsFor: 'instance creation' stamp: 'len 6/28/2023 17:03:48'!
over: aRing
	^ self new: #(x y z) over: aRing! !

!CellComplex methodsFor: 'accessing' stamp: 'len 2/15/2017 07:32:58'!
cells: n
	"Answer the set of n-cells of the receiver."
	^ Set accumulate: [:aBlock| self cells: n do: aBlock]! !

!CellComplex methodsFor: 'accessing' stamp: 'len 2/17/2017 16:51:20'!
vertices
	| answer |
	self propertyAt: #vertices ifPresent: [:aSet| ^ aSet].
	answer _ Set new.
	self facets do: [:each| answer addAll: each vertices].
	^ self propertyAt: #vertices put: answer! !

!CellComplex methodsFor: 'enumerating' stamp: 'len 2/15/2017 07:51:33'!
cells: n do: aBlock
	"Iterate over the n-cells of the receiver, possibly with repretitions.
	Subclasses should reimplement."
	^ self do: [:each| each dimension = n ifTrue: [aBlock value: each]]! !

!CellComplex methodsFor: 'homology' stamp: 'len 9/16/2022 08:00:33'!
boundaryMap: k over: aRing
	"The k-th boundary map or differential d(k) goes from C(k) to C(k-1).
	Its image is the group of (k-1)-boundaries B(k-1), a subgroup of C(k-1).
	Its kernel is the group of k-cycles Z(k), a subgroup of C(k)."
	^ (self chains: k over: aRing) to: (self chains: k-1 over: aRing) map: [:x| x boundary]! !

!CellComplex methodsFor: 'homology' stamp: 'len 2/25/2017 07:13:30'!
chainComplexOver: aRing
	^ ChainComplex differentials: ((self dimension+1 to: 0 by: -1) collect: [:i| self boundaryMap: i over: aRing])! !

!CellComplex methodsFor: 'homology' stamp: 'len 4/21/2020 10:57:15'!
chains: k over: aRing
	"Answer the free module of k-chains over the given ring."
	k < 0 ifTrue: [^ aRing ^ #()].
	^ aRing ^ (self cells: k)! !

!CellComplex methodsFor: 'invariants' stamp: 'len 2/19/2017 18:25:22'!
dimension
	self isVoid ifTrue: [^ Infinity negative].
	^ self max: [:each| each dimension]! !

!CellComplex methodsFor: 'invariants' stamp: 'len 2/15/2017 07:37:12'!
euler
	"Answer the Euler characteristic of the receiver."
	^ (0 to: self dimension) sum: [:p| -1^p * (self cells: p) size]! !

!CellComplex methodsFor: 'invariants' stamp: 'len 5/23/2020 08:59:21'!
fPolynomial
	"Answer the f-polynomial of this cell complex. This is the univariate polynomial with coefficients given by the f-vector (in decreasing order of exponents)."
	^ ℤ polynomials coefficients: self fVector reversed! !

!CellComplex methodsFor: 'invariants' stamp: 'len 4/26/2022 07:43:30'!
fVector
	"Answer the f-vector of this cell complex. This is a tuple of integers that count the number of cells of each dimension."
	^ (-1 to: self dimension) collect: [:i| (self cells: i) size]! !

!CellComplex methodsFor: 'invariants' stamp: 'len 4/26/2022 07:42:30'!
gVector
	"Answer the g-vector of this cell complex."
	| h |
	h _ self hVector.
	^ (1 to: h size // 2 + 1) collect: [:i| i == 1 ifTrue: [1] ifFalse: [(h at: i) - (h at: i-1)]]! !

!CellComplex methodsFor: 'invariants' stamp: 'len 8/15/2022 06:48:19'!
hPolynomial
	"Answer the h-polynomial of this cell complex. This is the result of composing the f-polynomial with 'x - 1'."
	| f x |
	f _ self fPolynomial.
	x _ f parent x.
	^ f  ∘ (x - 1)! !

!CellComplex methodsFor: 'invariants' stamp: 'len 11/24/2022 19:48:42'!
hVector
	"Answer the h-vector of this cell complex. This is the tuple of coefficients of the h-polynomial (in decreasing order of exponents)."
	^ self hPolynomial coefficients reversed asArray! !

!CellComplex methodsFor: 'printing' stamp: 'len 6/3/2023 12:18:44'!
printOn: aStream
	aStream withAngleBrackets: [:aStream2|
		self do: [:each| aStream2 print: each] separatedBy: [aStream2 nextPut: $,]]! !

!CellComplex methodsFor: 'testing' stamp: 'len 2/25/2017 15:10:35'!
isTrivial
	"Answer true if this is the trivial complex, with only the empty cell."
	^ self size = 1! !

!CellComplex methodsFor: 'testing' stamp: 'len 2/25/2017 15:10:11'!
isVoid
	"Answer true if this is the void complex, that has no cells."
	^ self size = 0! !

!SimplicialComplex methodsFor: 'accessing' stamp: 'len 4/21/2016 04:37'!
edges
	^ self faces: 1! !

!SimplicialComplex methodsFor: 'accessing' stamp: 'len 11/30/2016 14:45:09'!
faces: m
	^ Set accumulate: [:aBlock| self faces: m do: aBlock]! !

!SimplicialComplex methodsFor: 'accessing' stamp: 'len 2/15/2017 08:29:11'!
facets
	"Answer the maximal faces of the receiver."
	^ self propertyAt: #facets! !

!SimplicialComplex methodsFor: 'accessing' stamp: 'len 12/3/2023 13:56:04'!
labelling
	"Answer a dictionary that associates a positive integer number to each vertex.
	For a simplicial complex with n vertices, the labels are 1,2,...,n."
	| V labelling |
	self propertyAt: #labelling ifPresent: [:aDictionary| ^ aDictionary].
	V := self vertices.
	(V allSatisfy: [:each| each isInteger])
		ifTrue: [V := V sorted]
		ifFalse: [V := V sorted: [:a :b| a printString <= b printString]].
	labelling := Dictionary new.
	1 to: V size do: [:each| labelling at: (V at: each) put: each].
	^ self propertyAt: #labelling put: labelling! !

!SimplicialComplex methodsFor: 'accessing' stamp: 'len 12/10/2023 10:35:50'!
nonfaces
	"Answer the set of minimal nonfaces, i.e. simpleces on the vertex set of the receiver which are not faces of the receiver."
	| answer V F |
	self isVoid ifTrue: [Set with: (Simplex vertices: #())].
	answer := Set new.
	V := self vertices asArray.
"	1 to: self vertices size do: [:k|"
	1 to: self dimension + 2 do: [:k|
		V combinations: k atATimeDo: [:combination|
			F := Simplex vertices: combination copy.
			((self contains: F) not and: [answer noneSatisfy: [:none| F ⊇ none]])
				ifTrue: [answer add: F]]].
	^ answer! !

!SimplicialComplex methodsFor: 'accessing' stamp: 'len 4/21/2016 04:38'!
ridges
	^ self faces: self dimension - 2! !

!SimplicialComplex methodsFor: 'accessing' stamp: 'len 2/20/2017 18:52:16'!
support
	"Answer the collection of vertices that belong to any face in the receiver."
	^ self vertices select: [:each| self facets anySatisfy: [:any| any includes: each]]! !

!SimplicialComplex methodsFor: 'enumerating' stamp: 'len 2/15/2017 11:20:19'!
cells: n do: aBlock
	"Iterate over the n-cells of the receiver, possibly with repetitions."
	^ self faces: n do: aBlock! !

!SimplicialComplex methodsFor: 'enumerating' stamp: 'len 2/19/2017 08:22:20'!
collect: aBlock
	^ self species faces: (self elements collect: aBlock)! !

!SimplicialComplex methodsFor: 'enumerating' stamp: 'len 2/14/2017 20:00:17'!
do: aBlock
	-1 to: self dimension do: [:each| (self faces: each) do: aBlock]! !

!SimplicialComplex methodsFor: 'enumerating' stamp: 'len 2/15/2017 07:53:57'!
faces: n do: aBlock
	"Iterate over the n-cells of the receiver, possibly with repetitions."
	self facets do: [:each| each faces: n do: [:face| aBlock value: face]]! !

!SimplicialComplex methodsFor: 'enumerating' stamp: 'len 2/19/2017 10:19:29'!
select: aBlock
	^ self species on: self vertices faces: (self elements select: aBlock)! !

!SimplicialComplex methodsFor: 'homology' stamp: 'len 11/24/2022 19:03:04'!
chainComplexOver: aRing
	"The k-th boundary map or differential d(k) goes from C(k) to C(k-1).
	Its image is the group of (k-1)-boundaries B(k-1), a subgroup of C(k-1).
	Its kernel is the group of k-cycles Z(k), a subgroup of C(k)."

	"The boundary of a chain is the linear combination of the boundary of the simplices in the chain. The boundary of a k-chain is a (k-1)-chain."

	| differentials domain codomain |
	domain _ self chains: -1 over: aRing.
	differentials _ (0 to: self dimension+1) collect: [:k|
		codomain _ domain.
		domain _ self chains: k over: aRing.
		k = 0
			ifTrue: [(domain ⇒ codomain) zero]
			ifFalse:
				[domain to: codomain map: [:x|
					| answer |
					answer _ codomain zero.
					x with: domain names do: [:value :key|
						| V |
						V _ key vertices asArray.
						1 to: V size do: [:i| | F f |
							"F is the facet opposite the i-th vertex:"
							F _ Simplex vertices: (V copyWithoutIndex: i).
							f _ (codomain generatorNamed: F) * value.
							i odd ifTrue: [answer _ answer + f] ifFalse: [answer _ answer - f]]].
					answer]]].
	^ ChainComplex differentials: differentials reversed! !

!SimplicialComplex methodsFor: 'invariants' stamp: 'len 2/19/2017 18:24:25'!
dimension
	self isVoid ifTrue: [^ Infinity negative].
	^ self facets max: [:each| each dimension]! !

!SimplicialComplex methodsFor: 'morphisms' stamp: 'len 6/14/2023 13:17:34'!
apply: aMorphism
	^ self species faces: (self facets collect: aMorphism)! !

!SimplicialComplex methodsFor: 'morphisms' stamp: 'len 4/19/2024 07:06:12'!
to: aSimplicialComplex images: anArray
	self notYetImplemented! !

!SimplicialComplex methodsFor: 'morphisms' stamp: 'len 10/13/2023 08:48:32'!
to: aSimplicialComplex map: aBlock
	self assert: (aSimplicialComplex isKindOf: SimplicialComplex).
	^ SimplicialMap from: self to: aSimplicialComplex map: aBlock! !

!SimplicialComplex methodsFor: 'morphisms' stamp: 'len 4/5/2024 19:03:19'!
to: aSimplicialComplex vertexMap: aDictionary
	self assert: (aSimplicialComplex isKindOf: SimplicialComplex).
	^ SimplicialMap from: self to: aSimplicialComplex vertexMap: aDictionary! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 2/19/2017 08:20:23'!
* aSimplicialComplex
	"Answer the join of the receiver with the argument."
	| join |
	join _ Set new.
	self facets do: [:each|
		aSimplicialComplex facets do: [:other| join add: each * other]].
	^ self species facets: join! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 7/6/2020 14:27:27'!
+ aSimplicialComplex
	^ self species faces: self facets, aSimplicialComplex facets! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 12/10/2023 10:36:24'!
- aFace
	"Answer the deletion of a aFace, i.e. the simplicial complex obtained by removing aFace."
	^ self select: [:each| (each ⊆ aFace) not]! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 2/15/2017 11:15:36'!
/ aFace
	"Answer the link of aFace. This is the complex of all faces of simplices in the star that do not intersect aFace."
	^ self notYetImplemented! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 12/29/2017 09:46:31'!
× aSimplicialComplex
	"Answer the direct product of the receiver and the argument."
	| product |
	product _ Set new.
	self facets do: [:each|
		aSimplicialComplex facets do: [:other|
			self pathsFrom: each vertices to: other vertices do: [:path|
				product add: (Simplex vertices: path)]]].
	^ self species faces: product! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 2/19/2017 10:23:45'!
complement
	| V |
	V _ self vertices.
	^ self species on: V facets: (self facets collect: [:each| each complementIn: V])! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 2/15/2017 11:24:20'!
cone
	"Answer the join of the receiver with a new one-vertex simplicial complex."
	^ self * (self species facets: #((0)))! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 2/29/2016 08:25'!
coskeleton: n
	"Answer the n-coskeleton of the receiver."
	^ self notYetImplemented! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 2/19/2017 10:24:04'!
dual
	"Answer the Alexander dual of the receiver.
	This is the simplicial complex made of the complement of all faces *not* in the receiver, and it is generated by the complements of the minimal nonfaces."
	| V |
	V _ self vertices.
	^ self species on: V facets: (self nonfaces collect: [:each| each complementIn: V])! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 5/23/2020 09:11:37'!
facetIdeal
	"Answer the facet ideal of this simplicial complex.
	This is the ideal generated by those squarefree monomials associated to the maximal faces (facets) of the simplicial complex."
	^ self facetIdealIn: (ℚ polynomialsIn: self vertices size)! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 2/19/2017 10:13:47'!
facetIdealIn: aRing
	"Answer the facet ideal of this simplicial complex in the given polynomial ring.
	This is the ideal generated by those squarefree monomials associated to the maximal faces (facets) of the simplicial complex."
	| labelling |
	labelling _ self labelling.
	^ aRing * (self facets collect: [:each|
		each vertices inject: aRing one into: [:g :v| g * (aRing x: (labelling at: v))]])! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 1/14/2022 12:45:57'!
openStarOf: aCollection
	"Answer the open star in the receiver of the simplices in aCollection.
	This is just a set of simplices, and not necessarily forms a complex."
	| answer |
	answer _ Set new.
	aCollection do: [:each|
		self do: [:other| (each intersects: other) ifTrue: [answer add: other]]].
	^ answer! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 2/15/2017 11:23:53'!
skeleton: n
	"Answer the n-skeleton of the receiver."
	^ self collect: [:each| each dimension <= n]! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 5/23/2020 09:11:37'!
stanleyReisnerIdeal
	"Answer the Stanley-Reisner ideal of this simplicial complex.
	This is the ideal generated by those squarefree monomials associated to nonfaces of the simplicial complex."
	^ self stanleyReisnerIdealIn: (ℚ polynomialsIn: self vertices size)! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 2/19/2017 10:14:20'!
stanleyReisnerIdealIn: aRing
	"Answer the Stanley-Reisner ideal of this simplicial complex in the given polynomial ring.
	This is the ideal generated by those squarefree monomials associated to nonfaces of the simplicial complex."
	| labelling |
	labelling _ self labelling.
	^ aRing * (self nonfaces collect: [:each|
		each vertices inject: aRing one into: [:g :v| g * (aRing x: (labelling at: v))]])! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 5/23/2020 09:11:37'!
stanleyReisnerRing
	^ self stanleyReisnerRingOver: ℚ! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 12/25/2021 12:44:07'!
stanleyReisnerRingOver: aRing
	| R |
	R _  aRing polynomialsIn: self vertices size.
	^ R / (self stanleyReisnerIdealIn: R)! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 2/19/2017 10:19:06'!
starOf: aCollection
	"Answer the (closed) star in the receiver of the simplices in aCollection.
	This is the closure of the open star."
	^ self species on: self vertices faces: (self openStarOf: aCollection)! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 2/21/2017 11:57:55'!
suspension
	^ self * (self class sphere: 0)! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 5/1/2024 12:26:57'!
∨ aSimplicialComplex
	"Answer the wedge sum (one-point union) of the receiver with the argument."
	| v0 w0 facets |
	v0 := self support anyOne.
	w0 := aSimplicialComplex support any.
	facets := Set new.
	self facets do: [:each| facets add: (each collect: [:v| v = v0 ifTrue: [{0. 0}] ifFalse: [{1. v}]])].
	aSimplicialComplex facets do: [:each| facets add: (each collect: [:w| w = w0 ifTrue: [{0. 0}] ifFalse: [{2. w}]])].
	^ self species "on: vertices" facets: facets! !

!SimplicialComplex methodsFor: 'printing' stamp: 'len 5/29/2023 13:58:51'!
printOn: aStream
	aStream withAngleBrackets: [:aStream2|
		self facets do: [:each| aStream2 print: each] separatedBy: [aStream2 nextPut: $,]]! !

!SimplicialComplex methodsFor: 'testing' stamp: 'len 12/10/2023 10:35:50'!
contains: aSimplex
	^ self facets anySatisfy: [:one| one ⊇ aSimplex]! !

!SimplicialComplex methodsFor: 'testing' stamp: 'len 2/15/2017 08:23:17'!
includes: aSimplex
	^ (aSimplex isKindOf: Simplex) and: [self contains: aSimplex]! !

!SimplicialComplex methodsFor: 'testing' stamp: 'len 6/13/2016 16:29'!
isConnected
	^ (self skeleton: 1) asGraph isConnected! !

!SimplicialComplex methodsFor: 'testing' stamp: 'len 2/19/2017 18:22:52'!
isPure
	| d |
	d _ self dimension.
	^ self facets allSatisfy: [:each| each dimension = d]! !

!SimplicialComplex methodsFor: 'testing' stamp: 'len 2/25/2017 15:13:47'!
isTrivial
	"Answer true if this is the trivial complex, with only one face (the empty simplex)."
	^ self facets size = 1 and: [self facets allSatisfy: [:each| each isTrivial]]! !

!SimplicialComplex methodsFor: 'testing' stamp: 'len 2/19/2017 18:23:52'!
isVoid
	"Answer true if this is the void complex, that has no faces."
	^ self facets isEmpty! !

!SimplicialComplex methodsFor: 'private' stamp: 'len 2/15/2017 16:10:03'!
facets: aCollection
	self propertyAt: #facets put: aCollection! !

!SimplicialComplex methodsFor: 'private' stamp: 'len 4/19/2020 01:28:53'!
pathsFrom: A to: B do: aBlock
	| x |
	A isEmpty ifTrue: [^ aBlock value: A].
	B isEmpty ifTrue: [^ aBlock value: B].
	A size = 1 ifTrue:
		[| v |
		v _ A at: 1.
		^ aBlock value: (B collect: [:w| {v. w}])].
	B size = 1 ifTrue:
		[| w |
		w _ B at: 1.
		^ aBlock value: (A collect: [:v| {v. w}])].
	x _ {A last. B last}.
	self pathsFrom: A allButLast to: B do: [:each| aBlock value: (each copyWith: x)].
	self pathsFrom: A to: B allButLast do: [:each| aBlock value: (each copyWith: x)]! !

!SimplicialComplex methodsFor: 'private' stamp: 'len 2/15/2017 11:20:53'!
species
	^ SimplicialComplex! !

!SimplicialComplex methodsFor: 'private' stamp: 'len 2/24/2017 11:38:54'!
vertices: aCollection
	self propertyAt: #vertices put: aCollection asSet! !

!SimplicialComplex class methodsFor: 'examples' stamp: 'len 2/14/2017 20:39:44'!
kleinBottle
	"A minimal triangulation of the Klein bottle."
	^ self facets: #((2 3 7) (1 2 3) (1 3 5) (1 5 7) (1 4 7) (2 4 6) (1 2 6) (1 6 0) (1 4 0) (2 4 0) (3 4 7) (3 4 6) (3 5 6) (5 6 0) (2 5 0) (2 5 7))! !

!SimplicialComplex class methodsFor: 'examples' stamp: 'len 2/14/2017 20:39:57'!
realProjectivePlane
	"A minimal triangulation of the real projective plane."
	^ self facets: #((0 1 2) (0 2 3) (0 1 5) (0 4 5) (0 3 4) (1 2 4) (1 3 4) (1 3 5) (2 3 5) (2 4 5))! !

!SimplicialComplex class methodsFor: 'examples' stamp: 'len 2/20/2017 08:37:36'!
sphere: n
	"A minimal triangulation of the n-sphere."
	^ self facets: ((Simplex new: n+1) faces: n)! !

!SimplicialComplex class methodsFor: 'examples' stamp: 'len 2/14/2017 20:40:24'!
torus
	"A minimal triangulation of the torus."
	^ self facets: #((0 1 2) (1 2 4) (1 3 4) (1 3 6) (0 1 5) (1 5 6) (2 3 5) (2 4 5) (2 3 6) (0 2 6) (0 3 4) (0 3 5) (4 5 6) (0 4 6))! !

!SimplicialComplex class methodsFor: 'instance creation' stamp: 'len 12/10/2023 10:36:24'!
faces: aCollection
	"Answer a new simplicial complex with the given collection of simplices as faces.
	The faces in aCollection are not assumed to be maximal, so we compute a subset of maximal faces (facets)."
	| faces maximalFaces |
	faces := Set new: aCollection size.
	aCollection do: [:each|
		(each isKindOf: Simplex)
			ifTrue: [faces add: each]
			ifFalse: [faces add: (each as: Simplex)]].
	faces := faces asSortedCollection: [:a :b| a dimension <= b dimension].
	maximalFaces := Set new.
	1 to: faces size do: [:i| | face |
		face := faces at: i.
		((i+1 to: faces size) anySatisfy: [:j| face ⊆ (faces at: j)])
			ifFalse: [maximalFaces add: face]].
	^ self facets: maximalFaces! !

!SimplicialComplex class methodsFor: 'instance creation' stamp: 'len 2/15/2017 16:10:24'!
facets: aCollection
	"Answer a new simplicial complex with the given collection of simplices as facets.
	The faces in aCollection are assumed to be maximal."
	| facets |
	facets _ Set new: aCollection size.
	aCollection do: [:each|
		(each isKindOf: Simplex)
			ifTrue: [facets add: each]
			ifFalse: [facets add: (each as: Simplex)]].
	^ self new facets: facets! !

!SimplicialComplex class methodsFor: 'instance creation' stamp: 'len 2/24/2017 11:47:54'!
on: aVertexSet faces: aCollection
	"Answer a new simplicial complex with the given collection of simplices as faces.
	The faces in aCollection are not assumed to be maximal, so we compute a subset of maximal faces (facets)."
	^ (self faces: aCollection) vertices: aVertexSet! !

!SimplicialComplex class methodsFor: 'instance creation' stamp: 'len 2/24/2017 11:48:00'!
on: aVertexSet facets: aCollection
	"Answer a new simplicial complex with the given collection of simplices as facets.
	The faces in aCollection are assumed to be maximal."
	^ (self facets: aCollection) vertices: aVertexSet! !

!Vertex methodsFor: 'comparing' stamp: 'len 5/27/2024 07:00:11'!
= anObject
	^ anObject = value! !

!Vertex methodsFor: 'comparing' stamp: 'len 5/27/2024 06:51:40'!
hash
	^ value hash! !

!Vertex methodsFor: 'morphisms' stamp: 'len 6/14/2024 15:06:06'!
category
	^ category! !

!Vertex methodsFor: 'morphisms' stamp: 'len 5/24/2024 08:37:31'!
id
	^ self propertyAt: #id ifAbsentPut: [self to: self steps: #()]! !

!Vertex methodsFor: 'morphisms' stamp: 'len 6/7/2024 09:08:05'!
to: aCodomain steps: anArray
	^ Path from: self to: aCodomain steps: anArray! !

!Vertex methodsFor: 'morphisms' stamp: 'len 6/7/2024 09:08:21'!
⇢ aCodomain
	self = aCodomain ifTrue: [^ self id].
	((aCodomain isKindOf: Vertex) and: [(neighbors occurrencesOf: aCodomain value) = 1])
		ifTrue: [^ self to: aCodomain steps: {neighbors indexOf: aCodomain value}].
	^ nil! !

!Vertex methodsFor: 'printing' stamp: 'len 5/27/2024 06:52:34'!
printOn: aStream
	value isSymbol ifTrue: [aStream nextPutAll: value] ifFalse: [aStream print: value]! !

!Vertex methodsFor: 'private' stamp: 'len 5/27/2024 06:49:47'!
neighbors
	^ neighbors! !

!Vertex methodsFor: 'private' stamp: 'len 5/27/2024 06:50:15'!
value
	^ value! !

!Vertex methodsFor: 'private' stamp: 'len 6/14/2024 15:05:27'!
value: anObject neighbors: anArray category: aFreeCategory
	value := anObject.
	neighbors := anArray.
	category := aFreeCategory! !

!Vertex class methodsFor: 'instance creation' stamp: 'len 6/14/2024 15:05:52'!
value: anObject neighbors: anArray category: aFreeCategory
	^ self new value: anObject neighbors: anArray category: aFreeCategory! !

!CommaObject methodsFor: 'accessing' stamp: 'len 4/8/2024 13:21:46'!
arrow
	^ self propertyAt: #arrow! !

!CommaObject methodsFor: 'accessing' stamp: 'len 6/14/2024 15:01:44'!
category
	^ self propertyAt: #category! !

!CommaObject methodsFor: 'accessing' stamp: 'len 4/8/2024 13:21:34'!
source
	^ self propertyAt: #source! !

!CommaObject methodsFor: 'accessing' stamp: 'len 4/8/2024 13:21:39'!
target
	^ self propertyAt: #target! !

!CommaObject methodsFor: 'comparing' stamp: 'len 4/8/2024 13:22:21'!
= anObject
	^ self class = anObject class and: [self source = anObject source and: [self target = anObject target and: [self arrow = anObject arrow]]]! !

!CommaObject methodsFor: 'comparing' stamp: 'len 4/8/2024 13:23:01'!
hash
	^ (self source hash hashMultiply + self target hash) hashMultiply + self arrow hash! !

!CommaObject methodsFor: 'morphisms' stamp: 'len 4/30/2024 06:41:10'!
id
	^ self propertyAt: #id ifAbsentPut: [self to: self source: self source id target: self target id]! !

!CommaObject methodsFor: 'morphisms' stamp: 'len 4/26/2024 16:28:50'!
to: aCodomain source: aMorphism target: anotherMorphism
	^ CommaMorphism from: self to: aCodomain source: aMorphism target: anotherMorphism! !

!CommaObject methodsFor: 'printing' stamp: 'len 8/30/2024 19:55:34'!
printOn: aStream
	aStream print: {self source. self target. self arrow}! !

!CommaObject class methodsFor: 'instance creation' stamp: 'len 6/14/2024 15:01:15'!
source: anObject target: anotherObject arrow: aMorphism category: aCommaCategory
	^ self new
		propertyAt: #source put: anObject;
		propertyAt: #target put: anotherObject;
		propertyAt: #arrow put: aMorphism;
		propertyAt: #category put: aCommaCategory;
		yourself! !

!ArrowObject methodsFor: 'accessing' stamp: 'len 6/23/2024 09:09:18'!
category
	^ self arrow category arrows! !

!ArrowObject methodsFor: 'accessing' stamp: 'len 6/23/2024 09:08:19'!
source
	^ self arrow domain! !

!ArrowObject methodsFor: 'accessing' stamp: 'len 6/23/2024 09:08:24'!
target
	^ self arrow codomain! !

!ArrowObject methodsFor: 'operations' stamp: 'len 7/2/2024 05:49:26'!
dual
	^ self class arrow: self arrow dual! !

!ArrowObject methodsFor: 'operations' stamp: 'len 6/23/2024 09:09:38'!
⊕ anObject
	^ self class arrow: self arrow ⊕ anObject arrow! !

!ArrowObject methodsFor: 'operations' stamp: 'len 7/2/2024 05:49:14'!
⊗ anObject
	^ self class arrow: self arrow ⊗ anObject arrow! !

!ArrowObject methodsFor: 'morphisms' stamp: 'len 7/2/2024 05:58:36'!
braidingWith: anObject
	^ self ⊗ anObject to: anObject ⊗ self source: (self source braidingWith: anObject source) target: (self target braidingWith: anObject target) ! !

!ArrowObject methodsFor: 'morphisms' stamp: 'len 7/2/2024 05:52:06'!
coevaluation
	^ self notYetImplemented! !

!ArrowObject methodsFor: 'morphisms' stamp: 'len 7/2/2024 05:52:04'!
evaluation
	^ self notYetImplemented! !

!ArrowObject methodsFor: 'printing' stamp: 'len 8/30/2024 19:55:26'!
printOn: aStream
	aStream print: self arrow! !

!ArrowObject class methodsFor: 'instance creation' stamp: 'len 6/23/2024 09:10:20'!
arrow: aMorphism
	^ self new
		propertyAt: #arrow put: aMorphism;
		yourself! !

!SliceObject methodsFor: 'accessing' stamp: 'len 7/5/2024 17:53:57'!
category
	^ self target slice! !

!SliceObject methodsFor: 'accessing' stamp: 'len 7/5/2024 17:32:42'!
source
	^ self arrow domain! !

!SliceObject methodsFor: 'accessing' stamp: 'len 7/5/2024 17:33:03'!
target
	^ self arrow codomain! !

!SliceObject methodsFor: 'operations' stamp: 'len 7/5/2024 17:20:09'!
× anObject
	"The product in a slice category is just the pullback in the original category:"
	self arrow ∧ anObject arrow ⇉ {self source. anObject source} into: [:π₁ :π₂|
		| answer |
		answer := self category objectAt: self arrow · π₁.
"		answer addProjections: {answer to: self source: target: .... answer to: anObject source: ... target: ..}."
		^ answer]! !

!SliceObject methodsFor: 'printing' stamp: 'len 8/30/2024 19:55:14'!
printOn: aStream
	aStream print: self arrow! !

!SliceObject class methodsFor: 'instance creation' stamp: 'len 7/5/2024 17:30:49'!
arrow: aMorphism
	^ self new
		propertyAt: #arrow put: aMorphism;
		yourself! !

!BimonoidObject methodsFor: 'accessing' stamp: 'len 8/30/2024 08:26:43'!
carrier
	^ unit codomain! !

!BimonoidObject methodsFor: 'accessing' stamp: 'len 8/30/2024 08:26:57'!
category
	^ self carrier category bimonoids! !

!BimonoidObject methodsFor: 'accessing' stamp: 'len 8/30/2024 08:28:49'!
comultiplication
	^ comultiplication! !

!BimonoidObject methodsFor: 'accessing' stamp: 'len 8/30/2024 08:28:58'!
counit
	^ counit! !

!BimonoidObject methodsFor: 'accessing' stamp: 'len 8/30/2024 08:29:03'!
multiplication
	^ multiplication! !

!BimonoidObject methodsFor: 'accessing' stamp: 'len 8/30/2024 08:29:07'!
unit
	^ unit! !

!BimonoidObject methodsFor: 'morphisms' stamp: 'len 8/30/2024 08:29:23'!
associatorWith: anObject and: anotherObject
	self assert: self carrier category isSymmetricMonoidal. "?"
	^ self ⊗ anObject ⊗ anotherObject to: (self ⊗ anObject ⊗ anotherObject) carrier: (self carrier associatorWith: anObject carrier and: anotherObject carrier)! !

!BimonoidObject methodsFor: 'morphisms' stamp: 'len 8/30/2024 08:29:27'!
braidingWith: anObject
	self assert: self carrier category isSymmetricMonoidal.
	^ self ⊗ anObject to: anObject ⊗ self carrier: (self carrier braidingWith: anObject carrier)! !

!BimonoidObject methodsFor: 'morphisms' stamp: 'len 8/30/2024 08:29:33'!
id
	^ self propertyAt: #id ifAbsentPut: [self to: self carrier: self carrier id]! !

!BimonoidObject methodsFor: 'morphisms' stamp: 'len 8/30/2024 08:32:58'!
leftUnitor
	^ self category unitObject ⊗ self to: self carrier: self carrier leftUnitor! !

!BimonoidObject methodsFor: 'morphisms' stamp: 'len 8/30/2024 08:33:06'!
rightUnitor
	^ self ⊗ self category unitObject to: self carrier: self carrier rightUnitor! !

!BimonoidObject methodsFor: 'morphisms' stamp: 'len 8/31/2024 18:45:12'!
to: aCodomain carrier: aMorphism
	^ BimonoidMorphism from: self to: aCodomain carrier: aMorphism! !

!BimonoidObject methodsFor: 'operations' stamp: 'len 9/5/2024 07:53:18'!
coopposite
	"Answer the comultiplicative opposite. This is the bimonoid with comultiplication order reversed."
	^ self class multiplication: multiplication unit: unit comultiplication: (self carrier braidingWith: self carrier) inverse ∘ comultiplication counit: counit! !

!BimonoidObject methodsFor: 'operations' stamp: 'len 9/5/2024 07:48:51'!
opposite
	"Answer the multiplicative opposite. This is the bimonoid with multiplication order reversed."
	^ self class multiplication: multiplication ∘ (self carrier braidingWith: self carrier) unit: unit comultiplication: comultiplication counit: counit! !

!BimonoidObject methodsFor: 'operations' stamp: 'len 8/31/2024 18:24:51'!
reverse
	^ self propertyAt: #reverse ifAbsentPut: [self class multiplication: comultiplication reverse unit: counit reverse comultiplication: multiplication reverse counit: unit reverse]! !

!BimonoidObject methodsFor: 'operations' stamp: 'len 8/31/2024 18:14:58'!
⊗ aBimonoid
	| τ |
	τ := self carrier id ⊗ (self carrier braidingWith: aBimonoid carrier) ⊗ aBimonoid carrier id.
	^ self class
		multiplication: multiplication ⊗ aBimonoid multiplication ∘ τ
		unit: unit ⊗ aBimonoid unit
		comultiplication: τ inverse ∘ (comultiplication ⊗ aBimonoid comultiplication)
		counit: counit ⊗ aBimonoid counit! !

!BimonoidObject methodsFor: 'printing' stamp: 'len 8/30/2024 08:33:30'!
printOn: aStream
	aStream print: self carrier! !

!BimonoidObject methodsFor: 'testing' stamp: 'len 8/31/2024 19:06:40'!
isBimonoid
	^ true! !

!BimonoidObject methodsFor: 'testing' stamp: 'len 9/1/2024 20:21:38'!
isCocommutative
	^ self propertyAt: #isCocommutative ifAbsentPut: [comultiplication = self coopposite comultiplication]! !

!BimonoidObject methodsFor: 'testing' stamp: 'len 9/1/2024 20:20:39'!
isCommutative
	^ self propertyAt: #isCommutative ifAbsentPut: [multiplication = self opposite multiplication]! !

!BimonoidObject methodsFor: 'testing' stamp: 'len 8/30/2024 08:34:57'!
isComonoid
	^ true! !

!BimonoidObject methodsFor: 'testing' stamp: 'len 8/31/2024 19:04:43'!
isConnected
	^ (self unit ∘ self counit) isIdentity! !

!BimonoidObject methodsFor: 'testing' stamp: 'len 8/31/2024 19:05:29'!
isFrobenius
	"Answer true if the receiver is a bimonoid object that satisfies that Frobenius laws.
	A Frobenius monoid in a vector space is called a Frobenius algebra."
	| id μ δ δμ |
	id := self carrier id.
	μ := self multiplication.
	δ := self comultiplication.
	δμ := δ ∘ μ.
	^ id ⊗ μ ∘ (δ ⊗ id) = δμ and: [μ ⊗ id ∘ (id ⊗ δ) = δμ]! !

!BimonoidObject methodsFor: 'testing' stamp: 'len 8/30/2024 08:34:54'!
isMonoid
	^ true! !

!BimonoidObject methodsFor: 'testing' stamp: 'len 8/31/2024 19:05:50'!
isSpecial
	^ (self multiplication ∘ self comultiplication) isIdentity! !

!BimonoidObject methodsFor: 'private' stamp: 'len 8/30/2024 08:43:21'!
multiplication: μ unit: η comultiplication: Δ counit: ε
	self assert: μ codomain = η codomain.
	self assert: μ codomain = Δ domain.
	self assert: Δ domain = ε domain.
	multiplication := μ.
	unit := η.
	comultiplication := Δ.
	counit := ε! !

!BimonoidObject class methodsFor: 'instance creation' stamp: 'len 8/30/2024 08:40:38'!
multiplication: μ unit: η comultiplication: Δ counit: ε
	^ self new multiplication: μ unit: η comultiplication: Δ counit: ε! !

!GroupObject methodsFor: 'accessing' stamp: 'len 6/9/2024 08:32:12'!
carrier
	^ unit codomain! !

!GroupObject methodsFor: 'accessing' stamp: 'len 6/14/2024 15:02:05'!
category
	^ self carrier category groups! !

!GroupObject methodsFor: 'accessing' stamp: 'len 6/9/2024 15:21:49'!
inverse
	^ inverse! !

!GroupObject methodsFor: 'accessing' stamp: 'len 6/9/2024 08:32:28'!
multiplication
	^ multiplication! !

!GroupObject methodsFor: 'accessing' stamp: 'len 6/9/2024 08:32:33'!
unit
	^ unit! !

!GroupObject methodsFor: 'morphisms' stamp: 'len 6/9/2024 15:27:42'!
id
	^ self propertyAt: #id ifAbsentPut: [self to: self carrier: self carrier id]! !

!GroupObject methodsFor: 'morphisms' stamp: 'len 8/31/2024 18:28:25'!
to: aCodomain carrier: aMorphism
	^ GroupMorphism from: self to: aCodomain carrier: aMorphism! !

!GroupObject methodsFor: 'operations' stamp: 'len 6/10/2024 13:31:55'!
× aGroupObject
	self notYetImplemented! !

!GroupObject methodsFor: 'printing' stamp: 'len 6/9/2024 08:45:10'!
printOn: aStream
	aStream print: self carrier! !

!GroupObject methodsFor: 'testing' stamp: 'len 6/16/2024 08:00:30'!
isCommutative
	"By Eckmann-Hilton argument, Grp(Grp) = Ab."
	^ self carrier isGroup or: [super isCommutative]! !

!GroupObject methodsFor: 'testing' stamp: 'len 8/29/2024 15:33:01'!
isGroup
	^ true! !

!GroupObject methodsFor: 'private' stamp: 'len 6/9/2024 08:44:19'!
multiplication: μ unit: η inverse: ι
	self assert: multiplication isNil.
	multiplication := μ.
	unit := η.
	inverse := ι! !

!GroupObject class methodsFor: 'instance creation' stamp: 'len 6/9/2024 08:43:31'!
multiplication: μ unit: η inverse: ι
	^ self new multiplication: μ unit: η inverse: ι! !

!ModuleObject methodsFor: 'accessing' stamp: 'len 9/1/2024 21:57:57'!
action
	^ action! !

!ModuleObject methodsFor: 'accessing' stamp: 'len 8/30/2024 07:58:18'!
carrier
	^ action codomain! !

!ModuleObject methodsFor: 'accessing' stamp: 'len 8/30/2024 07:58:28'!
category
	^ scalars modules! !

!ModuleObject methodsFor: 'accessing' stamp: 'len 9/1/2024 21:57:46'!
scalars
	^ scalars! !

!ModuleObject methodsFor: 'morphisms' stamp: 'len 8/28/2024 10:56:16'!
id
	^ self propertyAt: #id ifAbsentPut: [self to: self carrier: self carrier id]! !

!ModuleObject methodsFor: 'morphisms' stamp: 'len 8/31/2024 18:45:19'!
to: aCodomain carrier: aMorphism
	^ ModuleMorphism from: self to: aCodomain carrier: aMorphism! !

!ModuleObject methodsFor: 'printing' stamp: 'len 6/9/2024 09:57:39'!
printOn: aStream
	aStream print: self carrier! !

!ModuleObject methodsFor: 'testing' stamp: 'len 8/31/2024 08:49:14'!
isModule
	^ true! !

!ModuleObject methodsFor: 'private' stamp: 'len 8/30/2024 09:34:14'!
scalars: aMonoid action: aMorphism
	self assert: scalars isNil.
	scalars := aMonoid.
	action := aMorphism! !

!ModuleObject class methodsFor: 'instance creation' stamp: 'len 8/30/2024 09:35:44'!
scalars: aMonoid action: aMorphism
	^ self new scalars: aMonoid action: aMorphism! !

!MonoidObject methodsFor: 'accessing' stamp: 'len 6/7/2024 13:38:36'!
carrier
	^ unit codomain! !

!MonoidObject methodsFor: 'accessing' stamp: 'len 6/14/2024 15:06:36'!
category
	^ self carrier category monoids! !

!MonoidObject methodsFor: 'accessing' stamp: 'len 6/5/2024 05:51:25'!
multiplication
	^ multiplication! !

!MonoidObject methodsFor: 'accessing' stamp: 'len 6/5/2024 05:51:30'!
unit
	^ unit! !

!MonoidObject methodsFor: 'morphisms' stamp: 'len 8/23/2024 08:38:27'!
associatorWith: anObject and: anotherObject
	self assert: self carrier category isSymmetricMonoidal. "?"
	^ self ⊗ anObject ⊗ anotherObject to: (self ⊗ anObject ⊗ anotherObject) carrier: (self carrier associatorWith: anObject carrier and: anotherObject carrier)! !

!MonoidObject methodsFor: 'morphisms' stamp: 'len 8/23/2024 08:35:40'!
braidingWith: anObject
	self assert: self carrier category isSymmetricMonoidal.
	^ self ⊗ anObject to: anObject ⊗ self carrier: (self carrier braidingWith: anObject carrier)! !

!MonoidObject methodsFor: 'morphisms' stamp: 'len 6/7/2024 13:38:17'!
id
	^ self propertyAt: #id ifAbsentPut: [self to: self carrier: self carrier id]! !

!MonoidObject methodsFor: 'morphisms' stamp: 'len 8/30/2024 08:33:15'!
leftUnitor
	^ self category unitObject ⊗ self to: self carrier: self carrier leftUnitor! !

!MonoidObject methodsFor: 'morphisms' stamp: 'len 8/30/2024 08:33:20'!
rightUnitor
	^ self ⊗ self category unitObject to: self carrier: self carrier rightUnitor! !

!MonoidObject methodsFor: 'morphisms' stamp: 'len 8/31/2024 18:45:25'!
to: aCodomain carrier: aMorphism
	^ MonoidMorphism from: self to: aCodomain carrier: aMorphism! !

!MonoidObject methodsFor: 'operations' stamp: 'len 9/5/2024 07:49:28'!
opposite
	"Answer the multiplicative opposite. This is the monoid with multiplication order reversed."
	self carrier isMonoid ifTrue: [^ self].
	^ self class multiplication: multiplication ∘ (self carrier braidingWith: self carrier) unit: unit! !

!MonoidObject methodsFor: 'operations' stamp: 'len 8/30/2024 22:01:16'!
⊗ aMonoid
	^ self class
		multiplication: multiplication ⊗ aMonoid multiplication ∘ (self carrier id ⊗ (self carrier braidingWith: aMonoid carrier) ⊗ aMonoid carrier id)
		unit: unit ⊗ aMonoid unit! !

!MonoidObject methodsFor: 'printing' stamp: 'len 6/9/2024 08:44:59'!
printOn: aStream
	aStream print: self carrier! !

!MonoidObject methodsFor: 'testing' stamp: 'len 9/1/2024 20:22:20'!
isCommutative
	"Answer true if the receiver is a commutative monoid."
	self carrier isMonoid ifTrue: [^ true]. "by Eckmann-Hilton argument, Mon(Mon(C)) = CMon(C)"
	^ self propertyAt: #isCommutative ifAbsentPut: [multiplication = self opposite multiplication]! !

!MonoidObject methodsFor: 'testing' stamp: 'len 8/29/2024 15:15:16'!
isMonoid
	^ true! !

!MonoidObject methodsFor: 'private' stamp: 'len 8/30/2024 08:36:20'!
multiplication: μ unit: η
	self assert: μ codomain = η codomain.
	multiplication := μ.
	unit := η! !

!MonoidObject class methodsFor: 'instance creation' stamp: 'len 8/30/2024 08:36:38'!
multiplication: μ unit: η
	^ self new multiplication: μ unit: η! !

!ChainComplex methodsFor: 'accessing' stamp: 'len 6/29/2023 19:43:27'!
at: k
	"Answer the k-th differential or boundary map d(k):C(k)→C(k-1)."
	^ differentials at: differentials size - k + shift ifAbsent: [(self chains: k) → (self chains: k-1)]! !

!ChainComplex methodsFor: 'accessing' stamp: 'len 4/22/2020 22:47:36'!
chains
	^ Iterator on: self performing: #chainsDo:! !

!ChainComplex methodsFor: 'accessing' stamp: 'len 11/4/2020 12:24:59'!
chains: k
	| i |
	i _ differentials size - k + shift.
	i < 1 ifTrue: [^ differentials first domain null].
	i = (differentials size + 1) ifTrue: [^ differentials last codomain].
	i > differentials size ifTrue: [^ differentials last codomain null].
	^ (differentials at: i) domain! !

!ChainComplex methodsFor: 'accessing' stamp: 'len 11/4/2020 12:25:07'!
indices
	^ differentials size + shift - 1 to: shift by: -1! !

!ChainComplex methodsFor: 'accessing' stamp: 'len 11/4/2020 12:25:44'!
maxDegree
	^ differentials size - 2 + shift! !

!ChainComplex methodsFor: 'accessing' stamp: 'len 11/4/2020 12:25:37'!
minDegree
	^ shift! !

!ChainComplex methodsFor: 'accessing' stamp: 'len 11/4/2020 12:27:42'!
null
	^ (self chains: self minDegree) null asChainComplex! !

!ChainComplex methodsFor: 'accessing' stamp: 'len 5/1/2024 12:27:01'!
scalars
	^ differentials any domain scalars! !

!ChainComplex methodsFor: 'comparing' stamp: 'len 11/4/2020 12:17:28'!
= anObject
	self == anObject ifTrue: [^ true].
	(anObject isKindOf: ChainComplex) ifFalse:  [^ super = anObject].
	(self minDegree min: anObject minDegree)
		to: (self maxDegree max: anObject maxDegree)
		do: [:i| (self at: i) = (anObject at: i) ifFalse: [^ false]].
	^ true! !

!ChainComplex methodsFor: 'comparing' stamp: 'len 4/22/2020 18:00:00'!
~ aChainComplex
	"Answer true if the receiver is isomorphic to the argument."
	^ self notYetImplemented "or should it be 'homotopy equivalent'?"! !

!ChainComplex methodsFor: 'comparing' stamp: 'len 4/22/2020 22:05:16'!
hash
	| answer |
	answer _ 0.
	differentials do: [:each| each isZero ifFalse: [answer _ answer hashMultiply + each hash]].
	^ answer! !

!ChainComplex methodsFor: 'enumerating' stamp: 'len 4/22/2020 22:47:53'!
chainsDo: aBlock
	differentials do: [:each| aBlock value: each domain].
	aBlock value: differentials last codomain! !

!ChainComplex methodsFor: 'homology' stamp: 'len 11/4/2020 12:27:09'!
betti
	^ (self minDegree to: self maxDegree) collect: [:i| self betti: i]! !

!ChainComplex methodsFor: 'homology' stamp: 'len 2/25/2017 07:17:45'!
betti: k
	"Answer the k-th Betti number.
	This is the rank of the k-th homology group.
	For singular homology this gives a measure of the number of k-dimensional holes."
	^ (self homology: k) rank! !

!ChainComplex methodsFor: 'homology' stamp: 'len 4/22/2020 14:15:25'!
boundaries: k
	"Answer the group of k-boundaries B(k), a subgroup of the group of k-chains C(k).
	This is the image of the k+1-th differential d(k+1)."
	^ (self at: k+1) image! !

!ChainComplex methodsFor: 'homology' stamp: 'len 4/22/2020 14:15:37'!
cycles: k
	"Answer the group of k-cycles Z(k), a subgroup of the group of k-chains C(k).
	This is the kernel of the k-th differential d(k)."
	^ (self at: k) kernel! !

!ChainComplex methodsFor: 'homology' stamp: 'len 10/5/2022 17:21:25'!
homology
	| objects |
	objects _ self indices collect: [:i| self homology: i].
	^ self class differentials: ((1 to: objects size - 1) collect: [:i| ((objects at: i) ⇒ (objects at: i+1)) zero])! !

!ChainComplex methodsFor: 'homology' stamp: 'len 2/24/2017 19:00:35'!
homology: k
	"Answer the k-th homology group H(k).
	This is the quotient of the k-cycles Z(k) modulo the k-boundaries B(k)."
	^ (self cycles: k) / (self boundaries: k)! !

!ChainComplex methodsFor: 'morphisms' stamp: 'len 4/16/2024 18:23:55'!
id
	^ self propertyAt: #id ifAbsentPut: [self to: self components: (self chains collect: [:each| each id])]! !

!ChainComplex methodsFor: 'morphisms' stamp: 'len 4/16/2024 18:49:41'!
to: aChainComplex
"	((aCodomain isKindOf: ChainComplex) and: [self scalars = aCodomain scalars])
		ifFalse: [^ nil].
	..."
	^ super to: aChainComplex! !

!ChainComplex methodsFor: 'morphisms' stamp: 'len 4/16/2024 18:24:02'!
to: aCodomain components: anArray
	^ ChainMap from: self to: aCodomain components: anArray! !

!ChainComplex methodsFor: 'operations' stamp: 'len 10/5/2022 18:40:00'!
/ aSubcomplex
	"Answer the quotient of the receiver by the argument, equipped with the quotient map."
	^ self class differentials: (differentials with: aSubcomplex differentials collect: [:f :g| (f domain → (f domain / g domain)) section → (f codomain / g codomain)]) shift: shift "assuming they are the same degree and length"! !

!ChainComplex methodsFor: 'operations' stamp: 'len 5/14/2019 16:44:49'!
<< n
	"Answer the complex with degrees shifted by n."
	^ self >> n negated! !

!ChainComplex methodsFor: 'operations' stamp: 'len 11/4/2020 12:20:07'!
>> n
	"Answer the complex with degrees shifted by n."
	^ self class differentials: differentials * (-1^n) shift: shift + n! !

!ChainComplex methodsFor: 'operations' stamp: 'len 1/3/2022 10:52:46'!
@ aPrimeIdeal
	"Answer the localization of the receiver at aPrimeIdeal."
	^ self class differentials: (differentials collect: [:each| each @ aPrimeIdeal]) shift: shift! !

!ChainComplex methodsFor: 'operations' stamp: 'len 4/17/2024 06:48:36'!
apply: aBlock
	^ self class differentials: (self differentials collect: aBlock) shift: shift! !

!ChainComplex methodsFor: 'operations' stamp: 'len 6/12/2024 18:13:02'!
dual
	"Answer the dual of the receiver. This is the cochain complex, taking dual in all objects and arrows reversed."
	^ (self class differentials: (self differentials reversed collect: [:each| each dual]) shift: shift) opposite! !

!ChainComplex methodsFor: 'operations' stamp: 'len 10/5/2022 17:21:20'!
hom: aCodomain
	^ self class differentials: (differentials collect: [:each| each ⇒ aCodomain]) reversed shift: shift! !

!ChainComplex methodsFor: 'operations' stamp: 'len 4/26/2020 04:01:30'!
stupidTruncationAbove: n
	"The 'stupid' truncation above is the subcomplex obtained by making 0 the i-th chain for all i > n."
	^ self notYetImplemented! !

!ChainComplex methodsFor: 'operations' stamp: 'len 4/26/2020 04:01:37'!
stupidTruncationBelow: n
	"The 'stupid' truncation below is the quotient complex obtained by making 0 the i-th chain for all i < n."
	^ self notYetImplemented! !

!ChainComplex methodsFor: 'operations' stamp: 'len 4/17/2024 08:02:47'!
sum
	"Answer the direct sum of the terms of the receiver.
	This is the forgetful functor from the category of chain complexes over A to A."
	^ differentials inject: differentials first domain null into: [:sum :each| sum ⊕ each domain]! !

!ChainComplex methodsFor: 'operations' stamp: 'len 4/26/2020 04:01:58'!
truncationAbove: n
	"The 'stupid' truncation above is the complex obtained by making 0 the i-th chain for all i > n, and replacing the n-th chain with the kernel of the n-th differential.
	This complex has the property that the i-th homology group equals that of the original complex for i >= n and it is 0 for i < n."
	^ self notYetImplemented! !

!ChainComplex methodsFor: 'operations' stamp: 'len 4/26/2020 04:01:52'!
truncationBelow: n
	"The canonical truncation below is the complex obtained by making 0 the i-th chain for all i < n, and replacing the n-th chain with the cokernel of the (n+1)-th differential.
	This complex has the property that the i-th homology group equals that of the original complex for i <= n and it is 0 for i > n."
	^ self notYetImplemented! !

!ChainComplex methodsFor: 'operations' stamp: 'len 8/23/2024 08:52:36'!
⊕ aChainComplex
	"Answer the direct sum of the receiver and the argument."
	^ self class differentials: (differentials with: aChainComplex differentials collect: [:f :g| f ⊕ g]) shift: shift "assuming they are the same shift and length"! !

!ChainComplex methodsFor: 'operations' stamp: 'len 11/4/2020 12:20:43'!
⊗ aChainComplex
	"Answer the tensor product of the receiver with the argument."
	^ self class differentials: (differentials with: aChainComplex differentials collect: [:f :g| f ⊗ g]) shift: shift "assuming they are the same degree and length"! !

!ChainComplex methodsFor: 'printing' stamp: 'len 4/17/2024 06:45:23'!
printOn: aStream
	self isTrivial ifTrue: [aStream print: 0. ^ self].
	aStream print: differentials first domain.
	differentials do: [:each| aStream nextPutAll: ' → '; print: each codomain]

"reversed arrows:
	aStream print: differentials last codomain.
	differentials reverseDo: [:each| aStream nextPutAll: ' ← '; print: each domain]
"! !

!ChainComplex methodsFor: 'testing' stamp: 'len 11/4/2020 12:27:18'!
isExact
	self minDegree to: self maxDegree do: [:i| (self isExactAt: i) ifFalse: [^ false]].
	^ true! !

!ChainComplex methodsFor: 'testing' stamp: 'len 4/29/2020 12:39:17'!
isExactAt: anInteger
	^ (self at: anInteger) image = (self at: anInteger-1) kernel! !

!ChainComplex methodsFor: 'testing' stamp: 'len 4/22/2020 22:47:01'!
isTrivial
	^ self chains allSatisfy: [:each| each isTrivial]! !

!ChainComplex methodsFor: 'private' stamp: 'len 6/29/2023 19:43:43'!
differentials
	"Answer the differentials, ordered as d(n) → ... → d(1) → d(0)."
	^ differentials! !

!ChainComplex methodsFor: 'private' stamp: 'len 11/4/2020 12:24:18'!
differentials: anArray shift: anInteger
	differentials _ anArray.
	shift _ anInteger! !

!ChainComplex methodsFor: 'private' stamp: 'len 11/4/2020 12:26:45'!
shift
	^ shift! !

!ChainComplex methodsFor: 'private' stamp: 'len 12/10/2023 10:36:24'!
validate
	| n |
	n := self maxDegree.
	self assert: (self at: n+1) kernel isTrivial.
	self assert: (self at: self minDegree) image isTrivial.
	n+1 to: self minDegree + 1 by: -1 do: [:i|
		self assert: (self at: i) codomain = (self at: i-1) domain.
		self assert: (self at: i) image ⊆ (self at: i-1) kernel]! !

!ChainComplex class methodsFor: 'examples' stamp: 'len 5/23/2020 08:59:30'!
kleinBottle
	"The chain complex associated to a triangulation of the Klein bottle:"
	^ SimplicialComplex kleinBottle chainComplexOver: ℤ! !

!ChainComplex class methodsFor: 'instance creation' stamp: 'len 11/4/2020 12:19:26'!
differentials: anArray
	^ self differentials: anArray shift: 0! !

!ChainComplex class methodsFor: 'instance creation' stamp: 'len 11/4/2020 12:21:24'!
differentials: anArray shift: anInteger
	^ self new differentials: anArray shift: anInteger! !

!FreydObject methodsFor: 'accessing' stamp: 'len 6/14/2024 15:06:50'!
category
	^ value category Freyd! !

!FreydObject methodsFor: 'accessing' stamp: 'len 4/28/2024 05:47:44'!
codomain
	^ value codomain! !

!FreydObject methodsFor: 'accessing' stamp: 'len 4/28/2024 05:47:40'!
domain
	^ value domain! !

!FreydObject methodsFor: 'accessing' stamp: 'len 4/22/2024 05:10:54'!
value
	^ value! !

!FreydObject methodsFor: 'comparing' stamp: 'len 4/28/2024 05:21:56'!
= anObject
	^ anObject = value! !

!FreydObject methodsFor: 'comparing' stamp: 'len 4/28/2024 05:22:01'!
hash
	^ value hash! !

!FreydObject methodsFor: 'morphisms' stamp: 'len 4/28/2024 05:20:50'!
id
	^ self propertyAt: #id ifAbsentPut: [self to: self datum: value codomain id]! !

!FreydObject methodsFor: 'morphisms' stamp: 'len 4/22/2024 05:16:20'!
to: aCodomain datum: aMorphism
	^ FreydMorphism from: self to: aCodomain datum: aMorphism! !

!FreydObject methodsFor: 'operations' stamp: 'len 4/28/2024 05:19:14'!
× anObject
	^ self ⊕ anObject! !

!FreydObject methodsFor: 'operations' stamp: 'len 4/28/2024 05:19:10'!
⊔ anObject
	^ self ⊕ anObject! !

!FreydObject methodsFor: 'operations' stamp: 'len 4/28/2024 05:17:01'!
⊕ anObject
	"Answer the direct sum of the receiver and the argument."
	^ self class value: value ⊕ anObject value! !

!FreydObject methodsFor: 'printing' stamp: 'len 4/22/2024 05:11:45'!
printOn: aStream
	aStream print: value! !

!FreydObject methodsFor: 'private' stamp: 'len 4/22/2024 05:11:11'!
value: aMorphism
	value := aMorphism! !

!FreydObject class methodsFor: 'instance creation' stamp: 'len 4/28/2024 05:16:57'!
value: aMorphism
	^ self new value: aMorphism! !

!GradedObject methodsFor: 'as yet unclassified' stamp: 'len 9/4/2024 10:27:18'!
× aGradedObject
	^ self class grading: [:i| (self at: i) × (aGradedObject at: i)]! !

!GradedObject methodsFor: 'as yet unclassified' stamp: 'len 9/4/2024 09:18:06'!
at: anInteger
	^ grading value: anInteger! !

!GradedObject methodsFor: 'as yet unclassified' stamp: 'len 9/4/2024 09:18:18'!
grading: aBlock
	grading := aBlock! !

!GradedObject methodsFor: 'as yet unclassified' stamp: 'len 9/4/2024 10:14:33'!
id
	^ self propertyAt: #id ifAbsentPut: [self to: self grading: [:i| (self at: i) id]]! !

!GradedObject methodsFor: 'as yet unclassified' stamp: 'len 9/4/2024 10:08:26'!
to: aCodomain grading: aBlock
	^ GradedMorphism from: self to: aCodomain grading: aBlock! !

!GradedObject methodsFor: 'as yet unclassified' stamp: 'len 9/4/2024 10:27:29'!
⊔ aGradedObject
	^ self class grading: [:i| (self at: i) ⊔ (aGradedObject at: i)]! !

!GradedObject methodsFor: 'as yet unclassified' stamp: 'len 9/4/2024 10:26:47'!
⊕ aGradedObject
	^ self class grading: [:i| (self at: i) ⊕ (aGradedObject at: i)]! !

!GradedObject class methodsFor: 'as yet unclassified' stamp: 'len 9/4/2024 09:29:25'!
grading: aBlock
	^ self new grading: aBlock! !

!RelationObject methodsFor: 'comparing' stamp: 'len 5/3/2024 14:29:56'!
= anObject
	^ anObject = value! !

!RelationObject methodsFor: 'comparing' stamp: 'len 5/3/2024 14:30:19'!
hash
	^ value hash! !

!RelationObject methodsFor: 'evaluating' stamp: 'len 5/3/2024 14:21:10'!
value
	^ value! !

!RelationObject methodsFor: 'morphisms' stamp: 'len 8/26/2024 20:06:36'!
id
	^ self propertyAt: #id ifAbsentPut: [value id asRelation]! !

!RelationObject methodsFor: 'operations' stamp: 'len 8/30/2024 08:15:51'!
× anObject
	| answer |
	answer := self class value: value ⊔ anObject value.
	answer addProjections: (answer value ⇇ {value. anObject value} collect: [:ι| Relation arrow: ι coarrow: ι]).
	^ answer! !

!RelationObject methodsFor: 'operations' stamp: 'len 8/30/2024 08:15:34'!
⊔ anObject
	| answer |
	answer := self class value: value × anObject value.
	answer addCoprojections: (answer value ⇉ {value. anObject value} collect: [:π| Relation arrow: π]).
	^ answer! !

!RelationObject methodsFor: 'operations' stamp: 'len 8/30/2024 08:16:47'!
⊕ anObject
	| answer |
	(answer := self class value: value ⊕ anObject value)
		addProjections: (answer value ⇇ {value. anObject value} collect: [:ι| Relation arrow: ι coarrow: ι]);
		addCoprojections: (answer value ⇉ {value. anObject value} collect: [:π| Relation arrow: π]).
	^ answer! !

!RelationObject methodsFor: 'operations' stamp: 'len 8/30/2024 08:15:41'!
⊗ anObject
	^ self class value: value ⊗ anObject value! !

!RelationObject methodsFor: 'printing' stamp: 'len 5/3/2024 14:22:04'!
printOn: aStream
	aStream print: value! !

!RelationObject methodsFor: 'private' stamp: 'len 5/3/2024 14:21:05'!
value: anObject
	value := anObject! !

!RelationObject class methodsFor: 'instance creation' stamp: 'len 5/3/2024 14:20:55'!
value: anObject
	^ self new value: anObject! !

!CoherentSheaf methodsFor: 'accessing' stamp: 'len 6/26/2022 22:21:13'!
codomain
	"If this is a Hom sheaf, answer the codomain sheaf."
	^ self class module: self asModule codomain on: self space! !

!CoherentSheaf methodsFor: 'accessing' stamp: 'len 6/26/2022 22:21:17'!
domain
	"If this is a Hom sheaf, answer the domain sheaf."
	^ self class module: self asModule domain on: self space! !

!CoherentSheaf methodsFor: 'accessing' stamp: 'len 7/27/2022 11:47:51'!
rank
	"If the receiver is locally free of finite rank, return the rank."
	^ self notYetImplemented! !

!CoherentSheaf methodsFor: 'accessing' stamp: 'len 5/4/2023 22:28:06'!
space
	^ self propertyAt: #space! !

!CoherentSheaf methodsFor: 'converting' stamp: 'len 5/4/2023 22:28:38'!
asModule
	^ self propertyAt: #module! !

!CoherentSheaf methodsFor: 'morphisms' stamp: 'len 4/16/2024 18:42:47'!
from: aSheaf
	(self asModule from: aSheaf asModule) ifNotNil: [:aModuleMap| ^ CoherentSheafMorphism from: aSheaf to: self moduleMap: aModuleMap].
	^ super from: aSheaf! !

!CoherentSheaf methodsFor: 'morphisms' stamp: 'len 4/13/2024 05:05:42'!
fromAll: anArray
	(super fromAll: anArray) ifNotNil: [:anotherArray| ^ anotherArray].
	(self asModule fromAll: (anArray collect: [:each| each asModule])) ifNotNil: [:anotherArray| ^ anotherArray with: anArray collect: [:ι :X| CoherentSheafMorphism from: X to: self moduleMap: ι]].
	^ nil! !

!CoherentSheaf methodsFor: 'morphisms' stamp: 'len 4/13/2024 05:04:11'!
hom: aCodomain
	(aCodomain isKindOf: CoherentSheaf) ifFalse: [^ super hom: aCodomain].
	self assert: aCodomain space = self space.
	^ self class module: self asModule ⇒ aCodomain asModule on: self space! !

!CoherentSheaf methodsFor: 'morphisms' stamp: 'len 4/16/2024 18:49:58'!
to: aSheaf
	(self asModule to: aSheaf asModule) ifNotNil: [:aModuleMap| ^ CoherentSheafMorphism from: self to: aSheaf moduleMap: aModuleMap].
	^ super to: aSheaf! !

!CoherentSheaf methodsFor: 'morphisms' stamp: 'len 4/13/2024 05:05:42'!
toAll: anArray
	(super toAll: anArray) ifNotNil: [:anotherArray| ^ anotherArray].
	(self asModule toAll: (anArray collect: [:each| each asModule])) ifNotNil: [:anotherArray| ^ anotherArray with: anArray collect: [:π :X| CoherentSheafMorphism from: self to: X moduleMap: π]].
	^ nil! !

!CoherentSheaf methodsFor: 'operations' stamp: 'len 5/4/2023 22:29:53'!
<< anInteger
	"Answer the n-th Serre twist of the receiver."
	(anInteger = 0 or: [self isTrivial]) ifTrue: [^ self].
	^ self class module: self asModule << anInteger on: self space! !

!CoherentSheaf methodsFor: 'operations' stamp: 'len 7/27/2022 11:11:58'!
>> anInteger
	^ self << anInteger negated! !

!CoherentSheaf methodsFor: 'operations' stamp: 'len 7/27/2022 11:50:34'!
@ aPoint
	"Answer the stalk of the receiver at aPoint."
	^ self asModule @ (self space !! aPoint) asIdeal! !

!CoherentSheaf methodsFor: 'operations' stamp: 'len 6/26/2022 22:21:23'!
dual
	^ self class module: self asModule dual on: self space! !

!CoherentSheaf methodsFor: 'operations' stamp: 'len 7/26/2022 11:17:07'!
pullback: aMorphism
	"Answer the pullback or inverse image of the receiver along aMorphism."
	^ self notYetImplemented! !

!CoherentSheaf methodsFor: 'operations' stamp: 'len 7/26/2022 11:17:30'!
pushforward: aMorphism
	"Answer the pushforward or direct image of the receiver along aMorphism."
	^ self notYetImplemented! !

!CoherentSheaf methodsFor: 'operations' stamp: 'len 4/13/2024 05:04:11'!
⊕ aSheaf
	self assert: ((aSheaf isKindOf: CoherentSheaf) and: [aSheaf space = self space]).
	^ self class module: self asModule ⊕ aSheaf asModule on: self space! !

!CoherentSheaf methodsFor: 'operations' stamp: 'len 4/13/2024 05:04:11'!
⊗ aSheaf
	self assert: ((aSheaf isKindOf: CoherentSheaf) and: [aSheaf space = self space]).
	^ self class module: self asModule ⊗ aSheaf asModule on: self space! !

!CoherentSheaf methodsFor: 'printing' stamp: 'len 12/13/2021 18:08:57'!
printOn: aStream
	aStream print: self asModule! !

!CoherentSheaf methodsFor: 'testing' stamp: 'len 7/27/2022 11:48:05'!
isLocallyFree
	^ self notYetImplemented! !

!CoherentSheaf methodsFor: 'testing' stamp: 'len 12/13/2021 18:12:04'!
isTrivial
	^ self asModule isTrivial! !

!CoherentSheaf methodsFor: 'private' stamp: 'len 5/4/2023 22:27:32'!
module: aGradedModule
	self propertyAt: #module put: aGradedModule! !

!CoherentSheaf methodsFor: 'private' stamp: 'len 5/4/2023 22:27:43'!
space: aScheme
	self propertyAt: #space put: aScheme! !

!CoherentSheaf methodsFor: 'private' stamp: 'len 4/13/2024 05:04:11'!
species
	^ CoherentSheaf! !

!CoherentSheaf class methodsFor: 'instance creation' stamp: 'len 12/21/2021 20:45:36'!
module: aGradedModule on: aScheme
	^ self new module: aGradedModule; space: aScheme! !

!Morphism methodsFor: 'accessing' stamp: 'len 8/30/2024 20:51:53'!
category
	"Answer the category where the receiver belongs as morphism."
	^ self propertyAt: #category ifAbsent: [self subclassResponsibility]! !

!Morphism methodsFor: 'accessing' stamp: 'len 4/22/2020 14:43:39'!
codomain
	^ self propertyAt: #codomain! !

!Morphism methodsFor: 'accessing' stamp: 'len 4/22/2020 14:43:43'!
domain
	^ self propertyAt: #domain! !

!Morphism methodsFor: 'accessing' stamp: 'len 3/25/2024 09:05:31'!
identity
	self isEndomorphism ifFalse: [^ self error: 'not an endomorphism'].
	^ self domain id! !

!Morphism methodsFor: 'accessing' stamp: 'len 4/12/2024 04:52:29'!
parent
	"Answer the hom-set where the receiver belongs to, i.e. Hom(A,B) where A and B are the domain and codomain of the receiver."
	^ self codomain ^ self domain! !

!Morphism methodsFor: 'comparing' stamp: 'len 4/22/2020 14:43:11'!
hash
	^ self domain hash hashMultiply + self codomain hash! !

!Morphism methodsFor: 'converting' stamp: 'len 8/26/2024 20:06:36'!
asRelation
	"Answer the honest generalized morphism induced by the receiver."
	^ Relation arrow: self! !

!Morphism methodsFor: 'internalization' stamp: 'len 8/30/2024 20:54:17'!
carrier
	^ self! !

!Morphism methodsFor: 'operations' stamp: 'len 6/13/2024 14:07:11'!
/ aMorphism
	"Answer h:X→Y such that h·g = f, where g:A→X is the argument and f:A→Y is the receiver.
	This is a 'colift (or extension) of g along f' and it is denoted by f / g."
	^ (aMorphism colift: self) ifNil: [DivisibilityError new signalReceiver: self selector: #/ argument: aMorphism]! !

!Morphism methodsFor: 'operations' stamp: 'len 6/13/2024 14:07:26'!
\ aMorphism
	"Answer h:Y→X such that f·h = g, where f:X→B is the receiver and g:Y→B is the argument.
	This is a 'lift of g along f', denoted by f \ g."
	^ (self lift: aMorphism) ifNil: [DivisibilityError new signalReceiver: self selector: #\ argument: aMorphism]! !

!Morphism methodsFor: 'operations' stamp: 'len 8/4/2024 11:02:23'!
^ anObject
	"This is the exponential notation for the hom-set functor. See also #⇒."
	"If the argument is an integer, answer the repeated composition of the receiver with itself."
	anObject isInteger ifTrue: [^ self raisedTo: anObject].
	"If the argument is another object B, this is the Hom(-,B) contravariant functor:"
	(self category includes₀: anObject) ifTrue: [^ anObject ^ self codomain to: anObject ^ self domain map: [:f| f ∘ self]].
	"If the argument is another morphism, answer the conjugation:"
	^ anObject · self · anObject inverse! !

!Morphism methodsFor: 'operations' stamp: 'len 7/21/2024 09:30:37'!
· aMorphism
	"Answer the composition of the receiver with the argument.
	Given the argument f:X→Y and the receiver g:Y→Z, answer g·f:X→Z."
	^ self ∘ aMorphism! !

!Morphism methodsFor: 'operations' stamp: 'len 5/17/2024 08:35:50'!
× aMorphism
	"Answer the product of the receiver and the argument.
	If the receiver is A → X and the argument is B → Y, answer the unique morphism A×B → X×Y such that the obvious diagram commutes."
	self category isAdditive ifTrue: [^ self ⊕ aMorphism].
	^ self subclassResponsibility! !

!Morphism methodsFor: 'operations' stamp: 'len 5/10/2024 04:18:02'!
coequalizer: aMorphism
	"A coequalizer is a colimit p : Y → P under a parallel pair f,g : X → Y, i.e. p·f = p·g and p is universal with this property."
	"In a preadditive category the coequalizer is the cokernel of the difference."
	self category isPreadditive ifTrue: [^ (self - aMorphism) cokernel].
	^ self subclassResponsibility! !

!Morphism methodsFor: 'operations' stamp: 'len 6/13/2024 14:07:32'!
colift: aMorphism
	"Answer h:X→Y such that h·g = f, where g:A→X is the receiver and f:A→Y is the argument. Answer nil if there is no solution.
	This is a 'colift (or extension) of g along f' and it is denoted by f / g."
	^ self subclassResponsibility! !

!Morphism methodsFor: 'operations' stamp: 'len 5/3/2020 10:06:33'!
commutator: aMorphism
	^ self inverse · aMorphism inverse · self · aMorphism! !

!Morphism methodsFor: 'operations' stamp: 'len 7/21/2024 09:46:06'!
dual
	"If the receiver is a morphism in a monoidal category with dualizable domain and codomain, answer the dual morphism."
	^ self codomain id ⊗ self domain coevaluation ∘ (self codomain id ⊗ self ⊗ self domain dual id) ∘ (self domain evaluation ⊗ self domain dual)! !

!Morphism methodsFor: 'operations' stamp: 'len 7/21/2024 09:45:53'!
dual2
	"If the receiver is a morphism in a monoidal category with dualizable domain and codomain, answer the dual morphism."
	^ self codomain id ⊗ self domain coevaluation ∘ (self codomain id ⊗ self ⊗ self domain dual id) ∘ (self domain evaluation ⊗ self domain dual)! !

!Morphism methodsFor: 'operations' stamp: 'len 5/9/2024 15:43:37'!
equalizer: aMorphism
	"An equalizer is a limit e : E → X over a parallel pair f,g : X → Y, i.e. f·e = g·e and e is universal with this property."
	"In a preadditive category the equalizer is the kernel of the difference."
	self category isPreadditive ifTrue: [^ (self - aMorphism) kernel].
	^ self subclassResponsibility! !

!Morphism methodsFor: 'operations' stamp: 'len 4/17/2024 09:09:10'!
inverse
	"Answer a two-sided inverse of the receiver (i.e., a morphism that is both a retraction and a section) or nil."
	^ self propertyAt: #inverse ifAbsent: [	self isIdentity ifTrue: [self] ifFalse: [self subclassResponsibility]]! !

!Morphism methodsFor: 'operations' stamp: 'len 6/13/2024 14:07:37'!
lift: aMorphism
	"Answer h:Y→X such that f·h = g, where f:X→B is the receiver and g:Y→B is the argument.
	This is a 'lift of g along f', denoted by f \ g."
	^ self subclassResponsibility! !

!Morphism methodsFor: 'operations' stamp: 'len 4/24/2024 05:42:27'!
raisedTo: anInteger
	"Answer the receiver composed with itself anInteger times."
	anInteger = 1 ifTrue: [^ self].
	anInteger = 0 ifTrue: [^ self identity].
	anInteger < 0 ifTrue: [^ self inverse raisedTo: anInteger negated].
	^ anInteger even ifTrue: [self squared raisedTo: anInteger // 2] ifFalse: [(self squared raisedTo: anInteger // 2) · self]! !

!Morphism methodsFor: 'operations' stamp: 'len 3/25/2024 09:03:26'!
retraction
	"Answer a left inverse (or retraction) of the receiver."
	^ self propertyAt: #retraction ifAbsentPut: [self colift: self domain id]! !

!Morphism methodsFor: 'operations' stamp: 'len 5/18/2024 14:59:44'!
reverse
	"Answer the morphism associated to the receiver in the opposite category.
	The morphism is equal to the receiver but not identical, and the arrow is reversed."
	^ self propertyAt: #reverse ifAbsentPut: [OppositeMorphism reverse: self]! !

!Morphism methodsFor: 'operations' stamp: 'len 3/25/2024 09:03:01'!
section
	"Answer a right inverse (or section) of the receiver."
	^ self propertyAt: #section ifAbsentPut: [self lift: self codomain id]! !

!Morphism methodsFor: 'operations' stamp: 'len 8/4/2024 10:43:11'!
sections
	"If the receiver is a morphism φ : X → Y, answer the 'object of sections' of φ, denoted Γ(φ). This is the subobject of [Y,X] corresponding to morphisms whose composite with φ are the identity."
	^ self ⇒ self codomain ∧ (self codomain ⇒ self codomain) id! !

!Morphism methodsFor: 'operations' stamp: 'len 6/9/2022 07:17:13'!
squared
	^ self · self! !

!Morphism methodsFor: 'operations' stamp: 'len 7/21/2024 09:45:22'!
traceMorphism
	"The categorical trace of an endomorphism in a symmetric monoidal category."
	| X |
	self assert: self isEndomorphism.
	self assert: self category isSymmetricMonoidal.
	X := self domain.
	^ X evaluation ∘ (X braidingWith: X) ∘ (self ⊗ X dual id) ∘ X coevaluation! !

!Morphism methodsFor: 'operations' stamp: 'len 7/21/2024 09:45:10'!
→ aMorphism
	"Answer the composition with the argument in diagrammatic order. If the argument is an object, answer the composition with the canonical morphism from the codomain to the argument.  See also Domain>>#→."
	^ aMorphism isMorphism ifTrue: [aMorphism ∘ self] ifFalse: [self codomain == aMorphism ifTrue: [self] ifFalse: [self codomain → aMorphism ∘ self]]! !

!Morphism methodsFor: 'operations' stamp: 'len 8/4/2024 11:03:28'!
⇒ aCodomain
	"This is the hom-object functor. See #^ for the hom-set functor.
	If the receiver is a morphism g : X → Y, answer the map Hom(g,B) : Hom(Y,B) → Hom(X,B) that sends a morphism f to f∘g.
	This is a contravariant functor and it is often called the 'functor of points' of B."
	self assert: (self category includes₀: aCodomain). "make sure it's an object of the category"
	self flag: #fixme. "this is wrong, the enriched hom is not necesarily sets of morphisms:"
	^ self codomain ⇒ aCodomain to: self domain ⇒ aCodomain map: [:f| f ∘ self]! !

!Morphism methodsFor: 'operations' stamp: 'len 7/21/2024 09:30:25'!
∘ aMorphism
	"Answer the composition of the receiver with the argument.
	Given the argument f:X→Y and the receiver g:Y→Z, answer g·f:X→Z."
	^ self subclassResponsibility! !

!Morphism methodsFor: 'operations' stamp: 'len 7/21/2024 09:44:42'!
∧ aMorphism
	"Answer the pullback (or fibered product, cartesian square) of the receiver and the argument.
	The pullback is the limit of a cospan X → Z ← Y and it is the categorical dual of the pushout (see #∨).
	The pullback f ∧ g of a morphism f and a monomorphism g can be thought of as the 'preimage' under f of the subobject specified by g. Similarly, pullbacks of two monomorphisms can be thought of as the 'intersection' of the two subobjects."
	self category isPreabelian ifTrue:
		[| S answer |
		S := self ⊔ aMorphism negated.
		answer := S kernel.
		answer addProjections: (S domain ⇉ {self domain. aMorphism domain} collect: [:each| answer → each]).
		^ answer].
	"Assuming the category has binary products and equalizers:"
	^ self domain × aMorphism domain ⇉ {self domain. aMorphism domain} into: [:π₁ :π₂|
		| e |
		e := self ∘ π₁ equalizer: aMorphism ∘ π₂.
		e domain addProjections: {π₁ ∘ e. π₂ ∘ e}; yourself]! !

!Morphism methodsFor: 'operations' stamp: 'len 7/21/2024 09:44:16'!
∨ aMorphism
	"Answer the pushout (or fibered coproduct, fibered sum, cocartesian square, amalgamated sum) of the receiver and the argument.
	The pushout is the colimit of a span X ← Z → Y, and it is the categorical dual of the pullback (see #∧)."
	self category isPreabelian ifTrue:
		[| P answer |
		P := self ⊓ aMorphism negated.
		answer := P cokernel.
		answer addCoprojections: (P codomain ⇇ {self codomain. aMorphism codomain} collect: [:each| each → answer]).
		^ answer].
	"Assuming the category has binary coproducts and coequalizers:"
	^ self codomain ⊔ aMorphism codomain ⇇ {self codomain. aMorphism codomain} into: [:ι₁ :ι₂|
		| c |
		c := ι₁ ∘ self coequalizer: ι₂ ∘ aMorphism.
		c codomain addCoprojections: {c ∘ ι₁. c ∘ ι₂}; yourself]! !

!Morphism methodsFor: 'operations' stamp: 'len 7/21/2024 09:44:01'!
⊓ aMorphism
	"Answer the pairing of the receiver and the argument.
	If the receiver is A → X and the argument is A → Y, and assuming the product X×Y exists, answer the unique morphism A → X×Y given by the product universal property."
	self category isAdditive ifFalse: [^ self subclassResponsibility].
	self checkDomainsMatch: aMorphism.
	^​ self codomain ⊓ aMorphism codomain ⇇ {self codomain. aMorphism codomain} into: [:ι₁ :ι₂| ι₁ ∘ self + (ι₂ ∘ aMorphism)]! !

!Morphism methodsFor: 'operations' stamp: 'len 7/21/2024 09:43:51'!
⊔ aMorphism
	"Answer the copairing of the receiver and the argument.
	If the receiver is X → B and the argument is Y → B, and assuming the coproduct X⊔Y exists, answer the unique morphism X⊔Y → B given by the coproduct universal property."
	self category isAdditive ifFalse: [^ self subclassResponsibility].
	self checkCodomainsMatch: aMorphism.
	^ self domain ⊔ aMorphism domain ⇉ {self domain. aMorphism domain} into: [:π₁ :π₂| self ∘ π₁ + (aMorphism ∘ π₂)]! !

!Morphism methodsFor: 'operations' stamp: 'len 6/23/2024 05:57:27'!
⊗ aMorphism
	"If the receiver and the argument are morphisms of a monoidal category, answer their tensor product."
	self category isCartesianMonoidal ifTrue: [^ self × aMorphism].
	^ self subclassResponsibility! !

!Morphism methodsFor: 'operations-additive' stamp: 'len 7/21/2024 09:43:37'!
⊕ aMorphism
	"Answer the direct sum of the receiver and the argument.
	If the receiver is A → X and the argument is B → Y, answer the unique morphism A⊕B → X⊕Y such that the obvious diagram commutes."
	^ self domain ⊕ aMorphism domain ⇉ {self domain. aMorphism domain} into: [:π₁ :π₂|
		self codomain ⊕ aMorphism codomain ⇇ {self codomain. aMorphism codomain} into: [:ι₁ :ι₂|
			ι₁ ∘ self ∘ π₁ + (ι₂ ∘ aMorphism ∘ π₂)]]! !

!Morphism methodsFor: 'operations-dagger' stamp: 'len 8/27/2024 21:22:58'!
adjoint
	"If the receiver is a morphism X → Y in a dagger category, answer the its adjoint Y → X. This is the dagger."
	^ self subclassResponsibility! !

!Morphism methodsFor: 'operations-dagger' stamp: 'len 8/27/2024 21:24:04'!
isSelfAdjoint
	^ self = self adjoint! !

!Morphism methodsFor: 'operations-dagger' stamp: 'len 8/27/2024 21:24:39'!
isUnitary
	^ self adjoint = self inverse! !

!Morphism methodsFor: 'operations-preabelian' stamp: 'len 8/14/2024 11:22:24'!
astriction
	"Answer the astriction of the receiver to its coimage: given a morphism f:A→B answer the morphism coim(f)→B."
	^ self / self coimageMorphism! !

!Morphism methodsFor: 'operations-preabelian' stamp: 'len 8/14/2024 11:23:23'!
coastriction
	"Answer the coastriction of the receiver to its image: given a morphism f:A→B answer the morphism A→im(f)."
	^ self imageMorphism \ self! !

!Morphism methodsFor: 'operations-preabelian' stamp: 'len 8/14/2024 11:23:46'!
coimage
	"In an abelian category, the coimage is the cokernel of the kernel."
	self category isAbelian ifTrue: [^ self kernelMorphism cokernel].	
	^ self subclassResponsibility! !

!Morphism methodsFor: 'operations-preabelian' stamp: 'len 8/14/2024 11:23:46'!
coimageMorphism
	"In an abelian category, the coimage is the cokernel of the kernel."
	self category isAbelian ifTrue: [^ self kernelMorphism cokernelMorphism].	
	^ self subclassResponsibility! !

!Morphism methodsFor: 'operations-preabelian' stamp: 'len 6/26/2024 08:41:24'!
cokernel
	"Answer the cokernel object.
	Intuitively, the cokernel of a morphism f:X→Y is the 'most general' morphism q:Y→Q such that q·f = 0.
	The cokernel of a morphism f:X→Y is defined as the coequalizer of f and the zero morphism 0:X→Y, i.e. an object Q and a morphism q:Y→Q that makes a commutative triangle with f:X→Y and 0:X→Q. Moreover, the morphism q is universal for this diagram, i.e. any other such q':Y→Q' can be obtained by composing q with a unique morphism u:Q→Q'.
	Like all coequalizers, the cokernel is necessarily an epimorphism."
	^ self subclassResponsibility! !

!Morphism methodsFor: 'operations-preabelian' stamp: 'len 8/14/2024 11:23:00'!
cokernelMorphism
	"Answer a cokernel projection."
	^ self codomain → self cokernel! !

!Morphism methodsFor: 'operations-preabelian' stamp: 'len 5/7/2024 08:34:48'!
cokernelPair
	"The 'cokernel pair' of a morphism is the pair of embeddings of the codomain into the pushout of the morphism along itself."
	^ self ∨ self ⇇ {self codomain. self codomain}! !

!Morphism methodsFor: 'operations-preabelian' stamp: 'len 8/14/2024 11:23:01'!
image
	"In an abelian category, the image is the kernel of the cokernel."
	self category isAbelian ifTrue: [^ self cokernelMorphism kernel].
	^ self subclassResponsibility! !

!Morphism methodsFor: 'operations-preabelian' stamp: 'len 8/14/2024 11:23:47'!
imageMorphism
	"In an abelian category, the image is the kernel of the cokernel."
	self category isAbelian ifTrue: [^ self cokernelMorphism kernelMorphism].
	^ self subclassResponsibility! !

!Morphism methodsFor: 'operations-preabelian' stamp: 'len 6/26/2024 08:39:54'!
kernel
	"Answer the kernel object.
	Intuitively, the kernel of a morphism f:X→Y is the 'most general' morphism k:K→X such that f·k = 0.
	The kernel of a morphism f:X→Y is defined as the equalizer of f and the zero morphism 0:X→Y, i.e. an object K and a morphism k:K→X that makes a commutative triangle with f:X→Y and 0:K→Y. Moreover, the morphism k is universal for this diagram, i.e. any other such k':K'→X can be obtained by composing k with a unique morphism u:K'→K.
	Like all equalizers, the kernel is necessarily a monomorphism."
	^ self subclassResponsibility! !

!Morphism methodsFor: 'operations-preabelian' stamp: 'len 8/14/2024 11:23:46'!
kernelMorphism
	"Answer a kernel embedding."
	^ self kernel → self domain! !

!Morphism methodsFor: 'operations-preabelian' stamp: 'len 5/7/2024 08:32:29'!
kernelPair
	"The 'kernel pair' of a morphism is the pair of projections from the pullback of the morphism along itself to the domain."
	^ self ∧ self ⇉ {self domain. self domain}! !

!Morphism methodsFor: 'operations-preadditive' stamp: 'len 6/23/2024 06:19:43'!
* anInteger
	anInteger isInteger ifFalse: [^ self subclassResponsibility].
	anInteger = 1 ifTrue: [^ self].
	anInteger = 0 ifTrue: [^ self zero].
	anInteger < 0 ifTrue: [^ self negated * anInteger negated].
	^ anInteger even ifTrue: [self + self * (anInteger // 2)] ifFalse: [self + self * (anInteger // 2) + self]! !

!Morphism methodsFor: 'operations-preadditive' stamp: 'len 3/26/2024 15:40:43'!
+ aMorphism
	^ self subclassResponsibility! !

!Morphism methodsFor: 'operations-preadditive' stamp: 'len 3/26/2024 15:40:48'!
- aMorphism
	^ self + aMorphism negated! !

!Morphism methodsFor: 'operations-preadditive' stamp: 'len 4/17/2024 09:00:50'!
isZero
	^ self = self zero! !

!Morphism methodsFor: 'operations-preadditive' stamp: 'len 3/26/2024 15:42:17'!
negated
	^ self subclassResponsibility! !

!Morphism methodsFor: 'operations-preadditive' stamp: 'len 4/17/2024 09:04:14'!
zero
	"Answer the zero morphism with the same domain and codomain as the receiver."
	^ self subclassResponsibility! !

!Morphism methodsFor: 'printing' stamp: 'len 4/4/2024 12:38:16'!
arrowCharacter
	self propertyAt: #arrowCharacter ifPresent: [:aCharacter| ^ aCharacter].
	(self propertyAt: #inverse ifAbsent: []) ifNotNil: [^ $↔].
	(self propertyAt: #retraction ifAbsent: []) ifNotNil: [^ $↪]. "or ↣"
	(self propertyAt: #section ifAbsent: []) ifNotNil: [^ $↠].
	^ $→! !

!Morphism methodsFor: 'printing' stamp: 'len 4/22/2020 14:36:36'!
name
	^ self propertyAt: #name ifAbsent: [String streamContents: [:aStream| super printOn: aStream]]! !

!Morphism methodsFor: 'printing' stamp: 'len 4/22/2020 14:36:41'!
name: aString
	self propertyAt: #name put: aString! !

!Morphism methodsFor: 'printing' stamp: 'len 6/1/2024 08:48:34'!
printOn: aStream
	([self isIdentity] on: UnhandledError do: [false]) ifTrue: [aStream nextPutAll: 'id'. ^ self].
	(self category isPreadditive and: [self isZero]) ifTrue: [aStream print: 0. ^ self].
	aStream nextPutAll: self name; nextPutAll: ' : '.
	aStream print: self domain; space; nextPut: self arrowCharacter; space; print: self codomain! !

!Morphism methodsFor: 'properties' stamp: 'len 6/7/2024 13:57:34'!
hasProperty: aSymbol
	^ (properties ifNil: [^ false]) includesKey: aSymbol! !

!Morphism methodsFor: 'properties' stamp: 'len 6/7/2024 13:57:34'!
properties
	^ properties ifNil: [properties _ IdentityDictionary new]! !

!Morphism methodsFor: 'properties' stamp: 'len 6/7/2024 13:57:34'!
propertyAt: aSymbol
	^ self propertyAt: aSymbol ifAbsent: [self error: 'no such property']! !

!Morphism methodsFor: 'properties' stamp: 'len 6/7/2024 13:57:34'!
propertyAt: aSymbol ifAbsent: exceptionBlock
	^ (properties ifNil: [^ exceptionBlock value]) at: aSymbol ifAbsent: exceptionBlock! !

!Morphism methodsFor: 'properties' stamp: 'len 6/7/2024 13:57:35'!
propertyAt: aSymbol ifAbsentPut: aBlock
	^ self properties at: aSymbol ifAbsentPut: aBlock! !

!Morphism methodsFor: 'properties' stamp: 'len 6/7/2024 13:57:35'!
propertyAt: aSymbol ifPresent: aBlock
	^ (properties ifNil: [^ nil]) at: aSymbol ifPresent: aBlock! !

!Morphism methodsFor: 'properties' stamp: 'len 6/7/2024 13:57:35'!
propertyAt: aSymbol put: anObject
	^ self properties at: aSymbol put: anObject! !

!Morphism methodsFor: 'testing' stamp: 'len 8/8/2016 06:02'!
isAutomorphism
	^ self isEndomorphism and: [self isIsomorphism]! !

!Morphism methodsFor: 'testing' stamp: 'len 4/22/2020 06:00:10'!
isElement
	"Answer true if the receiver is an element of a Domain, i.e. if it understands the message #parent and answers its parent Domain.
	The parent of a morphism is a hom set."
	^ true! !

!Morphism methodsFor: 'testing' stamp: 'len 8/8/2016 06:02'!
isEndomorphism
	^ self domain = self codomain! !

!Morphism methodsFor: 'testing' stamp: 'len 4/15/2024 09:18:39'!
isEpimorphism
	"Answer true if the receiver is right cancelable: a morphism f:A→B is an epimorphism if, for any pair of morphisms g,h:B→C, gf = hf implies g = h."
	"In a preabelian category a morphism is an epimorphisms if and only if the cokernel is zero."
	self category isPreabelian ifTrue: [^ self cokernel isTrivial].
	^ self subclassResponsibility! !

!Morphism methodsFor: 'testing' stamp: 'len 7/21/2024 09:45:37'!
isIdempotent
	^ self isEndomorphism and: [self ∘ self = self]! !

!Morphism methodsFor: 'testing' stamp: 'len 11/16/2016 08:33'!
isIdentity
	^ self = self domain id! !

!Morphism methodsFor: 'testing' stamp: 'len 4/12/2024 04:58:39'!
isIsomorphism
	"In an abelian category a morphism is an isomorphism if and only if it is a monomorphism and an epimorphism."
	self category isAbelian ifTrue: [^ self isMonomorphism and: [self isEpimorphism]].
	^ self subclassResponsibility! !

!Morphism methodsFor: 'testing' stamp: 'len 4/15/2024 09:18:24'!
isMonomorphism
	"Answer true if the receiver is left cancelable: a morphism f:A→B is a monomorphism if, for any pair of morphisms g,h:C→A, fg = fh implies g = h."
	"In a preabelian category a morphism is an monomorphisms if and only if the kernel is zero."
	self category isPreabelian ifTrue: [^ self kernel isTrivial	].
	^ self subclassResponsibility! !

!Morphism methodsFor: 'testing' stamp: 'len 5/8/2020 17:57:22'!
isMorphism
	^ true! !

!Morphism methodsFor: 'testing' stamp: 'len 12/25/2021 12:15:27'!
isRetraction
	"A split epimorphism is a morphism that has a section (a right inverse).
	Dualy, a split epimorphism is a morphism that *is* a retraction (a left inverse)."
	^ self section notNil! !

!Morphism methodsFor: 'testing' stamp: 'len 12/25/2021 12:15:43'!
isSection
	"A split monomorphism is a morphism that has a retraction (a left inverse).
	Dualy, a split monomorphism is a morphism that *is* a section (a right inverse)."
	^ self retraction notNil! !

!Morphism methodsFor: 'testing' stamp: 'len 3/26/2024 17:57:03'!
isTrivial
	^ self isZero "assuming it is preadditive"! !

!Morphism methodsFor: 'private' stamp: 'len 4/5/2024 19:02:50'!
checkCodomainsMatch: aMorphism
	self codomain = aMorphism codomain ifFalse: [^ self error: 'codomains don''t match']! !

!Morphism methodsFor: 'private' stamp: 'len 4/5/2024 19:02:41'!
checkCompatibleComposition: aMorphism
	self domain = aMorphism codomain ifFalse: [^ self error: 'incompatible composition']! !

!Morphism methodsFor: 'private' stamp: 'len 4/5/2024 19:02:33'!
checkDomainsMatch: aMorphism
	self domain = aMorphism domain ifFalse: [^ self error: 'domains don''t match']! !

!Morphism methodsFor: 'private' stamp: 'len 4/16/2022 18:08:24'!
codomain: aDomain
	self propertyAt: #codomain put: aDomain! !

!Morphism methodsFor: 'private' stamp: 'len 4/16/2022 18:08:28'!
domain: aDomain
	self propertyAt: #domain put: aDomain! !

!Map methodsFor: 'accessing' stamp: 'len 8/19/2024 09:41:08'!
carrierFunction
	"Answer the induced function between the carrier sets of the domain and codomain of the receiver.
	This is the forgetful functor to the category of sets."
	^ self domain underlyingSet to: self codomain underlyingSet map: self! !

!Map methodsFor: 'comparing' stamp: 'len 5/31/2024 15:47:13'!
= anObject
	self == anObject ifTrue: [^ true].
	self species = anObject species ifFalse: [^ false].
	(self domain = anObject domain and: [self codomain = anObject codomain]) ifFalse: [^ false].
	self domain isFinitelyGenerated ifTrue: [^ self domain generators allSatisfy: [:each| (self value: each) = (anObject value: each)]].
	self domain isFinite ifTrue: [^ self domain elements allSatisfy: [:each| (self value: each) = (anObject value: each)]].
	^ self subclassResponsibility! !

!Map methodsFor: 'operations' stamp: 'len 4/3/2024 08:52:36'!
, aFunction
	"Answer the cartesian product of the receiver with the argument."
	^ (self domain, aFunction domain)
		to: (self codomain, aFunction codomain)
		map: [:each| {self value: (each at: 1). aFunction value: (each at: 2)}]! !

!Map methodsFor: 'operations' stamp: 'len 5/3/2024 06:15:54'!
\ anObject
	(self codomain includes: anObject) ifTrue: [^ self preimageElement: anObject].
	anObject isMorphism ifTrue: [^ super \ anObject].
	^ self preimage: anObject "maybe only if anObject ⊆ self codomain"! !

!Map methodsFor: 'operations' stamp: 'len 7/2/2023 18:43:45'!
image
	^ self propertyAt: #image ifAbsent: [self domain apply: self]! !

!Map methodsFor: 'operations' stamp: 'len 11/29/2023 10:28:43'!
preimage: aSubset
	^ self domain select: [:each| aSubset includes: (self value: each)]! !

!Map methodsFor: 'operations' stamp: 'len 10/14/2023 15:57:53'!
preimageElement: anElement
	"Answer an element in the preimage of anElement.
	Answer nil if anElement is not in the image of the receiver."
	^ self domain detect: [:one| (self value: one) = anElement] ifNone: []! !

!Map methodsFor: 'operations' stamp: 'len 5/2/2024 14:12:00'!
value: anElement
	| answer |
	self assert: (self domain includes: anElement).
	answer := (self propertyAt: #evaluable) value: anElement.
	self assert: (self codomain includes: answer).
	^ answer

"	^ self codomain !! ((self propertyAt: #evaluable) value: self domain !! anElement)"! !

!Map methodsFor: 'operations' stamp: 'len 7/21/2024 09:31:57'!
∘ aMap
	"Answer the composition of the receiver with the argument.
	Given the argument f:X→Y and the receiver g:Y→Z, answer g·f:X→Z.
	This is, (g∘f)(x) = g(f(x))."
	self checkCompatibleComposition: aMap.
	^ aMap domain to: self codomain map: [:x| self value: (aMap value: x)]! !

!Map methodsFor: 'testing' stamp: 'len 1/29/2024 10:03:31'!
imageContains: anElement
	^ (self preimageElement: anElement) notNil

"alternative:
	^ self image contains: anElement
"! !

!Map methodsFor: 'testing' stamp: 'len 8/9/2019 13:25:28'!
isAlgebraHomomorphism
	"Answer true if the receiver is a (unital) K-algebra homomorphism,
	i.e. a ring homomorphism that satisfies f(ka) = kf(a)."
	| K codomainOne domainOne |
	self isRingHomomorphism ifFalse: [^ false].
	(K _ self domain scalars) = self codomain scalars ifFalse: [^ false].
	K isFinite ifFalse: [^ self error: 'infinite domain'].
	domainOne _ self domain one.
	codomainOne _ self codomain one.
	^ K allSatisfy: [:each| (self value: domainOne * each) = (codomainOne * each)]! !

!Map methodsFor: 'testing' stamp: 'len 1/29/2024 10:03:05'!
isBijective
	(self domain isFinite and: [self codomain isFinite]) ifTrue: [^ self domain size = self codomain size and: [self isSurjective]].
	^ self isInjective and: [self isSurjective]! !

!Map methodsFor: 'testing' stamp: 'len 4/15/2024 09:20:37'!
isEpimorphism
	"In the category of sets epimorphisms are surjections." 
	^ self isSurjective! !

!Map methodsFor: 'testing' stamp: 'len 5/19/2018 17:54:16'!
isEvaluable
	^ true! !

!Map methodsFor: 'testing' stamp: 'len 8/29/2024 15:30:13'!
isGroupHomomorphism
	self domain isFinite ifFalse: [^ self error: 'infinite domain'].
	^ self domain allSatisfy: [:x|
		self domain allSatisfy: [:y|
			| fxfy fxy |
			fxfy := self codomain isAbelianGroup ifTrue: [(self value: x)+(self value: y)] ifFalse: [(self value: x)·(self value: y)].
			fxy := self domain isAbelianGroup ifTrue: [self value: x+y] ifFalse: [self value: x·y].
			fxfy = fxy]]! !

!Map methodsFor: 'testing' stamp: 'len 4/5/2024 09:15:26'!
isIdentity
	^ self propertyAt: #isIdentity ifAbsentPut: [super isIdentity]! !

!Map methodsFor: 'testing' stamp: 'len 1/26/2024 16:37:06'!
isInjective
	(self domain isFinite and: [self codomain isFinite]) ifTrue: [^ self domain size <= self codomain size and: [self codomain allSatisfy: [:y| (self domain count: [:x| (self value: x) = y]) = 1]]].
	^ self retraction notNil! !

!Map methodsFor: 'testing' stamp: 'len 5/10/2019 07:38:30'!
isModuleHomomorphism
	(self domain isModule and: [self codomain isModule]) ifFalse: [^ false].
	self domain scalars = self codomain scalars ifFalse: [^ false].
	self domain isFinite ifFalse: [^ self error: 'infinite domain'].
	^ self domain allSatisfy: [:x|
		self domain allSatisfy: [:y|
			| z |
			(z _ self value: x) + (self value: y) = (self value: x + y) and:
				[self domain scalars allSatisfy: [:r| z * r = (self value: x * r)]]]]! !

!Map methodsFor: 'testing' stamp: 'len 8/29/2024 15:14:00'!
isMonoidHomomorphism
	self domain isFinite ifFalse: [^ self error: 'infinite domain'].
	^ self domain allSatisfy: [:x|
		self domain allSatisfy: [:y|
			(self value: x) · (self value: y) = (self value: x·y)]]! !

!Map methodsFor: 'testing' stamp: 'len 4/15/2024 09:20:07'!
isMonomorphism
	"In the category of sets monomorphisms are injections." 
	^ self isInjective! !

!Map methodsFor: 'testing' stamp: 'len 5/10/2019 07:34:08'!
isRingHomomorphism
	(self domain isRing and: [self codomain isRing]) ifFalse: [^ false].
	self domain isFinite ifFalse: [^ self error: 'infinite domain'].
	(self value: self domain one) = self codomain one ifFalse: [^ false].
	^ self domain allSatisfy: [:x|
		self domain allSatisfy: [:y|
			(self value: x) + (self value: y) = (self value: x + y) and:
				[(self value: x) * (self value: y) = (self value: x * y)]]]! !

!Map methodsFor: 'testing' stamp: 'len 1/29/2024 10:01:39'!
isSurjective
	self codomain isFinitelyGenerated ifTrue: [^ self codomain generators allSatisfy: [:each| self imageContains: each]].
	(self domain isFinite and: [self codomain isFinite]) ifTrue: [^ self domain size >= self codomain size and: [self codomain allSatisfy: [:y| self imageContains: y]]].
	^ self section notNil! !

!Map methodsFor: 'private' stamp: 'len 8/20/2024 10:59:16'!
images
	"Assuming the domain is finitely generated, answer the images of the generators under the receiver."
	^ self propertyAt: #images ifAbsentPut: [self domain generators collect: [:each| self value: each]]! !

!Map class methodsFor: 'examples' stamp: 'len 9/18/2022 07:15:42'!
example2Morphism1
	"This is the most common way to define morphisms.
	ℚ^3 is the vector space of 3-tuples with rational coefficients,
	and this defines a linear map on it (an endomorphism)
	by sending the message #to:map: to the vector space.
	This creates an instance of ModuleMap."
	^ ℚ^3 to: ℚ^3 map: [:v| (v x - v y, v x, v z)]! !

!Map class methodsFor: 'examples' stamp: 'len 8/19/2024 09:41:08'!
example2Morphism12
	"This, on the other hand, is a function on the underlying set of
	ℚ^3. Is is a morphism in the category of sets, but is not a morphism
	of vector spaces. This creates an instance of Function."
	^ (ℚ^3) underlyingSet to: (ℚ^3) underlyingSet map: [:v| (v x - v y, v x, v z)]! !

!Map class methodsFor: 'examples' stamp: 'len 10/5/2022 17:22:13'!
example2Morphism2
	"Here's another way to define the same morphism,
	by creating vector space Hom(Q^3, Q^3) of linear maps
	and sending the message #map: to it."
	^ ℚ^3 ⇒ (ℚ^3) map: [:v| (v x - v y, v x, v z)]! !

!Map class methodsFor: 'examples' stamp: 'len 10/5/2022 17:22:18'!
example2Morphism22
	"Or equivalently, creating Hom(Q^3, Q^3) and coercing
	a Smalltalk block into an element of the Hom vector space."
	^ ℚ^3 ⇒ (ℚ^3) !! [:v| (v x - v y, v x, v z)]! !

!Map class methodsFor: 'examples' stamp: 'len 5/23/2020 09:33:01'!
example2Morphism3
	"And yet another way. Here Hom(Q^3, Q^3) is created
	by sending the message #endomorphisms to the vector space."
	^ (ℚ^3) endomorphisms !! [:v| (v x - v y, v x, v z)]! !

!Map class methodsFor: 'examples' stamp: 'len 5/23/2020 09:34:55'!
example3Frobenius1
	"One way to define the Frobenius ring homomorphism."
	^ (ℤ / 6) endomorphisms !! [:x| x^6]! !

!Map class methodsFor: 'examples' stamp: 'len 9/16/2022 07:46:25'!
example3Frobenius2
	"The Frobenius ring homomorphism defined by a polynomial."
	| R x |
	R _ ℤ / 6.
	x _ R polynomials x.
	^ R endomorphisms map: x ^ 6! !

!Map class methodsFor: 'instance creation' stamp: 'len 6/1/2024 09:58:27'!
from: aDomain to: aCodomain map: aBlock
"	self assert: aBlock isBlock."
	^ self new domain: aDomain; codomain: aCodomain; propertyAt: #evaluable put: aBlock; yourself! !

!Map class methodsFor: 'instance creation' stamp: 'len 9/16/2022 07:09:10'!
from: aDomain to: aCodomain mapWithArguments: aBlock
	^ self from: aDomain to: aCodomain map: [:each| aBlock valueWithArguments: each asArray]! !

!Functor methodsFor: 'accessing' stamp: 'len 4/12/2024 04:51:52'!
category
	^ Cat! !

!Functor methodsFor: 'converting' stamp: 'len 6/7/2024 09:02:53'!
asPresheaf
	^ Presheaf functor: self! !

!Functor methodsFor: 'operations' stamp: 'len 6/7/2024 13:52:31'!
× aFunctor
	| P |
	self assert: self class = aFunctor class.
	P := self codomain × aFunctor codomain.
	^ self domain × aFunctor domain to: P map: [:f| P compose: {self value: (f at: 1). aFunctor value: (f at: 2)}]! !

!Functor methodsFor: 'operations' stamp: 'len 5/23/2024 15:20:23'!
cocones
	"Answer category of cocones under this diagram. Colimits are 'universal cocones' and correspond to initial objects.
	See #cones for the dual notion."
	^ self ↓ (self codomain Δ: self domain)! !

!Functor methodsFor: 'operations' stamp: 'len 6/2/2024 05:46:27'!
coend
	"If the receiver is a functor F : Cᵒᵖ × C → D, answer the coend of F."
	self notYetImplemented! !

!Functor methodsFor: 'operations' stamp: 'len 5/22/2024 04:35:31'!
colimit
	"A colimit of a diagram F : J → C is an object X of C equipped with morphisms F(j) → X for all objects j of J such that everything commutes, and it is the universal object with this property.
	A colimit of a diagram of shape J corresponds to:
		empty category -> initial object;
		discrete category -> coproduct;
		span -> pushout."
	^ self codomain colimitOf: self! !

!Functor methodsFor: 'operations' stamp: 'len 5/22/2024 10:02:28'!
cones
	"Answer category of cones over this diagram. Limits are 'universal cones' and correspond to terminal objects.
	A cone over a diagram F : J → C can be seen as an object X of C (the vertex, apex or summit of the cone) together with morphisms X → F(j) for each object j of J (the legs of the cone). A cone can also be seen as a natural transformation from Δ(X) to F where Δ(N) : J → C is the constant functor, or as an object in the comma category (Δ ↓ F) where Δ : C → [J,C] is the diagonal functor."
	^ (self codomain Δ: self domain) ↓ self! !

!Functor methodsFor: 'operations' stamp: 'len 6/4/2024 05:54:16'!
elements
	"Answer the category of elements El(F) of the receiver F.
	(This might only make sense for Set-valued presheaves.)"
	^ Cat terminalObject ↓ self! !

!Functor methodsFor: 'operations' stamp: 'len 6/2/2024 05:46:34'!
end
	"If the receiver is a functor F : Cᵒᵖ × C → D, answer the end of F."
	self notYetImplemented! !

!Functor methodsFor: 'operations' stamp: 'len 5/22/2024 04:33:59'!
limit
	"A limit of a diagram F : J → C is an object X of C equipped with morphisms X → F(j) for all objects j of J such that everything commutes, and it is the universal object with this property.
	A limit of a diagram of shape J corresponds to:
		empty category -> terminal object;
		discrete category -> product;
		cospan -> pullback."
	^ self codomain limitOf: self! !

!Functor methodsFor: 'operations' stamp: 'len 4/24/2024 16:02:25'!
opposite
	^ self domain opposite to: self codomain opposite map₀: [:x| (self value₀: x reverse) reverse] map: [:f| (self value: f reverse) reverse]! !

!Functor methodsFor: 'operations' stamp: 'len 6/23/2024 22:28:01'!
rightDerivedContravariantFunctor
	"If the receiver is a left-exact additive functor F : Aᵒᵖ → B, with A an abelian category with enough projectives and B an abelian category, answer the i-th right derived functor of the receiver."
	^ self domain opposite to: self codomain complexes map: [:f| (f projectiveResolution apply: self) homology]! !

!Functor methodsFor: 'operations' stamp: 'len 4/17/2024 11:11:35'!
rightDerivedFunctor
	"If the receiver is a left-exact additive functor F:A→B, with A an abelian category with enough injectives (and B preadditive), answer the i-th right derived functor of the receiver."
	^ self domain to: self codomain complexes map: [:f| (f injectiveResolution apply: self) homology]! !

!Functor methodsFor: 'operations' stamp: 'len 6/3/2024 09:39:09'!
value: aMorphism
	"Answer the value of the receiver at aMorphism.
	The argument must be either a morphism of the domain of the receiver or its opposite."
	| f answer block block₀ |
	f := aMorphism.
	(self domain includes: f) ifFalse: [f := f reverse. self assert: (self domain includes: f)].
	block := self propertyAt: #evaluable.
	answer := block argumentCount = 3
		ifTrue:
			[block₀ := self propertyAt: #evaluable₀.
			block value: (block₀ value: f domain) value: (block₀ value: f codomain) value: f]
		ifFalse:
			[block value: f].
	self assert: (self codomain includes: answer).
	^ answer

"	| answer images |
	self propertyAt: #evaluable ifPresent: [:aBlock| ^ aBlock value: aMorphism].
	answer := self codomain identity.
	images := self propertyAt: #images.
	self domain \ aMorphism keysAndValuesDo: [:i :e| answer := answer · ((images at: i) ^ e)].
	^ answer"! !

!Functor methodsFor: 'operations' stamp: 'len 6/3/2024 09:38:57'!
value₀: anObject
	"Answer the value of the receiver at anObject.
	The argument must be either an object of the domain of the receiver or its opposite."
	| x |
	x := anObject.
	(self domain includes₀: x) ifFalse: [x := x reverse. self assert: (self domain includes₀: x)].
	^ (self propertyAt: #evaluable₀ ifAbsent: [^ (self value: x id) domain]) value: x! !

!Functor methodsFor: 'operations' stamp: 'len 4/8/2024 13:27:42'!
↓ aFunctor
	"Answer the comma category (S ↓ T), where S is the receiver and T is the argument."
	self assert: self codomain = aFunctor codomain.
	^ CommaCategory source: self target: aFunctor! !

!Functor methodsFor: 'operations' stamp: 'len 6/3/2024 10:09:24'!
⊓ aFunctor
	| P |
	self checkDomainsMatch: aFunctor.
	P := self codomain ⊓ aFunctor codomain.
	^ self domain to: P map: [:x| P compose: {self  value: x. aFunctor value: x}]! !

!Functor methodsFor: 'operations' stamp: 'len 6/5/2024 17:42:39'!
⊗ aFunctor
	^ self × aFunctor! !

!Functor methodsFor: 'testing' stamp: 'len 6/2/2024 11:21:00'!
isEquivalence
	"Answer true if the receiver is an equivalence of categories."
	^ self isFullyFaithful and: [self isEssentiallySurjective]! !

!Functor methodsFor: 'testing' stamp: 'len 6/2/2024 11:21:40'!
isEssentiallyInjective
	^ self propertyAt: #isEssentiallyInjective ifAbsent: [false "undetermined"]! !

!Functor methodsFor: 'testing' stamp: 'len 6/2/2024 11:21:29'!
isEssentiallySurjective
	^ self propertyAt: #isEssentiallySurjective ifAbsent: [false "undetermined"]! !

!Functor methodsFor: 'testing' stamp: 'len 6/1/2024 09:25:49'!
isFaithful
	"A functor F : C → D is called 'faithful' if for each pair of objects x, y of C, the function induced in hom-sets Hom(x,y) → Hom(F(x),F(y)) is injective."
	^ self propertyAt: #isFaithful ifAbsent: [false "undetermined"]! !

!Functor methodsFor: 'testing' stamp: 'len 6/1/2024 09:26:12'!
isFull
	"A functor F : C → D is called 'full' if for each pair of objects x, y of C, the function induced in hom-sets Hom(x,y) → Hom(F(x),F(y)) is surjective."
	^ self propertyAt: #isFull ifAbsent: [false "undetermined"]! !

!Functor methodsFor: 'testing' stamp: 'len 6/1/2024 09:26:28'!
isFullyFaithful
	^ self isFull and: [self isFaithful]! !

!Functor methodsFor: 'transformations' stamp: 'len 6/7/2024 13:52:16'!
^ aCodomain
	"This is the exponential notation for the hom-set functor. See also #⇒."
	(aCodomain isKindOf: Transformation) ifTrue: [^ self asPresheaf ^ aCodomain].
	(aCodomain isKindOf: Functor) ifTrue: [^ self asPresheaf ^ aCodomain asPresheaf].
	^ super ^ aCodomain! !

!Functor methodsFor: 'transformations' stamp: 'len 5/30/2024 08:35:26'!
id
	^ self asPresheaf id! !

!Functor methodsFor: 'transformations' stamp: 'len 5/30/2024 08:22:07'!
to: aFunctor constant: aMorphism
	"Answer a natural transformation from the receiver to aFunctor with all components equal to aMorphism."
	^ self asPresheaf to: aFunctor asPresheaf constant: aMorphism! !

!Functor methodsFor: 'transformations' stamp: 'len 5/30/2024 08:22:50'!
to: aFunctor transform: aBlock
	"Answer a natural transformation from the receiver to aFunctor, defined by components by aBlock."
	^ self asPresheaf to: aFunctor asPresheaf transform: aBlock! !

!Functor methodsFor: 'transformations' stamp: 'len 6/26/2024 09:21:50'!
to: aFunctor transformWithArguments: aBlock
	"When the receiver is n-ary, this method allows to define morphisms by n-ary blocks."
	^ self to: aFunctor transform: [:each| aBlock valueWithArguments: each asArray]! !

!Functor methodsFor: 'transformations' stamp: 'len 6/7/2024 13:52:54'!
⇒ aCodomain
	"This is the internal hom or presheaf hom. See also #^."
	(aCodomain isKindOf: Transformation) ifTrue: [^ self asPresheaf ⇒ aCodomain].
	(aCodomain isKindOf: Functor) ifTrue: [self asPresheaf ⇒ aCodomain asPresheaf].
	"TODO: if the receiver is Hom(X,-), by Yoneda lemma Hom(X,-) ⇒ F can be computed as F(X)"
	^ super ⇒ aCodomain! !

!Functor methodsFor: 'private' stamp: 'len 7/8/2022 10:50:07'!
species
	^ Functor! !

!Functor class methodsFor: 'class initialization' stamp: 'len 6/10/2024 08:38:38'!
initialize
	| I T |
	super initialize.
	I := FreeCategory vertices: #().
	T := FreeCategory vertices: #(1).
	Cat​ := Category new
		propertyAt: #initialObject put: I;
		propertyAt: #terminalObject put: T;
		propertyAt: #isClosedMonoidal put: true;
		propertyAt: #isCartesianMonoidal put: true;
		"propertyAt: #unitObject put: T;"
		yourself.
	Cat propertyAt: #enrichmentBase put: Cat! !

!Functor class methodsFor: 'instance creation' stamp: 'len 4/19/2024 07:40:54'!
from: aDomain to: aCodomain images: anArray
	^ self new domain: aDomain; codomain: aCodomain; propertyAt: #images put: anArray; yourself! !

!Functor class methodsFor: 'instance creation' stamp: 'len 4/19/2024 07:38:22'!
from: aDomain to: aCodomain map₀: aBlock map: anotherBlock
	^ self new domain: aDomain; codomain: aCodomain; propertyAt: #evaluable₀ put: aBlock; propertyAt: #evaluable put: anotherBlock; yourself! !

!Function methodsFor: 'accessing' stamp: 'len 6/10/2024 08:45:47'!
carrierFunction
	^ self! !

!Function methodsFor: 'accessing' stamp: 'len 5/3/2024 05:00:47'!
category
	^ Sets! !

!Function methodsFor: 'accessing' stamp: 'len 6/10/2024 16:54:33'!
graph
	"Answer a list of ordered pairs x -> f(x) where x iterates over the domain."
	^ Iterator on: [:aBlock| self domain do: [:each| aBlock value: each -> (self value: each)]]! !

!Function methodsFor: 'operations' stamp: 'len 5/10/2024 05:22:15'!
× aFunction
	"Answer the cartesian product of the receiver with the argument."
	^ self domain × aFunction domain to: self codomain × aFunction codomain mapWithArguments: [:x :y| {self value: x. aFunction value: y}]! !

!Function methodsFor: 'operations' stamp: 'len 5/9/2024 15:50:19'!
coequalizer: aMorphism
	^ self notYetImplemented! !

!Function methodsFor: 'operations' stamp: 'len 5/10/2024 14:36:25'!
equalizer: aMorphism
	^ (self domain select: [:x| (self value: x) = (aMorphism value: x)]) into: self domain map: [:x| x]! !

!Function methodsFor: 'operations' stamp: 'len 5/10/2024 14:37:10'!
∧ aFunction
	"Answer the pullback of the receiver and the argument.
	The pullback is the limit of a cospan Y → X ← Z."
	self flag: #fixme. "add projections"
	^ self domain × aFunction domain select: [:each| (self value: (each at: 1)) = (aFunction value: (each at: 2))]! !

!Function methodsFor: 'operations' stamp: 'len 5/3/2024 06:30:39'!
⊓ aFunction
	self checkDomainsMatch: aFunction.
	^ self domain to: self codomain ⊓ aFunction codomain map: [:x| {self  value: x. aFunction value: x}]! !

!Function methodsFor: 'operations' stamp: 'len 5/3/2024 06:30:26'!
⊔ aFunction
	self checkCodomainsMatch: aFunction.
	^ self domain ⊔ aFunction domain to: self codomain mapWithArguments: [:i :x| (i = 1 ifTrue: [self] ifFalse: [aFunction]) value: x]! !

!Function methodsFor: 'operations' stamp: 'len 6/5/2024 17:43:30'!
⊗ aFunction
	^ self × aFunction! !

!Function methodsFor: 'private' stamp: 'len 5/3/2024 05:06:20'!
species
	^ Function! !

!Sequence methodsFor: 'accessing' stamp: 'len 6/4/2019 05:39:30'!
at: anInteger
	^ self at: anInteger ifAbsent: []! !

!Sequence methodsFor: 'accessing' stamp: 'len 5/28/2023 16:06:10'!
at: anInteger ifAbsent: aBlock
	^ self codomain !! (anInteger > 0 ifTrue: [super value: anInteger] ifFalse: [aBlock value])! !

!Sequence methodsFor: 'accessing' stamp: 'len 5/23/2020 09:34:55'!
codomain
	^ self propertyAt: #codomain ifAbsent: [ℤ]! !

!Sequence methodsFor: 'accessing' stamp: 'len 5/23/2020 09:30:12'!
domain
	^ self propertyAt: #domain ifAbsent: [ℕ]! !

!Sequence methodsFor: 'accessing' stamp: 'len 6/1/2019 08:33:57'!
scalars
	"For compatibility with tuples."
	^ self codomain! !

!Sequence methodsFor: 'accessing' stamp: 'len 11/8/2023 13:27:56'!
size
	^ self propertyAt: #size ifAbsent: [ℕ size]! !

!Sequence methodsFor: 'comparing' stamp: 'len 12/5/2015 01:11'!
beginsWith: aSequenceableCollection
	1 to: aSequenceableCollection size do: [:i| (self at: i) = (aSequenceableCollection at: i) ifFalse: [^ false]].
	^ true! !

!Sequence methodsFor: 'comparing' stamp: 'len 12/27/2015 01:29'!
equals: aSequence upTo: n
	^ self beginsWith: (aSequence copyFrom: 1 to: n)! !

!Sequence methodsFor: 'comparing' stamp: 'len 12/27/2015 03:56'!
hash
	^ (self at: 1) hash + (self at: 3) hash + (self at: 5) hash! !

!Sequence methodsFor: 'converting' stamp: 'len 12/2/2016 09:57:05'!
asStream
	^ ReadStream on: self! !

!Sequence methodsFor: 'copying' stamp: 'len 11/25/2022 06:53:04'!
copyFrom: start to: end
	end isInfinite ifTrue: [^ self >> (1 - start)].
	^ (start to: end) collect: [:i| self at: i]! !

!Sequence methodsFor: 'copying' stamp: 'len 4/20/2016 21:25'!
first: n
	^ self copyFrom: 1 to: n! !

!Sequence methodsFor: 'enumerating' stamp: 'len 9/16/2022 07:48:28'!
collect: aBlock
	^ self species map: [:i| aBlock value: (self at: i)]! !

!Sequence methodsFor: 'enumerating' stamp: 'len 4/25/2016 07:08'!
count: aBlock
	^ (self collect: [:each| (aBlock value: each) ifTrue: [1] ifFalse: [0]]) sum! !

!Sequence methodsFor: 'enumerating' stamp: 'len 12/27/2015 03:45'!
do: aBlock
	1 to: self size do: [:each| aBlock value: (self at: each)]! !

!Sequence methodsFor: 'enumerating' stamp: 'len 6/2/2019 04:31:06'!
findFirst: aBlock
	"Return the index of my first element for which aBlock evaluates as true."
	| index |
	index _ 0.
	[(aBlock value: (self at: (index _ index + 1))) ifTrue: [^ index]] repeat! !

!Sequence methodsFor: 'enumerating' stamp: 'len 9/16/2022 07:49:16'!
select: aBlock
	^ self species map: [:i|
		| k j value |
		k _ 1.
		j _ 1.
		[[aBlock value: (value _ self at: k)] whileFalse: [k _ k + 1]. j < i] whileTrue: [j _ j + 1. k _ k + 1].
		value]! !

!Sequence methodsFor: 'enumerating' stamp: 'len 3/27/2016 04:44'!
withIndexDo: aBlock
	| i |
	i _ 1.
	self do: [:each| aBlock value: each value: i. i _ i + 1]! !

!Sequence methodsFor: 'operations' stamp: 'len 9/16/2022 08:03:40'!
* anObject
	^ (self codomain includes: anObject)
		ifTrue: [self species to: self codomain map: [:n| (self at: n) * anObject]]
		ifFalse: [self species to: self codomain map: [:n| (self at: n) * (anObject at: n)]]! !

!Sequence methodsFor: 'operations' stamp: 'len 9/16/2022 08:03:47'!
+ anObject
	^ (self codomain includes: anObject)
		ifTrue: [self species to: self codomain map: [:n| (self at: n) + anObject]]
		ifFalse: [self species to: self codomain map: [:n| (self at: n) + (anObject at: n)]]! !

!Sequence methodsFor: 'operations' stamp: 'len 5/6/2019 03:53:45'!
- anObject
	^ self + anObject negated! !

!Sequence methodsFor: 'operations' stamp: 'len 5/6/2019 03:51:55'!
/ anObject
	^ self * anObject reciprocal! !

!Sequence methodsFor: 'operations' stamp: 'len 6/1/2019 08:29:43'!
<< anInteger
	^ self >> anInteger negated! !

!Sequence methodsFor: 'operations' stamp: 'len 9/16/2022 08:03:52'!
>> anInteger
	^ self species to: self codomain map: [:i| self at: i-anInteger ifAbsent: [self codomain zero]]! !

!Sequence methodsFor: 'operations' stamp: 'len 9/16/2022 08:03:57'!
average
	^ self species to: self codomain map: [:N| ((1 to: N) sum: [:n| self at: n]) / N]! !

!Sequence methodsFor: 'operations' stamp: 'len 9/16/2022 08:04:06'!
backwardDifference: n at: h
	^ self species
		to: self codomain
		map: [:x| (0 to: n) sum: [:i| (-1)^i * (n choose: i) * (self at: x + (i*h))]]! !

!Sequence methodsFor: 'operations' stamp: 'len 9/16/2022 08:04:21'!
binomialInverseTransform
	^ self species to: self codomain map: [:n| (0 to: n-1) sum: [:k| (n-1 choose: k) * (self at: k+1)]]! !

!Sequence methodsFor: 'operations' stamp: 'len 9/16/2022 08:04:27'!
binomialTransform
	"The binomial transform is its own inverse, it's an involution."
	^ self species to: self codomain map: [:n| (0 to: n-1) sum: [:k| (-1)^(n-1-k) * (n-1 choose: k) * (self at: k+1)]]! !

!Sequence methodsFor: 'operations' stamp: 'len 9/16/2022 08:04:38'!
centralDifference: n at: h
	^ self species
		to: self codomain
		map: [:x| (0 to: n) sum: [:i| (-1)^i * (n choose: i) * (self at: x + ((n/2 - i)*h))]]! !

!Sequence methodsFor: 'operations' stamp: 'len 9/16/2022 08:04:43'!
convolution: aSequence
	^ self species to: self codomain map: [:n| (0 to: n-1) sum: [:i| (self at: 1+i) * (aSequence at: n-i)]]! !

!Sequence methodsFor: 'operations' stamp: 'len 6/1/2019 08:31:04'!
difference
	"Answer the 'difference' sequence of the receiver, or delta, or discrete derivative."
	^ (self << 1) - self! !

!Sequence methodsFor: 'operations' stamp: 'len 9/16/2022 08:04:50'!
dirichlet: aSequence
	"Answer the Dirichlet convolution of the receiver with the argument, assuming both are arithmetic functions (i.e. functions from the natural numbers to the complex numbers).
	The set of arithmetic functions form a commutative ring (the Dirichlet ring) under pointwise addition and Dirichlet convolution."
	^ self species to: self codomain map: [:n| n divisors sum: [:d| (self at: d) * (aSequence at: n/d)]]! !

!Sequence methodsFor: 'operations' stamp: 'len 9/16/2022 08:05:10'!
forwardDifference: n at: h
	^ self species
		to: self codomain
		map: [:x| (0 to: n) sum: [:i| (-1)^(n-i) * (n choose: i) * (self at: x + ((n-i)*h))]]! !

!Sequence methodsFor: 'operations' stamp: 'len 9/16/2022 08:05:23'!
moebiusInverse
	"This is equivalent to the Dirichlet convolution of the Moebius arithmetic function with the receiver.
	If f(n) and g(n) are two arithmetic functions satisfying g = f * 1 (Dirichlet convolution of f with the constant function 1), then the Moebius inversion formula can be used to retrieve f as f = mu * g. It is said that f and g and Moebius transforms of each other."
	^ self species to: self codomain map: [:n| n divisors sum: [:d| d moebius * (self at: n/d)]]! !

!Sequence methodsFor: 'operations' stamp: 'len 9/16/2022 08:05:29'!
negated
	^ self species to: self codomain map: [:n| (self at: n) negated]! !

!Sequence methodsFor: 'operations' stamp: 'len 9/16/2022 08:05:34'!
product
	"Answer the indefinite product of the receiver."
	^ self species to: self codomain map: [:i| (1 to: i) collect: [:k| self at: k] andFold: [:a :b| a*b]]! !

!Sequence methodsFor: 'operations' stamp: 'len 9/16/2022 08:05:39'!
reciprocal
	^ self species to: self codomain map: [:n| (self at: n) reciprocal]! !

!Sequence methodsFor: 'operations' stamp: 'len 5/6/2019 03:54:25'!
squared
	^ self * self! !

!Sequence methodsFor: 'operations' stamp: 'len 9/16/2022 08:05:45'!
stirlingInverseTransform
	^ self species to: self codomain map: [:n| (1 to: n) sum: [:k| (n stirling: k) * (self at: k)]]! !

!Sequence methodsFor: 'operations' stamp: 'len 9/16/2022 08:05:50'!
stirlingTransform
	^ self species to: self codomain map: [:n| (1 to: n) sum: [:k| (n Stirling: k) * (self at: k)]]! !

!Sequence methodsFor: 'operations' stamp: 'len 9/16/2022 08:05:55'!
sum
	"Answer the indefinite sum of the receiver."
	^ self species to: self codomain map: [:i| (1 to: i) sum: [:k| self at: k]]! !

!Sequence methodsFor: 'operations' stamp: 'len 12/4/2015 04:00'!
value: aNumber
	^ self at: aNumber asInteger! !

!Sequence methodsFor: 'printing' stamp: 'len 12/28/2016 11:13:18'!
printLimit
	^ self propertyAt: #printLimit ifAbsent: [17]! !

!Sequence methodsFor: 'printing' stamp: 'len 12/28/2016 11:13:57'!
printLimit: anInteger
	self propertyAt: #printLimit put: anInteger! !

!Sequence methodsFor: 'printing' stamp: 'len 6/4/2019 05:30:08'!
printOn: aStream
	(1 to: self printLimit) do: [:i| aStream print: (self at: i)] separatedBy: [aStream nextPutAll:', ' ].
	aStream nextPutAll: '...'! !

!Sequence methodsFor: 'printing' stamp: 'len 4/26/2016 06:46'!
printOn: aStream base: base
	(1 to: self printLimit) do: [:i| (self at: i) printOn: aStream base: base] separatedBy: [aStream nextPutAll:', ' ].
	aStream nextPutAll: '...'! !

!Sequence methodsFor: 'printing' stamp: 'len 4/26/2016 06:47'!
printStringBase: base
	^ String streamContents:
		[:aStream| self printOn: aStream base: base]! !

!Sequence methodsFor: 'private' stamp: 'len 12/3/2015 20:34'!
species
	^ Sequence! !

!Sequence class methodsFor: 'examples' stamp: 'len 9/16/2022 07:48:03'!
Omega
	"Number of prime divisors of n counted with multiplicity. A001222."
	^ Sequence map: [:n| n factorization size]! !

!Sequence class methodsFor: 'examples' stamp: 'len 9/16/2022 07:48:08'!
aliquot
	"This is the aliquot function a(n) or s(n).
	It is the sum of the proper divisors of n (aliquot parts of n).
	If a(n) = n, n is a perfect number. If a(n) = n - 1, it is almost perfect. If a(n) > n, it is an abundant number."
	^ Sequence map: [:n| n divisors sum - n]! !

!Sequence class methodsFor: 'examples' stamp: 'len 9/16/2022 07:48:13'!
bbs: s p: p q: q
	"Answer the Blum Blum Shub sequence for the given parameters."
	| lambda m |
	lambda _ p - 1 lcm: q - 1.
	m _ p * q.
	^ self map: [:i| s raisedTo: (2 raisedTo: i modulo: lambda) modulo: m]! !

!Sequence class methodsFor: 'examples' stamp: 'len 9/16/2022 07:48:17'!
bellNumbers
	"The Bell numbers."
	^ Sequence map: [:n| (0 to: n-1) sum: [:k| n-1 Stirling: k]]! !

!Sequence class methodsFor: 'examples' stamp: 'len 5/23/2020 09:33:01'!
bernoulli
	"This is the sequence of Bernoulli numbers (starting at 1), computed via a recurrence."
	^ Sequence to: ℚ initialValues: #(1) recurrence: [:f :n| (n>4 and: [n even]) ifTrue: [0] ifFalse: [((0 to: n-2) sum: [:k| (n choose: k) * (f at: k+1)]) / n negated]]! !

!Sequence class methodsFor: 'examples' stamp: 'len 9/16/2022 08:04:32'!
calkinWilf
	"The Calkin-Wilf sequence.
	It enumerates the positive rational numbers by a breadth-first traversal of the Calkin-Wilf tree."
	^ Sequence
		to: ℚ
		map:
			[:n| | q |
			q _ 1.
			n-1 timesRepeat: [q _ 1 / (2 * q floor - q + 1)].
			q]! !

!Sequence class methodsFor: 'examples' stamp: 'len 9/16/2022 07:48:22'!
catalanNumbers
	"The Catalan numbers."
	^ Sequence map: [:n| (2*(n-1) choose: n-1) / n]! !

!Sequence class methodsFor: 'examples' stamp: 'len 2/22/2017 08:26:11'!
fibonacci
	"The Fibonacci sequence defined as a recurrence."
	^ Sequence initialValues: #(0 1) recurrence: [:f :n| (f at: n-1) + (f at: n-2)]! !

!Sequence class methodsFor: 'examples' stamp: 'len 9/16/2022 08:05:16'!
harmonicNumbers
	"The harmonic numbers."
	^ Sequence to: ℚ map: [:n| (1 to: n) sum: [:k| 1/k]]! !

!Sequence class methodsFor: 'examples' stamp: 'len 5/1/2024 12:27:07'!
hensel: aPolynomial at: anIntegerRoot mod: p
	"Answer the p-adic expansion by Hensel lemma."
	| x |
	x := aPolynomial species x.
	^ self recurrence:
		[:f :n|
		n = 1
			ifTrue: [anIntegerRoot]
			ifFalse:
				[| g a |
				g := (f at: n-1) + (p^(n-1) * x).
				a := (aPolynomial value: g % (p^n)) roots any representative.
				(g value: a) \\ (p^n)]]! !

!Sequence class methodsFor: 'examples' stamp: 'len 2/22/2017 08:38:27'!
highlyCompositeNumbers
	"The sequence of highly composite numbers."
	^ Sequence recurrence: [:f :n| | i max |
		n = 1
			ifTrue: [1]
			ifFalse:
				[i _ f at: n-1.
				max _ i numberOfDivisors.
				[(i _ i + 1) numberOfDivisors > max] whileFalse. i]]! !

!Sequence class methodsFor: 'examples' stamp: 'len 9/16/2022 07:48:33'!
id
	"The identity sequence."
	^ Sequence map: [:n| n]! !

!Sequence class methodsFor: 'examples' stamp: 'len 9/16/2022 07:48:39'!
liouville
	"The Liouville function."
	| Omega |
	Omega _ Sequence Omega.
	^ Sequence map: [:n| (-1) ^ (Omega at: n)]! !

!Sequence class methodsFor: 'examples' stamp: 'len 5/1/2024 12:27:13'!
mangoldt
	"The von Mangoldt function (float)."
	^ Sequence map: [:n| | factors | factors := n factorization. factors asSet size = 1 ifTrue: [factors any ln] ifFalse: [0]]! !

!Sequence class methodsFor: 'examples' stamp: 'len 5/1/2024 12:27:18'!
mangoldt2
	"The log2 von Mangoldt function."
	^ Sequence map: [:n| | factors | factors := n factorization. factors asSet size = 1 ifTrue: [factors any highBit] ifFalse: [0]]! !

!Sequence class methodsFor: 'examples' stamp: 'len 9/16/2022 07:48:55'!
moebius
	"The Moebius function mu(n).
	This is 0 if n is squarefree, and (-1)^k otherwise (where k is the number of prime factors counted with multiplicity)."
	^ Sequence map: [:n| n moebius]! !

!Sequence class methodsFor: 'examples' stamp: 'len 9/16/2022 07:49:01'!
omega
	"Number of distinct primes dividing n. A001221."
	^ Sequence map: [:n| n factorization asSet size]! !

!Sequence class methodsFor: 'examples' stamp: 'len 2/22/2017 08:38:14'!
one
	"The constant sequence that is always 1."
	^ Sequence constant: 1! !

!Sequence class methodsFor: 'examples' stamp: 'len 9/16/2022 07:49:06'!
partitions
	"The partition function p(n) = number of partition of n. OEIS A000041."
	^ Sequence map: [:n| n partitions size]! !

!Sequence class methodsFor: 'examples' stamp: 'len 9/16/2022 07:49:10'!
phi
	"Euler's totient function."
	^ Sequence map: [:n| n phi]! !

!Sequence class methodsFor: 'examples' stamp: 'len 6/1/2019 13:35:39'!
primeGaps
	"The sequence of prime gaps.
	This is p(n+1) - p(n), the difference between concecutive primes."
	| p |
	p _ 2.
	^ Sequence streaming: [p negated + (p _ p nextPrime)]
"	^ Sequence primes difference"! !

!Sequence class methodsFor: 'examples' stamp: 'len 9/18/2022 07:13:38'!
primes
	"The sequence of primes."
	^ Sequence initialValues: #(2) recurrence: [:f :i| (f at: i-1) nextPrime]
"	^ Sequence map: [:i|
		| n count |
		n _ 2.
		count _ 1.
		[count = i] whileFalse: [n _ n nextPrime. count _ count + 1].
		n]"! !

!Sequence class methodsFor: 'examples' stamp: 'len 9/16/2022 07:49:21'!
sigma
	"The sigma(n) function, defined as the sum of the positive divisors of n.
	The number n is said to be a perfect number iff sigma(n) = 2*n."
	^ Sequence map: [:n| n divisors sum]! !

!Sequence class methodsFor: 'examples' stamp: 'len 9/16/2022 07:49:26'!
sigma: x
	"Answer the sigma(x,n) function."
	^ Sequence map: [:n| n divisors sum: [:d| d^x]]! !

!Sequence class methodsFor: 'examples' stamp: 'len 9/16/2022 07:49:31'!
tau
	"Number of divisors of n, also called d(n) and sigma_O(n). A000005."
	^ Sequence map: [:n| n divisors size]! !

!Sequence class methodsFor: 'intance creation' stamp: 'len 4/5/2024 19:02:16'!
constant: anInteger
	self assert: anInteger isInteger.
	^ self to: ℤ constant: anInteger! !

!Sequence class methodsFor: 'intance creation' stamp: 'len 5/23/2020 09:34:55'!
dynamic: aBlock
	^ self to: ℤ dynamic: aBlock! !

!Sequence class methodsFor: 'intance creation' stamp: 'len 5/23/2020 09:34:55'!
initialValues: anArray recurrence: aBinaryBlock
	^ self to: ℤ initialValues: anArray recurrence: aBinaryBlock! !

!Sequence class methodsFor: 'intance creation' stamp: 'len 9/16/2022 07:51:39'!
map: aBlock
	^ self to: ℤ map: aBlock! !

!Sequence class methodsFor: 'intance creation' stamp: 'len 10/10/2016 21:08'!
recurrence: aBinaryBlock
	^ self initialValues: #() recurrence: aBinaryBlock! !

!Sequence class methodsFor: 'intance creation' stamp: 'len 5/23/2020 09:34:55'!
streaming: aBlock
	^ self to: ℤ streaming: aBlock! !

!Sequence class methodsFor: 'intance creation' stamp: 'len 5/7/2024 08:11:19'!
to: aCodomain constant: anObject
	^ self to: aCodomain map: [:n| anObject]! !

!Sequence class methodsFor: 'intance creation' stamp: 'len 9/16/2022 08:06:16'!
to: aDomain dynamic: aBlock
	^ self to: aDomain map:
		[:n| | x |
		x _ 0.
		n timesRepeat: [x _ aBlock value: x].
		x]! !

!Sequence class methodsFor: 'intance creation' stamp: 'len 9/16/2022 08:06:28'!
to: aDomain initialValues: anArray recurrence: aBlock
	| cache |
	cache _ OrderedCollection withAll: anArray.
	^ self to: aDomain map:
		[:n|
		"(n isInteger and: [n > 0]) ifFalse: [DomainError signal]."
		[cache size < n] whileTrue: [cache add: (aBlock value: cache value: cache size + 1)].
		cache at: n]! !

!Sequence class methodsFor: 'intance creation' stamp: 'len 9/16/2022 07:37:12'!
to: aDomain map: aBlock
	^ self from: ℕ to: aDomain map: aBlock! !

!Sequence class methodsFor: 'intance creation' stamp: 'len 10/10/2016 21:08'!
to: aDomain recurrence: aBlock
	^ self to: aDomain initialValues: #() recurrence: aBlock! !

!Sequence class methodsFor: 'intance creation' stamp: 'len 9/16/2022 08:06:38'!
to: aDomain streaming: aBlock
	| cache |
	cache _ OrderedCollection new.
	^ self to: aDomain map:
		[:n|
		"(n isInteger and: [n > 0]) ifFalse: [DomainError signal]."
		[cache size < n] whileTrue: [cache add: aBlock value].
		cache at: n]! !

!GroupAction methodsFor: 'accessing' stamp: 'len 6/29/2016 08:46'!
degree
	^ self space size! !

!GroupAction methodsFor: 'accessing' stamp: 'len 2/13/2016 06:31'!
fixedPoints
	^ self space select: [:each| self isFixedPoint: each]! !

!GroupAction methodsFor: 'accessing' stamp: 'len 6/22/2016 07:36'!
fixedPointsOf: anElement
	"Dual idea to the stabilizer. The fixed points are the orbits of size 1."
	^ self space select: [:each| (self value: {anElement. each}) = each]! !

!GroupAction methodsFor: 'accessing' stamp: 'len 5/2/2024 06:57:31'!
group
	^ self propertyAt: #group! !

!GroupAction methodsFor: 'accessing' stamp: 'len 12/5/2023 16:08:49'!
kernel
	"This is also the intersection of all the stabilizers."
	^ self group select: [:g| self space allSatisfy: [:x| (self value: {g.x}) = x]]
	"^ self asRepresentation kernel"! !

!GroupAction methodsFor: 'accessing' stamp: 'len 12/5/2023 16:13:01'!
orbitOf: aPoint
	"Answer the set of points to which aPoint can be 'moved' by elements of the group G.
	All the orbits form a partition of the underlying set (space) X, and it's written X/G and called the quotient of the action. In geometric situations it may be called the orbit space, and in algebraic situations it is called the space of coinvariants (in contrast with the space of invariants, that are the fixed points)."
	| answer |
	self group generators ifNotNil: [:S| ^ (SchreierTree root: aPoint generators: S action: self) orbit].
	answer := Set new.
	self group do: [:each| answer add: (self value: {each. aPoint})].
	^ answer! !

!GroupAction methodsFor: 'accessing' stamp: 'len 12/11/2023 20:14:39'!
orbits
	"Answer the quotient of the action, also called space of orbits in geometric situations and space of coinvariants in algebraic situations."
	^ Iterator on: self performing: #orbitsDo:! !

!GroupAction methodsFor: 'accessing' stamp: 'len 12/6/2023 10:22:20'!
orbitsDo: aBlock
	"Iterate over the quotient of the action, also called space of orbits in geometric situations and space of coinvariants in algebraic situations."
	| orbits |
	orbits := OrderedCollection new.
	self space do: [:each| (orbits anySatisfy: [:any| any includes: each]) ifFalse: [aBlock value: (orbits add: (self orbitOf: each))]]! !

!GroupAction methodsFor: 'accessing' stamp: 'len 12/11/2023 10:45:17'!
reynolds
	"Answer the Reynolds operator, assuming the group acts on a polynomial ring S.
	Properties:
	- K-linear map S → S^G (it's the G-invariant projection from S to S^G;
	- restricts to the identity on S^G;
	- it's an S^G-module homomorphisms: R(p*q) = p*R(q) for all invariants p in S^G."
	| n |
	n := self group size.
	^ self space to: self space map: [:p| (self group sum: [:g| self value: {g. p}]) / n]! !

!GroupAction methodsFor: 'accessing' stamp: 'len 5/3/2024 05:32:53'!
space
	^ self propertyAt: #space! !

!GroupAction methodsFor: 'accessing' stamp: 'len 12/5/2023 16:11:39'!
stabilizerOf: aPoint
	"Answer the stabilizer subgroup (or isotropy group or little group) of aPoint, defined as the set of elements that 'fix' aPoint. The stabilizer of fixed points is the whole group, and the kernel of the action homomorphism G → Sym(X) is the intersection of all stabilizers."
	self group generators ifNotNil: [:S| ^ (SchreierTree root: aPoint generators: S action: self) stabilizer].
	^ self group select: [:each| (self value: {each. aPoint}) = aPoint]! !

!GroupAction methodsFor: 'converting' stamp: 'len 9/16/2022 08:08:54'!
asRepresentation
	^ self group
		to: self space automorphisms
		map: [:g| self space to: self space map: [:x| self value: {g.x}]]! !

!GroupAction methodsFor: 'graphs' stamp: 'len 3/24/2021 09:25:28'!
actionGraph
	"Answer the action diagram with respect to the group generators.
	This is similar to a Cayley diagram.
	The connected components of the action diagram are the orbits of the action."
	^ self actionGraph: self group generators! !

!GroupAction methodsFor: 'graphs' stamp: 'len 5/25/2016 03:45'!
actionGraph: groupGenerators
	"Answer the action diagram with respect to the given group generators.
	This is similar to a Cayley diagram.
	The connected components of the action diagram are the orbits of the action."
	| G |
	self space isFinite ifFalse: [^ self error: 'not a finite space'].
	G _ Digraph unorderedLabeled.
	groupGenerators do: [:g|
		self space do: [:x|
			G addEdgeFrom: x to: (self value: {g.x}) label: g]].
	^ G! !

!GroupAction methodsFor: 'testing' stamp: 'len 6/29/2023 19:45:50'!
isFaithful
	"A group action G × X → X is faithful (or effective) if the homomorphism G → Sym(X) has trivial kernel {id}."
	^ self propertyAt: #isFaithful ifAbsentPut: [self kernel isTrivial]! !

!GroupAction methodsFor: 'testing' stamp: 'len 12/6/2023 10:25:15'!
isFixedPoint: aPoint
	"Answer true if the argument is a fixed point of the receiver."
	^ (self group generators ifNil: [self group]) allSatisfy: [:each| (self value: {each. aPoint}) = aPoint]! !

!GroupAction methodsFor: 'testing' stamp: 'len 7/27/2016 07:34'!
isImprimitive
	^ self isPrimitive not! !

!GroupAction methodsFor: 'testing' stamp: 'len 12/6/2023 10:26:37'!
isIntransitive
	^ self isTransitive not! !

!GroupAction methodsFor: 'testing' stamp: 'len 7/27/2016 07:36'!
isPrimitive
	^ self orbits allSatisfy: [:each| each size = 1 or: [each size = self space size]]! !

!GroupAction methodsFor: 'testing' stamp: 'len 5/1/2024 12:27:24'!
isRegular
	^ self isTransitive and: [(self stabilizerOf: self space any) isTrivial]! !

!GroupAction methodsFor: 'testing' stamp: 'len 12/6/2023 10:23:32'!
isTransitive
	^ self orbits isSingleton! !

!GroupAction class methodsFor: 'as yet unclassified' stamp: 'len 8/19/2024 09:41:08'!
from: aGroup on: anObject action: aBlock
	^ (self from: aGroup underlyingSet × anObject underlyingSet to: anObject underlyingSet mapWithArguments: aBlock)
		propertyAt: #group put: aGroup;
		propertyAt: #space put: anObject;
		yourself! !

!BilinearMap methodsFor: 'as yet unclassified' stamp: 'len 10/5/2022 17:22:24'!
left
	"Answer the linear map that fixes the first argument."
	| X Y Z |
	X _ self domain at: 1.
	Y _ self domain at: 2.
	Z _ self codomain.
	^ X to: Y ⇒ Z map: [:x| Y to: Z map: [:y| self value: x value: y]]! !

!BilinearMap methodsFor: 'as yet unclassified' stamp: 'len 10/5/2022 17:22:28'!
right
	"Answer the linear map that fixes the second argument."
	| X Y Z |
	X _ self domain at: 1.
	Y _ self domain at: 2.
	Z _ self codomain.
	^ Y to: X ⇒ Z map: [:y| X to: Z map: [:x| self value: x value: y]]! !

!BilinearMap methodsFor: 'as yet unclassified' stamp: 'len 7/14/2020 07:31:45'!
table
	^ self propertyAt: #table! !

!BilinearMap methodsFor: 'as yet unclassified' stamp: 'len 7/14/2020 07:31:36'!
table: anArray
	self propertyAt: #table put: anArray! !

!BilinearMap methodsFor: 'as yet unclassified' stamp: 'len 7/14/2020 07:01:41'!
value: anArray
	self assert: anArray size = 2.
	^ self value: anArray first value: anArray second! !

!BilinearMap methodsFor: 'as yet unclassified' stamp: 'len 12/12/2023 20:04:53'!
value: anElement value: anotherElement
	| v w t |
	v := (self domain at: 1) \ anElement.
	w := (self domain at: 2) \ anotherElement. 
	t := self codomain freeCover zero.
	self table withIndexDo: [:ai :i|
		ai withIndexDo: [:aij :j|
			t := (aij collect: [:each| (v at: i) * each * (w at: j)]) + t]].
	^ self codomain elementAt: t! !

!BilinearMap methodsFor: 'as yet unclassified' stamp: 'len 11/5/2022 13:32:01'!
⊕ aBilinearMap
	"Answer the direct sum of the receiver and the argument."
	| domain |
	((self domain at: 1) = (self domain at: 2) and: [(aBilinearMap domain at: 1) = (aBilinearMap domain at: 2)])
		ifTrue: [domain _ (self domain at: 1) ⊕ (aBilinearMap domain at: 1).
			domain _ domain, domain]
		ifFalse: [domain _ (self domain at: 1) ⊕ (aBilinearMap domain at: 1), ((self domain at: 2) ⊕ (aBilinearMap domain at: 2))].
	^ self class
		from: domain
		to: self codomain ⊕ aBilinearMap codomain
		mapWithArguments: [:x :y| self notYetImplemented]! !

!BilinearMap class methodsFor: 'instance creation' stamp: 'len 9/16/2022 07:33:09'!
from: aDomain to: aCodomain map: aBlock
	^ self from: aDomain to: aCodomain mapWithArguments: [:x :y| aBlock value: {x. y}]! !

!BilinearMap class methodsFor: 'instance creation' stamp: 'len 9/16/2022 07:33:33'!
from: aDomain to: aCodomain mapWithArguments: aBlock
	| table |
	table _ aDomain components first generators collect: [:x| aDomain components second generators collect: [:y| aCodomain \ (aBlock value: x value: y)]].
	^ self from: aDomain to: aCodomain table: table! !

!BilinearMap class methodsFor: 'instance creation' stamp: 'len 7/14/2020 07:31:21'!
from: aDomain to: aCodomain table: anArray
	^ self new domain: aDomain; codomain: aCodomain; table: anArray! !

!BilinearMap class methodsFor: 'instance creation' stamp: 'len 9/16/2022 07:32:04'!
on: aModule map: aBlock
	^ self on: aModule mapWithArguments: [:x :y| aBlock value: {x. y}]! !

!BilinearMap class methodsFor: 'instance creation' stamp: 'len 9/16/2022 07:32:22'!
on: aModule mapWithArguments: aBlock
	^ self from: (aModule, aModule) to: aModule mapWithArguments: aBlock! !

!BilinearMap class methodsFor: 'instance creation' stamp: 'len 7/14/2020 07:35:34'!
on: aModule table: anArray
	^ self from: (aModule, aModule) to: aModule table: anArray! !

!BilinearForm methodsFor: 'accessing' stamp: 'len 12/28/2015 21:09'!
bitSize
	^ matrix bitSize! !

!BilinearForm methodsFor: 'accessing' stamp: 'len 1/8/2016 06:36'!
codomain
	^ self scalars! !

!BilinearForm methodsFor: 'accessing' stamp: 'len 8/19/2024 09:41:08'!
domain
	^ space underlyingSet × space underlyingSet! !

!BilinearForm methodsFor: 'accessing' stamp: 'len 11/7/2015 23:26'!
matrix
	^ matrix! !

!BilinearForm methodsFor: 'accessing' stamp: 'len 7/28/2020 19:33:13'!
scalars
	^ space scalars! !

!BilinearForm methodsFor: 'accessing' stamp: 'len 7/29/2020 06:30:58'!
space
	^ space! !

!BilinearForm methodsFor: 'comparing' stamp: 'len 7/28/2020 19:32:00'!
= anObject
	^ self class = anObject class and: [space = anObject space and: [matrix = anObject matrix]]! !

!BilinearForm methodsFor: 'comparing' stamp: 'len 7/27/2020 19:20:48'!
hash
	^ matrix hash! !

!BilinearForm methodsFor: 'converting' stamp: 'len 11/23/2022 21:27:07'!
asPolynomial
	| n P x y |
	n _ matrix height.
	P _ self scalars polynomialsIn: ((1 to: n) collect: [:i| 'x' asText, i printString sub]), ((1 to: n) collect: [:i| 'y', i printString sub]).
	x _ P^n fill: [:i| P x: i].
	y _ P^n fill: [:i| P x: n+i].
	^ x · ((matrix over: P) * y)! !

!BilinearForm methodsFor: 'converting' stamp: 'len 7/28/2020 19:32:47'!
depolarization
	"Answer the associated quadratic form Q(v) := B(v,v)."
	^ QuadraticForm from: space gramian: matrix! !

!BilinearForm methodsFor: 'initialization' stamp: 'len 8/23/97 15:35'!
matrix: aMatrix
	matrix _ aMatrix! !

!BilinearForm methodsFor: 'initialization' stamp: 'len 7/28/2020 19:33:47'!
space: aFreeModule
	space _ aFreeModule! !

!BilinearForm methodsFor: 'operations' stamp: 'len 7/28/2020 19:32:35'!
* anObject
	^ self class on: space matrix: matrix * anObject! !

!BilinearForm methodsFor: 'operations' stamp: 'len 9/16/2022 08:18:49'!
+ aBilinearForm
	space == aBilinearForm space ifTrue: [^ self class on: space matrix: matrix + aBilinearForm matrix].
	space = aBilinearForm space ifFalse: [^ self error: 'domains don''t match'].
	^ self class on: space map: [:each| (self value: each) + (aBilinearForm value: each)]! !

!BilinearForm methodsFor: 'operations' stamp: 'len 7/28/2020 09:38:10'!
automorphisms
	"Answer the orthogonal group consisting of the self-isometries with respect to the receiver."
	^ self depolarization automorphisms! !

!BilinearForm methodsFor: 'operations' stamp: 'len 11/23/2022 21:27:18'!
gramianOf: anArray
	"Answer the Gramian matrix of the vectors in anArray."
	^ (self scalars^anArray size) endomorphisms fill: [:i :j| self value: (anArray at: i) value: (anArray at: j)]! !

!BilinearForm methodsFor: 'operations' stamp: 'len 5/1/2024 10:29:51'!
left
	"Answer the linear map from the space to its dual that fixes the right argument. If the bilinear form is non-degenerate, this map is an isomorphism."
	| V L |
	V := space.
	L := V dual.
	^ V to: L map: [:v| L map: [:w| self value: w value: v]]! !

!BilinearForm methodsFor: 'operations' stamp: 'len 1/8/2016 06:06'!
leftRadical
	^ self left kernel! !

!BilinearForm methodsFor: 'operations' stamp: 'len 7/28/2020 19:33:08'!
negated
	^ self class on: space matrix: matrix negated! !

!BilinearForm methodsFor: 'operations' stamp: 'len 7/21/2020 18:37:25'!
orthogonalizationOf: aCollection
	"Answer an orthogonalization of the given basis.
	Perform the Gram-Schmidt orthogonalization process."
	| answer norms u uv |
	answer _ OrderedCollection new: aCollection size.
	norms _ OrderedCollection new: aCollection size.
	aCollection do: [:each|
		u _ each.
		answer with: norms do: [:v :vv|
			uv _ self value: u value: v.
			u _ u - (v * uv / vv)].
		answer add: u.
		norms add: (self value: u value: u)].
	^ answer! !

!BilinearForm methodsFor: 'operations' stamp: 'len 7/6/2020 11:36:32'!
radical
	"Assuming the receiver is symmetric, answer the radical subspace."
	^ self leftRadical! !

!BilinearForm methodsFor: 'operations' stamp: 'len 1/8/2016 06:29'!
rank
	^ matrix rank! !

!BilinearForm methodsFor: 'operations' stamp: 'len 5/1/2024 10:29:58'!
right
	"Answer the linear map from the domain to its dual that fixes the left argument. If the bilinear form is non-degenerate, this map is an isomorphism."
	| V L |
	V := space.
	L := V dual.
	^ V to: L map: [:v| L map: [:w| self value: v value: w]]! !

!BilinearForm methodsFor: 'operations' stamp: 'len 1/8/2016 06:06'!
rightRadical
	^ self right kernel! !

!BilinearForm methodsFor: 'operations' stamp: 'len 12/15/2022 11:22:44'!
skewSymmetricPart
	^ self class
		on: space
		matrix: matrix - matrix transpose / (self scalars !! 2)! !

!BilinearForm methodsFor: 'operations' stamp: 'len 12/15/2022 11:23:40'!
symmetricPart
	^ self class
		on: space
		matrix: matrix + matrix transpose / (self scalars !! 2)! !

!BilinearForm methodsFor: 'operations' stamp: 'len 8/9/2020 07:48:52'!
transpose
	"The transpose of a bilinear form B(x,y) is B(y,x)."
	^ self class on: space matrix: matrix transpose! !

!BilinearForm methodsFor: 'operations' stamp: 'len 4/26/2021 11:39:17'!
value: anElement value: anotherElement
	^ space \ anElement · (matrix * (space \ anotherElement))! !

!BilinearForm methodsFor: 'operations' stamp: 'len 5/3/2021 11:00:44'!
⊔ aBilinearForm
	"Answer the orthogonal sum of the receiver and the argument."
	^ self class on: space ⊕ aBilinearForm space matrix: matrix ⊕ aBilinearForm matrix! !

!BilinearForm methodsFor: 'operations' stamp: 'len 7/29/2024 09:35:01'!
⊗ anObject
	(anObject isKindOf: BilinearForm)
		ifTrue: [^ self class on: space ⊗ anObject space matrix: (matrix ⊗ anObject matrix)].
	(anObject isKindOf: QuadraticForm)
		ifTrue: [^ (self ⊗ anObject polarization) depolarization].
	^ Error signal! !

!BilinearForm methodsFor: 'printing' stamp: 'len 3/18/2018 18:42:28'!
printOn: aStream
	aStream print: self asPolynomial! !

!BilinearForm methodsFor: 'testing' stamp: 'len 1/8/2016 06:30'!
isAlternating
	"A bilinear form B is called 'alternating' if B(v,v) = 0 for all v."
	matrix isSkewSymmetric ifFalse: [^ false].
	matrix diagonalDo: [:each| each isZero ifFalse: [^ false]].
	^ true! !

!BilinearForm methodsFor: 'testing' stamp: 'len 10/21/2023 21:17:07'!
isNonDegenerate
	"A bilinear form B is called 'non-degenerate' if B(v,w) = 0 for all w implies v = 0.
	B is non-degenerate iff the left and right radicals are trivial."
	^ self rank = self domain rank! !

!BilinearForm methodsFor: 'testing' stamp: 'len 7/10/2020 07:46:31'!
isPositiveDefinite
	"A bilinear form B over the real or complex number is called 'positive definite' if B(v,v) > 0 for all v."
	^ matrix isPositiveDefinite! !

!BilinearForm methodsFor: 'testing' stamp: 'len 1/7/2016 23:40'!
isReflexive
	"A bilinear form B is called 'reflexive' if B(v,w) = 0 implies B(w,v) = 0 for all v,w."
	^ self isSymmetric or: [self isAlternating]! !

!BilinearForm methodsFor: 'testing' stamp: 'len 7/27/2020 19:06:58'!
isSkewSymmetric
	"A bilinear form B is called 'skew-symmetric' (or 'anti-symmetric') if B(v,w) = -B(w,v) for all v,w."
	^ matrix isSkewSymmetric! !

!BilinearForm methodsFor: 'testing' stamp: 'len 7/28/2020 10:27:27'!
isStandardDotProduct
	"Answer true if the receiver is the standard dot product."
	^ matrix isIdentity! !

!BilinearForm methodsFor: 'testing' stamp: 'len 1/8/2016 06:30'!
isSymmetric
	"A bilinear form B is called 'symmetric' if B(v,w) = B(w,v) for all v,w."
	^ matrix isSymmetric! !

!BilinearForm class methodsFor: 'instance creation' stamp: 'len 7/14/2020 07:37:24'!
from: aDomain to: aCodomain table: anArray
	^ self on: (aDomain at: 1) matrix: (anArray at: 1)! !

!BilinearForm class methodsFor: 'instance creation' stamp: 'len 12/12/2023 20:05:06'!
on: aModule mapWithArguments: aBlock
	| generators matrix |
	generators := aModule generators.
	matrix := aModule freeCover endomorphisms fill: [:i :j| aBlock value: (generators at: i) value: (generators at: j)].
	^ self on: aModule matrix: matrix! !

!BilinearForm class methodsFor: 'instance creation' stamp: 'len 7/28/2020 19:33:55'!
on: aFreeModule matrix: aMatrix
	"Answer a new instance of the receiver representing the bilinear form associated to aMatrix in the given bases."
	^ self new space: aFreeModule; matrix: aMatrix! !

!MonoidMap methodsFor: 'accessing' stamp: 'len 4/12/2024 04:52:41'!
category
	^ Mon! !

!MonoidMap methodsFor: 'accessing' stamp: 'len 12/6/2023 10:39:48'!
space
	"If the receiver is a representation (i.e., a monoid homomorphism to the endomorphism monoid of some object), answer the representation space."
	^ self codomain space! !

!MonoidMap methodsFor: 'converting' stamp: 'len 12/6/2023 10:39:13'!
asAction
	"If the receiver is a representation (i.e., a monoid homomorphism to the endomorphism monoid of some object), answer the associated action on the representation space."
	^ self domain on: self space action: [:x :y| (self value: x) value: y]! !

!MonoidMap methodsFor: 'internalization' stamp: 'len 6/14/2024 10:24:40'!
carrier
	^ self carrierFunction! !

!MonoidMap methodsFor: 'operations' stamp: 'len 6/26/2023 13:00:24'!
image
	^ self codomain sub: self images! !

!MonoidMap methodsFor: 'operations' stamp: 'len 4/24/2024 04:56:59'!
value: anElement
	| answer images |
	self propertyAt: #evaluable ifPresent: [:aBlock|
		self assert: (self domain includes: anElement).
		^ aBlock value: anElement].
	answer := self codomain identity.
	images := self propertyAt: #images.
	self domain \ anElement keysAndValuesDo: [:i :e| answer := answer · ((images at: i) ^ e)].
	^ answer! !

!MonoidMap methodsFor: 'printing' stamp: 'len 1/2/2022 11:23:13'!
printOn: aStream
	aStream nextPut: $(.
	(1 to: self domain rank)
		do: [:i| aStream print: (self value: (self domain x: i))]
		separatedBy: [aStream nextPutAll: ', '].
	aStream nextPut: $)! !

!MonoidMap methodsFor: 'testing' stamp: 'len 4/26/2020 06:34:36'!
isContinuous
	"Answer true if the receiver is continuous (also called non-erasing)."
	^ self domain generators noneSatisfy: [:each| (self value: each) = self codomain identity]! !

!MonoidMap methodsFor: 'testing' stamp: 'len 4/15/2024 09:20:44'!
isEpimorphism
	"In the category of monoids not all epimorphisms are surjective."
	self isSurjective ifTrue: [^ true].
	^ self notYetImplemented! !

!MonoidMap methodsFor: 'testing' stamp: 'len 4/26/2020 08:16:41'!
isMonoidHomomorphism
	^ true! !

!MonoidMap methodsFor: 'testing' stamp: 'len 4/26/2020 06:33:06'!
isTrivial
	^ self domain generators allSatisfy: [:each| (self value: each) = self codomain identity]! !

!MonoidMap methodsFor: 'private' stamp: 'len 4/26/2020 08:14:10'!
species
	^ MonoidMap! !

!MonoidMap methodsFor: 'private' stamp: 'len 7/8/2022 11:13:22'!
validate
	self assert: super isMonoidHomomorphism! !

!MonoidMap class methodsFor: 'initialization' stamp: 'len 6/14/2024 10:24:57'!
initialize
	| I |
	super initialize.
	I := FreeMonoid new: 0. "the trivial monoid is a zero object"
	Mon := Sets monoids
		propertyAt: #initialObject put: I;
		propertyAt: #terminalObject put: I;
		propertyAt: #zeroObject put: I;
		yourself! !

!MonoidMap class methodsFor: 'instance creation' stamp: 'len 4/19/2024 07:41:16'!
from: aDomain to: aCodomain images: anArray
	^ self new domain: aDomain; codomain: aCodomain; propertyAt: #images put: anArray; yourself! !

!GroupMap methodsFor: 'accessing' stamp: 'len 4/12/2024 04:52:50'!
category
	^ Grp! !

!GroupMap methodsFor: 'accessing' stamp: 'len 12/2/2023 11:01:45'!
character
	"If the receiver is a linear representation (i.e., a group homomorphism to the general linear group), answer the character of the receiver."
	"This is a class function, i.e. it's constant on conjugacy classes, because similar matrices (or linear maps) have the same trace."
	self space isModule ifFalse: [^ self error: 'not a linear representation'].
	^ self domain to: self space scalars units map: [:g| (self value: g) trace]! !

!GroupMap methodsFor: 'accessing' stamp: 'len 12/6/2023 10:40:00'!
space
	"If the receiver is a representation (i.e., a group homomorphism to the automorphism group of some object), answer the representation space."
	^ self codomain space! !

!GroupMap methodsFor: 'comparing' stamp: 'len 5/13/2019 16:32:40'!
= anObject
	((anObject isKindOf: GroupMap) and: [self domain generators notNil])
		ifFalse: [^ super = anObject].
	(anObject domain = self domain and: [anObject codomain = self codomain])
		ifFalse: [^ false].
	^ self domain generators allSatisfy: [:each| (self value: each) = (anObject value: each)]! !

!GroupMap methodsFor: 'converting' stamp: 'len 12/6/2023 10:38:21'!
asAction
	"If the receiver is a representation (i.e., a group homomorphism to the automorphism group of some object), answer the associated group action on the representation space."
	^ self domain on: self space action: [:x :y| (self value: x) value: y]! !

!GroupMap methodsFor: 'internalization' stamp: 'len 6/14/2024 10:23:12'!
carrier
	^ self carrierFunction! !

!GroupMap methodsFor: 'operations' stamp: 'len 7/2/2023 18:42:45'!
cokernel
	^ self codomain / self image! !

!GroupMap methodsFor: 'operations' stamp: 'len 6/26/2023 13:00:37'!
image
	^ self codomain sub: self images! !

!GroupMap methodsFor: 'operations' stamp: 'len 9/16/2022 07:36:48'!
inverse
	"Answer the compositional inverse of the receiver."
	^ self class
		from: self codomain to: self domain
		map: [:each| self domain detect: [:one| (self value: one) = each]]! !

!GroupMap methodsFor: 'operations' stamp: 'len 8/18/2020 18:58:38'!
kernel
	^ self propertyAt: #kernel ifAbsent:
		[self computeImageAndKernel.
		self propertyAt: #kernel]! !

!GroupMap methodsFor: 'operations' stamp: 'len 12/6/2023 10:46:15'!
preimage: aSubgroup
	^ self domain ambient sub: (aSubgroup generators collect: [:each| self preimageElement: each]), self kernel generators! !

!GroupMap methodsFor: 'operations' stamp: 'len 8/29/2024 15:17:39'!
value: anElement
	| answer images |
	self propertyAt: #evaluable ifPresent: [:aBlock|
		self assert: (self domain includes: anElement).
		^ aBlock value: anElement].
	answer := self codomain identity.
	images := self propertyAt: #images.
	self codomain isAbelianGroup
		ifTrue: [self domain \ anElement keysAndValuesDo: [:i :e| answer := answer + ((images at: i) * e)]]
		ifFalse: [self domain \ anElement keysAndValuesDo: [:i :e| answer := answer · ((images at: i) ^ e)]].
	^ answer! !

!GroupMap methodsFor: 'testing' stamp: 'len 5/10/2019 07:40:55'!
isGroupHomomorphism
	^ true! !

!GroupMap methodsFor: 'testing' stamp: 'len 11/7/2015 16:46'!
isInjective
	^ self kernel isTrivial! !

!GroupMap methodsFor: 'testing' stamp: 'len 11/7/2015 16:49'!
isSurjective
	^ self image = self codomain! !

!GroupMap methodsFor: 'testing' stamp: 'len 7/2/2023 18:45:40'!
isTrivial
	^ self domain generators allSatisfy: [:each| (self value: each) = self codomain identity]
"
alternative:
	^ self kernel = self domain
"! !

!GroupMap methodsFor: 'private' stamp: 'len 8/29/2024 15:17:40'!
computeImageAndKernel
	"'Handbook of Computational Group Theory', 3.4.2, algorithm IMAGEKERNEL, page 76."
	| image kernel random |
	random := Random new.
	kernel := self domain null.
	image := self codomain null.
	[kernel size * image size < self domain size]
		whileTrue:
			[| g h |
			g := self domain atRandom: random.
			h := self value: g.
			(image includes: h)
				ifFalse: [image := self codomain sub: (image generators copyWith: h)]
				ifTrue:
					[| k |
					k := self domain isAbelianGroup
						ifTrue: [g - (self preimageElement: h)]
						ifFalse: [g · (self preimageElement: h) inverse].
					(kernel includes: k) ifFalse: [kernel := self domain sub: (kernel generators copyWith: k)]]].
	self propertyAt: #image put: image.
	self propertyAt: #kernel put: kernel! !

!GroupMap methodsFor: 'private' stamp: 'len 1/11/2018 18:20:41'!
species
	^ GroupMap! !

!GroupMap methodsFor: 'private' stamp: 'len 7/8/2022 11:13:33'!
validate
	self assert: super isGroupHomomorphism! !

!GroupMap class methodsFor: 'initialization' stamp: 'len 6/14/2024 10:24:23'!
initialize
	| I |
	super initialize.
	I := FreeGroup new: 0. "the trivial group is a zero object"
	Grp := Sets groups
		propertyAt: #initialObject put: I;
		propertyAt: #terminalObject put: I;
		propertyAt: #zeroObject put: I;
		propertyAt: #isSymmetricMonoidal put: true;
		propertyAt: #unitObject put: I;
		yourself! !

!GroupMap class methodsFor: 'instance creation' stamp: 'len 4/19/2024 07:41:21'!
from: aDomain to: aCodomain images: anArray
	^ self new domain: aDomain; codomain: aCodomain; propertyAt: #images put: anArray; yourself! !

!RingMap methodsFor: 'accessing' stamp: 'len 9/1/2024 20:03:28'!
carrier
	^ self asAbelianGroupMap! !

!RingMap methodsFor: 'accessing' stamp: 'len 4/12/2024 04:53:08'!
category
	^ Rings! !

!RingMap methodsFor: 'accessing' stamp: 'len 7/8/2022 08:26:45'!
degree
	^ self domain generators max: [:each| (self value: each) degree - each degree]! !

!RingMap methodsFor: 'accessing' stamp: 'len 8/20/2024 10:53:57'!
scalars
	self isFiniteAlgebraMap ifTrue: [^ self asModuleMap scalars].
	self isFinitelyGeneratedAlgebraMap ifTrue: [^ self codomain scalars].
	^ ℤ! !

!RingMap methodsFor: 'comparing' stamp: 'len 8/20/2024 11:10:32'!
= anObject
	self class = anObject class ifFalse: [^ super = anObject].
	(self domain = anObject domain and: [self codomain = anObject codomain]) ifFalse: [^ false].
	((self hasProperty: #moduleMap) and: [anObject hasProperty: #moduleMap]) ifTrue: [^ self asModuleMap = anObject asModuleMap].
	((self hasProperty: #images) and: [anObject hasProperty: #images]) ifTrue: [^ self images = anObject images].
	^ super = anObject! !

!RingMap methodsFor: 'converting' stamp: 'len 9/16/2022 08:02:42'!
asAbelianGroupMap
	^ self domain asAbelianGroup to: self codomain asAbelianGroup map: [:x| self value: self domain !! x]! !

!RingMap methodsFor: 'converting' stamp: 'len 8/19/2024 17:50:09'!
asModuleMap
	^ self propertyAt: #moduleMap ifAbsentPut: [self domain asModule to: self codomain asModule map: self]! !

!RingMap methodsFor: 'operations' stamp: 'len 9/16/2022 08:02:35'!
@ aPrimeIdeal
	"Answer the induced ring homomorphism at the respective localizations."
	| A B |
	A _ self domain @ (self preimage: aPrimeIdeal).
	B _ self codomain @ aPrimeIdeal.
	^ A to: B map: [:x| (B embed: (self value: x numerator)) / (B embed: (self value: x denominator))]! !

!RingMap methodsFor: 'operations' stamp: 'len 8/19/2024 18:31:43'!
image
	self isFiniteAlgebraMap ifTrue: [^ self codomain sub: self asModuleMap image].
	self isFinitelyGeneratedAlgebraMap ifTrue: [^ self codomain sub: self images].
	^ super image! !

!RingMap methodsFor: 'operations' stamp: 'len 8/20/2024 10:53:17'!
kernel
	"See RationalMap>>image."
	| A B m n P t ι generators I |
	self propertyAt: #kernel ifPresent: [:anIdeal| ^ anIdeal].
	self isFiniteAlgebraMap ifTrue: [^ self propertyAt: #kernel put: self domain * self asModuleMap kernel generators].
	(self domain isField and: [self codomain isField]) ifTrue: [^ self domain * 0].
	self codomain isTrivial ifTrue: [^ self domain].
	(self isFinitelyGeneratedAlgebraMap and: [self domain isAffineAlgebra and: [self codomain isAffineAlgebra]])
		ifFalse: [self assert: self domain isFinite. ^ self propertyAt: #kernel put: (self domain * (self domain select: [:x| (self value: x) isZero]))].
	A := self domain.
	B := self codomain.
	n := A rank.
	m := B rank.
	P := self codomain scalars polynomialsIn: n + m + 1.
	ι := B to: P images: ((1 to: B rank) collect: [:i| P x: i+n]).
	t := P x: P rank.
	generators := OrderedCollection new.
	1 to: n do: [:i| generators add: (P x: i) - (ι value: (self value: (A x: i)))].
	generators add: P one - t.
	I := P * generators eliminateAll: (n+1 to: P rank).
	^ self propertyAt: #kernel put: A * (I generators collect: [:each| A !! each])	! !

!RingMap methodsFor: 'operations' stamp: 'len 4/13/2024 09:28:22'!
opposite
	"Answer the ring homomorphism between the opposite rings induced by the receiver."
	^ self domain opposite to: self codomain opposite map: [:x| (self value: x) opposite]! !

!RingMap methodsFor: 'operations' stamp: 'len 11/29/2023 10:32:49'!
preimage: anIdeal
	^ self domain * (anIdeal generators collect: [:each| self preimageElement: each]) + self kernel! !

!RingMap methodsFor: 'operations' stamp: 'len 8/19/2024 17:58:18'!
preimageElement: anElement
	"Answer an element in the preimage of anElement.
	Answer nil if anElement is not in the image of the receiver."
	self isFiniteAlgebraMap ifTrue: [^ self domain !! (self asModuleMap preimageElement: self codomain asModule !! anElement)].
	^ super preimageElement: anElement! !

!RingMap methodsFor: 'operations' stamp: 'len 8/20/2024 10:55:31'!
spec
	"This is the Spec functor. Answer the morphism between affine schemes induced by the receiver, i.e. given a ring homomorphism f:R→S, Spec(f) is a scheme morphism Spec(S)→Spec(R)."	
	| representatives |
	(self isFinitelyGeneratedAlgebraMap and: [self domain isAffineAlgebra and: [self codomain isAffineAlgebra]])
		ifFalse: [^ AffineMorphism ringMap: self].
	representatives := self codomain isQuotient ifTrue: [self images collect: [:each| each representative]] ifFalse: [self images].
	^ self codomain spec to: self domain spec representatives: representatives! !

!RingMap methodsFor: 'operations' stamp: 'len 12/23/2023 10:32:32'!
units
	"This is the natural functor from the cateogry of rings to the category of groups which sends each ring R to its group of units U(R) and each ring homomorphism to the restriction to U(R). This functor has a left adjoint which sends each group G to the integral group ring ℤ[G]."
	^ self domain units to: self codomain units map: [:each| self value: each]! !

!RingMap methodsFor: 'operations' stamp: 'len 8/19/2024 18:00:57'!
value: anElement
	self propertyAt: #evaluable ifPresent: [:aBlock|
		self assert: (self domain includes: anElement).
		^ aBlock value: anElement].
	self propertyAt: #moduleMap ifPresent: [:aModuleMap| ^ self codomain !! (aModuleMap value: aModuleMap domain !! anElement)].
	^ self codomain evaluate: self domain \ anElement at: self images! !

!RingMap methodsFor: 'operations' stamp: 'len 8/19/2024 18:30:40'!
∘ aRingMap
	(self isFinitelyGeneratedAlgebraMap and: [aRingMap isFinitelyGeneratedAlgebraMap and: [self scalars = aRingMap scalars]]) ifFalse: [^ super ∘ aRingMap].
	self checkCompatibleComposition: aRingMap.
	self propertyAt: #moduleMap ifPresent: [:aModuleMap|
		aRingMap propertyAt: #moduleMap ifPresent: [:anotherModuleMap|
			^ self class from: aRingMap domain to: self codomain moduleMap: aModuleMap ∘ anotherModuleMap]].
	^ self class from: aRingMap domain to: self codomain images: (aRingMap images apply: self)! !

!RingMap methodsFor: 'printing' stamp: 'len 10/13/2023 16:17:05'!
printOn: aStream
	aStream print: (self propertyAt: #images ifAbsent: [^ super printOn: aStream])! !

!RingMap methodsFor: 'testing' stamp: 'len 8/19/2024 18:10:30'!
imageContains: anElement
	"As in Magma, algorithm in p. 82 of [AL94]."
	^ super imageContains: anElement! !

!RingMap methodsFor: 'testing' stamp: 'len 8/20/2024 11:11:17'!
inverse
	self isFiniteAlgebraMap ifTrue: [^ self class from: self codomain to: self domain moduleMap: self asModuleMap inverse].
"	self codomain isFinitelyGenerated ifTrue: [^ self class from: self codomain to: self domain images: (self codomain generators collect: [:each| self preimageElement: each])]."
	^ super inverse! !

!RingMap methodsFor: 'testing' stamp: 'len 4/15/2024 09:20:49'!
isEpimorphism
	"In the category of unital rings not all epimorphisms are surjective. For example, the initial morphism ℤ → ℚ from the rational integers to the rational numbers is not surjective but it is an epimorphism."
	self isSurjective ifTrue: [^ true].
	^ self notYetImplemented! !

!RingMap methodsFor: 'testing' stamp: 'len 8/20/2024 10:57:29'!
isFiniteAlgebraMap
	"Answer true if the receiver is a map of finite R-algebras defined as a module map between the underlying R-modules."
	^ (self hasProperty: #moduleMap) or: [(self hasProperty: #images) and: [self domain isFiniteAlgebra and: [self codomain isFiniteAlgebra]]]! !

!RingMap methodsFor: 'testing' stamp: 'len 8/20/2024 10:57:56'!
isFinitelyGeneratedAlgebraMap
	^ (self hasProperty: #images) or: [self hasProperty: #moduleMap]! !

!RingMap methodsFor: 'testing' stamp: 'len 7/8/2022 08:26:01'!
isGraded
	"Answer true if the receiver is a graded ring homomorphism."
	(self domain isGraded and: [self codomain isGraded]) ifFalse: [^ false].
	^ self domain generators allSatisfy: [:each| (self value: each) degree = each degree]! !

!RingMap methodsFor: 'testing' stamp: 'len 8/19/2024 18:08:42'!
isInjective
"	(self domain isField and: [self codomain isTrivial not]) ifTrue: [^ true]." "a ring homomorphism from a field to a nontrivial ring is injective."
	self isFiniteAlgebraMap ifTrue: [^ self asModuleMap isInjective].
	^ self kernel isTrivial! !

!RingMap methodsFor: 'testing' stamp: 'len 12/10/2023 10:36:24'!
isLocal
	"A ring homomorphism called 'local' if it is a homomorphism of local rings and carries the maximal ideal to the maximal ideal."
	^ self domain isLocal and: [self codomain isLocal and: [(self domain maximalIdeal apply: self) ⊆ self codomain maximalIdeal]]! !

!RingMap methodsFor: 'testing' stamp: 'len 5/10/2019 07:41:10'!
isRingHomomorphism
	^ true! !

!RingMap methodsFor: 'testing' stamp: 'len 8/19/2024 18:08:59'!
isSurjective
	self isFiniteAlgebraMap ifTrue: [^ self asModuleMap isSurjective].
	^ super isSurjective! !

!RingMap methodsFor: 'testing' stamp: 'len 1/2/2022 10:14:24'!
isZero
	"A ring homomorphism to a nontrivial ring cannot be zero, because 1 maps to 1."
	^ (self value: self domain one) = self codomain zero
"	^ self codomain isTrivial"! !

!RingMap methodsFor: 'private' stamp: 'len 1/11/2018 17:38:33'!
species
	^ RingMap! !

!RingMap methodsFor: 'private' stamp: 'len 7/8/2022 11:13:40'!
validate
	self assert: super isRingHomomorphism! !

!RingMap class methodsFor: 'initialization' stamp: 'len 6/9/2024 16:05:54'!
initialize
	super initialize.
	Rings := Category new "Ab monoids"
		propertyAt: #initialObject put: ℤ;
		propertyAt: #terminalObject put: ℤ/1;
		yourself! !

!RingMap class methodsFor: 'instance creation' stamp: 'len 4/19/2024 07:41:25'!
from: aDomain to: aCodomain images: anArray
	^ self new domain: aDomain; codomain: aCodomain; propertyAt: #images put: anArray; yourself! !

!RingMap class methodsFor: 'instance creation' stamp: 'len 8/20/2024 11:04:30'!
from: aDomain to: aCodomain moduleMap: aModuleMap
	^ self new domain: aDomain; codomain: aCodomain; propertyAt: #moduleMap put: aModuleMap; yourself! !

!ModuleMap methodsFor: 'accessing' stamp: 'len 4/1/2021 06:41:51'!
bitSize
	^ self asMatrix bitSize! !

!ModuleMap methodsFor: 'accessing' stamp: 'len 4/12/2024 04:57:46'!
category
	^ self domain scalars modules! !

!ModuleMap methodsFor: 'accessing' stamp: 'len 5/16/2019 20:40:32'!
codomain
	^ codomain! !

!ModuleMap methodsFor: 'accessing' stamp: 'len 7/6/2022 11:34:14'!
degree
	self isTrivial ifTrue: [^ Infinity negative].
	^ self asMatrix coefficients max: [:each| each degree]! !

!ModuleMap methodsFor: 'accessing' stamp: 'len 4/1/2021 06:41:57'!
denominator
	^ self asMatrix denominator! !

!ModuleMap methodsFor: 'accessing' stamp: 'len 5/16/2019 20:40:36'!
domain
	^ domain! !

!ModuleMap methodsFor: 'accessing' stamp: 'len 5/29/2020 10:16:57'!
one
	^ self identity! !

!ModuleMap methodsFor: 'accessing' stamp: 'len 5/28/2020 09:52:20'!
scalars
	^ self domain scalars! !

!ModuleMap methodsFor: 'accessing' stamp: 'len 9/16/2022 08:03:32'!
zero
	^ self domain to: self codomain map: [:x| self codomain zero]! !

!ModuleMap methodsFor: 'comparing' stamp: 'len 3/13/2021 13:45:24'!
= anObject
	self == anObject ifTrue: [^ true].
	(anObject isKindOf: ModuleMap) ifFalse: [^ super = anObject].
	^ domain = anObject domain and: [codomain = anObject codomain and: [(self - anObject) isZero]]! !

!ModuleMap methodsFor: 'comparing' stamp: 'len 5/31/2022 11:54:49'!
| aModuleMap
	"Answer true if the receiver is a left divisor of the argument
	(or equivalently, the argument is a right multiple of the receiver),
	i.e. if the receiver is a and the argument is b, there exists x with ax = b."
	aModuleMap isZero ifTrue: [^ true].
	self isZero ifTrue: [^ false].
	^ (self lift: aModuleMap) notNil! !

!ModuleMap methodsFor: 'converting' stamp: 'len 4/5/2024 18:59:40'!
asAbelianGroupMap
	self assert: self scalars = ℤ.
	^ self! !

!ModuleMap methodsFor: 'converting' stamp: 'len 4/22/2024 04:55:10'!
asChainMap
	^ self domain asChainComplex to: self codomain asChainComplex components: {self}! !

!ModuleMap methodsFor: 'converting' stamp: 'len 4/1/2021 06:34:04'!
asMatrix
	"Answer the matrix corresponding to the receiver with respect to the fixed list of generators of its domain and codomain."
	^ self propertyAt: #matrix! !

!ModuleMap methodsFor: 'converting' stamp: 'len 4/5/2024 18:59:23'!
asPolynomial
	"If the receiver is a linear form, answer the receiver as a polynomial in the coordinate ring of the domain."
	| P |
	self isLinearForm ifFalse: [self error: 'not a linear form'].
	P := self domain coordinateRing.
	^ (P !!!! P generators) · (self asMatrix asTuple over: P)! !

!ModuleMap methodsFor: 'converting' stamp: 'len 5/31/2022 18:10:39'!
asScalar
	"If the receiver is the embedding of an element of the scalars ring in an endomorphism algebra, answer the corresponding scalar."
	^ self asMatrix asScalar! !

!ModuleMap methodsFor: 'converting' stamp: 'len 12/2/2023 08:46:50'!
asSingletonMatrix
	"Answer the 1x1 matrix with the receiver as its only coefficient."
	^ self parent asRing !!!!!! {{self}}! !

!ModuleMap methodsFor: 'operations' stamp: 'len 7/25/2021 12:32:13'!
* anObject
	((self scalars includes: anObject) not and: [anObject isKindOf: ModuleMap]) ifTrue: [^ self · anObject].
	^ domain to: codomain validMatrix: self asMatrix * anObject! !

!ModuleMap methodsFor: 'operations' stamp: 'len 9/16/2022 08:03:18'!
+ anObject
	(anObject isKindOf: ModuleMap) ifFalse: [^ super + anObject].
	(self domain == anObject domain and: [self codomain == anObject codomain])
			ifTrue: [^ domain to: codomain validMatrix: self asMatrix + anObject asMatrix].
	self checkDomainsMatch: anObject.
	self checkCodomainsMatch: anObject.
	^ domain to: codomain map: [:v| (self value: v) + (anObject value: v)]! !

!ModuleMap methodsFor: 'operations' stamp: 'len 6/13/2024 14:07:43'!
/ anObject
	"If the argument is i:A→X, and the receiver is f:A→Y, answer g:X→Y such that the diagram commutes.
	This is a 'colift (or extension) of f along i' and it is denoted by f / i."
	(anObject isKindOf: ModuleMap) ifFalse: [^ self * (self domain scalars !! anObject) inverse].
	^ super / anObject! !

!ModuleMap methodsFor: 'operations' stamp: 'len 11/7/2023 21:19:39'!
@ aPrimeIdeal
	"Answer the localization of the receiver at aPrimeIdeal."
	^ self ⊗ (self scalars @ aPrimeIdeal)! !

!ModuleMap methodsFor: 'operations' stamp: 'len 5/14/2023 18:21:10'!
÷ anElement
	"Answer the exact division of the receiver by the argument.
	Asume that the argument divides the receiver."
	^ anElement \ self! !

!ModuleMap methodsFor: 'operations' stamp: 'len 12/15/2021 19:51:16'!
characteristicPolynomial
	^ self asMatrix characteristicPolynomial! !

!ModuleMap methodsFor: 'operations' stamp: 'len 7/2/2023 18:37:09'!
cokernel
	^ self codomain / self image! !

!ModuleMap methodsFor: 'operations' stamp: 'len 4/15/2024 09:36:08'!
colift: aModuleMap
	self checkDomainsMatch: aModuleMap.
	domain relationsMatrix = aModuleMap domain relationsMatrix ifFalse: [^ self notYetImplemented].
	^ (domain isFreelyGenerated
		ifTrue: [self asMatrix colift: aModuleMap asMatrix]
		ifFalse: [self asMatrix colift: aModuleMap asMatrix modulo: domain relationsMatrix])
			ifNotNil: [:aMatrix| codomain to: aModuleMap codomain matrix: aMatrix]! !

!ModuleMap methodsFor: 'operations' stamp: 'len 6/24/2024 14:59:10'!
dual
	"Answer the transpose (or dual, or adjoint) of the receiver.
	The assignment of a linear map f : V → W to its dual fᵛ : Wᵛ → Vᵛ produces an injective linear map between Hom(V,W) and Hom(Wᵛ,Vᵛ).
	This is the 'operator adjoint', not to be confused with the 'Hilbert adjoint' that is defined for an operator in an inner product space."
	(self scalars isCommutative or: [self scalars isInvolutive]) ifFalse: [^ self notYetImplemented].
	self flag: #fixme. "shouldn't be opposite instead of transpose?"
	^ codomain dual to: domain dual matrix: self asMatrix transpose! !

!ModuleMap methodsFor: 'operations' stamp: 'len 11/26/2023 20:50:39'!
evaluate: aPolynomial
	"Answer the result of evaluating aPolynomial at the receiver, assuming the receiver is an endomorphism."
	^ aPolynomial value: self! !

!ModuleMap methodsFor: 'operations' stamp: 'len 6/26/2023 13:00:50'!
image
	^ self propertyAt: #image ifAbsentPut: [codomain sub: self asMatrix]! !

!ModuleMap methodsFor: 'operations' stamp: 'len 12/9/2022 10:42:02'!
inverse
	"Answer a two-sided inverse of the receiver (i.e., a morphism that is both a retraction and a section) or nil."
	self flag: #fixme. "this is a right inverse, not two-sided inverse"
	^ self section ifNil: [self error: 'not invertible']! !

!ModuleMap methodsFor: 'operations' stamp: 'len 6/26/2023 13:00:54'!
kernel
	^ self propertyAt: #kernel ifAbsentPut: [self domain sub: (self asMatrix syzygiesModulo: self codomain relationsMatrix)]! !

!ModuleMap methodsFor: 'operations' stamp: 'len 4/15/2024 09:43:48'!
lift: aModuleMap
	self checkCodomainsMatch: aModuleMap.
	codomain relationsMatrix = aModuleMap codomain relationsMatrix ifFalse: [^ self notYetImplemented].
	^ (codomain isFreelyGenerated
		ifTrue: [self asMatrix lift: aModuleMap asMatrix]
		ifFalse: [self asMatrix lift: aModuleMap asMatrix modulo: codomain relationsMatrix])
			ifNotNil: [:aMatrix| aModuleMap domain to: domain matrix: aMatrix]! !

!ModuleMap methodsFor: 'operations' stamp: 'len 12/15/2021 19:50:51'!
minimalPolynomial
	^ self asMatrix minimalPolynomial! !

!ModuleMap methodsFor: 'operations' stamp: 'len 4/6/2021 14:26:04'!
negated
	^ domain to: codomain validMatrix: self asMatrix negated! !

!ModuleMap methodsFor: 'operations' stamp: 'len 7/18/2021 07:40:10'!
norm
	^ self asMatrix determinant! !

!ModuleMap methodsFor: 'operations' stamp: 'len 12/10/2021 19:25:03'!
normalization
	"Answer a unit u such that 'self * u' is a unique choice of associate. See >>normalized."
	self isEndomorphism ifFalse: [^ self error: 'not an endomorphism'].
	^ self notYetImplemented! !

!ModuleMap methodsFor: 'operations' stamp: 'len 12/10/2021 19:24:00'!
normalized
	"Answer a unique choice of associate. See >>normalization."
	^ self * self normalization! !

!ModuleMap methodsFor: 'operations' stamp: 'len 11/29/2023 10:40:01'!
preimage: aSubmodule
	self flag: #fixme. "maybe implement as (self \ (aSubmodule → self codomain)) image ???"
	^ self domain ambient sub: (aSubmodule generators collect: [:each| self preimageElement: each]) + self kernel! !

!ModuleMap methodsFor: 'operations' stamp: 'len 10/14/2023 15:59:44'!
preimageElement: anElement
	"Answer an element in the preimage of anElement.
	Answer nil if anElement is not in the image of the receiver."
	^ domain elementAt: ((self asMatrix lift: (codomain \ anElement) asMatrix modulo: self codomain relationsMatrix) ifNil: [^ nil]) asTuple! !

!ModuleMap methodsFor: 'operations' stamp: 'len 4/10/2024 04:07:02'!
representation
	"Assuming the receiver is an endomorphism, answer the module endomorphism corresponding to the left regular representation of the receiver."
	^ (self domain ⇒ self codomain) endomorphisms map: [:x| self * x]! !

!ModuleMap methodsFor: 'operations' stamp: 'len 10/19/2023 13:36:49'!
restriction
	"This is the 'restriction of scalars' functor.
	If the receiver is an homomorphism of modules over a finite R-algebra, answer an homomorphism between R-modules.
	This functor is right adjoint to 'extension of scalars' (see #⊗) and left adjoint to 'coextension of scalars' (see #⇒)."
	^ self domain restriction to: self codomain restriction validMatrix: self asMatrix restriction! !

!ModuleMap methodsFor: 'operations' stamp: 'len 6/16/2024 07:57:26'!
rightRepresentation
	"Assuming the receiver is an endomorphism, answer the module endomorphism corresponding to the right regular representation of the receiver."
	^ self parent endomorphisms map: [:x| x * self]! !

!ModuleMap methodsFor: 'operations' stamp: 'len 10/26/2023 10:51:30'!
top
	"If the receiver is a module map from M to N, answer the induced map from the top of M to the top of N. See Module>>#top."
	| π₁ π₂ |
	π₁ := self domain → self domain top.
	π₂ := self codomain → self codomain top.
	^ self domain top to: self codomain top map: [:x| π₂ value: (self value: (π₁ preimageElement: x))]! !

!ModuleMap methodsFor: 'operations' stamp: 'len 4/1/2021 06:43:21'!
trace
	^ self asMatrix trace! !

!ModuleMap methodsFor: 'operations' stamp: 'len 4/1/2021 06:43:27'!
transpose
	"The kernel of this map is the complement of the image of the receiver (the orthogonal complement with respect to the standard inner product defined or dot product).
	See also >>adjoint."
	^ codomain to: domain matrix: self asMatrix transpose! !

!ModuleMap methodsFor: 'operations' stamp: 'len 7/6/2021 14:32:15'!
value: anElement
"	(domain isTrivial or: [codomain isTrivial])
		ifTrue: [^ codomain ambient zero]."
	^ codomain elementAt: self asMatrix * (domain \ anElement)

"	^ codomain elementAt: self asMatrix * (domain \ (domain !! anElement))"! !

!ModuleMap methodsFor: 'operations' stamp: 'len 7/21/2024 09:32:51'!
∘ aModuleMap
	"Answer the composition of the receiver with the argument."
	self species = aModuleMap species ifFalse: [^ super ∘ aModuleMap].
	domain == aModuleMap codomain
		ifTrue: [^ aModuleMap domain to: codomain validMatrix: self asMatrix ∘ aModuleMap asMatrix].
	domain ⊇ aModuleMap codomain
		ifTrue: [^ aModuleMap domain to: codomain map: [:each| self value: (aModuleMap value: each)]].
	^ self error: 'incompatible composition'! !

!ModuleMap methodsFor: 'operations' stamp: 'len 5/3/2024 04:51:34'!
⊓ aModuleMap
	(codomain isFreelyGenerated and: [aModuleMap codomain isFreelyGenerated]) ifFalse: [^ super ⊓ aModuleMap].
	self checkDomainsMatch: aModuleMap.
	^ domain to: codomain ⊕ aModuleMap codomain validMatrix: self asMatrix ⊓ aModuleMap asMatrix! !

!ModuleMap methodsFor: 'operations' stamp: 'len 5/3/2024 04:53:13'!
⊔ aModuleMap
	(domain isFreelyGenerated and: [aModuleMap domain isFreelyGenerated]) ifFalse: [^ super ⊔ aModuleMap].
	self checkCodomainsMatch: aModuleMap.	
	^ domain ⊕ aModuleMap domain to: codomain validMatrix: self asMatrix ⊔ aModuleMap asMatrix! !

!ModuleMap methodsFor: 'operations' stamp: 'len 7/6/2023 21:37:54'!
⊕ aModuleMap
	"Answer the direct sum of the receiver and the argument."
	(domain isFreelyGenerated and: [codomain isFreelyGenerated and: [aModuleMap domain isFreelyGenerated and: [aModuleMap codomain isFreelyGenerated]]]) ifFalse: [^ super ⊕ aModuleMap].
	^ domain ⊕ aModuleMap domain to: codomain ⊕ aModuleMap codomain validMatrix: self asMatrix ⊕ aModuleMap asMatrix! !

!ModuleMap methodsFor: 'operations' stamp: 'len 7/29/2024 09:35:18'!
⊗ anObject
	"Answer the tensor product of the receiver with the argument, if the argument is another module homomorphism in the same category.
	If the argument is a ring, answer the extension of scalars."
	(anObject isKindOf: Ring) ifTrue: [^ domain ⊗ anObject to: codomain ⊗ anObject validMatrix: self asMatrix ⊗ anObject].
	(anObject isKindOf: Module) ifTrue: [^ self ⊗ anObject id].
	(anObject isKindOf: ModuleMap) ifTrue: [^ domain ⊗ anObject domain to: codomain ⊗ anObject codomain validMatrix: self asMatrix ⊗ anObject asMatrix].
	^ self notYetImplemented! !

!ModuleMap methodsFor: 'operations' stamp: 'len 7/1/2024 10:56:19'!
◃ anObject
	^ self * anObject! !

!ModuleMap methodsFor: 'printing' stamp: 'len 6/8/2022 18:07:53'!
printOn: aStream
	self isZero ifTrue: [aStream nextPut: $0. ^ self].
	self isIdentity ifTrue: [aStream nextPutAll: 'id'. ^ self].
	self negated isIdentity ifTrue: [aStream nextPutAll: '-id'. ^ self].
"	(self isLinearForm and: [self scalars isCommutative]) ifTrue: [aStream print: self asPolynomial. ^ self]."
	"If the codomain is tuples, print the linear map as a tuple of linear forms:"
"	((self codomain isKindOf: FreeModule) and: [self scalars isCommutative]) ifTrue:
		[aStream nextPut: $(.
		self asMatrix rows
			do: [:each| aStream print: (self domain dual elementAt: each)]
			separatedBy: [aStream nextPutAll: ', '].
		aStream nextPut: $).
		^ self]."
	aStream print: self asMatrix
	"Print it as a linear combination of the generators of the codomain:"
"	A _ self domain coordinateRing.
	B _ A polynomialsIn: self codomain coordinates names.
	f _ B zero.
	self asMatrix withIndicesDo: [:each :i :j| f _ (B x: i) * (A x: j) * each + f].
	aStream print: f"! !

!ModuleMap methodsFor: 'testing' stamp: 'len 3/17/2021 14:38:35'!
isAutomorphism
	"A surjective endomorphism of a finitely generated module is an automorphism (i.e., it's not necessary to check it is injective)."
	^ self isEndomorphism and: [self isSurjective]! !

!ModuleMap methodsFor: 'testing' stamp: 'len 3/11/2020 18:49:29'!
isConstant
	^ self isZero! !

!ModuleMap methodsFor: 'testing' stamp: 'len 7/8/2022 08:25:10'!
isGraded
	"Answer true if the receiver is a graded module homomorphism."
	| n |
	(self domain isGraded and: [self codomain isGraded]) ifFalse: [^ false].
	n _ self degree.
	^ self asMatrix coefficients allSatisfy: [:each| each isHomogeneous and: [each degree = n]]! !

!ModuleMap methodsFor: 'testing' stamp: 'len 7/12/2022 06:30:19'!
isGroupHomomorphism
	^ self domain isGroup and: [self codomain isGroup]! !

!ModuleMap methodsFor: 'testing' stamp: 'len 3/12/2020 16:14:11'!
isIdentity
	self isEndomorphism ifFalse: [^ false].
	^ self domain generators allSatisfy: [:each| (self value: each) = each]! !

!ModuleMap methodsFor: 'testing' stamp: 'len 5/16/2019 20:42:56'!
isInjective
	^ self kernel isTrivial! !

!ModuleMap methodsFor: 'testing' stamp: 'len 12/7/2022 19:37:37'!
isIsomorphism
	^ self isSurjective and: [self isEndomorphism or: [self isInjective]]! !

!ModuleMap methodsFor: 'testing' stamp: 'len 4/8/2021 12:49:58'!
isLinearForm
	"Answer true if the receiver is a linear form (or linear functional, one-form, covector)."
	^ self codomain = self scalars asIdeal! !

!ModuleMap methodsFor: 'testing' stamp: 'len 4/25/2022 18:04:49'!
isMinusOne
	^ self = self identity negated! !

!ModuleMap methodsFor: 'testing' stamp: 'len 5/10/2019 07:41:27'!
isModuleHomomorphism
	^ true! !

!ModuleMap methodsFor: 'testing' stamp: 'len 7/16/2020 10:36:53'!
isOne
	^ self isIdentity! !

!ModuleMap methodsFor: 'testing' stamp: 'len 1/13/2018 21:54:27'!
isProjection
	^ self isIdempotent! !

!ModuleMap methodsFor: 'testing' stamp: 'len 10/17/2022 16:14:48'!
isSurjective
	^ self image = self codomain

"alternatively:
	^ self cokernel isTrivial"! !

!ModuleMap methodsFor: 'testing' stamp: 'len 5/25/2022 13:36:36'!
isUnit
	"Answer true if the receiver is invertible."
	^ self isAutomorphism! !

!ModuleMap methodsFor: 'testing' stamp: 'len 3/13/2021 13:36:11'!
isZero
	^ self image isTrivial! !

!ModuleMap methodsFor: 'testing' stamp: 'len 5/25/2022 11:05:19'!
isZeroDivisor
	"Answer true if there exists a nonzero element that multiplied by the receiver is zero.
	Assumes the receiver is an endomorphism."
	^ self kernel isTrivial not! !

!ModuleMap methodsFor: 'private' stamp: 'len 5/16/2019 20:40:52'!
codomain: aModule
	codomain _ aModule! !

!ModuleMap methodsFor: 'private' stamp: 'len 5/16/2019 20:40:56'!
domain: aModule
	domain _ aModule! !

!ModuleMap methodsFor: 'private' stamp: 'len 5/29/2020 10:58:40'!
matrix: aMatrix
	self propertyAt: #matrix put: aMatrix! !

!ModuleMap methodsFor: 'private' stamp: 'len 1/11/2018 18:20:06'!
species
	^ ModuleMap! !

!ModuleMap methodsFor: 'private' stamp: 'len 7/8/2022 11:14:14'!
validate
	self assert: super isModuleHomomorphism! !

!ModuleMap class methodsFor: 'instance creation' stamp: 'len 5/29/2020 10:46:33'!
from: aDomain to: aCodomain matrix: aMatrix
	^ self new
		domain: aDomain;
		codomain: aCodomain;
		matrix: aMatrix! !

!Matrix methodsFor: 'accessing' stamp: 'len 12/20/2021 13:26:46'!
at: aPoint
	"Answer the coefficient at i@j (row i, column j)."
	^ self atRow: aPoint x column: aPoint y! !

!Matrix methodsFor: 'accessing' stamp: 'len 4/26/2022 21:54:54'!
at: aPoint add: anElement
	self at: aPoint put: (self at: aPoint) + anElement! !

!Matrix methodsFor: 'accessing' stamp: 'len 12/20/2021 13:27:45'!
at: aPoint ifAbsent: exceptionBlock
	"Answer the coefficient at i@j (row i, column j), and evaluate aBlock if the indices are out of bounds."
	^ self atRow: aPoint x column: aPoint y ifAbsent: exceptionBlock! !

!Matrix methodsFor: 'accessing' stamp: 'len 12/20/2021 13:28:06'!
at: aPoint put: anObject
	"Answer the coefficient at i@j (row i, column j)."
	^ self atRow: aPoint x column: aPoint y put: anObject! !

!Matrix methodsFor: 'accessing' stamp: 'len 4/28/2022 12:34:14'!
atRow: i column: j
	^ self atRow: i column: j ifAbsent: [self scalars zero]! !

!Matrix methodsFor: 'accessing' stamp: 'len 4/28/2022 12:09:51'!
atRow: i column: j ifAbsent: exceptionBlock
	^ self subclassResponsibility! !

!Matrix methodsFor: 'accessing' stamp: 'len 5/29/2020 04:56:59'!
bitSize
	| answer |
	answer _ 0.
	self do: [:each| answer _ answer + each bitSize].
	^ answer! !

!Matrix methodsFor: 'accessing' stamp: 'len 11/23/2022 21:29:03'!
columnAt: j
	^ codomain fill: [:i| self at: i@j]! !

!Matrix methodsFor: 'accessing' stamp: 'len 5/29/2020 06:14:11'!
columnAt: j put: aTuple
	aTuple withIndexDo: [:each :i| self at: i@j put: each]! !

!Matrix methodsFor: 'accessing' stamp: 'len 5/29/2020 06:55:40'!
columns
	^ (Iterator on: self performing: #columnsDo:) asArray! !

!Matrix methodsFor: 'accessing' stamp: 'len 10/30/2023 19:02:17'!
denominator
	"If the coefficients ring is a localization, answer the LCM of the denominators of the coefficients."
	self scalars isLocalization ifFalse: [^ self scalars one].
	^ self propertyAt: #denominator ifAbsentPut:
		[self inject: self scalars numerators one into: [:d :each| each denominator lcm: d]]! !

!Matrix methodsFor: 'accessing' stamp: 'len 5/29/2020 07:26:49'!
diagonal
	^ (Iterator on: self performing: #diagonalDo:) asArray! !

!Matrix methodsFor: 'accessing' stamp: 'len 5/29/2020 06:32:28'!
height
	^ codomain rank! !

!Matrix methodsFor: 'accessing' stamp: 'len 4/5/2018 15:32:32'!
lastColumn
	^ self columnAt: self width! !

!Matrix methodsFor: 'accessing' stamp: 'len 1/6/2022 17:03:55'!
lastRow
	^ self rowAt: self height! !

!Matrix methodsFor: 'accessing' stamp: 'len 12/2/2022 14:25:27'!
lift
	"If the coefficients ring is a quotient R/I, answer a representative of the receiver over R."
	^ self class from: domain lift to: codomain lift fill: [:i :j| (self atRow: i column: j) lift]! !

!Matrix methodsFor: 'accessing' stamp: 'len 4/9/2024 08:02:20'!
numerator
	"If the coefficients ring is a localization, answer the product of the receiver by the LCM of the denominators of the coefficients. The answer is a matrix over the ring of numerators of the localization ring."
	| d |
	self scalars isLocalization ifFalse: [^ self].
	self propertyAt: #numerator ifPresent: [:aMatrix| ^ aMatrix].
	d := self scalars !! self denominator.
	^ self propertyAt: #numerator put: (self domain numerators to: self codomain numerators fill: [:i :j| ((self at: i@j) * d) numerator])! !

!Matrix methodsFor: 'accessing' stamp: 'len 12/2/2022 14:13:06'!
projection: anInteger
	"If the coefficients ring is a product ring, answer matrix induced by the projection to the anInteger-th component."
	^ self class from: (domain over: (domain scalars at: anInteger)) to: (codomain over: (domain scalars at: anInteger)) fill: [:i :j| (self atRow: i column: j) at: anInteger]! !

!Matrix methodsFor: 'accessing' stamp: 'len 11/23/2022 21:34:45'!
representative
	"If the coefficients ring is a quotient R/I, answer a representative of the receiver over R. See >>%."
	^ self class from: domain lift to: codomain lift fill: [:i :j| (self atRow: i column: j) representative]! !

!Matrix methodsFor: 'accessing' stamp: 'len 11/23/2022 21:29:28'!
rowAt: i
	^ domain fill: [:j| self at: i@j]! !

!Matrix methodsFor: 'accessing' stamp: 'len 5/29/2020 06:14:33'!
rowAt: i put: aTuple
	aTuple withIndexDo: [:each :j| self at: i@j put: each]! !

!Matrix methodsFor: 'accessing' stamp: 'len 5/29/2020 06:55:51'!
rows
	^ (Iterator on: self performing: #rowsDo:) asArray! !

!Matrix methodsFor: 'accessing' stamp: 'len 5/29/2020 04:58:46'!
width
	^ domain rank! !

!Matrix methodsFor: 'accessing' stamp: 'len 11/23/2022 21:34:54'!
zero
	| zero |
	zero _ self scalars zero.
	^ self class from: domain to: codomain fill: [:i :j| zero]! !

!Matrix methodsFor: 'comparing' stamp: 'len 5/15/2019 23:48:39'!
= anObject
	anObject isMatrix ifFalse: [^ false].
	self height = anObject height ifFalse: [^ false].
	self width = anObject width ifFalse: [^ false].
	1 to: self height do: [:i|
		1 to: self width do: [:j|
			(self at: i@j) = (anObject at: i@j) ifFalse: [^ false]]].
	^ true! !

!Matrix methodsFor: 'comparing' stamp: 'len 12/19/2023 21:08:34'!
~ aMatrix
	"Two rectangular matrices A and B are 'column equivalent' if there exists an invertible matrix P such that A * P = B. Two matrices are column equivalent if they have the same reduced column echelon form.
	In the case of square matrices, answer true if the receiver and the argument are associates as elements of a ring.
	Note that we define 'a ~ b' if there's a unit 'u' such that 'au = b' (this relation is called 'strongly associate' by some authors)."
	^ self coechelon = aMatrix coechelon! !

!Matrix methodsFor: 'comparing' stamp: 'len 4/5/2018 15:31:22'!
hash
	| answer |
	answer _ 0.
	1 to: self height do: [:i|
		1 to: self width do: [:j|
			answer _ answer hashMultiply + (self at: i@j) hash]].
	^ answer! !

!Matrix methodsFor: 'comparing' stamp: 'len 12/19/2023 21:07:16'!
≃ aMatrix
	"Two square matrices A and B are 'similar' or 'conjugate' if there exists an invertible matrix P such that P⁻¹ * A * P = B.
	This is the conjugacy equivalence relation in GL.
	Two matrices are similar if and only if they have the same rational canonical form (or Frobenius normal form)."
	^ self invariantFactors = aMatrix invariantFactors! !

!Matrix methodsFor: 'comparing' stamp: 'len 12/19/2023 21:07:27'!
≅ aMatrix
	"Two square matrices A and B over a field are 'congruent' if there exists an invertible matrix P such that P^T * A * P = B.
	Assuming the matrices are invertible, the congruence of A and B is equivalent to similarity of their associated cosquares."
	^ self cosquare ≃ aMatrix cosquare! !

!Matrix methodsFor: 'comparing' stamp: 'len 12/19/2023 21:07:36'!
≡ aMatrix
	"Two rectangular matrices A and B are 'equivalent' if there exist invertible matrices P and Q such that Q⁻¹ * A * P = B.
	Two matrices over a field are equivalent if and only if they have the same rank, and over a PID they are equivalent if and only if they have the same Smith normal form."
	^ self elementaryDivisors = aMatrix elementaryDivisors! !

!Matrix methodsFor: 'converting' stamp: 'len 4/1/2021 06:34:34'!
asMatrix
	^ self! !

!Matrix methodsFor: 'converting' stamp: 'len 4/5/2024 18:58:53'!
asPolynomial
	"If the receiver is a linear form, answer the receiver as a polynomial in the coordinate ring of the domain."
	| P |
	self isLinearForm ifFalse: [self error: 'not a linear form'].
	P := self domain coordinateRing.
	^ (P !!!! P generators) · (self asTuple over: P)! !

!Matrix methodsFor: 'converting' stamp: 'len 11/23/2022 21:32:48'!
asRationalMap
	| A B polynomials |
	A _ self domain coordinateRing.
	B _ self codomain coordinateRing.
	polynomials _ (self over: A) * (A !!!! A generators).
	^ A spec to: B spec representatives: polynomials! !

!Matrix methodsFor: 'converting' stamp: 'len 5/31/2022 18:10:34'!
asScalar
	"If the receiver is the embedding of an element of the scalars ring in an endomorphism algebra, answer the corresponding scalar."
	self isScalar ifFalse: [^ self error: 'not a scalar matrix'].
	^ self at: 1@1! !

!Matrix methodsFor: 'converting' stamp: 'len 5/5/2023 18:19:20'!
asTuple
	"Answer the receiver converted to Tuple by concatenating its rows (which is also the coordinates of the receiver in the canonical basis)."
	| answerCoefficients i |
	answerCoefficients _ self scalars new: self width * self height.
	i _ 1.
	self rowsDo: [:each|
		answerCoefficients replaceFrom: i to: i + self width - 1 with: each coefficients startingAt: 1.
		i _ i + self width].
	^ self scalars ^ (self width * self height) coefficients: answerCoefficients! !

!Matrix methodsFor: 'copying' stamp: 'len 4/26/2022 04:54:21'!
coproject: anArray
	^ self class from: (self  scalars ^ anArray size) to: codomain columns: (anArray collect: [:j| self columnAt: j])! !

!Matrix methodsFor: 'copying' stamp: 'len 11/23/2022 21:34:34'!
copyFrom: aPoint to: anotherPoint
	"Answer the submatrix of the receiver from aPoint to anotherPoint."

	| start |
	start _ aPoint - (1@1).
	^ self class
		from: (domain copyFrom: aPoint y to: anotherPoint y)
		to: (codomain copyFrom: aPoint x to: anotherPoint x)
		fill: [:i :j| self at: start + (i@j)]! !

!Matrix methodsFor: 'copying' stamp: 'len 4/26/2022 05:48:43'!
copyFromColumn: start to: end
	^ self copyFrom: 1 @ start to: self height @ end! !

!Matrix methodsFor: 'copying' stamp: 'len 4/26/2022 05:48:24'!
copyFromRow: start to: end
	^ self copyFrom: start @ 1 to: end @ self width! !

!Matrix methodsFor: 'copying' stamp: 'len 11/23/2022 21:39:09'!
copyWithout: aPoint
	"Answer the matrix obtained by removing the row i and column j from the receiver, where the argument is the point i@j."
	^ self scalars
		matrix: self height - 1 @ (self width - 1)
		fill: [:i :j| self at: (i < aPoint x ifTrue: [i] ifFalse: [i + 1]) @ (j < aPoint y ifTrue: [j] ifFalse: [j + 1])]! !

!Matrix methodsFor: 'copying' stamp: 'len 11/23/2022 21:39:15'!
copyWithoutColumn: anInteger
	"Answer the matrix obtained by removing the anInteger-th column from the receiver."
	^ self scalars
		matrix: self height @ (self width - 1)
		fill: [:i :j| self at: i @ (j < anInteger ifTrue: [j] ifFalse: [j + 1])]! !

!Matrix methodsFor: 'copying' stamp: 'len 11/23/2022 21:39:20'!
copyWithoutRow: anInteger
	"Answer the matrix obtained by removing the anInteger-th column from the receiver."
	^ self scalars
		matrix: self height - 1 @ self width
		fill: [:i :j| self at: (i < anInteger ifTrue: [i] ifFalse: [i + 1]) @ j]! !

!Matrix methodsFor: 'copying' stamp: 'len 12/24/2022 17:13:34'!
copyWithoutRowAndColumn: aPoint
	"Answer the matrix obtained by removing the row i and column j from the receiver, where the argument is the point i@j."
	^ self scalars
		matrix: self height - 1 @ (self width - 1)
		fill: [:i :j| self at: (i < aPoint x ifTrue: [i] ifFalse: [i + 1]) @ (j < aPoint y ifTrue: [j] ifFalse: [j + 1])]! !

!Matrix methodsFor: 'copying' stamp: 'len 4/26/2022 04:52:22'!
copyWithoutZeroColumns
	^ Matrix to: codomain columns: (self columns select: [:each| each isZero not])! !

!Matrix methodsFor: 'copying' stamp: 'len 4/26/2022 04:52:28'!
copyWithoutZeroRows
	^ Matrix from: domain rows: (self rows select: [:each| each isZero not])! !

!Matrix methodsFor: 'copying' stamp: 'len 4/26/2022 04:53:06'!
project: anArray
	^ self class from: domain to: (self scalars ^ anArray size) rows: (anArray collect: [:i| self rowAt: i])! !

!Matrix methodsFor: 'enumerating' stamp: 'len 3/24/2018 19:27:46'!
allSatisfy: aBlock
	self do: [:each| (aBlock value: each) ifFalse: [^ false]].
	^ true! !

!Matrix methodsFor: 'enumerating' stamp: 'len 11/23/2022 21:34:27'!
collect: aBlock
	^ self class from: self domain to: self codomain fill: [:i :j| aBlock value: (self at: i@j)]! !

!Matrix methodsFor: 'enumerating' stamp: 'len 4/5/2018 15:28:54'!
columnsDo: aBlock
	1 to: self width do: [:i| aBlock value: (self columnAt: i)]! !

!Matrix methodsFor: 'enumerating' stamp: 'len 5/29/2020 13:07:39'!
diagonalDo: aBlock
	1 to: (self width min: self height) do: [:i| aBlock value: (self at: i@i)]! !

!Matrix methodsFor: 'enumerating' stamp: 'len 4/5/2018 15:29:50'!
do: aBlock
	1 to: self height do: [:i|
		1 to: self width do: [:j|
			aBlock value: (self at: i@j)]]! !

!Matrix methodsFor: 'enumerating' stamp: 'len 7/14/2019 15:19:46'!
inject: thisValue into: binaryBlock 
	| nextValue |
	nextValue _ thisValue.
	self do: [:each | nextValue _ binaryBlock value: nextValue value: each].
	^ nextValue! !

!Matrix methodsFor: 'enumerating' stamp: 'len 5/18/2022 06:30:55'!
pivotsDo: aBlock
	"Enumerate the row-style pivot indices. These are the pairs i@j corresponding to the first nonzero entry of each row."
	| i |
	i _ 1.
	self rowsDo: [:each|
		each firstNonzeroIndex ifNotNil: [:j| aBlock value: i@j].
		i _ i + 1]! !

!Matrix methodsFor: 'enumerating' stamp: 'len 4/5/2018 15:43:00'!
rowsDo: aBlock
	1 to: self height do: [:i| aBlock value: (self rowAt: i)]! !

!Matrix methodsFor: 'enumerating' stamp: 'len 1/11/2024 11:17:13'!
withIndicesDo: aBlock
	1 to: self height do: [:i|
		1 to: self width do: [:j|
			aBlock value: (self atRow: i column: j) value: i value: j]]! !

!Matrix methodsFor: 'normal forms' stamp: 'len 12/29/2022 19:55:48'!
HNF
	"Answer the row-style Hermite normal form of the receiver."
	self isEmpty ifTrue: [^ self].
	self scalars isLocalization ifTrue: [^ (self numerator HNF over: self scalars) / self denominator].
	^ (HermiteEchelonization on: self) echelon! !

!Matrix methodsFor: 'normal forms' stamp: 'len 12/29/2022 19:56:35'!
HNFAndTransformation
	"Answer the row-style Hermite normal form H of the receiver A and the unique unimodular matrix T such that T*A = H."
	self scalars isLocalization ifTrue:
		[| HT |
		HT _ self numerator HNFAndTransformation.
		^ {(HT first over: self scalars) / self denominator. HT second over: self scalars}].
	^ (HermiteEchelonization on: self) echelonAndTransformation! !

!Matrix methodsFor: 'normal forms' stamp: 'len 12/7/2023 16:59:37'!
PRCF
	"Answer the primary rational canonical form of the receiver, assuming it's a square matrix over a field.
	The PRCF reflects a decomposition of the vector space into a maximal number of cyclic subspaces. Unlike the RCF, finding this form requires factorization of polynomials over the coefficients field, and as a consequence the primary rational canonical form may change when the same matrix is considered over an extension field of the coefficients field."
	^ self primaryInvariantFactors inject: (self scalars^0) id into: [:last :each| last ⊕ each companionMatrix]! !

!Matrix methodsFor: 'normal forms' stamp: 'len 12/7/2023 16:59:27'!
RCF
	"Answer the Frobenius normal form (or rational canonical form) of the receiver, assuming it's a square matrix over a field.
	The RCF of a matrix A reflects a minimal decomposition of the vector space into subspaces that are cyclic for A (i.e., spanned by some vector and its repeated images under A). A matrix B is similar to A iff it has the same rational canonical form as A. Unlike the PRCF, finding this form doesn't require factorization of polynomials or any operation that might change when extending the coefficients field (hence the 'rational'), showing that matrix similarity does not change upon field extensions."
	^ self invariantFactors inject: (self scalars^0) id into: [:last :each| last ⊕ each companionMatrix]! !

!Matrix methodsFor: 'normal forms' stamp: 'len 7/9/2023 17:57:41'!
SNF
	"Answer the Smith normal form of the receiver, assuming the coefficient ring is an elementary divisor ring."
	self propertyAt: #SNFAndTransformations ifPresent: [:anArray| ^ anArray first].
	^ self propertyAt: #SNF ifAbsentPut: [self scalars smithNormalFormOf: self]! !

!Matrix methodsFor: 'normal forms' stamp: 'len 12/13/2022 12:56:46'!
SNFAfterHNF
	"Answer the Smith normal form of the receiver. Perform first a HNF reduction."
	| H n |
	H _ self HNF.
	n _ H diagonal findLast: [:each| each isZero not].
	^ (H copyFrom: 1@1 to: n@n) SNF ⊕ (self scalars ^ ((H width max: H height) - n)) endomorphisms zero! !

!Matrix methodsFor: 'normal forms' stamp: 'len 7/9/2023 17:58:18'!
SNFAndTransformations
	"Answer the Smith normal form S of the receiver A and the unique unimodular matrices P and Q such that P*A*Q = S, assuming the coefficient ring is an elementary divisor ring."
	^ self propertyAt: #SNFAndTransformations ifAbsentPut: [self scalars smithNormalFormAndTransformationsOf: self]! !

!Matrix methodsFor: 'normal forms' stamp: 'len 7/9/2023 17:59:38'!
SNFOneStep
	| L S R zero one j k |
	self flag: #deprecated.
	L := self codomain id.
	R := self domain id.
	(self isEmpty or: [self isZero]) ifTrue: [^ {L. self. R}].
	S := self copy.
	zero := self scalars zero.
	one := self scalars one.

	"put a nonzero column as first column"
	j := 1.
	[(S columnAt: j) isZero] whileTrue: [j := j + 1].
	j > 1 ifTrue: [R at: 1@1 put: zero; at: j@j put: zero; at: 1@j put: one; at: j@1 put: one negated. S := S * R].

	self assert: self * R = S.

	"put a nonzero value at 1@1:"
	k := 1.
	[(S at: k@1) isZero] whileTrue: [k := k + 1].
	k > 1 ifTrue: [L at: 1@1 put: zero; at: k@k put: zero; at: 1@k put: one; at: k@1 put: one negated. S := L * S].

	self assert: L * self * R = S.

	2 to: S height do: [:i| | a1 ai euclid c d e f M |
		a1 := S at: 1@1.
		ai := S at: i@1.
		ai | a1 ifFalse:
			[euclid := ExtendedEuclid on: {a1. ai}.
			c := euclid bezout at: 1.
			d := (euclid bezout at: 2) negated.
			self assert: a1*c - (ai*d) = euclid gcd.
			e := ai negated / euclid gcd.
			f := a1 / euclid gcd.
			self assert: d*e + (c*f) = self scalars one.
			M := S codomain id.
			M at: 1@1 put: c; at: 1@i put: d negated; at: i@1 put: e; at: i@i put: f.
			self assert: M determinant = self scalars one.
			S := M * S.
			L := M * L.
			self assert: L * self * R = S]].

	"now everything in column 1 is divisible by the pivot at 1@1:"
	2 to: S height do: [:i| | x |
		x := (S at: i@1) negated / (S at: 1@1).
		S addRow: 1 times: x to: i.
		L addRow: 1 times: x to: i].

	self assert: L * self * R = S.

	"if anything at the right of the pivot in the first row is not zero, we recurse
	(the algorithm must termiate if the cofficients ring is Noetherian)"
	((j+1 to: self width) allSatisfy: [:jj| (S at: 1@jj) isZero])
		ifFalse:
			[| result |
			result := S transpose SNFOneStep.
			L := (result at: 3) * L.
			S := (result at: 2) transpose.
			R := R * (result at: 1) transpose].

	^ {L. S. R}! !

!Matrix methodsFor: 'normal forms' stamp: 'len 7/9/2023 17:59:43'!
SNFRecursive
	| L S R LL SS RR I result |
	self flag: #deprecated.
	L := self codomain id.
	R := self domain id.
	(self isEmpty or: [self isZero]) ifTrue: [^ {L. self. R}].

	result := self SNFOneStep.
	L := result at: 1.
	S := result at: 2.
	R := result at: 3.
	result := (S copyFrom: 2@2 to: S height @ S width) SNFRecursive.
	LL := result at: 1.
	SS := result at: 2.
	RR := result at: 3.
	
	I := (self scalars^1) id.
	L := I ⊕ LL * L.
	S := (I * (S at: 1@1)) ⊕ SS.
	R := R * (I ⊕ RR).

	"TODO: fix diagonal"
	
	^ {L. S. R}! !

!Matrix methodsFor: 'normal forms' stamp: 'len 12/22/2022 19:09:57'!
basis
	self propertyAt: #basisAndTransformation ifPresent: [:anArray| ^ anArray first].
	^ self propertyAt: #basis ifAbsentPut: [self scalars basisOf: self]! !

!Matrix methodsFor: 'normal forms' stamp: 'len 1/9/2022 13:13:24'!
basisAndTransformation
	^ self propertyAt: #basisAndTransformation ifAbsentPut: [self scalars basisAndTransformationOf: self]! !

!Matrix methodsFor: 'normal forms' stamp: 'len 12/22/2022 19:09:42'!
basisTransformation
	^ self basisAndTransformation second! !

!Matrix methodsFor: 'normal forms' stamp: 'len 12/29/2022 16:26:13'!
coechelon
	"Answer the column echelon form of the receiver."
	self propertyAt: #coechelonAndTransformation ifPresent: [:anArray| ^ anArray first].
	^ self propertyAt: #coechelon ifAbsentPut: [self transpose echelon transpose]! !

!Matrix methodsFor: 'normal forms' stamp: 'len 12/29/2022 16:27:29'!
coechelonAndTransformation
	"Answer an array with the column echelon form of the receiver and the transformation to echelon form."
	^ self propertyAt: #coechelonAndTransformation ifAbsentPut: [self transpose echelonAndTransformation collect: [:each| each transpose]]! !

!Matrix methodsFor: 'normal forms' stamp: 'len 12/29/2022 16:26:51'!
coechelonTransformation
	"Answer the transformation to column echelon form."
	^ self coechelonAndTransformation second! !

!Matrix methodsFor: 'normal forms' stamp: 'len 4/10/2021 12:28:33'!
dependentColumns
	"Answer the collection of indices of linearly dependent columns."
	| independent d answer |
	independent _ self independentColumns.
	d _ 1.
	answer _ OrderedCollection new: self width - independent size.
	independent do: [:i| answer addAll: (d to: i-1). d _ i+1].
	answer addAll: (d to: self width).
	^ answer! !

!Matrix methodsFor: 'normal forms' stamp: 'len 5/19/2023 07:11:55'!
echelon
	"Answer the row echelon form of the receiver."
	self propertyAt: #echelonAndTransformation ifPresent: [:anArray| ^ anArray first].
	^ self propertyAt: #echelon ifAbsentPut: [self scalars echelonOf: self]! !

!Matrix methodsFor: 'normal forms' stamp: 'len 5/19/2023 07:12:10'!
echelonAndTransformation
	"Answer an array with the row echelon form of the receiver and the transformation to echelon form."
	^ self propertyAt: #echelonAndTransformation ifAbsentPut: [self scalars echelonAndTransformationOf: self]! !

!Matrix methodsFor: 'normal forms' stamp: 'len 12/22/2022 18:42:10'!
echelonTransformation
	"Answer the transformation to row echelon form."
	^ self echelonAndTransformation second! !

!Matrix methodsFor: 'normal forms' stamp: 'len 7/7/2023 11:40:35'!
elementaryDivisors
	"Answer the diagonal of the Smith normal form, assuming the coefficient ring is an elementary divisor ring."
	self isEmpty ifTrue: [^ #()].
	self scalars isField ifTrue: [^ (1 to: self rank) collect: [:each| self scalars one]].
	^ self SNF diagonal asArray select: [:each| each isZero not]! !

!Matrix methodsFor: 'normal forms' stamp: 'len 7/13/2019 04:31:49'!
hessenberg
	"Answer the matrix similar to the receiver but in upper Hessenberg form (zeroes below the first subdiagonal)."
	^ self notYetImplemented! !

!Matrix methodsFor: 'normal forms' stamp: 'len 4/10/2021 12:28:27'!
independentColumns
	"Answer the collection of indices of linearly independent columns."
	^ self echelon pivots collect: [:each| each y]! !

!Matrix methodsFor: 'normal forms' stamp: 'len 5/17/2022 04:52:23'!
invariantFactors
	"Answer the invariant factors of the receiver, corresponding to the Frobenius normal form (or rational canonical form), assuming it's a square matrix over a field."
	^ self characteristicMatrix elementaryDivisors select: [:each| each degree > 0]! !

!Matrix methodsFor: 'normal forms' stamp: 'len 4/10/2024 04:01:46'!
jordan
	"Answer the Jordan blocks of the receiver's Jordan normal form."
	| spectrum blocks one zero |
	spectrum := self spectrum.
	spectrum size = self height ifFalse: [^ self error: 'the characteristic polynomial doesn''t split'].
"	I _ matrix species identity."
	blocks := Bag new.
	one := self scalars one.
	zero := self scalars zero.
	spectrum asSet do: [:eigenvalue|
		| multiplicity dimensions X T count |
		multiplicity := spectrum occurrencesOf: eigenvalue.
		dimensions := OrderedCollection new.
		X := self - (self domain to: self codomain scalar: eigenvalue).
		T := X.
		[(dimensions add: T nullity) < multiplicity] whileTrue: [T := T * X].
		count := 0.
		dimensions size to: 1 by: -1 do: [:n| | k block |
			k := (dimensions at: n) - (dimensions at: n-1 ifAbsent: [0]).
			block := (self scalars^n) endomorphisms fill: [:i :j| i=j ifTrue: [eigenvalue] ifFalse: [j-1=i ifTrue: [one] ifFalse: [zero]]].
			blocks add: block withOccurrences: k - count.
			count := count + k]].
	^ blocks! !

!Matrix methodsFor: 'normal forms' stamp: 'len 8/10/2020 05:25:58'!
orthogonalized
	"Perform the Gram-Schmidt orthogonalization process on the columns of the receiver."
	| orthogonalVectors orthogonalVectorsNorms2 u uv |
	orthogonalVectors _ OrderedCollection new: self width.
	orthogonalVectorsNorms2 _ OrderedCollection new: self width.
	self columns do: [:each|
		u _ each.
		orthogonalVectors with: orthogonalVectorsNorms2 do: [:v :vv|
			uv _ u · v.
			u _ u - (v * uv / vv)].
		orthogonalVectors add: u.
		orthogonalVectorsNorms2 add: u · u].
	^ self class from: domain to: codomain columns: orthogonalVectors! !

!Matrix methodsFor: 'normal forms' stamp: 'len 3/7/2017 08:34:26'!
pivots
	"Answer the collection of row-style pivot indices. These are the pairs i@j corresponding to the first nonzero entry of each row."
	^ Iterator on: self performing: #pivotsDo:! !

!Matrix methodsFor: 'normal forms' stamp: 'len 8/5/2021 08:40:26'!
primaryInvariantFactors
	^ self characteristicPolynomial factorization! !

!Matrix methodsFor: 'operations' stamp: 'len 11/7/2023 21:21:54'!
% anInteger
	self assert: self scalars = ℤ.
	^ self apply: (ℤ / anInteger) projection! !

!Matrix methodsFor: 'operations' stamp: 'len 4/5/2024 18:59:06'!
* anObject
	((self scalars includes: anObject) or: [anObject isInteger]) ifTrue: [^ self collect: [:each| each * anObject]].
	anObject isMatrix ifTrue: [^ self · anObject].
	anObject isTuple ifTrue: [^ self value: anObject].
	(anObject isKindOf: ModuleMap) ifTrue: [^ self · anObject].
	^ Error signal! !

!Matrix methodsFor: 'operations' stamp: 'len 11/23/2022 21:34:06'!
+ aMatrix
	aMatrix isMatrix ifFalse: [^ self adapt: aMatrix andSend: #+].
	self checkDomainsMatch: aMatrix.
	self checkCodomainsMatch: aMatrix.
	^ self class from: domain to: codomain fill: [:i :j| (self at: i@j) + (aMatrix at: i@j)]! !

!Matrix methodsFor: 'operations' stamp: 'len 3/23/2016 00:21'!
- aMatrix
	^ self + aMatrix negated! !

!Matrix methodsFor: 'operations' stamp: 'len 6/29/2023 14:12:32'!
/ anObject
	"Answer X such that XA = B, where B is the receiver and A is the argument.
	X is called a colift (or extension) of B along A, written B / A.
	If the argument is a scalar, just divide each element of the matrix by the scalar."
	(anObject isMatrix and: [self scalars = anObject scalars]) ifFalse: [^ super / anObject].
	^ (anObject colift: self) ifNil: [DivisibilityError new signalReceiver: self selector: #/ argument: anObject]! !

!Matrix methodsFor: 'operations' stamp: 'len 11/29/2023 10:36:15'!
\ anObject
	"Answer X such that AX = B, where A is the receiver and B is the argument.
	X is called a lift of B along A, written A \ B.
	The argument can also be a tuple, in which case it is considered as a column matrix and the returned value is also a tuple.
	This is the 'backslash' operator, as implemented in MATLAB, Octave and Sage."
	(anObject isMatrix and: [self scalars = anObject scalars])
		ifTrue: [^ (self lift: anObject) ifNil: [DivisibilityError new signalReceiver: self selector: #\ argument: anObject]].
	(anObject isTuple and: [self scalars = anObject scalars])
		ifTrue: [^ self preimageElement: anObject].
	^ super \ anObject! !

!Matrix methodsFor: 'operations' stamp: 'len 7/15/2021 12:37:58'!
adjugate
	"Answer the adjugate matrix (or classical adjoint matrix) of the receiver. This is the matrix such that multiplicated at the left by the receiver equals the scalar matrix with the determinant of the receiver in the diagonal."
	| f |
	f _ self characteristicPolynomial >> 1.
	^ (self height odd ifTrue: [f] ifFalse: [f negated]) value: self! !

!Matrix methodsFor: 'operations' stamp: 'len 8/10/2020 05:34:21'!
antitranspose
	^ self class from: codomain to: domain rows: (self columns reversed collect: [:each| each reversed])! !

!Matrix methodsFor: 'operations' stamp: 'len 5/5/2024 07:19:04'!
apply: aMap
	"Answer a new matrix with coefficients obtainted by applying aMap to the coefficients of the receiver.
	If aMap is a block we assume the parent doesn't change, i.e. the block must evaluate to values within the scalars ring of the receiver."

	aMap isBlock ifTrue: [^ domain to: codomain fill: [:i :j| aMap value: (self at: i@j)]].
	^ (domain over: aMap codomain) to: (codomain over: aMap codomain) fill: [:i :j| aMap value: (self at: i@j)]! !

!Matrix methodsFor: 'operations' stamp: 'len 10/19/2023 19:27:32'!
berkowitz
	"Answer the coefficients of the characteristic polynomial of the receiver.
	It's computed by the Berkowitz division-free algorithm and works over any commutative ring.
	It uses small space in comparision with classic Gaussian elimination and performs O(n^4) scalar operations."
	| n v C Ar R S Q one |
	self assert: self isSquare.
	one := self scalars one.
	(n := self width) = 0 ifTrue: [^ self scalars !!!! {one}].
	n = 1 ifTrue: [^ self scalars !!!! {one. (self at: 1@1) negated}].
	n = 2 ifTrue:
			[^ self scalars !!!!
				{one.
				((self at: 1@1) + (self at: 2@2)) negated.
				(self at: 1@1) * (self at: 2@2) - ((self at: 1@2) * (self at: 2@1))}].

	v := self scalars !!!!
		{one.
		(self at: 2@2) negated - (self at: 1@1).
		(self at: 2@2) * (self at: 1@1) - ((self at: 1@2) * (self at: 2@1))}.

	3 to: n do: [:r|
		C := (self scalars^r ⇒ (self scalars^(r+1))) zero.
		Ar := self copyFrom: 1@1 to: r-1 @ (r-1).

		R := (self rowAt: r) copyFrom: 1 to: r-1.
		S := (self columnAt: r) copyFrom: 1 to: r-1.

		C at: 1@1 put: one negated.
		C at: 2@1 put: (self at: r@r).
		C at: 3@1 put: (R · S).

		Q := Ar * S.

		C at: 4@1 put: (R · Q).

		3 to: r-1 do: [:i|
			Q := Ar * Q.
			C at: i+2 @ 1 put: (R · Q)].

		2 to: r do: [ :i |
			0 to: r+1-i do: [ :j |
				C at: i+j @ i put: (C at: j+1 @ 1)]].

		v := C * v].

	^ n even ifTrue: [v] ifFalse: [v negated]! !

!Matrix methodsFor: 'operations' stamp: 'len 11/23/2022 21:36:49'!
characteristicMatrix
	"Answer the characteristic matrix I*x - A."
	| P x M |
	P _ self scalars polynomials.
	x _ P x.
	M _ P^self width.
	^ M to: M fill: [:i :j|
		i = j
			ifTrue: [x - (P constant: (self at: i @ j))]
			ifFalse: [P constant: (self at: i @ j) negated]]! !

!Matrix methodsFor: 'operations' stamp: 'len 4/10/2024 11:52:49'!
characteristicPolynomial
	self scalars isLocalization ifTrue:
		[| P x d answer |
		P := self scalars numerators polynomials.
		x := P x.
		d := self denominator.
		answer := ((self domain ⇒ self codomain over: P) asRing one * (x * d) - (self numerator over: P)) determinant over: self scalars.
		self width timesRepeat: [answer := answer / d].
		^ answer].
	self width <= 6 ifTrue: [^ self characteristicMatrix determinant].
	^ self scalars polynomials coefficients: self berkowitz coefficients reversed

"TODO: best algorithms choices are:
	- for Z use modular algorithm: compute modulo p for many primes p, then CRT;
	- for finite fields (fields with no coefficient explosion) use Hessenberg form with O(n^3);
	- for general ring, use Berkowitz"
! !

!Matrix methodsFor: 'operations' stamp: 'len 5/8/2023 16:56:08'!
characteristicPolynomial3
	"[Coh96] Algorithm 2.2.7. (Characteristic Polynomial and Adjoint Matrix) O(n^4).
	This is the Faddeev-Leverrier algorithm and works over a commutative ring of characteristic 0 or characteristic coprime to 1..n. It also computes the determinant as a side product."
	| n i I C a |
	n _ self height.
	i _ 0. I _ self identity. C _ I. a _ OrderedCollection new: n+1.
	a add: self scalars one.
	[(i _ i + 1) = n
		ifTrue:
			[a add: (self * C) trace negated / n.
			^ self scalars polynomials newFrom: a reversed. "adj _ (-1)^(n-1) * C"].
	C _ self * C.
	a add: C trace negated / i.
	C _ C + (I * a last)] repeat! !

!Matrix methodsFor: 'operations' stamp: 'len 5/8/2023 16:56:45'!
characteristicPolynomial4
	"This is the Faddeev-Leverrier algorithm to compute the characteristic polynomial, adjoint matrix and determinant of a matrix. It works over a commutative ring of characteristic 0 or characteristic coprime to 1..n. It runs in O(n^4)."
	| n p I B |
	n _ self height.
	p _ self scalars new: n+1.
	p at: n+1 put: self scalars one.
	I _ self identity.
	B _ I.
	1 to: n-1 do: [:k|
		B _ self*B.
		B _ B + (I*(p at: n-k+1 put: B trace negated / k))].
	p at: 1 put: (self*B) trace negated / n.
	^ self scalars polynomials coefficients: p! !

!Matrix methodsFor: 'operations' stamp: 'len 5/8/2023 16:57:30'!
characteristicPolynomialAndAdjoint
	"[Coh96] Algorithm 2.2.7. (Characteristic Polynomial and Adjoint Matrix) O(n^4)."
	| n i I C a |
	n _ self height.
	i _ 0. I _ self identity. C _ I. a _ OrderedCollection new: n.
	a add: self scalars one.
	[(i _ i + 1) = n
		ifTrue:
			[a add: (self * C) trace negated / n.
			^ {self scalars polynomials newFrom: a reversed. (-1)^(n-1) * C}].
	C _ self * C.
	a add: C trace negated / i.
	C _ C + (I * a last)] repeat! !

!Matrix methodsFor: 'operations' stamp: 'len 10/13/2016 14:00'!
cofactor: aPoint
	"Answer the cofactor i@j of the receiver."

	^ (aPoint x + aPoint y) even
		ifTrue: [self minor: aPoint]
		ifFalse: [(self minor: aPoint) negated]! !

!Matrix methodsFor: 'operations' stamp: 'len 5/3/2021 10:57:09'!
columnExtended
	"Answer a square full rank matrix, adding columns if needed."
	| M |
	(self isSquare and: [self isFullRank]) ifTrue: [^ self].
	M _ self ⊔ self codomain id.
	^ Matrix from: self codomain to: self codomain columns: (M independentColumns collect: [:i| M columnAt: i])! !

!Matrix methodsFor: 'operations' stamp: 'len 8/9/2020 07:53:30'!
comatrix
	"Answer the co-matrix (or cofactor matrix) of the receiver, i.e. the matrix '(a{ij})' where 'a{ij}' is the cofactor 'ij'."
	^ self adjugate transpose! !

!Matrix methodsFor: 'operations' stamp: 'len 5/28/2023 15:53:17'!
conjugate
	"Answer the conjugate transpose of the receiver. This is the involution of the matrix algebra."
	^ self scalars isInvolutive ifTrue: [self transpose collect: [:each| each conjugate]] ifFalse: [self transpose]! !

!Matrix methodsFor: 'operations' stamp: 'len 5/14/2023 12:04:25'!
content
	"Answer the GCD of the coefficients of the receiver."
	| answer |
	self isZero ifTrue: [^ self scalars zero].
	self scalars isField ifTrue: [^ self scalars one].
	answer _ self scalars zero.
	self do: [:each| answer _ answer gcd: each. answer isOne ifTrue: [^ answer]].
	^ answer! !

!Matrix methodsFor: 'operations' stamp: 'len 12/11/2022 09:29:30'!
cosquare
	^ self transpose inverse * self! !

!Matrix methodsFor: 'operations' stamp: 'len 4/2/2024 06:40:48'!
determinant
	| n a0 |
	self assert: self isSquare.
	self isEmpty ifTrue: [^ self scalars one].
	n := self width.
	"For localizations, compute the determinant of the numerator matrix and divide by denominator n times:"
	self scalars isLocalization ifTrue:
		[| answer d |
		answer := self scalars !! self numerator determinant.
		d := self denominator.
		n timesRepeat: [answer := answer / d].
		^ answer].
	self scalars isProduct ifTrue:
		[^ self scalars compose: ((1 to: self scalars components size) collect: [:i| (self projection: i) determinant])].
	"For small matrices use Laplace expansion:"
	n <= 6 ifTrue: [^ (1 to: n) sum: [:i| (self at: i@1) * (self cofactor: i@1)]].
	"Over a field use Gaussian elimination:"
	self scalars isField ifTrue: [^ (GaussJordanEchelonization on: self) determinant].
	"Otherwise get the determinant from the characteristic polynomial (possibly computed by Berkowitz algorithm):"
	a0 := self characteristicPolynomial independentCoefficient.
	^ n even ifTrue: [a0] ifFalse: [a0 negated]! !

!Matrix methodsFor: 'operations' stamp: 'len 7/12/2019 04:58:17'!
determinant1
	| a0 |
	a0 _ self characteristicPolynomial independentCoefficient.
	^ self height even ifTrue: [a0] ifFalse: [a0 negated]! !

!Matrix methodsFor: 'operations' stamp: 'len 5/22/2022 11:09:39'!
determinant2
	"[Coh96] Algorithm 2.2.6. (Determinant using Gauss-Bareiss). O(n^3)"
	| n M k c s p i t |
	self assert: self scalars isIntegralDomain.
	self assert: self isSquare.
	n _ self height.
	M _ self copy.
	k _ 0. c _ self scalars one. s _ self scalars one.
	[k _ k + 1.
	k = n ifTrue: [^ s * (M at: n@n)].
	p _ M at: k@k. i _ k.
	p isZero ifTrue: [i _ (k+1 to: n) detect: [:j| (M at: j@k) isZero not] ifNone: [^ self scalars zero]].
	k to: n do: [:j| t _ M at: i@j. M at: i@j put: (M at: k@j). M at: k@j put: t].
	s _ s negated.
	p _ M at: k@k.
	"the division t/c is exact, must use Euclidean division and discard the remainder"
	c | t ifFalse: [self halt].
	k+1 to: n do: [:j| t _ p * (M at: i@j) - ((M at: i@k) * (M at: k@j)). M at: i@j put: t/c].
	c _ p] repeat! !

!Matrix methodsFor: 'operations' stamp: 'len 10/19/2023 09:54:30'!
determinant3
	self assert: self isSquare.
	self isEmpty ifTrue: [^ self scalars one].
	^ (1 to: self height) sum: [:i| (self at: i@1) * (self cofactor: i@1)]! !

!Matrix methodsFor: 'operations' stamp: 'len 6/14/2023 15:08:27'!
determinantModular
	| B C n r moduli determinants |
	B := 0.
	self do: [:each| B := B max: each abs].
	n := self width.
	C := (n^n) sqrt * (B^n).
	r := (C log: 2) ceiling.
	moduli := OrderedCollection new: r.
	moduli add: 2.
	r - 1 timesRepeat: [moduli add: moduli last nextPrime].
	determinants := moduli collect: [:each| (self % each) determinant].
	^ (CRT solve: determinants) lift! !

!Matrix methodsFor: 'operations' stamp: 'len 4/5/2018 15:29:05'!
determinantx
	(self height = 2 and: [self width = 2])
		ifTrue: [^ (self at: 1@1) * (self at: 2@2) - ((self at: 2@1) * (self at: 1@2))].
	^ self determinant! !

!Matrix methodsFor: 'operations' stamp: 'len 4/10/2024 04:00:50'!
gcd: aMatrix
	"The GCD is well defined for scalar matrices over a ring with GCD."
	^ self domain to: self codomain scalar: (self asScalar gcd: aMatrix asScalar)! !

!Matrix methodsFor: 'operations' stamp: 'len 6/29/2023 19:48:28'!
index
	"Answer the index of the receiver, assuming it is an endomorphism.
	This is precisely the Euler characteristic of the 2-term complex 0 → domain → codomain → 0."
	^ self kernel rank - self cokernel rank! !

!Matrix methodsFor: 'operations' stamp: 'len 4/6/2021 11:06:49'!
kernel
	^ self syzygies image! !

!Matrix methodsFor: 'operations' stamp: 'len 8/14/2024 11:23:46'!
kernelMorphism
	self flag: #fixme. "not sure this is correct, it's not unique"
	^ self syzygies
"maybe should be:
	^ self syzygies image₁"! !

!Matrix methodsFor: 'operations' stamp: 'len 6/20/2024 14:53:51'!
kronecker: anObject
	"Answer the Kronecker product of the receiver by the argument, if the argument is another matrix.
	If the argument is a ring, answer the extension of scalars."
	| m n p q |
	self assert: self scalars = anObject scalars.
	m := self height.
	n := self width.
	p := anObject height.
	q := anObject width.
	self flag: #fixme. "this is inefficient"
	^ self scalars^(n*q)
		to: self scalars^(m*p)
		fill: [:i :j|
			(self at: (i-1)*m//(m*p)+1 @ ((j-1)*n//(n*q)+1)) *
			(anObject at: (i-1)\\p+1 @ ((j-1)\\q+1))]! !

!Matrix methodsFor: 'operations' stamp: 'len 4/10/2024 04:01:58'!
lcm: aMatrix
	"The LCM is well defined for scalar matrices over a ring with GCD."
	^ self domain to: self codomain scalar: (self asScalar lcm: aMatrix asScalar)! !

!Matrix methodsFor: 'operations' stamp: 'len 10/19/2023 09:55:58'!
minimalPolynomial
	| P n answer |
	self assert: self isSquare.
	self assert: self scalars isIntegralDomain.
	P := self scalars polynomials.
	n := self width.
	answer := P one.
	self codomain basis do: [:eᵢ| "It's not necessary to iterate over the whole basis"
		| v L K s |
		v := eᵢ.
		L := OrderedCollection new: n + 1.
		L add: v.
		[v := self * v.
		L add: v.
		K := (Matrix columns: L) syzygies.
		K isZero] whileTrue.
		K := K coechelon.
		s := K columns first coefficients.
		answer := answer lcm: (P coefficients: s / s last).
		answer degree = n ifTrue: [^ answer]].
	^ answer! !

!Matrix methodsFor: 'operations' stamp: 'len 6/15/2023 16:43:59'!
minor: aPoint
	"Answer the (i,j)-minor, i.e. the determinant of the matrix obtained by removing row i and column j from the receiver."
	^ (self copyWithoutRowAndColumn: aPoint) determinant! !

!Matrix methodsFor: 'operations' stamp: 'len 11/23/2022 21:39:32'!
minors: k
	"Answer the list of all the k-minors of the receiver, i.e. the determinants of all matrices obtained by deleting m - k rows and n - k columns."
	| answer |
	answer _ OrderedCollection new.
	(1 to: self height) combinations: k atATimeDo: [:rows|
		(1 to: self width) combinations: k atATimeDo: [:columns|
			answer add: (self scalars matrix: k@k fill: [:i :j| self at: (rows at: i) @ (columns at: j)]) determinant]].
	^ answer! !

!Matrix methodsFor: 'operations' stamp: 'len 3/23/2016 00:23'!
negated
	^ self collect: [:each| each negated]! !

!Matrix methodsFor: 'operations' stamp: 'len 12/22/2022 18:45:22'!
normalization
	"Answer a unit u such that 'self * u' is a unique choice of associate. See >>normalized."
	self isSquare ifFalse: [^ self error: 'not square'].
	(self scalars isPID not or: [self isZero]) ifTrue: [^ self one].
	^ self coechelonTransformation! !

!Matrix methodsFor: 'operations' stamp: 'len 1/7/2022 14:23:27'!
normalized
	"Answer a unique choice of associate. See >>normalization."
	self isSquare ifFalse: [^ self error: 'not square'].
	self scalars isPID ifFalse: [^ self].
	^ self coechelon! !

!Matrix methodsFor: 'operations' stamp: 'len 4/5/2018 15:33:02'!
nullity
	^ self width - self rank! !

!Matrix methodsFor: 'operations' stamp: 'len 11/5/2022 14:06:28'!
opposite
	"Answer the receiver as an element of the opposite ring."
	^ self conjugate! !

!Matrix methodsFor: 'operations' stamp: 'len 4/3/2024 08:59:25'!
permanent
	| n |
	self assert: self isSquare.
	n := self width.
	^ (SymmetricGroup new: n) elements sum: [:σ| (1 to: n) product: [:i| self atRow: i column: (σ value: i)]]! !

!Matrix methodsFor: 'operations' stamp: 'len 11/29/2023 10:37:38'!
preimageElement: aTuple
	"Answer a tuple in the preimage of aTuple.
	Answer nil if aTuple is not in the image of the receiver."
	^ (self lift: aTuple asMatrix) ifNotNil: [:aMatrix| aMatrix asTuple]! !

!Matrix methodsFor: 'operations' stamp: 'len 4/19/2024 14:41:17'!
rank
	^ self echelon pivots size

"alternative:
	^ self echelon rows count: [:each| each isZero not]
"! !

!Matrix methodsFor: 'operations' stamp: 'len 10/19/2023 13:37:14'!
restriction
	"This is the 'restriction of scalars' functor.
	If the receiver is a n × m matrix over a finite R-algebra with underlying free module R^d, answer a n*d × m*d matrix with coefficients in R seen as an n × m block matrix with each block equal to the representation matrix of the corresponding coefficient in the original matrix.
	This functor is right adjoint to 'extension of scalars' (see #⊗) and left adjoint to 'coextension of scalars' (see #⇒)."
	| R d answer |
	self propertyAt: #restriction ifPresent: [:aMatrix| ^ aMatrix].
	R := self scalars scalars.
	d := self scalars asModule rank.
	answer := R^(self width*d) → (R^0).
	1 to: self height do: [:i|
		| a |
		a := R^0 → (R^d).
		1 to: self width do: [:j| a := a ⊔ (self at: i@j) representation asMatrix].
		answer := answer ⊓ a].
	^ self propertyAt: #restriction put: answer! !

!Matrix methodsFor: 'operations' stamp: 'len 3/31/2021 09:42:21'!
rowExtended
	"Answer a square full rank matrix, adding rows if needed."
	^ self transpose columnExtended transpose! !

!Matrix methodsFor: 'operations' stamp: 'len 10/19/2023 09:53:56'!
trace
	| answer |
	self assert: self isSquare.
	answer := self scalars zero.
	1 to: self height do: [:i| answer := answer + (self at: i@i)].
	^ answer! !

!Matrix methodsFor: 'operations' stamp: 'len 11/23/2022 21:34:49'!
transpose
	^ self class from: codomain to: domain fill: [:i :j| self at: j@i]! !

!Matrix methodsFor: 'operations' stamp: 'len 11/26/2023 20:46:10'!
value: aTuple
	^ codomain fill: [:i| (self rowAt: i) · aTuple]! !

!Matrix methodsFor: 'operations' stamp: 'len 7/21/2024 09:33:21'!
∘ aMatrix
	| rows columns |
	aMatrix isMatrix ifFalse: [^ super ∘ aMatrix].
	self checkCompatibleComposition: aMatrix.
	rows := self rows asArray.
	columns := aMatrix columns asArray.
	^ self class from: aMatrix domain to: self codomain fill: [:i :j| (rows at: i) · (columns at: j)]! !

!Matrix methodsFor: 'operations' stamp: 'len 5/3/2024 04:51:57'!
⊓ aMatrix
	"Answer the pairing of the receiver and the argument.
	This is the row-augmented matrix with the receiver stacked on top of the argument.
	If the receiver is A and the argument is B, output a matrix of the form:
	  [A]
	  [B]"
	aMatrix isTuple ifTrue: [^ self ⊓ aMatrix asRowMatrix].
	aMatrix isMatrix ifFalse: [^ super ⊓ aMatrix].
	self checkDomainsMatch: aMatrix.
	^ self class from: domain to: codomain ⊕ aMatrix codomain rows: self rows, aMatrix rows! !

!Matrix methodsFor: 'operations' stamp: 'len 5/3/2024 04:53:25'!
⊔ aMatrix
	"Answer the copairing of the receiver and the argument.
	This is the column-augmented matrix with the receiver concatenated with the argument.
	If the receiver is A and the argument is B, output a matrix of the form:
	  [A B]"
	aMatrix isTuple ifTrue: [^ self ⊔ aMatrix asMatrix].
	aMatrix isMatrix ifFalse: [^ super ⊔ aMatrix].
	self checkCodomainsMatch: aMatrix.
	^ self class from: domain ⊕ aMatrix domain to: codomain columns: self columns, aMatrix columns! !

!Matrix methodsFor: 'operations' stamp: 'len 11/23/2022 21:34:17'!
⊕ aMatrix
	"Answer the block sum of the receiver and the argument.
	If the receiver is A and the argument is B, output a matrix of the form:
	  [A 0]
	  [0 B]"
	aMatrix isMatrix ifFalse: [^ super ⊕ aMatrix].
	^ self class from: domain ⊕ aMatrix domain to: codomain ⊕ aMatrix codomain fill: [:i :j| self at: i @ j ifAbsent: [aMatrix at: i - self height @ (j - self width) ifAbsent: [self scalars zero]]]! !

!Matrix methodsFor: 'operations' stamp: 'len 7/29/2024 09:33:30'!
⊗ anObject
	"Answer the tensor product of the receiver by the argument as module homomorphisms, if the argument is another matrix.
	If the argument is a ring, answer the extension of scalars."
	| m n p q |
	anObject isTuple ifTrue: [^ self ⊗ anObject asMatrix].
	(anObject isKindOf: Ring) ifTrue: [^ self apply: self scalars → anObject].
	anObject isMatrix ifFalse: [^ super ⊗ anObject].
	"Since we identify the tensor product of free modules Rⁿ ⊗ Rᵐ with Rⁿᵐ, the tensor product of matrices (as homomorphisms of free modules) coincides with the Kronecker product."
	self assert: self scalars = anObject scalars.
	m := self height.
	n := self width.
	p := anObject height.
	q := anObject width.
	self flag: #fixme. "this is inefficient"
	^ self scalars^(n*q)
		to: self scalars^(m*p)
		fill: [:i :j|
			(self at: (i-1)*m//(m*p)+1 @ ((j-1)*n//(n*q)+1)) *
			(anObject at: (i-1)\\p+1 @ ((j-1)\\q+1))]! !

!Matrix methodsFor: 'operations-inplace' stamp: 'len 5/19/2023 14:52:43'!
+= aMatrix
	self replaceWith: self plus: aMatrix! !

!Matrix methodsFor: 'operations-inplace' stamp: 'len 5/19/2023 14:52:36'!
-= aMatrix
	self replaceWith: self minus: aMatrix! !

!Matrix methodsFor: 'operations-inplace' stamp: 'len 1/6/2024 10:30:53'!
PLE: aBlock
"	| n nₕ A₁ A₂ A₃ C₁ C₂ C₃|
	(n := self width) <= 1 ifTrue: [^ self "..."].
	nₕ := n - 1 // 2 + 1.
	m := self height.
	mₕ := m - 1 // 2 + 1.
	self horizontalSplit: [:A₁ :A₂|
		A₁ PLE: [:P₁ :L₁ :E₁|
			A₂ verticalSplit: [:A₃ :A₄|
				A₂ replaceWith: P₁ times: A₂.
				L₁ verticalSplit: [:L₁₁ :L₁₂|
					
					A₃ replaceWithLowerTriangular: L₁₁ inverse times: A₃.
					^ aBlock value: 
	C₁ := self from: 1 @ 1 to: nₕ @ nₕ.
	C₂ := self from: 1 @ (nₕ + 1) to: nₕ @ n.
	C₃ := self from: nₕ + 1 @ (nₕ + 1) to: n @ n.
	C₁ replaceWithUpperTriangularInverse: A₁.
	C₂ replaceWith: A₂ timesUpperTriangular: C₃.
	C₂ accumulateWithUpperTriangular: C₁ times: C₂ timesScalar: -1.
	C₃ replaceWithUpperTriangularInverse: A₃"! !

!Matrix methodsFor: 'operations-inplace' stamp: 'len 1/6/2024 10:34:23'!
permuteColumnsBy: aPermutation
	self height > 0 ifFalse: [^ self].
	aPermutation withIndexDo: [:j :i|
		self assert: j >= i.
		self swapColumn: i with: j]! !

!Matrix methodsFor: 'operations-inplace' stamp: 'len 1/6/2024 10:34:05'!
permuteRowsBy: aPermutation
	self width > 0 ifFalse: [^ self].
	aPermutation withIndexDo: [:j :i|
		self assert: j >= i.
		self swapRow: i with: j]! !

!Matrix methodsFor: 'operations-inplace' stamp: 'len 5/26/2023 18:45:10'!
replacePeelingStrassenWinogradWith: aMatrix1 times: aMatrix2
	"Apply dynamic peeling if needed and perform Strassen-Winograd on submatrices with even dimensions.
	Assumes the matrices are square."
	| n A B C₁₁ |
	(n := aMatrix1 width) even ifTrue: [^ self replaceStrassenWinogradWith: aMatrix1 times: aMatrix2].
	A := aMatrix1.
	B := aMatrix2.
	C₁₁ := self from: 1@1 to: n-1 @ (n-1).
	C₁₁ replaceStrassenWinogradWith: (A from: 1@1 to: n-1 @ (n-1)) times: (B from: 1@1 to: n-1 @ (n-1)).
	C₁₁ accumulateWith: (A from: 1@n to: n-1@n) times: (B from: n@1 to: n@(n-1)).
	(self from: 1@n to: n-1@n) replaceWith: (A from: 1@1 to: n-1@n) times: (B from: 1@n to: n@n).
	(self from: n@1 to: n@n) replaceWith: (A from: n@1 to: n@n) times: B! !

!Matrix methodsFor: 'operations-inplace' stamp: 'len 1/22/2024 10:58:52'!
replaceSolveLowerTriangular: aMatrix
	| n nₕ A₁ A₂ A₃ B₁ B₂ |
	self assert: aMatrix isLowerTriangular.
	self assert: aMatrix isSquare.
	self assert: aMatrix width = self height.
	(n := aMatrix width) <= 1 ifTrue: [^ self at: 1@1 put: (self at: 1@1) * (aMatrix at: 1@1) inverse].
	nₕ := n - 1 // 2 + 1.
	A₁ := aMatrix from: 1 @ 1 to: nₕ @ nₕ.
	A₂ := aMatrix from: nₕ + 1 @ 1 to: n @ nₕ.
	A₃ := aMatrix from: nₕ + 1 @ (nₕ + 1) to: n @ n.
	B₁ := self from: 1 @ 1 to: nₕ @ n.
	B₂ := self from: nₕ + 1 @ 1 to: n @ n.
	B₁ replaceSolveLowerTriangular: A₁.
	B₂ accumulateWith: A₂ times: B₁ timesScalar: -1.
	B₂ replaceSolveLowerTriangular: A₃! !

!Matrix methodsFor: 'operations-inplace' stamp: 'len 1/22/2024 10:58:46'!
replaceSolveUpperTriangular: aMatrix
	| n nₕ A₁ A₂ A₃ B₁ B₂ |
	self assert: aMatrix isUpperTriangular.
	self assert: aMatrix isSquare.
	self assert: aMatrix width = self height.
	(n := aMatrix width) <= 1 ifTrue: [^ self at: 1@1 put: (self at: 1@1) * (aMatrix at: 1@1) inverse].
	nₕ := n - 1 // 2 + 1.
	A₁ := aMatrix from: 1 @ 1 to: nₕ @ nₕ.
	A₂ := aMatrix from: 1 @ (nₕ + 1) to: nₕ @ n.
	A₃ := aMatrix from: nₕ + 1 @ (nₕ + 1) to: n @ n.
	B₁ := self from: 1 @ 1 to: nₕ @ n.
	B₂ := self from: nₕ + 1 @ 1 to: n @ n.
	B₂ replaceSolveUpperTriangular: A₃.
	B₁ accumulateWith: A₂ times: B₂ timesScalar: -1.
	B₁ replaceSolveUpperTriangular: A₁! !

!Matrix methodsFor: 'operations-inplace' stamp: 'len 4/9/2024 08:33:03'!
replaceStrassenWinogradWith: aMatrix1 times: aMatrix2
	"Strassen-Winograd matrix multiplication algorithm with complexity O(n^ω), ω = log₂(7) ≈ 2.8074.
	Schedule with 2 temporary matrices from [BDPZ07] and dynamic peeling as [HLJJ+96].
	Assumes the matrices are square with even dimension."
	| A B m ℓ n mₕ ℓₕ nₕ A₁₁ A₁₂ A₂₁ A₂₂ B₁₁ B₁₂ B₂₁ B₂₂ C₁₁ C₁₂ C₂₁ C₂₂ S₁ S₂ S₃ S₄ T₁ T₂ T₃ T₄ P₁ P₂ P₃ P₄ P₅ P₆ P₇ U₁ U₂ U₃ U₄ U₅ U₆ U₇ X Y |
	A := aMatrix1.
	B := aMatrix2.
	m := A height.
	ℓ := A width.
	n := B height.
	mₕ := m - 1 // 2 + 1.
	ℓₕ := ℓ - 1 // 2 + 1.
	nₕ := n - 1 // 2 + 1.
	A₁₁ := A from: 1 @ 1 to: mₕ @ ℓₕ.
	A₁₂ := A from: 1 @ (ℓₕ + 1) to: mₕ @ ℓ.
	A₂₁ := A from: mₕ + 1 @ 1 to: m @ ℓₕ.
	A₂₂ := A from: mₕ + 1 @ (ℓₕ + 1) to: m @ ℓ.
	self assert: A₁₁ ⊔ A₁₂ ⊓ (A₂₁ ⊔ A₂₂) = A.
	B₁₁ := B from: 1 @ 1 to: ℓₕ @ nₕ.
	B₁₂ := B from: 1 @ (nₕ + 1) to: ℓₕ @ n.
	B₂₁ := B from: ℓₕ + 1 @ 1 to: ℓ @ nₕ.
	B₂₂ := B from: ℓₕ + 1 @ (nₕ + 1) to: ℓ @ n.
	self assert: B₁₁ ⊔ B₁₂ ⊓ (B₂₁ ⊔ B₂₂) = B.
	C₁₁ := self from: 1 @ 1 to: mₕ @ nₕ.
	C₁₂ := self from: 1 @ (nₕ + 1) to: mₕ @ n.
	C₂₁ := self from: mₕ + 1 @ 1 to: m @ nₕ.
	C₂₂ := self from: mₕ + 1 @ (nₕ + 1) to: m @ n.
	self assert: C₁₁ ⊔ C₁₂ ⊓ (C₂₁ ⊔ C₂₂) = self.
	X := A₁₁ zero. Y := X copy.
	S₃ := X replaceWith: A₁₁ minus: A₂₁.
	T₃ := Y replaceWith: B₂₂ minus: B₁₂.
	P₇ := C₂₁ replaceWith: S₃ times: T₃.
	S₁ := X replaceWith: A₂₁ plus: A₂₂.
	T₁ := Y replaceWith: B₁₂ minus: B₁₁.
	P₅ := C₂₂ replaceWith: S₁ times: T₁.
	S₂ := X replaceWith: S₁ minus: A₁₁.
	T₂ := Y replaceWith: B₂₂ minus: T₁.
	P₆ := C₁₂ replaceWith: S₂ times: T₂.
	S₄ := X replaceWith: A₁₂ minus: S₂.
	P₃ := C₁₁ replaceWith: S₄ times: B₂₂.
	P₁ := X replaceWith: A₁₁ times: B₁₁.
	U₂ := C₁₂ replaceWith: P₁ plus: P₆.
	U₃ := C₂₁ replaceWith: U₂ plus: P₇.
	U₄ := C₁₂ replaceWith: U₂ plus: P₅.
	U₇ := C₂₂ replaceWith: U₃ plus: P₅.
	U₅ := C₁₂ replaceWith: U₄ plus: P₃.
	T₄ := Y replaceWith: T₂ minus: B₂₁.
	P₄ := C₁₁ replaceWith: A₂₂ times: T₄.
	U₆ := C₂₁ replaceWith: U₃ minus: P₄.
	P₂ := C₁₁ replaceWith: A₁₂ times: B₂₁.
	U₁ := C₁₁ replaceWith: P₁ plus: P₂
"	S₁ := A₂₁ + A₂₂. S₂ := S₁ - A₁₁. S₃ := A₁₁ - A₂₁.
	T₁ := B₁₂ - B₁₁. T₂ := B₂₂ - T₁. T₃ := B₂₂ - B₁₂.
	S₄ := A₁₂ - S₂. T₄ := T₂ - B₂₁.
	P₁ := A₁₁ * B₁₁. P₂ := A₁₂ * B₂₁.
	P₃ := S₄ * B₂₂. P₄ := A₂₂ * T₄.
	P₅ := S₁ * T₁. P₆ := S₂ * T₂. P₇ := S₃ * T₃.
	U₁ := P₁ + P₂. U₂ := P₁ + P₆.
	U₃ := U₂ + P₇. U₄ := U₂ + P₅.
	U₅ := U₄ + P₃. U₆ := U₃ - P₄. U₇ := U₃ + P₅.
	^ U₁ ⊔ U₅ ⊓ (U₆ ⊔ U₇)"! !

!Matrix methodsFor: 'operations-inplace' stamp: 'len 1/8/2024 14:59:11'!
replaceWith: aMatrix1 times: aMatrix2
	self atAllPut: self scalars zero.
	self accumulateWith: aMatrix1 times: aMatrix2! !

!Matrix methodsFor: 'operations-inplace' stamp: 'len 1/5/2024 11:03:03'!
replaceWith: aMatrix1 timesLowerTriangular: aMatrix2
	| m n mₕ A₁ A₂ L₁ L₂ L₃ C₁ C₂ |
	(m := aMatrix2 height) <= 1 ifTrue: [^ self replaceWith: aMatrix1 times: aMatrix2].
	self assert: aMatrix2 isSquare.
	self assert: aMatrix2 isLowerTriangular.
	n := aMatrix1 height.
	mₕ := m - 1 // 2 + 1.
	A₁ := aMatrix1 from: 1 @ 1 to: n @ mₕ.
	A₂ := aMatrix1 from: 1 @ (mₕ + 1) to: n @ m.
	self assert: A₁ ⊔ A₂ = aMatrix1.
	L₁ := aMatrix2 from: 1 @ 1 to: mₕ @ mₕ.
	L₂ := aMatrix2 from: mₕ + 1 @ 1 to: m @ mₕ.
	L₃ := aMatrix2 from: mₕ + 1 @ (mₕ + 1) to: m @ m.
	C₁ := self from: 1 @ 1 to:  n @ mₕ.
	C₂ := self from: 1 @ (mₕ + 1) to: n @ m.
	self assert: C₁ ⊔ C₂ = self.
	C₁ replaceWith: A₁ timesLowerTriangular: L₁.
	C₁ accumulateWith: A₂ times: L₂.
	C₂ replaceWith: A₂ timesLowerTriangular: L₃! !

!Matrix methodsFor: 'operations-inplace' stamp: 'len 1/22/2024 10:25:40'!
replaceWithInverseUpperTriangular: aMatrix
	| n nₕ A₁ A₂ A₃ C₁ C₂ C₃|
	self assert: self isSquare.
	self assert: (aMatrix width = self width and: [aMatrix height = self height]).
	(n := self width) <= 1 ifTrue: [^ self replaceWithInverse: aMatrix].
	nₕ := n - 1 // 2 + 1.
	A₁ := aMatrix from: 1 @ 1 to: nₕ @ nₕ.
	A₂ := aMatrix from: 1 @ (nₕ + 1) to: nₕ @ n.
	A₃ := aMatrix from: nₕ + 1 @ (nₕ + 1) to: n @ n.
	C₁ := self from: 1 @ 1 to: nₕ @ nₕ.
	C₂ := self from: 1 @ (nₕ + 1) to: nₕ @ n.
	C₃ := self from: nₕ + 1 @ (nₕ + 1) to: n @ n.
	C₁ replaceWithInverseUpperTriangular: A₁.
	C₂ replaceWith: A₂ timesUpperTriangular: C₃.
	C₂ accumulateWithUpperTriangular: C₁ times: C₂ timesScalar: -1.
	C₃ replaceWithInverseUpperTriangular: A₃! !

!Matrix methodsFor: 'operations-inplace' stamp: 'len 1/5/2024 10:40:32'!
replaceWithUpperTriangular: aMatrix1 times: aMatrix2
	| m n mₕ U₁ U₂ U₃ B₁ B₂ C₁ C₂ |
	(m := aMatrix1 width) <= 1 ifTrue: [^ self replaceWith: aMatrix1 times: aMatrix2].
	self assert: aMatrix1 isSquare.
	self assert: aMatrix1 isUpperTriangular.
	n := aMatrix2 width.
	mₕ := m - 1 // 2 + 1.
	U₁ := aMatrix1 from: 1 @ 1 to: mₕ @ mₕ.
	U₂ := aMatrix1 from: 1 @ (mₕ + 1) to: mₕ @ m.
	U₃ := aMatrix1 from: mₕ + 1 @ (mₕ + 1) to: m @ m.
	B₁ := aMatrix2 from: 1 @ 1 to: mₕ @ n.
	B₂ := aMatrix2 from: mₕ + 1 @ 1 to: m @ n.
	self assert: B₁ ⊓ B₂ = aMatrix2.
	C₁ := self from: 1 @ 1 to:  mₕ @ n.
	C₂ := self from: mₕ + 1 @ 1 to: m @ n.
	self assert: C₁ ⊓ C₂ = self.
	C₁ replaceWithUpperTriangular: U₁ times: B₁.
	C₁ accumulateWith: U₂ times: B₂.
	C₂ replaceWithUpperTriangular: U₃ times: B₂! !

!Matrix methodsFor: 'operations-inplace' stamp: 'len 1/5/2024 10:53:05'!
replaceWithUpperTriangular: aMatrix1 timesLowerTriangular: aMatrix2
	| n nₕ U₁ U₂ U₃ L₁ L₂ L₃ C₁₁ C₁₂ C₂₁ C₂₂ |
	(n := aMatrix1 width) <= 1 ifTrue: [^ self replaceWith: aMatrix1 times: aMatrix2].
	self assert: (aMatrix1 isSquare and: [aMatrix2 isSquare and: [aMatrix1 width = aMatrix2 width]]).
	self assert: aMatrix1 isUpperTriangular.
	self assert: aMatrix2 isLowerTriangular.
	nₕ := n - 1 // 2 + 1.
	U₁ := aMatrix1 from: 1 @ 1 to: nₕ @ nₕ.
	U₂ := aMatrix1 from: 1 @ (nₕ + 1) to: nₕ @ n.
	U₃ := aMatrix1 from: nₕ + 1 @ (nₕ + 1) to: n @ n.
	L₁ := aMatrix2 from: 1 @ 1 to: nₕ @ nₕ.
	L₂ := aMatrix2 from: (nₕ + 1) @ 1 to: n @ nₕ.
	L₃ := aMatrix2 from: nₕ + 1 @ (nₕ + 1) to: n @ n.
	C₁₁ := self from: 1 @ 1 to: nₕ @ nₕ.
	C₁₂ := self from: 1 @ (nₕ + 1) to: nₕ @ n.
	C₂₁ := self from: nₕ + 1 @ 1 to: n @ nₕ.
	C₂₂ := self from: nₕ + 1 @ (nₕ + 1) to: n @ n.
	C₁₁ replaceWithUpperTriangular: U₁ timesLowerTriangular: L₁.
	C₁₁ accumulateWith: U₂ times: L₂.
	C₁₂ replaceWith: U₂ timesLowerTriangular: L₃.
	C₂₁ replaceWithUpperTriangular: U₃ times: L₂.
	C₂₂ replaceWithUpperTriangular: U₃ timesLowerTriangular: L₃! !

!Matrix methodsFor: 'printing' stamp: 'len 5/29/2023 23:29:54'!
printBinaryOn: aStream
	| elementSize space form canvas rect side color |
	elementSize := Preferences defaultFontSize.
	space := elementSize / 8.0.
	form := Form extent: self width @ self height * elementSize depth: 8.
	form fillColor: Color transparent.
	canvas := BitBltCanvas onForm: form.
	color := Theme current text.
	1 to: self height do: [:i|
		1 to: self width do: [:j|
			rect := j-1@(i-1) * elementSize + space extent: elementSize@elementSize - (space*2).
			(self isZeroAt: i@j)
				ifTrue: [canvas frameRectangle: rect borderWidth: 1 color: color]
				ifFalse: [canvas fillRectangle: rect color: color]]].
	(side := form width max: form height) > 300 ifTrue: [form := form magnifyBy: 300.0 / side].
	aStream print: form! !

!Matrix methodsFor: 'printing' stamp: 'len 6/13/2023 17:17:22'!
printOn: aStream
	| columnWidth rowHeight w h canvas form textColor space lineWidth |
	self isTrivial ifTrue: [aStream print: 0. ^ self].
	aStream isText ifFalse: [self printPlainStringOn: aStream. ^ self].
	(self scalars isKindOf: BinaryField)
		ifTrue: [^ self printBinaryOn: aStream].
	columnWidth := Array new: self width withAll: 0.
	rowHeight := 0.
	1 to: self width do: [:j|
		| cellExtent |
		cellExtent := 0@0.
		1 to: self height do: [:i|
			cellExtent := cellExtent max: (TextComposition new setModel: (TextModel withText: (self at: i@j) printText, '  '); extentForComposing: 9999999@9999999; composeAll; usedExtent)].
		columnWidth at: j put: cellExtent x.
		rowHeight := rowHeight max: cellExtent y].
	space := 5.
	w := columnWidth sum + (space * 2).
	h := self height * rowHeight + (space * 1.5).
	form := Form extent: w@h + 2 depth: 32.
	form fillColor: Color transparent.
	canvas := VectorCanvas onFormWithSubPixelAntiAliasing: form.
	textColor := Theme current text.
	1 to: self height do: [:i|
		1 to: self width do: [:j|
			| textComposition |
			textComposition := TextComposition new setModel: (TextModel withText: (self at: i@j) printText centered); extentForComposing: (columnWidth at: j) @ rowHeight; composeAll.
			canvas
				drawTextComposition: textComposition
				at: ((1 to: j-1) sum: [:k| columnWidth at: k] ifEmpty: [0]) @ (i-1*rowHeight) + space
				extent: textComposition usedExtent
				color: textColor
				selectionColor: textColor
				avoidOverhang: true]].
	lineWidth := 1.0.
	canvas
		line: 1@2 to: 1@(h-1) width: lineWidth color: textColor;
		line: 1@1 to: space*1.5@1 width: lineWidth color: textColor;
		line: 1@h to: space*1.5@h width: lineWidth color: textColor;
		line: w@2 to: w@(h-1) width: lineWidth color: textColor;
		line: w@1 to: w-(space*1.5)@1 width: lineWidth color: textColor;
		line: w@h to: w-(space*1.5)@h width: lineWidth color: textColor.
	aStream print: form! !

!Matrix methodsFor: 'printing' stamp: 'len 6/13/2023 17:20:02'!
printPlainStringOn: aStream
	self rows do: [:each| aStream withBrackets: [:aStream2| each asArray do: [:x| aStream2 print: x] separatedBy: [aStream nextPutAll: '  ']]] separatedBy: [aStream nextPutAll: String lfString]! !

!Matrix methodsFor: 'solving' stamp: 'len 6/29/2023 14:23:41'!
colift: aMatrix
	"Answer X such that XA = B, where A is the receiver and B is the argument. Answer nil if there's no solution.
	X is called a colift (or extension) of B along A, written B / A."
	| X |
	aMatrix isMatrix ifFalse: [^ super colift: aMatrix].
	self scalars isCommutative ifTrue:
		[X := (aMatrix transpose quotientBy: self transpose) transpose.
		^ X * self = aMatrix ifTrue: [X]].
	self scalars isInvolutive ifTrue:
		[X := (aMatrix conjugate quotientBy: self conjugate) conjugate.
		^ X * self = aMatrix ifTrue: [X]].
	^ self notYetImplemented! !

!Matrix methodsFor: 'solving' stamp: 'len 1/4/2022 09:01:04'!
colift: aMatrix modulo: aRelationsMatrix
	"Answer X such that XA = B modulo L, i.e. X such that there exists Y with XA + YL = B, where A is self, B is aMatrix and L is aRelationsMatrix."
	aRelationsMatrix isZero ifTrue: [^ self colift: aMatrix].
	^ (self ⊓ aRelationsMatrix transpose colift: aMatrix) ifNotNil: [:X| X copyFromColumn: 1 to: self height]! !

!Matrix methodsFor: 'solving' stamp: 'len 5/8/2023 18:47:17'!
cosyzygies
	"Answer a matrix whose columns span the cokernel or left nullspace of the receiver.
	For a matrix A, the output is X such that XA = 0."
	self scalars isCommutative ifTrue: [^ self transpose syzygies transpose].
	self scalars isInvolutive ifTrue: [^ self conjugate syzygies conjugate].
	^ self notYetImplemented! !

!Matrix methodsFor: 'solving' stamp: 'len 6/1/2022 20:42:52'!
divisionBy: aMatrix
	"Answer X and N such that AX + N = B, where B is self and A is aMatrix, satisfying that if the i-th column of B is a linear combination of the columns of A then the i-th column of N is zero."
	| X |
	X _ self quotientBy: aMatrix.
	^ {X. self - (aMatrix * X)}! !

!Matrix methodsFor: 'solving' stamp: 'len 6/29/2023 14:23:57'!
lift: aMatrix
	"Answer X such that AX = B, where A is the receiver and B is the argument. 	Answer nil if there's no solution.
	X is called a lift of B along A, written A \ B."
	| X |
	aMatrix isMatrix ifFalse: [^ super lift: aMatrix].
	X := aMatrix quotientBy: self.
	^ self * X = aMatrix ifTrue: [X]! !

!Matrix methodsFor: 'solving' stamp: 'len 6/2/2022 19:25:01'!
lift: aMatrix modulo: aRelationsMatrix
	"Answer X such that AX = B modulo L, i.e. X such that there exists Y with AX + LY = B, where A is self, B is aMatrix and aRelationsMatrix is L."
	aRelationsMatrix isZero ifTrue: [^ self lift: aMatrix].
	^ (self ⊔ aRelationsMatrix lift: aMatrix) ifNotNil: [:X| X copyFromRow: 1 to: self width]! !

!Matrix methodsFor: 'solving' stamp: 'len 6/29/2023 14:34:01'!
quotientBy: aMatrix
	"Answer X such that AX + N = B, where B is the receiver and A is the argument, satisfying that if the i-th column of B is a linear combination of the columns of A then the i-th column of N is zero."
	self checkCodomainsMatch: aMatrix.
	(self isZero or: [aMatrix isZero]) ifTrue: [^ (self domain ⇒ aMatrix domain) zero].
	^ self scalars matrix: self quotientBy: aMatrix! !

!Matrix methodsFor: 'solving' stamp: 'len 6/1/2022 19:08:25'!
quotientBy: aMatrix modulo: aRelationsMatrix
	"Answer X such that AX + N = B modulo L, i.e. X such that there exists Y with AX + LY + N = B, where B is the receiver, A is aMatrix and L is aRelationsMatrix, satisfying that if the i-th column of B is a linear combination of the columns of A modulo L then the i-th column of N is zero."
	aRelationsMatrix isZero ifTrue: [^ self quotientBy: aMatrix].
	^ (self quotientBy: aMatrix ⊔ aRelationsMatrix) copyFromRow: 1 to: aMatrix width! !

!Matrix methodsFor: 'solving' stamp: 'len 6/29/2023 14:34:45'!
reductionBy: aMatrix
	"Answer N with AX + N = B. See >>quotientBy:."
	self checkCodomainsMatch: aMatrix.
	(self isZero or: [aMatrix isZero]) ifTrue: [^ self].
	^ self scalars matrix: self reductionBy: aMatrix! !

!Matrix methodsFor: 'solving' stamp: 'len 6/1/2022 20:35:23'!
reductionBy: aMatrix modulo: aRelationsMatrix
	"Answer N with AX + N = B modulo L. See >>quotientBy:modulo:."
	| A |
	aRelationsMatrix isZero ifTrue: [^ self reductionBy: aMatrix].
	A _ aMatrix ⊔ aRelationsMatrix.
	^ self - (A * (self quotientBy: A))! !

!Matrix methodsFor: 'solving' stamp: 'len 5/16/2022 20:33:54'!
syzygies
	"Answer a matrix whose columns span the (right) kernel or nullspace of the receiver.
	For a matrix A, the output is X such that AX = 0."
	^ self scalars syzygiesOf: self! !

!Matrix methodsFor: 'solving' stamp: 'len 9/11/2022 19:37:15'!
syzygiesModulo: aRelationsMatrix
	aRelationsMatrix isZero ifTrue: [^ self syzygies].
	^ (self ⊔ aRelationsMatrix) syzygies copyFromRow: 1 to: self width! !

!Matrix methodsFor: 'spectrum' stamp: 'len 5/29/2020 05:03:52'!
eigenspaceAt: anEigenvalue
	^ (self - (self identity * anEigenvalue)) kernel! !

!Matrix methodsFor: 'spectrum' stamp: 'len 2/6/2016 19:39'!
eigenvalues
	^ self spectrum asSet! !

!Matrix methodsFor: 'spectrum' stamp: 'len 11/19/2023 11:31:04'!
spectralRadius
	^ self spectrum max: [:each| each abs]! !

!Matrix methodsFor: 'spectrum' stamp: 'len 3/27/2018 16:26:17'!
spectrum
	^ self characteristicPolynomial allRoots! !

!Matrix methodsFor: 'submatrices' stamp: 'len 1/13/2024 10:32:37'!
fromColumn: start to: end
	self flag: #deprecated.
	^ self from: 1 @ start to: self height @ end! !

!Matrix methodsFor: 'submatrices' stamp: 'len 1/13/2024 10:32:42'!
fromRow: start to: end
	self flag: #deprecated.
	^ self from: start @ 1 to: end @ self width! !

!Matrix methodsFor: 'submatrices' stamp: 'len 1/13/2024 10:32:45'!
horizontalSplit: aBlock
	| h |
	self flag: #deprecated.
	h := self width - 1 // 2 + 1.
	^ aBlock value: (self fromColumn: 1 to: h) value: (self fromColumn: h+1 to: self width)! !

!Matrix methodsFor: 'submatrices' stamp: 'len 1/13/2024 10:32:48'!
lowerTriangularSplit: aBlock
	| n nₕ |
	self flag: #deprecated.
	self assert: self isSquare.
	self assert: self isLowerTriangular.
	n := self height.
	nₕ := n - 1 // 2 + 1.
	^ aBlock
		value: (self from: 1 @ 1 to: nₕ @ nₕ)
		value: (self from: nₕ + 1 @ 1 to: n @ nₕ)
		value: (self from: nₕ + 1 @ (nₕ + 1) to: n @ n)! !

!Matrix methodsFor: 'submatrices' stamp: 'len 1/13/2024 10:32:51'!
upperTriangularSplit: aBlock
	| n nₕ |
	self flag: #deprecated.
	self assert: self isSquare.
	self assert: self isUpperTriangular.
	n := self width.
	nₕ := n - 1 // 2 + 1.
	^ aBlock
		value: (self from: 1 @ 1 to: nₕ @ nₕ)
		value: (self from: 1 @ (nₕ + 1) to: nₕ @ n)
		value: (self from: nₕ + 1 @ (nₕ + 1) to: n @ n)! !

!Matrix methodsFor: 'submatrices' stamp: 'len 1/13/2024 10:32:54'!
verticalSplit: aBlock
	| h |
	self flag: #deprecated.
	h := self height - 1 // 2 + 1.
	^ aBlock value: (self fromRow: 1 to: h) value: (self fromRow: h+1 to: self height)! !

!Matrix methodsFor: 'testing' stamp: 'len 5/25/2022 13:36:26'!
isAutomorphism
	"Answer true if the receiver is invertible."
	^ self isSquare and: [self determinant isUnit]! !

!Matrix methodsFor: 'testing' stamp: 'len 5/20/2023 12:21:49'!
isDense
	^ false! !

!Matrix methodsFor: 'testing' stamp: 'len 5/30/2019 04:43:29'!
isDiagonal
	^ self isLowerTriangular and: [self isUpperTriangular]! !

!Matrix methodsFor: 'testing' stamp: 'len 12/20/2022 15:00:46'!
isEchelon
	"Answer true if the receiver is in row echelon form.
	It must satisfy the following conditions:
	1. All nonzero rows are above any rows of all zeros;
	2. The leading coefficient (or pivot) of each nonzero row is always strictly to the right of the pivot of the row above it."
	| lastPivot |
	lastPivot _ 0@0.
	self pivotsDo: [:each|
		(each y > lastPivot y and: [each x - lastPivot x = 1]) ifFalse: [^ false].
		lastPivot _ each].
	^ true! !

!Matrix methodsFor: 'testing' stamp: 'len 5/29/2020 06:32:04'!
isEmpty
	^ self width = 0 or: [self height = 0]! !

!Matrix methodsFor: 'testing' stamp: 'len 3/17/2021 14:40:31'!
isEndomorphism
	^ self isSquare! !

!Matrix methodsFor: 'testing' stamp: 'len 4/5/2018 15:31:35'!
isFullRank
	^ self rank = (self width min: self height)! !

!Matrix methodsFor: 'testing' stamp: 'len 6/17/2023 22:08:02'!
isHermiteNormalForm
	"Answer true if the receiver is in row Hermite normal form over ℤ.
	It must satisfy the following conditions:
	1. It is upper triangular;
	2. The leading coefficient (or pivot) of a nonzero row is always strictly to the right of the leading coefficient of the row above it, and it is positive;
	3. And the elements below pivots are zero and elements above pivots are nonnegative and strictly smaller than the pivot."
	| lastPivot |
	lastPivot := 0@0.
	self pivotsDo: [:each| | coefficient |
		(each x <= each y and: [each y > lastPivot y and: [each x - lastPivot x = 1]])
			ifFalse: [^ false].
		coefficient := self at: each.
		coefficient > 0 ifFalse: [^ false].
		1 to: each x - 1 do: [:i| | v |
			((v := self at: i@each y) >= 0 and: [v < coefficient])
				ifFalse: [^ false]].
		each x + 1 to: self height do: [:i|
			(self at: i@each y) = 0
				ifFalse: [^ false]].
		lastPivot := each].
	^ true! !

!Matrix methodsFor: 'testing' stamp: 'len 7/22/2021 18:53:41'!
isHermitian
	"Answer true if the receiver is Hermitian (or self-adjoint)."
	^ self = self conjugate! !

!Matrix methodsFor: 'testing' stamp: 'len 8/14/2020 17:13:22'!
isIdentity
	^ self isSquare and: [self = self identity]! !

!Matrix methodsFor: 'testing' stamp: 'len 8/25/2021 18:28:29'!
isIsomorphism
	^ self isUnimodular! !

!Matrix methodsFor: 'testing' stamp: 'len 12/17/2022 10:58:51'!
isLowerTriangular
	"Answer true if the receiver is lower triangular (or left triangular)."
	1 to: (self width min: self height) do: [:i|
		i+1 to: self width do: [:j| (self isZeroAt: i@j) ifFalse: [^ false]]].
	^ true! !

!Matrix methodsFor: 'testing' stamp: 'len 4/2/2018 05:16:26'!
isMatrix
	^ true! !

!Matrix methodsFor: 'testing' stamp: 'len 6/17/2023 12:00:10'!
isMinimalStandardBasis
	"A Groebner basis G of an ideal I is called 'minimal' if the leading terms of the elements in G minimally generate in(I); or equivalently, if for all g in G:
	- LC(g) is normalized (over fields g is monic), and
	- LT(g) is not in ⟨G-{g}⟩ (i.e., leading-term-minimal, no leading term of any generator divides any other generator's leading term).
	Note that any leading-term-minimal Groebner basis is also cardinality-minimal."
	self isStandardBasis ifFalse: [^ false].
	self columnsDo: [:g| g leadingCoefficient normalization isOne ifFalse: [^ false]].
	1 to: self width do: [:i|
		| Cᵢ m c |
		Cᵢ := self columnAt: i.
		m := Cᵢ leadingMonomial.
		c := Cᵢ leadingCoefficient.
		1 to: self width do: [:j|
			i ~= j ifTrue:
				[| Cⱼ |
				Cⱼ := self columnAt: j.
				(Cⱼ leadingMonomial | m and: [Cⱼ leadingCoefficient | c]) ifTrue: [^ false]]]].
	^ true! !

!Matrix methodsFor: 'testing' stamp: 'len 1/2/2022 10:01:23'!
isMonomial
	"A matrix is called a 'monomial matrix' if it has exactly one nonzero entry in each column and each row."
	self rowsDo: [:row| (row count: [:each| each isZero not]) = 1 ifFalse: [^ false]].
	self columnsDo: [:column| (column count: [:each| each isZero not]) = 1 ifFalse: [^ false]].
	^ true! !

!Matrix methodsFor: 'testing' stamp: 'len 4/5/2024 18:58:44'!
isNegativeDefinite
	self assert: self isSquare.
	self scalars isReal ifFalse: [^ self error: 'not a real matrix'].
	self flag: #fix. "define this for complex matrices too"
	^ (1 to: self width) allSatisfy: [:i| (self copyFrom: 1@1 to: i@i) determinant < 0]! !

!Matrix methodsFor: 'testing' stamp: 'len 5/29/2020 05:03:24'!
isNilpotent
	"Answer true if self^n = 0 for some integer n >= 1."
	"This only works for real or complex matrices."
	^ self trace isZero and: [self determinant isZero]! !

!Matrix methodsFor: 'testing' stamp: 'len 7/22/2021 18:53:54'!
isNormal
	^ self conjugate * self = (self * self conjugate)! !

!Matrix methodsFor: 'testing' stamp: 'len 8/9/2020 07:53:38'!
isOrthogonal
	"A real square matrix Q is orthogonal if Q^t * Q = I (the transposed is the inverse).
	Equivalently:
		- Q has orthonormal columns and rows;
		- For all v, ||Qv|| = ||v|| (the matrix preserves the Euclidean norm defined by the standard dot product)."
	^ self isSquare and: [(self * self transpose) isIdentity]! !

!Matrix methodsFor: 'testing' stamp: 'len 4/5/2024 18:58:37'!
isPositiveDefinite
	self assert: self isSquare.
	"TODO: extend this to the hermitian matrices over the complex numbers, use the indefinite factorization algorithm as Sage"
	self scalars isComplex
		ifTrue:
			[self isHermitian ifFalse: [^ false].
			self notYetImplemented].
	self scalars isReal
		ifTrue:
			[self isSymmetric ifFalse: [^ false].
			^ (1 to: self width) allSatisfy: [:i| (self copyFrom: 1@1 to: i@i) determinant > 0]].
	^ self error: 'not a real or complex matrix'! !

!Matrix methodsFor: 'testing' stamp: 'len 5/23/2016 19:55'!
isRankDeficient
	^ self isFullRank not! !

!Matrix methodsFor: 'testing' stamp: 'len 12/20/2022 15:00:27'!
isReducedEchelon
	"Answer true if the receiver is in reduced row echelon form.
	It must satisfy the following conditions:
	1. It is in row echelon form;
	2. And every leading coefficient is 1 and is the only nonzero entry in its column."
	| lastPivot |
	lastPivot _ 0@0.
	self pivotsDo: [:each|
		(each y > lastPivot y and: [each x - lastPivot x = 1]) ifFalse: [^ false].
		(self at: each) isOne ifFalse: [^ false].
		1 to: self height do: [:j|
			(j = each x or: [(self at: j @ each y) isZero]) ifFalse: [^ false]].
		lastPivot _ each].
	^ true! !

!Matrix methodsFor: 'testing' stamp: 'len 6/17/2023 14:22:09'!
isReducedStandardBasis
	"A strong Groebner basis G is called 'reduced' (or 'auto-reduced') if for all g in G:
	- LC(g) is normalized (over fields g is monic), and
	- if the monomial m of any term c*m of g can be divided by the leading monomial LM(f) of any other element f of G, the Euclidean quotient of the division c by LC(f) is zero.
	In particular, a reduced Groebner basis is leading-term-minimal (no leading term of any generator divides any other generator's leading term), and a leading-term-minimal basis is also cardinality-minimal."
	self isStandardBasis ifFalse: [^ false].
	self columnsDo: [:g| g leadingCoefficient normalization isOne ifFalse: [^ false]].
	1 to: self width do: [:i|
		(self columnAt: i) associationsDo: [:each|
			1 to: self width do: [:j|
				i ~= j ifTrue:
					[| Cⱼ |
					Cⱼ := self columnAt: j.
					(Cⱼ leadingMonomial | each key and: [(each value // Cⱼ leadingCoefficient) isZero not]) ifTrue: [^ false]]]]].
	^ true! !

!Matrix methodsFor: 'testing' stamp: 'len 4/5/2018 15:42:21'!
isScalar
	self isDiagonal ifFalse: [^ false].
	2 to: self height do: [:i|
		(self at: i@i) = (self at: 1@1) ifFalse: [^ false]].
	^ true! !

!Matrix methodsFor: 'testing' stamp: 'len 1/9/2022 08:31:55'!
isSemisimple
	^ self minimalPolynomial isSquarefree! !

!Matrix methodsFor: 'testing' stamp: 'len 5/3/2021 10:57:24'!
isSimplectic
	| M ω |
	(self isSquare and: [self width even]) ifFalse: [^ false].
	M _ (self scalars^(self width/2)) endomorphisms.
	ω _ M zero ⊔ M identity ⊓ (M identity negated ⊔ M zero).
	^ self transpose * ω * self = ω! !

!Matrix methodsFor: 'testing' stamp: 'len 10/16/2022 11:50:25'!
isSingular
	"Answer true if the receiver has nontrivial kernel."
	^ self determinant isZeroDivisor! !

!Matrix methodsFor: 'testing' stamp: 'len 7/22/2021 18:54:00'!
isSkewHermitian
	"Answer true if the receiver is skew-Hermitian (or antihermitian)."
	^ self = self conjugate negated! !

!Matrix methodsFor: 'testing' stamp: 'len 8/9/2020 07:53:41'!
isSkewSymmetric
	"Answer true if the receiver is a skew-symmetric (or anti-symmetric) matrix."
	^ self negated = self transpose! !

!Matrix methodsFor: 'testing' stamp: 'len 7/10/2023 19:39:47'!
isSmithNormalForm
	"Answer true if the receiver is in Smith normal form."
	| diagonal previousEntry n0 |
	self isDiagonal ifFalse: [^ false].
	self isEmpty ifTrue: [^ true].
	diagonal := self diagonal.
	diagonal do: [:each| each normalization isOne ifFalse: [^ false]].
	previousEntry := diagonal first.
	n0 := diagonal findLast: [:each| each isZero not].
	2 to: n0 do: [:i| | thisEntry |
		thisEntry := diagonal at: i.
		previousEntry | thisEntry ifFalse: [^ false].
		previousEntry := thisEntry].
	n0+1 to: diagonal size do: [:i|
		(diagonal at: i) isZero ifFalse: [^ false]].
	^ true! !

!Matrix methodsFor: 'testing' stamp: 'len 4/5/2018 15:31:59'!
isSquare
	^ self height = self width! !

!Matrix methodsFor: 'testing' stamp: 'len 12/18/2022 11:34:49'!
isStandardBasis
	"Answer true if the columns of the receiver form a standard basis of the module spanned by the columns."
	1 to: self width do: [:i| | fi |
		fi _ self columnAt: i.
		i+1 to: self width do: [:j| | fj |
			fj _ self columnAt: j.
			(fi s: fj) ifNotNil: [:s| (s \\ self columns) isZero ifFalse: [^ false]]]].
	^ true! !

!Matrix methodsFor: 'testing' stamp: 'len 8/9/2020 07:53:44'!
isSymmetric
	^ self = self transpose! !

!Matrix methodsFor: 'testing' stamp: 'len 3/2/2017 19:36:13'!
isTriangular
	^ self isLowerTriangular or: [self isUpperTriangular]! !

!Matrix methodsFor: 'testing' stamp: 'len 5/4/2020 10:04:50'!
isUnimodular
	^ self determinant isUnit! !

!Matrix methodsFor: 'testing' stamp: 'len 7/22/2021 18:54:06'!
isUnitary
	"A complex square matrix U is unitary if U* * U = I (the adjoint is the inverse).
	Equivalently:
		- U has orthonormal columns and rows;
		- For all v, ||Uv|| = ||v||."
	^ self isSquare and: [(self * self conjugate) isIdentity]! !

!Matrix methodsFor: 'testing' stamp: 'len 12/17/2022 10:59:13'!
isUpperTriangular
	"Answer true if the receiver is upper triangular (or right triangular)."
	^ self transpose isLowerTriangular! !

!Matrix methodsFor: 'testing' stamp: 'len 3/23/2016 00:27'!
isZero
	self do: [:each| each isZero ifFalse: [^ false]].
	^ true! !

!Matrix methodsFor: 'testing' stamp: 'len 12/1/2016 17:03:47'!
isZeroAt: aPoint
	^ (self at: aPoint) isZero! !

!Matrix methodsFor: 'testing' stamp: 'len 12/22/2022 19:00:54'!
isZeroAtColumn: anInteger
	^ (self columnAt: anInteger) isZero! !

!Matrix methodsFor: 'private' stamp: 'len 12/13/2016 09:51:35'!
hadamardBound
	"Answer a bound N on the determinant of the receiver such that |det A| < 2^N.
	Assume the coefficients are real."
	^ (self rows sum: [:row| (row sum: [:each| each squared])]) log2 min: (self columns sum: [:column| (column sum: [:each| each squared])]) log2! !

!Matrix methodsFor: 'private' stamp: 'len 7/8/2022 11:08:27'!
validate
	self assert: (self allSatisfy: [:each| self scalars includes: each]).
	^ super validate! !

!Matrix class methodsFor: 'instance creation' stamp: 'len 10/26/2020 16:29:36'!
columns: anArray
	^ self to: anArray first parent columns: anArray! !

!Matrix class methodsFor: 'instance creation' stamp: 'len 11/25/2022 06:23:37'!
from: aDomain rows: anArray
	^ self from: aDomain to: aDomain scalars ^ anArray size rows: anArray! !

!Matrix class methodsFor: 'instance creation' stamp: 'len 5/12/2023 20:46:42'!
from: aDomain to: aCodomain columns: anArray
	^ (self from: aCodomain to: aDomain rows: anArray) transpose! !

!Matrix class methodsFor: 'instance creation' stamp: 'len 11/23/2022 21:33:31'!
from: aDomain to: aCodomain fill: aBlock
	^ self from: aDomain to: aCodomain rows: ((1 to: aCodomain rank) collect: [:i| aDomain fill: [:j| aBlock value: i value: j]])! !

!Matrix class methodsFor: 'instance creation' stamp: 'len 5/29/2020 10:47:04'!
from: aDomain to: aCodomain matrix: aMatrix
	^ self shouldNotImplement! !

!Matrix class methodsFor: 'instance creation' stamp: 'len 1/11/2024 18:41:02'!
from: aDomain to: aCodomain rows: anArray
	| coefficients i n |
	coefficients := aDomain scalars new: aDomain rank * aCodomain rank.
	i := 1.
	n := aDomain rank.
	anArray do: [:each| coefficients replaceFrom: i to: i + n - 1 with: each coefficients. i := i + n].
	^ DenseMatrix from: aDomain to: aCodomain coefficients: coefficients! !

!Matrix class methodsFor: 'instance creation' stamp: 'len 10/26/2020 16:28:36'!
rows: anArray
	^ self from: anArray first parent rows: anArray! !

!Matrix class methodsFor: 'instance creation' stamp: 'len 11/25/2022 06:23:05'!
to: aCodomain columns: anArray
	^ self from: aCodomain scalars ^ anArray size to: aCodomain columns: anArray! !

!DenseMatrix methodsFor: 'accessing' stamp: 'len 5/20/2023 19:28:50'!
atAllPut: anElement
	coefficients atAllPut: anElement! !

!DenseMatrix methodsFor: 'accessing' stamp: 'len 4/20/2022 18:37:50'!
atRow: i column: j
	^ coefficients at: i - 1 * self width + j! !

!DenseMatrix methodsFor: 'accessing' stamp: 'len 5/15/2022 22:37:43'!
atRow: i column: j ifAbsent: exceptionBlock
	((i between: 1 and: self height) and: [j between: 1 and: self width])
		ifFalse: [^ exceptionBlock value].
	^ coefficients at: i - 1 * self width + j "ifAbsent: exceptionBlock"! !

!DenseMatrix methodsFor: 'accessing' stamp: 'len 5/15/2022 22:38:15'!
atRow: i column: j put: anObject
	((i between: 1 and: self height) and: [j between: 1 and: self width])
		ifFalse: [^ self error: 'indices out of bounds'].
	^ coefficients at: i - 1 * self width + j put: anObject! !

!DenseMatrix methodsFor: 'accessing' stamp: 'len 5/15/2023 17:31:53'!
lift
	"If the coefficients ring is a quotient R/I, answer a representative of the receiver over R."
	self scalars cover = ℤ ifTrue: [^ self class from: domain lift to: codomain lift coefficients: coefficients lift].
	^ super lift! !

!DenseMatrix methodsFor: 'accessing' stamp: 'len 12/2/2022 14:30:26'!
projection: anInteger
	"If the coefficients ring is a product ring, answer matrix induced by the projection to the anInteger-th component."
	^ self class from: (domain over: (domain scalars at: anInteger)) to: (codomain over: (domain scalars at: anInteger)) coefficients: (coefficients projection: anInteger)! !

!DenseMatrix methodsFor: 'accessing' stamp: 'len 5/15/2023 17:30:51'!
representative
	"If the coefficients ring is a quotient R/I, answer a representative of the receiver over R."
	self scalars cover = ℤ ifTrue: [^ self class from: domain lift to: codomain lift coefficients: coefficients representative].
	^ super representative! !

!DenseMatrix methodsFor: 'accessing' stamp: 'len 5/5/2023 16:50:11'!
rowAt: i
	^ domain coefficients: (coefficients copyFrom: i - 1 * self width + 1 to: i * self width)! !

!DenseMatrix methodsFor: 'accessing' stamp: 'len 5/5/2023 16:50:23'!
rowAt: i put: aTuple
	coefficients replaceFrom: i - 1 * self width + 1 to: i * self width with: aTuple coefficients startingAt: 1! !

!DenseMatrix methodsFor: 'accessing' stamp: 'len 6/9/2023 20:57:12'!
zero
	^ self class from: domain to: codomain coefficients: (self scalars zeros: coefficients size)! !

!DenseMatrix methodsFor: 'comparing' stamp: 'len 12/11/2022 09:53:10'!
= anObject
	^ (self class = anObject class and: [coefficients = anObject coefficients]) or: [super = anObject]! !

!DenseMatrix methodsFor: 'comparing' stamp: 'len 5/5/2024 07:19:24'!
apply: aMap
	"Answer a new tuple with coefficients obtainted by applying aMap to the coefficients of the receiver.
	If aMap is a block we assume the parent doesn't change, i.e. the block must evaluate to values within the scalars ring of the receiver."

	aMap isBlock ifTrue: [^ self class from: domain to: codomain coefficients: (coefficients apply: aMap)].
	^ self class from: (domain over: aMap codomain) to: (codomain over: aMap codomain) coefficients: (coefficients apply: aMap)! !

!DenseMatrix methodsFor: 'converting' stamp: 'len 5/5/2023 18:19:38'!
asTuple
	"Answer the receiver converted to Tuple by concatenating its rows (which is also the coordinates of the receiver in the canonical basis)."
	^ self scalars ^ (self width * self height) coefficients: coefficients! !

!DenseMatrix methodsFor: 'converting' stamp: 'len 5/5/2023 17:16:37'!
over: aRing
	self scalars = aRing ifTrue: [^ self].
	^ self class from: (domain over: aRing) to: (codomain over: aRing) coefficients: (aRing new: coefficients size fill: [:i| coefficients at: i])! !

!DenseMatrix methodsFor: 'copying' stamp: 'len 1/5/2024 16:00:31'!
copyFrom: start to: stop
	"Answer a new dense matrix containing the submatrix of the receiver from start to stop."
	| w h |
	(stop x > self height or: [stop y > self width]) ifTrue: [^ self error: 'index out of bounds'].
	w := stop y - start y + 1 max: 0.
	h := stop x - start x + 1 max: 0.
	^ self class
		from: (domain copyFrom: start y to: stop y)
		to: (codomain copyFrom: start x to: stop x)
		coefficients:
			((self scalars new: w * h)
				replaceFrom: 1 by: w withMatrix: coefficients startingAt: (self rowIndexAt: start x) + start y - 1 by: self width width: w height: h)! !

!DenseMatrix methodsFor: 'copying' stamp: 'len 1/11/2024 18:57:55'!
from: start to: stop
	"Answer the submatrix of the receiver from start to stop."
	| h w |
	h := stop x - start x + 1 max: 0.
	w := stop y - start y + 1 max: 0.
	self flag: #fixme. "better just fail if the submatrix is empty"
	(w > 0 and: [h > 0]) ifFalse: [^ DenseMatrix from: domain scalars ^ w to: codomain scalars ^ h coefficients: (self scalars new: 0)].
	(stop x > self height or: [stop y > self width]) ifTrue: [^ self error: 'index out of bounds'].
	^ Submatrix
		from: domain scalars ^ w
		to: codomain scalars ^ h
		coefficients: coefficients
		startIndex: (self rowIndexAt: start x) + start y - 1
		stride: self width! !

!DenseMatrix methodsFor: 'copying' stamp: 'len 12/20/2022 09:46:05'!
postCopy
	super postCopy.
	properties _ nil.
	coefficients _ coefficients copy! !

!DenseMatrix methodsFor: 'enumerating' stamp: 'len 4/21/2022 12:32:12'!
allSatisfy: aBlock
	^ coefficients allSatisfy: aBlock! !

!DenseMatrix methodsFor: 'enumerating' stamp: 'len 5/29/2020 04:11:36'!
collect: aBlock
	^ self class from: domain to: codomain coefficients: (coefficients collect: aBlock)! !

!DenseMatrix methodsFor: 'enumerating' stamp: 'len 12/15/2022 12:50:32'!
diagonalDo: aBlock
	| i step |
	i _ 1.
	step _ self width + 1.
	[i <= coefficients size]
		whileTrue:
			[aBlock value: (coefficients at: i).
			i _ i + step]! !

!DenseMatrix methodsFor: 'enumerating' stamp: 'len 5/28/2020 10:34:42'!
do: aBlock
	coefficients do: aBlock! !

!DenseMatrix methodsFor: 'enumerating' stamp: 'len 5/20/2022 11:37:50'!
pivotsDo: aBlock
	"Enumerate the row-style pivot indices. These are the pairs i@j corresponding to the first nonzero entry of each row."
	| w rowStart |
	w _ self width.
	rowStart _ 1.
	1 to: self height do: [:i|
		(coefficients findFirstNonzeroFrom: rowStart to: rowStart + w - 1) ifNotNil: [:j| aBlock value: i@(j - rowStart + 1)].
		rowStart _ rowStart + w]! !

!DenseMatrix methodsFor: 'enumerating' stamp: 'len 4/21/2022 12:35:08'!
withIndicesDo: aBlock
	| width i j |
	width _ self width.
	i _ 1.
	j _ 1.
	coefficients do: [:each|
		aBlock value: each value: i value: j.
		(j _ j + 1) > width ifTrue: [j _ 1. i _ i + 1]].! !

!DenseMatrix methodsFor: 'operations' stamp: 'len 10/24/2023 16:29:27'!
* anObject
	((self scalars includes: anObject) or: [anObject isInteger]) ifTrue: [^ self class from: domain to: codomain coefficients: coefficients * anObject].
	anObject isMatrix ifTrue: [^ self · anObject].
	anObject isTuple ifTrue: [^ self value: anObject].
	(anObject isKindOf: ModuleMap) ifTrue: [^ self · anObject].
	^ self class from: domain to: codomain coefficients: coefficients * (self scalars !! anObject)! !

!DenseMatrix methodsFor: 'operations' stamp: 'len 6/9/2022 07:23:50'!
+ aMatrix
	self class = aMatrix class ifFalse: [^ super + aMatrix].
	self checkDomainsMatch: aMatrix.
	self checkCodomainsMatch: aMatrix.
	^ self class from: domain to: codomain coefficients: coefficients + aMatrix coefficients! !

!DenseMatrix methodsFor: 'operations' stamp: 'len 5/9/2023 17:56:08'!
- aMatrix
	self class = aMatrix class ifFalse: [^ super - aMatrix].
	self checkDomainsMatch: aMatrix.
	self checkCodomainsMatch: aMatrix.
	^ self class from: domain to: codomain coefficients: coefficients - aMatrix coefficients! !

!DenseMatrix methodsFor: 'operations' stamp: 'len 4/21/2022 12:38:12'!
negated
	^ self class from: domain to: codomain coefficients: coefficients negated! !

!DenseMatrix methodsFor: 'operations' stamp: 'len 5/18/2023 17:32:36'!
transpose
	^ self class from: codomain to: domain coefficients: ((coefficients species new: coefficients size) replaceWithMatrixTranspose: coefficients width: self width)! !

!DenseMatrix methodsFor: 'operations' stamp: 'len 2/3/2024 17:02:59'!
value: aTuple
	(coefficients isEmpty or: [aTuple isEmpty]) ifTrue: [^ codomain zero].
	^ codomain coefficients:
		((self scalars zeros: self height)
			replaceFrom: 1 to: self height
			plusMatrix: coefficients startingAt: 1 by: self width width: self width
			timesVector: aTuple coefficients startingAt: 1)! !

!DenseMatrix methodsFor: 'operations' stamp: 'len 7/21/2024 09:34:12'!
∘ aMatrix
	self class = aMatrix class ifFalse: [^ super ∘ aMatrix].
	self checkCompatibleComposition: aMatrix.
	^ (self class
		from: aMatrix domain
		to: codomain
		coefficients: (self scalars zeros: aMatrix width * self height))
			accumulateWith: self times: aMatrix! !

!DenseMatrix methodsFor: 'operations' stamp: 'len 5/3/2024 04:52:08'!
⊓ aMatrix
	"Answer the pairing of the receiver and the argument.
	This is the row-augmented matrix with the receiver stacked on top of the argument.
	If the receiver is A and the argument is B, output a matrix of the form:
	  [A]
	  [B]"
	self class = aMatrix class ifFalse: [^ super ⊓ aMatrix].
	self checkDomainsMatch: aMatrix.
	^ self class from: domain to: codomain ⊕ aMatrix codomain coefficients: coefficients, aMatrix coefficients! !

!DenseMatrix methodsFor: 'operations' stamp: 'len 5/3/2024 04:53:46'!
⊔ aMatrix
	"Answer the copairing of the receiver and the argument.
	This is the column-augmented matrix with the receiver concatenated with the argument.
	If the receiver is A and the argument is B, output a matrix of the form:
	  [A B]"
	| newCoefficients w |
	self class = aMatrix class ifFalse: [^ super ⊔ aMatrix].
	self checkCodomainsMatch: aMatrix.
	newCoefficients := self scalars new: coefficients size + aMatrix coefficients size.
	w := self width + aMatrix width.
	1 to: self height do: [:i|
		newCoefficients
			replaceFrom: i - 1 * w + 1 to: i - 1 * w + self width with: coefficients startingAt: i - 1 * self width + 1;
			replaceFrom: i - 1 * w + self width + 1 to: i * w with: aMatrix coefficients startingAt: i - 1 * aMatrix width + 1].
	^ self class from: domain ⊕ aMatrix domain to: codomain coefficients: newCoefficients! !

!DenseMatrix methodsFor: 'operations' stamp: 'len 5/16/2022 11:32:28'!
⊕ aMatrix
	"Answer the block sum of the receiver and the argument.
	If the receiver is A and the argument is B, output a matrix of the form:
	  [A 0]
	  [0 B]"
	| newCoefficients w |
	self class = aMatrix class ifFalse: [^ super ⊕ aMatrix].
	w _ self width + aMatrix width.
	newCoefficients _ self scalars zeros: w * (self height + aMatrix height).
	1 to: self height do: [:i|
		newCoefficients replaceFrom: i - 1 * w + 1 to: i - 1 * w + self width with: coefficients startingAt: i - 1 * self width + 1].
	1 to: aMatrix height do: [:i|
		newCoefficients replaceFrom: i - 1 + self height * w + self width + 1 to: i + self height * w with: aMatrix coefficients startingAt: i - 1 * aMatrix width + 1].
	^ self class from: domain ⊕ aMatrix domain to: codomain ⊕ aMatrix codomain coefficients: newCoefficients
! !

!DenseMatrix methodsFor: 'operations-inplace' stamp: 'len 2/1/2024 19:33:46'!
accumulateWith: aMatrix1 times: aMatrix2
	(aMatrix1 isEmpty or: [aMatrix2 isEmpty]) ifTrue: [^ self].
	coefficients
		replaceFrom: 1 by: self width
		plusMatrix: aMatrix1 coefficients startingAt: aMatrix1 startIndex by: aMatrix1 stride width: aMatrix1 width height: aMatrix1 height
		timesMatrix: aMatrix2 coefficients startingAt: aMatrix2 startIndex by: aMatrix2 stride width: aMatrix2 width! !

!DenseMatrix methodsFor: 'operations-inplace' stamp: 'len 5/21/2023 17:09:39'!
replaceWith: aMatrix1 minus: aMatrix2
	(aMatrix1 class = self class and: [aMatrix2 class = self])
		ifTrue: [coefficients replaceFrom: 1 to: coefficients size with: aMatrix1 coefficients startingAt: 1 minus: aMatrix2 coefficients startingAt: 1. ^ self].
	1 to: self height do: [:i|
		| i₀ j₀ k₀ |
		i₀ := self rowIndexAt: i.
		j₀ := aMatrix1 rowIndexAt: i.
		k₀ := aMatrix2 rowIndexAt: i.
		coefficients replaceFrom: i₀ to: i₀ + self width - 1 with: aMatrix1 coefficients startingAt: j₀ minus: aMatrix2 coefficients startingAt: k₀]! !

!DenseMatrix methodsFor: 'operations-inplace' stamp: 'len 5/21/2023 17:09:53'!
replaceWith: aMatrix1 plus: aMatrix2
	(aMatrix1 class = self class and: [aMatrix2 class = self])
		ifTrue: [coefficients replaceFrom: 1 to: coefficients size with: aMatrix1 coefficients startingAt: 1 plus: aMatrix2 coefficients startingAt: 1. ^ self].
	1 to: self height do: [:i|
		| i₀ j₀ k₀ |
		i₀ := self rowIndexAt: i.
		j₀ := aMatrix1 rowIndexAt: i.
		k₀ := aMatrix2 rowIndexAt: i.
		coefficients replaceFrom: i₀ to: i₀ + self width - 1 with: aMatrix1 coefficients startingAt: j₀ plus: aMatrix2 coefficients startingAt: k₀]! !

!DenseMatrix methodsFor: 'operations-rows' stamp: 'len 12/19/2022 10:24:22'!
addRow: i₁ times: anElement to: i₂
	self addRow: i₁ times: anElement to: i₂ startingAt: 1! !

!DenseMatrix methodsFor: 'operations-rows' stamp: 'len 2/2/2024 10:59:24'!
addRow: i₁ times: anElement to: i₂ startingAt: startColumn
	| width start₁ start₂ |
	width := self width.
	start₁ := i₁ - 1 * width + startColumn.
	start₂ := i₂ - 1 * width + startColumn.
	coefficients
		replaceFrom: start₂ to: i₂ * width
		plus: coefficients startingAt: start₁
		timesScalar: anElement! !

!DenseMatrix methodsFor: 'operations-rows' stamp: 'len 12/29/2022 09:51:40'!
cancelRow: i₁ and: i₂ with: mgcd
	| s t u v A₁ A₂ |
	s _ mgcd at: 2.
	t _ mgcd at: 3.
	u _ mgcd at: 4.
	v _ mgcd at: 5.
	self flag: #fixme. "optimize:"
	A₁ _ (self rowAt: i₁) copy.
	A₂ _ (self rowAt: i₂) copy.
	self rowAt: i₁ put: A₁*s + (A₂*t).
	self rowAt: i₂ put: A₁*u + (A₂*v)! !

!DenseMatrix methodsFor: 'operations-rows' stamp: 'len 12/29/2022 09:52:16'!
copyRow: i₁ times: anElement to: i₂
	self copyRow: i₁ times: anElement to: i₂ startingAt: 1! !

!DenseMatrix methodsFor: 'operations-rows' stamp: 'len 12/29/2022 09:53:17'!
copyRow: i₁ times: anElement to: i₂ startingAt: startColumn
	| width start₁ start₂ |
	width _ self width.
	start₁ _ i₁ - 1 * width + startColumn.
	start₂ _ i₂ - 1 * width + startColumn.
	coefficients
		replaceFrom: start₂ to: i₂ * width
		with: coefficients startingAt: start₁
		timesScalar: anElement! !

!DenseMatrix methodsFor: 'operations-rows' stamp: 'len 12/29/2022 09:53:40'!
copyRow: i₁ to: i₂
	self copyRow: i₁ to: i₂ startingAt: 1! !

!DenseMatrix methodsFor: 'operations-rows' stamp: 'len 12/29/2022 09:54:41'!
copyRow: i₁ to: i₂ startingAt: startColumn
	| width start₁ start₂ |
	width _ self width.
	start₁ _ i₁ - 1 * width + startColumn.
	start₂ _ i₂ - 1 * width + startColumn.
	coefficients
		replaceFrom: start₂ to: i₂ * width
		with: coefficients startingAt: start₁! !

!DenseMatrix methodsFor: 'operations-rows' stamp: 'len 12/15/2022 11:53:33'!
multiplyRow: i by: anElement
	self multiplyRow: i by: anElement startingAt: 1! !

!DenseMatrix methodsFor: 'operations-rows' stamp: 'len 5/21/2023 20:44:20'!
multiplyRow: i by: anElement startingAt: startColumn
	| width start |
	width := self width.
	start := i - 1 * width + startColumn.
	coefficients
		replaceFrom: start to: i * width
		with: coefficients startingAt: start
		timesScalar: anElement! !

!DenseMatrix methodsFor: 'operations-rows' stamp: 'len 12/19/2022 10:28:49'!
swapRow: i₁ with: i₂
	| width start₁ start₂ |
	width _ self width.
	start₁ _ i₁ - 1 * width + 1.
	start₂ _ i₂ - 1 * width + 1.
	coefficients
		swapFrom: start₁ to: i₁ * width
		with: coefficients startingAt: start₂! !

!DenseMatrix methodsFor: 'testing' stamp: 'len 5/20/2023 12:22:00'!
isDense
	^ true! !

!DenseMatrix methodsFor: 'testing' stamp: 'len 4/21/2022 12:45:41'!
isZero
	^ coefficients isZero! !

!DenseMatrix methodsFor: 'testing' stamp: 'len 4/21/2022 12:47:28'!
isZeroAt: aPoint
	^ coefficients isZeroAt: aPoint x - 1 * self width + aPoint y! !

!DenseMatrix methodsFor: 'private' stamp: 'len 5/28/2020 09:57:19'!
coefficients
	^ coefficients! !

!DenseMatrix methodsFor: 'private' stamp: 'len 5/8/2023 16:32:22'!
coefficients: anArray
	coefficients _ anArray! !

!DenseMatrix methodsFor: 'private' stamp: 'len 1/10/2024 10:14:50'!
rowIndexAt: anInteger
	"Answer the index of the start of the anInteger-th row in the array of coefficients."
	^ anInteger - 1 * self width + 1! !

!DenseMatrix methodsFor: 'private' stamp: 'len 5/22/2023 17:21:22'!
rowIndices
	^ (1 to: self height - 1 * self width + 1 by: self width) as: DoubleByteArray! !

!DenseMatrix methodsFor: 'private' stamp: 'len 1/1/2024 07:53:15'!
startIndex
	^ 1! !

!DenseMatrix methodsFor: 'private' stamp: 'len 1/1/2024 07:53:01'!
stride
	^ self width! !

!DenseMatrix methodsFor: 'private' stamp: 'len 5/14/2023 18:01:51'!
validate
	self assert: coefficients size = (domain rank * codomain rank).
	self assert: (self scalars isValidArray: coefficients).
	^ super validate! !

!DenseMatrix class methodsFor: 'instance creation' stamp: 'len 4/20/2022 20:57:36'!
from: aDomain to: aCodomain coefficients: anArray
	^ self new domain: aDomain; codomain: aCodomain; coefficients: anArray! !

!SparseMatrix methodsFor: 'accessing' stamp: 'len 5/3/2022 05:36:15'!
atRow: i column: j ifAbsent: exceptionBlock
	(rowPointers at: i) to: (rowPointers at: i+1) - 1 do: [:k| (columnIndices at: k) = j ifTrue: [^ coefficients at: k]].
	^ exceptionBlock value! !

!SparseMatrix methodsFor: 'operations' stamp: 'len 11/26/2023 20:46:24'!
value: aTuple
	^ codomain fill: [:i|
		| value |
		value := self scalars zero.
		(rowPointers at: i) to: (rowPointers at: i+1) - 1 do: [:j| value := (coefficients at: j) * (aTuple at: (columnIndices at: j)) + value].
		value]! !

!SparseMatrix methodsFor: 'private' stamp: 'len 5/3/2022 05:36:47'!
coefficients: anArray columnIndices: anArray2 rowPointers: anArray3
	coefficients _ anArray.
	columnIndices _ anArray2.
	rowPointers _ anArray3! !

!SparseMatrix methodsFor: 'private' stamp: 'len 7/8/2022 11:15:49'!
validate
	self assert: coefficients size = columnIndices size.
	self assert: rowPointers last - 1 = coefficients size.
	self assert: (coefficients allSatisfy: [:each| self scalars includes: each]).
	self assert: (columnIndices allSatisfy: [:each| each between: 1 and: domain rank]).
	self assert: ((1 to: rowPointers size - 1) sum: [:i| (rowPointers at: i+1) - (rowPointers at: i)]) = coefficients size.
	self assert: ((1 to: rowPointers size - 1) allSatisfy: [:i| (rowPointers at: i+1) >= (rowPointers at: i)]).
	^ super validate! !

!SparseMatrix class methodsFor: 'examples' stamp: 'len 5/3/2022 05:35:22'!
example
	^ self from: ℤ^5 to: ℤ^5
		coefficients: #(1 -1 -3 -2 5 4 6 4 -4 2 7 8 -5)
		columnIndices: #(1 2 4 1 2 3 4 5 1 3 4 2 5)
		rowPointers: #(1 4 6 9 12 14)! !

!SparseMatrix class methodsFor: 'instance creation' stamp: 'len 5/3/2022 05:35:06'!
from: aDomain to: aCodomain coefficients: anArray columnIndices: anArray2 rowPointers: anArray3
	^ self new domain: aDomain; codomain: aCodomain; coefficients: anArray columnIndices: anArray2 rowPointers: anArray3! !

!Submatrix methodsFor: 'accessing' stamp: 'len 12/30/2023 17:13:31'!
atAllPut: anElement
	self rowIndicesDo: [:i₀| coefficients from: i₀ to: i₀ + self width - 1 put: anElement]! !

!Submatrix methodsFor: 'accessing' stamp: 'len 12/30/2023 17:14:25'!
atRow: i column: j ifAbsent: exceptionBlock
	(j between: 1 and: self width) ifFalse: [^ exceptionBlock value].
	^ coefficients at: (self rowIndexAt: i) + j - 1! !

!Submatrix methodsFor: 'accessing' stamp: 'len 12/30/2023 17:14:44'!
atRow: i column: j put: anElement
	(j between: 1 and: self width) ifFalse: [^ self  error: 'index out of bounds'].
	^ coefficients at: (self rowIndexAt: i) + j - 1 put: anElement! !

!Submatrix methodsFor: 'copying' stamp: 'len 1/11/2024 18:41:02'!
copy
	^ DenseMatrix
		from: domain
		to: codomain
		coefficients:
			((self scalars new: self width * self height)
				replaceFrom: 1 by: self width withMatrix: coefficients startingAt: startIndex by: stride width: self width height: self height)! !

!Submatrix methodsFor: 'copying' stamp: 'len 1/11/2024 21:20:36'!
copyFrom: start to: stop
	"Answer a new dense matrix containing the submatrix of the receiver from start to stop."
	| w h |
	(stop x > self height or: [stop y > self width]) ifTrue: [^ self error: 'index out of bounds'].
	w := stop y - start y + 1 max: 0.
	h := stop x - start x + 1 max: 0.
	^ DenseMatrix
		from: (domain copyFrom: start y to: stop y)
		to: (codomain copyFrom: start x to: stop x)
		coefficients:
			((self scalars new: w * h)
				replaceFrom: 1 by: w withMatrix: coefficients startingAt: (self rowIndexAt: start x) + start y - 1 by: stride width: w height: h)! !

!Submatrix methodsFor: 'copying' stamp: 'len 1/11/2024 18:57:15'!
from: start to: stop
	"Answer the submatrix of the receiver from start to stop."
	| h w |
	h := stop x - start x + 1 max: 0.
	w := stop y - start y + 1 max: 0.
	self flag: #fixme. "better just fail if the submatrix is empty"
	(w > 0 and: [h > 0]) ifFalse: [^ DenseMatrix from: domain scalars ^ w to: codomain scalars ^ h coefficients: (self scalars new: 0)].
	(stop x > self height or: [stop y > self width]) ifTrue: [^ self error: 'index out of bounds'].
	^ self class
		from: domain scalars ^ w
		to: codomain scalars ^ h
		coefficients: coefficients
		startIndex: (self rowIndexAt: start x) + start y - 1
		stride: stride! !

!Submatrix methodsFor: 'operations' stamp: 'len 2/3/2024 17:03:19'!
value: aTuple
	(coefficients isEmpty or: [aTuple isEmpty]) ifTrue: [^ codomain zero].
	^ codomain coefficients:
		((codomain scalars zeros: self height)
			replaceFrom: 1 to: self height
			plusMatrix: coefficients startingAt: startIndex by: stride width: self width
			timesVector: aTuple coefficients startingAt: 1)! !

!Submatrix methodsFor: 'operations-inplace' stamp: 'len 2/1/2024 19:33:46'!
accumulateWith: aMatrix1 times: aMatrix2
	(aMatrix1 isEmpty or: [aMatrix2 isEmpty]) ifTrue: [^ self].
	coefficients
		replaceFrom: startIndex by: stride
		plusMatrix: aMatrix1 coefficients startingAt: aMatrix1 startIndex by: aMatrix1 stride width: aMatrix1 width height: aMatrix1 height
		timesMatrix: aMatrix2 coefficients startingAt: aMatrix2 startIndex by: aMatrix2 stride width: aMatrix2 width! !

!Submatrix methodsFor: 'operations-inplace' stamp: 'len 1/1/2024 08:04:19'!
replaceWith: aMatrix1 minus: aMatrix2
	coefficients
		replaceFrom: startIndex by: stride
		withMatrix: aMatrix1 coefficients startingAt: aMatrix1 startIndex by: aMatrix1 stride width: aMatrix1 width height: aMatrix1 height
		plusMatrix: aMatrix2 coefficients startingAt: aMatrix2 startIndex by: aMatrix2 stride
		timesScalar: -1! !

!Submatrix methodsFor: 'operations-inplace' stamp: 'len 1/1/2024 08:04:28'!
replaceWith: aMatrix1 plus: aMatrix2
	coefficients
		replaceFrom: startIndex by: stride
		withMatrix: aMatrix1 coefficients startingAt: aMatrix1 startIndex by: aMatrix1 stride width: aMatrix1 width height: aMatrix1 height
		plusMatrix: aMatrix2 coefficients startingAt: aMatrix2 startIndex by: aMatrix2 stride
		timesScalar: 1! !

!Submatrix methodsFor: 'testing' stamp: 'len 12/30/2023 17:10:34'!
isDense
	^ true! !

!Submatrix methodsFor: 'private' stamp: 'len 12/30/2023 17:11:35'!
coefficients
	^ coefficients! !

!Submatrix methodsFor: 'private' stamp: 'len 12/30/2023 17:12:13'!
coefficients: anArray startIndex: anInteger stride: anotherInteger
	coefficients := anArray.
	startIndex := anInteger.
	stride := anotherInteger! !

!Submatrix methodsFor: 'private' stamp: 'len 1/10/2024 10:15:40'!
rowIndexAt: anInteger
	"Answer the index of the start of the anInteger-th row in the array of coefficients."
	^ anInteger - 1 * stride + startIndex! !

!Submatrix methodsFor: 'private' stamp: 'len 12/30/2023 17:10:26'!
rowIndicesDo: aBlock
	| i |
	i := startIndex.
	self height timesRepeat: [aBlock value: i. i := i + stride]! !

!Submatrix methodsFor: 'private' stamp: 'len 1/1/2024 09:19:17'!
startIndex
	^ startIndex! !

!Submatrix methodsFor: 'private' stamp: 'len 1/1/2024 09:19:21'!
stride
	^ stride! !

!Submatrix class methodsFor: 'instance creation' stamp: 'len 12/31/2023 09:14:22'!
from: aDomain to: aCodomain coefficients: anArray startIndex: anInteger stride: anotherInteger
	^ self new domain: aDomain; codomain: aCodomain; coefficients: anArray startIndex: anInteger stride: anotherInteger! !

!QuadraticForm methodsFor: 'accessing' stamp: 'len 3/28/2018 02:47:11'!
at: aPoint
	| i j n |
	i _ aPoint x - 1.
	j _ aPoint y - 1.
	i > j ifTrue: [i _ j. j _ aPoint x - 1].
	n _ self rank.
	^ self coefficients at: i * n - (i-1*i//2) + j - i + 1! !

!QuadraticForm methodsFor: 'accessing' stamp: 'len 3/28/2018 03:01:03'!
bitSize
	^ self coefficients bitSize! !

!QuadraticForm methodsFor: 'accessing' stamp: 'len 12/30/2015 21:16'!
codomain
	^ self scalars! !

!QuadraticForm methodsFor: 'accessing' stamp: 'len 3/28/2018 03:00:51'!
coefficients
	"Answer the coefficients of the receiver in lexicographical order."
	^ coefficients! !

!QuadraticForm methodsFor: 'accessing' stamp: 'len 9/22/2018 18:57:55'!
content
	^ self coefficients content! !

!QuadraticForm methodsFor: 'accessing' stamp: 'len 3/28/2018 03:12:29'!
determinant
	"Answer the determinant of the Hessian matrix of the receiver. This is the determinant of the Gram matrix of twice the receiver."
	^ self hessian determinant! !

!QuadraticForm methodsFor: 'accessing' stamp: 'len 5/6/2022 12:34:23'!
discriminant
	"Note: this invariant is defined differently by different authors."
	self rank odd ifTrue: [^ self determinant / 2].
	(self rank // 2) odd ifTrue: [^ self determinant negated].
	^ self determinant! !

!QuadraticForm methodsFor: 'accessing' stamp: 'len 8/4/2021 14:24:00'!
gramian
	"Answer the Gramian matrix G for the receiver Q.
	This is a matrix G such that Q(x) = x^t * G * x."
	| R two |
	R _ self scalars.
	two _ R !! 2.
	^ self hessian collect: [:each| R !! (each / two)]! !

!QuadraticForm methodsFor: 'accessing' stamp: 'len 11/23/2022 21:39:39'!
hessian
	"Answer the Hessian matrix H for the receiver Q.
	This is a matrix H such that Q(x) = x^t * H * x / 2."
	^ self scalars matrix: self domain rank fill: [:i :j| i = j ifTrue: [(self at: i@j)*2] ifFalse: [self at: i@j]]! !

!QuadraticForm methodsFor: 'accessing' stamp: 'len 3/27/2018 23:58:26'!
rank
	^ self domain rank! !

!QuadraticForm methodsFor: 'accessing' stamp: 'len 3/19/2018 20:00:15'!
scalars
	^ self domain scalars! !

!QuadraticForm methodsFor: 'comparing' stamp: 'len 3/28/2018 03:12:11'!
= aQuadraticForm
	(aQuadraticForm isKindOf: QuadraticForm) ifFalse: [^ false].
	^ self coefficients = aQuadraticForm coefficients! !

!QuadraticForm methodsFor: 'comparing' stamp: 'len 9/22/2018 18:57:58'!
~ aQuadraticForm
	"Answer true if the receiver and the argument are integrally equivalent."
	^ self hessian ~ aQuadraticForm hessian! !

!QuadraticForm methodsFor: 'comparing' stamp: 'len 3/28/2018 03:12:33'!
hash
	^ self coefficients hash! !

!QuadraticForm methodsFor: 'converting' stamp: 'len 7/6/2020 10:56:53'!
asPolynomial
	| n R answer |
	n _ self rank.
	R _ self domain coordinateRing.
	answer _ R zero.
	1 to: n do: [:i|
		| vi |
		vi _ R x: i.
		i to: n do: [:j| answer _  vi * (R x: j) * (self at: i@j) + answer]].
	^ answer! !

!QuadraticForm methodsFor: 'converting' stamp: 'len 7/20/2020 06:57:04'!
polarization
	"Answer the associated symmetric bilinear form (assuming the characteristic is not 2).
	This is, via the polarization identity: B(v,w) := (Q(v+w) - Q(v) -Q(w)) / 2."
	^ BilinearForm on: self domain matrix: self gramian! !

!QuadraticForm methodsFor: 'initialization' stamp: 'len 3/28/2018 03:06:18'!
coefficients: aTuple
	coefficients _ aTuple! !

!QuadraticForm methodsFor: 'operations' stamp: 'len 3/28/2018 02:59:45'!
* anObject
	^ self class from: self domain coefficients: self coefficients * anObject! !

!QuadraticForm methodsFor: 'operations' stamp: 'len 7/5/2020 20:10:42'!
+ aQuadraticForm
	self domain = aQuadraticForm domain ifFalse: [^ self error: 'domains don''t match'].
"	self domain matrix = aQuadraticForm domain matrix ifFalse: [self notYetImplemented]."
	^ self class
		from: self domain
		coefficients: self coefficients + aQuadraticForm coefficients! !

!QuadraticForm methodsFor: 'operations' stamp: 'len 7/22/2021 18:54:22'!
adjoint
	"Answer the adjoint (integral) quadratic form associated to the receiver."
	| A |
	A _ self hessian conjugate.
	self rank odd ifTrue: [A _ A*2].
	^ self class from: self domain hessian: A! !

!QuadraticForm methodsFor: 'operations' stamp: 'len 7/28/2020 19:37:10'!
automorphisms
	"Answer the orthogonal group consisting of the self-isometries with respect to the receiver."
	^ OrthogonalGroup on: self! !

!QuadraticForm methodsFor: 'operations' stamp: 'len 3/28/2018 02:59:58'!
negated
	^ self class from: self domain coefficients: self coefficients negated! !

!QuadraticForm methodsFor: 'operations' stamp: 'len 7/17/2019 10:51:12'!
primitivePart
	^ self class from: self domain coefficients: self coefficients primitivePart! !

!QuadraticForm methodsFor: 'operations' stamp: 'len 7/17/2019 10:51:22'!
reciprocal
	^ self adjoint primitivePart * self content! !

!QuadraticForm methodsFor: 'operations' stamp: 'len 4/26/2021 11:43:35'!
value: aVector
	| v n answer |
	v _ self domain \ aVector.
	n _ self rank.
	answer _ self scalars zero.
	1 to: n do: [:i|
		| vi |
		vi _ v at: i.
		i to: n do: [:j|
			answer _ (self at: i@j) * vi * (v at: j) + answer]].
	^ answer! !

!QuadraticForm methodsFor: 'operations' stamp: 'len 4/5/2024 19:01:52'!
⊕ aQuadraticForm
	"Answer the orthogonal sum of the receiver and the argument."
	self assert: (aQuadraticForm isKindOf: QuadraticForm).
	^ self class from: self domain ⊕ aQuadraticForm domain gramian: self gramian ⊕ aQuadraticForm gramian! !

!QuadraticForm methodsFor: 'printing' stamp: 'len 4/21/2016 00:22'!
printOn: aStream
	aStream print: self asPolynomial! !

!QuadraticForm methodsFor: 'testing' stamp: 'len 3/28/2018 03:12:40'!
isDiagonal
	"Answer true if the receiver is in diagonal form."
	^ self hessian isDiagonal! !

!QuadraticForm methodsFor: 'testing' stamp: 'len 3/28/2018 01:03:53'!
isPrimitive
	^ self content = self scalars one! !

!QuadraticForm methodsFor: 'testing' stamp: 'len 7/6/2020 06:25:48'!
isRegular
	^ self polarization isNonDegenerate! !

!QuadraticForm methodsFor: 'testing' stamp: 'len 7/13/2020 18:13:26'!
isZero
	^ coefficients isZero! !

!QuadraticForm class methodsFor: 'instance creation' stamp: 'len 7/19/2020 07:21:29'!
coefficients: aTuple
	"Answer the quadratic form with the given coefficients (in lexicographical order)."
	aTuple isTuple ifFalse: [^ self error: 'not a tuple'].
	^ self from: aTuple scalars ^ (aTuple size * 2) sqrtFloor coefficients: aTuple! !

!QuadraticForm class methodsFor: 'instance creation' stamp: 'len 7/19/2020 07:22:46'!
from: aFreeModule coefficients: aTuple
	"Answer the quadratic form associated with the given coefficients (in lexicographical order) in the distinguished basis of the given free module."
	^ self new domain: aFreeModule; coefficients: ((aTuple isTuple and: [aTuple scalars = aFreeModule scalars]) ifTrue: [aTuple] ifFalse: [aFreeModule scalars ^ aTuple size !! aTuple])! !

!QuadraticForm class methodsFor: 'instance creation' stamp: 'len 11/23/2022 17:11:11'!
from: aFreeModule gramian: aMatrix
	| coefficients n |
	coefficients _ OrderedCollection new.
	n _ aFreeModule rank.
	1 to: n do: [:i|
		i to: n do: [:j|
			coefficients add: (i = j ifTrue: [aMatrix at: i@j] ifFalse: [(aMatrix at: i@j) * 2])]].
	^ self from: aFreeModule coefficients: aFreeModule scalars !!!! coefficients asArray! !

!QuadraticForm class methodsFor: 'instance creation' stamp: 'len 7/6/2020 09:37:51'!
from: aFreeModule hessian: aMatrix
	^ self from: aFreeModule gramian: aMatrix/2! !

!SchemeMorphism methodsFor: 'accessing' stamp: 'len 4/12/2024 04:53:17'!
category
	^ Sch! !

!SchemeMorphism methodsFor: 'operations' stamp: 'len 6/24/2022 08:55:45'!
@ aPoint
	"Answer the induced map on stalks. See [Vak17, Exercise 6.2.C]."
	^ self notYetImplemented! !

!SchemeMorphism methodsFor: 'operations' stamp: 'len 6/24/2022 08:34:15'!
image
	"Answer (the Zeriski closure of) the image of the receiver. This is a closed subscheme of the codomain."
	"It can be computed affine-locally. See [Vak17, Theorem 8.3.4]."
	^ self notYetImplemented! !

!SchemeMorphism methodsFor: 'testing' stamp: 'len 6/24/2022 09:06:58'!
isAffine
	"Affineness is affine-local on the target. See [Val17, 7.3.4]."
	^ self notYetImplemented! !

!SchemeMorphism methodsFor: 'testing' stamp: 'len 6/29/2023 19:50:21'!
isFinite
	"Finiteness is affine-local on the target. A morphism π:X→Y is finite if there's a cover of Y by affine open sets Spec A such that π^-1(Spec A) is the spectrum of a finite A-algebra. See [Val17, 7.3.G].
	Also finite = integral + finite type [Val17, 7.3.P]."
	^ self notYetImplemented! !

!SchemeMorphism methodsFor: 'testing' stamp: 'len 6/24/2022 09:19:25'!
isFiniteType
	^ self isLocallyOfFiniteType and: [self isQuasicompact]! !

!SchemeMorphism methodsFor: 'testing' stamp: 'len 6/29/2023 19:50:37'!
isIntegral
	"A morphism π:X→Y is integral is π is affine, and for every affine open subset Spec B <= Y, with π^-1(Spec B) = Spec A, the induced map B → A is an integral ring homomorphism."
	"Integrality is affine-local. See [Val17, 7.3.10]."
	^ self notYetImplemented! !

!SchemeMorphism methodsFor: 'testing' stamp: 'len 6/24/2022 09:19:09'!
isLocallyOfFinitePresentation
	"Locally of finite presentation is affine-local on the source. See [Val17, 7.3.U]."
	^ self notYetImplemented! !

!SchemeMorphism methodsFor: 'testing' stamp: 'len 6/24/2022 09:18:20'!
isLocallyOfFiniteType
	"Locally of finite type is affine-local on the target. See [Val17, 7.3.O]."
	^ self notYetImplemented! !

!SchemeMorphism methodsFor: 'testing' stamp: 'len 6/24/2022 09:22:44'!
isQuasiaffine
	"Quasiaffineness is affine-local on the target. See [Val17, 17.3.H]."
	^ self notYetImplemented! !

!SchemeMorphism methodsFor: 'testing' stamp: 'len 6/24/2022 09:05:59'!
isQuasicompact
	"Quasicompactness is affine-local on the target. See [Val17, 7.3.C]."
	^ self notYetImplemented! !

!SchemeMorphism methodsFor: 'testing' stamp: 'len 6/24/2022 09:06:12'!
isQuasiseparated
	"Quasiseparatedness is affine-local on the target. See [Val17, 7.3.C]."
	^ self notYetImplemented! !

!SchemeMorphism methodsFor: 'private' stamp: 'len 4/4/2024 08:24:58'!
species
	^ SchemeMorphism! !

!SchemeMorphism class methodsFor: 'class initialization' stamp: 'len 4/12/2024 06:12:16'!
initialize
	super initialize.
	Sch := Category new
		propertyAt: #initialObject put: (ℤ/1) spec;
		propertyAt: #terminalObject put: ℤ spec;
		yourself! !

!AffineMorphism methodsFor: 'accessing' stamp: 'len 5/8/2023 18:35:39'!
codomain
	^ self asRingMap domain spec! !

!AffineMorphism methodsFor: 'accessing' stamp: 'len 5/8/2023 18:35:45'!
domain
	^ self asRingMap codomain spec! !

!AffineMorphism methodsFor: 'comparing' stamp: 'len 4/4/2024 08:25:10'!
= anObject
	^ (anObject isKindOf: AffineMorphism) and: [self asRingMap = anObject asRingMap]! !

!AffineMorphism methodsFor: 'comparing' stamp: 'len 5/8/2023 18:35:51'!
hash
	^ self asRingMap hash! !

!AffineMorphism methodsFor: 'converting' stamp: 'len 5/8/2023 18:35:33'!
asRationalMap
	^ self domain to: self codomain representatives: ((1 to: self asRingMap domain rank) collect: [:i| self asRingMap value: (self asRingMap domain x: i)])! !

!AffineMorphism methodsFor: 'converting' stamp: 'len 10/4/2023 19:20:02'!
asRingMap
	^ self propertyAt: #ringMap! !

!AffineMorphism methodsFor: 'operations' stamp: 'len 5/8/2023 18:35:03'!
@ aPoint
	"Answer the induced map on stalks."
	^ (self asRingMap @ aPoint asIdeal) spec! !

!AffineMorphism methodsFor: 'operations' stamp: 'len 4/4/2024 08:25:10'!
× aMorphism
	(aMorphism isKindOf: AffineMorphism) ifFalse: [^ super × aMorphism].
	^ (self asRingMap ⊗ aMorphism asRingMap) spec! !

!AffineMorphism methodsFor: 'operations' stamp: 'len 6/26/2023 14:43:05'!
image
	"Answer (the Zeriski closure of) the image of the receiver. This is a closed subscheme of the codomain."
	^ self codomain sub: self asRingMap kernel! !

!AffineMorphism methodsFor: 'operations' stamp: 'len 5/8/2023 18:36:00'!
inverse
	^ self asRingMap inverse spec! !

!AffineMorphism methodsFor: 'operations' stamp: 'len 6/26/2023 14:43:09'!
preimage: aSubscheme
	"Answer the preimage of aSubscheme. The argument is a subscheme of the codomain, and the answer is a subscheme of the domain."
	^ self domain sub: (aSubscheme asIdeal apply: self asRingMap)! !

!AffineMorphism methodsFor: 'operations' stamp: 'len 6/24/2022 12:27:53'!
projectiveClosure
	^ self notYetImplemented! !

!AffineMorphism methodsFor: 'operations' stamp: 'len 5/8/2023 18:36:27'!
value: aPoint
	^ self codomain !! (self asRingMap preimage: aPoint asIdeal)! !

!AffineMorphism methodsFor: 'operations' stamp: 'len 7/21/2024 09:34:29'!
∘ aMorphism
	(aMorphism isKindOf: AffineMorphism) ifFalse: [^ super ∘ aMorphism].
	^ (aMorphism asRingMap ∘ self asRingMap) spec! !

!AffineMorphism methodsFor: 'testing' stamp: 'len 6/29/2023 19:51:00'!
isClosedImmersion
	"A morphism π:X→Y is a closed embedding (or closed immersion) if it is an affine morphism, and for every affine open subset Spec B <= Y with π^-1(Spec B) ~ Spec A, the map B → A is surjective."
	^ self asRingMap isSurjective! !

!AffineMorphism methodsFor: 'testing' stamp: 'len 12/10/2023 10:36:24'!
isDominant
	"Answer true if the image is dense."
	^ self asRingMap kernel ⊆ self asRingMap domain nilradical! !

!AffineMorphism methodsFor: 'testing' stamp: 'len 5/8/2023 18:36:13'!
isIdentity
	^ self asRingMap isIdentity! !

!AffineMorphism methodsFor: 'testing' stamp: 'len 5/8/2023 18:36:17'!
isIntegral
	^ self asRingMap isIntegral! !

!AffineMorphism methodsFor: 'testing' stamp: 'len 5/8/2023 18:36:19'!
isIsomorphism
	^ self asRingMap isIsomorphism! !

!AffineMorphism methodsFor: 'testing' stamp: 'len 6/24/2022 12:23:22'!
isOpenImmersion
	^ self notYetImplemented! !

!AffineMorphism methodsFor: 'testing' stamp: 'len 6/24/2022 09:04:37'!
isQuasicompact
	^ true! !

!AffineMorphism methodsFor: 'testing' stamp: 'len 6/24/2022 09:04:47'!
isQuasiseparated
	^ true! !

!AffineMorphism methodsFor: 'private' stamp: 'len 10/4/2023 19:19:54'!
ringMap: aRingMap
	self propertyAt: #ringMap put: aRingMap! !

!AffineMorphism class methodsFor: 'instance creation' stamp: 'len 7/9/2022 17:41:05'!
ringMap: aRingMap
	^ self new ringMap: aRingMap! !

!AffinePoint methodsFor: 'accessing' stamp: 'len 5/8/2023 22:57:16'!
ambient
	^ self codomain ambient! !

!AffinePoint methodsFor: 'accessing' stamp: 'len 5/8/2023 22:57:32'!
codomain
	^ codomain! !

!AffinePoint methodsFor: 'accessing' stamp: 'len 5/8/2023 22:58:16'!
coordinates
	^ coordinates! !

!AffinePoint methodsFor: 'accessing' stamp: 'len 5/8/2023 22:58:29'!
domain
	^ self scalars spec! !

!AffinePoint methodsFor: 'accessing' stamp: 'len 1/7/2017 22:07:07'!
height
	^ coordinates height! !

!AffinePoint methodsFor: 'accessing' stamp: 'len 7/26/2022 19:24:31'!
multiplicity
	^ self codomain multiplicityAt: coordinates! !

!AffinePoint methodsFor: 'accessing' stamp: 'len 5/8/2023 22:59:29'!
scalars
	^ coordinates scalars! !

!AffinePoint methodsFor: 'accessing' stamp: 'len 4/12/2018 04:17:39'!
tangentCone
	"Answer the affine tangent cone at this point."
	^ self codomain tangentConeAt: coordinates! !

!AffinePoint methodsFor: 'accessing' stamp: 'len 4/12/2018 04:17:46'!
tangentSpace
	"Answer the affine tangent space at this point."
	^ self codomain tangentSpaceAt: coordinates! !

!AffinePoint methodsFor: 'arithmetic' stamp: 'len 5/8/2023 23:26:08'!
+ aTuple
	"Answer the result of translating the receiver by a vector."
	^ self shallowCopy coordinates: coordinates + aTuple! !

!AffinePoint methodsFor: 'arithmetic' stamp: 'len 5/8/2023 23:26:23'!
- anAffinePoint
	"The difference between two affine points is a vector (a tuple)."
	^ coordinates - anAffinePoint coordinates! !

!AffinePoint methodsFor: 'comparing' stamp: 'len 5/8/2023 23:27:02'!
= anObject
	^ self class = anObject class and: [coordinates = anObject coordinates]! !

!AffinePoint methodsFor: 'comparing' stamp: 'len 5/8/2023 23:27:56'!
hash
	^ coordinates hash! !

!AffinePoint methodsFor: 'converting' stamp: 'len 5/8/2023 23:27:09'!
asIdeal
	"Answer the prime ideal defining the receiver."
	| R |
"	self codomain scalars = self scalars ifFalse: [^ self notYetImplemented]."
	R _ self codomain coordinateRing.
	^ R * (R generators - coordinates asArray)! !

!AffinePoint methodsFor: 'converting' stamp: 'len 5/8/2023 23:27:47'!
asRingMap
	^ self codomain coordinateRing to: self domain coordinateRing map: [:f| f value: coordinates]! !

!AffinePoint methodsFor: 'converting' stamp: 'len 5/8/2023 22:57:22'!
asTuple
	^ coordinates! !

!AffinePoint methodsFor: 'converting' stamp: 'len 6/28/2023 00:04:00'!
homogenized
	"Answer the corresponding point in the projective closure."
	^ self codomain → self codomain projectiveClosure value: self! !

!AffinePoint methodsFor: 'operations' stamp: 'len 7/12/2023 12:42:20'!
restriction
	"Answer the corresponding point in the Weil restriction of the codomain."
	| newCoordinates |
	newCoordinates := self scalars scalars new: 0.
	coordinates coefficients do: [:each| newCoordinates := newCoordinates, each coefficients].
	^ self codomain restriction pointAt: (self scalars scalars !!!! newCoordinates)! !

!AffinePoint methodsFor: 'printing' stamp: 'len 5/8/2023 23:28:07'!
printOn: aStream
	aStream print: coordinates! !

!AffinePoint methodsFor: 'testing' stamp: 'len 5/8/2023 22:59:13'!
isSingular
	^ self isSmooth not! !

!AffinePoint methodsFor: 'testing' stamp: 'len 5/8/2023 23:28:02'!
isSmooth
	^ (self codomain singular satisfies: coordinates) not! !

!AffinePoint methodsFor: 'private' stamp: 'len 5/8/2023 22:58:04'!
codomain: anAffineVariety
	codomain _ anAffineVariety! !

!AffinePoint methodsFor: 'private' stamp: 'len 5/8/2023 23:07:30'!
coordinates: aTuple
	coordinates _ aTuple! !

!AffinePoint methodsFor: 'private' stamp: 'len 6/21/2023 16:09:36'!
validate
	super validate.
	self assert: (codomain satisfies: coordinates)! !

!AffinePoint class methodsFor: 'instance creation' stamp: 'len 2/13/2017 21:16:06'!
on: anAffineVariety coordinates: aTuple
	^ self new codomain: anAffineVariety; coordinates: aTuple! !

!ProjectivePoint methodsFor: 'accessing' stamp: 'len 5/8/2023 23:01:00'!
ambient
	^ self codomain ambient! !

!ProjectivePoint methodsFor: 'accessing' stamp: 'len 5/8/2023 23:01:16'!
codomain
	^ codomain! !

!ProjectivePoint methodsFor: 'accessing' stamp: 'len 5/8/2023 23:01:23'!
coordinates
	^ coordinates! !

!ProjectivePoint methodsFor: 'accessing' stamp: 'len 5/8/2023 23:01:30'!
domain
	^ self scalars spec! !

!ProjectivePoint methodsFor: 'accessing' stamp: 'len 2/13/2017 07:53:19'!
multiplicity
	^ self dehomogenized multiplicity "assuming none of the components of the projective variety lies on the hyperplane at infinity"! !

!ProjectivePoint methodsFor: 'accessing' stamp: 'len 5/8/2023 23:02:17'!
scalars
	^ coordinates scalars! !

!ProjectivePoint methodsFor: 'accessing' stamp: 'len 2/9/2017 10:41:07'!
tangentCone
	"Answer the projective tangent cone at this point."
	^ self dehomogenized tangentCone projectiveClosure "this projective closure uses the embedding corresponding to the same affine patch index that was used for dehomogenization"! !

!ProjectivePoint methodsFor: 'comparing' stamp: 'len 5/8/2023 23:28:33'!
= anObject
	self class = anObject class ifFalse: [^ super = anObject].
	coordinates size = anObject coordinates size ifFalse: [^ false].
	^ coordinates ~ anObject coordinates! !

!ProjectivePoint methodsFor: 'comparing' stamp: 'len 5/3/2018 04:28:40'!
hash
	self scalars isField ifTrue: [^ self hashField].
	self scalars isIntegralDomain ifTrue: [^ self hashIntegralDomain].
	^ self scalars hash "hashMultiply + self coordinates lastNonZeroDivisor"! !

!ProjectivePoint methodsFor: 'comparing' stamp: 'len 4/26/2022 06:03:39'!
hashField
	| hash x |
	hash _ 0.
	x _ coordinates at: coordinates lastNonzeroIndex.
	1 to: coordinates size do: [:i | hash _ (hash + ((coordinates at: i) / x) hash) hashMultiply].
	^hash! !

!ProjectivePoint methodsFor: 'comparing' stamp: 'len 4/26/2022 06:03:44'!
hashIntegralDomain
	| Q hash x |
	Q _ self scalars fractions.
	hash _ 0.
	x _ Q embed: (coordinates at: coordinates lastNonzeroIndex).
	1 to: coordinates size do: [:i | hash _ (hash + ((Q embed: (coordinates at: i)) / x) hash) hashMultiply].
	^ hash! !

!ProjectivePoint methodsFor: 'converting' stamp: 'len 8/14/2022 09:54:14'!
asIdeal
	"Answer the prime ideal defining the receiver."
	| R m am xm ai generators |
	self codomain scalars = self scalars ifFalse: [^ self notYetImplemented].
	R _ self codomain coordinateRing.
	generators _ OrderedCollection new: coordinates size.
	m _ coordinates lastNonzeroIndex.
	am _ coordinates at: m.
	xm _ R x: m.
	1 to: m do: [:i|
		ai _ coordinates at: i.
		ai isZero ifTrue: [generators add: (R x: i)] ifFalse: [generators add: (R x: i) * am - (xm*ai)]].
	m+1 to: coordinates size do: [:i|
		generators add: (R x: i)].
	^ R * generators! !

!ProjectivePoint methodsFor: 'converting' stamp: 'len 5/8/2023 23:01:07'!
asTuple
	^ coordinates! !

!ProjectivePoint methodsFor: 'converting' stamp: 'len 5/8/2023 23:28:41'!
dehomogenized
	"Answer the dehomogenization of the receiver."
	^ self dehomogenizedIn: coordinates lastNonzeroIndex! !

!ProjectivePoint methodsFor: 'converting' stamp: 'len 11/23/2022 21:30:29'!
dehomogenizedIn: anInteger
	"Answer the dehomogenization of the receiver with respect to the anInteger-th coordinate."
	| scalar |
	scalar _ coordinates at: anInteger.
	^ (self codomain patch: anInteger) pointAt:
		(self scalars^(coordinates size - 1)
			fill: [:i| (i < anInteger ifTrue: [coordinates at: i] ifFalse: [coordinates at: i + 1]) / scalar])! !

!ProjectivePoint methodsFor: 'printing' stamp: 'len 6/14/2023 17:09:27'!
printInsidesOn: aStream
	| separator |
	separator := (coordinates anySatisfy: [:any| any printString isAlphaNumeric not]) ifTrue: [' : '] ifFalse: [':'].
	coordinates asArray do: [:each| aStream print: each] separatedBy: [aStream nextPutAll: separator].
! !

!ProjectivePoint methodsFor: 'printing' stamp: 'len 2/10/2017 09:55:27'!
printOn: aStream
	aStream nextPut: $[.
	self printInsidesOn: aStream.
	aStream nextPut: $]! !

!ProjectivePoint methodsFor: 'testing' stamp: 'len 5/8/2023 23:01:44'!
isSingular
	^ self isSmooth not! !

!ProjectivePoint methodsFor: 'testing' stamp: 'len 5/8/2023 23:28:53'!
isSmooth
	^ (self codomain singular satisfies: coordinates) not
	
"OR:
	^ self dehomogenized isSmooth
but dehomogenizing requires it be be over a field"
! !

!ProjectivePoint methodsFor: 'private' stamp: 'len 5/8/2023 23:02:41'!
codomain: aProjectiveVariety
	codomain _ aProjectiveVariety! !

!ProjectivePoint methodsFor: 'private' stamp: 'len 5/8/2023 23:02:46'!
coordinates: aTuple
	coordinates _ aTuple! !

!ProjectivePoint methodsFor: 'private' stamp: 'len 6/21/2023 16:09:23'!
validate
	super validate.
	self assert: (codomain satisfies: coordinates)! !

!ProjectivePoint class methodsFor: 'instance creation' stamp: 'len 2/13/2017 21:15:36'!
on: aProjectiveVariety coordinates: aTuple
	^ self new codomain: aProjectiveVariety; coordinates: aTuple! !

!ProjectiveLinePoint methodsFor: 'accessing' stamp: 'len 7/30/2019 05:43:44'!
denominator
	self isInfinity ifTrue: [^ self scalars zero].
	^ self value denominator! !

!ProjectiveLinePoint methodsFor: 'accessing' stamp: 'len 11/23/2022 17:12:25'!
infinity
	^ self shallowCopy coordinates: self scalars !!!! {self scalars one. self scalars zero}! !

!ProjectiveLinePoint methodsFor: 'accessing' stamp: 'len 12/5/2016 10:33:53'!
numerator
	self isInfinity ifTrue: [^ Infinity projective].
	^ self value numerator! !

!ProjectiveLinePoint methodsFor: 'accessing' stamp: 'len 11/23/2022 17:12:51'!
one
	^ self shallowCopy coordinates: self scalars !!!! {self scalars one. self scalars one}! !

!ProjectiveLinePoint methodsFor: 'accessing' stamp: 'len 6/27/2023 15:29:39'!
value
	^ (coordinates at: 1) / (coordinates at: 2)! !

!ProjectiveLinePoint methodsFor: 'accessing' stamp: 'len 11/23/2022 17:13:01'!
zero
	^ self shallowCopy coordinates: self scalars !!!! {self scalars zero. self scalars one}! !

!ProjectiveLinePoint methodsFor: 'arithmetic' stamp: 'len 4/5/2024 19:01:37'!
* aCusp
	self isInfinity ifTrue: [aCusp isZero ifTrue: [self error: 'undefined'] ifFalse: [^ self]].
	aCusp isInfinity ifTrue: [self isZero ifTrue: [self error: 'undefined'] ifFalse: [^ aCusp]].
	^ self shallowCopy coordinates: self scalars !!!! {self value * aCusp value. self scalars one}! !

!ProjectiveLinePoint methodsFor: 'arithmetic' stamp: 'len 11/23/2022 17:12:15'!
+ aCusp
	self isInfinity ifTrue: [^ self].
	aCusp isInfinity ifTrue: [^ aCusp].
	^ self shallowCopy coordinates: self scalars !!!! {self value + aCusp value. self scalars one}! !

!ProjectiveLinePoint methodsFor: 'arithmetic' stamp: 'len 12/4/2016 22:17:46'!
- aCusp
	^ self + aCusp negated! !

!ProjectiveLinePoint methodsFor: 'arithmetic' stamp: 'len 5/3/2020 10:09:56'!
/ aCusp
	^ self * aCusp inverse! !

!ProjectiveLinePoint methodsFor: 'arithmetic' stamp: 'len 6/2/2024 10:59:45'!
^ anInteger
	"Answer the receiver raised to the power anInteger."
	anInteger isInteger ifFalse: [^ super ^ anInteger].
	anInteger = 1 ifTrue: [^ self].
	anInteger = 0 ifTrue: [^ self one].
	anInteger < 0 ifTrue: [^ self inverse ^ anInteger negated].
	^ anInteger even ifTrue: [self squared ^ (anInteger // 2)] ifFalse: [self squared ^ (anInteger // 2) * self]! !

!ProjectiveLinePoint methodsFor: 'arithmetic' stamp: 'len 11/23/2022 17:12:34'!
inverse
	self isInfinity ifTrue: [^ self zero].
	self isZero ifTrue: [^ self infinity].
	^ self shallowCopy coordinates: self scalars !!!! {self value inverse. self scalars one}! !

!ProjectiveLinePoint methodsFor: 'arithmetic' stamp: 'len 11/23/2022 17:12:43'!
negated
	self isInfinity ifTrue: [^ self].
	^ self shallowCopy coordinates: self scalars !!!! {self value negated. self scalars one}! !

!ProjectiveLinePoint methodsFor: 'printing' stamp: 'len 5/23/2020 07:40:50'!
printOn: aStream
	self isInfinity
		ifTrue: [aStream nextPut: $∞]
		ifFalse: [self scalars isField ifTrue: [aStream print: self value] ifFalse: [super printOn: aStream]]! !

!ProjectiveLinePoint methodsFor: 'testing' stamp: 'len 5/8/2023 23:29:19'!
isInfinity
	^ (coordinates at: 2) isZero! !

!ProjectiveLinePoint methodsFor: 'testing' stamp: 'len 12/4/2016 22:13:31'!
isZero
	^ self isInfinity not and: [self value isZero]! !

!ProjectiveLinePoint methodsFor: 'testing' stamp: 'len 5/8/2023 23:29:42'!
∥ aPoint
	"Answer true if the receiver is parallel with aPoint.
	Two points [a:b] and [c:d] of a projective line over a ring R are called 'neighbours' or 'parallel' if the matrix:
		[a b]
		[c d]
	is not in GL(2,R), i.e. its determinant ad - cb is not a unit of R.
	Points that are not neighbours are called 'distant'."

	^ (coordinates x * aPoint coordinates y - (aPoint coordinates x * coordinates y)) isUnit not! !

!RationalMap methodsFor: 'accessing' stamp: 'len 12/28/2016 21:54:27'!
at: anInteger
	"Answer the anInteger-th component of the receiver (a rational function, an element of the function field of the domain)."
	^ self representatives at: anInteger! !

!RationalMap methodsFor: 'accessing' stamp: 'len 6/27/2023 22:13:40'!
base
	"Answer the 'base locus' or 'indeterminacy locus' of the receiver, i.e. the subscheme of the domain where the receiver is indetermined."
	| ρ |
	self flag: #fixme. "this looks incorrect, it comes from M2 baseLocusOfMap"
	ρ := (self representatives numerator asMatrix over: self domain coordinateRing) image relationsMatrix  transpose kernel.
	^ self domain sub: (ρ generators sum: [:each| self domain coordinateRing * each asArray])

"this is wrong:
	^ self domain sub: (self representatives collect: [:each| each denominator])"! !

!RationalMap methodsFor: 'accessing' stamp: 'len 7/11/2022 12:32:00'!
partialDomain
	^ self propertyAt: #partialDomain ifAbsent: [self domain]! !

!RationalMap methodsFor: 'accessing' stamp: 'len 6/27/2023 15:18:24'!
representatives
	"Answer the array of representatives of the components of the receiver, i.e. polynomials or formal fractions of polynomials."
	^ self propertyAt: #representatives! !

!RationalMap methodsFor: 'accessing' stamp: 'len 1/5/2017 09:27:06'!
size
	"Answer the number of components of the receiver."
	^ self codomain ambient rank! !

!RationalMap methodsFor: 'comparing' stamp: 'len 7/9/2022 14:16:50'!
= anObject
	| I |
	(anObject isKindOf: RationalMap) ifFalse: [^ super = anObject].
	(self domain = anObject domain and: [self codomain = anObject codomain]) ifFalse: [^ false].
	I _ self domain asIdeal.
	1 to: self size do: [:i| | f g |
		f _ self at: i.
		g _ anObject at: i.
		(I includes: f numerator * g denominator - (f denominator * g numerator)) ifFalse: [^ false]].
	^ true! !

!RationalMap methodsFor: 'converting' stamp: 'len 6/27/2023 16:38:07'!
asFunctionFieldMap
	"If the receiver is dominant, answer the induced (pullback) homomorphism between the function fields."
	^ self notYetImplemented! !

!RationalMap methodsFor: 'converting' stamp: 'len 4/5/2024 19:00:21'!
asRingMap
	"If the receiver is regular, answer the induced (pullback) ring homomorphism between the coordinate rings.
	This is the adjoint of the Spec functor."
	self isPolynomial ifFalse: [self error: 'not a polynomial map'].
	^ self codomain coordinateRing to: self domain coordinateRing images: (self representatives asArray collect: [:each| each numerator])! !

!RationalMap methodsFor: 'operations' stamp: 'len 1/20/2018 22:05:44'!
* anObject
	^ self species from: self domain to: self codomain representatives: self representatives * anObject! !

!RationalMap methodsFor: 'operations' stamp: 'len 4/5/2024 19:00:53'!
+ aRationalMap
	aRationalMap isTuple
		ifTrue: [^ self species from: self domain to: self codomain representatives: self representatives + aRationalMap].
	(self domain = aRationalMap domain and: [self codomain = aRationalMap codomain])
		ifFalse: [^ Error signal].
	^ self species from: self domain to: self codomain representatives: self representatives + aRationalMap representatives! !

!RationalMap methodsFor: 'operations' stamp: 'len 5/15/2018 16:58:45'!
graph
	^ self domain × self image! !

!RationalMap methodsFor: 'operations' stamp: 'len 10/23/2023 09:07:13'!
image
	"Answer (the Zeriski closure of) the image of the receiver. This is a subscheme of the codomain.
	Performs ideal elimination (a Groebner basis computation with the lexicographical order).
	See AlgebraMap>>kernel."
	| A B m n P t ι generators g I |
	self propertyAt: #image ifPresent: [:aScheme| ^ aScheme].
	A := self domain ambient coordinateRing.
	B := self codomain ambient coordinateRing.
	m := A rank.
	n := B rank.
	P := self domain scalars polynomialsIn: n + m + 1.
	"The embedding maps the i-th indeterminate to the (i+n)-th indeterminate in the bigger ring:"
	ι := A to: P images: ((1 to: A rank) collect: [:i| P x: i+n]).
	t := P x: P rank.
	generators := OrderedCollection new.
	g := P one.
	1 to: n do: [:i| | numerator denominator |
		numerator := ι value: (self representatives at: i) numerator.
		denominator := ι value: (self representatives at: i) denominator.
		generators add: denominator * (P x: i) - numerator.
		g := g * denominator].
	self domain asIdeal generators do: [:each| generators add: (ι value: each)].
	generators add: P one - (g * t).
	I := P * generators eliminateAll: (n+1 to: P rank).
	^ self propertyAt: #image put: (self codomain sub: (I generators collect: [:f| B !! f]))! !

!RationalMap methodsFor: 'operations' stamp: 'len 10/12/2023 08:24:27'!
implicitization
	"Magma uses the algorithm in p. 97 of [CLO97]."
	self notYetImplemented! !

!RationalMap methodsFor: 'operations' stamp: 'len 7/12/2023 17:39:06'!
jacobian
	"Answer the Jacobian matrix of the receiver."
	^ self domain ambient coordinateRing fractions
		matrix: self codomain ambient rank @ self domain ambient rank
		fill: [:i :j| (self representatives at: i) derivativeIn: j]! !

!RationalMap methodsFor: 'operations' stamp: 'len 1/20/2018 22:05:58'!
negated
	^ self species from: self domain to: self codomain representatives: self representatives negated! !

!RationalMap methodsFor: 'operations' stamp: 'len 6/26/2023 14:43:02'!
preimage: aSubscheme
	"Answer the preimage of aSubscheme. The argument is a subscheme of the codomain, and the answer is a subscheme of the domain."
	^ self domain sub: (aSubscheme asIdeal apply: self asRingMap)! !

!RationalMap methodsFor: 'operations' stamp: 'len 1/15/2017 17:24:31'!
projectiveClosure
	^ self class
		from: self domain projectiveClosure
		to: self codomain projectiveClosure
		representatives: (self representatives collect: [:each| each homogenized])! !

!RationalMap methodsFor: 'operations' stamp: 'len 7/12/2023 14:36:24'!
restriction
	"If the receiver is a rational map between affine varieties defined over an algebraic field extension L/k, answer the Weil restriction."
	| R L K d n S p α v representatives |
	(self domain isAffine and: [self codomain isAffine]) ifFalse: [^ self notYetImplemented].
	self isPolynomial ifFalse: [^ self notYetImplemented].
	self domain scalars degree = 1 ifTrue: [^ self].
	self propertyAt: #restriction ifPresent: [:aRationalMap| ^ aRationalMap].
	R := self domain ambient coordinateRing.
	L := R scalars.
	(d := L degree) = 1 ifTrue: [^ self].
	K := L scalars.
	n := R rank.
	S := K polynomialsIn: n*d + 1.
	α := S generators last.
	p := R scalars modulus value: α.
	v := (1 to: n) collect: [:i| (0 to: d-1) sum: [:j| α^j * (S x: d*(i-1) + j + 1)]].
	representatives := OrderedCollection new.
	self representatives do: [:g| | f |
		f := ((g numerator associations sum: [:each| (each key value: v) * (each value representative value: α)]) \\ p) asUnivariate.
		0 to: d-1 do: [:i| representatives add: (f at: i)]].
	^ self propertyAt: #restriction put: (self class from: self domain restriction to: self codomain restriction representatives: representatives)! !

!RationalMap methodsFor: 'operations' stamp: 'len 5/8/2023 23:03:33'!
value: aPoint
	| x value |
	(aPoint isKindOf: Ideal) ifTrue: [^ self asRingMap preimage: aPoint]. 
	x _ aPoint asTuple.
	value _ aPoint scalars !!!! (self representatives asArray collect: [:each| each value: x]).
	((aPoint isKindOf: AffinePoint) or: [aPoint isKindOf: ProjectivePoint]) ifTrue: [^ self codomain pointAt: value].
	^ value! !

!RationalMap methodsFor: 'operations' stamp: 'len 7/21/2024 09:34:45'!
∘ aRationalMap
	self species = aRationalMap species ifFalse: [^ super ∘ aRationalMap].
	self domain ⊇ aRationalMap codomain ifFalse: [self error: 'incompatible composition'].
	^ self species from: aRationalMap domain to: self codomain representatives: (self representatives asArray collect: [:each| each value: aRationalMap representatives])! !

!RationalMap methodsFor: 'printing' stamp: 'len 6/27/2023 15:46:58'!
printOn: aStream 
	self codomain isProjective
		ifTrue:
			[| separator |
			separator := (self representatives anySatisfy: [:any| any printString isAlphaNumeric not]) ifTrue: [' : '] ifFalse: [':'].
			aStream nextPut: $[.
			self representatives asArray do: [:each| aStream print: each] separatedBy: [aStream nextPutAll: separator].
			aStream nextPut: $]]
		ifFalse:
			[aStream nextPut: $(.
			self representatives asArray do: [:each| aStream print: each] separatedBy: [aStream nextPutAll: ', '].
			aStream nextPut: $)]! !

!RationalMap methodsFor: 'testing' stamp: 'len 1/15/2017 17:18:42'!
isAffineLinear
	"Answer true if the receiver is an affine linear map (defined by polynomials of degree 1)."
	^ self representatives allSatisfy: [:each| each isAffineLinear]! !

!RationalMap methodsFor: 'testing' stamp: 'len 12/28/2016 21:55:19'!
isConstant
	^ self representatives allSatisfy: [:each| each isConstant]! !

!RationalMap methodsFor: 'testing' stamp: 'len 10/17/2016 16:21'!
isDominant
	"Answer true if the closure of the image of the receiver is the whole codomain."
	^ self image = self codomain! !

!RationalMap methodsFor: 'testing' stamp: 'len 1/15/2017 17:17:24'!
isLinear
	"Answer true if the receiver is a homogeneous linear map (defined by homogeneous linear polynomials, with independent coefficient zero)."
	^ self representatives allSatisfy: [:each| each isLinear]! !

!RationalMap methodsFor: 'testing' stamp: 'len 6/7/2020 06:20:30'!
isPolynomial
	"Answer true if the receiver is a polynomial map."
	^ self representatives allSatisfy: [:each| each isIntegral]! !

!RationalMap methodsFor: 'testing' stamp: 'len 4/5/2024 19:00:06'!
isRegular
	"Answer true if the receiver is defined at all points of its partial domain."
	self partialDomain isAffine ifTrue: [^ self isPolynomial].
	self partialDomain isProjective ifTrue: [^ self base isEmpty].
	^ Error signal! !

!RationalMap methodsFor: 'testing' stamp: 'len 7/12/2023 17:03:37'!
isSurjective
	^ self codomain = self image! !

!RationalMap methodsFor: 'private' stamp: 'len 7/11/2022 12:31:16'!
partialDomain: aScheme
	self propertyAt: #partialDomain put: aScheme! !

!RationalMap methodsFor: 'private' stamp: 'len 9/18/2022 07:08:27'!
representatives: anArray
	self propertyAt: #representatives put: anArray! !

!RationalMap methodsFor: 'private' stamp: 'len 1/10/2017 18:47:11'!
species
	^ RationalMap! !

!RationalMap class methodsFor: 'examples' stamp: 'len 9/16/2022 08:12:38'!
example1TwistedCubicTangentParametrization
	"Example from Cox's 'Ideals, Varieties and Algorithms' pag. 234.
	Parametrization of the tangent surface of the twisted cubic."
	| A2 A3 |
	A2 _ AffineSpace new: #(t u) over: ℚ.
	A3 _ AffineSpace new: 3 over: ℚ.
	^ A2 to: A3 mapWithArguments: [:t :u| {t + u. t^2 + (t*u*2). t^3 + (t^2*u*3)}]! !

!RationalMap class methodsFor: 'examples' stamp: 'len 11/1/2016 16:51'!
example2TwistedCubicTangent
	"The tangent surface of the twisted cubic."
	^ self example1TwistedCubicTangentParametrization image! !

!RationalMap class methodsFor: 'instance creation' stamp: 'len 9/16/2022 08:21:46'!
from: aDomain to: aCodomain map: aBlock
	^ (self partiallyFrom: aDomain to: aCodomain map: aBlock) domain: aDomain! !

!RationalMap class methodsFor: 'instance creation' stamp: 'len 7/11/2022 12:35:24'!
from: aDomain to: aCodomain representatives: anArrayOfRationalFunctions
	^ (self partiallyFrom: aDomain to: aCodomain representatives: anArrayOfRationalFunctions) domain: aDomain! !

!RationalMap class methodsFor: 'instance creation' stamp: 'len 6/27/2023 15:43:37'!
partiallyFrom: aDomain to: aCodomain map: aBlock
	| K |
	K := aDomain ambient coordinateRing fractions.
	^ self partiallyFrom: aDomain to: aCodomain representatives: (aBlock value: (K^aDomain ambient rank fill: [:i| K x: i]))! !

!RationalMap class methodsFor: 'instance creation' stamp: 'len 6/27/2023 16:54:18'!
partiallyFrom: aDomain to: aCodomain representatives: anArray
	| representatives |
	representatives := aDomain ambient coordinateRing fractions !!!! anArray.
	aCodomain isProjective
		ifTrue: [representatives := representatives * (representatives asArray inject: aDomain ambient coordinateRing one into: [:lcm :each| lcm lcm: each denominator]).
			self assert: (representatives allSatisfy: [:each| each numerator isHomogeneous]).
			aDomain isProjective ifTrue: [self assert: (representatives allSatisfy: [:each| each degree = representatives first degree])]].
	^ self new partialDomain: aDomain; codomain: aCodomain; representatives: representatives! !

!SimplicialMap methodsFor: 'accessing' stamp: 'len 4/12/2024 04:53:26'!
category
	^ SCpx! !

!SimplicialMap methodsFor: 'comparing' stamp: 'len 9/16/2022 09:20:08'!
= aSimplicialMap
	self == aSimplicialMap ifTrue: [^ true].
	(aSimplicialMap isKindOf: SimplicialMap) ifFalse: [^ false].
	(self domain = aSimplicialMap domain and: [self codomain = aSimplicialMap codomain]) ifFalse: [^ false].
	^ vertexMap = aSimplicialMap vertexMap! !

!SimplicialMap methodsFor: 'operations' stamp: 'len 9/16/2022 09:23:16'!
× aSimplicialMap
	"Answer the fibered product of the receiver and the argument."
	self checkCodomainsMatch: aSimplicialMap.
	^ self domain × aSimplicialMap domain to: self codomain map: [:each| Simplex vertices: (each vertices collect: [:v| {vertexMap value: (v at: 1). aSimplicialMap vertexMap at: (v at: 2)}]) asSet]! !

!SimplicialMap methodsFor: 'operations' stamp: 'len 9/16/2022 09:20:38'!
value: aSimplex
	^ Simplex vertices: (aSimplex vertices collect: [:each| vertexMap at: each]) asSet! !

!SimplicialMap methodsFor: 'printing' stamp: 'len 9/16/2022 09:20:31'!
printOn: aStream
	self domain vertices do: [:each| aStream print: each -> (vertexMap at: each)] separatedBy: [aStream nextPutAll: ', ']! !

!SimplicialMap methodsFor: 'testing' stamp: 'len 9/16/2022 09:20:23'!
isInjective
	^ vertexMap asSet size = vertexMap size! !

!SimplicialMap methodsFor: 'testing' stamp: 'len 2/20/2017 15:28:04'!
isSurjective
	^ self codomain = self image! !

!SimplicialMap methodsFor: 'private' stamp: 'len 9/16/2022 09:23:23'!
vertexMap
	^ vertexMap! !

!SimplicialMap methodsFor: 'private' stamp: 'len 9/16/2022 09:20:52'!
vertexMap: aDictionary
	vertexMap _ aDictionary! !

!SimplicialMap class methodsFor: 'class initialization' stamp: 'len 4/12/2024 05:34:36'!
initialize
	super initialize.
	SCpx := Category new! !

!SimplicialMap class methodsFor: 'instance creation' stamp: 'len 5/1/2024 12:27:41'!
from: aSimplicialComplex to: anotherSimplicialComplex map: aBlock
	| vertexMap |
	vertexMap := Dictionary new.
	aSimplicialComplex support do: [:v| vertexMap at: v put: (aBlock value: (Simplex vertices: {v})) vertices any].
	^ self from: aSimplicialComplex to: anotherSimplicialComplex vertexMap: vertexMap! !

!SimplicialMap class methodsFor: 'instance creation' stamp: 'len 9/16/2022 13:03:09'!
from: aSimplicialComplex to: anotherSimplicialComplex vertexMap: aDictionary
	^ self new domain: aSimplicialComplex; codomain: anotherSimplicialComplex; vertexMap: aDictionary! !

!OppositeMorphism methodsFor: 'accessing' stamp: 'len 4/14/2024 14:44:51'!
category
	^ reverse category opposite! !

!OppositeMorphism methodsFor: 'accessing' stamp: 'len 4/24/2024 04:13:50'!
codomain
	^ reverse domain reverse! !

!OppositeMorphism methodsFor: 'accessing' stamp: 'len 4/24/2024 04:13:54'!
domain
	^ reverse codomain reverse! !

!OppositeMorphism methodsFor: 'comparing' stamp: 'len 4/4/2024 12:30:00'!
= anObject
	^ anObject = reverse! !

!OppositeMorphism methodsFor: 'comparing' stamp: 'len 4/4/2024 12:30:09'!
hash
	^ reverse hash! !

!OppositeMorphism methodsFor: 'internalization' stamp: 'len 6/9/2024 09:19:31'!
carrier
	^ reverse carrier reverse! !

!OppositeMorphism methodsFor: 'operations' stamp: 'len 5/8/2024 09:13:14'!
coequalizer: aMorphism
	^ (reverse equalizer: aMorphism reverse) reverse! !

!OppositeMorphism methodsFor: 'operations' stamp: 'len 4/15/2024 09:46:25'!
colift: aMorphism
	^ ((reverse lift: aMorphism reverse) ifNil: [^ nil]) reverse! !

!OppositeMorphism methodsFor: 'operations' stamp: 'len 5/8/2024 09:13:08'!
equalizer: aMorphism
	^ (reverse coequalizer: aMorphism reverse) reverse! !

!OppositeMorphism methodsFor: 'operations' stamp: 'len 4/5/2024 09:51:34'!
inverse
	^ reverse inverse reverse! !

!OppositeMorphism methodsFor: 'operations' stamp: 'len 4/15/2024 09:45:39'!
lift: aMorphism
	^ ((aMorphism reverse colift: reverse) ifNil: [^ nil]) reverse! !

!OppositeMorphism methodsFor: 'operations' stamp: 'len 4/4/2024 12:30:31'!
reverse
	^ reverse! !

!OppositeMorphism methodsFor: 'operations' stamp: 'len 7/21/2024 09:34:59'!
∘ aMorphism
	^ (aMorphism reverse ∘ reverse) reverse! !

!OppositeMorphism methodsFor: 'operations' stamp: 'len 5/8/2024 09:11:16'!
∧ aMorphism
	^ (reverse ∨ aMorphism reverse) reverse! !

!OppositeMorphism methodsFor: 'operations' stamp: 'len 5/8/2024 09:11:32'!
∨ aMorphism
	^ (reverse ∧ aMorphism reverse) reverse! !

!OppositeMorphism methodsFor: 'operations' stamp: 'len 5/8/2024 09:12:03'!
⊓ aMorphism
	^ (reverse ⊔ aMorphism reverse) reverse! !

!OppositeMorphism methodsFor: 'operations' stamp: 'len 5/8/2024 09:12:22'!
⊔ aMorphism
	^ (reverse ⊓ aMorphism reverse) reverse! !

!OppositeMorphism methodsFor: 'operations' stamp: 'len 6/5/2024 06:20:24'!
⊗ aMorphism
	^ (reverse ⊗ aMorphism reverse) reverse! !

!OppositeMorphism methodsFor: 'operations-preabelian' stamp: 'len 4/23/2024 08:33:51'!
cokernel
	^ reverse kernel reverse! !

!OppositeMorphism methodsFor: 'operations-preabelian' stamp: 'len 8/14/2024 11:23:47'!
cokernelMorphism
	^ reverse kernelMorphism reverse! !

!OppositeMorphism methodsFor: 'operations-preabelian' stamp: 'len 4/5/2024 09:50:21'!
kernel
	^ reverse cokernel reverse! !

!OppositeMorphism methodsFor: 'operations-preabelian' stamp: 'len 8/14/2024 11:23:46'!
kernelMorphism
	^ reverse cokernelMorphism reverse! !

!OppositeMorphism methodsFor: 'operations-preadditive' stamp: 'len 4/5/2024 09:51:53'!
+ aMorphism
	^ (reverse + aMorphism reverse) reverse! !

!OppositeMorphism methodsFor: 'operations-preadditive' stamp: 'len 4/5/2024 09:52:37'!
negated
	^ reverse negated reverse! !

!OppositeMorphism methodsFor: 'operations-preadditive' stamp: 'len 4/5/2024 09:52:45'!
zero
	^ reverse zero reverse! !

!OppositeMorphism methodsFor: 'printing' stamp: 'len 4/5/2024 17:48:28'!
arrowCharacter
	| c |
	c := reverse arrowCharacter.
	c = $↔ ifTrue: [^ c].
	c = $↪ ifTrue: [^ $↞].
	c = $↠ ifTrue: [^ $↩].
	^ $←! !

!OppositeMorphism methodsFor: 'printing' stamp: 'len 4/25/2024 08:18:30'!
printOn: aStream
	"See Morphism>>#printOn."
	reverse isIdentity ifTrue: [aStream nextPutAll: 'id'. ^ self].
	(reverse category isPreadditive and: [reverse isZero]) ifTrue: [aStream print: 0. ^ self].
	aStream nextPutAll: self name; nextPutAll: ' : '.
	aStream print: self codomain; space; nextPut: self arrowCharacter; space; print: self domain! !

!OppositeMorphism methodsFor: 'testing' stamp: 'len 4/5/2024 09:53:24'!
isEpimorphism
	^ reverse isMonomorphism! !

!OppositeMorphism methodsFor: 'testing' stamp: 'len 4/5/2024 09:54:10'!
isIsomorphism
	^ reverse isIsomorphism! !

!OppositeMorphism methodsFor: 'testing' stamp: 'len 4/5/2024 09:53:52'!
isMonomorphism
	^ reverse isEpimorphism! !

!OppositeMorphism methodsFor: 'testing' stamp: 'len 5/8/2024 09:13:52'!
isZero
	^ reverse isZero! !

!OppositeMorphism methodsFor: 'private' stamp: 'len 4/4/2024 12:30:47'!
reverse: aMorphism
	reverse := aMorphism! !

!OppositeMorphism class methodsFor: 'instance creation' stamp: 'len 4/4/2024 12:29:27'!
reverse: aMorphism
	^ self new reverse: aMorphism! !

!Path methodsFor: 'accessing' stamp: 'len 6/14/2024 15:07:36'!
category
	^ domain category! !

!Path methodsFor: 'accessing' stamp: 'len 4/14/2024 07:35:22'!
codomain
	^ codomain! !

!Path methodsFor: 'accessing' stamp: 'len 4/14/2024 07:35:27'!
domain
	^ domain! !

!Path methodsFor: 'comparing' stamp: 'len 5/24/2024 08:35:44'!
= anObject
	^ self class = anObject class and: [domain = anObject domain and: [steps = anObject steps]]! !

!Path methodsFor: 'comparing' stamp: 'len 5/24/2024 08:35:09'!
hash
	^ domain hash hashMultiply + steps hash! !

!Path methodsFor: 'operations' stamp: 'len 7/21/2024 09:35:13'!
∘ aMorphism
	self checkCompatibleComposition: aMorphism.
	^ self from: aMorphism domain to: codomain steps: aMorphism steps, steps! !

!Path methodsFor: 'printing' stamp: 'len 5/27/2024 07:09:14'!
printOn: aStream
	| vertex |
	self isIdentity ifTrue: [aStream print: self domain. ^ self].
	vertex := domain.
	aStream print: vertex.
	steps do: [:each| vertex := self category objectAt: (vertex neighbors at: each). aStream nextPutAll: ' → '; print: vertex]

"	self category generatingGraph isLabeled ifTrue:
		[node := domain node.
		steps do: [:each|
			aStream print: (node labelAt: each).
			node := node neighborAt: each].
		^ self].
	node := domain node.
	aStream print: node value.
	steps do: [:each| node := node neighbors at: each. aStream nextPutAll: ' → '; print: node value]"! !

!Path methodsFor: 'testing' stamp: 'len 4/15/2024 09:16:58'!
isEpimorphism
	"In a free category, all morphisms are epimorphisms."
	^ true! !

!Path methodsFor: 'testing' stamp: 'len 5/24/2024 08:35:09'!
isIdentity
	^ steps isEmpty! !

!Path methodsFor: 'testing' stamp: 'len 4/15/2024 09:17:04'!
isMonomorphism
	"In a free category, all morphisms are monomorphisms."
	^ true! !

!Path methodsFor: 'private' stamp: 'len 5/24/2024 08:36:05'!
domain: aDomain codomain: aCodomain steps: anArray
	anArray isEmpty ifTrue: [self assert: aDomain = aCodomain]. "empty path must be the identity"
	domain := aDomain.
	codomain := aCodomain.
	steps := anArray! !

!Path methodsFor: 'private' stamp: 'len 5/24/2024 08:35:54'!
steps
	^ steps! !

!Path class methodsFor: 'instance creation' stamp: 'len 5/24/2024 08:36:24'!
from: aDomain to: aCodomain steps: anArray
	^ self new domain: aDomain codomain: aCodomain steps: anArray! !

!ProductMorphism methodsFor: 'accessing' stamp: 'len 4/24/2024 09:16:30'!
at: anInteger
	^ components at: anInteger! !

!ProductMorphism methodsFor: 'accessing' stamp: 'len 8/15/2024 21:27:43'!
category
	^ ProductCategory components: (components collect: [:each| each category])! !

!ProductMorphism methodsFor: 'accessing' stamp: 'len 8/15/2024 21:27:59'!
codomain
	^ ProductObject components: (components collect: [:each| each codomain])! !

!ProductMorphism methodsFor: 'accessing' stamp: 'len 8/15/2024 21:28:11'!
domain
	^ ProductObject components: (components collect: [:each| each domain])! !

!ProductMorphism methodsFor: 'comparing' stamp: 'len 4/4/2024 08:22:02'!
= anObject
	^ self class = anObject class and: [components = anObject components]! !

!ProductMorphism methodsFor: 'comparing' stamp: 'len 4/4/2024 08:21:44'!
hash
	^ components hash! !

!ProductMorphism methodsFor: 'operations' stamp: 'len 8/15/2024 21:34:18'!
× aMorphism
	^ self class components: (components with: aMorphism components collect: [:f :g| f × g])! !

!ProductMorphism methodsFor: 'operations' stamp: 'len 8/15/2024 21:34:30'!
coequalizer: aMorphism
	^ self class components: (components with: aMorphism components collect: [:f :g| f coequalizer: g])! !

!ProductMorphism methodsFor: 'operations' stamp: 'len 8/15/2024 21:37:45'!
colift: aMorphism
	^ self class components: (components with: aMorphism components collect: [:f :g| (f colift: g) ifNil: [^ nil]])! !

!ProductMorphism methodsFor: 'operations' stamp: 'len 8/15/2024 21:34:49'!
dual
	^ self class components: (components collect: [:each| each dual])! !

!ProductMorphism methodsFor: 'operations' stamp: 'len 8/15/2024 21:34:57'!
equalizer: aMorphism
	^ self class components: (components with: aMorphism components collect: [:f :g| f equalizer: g])! !

!ProductMorphism methodsFor: 'operations' stamp: 'len 8/15/2024 21:35:06'!
inverse
	^ self class components: (components collect: [:each| each inverse])! !

!ProductMorphism methodsFor: 'operations' stamp: 'len 8/15/2024 21:37:58'!
lift: aMorphism
	^ self class components: (components with: aMorphism components collect: [:f :g| (f lift: g) ifNil: [^ nil]])! !

!ProductMorphism methodsFor: 'operations' stamp: 'len 8/15/2024 13:04:45'!
reverse
	^ self category opposite compose: (components collect: [:each| each reverse])! !

!ProductMorphism methodsFor: 'operations' stamp: 'len 8/15/2024 21:42:10'!
∘ aMorphism
	^ self class components: (components with: aMorphism components collect: [:f :g| f ∘ g])! !

!ProductMorphism methodsFor: 'operations' stamp: 'len 8/15/2024 21:13:09'!
∧ aMorphism
	^ ProductObject components: (components with: aMorphism components collect: [:f :g| f ∧ g])! !

!ProductMorphism methodsFor: 'operations' stamp: 'len 8/15/2024 21:13:23'!
∨ aMorphism
	^ ProductObject components: (components with: aMorphism components collect: [:f :g| f ∨ g])! !

!ProductMorphism methodsFor: 'operations' stamp: 'len 8/15/2024 21:35:24'!
⊓ aMorphism
	^ self class components: (components with: aMorphism components collect: [:f :g| f ⊓ g])! !

!ProductMorphism methodsFor: 'operations' stamp: 'len 8/15/2024 21:35:34'!
⊔ aMorphism
	^ self class components: (components with: aMorphism components collect: [:f :g| f ⊔ g])! !

!ProductMorphism methodsFor: 'operations' stamp: 'len 8/15/2024 21:35:52'!
⊗ aMorphism
	^ self class components: (components with: aMorphism components collect: [:f :g| f ⊗ g])! !

!ProductMorphism methodsFor: 'operations-additive' stamp: 'len 8/15/2024 21:35:44'!
⊕ aMorphism
	^ self class components: (components with: aMorphism components collect: [:f :g| f ⊕ g])! !

!ProductMorphism methodsFor: 'operations-preabelian' stamp: 'len 8/15/2024 21:34:40'!
cokernel
	^ self class components: (components collect: [:each| each cokernelMorphism])! !

!ProductMorphism methodsFor: 'operations-preabelian' stamp: 'len 8/15/2024 21:35:15'!
kernel
	^ self class components: (components collect: [:each| each kernelMorphism])! !

!ProductMorphism methodsFor: 'operations-preadditive' stamp: 'len 8/15/2024 21:28:47'!
* aScalar
	^ self class components: components * aScalar! !

!ProductMorphism methodsFor: 'operations-preadditive' stamp: 'len 8/15/2024 21:41:34'!
+ aMorphism
	^ self class components: (components with: aMorphism components collect: [:f :g| f + g])! !

!ProductMorphism methodsFor: 'operations-preadditive' stamp: 'len 8/15/2024 21:29:27'!
negated
	^ self class components: components negated! !

!ProductMorphism methodsFor: 'operations-preadditive' stamp: 'len 8/15/2024 21:29:34'!
zero
	^ self class components: components zero! !

!ProductMorphism methodsFor: 'testing' stamp: 'len 4/10/2024 04:15:23'!
isEpimorphism
	^ components allSatisfy: [:each| each isEpimorphism]! !

!ProductMorphism methodsFor: 'testing' stamp: 'len 4/24/2024 09:15:14'!
isIdentity
	^ components allSatisfy: [:each| each isIdentity]! !

!ProductMorphism methodsFor: 'testing' stamp: 'len 4/10/2024 04:15:47'!
isIsomorphism
	^ components allSatisfy: [:each| each isIsomorphism]! !

!ProductMorphism methodsFor: 'testing' stamp: 'len 4/10/2024 04:15:32'!
isMonomorphism
	^ components allSatisfy: [:each| each isMonomorphism]! !

!ProductMorphism methodsFor: 'private' stamp: 'len 4/4/2024 08:21:39'!
components
	^ components! !

!ProductMorphism methodsFor: 'private' stamp: 'len 8/15/2024 21:30:13'!
components: anArray
	components := anArray! !

!ProductMorphism class methodsFor: 'instance creation' stamp: 'len 8/15/2024 21:29:58'!
components: anArray
	^ self new components: anArray! !

!Transformation methodsFor: 'accessing' stamp: 'len 5/23/2024 15:04:06'!
at: anObject
	"Answer the component of the receiver at anObject.
	If the receiver is a natural transformation between functors F,G:C→D, and X = anObject is an object of C, answer a morphism F(X)→G(X)."
	| X |
	X := self domain₀ !! anObject.
	self propertyAt: #componentsMap ifPresent: [:aDictionary| ^ aDictionary at: X].
	^ (self propertyAt: #componentsBlock) value: X! !

!Transformation methodsFor: 'accessing' stamp: 'len 6/14/2024 15:07:47'!
category
	"Answer the category where the receiver belongs as a morphism.
	If the receiver is a natural transformation η:F→G between functors F,G:C→D, answer functor category [C,D]."
	^ self domain category! !

!Transformation methodsFor: 'accessing' stamp: 'len 5/6/2024 12:22:25'!
codomain₀
	"If the receiver is a natural transformation η:F→G between functors F,G:C→D, answer D."
	^ self domain codomain! !

!Transformation methodsFor: 'accessing' stamp: 'len 5/6/2024 12:22:40'!
domain₀
	"If the receiver is a natural transformation η:F→G between functors F,G:C→D, answer C."
	^ self domain domain! !

!Transformation methodsFor: 'converting' stamp: 'len 5/24/2024 12:58:33'!
asFunctorToArrowCategory
	"If the receiver is a natural transformation F → G between two functors F,G : C → D, answer the receiver as a functor from C to Arr(D)."
	^ self notYetImplemented! !

!Transformation methodsFor: 'converting' stamp: 'len 5/24/2024 12:58:49'!
asFunctorToCommaCategory
	"If the receiver is a natural transformation F → G between two functors F,G : C → D, answer the receiver as a functor from C to the comma category (F ↓ G)."
	| comma |
	comma := self domain ↓ self codomain.
	^ self domain domain to: comma
		map₀: [:x| comma source: x target: x arrow: (self at: x)]
		map: [:x :y :f| x to: y source: (self at: f domain) target: (self at: f codomain)]! !

!Transformation methodsFor: 'operations' stamp: 'len 6/13/2024 14:07:48'!
colift: aTransformation
	"Answer h:X→Y such that h·g = f, where g:A→X is the receiver and f:A→Y is the argument. Answer nil if there is no solution.
	This is a 'colift (or extension) of g along f' and it is denoted by f / g."
"	^ self codomain to: aTransformation domain transform: [:x| ((self at: x) colift: (aTransformation at: x)) ifNil: [^ nil]]"
	^ self notYetImplemented! !

!Transformation methodsFor: 'operations' stamp: 'len 6/13/2024 14:07:53'!
lift: aTransformation
	"Answer h:Y→X such that f·h = g, where f:X→B is the receiver and g:Y→B is the argument.
	This is a 'lift of g along f', denoted by f \ g."
	^ self notYetImplemented! !

!Transformation methodsFor: 'operations' stamp: 'len 8/15/2024 13:02:22'!
reverse
	^ self codomain reverse to: self domain reverse transform: [:u| (self at: u) reverse]! !

!Transformation methodsFor: 'operations' stamp: 'len 7/21/2024 09:35:44'!
∘ aTransformation
	"Answer the vertical composition of the receiver with the argument."
	self checkCompatibleComposition: aTransformation.
	^ aTransformation domain to: self codomain transform: [:u| (self at: u) ∘ (aTransformation at: u)]! !

!Transformation methodsFor: 'operations' stamp: 'len 7/21/2024 09:42:13'!
⊗ aTransformation
	"Answer the Godement product of the receiver with the argument.
	This is the horizontal composition of natural transformations as 2-morphisms in the 2-category Cat (or whiskering, because it puts the whiskers on the Cat).
	The endofunctors category is monoidal with composition as tensor product and the identity functor as tensor unit."
	^ self domain ⊗ aTransformation domain to: self codomain ⊗ aTransformation codomain transform: [:u| (self at: (aTransformation codomain value₀: u)) ∘ (self domain value: (aTransformation at: u))]! !

!Transformation methodsFor: 'operations-preabelian' stamp: 'len 8/14/2024 11:23:01'!
cokernel
	"Answer the cokernel object."
	^ self domain₀ to: self codomain₀ map: [:f| (self value: f) cokernelMorphism]! !

!Transformation methodsFor: 'operations-preabelian' stamp: 'len 8/14/2024 11:23:01'!
cokernelMorphism
	"Answer the cokernel projection."
	^ self codomain to: self cokernel transform: [:u| (self at: u) cokernelMorphism]! !

!Transformation methodsFor: 'operations-preabelian' stamp: 'len 8/14/2024 11:23:47'!
kernel
	"Answer the kernel object."
	^ self domain₀ to: self codomain₀ map: [:f| (self value: f) kernelMorphism]! !

!Transformation methodsFor: 'operations-preabelian' stamp: 'len 8/14/2024 11:23:47'!
kernelMorphism
	"Answer the kernel embedding."
	^ self kernel to: self domain transform: [:u| (self at: u) kernelMorphism]! !

!Transformation methodsFor: 'operations-preadditive' stamp: 'len 6/2/2024 15:02:23'!
+ aTransformation
	^ self domain to: self codomain transform: [:u| (self at: u) + (aTransformation at: u)]! !

!Transformation methodsFor: 'operations-preadditive' stamp: 'len 6/2/2024 15:03:04'!
negated
	^ self domain to: self codomain transform: [:u| (self at: u) negated]! !

!Transformation methodsFor: 'operations-preadditive' stamp: 'len 6/2/2024 15:03:20'!
zero
	^ self domain to: self codomain transform: [:u| (self at: u) zero]! !

!Transformation methodsFor: 'testing' stamp: 'len 4/19/2024 12:36:34'!
isEpimorphism
	"If a natural transformation is pointwise epi, then it is epi.
	The converse is true if the target category has pushouts."
	^ self domain objects allSatisfy: [:each| (self at: each) isEpimorphism]! !

!Transformation methodsFor: 'testing' stamp: 'len 4/19/2024 12:36:09'!
isMonomorphism
	"If a natural transformation is pointwise mono, then it is mono.
	The converse is true if the target category has pullbacks."
	^ self domain objects allSatisfy: [:each| (self at: each) isMonomorphism]! !

!Transformation class methodsFor: 'instance creation' stamp: 'len 5/23/2024 15:02:55'!
from: aFunctor to: anotherFunctor components: aDictionary
	^ self new domain: aFunctor; codomain: anotherFunctor; propertyAt: #componentsMap put: aDictionary; yourself! !

!Transformation class methodsFor: 'instance creation' stamp: 'len 5/23/2024 15:04:15'!
from: aFunctor to: anotherFunctor transform: aBlock
	^ self new domain: aFunctor; codomain: anotherFunctor; propertyAt: #componentsBlock put: aBlock; yourself! !

!CommaMorphism methodsFor: 'accessing' stamp: 'len 6/14/2024 15:07:31'!
category
	^ self domain category! !

!CommaMorphism methodsFor: 'accessing' stamp: 'len 4/26/2024 15:48:22'!
source
	^ self propertyAt: #source! !

!CommaMorphism methodsFor: 'accessing' stamp: 'len 4/26/2024 15:48:26'!
target
	^ self propertyAt: #target! !

!CommaMorphism methodsFor: 'operations' stamp: 'len 7/2/2024 05:54:16'!
dual
	"Note: this makes sense in the arrow category, not in general comma categories."
	^ self domain dual to: self codomain dual source: self source dual target: self target dual! !

!CommaMorphism methodsFor: 'operations' stamp: 'len 7/21/2024 09:31:09'!
∘ aMorphism
	self checkCompatibleComposition: aMorphism.
	^ aMorphism domain to: self codomain source: self source ∘ aMorphism source target: self target ∘ aMorphism target! !

!CommaMorphism methodsFor: 'operations' stamp: 'len 7/2/2024 05:56:10'!
⊗ aMorphism
	"Note: this makes sense in the arrow category, not in general comma categories."
	^ self domain ⊗ aMorphism domain to: self codomain ⊗ aMorphism codomain source: self source ⊗ aMorphism source target: self target ⊗ aMorphism target! !

!CommaMorphism methodsFor: 'operations-additive' stamp: 'len 6/23/2024 09:22:51'!
⊕ aMorphism
	^ self domain ⊕ aMorphism domain to: self codomain ⊕ aMorphism codomain source: self source ⊕ aMorphism source target: self target ⊕ aMorphism target! !

!CommaMorphism methodsFor: 'operations-preadditive' stamp: 'len 6/23/2024 09:30:05'!
* aScalar
	^ self domain to: self codomain source: self source * aScalar target: self target * aScalar! !

!CommaMorphism methodsFor: 'operations-preadditive' stamp: 'len 6/23/2024 09:29:37'!
+ aMorphism
	^ self domain to: self codomain source: self source + aMorphism source target: self target + aMorphism target! !

!CommaMorphism methodsFor: 'operations-preadditive' stamp: 'len 6/23/2024 09:30:19'!
negated
	^ self domain to: self codomain source: self source negated target: self target negated! !

!CommaMorphism methodsFor: 'operations-preadditive' stamp: 'len 6/23/2024 09:27:37'!
zero
	^ self domain to: self codomain source: self source zero target: self target zero! !

!CommaMorphism methodsFor: 'testing' stamp: 'len 8/3/2024 10:19:12'!
isMonomorphism
	(self category isKindOf: SliceCategory) ifTrue: [^ self source isMonomorphism].
	^ super isMonomorphism! !

!CommaMorphism class methodsFor: 'instance creation' stamp: 'len 4/26/2024 16:27:47'!
from: aDomain to: aCodomain source: aMorphism target: anotherMorphism
	^ self new
		propertyAt: #domain put: aDomain;
		propertyAt: #codomain put: aCodomain;
		propertyAt: #source put: aMorphism;
		propertyAt: #target put: anotherMorphism;
		yourself! !

!BimonoidMorphism methodsFor: 'accessing' stamp: 'len 8/31/2024 18:29:48'!
carrier
	^ carrier! !

!BimonoidMorphism methodsFor: 'accessing' stamp: 'len 8/31/2024 18:31:17'!
category
	^ domain category! !

!BimonoidMorphism methodsFor: 'accessing' stamp: 'len 8/31/2024 18:30:39'!
codomain
	^ codomain! !

!BimonoidMorphism methodsFor: 'accessing' stamp: 'len 8/31/2024 18:30:36'!
domain
	^ domain! !

!BimonoidMorphism methodsFor: 'operations' stamp: 'len 8/31/2024 18:57:40'!
coopposite
	^ self class from: domain coopposite to: codomain coopposite carrier: carrier! !

!BimonoidMorphism methodsFor: 'operations' stamp: 'len 8/31/2024 18:57:32'!
opposite
	^ self class from: domain opposite to: codomain opposite carrier: carrier! !

!BimonoidMorphism methodsFor: 'operations' stamp: 'len 8/31/2024 18:54:01'!
reverse
	^ self propertyAt: #reverse ifAbsentPut: [self class from: codomain reverse to: domain reverse carrier: carrier reverse]! !

!BimonoidMorphism methodsFor: 'operations' stamp: 'len 8/31/2024 18:32:19'!
∘ aMorphism
	self checkCompatibleComposition: aMorphism.
	^ aMorphism domain to: codomain carrier: carrier ∘ aMorphism carrier! !

!BimonoidMorphism methodsFor: 'printing' stamp: 'len 8/31/2024 18:31:49'!
printOn: aStream
	aStream print: carrier! !

!BimonoidMorphism methodsFor: 'private' stamp: 'len 8/31/2024 18:30:52'!
domain: aDomain codomain: aCodomain carrier: aMorphism
	domain := aDomain.
	codomain := aCodomain.
	carrier := aMorphism! !

!BimonoidMorphism class methodsFor: 'instance creation' stamp: 'len 8/31/2024 18:35:03'!
from: aDomain to: aCodomain carrier: aMorphism
	^ self new domain: aDomain codomain: aCodomain carrier: aMorphism! !

!GroupMorphism methodsFor: 'accessing' stamp: 'len 8/30/2024 20:53:09'!
carrier
	^ carrier! !

!GroupMorphism methodsFor: 'accessing' stamp: 'len 8/30/2024 20:54:32'!
category
	^ domain category! !

!GroupMorphism methodsFor: 'accessing' stamp: 'len 8/30/2024 20:53:21'!
codomain
	^ codomain! !

!GroupMorphism methodsFor: 'accessing' stamp: 'len 8/30/2024 20:53:18'!
domain
	^ domain! !

!GroupMorphism methodsFor: 'operations' stamp: 'len 8/30/2024 20:55:48'!
× aMorphism
	^ domain × aMorphism domain to: codomain × aMorphism codomain carrier: carrier × aMorphism carrier! !

!GroupMorphism methodsFor: 'operations' stamp: 'len 8/30/2024 20:57:26'!
∘ aMorphism
	self checkCompatibleComposition: aMorphism.
	^ aMorphism domain to: codomain carrier: carrier ∘ aMorphism carrier! !

!GroupMorphism methodsFor: 'printing' stamp: 'len 8/30/2024 20:56:48'!
printOn: aStream
	aStream print: carrier! !

!GroupMorphism methodsFor: 'private' stamp: 'len 8/30/2024 20:53:38'!
domain: aDomain codomain: aCodomain carrier: aMorphism
	domain := aDomain.
	codomain := aCodomain.
	carrier := aMorphism! !

!GroupMorphism class methodsFor: 'instance creation' stamp: 'len 8/30/2024 20:53:58'!
from: aDomain to: aCodomain carrier: aMorphism
	^ self new domain: aDomain codomain: aCodomain carrier: aMorphism! !

!ModuleMorphism methodsFor: 'accessing' stamp: 'len 8/31/2024 18:29:57'!
carrier
	^ carrier! !

!ModuleMorphism methodsFor: 'accessing' stamp: 'len 8/31/2024 18:31:23'!
category
	^ domain category! !

!ModuleMorphism methodsFor: 'accessing' stamp: 'len 8/31/2024 18:32:08'!
codomain
	^ codomain! !

!ModuleMorphism methodsFor: 'accessing' stamp: 'len 8/31/2024 18:32:06'!
domain
	^ domain! !

!ModuleMorphism methodsFor: 'operations' stamp: 'len 8/31/2024 18:32:25'!
∘ aMorphism
	self checkCompatibleComposition: aMorphism.
	^ aMorphism domain to: codomain carrier: carrier ∘ aMorphism carrier! !

!ModuleMorphism methodsFor: 'printing' stamp: 'len 8/31/2024 18:32:02'!
printOn: aStream
	aStream print: carrier! !

!ModuleMorphism methodsFor: 'private' stamp: 'len 8/31/2024 18:30:58'!
domain: aDomain codomain: aCodomain carrier: aMorphism
	domain := aDomain.
	codomain := aCodomain.
	carrier := aMorphism! !

!ModuleMorphism class methodsFor: 'instance creation' stamp: 'len 8/31/2024 18:35:19'!
from: aDomain to: aCodomain carrier: aMorphism
	^ self new domain: aDomain codomain: aCodomain carrier: aMorphism! !

!MonoidMorphism methodsFor: 'accessing' stamp: 'len 8/31/2024 18:30:02'!
carrier
	^ carrier! !

!MonoidMorphism methodsFor: 'accessing' stamp: 'len 8/31/2024 18:31:27'!
category
	^ domain category! !

!MonoidMorphism methodsFor: 'accessing' stamp: 'len 8/31/2024 18:30:11'!
codomain
	^ codomain! !

!MonoidMorphism methodsFor: 'accessing' stamp: 'len 8/31/2024 18:30:08'!
domain
	^ domain! !

!MonoidMorphism methodsFor: 'operations' stamp: 'len 8/31/2024 18:57:54'!
opposite
	^ self class from: domain opposite to: codomain opposite carrier: carrier! !

!MonoidMorphism methodsFor: 'operations' stamp: 'len 8/31/2024 18:32:30'!
∘ aMorphism
	self checkCompatibleComposition: aMorphism.
	^ aMorphism domain to: codomain carrier: carrier ∘ aMorphism carrier! !

!MonoidMorphism methodsFor: 'printing' stamp: 'len 8/31/2024 18:31:55'!
printOn: aStream
	aStream print: carrier! !

!MonoidMorphism methodsFor: 'private' stamp: 'len 8/31/2024 18:31:03'!
domain: aDomain codomain: aCodomain carrier: aMorphism
	domain := aDomain.
	codomain := aCodomain.
	carrier := aMorphism! !

!MonoidMorphism class methodsFor: 'instance creation' stamp: 'len 8/31/2024 18:35:34'!
from: aDomain to: aCodomain carrier: aMorphism
	^ self new domain: aDomain codomain: aCodomain carrier: aMorphism! !

!ChainMap methodsFor: 'accessing' stamp: 'len 10/5/2022 18:43:50'!
at: anInteger
	^ components at: components size - anInteger + self domain minDegree ifAbsent:
		[| X Y |
		X _ self domain chains: anInteger.
		Y _ self codomain chains: anInteger.
		self assert: (X isTrivial or: [Y isTrivial]).
		X → Y]! !

!ChainMap methodsFor: 'accessing' stamp: 'len 5/1/2024 12:27:46'!
category
	^ components any parent complexes! !

!ChainMap methodsFor: 'accessing' stamp: 'len 4/22/2020 14:25:19'!
components
	^ components! !

!ChainMap methodsFor: 'accessing' stamp: 'len 11/4/2020 16:24:37'!
degree
	^ 0! !

!ChainMap methodsFor: 'accessing' stamp: 'len 3/26/2024 13:03:54'!
zero
	^ self class from: self domain to: self codomain components: (self components collect: [:each| each zero])! !

!ChainMap methodsFor: 'comparing' stamp: 'len 7/8/2022 08:38:05'!
= anObject
	self == anObject ifTrue: [^ true].
	(anObject isKindOf: ChainMap) ifFalse: [^ super = anObject].
	^ self domain = anObject domain and: [self codomain = anObject codomain and: [components = anObject components]]! !

!ChainMap methodsFor: 'homology' stamp: 'len 9/16/2022 08:07:33'!
boundaries: k
	^ (self domain boundaries: k) to: (self codomain boundaries: k) map: [:x| (self at: k+1) value: x]! !

!ChainMap methodsFor: 'homology' stamp: 'len 9/16/2022 08:07:38'!
cycles: k
	^ (self domain cycles: k) to: (self codomain cycles: k) map: [:x| (self at: k) value: x]! !

!ChainMap methodsFor: 'homology' stamp: 'len 4/22/2020 15:44:02'!
homology: k
	^ self notYetImplemented! !

!ChainMap methodsFor: 'operations' stamp: 'len 4/23/2020 00:23:25'!
* anElement
	^ self class from: self domain to: self codomain components: components * anElement! !

!ChainMap methodsFor: 'operations' stamp: 'len 4/22/2020 20:05:42'!
+ aChainMap
	(aChainMap isKindOf: ChainMap) ifFalse: [^ super + aChainMap].
	^ self class from: self domain to: self codomain components: components + aChainMap components! !

!ChainMap methodsFor: 'operations' stamp: 'len 9/18/2022 07:13:54'!
cokernel
	| chains |
	chains _ components collect: [:each| each cokernel].
"	^ ChainComplex differentials:  (self domain differentials withIndexCollect: [:each :i| (terms at: i) to: (terms at: i+1) map: each])"
	self notYetImplemented! !

!ChainMap methodsFor: 'operations' stamp: 'len 9/16/2022 08:07:45'!
image
	| chains |
	chains _ components collect: [:each| each image].
	^ ChainComplex differentials:  (self codomain differentials withIndexCollect: [:each :i| (chains at: i) to: (chains at: i+1) map: each])! !

!ChainMap methodsFor: 'operations' stamp: 'len 12/9/2022 10:40:53'!
inverse
	^ self class from: self codomain to: self domain components: (components collect: [:each| each inverse])! !

!ChainMap methodsFor: 'operations' stamp: 'len 9/16/2022 08:07:50'!
kernel
	| chains |
	chains _ components collect: [:each| each kernel].
	^ ChainComplex differentials:  (self domain differentials withIndexCollect: [:each :i| (chains at: i) to: (chains at: i+1) map: each])! !

!ChainMap methodsFor: 'operations' stamp: 'len 4/22/2020 20:03:57'!
negated
	^ self class from: self domain to: self codomain components: components negated! !

!ChainMap methodsFor: 'operations' stamp: 'len 4/23/2020 00:22:45'!
retraction
	^ self class from: self codomain to: self domain components: (components collect: [:each| each retraction ifNil: [^ nil]])! !

!ChainMap methodsFor: 'operations' stamp: 'len 4/23/2020 00:22:52'!
section
	^ self class from: self codomain to: self domain components: (components collect: [:each| each section ifNil: [^ nil]])! !

!ChainMap methodsFor: 'operations' stamp: 'len 4/17/2024 08:03:22'!
sum
	"Answer the direct sum of the terms of the receiver.
	This is the forgetful functor from the category of chain complexes over A to A."
	^ components inject: components first zero into: [:sum :each| sum ⊕ each]! !

!ChainMap methodsFor: 'operations' stamp: 'len 7/21/2024 09:36:26'!
∘ aChainMap
	(aChainMap isKindOf: ChainMap) ifFalse: [^ super ∘ aChainMap].
	^ self class from: aChainMap domain to: self codomain components: (components with: aChainMap components collect: [:f :g| f ∘ g])! !

!ChainMap methodsFor: 'testing' stamp: 'len 4/22/2020 19:23:14'!
isIdentity
	^ components allSatisfy: [:each| each isIdentity]! !

!ChainMap methodsFor: 'testing' stamp: 'len 7/8/2022 08:37:49'!
isInjective
	^ components allSatisfy: [:each| each isInjective]! !

!ChainMap methodsFor: 'testing' stamp: 'len 4/22/2020 15:45:25'!
isQuasiIsomorphism
	^ self indices allSatisfy: [:i| (self homology: i) isIsomorphism]! !

!ChainMap methodsFor: 'testing' stamp: 'len 7/8/2022 08:37:45'!
isSurjective
	^ components allSatisfy: [:each| each isSurjective]! !

!ChainMap methodsFor: 'testing' stamp: 'len 7/8/2022 08:37:39'!
isZero
	^ components allSatisfy: [:each| each isZero]! !

!ChainMap methodsFor: 'private' stamp: 'len 4/22/2020 14:25:03'!
components: anArray
	components _ anArray! !

!ChainMap methodsFor: 'private' stamp: 'len 7/21/2024 09:42:01'!
validate
	super validate.
	self assert: (self indices allButLast allSatisfy: [:i| (self at: i) ∘ (self domain at: i) = ((self codomain at: i) ∘ (self at: i+1))])! !

!ChainMap class methodsFor: 'instance creation' stamp: 'len 4/22/2020 14:29:07'!
from: aDomain to: aCodomain components: anArray
	^ self new domain: aDomain; codomain: aCodomain; components: anArray! !

!FreydMorphism methodsFor: 'accessing' stamp: 'len 4/22/2024 05:13:33'!
category
	^ datum category Freyd! !

!FreydMorphism methodsFor: 'accessing' stamp: 'len 6/29/2023 17:08:03'!
datum
	^ datum! !

!FreydMorphism methodsFor: 'accessing' stamp: 'len 7/21/2024 09:39:42'!
witness
	^ self propertyAt: #witness ifAbsentPut: [self codomain \ (datum ∘ self domain)]! !

!FreydMorphism methodsFor: 'comparing' stamp: 'len 6/29/2023 17:07:56'!
= anObject
	anObject class = self class ifFalse: [^ false].
	(self domain = anObject domain and: [self codomain = anObject codomain]) ifFalse: [^ false].
	^ (self codomain lift: datum - anObject datum) notNil! !

!FreydMorphism methodsFor: 'comparing' stamp: 'len 6/29/2023 17:08:27'!
hash
	^ self domain hash + self codomain hash hashMultiply! !

!FreydMorphism methodsFor: 'operations' stamp: 'len 4/28/2024 05:25:54'!
cokernel
	^ self class from: self codomain to: (FreydObject value: datum) ⊔ self codomain datum: datum codomain id! !

!FreydMorphism methodsFor: 'operations' stamp: 'len 6/29/2023 18:16:01'!
colift: aMorphism
	self notYetImplemented! !

!FreydMorphism methodsFor: 'operations' stamp: 'len 4/22/2024 08:42:26'!
kernel
	self notYetImplemented
"	^ self class from: datum ⊓ self codomain to: self domain datum: datum codomain id"! !

!FreydMorphism methodsFor: 'operations' stamp: 'len 6/29/2023 18:15:59'!
lift: aMorphism
	self notYetImplemented! !

!FreydMorphism methodsFor: 'operations' stamp: 'len 7/21/2024 09:37:46'!
∘ aMorphism
	self checkCompatibleComposition: aMorphism.
	^ self class from: aMorphism domain to: self codomain datum: datum ∘ aMorphism datum! !

!FreydMorphism methodsFor: 'operations-preadditive' stamp: 'len 4/17/2024 08:56:32'!
+ aMorphism
	self checkDomainsMatch: aMorphism.
	self checkCodomainsMatch: aMorphism.
	^ self class from: self domain to: self codomain datum: datum + aMorphism datum! !

!FreydMorphism methodsFor: 'operations-preadditive' stamp: 'len 4/17/2024 08:56:41'!
negated
	^ self class from: self domain to: self codomain datum: datum negated! !

!FreydMorphism methodsFor: 'operations-preadditive' stamp: 'len 4/17/2024 08:59:45'!
zero
	^ self class from: self domain to: self codomain datum: datum zero! !

!FreydMorphism methodsFor: 'testing' stamp: 'len 6/30/2023 00:33:29'!
isEpimorphism
	^ datum isIdentity or: [super isEpimorphism]! !

!FreydMorphism methodsFor: 'testing' stamp: 'len 4/17/2024 08:50:42'!
isIdentity
	^ self isEndomorphism and: [datum isIdentity]! !

!FreydMorphism methodsFor: 'private' stamp: 'len 6/29/2023 17:27:27'!
datum: aMorphism
	datum := aMorphism! !

!FreydMorphism class methodsFor: 'instance creation' stamp: 'len 6/29/2023 17:26:53'!
from: aDomain to: aCodomain datum: aMorphism
	self assert: (aMorphism domain = aDomain codomain and: [aMorphism codomain = aCodomain codomain]).
	^ self new domain: aDomain; codomain: aCodomain; datum: aMorphism! !

!GradedMorphism methodsFor: 'as yet unclassified' stamp: 'len 9/4/2024 09:58:36'!
at: anInteger
	^ grading value: anInteger! !

!GradedMorphism methodsFor: 'as yet unclassified' stamp: 'len 9/4/2024 10:12:55'!
category
	^ (self at: 0) category graded! !

!GradedMorphism methodsFor: 'as yet unclassified' stamp: 'len 9/4/2024 09:58:19'!
codomain
	^ codomain! !

!GradedMorphism methodsFor: 'as yet unclassified' stamp: 'len 9/4/2024 09:58:16'!
domain
	^ domain! !

!GradedMorphism methodsFor: 'as yet unclassified' stamp: 'len 9/4/2024 10:09:32'!
domain: aGradedObject codomain: anotherGradedObject grading: aBlock
	domain := aGradedObject.
	codomain := anotherGradedObject.
	grading := aBlock! !

!GradedMorphism methodsFor: 'as yet unclassified' stamp: 'len 9/4/2024 10:16:59'!
isZero
	self flag: #fixme.
	^ false! !

!GradedMorphism class methodsFor: 'as yet unclassified' stamp: 'len 9/4/2024 10:08:51'!
from: aDomain to: aCodomain grading: aBlock
	^ self new domain: aDomain codomain: aCodomain grading: aBlock! !

!Relation methodsFor: 'accessing' stamp: 'len 8/13/2024 16:23:57'!
arrow
	^ arrow! !

!Relation methodsFor: 'accessing' stamp: 'len 8/27/2024 21:57:57'!
category
	^ arrow category relations! !

!Relation methodsFor: 'accessing' stamp: 'len 8/13/2024 16:24:11'!
coarrow
	^ coarrow! !

!Relation methodsFor: 'accessing' stamp: 'len 8/26/2024 20:06:54'!
codomain
	^ RelationObject value: arrow codomain! !

!Relation methodsFor: 'accessing' stamp: 'len 8/26/2024 20:06:54'!
domain
	^ RelationObject value: coarrow codomain! !

!Relation methodsFor: 'accessing' stamp: 'len 8/13/2024 16:24:48'!
generalizedImage
	^ arrow image! !

!Relation methodsFor: 'accessing' stamp: 'len 8/26/2024 17:12:12'!
zero
	^ self class arrow: (coarrow codomain ⇒ arrow codomain) zero! !

!Relation methodsFor: 'comparing' stamp: 'len 8/27/2024 21:36:49'!
= anObject
	"Answer true if the receiver is stably equivalent to the argument. [Pos17b, Definition 1.12]."
	"If they are assumed normalized, we can just test equality of the arrows."
	^ self class = anObject class and: [self subobject = anObject subobject]! !

!Relation methodsFor: 'comparing' stamp: 'len 8/27/2024 21:36:54'!
hash
	^ self subobject hash! !

!Relation methodsFor: 'operations' stamp: 'len 8/13/2024 16:21:11'!
+ aMorphism
	^ coarrow ∧ aMorphism coarrow ⇉ {coarrow domain. aMorphism coarrow domain} into:
		[:π₁ :π₂| self class arrow: arrow ∘ π₁ + (aMorphism arrow ∘ π₂) coarrow: coarrow ∘ π₁]! !

!Relation methodsFor: 'operations' stamp: 'len 8/27/2024 21:35:18'!
adjoint
	^ self class arrow: coarrow coarrow: arrow! !

!Relation methodsFor: 'operations' stamp: 'len 5/3/2024 14:36:28'!
codefect
	^ (self generalizedDomain → self domain value) cokernel! !

!Relation methodsFor: 'operations' stamp: 'len 8/13/2024 16:23:33'!
defect
	^ (arrow ∘ (coarrow kernel → coarrow domain)) image! !

!Relation methodsFor: 'operations' stamp: 'len 5/3/2024 14:35:42'!
generalizedCoimage
	^ (self generalizedKernel → self domain value) cokernel! !

!Relation methodsFor: 'operations' stamp: 'len 5/3/2024 14:35:49'!
generalizedCokernel
	^ (self generalizedImage → self codomain value) cokernel! !

!Relation methodsFor: 'operations' stamp: 'len 8/27/2024 21:34:02'!
generalizedDomain
	^ self adjoint generalizedImage! !

!Relation methodsFor: 'operations' stamp: 'len 8/27/2024 21:34:07'!
generalizedKernel
	^ self adjoint defect! !

!Relation methodsFor: 'operations' stamp: 'len 8/13/2024 16:29:11'!
negated
	^ self class arrow: arrow negated coarrow: coarrow! !

!Relation methodsFor: 'operations' stamp: 'len 8/13/2024 16:29:30'!
representative
	"Assuming the receiver is honest (i.e., the coarrow is an isomorphism), answer a honest representative."
	^ arrow ∘ coarrow inverse! !

!Relation methodsFor: 'operations' stamp: 'len 8/27/2024 21:34:14'!
retraction
	^ self isMonomorphism ifTrue: [self adjoint]! !

!Relation methodsFor: 'operations' stamp: 'len 8/27/2024 21:34:20'!
section
	^ self isEpimorphism ifTrue: [self adjoint]! !

!Relation methodsFor: 'operations' stamp: 'len 9/4/2024 09:35:20'!
subobject
	"Answer the associated relation of this span as subobject of the product. [Pos17b, Definition 1.11]."
	^ self propertyAt: #subobject ifAbsentPut: [(arrow ⊓ coarrow) image]! !

!Relation methodsFor: 'operations' stamp: 'len 8/13/2024 16:29:35'!
∘ aMorphism
	self checkCompatibleComposition: aMorphism.
	^ coarrow ∧ aMorphism arrow ⇉ {coarrow domain. aMorphism arrow domain} into:
		[:π₁ :π₂| self class arrow: arrow ∘ π₁ coarrow: aMorphism coarrow ∘ π₂]! !

!Relation methodsFor: 'testing' stamp: 'len 8/13/2024 16:28:49'!
isHonest
	"A generalized morphism is 'honest' when it has full 'generalized domain' and zero 'defect'."
	^ coarrow isIsomorphism! !

!Relation methodsFor: 'testing' stamp: 'len 7/5/2023 12:17:52'!
isIdentity
	^ self isEndomorphism and: [self isHonest and: [self representative isIdentity]]! !

!Relation methodsFor: 'testing' stamp: 'len 8/13/2024 16:28:58'!
isNormalized
	"Answer true if the receiver is 'normalized' or 'stable'."
	^ (arrow ⊓ coarrow) isMonomorphism! !

!Relation methodsFor: 'testing' stamp: 'len 8/13/2024 16:29:05'!
isZero
	^ arrow isZero! !

!Relation methodsFor: 'private' stamp: 'len 9/4/2024 09:49:16'!
arrow: aMorphism coarrow: anotherMorphism
	arrow := aMorphism.
	coarrow := anotherMorphism.
	"'Normalize' or 'stabilize' the representation of this relation, i.e. choosing arrow and coarrow such that arrow ⊓ coarrow is a monomorphism:"
	arrow ∨ coarrow ⇇ {arrow codomain. coarrow codomain} into: [:ι₁ :ι₂|
		ι₁ ∧ ι₂ ⇉ {ι₁ domain. ι₂ domain} into: [:π₁ :π₂| arrow := π₁. coarrow := π₂]]! !

!Relation methodsFor: 'private' stamp: 'len 8/13/2024 16:25:29'!
normalize
	arrow ∨ coarrow ⇇ {arrow codomain. coarrow codomain} into: [:ι₁ :ι₂|
		ι₁ ∧ ι₂ ⇉ {ι₁ domain. ι₂ domain} into: [:π₁ :π₂| arrow := π₁. coarrow := π₂]]! !

!Relation class methodsFor: 'instance creation' stamp: 'len 8/26/2024 17:11:16'!
arrow: aMorphism
	^ self arrow: aMorphism coarrow: aMorphism domain id! !

!Relation class methodsFor: 'instance creation' stamp: 'len 8/13/2024 16:25:43'!
arrow: aMorphism coarrow: anotherMorphism
	^ self new arrow: aMorphism coarrow: anotherMorphism! !

!CoherentSheafMorphism methodsFor: 'accessing' stamp: 'len 4/12/2024 04:58:02'!
category
	^ self space sheaves! !

!CoherentSheafMorphism methodsFor: 'accessing' stamp: 'len 12/21/2021 20:44:01'!
space
	^ self domain space! !

!CoherentSheafMorphism methodsFor: 'accessing' stamp: 'len 7/13/2023 22:23:27'!
zero
	^ self class from: self domain to: self codomain moduleMap: self asModuleMap zero! !

!CoherentSheafMorphism methodsFor: 'converting' stamp: 'len 7/13/2023 22:15:26'!
asModuleMap
	^ self propertyAt: #moduleMap! !

!CoherentSheafMorphism methodsFor: 'operations' stamp: 'len 7/13/2023 22:19:01'!
+ aSheafMap
	^ self class from: self domain to: aSheafMap codomain moduleMap: self asModuleMap + aSheafMap asModuleMap! !

!CoherentSheafMorphism methodsFor: 'operations' stamp: 'len 4/13/2024 05:04:11'!
cokernel
	^ CoherentSheaf module: self asModuleMap cokernel on: self space! !

!CoherentSheafMorphism methodsFor: 'operations' stamp: 'len 7/13/2023 22:21:26'!
colift: aSheafMap
	^ (self asModuleMap colift: aSheafMap asModuleMap)
		ifNotNil: [:aModuleMap| self class from: self codomain to: aSheafMap codomain moduleMap: aModuleMap]! !

!CoherentSheafMorphism methodsFor: 'operations' stamp: 'len 4/13/2024 05:04:11'!
image
	^ CoherentSheaf module: self asModuleMap image on: self space! !

!CoherentSheafMorphism methodsFor: 'operations' stamp: 'len 4/13/2024 05:04:11'!
kernel
	^ CoherentSheaf module: self asModuleMap kernel on: self space! !

!CoherentSheafMorphism methodsFor: 'operations' stamp: 'len 7/13/2023 22:22:30'!
lift: aSheafMap
	^ (self asModuleMap lift: aSheafMap asModuleMap)
		ifNotNil: [:aModuleMap| self class from: aSheafMap domain to: self domain moduleMap: aModuleMap]! !

!CoherentSheafMorphism methodsFor: 'operations' stamp: 'len 7/13/2023 22:22:57'!
negated
	^ self class from: self domain to: self codomain moduleMap: self asModuleMap negated! !

!CoherentSheafMorphism methodsFor: 'printing' stamp: 'len 12/13/2021 18:14:29'!
printOn: aStream
	aStream print: self asModuleMap! !

!CoherentSheafMorphism methodsFor: 'private' stamp: 'len 7/13/2023 22:15:14'!
moduleMap: aModuleMap
	self propertyAt: #moduleMap put: aModuleMap! !

!CoherentSheafMorphism methodsFor: 'private' stamp: 'len 4/13/2024 05:05:42'!
species
	^ CoherentSheafMorphism! !

!CoherentSheafMorphism class methodsFor: 'instance creation' stamp: 'len 6/26/2022 22:38:29'!
from: aDomain to: aCodomain moduleMap: aModuleMap
	self assert: aDomain space = aCodomain space.
	self assert: (aModuleMap domain = self asModule and: [aModuleMap codomain = aCodomain asModule]).
	^ self new domain: aDomain; codomain: aCodomain; moduleMap: aModuleMap! !

!EquivalenceClass methodsFor: 'accessing' stamp: 'len 5/10/2024 10:17:07'!
equivalence
	^ equivalence! !

!EquivalenceClass methodsFor: 'accessing' stamp: 'len 5/10/2024 10:14:59'!
representative
	^ representative! !

!EquivalenceClass methodsFor: 'comparing' stamp: 'len 5/10/2024 10:23:45'!
= anObject
	^ self class = anObject class and: [equivalence = anObject equivalence and: [self includes: anObject representative]]! !

!EquivalenceClass methodsFor: 'comparing' stamp: 'len 5/10/2024 10:09:42'!
hash
	^ 0! !

!EquivalenceClass methodsFor: 'printing' stamp: 'len 5/10/2024 10:10:00'!
printOn: aStream
	aStream print: representative! !

!EquivalenceClass methodsFor: 'testing' stamp: 'len 5/10/2024 10:24:12'!
includes: anObject
	^ equivalence value: representative value: anObject! !

!EquivalenceClass methodsFor: 'private' stamp: 'len 5/10/2024 10:16:01'!
representative: anElement equivalence: aBlock
	representative := anElement.
	equivalence := aBlock! !

!EquivalenceClass class methodsFor: 'instance creation' stamp: 'len 5/10/2024 10:16:24'!
representative: anElement equivalence: aBlock
	^ self new representative: anElement equivalence: aBlock! !

!Monomial methodsFor: 'accessing' stamp: 'len 11/21/2016 15:56:16'!
at: anIndeterminate
	^ exponents at: anIndeterminate! !

!Monomial methodsFor: 'accessing' stamp: 'len 3/16/2016 20:03'!
bitSize
	^ exponents inject: 0 into: [:x :each| x + each bitSize]! !

!Monomial methodsFor: 'accessing' stamp: 'len 3/16/2016 20:05'!
exponents
	^ exponents! !

!Monomial methodsFor: 'accessing' stamp: 'len 7/1/2022 10:59:09'!
firstIndeterminate
	"Answer the first indeterminate effectively present."
	^ exponents findFirst: [:one| one ~= 0]! !

!Monomial methodsFor: 'accessing' stamp: 'len 6/19/2023 01:51:19'!
identity
	^ parent identity! !

!Monomial methodsFor: 'accessing' stamp: 'len 1/2/2022 10:04:35'!
indeterminates
	"Answer the list of indeterminates effectively present in this monomial (with nonzero exponent). This is called the 'support' of a monomial."
	^ (1 to: exponents size) select: [:i| (exponents at: i) ~= 0]! !

!Monomial methodsFor: 'accessing' stamp: 'len 7/1/2022 10:59:29'!
lastIndeterminate
	"Answer the last indeterminate effectively present."
	^ exponents findLast: [:one| one ~= 0]! !

!Monomial methodsFor: 'accessing' stamp: 'len 11/20/2016 11:56:47'!
ordering
	^ parent ordering! !

!Monomial methodsFor: 'accessing' stamp: 'len 1/23/2017 11:35:28'!
parent
	^ parent! !

!Monomial methodsFor: 'accessing' stamp: 'len 1/2/2022 10:04:42'!
support
	"Answer the list of indeterminates effectively present in this monomial (with nonzero exponent)."
	^ self indeterminates! !

!Monomial methodsFor: 'comparing' stamp: 'len 12/3/2023 21:19:12'!
< aMonomial
	^ (self compare: aMonomial) < 0! !

!Monomial methodsFor: 'comparing' stamp: 'len 12/3/2023 21:17:12'!
<= aMonomial
	^ (self compare: aMonomial) <= 0! !

!Monomial methodsFor: 'comparing' stamp: 'len 11/21/2016 19:44:36'!
= aMonomial
	| b |
	self == aMonomial ifTrue: [^ true].
	aMonomial isInteger ifTrue: [^ self degree = aMonomial].
"	^ exponents = aMonomial exponents"
	b _ aMonomial exponents.
	exponents size = b size ifFalse: [^ false].
	1 to: exponents size do: [:i| (exponents at: i) = (b at: i) ifFalse: [^ false]].
	^ true! !

!Monomial methodsFor: 'comparing' stamp: 'len 12/4/2023 10:13:21'!
> aMonomial
	^ aMonomial < self! !

!Monomial methodsFor: 'comparing' stamp: 'len 12/4/2023 10:13:28'!
>= aMonomial
	^ aMonomial <= self! !

!Monomial methodsFor: 'comparing' stamp: 'len 5/23/2022 11:59:12'!
| aMonomial
	"Answer true if the receiver divides the argument."
"	self degree > aMonomial degree ifTrue: [^ false]. <- this doesn't seem to help"
	1 to: exponents size do: [:i| (exponents at: i) > (aMonomial at: i) ifTrue: [^ false]].
	^ true! !

!Monomial methodsFor: 'comparing' stamp: 'len 1/5/2018 11:12:42'!
compare: aMonomial
	"Answer -1 if the receiver is < than the argument, 0 if they are equal, 1 if it is > than the argument."
	^ self ordering compare: self with: aMonomial! !

!Monomial methodsFor: 'comparing' stamp: 'len 11/30/2016 21:59:33'!
hash
	| answer |
	answer _ self lastIndeterminate.
	1 to: exponents size do: [:i|
		| e |
		(e _ exponents at: i) = 0
			ifFalse: [answer _ answer hashMultiply + e hash]].
	^ answer! !

!Monomial methodsFor: 'comparing' stamp: 'len 5/22/2022 20:07:38'!
⊥ anElement
	"Answer true if the receiver and the argument are coprime."
	^ (self gcd: anElement) isIdentity! !

!Monomial methodsFor: 'converting' stamp: 'len 5/23/2018 22:18:46'!
orderedBy: aMonomialOrdering
	^ (self parent orderedBy: aMonomialOrdering) !! self! !

!Monomial methodsFor: 'copying' stamp: 'len 5/14/2019 03:30:59'!
copyWith: anIndeterminate to: anInteger
	^ parent exponents: (exponents copy at: anIndeterminate put: anInteger; yourself)! !

!Monomial methodsFor: 'copying' stamp: 'len 5/14/2019 03:31:04'!
copyWithout: anIndeterminate
	"Answer a copy of the receiver with the given indeterminate removed."
	^ parent exponents: (exponents copy at: anIndeterminate put: 0; yourself)! !

!Monomial methodsFor: 'copying' stamp: 'len 12/20/2022 09:32:35'!
postCopy
	super postCopy.
	exponents _ exponents copy.
	degree _ nil! !

!Monomial methodsFor: 'enumerating' stamp: 'len 5/14/2019 04:00:53'!
do: aBinaryBlock
	exponents withIndexDo: [:each :i| aBinaryBlock value: i value: each]! !

!Monomial methodsFor: 'enumerating' stamp: 'len 6/3/2023 20:20:25'!
keysAndValuesDo: aBinaryBlock
	"Iterate over each indeterminate and exponent. For compatibility with Word and Tuple."
	exponents withIndexDo: [:each :i| aBinaryBlock value: i value: each]! !

!Monomial methodsFor: 'operations' stamp: 'len 6/19/2023 01:50:03'!
* aMonomial
	^ self · aMonomial! !

!Monomial methodsFor: 'operations' stamp: 'len 5/14/2019 03:30:33'!
/ aMonomial
	"Answer the exact division of the receiver by the argument."
	| b bn c |
	b _ aMonomial exponents.
	bn _ aMonomial exponents size.
	exponents size = bn ifFalse: [^ self error: 'not same size'].
	c _ Array new: bn.
	1 to: bn do: [:i| c at: i put: (exponents at: i) - (b at: i)].
	^ parent exponents: c! !

!Monomial methodsFor: 'operations' stamp: 'len 5/14/2019 03:30:39'!
^ anInteger
	^ parent exponents: exponents * anInteger! !

!Monomial methodsFor: 'operations' stamp: 'len 5/14/2019 03:30:44'!
· aMonomial
	| b bn c |
	b _ aMonomial exponents.
	bn _ aMonomial exponents size.
	exponents size = bn ifFalse: [^ self error: 'not same size'].
	c _ Array new: bn.
	1 to: bn do: [:i| c at: i put: (exponents at: i) + (b at: i)].
	^ parent exponents: c! !

!Monomial methodsFor: 'operations' stamp: 'len 7/6/2022 05:39:27'!
degree
	"Answer the total degree of the receiver."
	^ degree ifNil: [degree _ parent ordering degreeOf: exponents]! !

!Monomial methodsFor: 'operations' stamp: 'len 5/6/2023 18:51:34'!
degreeIn: anIndeterminate
	"Answer the degree of the receiver in the given indeterminate, i.e. the power to which the indeterminate appears in the receiver (times the indeterminate's weight, if the grading is nontrivial)."
	^ parent ordering degreeOf: exponents in: anIndeterminate! !

!Monomial methodsFor: 'operations' stamp: 'len 6/28/2023 16:59:05'!
dehomogenizedIn: anIndeterminate
	"Answer a copy of the receiver removing the given indeterminate.
	Note: It is not meaningful to talk about 'dehomogenization' of a monomial as an element of a monoid, this is only used for dehomogenization of polynomials."
	| newExponents |
	newExponents := Array new: exponents size.
	newExponents replaceFrom: 1 to: anIndeterminate - 1 with: exponents startingAt: 1.
	newExponents replaceFrom: anIndeterminate to: exponents size - 1 with: exponents startingAt: anIndeterminate + 1.
	newExponents at: exponents size put: 0.
	^ parent exponents: newExponents! !

!Monomial methodsFor: 'operations' stamp: 'len 5/14/2019 03:31:12'!
gcd: aMonomial
	"Answer the greatest common divisor of the receiver and the argument."
	exponents size <= aMonomial exponents size ifFalse: [^ aMonomial gcd: self].
	^ parent exponents: (exponents withIndexCollect: [:each :i| each min: (aMonomial at: i)])! !

!Monomial methodsFor: 'operations' stamp: 'len 6/28/2023 16:59:26'!
homogenizedIn: anIndeterminate to: anInteger
	"Answer a copy of the receiver of degree anInteger completing with a power of the indeterminate anIndeterminate.
	Note: It is not meaningful to talk about 'homogenization' of a monomial as an element of a monoid, this is only used for homogenization of polynomials."
	| n d w |
	(n := self degree) = anInteger ifTrue: [^ self].
	d := anInteger - n.
	w := parent ordering weightOf: anIndeterminate.
	w | d ifFalse: [^ self error: 'fractional exponent'].
	^ parent exponents: (exponents copy at: anIndeterminate put: d // w + (exponents at: anIndeterminate); yourself)! !

!Monomial methodsFor: 'operations' stamp: 'len 5/14/2019 03:31:26'!
lcm: aMonomial
	"Answer the least common multiple of the receiver and the argument."
	exponents size >= aMonomial exponents size ifFalse: [^ aMonomial lcm: self].
	^ parent exponents: (exponents withIndexCollect: [:each :i| each max: (aMonomial at: i)])! !

!Monomial methodsFor: 'operations' stamp: 'len 5/15/2019 04:32:30'!
log: b
	"Answer the discrete logarithm of the receiver in base b. This is, answer an integer k such that b^k equals the receiver."
	self notYetImplemented! !

!Monomial methodsFor: 'operations' stamp: 'len 1/23/2017 11:36:23'!
permutedBy: aPermutation
	"Permute the variables of the receiver. The argument can be an Array (permutation in 'image format'). For example given a monomial in x,z,y, #(1 2 3) doesn't change anything, #(2 1 3) exchanges variables x and y."
	| answer |
	answer _ self parent identity.
	exponents withIndexDo: [:exp :i|
		exp = 0 ifFalse: [answer _ answer * (self parent x: (aPermutation at: i) to: exp)]].
	^ answer! !

!Monomial methodsFor: 'operations' stamp: 'len 5/14/2019 03:31:39'!
root: anInteger
	^ parent exponents: exponents / anInteger! !

!Monomial methodsFor: 'operations' stamp: 'len 5/14/2019 03:31:46'!
root: anInteger in: anIndeterminate
	^ parent exponents: (exponents copy at: anIndeterminate put: (self at: anIndeterminate) / anInteger; yourself)! !

!Monomial methodsFor: 'operations' stamp: 'len 6/19/2023 01:52:01'!
squared
	^ self ^ 2! !

!Monomial methodsFor: 'operations' stamp: 'len 2/9/2017 03:20:49'!
substitute: aBlock
	"Answer the receiver after substituting indeterminates by aBlock."
	| answer |
	answer _ self parent identity.
	exponents withIndexDo: [:exp :i|
		exp = 0 ifFalse: [answer _ answer * (self parent x: (aBlock value: i) to: exp)]].
	^ answer! !

!Monomial methodsFor: 'operations' stamp: 'len 6/21/2023 23:04:26'!
value: anObject
	^ anObject exponentiate: exponents! !

!Monomial methodsFor: 'operations' stamp: 'len 6/6/2016 04:45'!
without: anIndeterminate
	^ (self has: anIndeterminate) ifFalse: [self] ifTrue: [self copyWithout: anIndeterminate]! !

!Monomial methodsFor: 'printing' stamp: 'len 5/6/2023 15:58:58'!
printExponent: anInteger on: aStream
	| s |
	anInteger = 1 ifTrue: [^ self].
	aStream isText ifTrue: [aStream nextPutAll: anInteger printString super. ^ self].
	s _ anInteger printString.
	s size > 1 ifTrue: [s _ '{', s, '}'].
	aStream nextPutAll: '^', s! !

!Monomial methodsFor: 'printing' stamp: 'len 5/6/2023 15:30:26'!
printIndeterminate: anInteger on: aStream
	(self parent names ifNotNil: [:names| names at: anInteger ifAbsent: []])
		ifNotNil: [:name| aStream nextPutAll: name displayStringOrText. ^ self].
	aStream nextPutAll: 'x', anInteger printString sub! !

!Monomial methodsFor: 'printing' stamp: 'len 6/22/2023 00:09:37'!
printOn: aStream
	self degree = 0 ifTrue: [aStream print: 1. ^ self].
	1 to: self parent rank do: [:i| | r |
		(r := self at: i) = 0 ifFalse:
			[self printIndeterminate: i on: aStream.
			self printExponent: r on: aStream]]! !

!Monomial methodsFor: 'printing' stamp: 'len 6/22/2023 00:09:49'!
printOn: aStream shifted: anArray
	| shiftedExponents |
	shiftedExponents := exponents + anArray.
	shiftedExponents sum = 0 ifTrue: [aStream print: 1. ^ self].
	1 to: self parent rank do: [:i| | r |
		(r := shiftedExponents at: i) = 0 ifFalse:
			[self printIndeterminate: i on: aStream.
			self printExponent: r on: aStream]]! !

!Monomial methodsFor: 'testing' stamp: 'len 12/5/2015 22:34'!
has: anIndeterminate
	^ (self at: anIndeterminate) ~= 0! !

!Monomial methodsFor: 'testing' stamp: 'len 6/6/2016 02:50'!
isIdentity
	^ exponents allSatisfy: [:each| each = 0]! !

!Monomial methodsFor: 'testing' stamp: 'len 2/14/2017 10:38:05'!
isPurePower
	"Answer true if the receiver is a power of a single indeterminate."
	| count |
	count _ 0.
	exponents do: [:each| each == 0 ifFalse: [count _ count + 1]. count > 1 ifTrue: [^ false]].
	^ count = 1! !

!Monomial methodsFor: 'testing' stamp: 'len 1/9/2022 08:30:18'!
isSquarefree
	^ exponents allSatisfy: [:each| each == 0 or: [each == 1]]! !

!Monomial methodsFor: 'testing' stamp: 'len 6/6/2016 05:03'!
isUnivariateIn: anIndeterminate
	^ exponents isEmpty or: [(self at: anIndeterminate) = self degree]! !

!Monomial methodsFor: 'private' stamp: 'len 12/24/2023 09:18:38'!
exponents: anArray parent: aFreeAbelianMonoid
	exponents := anArray.
	parent := aFreeAbelianMonoid! !

!Monomial methodsFor: 'private' stamp: 'len 2/26/2017 10:37:42'!
parent: aFreeAbelianMonoid
	parent _ aFreeAbelianMonoid! !

!Monomial class methodsFor: 'instance creation' stamp: 'len 7/4/2022 12:30:24'!
exponents: anArray parent: aFreeAbelianMonoid
	^ self basicNew exponents: anArray parent: aFreeAbelianMonoid! !

!Monomial class methodsFor: 'instance creation' stamp: 'len 11/24/2016 10:58:05'!
new
	^ self shouldNotImplement! !

!Word methodsFor: 'accessing' stamp: 'len 12/4/2023 20:21:46'!
identity
	^ self parent identity! !

!Word methodsFor: 'accessing' stamp: 'len 1/10/2018 11:28:25'!
length
	syllables isEmpty ifTrue: [^ 0].
	^ syllables sum: [:each| each value abs]! !

!Word methodsFor: 'accessing' stamp: 'len 5/10/2019 14:41:44'!
parent
	^ parent! !

!Word methodsFor: 'accessing' stamp: 'len 3/3/2016 05:24'!
syllables
	^ syllables! !

!Word methodsFor: 'comparing' stamp: 'len 12/3/2023 21:20:29'!
< aWord
	^ (self compare: aWord) < 0! !

!Word methodsFor: 'comparing' stamp: 'len 12/3/2023 21:17:03'!
<= aWord
	^ (self compare: aWord) <= 0! !

!Word methodsFor: 'comparing' stamp: 'len 3/3/2016 05:23'!
= aWord
	^ syllables = aWord syllables! !

!Word methodsFor: 'comparing' stamp: 'len 12/4/2023 10:13:43'!
> aWord
	^ aWord < self! !

!Word methodsFor: 'comparing' stamp: 'len 12/4/2023 10:13:49'!
>= aWord
	^ aWord <= self! !

!Word methodsFor: 'comparing' stamp: 'len 1/10/2018 11:40:04'!
compare: aWord
	"Answer -1 if the receiver is < than the argument, 0 if they are equal, 1 if it is > than the argument.
	This is the noncommutative graded-lexicographical ordering."
	| result stream1 stream2 a1 a2 r1 r2 r x1 x2 |
	(result _ (self length - aWord length) sign) = 0 ifFalse: [^ result].
	self isEmpty ifTrue: [^ 0].
	stream1 _ syllables readStream.
	stream2 _ aWord syllables readStream.
	r1 _ 0.
	r2 _ 0.
	[r1 > 0 ifFalse: [a1 _ stream1 next. x1 _ a1 key. r1 _ a1 value].
	r2 > 0 ifFalse: [a2 _ stream2 next. x2 _ a2 key. r2 _ a2 value].
	r _ r1 min: r2.
	x1 < x2 ifTrue: [^ -1].
	x1 = x2 ifFalse: [^ 1].
	r1 _ r1 - r.
	r2 _ r2 - r.
	stream1 atEnd and: [stream2 atEnd]] whileFalse.
	^ 0! !

!Word methodsFor: 'comparing' stamp: 'len 3/3/2016 05:23'!
hash
	^ syllables hash! !

!Word methodsFor: 'copying' stamp: 'len 5/10/2019 17:16:33'!
copyWithout: anInteger
	^ self class syllables: (self syllables select: [:each| each key ~= anInteger])! !

!Word methodsFor: 'enumerating' stamp: 'len 5/10/2019 18:29:24'!
do: aBinaryBlock
	syllables do: [:each| aBinaryBlock value: each key value: each value]! !

!Word methodsFor: 'enumerating' stamp: 'len 6/3/2023 20:19:47'!
keysAndValuesDo: aBinaryBlock
	"Iterate over each indeterminate and exponent. For compatibility with Monomial and Tuple."
	syllables do: [:each| aBinaryBlock value: each key value: each value]! !

!Word methodsFor: 'operations' stamp: 'len 12/4/2023 20:29:37'!
* anElement
	^ self · anElement! !

!Word methodsFor: 'operations' stamp: 'len 12/4/2023 20:28:06'!
^ anInteger
	"Answer the receiver composed with itself anInteger times.
	If the argument is another group element, answer the conjugation."
	anInteger isInteger ifFalse: [^ anInteger · self · anInteger inverse].
	anInteger = 1 ifTrue: [^ self].
	anInteger = 0 ifTrue: [^ self identity].
	anInteger < 0 ifTrue: [^ self inverse ^ anInteger negated].
	^ anInteger even ifTrue: [self · self ^ (anInteger // 2)] ifFalse: [self · self ^ (anInteger // 2) · self]! !

!Word methodsFor: 'operations' stamp: 'len 4/5/2024 18:58:26'!
· aWord
	| x y |
	self isEmpty ifTrue: [^ aWord].
	aWord isEmpty ifTrue: [^ self].
	parent = aWord parent ifFalse: [self error: 'words with different parents'].
	syllables last key = aWord syllables first key
		ifFalse: [^ (self class syllables: syllables, aWord syllables) parent: parent].
	x := syllables as: OrderedCollection.
	y := aWord syllables as: OrderedCollection.
	[x notEmpty and: [y notEmpty and: [x last key = y first key]]]
		whileTrue:
			[| xn y1 exponent |
			xn := x removeLast.
			y1 := y removeFirst.
			(exponent := xn value + y1 value) = 0
				ifFalse: [^ (self class syllables: (x, {Association key: xn key value: exponent}, y) asArray) parent: parent]].
	^ (self class syllables: (x, y) asArray) parent: parent! !

!Word methodsFor: 'operations' stamp: 'len 5/15/2019 03:14:42'!
eq: aWord
	"Answer the relator for the relation that equates the receiver to the argument."
	^ self · aWord inverse! !

!Word methodsFor: 'operations' stamp: 'len 5/10/2019 16:13:38'!
inverse
	^ (self class syllables: (syllables collect: [:each| Association key: each key value: each value negated]) reversed) parent: parent! !

!Word methodsFor: 'operations' stamp: 'len 5/10/2019 16:13:47'!
reversed
	^ (self class syllables: syllables reversed) parent: parent! !

!Word methodsFor: 'operations' stamp: 'len 12/4/2023 20:25:01'!
squared
	^ self · self! !

!Word methodsFor: 'printing' stamp: 'len 5/6/2023 15:20:38'!
printLetter: letter on: aStream
	letter isInteger
		ifFalse:
			[letter class = self class
				ifTrue: [aStream nextPut: $(; print: letter; nextPut: $)]
				ifFalse: [(aStream isText and: [letter isString])
					ifTrue: [aStream nextPutAll: letter asText]
					ifFalse: [aStream print: letter]].
			^ self].
	aStream nextPut: $x; nextPutAll: letter printStringSubscript! !

!Word methodsFor: 'printing' stamp: 'len 5/6/2023 15:36:09'!
printOn: aStream
	self isEmpty ifTrue: [aStream nextPut: $ε. ^ self].
	self do: [:each :r|
		r = 0 ifFalse:
			[| x |
			x _ self parent names ifNil: [each] ifNotNil: [:names| names at: each ifAbsent: [each]].
			self printLetter: x on: aStream.
			r = 1 ifFalse: [aStream nextPutAll: r printString super]]]! !

!Word methodsFor: 'testing' stamp: 'len 3/3/2016 05:23'!
isEmpty
	^ syllables isEmpty! !

!Word methodsFor: 'testing' stamp: 'len 12/4/2023 20:32:14'!
isIdentity
	^ self = self identity! !

!Word methodsFor: 'testing' stamp: 'len 1/10/2018 16:54:56'!
isStandard
	"Answer true if the receiver is a standard word, i.e. if the symbols appear in ascending order."
	syllables size < 2 ifTrue: [^ true].
	1 to: syllables size - 1 do: [:i|
		(syllables at: i) key < (syllables at: i+1) key
			ifFalse: [^ false]].
	^ true! !

!Word methodsFor: 'private' stamp: 'len 5/10/2019 14:41:37'!
parent: aDomain
	parent _ aDomain! !

!Word methodsFor: 'private' stamp: 'len 3/3/2016 05:21'!
syllables: anArray
	syllables _ anArray! !

!Word class methodsFor: 'instance creation' stamp: 'len 6/30/2016 02:31'!
empty
	^ self syllables: #()! !

!Word class methodsFor: 'instance creation' stamp: 'len 6/30/2016 02:31'!
new
	^ self shouldNotImplement! !

!Word class methodsFor: 'instance creation' stamp: 'len 6/30/2016 02:30'!
syllables: anArray
	^ self basicNew syllables: anArray! !

!Word class methodsFor: 'instance creation' stamp: 'len 2/12/2016 07:30'!
x: i
	^ self x: i to: 1! !

!Word class methodsFor: 'instance creation' stamp: 'len 6/29/2023 19:51:50'!
x: i to: k
	"Answer a new instance of the receiver with only one indeterminate, xᵢ, raised to n."
	k = 0 ifTrue: [^ self empty].
	^ self syllables: {i -> k}! !

!MonomialOrdering methodsFor: 'accessing' stamp: 'len 7/4/2016 00:40'!
indeterminates
	^ indeterminates! !

!MonomialOrdering methodsFor: 'accessing' stamp: 'len 7/4/2016 00:40'!
rank
	^ indeterminates size! !

!MonomialOrdering methodsFor: 'accessing' stamp: 'len 7/2/2016 23:33'!
type
	^ nil! !

!MonomialOrdering methodsFor: 'accessing' stamp: 'len 7/6/2022 06:08:07'!
weightOf: anIndeterminate
	^ 1! !

!MonomialOrdering methodsFor: 'comparing' stamp: 'len 8/8/2019 04:55:44'!
= anObject
	self == anObject ifTrue: [^ true].
	^ self class = anObject class and: [indeterminates = anObject indeterminates]! !

!MonomialOrdering methodsFor: 'comparing' stamp: 'len 2/3/2017 07:14:12'!
hash
	^ self type hash! !

!MonomialOrdering methodsFor: 'operations' stamp: 'len 3/6/2021 14:57:57'!
, aMonomialOrdering
	(self type notNil and: [aMonomialOrdering type notNil]) ifFalse: [^ self notYetImplemented].
	^ BlockMonomialOrdering blocks: {self. aMonomialOrdering}! !

!MonomialOrdering methodsFor: 'operations' stamp: 'len 3/6/2021 14:53:04'!
× aMonomialOrdering
	"Answer the product of the monomial ordering, shifting indeterminates to correct for the new rank."
	(self type notNil and: [self type = aMonomialOrdering type])
		ifTrue: [^ self class indeterminates: self indeterminates, (aMonomialOrdering indeterminates collect: [:i| i + self rank])].
	^ self, (aMonomialOrdering substitute: [:i| i + self rank])! !

!MonomialOrdering methodsFor: 'operations' stamp: 'len 3/6/2021 15:00:56'!
slice: anArray
	"Answer the ordering corresponding to a subset of the indeterminates."
	self type notNil ifFalse: [^ self subclassResponsibility].
	^ self class new: anArray size! !

!MonomialOrdering methodsFor: 'operations' stamp: 'len 3/6/2021 15:00:14'!
substitute: aBlock
	"Answer a new ordering like the receiver but substituting indeterminates by aBlock."
	self type notNil ifFalse: [^ self subclassResponsibility].
	^ self class indeterminates: (self indeterminates collect: aBlock)! !

!MonomialOrdering methodsFor: 'ordering' stamp: 'len 1/28/2017 09:51:49'!
blockCompare: aMonomial with: anotherMonomial
	^ self compare: aMonomial with: anotherMonomial! !

!MonomialOrdering methodsFor: 'ordering' stamp: 'len 11/21/2016 08:42:01'!
compare: aMonomial with: anotherMonomial
	^ self subclassResponsibility! !

!MonomialOrdering methodsFor: 'printing' stamp: 'len 3/6/2021 12:54:01'!
printOn: aStream
	| M |
	self type isNil
		ifTrue: [super printOn: aStream]
		ifFalse: [aStream nextPutAll: self type].
	M _ FreeAbelianMonoid new: indeterminates max.
	aStream nextPut: $[.
	indeterminates do: [:i| aStream print: (M x: i)] separatedBy: [aStream nextPut: $,].
	aStream nextPut: $]! !

!MonomialOrdering methodsFor: 'testing' stamp: 'len 1/26/2017 22:27:21'!
isGlobal
	"Answer true if the receiver is a noetherian or global ordering (as opposed to a local ordering).
	Global orderings satisfy 1 < m for all nontrivial monomials m."
	^ false! !

!MonomialOrdering methodsFor: 'testing' stamp: 'len 10/28/2016 10:43'!
isGraded
	"Answer true if the receiver is a graded (also called total) ordering."
	^ false! !

!MonomialOrdering methodsFor: 'testing' stamp: 'len 7/31/2021 10:55:26'!
isGradedWeighted
	^ false! !

!MonomialOrdering methodsFor: 'testing' stamp: 'len 1/22/2017 21:53:20'!
isLocal
	"Answer true if the receiver is a local (or non-noetherian) ordering.
	Local orderings satisfy 1 > m for all nontrivial monomials m."
	^ false! !

!MonomialOrdering methodsFor: 'private' stamp: 'len 7/6/2022 05:45:07'!
degreeOf: anArray
	^ anArray isEmpty ifTrue: [0] ifFalse: [anArray sum]! !

!MonomialOrdering methodsFor: 'private' stamp: 'len 5/6/2023 18:48:38'!
degreeOf: anArray in: anIndeterminate
	^ anArray at: anIndeterminate! !

!MonomialOrdering methodsFor: 'private' stamp: 'len 3/6/2021 14:47:17'!
indeterminates: anArray
	indeterminates _ anArray asArray! !

!MonomialOrdering class methodsFor: 'examples' stamp: 'len 2/12/2017 06:06:37'!
glex: anArray
	^ GradedLexicographicOrdering indeterminates: anArray! !

!MonomialOrdering class methodsFor: 'examples' stamp: 'len 2/12/2017 06:06:43'!
grevlex: anArray
	^ GradedReverseLexicographicOrdering indeterminates: anArray! !

!MonomialOrdering class methodsFor: 'examples' stamp: 'len 7/31/2021 10:59:31'!
grevlex: anArray weights: anotherArray
	^ GradedReverseLexicographicWeightedOrdering indeterminates: anArray weights: anotherArray! !

!MonomialOrdering class methodsFor: 'examples' stamp: 'len 7/30/2021 13:27:29'!
invlex: anArray
	^ LexicographicOrdering indeterminates: anArray reversed! !

!MonomialOrdering class methodsFor: 'examples' stamp: 'len 7/4/2016 00:45'!
lex: anArray
	^ LexicographicOrdering indeterminates: anArray! !

!MonomialOrdering class methodsFor: 'examples' stamp: 'len 2/12/2017 06:01:42'!
lglex: anArray
	^ LocalGradedLexicographicOrdering indeterminates: anArray! !

!MonomialOrdering class methodsFor: 'examples' stamp: 'len 2/12/2017 06:02:42'!
lgrevlex: anArray
	^ LocalGradedReverseLexicographicOrdering indeterminates: anArray! !

!MonomialOrdering class methodsFor: 'examples' stamp: 'len 1/19/2017 07:28:23'!
llex: anArray
	^ LocalLexicographicOrdering indeterminates: anArray! !

!MonomialOrdering class methodsFor: 'instance creation' stamp: 'len 1/28/2017 10:04:02'!
indeterminates: anArray
	anArray isInteger ifTrue: [^ self new: anArray].
	^ self new indeterminates: anArray! !

!MonomialOrdering class methodsFor: 'instance creation' stamp: 'len 1/28/2017 10:04:09'!
new: anInteger
	^ self new indeterminates: (1 to: anInteger)! !

!BlockMonomialOrdering methodsFor: 'accessing' stamp: 'len 6/20/2023 21:26:37'!
blocks
	^ blocks! !

!BlockMonomialOrdering methodsFor: 'comparing' stamp: 'len 8/8/2019 04:54:50'!
= anObject
	self == anObject ifTrue: [^ true].
	^ self class = anObject class and: [blocks = anObject blocks]! !

!BlockMonomialOrdering methodsFor: 'comparing' stamp: 'len 8/8/2019 04:55:01'!
hash
	^ blocks hash! !

!BlockMonomialOrdering methodsFor: 'operations' stamp: 'len 3/6/2021 20:59:57'!
slice: anArray
	"Answer the ordering corresponding to a subset of the indeterminates."
	| answerBlocks |
	answerBlocks _ OrderedCollection new.
	blocks do: [:each|
		| subset |
		subset _ anArray select: [:i| each indeterminates includes: i].
		subset notEmpty ifTrue: [answerBlocks add: (each slice: subset)]].
	answerBlocks size = 1 ifTrue: [^ answerBlocks first].
	^ self class blocks: answerBlocks! !

!BlockMonomialOrdering methodsFor: 'ordering' stamp: 'len 7/31/2021 10:11:35'!
compare: aMonomial with: anotherMonomial
	| answer |
	blocks do: [:each| (answer _ each blockCompare: aMonomial with: anotherMonomial) == 0 ifFalse: [^ answer]].
	^ answer! !

!BlockMonomialOrdering methodsFor: 'printing' stamp: 'len 3/4/2021 15:58:54'!
printOn: aStream
	blocks do: [:each| aStream print: each] separatedBy: [aStream nextPutAll: ' × ']! !

!BlockMonomialOrdering methodsFor: 'testing' stamp: 'len 1/28/2017 09:18:31'!
isGlobal
	^ blocks allSatisfy: [:each| each isGlobal]! !

!BlockMonomialOrdering methodsFor: 'testing' stamp: 'len 1/28/2017 09:30:58'!
isLocal
	^ blocks allSatisfy: [:each| each isLocal]! !

!BlockMonomialOrdering methodsFor: 'private' stamp: 'len 1/28/2017 09:43:49'!
blocks: anArray
	blocks _ anArray.
	indeterminates _ Array streamContents: [:aStream| blocks do: [:each| aStream nextPutAll: each indeterminates]]! !

!BlockMonomialOrdering class methodsFor: 'instance creation' stamp: 'len 1/28/2017 09:46:11'!
blocks: anArray
	^ self new blocks: anArray! !

!GradedLexicographicOrdering methodsFor: 'accessing' stamp: 'len 2/12/2017 06:05:25'!
type
	^ #glex! !

!GradedLexicographicOrdering methodsFor: 'ordering' stamp: 'len 1/28/2017 09:55:07'!
blockCompare: aMonomial with: anotherMonomial
	| d1 d2 e1 e2 n1 n2 |
	e1 _ aMonomial exponents.
	e2 _ anotherMonomial exponents.
	n1 _ e1 size.
	n2 _ e2 size.

	d1 _ 0.
	d2 _ 0.
	1 to: indeterminates size do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		xi <= n1 ifTrue: [d1 _ d1 + (e1 at: xi)].
		xi <= n2 ifTrue: [d2 _ d2 + (e2 at: xi)]].
	d1 > d2 ifTrue: [^ 1].
	d1 = d2 ifFalse: [^ -1].

	1 to: indeterminates size do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		a _ xi <= n1 ifTrue: [e1 at: xi] ifFalse: [0].
		b _ xi <= n2 ifTrue: [e2 at: xi] ifFalse: [0].
		a > b ifTrue: [^ 1].
		a = b ifFalse: [^ -1]].
	^ 0! !

!GradedLexicographicOrdering methodsFor: 'ordering' stamp: 'len 11/21/2016 13:43:16'!
compare: aMonomial with: anotherMonomial
	| d1 d2 e1 e2 n1 n2 |
	(d1 _ aMonomial degree) > (d2 _ anotherMonomial degree) ifTrue: [^ 1].
	d1 = d2 ifFalse: [^ -1].
	e1 _ aMonomial exponents.
	e2 _ anotherMonomial exponents.
	n1 _ e1 size.
	n2 _ e2 size.
	1 to: indeterminates size do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		a _ xi <= n1 ifTrue: [e1 at: xi] ifFalse: [0].
		b _ xi <= n2 ifTrue: [e2 at: xi] ifFalse: [0].
		a > b ifTrue: [^ 1].
		a = b ifFalse: [^ -1]].
	^ 0! !

!GradedLexicographicOrdering methodsFor: 'testing' stamp: 'len 1/26/2017 22:27:59'!
isGlobal
	^ true! !

!GradedLexicographicOrdering methodsFor: 'testing' stamp: 'len 7/6/2016 08:27'!
isGraded
	^ true! !

!GradedReverseLexicographicOrdering methodsFor: 'accessing' stamp: 'len 2/12/2017 06:07:37'!
type
	^ #grevlex! !

!GradedReverseLexicographicOrdering methodsFor: 'ordering' stamp: 'len 5/7/2023 00:32:39'!
blockCompare: aMonomial with: anotherMonomial
	| d1 d2 n1 n2 e1 e2 |
	e1 _ aMonomial exponents.
	e2 _ anotherMonomial exponents.
	n1 _ e1 size.
	n2 _ e2 size.
	
	d1 _ 0.
	d2 _ 0.
	1 to: indeterminates size do: [:i|
		| xi |
		xi _ indeterminates at: i.
		xi <= n1 ifTrue: [d1 _ d1 + (e1 at: xi)].
		xi <= n2 ifTrue: [d2 _ d2 + (e2 at: xi)]].
	d1 > d2 ifTrue: [^ 1].
	d1 = d2 ifFalse: [^ -1].

	indeterminates size to: 1 by: -1 do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		a _ xi <= n1 ifTrue: [e1 at: xi] ifFalse: [0].
		b _ xi <= n2 ifTrue: [e2 at: xi] ifFalse: [0].
		a < b ifTrue: [^ 1].
		a = b ifFalse: [^ -1]].
	^ 0! !

!GradedReverseLexicographicOrdering methodsFor: 'ordering' stamp: 'len 11/21/2016 12:20:07'!
compare: aMonomial with: anotherMonomial
	| d1 d2 n1 n2 e1 e2 |
	(d1 _ aMonomial degree) > (d2 _ anotherMonomial degree) ifTrue: [^ 1].
	d1 = d2 ifFalse: [^ -1].
	e1 _ aMonomial exponents.
	e2 _ anotherMonomial exponents.
	n1 _ e1 size.
	n2 _ e2 size.
	indeterminates size to: 1 by: -1 do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		a _ xi <= n1 ifTrue: [e1 at: xi] ifFalse: [0].
		b _ xi <= n2 ifTrue: [e2 at: xi] ifFalse: [0].
		a < b ifTrue: [^ 1].
		a = b ifFalse: [^ -1]].
	^ 0! !

!GradedReverseLexicographicOrdering methodsFor: 'testing' stamp: 'len 1/26/2017 22:28:06'!
isGlobal
	^ true! !

!GradedReverseLexicographicOrdering methodsFor: 'testing' stamp: 'len 7/6/2016 08:27'!
isGraded
	^ true! !

!GradedReverseLexicographicWeightedOrdering methodsFor: 'accessing' stamp: 'len 7/31/2021 10:58:42'!
type
	^ #grevlexw! !

!GradedReverseLexicographicWeightedOrdering methodsFor: 'accessing' stamp: 'len 5/6/2023 18:59:30'!
weightOf: anIndeterminate
	^ weights at: anIndeterminate! !

!GradedReverseLexicographicWeightedOrdering methodsFor: 'accessing' stamp: 'len 7/31/2021 10:19:43'!
weights
	^ weights! !

!GradedReverseLexicographicWeightedOrdering methodsFor: 'ordering' stamp: 'len 5/7/2023 00:38:36'!
blockCompare: aMonomial with: anotherMonomial
	| d1 d2 n1 n2 e1 e2 |
	e1 _ aMonomial exponents.
	e2 _ anotherMonomial exponents.
	n1 _ e1 size.
	n2 _ e2 size.
	
	d1 _ 0.
	d2 _ 0.
	1 to: indeterminates size do: [:i|
		| xi w |
		xi _ indeterminates at: i.
		w _ weights at: xi.
		xi <= n1 ifTrue: [d1 _ (e1 at: xi) * w + d1].
		xi <= n2 ifTrue: [d2 _ (e2 at: xi) * w + d2]].
	d1 > d2 ifTrue: [^ 1].
	d1 = d2 ifFalse: [^ -1].

	indeterminates size to: 1 by: -1 do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		a _ xi <= n1 ifTrue: [e1 at: xi] ifFalse: [0].
		b _ xi <= n2 ifTrue: [e2 at: xi] ifFalse: [0].
		a < b ifTrue: [^ 1].
		a = b ifFalse: [^ -1]].
	^ 0! !

!GradedReverseLexicographicWeightedOrdering methodsFor: 'testing' stamp: 'len 7/31/2021 10:55:36'!
isGradedWeighted
	^ true! !

!GradedReverseLexicographicWeightedOrdering methodsFor: 'private' stamp: 'len 5/4/2023 17:41:46'!
degreeOf: anArray
	| answer |
	answer _ 0.
	indeterminates with: weights do: [:i :w| answer _ (anArray at: i) * w + answer].
	^ answer! !

!GradedReverseLexicographicWeightedOrdering methodsFor: 'private' stamp: 'len 5/6/2023 18:50:30'!
degreeOf: anArray in: anIndeterminate
	^ (anArray at: anIndeterminate) * (weights at: anIndeterminate)! !

!GradedReverseLexicographicWeightedOrdering methodsFor: 'private' stamp: 'len 7/31/2021 10:20:46'!
weights: anArray
	weights _ anArray! !

!GradedReverseLexicographicWeightedOrdering class methodsFor: 'instance creation' stamp: 'len 7/31/2021 10:58:11'!
indeterminates: anArray
	^ self shouldNotImplement! !

!GradedReverseLexicographicWeightedOrdering class methodsFor: 'instance creation' stamp: 'len 7/31/2021 10:57:59'!
indeterminates: anArray weights: anotherArray
	^ self new indeterminates: anArray; weights: anotherArray! !

!LexicographicOrdering methodsFor: 'accessing' stamp: 'len 7/2/2016 23:26'!
type
	^ #lex! !

!LexicographicOrdering methodsFor: 'ordering' stamp: 'len 11/21/2016 13:40:59'!
compare: aMonomial with: anotherMonomial
	| e1 e2 n1 n2 |
	e1 _ aMonomial exponents.
	e2 _ anotherMonomial exponents.
	n1 _ e1 size.
	n2 _ e2 size.
	1 to: indeterminates size do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		a _ xi <= n1 ifTrue: [e1 at: xi] ifFalse: [0].
		b _ xi <= n2 ifTrue: [e2 at: xi] ifFalse: [0].
		a > b ifTrue: [^ 1].
		a = b ifFalse: [^ -1]].
	^ 0! !

!LexicographicOrdering methodsFor: 'testing' stamp: 'len 1/26/2017 22:27:28'!
isGlobal
	^ true! !

!LocalGradedLexicographicOrdering methodsFor: 'accessing' stamp: 'len 2/12/2017 06:02:13'!
type
	^ #lglex! !

!LocalGradedLexicographicOrdering methodsFor: 'ordering' stamp: 'len 1/28/2017 09:56:50'!
blockCompare: aMonomial with: anotherMonomial
	| d1 d2 e1 e2 n1 n2 |
	e1 _ aMonomial exponents.
	e2 _ anotherMonomial exponents.
	n1 _ e1 size.
	n2 _ e2 size.

	d1 _ 0.
	d2 _ 0.
	1 to: indeterminates size do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		xi <= n1 ifTrue: [d1 _ d1 + (e1 at: xi)].
		xi <= n2 ifTrue: [d2 _ d2 + (e2 at: xi)]].
	d1 < d2 ifTrue: [^ 1].
	d1 = d2 ifFalse: [^ -1].

	indeterminates size to: 1 by: -1 do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		a _ xi <= n1 ifTrue: [e1 at: xi] ifFalse: [0].
		b _ xi <= n2 ifTrue: [e2 at: xi] ifFalse: [0].
		a < b ifTrue: [^ 1].
		a = b ifFalse: [^ -1]].
	^ 0! !

!LocalGradedLexicographicOrdering methodsFor: 'ordering' stamp: 'len 1/26/2017 08:46:40'!
compare: aMonomial with: anotherMonomial
	| d1 d2 e1 e2 n1 n2 |
	(d1 _ aMonomial degree) < (d2 _ anotherMonomial degree) ifTrue: [^ 1].
	d1 = d2 ifFalse: [^ -1].
	e1 _ aMonomial exponents.
	e2 _ anotherMonomial exponents.
	n1 _ e1 size.
	n2 _ e2 size.
	indeterminates size to: 1 by: -1 do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		a _ xi <= n1 ifTrue: [e1 at: xi] ifFalse: [0].
		b _ xi <= n2 ifTrue: [e2 at: xi] ifFalse: [0].
		a < b ifTrue: [^ 1].
		a = b ifFalse: [^ -1]].
	^ 0! !

!LocalGradedLexicographicOrdering methodsFor: 'testing' stamp: 'len 1/19/2017 08:09:27'!
isGraded
	^ true! !

!LocalGradedLexicographicOrdering methodsFor: 'testing' stamp: 'len 1/19/2017 08:03:51'!
isLocal
	^ true! !

!LocalGradedReverseLexicographicOrdering methodsFor: 'accessing' stamp: 'len 2/12/2017 06:03:00'!
type
	^ #lgrevlex! !

!LocalGradedReverseLexicographicOrdering methodsFor: 'ordering' stamp: 'len 1/28/2017 09:57:27'!
blockCompare: aMonomial with: anotherMonomial
	| d1 d2 e1 e2 n1 n2 |
	e1 _ aMonomial exponents.
	e2 _ anotherMonomial exponents.
	n1 _ e1 size.
	n2 _ e2 size.

	d1 _ 0.
	d2 _ 0.
	1 to: indeterminates size do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		xi <= n1 ifTrue: [d1 _ d1 + (e1 at: xi)].
		xi <= n2 ifTrue: [d2 _ d2 + (e2 at: xi)]].
	d1 < d2 ifTrue: [^ 1].
	d1 = d2 ifFalse: [^ -1].

	1 to: indeterminates size do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		a _ xi <= n1 ifTrue: [e1 at: xi] ifFalse: [0].
		b _ xi <= n2 ifTrue: [e2 at: xi] ifFalse: [0].
		"a > b ifTrue: [^ 1]." "Magma handbook and Using Algebraic Geometry contradict each other"
		a < b ifTrue: [^ 1].
		a = b ifFalse: [^ -1]].
	^ 0! !

!LocalGradedReverseLexicographicOrdering methodsFor: 'ordering' stamp: 'len 1/28/2017 12:37:48'!
compare1: aMonomial with: anotherMonomial
	"This follows Magma conventions."
	| d1 d2 e1 e2 n1 n2 |
	(d1 _ aMonomial degree) < (d2 _ anotherMonomial degree) ifTrue: [^ 1].
	d1 = d2 ifFalse: [^ -1].
	e1 _ aMonomial exponents.
	e2 _ anotherMonomial exponents.
	n1 _ e1 size.
	n2 _ e2 size.
	1 to: indeterminates size do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		a _ xi <= n1 ifTrue: [e1 at: xi] ifFalse: [0].
		b _ xi <= n2 ifTrue: [e2 at: xi] ifFalse: [0].
		a < b ifTrue: [^ 1].
		a = b ifFalse: [^ -1]].
	^ 0! !

!LocalGradedReverseLexicographicOrdering methodsFor: 'ordering' stamp: 'len 1/28/2017 12:37:26'!
compare2: aMonomial with: anotherMonomial
	"This is Singular's 'ds' ordering (indeterminates are reversed)."
	| d1 d2 e1 e2 n1 n2 |
	(d1 _ aMonomial degree) < (d2 _ anotherMonomial degree) ifTrue: [^ 1].
	d1 = d2 ifFalse: [^ -1].
	e1 _ aMonomial exponents.
	e2 _ anotherMonomial exponents.
	n1 _ e1 size.
	n2 _ e2 size.
	indeterminates size to: 1 by: -1 do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		a _ xi <= n1 ifTrue: [e1 at: xi] ifFalse: [0].
		b _ xi <= n2 ifTrue: [e2 at: xi] ifFalse: [0].
		a < b ifTrue: [^ 1].
		a = b ifFalse: [^ -1]].
	^ 0! !

!LocalGradedReverseLexicographicOrdering methodsFor: 'ordering' stamp: 'len 1/28/2017 12:38:26'!
compare: aMonomial with: anotherMonomial
	"This follows Magma conventions."
	| d1 d2 e1 e2 n1 n2 |
	(d1 _ aMonomial degree) < (d2 _ anotherMonomial degree) ifTrue: [^ 1].
	d1 = d2 ifFalse: [^ -1].
	e1 _ aMonomial exponents.
	e2 _ anotherMonomial exponents.
	n1 _ e1 size.
	n2 _ e2 size.
	1 to: indeterminates size do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		a _ xi <= n1 ifTrue: [e1 at: xi] ifFalse: [0].
		b _ xi <= n2 ifTrue: [e2 at: xi] ifFalse: [0].
		a < b ifTrue: [^ 1].
		a = b ifFalse: [^ -1]].
	^ 0! !

!LocalGradedReverseLexicographicOrdering methodsFor: 'testing' stamp: 'len 11/22/2016 14:56:05'!
isGraded
	^ true! !

!LocalGradedReverseLexicographicOrdering methodsFor: 'testing' stamp: 'len 11/22/2016 14:56:02'!
isLocal
	^ true! !

!LocalLexicographicOrdering methodsFor: 'accessing' stamp: 'len 1/19/2017 07:29:54'!
type
	^ #llex! !

!LocalLexicographicOrdering methodsFor: 'ordering' stamp: 'len 1/28/2017 12:33:32'!
compare1: aMonomial with: anotherMonomial
	"This is Magma's 'llex' ordering."
	| e1 e2 n1 n2 |
	e1 _ aMonomial exponents.
	e2 _ anotherMonomial exponents.
	n1 _ e1 size.
	n2 _ e2 size.
	indeterminates size to: 1 by: -1 do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		a _ xi <= n1 ifTrue: [e1 at: xi] ifFalse: [0].
		b _ xi <= n2 ifTrue: [e2 at: xi] ifFalse: [0].
		a < b ifTrue: [^ 1].
		a = b ifFalse: [^ -1]].
	^ 0! !

!LocalLexicographicOrdering methodsFor: 'ordering' stamp: 'len 1/28/2017 12:33:15'!
compare2: aMonomial with: anotherMonomial
	"This is Singular's 'ls' ordering (indeterminates are reversed)."
	| e1 e2 n1 n2 |
	e1 _ aMonomial exponents.
	e2 _ anotherMonomial exponents.
	n1 _ e1 size.
	n2 _ e2 size.
	1 to: indeterminates size do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		a _ xi <= n1 ifTrue: [e1 at: xi] ifFalse: [0].
		b _ xi <= n2 ifTrue: [e2 at: xi] ifFalse: [0].
		a < b ifTrue: [^ 1].
		a = b ifFalse: [^ -1]].
	^ 0! !

!LocalLexicographicOrdering methodsFor: 'ordering' stamp: 'len 1/28/2017 12:31:30'!
compare: aMonomial with: anotherMonomial
	| e1 e2 n1 n2 |
	e1 _ aMonomial exponents.
	e2 _ anotherMonomial exponents.
	n1 _ e1 size.
	n2 _ e2 size.
	indeterminates size to: 1 by: -1 do: [:i|
		| xi a b |
		xi _ indeterminates at: i.
		a _ xi <= n1 ifTrue: [e1 at: xi] ifFalse: [0].
		b _ xi <= n2 ifTrue: [e2 at: xi] ifFalse: [0].
		a < b ifTrue: [^ 1].
		a = b ifFalse: [^ -1]].
	^ 0! !

!LocalLexicographicOrdering methodsFor: 'testing' stamp: 'len 10/28/2016 10:44'!
isLocal
	^ true! !

!GroupElement methodsFor: 'testing' stamp: 'len 4/23/2024 05:00:14'!
isIdentity
	^ self = self identity! !

!GroupElement methodsFor: 'operations' stamp: 'len 4/23/2024 05:03:28'!
* anElement
	^ self · anElement! !

!GroupElement methodsFor: 'operations' stamp: 'len 4/23/2024 05:03:12'!
^ anInteger
	"Answer the receiver composed with itself anInteger times.
	If the argument is another group element, answer the conjugation."
	anInteger isInteger ifFalse: [^ anInteger · self · anInteger inverse].
	anInteger = 1 ifTrue: [^ self].
	anInteger = 0 ifTrue: [^ self identity].
	anInteger < 0 ifTrue: [^ self inverse ^ anInteger negated].
	^ anInteger even ifTrue: [self · self ^ (anInteger // 2)] ifFalse: [self · self ^ (anInteger // 2) · self]! !

!GroupElement methodsFor: 'operations' stamp: 'len 4/23/2024 04:59:49'!
log
	^ self parent logarithmOf: self! !

!GroupElement methodsFor: 'operations' stamp: 'len 4/23/2024 04:59:44'!
log: α
	^ self parent logarithmOf: self base: α! !

!GroupElement methodsFor: 'operations' stamp: 'len 4/23/2024 05:06:37'!
order
	^ self parent orderOf: self! !

!Coset methodsFor: 'accessing' stamp: 'len 12/4/2023 20:21:28'!
identity
	^ self parent identity! !

!Coset methodsFor: 'accessing' stamp: 'len 6/14/2022 12:47:00'!
parent
	^ parent! !

!Coset methodsFor: 'accessing' stamp: 'len 11/25/2015 02:29'!
representative
	^ representative! !

!Coset methodsFor: 'comparing' stamp: 'len 6/14/2022 12:44:13'!
= anObject
	(self class = anObject class and: [parent = anObject parent]) ifFalse: [^ false].
	^ self contains: anObject representative! !

!Coset methodsFor: 'comparing' stamp: 'len 6/14/2022 12:44:24'!
hash
	^ parent hash! !

!Coset methodsFor: 'enumerating' stamp: 'len 8/29/2024 15:17:40'!
do: aBlock
	parent cover isAbelianGroup
		ifTrue: [parent relations do: [:each| aBlock value: each + representative]]
		ifFalse: [parent relations do: [:each| aBlock value: each · representative]]! !

!Coset methodsFor: 'operations' stamp: 'len 8/29/2024 15:17:39'!
· aCoset
	^ self class
		representative:
			(parent cover isAbelianGroup
				ifTrue: [representative + aCoset representative]
				ifFalse: [representative · aCoset representative])
		parent: parent! !

!Coset methodsFor: 'operations' stamp: 'len 8/29/2024 15:17:39'!
inverse
	^ self class
		representative:
			(parent cover isAbelianGroup
				ifTrue: [representative negated]
				ifFalse: [representative inverse])
		parent: parent! !

!Coset methodsFor: 'printing' stamp: 'len 6/14/2022 12:47:38'!
printOn: aStream
	aStream print: representative! !

!Coset methodsFor: 'testing' stamp: 'len 8/29/2024 15:17:39'!
contains: anElement
	^ parent relations contains:
		(parent cover isAbelianGroup
			ifTrue: [anElement - representative]
			ifFalse: [anElement · representative inverse])! !

!Coset methodsFor: 'testing' stamp: 'len 6/14/2022 12:49:11'!
includes: anObject
	^ (parent cover includes: anObject) and: [self contains: anObject]! !

!Coset methodsFor: 'private' stamp: 'len 4/23/2024 04:58:58'!
representative: anElement parent: aQuotientGroup
	representative := anElement.
	parent := aQuotientGroup! !

!Coset class methodsFor: 'instance creation' stamp: 'len 4/23/2024 04:58:35'!
representative: anElement parent: aQuotientGroup
	^ self new representative: anElement parent: aQuotientGroup! !

!ProductGroupElement methodsFor: 'accessing' stamp: 'len 4/25/2020 06:38:06'!
at: anInteger
	^ components at: anInteger! !

!ProductGroupElement methodsFor: 'accessing' stamp: 'len 4/25/2020 06:38:11'!
parent
	^ parent! !

!ProductGroupElement methodsFor: 'accessing' stamp: 'len 4/25/2020 06:38:16'!
size
	^ components size! !

!ProductGroupElement methodsFor: 'comparing' stamp: 'len 4/25/2020 06:38:33'!
= anObject
	^ self class = anObject class and: [components = anObject components]! !

!ProductGroupElement methodsFor: 'comparing' stamp: 'len 4/25/2020 06:38:37'!
hash
	^ components hash! !

!ProductGroupElement methodsFor: 'operations' stamp: 'len 8/29/2024 15:17:39'!
· anElement
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #·].
	^ self class components: (components withIndexCollect: [:each :i| (parent at: i) isAbelianGroup ifTrue: [each + (anElement at: i)] ifFalse: [each · (anElement at: i)]]) parent: parent! !

!ProductGroupElement methodsFor: 'operations' stamp: 'len 8/29/2024 15:17:40'!
inverse
	^ self class components: (components with: parent components collect: [:g :G| G isAbelianGroup ifTrue: [g negated] ifFalse: [g inverse]]) parent: parent! !

!ProductGroupElement methodsFor: 'printing' stamp: 'len 4/25/2020 06:38:47'!
printOn: aStream
	aStream print: components! !

!ProductGroupElement methodsFor: 'private' stamp: 'len 4/25/2020 06:39:26'!
components
	^ components! !

!ProductGroupElement methodsFor: 'private' stamp: 'len 11/24/2022 17:49:10'!
components: anArray parent: aDirectProductGroup
	components _ anArray.
	parent _ aDirectProductGroup! !

!ProductGroupElement class methodsFor: 'instance creation' stamp: 'len 5/7/2023 17:24:17'!
components: anArray parent: aGroup
	^ self new components: anArray parent: aGroup! !

!SemidirectProductElement methodsFor: 'accessing' stamp: 'len 5/5/98 00:18'!
left
	"Answer the left component of the receiver."
	^ left! !

!SemidirectProductElement methodsFor: 'accessing' stamp: 'len 10/6/2016 15:37'!
parent
	^ parent! !

!SemidirectProductElement methodsFor: 'accessing' stamp: 'len 5/5/98 00:18'!
right
	"Answer the right component of the receiver."
	^ right! !

!SemidirectProductElement methodsFor: 'constants' stamp: 'len 1/23/2017 11:46:24'!
identity
	^ self parent identity! !

!SemidirectProductElement methodsFor: 'operations' stamp: 'len 5/5/2019 18:19:05'!
· aSemidirectProduct
	^ self parent
		project:
			{left · aSemidirectProduct left.
			parent action value: {aSemidirectProduct left. right} · aSemidirectProduct right}! !

!SemidirectProductElement methodsFor: 'operations' stamp: 'len 5/5/2019 18:17:09'!
inverse
	| leftInverse rightInverse |
	leftInverse _ left inverse.
	rightInverse _ right inverse.
	^ parent project: {leftInverse. (parent action value: {leftInverse. rightInverse}) inverse}! !

!SemidirectProductElement methodsFor: 'printing' stamp: 'len 2/12/2016 06:10'!
printOn: aStream
	aStream nextPut: $(; print: left; nextPutAll: ', '; print: right; nextPut: $)! !

!SemidirectProductElement methodsFor: 'private' stamp: 'len 4/23/2024 04:50:31'!
left: anElement right: anotherElement parent: aSemidirectProductGroup
	left := anElement.
	right := anotherElement.
	parent := aSemidirectProductGroup! !

!SemidirectProductElement class methodsFor: 'instance creation' stamp: 'len 4/23/2024 04:50:54'!
left: anElement right: anotherElement parent: aSemidirectProductGroup
	^ self new left: anElement right: anotherElement parent: aSemidirectProductGroup! !

!Permutation methodsFor: 'accessing' stamp: 'len 5/25/2019 05:27:21'!
aChange
	"Answer a point changed by the receiver (or nil if there is none)."
	self supportDo: [:each| ^ each].
	^ nil! !

!Permutation methodsFor: 'accessing' stamp: 'len 5/25/2019 06:22:47'!
at: anInteger
	^ images at: anInteger ifAbsent: [anInteger]! !

!Permutation methodsFor: 'accessing' stamp: 'len 5/25/2019 06:19:36'!
at: anInteger put: anotherInteger
	^ images at: anInteger put: anotherInteger! !

!Permutation methodsFor: 'accessing' stamp: 'len 2/8/2018 08:49:09'!
codomain
	^ self domain! !

!Permutation methodsFor: 'accessing' stamp: 'len 5/25/2019 06:19:41'!
degree
	^ images size! !

!Permutation methodsFor: 'accessing' stamp: 'len 4/30/2019 12:30:51'!
domain
	^ parent space! !

!Permutation methodsFor: 'accessing' stamp: 'len 5/25/2019 05:29:24'!
fixedPoints
	"Answer the points fixed by the receiver."
	^ Iterator on: self performing: #fixedPointsDo:! !

!Permutation methodsFor: 'accessing' stamp: 'len 4/30/2019 12:31:23'!
identity
	"Answer the identity permutation."
	^ parent identity! !

!Permutation methodsFor: 'accessing' stamp: 'len 2/8/2018 08:52:14'!
one
	^ self identity! !

!Permutation methodsFor: 'accessing' stamp: 'len 4/30/2019 12:32:10'!
parent
	^ parent! !

!Permutation methodsFor: 'accessing' stamp: 'len 2/8/2018 09:28:02'!
sign
	| answer |
	answer _ 1.
	self cyclesDo: [:each| each size even ifTrue: [answer _ answer * -1]].
	^ answer

	"^ self transpositions size even ifTrue: [1] ifFalse: [-1]"! !

!Permutation methodsFor: 'accessing' stamp: 'len 5/25/2019 05:26:06'!
support
	"Answer the points changed by the receiver."
	^ Iterator on: self performing: #supportDo:! !

!Permutation methodsFor: 'accessing' stamp: 'len 12/18/2023 11:33:04'!
transpositions
	"Answer the decomposition of the receiver as product of transpositions."
	| answer last value |
	answer := OrderedCollection new.
	self supportDo: [:i|
		last := i.
		answer reverseDo: [:each| last := each at: last].
		(value := self at: i) = last
			ifFalse: [answer addFirst: (parent transposing: last with: value)]].
	^ answer! !

!Permutation methodsFor: 'accessing' stamp: 'len 5/1/2019 02:37:25'!
type
	"Answer the type of the receiver."
	^ (self cycles asSortedCollection: [:a :b| a size <= b size]) collect: [:each| each size]! !

!Permutation methodsFor: 'actions' stamp: 'len 2/8/2018 08:51:52'!
permute: anArray
	"Answer the permutation of the elements of anArray induced by the receiver."
	| answer |
	answer _ Array new: anArray size.
	1 to: anArray size do: [:i| answer at: i put: (anArray at: (self at: i))].
	^ answer! !

!Permutation methodsFor: 'actions' stamp: 'len 6/15/2022 10:38:11'!
value: anObject
	^ parent indexToSpace at: (self at: (parent spaceToIndex at: anObject ifAbsent: [^ anObject]))! !

!Permutation methodsFor: 'comparing' stamp: 'len 12/3/2023 21:20:20'!
< aPermutation
	^ (self compare: aPermutation) < 0! !

!Permutation methodsFor: 'comparing' stamp: 'len 12/3/2023 21:16:56'!
<= aPermutation
	^ (self compare: aPermutation) <= 0! !

!Permutation methodsFor: 'comparing' stamp: 'len 5/25/2019 06:21:34'!
= aPermutation
	^ self class = aPermutation class and: [images = aPermutation images]! !

!Permutation methodsFor: 'comparing' stamp: 'len 12/4/2023 10:14:02'!
> aPermutation
	^ aPermutation < self! !

!Permutation methodsFor: 'comparing' stamp: 'len 12/4/2023 10:14:06'!
>= aPermutation
	^ aPermutation <= self! !

!Permutation methodsFor: 'comparing' stamp: 'len 12/3/2023 16:10:08'!
compare: aPermutation
	"Answer -1 if the receiver is < than the argument, 0 if they are equal, 1 if it is > than the argument."
	| sign |
	(sign := (images size - aPermutation images size) sign) = 0 ifFalse: [^ sign].
	images isEmpty ifTrue: [^ 0].
	images with: aPermutation images do: [:a :b|
		a > b ifTrue: [^ 1].
		a = b ifFalse: [^ -1]].
	^ 0! !

!Permutation methodsFor: 'comparing' stamp: 'len 5/25/2019 06:22:25'!
hash
	| answer |
	answer _ 0.
	1 to: images size do: [:i| | value |
		(value _ images at: i) = i ifFalse: [answer _ answer bitXor: i hash hashMultiply + value hash]].
	^ answer! !

!Permutation methodsFor: 'converting' stamp: 'len 5/25/2019 06:22:16'!
asArray
	^ images! !

!Permutation methodsFor: 'cycles' stamp: 'len 2/8/2018 08:49:33'!
cycles
	"Answer the cycles of the receiver."
	^ Iterator on: self performing: #cyclesDo:! !

!Permutation methodsFor: 'cycles' stamp: 'len 5/1/2024 12:27:52'!
cyclesDo: aBlock
	"Iterate over the cycles of the receiver."
	| left first next cycle |
	left := self support copyAs: Set.
	[left size > 0] whileTrue:
		[first := left any.
		cycle := OrderedCollection new.
		next := first.
		[(cycle add: (left remove: (next := self at: next))) ~= first] whileTrue.
		aBlock value: cycle]! !

!Permutation methodsFor: 'enumerating' stamp: 'len 5/25/2019 06:19:47'!
fixedPointsDo: aBlock
	"Enumerate the points fixed by the receiver."
	1 to: images size do: [:i| (images at: i) = i ifTrue: [aBlock value: i]]! !

!Permutation methodsFor: 'enumerating' stamp: 'len 5/25/2019 06:21:06'!
supportDo: aBlock
	"Enumerate the points changed by the receiver."
	1 to: images size do: [:i| (images at: i) = i ifFalse: [aBlock value: i]]! !

!Permutation methodsFor: 'operations' stamp: 'len 12/4/2023 20:29:30'!
* anElement
	^ self · anElement! !

!Permutation methodsFor: 'operations' stamp: 'len 12/4/2023 20:27:47'!
^ anInteger
	"Answer the receiver composed with itself anInteger times.
	If the argument is another group element, answer the conjugation."
	anInteger isInteger ifFalse: [^ anInteger · self · anInteger inverse].
	anInteger = 1 ifTrue: [^ self].
	anInteger = 0 ifTrue: [^ self identity].
	anInteger < 0 ifTrue: [^ self inverse ^ anInteger negated].
	^ anInteger even ifTrue: [self · self ^ (anInteger // 2)] ifFalse: [self · self ^ (anInteger // 2) · self]! !

!Permutation methodsFor: 'operations' stamp: 'len 12/16/2023 19:05:18'!
· aPermutation
	"Answer the product (function composition) of the receiver with the argument.
	This is the group operation."
	| otherImages newImages |
	self assert: images size = aPermutation images size.
	otherImages := aPermutation images.
	newImages := images class new: images size.
	1 to: images size do: [:i| newImages at: i put: (images at: (otherImages at: i))].
	^ self class images: newImages parent: parent! !

!Permutation methodsFor: 'operations' stamp: 'len 12/16/2023 19:05:53'!
inverse
	"Answer the compositive inverse of the receiver."
	| inverseImages |
	inverseImages := images class new: images size.
	1 to: images size do: [:i| inverseImages at: (images at: i) put: i].
	^ self class images: inverseImages parent: parent! !

!Permutation methodsFor: 'operations' stamp: 'len 12/16/2023 19:08:14'!
log
	^ parent logarithmOf: self! !

!Permutation methodsFor: 'operations' stamp: 'len 12/16/2023 19:08:19'!
log: α
	^ parent logarithmOf: self base: α! !

!Permutation methodsFor: 'operations' stamp: 'len 12/4/2023 20:24:53'!
squared
	^ self · self! !

!Permutation methodsFor: 'printing' stamp: 'len 12/18/2023 11:17:54'!
printOn: aStream
	self isIdentity ifTrue: [aStream nextPutAll: 'id'. ^ self].
	self cyclesDo: [:cycle|
		aStream nextPut: $(.
		cycle do: [:i| | element |
			element := parent indexToSpace at: i.
			element isSymbol
				ifTrue: [aStream nextPutAll: element]
				ifFalse: [aStream print: element]] separatedBy: [aStream space].
		aStream nextPut: $)]! !

!Permutation methodsFor: 'testing' stamp: 'len 2/8/2018 08:44:34'!
even
	^ self sign = 1! !

!Permutation methodsFor: 'testing' stamp: 'len 12/19/2023 18:17:35'!
isCycle
	"Answer true if the receiver is a cycle."
	^ self cycles isSingleton! !

!Permutation methodsFor: 'testing' stamp: 'len 12/19/2023 18:17:18'!
isIdentity
	"Answer true if the receiver is the identity permutation."
	self supportDo: [:i| ^ false].
	^ true! !

!Permutation methodsFor: 'testing' stamp: 'len 12/19/2023 18:22:23'!
isTransposition
	"Answer true if the receiver is a transposition."
	^ self support isPair! !

!Permutation methodsFor: 'testing' stamp: 'len 2/8/2018 08:51:17'!
odd
	^ self sign = -1! !

!Permutation methodsFor: 'testing' stamp: 'len 10/9/2023 09:52:19'!
≃ aPermutation
	"Answer true if the receiver and the argument are conjugate."
	^ self type = aPermutation type! !

!Permutation methodsFor: 'private' stamp: 'len 5/25/2019 06:22:06'!
images
	^ images! !

!Permutation methodsFor: 'private' stamp: 'len 12/23/2023 11:10:56'!
images: anArray parent: aSymmetricGroup
	images := anArray.
	parent := aSymmetricGroup.
	self flag: #fixme. "remove asserts:"
	self assert: images size = parent degree.
	self assert: images class = (images size <= 16rFF ifTrue: [ByteArray] ifFalse: [WordArray])! !

!Permutation class methodsFor: 'instance creation' stamp: 'len 12/16/2023 19:03:00'!
images: anArray parent: aSymmetricGroup
	^ self new images: anArray parent: aSymmetricGroup! !

!RingElement methodsFor: 'accessing' stamp: 'len 9/24/2018 22:58:16'!
one
	^ self parent one! !

!RingElement methodsFor: 'accessing' stamp: 'len 9/24/2018 22:58:19'!
zero
	^ self parent zero! !

!RingElement methodsFor: 'comparing' stamp: 'len 11/11/2023 15:13:01'!
| anElement
	"Answer true if the receiver is a left divisor of the argument
	(or equivalently, the argument is a right multiple of the receiver),
	i.e. if the receiver is a and the argument is b, there exists x with ax = b."
	anElement isZero ifTrue: [^ true].
	self isZero ifTrue: [^ false].
	self parent isField ifTrue: [^ true].
	self parent isEuclidean ifTrue: [^ (anElement \\ self) isZero].
	^ (self lift: anElement) notNil

"alternative:
	^ anElement isZero or: [self isZero not and: [self asIdeal includes: anElement]]"! !

!RingElement methodsFor: 'comparing' stamp: 'len 5/31/2022 11:24:01'!
~ anElement
	"Answer true if the receiver and the argument are associates.
	Note that we define 'a ~ b' if there's a unit 'u' such that 'au = b'
	(this relation is called 'strongly associate' by some authors)."
	self parent hasCanonicalAssociates ifTrue: [^ self normalized = anElement normalized].
	^ (self lift: anElement) ifNil: [false] ifNotNil: [:x| x isUnit]! !

!RingElement methodsFor: 'comparing' stamp: 'len 5/23/2022 11:36:23'!
⊥ anElement
	"Answer true if the receiver and the argument are coprime."
	^ self asIdeal ⊥ anElement asIdeal! !

!RingElement methodsFor: 'converting' stamp: 'len 11/10/2023 10:36:32'!
adaptToFraction: rcvr andSend: selector
	^ self parent !! rcvr perform: selector with: self! !

!RingElement methodsFor: 'converting' stamp: 'len 11/10/2023 10:34:30'!
adaptToInteger: rcvr andSend: selector
	selector = #* ifTrue: [^ self * rcvr].
	selector = #+ ifTrue: [^ self one * rcvr + self].
	selector = #- ifTrue: [^ self one * rcvr - self].
	selector = #/ ifTrue: [^ self one * rcvr / self].
	^ self parent !! rcvr perform: selector with: self! !

!RingElement methodsFor: 'converting' stamp: 'len 1/3/2022 11:07:20'!
asIdeal
	"Answer the ideal generated by the receiver."
	^ self parent * self! !

!RingElement methodsFor: 'converting' stamp: 'len 5/6/2023 18:30:31'!
asSingletonMatrix
	"Answer the 1x1 matrix with the receiver as its only coefficient."
	^ self parent !!!!!! {{self}}! !

!RingElement methodsFor: 'operations' stamp: 'len 6/17/2019 11:19:47'!
* anElement
	^ self subclassResponsibility! !

!RingElement methodsFor: 'operations' stamp: 'len 6/17/2019 11:19:52'!
+ anElement
	^ self subclassResponsibility! !

!RingElement methodsFor: 'operations' stamp: 'len 11/23/2022 21:42:40'!
, aTuple
	^ self parent !!!! {self} , aTuple! !

!RingElement methodsFor: 'operations' stamp: 'len 6/17/2019 11:19:36'!
- anElement
	^ self + anElement negated! !

!RingElement methodsFor: 'operations' stamp: 'len 5/29/2022 19:39:19'!
/ anElement
	"Answer x such that xa = b, where b is the receiver and a is the argument.
	This is the right division of b by a, written b / a."
	(self parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #/].
	^ (anElement colift: self) ifNil: [DivisibilityError new signalReceiver: self selector: #/ argument: anElement]! !

!RingElement methodsFor: 'operations' stamp: 'len 11/22/2023 16:08:29'!
// anElement
	"Answer the quotient of the division of the receiver by the argument.
	In Euclidean rings, this is the quotient of the Euclidean division.
	See also #\\ and #gauge."
	^ self / anElement! !

!RingElement methodsFor: 'operations' stamp: 'len 5/29/2022 19:39:19'!
\ anElement
	"Answer x such that ax = b, where a is the receiver and b is the argument.
	This is the left division of b by a, written a \ b."
	(self parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #\].
	^ (self lift: anElement) ifNil: [DivisibilityError new signalReceiver: self selector: #\ argument: anElement]! !

!RingElement methodsFor: 'operations' stamp: 'len 5/26/2022 12:21:18'!
\\ anElement
	"Answer the remainder of the division of the receiver by the argument.
	In Euclidean rings, this is the remainder of the Euclidean division.
	See also #// and #gauge."
	^ self - (anElement * (self // anElement))! !

!RingElement methodsFor: 'operations' stamp: 'len 5/28/2023 19:46:10'!
^ anInteger
	"Answer the receiver raised to the power anInteger."
	anInteger = 1 ifTrue: [^ self].
	anInteger = 0 ifTrue: [^ self one].
	anInteger < 0 ifTrue: [^ self  inverse ^ anInteger negated].
	anInteger isFraction ifTrue: [^ (self root: anInteger denominator) ^ anInteger numerator].
	^ anInteger even ifTrue: [self squared ^ (anInteger // 2)] ifFalse: [self squared ^ (anInteger // 2) * self]! !

!RingElement methodsFor: 'operations' stamp: 'len 6/17/2019 11:20:04'!
· anElement
	^ self * anElement! !

!RingElement methodsFor: 'operations' stamp: 'len 5/14/2023 13:30:31'!
÷ anElement
	"Answer the exact division of the receiver by the argument.
	Asume that the argument divides the receiver."
	^ anElement \ self! !

!RingElement methodsFor: 'operations' stamp: 'len 11/17/2023 14:38:24'!
absoluteNorm
	"Answer the absolute norm of the receiver."
	| μ |
	μ := self minimalPolynomial.
	^ μ degree even ifTrue: [μ independentCoefficient] ifFalse: [μ independentCoefficient negated]! !

!RingElement methodsFor: 'operations' stamp: 'len 11/17/2023 14:34:49'!
absoluteTrace
	"Answer the absolute trace of the receiver."
	| μ |
	μ := self minimalPolynomial.
	^ (μ at: μ degree - 1) negated! !

!RingElement methodsFor: 'operations' stamp: 'len 10/17/2022 18:06:29'!
annihilator
	"Answer a generator of the ideal of all elements that multiplied by the receiver are zero."
	self parent isIntegralDomain ifTrue: [^ self isZero ifTrue: [self parent one] ifFalse: [self parent zero]].
	^ self annihilatorIdeal generator! !

!RingElement methodsFor: 'operations' stamp: 'len 10/18/2023 09:03:27'!
annihilatorIdeal
	"Answer the ideal of all elements that multiplied by the receiver are zero."
	self parent isIntegralDomain ifTrue: [^ self isZero ifTrue: [self parent asIdeal] ifFalse: [self parent asIdeal null]].
	self parent isFiniteAlgebra ifTrue: [	^ self parent * (self representation kernel generators collect: [:each| self parent !! each])].
	^ self parent * (self parent zeroDivisors select: [:each| (self * each) isZero])
"	^ self parent * (self parent select: [:each| (self * each) isZero])"! !

!RingElement methodsFor: 'operations' stamp: 'len 6/13/2024 14:08:00'!
anticommutator: anElement
	"Answer the anticommutator of the receiver and the argument.
	This is usually denoted by {a,b}."
	^ self * anElement + (anElement * self)! !

!RingElement methodsFor: 'operations' stamp: 'len 12/10/2021 19:37:31'!
associates
	^ self parent units collect: [:each| self * each]! !

!RingElement methodsFor: 'operations' stamp: 'len 6/26/2023 13:01:10'!
centralizer
	"Answer the subalgebra of the parent algebra commuting with the receiver."
	^ self parent centralizerOf: (self parent sub: {self})! !

!RingElement methodsFor: 'operations' stamp: 'len 6/16/2024 07:57:26'!
colift: anElement
	"Answer x such that xa = b, where a is the receiver and b is the argument. Answer nil if there's no solution.
	This is the right division of b by a, written b / a."
	anElement isZero ifTrue: [^ anElement].
"	self parent isField ifTrue: [^ self isZero ifFalse: [anElement * self inverse]]."
	self parent isFiniteAlgebra ifTrue: [	^ self parent !! ((self rightRepresentation preimageElement: self parent asModule !! anElement) ifNil: [^ nil])].
	self parent isEuclidean ifTrue: [| division | ^ (division := anElement divisionBy: self) remainder isZero ifTrue: [division quotient]].
	self parent isFinite ifTrue: [^ self parent detect: [:x| x * self = anElement] ifNone: []].
	^ self subclassResponsibility! !

!RingElement methodsFor: 'operations' stamp: 'len 6/13/2024 14:08:06'!
commutator: anElement
	"Answer the commutator (Lie bracket) of the receiver and the argument.
	This is usually denoted by [a,b]."
	^ self * anElement - (anElement * self)! !

!RingElement methodsFor: 'operations' stamp: 'len 5/15/2020 06:15:27'!
divisionBy: anElement
	^ Division divide: self by: anElement! !

!RingElement methodsFor: 'operations' stamp: 'len 11/26/2023 13:43:09'!
evaluate: aPolynomial
	"Answer the result of evaluating aPolynomial at the receiver."
	^ aPolynomial value: self! !

!RingElement methodsFor: 'operations' stamp: 'len 6/25/2023 09:54:56'!
factorization
	"Answer a collection with the irreducible factors of the receiver (with multiplicity)."
	| answer |
	answer := Bag new.
	self factorizationDo: [:p :e| answer add: p withOccurrences: e].
	^ answer! !

!RingElement methodsFor: 'operations' stamp: 'len 4/6/2024 06:38:01'!
factorizationDo: aBlock
	"Enumerate the irreducible factors of the receiver and their multiplicities."
	self assert: self parent isUFR.
	^ self subclassResponsibility! !

!RingElement methodsFor: 'operations' stamp: 'len 12/18/2022 08:45:51'!
gauge
	"Answer the value of the Euclidean function at the receiver."
	self parent isDVR ifTrue: [^ self isZero ifTrue: [0] ifFalse: [self valuation + 1]].
	self parent isField ifTrue: [^ self isZero ifTrue: [0] ifFalse: [1]].
	^ self subclassResponsibility! !

!RingElement methodsFor: 'operations' stamp: 'len 6/1/2022 18:05:51'!
gcd: anElement
	"Answer the greatest common divisor of the receiver and the argument,
	i.e. the normalized generator of the principal ideal generated by the reciever and the argument.
	This is the Euclidean algorithm, and assumes the receiver and argument are element of an Euclidean ring."
	| a b |
	a _ self.
	b _ anElement.
	[a isZero] whileFalse: [a _ b \\ (b _ a)].
	^ b normalized! !

!RingElement methodsFor: 'operations' stamp: 'len 4/23/2021 11:13:08'!
inverse
	^ self \ self one! !

!RingElement methodsFor: 'operations' stamp: 'len 12/10/2021 19:41:57'!
lcm: anElement
	"Answer the least common multiple of the receiver and the argument.
	The result is the canonical associate (normalized)."
	self isZero ifTrue: [^ self].
	anElement isZero ifTrue: [^ anElement].
	^ (self / (self gcd: anElement) * anElement) normalized! !

!RingElement methodsFor: 'operations' stamp: 'len 10/18/2023 09:17:14'!
lift: anElement
	"Answer x such that ax = b, where a is the receiver and b is the argument. Answer nil if there's no solution.
	This is the left division of b by a, written a \ b."
	self parent isCommutative ifTrue: [^ self colift: anElement].
	self parent isInvolutive ifTrue: [^ (self conjugate colift: anElement conjugate) conjugate].
	self parent isFiniteAlgebra ifTrue: [^ self parent !! ((self representation preimageElement: self parent asModule !! anElement) ifNil: [^ nil])].
	self parent isFinite ifTrue: [^ self parent detect: [:x| self * x = anElement] ifNone: []].
	^ self subclassResponsibility! !

!RingElement methodsFor: 'operations' stamp: 'len 6/23/2023 17:51:51'!
log
	"If the receiver is a unit and the group of units is cyclic with a fixed generator (for example a distinguished primitive element), answer the logarithm of the receiver with base the generator."
	self isUnit ifFalse: [^ self error: 'not a unit'].
	^ self parent units logarithmOf: self! !

!RingElement methodsFor: 'operations' stamp: 'len 6/23/2023 17:51:44'!
log: anElement
	"Answer the logarithm of the receiver with base anElement."
	self isUnit ifFalse: [^ self error: 'not a unit'].
	^ self parent units logarithmOf: self base: anElement! !

!RingElement methodsFor: 'operations' stamp: 'len 10/16/2022 10:27:12'!
minimalPolynomial
	^ self representation minimalPolynomial! !

!RingElement methodsFor: 'operations' stamp: 'len 6/21/2023 15:00:38'!
multiplicativeOrder
	"Answer the order of the receiver as an element of the group of units.
	Return 0 if the receiver is not a unit."
	self isUnit ifFalse: [^ 0].
	^ self parent units orderOf: self! !

!RingElement methodsFor: 'operations' stamp: 'len 5/29/2020 07:53:44'!
negated
	^ self * -1! !

!RingElement methodsFor: 'operations' stamp: 'len 11/17/2023 14:39:12'!
norm
	"Answer the relative norm of the receiver."
	^ self representation determinant

"alternatively:
	| χ |
	χ _ self representation characteristicPolynomial.
	^ χ degree even ifTrue: [χ independentCoefficient] ifFalse: [χ independentCoefficient negated]"! !

!RingElement methodsFor: 'operations' stamp: 'len 12/10/2021 19:19:49'!
normalization
	"Answer a unit u such that 'self * u' is a unique choice of associate. See >>normalized."
	self isUnit ifTrue: [^ self inverse].
	self isZero ifTrue: [^ self parent one].
	^ self subclassResponsibility! !

!RingElement methodsFor: 'operations' stamp: 'len 7/30/2021 10:27:06'!
normalized
	"Answer a unique choice of associate. See >>normalization."
	^ self * self normalization! !

!RingElement methodsFor: 'operations' stamp: 'len 4/13/2024 09:36:07'!
opposite
	"Answer the receiver as an element of the opposite ring."
	self parent isCommutative ifTrue: [^ self].
	self parent isInvolutive ifTrue: [^ self conjugate].
	^ OppositeRingElement opposite: self! !

!RingElement methodsFor: 'operations' stamp: 'len 5/25/2022 19:56:39'!
quotientBy: anElement modulo: m
	"Answer the Euclidean quotient of the receiver by anElement modulo m.
	If the receiver is 'r' and anElement is 's', answer 'q' such that 's*q = r mod m', or in other words 's*q - r' is divisible by 'm' and 'q' is either 0 (if 'r' is divisible by 'm') or the Euclidean degree of 'q' is strictly smaller than the Euclidean degree of 'm'."
	| f g fs gs h hs q r |
	f _ anElement. fs _ self one.
	g _ m. gs _ self zero.
	[g isZero] whileFalse:
		[q _ f // g. r _ f - (g*q).
		h _ g. hs _ gs.
		g _ r. gs _ fs - (q*gs).
		f _ h. fs _ hs].
	q _ self // f.
	^ fs * q \\ m
	
"alternative:
	xgcd _ anElement xgcd: m.
	^ self // (xgcd at: 1) * (xgcd at: 2) \\ m"! !

!RingElement methodsFor: 'operations' stamp: 'len 10/24/2023 16:11:37'!
radical
	"Assuming the receiver is an element in a UFR, answer the radical or squarefree part."
	| answer |
	answer := self one.
	self factorizationDo: [:p :e| answer := answer * p].
	^ answer! !

!RingElement methodsFor: 'operations' stamp: 'len 6/25/2023 20:45:19'!
raisedTo2: anInteger modulo: anElement
	"Answer the receiver raised to the power anInteger modulo anElement."
	| n x y |
	self flag: #fixme. "just a test"
	anInteger = 0 ifTrue: [^ self one].
	anInteger > 0 ifTrue: [x := self. n := anInteger] ifFalse: [x := self inverse. n := anInteger negated].
	y := 1.
	[n > 1] whileTrue:	
		[n odd ifTrue: [y := x * y \\ anElement].
		x := x squared \\ anElement.
		n := n bitShift: -1].
	^ x * y \\ anElement! !

!RingElement methodsFor: 'operations' stamp: 'len 6/30/2023 14:32:52'!
raisedTo: anInteger
	^ self ^ anInteger! !

!RingElement methodsFor: 'operations' stamp: 'len 5/27/2023 17:26:56'!
raisedTo: anInteger modulo: anElement
	"Answer the receiver raised to the power anInteger modulo anElement."
	anInteger = 1 ifTrue: [^ self \\ anElement].
	anInteger = 0 ifTrue: [^ self one \\ anElement].
	anInteger < 0 ifTrue: [^ (self raisedTo: anInteger negated modulo: anElement) inverse \\ anElement].
	anInteger = 2 ifTrue: [^ self squared \\ anElement].
	^ anInteger even ifTrue: [self squared \\ anElement raisedTo: anInteger // 2 modulo: anElement] ifFalse: [(self squared \\ anElement raisedTo: anInteger // 2 modulo: anElement) * self \\ anElement]! !

!RingElement methodsFor: 'operations' stamp: 'len 1/7/2022 13:47:33'!
reciprocal
	^ (self parent fractions !! self) inverse! !

!RingElement methodsFor: 'operations' stamp: 'len 10/15/2023 09:42:01'!
representation
	"Answer the module endomorphism corresponding to the left regular representation of the receiver,
	i.e. an endomorphism of the underlying module corresponding to left multiplication by the receiver."
	| M |
	^ (M := self parent asModule) endomorphisms map: [:v| M !! (self * (self parent !! v))]! !

!RingElement methodsFor: 'operations' stamp: 'len 10/15/2023 09:54:47'!
representation2
	"Answer the module endomorphism corresponding to the left regular representation of the receiver,
	i.e. an endomorphism of the underlying module corresponding to left multiplication by the receiver."
	self flag: #fixme. "this is slower!! for example, it is 50% faster for cyloctomic field of order 6, but 5x slower for cyclotomic field of order 60"
	^ self parent representation value: self! !

!RingElement methodsFor: 'operations' stamp: 'len 6/16/2024 07:57:26'!
rightRepresentation
	"Answer the module endomorphism corresponding to the right regular representation of the receiver,
	i.e. an endomorphism of the underlying module corresponding to right multiplication by the receiver."
	| M |
	^ (M := self parent asModule) endomorphisms map: [:v| M !! (self parent !! v * self)]! !

!RingElement methodsFor: 'operations' stamp: 'len 5/1/2024 12:27:56'!
root: anInteger
	"Answer a n-th root of the receiver."
	^ (self parent polynomials x ^ anInteger - self) roots any! !

!RingElement methodsFor: 'operations' stamp: 'len 6/26/2023 01:34:30'!
sqrt
	"Answer a square root of the receiver."
	^ self root: 2! !

!RingElement methodsFor: 'operations' stamp: 'len 5/30/2023 22:30:35'!
squareRoot
	^ self sqrt! !

!RingElement methodsFor: 'operations' stamp: 'len 9/24/2018 22:53:02'!
squared
	^ self * self! !

!RingElement methodsFor: 'operations' stamp: 'len 5/10/2020 11:00:58'!
stabilizerWith: b modulo: N
	"If the receiver is 'a', answer 'c' such that '<a + cb, N> = <a, b, N>'."
	self notYetImplemented! !

!RingElement methodsFor: 'operations' stamp: 'len 11/17/2023 14:35:28'!
trace
	"Answer the relative trace of the receiver."
	^ self representation trace

"alternatively:
	| χ |
	χ _ self representation characteristicPolynomial.
	^ (χ at: χ degree - 1) negated"! !

!RingElement methodsFor: 'operations' stamp: 'len 5/8/2020 18:22:38'!
valuation
	"If the receiver is an element of a valuation ring or a Euclidean ring, answer its valuation or Euclidean function."
	^ self subclassResponsibility! !

!RingElement methodsFor: 'operations' stamp: 'len 8/7/2019 09:11:23'!
valuation: p
	"Answer the p-adic valuation of the receiver.
	This is the exponent of the highest power of p that divides the receiver."
	| answer q |
	self isZero ifTrue: [^ Infinity positive].
	q _ self normalized.
	answer _ 0.
	[p | q] whileTrue: [answer _ answer + 1. q _ q // p].
	^ answer! !

!RingElement methodsFor: 'operations' stamp: 'len 6/9/2023 09:58:15'!
xgcd: anElement
	"Answer the GCD of the receiver and the argument and the Bézout coefficients.
	If the receiver is 'a', the argument is 'b' and their GCD is 'g', answer an array {g. s. t} where as + bt = g.
	This is the extended Euclidean algorithm."
	| a b zero one s₁ t₁ s t r₁ r u |
	a := self.
	b := anElement.
	zero := a zero. one := a one.
	s₁ := zero. s := one.
	t₁ := one. t := zero.
	r₁ := a normalized.
	r := b normalized.
	[r₁ isZero]
		whileFalse:
			[ | q temp |
			q := r // r₁.
			temp := r₁. r₁ := r - (q * r₁). r := temp.
			temp := s₁. s₁ := s - (q * s₁). s := temp.
			temp := t₁. t₁ := t - (q * t₁). t := temp].
	s := s * b normalization. t := t * a normalization.
	u := r normalization.
	s := s * u. t := t * u. r := r * u.
	^ {r. t. s}! !

!RingElement methodsFor: 'operations' stamp: 'len 5/26/2022 12:36:03'!
xxgcd: anElement
	"(More) Extended GCD.
	If the receiver is 'a', the argument is 'b' and their GCD is 'g'. answer an array {g. s. t. u. v} where as + bt = g, au + bv = 0, and sv - ut = 1, i.e. answer the coefficients of a unimodular matrix such that:.
		[s  t] [a]     [g]
		[u v] [b] = [0]."
	| xgcd g |
	(self isZero and: [anElement isZero]) ifTrue: [^ {self. self parent one. self. self. self parent one}].
"	self parent isIntegralDomain ifFalse: [^ DomainError signal]."
	^ (xgcd _ self xgcd: anElement), {(anElement / (g _ xgcd at: 1)) negated. self / g}! !

!RingElement methodsFor: 'operations' stamp: 'len 7/1/2024 10:57:40'!
▹ anObject
	^ anObject ◃ self opposite! !

!RingElement methodsFor: 'testing' stamp: 'len 4/27/2021 12:41:11'!
isCentral
	"Answer true if the receiver is in the center of its parent algebra."
	^ self parent center contains: self! !

!RingElement methodsFor: 'testing' stamp: 'len 6/11/2020 12:31:32'!
isIdempotent
	^ self squared isOne! !

!RingElement methodsFor: 'testing' stamp: 'len 5/10/2020 11:49:43'!
isIdentity
	^ self isOne! !

!RingElement methodsFor: 'testing' stamp: 'len 10/19/2023 19:41:42'!
isIntegral
	^ self minimalPolynomial coefficients allSatisfy: [:each| each isIntegral]! !

!RingElement methodsFor: 'testing' stamp: 'len 10/17/2022 11:45:50'!
isIrreducible
	"A nonzero nonunit element 'a' is called irreducible if a=bc implies that a|b (and then c is a unit) or a|c (and then b is a unit)."
	self parent isIntegralDomain ifTrue: [^ self isPrime].
	(self isZero or: [self isUnit]) ifTrue: [^ false].
	self parent isFinite ifFalse: [^ self subclassResponsibility].
	self parent do: [:x|
		self parent do: [:y|
			x*y = self ifTrue: [(x isUnit or: [y isUnit]) ifFalse: [^ false]]]].
	^ true! !

!RingElement methodsFor: 'testing' stamp: 'len 4/25/2022 18:02:41'!
isMinusOne
	^ self = self parent one negated! !

!RingElement methodsFor: 'testing' stamp: 'len 7/30/2019 05:25:00'!
isNilpotent
	"Answer true if self^n = 0 for some integer n >= 1."
	^ self parent nilradical contains: self! !

!RingElement methodsFor: 'testing' stamp: 'len 9/24/2018 02:11:01'!
isOne
	^ self = self parent one! !

!RingElement methodsFor: 'testing' stamp: 'len 5/4/2020 09:33:07'!
isPrime
	"A nonzero nonunit element 'a' is called prime if a|bc implies that a|b or a|c."
	(self isZero or: [self isUnit]) ifTrue: [^ false].
	self parent isFinite ifFalse: [^ self subclassResponsibility].
	self parent do: [:x|
		self parent do: [:y| | xy |
			((xy _ x*y) isZero not and: [self | (xy)])
				ifTrue: [(self | x or: [self | y]) ifFalse: [^ false]]]].
	^ true! !

!RingElement methodsFor: 'testing' stamp: 'len 7/21/2019 12:47:10'!
isReal
	^ false! !

!RingElement methodsFor: 'testing' stamp: 'len 6/20/2019 18:19:45'!
isReducible
	"A nonzero nonunit element is called 'reducible' if it is not irreducible."
	^ self isZero not and: [self isUnit not and: [self isIrreducible not]]! !

!RingElement methodsFor: 'testing' stamp: 'len 6/26/2023 01:34:15'!
isSquare
	"Answer true if the receiver is a perfect square, i.e. it has a square root."
	^ (self parent polynomials x squared - self) roots notEmpty! !

!RingElement methodsFor: 'testing' stamp: 'len 10/19/2023 19:44:16'!
isUnit
	"Answer true if the receiver is invertible."
	self parent isDivisionRing ifTrue: [^ self isZero not].
	"self parent isFiniteAlgebra ifTrue: [^ self norm isUnit]."
	^ (self lift: self one) notNil! !

!RingElement methodsFor: 'testing' stamp: 'len 9/24/2018 02:10:54'!
isZero
	^ self = self parent zero! !

!RingElement methodsFor: 'testing' stamp: 'len 10/19/2023 19:46:13'!
isZeroDivisor
	"Answer true if there exists a nonzero element that multiplied by the receiver is zero."
	self parent isIntegralDomain ifTrue: [^ self isZero].
	self parent isFinite ifTrue: [^ self isUnit not].
	self parent isPIR ifTrue: [^ self annihilator isZero not].
	"self parent isFiniteAlgebra ifTrue: [^ self representation isZeroDivisor and: [self parent isCommutative or: [self corepresentation isZeroDivisor]]]."
	^ self annihilatorIdeal isTrivial not! !

!OppositeRingElement methodsFor: 'accessing' stamp: 'len 4/26/2021 11:21:37'!
opposite
	^ opposite! !

!OppositeRingElement methodsFor: 'comparing' stamp: 'len 4/26/2021 11:20:57'!
= anElement
	^ self class = anElement class and: [opposite = anElement opposite]! !

!OppositeRingElement methodsFor: 'comparing' stamp: 'len 4/26/2021 11:21:05'!
hash
	^ opposite hash! !

!OppositeRingElement methodsFor: 'operations' stamp: 'len 4/26/2021 11:21:22'!
* anElement
	^ self class opposite: anElement opposite * opposite! !

!OppositeRingElement methodsFor: 'operations' stamp: 'len 5/13/2022 07:10:37'!
+ anElement
"	(self parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #+]."
	^ self class opposite: opposite + anElement opposite! !

!OppositeRingElement methodsFor: 'operations' stamp: 'len 5/13/2022 07:11:01'!
- anElement
"	(self parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #-]."
	^ self class opposite: opposite - anElement opposite! !

!OppositeRingElement methodsFor: 'operations' stamp: 'len 4/15/2024 09:46:04'!
colift: anElement
	^ self class opposite: ((opposite lift: anElement opposite) ifNil: [^ nil])! !

!OppositeRingElement methodsFor: 'operations' stamp: 'len 4/26/2021 11:21:32'!
inverse
	^ self class opposite: opposite inverse! !

!OppositeRingElement methodsFor: 'operations' stamp: 'len 4/15/2024 09:44:12'!
lift: anElement
	^ self class opposite: ((anElement opposite colift: opposite) ifNil: [^ nil])! !

!OppositeRingElement methodsFor: 'operations' stamp: 'len 5/13/2022 07:11:10'!
negated
	^ self class opposite: opposite negated! !

!OppositeRingElement methodsFor: 'operations' stamp: 'len 5/30/2023 13:43:01'!
squared
	^ self class opposite: opposite squared! !

!OppositeRingElement methodsFor: 'printing' stamp: 'len 4/26/2021 11:21:47'!
printOn: aStream
	opposite printOn: aStream! !

!OppositeRingElement methodsFor: 'testing' stamp: 'len 11/20/2023 16:11:35'!
isZero
	^ opposite isZero! !

!OppositeRingElement methodsFor: 'private' stamp: 'len 4/3/2024 08:49:32'!
parent
	^ opposite parent opposite! !

!OppositeRingElement class methodsFor: 'instance creation' stamp: 'len 4/26/2021 11:22:25'!
opposite: anElement
	^ self new opposite: anElement! !

!ProductRingElement methodsFor: 'accessing' stamp: 'len 4/23/2020 01:42:02'!
at: anInteger
	^ components at: anInteger! !

!ProductRingElement methodsFor: 'accessing' stamp: 'len 4/23/2020 01:37:47'!
parent
	^ parent! !

!ProductRingElement methodsFor: 'accessing' stamp: 'len 4/23/2020 01:41:55'!
size
	^ components size! !

!ProductRingElement methodsFor: 'comparing' stamp: 'len 4/23/2020 01:40:33'!
= anObject
	^ self class = anObject class and: [components = anObject components]! !

!ProductRingElement methodsFor: 'comparing' stamp: 'len 5/31/2022 11:39:51'!
| anElement
	"Answer true if the receiver is a left divisor of the argument
	(or equivalently, the argument is a right multiple of the receiver),
	i.e. if the receiver is a and the argument is b, there exists x with ax = b."
	1 to: self size do: [:i| (self at: i) | (anElement at: i) ifFalse: [^ false]].
	^ true! !

!ProductRingElement methodsFor: 'comparing' stamp: 'len 4/23/2020 01:41:03'!
hash
	^ components hash! !

!ProductRingElement methodsFor: 'operations' stamp: 'len 7/6/2023 22:52:47'!
* anElement
	anElement isInteger ifTrue: [^ parent compose: components * anElement].
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #*].
	^ parent compose: components * anElement components! !

!ProductRingElement methodsFor: 'operations' stamp: 'len 7/6/2023 22:51:56'!
+ anElement
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #+].
	^ parent compose: components + anElement components! !

!ProductRingElement methodsFor: 'operations' stamp: 'len 7/6/2023 22:46:10'!
// anElement
	| a₁ a₂ b₁ b₂ |
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #//].
	anElement isZero ifTrue: [^ DivisibilityError new signalReceiver: self selector: #// argument: anElement].
	components size = 2 ifFalse: [^ self notYetImplemented].
	a₁ := self at: 1.
	a₂ := self at: 2.
	b₁ := anElement at: 1.
	b₂ := anElement at: 2.
	(b₁ isZero not and: [b₂ isZero not]) ifTrue:
		[ | q₁ q₂ r₁ r₂ |
		q₁ := a₁ // b₁.
		q₂ := a₂ // b₂.
		r₁ := a₁ - (b₁*q₁).
		r₂ := a₂ - (b₂*q₂).
		r₁ isZero = r₂ isZero ifTrue: [^ parent compose: {q₁. q₂}].
		r₁ isZero ifTrue: [^ parent compose: {q₁ - 1. q₂}].
		^ parent compose: {q₁. q₂ - 1}].
	self notYetImplemented.
	^ parent compose: (components with: anElement components collect: [:a :b| b isZero ifTrue: [b] ifFalse: [a // b]])! !

!ProductRingElement methodsFor: 'operations' stamp: 'len 5/21/2022 16:14:46'!
annihilator
	^ parent compose: (components collect: [:each| each annihilator])! !

!ProductRingElement methodsFor: 'operations' stamp: 'len 10/8/2022 19:38:22'!
colift: anElement
	"Answer x such that xa = b, where a is the receiver and b is the argument. Answer nil if there's no solution.
	This is the right division of b by a, written b / a."
	^ parent compose: ((1 to: self size) collect: [:i| ((self at: i) colift: (anElement at: i)) ifNil: [^ nil]])! !

!ProductRingElement methodsFor: 'operations' stamp: 'len 6/25/2023 09:57:17'!
factorizationDo: aBlock
	"Enumerate the irreducible factors of the receiver and their multiplicities."
	| one |
	self isZero ifTrue: [^ self error: 'factorization of zero'].
	one := components collect: [:each| each isZero ifTrue: [each] ifFalse: [each one]].
	components withIndexDo: [:each :i|
		each factorizationDo: [:factor :times|
			aBlock value: (parent compose: (one copy at: i put: factor; yourself)) value: times]]! !

!ProductRingElement methodsFor: 'operations' stamp: 'len 12/7/2023 16:56:49'!
gauge
	"Answer the value of the Euclidean function at the receiver."
	^ components inject: 0 asOrdinal into: [:last :each|  Ordinal ω * last + each gauge asOrdinal]! !

!ProductRingElement methodsFor: 'operations' stamp: 'len 6/1/2022 18:05:57'!
gcd: anElement
	^ parent compose: (components with: anElement components collect: [:a :b| a gcd: b])! !

!ProductRingElement methodsFor: 'operations' stamp: 'len 7/6/2023 22:51:21'!
inverse
	^ parent compose: components inverse! !

!ProductRingElement methodsFor: 'operations' stamp: 'len 6/1/2022 18:08:15'!
lcm: anElement
	^ parent compose: (components with: anElement components collect: [:a :b| a lcm: b])! !

!ProductRingElement methodsFor: 'operations' stamp: 'len 4/15/2024 09:44:15'!
lift: anElement
	^ parent compose: ((1 to: self size) collect: [:i| ((self at: i) lift: (anElement at: i)) ifNil: [^ nil]])! !

!ProductRingElement methodsFor: 'operations' stamp: 'len 7/6/2023 22:52:11'!
negated
	^ parent compose: components negated! !

!ProductRingElement methodsFor: 'operations' stamp: 'len 12/10/2021 19:20:25'!
normalization
	"Answer a unit u such that 'self * u' is a unique choice of associate. See >>normalized."
	^ parent compose: (components collect: [:each| each normalization])! !

!ProductRingElement methodsFor: 'operations' stamp: 'len 7/6/2023 22:52:23'!
squared
	^ parent compose: components squared! !

!ProductRingElement methodsFor: 'operations' stamp: 'len 12/21/2022 13:28:24'!
xgcd: anElement
	"Answer the GCD of the receiver and the argument and the Bézout coefficients.
	If the receiver is 'a', the argument is 'b' and their GCD is 'g', answer an array {g. s. t} where as + bt = g."
	| g s t |
	g _ Array new: components size.
	s _ Array new: components size.
	t _ Array new: components size.
	components withIndexDo: [:each :i|
		| xgcd |
		xgcd _ each xgcd: (anElement at: i).
		g at: i put: (xgcd at: 1).
		s at: i put: (xgcd at: 2).
		t at: i put: (xgcd at: 3)].
	^ {parent compose: g. parent compose: s. parent compose: t}! !

!ProductRingElement methodsFor: 'printing' stamp: 'len 11/16/2023 21:53:48'!
printOn: aStream
	(parent components allSatisfy: [:each| (each isKindOf: ModularIntegerRing) and: [each modulus <= 16]])
		ifTrue: [components do: [:each| each representative printOn: aStream base: 16]]
		ifFalse: [aStream print: components]! !

!ProductRingElement methodsFor: 'testing' stamp: 'len 4/25/2022 18:03:02'!
isMinusOne
	^ components allSatisfy: [:each| each isMinusOne]! !

!ProductRingElement methodsFor: 'testing' stamp: 'len 6/19/2022 12:18:00'!
isNilpotent
	"Answer true if self^n = 0 for some integer n >= 1."
	^ components allSatisfy: [:each| each isNilpotent]! !

!ProductRingElement methodsFor: 'testing' stamp: 'len 1/4/2022 11:02:15'!
isOne
	^ components allSatisfy: [:each| each isOne]! !

!ProductRingElement methodsFor: 'testing' stamp: 'len 5/4/2020 09:36:53'!
isUnit
	"Answer true if the receiver is invertible."
	^ components allSatisfy: [:each| each isUnit]! !

!ProductRingElement methodsFor: 'testing' stamp: 'len 11/24/2022 11:04:29'!
isZero
	^ components isZero! !

!ProductRingElement methodsFor: 'testing' stamp: 'len 5/7/2022 07:30:40'!
isZeroDivisor
	"Answer true if there exists a nonzero element that multiplied by the receiver is zero."
	^ components anySatisfy: [:any| any isZeroDivisor]! !

!ProductRingElement methodsFor: 'private' stamp: 'len 4/23/2020 01:37:55'!
components
	^ components! !

!ProductRingElement methodsFor: 'private' stamp: 'len 11/24/2022 17:47:07'!
components: anArray parent: aProductRing
	components _ anArray.
	parent _ aProductRing! !

!ProductRingElement class methodsFor: 'instance creation' stamp: 'len 11/24/2022 17:46:40'!
components: anArray parent: aProductRing
	^ self new components: anArray parent: aProductRing! !

!Ratio methodsFor: 'accessing' stamp: 'len 12/28/2015 20:31'!
bitSize
	^ numerator bitSize + denominator bitSize! !

!Ratio methodsFor: 'accessing' stamp: 'len 11/28/2015 06:28'!
denominator
	^ denominator! !

!Ratio methodsFor: 'accessing' stamp: 'len 11/28/2015 06:28'!
numerator
	^ numerator! !

!Ratio methodsFor: 'accessing' stamp: 'len 7/10/2019 10:45:14'!
parent
	^ numerator parent fractions! !

!Ratio methodsFor: 'accessing' stamp: 'len 11/20/2022 11:32:13'!
representative
	| F |
	F _ self parent numerators cover fractions.
	^ F !! self numerator representative / (F !! self denominator representative)! !

!Ratio methodsFor: 'accessing-multivariate' stamp: 'len 8/14/2019 08:21:18'!
degree
	^ numerator degree - denominator degree! !

!Ratio methodsFor: 'accessing-multivariate' stamp: 'len 1/7/2022 13:50:24'!
degreeIn: anIndeterminate
	^ (numerator degreeIn: anIndeterminate) - (denominator degreeIn: anIndeterminate)! !

!Ratio methodsFor: 'accessing-multivariate' stamp: 'len 10/26/2023 18:06:52'!
independentCoefficient
	self assert: self isIntegral.
	^ numerator independentCoefficient! !

!Ratio methodsFor: 'accessing-multivariate' stamp: 'len 8/14/2019 08:23:11'!
indeterminates
	^ Set new addAll: numerator indeterminates; addAll: denominator indeterminates; yourself! !

!Ratio methodsFor: 'accessing-multivariate' stamp: 'len 4/5/2024 18:58:01'!
leadingCoefficient
	self isIntegral ifFalse: [^ self error: 'not integral'].
	^ numerator leadingCoefficient! !

!Ratio methodsFor: 'accessing-multivariate' stamp: 'len 4/5/2024 18:57:52'!
leadingMonomial
	self isIntegral ifFalse: [^ self error: 'not integral'].
	^ numerator leadingMonomial! !

!Ratio methodsFor: 'accessing-multivariate' stamp: 'len 12/27/2021 07:56:32'!
leadingTerm
	^ self parent numerator: numerator leadingTerm denominator: denominator! !

!Ratio methodsFor: 'accessing-multivariate' stamp: 'len 10/11/2023 09:01:43'!
tail
	^ self parent numerator: numerator tail denominator: denominator! !

!Ratio methodsFor: 'comparing' stamp: 'len 12/4/2023 10:14:24'!
< anElement
	^ numerator * anElement denominator < (anElement numerator * denominator)! !

!Ratio methodsFor: 'comparing' stamp: 'len 7/30/2019 05:14:23'!
<= anElement
	^ numerator * anElement denominator <= (anElement numerator * denominator)! !

!Ratio methodsFor: 'comparing' stamp: 'len 1/2/2022 17:38:07'!
= anObject
	^ self class = anObject class and: [numerator * anObject denominator = (denominator * anObject numerator)]! !

!Ratio methodsFor: 'comparing' stamp: 'len 12/4/2023 10:14:32'!
> anElement
	^ anElement < self! !

!Ratio methodsFor: 'comparing' stamp: 'len 12/4/2023 10:14:37'!
>= anElement
	^ anElement <= self! !

!Ratio methodsFor: 'comparing' stamp: 'len 12/3/2023 16:08:05'!
compare: anElement
	^ numerator * anElement denominator compare: (anElement numerator * denominator)! !

!Ratio methodsFor: 'comparing' stamp: 'len 11/28/2015 06:36'!
hash
	^ 0! !

!Ratio methodsFor: 'operations' stamp: 'len 6/19/2022 10:12:03'!
* anElement
	| d1 d2 |
	(self parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #*].
	d1 _ numerator gcd: anElement denominator.
	d2 _ denominator gcd: anElement numerator.
	^ self parent
		reducedNumerator: numerator / d1 * (anElement numerator / d2)
		denominator: denominator / d2 * (anElement denominator / d1)! !

!Ratio methodsFor: 'operations' stamp: 'len 6/19/2022 11:52:06'!
+ anElement
	| n d d1 d2 u |
	(self parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #+].
	d _ denominator gcd: anElement denominator.
	n _ numerator * (d1 _ anElement denominator / d) + (anElement numerator * (d2 _ denominator / d)).
	d1 _ d1 * d2.
	n _ n / (d2 _ n gcd: d).
	d _ d1 * (d / d2).
	u _ d normalization.
	^ self parent reducedNumerator: n * u denominator: d * u! !

!Ratio methodsFor: 'operations' stamp: 'len 6/19/2022 11:59:46'!
// anElement
	"Answer the quotient of the division of the receiver by anElement."
	anElement isUnit ifTrue: [^ self * anElement inverse].
	self flag: #fix. "this looks wrong:"
	^ self parent numerator: numerator * anElement denominator // anElement numerator denominator: denominator! !

!Ratio methodsFor: 'operations' stamp: 'len 11/22/2023 21:01:46'!
^ anInteger
	anInteger = 1 ifTrue: [^ self].
	anInteger < 0 ifTrue: [^ self inverse ^ anInteger negated].
	^ self parent numerator: numerator ^ anInteger denominator: denominator ^ anInteger! !

!Ratio methodsFor: 'operations' stamp: 'len 8/12/2022 12:50:58'!
colift: anElement
	"Answer x such that xa = b, where a is the receiver and b is the argument. Answer nil if there's no solution.
	This is the right division of b by a, written b / a."
	| d1 d2 n d u |
	anElement isZero ifTrue: [^ anElement].
	d2 _ numerator gcd: anElement numerator.
	(d _ numerator / d2) isZeroDivisor ifTrue: [^ nil].
	d1 _ denominator gcd: anElement denominator.
	n _ denominator / d1 * (anElement numerator / d2).
	d _ d * (anElement denominator / d1).
	u _ d normalization.
	^ self parent reducedNumerator: n * u denominator: d * u! !

!Ratio methodsFor: 'operations' stamp: 'len 7/17/2019 11:14:07'!
height
	^ numerator height max: denominator height! !

!Ratio methodsFor: 'operations' stamp: 'len 5/29/2022 19:39:19'!
inverse
	| u |
	self isUnit ifFalse: [^ DivisibilityError new signalReceiver: self one selector: #/ argument: self].
	u _ numerator normalization.
	^ self parent reducedNumerator: denominator * u denominator: numerator * u! !

!Ratio methodsFor: 'operations' stamp: 'len 12/27/2021 07:50:51'!
negated 
	^ self parent reducedNumerator: numerator negated denominator: denominator! !

!Ratio methodsFor: 'operations' stamp: 'len 12/27/2021 07:53:53'!
normalization
	"Answer a unit u such that 'self * u' is a unique choice of associate. See >>normalized."
	self isUnit ifTrue: [^ self inverse].
	^ self parent reducedNumerator: denominator * numerator normalization denominator: denominator one! !

!Ratio methodsFor: 'operations' stamp: 'len 12/29/2021 13:59:08'!
squared
	^ self parent reducedNumerator: numerator squared denominator: denominator squared! !

!Ratio methodsFor: 'operations' stamp: 'len 5/8/2020 18:22:25'!
valuation
	"If the receiver is an element of a valuation ring or a Euclidean ring, answer its valuation or Euclidean function."
	^ numerator valuation - denominator valuation! !

!Ratio methodsFor: 'operations' stamp: 'len 7/31/2019 05:42:19'!
valuation: p
	"Answer the p-adic valuation of the receiver."
	^ (numerator valuation: p) - (denominator valuation: p)! !

!Ratio methodsFor: 'operations' stamp: 'len 1/9/2022 13:27:49'!
value: anObject
	^ (numerator value: anObject) / (denominator value: anObject)! !

!Ratio methodsFor: 'operations' stamp: 'len 1/9/2022 13:28:15'!
valueWithArguments: anArray
	^ (numerator valueWithArguments: anArray) / (denominator valueWithArguments: anArray)! !

!Ratio methodsFor: 'printing' stamp: 'len 7/16/2019 16:40:18'!
printOn: aStream
	| string |
	self isIntegral ifTrue: [aStream print: numerator. ^ self].
	aStream print: numerator; nextPutAll: ' / '.
	string _ denominator printString.
	((string includes: $+) or: [string includes: $-])
		ifTrue: [aStream nextPut: $(; print: denominator; nextPut: $)]
		ifFalse: [aStream print: denominator]! !

!Ratio methodsFor: 'testing' stamp: 'len 7/6/2022 05:58:41'!
isHomogeneous
	^ numerator isHomogeneous and: [denominator isHomogeneous]! !

!Ratio methodsFor: 'testing' stamp: 'len 1/2/2022 17:42:47'!
isIntegral
	^ denominator isOne! !

!Ratio methodsFor: 'testing' stamp: 'len 7/30/2019 05:27:02'!
isNilpotent
	"Answer true if self^n = 0 for some integer n >= 1."
	^ numerator isNilpotent! !

!Ratio methodsFor: 'testing' stamp: 'len 5/7/2022 07:28:15'!
isUnit
	"Answer true if the receiver is invertible."
	^ self isZeroDivisor not! !

!Ratio methodsFor: 'testing' stamp: 'len 11/28/2015 06:36'!
isZero
	^ numerator isZero! !

!Ratio methodsFor: 'testing' stamp: 'len 5/7/2022 07:30:48'!
isZeroDivisor
	"Answer true if there exists a nonzero element that multiplied by the receiver is zero."
	^ numerator isZeroDivisor! !

!Ratio methodsFor: 'private' stamp: 'len 6/19/2022 09:50:55'!
reduce
	| gcd u |
	numerator isZero ifTrue: [denominator _ numerator one. ^ self].
	gcd _ numerator gcd: denominator.
	numerator _ numerator / gcd.
	denominator _ denominator / gcd.
	u _ denominator normalization.
	numerator _ numerator * u.
	denominator _ denominator * u! !

!Ratio methodsFor: 'private' stamp: 'len 3/3/2021 14:21:09'!
setNumerator: anElement denominator: anotherElement
	numerator _ anElement.
	denominator _ anotherElement! !

!Ratio class methodsFor: 'instance creation' stamp: 'len 4/7/2018 00:41:16'!
reducedNumerator: anObject denominator: anotherObject
	^ self new setNumerator: anObject denominator: anotherObject! !

!Germ methodsFor: 'accessing' stamp: 'len 6/29/2019 18:19:48'!
parent
	^ parent! !

!Germ methodsFor: 'comparing' stamp: 'len 12/10/2023 10:36:24'!
= anObject
	parent = anObject parent ifFalse: [^ false].
	parent numerators isIntegralDomain
		ifTrue: [^ numerator * anObject denominator = (denominator * anObject numerator)].
	"when we have canonical associates we can do this:
	parent numerators hasCanonicalAssociates
		ifTrue: [^ (numerator * anObject denominator) normalized = (denominator * anObject numerator) normalized]."
	^ ((numerator * anObject denominator - (denominator * anObject numerator)) annihilatorIdeal ⊆ parent baseIdeal) not! !

!Germ methodsFor: 'operations' stamp: 'len 9/8/2023 17:16:28'!
// anElement
	"Answer the quotient of the Euclidean division of the receiver by the argument."
	| v |
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #//].
	anElement isZero ifTrue: [^ DivisibilityError new signalReceiver: self selector: #// argument: anElement].
	self isZero ifTrue: [^ self].
	(v := self valuation - anElement valuation) < 0 ifTrue: [^ self zero].
	^ self normalization inverse * anElement normalization * (parent base ^ v)! !

!Germ methodsFor: 'operations' stamp: 'len 9/8/2023 17:34:21'!
colift: anElement
	"Answer x such that xa = b, where a is the receiver and b is the argument. Answer nil if there's no solution.
	This is the right division of b by a, written b / a."
	| d1 d2 n d u |
	anElement isZero ifTrue: [^ anElement].
	d2 := numerator gcd: anElement numerator.
	d := numerator / d2.
	(self parent baseIdeal includes: d) ifTrue: [^ nil].
	d1 := denominator gcd: anElement denominator.
	n := denominator / d1 * (anElement numerator / d2).
	d := d * (anElement denominator / d1).
	u := d normalization.
	^ self parent reducedNumerator: n * u denominator: d * u! !

!Germ methodsFor: 'operations' stamp: 'len 6/25/2023 09:58:32'!
factorizationDo: aBlock
	"If the parent of the receiver is a DVR, this means it is an UFD with unique irreducible element up to multiplication by units."
	self isZero ifTrue: [^ self error: 'factorization of zero'].
	aBlock value: parent uniformizer value: self valuation! !

!Germ methodsFor: 'operations' stamp: 'len 5/26/2022 12:32:52'!
gcd: anElement
	self isZero ifTrue: [^ anElement normalized].
	anElement isZero ifTrue: [^ self normalized].
	^ parent uniformizer ^ (self valuation min: anElement valuation)! !

!Germ methodsFor: 'operations' stamp: 'len 6/29/2019 17:46:38'!
lcm: anElement
	self isZero ifTrue: [^ self].
	anElement isZero ifTrue: [^ anElement].
	^ parent uniformizer ^ (self valuation max: anElement valuation)! !

!Germ methodsFor: 'operations' stamp: 'len 9/8/2023 17:16:36'!
normalization
	"Answer a unit u such that 'self * u' is a unique choice of associate. See >>normalized."
	| p q u |
	self isZero ifTrue: [^ parent one].
	p := parent base.
	u := numerator normalization.
	q := numerator * u.
	[p | q] whileTrue: [q := q // p]. "TODO: optimize this, it's computing division twice"
	^ parent reducedNumerator: denominator * u denominator: q! !

!Germ methodsFor: 'operations' stamp: 'len 9/8/2023 17:16:42'!
valuation
	"Answer the p-adic valuation of the receiver."
	^ self valuation: parent base! !

!Germ methodsFor: 'printing' stamp: 'len 12/27/2021 07:51:55'!
printOn: aStream
	super printOn: aStream
"	| n u |
	(n _ self valuation) isZero ifTrue: [aStream print: fraction. ^ self].
	u _ self unit.
	(u numerator printString first = $-) ifTrue: [u _ u negated. aStream nextPut: $-].
	n ~= 0 ifTrue:
		[aStream print: parent p.
		n ~= 1 ifTrue: [aStream nextPutAll: n printString super].
		u ~= parent fractions one ifTrue: [aStream nextPut: Character dot]].
	u ~= parent fractions one ifTrue:
		[((u numerator printString includesAnyOf: ' +-') and: [(u printString beginsWith: '(') not])
			ifTrue: [aStream nextPut: $(; print: u; nextPut: $)]
			ifFalse: [aStream print: u]]"! !

!Germ methodsFor: 'testing' stamp: 'len 9/8/2023 17:34:26'!
isUnit
	"Answer true if the receiver is invertible."
	^ (parent baseIdeal includes: numerator) not! !

!Germ methodsFor: 'private' stamp: 'len 6/28/2019 13:24:53'!
parent: aLocalRing
	parent _ aLocalRing! !

!Rational methodsFor: 'accessing' stamp: 'len 7/21/2019 04:48:21'!
imaginary
	^ self zero! !

!Rational methodsFor: 'accessing' stamp: 'len 5/23/2020 09:33:01'!
parent
	^ ℚ! !

!Rational methodsFor: 'accessing' stamp: 'len 7/21/2019 04:48:12'!
real
	^ self! !

!Rational methodsFor: 'comparing' stamp: 'len 11/8/2023 09:55:30'!
< anElement
	anElement isFloat ifTrue: [^ self asFloat < anElement].
	anElement isInteger ifTrue: [^ numerator < (anElement * denominator)].
	^ numerator * anElement denominator < (anElement numerator * denominator)! !

!Rational methodsFor: 'comparing' stamp: 'len 11/9/2023 14:58:09'!
<= anElement
	anElement isFloat ifTrue: [^ self asFloat <= anElement].
	anElement isInteger ifTrue: [^ numerator <= (anElement * denominator)].
	^ numerator * anElement denominator <= (anElement numerator * denominator)! !

!Rational methodsFor: 'comparing' stamp: 'len 7/17/2019 11:23:10'!
= anObject
	anObject isInteger ifTrue: [^ denominator = 1 and: [numerator = anObject]].
	anObject isFraction ifTrue: [^ numerator = anObject numerator and: [denominator = anObject denominator]].
	^ super = anObject! !

!Rational methodsFor: 'comparing' stamp: 'len 12/3/2023 21:40:47'!
> anElement
	anElement isFloat ifTrue: [^ self asFloat > anElement].
	anElement isInteger ifTrue: [^ numerator > (anElement * denominator)].
	^ numerator * anElement denominator > (anElement numerator * denominator)! !

!Rational methodsFor: 'comparing' stamp: 'len 12/3/2023 21:41:19'!
>= anElement
	anElement isFloat ifTrue: [^ self asFloat >= anElement].
	anElement isInteger ifTrue: [^ numerator >= (anElement * denominator)].
	^ numerator * anElement denominator >= (anElement numerator * denominator)! !

!Rational methodsFor: 'comparing' stamp: 'len 5/27/2022 19:02:18'!
| anElement
	"Answer true if the receiver divides the argument."
	^ anElement isZero or: [self isZero not]! !

!Rational methodsFor: 'comparing' stamp: 'len 12/4/2023 10:33:14'!
between: min and: max 
	"Answer whether the receiver is less than or equal to the argument, max,  and greater than or equal to the argument, min."

	^self >= min and: [self <= max]! !

!Rational methodsFor: 'comparing' stamp: 'len 12/3/2023 16:07:45'!
compare: anElement
	anElement isFloat ifTrue: [^ self asFloat compare: anElement].
	anElement isInteger ifTrue: [^ numerator compare: (anElement * denominator)].
	^ numerator * anElement denominator compare: (anElement numerator * denominator)! !

!Rational methodsFor: 'comparing' stamp: 'len 7/17/2019 11:24:56'!
hash
	^ self isIntegral ifTrue: [numerator hash] ifFalse: [self asFloat hash]! !

!Rational methodsFor: 'comparing' stamp: 'len 12/4/2023 10:33:21'!
max: anElement 
	"Answer the receiver or the argument, whichever is greater."

	^ self > anElement ifTrue: [self] ifFalse: [anElement]! !

!Rational methodsFor: 'comparing' stamp: 'len 12/4/2023 10:33:26'!
min: anElement
	"Answer the receiver or the argument, whichever is lesser."

	^ self < anElement ifTrue: [self] ifFalse: [anElement]! !

!Rational methodsFor: 'comparing' stamp: 'len 12/4/2023 10:33:31'!
min: aMin max: aMax
	^ (self min: aMin) max: aMax! !

!Rational methodsFor: 'converting' stamp: 'len 7/17/2019 08:34:42'!
adaptToFloat: rcvr andSend: selector 
	"If I am involved in arithmetic with a Float, convert me to a Float."
	^ rcvr perform: selector with: self asFloat! !

!Rational methodsFor: 'converting' stamp: 'len 10/11/2023 08:48:53'!
asComplex
	^ self asNumber! !

!Rational methodsFor: 'converting' stamp: 'len 10/11/2023 08:47:31'!
asFloat
	^ self asNumber asFloat! !

!Rational methodsFor: 'converting' stamp: 'len 10/11/2023 08:33:53'!
asFraction
	^ Fraction numerator: numerator denominator: denominator! !

!Rational methodsFor: 'converting' stamp: 'len 10/11/2023 08:36:44'!
asInteger
	self assert: denominator = 1.
	^ numerator! !

!Rational methodsFor: 'converting' stamp: 'len 11/10/2023 19:18:11'!
asNumber
	"Answer the receiver as a Smalltalk number (either an Integer or a Fraction)."
	denominator = 1 ifTrue: [^ numerator].
	^ self asFraction! !

!Rational methodsFor: 'converting' stamp: 'len 11/12/2023 16:50:49'!
asRational
	^ self! !

!Rational methodsFor: 'operations' stamp: 'len 7/19/2021 11:50:32'!
* anElement
	| d1 d2 |
	anElement isFraction ifFalse: [^ super * anElement].
	d1 _ numerator gcd: anElement denominator.
	d2 _ denominator gcd: anElement numerator.
	(d2 = denominator and: [d1 = anElement denominator])
		ifTrue: [^ self class reducedNumerator: numerator // d1 * (anElement numerator // d2) denominator: 1].
	^ self class
		reducedNumerator: numerator // d1 * (anElement numerator // d2)
		denominator: denominator // d2 * (anElement denominator // d1)! !

!Rational methodsFor: 'operations' stamp: 'len 7/23/2021 11:19:08'!
+ anElement
	| d d1 d2 n |
	anElement isFraction ifFalse: [^ super + anElement].
	d _ denominator gcd: anElement denominator.
	n _ numerator * (d1 _ anElement denominator // d) + (anElement numerator * (d2 _ denominator // d)).
	d1 _ d1 * d2.
	n _ n // (d2 _ n gcd: d).
	d _ d1 * (d // d2).
	^ self class reducedNumerator: n denominator: d! !

!Rational methodsFor: 'operations' stamp: 'len 7/17/2019 03:34:48'!
abs
	^ self class reducedNumerator: numerator abs denominator: denominator! !

!Rational methodsFor: 'operations' stamp: 'len 7/21/2019 08:56:49'!
abs: p
	"Answer the p-adic absolute value of the receiver."
	^ (numerator abs: p) / (denominator abs: p)! !

!Rational methodsFor: 'operations' stamp: 'len 11/20/2023 10:25:46'!
abs²
	"Answer the square of the absolute value of the receiver."
	^ self squared! !

!Rational methodsFor: 'operations' stamp: 'len 11/10/2023 10:28:39'!
conjugate
	"Answer the complex conjugate of the receiver."
	^ self! !

!Rational methodsFor: 'operations' stamp: 'len 7/17/2019 11:13:35'!
height
	^ numerator abs max: denominator! !

!Rational methodsFor: 'operations' stamp: 'len 5/23/2020 09:33:01'!
minimalPolynomial
	^ ℚ polynomials x - self! !

!Rational methodsFor: 'operations' stamp: 'len 12/10/2021 19:19:36'!
normalization
	"Answer a unit u such that 'self * u' is a unique choice of associate. See >>normalized."
	^ self isZero ifTrue: [self one] ifFalse: [self inverse]! !

!Rational methodsFor: 'operations' stamp: 'len 7/19/2019 06:58:54'!
rounded
	"Answer the integer nearest the receiver."
	^ numerator + ((denominator bitShift: -1) * numerator sign)  // denominator! !

!Rational methodsFor: 'operations' stamp: 'len 7/17/2019 03:21:26'!
sign
	^ numerator sign! !

!Rational methodsFor: 'operations' stamp: 'len 8/3/2020 08:30:39'!
sqrt
	| n d answer |
	n _ numerator sqrt.
	d _ denominator sqrt.
	(n isInteger and: [d isInteger]) ifTrue: [^ self class reducedNumerator: n denominator: d].
	"The #sqrt method in integer will only answer a Float if there's no exact square root.
	So, we need a float anyway."
	(n isInfinite or: [d isInfinite]) ifTrue: [^ self asFloat sqrt].
	answer _ n / d.
	answer isNaN ifTrue: [^ self asFloat sqrt].
	^ answer! !

!Rational methodsFor: 'printing' stamp: 'len 10/11/2023 08:47:15'!
printOn: aStream
	self asNumber printOn: aStream
"	self isIntegral ifTrue: [aStream print: numerator. ^ self].
	aStream nextPutAll: numerator printString super; nextPut: $/; nextPutAll: denominator printString sub"! !

!Rational methodsFor: 'printing' stamp: 'len 10/11/2023 08:47:22'!
printOn: aStream base: base
	^ self asNumber printOn: aStream base: base! !

!Rational methodsFor: 'testing' stamp: 'len 10/11/2023 20:55:12'!
isFraction
	"Rationals are polymorphic with Fractions."
	^ true! !

!Rational methodsFor: 'testing' stamp: 'len 10/11/2023 20:55:44'!
isNumber
	"Rationals are polymorphic with Fractions, so they also behave as Numbers."
	^ true! !

!Rational methodsFor: 'testing' stamp: 'len 7/21/2019 12:45:17'!
isRational
	^ true! !

!Rational methodsFor: 'testing' stamp: 'len 7/21/2019 12:46:51'!
isReal
	^ true! !

!Rational methodsFor: 'testing' stamp: 'len 5/8/2020 17:00:34'!
isUnit
	^ self isZero not! !

!Rational methodsFor: 'testing' stamp: 'len 7/19/2019 07:29:10'!
negative
	^ numerator negative! !

!Rational methodsFor: 'testing' stamp: 'len 7/19/2019 07:29:02'!
positive
	^ numerator positive! !

!Rational methodsFor: 'testing' stamp: 'len 7/19/2019 07:29:26'!
strictlyPositive
	^ numerator strictlyPositive! !

!RationalFunction methodsFor: 'operations' stamp: 'len 6/28/2023 18:54:23'!
derivative
	| a g |
	a := denominator * numerator derivative - (numerator * denominator derivative).
	g := denominator gcd: a.
	^ self parent reducedNumerator: a // g denominator: (denominator // g) squared * g! !

!RationalFunction methodsFor: 'operations' stamp: 'len 6/28/2023 18:55:22'!
derivativeIn: anIndeterminate
	| a g |
	a := denominator * (numerator derivativeIn: anIndeterminate) - (numerator * (denominator derivativeIn: anIndeterminate)).
	g := denominator gcd: a.
	^ self parent reducedNumerator: a // g denominator: (denominator // g) squared * g! !

!RationalFunction methodsFor: 'operations' stamp: 'len 6/28/2023 18:57:11'!
homogenized
	"Answer the homogenization of the receiver introducing a new indeterminate."
	^ self parent numerators homogenization fractions reducedNumerator: numerator homogenized denominator: denominator homogenized! !

!RationalFunction methodsFor: 'operations' stamp: 'len 1/2/2022 09:43:18'!
homogenizedIn: anIndeterminate
	"Answer the homogenization of the receiver in the given indeterminate."
	^ self parent numerator: (numerator homogenizedIn: anIndeterminate) denominator: (denominator homogenizedIn: anIndeterminate)! !

!RationalFunction methodsFor: 'printing' stamp: 'len 9/29/2022 13:57:58'!
printOn: aStream
	| n d |
	n _ numerator orderedBy: #lgrevlex.
	d _ denominator orderedBy: #lgrevlex.
	d isOne ifTrue: [aStream print: n. ^ self].
	n terms size > 1
		ifTrue: [aStream nextPut: $(; print: n; nextPut: $)]
		ifFalse: [aStream print: n].
	aStream nextPutAll: ' / '.
	d terms size > 1
		ifTrue: [aStream nextPut: $(; print: d; nextPut: $)]
		ifFalse: [aStream print: d]! !

!RationalFunction methodsFor: 'roots and poles' stamp: 'len 3/24/2018 20:30:55'!
allPoles
	^ denominator allRoots! !

!RationalFunction methodsFor: 'roots and poles' stamp: 'len 3/24/2018 20:30:46'!
allPolesIn: aRing
	^ denominator allRootsIn: aRing! !

!RationalFunction methodsFor: 'roots and poles' stamp: 'len 3/24/2018 20:30:17'!
allRoots
	^ numerator allRoots! !

!RationalFunction methodsFor: 'roots and poles' stamp: 'len 3/24/2018 20:30:25'!
allRootsIn: aRing
	"Answer the roots (counted with multiplicity) in the given domain."
	^ numerator allRootsIn: aRing! !

!RationalFunction methodsFor: 'roots and poles' stamp: 'len 12/4/2017 20:39:51'!
orderAt: aNumber
	^ (numerator multiplicityAt: aNumber) - (denominator multiplicityAt: aNumber)! !

!RationalFunction methodsFor: 'roots and poles' stamp: 'len 2/12/2016 02:56'!
poles
	^ denominator roots! !

!RationalFunction methodsFor: 'roots and poles' stamp: 'len 3/24/2018 20:30:38'!
polesIn: aRing
	^ denominator rootsIn: aRing! !

!RationalFunction methodsFor: 'roots and poles' stamp: 'len 2/12/2016 02:56'!
roots
	^ numerator roots! !

!RationalFunction methodsFor: 'roots and poles' stamp: 'len 3/24/2018 20:30:33'!
rootsIn: aRing
	^ numerator rootsIn: aRing! !

!RationalFunction methodsFor: 'testing' stamp: 'len 8/8/2019 08:42:14'!
isAffineLinear
	^ numerator isAffineLinear and: [denominator isConstant]! !

!RationalFunction methodsFor: 'testing' stamp: 'len 6/27/2023 15:49:52'!
isConstant
	^ numerator isConstant and: [denominator isConstant]! !

!RationalFunction methodsFor: 'testing' stamp: 'len 10/17/2016 09:39'!
isLinear
	^ denominator isLinear and: [denominator isConstant]! !

!Residue methodsFor: 'accessing' stamp: 'len 10/7/2023 12:20:43'!
at: anIntegerOrMonomial
	^ representative at: anIntegerOrMonomial! !

!Residue methodsFor: 'accessing' stamp: 'len 12/28/2015 20:32'!
bitSize
	^ representative bitSize! !

!Residue methodsFor: 'accessing' stamp: 'len 10/7/2023 12:21:47'!
coefficients
	| coefficients n |
	n := parent degree.
	coefficients := representative coefficients.
	coefficients size = n ifTrue: [^ coefficients].
	^ (parent scalars zeros: n) replaceFrom: 1 to: coefficients size with: coefficients! !

!Residue methodsFor: 'accessing' stamp: 'len 8/14/2019 04:35:05'!
lift
	^ representative! !

!Residue methodsFor: 'accessing' stamp: 'len 11/30/2016 19:16:51'!
modulus
	^ parent modulus! !

!Residue methodsFor: 'accessing' stamp: 'len 10/16/2016 15:57'!
one
	^ parent one! !

!Residue methodsFor: 'accessing' stamp: 'len 11/3/2016 04:43'!
parent
	^ parent! !

!Residue methodsFor: 'accessing' stamp: 'len 11/25/2015 03:11'!
representative
	^ representative! !

!Residue methodsFor: 'accessing' stamp: 'len 10/16/2016 15:58'!
zero
	^ parent zero! !

!Residue methodsFor: 'accessing-multivariate' stamp: 'len 8/14/2019 08:10:39'!
degree
	^ representative degree! !

!Residue methodsFor: 'accessing-multivariate' stamp: 'len 1/9/2022 13:21:42'!
degreeIn: anIndeterminate
	^ representative degreeIn: anIndeterminate! !

!Residue methodsFor: 'accessing-multivariate' stamp: 'len 8/14/2019 08:10:49'!
independentCoefficient
	^ representative independentCoefficient! !

!Residue methodsFor: 'accessing-multivariate' stamp: 'len 8/14/2019 08:10:54'!
indeterminates
	^ representative indeterminates! !

!Residue methodsFor: 'accessing-multivariate' stamp: 'len 8/14/2019 08:11:05'!
leadingCoefficient
	^ representative leadingCoefficient! !

!Residue methodsFor: 'accessing-multivariate' stamp: 'len 8/14/2019 08:11:10'!
leadingMonomial
	^ representative leadingMonomial! !

!Residue methodsFor: 'accessing-multivariate' stamp: 'len 8/14/2019 08:11:16'!
leadingTerm
	^ parent representative: representative leadingTerm! !

!Residue methodsFor: 'accessing-multivariate' stamp: 'len 8/14/2019 08:11:56'!
tail
	^ parent representative: representative tail! !

!Residue methodsFor: 'comparing' stamp: 'len 6/10/2022 11:52:50'!
= anObject
	parent = anObject parent ifFalse: [^ false].
	^ parent cover hasCanonicalReduction
		ifTrue: [representative = anObject representative]
		ifFalse: [self contains: anObject representative]! !

!Residue methodsFor: 'comparing' stamp: 'len 6/10/2022 11:53:16'!
hash
	^ parent cover hasCanonicalReduction ifTrue: [representative hash] ifFalse: [parent hash]! !

!Residue methodsFor: 'operations' stamp: 'len 8/14/2019 04:33:31'!
* anElement
	anElement isInteger ifTrue: [^ parent project: representative * anElement].
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #*].
	^ parent project: representative * anElement representative! !

!Residue methodsFor: 'operations' stamp: 'len 8/14/2019 04:33:18'!
+ anElement
	(parent includes: anElement) ifFalse: [^ self  adapt: anElement andSend: #+].
	^ parent project: representative + anElement representative! !

!Residue methodsFor: 'operations' stamp: 'len 5/29/2022 19:39:19'!
// anElement
	"Answer the quotient of the division of the receiver by the argument."
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #//].
	anElement isZero ifTrue: [^ DivisibilityError new signalReceiver: self selector: #// argument: anElement].
	self isZero ifTrue: [^ self].
	^ parent representative: (representative quotientBy: anElement representative modulo: parent modulus)
	
"alternative:
	^ self - (self \\ anElement) / b
"! !

!Residue methodsFor: 'operations' stamp: 'len 6/10/2022 11:52:56'!
annihilator
	"Answer a generator of the ideal of all elements that multiplied by the receiver are zero."
	| xgcd |
	parent cover isEuclidean ifFalse: [^ super annihilator].
	xgcd _ representative xgcd: parent modulus.
	^ parent project: ((xgcd at: 2) annihilator gcd: parent modulus // (xgcd at: 1))! !

!Residue methodsFor: 'operations' stamp: 'len 6/10/2022 11:53:00'!
annihilatorIdeal
	"Answer the ideal of all elements that multiplied by the receiver are zero."
	parent cover isPIR ifFalse: [^ super annihilatorIdeal].
	^ parent * self annihilator! !

!Residue methodsFor: 'operations' stamp: 'len 6/20/2023 19:19:21'!
colift: anElement
	"Answer x such that xa = b, where a is the receiver and b is the argument. Answer nil if there's no solution.
	This is the right division of b by a, written b / a."
	anElement isZero ifTrue: [^ anElement].
	parent cover isEuclidean ifTrue:
		[| xgcd |
		xgcd := representative xgcd: self modulus.
		^ parent project: (xgcd at: 2) * (anElement representative / (xgcd at: 1))].
"	parent isEuclidean ifTrue:
		[| division | ^ (division := anElement divisionBy: self) remainder isZero ifTrue: [division quotient]]."
	^ (self asSingletonMatrix colift: anElement asSingletonMatrix) ifNotNil: [:aMatrix| aMatrix asScalar]! !

!Residue methodsFor: 'operations' stamp: 'len 10/16/2022 10:40:36'!
gauge
	"Answer the value of the Euclidean function at the receiver."
	^ self normalized lift gauge "assuming the lift has minimal Euclidean valuation in the cover ring"! !

!Residue methodsFor: 'operations' stamp: 'len 8/5/2022 09:44:00'!
gcd: anElement
	parent cover isEuclidean ifFalse: [^ super gcd: anElement].
	^ (parent project: (representative gcd: anElement representative)) normalized! !

!Residue methodsFor: 'operations' stamp: 'len 6/10/2022 11:53:25'!
inverse
	| xgcd |
	self isOne ifTrue: [^ self].
	parent cover isEuclidean ifFalse: [^ super inverse].
	xgcd _ representative xgcd: self modulus.
	(xgcd at: 1) isOne ifFalse: [^ DivisibilityError new signalReceiver: self one selector: #/ argument: self].
	^ parent project: (xgcd at: 2)! !

!Residue methodsFor: 'operations' stamp: 'len 10/7/2023 12:26:26'!
inverse2
	"Assuming the receiver is an element of an affine algebra, answer the inverse of the receiver.
	See [KSWZ17]."
	| R S y z X G T P Q Q0 P1 |
	self isOne ifTrue: [^ self].
	R := parent cover.
	"Should we require something on the coefficients ring? Must it be a PIR or Euclidean?"
	(R isEuclidean or: [parent relators size = 1 and: [self modulus leadingCoefficient isUnit]]) ifTrue:
		[| euclid |
		euclid := representative xgcd: self modulus.
		^ (euclid at: 1) isOne ifTrue: [parent project: (euclid at: 2)]].
	y := R rank + 1.
	z := R rank + 2.
	S := R scalars polynomialsIn: R rank + 2 ordering: (MonomialOrdering lex: {y. z}), (MonomialOrdering grevlex: R indeterminates).
	self assert: (S monomials x: y) > (S monomials x: z).
	1 to: R rank do: [:i| self assert: (S monomials x: z) > (S monomials x: i)].
	X := OrderedCollection new.
	parent relators do: [:g| X add: S !! g].
	X add: S !! representative * (S x: y) - (S x: z).
	G := (S * X) basis.
	T := S extract: {y. z}.
	P := [:s|
		| answer |
		answer := OrderedCollection new.
		G do: [:g| | h | h := T !! g. (h leadingMonomial degreeIn: 1) = 0 and: [(h leadingMonomial degreeIn: 2) <= s ifTrue: [answer add: R !! h leadingCoefficient]]].
		answer].
	Q := [:s|
		| answer |
		answer := OrderedCollection new.
		G do: [:g| | h | h := T !! g. (h leadingMonomial degreeIn: 1) = 1 and: [(h leadingMonomial degreeIn: 2) <= s ifTrue: [answer add: R !! h leadingCoefficient]]].
		answer].
	Q0 := Q value: 0.
	(Q0 anySatisfy: [:any| any isUnit]) ifFalse: [^ nil].
	P1 := P value: 1.
	(P1 noneSatisfy: [:none| none isUnit]) ifFalse: [^ nil].
	^ G! !

!Residue methodsFor: 'operations' stamp: 'len 10/16/2016 15:57'!
negated
	^ parent project: representative negated! !

!Residue methodsFor: 'operations' stamp: 'len 11/26/2023 21:02:11'!
normalization
	"Answer a unit u such that 'self * u' is a unique choice of associate. See >>normalized."
	"Adapted from ModularInteger>>\. This algorithm solves the congruence ax = self (mod m) where 'a' is the canonical associate of the receiver, and then looks for a solution 'x' that is a unit."
	| a x modulus m euclid |
	self isUnit ifTrue: [^ self inverse].
	self isZero ifTrue: [^ parent one].
	self flag: #fix. "optimize and generalize for when cover is not a PIR"
	"See [Sto00], pag. 15."
	parent cover isEuclidean ifFalse: [^ self notYetImplemented].
	a := representative gcd: (modulus := parent modulus).
	a isOne ifTrue: [^ self inverse].
	x := representative // a.
	m := modulus // a.
	[(euclid := x xgcd: modulus) first isOne] whileFalse: [x := x + m].
	^ parent project: euclid second! !

!Residue methodsFor: 'operations' stamp: 'len 5/30/2023 13:42:36'!
squared
	^ parent project: representative squared! !

!Residue methodsFor: 'operations' stamp: 'len 6/10/2022 11:53:35'!
stabilizerWith: b modulo: N
	"If the receiver is 'a', answer 'c' such that '<a + cb, N> = <a, b, N>'."
	parent cover isEuclidean ifFalse: [^ self notYetImplemented].
	parent project: (representative stabilizerWith: b representative modulo: (N representative gcd: parent modulus))! !

!Residue methodsFor: 'operations' stamp: 'len 6/14/2022 18:00:14'!
valuation
	"If the receiver is an element of a valuation ring or a Euclidean ring, answer its valuation or Euclidean function."
	^ self normalized lift valuation "assuming the lift has minimal valuation in the cover ring"! !

!Residue methodsFor: 'operations' stamp: 'len 8/14/2019 08:11:36'!
value: anObject
	^ representative value: anObject! !

!Residue methodsFor: 'operations' stamp: 'len 8/14/2019 08:11:41'!
valueWithArguments: anArray
	^ representative valueWithArguments: anArray! !

!Residue methodsFor: 'operations' stamp: 'len 12/21/2022 13:28:27'!
xgcd: anElement
	"Answer the GCD of the receiver and the argument and the Bézout coefficients.
	If the receiver is 'a', the argument is 'b' and their GCD is 'g', answer an array {g. s. t} where as + bt = g."
	| xgcd g u |
	parent cover isEuclidean ifFalse: [^ super xgcd: anElement].
	xgcd _ representative xgcd: anElement representative.
	g _ parent project: (xgcd at: 1).
	u _ g normalization.
	^ {g * u. (parent project: (xgcd at: 2)) * u. (parent project: (xgcd at: 3)) * u}! !

!Residue methodsFor: 'operations' stamp: 'len 6/10/2022 11:53:43'!
xxgcd: anElement
	"(More) Extended GCD.
	If the receiver is 'a', the argument is 'b' and their GCD is 'g'. answer an array {g. s. t. u. v} where as + bt = g, au + bv = 0, and sv - ut = 1, i.e. answer the coefficients of a unimodular matrix such that:.
		[s  t] [a]     [g]
		[u v] [b] = [0]."
	| xxgcd g s t u v x |
	(self isZero and: [anElement isZero]) ifTrue: [^ {self. self parent one. self. self. self parent one}].
	parent cover isEuclidean ifFalse: [^ super xxgcd: anElement].
	xxgcd _ representative xxgcd: anElement representative.
	g _ parent project: (xxgcd at: 1).
	x _ g normalization.
	g _ g * x.
	s _ (parent project: (xxgcd at: 2)) * x.
	t _ (parent project: (xxgcd at: 3)) * x.
	u _ (parent project: (xxgcd at: 4)) * x.
	v _ (parent project: (xxgcd at: 5)) * x.
	x _ (s*v - (u*t)) inverse.
	u _ u * x.
	v _ v * x.
	^ {g. s. t. u. v}! !

!Residue methodsFor: 'operations' stamp: 'len 10/7/2023 12:25:50'!
∘ anElement
	"Answer the modular composition of the receiver with the argument, assuming they are elements of a univariate affine algebra."
	^ representative composeWith: anElement representative modulo: parent modulus! !

!Residue methodsFor: 'printing' stamp: 'len 11/14/2023 13:24:04'!
printOn: aStream
	parent printRepresentative: representative on: aStream! !

!Residue methodsFor: 'testing' stamp: 'len 5/24/2022 06:31:10'!
contains: anElement
	^ parent relations contains: anElement - representative! !

!Residue methodsFor: 'testing' stamp: 'len 6/10/2022 11:53:20'!
includes: anObject
	^ (parent cover includes: anObject) and: [self contains: anObject]! !

!Residue methodsFor: 'testing' stamp: 'len 7/6/2022 05:59:03'!
isHomogeneous
	^ representative isHomogeneous! !

!Residue methodsFor: 'testing' stamp: 'len 6/10/2022 11:53:28'!
isUnit
	"Answer true if the receiver is invertible."
	parent cover isEuclidean ifTrue: [^ ((representative xgcd: self modulus) at: 1) isOne].
	^ super isUnit! !

!Residue methodsFor: 'testing' stamp: 'len 5/24/2022 06:32:19'!
isZero
	^ representative isZero "the representative of 0 is ensured to be 0"! !

!Residue methodsFor: 'testing' stamp: 'len 10/7/2023 12:25:25'!
isZeroDivisor2
	"Assuming the receiver is an element of an affine algebra, answer true if it is a zero divisor.
	See [KSWZ17]."
	| R S y z X G T P P0 P1 |
	R := parent cover.
	y := R rank + 1.
	z := R rank + 2.
	S := R scalars polynomialsIn: R rank + 2 ordering: (MonomialOrdering lex: {y. z}), (MonomialOrdering grevlex: R indeterminates).
	self assert: (S monomials x: y) > (S monomials x: z).
	1 to: R rank do: [:i| self assert: (S monomials x: z) > (S monomials x: i)].
	X := OrderedCollection new.
	parent relators do: [:g| X add: S !! g].
	X add: S !! representative * (S x: y) - (S x: z).
	G := (S * X) basis.
	T := S extract: {y. z}.
	P := [:s|
		| answer |
		answer := OrderedCollection new.
		G do: [:g| | h | h := T !! g. (h leadingMonomial degreeIn: 1) = 0 and: [(h leadingMonomial degreeIn: 2) <= s ifTrue: [answer add: R !! h leadingCoefficient]]].
		answer].
"	Q _ [:s|
		| answer |
		answer _ OrderedCollection new.
		G do: [:g| | h | h _ T !! g. (h leadingMonomial degreeIn: 1) = 1 and: [(h leadingMonomial degreeIn: 2) <= s ifTrue: [answer add: R !! h leadingCoefficient]]].
		answer]."
	P0 := P value: 0.
	P1 := P value: 1.
	^ P0 size <= P1 size and: [P1 noneSatisfy: [:none| none isUnit]]! !

!Residue methodsFor: 'private' stamp: 'len 6/16/2023 18:23:54'!
representative: anElement parent: aQuotientRing
	representative := anElement.
	parent := aQuotientRing! !

!Residue methodsFor: 'converting' stamp: 'len 10/7/2023 12:23:40'!
asRationalFunction
	"Answer the rational function reconstruction of the receiver, or nil if it doesn't exist.
	This is Wang's rational reconstruction algorithm extended to rational functions."
	| f g M N r0 r1 t0 t1 |
	self assert: self parent scalars isField.
	self assert: self parent isUnivariate.
	f := self parent modulus.
	g := self representative.
	M := f degree.
	N := M // 2.
	"D _ M - N - 1."
	r0 := f. t0 := f parent zero.
	r1 := g. t1 := f parent one.
	[r1 degree > N]
		whileTrue:
			[| q temp |
			q := r0 // r1.
			temp := r0.
			r0 := r1.
			r1 := temp - (q*r1).
			temp := t0.
			t0 := t1.
			t1 := temp - (q*t1)].
	(r1 gcd: t1) isOne ifFalse: [^ nil].
	^ self parent cover fractions
		reducedNumerator: r1 / t1 leadingCoefficient
		denominator: t1 / t1 leadingCoefficient! !

!Residue class methodsFor: 'instance creation' stamp: 'len 6/16/2023 18:24:32'!
representative: anElement parent: aQuotientRing
	^ self new representative: anElement parent: aQuotientRing! !

!GaloisRingElement methodsFor: 'accessing' stamp: 'len 7/14/2023 12:29:38'!
expansion
	"Answer the coefficients of the p-adic expansion of the receiver."
	| answer |
	answer := Array new: parent exponent withAll: self zero.
	representative coefficients withIndexDo: [:a :i|
		a expansion withIndexDo: [:b :j| answer at: j add: parent x^(i-1) * b]].
	^ answer! !

!GaloisRingElement methodsFor: 'accessing' stamp: 'len 6/2/2023 15:01:11'!
unitPart
	self isZero ifTrue: [^ parent one].
	^ parent representative: representative primitivePart! !

!GaloisRingElement methodsFor: 'operations' stamp: 'len 4/26/2022 09:13:25'!
* anElement
	(anElement isInteger or: [parent scalars includes: anElement])
		ifTrue: [^ parent representative: representative * anElement].
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #*].
	^ parent project: representative * anElement representative! !

!GaloisRingElement methodsFor: 'operations' stamp: 'len 4/26/2022 09:10:36'!
+ anElement
	(parent includes: anElement) ifFalse: [^ self  adapt: anElement andSend: #+].
	^ parent representative: representative + anElement representative! !

!GaloisRingElement methodsFor: 'operations' stamp: 'len 4/26/2022 09:11:38'!
- anElement
	(parent includes: anElement) ifFalse: [^ self  adapt: anElement andSend: #-].
	^ parent representative: representative - anElement representative! !

!GaloisRingElement methodsFor: 'operations' stamp: 'len 9/8/2023 17:07:13'!
// anElement
	"Answer the quotient of the Euclidean division of the receiver by the argument."
	| v |
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #//].
	anElement isZero ifTrue: [^ DivisibilityError new signalReceiver: self selector: #// argument: anElement].
	self isZero ifTrue: [^ self].
	(v := self valuation - anElement valuation) < 0 ifTrue: [^ self zero].
	^ self unitPart * anElement normalization * (parent base ^ v)! !

!GaloisRingElement methodsFor: 'operations' stamp: 'len 6/3/2022 07:24:49'!
annihilator
	"Answer a generator of the ideal of all elements that multiplied by the receiver are zero."
	^ parent project: representative annihilator! !

!GaloisRingElement methodsFor: 'operations' stamp: 'len 6/4/2023 14:27:21'!
colift: anElement
	"Answer x such that xa = b, where a is the receiver and b is the argument. Answer nil if there's no solution.
	This is the right division of b by a, written b / a."
	| division |
	anElement isZero ifTrue: [^ anElement].
	^ (division := anElement divisionBy: self) remainder isZero ifTrue: [division quotient]! !

!GaloisRingElement methodsFor: 'operations' stamp: 'len 10/16/2022 10:42:50'!
gauge
	"Answer the value of the Euclidean function at the receiver."
	^ self valuation! !

!GaloisRingElement methodsFor: 'operations' stamp: 'len 6/10/2022 11:54:10'!
gcd: anElement
	self isZero ifTrue: [^ anElement normalized].
	anElement isZero ifTrue: [^ self normalized].
	^ parent representative: (parent cover constant: (representative content gcd: anElement representative content))! !

!GaloisRingElement methodsFor: 'operations' stamp: 'len 12/7/2023 16:54:49'!
generalizedFrobenius
	"Answer the result of applying the generalized Frobenius automorphism to the receiver."
	| p |
	p := self parent base.
	^ self expansion reversed inject: self zero into: [:last :each| last * p + (each ^ p)]! !

!GaloisRingElement methodsFor: 'operations' stamp: 'len 10/26/2023 18:07:16'!
generalizedTrace
	"Answer the generalized trace of the receiver. This is a generalization of the trace of Galois fields to Galois rings."
	| answer x |
	answer := self.
	x := self.
	self parent degree - 1 timesRepeat:
		[x := x generalizedFrobenius.
		answer := answer + x].
	^ answer independentCoefficient! !

!GaloisRingElement methodsFor: 'operations' stamp: 'len 6/4/2023 14:33:26'!
inverse
	"If an element u is a unit of GR(p^m,r), and N = (p^r - 1)*(p^(m-1)), then u^N = 1.
	This means that the inverse of u can be computed as u^(N-1). See [EIP00].
	For Galois fields this is faster than using the extended Euclidean algorithm to compute the inverse."
	self isUnit ifFalse: [^ DivisibilityError new signalReceiver: self one selector: #/ argument: self].
	self isOne ifTrue: [^ self].
	^ parent representative: (representative raisedTo: parent inversionExponent modulo: parent modulus)! !

!GaloisRingElement methodsFor: 'operations' stamp: 'len 6/10/2022 11:54:13'!
lcm: anElement
	self isZero ifTrue: [^ self].
	anElement isZero ifTrue: [^ anElement].
	^ parent representative: (parent cover constant: (representative content lcm: anElement representative content))! !

!GaloisRingElement methodsFor: 'operations' stamp: 'len 4/26/2022 09:11:23'!
negated
	^ parent representative: representative negated! !

!GaloisRingElement methodsFor: 'operations' stamp: 'len 6/2/2023 15:00:54'!
normalization
	"Answer a unit u such that 'self * u' is a unique choice of associate. See >>normalized."
	^ self unitPart inverse! !

!GaloisRingElement methodsFor: 'operations' stamp: 'len 6/25/2019 02:34:22'!
valuation
	^ representative content valuation! !

!GaloisRingElement methodsFor: 'testing' stamp: 'len 5/7/2022 07:28:43'!
isNilpotent
	"Answer true if self^n = 0 for some integer n >= 1."
	^ self isZeroDivisor! !

!GaloisRingElement methodsFor: 'testing' stamp: 'len 5/7/2022 07:38:36'!
isUnit
	"Answer true if the argument is invertible.
	An element in a finite ring is either a unit or a zero divisor."
	^ self isZeroDivisor not! !

!GaloisRingElement methodsFor: 'testing' stamp: 'len 5/7/2022 07:29:37'!
isZeroDivisor
	"Answer true if there exists a nonzero element that multiplied by the receiver is zero."
	^ representative coefficients allSatisfy: [:each| each isZeroDivisor]

"alternative:
	^ parent maximalIdeal contains: self
"! !

!GaloisFieldElement methodsFor: 'accessing' stamp: 'len 6/2/2023 15:03:46'!
unitPart
	self isZero ifTrue: [^ parent one].
	^ self! !

!GaloisFieldElement methodsFor: 'comparing' stamp: 'len 5/27/2022 19:02:05'!
| anElement
	"Answer true if the receiver divides the argument."
	^ anElement isZero or: [self isZero not]! !

!GaloisFieldElement methodsFor: 'operations' stamp: 'len 5/28/2023 19:47:56'!
^ anInteger
	"Answer the receiver raised to the power anInteger."
	anInteger = 0 ifTrue: [^ self one].
	self isZero ifTrue: [^ self].
	anInteger isFraction ifTrue: [^ (self root: anInteger denominator) ^ anInteger numerator].
	^ parent representative: (representative raisedTo: anInteger \\ (parent size - 1) modulo: parent modulus)! !

!GaloisFieldElement methodsFor: 'operations' stamp: 'len 6/4/2023 17:29:47'!
colift: anElement
	"Answer x such that xa = b, where a is the receiver and b is the argument. Answer nil if there's no solution.
	This is the right division of b by a, written b / a."
	anElement isZero ifTrue: [^ anElement].
	^ self isZero ifFalse: [anElement * self inverse]! !

!GaloisFieldElement methodsFor: 'operations' stamp: 'len 10/24/2023 21:12:42'!
conjugates
	"Answer the Galois conjugates of the receiver."
	^ Iterator on: [:aBlock| self conjugatesDo: aBlock]! !

!GaloisFieldElement methodsFor: 'operations' stamp: 'len 10/24/2023 21:27:14'!
conjugatesDo: aBlock
	"Iterate over the Galois conjugates of the receiver."
	| p α |
	p := self parent characteristic.
	aBlock value: 	(α := self).
	self parent degree - 1 timesRepeat: [aBlock value: (α := α ^ p)]! !

!GaloisFieldElement methodsFor: 'operations' stamp: 'len 10/24/2023 10:29:52'!
frobenius
	"Answer the result of applying the Frobenius automorphism to the receiver."
	^ self ^ self parent characteristic! !

!GaloisFieldElement methodsFor: 'operations' stamp: 'len 12/6/2023 09:35:48'!
inverse
	"Inverse using Lagrange's theorem and addition chains. See [Coh+05. Algorithm 11.47].
	Note: this can be generalized to Galois rings."
	| q d a b y T i k j |
	self flag: #fixme. "generalize to Galois rings"
	self isOne ifTrue: [^ self].
	q := self parent characteristic.
	d := self parent degree.
	a := self parent propertyAt: #chain1 ifAbsentPut: [AdditionChain min: q - 2].
	b := self parent propertyAt: #chain2 ifAbsentPut: [AdditionChain min: d - 1].
	y := a raise: self.
	T := Array new: b size.
	T at: 1 put: self * y.
	i := 2.
	[i <= b size] whileTrue:
		[j := b j: i.
		k := b k: i.
		T at: i put: ((T at: k) ^ (q^(b at: j))) * (T at: j).
		i := i + 1].
	^ y * (T last ^ q)! !

!GaloisFieldElement methodsFor: 'operations' stamp: 'len 10/30/2023 09:39:52'!
minimalPolynomialAlong: aMorphism
	"Given a field embedding, answer the minimal polynomial of the receiver (an element of the codomain) over the domain."
	| E F d bound y A |
	E := aMorphism domain.
	F := aMorphism codomain.
	self assert: F == parent.
	d := F degree / E degree.
	bound := d*2.
	y := F one.
	A := Array new: bound.
	1 to: bound - 1 do: [:i|
		A at: i put: (aMorphism preimageElement: y).
		y := y * self].
	A at: bound put: (aMorphism preimageElement: y).
	^ E polynomials berlekampMassey: A! !

!GaloisFieldElement methodsFor: 'operations' stamp: 'len 5/9/2022 11:09:52'!
normalized
	"Answer a unique choice of associate. See >>normalization."
	self isZero ifTrue: [^ self].
	^ parent one! !

!GaloisFieldElement methodsFor: 'operations' stamp: 'len 6/12/2023 17:54:04'!
sqrt
	self parent characteristic = 2 ifTrue: [^ self ^ (self parent size // 2)]. "this could also be computed with lookup table like squares!!"
	^ super sqrt! !

!GaloisFieldElement methodsFor: 'testing' stamp: 'len 11/7/2023 11:08:42'!
isNormal
	"If the receiver is α in GF(q^n) over GF(q), answer true if α, α^q, ..., α^(q^(n-1)) is a basis of GF(q^n) over GF(q)."
	| a n q rows |
	q := self parent scalars size.
	n := self parent degree.
	a := self.
	rows := OrderedCollection new: n.
	rows add: a coefficients.
	n-1 timesRepeat: [a := a ^ q. rows add: a coefficients].
	^ (self parent asModule endomorphisms rows: rows) rank = n! !

!GaloisFieldElement methodsFor: 'testing' stamp: 'len 7/16/2023 15:51:36'!
isPrimitiveRoot
	"Answer true if the receiver is a generator of the group of units.
	For GF(p^n) this is a primitive (p^n - 1)-th root of unity."
	^ self multiplicativeOrder = self parent units size! !

!GaloisFieldElement methodsFor: 'testing' stamp: 'len 6/26/2023 01:36:23'!
isSquare
	"Answer true if the receiver is a perfect square, i.e. it has a square root."
	"In characteristic 2 all elements are perfect squares."
	^ self parent characteristic = 2 or: [super isSquare]! !

!GaloisFieldElement methodsFor: 'testing' stamp: 'len 5/9/2022 11:07:52'!
isZeroDivisor
	"Answer true if there exists a nonzero element that multiplied by the receiver is zero."
	^ self isZero! !

!ModularInteger methodsFor: 'accessing' stamp: 'len 4/21/2016 05:55'!
bitSize
	^ representative bitSize! !

!ModularInteger methodsFor: 'accessing' stamp: 'len 4/4/2021 09:51:40'!
lift
	"Answer a balanced integer representative."
	| m |
	m _ parent modulus.
	^ representative <= (m >> 1) ifTrue: [representative] ifFalse: [representative - m]! !

!ModularInteger methodsFor: 'accessing' stamp: 'len 3/29/2016 20:49'!
representative
	^ representative! !

!ModularInteger methodsFor: 'accessing' stamp: 'len 6/2/2023 15:02:08'!
unitPart
	"Adapted from ModularInteger>>\. This algorithm solves the congruence ax = self (mod m) where 'a' is the canonical associate of the receiver, and then looks for a solution 'x' that is a unit."
	| a x modulus m |
	self isZero ifTrue: [^ parent one].
	a := representative gcd: (modulus := parent modulus).
	a = 1 ifTrue: [^ self].
	x := representative // a.
	m := modulus // a.
	[(x gcd: modulus) = 1] whileFalse: [x := x + m]. "at most 'a' solutions, and some is guaranteed to be a unit"
	^ parent project: x

"alternative 1 (similar as above but computes extra GCDs and creates extra elements):
	^ self normalized \ self detect: [:u| u isUnit]"
	
"alternative 2 (bruteforce):
	| associate |
	associate _ self normalized.
	^ self units detect: [:u| associate * u = self]"! !

!ModularInteger methodsFor: 'comparing' stamp: 'len 6/5/2022 19:30:27'!
= anObject
	^ parent = anObject parent and: [representative = anObject representative]! !

!ModularInteger methodsFor: 'comparing' stamp: 'len 5/31/2022 11:25:54'!
| anElement
	"Answer true if the receiver divides the argument."
	^ anElement isZero or: [self isZero not and: [(anElement \\ self) isZero]]! !

!ModularInteger methodsFor: 'comparing' stamp: 'len 3/29/2016 20:48'!
hash
	^ representative hash! !

!ModularInteger methodsFor: 'converting' stamp: 'len 12/2/2016 09:43:47'!
asRational
	"Answer the rational reconstruction of the receiver, or nil if it doesn't exist."
	| N |
	N _ (self modulus // 2) sqrtFloor.
	^ self asRationalMaxNumerator: N maxDenominator: N! !

!ModularInteger methodsFor: 'converting' stamp: 'len 7/12/2023 14:57:39'!
asRational: T
	"Answer the rational reconstruction of the receiver, or nil if not found.
	This is the MQRR (Maximal Quotient Rational Reconstruction) algorithm.
	The parameter T > 0 bounds the size of the possible outputs. If u is the representative of the receiver and m is the modulus, the algorithm returns a rational n/d = u mod m, d > 0, gcd(n,d) = 1 and T*|n|*d < m, or fails.
	The algorithm is almost optimal in the sense that requires that the modulus be only a modest number bits longer than 2*|n|*d. The time complexity is O(log² m).
	See [Mon04]."
	| T₂ n d t₀ r₀ t₁ r₁ temp answer |
	representative = 0 ifTrue: [^ self modulus > T ifTrue: [0]].
	n := 0. d := 0.
	t₀ := 0. r₀ := self modulus.
	t₁ := 1. r₁ := representative.
	T₂ := T.
	[r₁ ~~ 0 and: [r₀ > T₂]]
		whileTrue:
			[| q |
			(q := r₀ // r₁) > T₂
				ifTrue: [n := r₁. d := t₁. T₂ := q].
			temp := r₀ - (q * r₁). r₀ := r₁. r₁ := temp.
			temp := t₀ - (q * t₁). t₀ := t₁. t₁ := temp].
	^ (d ~~ 0 and: [(answer := (n/d) asRational) numerator abs = n abs]) ifTrue: [answer]! !

!ModularInteger methodsFor: 'converting' stamp: 'len 7/12/2023 14:57:34'!
asRationalMaxNumerator: N maxDenominator: D
	"Answer the rational reconstruction of the receiver, or nil if it doesn't exist."
	| n d t₀ r₀ t₁ r₁ temp answer |
	representative = 0 ifTrue: [^ 0].
	t₀ := 0. r₀ := self modulus.
	t₁ := 1. r₁ := representative.
	[r₁ > N]
		whileTrue:
			[| q |
			q := r₀ // r₁.
			temp := r₀ - (q * r₁). r₀ := r₁. r₁ := temp.
			temp := t₀ - (q * t₁). t₀ := t₁. t₁ := temp].
	n := r₁. d := t₁.
	d <= 0 ifTrue: [n := n negated. d := d negated].
	^ (d <= D and: [(answer := (n/d) asRational) numerator abs = n abs]) ifTrue: [answer]! !

!ModularInteger methodsFor: 'operations' stamp: 'len 1/9/2022 20:54:19'!
+ anElement
	| m r |
	anElement isInteger ifTrue: [^ parent project: representative + anElement].
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #+].
	m _ parent modulus.
	r _ representative + anElement representative.
	r >= m ifTrue: [r _ r - m].
	^ parent representative: r! !

!ModularInteger methodsFor: 'operations' stamp: 'len 1/9/2022 20:54:57'!
- anElement
	| m r |
	anElement isInteger ifTrue: [^ parent project: representative - anElement].
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #-].
	m _ parent modulus.
	r _ representative + m - anElement representative.
	r >= m ifTrue: [r _ r - m].
	^ parent representative: r! !

!ModularInteger methodsFor: 'operations' stamp: 'len 5/29/2022 19:39:19'!
// anElement
	"Answer the quotient of the Euclidean division of the receiver by the argument."
	anElement isZero ifTrue: [^ DivisibilityError new signalReceiver: self selector: #// argument: anElement].
	self isZero ifTrue: [^ self].
	^ parent representative: (representative quotientBy: anElement representative modulo: parent modulus)! !

!ModularInteger methodsFor: 'operations' stamp: 'len 5/28/2023 19:47:46'!
^ anInteger
	anInteger isFraction ifTrue: [^ (self root: anInteger denominator) ^ anInteger numerator].
	^ parent representative: (representative raisedTo: (anInteger isInteger ifTrue: [anInteger] ifFalse: [anInteger representative]) modulo: parent modulus)! !

!ModularInteger methodsFor: 'operations' stamp: 'len 4/6/2024 06:40:55'!
additiveOrder
	representative = 0 ifTrue: [^ 0].
	^ parent modulus / (representative gcd: parent modulus)! !

!ModularInteger methodsFor: 'operations' stamp: 'len 1/9/2022 08:09:47'!
annihilator
	"Answer a generator of the ideal of all elements that multiplied by the receiver are zero."
	^ parent project: parent modulus // (representative gcd: parent modulus)! !

!ModularInteger methodsFor: 'operations' stamp: 'len 5/28/2022 11:36:11'!
colift: anElement
	"Answer x such that xa = b, where a is the receiver and b is the argument. Answer nil if there's no solution.
	This is the right division of b by a, written b / a."
	^ super colift: anElement
"	| a b d m |
	anElement isInteger ifTrue: [^ self * (parent inverseOfRepresentative: anElement)].
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #/].
	m _ parent modulus.
	m = 1 ifTrue: [^ self].
	b _ representative.
	a _ anElement representative.
	d _ a gcd: m.
	d = 1 ifTrue: [^ parent project: (a reciprocalModulo: m) * b].
	d | b ifFalse: [^ DivisionError new signalReceiver: self selector: #/ argument: anElement].
	a _ a // d.
	b _ b // d.
	m _ m // d.
	^ parent project: (a reciprocalModulo: m) * b "! !

!ModularInteger methodsFor: 'operations' stamp: 'len 6/25/2023 10:01:10'!
factorizationDo: aBlock
	self normalized representative factorizationDo: [:p :e|
		| pp |
		(pp := parent representative: p) isIrreducible ifTrue: [aBlock value: pp value: e]]! !

!ModularInteger methodsFor: 'operations' stamp: 'len 10/16/2022 10:41:51'!
gauge
	"Answer the value of the Euclidean function at the receiver."
	^ self isZero ifTrue: [0] ifFalse: [representative gcd: parent modulus]! !

!ModularInteger methodsFor: 'operations' stamp: 'len 6/8/2019 12:06:49'!
negated
	representative = 0 ifTrue: [^ self].
	^ parent representative: parent modulus - representative! !

!ModularInteger methodsFor: 'operations' stamp: 'len 6/2/2023 15:01:41'!
normalization
	"Answer a unit u such that 'self * u' is a unique choice of associate. See >>normalized."
	^ self unitPart inverse! !

!ModularInteger methodsFor: 'operations' stamp: 'len 7/30/2021 10:25:31'!
normalized
	"Answer a unique choice of associate. See >>normalization."
	representative = 0 ifTrue: [^ self].
	^ parent representative: (representative gcd: parent modulus)! !

!ModularInteger methodsFor: 'operations' stamp: 'len 5/25/2022 13:55:47'!
solve: anElement
	"Answer all solutions 'x' such that 'ax = b (mod m)', where the receiver is 'a (mod m)' and the argument is 'b (mod m)'."
	| a b d m x |
	m _ parent modulus.
	m = 1 ifTrue: [^ {self}]. "case for the zero ring"
	a _ representative.
	b _ anElement isInteger ifTrue: [anElement] ifFalse: [anElement representative].
	d _ a gcd: m.
	d = 1 ifTrue: [^ {parent project: (a reciprocalModulo: m) * b}].
	d | b ifFalse: [^ #()].
	a _ a // d.
	b _ b // d.
	m _ m // d.
	x _ (a reciprocalModulo: m) * b.
	^ Iterator on: [:aBlock| 0 to: d-1 do: [:i| aBlock value: (parent project: i*m + x)]]! !

!ModularInteger methodsFor: 'operations' stamp: 'len 5/30/2023 22:29:51'!
squareRootOrNil
	"Answer a square root if the receiver is a quadratic residue. Otherwise answer nil."
	^ self notYetImplemented! !

!ModularInteger methodsFor: 'operations' stamp: 'len 1/9/2022 08:09:58'!
stabilizerWith: anElement
	| N g |
	N _ self modulus.
	g _ (representative gcd: anElement representative) gcd: N.
	^ parent representative: (N // g split: representative // g)! !

!ModularInteger methodsFor: 'operations' stamp: 'len 1/14/2022 14:10:40'!
valuation
	"Answer the Euclidean valuation of the receiver."
	^ self isZero ifTrue: [Infinity negative] ifFalse: [representative gcd: parent modulus]! !

!ModularInteger methodsFor: 'testing' stamp: 'len 5/9/2023 23:07:52'!
isIrreducible
	"An element of ℤ/nℤ is irreducible iff its canonical associate is a prime p in Z and its exponent in the prime factorization of n is > 1, or equivalently p^2 | n."
	^ (parent modulusFactors occurrencesOf: self normalized representative) > 1! !

!ModularInteger methodsFor: 'testing' stamp: 'len 4/25/2022 18:03:38'!
isMinusOne
	^ representative + 1 = parent modulus! !

!ModularInteger methodsFor: 'testing' stamp: 'len 4/25/2022 18:03:09'!
isOne
	^ representative = 1! !

!ModularInteger methodsFor: 'testing' stamp: 'len 5/9/2023 23:08:06'!
isPrime
	"An element of ℤ/nℤ is prime iff its canonical associate is a prime p in Z and p < n."
	| p |
	p _ self normalized representative.
	^ p < parent modulus and: [parent modulusFactors includes: p]! !

!ModularInteger methodsFor: 'testing' stamp: 'len 7/16/2023 15:52:05'!
isPrimitiveRoot
	"Answer true if the receiver is a generator of the group of units.
	For ℤ/pℤ this is a primitive (p-1)-th root of unity."
	^ self multiplicativeOrder = self parent units size! !

!ModularInteger methodsFor: 'testing' stamp: 'len 6/26/2023 01:34:54'!
isSquare
	"Answer true if the receiver is a perfect square, i.e. it has a square root."
	(representative kronecker: self modulus) ~= 1 ifTrue: [^ false].
	^ super isSquare! !

!ModularInteger methodsFor: 'testing' stamp: 'len 5/7/2022 07:38:16'!
isUnit
	"Answer true if the receiver is invertible.
	An element in a finite ring is either a unit or a zero divisor."
	^ self isZeroDivisor not! !

!ModularInteger methodsFor: 'testing' stamp: 'len 12/4/2016 15:16:58'!
isZero
	^ representative == 0! !

!ModularInteger methodsFor: 'testing' stamp: 'len 5/7/2022 07:30:02'!
isZeroDivisor
	"Answer true if there exists a nonzero element that multiplied by the receiver is zero.
	An element in a finite ring is either a unit or a zero divisor."
	self isZero ifTrue: [^ parent isTrivial not].
	^ (representative gcd: parent modulus) ~= 1! !

!ModularInteger methodsFor: 'private' stamp: 'len 3/29/2016 23:52'!
representative: anInteger
	representative _ anInteger! !

!PrimePowerResidue methodsFor: 'accessing' stamp: 'len 10/27/2023 10:54:19'!
expansion
	"Answer the coefficients of the p-adic expansion of the receiver."
	| p q r |
	p := self parent base.
	q := representative.
	^ (1 to: self parent exponent) collect: [:i| r := q \\ p. q := q // p. r]! !

!PrimePowerResidue methodsFor: 'accessing' stamp: 'len 9/8/2023 17:07:01'!
unitPart
	| p q |
	self isZero ifTrue: [^ parent one].
	p := parent base.
	q := representative.
	[p | q] whileTrue: [q := q // p].
	^ parent representative: q! !

!PrimePowerResidue methodsFor: 'comparing' stamp: 'len 6/16/2023 18:17:49'!
| anElement
	"Answer true if the receiver divides the argument."
	^ anElement isZero or: [self isZero not and: [self valuation <= anElement valuation]]! !

!PrimePowerResidue methodsFor: 'operations' stamp: 'len 5/26/2022 12:58:06'!
// anElement
	"Answer the quotient of the Euclidean division of the receiver by the argument."
	^ super // anElement
"	| v |
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #//].
	anElement isZero ifTrue: [^ DivisionError new signalReceiver: self selector: #// argument: anElement].
	self isZero ifTrue: [^ self].
	(v _ self valuation - anElement valuation) < 0 ifTrue: [^ self zero].
	^ self normalization inverse * anElement normalization * (parent p ^ v)"! !

!PrimePowerResidue methodsFor: 'operations' stamp: 'len 9/8/2023 17:06:24'!
gcd: anElement
	self isZero ifTrue: [^ anElement normalized].
	anElement isZero ifTrue: [^ self normalized].
	^ parent representative: parent base ^ (self valuation min: anElement valuation)! !

!PrimePowerResidue methodsFor: 'operations' stamp: 'len 10/16/2023 11:06:34'!
inverse
	| a₁ s t m u mask |
	parent base = 2 ifFalse: [^ super inverse].
	self flag: #fixme. "implement for other bases, remove asserts"
	"See [Dum18, Algorithm 3: Explicit Quadratic Modular inverse modulo 2^m]."
	representative even ifTrue: [^ DivisibilityError new signalReceiver: self one selector: #/ argument: self].
	representative = 1 ifTrue: [^ self].
	a₁ := representative - 1.
	s := a₁ lowBit - 1.
	t := a₁ bitShift: s negated.
	self assert: 2^s * t + 1 = representative.
	m := parent exponent.
	u := 2 - representative.
	mask := (1 bitShift: m) - 1.
	(m // s) highBit timesRepeat:
		[a₁ := a₁ squared bitAnd: mask.
		u := u * (a₁ + 1) bitAnd: mask].
	self assert: ((representative * u) bitAnd: mask) = 1.
	^ parent representative: u! !

!PrimePowerResidue methodsFor: 'operations' stamp: 'len 9/8/2023 17:06:45'!
lcm: anElement
	self isZero ifTrue: [^ self].
	anElement isZero ifTrue: [^ anElement].
	^ parent representative: parent base ^ (self valuation max: anElement valuation)! !

!PrimePowerResidue methodsFor: 'operations' stamp: 'len 5/30/2023 22:34:46'!
sqrt
	^ self squareRootOrNil ifNil: [self error: 'not a perfect square']! !

!PrimePowerResidue methodsFor: 'operations' stamp: 'len 9/8/2023 17:06:54'!
squareRootOrNil
	"Answer a square root if the receiver is a quadratic residue. Otherwise answer nil."
	| p a v x q r e scaler |
	(representative = 0 or: [representative = 1]) ifTrue: [^ self].
	p := parent base.
	a := representative.
	v := 0.
	[p | a] whileTrue: [v := v + 1. a := a // p].
	v odd ifTrue: [^ nil].
	scaler := (parent representative: p) ^ (v // 2).
	a = 1 ifTrue: [^ (parent representative: p) ^ (v // 2)].
	p = 2 ifTrue:
		[| d i |
		d := parent exponent - v.
		d = 1 ifTrue: [^ scaler].
		d = 2 ifTrue: [^ a \\ 4 = 1 ifTrue: [scaler]].
		a \\ 8 = 1 ifFalse: [^ nil].
		d = 3 ifTrue: [^ scaler].
		x := 1.
		i := 1.
		"Newton iteration for inverse square root:"
		[i < d] whileTrue:
			[x := 3 - (a * x squared) * x // 2.
			i := i * 2].
		^ (parent representative: x*a) * scaler].
	x := parent residueField squareRootOfRepresentative: a \\ p.
	q := parent modulus.
	r := q // p.
	e := q - (2*r) + 1 // 2.
	^ ((parent representative: x) ^ r * ((parent representative: a) ^ e)) * scaler! !

!PrimePowerResidue methodsFor: 'operations' stamp: 'len 9/8/2023 17:07:06'!
valuation
	"Answer the p-adic valuation of the receiver."
	^ representative valuation: parent base! !

!PrimePowerResidue methodsFor: 'testing' stamp: 'len 5/7/2022 07:28:36'!
isNilpotent
	"Answer true if self^n = 0 for some integer n >= 1."
	^ self isZeroDivisor! !

!PrimePowerResidue methodsFor: 'testing' stamp: 'len 9/8/2023 17:06:40'!
isZeroDivisor
	"Answer true if there exists a nonzero element that multiplied by the receiver is zero."
	^ parent base | representative! !

!PrimeResidue methodsFor: 'comparing' stamp: 'len 5/27/2022 19:02:09'!
| anElement
	"Answer true if the receiver divides the argument."
	^ anElement isZero or: [self isZero not]! !

!PrimeResidue methodsFor: 'operations' stamp: 'len 4/6/2024 06:41:13'!
additiveOrder
	representative = 0 ifTrue: [^ 0].
	^ parent modulus! !

!PrimeResidue methodsFor: 'operations' stamp: 'len 6/20/2023 20:26:25'!
colift: anElement
	"Answer x such that xa = b, where a is the receiver and b is the argument. Answer nil if there's no solution.
	This is the right division of b by a, written b / a."
	anElement isZero ifTrue: [^ anElement].
	^ self isZero ifFalse: [anElement * self inverse]! !

!PrimeResidue methodsFor: 'operations' stamp: 'len 6/1/2022 18:06:30'!
gcd: anElement
	representative = 0 ifTrue: [^ anElement normalized].
	^ parent one! !

!PrimeResidue methodsFor: 'operations' stamp: 'len 6/9/2023 18:27:57'!
inverse
	representative = 1 ifTrue: [^ self].
	representative = 0 ifTrue: [^ DivisibilityError new signalReceiver: self one selector: #/ argument: self].
	^ parent project: ((representative xgcd: parent modulus) at: 2)! !

!PrimeResidue methodsFor: 'operations' stamp: 'len 6/9/2023 21:00:51'!
inverse2
	"[Coh+05, Algorithm 11.9."
	| p z u q |
	self flag: #fixme. "	This is actually about as fast as xgcd for small modulus, and slower for big modulus."
	p := parent modulus.
	z := representative.
	u := 1.
	[z = 1] whileFalse:
		[q := (p // z) negated.
		z := p + (q * z).
		u := q * u \\ p].
	^ parent representative: u! !

!PrimeResidue methodsFor: 'operations' stamp: 'len 6/1/2022 18:08:32'!
lcm: anElement
	representative = 0 ifTrue: [^ parent zero].
	^ anElement normalized! !

!PrimeResidue methodsFor: 'operations' stamp: 'len 11/22/2023 16:11:23'!
minimalPolynomial
	^ self parent polynomials x - self! !

!PrimeResidue methodsFor: 'operations' stamp: 'len 7/30/2021 10:26:29'!
normalized
	"Answer a unique choice of associate. See >>normalization."
	representative = 0 ifTrue: [^ self].
	^ parent one! !

!PrimeResidue methodsFor: 'operations' stamp: 'len 5/30/2023 22:28:23'!
squareRootOrNil
	"Answer a square root if the receiver is a quadratic residue. Otherwise answer nil."
	| p |
	(representative = 0 or: [representative = 1]) ifTrue: [^ self].
	p := parent modulus.
	p = 2 ifTrue: [^ self].
	(p bitAnd: 3) = 3 ifTrue: [^ self ^ (p + 1 // 4)].
	^ parent representative: ((parent squareRootOfRepresentative: representative) ifNil: [^ nil])! !

!PrimeResidue methodsFor: 'operations' stamp: 'len 5/30/2023 22:29:03'!
squareRoots
	"Answer all square roots of the receiver."
	| x |
	representative == 0 ifTrue: [^ {self}].
	x := self squareRoot ifNil: [^ #()].
	^ {x. x negated}! !

!PrimeResidue methodsFor: 'testing' stamp: 'len 5/30/2023 22:48:16'!
isSquare
	"Answer true if the receiver is a perfect square, i.e. it has a square root."
	^ representative = 0 or: [(representative kronecker: self modulus) = 1]! !

!PrimeResidue methodsFor: 'testing' stamp: 'len 5/7/2022 07:30:30'!
isZeroDivisor
	"Answer true if there exists a nonzero element that multiplied by the receiver is zero."
	^ self isZero! !

!AlgebraicRational methodsFor: 'accessing' stamp: 'len 11/5/2023 08:01:42'!
denominator
	^ self minimalPolynomial denominator! !

!AlgebraicRational methodsFor: 'accessing' stamp: 'len 11/5/2023 08:02:17'!
numerator
	^ self * self denominator! !

!AlgebraicRational methodsFor: 'converting' stamp: 'len 11/30/2023 15:51:22'!
asScalar
	self assert: self isScalar.
	^ representative independentCoefficient! !

!AlgebraicRational methodsFor: 'testing' stamp: 'len 11/30/2023 15:51:02'!
isScalar
	^ representative isConstant! !

!AlgebraicRational methodsFor: 'testing' stamp: 'len 11/26/2023 20:56:36'!
isUnit
	^ self isZero not! !

!CyclotomicRational methodsFor: 'operations' stamp: 'len 11/30/2023 16:04:45'!
conjugate
	"Answer the complex conjugate of the receiver."
	^ representative value: parent x inverse

"for the Gaussian rationals ℚ(i) = ℚ(ζ₄):
	^ parent i * (representative at: 1) negated + (representative at: 0)"! !

!CyclotomicRational methodsFor: 'testing' stamp: 'len 11/7/2023 11:29:39'!
isReal
	^ self conjugate = self! !

!CyclotomicRational methodsFor: 'nil' stamp: 'len 11/30/2023 16:05:55'!
inverse
	representative isConstant ifTrue: [^ parent representative: representative inverse].
	^ super inverse
"	| d |
	d := representative denominator.
	^ (self * d) inverse2 * d"
"	^ self conjugate * self norm inverse"! !

!Jet methodsFor: 'testing' stamp: 'len 11/21/2023 15:18:06'!
isNilpotent
	^ self isZeroDivisor! !

!Jet methodsFor: 'testing' stamp: 'len 11/21/2023 15:18:01'!
isUnit
	^ self isZeroDivisor not! !

!Jet methodsFor: 'testing' stamp: 'len 11/21/2023 15:18:17'!
isZeroDivisor
	^ representative independentCoefficient isZeroDivisor! !

!LaurentPolynomial methodsFor: 'as yet unclassified' stamp: 'len 12/1/2023 16:48:16'!
printCoefficient: coefficient monomial: m on: aStream
	| c |
	c := coefficient.
	(c isOne not or: [m degree = 0]) ifTrue:
		[c printText first = $-
			ifTrue: [aStream nextPut: $-. c := c negated].
		(m degree = 0 or: [c printText asString allSatisfy: [:each| each isAlphaNumeric or: ['{}()/' includes: each]]])
			ifTrue: [aStream print: c]
			ifFalse: [aStream nextPut: $(; print: c; nextPut: $)]].
	m degree = 0 ifFalse: [self printMonomial: m on: aStream]! !

!LaurentPolynomial methodsFor: 'as yet unclassified' stamp: 'len 5/6/2023 15:21:06'!
printIndeterminate: anInteger on: aStream
	| h i |
	h _ self parent rank / 2.
	i _ anInteger > h ifTrue: [anInteger - h] ifFalse: [anInteger].
	(self parent names ifNotNil: [:names| names at: i ifAbsent: []])
		ifNotNil: [:name| aStream nextPutAll: name displayStringOrText. ^ self].
	aStream nextPut: $x; nextPutAll: i printStringSubscript! !

!LaurentPolynomial methodsFor: 'as yet unclassified' stamp: 'len 5/6/2023 15:35:53'!
printMonomial: m on: aStream
	| h |
	m degree = 0 ifTrue: [aStream print: 1. ^ self].
	h _ self parent rank / 2.
	(m ordering indeterminates select: [:i| (m at: i) ~= 0])
		do: [:i| | r |
			self printIndeterminate: i on: aStream.
			r _ m at: i.
			i > h ifTrue: [r _ r negated].
			r = 1 ifFalse: [aStream nextPutAll: r printString super]]! !

!LaurentPolynomial methodsFor: 'as yet unclassified' stamp: 'len 12/3/2023 13:56:18'!
printOn: aStream
	| monomials leadingMonomial c |
	representative isConstant ifTrue: [aStream print: representative leadingCoefficient. ^ self].
	monomials := representative monomials sorted reversed.
	c := representative at: (leadingMonomial := monomials first).
	c printText first = $-
		ifTrue: [c := c negated. aStream nextPut: $-].
	self printCoefficient: c monomial: leadingMonomial on: aStream.
	monomials allButFirstDo: [:m|
		c := representative at: m.
		c printText first = $-
			ifTrue: [aStream nextPutAll: ' - '. c := c negated]
			ifFalse: [aStream nextPutAll: ' + '].
		self printCoefficient: c monomial: m on: aStream]! !

!AlgebraicClosureElement methodsFor: 'accessing' stamp: 'len 11/21/2023 15:38:30'!
representative
	^ representative! !

!AlgebraicClosureElement methodsFor: 'comparing' stamp: 'len 11/22/2023 10:54:12'!
= anObject
	| K |
	self class = anObject class ifFalse: [^ false].
	representative parent characteristic = anObject representative parent characteristic ifFalse: [^ self].
	K := representative parent ∨ anObject representative parent.
	^ K !! representative = (K !! anObject representative)! !

!AlgebraicClosureElement methodsFor: 'comparing' stamp: 'len 11/22/2023 10:54:36'!
hash
	^ self minimalPolynomial hash! !

!AlgebraicClosureElement methodsFor: 'operations' stamp: 'len 11/22/2023 10:21:26'!
* anElement
	| K |
	anElement isInteger ifTrue: [^ self class representative: representative * anElement].
	self class = anElement class ifFalse: [^ self adapt: anElement andSend: #*].
	K := representative parent ∨ anElement representative parent.
	^ self class representative: (K !! representative * (K !! anElement representative))! !

!AlgebraicClosureElement methodsFor: 'operations' stamp: 'len 11/22/2023 10:18:58'!
+ anElement
	| K |
	self class = anElement class ifFalse: [^ self  adapt: anElement andSend: #+].
	K := representative parent ∨ anElement representative parent.
	^ self class representative: (K !! representative + (K !! anElement representative))! !

!AlgebraicClosureElement methodsFor: 'operations' stamp: 'len 11/21/2023 21:53:53'!
^ anInteger
	"Answer the receiver raised to the power anInteger."
	anInteger = 0 ifTrue: [^ self one].
	self isZero ifTrue: [^ self].
	anInteger isFraction ifTrue: [^ (self root: anInteger denominator) ^ anInteger numerator].
	^ self class representative: representative ^ anInteger! !

!AlgebraicClosureElement methodsFor: 'operations' stamp: 'len 11/22/2023 16:02:41'!
colift: anElement
	"Answer x such that xa = b, where a is the receiver and b is the argument. Answer nil if there's no solution.
	This is the right division of b by a, written b / a."
	anElement isZero ifTrue: [^ anElement].
	^ self isZero ifFalse: [anElement * self inverse]! !

!AlgebraicClosureElement methodsFor: 'operations' stamp: 'len 11/21/2023 21:50:27'!
frobenius
	"Answer the result of applying the Frobenius automorphism to the receiver."
	^ self class representative: representative frobenius! !

!AlgebraicClosureElement methodsFor: 'operations' stamp: 'len 11/21/2023 21:50:46'!
inverse
	^ self class representative: representative inverse! !

!AlgebraicClosureElement methodsFor: 'operations' stamp: 'len 11/21/2023 21:46:26'!
minimalPolynomial
	^ representative minimalPolynomial! !

!AlgebraicClosureElement methodsFor: 'operations' stamp: 'len 11/23/2023 09:53:03'!
multiplicativeOrder
	^ representative multiplicativeOrder! !

!AlgebraicClosureElement methodsFor: 'operations' stamp: 'len 11/21/2023 21:51:05'!
negated
	^ self class representative: representative negated! !

!AlgebraicClosureElement methodsFor: 'operations' stamp: 'len 11/21/2023 21:48:07'!
norm
	"Answer the absolute norm of the receiver."
	^ self absoluteNorm! !

!AlgebraicClosureElement methodsFor: 'operations' stamp: 'len 11/21/2023 21:47:49'!
trace
	"Answer the absolute trace of the receiver."
	^ self absoluteTrace! !

!AlgebraicClosureElement methodsFor: 'printing' stamp: 'len 11/21/2023 15:39:13'!
printOn: aStream
	aStream print: representative! !

!AlgebraicClosureElement methodsFor: 'testing' stamp: 'len 11/21/2023 15:39:30'!
isOne
	^ representative isOne! !

!AlgebraicClosureElement methodsFor: 'testing' stamp: 'len 11/21/2023 21:48:40'!
isSquare
	^ true! !

!AlgebraicClosureElement methodsFor: 'testing' stamp: 'len 11/21/2023 15:39:25'!
isZero
	^ representative isZero! !

!AlgebraicClosureElement methodsFor: 'private' stamp: 'len 11/21/2023 15:46:46'!
parent
	^ representative parent algebraicClosure! !

!AlgebraicClosureElement methodsFor: 'private' stamp: 'len 11/21/2023 15:38:49'!
representative: aGaloisFieldElement
	representative := aGaloisFieldElement! !

!AlgebraicClosureElement class methodsFor: 'instance creation' stamp: 'len 11/21/2023 15:45:06'!
representative: aGaloisFieldElement
	^ self new representative: aGaloisFieldElement! !

!ComplexAlgebraicNumber methodsFor: 'accessing' stamp: 'len 11/10/2023 14:43:33'!
bounds
	"Answer a rational ball isolating the receiver from any other root of the minimal polynomial."
	^ bounds! !

!ComplexAlgebraicNumber methodsFor: 'accessing' stamp: 'len 11/9/2023 09:54:30'!
denominator
	"Answer an rational integer such that the receiver multiplied by it is integral."
	^ minimalPolynomial denominator! !

!ComplexAlgebraicNumber methodsFor: 'accessing' stamp: 'len 11/10/2023 20:10:50'!
imaginary
	"Answer the imaginary part of the receiver."
	^ (self * self parent i negated) real! !

!ComplexAlgebraicNumber methodsFor: 'accessing' stamp: 'len 11/9/2023 09:53:47'!
minimalPolynomial
	"Answer a monic polynomial in ℚ[x] of minimal degree with the receiver as root."
	^ minimalPolynomial! !

!ComplexAlgebraicNumber methodsFor: 'accessing' stamp: 'len 11/10/2023 16:14:15'!
real
	"Answer the real part of the receiver."
	^ (self + self conjugate / 2) asReal! !

!ComplexAlgebraicNumber methodsFor: 'approximating' stamp: 'len 11/10/2023 20:00:05'!
refine: aBall
	^ self refine: aBall center to: aBall radius / 2! !

!ComplexAlgebraicNumber methodsFor: 'approximating' stamp: 'len 11/20/2023 10:25:16'!
refine: aNumber to: ε
	"See [Coh96, Algorithm 3.6.6]."
	| P dP m x v c dx y v₁ m₁ |
	P := minimalPolynomial.
	dP := P derivative.
	x := aNumber.
	v := P value: x.
	m := v abs².
	c := 0. dx := v / (dP value: x).
	[dx within: ε]
		whileFalse:
			[y := x - dx.
			v₁ := P value: y.
			m₁ := v₁ abs².
			m₁ < m
				ifTrue: [x := y. v := v₁. m := m₁. c := 0. dx := v / (dP value: x)]
				ifFalse: [c := c + 1. dx := dx / 4. c > 20 ifTrue: [^ self error: 'not enough precision']]].
	"Polish root:"
	2 timesRepeat: [x := x - ((P value: x) / (dP value: x))].
	^​ Ball center: x radius: ε! !

!ComplexAlgebraicNumber methodsFor: 'comparing' stamp: 'len 11/22/2023 15:56:23'!
= anObject
	^ anObject class = self class and: [minimalPolynomial = anObject minimalPolynomial and: [bounds overlaps: anObject bounds]]! !

!ComplexAlgebraicNumber methodsFor: 'comparing' stamp: 'len 4/29/2018 20:09:45'!
hash
	^ minimalPolynomial hash! !

!ComplexAlgebraicNumber methodsFor: 'converting' stamp: 'len 11/10/2023 19:15:48'!
adaptToFloat: rcvr andSend: selector
	^ rcvr perform: selector with: self asFloat! !

!ComplexAlgebraicNumber methodsFor: 'converting' stamp: 'len 11/8/2023 09:06:28'!
asComplex
	^ self! !

!ComplexAlgebraicNumber methodsFor: 'converting' stamp: 'len 11/10/2023 19:15:28'!
asFloat
	"Answer a floating-point approximation of the receiver."
	^ (self refine: bounds center to: Float epsilon) center asFloat! !

!ComplexAlgebraicNumber methodsFor: 'converting' stamp: 'len 11/9/2023 20:57:34'!
asRational
	minimalPolynomial degree < 2 ifFalse: [^ self error: 'the number is irrational'].
	^ minimalPolynomial independentCoefficient negated! !

!ComplexAlgebraicNumber methodsFor: 'converting' stamp: 'len 11/14/2023 10:24:05'!
asReal
	self isReal ifFalse: [^ self error: 'not a real number'].
	self assert: (bounds center imaginary within: bounds radius).
	^ RealAlgebraicNumber minimalPolynomial: minimalPolynomial bounds: (Ball center: bounds center real radius: bounds radius)! !

!ComplexAlgebraicNumber methodsFor: 'operations' stamp: 'len 11/13/2023 10:34:48'!
* aNumber
	| isolator B₁ B₂ B |
	(aNumber isRational and: [self isRational]) ifTrue: [^ self class fromRational: self asRational * aNumber asRational].
	aNumber class = self class ifFalse: [^ self adapt: aNumber andSend: #*].
	"TODO: optimize for when either the receiver or the argument is rational, we dont need to factorize again:"
	isolator := self rootIsolatorClass on: (minimalPolynomial zeroProduct: aNumber minimalPolynomial) radical.
	B₁ := bounds.
	B₂ := aNumber bounds.
	"TODO: alternate refining B₁ and B₂, or other strategy"
	[isolator atMostOneRootIn: (B := B₁ * B₂)]
		whileFalse:
			[B₁ := self refine: B₁.
			B₂ := aNumber refine: B₂].
	^ self class polynomial: isolator polynomial bounds: B! !

!ComplexAlgebraicNumber methodsFor: 'operations' stamp: 'len 11/20/2023 10:23:25'!
+ aNumber
	| isolator B₁ B₂ B |
	(aNumber isRational and: [self isRational]) ifTrue: [^ self class fromRational: self asRational + aNumber asRational].
	aNumber class = self class ifFalse: [^ self adapt: aNumber andSend: #+].
	"TODO: optimize for when either the receiver or the argument is rational, we dont need to factorize again:"
	isolator := self rootIsolatorClass on: (minimalPolynomial zeroAddition: aNumber minimalPolynomial) radical.
	B₁ := bounds.
	B₂ := aNumber bounds.
	"TODO: alternate refining B₁ and B₂, or other strategy"
	[isolator atMostOneRootIn: (B := B₁ + B₂)]
		whileFalse:
			[B₁ := self refine: B₁.
			B₂ := aNumber refine: B₂].
	^ self class polynomial: isolator polynomial bounds: B! !

!ComplexAlgebraicNumber methodsFor: 'operations' stamp: 'len 11/11/2023 15:10:27'!
// anElement
	"Answer the quotient of the division of the receiver by anElement."
	^ self * anElement inverse! !

!ComplexAlgebraicNumber methodsFor: 'operations' stamp: 'len 11/11/2023 15:25:08'!
\\ anElement
	"Answer the remainder of the division of the receiver by the argument."
	^ self parent zero! !

!ComplexAlgebraicNumber methodsFor: 'operations' stamp: 'len 11/20/2023 10:11:09'!
abs
	"Answer the absolute value of the receiver."
	^ (self real squared + self imaginary squared) sqrt! !

!ComplexAlgebraicNumber methodsFor: 'operations' stamp: 'len 11/20/2023 10:25:59'!
abs²
	"Answer the square of the absolute value of the receiver."
	^ self real squared + self imaginary squared! !

!ComplexAlgebraicNumber methodsFor: 'operations' stamp: 'len 11/8/2023 09:23:45'!
colift: aNumber
	"Answer x such that xa = b, where a is the receiver and b is the argument. Answer nil if there's no solution.
	This is the right division of b by a, written b / a."
	aNumber isZero ifTrue: [^ aNumber].
	^ self isZero ifFalse: [aNumber * self inverse]! !

!ComplexAlgebraicNumber methodsFor: 'operations' stamp: 'len 11/9/2023 18:24:33'!
conjugate
	"Answer the complex conjugate of the receiver."
	self isZero ifTrue: [^ self].
	^ self class minimalPolynomial: minimalPolynomial bounds: bounds conjugate! !

!ComplexAlgebraicNumber methodsFor: 'operations' stamp: 'len 11/13/2023 10:54:50'!
conjugates
	"Answer the Galois conjugates of the receiver."
	"The conjugates of an algebraic number are all the roots of the minimal polynomial."
	^ minimalPolynomial rootsIn: self parent! !

!ComplexAlgebraicNumber methodsFor: 'operations' stamp: 'len 11/26/2023 21:09:49'!
evaluate: aPolynomial
	"Answer the result of evaluating aPolynomial at the receiver."
	| f μ isolator B₁ B |
	self isRational ifTrue: [^ self class fromRational: (self asRational evaluate: aPolynomial)].
	f := aPolynomial \\ minimalPolynomial.
	f isConstant ifTrue: [^ self class fromRational: f independentCoefficient].
	μ := (self representation evaluate: f) minimalPolynomial.
	isolator := self rootIsolatorClass on: μ.
	B₁ := bounds.
	[isolator atMostOneRootIn: (B := B₁ evaluate: f)]
		whileFalse: [B₁ := self refine: B₁].
	^ self class minimalPolynomial: μ bounds: B! !

!ComplexAlgebraicNumber methodsFor: 'operations' stamp: 'len 12/1/2023 18:27:56'!
height
	^ minimalPolynomial height! !

!ComplexAlgebraicNumber methodsFor: 'operations' stamp: 'len 11/12/2023 09:24:45'!
inverse
	"Answer the multiplicative inverse of the receiver."
	self isZero ifTrue: [^ DivisibilityError new signalReceiver: self one selector: #/ argument: self].
	^ self class minimalPolynomial: minimalPolynomial zeroInverse normalized bounds: bounds inverse! !

!ComplexAlgebraicNumber methodsFor: 'operations' stamp: 'len 11/17/2023 11:32:48'!
multiplicativeOrder
	"Answer the order of the receiver as an element of the group of units.
	Return 0 if the receiver is not a unit."
	self abs isOne ifFalse: [^ 0].
	^ minimalPolynomial cyclotomicOrderOrNil ifNil: [0]! !

!ComplexAlgebraicNumber methodsFor: 'operations' stamp: 'len 11/9/2023 10:20:34'!
negated
	"Answer the additive inverse of the receiver."
	self isZero ifTrue: [^ self].
	^ self class minimalPolynomial: minimalPolynomial zeroNegation bounds: bounds negated! !

!ComplexAlgebraicNumber methodsFor: 'operations' stamp: 'len 11/17/2023 14:40:47'!
norm
	"Answer the absolute norm of the receiver."
	^ self absoluteNorm

"Note: this is the norm over ℚ. For the norm over ℝ we can do: self * self conjugate"

"alternatively:
	^ self conjugates product asReal"! !

!ComplexAlgebraicNumber methodsFor: 'operations' stamp: 'len 11/11/2023 15:25:01'!
normalized
	"Answer a unique choice of associate. See >>normalization."
	self isZero ifTrue: [^ self].
	^ self parent one! !

!ComplexAlgebraicNumber methodsFor: 'operations' stamp: 'len 11/29/2023 10:03:24'!
representation
	^ minimalPolynomial companionMatrix! !

!ComplexAlgebraicNumber methodsFor: 'operations' stamp: 'len 11/20/2023 10:21:00'!
sign
	"For a general complex algebraic number z we define sign as z / |z| if z ≠ 0, and otherwise 0."
	self isZero ifTrue: [^ self].
	^ self / self abs! !

!ComplexAlgebraicNumber methodsFor: 'operations' stamp: 'len 11/9/2023 19:22:03'!
sqrt
	self isZero ifTrue: [^ self].
	^ self parent sqrt: self asRational! !

!ComplexAlgebraicNumber methodsFor: 'operations' stamp: 'len 11/12/2023 22:05:55'!
squared
	^ self class polynomial: minimalPolynomial zeroSquared bounds: bounds squared! !

!ComplexAlgebraicNumber methodsFor: 'operations' stamp: 'len 11/17/2023 14:41:25'!
trace
	"Answer the absolute trace of the receiver."
	^ self absoluteTrace

"alternatively:
	^ self conjugates sum asReal"! !

!ComplexAlgebraicNumber methodsFor: 'printing' stamp: 'len 1/11/2016 06:44'!
printOn: aStream
	self printOn: aStream base: 10! !

!ComplexAlgebraicNumber methodsFor: 'printing' stamp: 'len 11/10/2023 19:15:59'!
printOn: aStream base: base
	| x a b |
	self isRational ifTrue: [^ self asRational printOn: aStream base: base].
	minimalPolynomial degree = 2 ifTrue: [^ self printQuadraticOn: aStream base: base].
	x := self asFloat.
	a := x real asFloat roundTo: self printPrecision.
	b := x imaginary asFloat roundTo: self printPrecision.
	self isImaginary ifFalse: [a printOn: aStream base: base].
	self isReal ifFalse:
		[self isImaginary ifFalse: [aStream nextPutAll: (0 <= b ifTrue: [' + '] ifFalse: [b := b negated. ' - '])].
		b printOn: aStream base: base.
		aStream nextPutAll: 'i' italic].
	aStream nextPutAll: '..'! !

!ComplexAlgebraicNumber methodsFor: 'printing' stamp: 'len 11/13/2023 10:46:41'!
printPrecision
	^ 0.00001! !

!ComplexAlgebraicNumber methodsFor: 'printing' stamp: 'len 12/23/2023 10:29:26'!
printQuadraticOn: aStream base: base
	| f a b c Δ z y x1 x2 sign |
	f := minimalPolynomial integralPrimitivePart.
	a := (f at: 2) asInteger.
	b := (f at: 1) asInteger.
	c := (f at: 0) asInteger.
	Δ := b squared - (4*a*c).
	z := Δ squarefreePart.
	y := (Δ / z) sqrt.
	x1 := b negated + (Δ negative ifTrue: [Δ negated sqrt i] ifFalse: [Δ sqrt]) / (2*a).
	x2 := b negated - (Δ negative ifTrue: [Δ negated sqrt i] ifFalse: [Δ sqrt]) / (2*a).
	(x1 - bounds center) abs <= bounds radius
		ifTrue: [sign := ' + ']
		ifFalse: [(x2 - bounds center) abs <= bounds radius ifTrue: [sign := ' - '. y := y negated] ifFalse: [self halt]].
	b = 0 ifFalse:
		[b/(-2*a) printOn: aStream base: base.
		aStream nextPutAll: sign.
		y := y abs].
	y negative ifTrue: [aStream nextPut: $-. y := y abs].
	y/(2*a) = 1 ifFalse: [y/(2*a) printOn: aStream base: base].
	"TODO: put the i before √"
	z abs = 1 ifFalse:
		[aStream nextPut: $√.
		z abs printOn: aStream base: base].
	z negative ifTrue: [aStream nextPutAll: 'i' italic]! !

!ComplexAlgebraicNumber methodsFor: 'testing' stamp: 'len 11/9/2023 19:32:11'!
isImaginary
	"Answer true if the receiver's real part is zero and imaginary part is not zero."
	^ self isZero not and: [(self * self parent i) isReal]! !

!ComplexAlgebraicNumber methodsFor: 'testing' stamp: 'len 11/10/2023 16:06:36'!
isRational
	^ minimalPolynomial degree < 2! !

!ComplexAlgebraicNumber methodsFor: 'testing' stamp: 'len 11/10/2023 16:06:24'!
isReal
	"Answer true if the receiver's imaginary part is zero."
	^ self = self conjugate! !

!ComplexAlgebraicNumber methodsFor: 'testing' stamp: 'len 11/17/2023 10:58:47'!
isSquare
	"Answer true if the receiver is a perfect square, i.e. it has a square root."
	^ true! !

!ComplexAlgebraicNumber methodsFor: 'testing' stamp: 'len 11/10/2023 16:06:17'!
isZero
	^ self isRational and: [minimalPolynomial independentCoefficient isZero]! !

!ComplexAlgebraicNumber methodsFor: 'private' stamp: 'len 11/10/2023 14:22:07'!
minimalPolynomial: aPolynomial bounds: aBall
	self assert: aPolynomial isMonic.
	self assert: aPolynomial scalars = ℚ.
	minimalPolynomial := aPolynomial.
	bounds := aBall.
	self normalize! !

!ComplexAlgebraicNumber methodsFor: 'private' stamp: 'len 11/10/2023 16:18:06'!
normalize
	"Rational numbers are represented exactly with a ball of radius 0:"
	bounds radius isZero ifTrue: [^ self].
	minimalPolynomial degree < 2 ifTrue:
		[bounds := Ball center: minimalPolynomial independentCoefficient negated radius: 0.
		^ self].
	"If a number is not 0, it is represented with a ball that doesn't include 0:"
	[(bounds := self refine: bounds) hasZero] whileTrue! !

!ComplexAlgebraicNumber methodsFor: 'private' stamp: 'len 11/8/2023 08:51:21'!
parent
	^ ℂ! !

!ComplexAlgebraicNumber methodsFor: 'private' stamp: 'len 11/10/2023 14:18:13'!
rootIsolatorClass
	^ ComplexRootIsolator! !

!ComplexAlgebraicNumber class methodsFor: 'instance creation' stamp: 'len 11/13/2023 10:36:50'!
fromRational: aRational
	"Answer an instance of the receiver representing a rational number."
	^ self minimalPolynomial: aRational minimalPolynomial bounds: (Ball center: aRational radius: 0)! !

!ComplexAlgebraicNumber class methodsFor: 'instance creation' stamp: 'len 11/9/2023 10:50:45'!
minimalPolynomial: aPolynomial bounds: aBall
	"Answer an instance of the receiver representing the unique root of aPolynomial in the given rational ball of the complex plane.
	The given polynomial is assumed to be monic of minimal degree."
	^ self new minimalPolynomial: aPolynomial bounds: aBall! !

!ComplexAlgebraicNumber class methodsFor: 'instance creation' stamp: 'len 11/9/2023 20:30:31'!
polynomial: aPolynomial bounds: aBall
	"Answer an instance of the receiver representing the unique root of aPolynomial in the given rational ball of the complex plane.
	The polynomial doesn't need to be minimal."
	^ self minimalPolynomial: (aPolynomial factorization asSet detectMin: [:f| (f value: aBall center) abs]) normalized bounds: aBall! !

!RealAlgebraicNumber methodsFor: 'comparing' stamp: 'len 12/3/2023 21:19:44'!
< aNumber
	^ (self compare: aNumber) < 0! !

!RealAlgebraicNumber methodsFor: 'comparing' stamp: 'len 12/3/2023 21:12:09'!
<= aNumber
	^ (self compare: aNumber) <= 0! !

!RealAlgebraicNumber methodsFor: 'comparing' stamp: 'len 12/4/2023 10:14:59'!
> aNumber
	^ aNumber < self! !

!RealAlgebraicNumber methodsFor: 'comparing' stamp: 'len 12/4/2023 10:15:08'!
>= aNumber
	^ aNumber <= self! !

!RealAlgebraicNumber methodsFor: 'comparing' stamp: 'len 12/4/2023 10:33:59'!
between: min and: max 
	"Answer whether the receiver is less than or equal to the argument, max,  and greater than or equal to the argument, min."

	^self >= min and: [self <= max]! !

!RealAlgebraicNumber methodsFor: 'comparing' stamp: 'len 12/3/2023 16:06:25'!
compare: aNumber
	| B₁ B₂ |
	aNumber class = self class ifFalse: [^ (self - aNumber) sign].
	self = aNumber ifTrue: [^ 0].
	B₁ := bounds.
	B₂ := aNumber bounds.
	[B₁ overlaps: B₂] whileTrue: [B₁ := self refine: B₁. B₂ := aNumber refine: B₂].
	^ B₁ center compare: B₂ center! !

!RealAlgebraicNumber methodsFor: 'comparing' stamp: 'len 12/4/2023 10:33:55'!
max: anElement 
	"Answer the receiver or the argument, whichever is greater."

	^ self > anElement ifTrue: [self] ifFalse: [anElement]! !

!RealAlgebraicNumber methodsFor: 'comparing' stamp: 'len 12/4/2023 10:33:50'!
min: anElement
	"Answer the receiver or the argument, whichever is lesser."

	^ self < anElement ifTrue: [self] ifFalse: [anElement]! !

!RealAlgebraicNumber methodsFor: 'comparing' stamp: 'len 12/4/2023 10:33:46'!
min: aMin max: aMax
	^ (self min: aMin) max: aMax! !

!RealAlgebraicNumber methodsFor: 'converting' stamp: 'len 11/10/2023 20:01:18'!
asComplex
	^ ComplexAlgebraicNumber polynomial: minimalPolynomial bounds: (Ball center: bounds center asComplex radius: bounds radius)! !

!RealAlgebraicNumber methodsFor: 'converting' stamp: 'len 11/10/2023 14:11:57'!
asReal
	^ self! !

!RealAlgebraicNumber methodsFor: 'operations' stamp: 'len 11/10/2023 16:11:23'!
abs
	^ self negative ifTrue: [self negated] ifFalse: [self]! !

!RealAlgebraicNumber methodsFor: 'operations' stamp: 'len 11/20/2023 10:26:07'!
abs²
	"Answer the square of the absolute value of the receiver."
	^ self squared! !

!RealAlgebraicNumber methodsFor: 'operations' stamp: 'len 11/10/2023 14:45:33'!
conjugate
	"Answer the complex conjugate of the receiver."
	^ self! !

!RealAlgebraicNumber methodsFor: 'operations' stamp: 'len 11/17/2023 11:06:37'!
multiplicativeOrder
	"Answer the order of the receiver as an element of the group of units.
	Return 0 if the receiver is not a unit."
	^ self isOne ifTrue: [1] ifFalse: [self isMinusOne ifTrue: [2] ifFalse: [0]]! !

!RealAlgebraicNumber methodsFor: 'operations' stamp: 'len 11/10/2023 14:08:35'!
sign
	^ bounds center sign! !

!RealAlgebraicNumber methodsFor: 'testing' stamp: 'len 11/10/2023 16:05:43'!
isImaginary
	^ false! !

!RealAlgebraicNumber methodsFor: 'testing' stamp: 'len 11/10/2023 14:05:44'!
isReal
	^ true! !

!RealAlgebraicNumber methodsFor: 'testing' stamp: 'len 11/17/2023 10:58:34'!
isSquare
	"Answer true if the receiver is a perfect square, i.e. it has a square root."
	^ self positive! !

!RealAlgebraicNumber methodsFor: 'testing' stamp: 'len 11/10/2023 16:04:07'!
negative
	^ self sign = -1! !

!RealAlgebraicNumber methodsFor: 'testing' stamp: 'len 11/10/2023 16:03:35'!
positive
	^ self sign >= 0! !

!RealAlgebraicNumber methodsFor: 'testing' stamp: 'len 11/10/2023 16:04:32'!
strictlyPositive
	^ self sign = 1! !

!RealAlgebraicNumber methodsFor: 'private' stamp: 'len 11/10/2023 14:05:38'!
parent
	^ ℝ! !

!RealAlgebraicNumber methodsFor: 'private' stamp: 'len 11/10/2023 14:18:30'!
rootIsolatorClass
	^ RealRootIsolator! !

!AbelianClosureElement methodsFor: 'accessing' stamp: 'len 11/21/2023 16:08:34'!
representative
	^ representative! !

!AbelianClosureElement methodsFor: 'comparing' stamp: 'len 11/22/2023 10:55:09'!
= anObject
	| K |
	self class = anObject class ifFalse: [^ false].
	K := representative parent ∨ anObject representative parent.
	^ K !! representative = (K !! anObject representative)! !

!AbelianClosureElement methodsFor: 'comparing' stamp: 'len 11/22/2023 10:54:56'!
hash
	^ self minimalPolynomial hash! !

!AbelianClosureElement methodsFor: 'operations' stamp: 'len 11/22/2023 10:21:37'!
* anElement
	| K |
	anElement isInteger ifTrue: [^ self class representative: representative * anElement].
	self class = anElement class ifFalse: [^ self adapt: anElement andSend: #*].
	K := representative parent ∨ anElement representative parent.
	^ self class representative: (K !! representative * (K !! anElement representative))! !

!AbelianClosureElement methodsFor: 'operations' stamp: 'len 11/22/2023 10:21:43'!
+ anElement
	| K |
	self class = anElement class ifFalse: [^ self  adapt: anElement andSend: #+].
	K := representative parent ∨ anElement representative parent.
	^ self class representative: (K !! representative + (K !! anElement representative))! !

!AbelianClosureElement methodsFor: 'operations' stamp: 'len 11/22/2023 16:02:53'!
colift: anElement
	"Answer x such that xa = b, where a is the receiver and b is the argument. Answer nil if there's no solution.
	This is the right division of b by a, written b / a."
	anElement isZero ifTrue: [^ anElement].
	^ self isZero ifFalse: [anElement * self inverse]! !

!AbelianClosureElement methodsFor: 'operations' stamp: 'len 11/22/2023 20:58:24'!
conjugate
	"Answer the complex conjugate of the receiver."
	^ self class representative: representative conjugate! !

!AbelianClosureElement methodsFor: 'operations' stamp: 'len 11/22/2023 10:21:55'!
inverse
	^ self class representative: representative inverse! !

!AbelianClosureElement methodsFor: 'operations' stamp: 'len 11/22/2023 10:20:38'!
minimalPolynomial
	^ representative minimalPolynomial! !

!AbelianClosureElement methodsFor: 'operations' stamp: 'len 11/23/2023 09:52:45'!
multiplicativeOrder
	^ representative multiplicativeOrder! !

!AbelianClosureElement methodsFor: 'operations' stamp: 'len 11/22/2023 10:22:03'!
negated
	^ self class representative: representative negated! !

!AbelianClosureElement methodsFor: 'operations' stamp: 'len 11/22/2023 10:22:11'!
norm
	"Answer the absolute norm of the receiver."
	^ self absoluteNorm! !

!AbelianClosureElement methodsFor: 'operations' stamp: 'len 11/22/2023 10:22:15'!
trace
	"Answer the absolute trace of the receiver."
	^ self absoluteTrace! !

!AbelianClosureElement methodsFor: 'printing' stamp: 'len 11/21/2023 16:09:07'!
printOn: aStream
	aStream print: representative! !

!AbelianClosureElement methodsFor: 'testing' stamp: 'len 11/22/2023 10:22:34'!
isOne
	^ representative isOne! !

!AbelianClosureElement methodsFor: 'testing' stamp: 'len 12/2/2023 09:51:07'!
isSquare
	"Answer true if the receiver is a perfect square, i.e. it has a square root."
	representative isScalar ifTrue: [^ true].
	^ super isSquare! !

!AbelianClosureElement methodsFor: 'testing' stamp: 'len 11/22/2023 10:22:44'!
isZero
	^ representative isZero! !

!AbelianClosureElement methodsFor: 'private' stamp: 'len 11/21/2023 16:12:38'!
parent
	^ ℚ abelianClosure! !

!AbelianClosureElement methodsFor: 'private' stamp: 'len 11/21/2023 16:08:51'!
representative: aCyclotomicRational
	representative := aCyclotomicRational! !

!AbelianClosureElement class methodsFor: 'instance creation' stamp: 'len 11/21/2023 16:11:14'!
representative: aCyclotomicRational
	^ self new representative: aCyclotomicRational! !

!Polynomial methodsFor: 'accessing' stamp: 'len 10/30/2023 19:03:53'!
denominator
	"If the coefficients ring is a localization, answer the LCM of the denominators of the coefficients."
	self scalars isLocalization ifFalse: [^ self scalars one].
	^ self coefficients inject: self scalars numerators one into: [:d :each| each denominator lcm: d]! !

!Polynomial methodsFor: 'accessing' stamp: 'len 12/23/2023 15:19:36'!
numerator
	"If the coefficients ring is a localization, answer the product of the receiver by the LCM of the denominators of the coefficients. The answer is a polynomial over the ring of numerators of the localization ring."
	| d |
	self scalars isLocalization ifFalse: [^ self].
	d := self scalars !! self denominator.
	^ parent numerators associations: (self associations collect: [:each| each key -> (each value * d) numerator])! !

!Polynomial methodsFor: 'accessing' stamp: 'len 10/6/2016 15:34'!
parent
	^ parent! !

!Polynomial methodsFor: 'accessing' stamp: 'len 7/16/2019 16:53:18'!
representative
	"If the coefficients ring is a quotient R/I, answer a representative of the receiver over R. See >>%."
	^ self apply: self scalars projection section! !

!Polynomial methodsFor: 'accessing' stamp: 'len 10/6/2016 15:34'!
scalars
	^ parent scalars! !

!Polynomial methodsFor: 'accessing-coefficients' stamp: 'len 4/27/2022 16:44:40'!
coefficients
	"Answer the collection of coefficients of the receiver, possibly including zero entries."
	^ coefficients! !

!Polynomial methodsFor: 'accessing-coefficients' stamp: 'len 4/28/2022 06:58:18'!
independentCoefficient
	^ self at: parent monomials identity! !

!Polynomial methodsFor: 'accessing-indeterminates' stamp: 'len 3/1/2016 16:31'!
has: anIndeterminate
	"Answer true if anIndeterminate is effectively present in the receiver."
	^ self monomials anySatisfy: [:any| any has: anIndeterminate]! !

!Polynomial methodsFor: 'accessing-indeterminates' stamp: 'len 2/18/2017 19:52:08'!
indeterminates
	"Answer the indeterminates effectively present in this polynomial."
	^ self parent indeterminates select: [:each| self has: each]! !

!Polynomial methodsFor: 'accessing-indeterminates' stamp: 'len 2/3/2017 07:16:12'!
leadingIndeterminate
	"Answer the main (or leading) indeterminate of the receiver (according to a monomial ordering)."
	| indeterminates |
	indeterminates _ self ordering indeterminates.
	indeterminates reverseDo: [:i| (self has: i) ifTrue: [^ i]].
	^ indeterminates first! !

!Polynomial methodsFor: 'accessing-monomials' stamp: 'len 6/12/2023 16:13:08'!
degree
	"Answer the total degree of the receiver, i.e. the maximum of the degree of its monomials."
	self isZero ifTrue: [^ Infinity negative].
"	self parent ordering isOrdinaryGraded ifTrue: [^ self monomials first degree]."
	^ self monomials max: [:each| each degree]! !

!Polynomial methodsFor: 'accessing-monomials' stamp: 'len 3/2/2016 23:47'!
degreeIn: anIndeterminate
	"Answer the degree of the receiver in the given indeterminate."
	self isZero ifTrue: [^ Infinity negative].
	^ self monomials max: [:each| each degreeIn: anIndeterminate]! !

!Polynomial methodsFor: 'accessing-monomials' stamp: 'len 2/6/2017 06:40:57'!
density
	"Answer a measure of the density/sparsity of the receiver."
	self isZero ifTrue: [^ 0].
	^ self coefficients size / (self degree + 1)! !

!Polynomial methodsFor: 'accessing-monomials' stamp: 'len 1/14/2022 13:53:56'!
ecart
	"Answer the ecart of the receiver. This is a measure of how far a polynomial is from being homogeneous."
	^ self degree - self leadingMonomial degree! !

!Polynomial methodsFor: 'accessing-monomials' stamp: 'len 1/2/2022 10:08:16'!
monomials
	"Answer the collection of monomials effectively present in this polynomial (with nonzero coefficient). This is called the 'support' of a polynomial."
	^ Iterator on: self performing: #monomialsDo:! !

!Polynomial methodsFor: 'accessing-monomials' stamp: 'len 6/12/2023 16:18:06'!
order
	"Answer the minimum degree of the monomials present in the receiver."
	^ self isZero ifTrue: [Infinity positive] ifFalse: [self monomials min: [:each| each degree]]! !

!Polynomial methodsFor: 'accessing-monomials' stamp: 'len 2/3/2017 07:17:54'!
ordering
	"Answer the monomial ordering of the receiver."
	^ self parent ordering! !

!Polynomial methodsFor: 'accessing-monomials' stamp: 'len 1/2/2022 10:08:28'!
support
	"Answer the collection of monomials effectively present in this polynomial (with nonzero coefficient)."
	^ self monomials! !

!Polynomial methodsFor: 'accessing-terms' stamp: 'len 4/27/2022 16:55:26'!
associations
	^ Iterator on: self performing: #associationsDo:! !

!Polynomial methodsFor: 'accessing-terms' stamp: 'len 2/7/2017 03:38:56'!
formAt: anInteger
	"Answer the homogeneous component of degree anInteger (an anInteger-form)."
	| answer |
	answer _ self zero.
	self terms do: [:each| each degree = anInteger ifTrue: [answer _ answer + each]].
	^ answer! !

!Polynomial methodsFor: 'accessing-terms' stamp: 'len 6/16/2023 20:11:10'!
initialForm
	"Answer the homogeneous component of the lowest degree.
	This makes sense for a local ordering."
	self parent isLocal ifFalse: [self error: 'not a local ordering'].
	^ self isZero ifTrue: [self] ifFalse: [self formAt: self order]! !

!Polynomial methodsFor: 'accessing-terms' stamp: 'len 6/7/2020 14:31:24'!
initialTerm
	^ self isZero
		 ifTrue: [self]
		 ifFalse: [self termAt: self initialMonomial]! !

!Polynomial methodsFor: 'accessing-terms' stamp: 'len 3/1/2016 22:11'!
leadingTerm
	"Answer the first term of the receiver."

	^ self isZero
		 ifTrue: [self]
		 ifFalse: [self termAt: self leadingMonomial]! !

!Polynomial methodsFor: 'accessing-terms' stamp: 'len 2/10/2017 20:28:17'!
linearForm
	^ self formAt: 1! !

!Polynomial methodsFor: 'accessing-terms' stamp: 'len 3/1/2016 22:08'!
tail
	^ self - self leadingTerm! !

!Polynomial methodsFor: 'accessing-terms' stamp: 'len 12/21/2017 18:25:51'!
termAt: aMonomial
	^ self parent coefficient: (self at: aMonomial) monomial: aMonomial! !

!Polynomial methodsFor: 'accessing-terms' stamp: 'len 11/29/2016 11:49:38'!
terms
	^ Iterator on: self performing: #termsDo:! !

!Polynomial methodsFor: 'comparing' stamp: 'len 4/29/2022 10:12:51'!
= anObject
	^ self == anObject or: [self class = anObject class and: [coefficients = anObject coefficients]]! !

!Polynomial methodsFor: 'comparing' stamp: 'len 4/29/2022 10:13:12'!
hash
	^ coefficients hash! !

!Polynomial methodsFor: 'converting' stamp: 'len 9/16/2022 08:19:58'!
asBilinearForm
	(self degree = 2 and: [self isHomogeneous]) ifFalse: [^ self error: 'not homogeneous of degree 2'].
	self parent rank even ifFalse: [^ self error: 'not even rank'].
	^ BilinearForm on: self scalars ^ (self parent rank / 2) mapWithArguments: [:x :y| self value: (x, y)]! !

!Polynomial methodsFor: 'converting' stamp: 'len 5/16/2023 22:18:09'!
asMultivariate
	"Convert a polynomial in R[x₁,...,xₙ][y] to a polynomial in R[x₁,...,xₙ,y]."
	(self scalars isKindOf: PolynomialRing) ifFalse: [^ self].
	self parent isUnivariate ifFalse: [^ self].
	^ self parent asMultivariate !! self! !

!Polynomial methodsFor: 'converting' stamp: 'len 11/23/2022 17:14:18'!
asQuadraticForm
	| coeff |
	(self degree = 2 and: [self isHomogeneous]) ifFalse: [^ self error: 'not homogeneous of degree 2'].
	coeff _ OrderedCollection new.
	1 to: self parent rank do: [:i|
		i to: self parent rank do: [:j|
			coeff add: (self at: ((self parent monomials x: i) * (self parent monomials x: j)))]].
	^ QuadraticForm from: self scalars ^ self parent rank coefficients: self parent scalars !!!! coeff asArray! !

!Polynomial methodsFor: 'converting' stamp: 'len 12/24/2023 09:13:26'!
asScalar
	self isConstant ifFalse: [^ self error: 'not a constant polynomial'].
	^ self independentCoefficient! !

!Polynomial methodsFor: 'converting' stamp: 'len 5/8/2023 17:00:17'!
asUnivariate
	"Answer the receiver as univariate in the last indeterminate, e.g. go from R[x,y,z] to R[x,y][z]."
	| S term n d newCoefficients |
	self parent isUnivariate ifTrue: [^ self].
	n _ self parent rank.
	S _ self parent asUnivariate.
	(d _ self degreeIn: n) <= 0
		ifTrue: [^ S constant: S scalars !! self].
	newCoefficients _ S scalars zeros: d+1.
	self associationsDo: [:each|
		term _ S scalars coefficient: each value monomial: S scalars monomials !! (each key without: n).
		newCoefficients at: (each key at: n)+1 add: term].
	^ S coefficients: newCoefficients

"alternative (but slower):
	self parent isUnivariate ifTrue: [^ self].
	^ self parent asUnivariate !! self
"
! !

!Polynomial methodsFor: 'converting' stamp: 'len 3/6/2021 15:20:06'!
asUnivariateIn: anIndeterminate
	"Answer the receiver as univariate in the given indeterminate, e.g. go from R[x,y,z] to R[x,y][z]."
	(self parent isUnivariate and: [self parent indeterminate = anIndeterminate]) ifTrue: [^ self].
	^ (self parent asUnivariateIn: anIndeterminate) !! self! !

!Polynomial methodsFor: 'converting' stamp: 'len 5/23/2018 22:30:47'!
orderedBy: aMonomialOrdering
	"Answer a copy of the receiver with a different monomial ordering."
	^ (self parent orderedBy: aMonomialOrdering) !! self! !

!Polynomial methodsFor: 'copying' stamp: 'len 12/20/2022 09:32:49'!
postCopy
	super postCopy.
	coefficients _ coefficients copy! !

!Polynomial methodsFor: 'enumerating' stamp: 'len 4/27/2022 16:55:56'!
associationsDo: aBlock
	self subclassResponsibility! !

!Polynomial methodsFor: 'enumerating' stamp: 'len 4/27/2022 16:48:55'!
monomialsDo: aBlock
	"Iterate over the support of the receiver, i.e. the monomials with nonzero coefficient."
	self subclassResponsibility! !

!Polynomial methodsFor: 'enumerating' stamp: 'len 4/27/2022 16:54:43'!
termsDo: aBlock
	self associationsDo: [:each| aBlock value: (self parent coefficient: each value monomial: each key)]! !

!Polynomial methodsFor: 'factorization' stamp: 'len 12/23/2023 10:30:35'!
content
	"Answer the GCD of the coefficients of the receiver.
	In a field, it is convenient to define the content as 1.
	For example, 2x² + 4 has content 2 in ℤ[x] and 1 in ℚ[x]."
	| answer |
	self isZero ifTrue: [^ self scalars zero].
	self scalars isField ifTrue: [^ self scalars one].
	answer := self scalars zero.
	self coefficients do: [:each| answer := answer gcd: each. answer isOne ifTrue: [^ answer]].
	^ answer! !

!Polynomial methodsFor: 'factorization' stamp: 'len 12/23/2023 16:34:25'!
integralPrimitivePart
	"Answer the normalized integral primitive polynomial associated to the receiver.
	Remove the integral content (including normalization unit).
	NOTE: assumes the receiver is a polynomial over the fraction field of an integral domain with a GCD algorithm."
	| a b |
	self isZero ifTrue: [^ self].
	a := self leadingCoefficient numerator normalized.
	b := self leadingCoefficient denominator.
	self coefficients do: [:each|
		a := a gcd: each numerator.
		b := b lcm: each denominator].
	^ self * (self scalars reducedNumerator: b * self leadingCoefficient numerator normalization denominator: a)! !

!Polynomial methodsFor: 'factorization' stamp: 'len 12/23/2023 10:10:04'!
primitivePart
	"Answer the primitive part of the receiver."
	^ self isZero ifTrue: [self] ifFalse: [self / self content]! !

!Polynomial methodsFor: 'factorization' stamp: 'len 9/25/2018 00:28:05'!
sign
	"Answer the sign of the receiver, i.e. the sign if its leading coefficient."
	^ self leadingCoefficient sign! !

!Polynomial methodsFor: 'gcd' stamp: 'len 6/16/2023 17:36:33'!
gcd: aPolynomial
	| f₁ f₂ m₁ m₂ c₁ c₂ |
	self isZero ifTrue: [^ aPolynomial normalized].
	aPolynomial isZero ifTrue: [^ self normalized].
	(self isConstant or: [aPolynomial isConstant]) ifTrue:
		[^ self scalars isField ifTrue: [self one] ifFalse: [self parent constant: (self content gcd: aPolynomial content)]].
	self scalars isLocalization ifTrue: [^ (self parent !! (self numerator gcd: aPolynomial numerator)) normalized].
"	(self scalars isKindOf: PolynomialRing) ifTrue: [^ self parent !! (self flatten gcd: aPolynomial flatten)]."
"	self scalars = ℤ ifTrue: [(self gcdheu: aPolynomial) ifNotNil: [:answer| ^ answer]]."
"	self scalars = ℤ ifTrue: [^ self mgcd: aPolynomial]."
	self parent isUnivariate ifTrue: [^ self ugcd: aPolynomial]. "should not happen, see UnivariatePolynomial>>#gcd:"
	"Multivariate case:"
	m₁ := self monomials gcd.
	m₂ := aPolynomial monomials gcd.
	f₁ := (self / m₁) asUnivariate.
	f₂ := (aPolynomial / m₂) asUnivariate.
	c₁ := f₁ content.
	c₂ := f₂ content.
	^ ((self parent !! ((f₁ / c₁ ugcd: f₂ / c₂) * (c₁ gcd: c₂)) asMultivariate) * (m₁ gcd: m₂)) normalized! !

!Polynomial methodsFor: 'gcd' stamp: 'len 6/16/2023 17:31:39'!
gcdheu: aPolynomial
	"GCD Heuristic Algorithm. See [GCL92, Algorithm 7.4].
	Answer the GCD of the two multivariate polynomials over the integers, or nil."
	| R ξ i point γ G j g |
	self isZero ifTrue: [^ aPolynomial normalized].
	aPolynomial isZero ifTrue: [^ self normalized].
	R := self parent.
	self assert: R scalars = ℤ.
	ξ := (self normMax min: aPolynomial normMax)*2 + 2.
	i := (1 to: R rank)
		detect: [:k| (self has: k) and: [aPolynomial has: k]]
		ifNone: [^ R constant: (self content gcd: aPolynomial content)].
	6 timesRepeat:
		[ξ highBit * ((self degreeIn: i) max: (aPolynomial degreeIn: i)) > 5000 ifTrue: [^ nil].
		point := (1 to: R rank) collect: [:k| k = i ifTrue: [R constant: ξ] ifFalse: [R x: k]].
		(γ := (self value: point) gcdheu: (aPolynomial value: point)) ifNotNil:
			[G := R zero.
			j := 0.
			[γ isZero] whileFalse:
				[g := γ apply: [:a| a \\ ξ].
				G := (R x: i to: j) * g + G.
				γ := (γ - g) // ξ.
				j := j + 1].
			(G | self and: [G | aPolynomial]) ifTrue: [^ G]].
		ξ := ξ * 73794 // 27011].
	^ nil! !

!Polynomial methodsFor: 'gcd' stamp: 'len 6/10/2023 15:43:37'!
mgcd: aPolynomial
	"Modular GCD Algorithm. See [GCL92, Algorithm 7.1].
	This algorithm reduces the multivariate integer GCD problem to a series of multivariate finite field GCD problems by applying modular homomorphisms."
	| R k a b A B c g q H limit p 𝔽ₚ Rₚ Aₚ Bₚ gₚ Cₚ n m C |
	self assert: self scalars = ℤ.
	R := self parent.
"	k > 1 ifFalse: [^ self ugcd: aPolynomial]."
	"Remove the content:"
	a := self content. b := aPolynomial content.
	(self indeterminates anySatisfy: [:i| aPolynomial has: i]) ifFalse: [^ self parent constant: (a gcd: b)].
	k := (R rank to: 1 by: -1) detect: [:i| (self has: i) or: [aPolynomial has: i]] ifNone: [0].
	A := self / a. B := aPolynomial / b.
	"Compute coefficient bound for the GCD:"
	c := a gcd: b. g := A leadingCoefficient gcd: B leadingCoefficient.
	q := 1. H := R zero. n := (A degreeIn: k) min: (B degreeIn: k).
	limit := (1 << n) * g abs * (A normMax min: B normMax).
	"Main loop:"
	[[p := 16rFFFFFFFF atRandom nextPrime. p | g] whileTrue.
	𝔽ₚ := PrimeField new: p.
	Rₚ := R over: 𝔽ₚ.
	Aₚ := Rₚ !! A. Bₚ := Rₚ !! B.
	gₚ := 𝔽ₚ !! g. Cₚ := Aₚ pgcd: Bₚ. m := Cₚ degreeIn: k.
	"Normalize Cₚ so that the leading coefficient is gₚ:"
	Cₚ := Cₚ * (gₚ * Cₚ leadingCoefficient inverse).
	"Test for unlucky homomorphisms:"
	m < n
		ifTrue: [q := p. H := Cₚ lift. n := m]
		ifFalse: [m = n ifTrue:
			[| xgcd |
			xgcd := q xgcd: p.
			H := R associations: ((H monomials asSet, Cₚ monomials asSet) asArray
				collect: [:each| | hᵢ cᵢ |
					hᵢ := H at: each. cᵢ := (Cₚ at: each) lift.
					each -> (hᵢ * (xgcd at: 3) * p + (cᵢ * (xgcd at: 2) * q))]).
			q := q * p.
			q > limit
				ifTrue:
					[C := H primitivePart.
					(C | A and: [C | B]) ifTrue: [^ C * c]]
				ifFalse:
					[m = 0 ifTrue: [^ R constant: c]]]]] repeat! !

!Polynomial methodsFor: 'gcd' stamp: 'len 6/10/2023 13:31:17'!
oldgcd: aPolynomial
	| a b u v r |
	self isZero ifTrue: [^ aPolynomial normalized].
	aPolynomial isZero ifTrue: [^ self normalized].
	(self isConstant or: [aPolynomial isConstant]) ifTrue:
		[^ self scalars isField ifTrue: [self one] ifFalse: [self parent constant: (self content gcd: aPolynomial content)]].
	self scalars hasGCD ifFalse: [^ self error: 'the coefficients ring doesn''t have GCD'].
	self scalars isLocalization ifTrue: [^ (self parent !! (self numerator gcd: aPolynomial numerator)) normalized].
"	self scalars = ℤ ifTrue: [(self gcdheu: aPolynomial) ifNotNil: [:answer| ^ answer]]."
"	(self scalars isKindOf: PolynomialRing) ifTrue: [^ self parent !! (self flatten gcd: aPolynomial flatten)]."
	"Multivariate case:"
	self parent isUnivariate ifFalse:
		[| ma mb |
		ma := self monomials gcd.
		mb := aPolynomial monomials gcd.
		a := (self / ma) asUnivariate.
		b := (aPolynomial / mb) asUnivariate.
		u := a content.
		v := b content.
		^ ((self parent !! ((a / u gcd: b / v) * (u gcd: v)) asMultivariate) * (ma gcd: mb)) normalized].
	"Generic Euclidean algorithm:"
	self scalars isField ifTrue: [^ super gcd: aPolynomial].
	"Over a general ring we use the primitive PRS algorithm [Coh96, Algorithm 3.2.10]:"
	self scalars isUFD ifFalse: [^ self error: 'the coefficients ring is not a UFD'].
	u := self content.
	v := aPolynomial content.
	a := self ÷ u.
	b := aPolynomial ÷ v.
	[b isZero] whileFalse: [r := (a pseudoRem: b) primitivePart. a := b. b := r].
	a isConstant ifTrue: [a := self one].
	^ a normalized * (u gcd: v)

"alternative for the last part:
	""Over a general UFD we use the subresultant GCD algorithm [Coh96, Algorithm 3.3.1]:""
	self scalars isUFD ifFalse: [^ self error: 'the coefficients ring is not a UFD'].
	aPolynomial degree > self degree ifTrue: [^ aPolynomial gcd: self].
	u := self content.
	v := aPolynomial content.
	a := self ÷ u.
	b := aPolynomial ÷ v.
	h := g := self scalars one.
	[δ := a degree - b degree.
	r := a pseudoRem: b.
	r isConstant] whileFalse:
		[a := b. b := r ÷ (g*(h^δ)). g := a leadingCoefficient. h := g^δ ÷ (h^(δ - 1))].
	r isZero ifFalse: [b := self one].
	^ b primitivePart	 * (u gcd: v)"! !

!Polynomial methodsFor: 'gcd' stamp: 'len 6/10/2023 16:06:24'!
pgcd: aPolynomial
	"Multivariate GCD Reduction Algorithm. See [GCL92, Algorithm 7.2].
	This algorithm reduces the k-variate finite field GCD problem to a series of (k-1)-variate finite field GCD problems by applying evaluation homomorphisms. This algorithm is applied recursively."
	| k R S A B a b c g q H n α A₀ B₀ C₀ m g₀ C |
	R := self parent.
	k := (R rank to: 1 by: -1) detect: [:i| (self has: i) or: [aPolynomial has: i]] ifNone: [0].
	k > 1 ifFalse: [^ self ugcd: aPolynomial].
	"Determine the content of A and B considered as polynomials in 𝔽[xₖ][x₁...xₖ₋₁] (polynomials with coefficients in 𝔽[xₖ])."
	S := R extract: (1 to: k-1), (k+1 to: R rank).
	A := S !! self. B := S !! aPolynomial.
	a := A content. b := B content.
	A := A / a. B := B / b.
	c := a ugcd: b. g := A leadingCoefficient ugcd: B leadingCoefficient.
	"Note that both c and g are in 𝔽[xₖ]."
	A := R !! A. B := R !! B. c := R !! c.
	q := R one. H := R one. n := (A degreeIn: k) min: (B degreeIn: k). "limit := n + g degree."
	"Main loop:"
	[[α := R scalars atRandom. (g₀ := g value: α) isZero or: [(q value: α in: k) isZero "already used"]] whileTrue.
	"Warning: the line above could hang if the coefficients field doesn't have enough elements. In that case we should move to a field extension."
	A₀ := A value: α in: k. B₀ := B value: α in: k.
	C₀ := A₀ pgcd: B₀. m := C₀ degreeIn: k - 1.
	"Normalize C₀ so that the leading coefficient is g₀:"
	C₀ := C₀ * (C₀ leadingCoefficient inverse * g₀).
	"Test for unlucky homomorphisms:"
	m < n
		ifTrue: [q := R one. H := R one. n := m]
		ifFalse: [m >= "or =?" n ifTrue:
			[| v |
			"Interpolate:"
			v := (q value: α in: k) inverse * (C₀ "g₀ or C₀?" - (H value: α in: k)).
			H := H + (v * q "* C₀?").
			q := q * ((R x: k) - α).
			"Test for completion:"
			(S !! H) leadingCoefficient = g ifTrue:
				[C := H primitivePart.
				(C | A and: [C | B])
					ifTrue: [^ C * c]
					ifFalse: [m = 0 ifTrue: [^ c]]]]]] repeat! !

!Polynomial methodsFor: 'gcd' stamp: 'len 6/10/2023 18:12:55'!
ugcd: aPolynomial
	"Univariate GCD."
	| f₁ f₂ c₁ c₂ r |
	self isZero ifTrue: [^ aPolynomial normalized].
	aPolynomial isZero ifTrue: [^ self normalized].
	(self isConstant or: [aPolynomial isConstant]) ifTrue:
		[^ self scalars isField ifTrue: [self one] ifFalse: [self parent constant: (self content gcd: aPolynomial content)]].
	self scalars isLocalization ifTrue: [^ (self parent !! (self numerator gcd: aPolynomial numerator)) normalized].
	"Generic Euclidean algorithm:"
	self scalars isField ifTrue: [^ super gcd: aPolynomial].
	"Over a general ring we use the primitive PRS algorithm [Coh96, Algorithm 3.2.10]:"
	self scalars isUFD ifFalse: [^ self error: 'the coefficients ring is not a UFD'].
	c₁ := self content.
	c₂ := aPolynomial content.
	f₁ := self ÷ c₁.
	f₂ := aPolynomial ÷ c₂.
	[f₂ isZero] whileFalse: [r := (f₁ pseudoRem: f₂) primitivePart. f₁ := f₂. f₂ := r].
	f₁ isConstant ifTrue: [^ self parent constant: (c₁ gcd: c₂)].
	^ f₁ normalized * (c₁ gcd: c₂)

"alternative for the last part:
	""Over a general UFD we use the subresultant GCD algorithm [Coh96, Algorithm 3.3.1]:""
	self scalars isUFD ifFalse: [^ self error: 'the coefficients ring is not a UFD'].
	aPolynomial degree > self degree ifTrue: [^ aPolynomial gcd2: self].
	u _ self content.
	v _ aPolynomial content.
	a _ self / u.
	b _ aPolynomial / v.
	h _ g _ self scalars one.
	[δ _ a degree - b degree.
	r _ a pseudoRem: b.
	r isConstant] whileFalse:
		[a _ b. b _ r / (g*(h^δ)). g _ a leadingCoefficient. h _ g^δ / (h^(δ - 1))].
	r isZero ifFalse: [b _ self one].
	^ b primitivePart	* (u gcd: v) 
"! !

!Polynomial methodsFor: 'gcd' stamp: 'len 6/9/2023 09:57:22'!
xgcd: aPolynomial
	"Answer the GCD of the receiver and the argument and the Bézout coefficients.
	If the receiver is 'a', the argument is 'b' and their GCD is 'g', answer an array {g. s. t} where as + bt = g.
	This is the extended Euclidean algorithm."
	| a b zero one s₁ t₁ s t r₁ r u |
	a := self.
	b := aPolynomial.
	zero := a zero. one := a one.
	s₁ := zero. s := one.
	t₁ := one. t := zero.
	self scalars isField
		ifTrue:
			[r₁ := a normalized.
			r := b normalized.
			[r₁ isZero]
				whileFalse:
					[ | q temp |
					q := r // r₁.
					temp := r₁. r₁ := r - (q * r₁). r := temp.
					temp := s₁. s₁ := s - (q * s₁). s := temp.
					temp := t₁. t₁ := t - (q * t₁). t := temp].
			s := s * b normalization. t := t * a normalization.
			u := r normalization.
			s := s * u. t := t * u. r := r * u]
		ifFalse:
			[r₁ := a primitivePart normalized.
			r := b primitivePart normalized.
			[r₁ isZero]
				whileFalse:
					[| division q m temp |
					division := r pseudoDivisionBy: r₁.
					q := division quotient.
					m := r₁ leadingCoefficient ^ division delta.
					temp := r₁. r₁ := r*m - (q * r₁). r := temp.
					temp := s₁. s₁ := s*m - (q * s₁). s := temp.
					temp := t₁. t₁ := t*m - (q * t₁). t := temp].
			s := s * b normalization. t := t * a normalization.
			u := (a content gcd: b content) * r normalization.
			s := s * u. t := t * u. r := r * u].
	^ {r. t. s}! !

!Polynomial methodsFor: 'operations' stamp: 'len 11/7/2023 21:21:59'!
% anInteger
	self assert: self scalars = ℤ.
	^ self apply: (ℤ / anInteger) projection! !

!Polynomial methodsFor: 'operations' stamp: 'len 7/1/2022 05:52:32'!
* anElement
	(anElement isInteger or: [self scalars includes: anElement])
		ifTrue: [^ self class coefficients: coefficients * anElement parent: parent].
	(parent includes: anElement)
		ifTrue: [^ self multipliedBy: anElement].
	(anElement isKindOf: Monomial)
		ifTrue: [^ self multipliedByMonomial: anElement].
	^ self adapt: anElement andSend: #*! !

!Polynomial methodsFor: 'operations' stamp: 'len 4/27/2022 19:25:39'!
+ anElement
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #+].
	^ self class coefficients: coefficients + anElement coefficients parent: parent! !

!Polynomial methodsFor: 'operations' stamp: 'len 4/27/2022 19:25:45'!
- anElement
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #-].
	^ self class coefficients: coefficients - anElement coefficients parent: parent! !

!Polynomial methodsFor: 'operations' stamp: 'len 7/6/2023 00:55:28'!
/ anElement
	"Answer x such that xa = b, where b is the receiver and a is the argument.
	This is the right division of b by a, written b / a."
	self isZero ifTrue: [^ self].
	(anElement isKindOf: Monomial) ifTrue: [^ self dividedByMonomial: anElement].
	(self scalars includes: anElement) ifTrue: [^ self dividedByScalar: anElement].
	^ super / anElement! !

!Polynomial methodsFor: 'operations' stamp: 'len 1/5/2022 12:45:48'!
// anObject
	"Answer the quotient of the division of the receiver by the argument."
	(anObject isKindOf: Monomial)
		ifTrue: [^ self dividedByMonomial: anObject].
	(self scalars includes: anObject)
		ifTrue: [^ self apply: [:each| each // anObject]].
	anObject isCollection ifTrue: [^ (self divisionBy: anObject) quotients].
	^ (self divisionBy: anObject) quotient! !

!Polynomial methodsFor: 'operations' stamp: 'len 7/28/2021 12:57:14'!
\\ anObject
	"Answer the remainder of the division of the receiver by the argument."
	(self scalars includes: anObject) ifTrue: [^ self apply: [:each| each \\ anObject]].
	^ (self divisionBy: anObject) remainderAlone! !

!Polynomial methodsFor: 'operations' stamp: 'len 6/5/2023 19:33:05'!
^ anInteger
	self isMonomial ifTrue: [^ self parent coefficient: self leadingCoefficient ^ anInteger monomial: self monomials first ^ anInteger].
	^ super ^ anInteger! !

!Polynomial methodsFor: 'operations' stamp: 'len 6/6/2023 00:09:00'!
÷ anElement
	(self scalars isIntegralDomain and: [self parent includes: anElement]) ifTrue: [^ self // anElement].
	^ self / anElement! !

!Polynomial methodsFor: 'operations' stamp: 'len 5/31/2022 21:11:30'!
annihilator
	"Answer a generator of the ideal of all elements that multiplied by the receiver are zero.
	McCoy's theorem: a polynomial f in R[X] is a zero divisor iff there is nonzero r in R with fr = 0 (see [McC42])."
	| r |
	self parent scalars isPIR ifFalse: [^ self annihilatorIdeal generator].
	r _ self parent scalars one.
	self coefficients do: [:each| r _ r lcm: each annihilator].
	^ self parent constant: r! !

!Polynomial methodsFor: 'operations' stamp: 'len 10/5/2022 18:44:14'!
annihilatorIdeal
	"Answer the ideal of all elements that multiplied by the receiver are zero.
	McCoy's theorem: a polynomial f in R[X] is a zero divisor iff there is nonzero r in R with fr = 0 (see [McC42])."
	| answer |
	answer _ self parent scalars asIdeal.
	self coefficients do: [:each| each isZero ifFalse: [(answer _ answer ∩ each annihilatorIdeal) isTrivial ifTrue: [^ answer]]].
	^ answer apply: self parent scalars → self parent! !

!Polynomial methodsFor: 'operations' stamp: 'len 5/5/2024 07:19:39'!
apply: aMap
	"Answer a new polynomial with coefficients obtainted by applying aMap to the coefficients of the receiver.
	If aMap is a block we assume the parent doesn't change, i.e. the block must evaluate to values within the scalars ring of the receiver."

	^ self class coefficients: (coefficients apply: aMap) parent: (aMap isBlock ifTrue: [parent] ifFalse: [parent over: aMap codomain])! !

!Polynomial methodsFor: 'operations' stamp: 'len 12/24/2023 09:13:35'!
colift: aPolynomial
	"Answer x such that xa = b, where a is the receiver and b is the argument. Answer nil if there's no solution.
	This is the right division of b by a, written b / a."
	self isConstant ifTrue: [^ aPolynomial dividedByScalar: self independentCoefficient].
	self isUnit ifTrue: [^ aPolynomial * self inverse].
	^ (self asSingletonMatrix colift: aPolynomial asSingletonMatrix) ifNotNil: [:aMatrix| aMatrix asScalar]! !

!Polynomial methodsFor: 'operations' stamp: 'len 6/28/2023 17:01:52'!
dehomogenized
	"Answer the dehomogenization of the receiver removing the an indeterminate.
	Answers a polynomial in a polynomial ring with one fewer indeterminate.
	This is the inverse of the message >>#homogenized."
	^ self parent dehomogenization !! self! !

!Polynomial methodsFor: 'operations' stamp: 'len 4/28/2022 06:43:11'!
dehomogenizedIn: anIndeterminate
	"Answer the dehomogenization of the receiver in the given indeterminate."
	^ self applyToMonomials: [:each| each dehomogenizedIn: anIndeterminate]! !

!Polynomial methodsFor: 'operations' stamp: 'len 1/11/2017 14:26:35'!
derivative: n in: anIndeterminate
	"Answer the n-th derivative in the given indeterminate."
	| answer |
	n < 0 ifTrue: [^ self error: 'the order of the derivative should be positive'].
	answer _ self.
	n timesRepeat: [answer _ answer derivativeIn: anIndeterminate].
	^ answer! !

!Polynomial methodsFor: 'operations' stamp: 'len 6/27/2023 00:20:08'!
derivativeIn: anIndeterminate
	| answer |
	answer := parent zero.
	self associationsDo: [:each| | degree |
		degree := each key at: anIndeterminate.
		degree > 0 ifTrue:
			[answer := answer + (parent coefficient: each value * degree monomial: (each key parent exponents: (each key exponents copy at: anIndeterminate put: degree - 1; yourself)))]].
	^ answer! !

!Polynomial methodsFor: 'operations' stamp: 'len 10/16/2022 10:39:27'!
gauge
	"Answer the value of the Euclidean function at the receiver."
	^ self isZero ifTrue: [0] ifFalse: [self leadingMonomial degree]! !

!Polynomial methodsFor: 'operations' stamp: 'len 1/23/2017 11:41:39'!
gradient
	^ self parent indeterminates collect: [:each| self derivativeIn: each]! !

!Polynomial methodsFor: 'operations' stamp: 'len 12/1/2023 18:24:58'!
height
	^ self coefficients inject: 1 into: [:x :each| x max: each height]! !

!Polynomial methodsFor: 'operations' stamp: 'len 5/6/2023 18:23:35'!
hessian
	"Answer the Hessian matrix of the receiver."
	| R n derivatives |
	self flag: #fixme. "optimize (the matrix is symmetrical)"
	R _ self parent.
	n _ self parent rank.
	derivatives _ (1 to: n) collect: [:i| self derivativeIn: i].
	^ (R ^ n) endomorphisms fill: [:i :j| (derivatives at: i) derivativeIn: j]! !

!Polynomial methodsFor: 'operations' stamp: 'len 6/28/2023 17:01:02'!
homogenized
	"Answer the homogenization of the receiver introducing a new indeterminate.
	Answers an element in a new polynomial ring with one additional indeterminate."
	^ self parent homogenization !! self! !

!Polynomial methodsFor: 'operations' stamp: 'len 6/27/2023 23:09:14'!
homogenizedIn: anIndeterminate
	"Answer the homogenization of the receiver in the given indeterminate.
	Assume the indeterminate exists (not a new indeterminate)."
	^ self homogenizedIn: anIndeterminate to: self degree! !

!Polynomial methodsFor: 'operations' stamp: 'len 6/27/2023 23:12:07'!
homogenizedIn: anIndeterminate to: degree
	"Answer the homogenization of the receiver in the given indeterminate.
	Assume the indeterminate exists (not a new indeterminate)."
	^ self applyToMonomials: [:each| each homogenizedIn: anIndeterminate to: degree]! !

!Polynomial methodsFor: 'operations' stamp: 'len 7/6/2023 00:44:28'!
inverse
	| answer g g₁ u |
	self isConstant ifTrue: [^ self parent constant: self independentCoefficient inverse].
	self isUnit ifFalse: [^ DivisibilityError new signalReceiver: self one selector: #/ argument: self].
	"Naive but general power series inversion algorithm:"
	u := self independentCoefficient inverse.
	answer := g := self one.
	g₁ := g - (self * u).
	[g isZero] whileFalse: [answer := answer + (g := g * g₁)].
	^ answer * u! !

!Polynomial methodsFor: 'operations' stamp: 'len 5/2/2018 16:21:10'!
length
	self isZero ifTrue: [^ 0].
	^ self coefficients sum: [:each| each height]! !

!Polynomial methodsFor: 'operations' stamp: 'len 4/27/2022 19:35:22'!
negated
	^ self class coefficients: coefficients negated parent: parent! !

!Polynomial methodsFor: 'operations' stamp: 'len 3/2/2016 23:55'!
norm1
	"Answer the 1-norm (or taxicab norm, or Manhattan norm) of the receiver."
	^ self coefficients inject: self scalars zero into: [:x :each| x + each abs]! !

!Polynomial methodsFor: 'operations' stamp: 'len 3/2/2016 23:49'!
norm2
	"Answer the squared norm of the receiver."
	^ self coefficients inject: self scalars zero into: [:x :each| x + each squared]! !

!Polynomial methodsFor: 'operations' stamp: 'len 3/2/2016 23:54'!
normInfinite
	"Answer the infinite norm of the receiver.
	(In finite-dimensional vector spaces it's the same as the maximum norm)."
	^ self normMax! !

!Polynomial methodsFor: 'operations' stamp: 'len 3/2/2016 23:52'!
normMax
	"Answer the maximum norm of the receiver."
	^ self coefficients inject: self scalars zero into: [:x :each| x max: each abs]! !

!Polynomial methodsFor: 'operations' stamp: 'len 12/10/2021 19:18:40'!
normalization
	"Answer a unit u such that 'self * u' is a unique choice of associate. See >>normalized.
	NOTE: when the coefficients ring is not an integral domain this choice of unit might not be unique."
	self isZero ifTrue: [^ parent one].
	^ parent constant: self leadingCoefficient normalization! !

!Polynomial methodsFor: 'operations' stamp: 'len 4/28/2022 06:43:26'!
permutedBy: aPermutation
	"Permute the variables of the receiver. The argument can be an Array (a permutation in 'image format'). For example given a polynomial in x,z,y, #(1 2 3) doesn't change anything, and #(2 1 3) exchanges variables x and y."
	^ self applyToMonomials: [:each| each permutedBy: aPermutation]! !

!Polynomial methodsFor: 'operations' stamp: 'len 4/5/2024 18:57:32'!
pseudoDivisionBy: aPolynomial
	"Answer a pseudo-division algorithm to divide the receiver by aPolynomial."
	self isUnivariate ifFalse: [^ self error: 'polynomial is not univariate'].
"	self scalars isUFD ifFalse: [^ DomainError signal: 'polynomial not over a UFD']."
	^ PseudoDivision divide: self by: aPolynomial! !

!Polynomial methodsFor: 'operations' stamp: 'len 3/6/2021 15:22:47'!
pseudoDivisionBy: aPolynomial in: anIndeterminate
	| U |
	U _ self parent asUnivariateIn: anIndeterminate.
	^ U !! self pseudoDivisionBy: U !! aPolynomial ! !

!Polynomial methodsFor: 'operations' stamp: 'len 4/24/2018 19:40:35'!
pseudoQuo: aPolynomial
	"Answer the quotient of the pseudo-division of the receiver by the argument."
	self isUnivariate ifFalse: [^ (self pseudoDivisionBy: aPolynomial in: self leadingIndeterminate) quotient asMultivariate].
	^ (self pseudoDivisionBy: aPolynomial) quotient! !

!Polynomial methodsFor: 'operations' stamp: 'len 3/6/2021 15:17:53'!
pseudoRem2: aPolynomial
	"Answer the remainder of the pseudo-division of the receiver by the argument."
"	self isUnivariate ifFalse: [^ (self pseudoDivisionBy: aPolynomial in: self leadingIndeterminate) remainder asMultivariate]."
	^ (self pseudoDivisionBy: aPolynomial) remainder! !

!Polynomial methodsFor: 'operations' stamp: 'len 10/28/2023 09:28:09'!
pseudoRem3: aPolynomial
	"Answer the remainder of the pseudo-division of the receiver by the argument."
	| n d b w k |
"	self isUnivariate ifFalse: [^ (self pseudoDivisionBy: aPolynomial in: self leadingIndeterminate) remainder asMultivariate]."
	"^ (self pseudoDivisionBy: aPolynomial) remainder"
	self degree < (n := aPolynomial degree) ifTrue: [^ self].
	w := self.
	d := self degree - n + 1.
	b := aPolynomial leadingCoefficient.
	[k := w degree - n.
	w := b * w - ((self parent coefficient: w leadingCoefficient xTo: k)*aPolynomial).
	w isZero ifTrue: [^ w].
	w degree < n ifTrue: [^ w * (b ^ k)].
	k > d ifTrue: [w := w * (b ^ (k - d))]] repeat! !

!Polynomial methodsFor: 'operations' stamp: 'len 7/15/2021 12:38:27'!
pseudoRem4: aPolynomial
	"Answer the remainder of the pseudo-division of the receiver by the argument."
	| n b w e k |
"	self isUnivariate ifFalse: [^ (self pseudoDivisionBy: aPolynomial in: self leadingIndeterminate) remainder asMultivariate]."
	"^ (self pseudoDivisionBy: aPolynomial) remainder"
	self degree < (n _ aPolynomial degree) ifTrue: [^ self].
	w _ self.
	e _ self degree - n + 1.
	b _ aPolynomial leadingCoefficient.
	[k _ w degree - n.
	w _ w * b - (aPolynomial << k * w leadingCoefficient).
	w isZero ifTrue: [^ w].
	w degree < n ifTrue: [^ w * (b ^ k)].
	k > e ifTrue: [w _ w * (b ^ (k - e))]] repeat! !

!Polynomial methodsFor: 'operations' stamp: 'len 4/24/2018 19:40:49'!
pseudoRem: aPolynomial
	"Answer the remainder of the pseudo-division of the receiver by the argument."
	self isUnivariate ifFalse: [^ (self pseudoDivisionBy: aPolynomial in: self leadingIndeterminate) remainder asMultivariate].
	^ (self pseudoDivisionBy: aPolynomial) remainder! !

!Polynomial methodsFor: 'operations' stamp: 'len 10/24/2023 16:11:48'!
radical
	"Answer the maximal squarefree divisor of the receiver.
	This is often called 'squarefree part', but we call it 'radical' to be consistent with integers and ideals."
	| g |
	self parent scalars characteristic = 0 ifFalse: [^ super radical].
	g := self.
	self indeterminates do: [:each| g := g gcd: (self derivativeIn: each)].
	^ self / g! !

!Polynomial methodsFor: 'operations' stamp: 'len 12/9/2022 08:22:24'!
squared
	^ self class coefficients: coefficients autoconvolution parent: parent! !

!Polynomial methodsFor: 'operations' stamp: 'len 4/28/2022 06:43:34'!
substitute: aBlock
	"Answer the receiver after substituting indeterminates by aBlock."
	^ self applyToMonomials: [:each| each substitute: aBlock]! !

!Polynomial methodsFor: 'operations' stamp: 'len 5/8/2020 18:22:10'!
valuation
	"If the receiver is an element of a valuation ring or a Euclidean ring, answer its valuation or Euclidean function."
	self isZero ifTrue: [^ Infinity negative].
	^ self leadingMonomial degree! !

!Polynomial methodsFor: 'operations' stamp: 'len 6/21/2023 22:28:42'!
value: anObject
	"Answer the value of the receiver at the argument. For multivariate polynomials, a Tuple or Array is expected."
	| answer |
	anObject size = parent rank
		ifFalse: [self error: 'the arity of the argument should match the number of indeterminates'].
	answer := (anObject at: 1) zero.
	self associationsDo: [:each|
		| monomial |
		monomial := each key.
		answer := (monomial value: anObject) * each value + answer].
	^ answer! !

!Polynomial methodsFor: 'operations' stamp: 'len 6/10/2023 11:37:43'!
value: anElement in: anIndeterminate
	"Answer the value of the receiver when substituting the given indeterminate by anElement."
	self flag: #fixme. "optimize this"
	self assert: (self parent scalars includes: anElement).
	^ self value: ((1 to: self parent rank) collect: [:i| i = anIndeterminate ifTrue: [self parent constant: anElement] ifFalse: [self parent x: i]])! !

!Polynomial methodsFor: 'operations' stamp: 'len 11/1/2016 18:40'!
valueWithArguments: anArray
	^ self value: anArray! !

!Polynomial methodsFor: 'operations' stamp: 'len 8/14/2022 10:57:46'!
∘ anObject
	"Answer the composition of the receiver with the argument."
	anObject isBlock ifTrue: [^ [:x| self value: (anObject value: x)]].
	^ self value: anObject! !

!Polynomial methodsFor: 'printing' stamp: 'len 12/1/2023 16:48:44'!
printCoefficient: coefficient monomial: m on: aStream
	| c |
	c := coefficient.
	(c isOne not or: [m degree = 0]) ifTrue:
		[c printText first = $-
			ifTrue: [aStream nextPut: $-. c := c negated].
		(m degree = 0 or: [c printText asString allSatisfy: [:each| each isAlphaNumeric or: ['{}()/' includes: each]]])
			ifTrue: [aStream print: c]
			ifFalse: [aStream nextPut: $(; print: c; nextPut: $)]].
	m degree = 0 ifFalse: [aStream print: m]! !

!Polynomial methodsFor: 'printing' stamp: 'len 12/1/2023 16:48:53'!
printCoefficient: coefficient monomial: m shifted: anArray on: aStream
	| c degree |
	c := coefficient.
	degree := (m exponents + anArray) sum.
	(c isOne not or: [degree = 0]) ifTrue:
		[c printText first = $-
			ifTrue: [aStream nextPut: $-. c := c negated].
		(m degree = 0 or: [c printText asString allSatisfy: [:each| each isAlphaNumeric or: ['{}()/' includes: each]]])
			ifTrue: [aStream print: c]
			ifFalse: [aStream nextPut: $(; print: c; nextPut: $)]].
	degree = 0 ifFalse: [m printOn: aStream shifted: anArray]! !

!Polynomial methodsFor: 'printing' stamp: 'len 12/3/2023 13:56:26'!
printOn: aStream
	| monomials leadingMonomial c |
	(self scalars isKindOf: ModularIntegerRing)
		ifTrue: [aStream print: self lift. ^ self].
	self isConstant ifTrue: [aStream print: self leadingCoefficient. ^ self].
	monomials := self monomials sorted reversed.
	c := self at: (leadingMonomial := monomials first).
	c printText first = $-
		ifTrue: [c := c negated. aStream nextPut: $-].
	self printCoefficient: c monomial: leadingMonomial on: aStream.
	monomials allButFirstDo: [:m|
		c := self at: m.
		c printText first = $-
			ifTrue: [aStream nextPutAll: ' - '. c := c negated]
			ifFalse: [aStream nextPutAll: ' + '].
		self printCoefficient: c monomial: m on: aStream]! !

!Polynomial methodsFor: 'printing' stamp: 'len 12/3/2023 13:56:47'!
printOn: aStream shifted: anArray
	| monomials leadingMonomial c |
	(self scalars isKindOf: ModularIntegerRing)
		ifTrue: [self lift printOn: aStream shifted: anArray. ^ self].
	monomials := self monomials sorted reversed.
	c := self at: (leadingMonomial := monomials first).
	c printText first = $-
		ifTrue: [c := c negated. aStream nextPut: $-].
	self printCoefficient: c monomial: leadingMonomial shifted: anArray on: aStream.
	monomials allButFirstDo: [:m|
		c := self at: m.
		c printText first = $-
			ifTrue: [aStream nextPutAll: ' - '. c := c negated]
			ifFalse: [aStream nextPutAll: ' + '].
		self printCoefficient: c monomial: m shifted: anArray on: aStream]! !

!Polynomial methodsFor: 'reduction' stamp: 'len 5/22/2022 12:36:46'!
g: aPolynomial
	"Answer the GCD-tuple of the receiver with the argument."
	| m xgcd |
	m _ self leadingMonomial lcm: aPolynomial leadingMonomial.
	xgcd _ self leadingCoefficient xgcd: aPolynomial leadingCoefficient.
	^ self * (m / self leadingMonomial) * (xgcd at: 2) + (aPolynomial * (m / aPolynomial leadingMonomial) * (xgcd at: 3))! !

!Polynomial methodsFor: 'reduction' stamp: 'len 1/13/2022 09:08:39'!
reductionBy: anArray
	"If the ordering is global answer a top-reduction of the receiver with respect to the argument (without doing tail reduction). Otherwise answer the Mora normal form."
	^ self ordering isGlobal
		ifTrue: [self reductionGlobalBy: anArray]
		ifFalse: [self reductionMoraBy: anArray]! !

!Polynomial methodsFor: 'reduction' stamp: 'len 1/13/2022 10:05:22'!
reductionFullBy: anArray
	"Answer the tail-reduced normal form of the receiver with respect to the argument (doing full tail reduction).
	For an ordering that is not global, answer the Mora normal form."
	| g h |
	self ordering isGlobal ifFalse: [^ self reductionMoraBy: anArray].
	g _ self.
	h _ g zero.
	[g isZero]
		whileFalse:
			[g _ g reductionGlobalBy: anArray.
			g isZero ifFalse: [h _ h + g leadingTerm. g _ g tail]].
	^ h! !

!Polynomial methodsFor: 'reduction' stamp: 'len 6/17/2023 14:32:54'!
reductionGlobalBy: anArray
	"Answer a top-reduction of the receiver with respect to the argument (without doing tail reduction)."
	| h |
	h := self.
	[h isZero]
		whileFalse:
			[| m c g q |
			m := h leadingMonomial.
			c := h leadingCoefficient.
			g := anArray detect: [:one| one leadingMonomial | m and: [(q := c // one leadingCoefficient) isZero not]] ifNone: [^ h].
			h := h + (g * (m / g leadingMonomial) * q negated)].
	^ h! !

!Polynomial methodsFor: 'reduction' stamp: 'len 6/7/2022 12:30:37'!
reductionMoraBy: anArray
	"Answer Mora's normal form of the receiver with respect to the argument."
	| h L m c g ecartg |
	h _ self.
	L _ OrderedCollection withAll: anArray.
	[h isZero ifTrue: [^ h].
	m _ h leadingMonomial.
	c _ h leadingCoefficient.
	g _ ecartg _ nil.
	L do: [:each|
		| ecart |
		(each leadingMonomial | m and: [each leadingCoefficient | c and: [ecart _ each ecart. g isNil or: [ecart < ecartg]]])
			ifTrue: [g _ each. ecartg _ ecart]].
	g isNil ifTrue: [^ h].
	ecartg > h ecart ifTrue: [L add: h].
	h _ h + (g * (m / g leadingMonomial) * (c negated / g leadingCoefficient))] repeat! !

!Polynomial methodsFor: 'reduction' stamp: 'len 5/22/2022 12:04:20'!
s: aPolynomial
	"Answer the S-polynomial of the receiver with the argument."
	| m c |
	m _ self leadingMonomial lcm: aPolynomial leadingMonomial.
	c _ self leadingCoefficient lcm: aPolynomial leadingCoefficient.
	^ self * (m / self leadingMonomial) * (c / self leadingCoefficient) + (aPolynomial * (m / aPolynomial leadingMonomial) * (c negated / aPolynomial leadingCoefficient))! !

!Polynomial methodsFor: 'remainder sequences' stamp: 'len 3/9/2016 00:07'!
eprs: aPolynomial
	"Answer the (Pseudo) Euclidean Polynomial Remainder Sequence of the receiver with the argument."
	| answer f0 f1 r |
	answer _ OrderedCollection new.
	f1 _ self.
	answer add: f1.
	r _ aPolynomial.
	[r isZero]
		whileFalse:
			[answer add: r.
			f0 _ f1.
			f1 _ r.
			r _ f0 pseudoRem: f1].
	^ answer! !

!Polynomial methodsFor: 'remainder sequences' stamp: 'len 7/17/2019 10:49:49'!
pprs: aPolynomial
	"Answer the Primitive Polynomial Remainder Sequence of the receiver with the argument."
	| answer f0 f1 r |
	answer _ OrderedCollection new.
	f1 _ self.
	answer add: f1.
	r _ aPolynomial.
	[r isZero]
		whileFalse:
			[answer add: r.
			f0 _ f1.
			f1 _ r.
			r _ (f0 pseudoRem: f1) primitivePart].
	^ answer! !

!Polynomial methodsFor: 'remainder sequences' stamp: 'len 4/5/2024 18:57:43'!
prs: aPolynomial
	"Answer the Polynomial Remainder Sequence of the receiver with the argument."
	| answer f0 f1 r |
	self parent scalars isField ifFalse: [^ self error: 'scalars are not a field'].
	answer := OrderedCollection new.
	f1 := self.
	answer add: f1.
	r := aPolynomial.
	[r isZero]
		whileFalse:
			[answer add: r.
			f0 := f1.
			f1 := r.
			r := f0 \\ f1].
	^ answer! !

!Polynomial methodsFor: 'remainder sequences' stamp: 'len 3/9/2016 06:32'!
sprs2: aPolynomial
	"Answer the Subresultant Polynomial Remainder Sequence of the receiver with the argument."
	| delta b phi beta f1 f2 r answer |
	self assert: self scalars isUFD.
	self assert: self degree >= aPolynomial degree.
	delta _ self degree - aPolynomial degree + 1.
	b _ aPolynomial leadingCoefficient.
	phi _ b ^ (delta - 1).
	beta _ (-1) ^ delta.
	answer _ OrderedCollection new.
	answer add: self; add: aPolynomial.
	f1 _ aPolynomial. f2 _ self. "f1 is F_{i-1}, f2 is F_{i-2}, r is F_i"
	[r _ (f2 pseudoRem: f1) / beta.
	r isZero ifTrue: [^ answer].
	answer add: r. f2 _ f1. f1 _ r.
	delta _ f1 degree - r degree + 1.
	beta _ (-1) ^ delta * (phi ^ (delta - 1)) * b.
	b _ r leadingCoefficient.
	phi _ phi * ((b / phi) ^ (delta - 1))] repeat! !

!Polynomial methodsFor: 'remainder sequences' stamp: 'len 1/9/2022 08:19:48'!
sprs: aPolynomial
	"Answer the Subresultant Polynomial Remainder Sequence of the receiver with the argument."
	| delta phi beta f1 f2 r answer |
	self assert: self scalars isUFD.
	self assert: self degree >= aPolynomial degree.
	f2 _ self. f1 _ aPolynomial."f1 is F_{i-1}, f2 is F_{i-2}, r is F_i"
	phi _ self scalars one.
	answer _ OrderedCollection new.
	answer add: f2.
	[f1 isZero]
		whileFalse:
			[answer add: f1.
			delta _ f2 degree - f1 degree + 1.
			beta _ (-1) ^ delta * (phi ^ (delta - 1)) * f2 leadingCoefficient.
			phi _ phi * ((f1 leadingCoefficient / phi) ^ (delta - 1)).
			r _ (f2 pseudoRem: f1) / beta.
			f2 _ f1. f1 _ r].
	^ answer! !

!Polynomial methodsFor: 'testing' stamp: 'len 6/16/2023 17:31:20'!
| aPolynomial
	"Answer true if the receiver divides the argument."
	aPolynomial isZero ifTrue: [^ true].
	self isZero ifTrue: [^ false].
	(self independentCoefficient isZero and: [aPolynomial independentCoefficient isZero not]) ifTrue: [^ false].
	self scalars isField ifTrue: [^ (aPolynomial \\ self) isZero].
	self independentCoefficient | aPolynomial independentCoefficient ifFalse: [^ false].
	self coefficients sum | aPolynomial coefficients sum ifFalse: [^ false].
	"self content | aPolynomial content ifFalse: [^ false]."
	self isUnit ifTrue: [^ true].
	(self scalars isIntegralDomain and: [self leadingCoefficient isUnit]) ifTrue: [^ (aPolynomial pseudoRem: self) isZero].
	^ (self lift: aPolynomial) notNil! !

!Polynomial methodsFor: 'testing' stamp: 'len 12/30/2016 20:10:56'!
isAffineLinear
	^ self degree < 2! !

!Polynomial methodsFor: 'testing' stamp: 'len 10/5/2022 18:44:20'!
isBasicIrreducible
	self scalars isLocal ifFalse: [self error: 'not over a local ring'].
	^ (self apply: self scalars → self scalars residueField) isIrreducible! !

!Polynomial methodsFor: 'testing' stamp: 'len 2/17/2017 08:07:02'!
isBinomial
	^ self monomials size = 2! !

!Polynomial methodsFor: 'testing' stamp: 'len 4/28/2022 11:54:41'!
isConstant
	self monomialsDo: [:each| each isIdentity ifFalse: [^ false]].
	^ true! !

!Polynomial methodsFor: 'testing' stamp: 'len 3/1/2016 17:33'!
isHomogeneous
	| n |
	n _ self degree.
	self monomials do: [ :each | each degree = n ifFalse: [^ false]].
	^ true! !

!Polynomial methodsFor: 'testing' stamp: 'len 5/10/2020 12:34:09'!
isIdempotent
	^ self isConstant and: [self independentCoefficient isIdempotent]! !

!Polynomial methodsFor: 'testing' stamp: 'len 8/5/2021 08:40:43'!
isIrreducible
	self isConstant ifTrue: [^ false]. "constant polynomials are not reducible nor irreducible"
	self degree = 1 ifTrue: [^ true].
	^ self factorization size = 1! !

!Polynomial methodsFor: 'testing' stamp: 'len 12/30/2016 20:11:59'!
isLinear
	^ self degree < 2 and: [self independentCoefficient isZero]! !

!Polynomial methodsFor: 'testing' stamp: 'len 1/9/2022 09:58:58'!
isMonic
	^ self leadingCoefficient isOne! !

!Polynomial methodsFor: 'testing' stamp: 'len 2/17/2017 08:07:17'!
isMonomial
	^ self monomials size = 1! !

!Polynomial methodsFor: 'testing' stamp: 'len 7/30/2019 05:28:21'!
isNilpotent
	"Answer true if self^n = 0 for some integer n >= 1."
	^ self coefficients allSatisfy: [:each| each isNilpotent]! !

!Polynomial methodsFor: 'testing' stamp: 'len 5/11/2022 09:10:43'!
isPrimitive
	"A polynomial is primitive if its content is a unit.
	(More generally, a polynomial is primitive if the coefficients generate the unit ideal <1>.)"
	^ self content isUnit! !

!Polynomial methodsFor: 'testing' stamp: 'len 11/30/2023 14:19:21'!
isSeparable
	"A polynomial over a field K is separable if its roots in an algebraic closure of K are distinct."
	self scalars isField ifTrue: [^ (self gcd: self derivative) isConstant].
	"Over a local ring, separable is equivalent to basic irreducible, which in turn is equivalent to irreducible in the residue field:"
	self scalars isLocal ifTrue: [^ self isBasicIrreducible].
	^ self notYetImplemented! !

!Polynomial methodsFor: 'testing' stamp: 'len 5/1/2024 12:28:02'!
isSquarefree
	self isMonomial ifTrue: [^ self monomials any isSquarefree].
	self isZero ifTrue: [^ false].
	self scalars characteristic = 0 ifTrue: [^ (self gcd: self derivative) isConstant].
	self squarefreeFactorizationDo: [:f :r| r > 1 ifTrue: [^ false]].
	^ true! !

!Polynomial methodsFor: 'testing' stamp: 'len 1/23/2017 11:42:42'!
isUnivariate
	^ self parent isUnivariate! !

!Polynomial methodsFor: 'testing' stamp: 'len 1/23/2017 11:42:50'!
isUnivariateIn: anInteger
	"Answer true if the receiver is an univariate polynomial in the anInteger-th indeterminate."
	(anInteger = 1 and: [self parent isUnivariate]) ifTrue: [^ true].
	self monomialsDo: [:each| (each isUnivariateIn: anInteger) ifFalse: [^ false]].
	^ true! !

!Polynomial methodsFor: 'testing' stamp: 'len 12/24/2023 08:34:06'!
isZero
	^ coefficients isEmpty! !

!Polynomial methodsFor: 'testing' stamp: 'len 5/23/2022 19:25:00'!
isZeroDivisor
	"Answer true if there exists a nonzero element that multiplied by the receiver is zero."
	parent isIntegralDomain ifTrue: [^ self isZero].
	"If the receiver has only 1 term, we can just check if the coefficient is a zero divisor:"
	self support isSingleton ifTrue: [^ self leadingCoefficient isZeroDivisor].
	^ self annihilatorIdeal isTrivial not! !

!Polynomial methodsFor: 'private' stamp: 'len 4/27/2022 16:52:11'!
coefficients: aCollection parent: aPolynomialRing
	coefficients _ aCollection.
	parent _ aPolynomialRing! !

!Polynomial methodsFor: 'private' stamp: 'len 4/28/2022 06:09:02'!
dividedByScalar: anElement
	^ self class coefficients: coefficients / anElement parent: parent! !

!Polynomial methodsFor: 'private' stamp: 'len 5/27/2022 19:10:22'!
exactlyDividedBy: anElement
	^ (self divisionBy: anElement) exactQuotient! !

!Polynomial methodsFor: 'private' stamp: 'len 1/13/2024 10:36:15'!
multipliedBy: aPolynomial
	aPolynomial isConstant ifTrue: [^ self class coefficients: coefficients * aPolynomial leadingCoefficient parent: parent].
	^ self class coefficients: (coefficients convolution: aPolynomial coefficients) parent: parent! !

!Polynomial methodsFor: 'private' stamp: 'len 8/11/2019 12:13:56'!
multipliedBy: aPolynomial truncatedTo: anInteger
	^ (self multipliedBy: aPolynomial) truncatedTo: anInteger "optimize this"! !

!Polynomial methodsFor: 'private' stamp: 'len 7/8/2022 11:17:17'!
validate
	super validate.
	self monomials do: [:each|
		self assert: (each indeterminates allSatisfy: [:i| self parent has: i]).
		self assert: each exponents size = self parent rank].
	self assert: (self coefficients allSatisfy: [:each| self parent scalars includes: each])! !

!Polynomial class methodsFor: 'instance creation' stamp: 'len 2/6/2017 05:43:55'!
new
	^ self shouldNotImplement! !

!MultivariatePolynomial methodsFor: 'accessing' stamp: 'len 4/27/2022 13:20:46'!
bitSize
	| answer |
	self isZero ifTrue: [^ 0].
	answer _ 0.
	coefficients associationsDo: [:each| answer _ each key bitSize + each value bitSize + answer].
	^ answer! !

!MultivariatePolynomial methodsFor: 'accessing-coefficients' stamp: 'len 4/27/2022 19:22:46'!
at: aMonomial
	aMonomial isInteger ifTrue: [^ coefficients at: (self parent monomials x: self leadingIndeterminate to: aMonomial) ifAbsent: [self scalars zero]].
	^ coefficients at: aMonomial ifAbsent: [self scalars zero]! !

!MultivariatePolynomial methodsFor: 'accessing-coefficients' stamp: 'len 4/27/2022 13:22:21'!
initialCoefficient
	^ coefficients isEmpty ifTrue: [self scalars zero] ifFalse: [coefficients first]! !

!MultivariatePolynomial methodsFor: 'accessing-coefficients' stamp: 'len 4/27/2022 13:22:42'!
leadingCoefficient
	^ coefficients isEmpty ifTrue: [self scalars zero] ifFalse: [coefficients last]! !

!MultivariatePolynomial methodsFor: 'accessing-monomials' stamp: 'len 4/27/2022 13:23:08'!
initialMonomial
	^ coefficients isEmpty ifFalse: [coefficients firstKey]! !

!MultivariatePolynomial methodsFor: 'accessing-monomials' stamp: 'len 4/27/2022 13:23:28'!
leadingMonomial
	^ coefficients isEmpty ifFalse: [coefficients lastKey]! !

!MultivariatePolynomial methodsFor: 'accessing-terms' stamp: 'len 4/27/2022 16:56:29'!
associations
	^ coefficients associations! !

!MultivariatePolynomial methodsFor: 'accessing-terms' stamp: 'len 4/28/2022 06:56:30'!
leadingTerm
	| leadingAssociation |
	self isZero ifTrue: [^ self].
	leadingAssociation _ coefficients associations last.
	^ parent coefficient: leadingAssociation value monomial: leadingAssociation key! !

!MultivariatePolynomial methodsFor: 'accessing-terms' stamp: 'len 4/27/2022 18:47:57'!
tail
	self isZero ifTrue: [^ self].
	^ self class coefficients: coefficients allButLast parent: parent! !

!MultivariatePolynomial methodsFor: 'converting' stamp: 'len 4/27/2022 18:54:56'!
lift
	"If the coefficients ring is a quotient R/I, answer a representative of the receiver over R. See >>%."
	^ self class coefficients: (coefficients collect: [:each| each lift]) parent: parent lift! !

!MultivariatePolynomial methodsFor: 'converting' stamp: 'len 5/8/2023 17:05:19'!
over: aRing
	self flag: #deprecated.
	self scalars = aRing ifTrue: [^ self].
	^ (parent over: aRing) coefficients: (coefficients collect: [:each| aRing !! each]) "this is wrong"! !

!MultivariatePolynomial methodsFor: 'enumerating' stamp: 'len 4/27/2022 16:56:15'!
associationsDo: aBlock
	coefficients associationsDo: aBlock! !

!MultivariatePolynomial methodsFor: 'enumerating' stamp: 'len 4/27/2022 13:33:58'!
monomialsDo: aBlock
	"Iterate over the support of the receiver, i.e. the monomials with nonzero coefficient."
	coefficients keysDo: aBlock! !

!MultivariatePolynomial methodsFor: 'operations' stamp: 'len 4/27/2022 13:35:37'!
\\ anObject
	"Answer the remainder of the division of the receiver by the argument."
	(self scalars includes: anObject) ifTrue: [^ self apply: [:each| each \\ anObject]].
	^ self reductionFullBy: (anObject isCollection ifTrue: [anObject] ifFalse: [{anObject}])! !

!MultivariatePolynomial methodsFor: 'operations' stamp: 'len 4/27/2022 13:35:49'!
divisionBy: anArray
	self ordering isGlobal ifFalse: [^ self notYetImplemented].
	^ MultivariateDivision divide: self by: (anArray isCollection ifTrue: [anArray] ifFalse: [{anArray}])! !

!MultivariatePolynomial methodsFor: 'operations' stamp: 'len 4/27/2022 13:37:46'!
truncatedTo: anInteger
	self degree < anInteger ifTrue: [^ self].
	^ self class coefficients: (coefficients selectByKey: [:each| each degree < anInteger]) parent: parent! !

!MultivariatePolynomial methodsFor: 'testing' stamp: 'len 5/31/2022 19:06:51'!
isUnit
	"Answer true if the receiver is invertible."
	self isConstant ifTrue: [^ self independentCoefficient isUnit].
	parent scalars isIntegralDomain ifTrue: [^ false].
	self independentCoefficient isUnit ifFalse: [^ false].
	self associationsDo: [:each| (each key isIdentity or: [each value isNilpotent]) ifFalse: [^ false]].
	^ true
	"Also: for a local ring R with residue field K, a polynomial in R[x] is a unit iff its projection to K[x] is a unit."! !

!MultivariatePolynomial methodsFor: 'private' stamp: 'len 4/28/2022 06:42:20'!
applyToMonomials: aBlock
	^ self class coefficients: (coefficients collectByKey: aBlock) parent: parent! !

!MultivariatePolynomial methodsFor: 'private' stamp: 'len 4/27/2022 18:48:06'!
dividedByMonomial: aMonomial
	"The monomial ordering is preserved by this operation."
	^ self class coefficients: (coefficients collectByKey: [:each| each / aMonomial]) parent: parent! !

!MultivariatePolynomial methodsFor: 'private' stamp: 'len 4/27/2022 18:48:14'!
multipliedByMonomial: aMonomial
	"The monomial ordering is preserved by this operation."
	^ self class coefficients: (coefficients collectByKey: [:each| each * aMonomial]) parent: parent! !

!MultivariatePolynomial class methodsFor: 'instance creation' stamp: 'len 8/21/2022 08:25:52'!
coefficients: aSortedDictionary parent: aPolynomialRing
	^ self basicNew coefficients: aSortedDictionary parent: aPolynomialRing! !

!UnivariatePolynomial methodsFor: 'accessing' stamp: 'len 12/21/2017 18:20:42'!
bitSize
	^ self coefficients bitSize! !

!UnivariatePolynomial methodsFor: 'accessing' stamp: 'len 10/15/2023 09:45:46'!
degree
	coefficients isEmpty ifTrue: [^ Infinity negative]. "since we normalize the coefficients, isEmpty is equivalent to isZero"
	^ parent ordering isGradedWeighted
		ifTrue: [coefficients size - 1 * (parent ordering weightOf: 1)]
		ifFalse: [coefficients size - 1]! !

!UnivariatePolynomial methodsFor: 'accessing' stamp: 'len 5/15/2023 17:33:58'!
lift
	"If the coefficients ring is a quotient R/I, answer a representative of the receiver over R. See >>%."
	parent scalars cover = ℤ ifTrue: [^ parent lift coefficients: coefficients lift].
	^ self notYetImplemented! !

!UnivariatePolynomial methodsFor: 'accessing' stamp: 'len 12/23/2023 15:19:24'!
numerator
	"If the coefficients ring is a localization, answer the product of the receiver by the LCM of the denominators of the coefficients. The answer is a polynomial over the ring of numerators of the localization ring."
	| d |
	self scalars isLocalization ifFalse: [^ self].
	d := self scalars !! self denominator.
	^ parent numerators coefficients: (self scalars numerators new: coefficients size fill: [:i| ((coefficients at: i) * d) numerator])! !

!UnivariatePolynomial methodsFor: 'accessing' stamp: 'len 5/15/2023 17:30:10'!
representative
	"If the coefficients ring is a quotient R/I, answer a representative of the receiver over R. See >>%."
	parent scalars cover = ℤ ifTrue: [^ (parent over: ℤ) coefficients: coefficients representative].
	^ super representative! !

!UnivariatePolynomial methodsFor: 'accessing-coefficients' stamp: 'len 6/16/2023 18:59:26'!
at: aMonomial
	^ coefficients at: (aMonomial isInteger ifTrue: [aMonomial] ifFalse: [aMonomial degree])+1 ifAbsent: [self scalars zero]! !

!UnivariatePolynomial methodsFor: 'accessing-coefficients' stamp: 'len 1/1/2022 09:31:08'!
independentCoefficient
	^ coefficients at: 1 ifAbsent: [self scalars zero]! !

!UnivariatePolynomial methodsFor: 'accessing-coefficients' stamp: 'len 6/16/2023 19:00:27'!
initialCoefficient
	^ coefficients at: (coefficients firstNonzeroIndex ifNil: [^ self scalars zero])! !

!UnivariatePolynomial methodsFor: 'accessing-coefficients' stamp: 'len 6/16/2023 19:01:51'!
leadingCoefficient
	parent isLocal ifTrue: [^ self initialCoefficient].
	self isZero ifTrue: [^ self scalars zero].
	^ coefficients last! !

!UnivariatePolynomial methodsFor: 'accessing-monomials' stamp: 'len 6/16/2023 20:11:40'!
leadingMonomial
	| answer |
	self parent isLocal ifFalse: [^ self isZero ifFalse: [self parent monomials x: 1 to: self degree]].
	self monomialsDo: [:each| (answer isNil or: [each > answer]) ifTrue: [answer := each]].
	^ answer! !

!UnivariatePolynomial methodsFor: 'accessing-monomials' stamp: 'len 6/12/2023 16:19:52'!
order
	"Answer the minimum degree of the monomials present in the receiver."
	^ (coefficients firstNonzeroIndex ifNil: [^ Infinity positive]) - 1! !

!UnivariatePolynomial methodsFor: 'converting' stamp: 'len 5/8/2023 17:15:17'!
over: aRing
	self flag: #deprecated.
	self scalars = aRing ifTrue: [^ self].
	^ (parent over: aRing) newFrom: coefficients! !

!UnivariatePolynomial methodsFor: 'enumerating' stamp: 'len 4/28/2022 17:25:31'!
applyToMonomials: aBlock
	| associations n newCoefficients |
	associations _ OrderedCollection new: coefficients size.
	1 to: coefficients size do: [:i|
		(coefficients isZeroAt: i) ifFalse: [associations add: (aBlock value: (parent monomials x: 1 to: i-1)) -> (coefficients at: i)]].
	n _ associations max: [:each| each key degree].
	newCoefficients _ self scalars zeros: n+1.
	associations do: [:each| newCoefficients at: each key degree + 1 add: each value].
	^ self parent coefficients: newCoefficients! !

!UnivariatePolynomial methodsFor: 'enumerating' stamp: 'len 4/27/2022 16:56:56'!
associationsDo: aBlock
	coefficients withIndexDo: [:value :index| value isZero ifFalse: [aBlock value: (parent monomials x: 1 to: index-1) -> value]]! !

!UnivariatePolynomial methodsFor: 'enumerating' stamp: 'len 6/16/2023 18:39:19'!
monomialsDo: aBlock
	"Iterate over the support of the receiver, i.e. the monomials with nonzero coefficient."
	coefficients supportDo: [:i| aBlock value: (self parent monomials x: 1 to: i-1)]! !

!UnivariatePolynomial methodsFor: 'factorization' stamp: 'len 11/4/2023 10:51:02'!
distinctDegreeFactorizationDo: aBlock
	"Iterate over the distinct-degree factorization of a monic squarefree polynomial over a finite field.
	Evaluates aBlock at d and g, where g is the product of all irreducible factors of degree d.
	See [vzGG13, §14.2]"
	| i f f₂ q x R h found |
	f := self.
	R := f parent.
	x := R x.
	q := R scalars size.
	i := 1.
	f₂ := f.
	h := x.
	found := false.
	[f₂ degree >= (2*i)]
		whileTrue:
			[| g |
			g := f₂ gcd: (h := h raisedTo: q modulo: f₂) - x.
			g isOne ifFalse: [aBlock value: i value: g. f₂ := f₂ // g. found := true].
			i := i + 1].
	f₂ isOne ifFalse: [aBlock value: f₂ degree value: f₂. found := true].
	found ifFalse: [aBlock value: 1 value: f]! !

!UnivariatePolynomial methodsFor: 'factorization' stamp: 'len 11/4/2023 10:51:09'!
equalDegreeFactorization: d do: aBlock
	"Iterate over the equal-degree factorization of a monic squarefree univariate polynomial over a finite field.
	Assume that the receiver is the product of pairwise distinct irreducible factors of degree d.
	This is the Cantor-Zassenhaus algorithm. See [CZ81], [vzGG13, §14.3, Algorithm 14.8 and Exercise 14.16]."
	| f q k g c h |
	self degree = d ifTrue: [^ aBlock value: self].
"	self assert: d > 0.
	self assert: self degree \\ d = 0."
	q := self scalars size.
	k := self scalars degree. "q = p^k"
	f := self.
	"In many cases a random degree 1 monic polynomial ('g := x + a' with a random) would suffice:"
	[[(g := self parent atRandomMaxDegree: f degree - 1) isConstant] whileTrue.
	(c := g gcd: f) isConstant ifTrue:
		[q even
			ifTrue: "in characteristic 2 use trace polynomials:"
				[h := g.
				d * k - 1 timesRepeat: [g := g squared \\ f. h := h + g]]
			ifFalse:
				[h := g raisedTo: q^d - 1 / 2 modulo: f].
		c := h - 1 gcd: f].
	(c isConstant not and: [c degree < f degree]) ifTrue: "found nontrivial factor c..."
		[c equalDegreeFactorization: d do: aBlock.
		f := f // c.
		f degree = d ifTrue: [^ aBlock value: f]]] repeat! !

!UnivariatePolynomial methodsFor: 'factorization' stamp: 'len 6/25/2023 09:56:26'!
factorizationDo: aBlock
	"Enumerate the irreducible factors of the receiver and their multiplicities."
	self isZero ifTrue: [^ self error: 'factorization of zero'].
	self scalars polynomial: self factorizationDo: aBlock! !

!UnivariatePolynomial methodsFor: 'factorization' stamp: 'len 11/5/2023 08:32:08'!
squarefreeFactorization
	"Answer a squarefree factorization of the receiver."
	| answer |
	answer := Bag new.
	self squarefreeFactorizationDo: [:f :r| answer add: f withOccurrences: r].
	^ answer! !

!UnivariatePolynomial methodsFor: 'factorization' stamp: 'len 11/5/2023 09:05:05'!
squarefreeFactorizationDo: aBlock
	"Iterate over a squarefree factorization of the receiver."
	self scalars polynomial: self squarefreeFactorizationDo: aBlock! !

!UnivariatePolynomial methodsFor: 'factorization-private' stamp: 'len 11/17/2023 16:46:57'!
henselLiftFactors: anArray
	^ self parent scalars polynomial: self liftFactors: anArray! !

!UnivariatePolynomial methodsFor: 'factorization-private' stamp: 'len 11/5/2023 09:11:01'!
landauMignotteBound
	"Answer the Landau-Mignotte bound for the receiver.
	This is an upper bound for the absolute value of the coefficients of any nontrivial factor of a polynomial with integer coefficients. The bound depends on both the degree and the size of the coefficients of the receiver."
	| d h |
	d := self degree // 2.
	h := d // 2.
	^ (d - 1 choose: h) * self norm2 + (d - 1 choose: h - 1)! !

!UnivariatePolynomial methodsFor: 'gcd' stamp: 'len 6/10/2023 17:48:14'!
gcd: aPolynomial
	^ self ugcd: aPolynomial! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 6/5/2023 23:49:36'!
// anElement
	"Answer the quotient of the division of the receiver by the argument."
	(self scalars includes: anElement)
		ifTrue: [^ self class coefficients: coefficients // anElement parent: parent].
	anElement isCollection ifTrue: [^ (self divisionBy: anElement) quotients].
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #//].
	anElement leadingCoefficient isUnit
		ifFalse: [^ self class coefficients: (coefficients polynomialPartialQuotientBy: anElement coefficients) parent: parent].
	^ self class coefficients: (coefficients polynomialQuotientBy: anElement coefficients) parent: parent! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 12/2/2022 11:32:47'!
<< anInteger
	(anInteger = 0 or: [self isZero]) ifTrue: [^ self].
	self degree + anInteger >= 0 ifFalse: [^ self zero].
	self flag: #fixme. "delegate shift to coefficients array"
	^ self class
		coefficients:
			(anInteger < 0
				ifTrue: [coefficients copyFrom: 1 - anInteger to: coefficients size]
				"could be faster delegating the shift to the coefficients array:"
				ifFalse: [(parent scalars zeros: anInteger), coefficients])
		parent: parent! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 7/9/2016 03:05'!
>> anInteger
	^ self << anInteger negated! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 11/30/2023 15:25:53'!
\\ anElement
	"Answer the remainder of the division of the receiver by the argument."
	(self scalars includes: anElement)
		ifTrue: [^ self class coefficients: coefficients \\ anElement parent: parent].
	anElement isCollection ifTrue: [^ (self divisionBy: anElement) remainder].
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #\\].
"	anElement degree = 1
		ifTrue: [^ parent constant: (anElement independentCoefficient negated / anElement leadingCoefficient evaluate: self)]."
	anElement leadingCoefficient isUnit
		ifFalse: [^ self class coefficients: (coefficients copy partiallyReduceBy: anElement coefficients) parent: parent].
	^ self class coefficients: (coefficients copy reduceBy: anElement coefficients) parent: parent! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 5/27/2023 15:42:15'!
÷ anElement
	self isZero ifTrue: [^ self].
	(self parent includes: anElement) ifTrue:
		[self degree < anElement degree ifTrue: [^ self zero].
		self degree = anElement degree ifTrue: [^ self parent constant: self leadingCoefficient ÷ anElement leadingCoefficient]].
	^ super ÷ anElement! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 12/24/2023 09:14:15'!
colift: aPolynomial
	"Answer x such that xa = b, where a is the receiver and b is the argument. Answer nil if there's no solution.
	This is the right division of b by a, written b / a."
	| division |
	aPolynomial isZero ifTrue: [^ aPolynomial].
	self isConstant ifTrue: [^ aPolynomial dividedByScalar: self independentCoefficient].
	self leadingCoefficient isUnit
		ifTrue:
			[division := aPolynomial coefficients polynomialDivisionBy: coefficients]
		ifFalse:
			[self isUnit ifTrue: [^ aPolynomial * self inverse].
			parent scalars isIntegralDomain ifFalse: [^ (self asSingletonMatrix colift: aPolynomial asSingletonMatrix) ifNotNil: [:aMatrix| aMatrix asScalar]].
			division := aPolynomial coefficients polynomialPartialDivisionBy: coefficients].
	^ division second isZero ifTrue: [self class coefficients: division first parent: parent]! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 11/29/2023 10:03:24'!
companionMatrix
	"Answer the Frobenius companion matrix of the receiver.
	The companion matrix of a polynomial f in R[x] is the matrix of the 'multiplication by x' map on the R-algebra R[x]/⟨f⟩. This is a matrix that has f as both the characteristic and minimal polynomial.
	Also, given a linear recursive sequence with characteristic polynomial f, the transpose companion matrix of f generates the sequence."
	| n one zero |
	self assert: self isMonic.
	n := self degree.
	zero := self scalars zero.
	one := self scalars one.
	self flag: #fixme. "this could be made very fast, make low level operation replaceWithCompanionMatrix:"
	^ self scalars matrix: n@n fill: [:i :j| i-1 = j ifTrue: [one] ifFalse: [j < n ifTrue: [zero] ifFalse: [(self at: i-1) negated]]]! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 6/10/2023 09:58:40'!
composeWith: aPolynomial modulo: anotherPolynomial
	"Use Brent-Kung modular composition algorithm [BK78]."
	^ (BrentKung new: aPolynomial modulo: anotherPolynomial) compose: self! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 5/8/2023 17:06:45'!
derivative
	self isZero ifTrue: [^ self].
	^ parent coefficients: (self scalars new: self degree fill: [:i| (self at: i) * i ])! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 3/26/2016 23:05'!
derivativeIn: anIndeterminate
	^ (self has: anIndeterminate) ifTrue: [self derivative] ifFalse: [self zero]! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 7/9/2016 03:06'!
discriminant
	"Answer the (standard) discriminant of the receiver."
	| n |
	n _ self degree.
	^ (-1) ^ (n*(n-1)/2) / self leadingCoefficient * (self resultant: self derivative)! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 7/9/2016 03:06'!
discriminant0
	"Answer the (normalized) discriminant of the receiver."
	| n |
	n _ self degree.
	^ (-1) ^ (n*(n-1)/2) / (self leadingCoefficient ^ (2*n-1)) * (self resultant: self derivative)! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 4/25/2022 18:50:51'!
divisionBy: aPolynomial
	| result |
	aPolynomial isCollection ifTrue: [^ MultivariateDivision divide: self by: aPolynomial].
	result _ aPolynomial leadingCoefficient isUnit
		ifTrue: [coefficients polynomialDivisionBy: aPolynomial coefficients]
		ifFalse: [coefficients polynomialPartialDivisionBy: aPolynomial coefficients].
	^ Division dividend: self divisor: aPolynomial quotient: (self class coefficients: result first parent: parent) remainder: (self class coefficients: result second parent: parent)! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 11/17/2023 11:22:26'!
evenPart
	"Decompose the receiver in the form xf₁(x²) + f₀(x²) and answer f₀."
	^ parent coefficients: (self scalars new: coefficients size + 1 // 2 fill: [:i| coefficients at: i*2-1])! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 11/17/2023 11:22:33'!
oddPart
	"Decompose the receiver in the form xf₁(x²) + f₀(x²) and answer f₁."
	^ parent coefficients: (self scalars new: coefficients size // 2 fill: [:i| coefficients at: i*2])! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 5/27/2023 17:28:54'!
psc: anInteger with: aPolynomial
	"Answer the anInteger-th principal subresultant coefficient of the receiver with aPolynomial."
	| f g n m t rows tuple V |
	f := self.
	g := aPolynomial.
	m := f degree.
	n := g degree.
	t := m + n - anInteger - anInteger.
	t <= 0 ifTrue: [^ self scalars one].
	V := self scalars^t.
	rows := OrderedCollection new: t.
	tuple := V fill: [:i| f at: m - i + 1].
	n - anInteger timesRepeat: [rows add: tuple. tuple := tuple >> 1].
	tuple := V fill: [:i| g at: n - i + 1].
	m - anInteger timesRepeat: [rows add: tuple. tuple := tuple >> 1].
	^ (Matrix rows: rows) determinant

"alternative:
	^ (self subresultant: anInteger with: aPolynomial) leadingCoefficient
"! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 11/29/2023 10:03:24'!
resultant2: aPolynomial
	"Answer the resultant of the receiver with the argument."
	| f g mult |
	self degree <= aPolynomial degree
		ifTrue: [f _ self. g _ aPolynomial]
		ifFalse: [f _ aPolynomial. g _ self].
	f isConstant ifTrue: [^ (f ^ g degree)].
	f isMonic
		ifTrue:
			[mult _ f leadingCoefficient]
		ifFalse:
			[mult _ f leadingCoefficient ^ g degree.
			f _ f / f leadingCoefficient].
	^ (g value: f companionMatrix) determinant * mult! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 7/9/2016 03:07'!
resultant3: aPolynomial
	"Answer the resultant of the receiver with the argument."

	| f g answer negate |
	self degree > aPolynomial degree
		ifTrue: [f _ aPolynomial. g _ self. negate _ true]
		ifFalse: [f _ self. g _ aPolynomial. negate _ false].
	answer _ f isConstant
		ifTrue: [f ^ g degree]
		ifFalse:
			[(f resultant3: g \\ f) * (f leadingCoefficient ^ (g degree - f degree + 1))].
	^ negate ifTrue: [answer negated] ifFalse: [answer]! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 8/1/2021 11:32:03'!
resultant: aPolynomial
	"Answer the resultant of the receiver with aPolynomial."
	(self isZero or: [aPolynomial isZero]) ifTrue: [^ self scalars zero].
	self isConstant ifTrue: [^ self independentCoefficient ^ aPolynomial degree].
	aPolynomial isConstant ifTrue: [^ aPolynomial independentCoefficient ^ self degree].
	^ (self sylvester: aPolynomial) determinant! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 4/20/2022 10:06:30'!
reversed
	"Answer the reverse of the receiver."

	^ self class coefficients: coefficients reversed parent: parent! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 6/10/2023 10:13:50'!
shoupRaisedTo: anInteger modulo: aPolynomial
	"Shoup exponentiation algorithm. See [Coh+05, Algorithm 11.53]."
	| d q radix brentKung y n n₂ |
	self flag: #fixme. "this is about 10x slower than the normal raisedTo:modulo:"
	d := aPolynomial degree.
	q := self scalars size.
	radix := q^(d / (d log: q)) ceiling.
	brentKung := BrentKung new: (self parent x: 1 to: radix) \\ aPolynomial modulo: aPolynomial.
	y := self parent one.
	n := anInteger.
	[n = 0] whileFalse:
		[n₂ := n // radix.
		y := brentKung compose: y.
		y := (y * (self raisedTo: (n - n₂) modulo: aPolynomial)) \\ aPolynomial.
		n := n₂].
	^ y! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 5/1/2024 12:28:11'!
splittingField
	"The splitting field of a polynomial with coefficients in a field is the smallest field extension of that field over which the polynomial splits, i.e. decomposes into linear factors."
	| answer f i factors p |
	answer := self parent scalars.
	f := self.
	answer isField ifFalse: [answer := answer fractions].
	i := 1.
	[f := answer polynomials !! f.
	f isZero ifTrue: [^ answer].
	factors := f factorization asSet select: [:each| each degree > 1].
	factors isEmpty ifTrue: [^ answer].
	p := factors any.
	answer := answer extension: p.
	f := factors product.
	i := i + 1] repeat

"	i _ 1.
	[i >= f degree ifTrue: [^ answer].
	f _ (answer polynomialsIn: {'x', i printString sub}) !! f.
	p _ f factorization detect: [:one| one degree > 1] ifNone: [^ answer].
	answer _ answer extension: p.
	i _ i + 1] repeat"! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 11/23/2022 21:30:50'!
subresultant: i with: aPolynomial
	"Answer the i-th subresultant of the receiver with aPolynomial."
	| lambda mu n m c V rows matrix tuple |
	m _ self degree.
	n _ aPolynomial degree.
	lambda _ m min: n.
	mu _ (m max: n) - 1.
	i = lambda
		ifTrue:
			[m + 1 < n
				ifTrue: [c _ self]
				ifFalse:
					[n + 1 < m
						ifTrue: [c _ aPolynomial] ifFalse: [^ nil]].
			^ c * (c leadingCoefficient ^ ((m - n) abs - 1))].
	(i between: lambda and: mu) ifTrue: [^ self zero].
	(i between: 0 and: lambda - 1) ifFalse: [self error: 'index out of range'].
	V _ self parent^(m + n - (2*i)).
	rows _ OrderedCollection new.
	tuple _ V fill: [:k| self parent constant: (self at: m - k + 1)].
	n - i timesRepeat: [rows add: tuple. tuple _ tuple >> 1].
	tuple _ V fill: [:k| self parent constant: (aPolynomial at: n - k + 1)].
	m - i timesRepeat: [rows add: tuple. tuple _ tuple >> 1].
	matrix _ Matrix rows: rows.
	1 to: n - i do: [:k|
		matrix at: k @ (m + n - (2*i)) put: self << (n - i - k)].
	1 to: m - i do: [:k|
		matrix at: n - i + k @ (m + n - (2*i)) put: aPolynomial << (m - i - k)].
	^ matrix determinant! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 7/9/2016 03:08'!
subresultantChain: aPolynomial
	"Answer the Subresultant Chain of the receiver with the argument."
	| n answer |
	n _ self degree > aPolynomial degree ifTrue: [self degree - 1] ifFalse: [aPolynomial degree].
	answer _ OrderedCollection new: n + 2.
	answer add: self; add: aPolynomial.
	n - 1 to: 0 by: -1 do: [:i|
		answer add: (self subresultant: i with: aPolynomial)].
	^ answer! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 12/21/2022 13:28:36'!
sylvester: aPolynomial
	"Answer the Sylvester matrix of the receiver with the argument.
	If p,q are polynomials of degrees m and n:
		det S(p,q) = res (p,q)
		deg (gcd(p,q)) = m - n + rank (S(p,q))
	The kernel of the transposed Sylvester matrix gives all solutions of the Bézout equation:
		f*p + g*q = 0
	"
	| m n V rows tuple |
	m _ self degree.
	n _ aPolynomial degree.
	V _ self scalars^(m+n).
	rows _ OrderedCollection new: m+n.
	tuple _ V fill: [:i| self at: m-i+1].
	n timesRepeat: [rows add: tuple. tuple _ tuple >> 1].
	tuple _ V fill: [:i| aPolynomial at: n-i+1].
	m timesRepeat: [rows add: tuple. tuple _ tuple >> 1].
	^ Matrix rows: rows! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 4/20/2022 10:06:43'!
truncatedTo: anInteger
	coefficients size <= anInteger ifTrue: [^ self].
	^ self class coefficients: (coefficients copyFrom: 1 to: anInteger) parent: parent! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 6/6/2023 13:15:43'!
value: anObject
	"Evaluate the receiver at the given argument using Horner's method."
	| x answer one |
	x := anObject isSequenceable ifTrue: [anObject at: 1] ifFalse: [anObject].
	(self scalars includes: x) ifTrue: [^ coefficients evaluateFrom: 1 to: coefficients size at: x].
	answer := x zero.
	one := x one.
	coefficients reverseDo: [:each| answer := x * answer + (one * each)].
	^ answer! !

!UnivariatePolynomial methodsFor: 'roots' stamp: 'len 4/10/2018 16:11:32'!
allRoots
	"Answer the roots (counted with multiplicity) in the coefficients ring or field."
	^ self allRootsIn: self scalars! !

!UnivariatePolynomial methodsFor: 'roots' stamp: 'len 6/25/2023 11:38:00'!
allRootsIn: aRing
	"Answer the roots (counted with multiplicity) in aRing."
	| answer |
	answer := Bag new.
	self rootsIn: aRing withMultiplicitiesDo: [:τ :m| answer add: τ withOccurrences: m].
	^ answer! !

!UnivariatePolynomial methodsFor: 'roots' stamp: 'len 4/16/2018 20:38:44'!
cauchyRootBound
	| max a0 an |
	max _ 0.
	self coefficients do: [:each| max _ max max: each abs].
	a0 _ self independentCoefficient abs.
	an _ self leadingCoefficient abs.
	^ Array with: a0 / (a0 + max) with: an + max / an! !

!UnivariatePolynomial methodsFor: 'roots' stamp: 'len 2/13/2017 07:54:44'!
multiplicityAt: aPoint
	"Answer the multiplicity of aPoint as zero of the receiver."
	| answer f |
	self isZero ifTrue: [^ Infinity positive].
	answer _ 0.
	f _ self.
	[(f value: aPoint) isZero]
		whileTrue:
			[answer _ answer + 1.
			f _ f derivative].
	^ answer! !

!UnivariatePolynomial methodsFor: 'roots' stamp: 'len 12/23/2023 15:55:35'!
multiplicityAt: aPoint fourier: fourier
	"Like >>#multiplicityAt: but caches the derivatives in an OrderedCollection provided by the caller."
	| count |
	self isZero ifTrue: [^ Infinity positive].
	(self value: aPoint) isZero ifFalse: [^ 0].
	count := 1.
	fourier isEmpty ifTrue: [fourier add: self derivative].
	fourier do: [:each| (each value: aPoint) isZero ifFalse: [^ count]. count := count + 1].
	[fourier last isConstant]
		whileFalse:
			[((fourier add: fourier last derivative) value: aPoint) isZero ifFalse: [^ count]. count := count + 1].
	^ count! !

!UnivariatePolynomial methodsFor: 'roots' stamp: 'len 2/6/2017 06:44:06'!
orderAt: aPoint
	^ self multiplicityAt: aPoint! !

!UnivariatePolynomial methodsFor: 'roots' stamp: 'len 4/10/2018 16:11:22'!
roots
	"Answer the set of distinct roots in the coefficients ring or field."
	^ self rootsIn: self scalars! !

!UnivariatePolynomial methodsFor: 'roots' stamp: 'len 6/25/2023 11:36:39'!
rootsIn: aRing
	"Answer the distinct roots (not counted with multiplicity) in the given domain."
	^ Iterator on: [:aBlock| self rootsIn: aRing do: aBlock]! !

!UnivariatePolynomial methodsFor: 'roots' stamp: 'len 6/25/2023 11:34:59'!
rootsIn: aRing do: aBlock
	"Enumerate the distinct roots of the receiver in aRing (without multiplicities)."
	aRing rootsOf: self do: aBlock! !

!UnivariatePolynomial methodsFor: 'roots' stamp: 'len 6/25/2023 11:35:32'!
rootsIn: aRing withMultiplicitiesDo: aBlock
	"Enumerate the roots of the receiver in aRing with multiplicities."
	aRing rootsOf: self withMultiplicitiesDo: aBlock! !

!UnivariatePolynomial methodsFor: 'roots' stamp: 'len 11/12/2023 09:32:02'!
signature
	"Answer the signature (r₁,r₂) of the receiver, where r₁ is the number of real roots and 2r₂ is the number of non-real roots (they come in complex-conjugate pairs).
	Assume the receiver's coefficients are integers. Throw an error if the receiver is not squarefree.
	[Coh96] Algorithm 4.1.11 (Sturm)."
	| A B g h s n t r₁ d R |
	self isZero ifTrue: [^ #(0 0)].
	A := self primitivePart.
	B := self derivative primitivePart.
	g := 1.
	h := 1.
	s := A sign.
	n := A degree.
	t := n even ifTrue: [s negated] ifFalse: [s].
	r₁ := 1.
	[d := A degree - B degree.
	R := A pseudoRem: B.
	R isZero ifTrue: [^ self error: 'polynomial is not squarefree'].
	(d odd or: [B leadingCoefficient > 0])
		ifTrue: [R := R negated].
	"Use Sturm:"
	R sign ~= s ifTrue: [s := s negated. r₁ := r₁ - 1].
	R sign ~= ((-1) ^ R degree * t) ifTrue: [t := t negated. r₁ := r₁ + 1].
	"Finished?"
	R isConstant]
		whileFalse:
			[A := B.
			B := R / (h ^ d * g).
			g := A leadingCoefficient abs.
			h := h ^ (1 - d) * (g ^ d)].
	^ {r₁. n - r₁ / 2}! !

!UnivariatePolynomial methodsFor: 'roots' stamp: 'len 11/29/2023 10:03:24'!
zeroAddition: aPolynomial
	"Answer a polynomial whose zeros are the addition of the zeros of the receiver with the zeros of the argument."
	| f g R S X Y C |
	self degree <= aPolynomial degree ifTrue: [f := self. g := aPolynomial] ifFalse: [g := self. f := aPolynomial].
	f degree = 1 ifTrue: [^ g value: f].
	R := self parent.
	S := self scalars polynomialsIn: 2.
	X := S x: 1.
	Y := S x: 2.
	f isMonic ifFalse: [f := f normalized]. "otherwise the companion matrix is undefined"
	C := f companionMatrix apply: R scalars → R.
	^ ((g value: X - Y) asUnivariate value: C) determinant! !

!UnivariatePolynomial methodsFor: 'roots' stamp: 'len 11/12/2023 09:17:42'!
zeroInverse
	"Answer a polynomial whose zeros are the multiplicative inverses of the receiver's zeros."
	^ self reversed! !

!UnivariatePolynomial methodsFor: 'roots' stamp: 'len 11/12/2023 22:09:10'!
zeroNegation
	"Answer a polynomial whose zeros are the additive inverses of the receiver's zeros."
	^ self parent newFrom:
		(self degree odd "this distinction is made to keep the leading coefficient positive, as a minimal polynomial"
			ifTrue: [self coefficients withIndexCollect: [:each :i| i odd ifTrue: [each negated] ifFalse: [each]]]
			ifFalse: [self coefficients withIndexCollect: [:each :i| i even ifTrue: [each negated] ifFalse: [each]]])! !

!UnivariatePolynomial methodsFor: 'roots' stamp: 'len 11/29/2023 10:03:24'!
zeroProduct: aPolynomial
	"Answer a polynomial whose zeros are the product of the zeros of the receiver by the zeros of the argument."
	| f g C R |
	self degree <= aPolynomial degree ifTrue: [f := self. g := aPolynomial] ifFalse: [g := self. f := aPolynomial].
	"the following evaluation can be made faster:"
"	f degree = 1 ifTrue: [^ g value: parent x * f independentCoefficient negated / f leadingCoefficient]."
	f isMonic ifFalse: [f := f normalized]. "otherwise the companion matrix is undefined"
	R := self parent.
	C := f companionMatrix apply: R scalars → R.
	^ (g homogenized asUnivariate value: C) determinant! !

!UnivariatePolynomial methodsFor: 'roots' stamp: 'len 4/27/2018 16:25:56'!
zeroRaisedTo: anInteger
	"Answer a polynomial whose zeros are the zeros of the receiver raised to anInteger."
	self notYetImplemented! !

!UnivariatePolynomial methodsFor: 'roots' stamp: 'len 12/4/2017 10:22:45'!
zeroSquareRoot
	^ self value: self parent x squared! !

!UnivariatePolynomial methodsFor: 'roots' stamp: 'len 11/17/2023 11:19:17'!
zeroSquared
	"Answer a polynomial whose zeros are the squares of the zeros of the receiver."
	| f₀ f₁ |
	f₀ := self evenPart.
	f₁ := self oddPart.
	^ f₁ squared << 1 - f₀ squared! !

!UnivariatePolynomial methodsFor: 'testing' stamp: 'len 12/24/2023 08:38:01'!
has: anIndeterminate
	^ anIndeterminate = 1 and: [self isConstant not]! !

!UnivariatePolynomial methodsFor: 'testing' stamp: 'len 4/28/2022 11:53:24'!
isConstant
	^ coefficients size <= 1! !

!UnivariatePolynomial methodsFor: 'testing' stamp: 'len 6/14/2019 01:28:07'!
isEisenstein
	coefficients first valuation = 1 ifFalse: [^ false].
	((2 to: coefficients size - 1) allSatisfy: [:i| (coefficients at: i) valuation >= 1]) ifFalse: [^ false].
	^ coefficients last valuation = 0! !

!UnivariatePolynomial methodsFor: 'testing' stamp: 'len 10/5/2022 18:45:01'!
isInertial
	coefficients first valuation = 0 ifFalse: [^ false].
	coefficients last valuation = 0 ifFalse: [^ false].
	^ (self apply: self scalars → self scalars residueField) isIrreducible! !

!UnivariatePolynomial methodsFor: 'testing' stamp: 'len 11/17/2023 09:45:30'!
isIrreducible
	self isConstant ifTrue: [^ false]. "constant polynomials are not reducible nor irreducible"
	self degree = 1 ifTrue: [^ true].
	self independentCoefficient isZero ifTrue: [^ false].
	self scalars isFiniteField ifTrue: [^ self isIrreducibleBenOr].
	self scalars isAlgebraicallyClosed ifTrue: [^ false]. "because degree > 1"
	(self scalars = ℝ and: [self degree > 2]) ifTrue: [^ false].
	^ self factorization size = 1! !

!UnivariatePolynomial methodsFor: 'testing' stamp: 'len 7/17/2023 19:07:48'!
isIrreducibleBenOr
	"Ben-Or Irreducibility Test algorithm for polynomials over a finite field GF(q).
	Although the wrost-case complexity of this algorithm is wrose than Rabin's, it performs faster on average. See [GP97]."
	| q x one h |
	q := self scalars size.
	x := self parent x.
	one := self one.
	h := x.
	self degree // 2 timesRepeat:
		[h := h raisedTo: q modulo: self.
		(self gcd: h - x) = one ifFalse: [^ false]].
	^ true! !

!UnivariatePolynomial methodsFor: 'testing' stamp: 'len 12/23/2023 10:29:32'!
isIrreducibleHeuristic2: anInteger
	"Answer an Integer or nil. If the answer is an Integer, the
	receiver is irreducible iff that integer is prime, and in fact the
	integer will be prime with a very high probability (a probabilistic
	test is used here). If the answer is nil, the heuristic test has failed,
	and nothing can be said about the irreducibility of the receiver."

	"This is a probabilistic test for irreudcibility of rational univariate
	polynomials. It works looking for a prime evaluation of the polynomial.
	If it finds such a prime, then it's returned, and nil otherwise. The
	argument anInteger is the upper bound for the looking for primes."

	"Reference: 'A Heuristic Polynomial Irreducibility Test', Michael
	Monagan, J. Symbolic Comp., (1992) Vol. 13, No. 1, pp 47-57."

	| f g bg bound val try gcd |
	f := self integralPrimitivePart.
	g := f reversed.
	(bg := g norm1 / g leadingCoefficient abs + 1) <
	(bound := f norm1 / f leadingCoefficient abs + 1)
		ifTrue: [f := g. bound := bg].
	bound to: anInteger - 1 / 2 do: [ :each |
		val := (f value: each) abs.
		gcd := val gcd: 355929487585205167172661547995662840887819680000.
		(gcd <= (each - bound) squared and: [(try := val / gcd) isPrime])
			ifTrue: [^ try].
		val := (f value: each negated) abs.
		gcd := val gcd: 355929487585205167172661547995662840887819680000.
		(gcd <= (each - bound) squared and: [(try := val / gcd) isPrime])
			ifTrue: [^ try]
	].
	^ nil! !

!UnivariatePolynomial methodsFor: 'testing' stamp: 'len 12/23/2023 10:29:38'!
isIrreducibleHeuristic: anInteger
	"Answer an Integer or nil. If the answer is an Integer, the
	receiver is irreducible iff that integer is prime, and in fact the
	integer will be prime with a very high probability (a probabilistic
	test is used here). If the answer is nil, the heuristic test has failed,
	and nothing can be said about the irreducibility of the receiver."

	"This is a probabilistic test for irreudcibility of rational univariate
	polynomials. It works looking for a prime evaluation of the polynomial.
	If it finds such a prime, then it's returned, and nil otherwise. The
	argument anInteger is the upper bound for the looking for primes."

	| f val bound interval |
	f := self integralPrimitivePart.
	bound := self cauchyRootBound first floor abs.
	bound even ifTrue: [bound := 0 max: bound - 1].
	interval := f independentCoefficient odd
		ifTrue: [bound to: bound + (anInteger // 2)]
		ifFalse: [bound to: bound + anInteger by: 2].
	interval do: [ :each |
		val := (f value: each) abs.
		val isPrime ifTrue: [^ val].
		val := (f value: each negated) abs.
		val isPrime ifTrue: [^ val]
	].
	^ nil! !

!UnivariatePolynomial methodsFor: 'testing' stamp: 'len 7/16/2023 23:32:19'!
isIrreducibleRabin
	"This is Rabin's algorithm for irreducibility test. It works over any finite field GF(q)."
	| x one n h q |
	q := self scalars size.
	x := self parent x.
	one := self one.
	n := self degree.
	n factorization asSet do: [:p|
		h := (x raisedTo: q^(n/p) modulo: self) - x \\ self.
		(self gcd: h) = one ifFalse: [^ false]].
	((x raisedTo: q^n modulo: self) - x \\ self) isZero ifFalse: [^ false].
	^ true! !

!UnivariatePolynomial methodsFor: 'testing' stamp: 'len 7/17/2023 19:09:00'!
isIrreducibleRabin2
	"This is variant of Rabin's algorithm for irreducibility test. It works over any finite field GF(q) with O(n M(n) log q) operations in GF(q). See [GP97]."
	| x one n h q k₀ |
	q := self scalars size.
	x := self parent x.
	one := self one.
	n := self degree.
	h := x.
	k₀ := 0.
	(n factorization asSet asArray collect: [:each| n // each]) sort do: [:k|
		h := h raisedTo: q^(k - k₀) modulo: self.
		k₀ := k.
		(self gcd: h - x) = one ifFalse: [^ false]].
	((h raisedTo: q^(n - k₀) modulo: self) - x \\ self) isZero ifFalse: [^ false].
	^ true! !

!UnivariatePolynomial methodsFor: 'testing' stamp: 'len 12/24/2023 09:21:53'!
isUnit
	"Answer true if the receiver is invertible."
	self isConstant ifTrue: [^ self independentCoefficient isUnit].
	parent scalars isIntegralDomain ifTrue: [^ false].
	self independentCoefficient isUnit ifFalse: [^ false].
	2 to: coefficients size do: [:i| (coefficients at: i) isNilpotent ifFalse: [^ false]].
	^ true

	"Also: for a local ring R with residue field K, a polynomial in R[x] is a unit iff its projection to K[x] is a unit."! !

!UnivariatePolynomial methodsFor: 'testing' stamp: 'len 3/27/2016 07:56'!
isUnivariate
	^ true! !

!UnivariatePolynomial methodsFor: 'private' stamp: 'len 5/14/2023 18:23:42'!
coefficients: anArray parent: aPolynomialRing
	| n |
	coefficients _ (n _ anArray lastNonzeroIndex ifNil: [0]) < anArray size
		ifTrue: [anArray copyFrom: 1 to: n] ifFalse: [anArray].
	parent _ aPolynomialRing! !

!UnivariatePolynomial methodsFor: 'private' stamp: 'len 7/15/2021 12:34:04'!
dividedByMonomial: aMonomial
	^ self << aMonomial degree negated! !

!UnivariatePolynomial methodsFor: 'private' stamp: 'len 5/5/2023 17:18:53'!
dividedByScalar: anElement
	"We force coercion to the coefficients ring in case the division was not exact and it returned an element outside of the ring. This can happen with Integers, for example 1 / 2 doesn't produce a division error but instead returns a Fraction."
	^ self class coefficients: (parent scalars new: coefficients size fill: [:i| (coefficients at: i) / anElement]) parent: parent! !

!UnivariatePolynomial methodsFor: 'private' stamp: 'len 7/15/2021 12:41:15'!
exactlyDividedBy2: aPolynomial
	"Answer the exact division of the receiver by the argument.
	Apply the Schonhage-Jabelean algorithm, for polynomials of degree at most 2n and n with coefficients in a field. When necesary conditions don't hold, do the ordinary division.
	Ref: 'Algorithms With Exact Divisions Made Faster', Arnold Schonhage,
	INRIA Research Report Nro. 2381, Algorithms Seminar 1993-1994, p. 51."

	| order f g m n h l k cg q |
	self flag: #fix. "this has some bug"
	self isZero
		ifTrue: [^ self].
	aPolynomial isConstant
		ifTrue: [^ self / aPolynomial leadingCoefficient].
	(self isUnivariate and: [aPolynomial isUnivariate])
		ifFalse: [^ (MultivariateDivision divide: self by: {aPolynomial}) exactQuotient].
	self scalars isField
		ifFalse: [^ (PseudoDivision divide: self by: aPolynomial) exactQuotient].
	(order _ aPolynomial order) > 0 ifTrue: [^ self >> order exactlyDividedBy: aPolynomial >> order].
	f _ self coefficients.
	g _ aPolynomial coefficients.
	m _ f size.
	n _ g size.
	m = n ifTrue: [^ self parent constant: f last / g last].
 	n * 2 > m ifFalse: [^ (self divisionBy: aPolynomial) exactQuotient].

	h _ f size // 2.
	l _ h // 2.
	k _ h - l.

	q _ Array new: m-n+1.
	
	"Jebelean division for the lowest half:"
	cg _ g first inverse. "reciprocal of the independent coefficient"
	0 to: l do: [:i|
		| qi |
		qi _ q at: i+1 put: (f at: i+1) * cg.
		1 to: l-i do: [:j|
			f at: i+j+1 put: (f at: i+j+1) - (qi*(g at: j+1))]]. "optimize negated"
	
	"Schonhage division for the other half:"
	cg _ g last inverse. "reciprocal of the leading coefficient"
	m-n to: m-n-k+1 by: -1 do: [:i|
		| qi |
		qi _ q at: i+1 put: (f at: i+n) * cg.
		n-2 to: m-k-i by: -1 do: [:j|
			f at: i+j+1 put: (f at: i+j+1) - (qi*(g at: j+1))]].

	^ self parent coefficients: q! !

!UnivariatePolynomial methodsFor: 'private' stamp: 'len 5/29/2022 19:39:19'!
exactlyDividedBy: aPolynomial
	| division |
	division _ aPolynomial leadingCoefficient isUnit
		ifTrue: [coefficients polynomialDivisionBy: aPolynomial coefficients]
		ifFalse: [coefficients polynomialPartialDivisionBy: aPolynomial coefficients].
	division second isZero ifFalse: [^ DivisibilityError new signalReceiver: self selector: #/ argument: aPolynomial].
	^ self class coefficients: division first parent: parent! !

!UnivariatePolynomial methodsFor: 'private' stamp: 'len 7/15/2021 12:34:10'!
multipliedByMonomial: aMonomial
	^ self << aMonomial degree! !

!UnivariatePolynomial methodsFor: 'private' stamp: 'len 5/14/2023 17:53:35'!
validate
	super validate.
	self assert: (self scalars isValidArray: coefficients)! !

!UnivariatePolynomial class methodsFor: 'instance creation' stamp: 'len 4/20/2022 08:14:25'!
coefficients: anArray parent: aPolynomialRing
	^ self basicNew coefficients: anArray parent: aPolynomialRing! !

!FiniteAlgebraElement methodsFor: 'accessing' stamp: 'len 6/10/2020 14:00:48'!
parent
	^ parent! !

!FiniteAlgebraElement methodsFor: 'comparing' stamp: 'len 7/14/2020 09:50:46'!
= anObject
	^ self class = anObject class and: [moduleElement = anObject asModuleElement]! !

!FiniteAlgebraElement methodsFor: 'comparing' stamp: 'len 7/14/2020 09:50:50'!
hash
	^ moduleElement hash! !

!FiniteAlgebraElement methodsFor: 'converting' stamp: 'len 7/14/2020 09:51:07'!
asModuleElement
	^ moduleElement! !

!FiniteAlgebraElement methodsFor: 'converting' stamp: 'len 6/21/2020 14:06:13'!
asScalar
	"If the receiver is the embedding of an element of the scalars ring in the parent algebra, answer the corresponding scalar."
	^ self notYetImplemented! !

!FiniteAlgebraElement methodsFor: 'initialization' stamp: 'len 7/14/2020 09:51:39'!
parent: anAlgebra moduleElement: anElement
	parent _ anAlgebra.
	moduleElement _ anElement! !

!FiniteAlgebraElement methodsFor: 'operations' stamp: 'len 6/14/2024 15:19:45'!
* anElement
	(anElement isInteger or: [self parent scalars includes: anElement])
		ifTrue: [^ self class parent: parent moduleElement: moduleElement * anElement].
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #*].
	^ self class parent: parent moduleElement: (parent multiplicationBilinearMap value: moduleElement value: anElement asModuleElement)! !

!FiniteAlgebraElement methodsFor: 'operations' stamp: 'len 7/14/2020 09:53:21'!
+ anElement
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #+].
	^ self class parent: parent moduleElement: moduleElement + anElement asModuleElement! !

!FiniteAlgebraElement methodsFor: 'operations' stamp: 'len 7/14/2020 09:54:04'!
negated
	^ self class parent: parent moduleElement: moduleElement negated! !

!FiniteAlgebraElement methodsFor: 'operations' stamp: 'len 4/3/2024 08:49:32'!
opposite
	"Answer the receiver as an element of the opposite ring."
	self parent isCommutative ifTrue: [^ self].
	self parent isInvolutive ifTrue: [^ self conjugate].
	^ self parent opposite fromModuleElement: moduleElement! !

!FiniteAlgebraElement methodsFor: 'operations' stamp: 'len 10/16/2022 11:06:55'!
representation
	"Answer the module endomorphism corresponding to the left regular representation of the receiver."
	^ representation ifNil: [representation _ self parent asModule endomorphisms map: [:x| (self * (self parent !! x)) asModuleElement]]! !

!FiniteAlgebraElement methodsFor: 'printing' stamp: 'len 7/14/2020 09:54:14'!
printOn: aStream
	aStream print: moduleElement! !

!FiniteAlgebraElement methodsFor: 'testing' stamp: 'len 7/22/2021 18:35:04'!
isNilpotent
	"Answer true if self^n = 0 for some integer n >= 1."
	^ (self ^ self parent rank) isZero

"alternative:
	^ self parent nilradical contains: self
	
or:
	^ self representation isNilpotent"! !

!FiniteAlgebraElement methodsFor: 'testing' stamp: 'len 6/21/2020 14:05:18'!
isScalar
	"Answer true if the receiver corresponds to the embedding of an element of the scalars ring in the parent algebra."
	^ self notYetImplemented! !

!FiniteAlgebraElement methodsFor: 'testing' stamp: 'len 10/16/2022 10:46:06'!
isUnit
	"Answer true if the receiver is invertible."
"	self parent isDivisionRing ifTrue: [^ self isZero not]."
	^ self norm isUnit! !

!FiniteAlgebraElement methodsFor: 'testing' stamp: 'len 11/20/2023 10:52:09'!
isZero
	^ moduleElement isZero! !

!FiniteAlgebraElement methodsFor: 'testing' stamp: 'len 6/16/2024 07:57:26'!
isZeroDivisor
	"Answer true if there exists a nonzero element that multiplied by the receiver is zero."
	self parent isIntegralDomain ifTrue: [^ self isZero].
	self flag: #fixme. "is this correct? both left and right?"
	^ self representation isZeroDivisor and: [self parent isCommutative or: [self rightRepresentation isZeroDivisor]]! !

!FiniteAlgebraElement class methodsFor: 'instance creation' stamp: 'len 7/14/2020 10:06:42'!
parent: anAlgebra moduleElement: anElement
	^ self new parent: anAlgebra moduleElement: anElement! !

!AlgebraicInteger methodsFor: 'operations' stamp: 'len 5/30/2022 12:40:32'!
colift: anElement
	"Answer x such that xa = b, where a is the receiver and b is the argument. Answer nil if there's no solution.
	This is the right division of b by a, written b / a."
	^ super colift: anElement

"alternative:
	^ (self parent fractions !! self colift: self parent fractions !! anElement) ifNotNil: [:aFraction| self parent adapt: aFraction]"! !

!AlgebraicInteger methodsFor: 'operations' stamp: 'len 11/17/2023 10:23:08'!
conjugate
	"Answer the complex conjugate of the receiver."
	^ parent !! (parent fractions !! self) conjugate! !

!AlgebraicInteger methodsFor: 'printing' stamp: 'len 7/10/2021 11:35:53'!
printOn: aStream
	aStream print: parent fractions !! self! !

!AlgebraicInteger methodsFor: 'testing' stamp: 'len 7/11/2021 11:19:13'!
isIntegral
	^ true! !

!EisensteinInteger methodsFor: 'operations' stamp: 'len 7/10/2023 17:53:30'!
// anElement
	"Answer the quotient of the Euclidean division of the receiver by the argument."
	| a b c d n x y xC xF yC yF |
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #//].
	anElement isZero ifTrue: [^ DivisibilityError new signalReceiver: self selector: #// argument: anElement].
	a := moduleElement at: 1.
	b := moduleElement at: 2.
	c := anElement asModuleElement at: 1.
	d := anElement asModuleElement at: 2.
	n := c squared - (c*d) + d squared.
	c := c - d.
	d := d negated.
	x := a*c - (b*d) / n.
	y := b*c + (a*d) - (b*d) / n.
	xF := x floor. yF := y floor.
	xC := x ceiling. yC := y ceiling.
	^ ({{xF. yF}. {xC. yF}. {xF. yC}. {xC. yC}} collect: [:each| self class parent: parent moduleElement: (moduleElement parent elementAt: each)]) detectMin: [:each| (self - (anElement*each)) norm]! !

!EisensteinInteger methodsFor: 'operations' stamp: 'len 10/17/2022 12:30:11'!
conjugate
	"Answer the complex conjugate of the receiver."
	| a b |
	a _ moduleElement at: 1.
	b _ moduleElement at: 2.
	^ self class parent: parent moduleElement: (moduleElement parent elementAt: {a - b. b negated})! !

!EisensteinInteger methodsFor: 'operations' stamp: 'len 10/17/2022 09:40:17'!
gauge
	"Answer the value of the Euclidean function at the receiver."
	^ self norm! !

!EisensteinInteger methodsFor: 'operations' stamp: 'len 10/17/2022 12:17:36'!
norm
	| a b |
	a _ moduleElement at: 1.
	b _ moduleElement at: 2.
	^ a squared - (a*b) + b squared! !

!EisensteinInteger methodsFor: 'operations' stamp: 'len 4/1/2024 14:45:45'!
normalization
	"Answer a unit u such that 'self * u' is a unique choice of associate. See >>normalized."
	self isZero ifTrue: [^ parent one].
	self flag: #fixme. "there should be a more efficient way"
	^ ((parent units elements reject: [:u| (self * u) asModuleElement asArray <= #(0 0)]) sorted: [:u :v| (self * u) asModuleElement asArray reversed <= (self * v) asModuleElement asArray reversed]) first

"
	| a b ra rb |
	a _ moduleElement at: 1.
	b := moduleElement at: 2.
	ra := a \\ 3.
	rb := b \\ 3.
	ra = 0 ifTrue:
		[rb = 1 ifTrue: [^ parent ω squared negated].
		rb = 2 ifTrue: [^ parent ω squared].
		^ parent one].
	ra = 1 ifTrue:
		[rb = 0 ifTrue: [^ parent one negated].
		rb = 1 ifTrue: [^ parent ω].
		^ parent one].
	rb = 2 ifTrue: [^ parent ω negated].
	^ parent one"! !

!EisensteinInteger methodsFor: 'testing' stamp: 'len 10/18/2022 06:19:40'!
isPrimary
	"Answer true if the receiver is congruent to 2 mod 3."
	^ (moduleElement at: 1) \\ 3 = 2 and: [(moduleElement at: 2) \\ 3 = 0]! !

!EisensteinInteger methodsFor: 'testing' stamp: 'len 10/17/2022 12:18:56'!
isPrime
	| a b p s |
	a _ moduleElement at: 1.
	b _ moduleElement at: 2.
	b isZero ifTrue: [^ a \\ 3 = 2 and: [a isPrime]].
	p _ a squared - (a*b) + b squared.
	(p \\ 3 < 2 and: [p isPrime]) ifTrue: [^ true].
	s _ p sqrtFloor.
	^ s squared = p and: [p isPrime]! !

!EisensteinInteger methodsFor: 'testing' stamp: 'len 11/7/2023 11:31:09'!
isReal
	^ self conjugate = self! !

!EisensteinInteger methodsFor: 'testing' stamp: 'len 10/19/2022 10:47:42'!
positive
	"Answer true if the receiver is in the first sextant of the complex plane, taking ω = (1 + √-3)/2."
	^ (moduleElement at: 1) > 0 and: [(moduleElement at: 2) > 0]! !

!GaussianInteger methodsFor: 'accessing' stamp: 'len 3/24/2021 07:45:20'!
imaginary
	^ moduleElement at: 2! !

!GaussianInteger methodsFor: 'accessing' stamp: 'len 3/24/2021 07:45:16'!
real
	^ moduleElement at: 1! !

!GaussianInteger methodsFor: 'operations' stamp: 'len 7/10/2023 17:20:58'!
// anElement
	"Answer the quotient of the Euclidean division of the receiver by the argument."
	| a b c d n x y xF yF xC yC |
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #//].
	anElement isZero ifTrue: [^ DivisibilityError new signalReceiver: self selector: #// argument: anElement].
	a := self real.
	b := self imaginary.
	c := anElement real.
	d := anElement imaginary.
	n := c squared + d squared.
	x := a*c + (b*d) / n.
	y := b*c - (a*d) / n.
	xF := x floor. yF := y floor.
	xC := x ceiling. yC := y ceiling.
	^ {parent real: xF imaginary: yF. parent real: xC imaginary: yF. parent real: xF imaginary: yC. parent real: xC imaginary: yC} detectMin: [:each| (self - (anElement*each)) norm]! !

!GaussianInteger methodsFor: 'operations' stamp: 'len 11/7/2023 11:27:48'!
conjugate
	"Answer the complex conjugate of the receiver."
	^ parent real: self real imaginary: self imaginary negated

"alternatively:
	^ self negated + self trace
"! !

!GaussianInteger methodsFor: 'operations' stamp: 'len 10/16/2022 10:38:32'!
gauge
	"Answer the value of the Euclidean function at the receiver."
	^ self norm! !

!GaussianInteger methodsFor: 'operations' stamp: 'len 3/24/2021 07:47:09'!
inverse
	^ self conjugate * self norm inverse! !

!GaussianInteger methodsFor: 'operations' stamp: 'len 10/16/2022 10:39:03'!
norm
	"Answer the reduced norm of the receiver."
	^ self real squared + self imaginary squared

"	^ (self * self conjugate) asModuleElement at: 1"! !

!GaussianInteger methodsFor: 'operations' stamp: 'len 1/4/2022 18:50:18'!
normalization
	"Answer a unit u such that 'self * u' is a unique choice of associate. See >>normalized."
	"Choose an associate in the first quadrant of the complex plane."
	| a b |
	self isZero ifTrue: [^ parent one].
	a _ self real.
	b _ self imaginary.
	a > 0 ifTrue: [
		b >= 0 ifTrue: [^ parent one].
		^ parent i].
	a < 0 ifTrue: [
		b <= 0 ifTrue: [^ parent one negated].
		^ parent i negated].
	^ b < 0 ifTrue: [parent i] ifFalse: [parent i negated]! !

!GaussianInteger methodsFor: 'operations' stamp: 'len 3/24/2021 07:47:27'!
trace
	"Answer the reduced trace of the receiver."
	^ (self + self conjugate) asModuleElement at: 1! !

!GaussianInteger methodsFor: 'testing' stamp: 'len 5/9/2023 13:15:49'!
isPrime
	"A Gaussian integer a+bi is prime if either:
	- one of a, b is zero and absolute value of the other is prime congruent to 3 mod 4;
	- both are nonzero and a^2 + b^2 is prime."
	| a b |
	a _ self real.
	b _ self imaginary.
	a = 0 ifTrue: [^ b \\ 4 = 3 and: [b abs isPrime]].
	b = 0 ifTrue: [^ a \\ 4 = 3 and: [a abs isPrime]].
	^ (a squared + (b \\ 2)) isPrime! !

!GaussianInteger methodsFor: 'testing' stamp: 'len 11/7/2023 11:30:20'!
isReal
	^ self imaginary isZero! !

!GaussianInteger methodsFor: 'testing' stamp: 'len 1/5/2022 09:57:39'!
isUnit
	"All the units are: 1, -1, i, -i."
	^ (self real abs = 1 and: [self imaginary = 0]) or: [self real = 0 and: [self imaginary abs = 1]]! !

!QuadraticInteger methodsFor: 'operations' stamp: 'len 4/3/2024 08:58:44'!
normalization
	"Answer a unit u such that 'self * u' is a unique choice of associate. See >>normalized."
	self isZero ifTrue: [^ parent one].
	self flag: #fixme. "there should be a more efficient way"
	^ ((parent units elements reject: [:u| (self * u) asModuleElement asArray <= #(0 0)]) sorted: [:u :v| (self * u) asModuleElement asArray reversed <= (self * v) asModuleElement asArray reversed]) first! !

!QuadraticInteger methodsFor: 'testing' stamp: 'len 8/5/2021 08:42:38'!
isPrime
	"The norm of a (quadratic) prime is a (rational) integer prime or a prime squared.
	If the norm is a prime, the number is prime."
	| norm factors |
	(norm _ self norm) isPrime ifTrue: [^ true].
	factors _ norm factorization.
	(factors size <= 2 and: [factors asSet size = 1]) ifFalse: [^ false].
	self notYetImplemented! !

!QuadraticInteger methodsFor: 'testing' stamp: 'len 10/16/2022 10:46:48'!
isUnit
	^ super isUnit
"there's also equations, a + bw is a unit if:
	a^2 - Db^2 = 1 for D = 2,3 mod 4
	(a + b/2)^2 - (1/4)Db^2 = 1 for D = 1 mod 4"! !

!GroupAlgebraElement methodsFor: 'operations' stamp: 'len 6/16/2024 10:07:28'!
* anElement
	| groupElementToIndex indexToGroupElement result |
	(anElement isInteger or: [self parent scalars includes: anElement])
		ifTrue: [^ self class parent: parent moduleElement: moduleElement * anElement].
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #*].
	indexToGroupElement := parent propertyAt: #indexToGroupElement.
	groupElementToIndex := parent propertyAt: #groupElementToIndex.
	self flag: #fixme."this assumes FreeModule>>zero returns a copy each time"	
	result := parent asModule zero.
	moduleElement withIndexDo: [:a :i|
		a isZero ifFalse:
			[| gi |
			gi := indexToGroupElement at: i.
			anElement asModuleElement withIndexDo: [:b :j|
				b isZero ifFalse:
					[| gj |
					gj := indexToGroupElement at: j.
					result at: (groupElementToIndex at: gi * gj) add: a*b]]]].
	^ self class parent: parent moduleElement: result! !

!GroupAlgebraElement methodsFor: 'operations' stamp: 'len 6/16/2024 10:07:48'!
conjugate
	"See also GroupAlgebra>>#involution."
	| groupElementToIndex indexToGroupElement result |
	indexToGroupElement := parent propertyAt: #indexToGroupElement.
	groupElementToIndex := parent propertyAt: #groupElementToIndex.
	self flag: #fixme. "this assumes FreeModule>>zero returns a copy each time"
	result := parent asModule zero.
	moduleElement withIndexDo: [:a :i|
		a isZero ifFalse:
			[result at: (groupElementToIndex at: (indexToGroupElement at: i) inverse) put: a]].
	^ self class parent: parent moduleElement: result! !

!Multivector methodsFor: 'accessing' stamp: 'len 7/20/2020 10:21:38'!
grade: anInteger
	"Answer the projection on grade anInteger. This is the homogeneous component of grade anInteger (an anInteger-vector)."
	| zero |
	zero _ parent scalars zero.
	^ self class parent: parent moduleElement: (moduleElement withIndexCollect: [:each :i| (i - 1) bitCount = anInteger ifTrue: [each] ifFalse: [zero]])! !

!Multivector methodsFor: 'converting' stamp: 'len 5/6/2023 15:21:19'!
asPolynomial
	| R answer |
	R _ self parent scalars polynomialsIn: ((1 to: self parent degree) collect: [:i| 'e', i printStringSubscript]).
	answer _ R zero.
	moduleElement withIndexDo: [:each :i| | term |
		term _ R !! each.
		1 to: parent degree do: [:j| (i-1 bitAt: j) = 1 ifTrue: [term _ term * (R x: j)]].
		answer _ answer + term].
	^ answer! !

!Multivector methodsFor: 'converting' stamp: 'len 7/14/2020 10:04:26'!
asScalar
	self isScalar ifFalse: [^ self error: 'not a scalar element'].
	^ moduleElement at: 1! !

!Multivector methodsFor: 'converting' stamp: 'len 7/22/2020 09:39:27'!
asVector
	| B answer |
	self isVector ifFalse: [^ self error: 'not a vector element'].
	B _ parent orthogonalBasis.
	answer _ parent space zero.
	1 to: parent degree do: [:i| answer _ (B at: i) * (moduleElement at: 1 << (i-1) + 1) + answer].
	^ answer! !

!Multivector methodsFor: 'operations' stamp: 'len 7/22/2020 15:56:55'!
* anElement
	"Answer the geometric product of the receiver with the argument.
	This is the main product operation of the Clifford algebra."
	(anElement isInteger or: [self parent scalars includes: anElement])
		ifTrue: [^ self class parent: parent moduleElement: moduleElement * anElement].
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #*].
	^ self product: anElement condition: [:i :j| true]! !

!Multivector methodsFor: 'operations' stamp: 'len 8/10/2022 10:29:01'!
|· anElement
	"Answer the right contraction (or right inner or interior product) of the receiver with the argument."
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #'|·'].
	^ self product: anElement condition: [:i :j| (i bitAnd: j) = j]! !

!Multivector methodsFor: 'operations' stamp: 'len 7/22/2020 15:58:27'!
· anElement
	"Answer the dot product of the receiver with the argument."
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #·].
	^ self product: anElement condition: [:i :j| i = j] "this can be optimized, lots of unnecesary iterations here"! !

!Multivector methodsFor: 'operations' stamp: 'len 8/10/2022 10:27:52'!
·| anElement
	"Answer the left contraction (or left inner or interior product) of the receiver with the argument."
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #'·|'].
	^ self product: anElement condition: [:i :j| (i bitAnd: j) = i]! !

!Multivector methodsFor: 'operations' stamp: 'len 7/22/2020 15:59:30'!
conjugate
	"Answer the Clifford conjugate of the receiver."
	^ self reflection transpose! !

!Multivector methodsFor: 'operations' stamp: 'len 7/20/2020 06:34:01'!
dual
	^ self * parent pseudoscalarInverse! !

!Multivector methodsFor: 'operations' stamp: 'len 12/20/2021 13:11:37'!
product: anElement condition: conditionBlock
	| coordinates table |
	coordinates _ parent asModule zero.
	table _ parent propertyAt: #basisMultiplicationTable.
	self asModuleElement withSupportDo: [:x :i|
		anElement asModuleElement withSupportDo: [:y :j|
			| product |
			(conditionBlock value: i-1 value: j-1)
				ifTrue:
					[product _ (table at: i) at: j.
					coordinates at: product first add: x * y * product second]]].
	^ self class parent: parent moduleElement: coordinates! !

!Multivector methodsFor: 'operations' stamp: 'len 6/13/2024 14:08:25'!
reflection
	"Answer the image of the reflection automorphism.
	This is also called grade involution or the (first) main involution, and it is denoted by a superscript star."
	^ self class parent: parent moduleElement: (moduleElement withIndexCollect: [:each :i| (i-1) bitParity = 1 ifTrue: [each negated] ifFalse: [each]])! !

!Multivector methodsFor: 'operations' stamp: 'len 6/13/2024 14:08:37'!
transpose
	"Answer the reversion of the receiver.
	This is also called the second main involution or the principal antiautomorphism, and it is denoted by a superscript dagger."
	^ self class parent: parent moduleElement: (moduleElement withIndexCollect: [:each :i| ((i-1) bitCount choose: 2) odd ifTrue: [each negated] ifFalse: [each]])! !

!Multivector methodsFor: 'operations' stamp: 'len 8/12/2022 13:01:05'!
∧ anElement
	"Answer the exterior product (or outer product, or wedge product) of the receiver with the argument.
	This is the product of the exterior algebra contained in the parent of the receiver."
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #∧].
	^ self product: anElement condition: [:i :j| (i bitAnd: j) = 0]! !

!Multivector methodsFor: 'operations' stamp: 'len 8/12/2022 13:00:35'!
∨ anElement
	"Answer the regressive product of the receiver with the argument.
	This is the dual of the exterior product."
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #∨].
	^ (self dual ∧ anElement dual) * parent pseudoscalar! !

!Multivector methodsFor: 'printing' stamp: 'len 7/5/2020 08:52:03'!
printOn: aStream
	aStream print: self asPolynomial! !

!Multivector methodsFor: 'testing' stamp: 'len 7/22/2020 09:27:21'!
isBivector
	moduleElement supportDo: [:i| (i-1) bitCount = 2 ifFalse: [^ false]].
	^ true! !

!Multivector methodsFor: 'testing' stamp: 'len 7/6/2020 07:34:35'!
isEven
	^ self parent evenSubalgebra contains: self! !

!Multivector methodsFor: 'testing' stamp: 'len 7/14/2021 16:53:37'!
isParavector
	"A paravector is the sum of a vector and a scalar."
	^ (self parent degree + 2 to: self parent rank) allSatisfy: [:i| (moduleElement at: i) isZero]! !

!Multivector methodsFor: 'testing' stamp: 'len 7/14/2021 16:53:43'!
isPseudoscalar
	moduleElement supportDo: [:i| i = parent rank ifFalse: [^ false]].
	^ true! !

!Multivector methodsFor: 'testing' stamp: 'len 7/22/2020 09:40:55'!
isPseudovector
	| k |
	k _ parent degree - 1.
	moduleElement supportDo: [:i| (i-1) bitCount = k ifFalse: [^ false]].
	^ true! !

!Multivector methodsFor: 'testing' stamp: 'len 7/22/2020 09:41:18'!
isScalar
	moduleElement supportDo: [:i| i = 1 ifFalse: [^ false]].
	^ true! !

!Multivector methodsFor: 'testing' stamp: 'len 7/22/2020 09:26:56'!
isVector
	moduleElement supportDo: [:i| (i-1) bitCount = 1 ifFalse: [^ false]].
	^ true! !

!Quaternion methodsFor: 'accessing' stamp: 'len 4/30/2021 12:42:19'!
imaginary
	"Answer the imaginary part of the receiver."
	^ self - self real! !

!Quaternion methodsFor: 'accessing' stamp: 'len 4/30/2021 12:43:14'!
real
	"Answer the real part of the receiver."
	^ self parent one * (moduleElement at: 1)! !

!Quaternion methodsFor: 'converting' stamp: 'len 7/14/2020 10:03:39'!
asScalar
	self isScalar ifFalse: [^ self error: 'not a scalar element'].
	^ moduleElement at: 1! !

!Quaternion methodsFor: 'operations' stamp: 'len 11/17/2023 14:23:16'!
conjugate
	"Answer the conjugate of the receiver, such that the reduced trace is the conjugate plus the receiver, and the reduced norm is the conjugate times the receiver."
	^ self class parent: parent moduleElement: (moduleElement withIndexCollect: [:each :i| i=1 ifTrue: [each] ifFalse: [each negated]])

"alternatively:
	^ self negated + self trace
"! !

!Quaternion methodsFor: 'operations' stamp: 'len 7/16/2020 19:02:30'!
inverse
	^ self conjugate * self norm inverse! !

!Quaternion methodsFor: 'operations' stamp: 'len 7/14/2020 10:05:46'!
norm
	"Answer the reduced norm of the receiver."
	^ (self * self conjugate) asModuleElement at: 1! !

!Quaternion methodsFor: 'operations' stamp: 'len 7/14/2020 10:05:53'!
trace
	"Answer the reduced trace of the receiver."
	^ (self + self conjugate) asModuleElement at: 1! !

!Quaternion methodsFor: 'printing' stamp: 'len 7/14/2020 10:04:07'!
printOn: aStream
	| P f |
	P _ self parent scalars polynomialsIn: #(i j k) ordering: #llex.
	f _ P constant: (moduleElement at: 1).
	2 to: 4 do: [:i| f _ (P x: i-1) * (moduleElement at: i) + f].
	f printOn: aStream! !

!Quaternion methodsFor: 'testing' stamp: 'len 6/11/2020 19:45:58'!
isIsotropic
	^ self isZero not and: [self norm isZero]! !

!Quaternion methodsFor: 'testing' stamp: 'len 7/14/2020 10:03:44'!
isPure
	^ (moduleElement at: 1) isZero! !

!Quaternion methodsFor: 'testing' stamp: 'len 7/14/2020 10:03:49'!
isScalar
	^ (2 to: 4) allSatisfy: [:i| (moduleElement at: i) isZero]! !

!FreePolynomial methodsFor: 'accessing' stamp: 'len 4/28/2022 06:57:10'!
at: aWord
	^ coefficients at: aWord ifAbsent: [self scalars zero]! !

!FreePolynomial methodsFor: 'accessing' stamp: 'len 4/28/2022 06:58:34'!
coefficients
	^ coefficients! !

!FreePolynomial methodsFor: 'accessing' stamp: 'len 6/29/2022 06:36:19'!
degree
	"Answer the total degree of the receiver."
	self isZero ifTrue: [^ Infinity negative].
	^ self monomials max: [:each| each length]! !

!FreePolynomial methodsFor: 'accessing' stamp: 'len 6/29/2022 06:36:25'!
independentCoefficient
	^ self at: parent monomials identity! !

!FreePolynomial methodsFor: 'accessing' stamp: 'len 4/28/2022 06:57:33'!
initialCoefficient
	^ coefficients isEmpty ifTrue: [self scalars zero] ifFalse: [coefficients first]! !

!FreePolynomial methodsFor: 'accessing' stamp: 'len 6/29/2022 06:39:25'!
leadingCoefficient
	^ self at: self leadingMonomial! !

!FreePolynomial methodsFor: 'accessing' stamp: 'len 6/29/2022 07:07:15'!
leadingMonomial
	^ coefficients isEmpty ifFalse: [coefficients lastKey]! !

!FreePolynomial methodsFor: 'accessing' stamp: 'len 6/29/2022 06:39:39'!
monomials
	"Answer the collection of words effectively present in this polynomial (with nonzero coefficient). This is called the 'support' of a polynomial."
	^ Iterator on: self performing: #monomialsDo:! !

!FreePolynomial methodsFor: 'accessing' stamp: 'len 1/10/2018 20:07:45'!
one
	^ self parent one! !

!FreePolynomial methodsFor: 'accessing' stamp: 'len 4/28/2022 07:58:56'!
parent
	^ parent! !

!FreePolynomial methodsFor: 'accessing' stamp: 'len 4/28/2022 06:57:19'!
scalars
	^ parent scalars! !

!FreePolynomial methodsFor: 'accessing' stamp: 'len 6/29/2022 13:11:40'!
tail
	self isZero ifTrue: [^ self].
	^ self class coefficients: coefficients allButLast parent: parent! !

!FreePolynomial methodsFor: 'comparing' stamp: 'len 4/29/2022 10:14:01'!
= anObject
	^ self == anObject or: [self class = anObject class and: [coefficients = anObject coefficients]]! !

!FreePolynomial methodsFor: 'comparing' stamp: 'len 4/29/2022 10:13:49'!
hash
	^ coefficients hash! !

!FreePolynomial methodsFor: 'copying' stamp: 'len 12/20/2022 09:32:53'!
postCopy
	super postCopy.
	coefficients _ coefficients copy! !

!FreePolynomial methodsFor: 'enumerating' stamp: 'len 4/28/2022 06:59:02'!
associationsDo: aBlock
	coefficients associationsDo: aBlock! !

!FreePolynomial methodsFor: 'enumerating' stamp: 'len 6/29/2022 06:39:57'!
monomialsDo: aBlock
	"Iterate over the support of the receiver, i.e. the words with nonzero coefficient."
	coefficients keysDo: aBlock! !

!FreePolynomial methodsFor: 'operations' stamp: 'len 5/2/2022 12:23:43'!
* anElement
	(anElement isInteger or: [self scalars includes: anElement])
		ifTrue: [^ self class coefficients: coefficients * anElement parent: parent].
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #*].
	anElement isConstant ifTrue: [^ self class coefficients: coefficients * anElement leadingCoefficient parent: parent].
	^ self class coefficients: (coefficients convolution: anElement coefficients) parent: parent! !

!FreePolynomial methodsFor: 'operations' stamp: 'len 4/28/2022 06:53:24'!
+ anElement
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #+].
	^ self class coefficients: coefficients + anElement coefficients parent: parent! !

!FreePolynomial methodsFor: 'operations' stamp: 'len 4/28/2022 06:53:34'!
- anElement
	(parent includes: anElement) ifFalse: [^ self adapt: anElement andSend: #-].
	^ self class coefficients: coefficients - anElement coefficients parent: parent! !

!FreePolynomial methodsFor: 'operations' stamp: 'len 5/5/2024 07:19:53'!
apply: aMap
	"Answer a new polynomial with coefficients obtainted by applying aMap to the coefficients of the receiver.
	If aMap is a block we assume the parent doesn't change, i.e. the block must evaluate to values within the scalars ring of the receiver."

	^ self class coefficients: (coefficients apply: aMap) parent: (aMap isBlock ifTrue: [parent] ifFalse: [parent over: aMap codomain])! !

!FreePolynomial methodsFor: 'operations' stamp: 'len 4/28/2022 06:53:41'!
negated
	^ self class coefficients: coefficients negated parent: parent! !

!FreePolynomial methodsFor: 'printing' stamp: 'len 12/1/2023 16:49:00'!
printCoefficient: coefficient word: w on: aStream
	| c |
	c := coefficient.
	(c isOne not or: [w length = 0]) ifTrue:
		[c printText first = $-
			ifTrue: [aStream nextPut: $-. c := c negated].
		(w length = 0 or: [c printText asString allSatisfy: [:each| each isAlphaNumeric or: ['{}()/' includes: each]]])
			ifTrue: [aStream print: c]
			ifFalse: [aStream nextPut: $(; print: c; nextPut: $)]].
	w length = 0 ifFalse: [aStream print: w]! !

!FreePolynomial methodsFor: 'printing' stamp: 'len 12/3/2023 13:56:53'!
printOn: aStream
	| words leadingWord c |
	(self scalars isKindOf: ModularIntegerRing)
		ifTrue: [aStream print: self lift. ^ self].
	self isConstant ifTrue: [aStream print: self leadingCoefficient. ^ self].
	words := self monomials sorted reversed.
	c := self at: (leadingWord := words first).
	c printText first = $-
		ifTrue: [c := c negated. aStream nextPut: $-].
	self printCoefficient: c word: leadingWord on: aStream.
	words allButFirstDo: [:w|
		c := self at: w.
		c printText first = $-
			ifTrue: [aStream nextPutAll: ' - '. c := c negated]
			ifFalse: [aStream nextPutAll: ' + '].
		self printCoefficient: c word: w on: aStream]! !

!FreePolynomial methodsFor: 'testing' stamp: 'len 6/29/2022 06:36:31'!
isConstant
	^ self monomials allSatisfy: [:each| each isIdentity]! !

!FreePolynomial methodsFor: 'testing' stamp: 'len 1/10/2018 16:57:08'!
isStandard
	"Answer true if the receiver is a standard polynomial, i.e. all its monomials are standard words."
	self monomialsDo: [:each| each isStandard ifFalse: [^ false]].
	^ true! !

!FreePolynomial methodsFor: 'testing' stamp: 'len 7/1/2022 06:44:36'!
isUnit
	^ self isConstant and: [self independentCoefficient isUnit]! !

!FreePolynomial methodsFor: 'testing' stamp: 'len 4/28/2022 07:04:29'!
isZero
	^ coefficients isEmpty! !

!FreePolynomial methodsFor: 'private' stamp: 'len 4/28/2022 07:06:49'!
coefficients: aCollection parent: aFreeAlgebra
	coefficients _ aCollection.
	parent _ aFreeAlgebra! !

!FreePolynomial class methodsFor: 'instance creation' stamp: 'len 8/21/2022 08:25:59'!
coefficients: aSortedDictionary parent: aFreeAlgebra
	^ self basicNew coefficients: aSortedDictionary parent: aFreeAlgebra! !

!FractionalIdeal methodsFor: 'accessing' stamp: 'len 5/3/2020 21:06:35'!
denominator
	^ denominator! !

!FractionalIdeal methodsFor: 'accessing' stamp: 'len 5/3/2020 21:09:15'!
denominatorIdeal
	"Answer the denominator ideal of the receiver, which is an integral ideal."
	^ self scalars * denominator
"
	^ (self + self ambient oneIdeal) inverse
"! !

!FractionalIdeal methodsFor: 'accessing' stamp: 'len 5/3/2020 21:10:54'!
generators
	| K denominatorInverse |
	K _ self scalars fractions.
	denominatorInverse _ (K !! denominator) inverse.
	^ numerator generators collect: [:each| (K !! each) * denominatorInverse]! !

!FractionalIdeal methodsFor: 'accessing' stamp: 'len 12/4/2023 20:21:36'!
identity
	^ self parent identity! !

!FractionalIdeal methodsFor: 'accessing' stamp: 'len 5/3/2020 21:06:11'!
numerator
	"Answer the numerator ideal of the receiver, which is an integral ideal."
	^ numerator! !

!FractionalIdeal methodsFor: 'accessing' stamp: 'len 5/3/2020 21:09:07'!
scalars
	^ numerator scalars! !

!FractionalIdeal methodsFor: 'comparing' stamp: 'len 1/7/2022 14:02:40'!
= anObject
	^ (anObject isKindOf: FractionalIdeal) and: [numerator * anObject denominator = (anObject numerator * denominator)]! !

!FractionalIdeal methodsFor: 'comparing' stamp: 'len 1/7/2022 14:02:48'!
hash
	^ 0! !

!FractionalIdeal methodsFor: 'operations' stamp: 'len 6/3/2023 12:19:47'!
* aFractionalIdeal
	self flag: #fixme. "this is not unique, should reduce denominator"
	^ self class numerator: numerator * aFractionalIdeal numerator denominator: denominator * aFractionalIdeal denominator! !

!FractionalIdeal methodsFor: 'operations' stamp: 'len 1/7/2022 13:59:04'!
+ aFractionalIdeal
	| d |
	d _ self denominator lcm: aFractionalIdeal denominator.
	^ self class numerator: self numerator * d + (aFractionalIdeal numerator * d) denominator: d! !

!FractionalIdeal methodsFor: 'operations' stamp: 'len 1/7/2022 14:01:04'!
^ anInteger
	^ self class numerator: self numerator ^ anInteger denominator: self denominator ^ anInteger! !

!FractionalIdeal methodsFor: 'operations' stamp: 'len 12/4/2023 20:29:15'!
· anElement
	^ self * anElement! !

!FractionalIdeal methodsFor: 'operations' stamp: 'len 12/4/2023 20:24:31'!
squared
	^ self * self! !

!FractionalIdeal methodsFor: 'printing' stamp: 'len 7/6/2023 14:59:08'!
printOn: aStream
	aStream withAngleBrackets: [:aStream2|
		(self generators "asSortedCollection: [:a :b| a printString <= b printString]")
			do: [:each| aStream2 print: each] separatedBy: [aStream2 nextPutAll: ', ']]! !

!FractionalIdeal methodsFor: 'testing' stamp: 'len 1/7/2022 13:56:47'!
contains: anElement
	self isTrivial ifTrue: [^ anElement isZero].
	^ self numerator contains: anElement * self denominator! !

!FractionalIdeal methodsFor: 'testing' stamp: 'len 5/3/2020 21:08:58'!
includes: anObject
	^ (self scalars includes: anObject) and: [self contains: anObject]! !

!FractionalIdeal methodsFor: 'testing' stamp: 'len 12/4/2023 20:31:51'!
isIdentity
	^ self = self identity! !

!FractionalIdeal methodsFor: 'testing' stamp: 'len 1/7/2022 13:56:26'!
isIntegral
	^ denominator isOne! !

!FractionalIdeal methodsFor: 'testing' stamp: 'len 7/15/2021 10:49:29'!
isMaximal
	^ self isZero not and: [self isPrime]! !

!FractionalIdeal methodsFor: 'testing' stamp: 'len 8/5/2021 08:38:40'!
isPrime
	^ self factorization size = 1! !

!FractionalIdeal methodsFor: 'testing' stamp: 'len 1/4/2022 08:53:06'!
isPrincipal
	"Answer true if the receiver is generated by a single element."
	self generators size <= 1 ifTrue: [^ true].
	self scalars isPIR ifTrue: [^ true].
	^ self propertyAt: #isPrincipal! !

!FractionalIdeal methodsFor: 'testing' stamp: 'len 6/26/2019 03:53:25'!
isTrivial
	^ self numerator isTrivial! !

!FractionalIdeal methodsFor: 'private' stamp: 'len 5/3/2020 21:12:34'!
numerator: anIdeal denominator: anElement
	numerator _ anIdeal.
	denominator _ anElement! !

!FractionalIdeal class methodsFor: 'instance creation' stamp: 'len 5/3/2020 21:12:54'!
numerator: anIdeal denominator: anElement
	^ self new numerator: anIdeal denominator: anElement! !

!ModuleCoset methodsFor: 'accessing' stamp: 'len 7/8/2022 08:18:58'!
degree
	^ representative degree! !

!ModuleCoset methodsFor: 'accessing' stamp: 'len 3/18/2020 17:40:47'!
parent
	^ parent! !

!ModuleCoset methodsFor: 'accessing' stamp: 'len 6/4/2016 04:18'!
representative
	^ representative! !

!ModuleCoset methodsFor: 'accessing' stamp: 'len 4/6/2024 06:59:00'!
zero
	^ self parent zero! !

!ModuleCoset methodsFor: 'comparing' stamp: 'len 6/5/2022 13:06:25'!
= anObject
	(self class = anObject class and: [parent = anObject parent]) ifFalse: [^ false].
	^ self contains: anObject representative
"	^ parent scalars hasCanonicalReduction
		ifTrue: [representative = anObject representative]
		ifFalse: [self contains: anObject representative]"! !

!ModuleCoset methodsFor: 'comparing' stamp: 'len 6/5/2022 13:06:06'!
hash
	^ parent hash
"	^ parent base hasCanonicalReduction ifTrue: [representative hash] ifFalse: [parent hash]"! !

!ModuleCoset methodsFor: 'converting' stamp: 'len 4/6/2024 06:59:22'!
adaptToFraction: rcvr andSend: selector
	selector = #* ifTrue: [^ self * rcvr].
	^ super adaptToFraction: rcvr andSend: selector! !

!ModuleCoset methodsFor: 'converting' stamp: 'len 4/6/2024 06:59:32'!
adaptToInteger: rcvr andSend: selector
	selector = #* ifTrue: [^ self * rcvr].
	^ super adaptToInteger: rcvr andSend: selector! !

!ModuleCoset methodsFor: 'enumerating' stamp: 'len 3/18/2020 17:36:16'!
do: aBlock
	parent relations do: [:each| aBlock value: each + representative]! !

!ModuleCoset methodsFor: 'operations' stamp: 'len 3/18/2020 17:30:02'!
* aScalar
	^ parent project: representative * aScalar! !

!ModuleCoset methodsFor: 'operations' stamp: 'len 3/18/2020 17:34:25'!
+ anElement
	(parent includes: anElement) ifFalse: [^ self  adapt: anElement andSend: #+].
	^ parent project: representative + anElement representative! !

!ModuleCoset methodsFor: 'operations' stamp: 'len 4/6/2024 06:56:03'!
- anElement
	(parent includes: anElement) ifFalse: [^ self  adapt: anElement andSend: #-].
	^ parent project: representative - anElement representative! !

!ModuleCoset methodsFor: 'operations' stamp: 'len 4/6/2024 06:57:38'!
/ aScalar
	^ self * (parent scalars !! aScalar) inverse! !

!ModuleCoset methodsFor: 'operations' stamp: 'len 3/18/2020 17:35:26'!
negated
	^ parent project: representative negated! !

!ModuleCoset methodsFor: 'operations' stamp: 'len 4/6/2024 06:58:28'!
order
	^ self parent orderOf: self! !

!ModuleCoset methodsFor: 'operations' stamp: 'len 7/1/2024 10:56:36'!
◃ anObject
	^ self * anObject! !

!ModuleCoset methodsFor: 'printing' stamp: 'len 3/18/2020 17:22:25'!
printOn: aStream
	aStream print: representative! !

!ModuleCoset methodsFor: 'random' stamp: 'len 3/18/2020 17:21:59'!
atRandom: aRandom
	^ (parent relations atRandom: aRandom) + representative! !

!ModuleCoset methodsFor: 'random' stamp: 'len 3/18/2020 17:22:06'!
atRandom: aRandom bits: bitSize
	^ (parent relations atRandom: aRandom bits: bitSize) + representative! !

!ModuleCoset methodsFor: 'testing' stamp: 'len 3/18/2020 17:17:36'!
contains: anObject
	^ parent relations contains: anObject - representative! !

!ModuleCoset methodsFor: 'testing' stamp: 'len 6/10/2022 11:52:23'!
includes: anObject
	^ (parent cover includes: anObject) and: [self contains: anObject]! !

!ModuleCoset methodsFor: 'testing' stamp: 'len 6/5/2022 13:06:45'!
isZero
	^ representative isZero! !

!ModuleCoset methodsFor: 'private' stamp: 'len 6/16/2023 18:19:52'!
representative: aTuple parent: aQuotientModule
	representative := aTuple.
	parent := aQuotientModule! !

!ModuleCoset class methodsFor: 'instance creation' stamp: 'len 6/16/2023 18:20:10'!
representative: aTuple parent: aQuotientModule
	^ self new representative: aTuple parent: aQuotientModule! !

!Tuple methodsFor: 'accessing' stamp: 'len 5/5/2023 00:12:55'!
at: anInteger
	anInteger isInteger ifFalse: [^ (coefficients at: anInteger position) at: anInteger monomial].
	^ coefficients at: anInteger! !

!Tuple methodsFor: 'accessing' stamp: 'len 5/5/2023 00:21:04'!
at: anInteger add: anElement
	^ coefficients at: anInteger add: anElement! !

!Tuple methodsFor: 'accessing' stamp: 'len 5/5/2023 00:13:04'!
at: anInteger ifAbsent: aBlock
	anInteger isInteger ifFalse: [^ (coefficients at: anInteger position ifAbsent: [^aBlock value]) at: anInteger monomial ifAbsent: aBlock].
	^ coefficients at: anInteger ifAbsent: aBlock! !

!Tuple methodsFor: 'accessing' stamp: 'len 5/5/2023 00:13:21'!
at: anInteger put: anObject
	^ coefficients at: anInteger put: self scalars !! anObject! !

!Tuple methodsFor: 'accessing' stamp: 'len 10/30/2023 19:04:39'!
denominator
	"If the coefficients ring is a localization, answer the LCM of the denominators of the coefficients."
	self scalars isLocalization ifFalse: [^ self scalars one].
	^ coefficients inject: self scalars numerators one into: [:d :each| each denominator lcm: d]! !

!Tuple methodsFor: 'accessing' stamp: 'len 5/6/2023 17:54:22'!
first
	^ coefficients first! !

!Tuple methodsFor: 'accessing' stamp: 'len 5/5/2023 16:46:33'!
firstNonzeroIndex
	"Answer the index of the first nonzero entry, or nil."
	^ coefficients firstNonzeroIndex! !

!Tuple methodsFor: 'accessing' stamp: 'len 5/6/2023 17:54:27'!
last
	^ coefficients last! !

!Tuple methodsFor: 'accessing' stamp: 'len 5/5/2023 17:06:11'!
lastNonzeroIndex
	"Answer the index of the last nonzero entry, or nil."
	^ coefficients lastNonzeroIndex! !

!Tuple methodsFor: 'accessing' stamp: 'len 5/15/2023 17:32:49'!
lift
	"If the coefficients ring is a quotient R/I, answer a representative of the receiver over R."
	parent scalars cover = ℤ ifTrue: [^ parent lift coefficients: coefficients lift].
	^ parent lift fill: [:i| (coefficients at: i) lift]! !

!Tuple methodsFor: 'accessing' stamp: 'len 12/23/2023 15:24:59'!
numerator
	"If the coefficients ring is a localization, answer the product of the receiver by the LCM of the denominators of the coefficients. The answer is a tuple over the ring of numerators of the localization ring."
	| d |
	self scalars isLocalization ifFalse: [^ self].
	d := self scalars !! self denominator.
	^ parent numerators coefficients: (self scalars numerators new: coefficients size fill: [:i| ((coefficients at: i) * d) numerator])! !

!Tuple methodsFor: 'accessing' stamp: 'len 5/5/2023 00:13:36'!
scalars
	^ parent scalars! !

!Tuple methodsFor: 'accessing' stamp: 'len 5/5/2023 00:22:18'!
size
	^ parent rank! !

!Tuple methodsFor: 'accessing' stamp: 'len 5/5/2023 00:11:07'!
x
	^ self at: 1! !

!Tuple methodsFor: 'accessing' stamp: 'len 5/5/2023 00:11:07'!
y
	^ self at: 2! !

!Tuple methodsFor: 'accessing' stamp: 'len 5/5/2023 00:11:07'!
z
	^ self at: 3! !

!Tuple methodsFor: 'accessing' stamp: 'len 6/6/2023 08:54:47'!
zero
	^ self class coefficients: (self scalars zeros: self size) parent: parent! !

!Tuple methodsFor: 'comparing' stamp: 'len 5/5/2023 00:12:21'!
= anObject
	^ self class = anObject class and: [coefficients = anObject coefficients]! !

!Tuple methodsFor: 'comparing' stamp: 'len 4/1/2024 14:43:51'!
~ aTuple
	"Answer true if the receiver and the argument are equivalent as homogeneous tuples."
	| depth |
	(depth := self lastNonzeroIndex) ~= aTuple lastNonzeroIndex ifTrue: [^ false].
	depth isNil ifTrue: [^ true].
	self scalars isIntegralDomain ifTrue:
		[| x y |
		x := self at: depth.
		y := aTuple at: depth.
		1 to: depth do: [:i| (self at: i) * y = ((aTuple at: i) * x) ifFalse: [^ false]].
		^ true].
	"Over a ring with standard bases we compare the standard bases:"
	(self scalars hasCanonicalBases and: [self scalars size > 255])
		ifTrue: [^ self asMatrix basis = aTuple asMatrix basis].
	"In a general ring we have to check all units:"
	^ self scalars units elements anySatisfy: [:any| self * any = aTuple]! !

!Tuple methodsFor: 'comparing' stamp: 'len 5/5/2023 00:12:30'!
hash
	^ coefficients hash! !

!Tuple methodsFor: 'comparing' stamp: 'len 5/5/2023 00:11:07'!
⊥ aTuple
	"Answer true if the receiver and the argument are orthogonal."
	^ (self · aTuple) isZero! !

!Tuple methodsFor: 'converting' stamp: 'len 4/6/2024 06:33:53'!
adaptToFraction: rcvr andSend: selector
	selector = #* ifTrue: [^ self * rcvr].
	^ super adaptToFraction: rcvr andSend: selector! !

!Tuple methodsFor: 'converting' stamp: 'len 4/6/2024 06:33:58'!
adaptToInteger: rcvr andSend: selector
	selector = #* ifTrue: [^ self * rcvr].
	^ super adaptToInteger: rcvr andSend: selector! !

!Tuple methodsFor: 'converting' stamp: 'len 5/5/2023 18:28:26'!
asArray
	^ coefficients asArray! !

!Tuple methodsFor: 'converting' stamp: 'len 5/5/2023 00:11:07'!
asMatrix
	"Tuples are equivalent to columns."
	^ Matrix columns: {self}! !

!Tuple methodsFor: 'converting' stamp: 'len 5/5/2023 00:11:07'!
asRowMatrix
	^ Matrix rows: {self}! !

!Tuple methodsFor: 'converting' stamp: 'len 5/5/2023 00:11:07'!
asTuple
	^ self! !

!Tuple methodsFor: 'converting' stamp: 'len 5/5/2023 17:21:41'!
over: aRing
	self flag: #deprecated.
	self scalars = aRing ifFalse: [^ (parent over: aRing) elementAt: coefficients]! !

!Tuple methodsFor: 'copying' stamp: 'len 5/5/2023 17:38:54'!
, anObject
	(anObject isTuple and: [self scalars = anObject scalars])
		ifTrue: [^ self class coefficients: coefficients, anObject coefficients parent: parent ⊕ anObject parent].
	^ self class coefficients: coefficients, (self scalars !! anObject) parent: self scalars ^ (self size + 1)! !

!Tuple methodsFor: 'copying' stamp: 'len 5/5/2023 16:55:09'!
copyFrom: start to: stop
	^ self class coefficients: (coefficients copyFrom: start to: stop) parent: (parent copyFrom: start to: stop) ! !

!Tuple methodsFor: 'copying' stamp: 'len 5/5/2023 00:14:26'!
postCopy
	super postCopy.
	coefficients _ coefficients copy! !

!Tuple methodsFor: 'enumerating' stamp: 'len 5/5/2024 07:20:07'!
apply: aMap
	"Answer a new tuple with coefficients obtainted by applying aMap to the coefficients of the receiver.
	If aMap is a block we assume the parent doesn't change, i.e. the block must evaluate to values within the scalars ring of the receiver."

	^ self class coefficients: (coefficients apply: aMap) parent: (aMap isBlock ifTrue: [parent] ifFalse: [parent over: aMap codomain])! !

!Tuple methodsFor: 'enumerating' stamp: 'len 5/5/2023 17:43:59'!
collect: aBlock
	^ self class coefficients: (self scalars new: self size fill: [:i| aBlock value: (coefficients at: i)]) parent: parent! !

!Tuple methodsFor: 'enumerating' stamp: 'len 5/5/2023 19:09:10'!
count: aBlock
	^ coefficients count: aBlock! !

!Tuple methodsFor: 'enumerating' stamp: 'len 7/12/2023 13:00:42'!
do: aBlock
	coefficients do: aBlock! !

!Tuple methodsFor: 'enumerating' stamp: 'len 6/3/2023 20:21:38'!
keysAndValuesDo: aBinaryBlock
	"Iterate over each index and coefficient. For compatibility with Monomial and Word."
	self withIndexDo: [:each :i| aBinaryBlock value: i value: each]! !

!Tuple methodsFor: 'enumerating' stamp: 'len 5/9/2023 13:50:51'!
supportDo: aBlock
	coefficients supportDo: aBlock! !

!Tuple methodsFor: 'enumerating' stamp: 'len 5/5/2023 18:43:03'!
with: anArray do: aBlock 
	"Evaluate twoArgBlock with corresponding elements from this collection and otherCollection."
	anArray size = self size ifFalse: [self error: 'sizes don''t match'].
	1 to: self size do:
		[:index |
		aBlock value: (self at: index) value: (anArray at: index)]! !

!Tuple methodsFor: 'enumerating' stamp: 'len 5/9/2023 17:49:38'!
withIndexCollect: aBlock
	^ self class coefficients: (self scalars new: self size fill: [:i| aBlock value: (coefficients at: i) value: i]) parent: parent! !

!Tuple methodsFor: 'enumerating' stamp: 'len 5/5/2023 18:33:18'!
withIndexDo: aBlock
	coefficients withIndexDo: aBlock! !

!Tuple methodsFor: 'enumerating' stamp: 'len 5/9/2023 13:53:04'!
withSupportDo: aBlock
	self supportDo: [:i| aBlock value: (self at: i) value: i]! !

!Tuple methodsFor: 'operations' stamp: 'len 11/7/2023 21:22:40'!
% anInteger
	self assert: self scalars = ℤ.
	^ self apply: (ℤ / anInteger) projection! !

!Tuple methodsFor: 'operations' stamp: 'len 10/24/2023 16:30:34'!
* anObject
	((self scalars includes: anObject) or: [anObject isInteger])
		ifTrue: [^ self class coefficients: coefficients * anObject parent: parent].
	anObject isMatrix
		ifTrue: [^ (self asRowMatrix * anObject) asTuple].
	(anObject isTuple and: [parent = anObject parent])
		ifTrue: [^ self class coefficients: coefficients * anObject coefficients parent: parent].
	^ self * (self scalars !! anObject)! !

!Tuple methodsFor: 'operations' stamp: 'len 5/5/2023 13:23:59'!
+ aTuple
	(parent includes: aTuple) ifFalse: [^ self adapt: aTuple andSend: #+].
	^ self class coefficients: coefficients + aTuple coefficients parent: parent! !

!Tuple methodsFor: 'operations' stamp: 'len 5/5/2023 13:24:26'!
- aTuple
	(parent includes: aTuple) ifFalse: [^ self adapt: aTuple andSend: #-].
	^ self class coefficients: coefficients - aTuple coefficients parent: parent! !

!Tuple methodsFor: 'operations' stamp: 'len 11/29/2023 10:07:21'!
/ anObject
	"If the argument is a matrix, answer X such that XA = B, where B is self and A is the argument.  X is called a lift of B along A.
	If the argument is a scalar, just divide each element of the tuple by it."
	(self scalars includes: anObject) ifTrue: [^ self collect: [:each| each / anObject]].
	anObject isMatrix ifTrue: [^ (anObject colift: self asRowMatrix) ifNotNil: [:aMatrix| aMatrix asTuple]].
	anObject isTuple ifTrue: [^ 	super / anObject].
	^ self / (self scalars !! anObject)! !

!Tuple methodsFor: 'operations' stamp: 'len 5/9/2023 17:46:37'!
// anElement
	(self scalars includes: anElement) ifTrue: [^ self apply: [:each| each // anElement]].
	^ super // anElement! !

!Tuple methodsFor: 'operations' stamp: 'len 5/5/2023 00:11:07'!
<< anInteger
	"Answer the left shift of the receiver by anInteger places.
	The answer is a new array of the same size as the receiver."
	^ self >> anInteger negated! !

!Tuple methodsFor: 'operations' stamp: 'len 5/5/2023 13:18:34'!
<<< anInteger
	"Answer the circular left shift of the receiver by anInteger places.
	The answer is a tuple of the same size as the receiver."
	^ self >>> anInteger negated! !

!Tuple methodsFor: 'operations' stamp: 'len 5/5/2023 15:54:18'!
>> anInteger
	"Answer the right shift of the receiver by anInteger places.
	The answer is a new array of the same size as the receiver."
	(anInteger = 0 or: [self size = 0]) ifTrue: [^ self].
	^ self class coefficients: coefficients >> anInteger parent: parent! !

!Tuple methodsFor: 'operations' stamp: 'len 5/5/2023 13:19:32'!
>>> anInteger
	"Answer the circular right shift of the receiver by anInteger places.
	The answer is a tuple of the same size as the receiver."
	(anInteger = 0 or: [self size = 0]) ifTrue: [^ self].
	^ self class coefficients: coefficients >>> anInteger parent: parent! !

!Tuple methodsFor: 'operations' stamp: 'len 5/9/2023 17:46:43'!
\\ anElement
	(self scalars includes: anElement) ifTrue: [^ self apply: [:each| each \\ anElement]].
	^ super \\ anElement! !

!Tuple methodsFor: 'operations' stamp: 'len 5/5/2023 15:55:45'!
· aTuple
	(self size = 0 or: [aTuple size = 0]) ifTrue: [^ self scalars zero].
	^ coefficients · aTuple coefficients! !

!Tuple methodsFor: 'operations' stamp: 'len 4/5/2024 18:56:52'!
× aTuple
	"Answer the cross product of the receiver with the argument."
	self assert: (self size = 3 and: [aTuple size = 3]).
	^ self class
		coefficients:
			((self scalars new: 3)
				at: 1 put: (coefficients at: 2)*(aTuple at: 3) - ((coefficients at: 3)*(aTuple at: 2));
				at: 2 put: (coefficients at: 3)*(aTuple at: 1) - ((coefficients at: 1)*(aTuple at: 3));
				at: 3 put: 	(coefficients at: 1)*(aTuple at: 2) - ((coefficients at: 2)*(aTuple at: 1));
				yourself)
		parent: parent! !

!Tuple methodsFor: 'operations' stamp: 'len 5/14/2023 15:08:20'!
÷ anObject
	^ self collect: [:each| each ÷ anObject]! !

!Tuple methodsFor: 'operations' stamp: 'len 5/5/2023 00:11:07'!
annihilator
	^ self annihilatorIdeal generator! !

!Tuple methodsFor: 'operations' stamp: 'len 5/5/2023 00:11:07'!
annihilatorIdeal
	| answer |
	answer _ self scalars asIdeal.
	self isZero ifTrue: [^ answer].
	self do: [:each| answer _ answer ∩ each annihilatorIdeal. answer isTrivial ifTrue: [^ answer]].
	^ answer! !

!Tuple methodsFor: 'operations' stamp: 'len 5/5/2023 00:11:07'!
associates
	^ self scalars units collect: [:each| self * each]! !

!Tuple methodsFor: 'operations' stamp: 'len 5/8/2023 18:58:21'!
conjugate
	^ self apply: [:each| each conjugate]! !

!Tuple methodsFor: 'operations' stamp: 'len 12/23/2023 10:52:19'!
content
	"Answer the GCD of the coefficients of the receiver.
	In a field, it is convenient to define the content as 1.
	For example, (2,4) has content 2 over ℤ and 1 over ℚ."
	| answer |
	self isZero ifTrue: [^ self scalars zero].
	self scalars isField ifTrue: [^ self scalars one].
	answer := self scalars zero.
	self do: [:each| answer := answer gcd: each. answer isOne ifTrue: [^ answer]].
	^ answer! !

!Tuple methodsFor: 'operations' stamp: 'len 6/21/2023 23:04:51'!
exponentiate: anArray
	^ coefficients exponentiate: anArray! !

!Tuple methodsFor: 'operations' stamp: 'len 12/1/2023 18:26:46'!
height
	^ coefficients inject: 1 into: [:x :each| x max: each height]! !

!Tuple methodsFor: 'operations' stamp: 'len 5/8/2023 18:16:24'!
homogenizedAt: anInteger
	self flag: #deprecated.
	^ (self copyFrom: 1 to: anInteger - 1), self scalars one, (self copyFrom: anInteger to: self size)! !

!Tuple methodsFor: 'operations' stamp: 'len 5/5/2023 16:01:58'!
negated
	^ self class coefficients: coefficients negated parent: parent! !

!Tuple methodsFor: 'operations' stamp: 'len 5/5/2023 00:11:07'!
norm
	^ self · self! !

!Tuple methodsFor: 'operations' stamp: 'len 5/5/2023 00:11:07'!
normalization
	"Answer a unit u such that 'self * u' is a unique choice of associate. See >>normalized.
	NOTE: when the coefficients ring is not an integral domain this choice of unit might not be unique."
	^ (self at: (self lastNonzeroIndex ifNil: [^ self scalars one])) normalization! !

!Tuple methodsFor: 'operations' stamp: 'len 4/6/2024 06:32:35'!
normalized
	"Answer a unique choice of associate. See >>normalization."
	^ self * self normalization! !

!Tuple methodsFor: 'operations' stamp: 'len 4/6/2024 06:41:55'!
order
	self isZero ifTrue: [^ 0].
	^ coefficients inject: 0 into: [:each :lastValue| each additiveOrder lcm: lastValue]! !

!Tuple methodsFor: 'operations' stamp: 'len 5/14/2023 15:06:41'!
primitivePart
	"Answer the primitive part of the receiver."
	^ self isZero ifTrue: [self] ifFalse: [self ÷ self content]! !

!Tuple methodsFor: 'operations' stamp: 'len 5/5/2023 16:02:44'!
product
	self size = 0 ifTrue: [^ self scalars one].
	^ coefficients product! !

!Tuple methodsFor: 'operations' stamp: 'len 5/5/2023 17:22:26'!
reversed
	^ self class coefficients: coefficients reversed parent: parent! !

!Tuple methodsFor: 'operations' stamp: 'len 5/5/2023 00:11:07'!
stabilizers
	| answer last |
	self size <= 1 ifTrue: [^ #()].
	answer _ OrderedCollection new: self size - 1.
	last _ self at: 1.
	2 to: self size do: [:i| | ai ci |
		ai _ self at: i.
		ci _ last stabilizerWith: ai.
		answer add: ci.
		last _ ci*ai + last].
	^ answer! !

!Tuple methodsFor: 'operations' stamp: 'len 5/5/2023 16:03:07'!
sum
	self size = 0 ifTrue: [^ self scalars zero].
	^ coefficients sum! !

!Tuple methodsFor: 'operations' stamp: 'len 5/9/2023 21:11:18'!
support
	^ coefficients support! !

!Tuple methodsFor: 'operations' stamp: 'len 5/9/2023 17:44:26'!
weight
	"Answer the Hamming weight of the receiver, i.e. the number of entries that are not zero."
	^ coefficients weight! !

!Tuple methodsFor: 'operations' stamp: 'len 7/29/2024 09:42:05'!
⊗ anElement
	"Answer the outer product of the receiver with the argument."
	anElement isTuple ifTrue: [^ anElement parent to: parent fill: [:i :j| (self at: i)*(anElement at: j)]].
	anElement isMatrix ifTrue: [^ self asMatrix ⊗ anElement transpose].
	^ self notYetImplemented! !

!Tuple methodsFor: 'operations' stamp: 'len 7/1/2024 10:56:04'!
◃ anObject
	^ self * anObject! !

!Tuple methodsFor: 'printing' stamp: 'len 5/10/2023 01:23:20'!
printOn: aStream
	coefficients printOn: aStream! !

!Tuple methodsFor: 'testing' stamp: 'len 5/5/2023 18:21:16'!
allSatisfy: aBlock
	^ coefficients allSatisfy: aBlock! !

!Tuple methodsFor: 'testing' stamp: 'len 5/5/2023 18:21:23'!
anySatisfy: aBlock
	^ coefficients anySatisfy: aBlock! !

!Tuple methodsFor: 'testing' stamp: 'len 5/5/2023 19:01:49'!
includes: anElement
	^ coefficients includes: anElement! !

!Tuple methodsFor: 'testing' stamp: 'len 5/5/2023 16:58:30'!
isEmpty
	^ self size = 0! !

!Tuple methodsFor: 'testing' stamp: 'len 5/5/2023 00:11:07'!
isMonomial
	^ self allSatisfy: [:each| each isMonomial]! !

!Tuple methodsFor: 'testing' stamp: 'len 5/8/2023 17:59:46'!
isSequenceable
	^ true! !

!Tuple methodsFor: 'testing' stamp: 'len 5/5/2023 00:11:07'!
isTuple
	^ true! !

!Tuple methodsFor: 'testing' stamp: 'len 5/5/2023 00:11:07'!
isUnimodular
	"Answer true if the coefficients of the receiver generate the unit ideal.
	Some authors use the name 'primitive' instead of 'unimodular'."
	^ (self scalars * self asArray) isOne! !

!Tuple methodsFor: 'testing' stamp: 'len 5/5/2023 16:44:47'!
isZero
	^ coefficients isZero! !

!Tuple methodsFor: 'testing' stamp: 'len 5/5/2023 16:03:53'!
isZeroAt: anInteger
	^ coefficients isZeroAt: anInteger! !

!Tuple methodsFor: 'testing' stamp: 'len 5/5/2023 18:21:33'!
noneSatisfy: aBlock
	^ coefficients noneSatisfy: aBlock! !

!Tuple methodsFor: 'private' stamp: 'len 5/5/2023 00:14:55'!
coefficients
	^ coefficients! !

!Tuple methodsFor: 'private' stamp: 'len 5/5/2023 00:15:36'!
coefficients: anArray parent: aFreeModule
	coefficients _ anArray.
	parent _ aFreeModule! !

!Tuple methodsFor: 'private' stamp: 'len 5/5/2023 00:15:04'!
parent
	^ parent! !

!Tuple methodsFor: 'private' stamp: 'len 5/16/2023 21:31:44'!
validate
	super validate.
	coefficients validate.
	self assert: (self scalars isValidArray: coefficients)! !

!Tuple class methodsFor: 'instance creation' stamp: 'len 5/5/2023 00:26:16'!
coefficients: anArray parent: aFreeModule
	^ self basicNew coefficients: anArray parent: aFreeModule! !

!MultivariateTuple methodsFor: 'accessing' stamp: 'len 5/7/2023 13:51:54'!
degree
	| answer |
	self isEmpty ifTrue: [^ Infinity negative].
	answer _ 0.
	coefficients withIndexDo: [:each :i| answer _ answer max: each degree + (self ordering degreeAt: i)].
	^ answer! !

!MultivariateTuple methodsFor: 'accessing' stamp: 'len 6/17/2023 12:42:02'!
ecart
	"Answer the ecart of the receiver. This is a measure of how far a tuple is from being homogeneous."
	self isZero ifTrue: [^ Infinity negative].
	^ (coefficients max: [:each| each degree]) - self leadingMonomial degree! !

!MultivariateTuple methodsFor: 'accessing' stamp: 'len 5/5/2023 00:52:13'!
leadingCoefficient
	^ self at: self leadingMonomial! !

!MultivariateTuple methodsFor: 'accessing' stamp: 'len 5/5/2023 00:52:13'!
leadingMonomial
	^ leadingMonomial ifNil: [leadingMonomial _ self ordering leadingMonomialOf: self]! !

!MultivariateTuple methodsFor: 'accessing' stamp: 'len 5/5/2023 00:52:13'!
leadingTerm
	^ self termAt: self leadingMonomial! !

!MultivariateTuple methodsFor: 'accessing' stamp: 'len 5/5/2023 00:52:13'!
ordering
	^ self parent ordering! !

!MultivariateTuple methodsFor: 'accessing' stamp: 'len 5/5/2023 00:52:13'!
tail
	^ self - self leadingTerm! !

!MultivariateTuple methodsFor: 'accessing' stamp: 'len 5/5/2023 01:00:18'!
termAt: aModuleMonomial
	^ (self parent x: aModuleMonomial position) * ((self at: aModuleMonomial position) termAt: aModuleMonomial monomial)! !

!MultivariateTuple methodsFor: 'enumerating' stamp: 'len 6/15/2023 12:18:48'!
associationsDo: aBlock
	| ordering |
	ordering := self ordering.
	self withIndexDo: [:fi :i|
		fi associationsDo: [:each| aBlock value: (Association key: (ModuleMonomial monomial: each key position: i ordering: ordering) value: each value)]]! !

!MultivariateTuple methodsFor: 'enumerating' stamp: 'len 6/15/2023 12:19:43'!
monomialsDo: aBlock
	| ordering |
	ordering := self ordering.
	self withIndexDo: [:fi :i|
		fi monomialsDo: [:each| aBlock value: (ModuleMonomial monomial: each position: i ordering: ordering)]]! !

!MultivariateTuple methodsFor: 'operations' stamp: 'len 5/5/2023 00:52:13'!
* anObject
	anObject class = ModuleMonomial ifTrue: [^ (self parent x: anObject position) * ((self at: anObject position) * anObject monomial)].
	anObject class = Monomial ifTrue: [^ self collect: [:each| each * anObject]].
	^ super * anObject! !

!MultivariateTuple methodsFor: 'operations' stamp: 'len 5/5/2023 00:52:13'!
// anObject
	anObject isCollection ifTrue: [^ (self divisionBy: anObject) quotients].
	anObject class = ModuleMonomial ifTrue: [^ self withIndexCollect: [:each :i| i = anObject position ifTrue: [each // anObject monomial] ifFalse: [each]]].
	^ self collect: [:each| each // anObject]! !

!MultivariateTuple methodsFor: 'operations' stamp: 'len 5/5/2023 00:52:13'!
\\ anObject
	anObject isCollection ifTrue: [^ self reductionFullBy: anObject].
	^ self collect: [:each| each \\ anObject]! !

!MultivariateTuple methodsFor: 'operations' stamp: 'len 5/5/2023 00:52:13'!
divisionBy: anArray
	self scalars ordering isGlobal ifFalse: [^ self notYetImplemented].
	^ MultivariateDivision divide: self by: (anArray isCollection ifTrue: [anArray] ifFalse: [{anArray}])! !

!MultivariateTuple methodsFor: 'operations' stamp: 'len 5/5/2023 00:52:13'!
g: aTuple
	"Answer the GCD-tuple of the receiver with the argument."
	| m xgcd |
	m _ self leadingMonomial lcm: aTuple leadingMonomial.
	xgcd _ self leadingCoefficient xgcd: aTuple leadingCoefficient.
	^ self * (m / self leadingMonomial) * (xgcd at: 2) + (aTuple * (m / aTuple leadingMonomial) * (xgcd at: 3))! !

!MultivariateTuple methodsFor: 'operations' stamp: 'len 5/5/2023 00:52:13'!
normalization
	"Answer a unit u such that 'self * u' is a unique choice of associate. See >>normalized.
	NOTE: when the coefficients ring is not an integral domain this choice of unit might not be unique."
	^ self leadingCoefficient normalization! !

!MultivariateTuple methodsFor: 'operations' stamp: 'len 5/5/2023 00:52:13'!
reductionBy: anArray
	"If the ordering is global answer a top-reduction of the receiver with respect to the argument (without doing tail reduction). Otherwise answer the Mora normal form."
	^ self scalars ordering isGlobal
		ifTrue: [self reductionGlobalBy: anArray]
		ifFalse: [self reductionMoraBy: anArray]! !

!MultivariateTuple methodsFor: 'operations' stamp: 'len 5/5/2023 00:52:13'!
reductionFullBy: anArray
	"Answer the tail-reduced normal form of the receiver with respect to the argument (doing full tail reduction).
	For an ordering that is not global, answer the Mora normal form."
	| g h |
	self scalars ordering isGlobal ifFalse: [^ self reductionMoraBy: anArray].
	g _ self.
	h _ g zero.
	[g isZero]
		whileFalse:
			[g _ g reductionGlobalBy: anArray.
			g isZero ifFalse: [h _ h + g leadingTerm. g _ g tail]].
	^ h! !

!MultivariateTuple methodsFor: 'operations' stamp: 'len 6/17/2023 14:33:08'!
reductionGlobalBy: anArray
	"Answer a top-reduction of the receiver with respect to the argument (without doing tail reduction)."
	| h |
	h := self.
	[h isZero]
		whileFalse:
			[| m c g q |
			m := h leadingMonomial.
			c := h leadingCoefficient.
			g := anArray detect: [:one| one leadingMonomial | m and: [(q := c // one leadingCoefficient) isZero not]] ifNone: [^ h].
			h := h + (g * (m / g leadingMonomial) * q negated)].
	^ h! !

!MultivariateTuple methodsFor: 'operations' stamp: 'len 5/5/2023 00:52:13'!
reductionMoraBy: anArray
	"Answer Mora's normal form of the receiver with respect to the argument."
	| h L m c g ecartg |
	h _ self.
	L _ OrderedCollection withAll: anArray.
	[h isZero ifTrue: [^ h].
	m _ h leadingMonomial.
	c _ h leadingCoefficient.
	g _ ecartg _ nil.
	L do: [:each|
		| ecart |
		(each leadingMonomial | m and: [each leadingCoefficient | c and: [ecart _ each ecart. g isNil or: [ecart < ecartg]]])
			ifTrue: [g _ each. ecartg _ ecart]].
	g isNil ifTrue: [^ h].
	ecartg > h ecart ifTrue: [L add: h].
	h _ h + (g * (m / g leadingMonomial) * (c negated / g leadingCoefficient))] repeat! !

!MultivariateTuple methodsFor: 'operations' stamp: 'len 5/5/2023 00:52:13'!
s: aTuple
	"Answer the S-tuple of the receiver with the argument."
	| m c |
	m _ (self leadingMonomial lcm: aTuple leadingMonomial) ifNil: [^ nil].
	c _ self leadingCoefficient lcm: aTuple leadingCoefficient.
	^ self * (m / self leadingMonomial) * (c / self leadingCoefficient) + (aTuple * (m / aTuple leadingMonomial) * (c negated / aTuple leadingCoefficient))! !

!MultivariateTuple methodsFor: 'testing' stamp: 'len 5/5/2023 00:52:13'!
isHomogeneous
	| n |
	n _ self degree.
	^ coefficients allSatisfy: [:each| each isZero or: [each degree = n]]! !

!ModuleMonomial methodsFor: 'accessing' stamp: 'len 5/7/2023 13:50:06'!
degree
	^ monomial degree + (ordering degreeAt: position)! !

!ModuleMonomial methodsFor: 'accessing' stamp: 'len 1/14/2017 20:20:21'!
monomial
	^ monomial! !

!ModuleMonomial methodsFor: 'accessing' stamp: 'len 1/14/2017 20:20:47'!
position
	^ position! !

!ModuleMonomial methodsFor: 'comparing' stamp: 'len 12/3/2023 21:19:31'!
< aModuleMonomial
	^ (self compare: aModuleMonomial) < 0! !

!ModuleMonomial methodsFor: 'comparing' stamp: 'len 12/3/2023 21:11:01'!
<= aModuleMonomial
	^ (self compare: aModuleMonomial) <= 0! !

!ModuleMonomial methodsFor: 'comparing' stamp: 'len 5/5/2023 01:01:32'!
= aModuleMonomial
	^ self class == aModuleMonomial class and: [monomial = aModuleMonomial monomial and: [position = aModuleMonomial position]]! !

!ModuleMonomial methodsFor: 'comparing' stamp: 'len 12/4/2023 10:15:20'!
> aModuleMonomial
	^ aModuleMonomial < self! !

!ModuleMonomial methodsFor: 'comparing' stamp: 'len 12/4/2023 10:15:25'!
>= aModuleMonomial
	^ aModuleMonomial <= self! !

!ModuleMonomial methodsFor: 'comparing' stamp: 'len 5/5/2023 01:02:21'!
compare: aModuleMonomial
	"Answer -1 if the receiver is < than the argument, 0 if they are equal, 1 if it is > than the argument."
	^ ordering compare: self with: aModuleMonomial! !

!ModuleMonomial methodsFor: 'comparing' stamp: 'len 1/5/2018 11:20:11'!
hash
	^ monomial hash + position hash hashMultiply! !

!ModuleMonomial methodsFor: 'operations' stamp: 'len 6/15/2023 12:20:26'!
* aModuleMonomial
	self assert: position = aModuleMonomial position.
	^ self class monomial: monomial * aModuleMonomial monomial position: position ordering: ordering! !

!ModuleMonomial methodsFor: 'operations' stamp: 'len 5/5/2023 01:00:48'!
/ aModuleMonomial
	self assert: position = aModuleMonomial position.
	^ monomial / aModuleMonomial monomial! !

!ModuleMonomial methodsFor: 'operations' stamp: 'len 6/15/2023 12:20:52'!
lcm: aModuleMonomial
	^ position = aModuleMonomial position ifTrue: [self class monomial: (monomial lcm: aModuleMonomial monomial) position: position ordering: ordering]! !

!ModuleMonomial methodsFor: 'printing' stamp: 'len 5/6/2023 15:21:39'!
printOn: aStream
	monomial isIdentity ifFalse: [aStream print: monomial].
	aStream nextPutAll: 'ε', position printStringSubscript! !

!ModuleMonomial methodsFor: 'testing' stamp: 'len 5/5/2023 01:02:15'!
| aModuleMonomial
	"Answer true if the receiver divides the argument."
	^ position = aModuleMonomial position and: [monomial | aModuleMonomial monomial]! !

!ModuleMonomial methodsFor: 'private' stamp: 'len 6/15/2023 12:14:49'!
monomial: aMonomial position: anInteger ordering: aModuleMonomialOrdering
	monomial := aMonomial.
	position := anInteger.
	ordering := aModuleMonomialOrdering! !

!ModuleMonomial class methodsFor: 'instance creation' stamp: 'len 6/15/2023 12:16:34'!
monomial: aMonomial position: anInteger ordering: aModuleMonomialOrdering
	^ self new monomial: aMonomial position: anInteger ordering: aModuleMonomialOrdering! !

!ModuleMonomialOrdering methodsFor: 'ordering' stamp: 'len 5/5/2023 01:02:59'!
compare: aModuleMonomial with: anotherModuleMonomial
	^ self subclassResponsibility! !

!ModuleMonomialOrdering methodsFor: 'ordering' stamp: 'len 12/3/2023 21:25:10'!
leadingMonomialOf: aTuple
	| answer |
	answer := nil.
	aTuple monomialsDo: [:each| (answer isNil or: [answer < each]) ifTrue: [answer := each]].
	^ answer! !

!ModuleMonomialOrdering methodsFor: 'private' stamp: 'len 5/7/2023 13:48:58'!
degreeAt: anInteger
	^ 0! !

!ModuleMonomialOrdering class methodsFor: 'examples' stamp: 'len 5/7/2023 01:42:28'!
pot
	^ POTMonomialOrdering new! !

!ModuleMonomialOrdering class methodsFor: 'examples' stamp: 'len 5/7/2023 01:43:08'!
top
	^ TOPMonomialOrdering new! !

!ModuleMonomialOrdering class methodsFor: 'examples' stamp: 'len 5/7/2023 01:46:23'!
topw: anArray
	^ TOPWMonomialOrdering weights: anArray! !

!POTMonomialOrdering methodsFor: 'comparing' stamp: 'len 7/28/2021 11:51:12'!
= anObject
	^ self class = anObject class! !

!POTMonomialOrdering methodsFor: 'comparing' stamp: 'len 7/28/2021 11:53:26'!
hash
	^ self class hash! !

!POTMonomialOrdering methodsFor: 'ordering' stamp: 'len 5/5/2023 01:03:25'!
compare: aModuleMonomial with: anotherModuleMonomial
	| result |
	(result _ (aModuleMonomial position - anotherModuleMonomial position) sign) == 0 ifFalse: [^ result].
	^ aModuleMonomial monomial compare: anotherModuleMonomial monomial! !

!POTMonomialOrdering methodsFor: 'ordering' stamp: 'len 6/15/2023 12:21:20'!
leadingMonomialOf: aTuple
	aTuple size to: 1 by: -1 do: [:i| | f |
		(f := aTuple at: i) isZero ifFalse: [^ ModuleMonomial monomial: f leadingMonomial position: i ordering: self]].
	^ nil! !

!POTMonomialOrdering methodsFor: 'printing' stamp: 'len 7/28/2021 11:54:21'!
printOn: aStream
	aStream nextPutAll: 'POT'! !

!SchreyerMonomialOrdering methodsFor: 'accessing' stamp: 'len 1/5/2018 11:25:47'!
type
	^ #schreyer! !

!SchreyerMonomialOrdering methodsFor: 'comparing' stamp: 'len 7/27/2021 11:42:24'!
= anObject
	^ self class = anObject class and: [weights = anObject weights]! !

!SchreyerMonomialOrdering methodsFor: 'comparing' stamp: 'len 7/27/2021 19:24:47'!
hash
	^ weights hash! !

!SchreyerMonomialOrdering methodsFor: 'ordering' stamp: 'len 5/5/2023 01:03:57'!
compare: aModuleMonomial with: anotherModuleMonomial
	| result |
	(result _ ((weights at: aModuleMonomial position) * aModuleMonomial monomial) leadingMonomial compare: ((weights at: anotherModuleMonomial position) * anotherModuleMonomial monomial) leadingMonomial) == 0 ifFalse: [^ result].
	^ (anotherModuleMonomial position - aModuleMonomial position) sign! !

!SchreyerMonomialOrdering methodsFor: 'private' stamp: 'len 7/28/2021 10:04:41'!
weights: anArray
	weights _ anArray! !

!SchreyerMonomialOrdering class methodsFor: 'instance creation' stamp: 'len 7/28/2021 09:53:43'!
weights: anArray
	^ self new weights: anArray! !

!TOPMonomialOrdering methodsFor: 'printing' stamp: 'len 7/28/2021 11:54:12'!
printOn: aStream
	aStream nextPutAll: 'TOP'! !

!TOPMonomialOrdering methodsFor: 'comparing' stamp: 'len 7/28/2021 11:51:16'!
= anObject
	^ self class = anObject class! !

!TOPMonomialOrdering methodsFor: 'comparing' stamp: 'len 7/28/2021 11:53:41'!
hash
	^ self class hash! !

!TOPMonomialOrdering methodsFor: 'ordering' stamp: 'len 5/5/2023 01:04:22'!
compare: aModuleMonomial with: anotherModuleMonomial
	| result |
	(result _ aModuleMonomial monomial compare: anotherModuleMonomial monomial) == 0 ifFalse: [^ result].
	^ (aModuleMonomial position - anotherModuleMonomial position) sign! !

!TOPMonomialOrdering methodsFor: 'ordering' stamp: 'len 12/3/2023 21:24:37'!
leadingMonomialOf: aTuple
	| monomial position |
	monomial := nil.
	1 to: aTuple size do: [:i|
		(aTuple at: i) leadingMonomial
			ifNotNil: [:aMonomial|
				(monomial isNil or: [monomial < aMonomial])
					ifTrue: [monomial := aMonomial. position := i]]].
	^ monomial ifNotNil: [ModuleMonomial monomial: monomial position: position ordering: self]! !

!TOPWMonomialOrdering methodsFor: 'accessing' stamp: 'len 5/7/2023 01:43:57'!
weights
	^ weights! !

!TOPWMonomialOrdering methodsFor: 'comparing' stamp: 'len 5/7/2023 01:44:27'!
= anObject
	^ self class = anObject class and: [weights = anObject weights]! !

!TOPWMonomialOrdering methodsFor: 'private' stamp: 'len 5/7/2023 13:49:27'!
degreeAt: anInteger
	^ weights at: anInteger! !

!TOPWMonomialOrdering methodsFor: 'private' stamp: 'len 5/7/2023 01:43:50'!
weights: anArray
	weights _ anArray! !

!TOPWMonomialOrdering methodsFor: 'printing' stamp: 'len 5/7/2023 01:49:43'!
printOn: aStream
	aStream nextPutAll: 'TOPW('.
	weights do: [:each| aStream print: each] separatedBy: [aStream nextPut: $,].
	aStream nextPut: $)! !

!TOPWMonomialOrdering class methodsFor: 'instance creation' stamp: 'len 5/7/2023 01:46:55'!
weights: anArray
	^ self new weights: anArray! !

!Divisor methodsFor: 'accessing' stamp: 'len 6/19/2023 14:33:59'!
coefficients
	^ coefficients! !

!Divisor methodsFor: 'accessing' stamp: 'len 7/18/2022 06:23:40'!
degree
	coefficients isEmpty ifTrue: [^ self scalars zero].
	^ coefficients sum! !

!Divisor methodsFor: 'accessing' stamp: 'len 7/18/2022 06:22:38'!
scalars
	^ parent scalars! !

!Divisor methodsFor: 'accessing' stamp: 'len 8/12/2022 13:18:46'!
support
	| answer |
	answer _ nil. "should start from the empty variety"
	coefficients keysDo: [:each| answer _ answer ifNil: [each] ifNotNil: [answer ∪ each]].
	^ answer! !

!Divisor methodsFor: 'comparing' stamp: 'len 1/11/2017 16:34:02'!
<= aDivisor
	^ (aDivisor - self) isEffective! !

!Divisor methodsFor: 'comparing' stamp: 'len 6/19/2023 15:15:26'!
= anObject
	^ (anObject isKindOf: Divisor) and: [coefficients = anObject coefficients]! !

!Divisor methodsFor: 'comparing' stamp: 'len 10/27/2016 10:26'!
>= aDivisor
	^ (self - aDivisor) isEffective! !

!Divisor methodsFor: 'comparing' stamp: 'len 1/2/2017 15:43:29'!
~ aDivisor
	"Answer true if the receiver and the argument are linearly equivalent."
	^ (self - aDivisor) isPrincipal! !

!Divisor methodsFor: 'comparing' stamp: 'len 7/25/2022 11:56:06'!
hash
	^ 0! !

!Divisor methodsFor: 'operations' stamp: 'len 7/18/2022 06:22:17'!
* anElement
	(anElement isInteger or: [self scalars includes: anElement])
		ifTrue: [^ self class coefficients: coefficients * anElement parent: parent].
	^ self error: 'not a scalar'! !

!Divisor methodsFor: 'operations' stamp: 'len 7/18/2022 06:21:07'!
+ aDivisor
	(parent includes: aDivisor) ifFalse: [^ self adapt: aDivisor andSend: #+].
	^ self class coefficients: coefficients + aDivisor coefficients parent: parent! !

!Divisor methodsFor: 'operations' stamp: 'len 7/18/2022 06:21:26'!
- aDivisor
	(parent includes: aDivisor) ifFalse: [^ self adapt: aDivisor andSend: #-].
	^ self class coefficients: coefficients - aDivisor coefficients parent: parent! !

!Divisor methodsFor: 'operations' stamp: 'len 6/19/2023 01:10:01'!
gcd: aDivisor
	| newCoefficients |
	newCoefficients := Dictionary new.
	coefficients keysAndValuesDo: [:key :value|
		aDivisor coefficients at: key ifPresent: [:value2| newCoefficients at: key put: (value min: value2)]].
	^ self class coefficients: newCoefficients parent: parent! !

!Divisor methodsFor: 'operations' stamp: 'len 7/18/2022 06:19:06'!
lcm: aDivisor
	| newCoefficients |
	newCoefficients _ coefficients copy.
	aDivisor coefficients keysAndValuesDo: [:key :value|
		newCoefficients at: key put: ((coefficients at: key) max: value)].
	^ self class coefficients: newCoefficients parent: parent! !

!Divisor methodsFor: 'operations' stamp: 'len 7/18/2022 06:21:39'!
negated
	^ self class coefficients: coefficients negated parent: parent! !

!Divisor methodsFor: 'printing' stamp: 'len 6/19/2023 14:29:10'!
printOn: aStream
	| keys R f |
	keys := coefficients keys asArray sort: [:a :b| a printString <= b printString].
	R := parent scalars polynomialsIn: (keys collect: [:each| each printText]).
	f := R zero.
	keys withIndexDo: [:each :i| f := (R x: i) * (coefficients at: each) + f].
	aStream print: f! !

!Divisor methodsFor: 'testing' stamp: 'len 2/25/2017 09:09:25'!
isEffective
	^ self allSatisfy: [:each| each positive]! !

!Divisor methodsFor: 'private' stamp: 'len 7/18/2022 06:20:16'!
coefficients: aDictionary parent: aDivisorGroup
	coefficients _ aDictionary.
	parent _ aDivisorGroup! !

!Divisor methodsFor: 'private' stamp: 'len 6/19/2023 14:33:45'!
parent
	^ parent! !

!Divisor class methodsFor: 'instance creation' stamp: 'len 7/18/2022 06:19:38'!
coefficients: aDictionary parent: aDivisorGroup
	^ self new coefficients: aDictionary parent: aDivisorGroup! !

!AdditionChain methodsFor: 'accessing' stamp: 'len 6/9/2023 20:48:11'!
at: anInteger
	^ values at: anInteger! !

!AdditionChain methodsFor: 'accessing' stamp: 'len 6/9/2023 15:02:07'!
j: anInteger
	^ firstIndices at: anInteger! !

!AdditionChain methodsFor: 'accessing' stamp: 'len 6/9/2023 15:02:17'!
k: anInteger
	^ secondIndices at: anInteger! !

!AdditionChain methodsFor: 'accessing' stamp: 'len 6/9/2023 11:32:06'!
size
	^ values size! !

!AdditionChain methodsFor: 'computing' stamp: 'len 6/9/2023 20:48:33'!
indicesDo: aBlock
	2 to: values size do: [:i| aBlock value: i value: (firstIndices at: i) value: (secondIndices at: i)]! !

!AdditionChain methodsFor: 'computing' stamp: 'len 6/9/2023 20:50:29'!
raise: anElement
	| x |
	values isEmpty ifTrue: [^ anElement ^ 0].
	x := Array new: self size.
	x at: 1 put: anElement.
	self indicesDo: [:i :j :k| x at: i put: (x at: j) * (x at: k)].
	^ x at: self size! !

!AdditionChain methodsFor: 'operations' stamp: 'len 6/9/2023 11:24:56'!
⊕ anInteger
	^ self class values: self values, (self values last + anInteger)! !

!AdditionChain methodsFor: 'operations' stamp: 'len 6/9/2023 11:36:18'!
⊗ anAdditionChain
	^ self class values: self values allButLast, (anAdditionChain values * self values last)! !

!AdditionChain methodsFor: 'printing' stamp: 'len 6/9/2023 11:31:41'!
printOn: aStream
	aStream print: values! !

!AdditionChain methodsFor: 'private' stamp: 'len 6/9/2023 11:32:42'!
values
	^ values! !

!AdditionChain methodsFor: 'private' stamp: 'len 6/9/2023 20:37:43'!
values: anArray
	values := anArray.
	firstIndices := Array new: values size.
	secondIndices := Array new: values size.
	2 to: values size do: [:i|
		| vᵢ jᵢ kᵢ vⱼ |
		vᵢ := values at: i.
		jᵢ := (1 to: i-1) detect: [:j|
			vⱼ := values at: j.
			(kᵢ := (j to: i-1) detect: [:k| vⱼ + (values at: k) = vᵢ] ifNone: []) notNil].
		firstIndices at: i put: jᵢ.
		secondIndices at: i put: kᵢ]! !

!AdditionChain class methodsFor: 'instance creation' stamp: 'len 6/9/2023 11:39:25'!
min: n
	n isPowerOfTwo ifTrue: [^ self values: ((0 to: n highBit - 1) collect: [:i| 1 << i])].
	n = 3 ifTrue: [^ self values: #(1 2 3)].
	^ self new: n split: 1 << (n highBit // 2)! !

!AdditionChain class methodsFor: 'instance creation' stamp: 'len 6/9/2023 11:39:07'!
new: n split: k
	| q r |
	q := n // k.
	r := n \\ k.
	r = 0 ifTrue: [^ (self min: k) ⊗ (self min: q)].
	^ (self new: k split: r) ⊗ (self min: q) ⊕ r! !

!AdditionChain class methodsFor: 'instance creation' stamp: 'len 6/9/2023 11:31:23'!
values: anArray
	^ self new values: anArray! !

!BabyStepGiantStep methodsFor: 'computing' stamp: 'len 8/29/2024 15:17:39'!
logarithmOf: anElement
	| m γ |
	γ := anElement.
	m := table size.
	group isAbelianGroup
		ifTrue:
			[0 to: m do: [:i| table at: γ ifPresent: [:j| ^ i*m + j]. γ := γ + δ]]
		ifFalse:
			[0 to: m do: [:i| table at: γ ifPresent: [:j| ^ i*m + j]. γ := γ * δ]].
	^ nil! !

!BabyStepGiantStep methodsFor: 'private' stamp: 'len 8/29/2024 15:17:40'!
group: aGroup base: α order: n
	| m x |
	group := aGroup.
	m := n sqrtFloor + 1.
	table := Dictionary new: m.
	x := aGroup identity.
	aGroup isAbelianGroup
		ifTrue:
			[0 to: m - 1 do: [:j| table at: x put: j. x := x + α].
			δ := α * m negated]			
		ifFalse:
			[0 to: m - 1 do: [:j| table at: x put: j. x := x * α].
			δ := α ^ m negated]! !

!BabyStepGiantStep class methodsFor: 'instance creation' stamp: 'len 6/4/2023 20:56:37'!
on: aGroup
	^ self new group: aGroup base: aGroup generator order: aGroup size! !

!BabyStepGiantStep class methodsFor: 'instance creation' stamp: 'len 6/4/2023 20:56:12'!
on: aGroup base: anElement
	^ self new group: aGroup base: anElement order: (aGroup orderOf: anElement)! !

!BabyStepGiantStep class methodsFor: 'instance creation' stamp: 'len 6/4/2023 20:55:52'!
on: aGroup base: anElement order: anInteger
	^ self new group: aGroup base: anElement order: anInteger! !

!Ball methodsFor: 'accessing' stamp: 'len 1/13/2016 22:30'!
center
	^ center! !

!Ball methodsFor: 'accessing' stamp: 'len 11/10/2023 14:34:25'!
enclosingBox
	"Answer the smallest complex box enclosing the receiver."
	^ ComplexBox
		real: (Ball center: center real radius: radius)
		imaginary: (Ball center: center imaginary radius: radius)! !

!Ball methodsFor: 'accessing' stamp: 'len 11/10/2023 14:31:33'!
halves
	| h |
	h := radius / 2.
	^ {self class center: center - h radius: h. self class center: center + h radius: h}! !

!Ball methodsFor: 'accessing' stamp: 'len 6/5/2016 20:42'!
radius
	^ radius! !

!Ball methodsFor: 'arithmetic' stamp: 'len 11/26/2023 20:37:57'!
* aBall
	self flag: #fixme. "abs takes square root if the ball is complex, we could avoid it"
	aBall isNumber ifTrue: [^ self class center: center * aBall radius: aBall abs * radius].
	^ self class center: center * aBall center radius: center abs + radius * aBall radius + (aBall center abs + aBall radius * radius)! !

!Ball methodsFor: 'arithmetic' stamp: 'len 11/26/2023 20:36:36'!
+ aBall
	aBall isNumber ifTrue: [^ self class center: center + aBall radius: radius].
	^ self class center: center + aBall center radius: radius + aBall radius! !

!Ball methodsFor: 'arithmetic' stamp: 'len 11/9/2023 18:23:34'!
conjugate
	^ self class center: center conjugate radius: radius! !

!Ball methodsFor: 'arithmetic' stamp: 'len 11/29/2023 09:56:35'!
evaluate: aPolynomial
	"Answer the result of evaluating aPolynomial at the receiver."
	| x r λ |
	self flag: #fixme. "abs takes square root if the ball is complex, we could avoid it"
	x := center zero.
	r := radius zero.
	λ := center abs + radius.
	aPolynomial coefficients reverseDo: [:each|
		r := λ * r + (x abs + r * radius).
		x := center * x + each].
	^ self class center: x radius: r! !

!Ball methodsFor: 'arithmetic' stamp: 'len 11/10/2023 11:01:37'!
inverse
	self hasZero ifTrue: [^ ZeroDivide signal].
	^ self class center: center reciprocal radius: (radius = 0 ifTrue: [0] ifFalse: [radius reciprocal])! !

!Ball methodsFor: 'arithmetic' stamp: 'len 11/9/2023 14:48:12'!
negated
	^ self class center: center negated radius: radius! !

!Ball methodsFor: 'arithmetic' stamp: 'len 11/26/2023 14:02:41'!
one
	^ self class center: center one radius: radius zero! !

!Ball methodsFor: 'arithmetic' stamp: 'len 11/10/2023 14:48:26'!
squared
	^ self * self! !

!Ball methodsFor: 'arithmetic' stamp: 'len 11/26/2023 14:02:17'!
zero
	^ self class center: center zero radius: radius zero! !

!Ball methodsFor: 'printing' stamp: 'len 11/10/2023 14:25:01'!
printOn: aStream
	aStream print: center; nextPutAll: ' ± '; print: radius! !

!Ball methodsFor: 'testing' stamp: 'len 11/10/2023 15:57:10'!
hasZero
	^ center within: radius! !

!Ball methodsFor: 'testing' stamp: 'len 11/10/2023 15:57:38'!
includes: aComplex
	^ aComplex - center within: radius! !

!Ball methodsFor: 'testing' stamp: 'len 11/10/2023 15:58:24'!
overlaps: aBall
	^ center - aBall center within: radius + aBall radius! !

!Ball methodsFor: 'private' stamp: 'len 11/10/2023 19:20:33'!
center: aNumber radius: anotherNumber
	center := aNumber asFloat.
	radius := anotherNumber asFloat! !

!Ball class methodsFor: 'instance creation' stamp: 'len 11/8/2023 18:04:06'!
center: aComplex radius: aNumber
	^ self new center: aComplex radius: aNumber! !

!BrentKung methodsFor: 'computing' stamp: 'len 6/10/2023 12:17:06'!
compose: aPolynomial
	"Compute the composition using the precomputed tables."
	| k F |
	self assert: aPolynomial degree < modulus degree.
	self assert: aPolynomial parent = modulus parent.
	k := P size.
	F := Array new: k.
	self flag: #fixme. "TODO: use fast matrix multiplication for this step"
	1 to: k do: [:i| F at: i put: ((1 to: k) sum: [:j| (G at: j) * (aPolynomial at: i - 1 * k + j - 1)])].
	^ ((1 to: k) sum: [:i| (F at: i) * (P at: i)]) \\ modulus! !

!BrentKung methodsFor: 'private' stamp: 'len 6/10/2023 09:52:16'!
precomputeToComposeWith: aPolynomial modulo: anotherPolynomial
	"Precomputation for Brent-Kung modular composition algorithm [BK78].
	See [Coh+05, Algorithm 11.50]."
	| k |
	modulus := anotherPolynomial.
	self assert: modulus scalars isFiniteField.
	self assert: aPolynomial degree < modulus degree.
	self assert: aPolynomial parent = modulus parent.
	k := modulus degree sqrt ceiling.
	G := Array new: k + 1.
	G at: 1 put: aPolynomial one.
	2 to: k + 1 do: [:i| G at: i put: (G at: i - 1) * aPolynomial \\ modulus].
	"G withIndexDo: [:each :i| self assert: aPolynomial^(i-1) \\ modulus = each]."
	P := Array new: k.
	P at: 1 put: aPolynomial one.
	2 to: k do: [:i| P at: i put: (G at: k + 1) * (P at: i - 1) \\ modulus]
	"P withIndexDo: [:each :i| self assert: aPolynomial^(i-1 * k) \\ modulus = each]."! !

!BrentKung class methodsFor: 'instance creation' stamp: 'len 6/10/2023 09:50:09'!
new: aPolynomial modulo: anotherPolynomial
	^ self new precomputeToComposeWith: aPolynomial modulo: anotherPolynomial! !

!CRT methodsFor: 'computing' stamp: 'len 6/7/2023 13:48:48'!
solve: remainders
	| k mj y yj x |
	k _ moduli size.
	y _ Array new: k.
	y at: 1 put: (remainders at: 1) \\ (moduli at: 1).
	2 to: k do: [:j|
		mj _ moduli at: j.
		yj _ y at: j-1.
		j-2 to: 1 by: -1 do: [:i| yj _ yj * (moduli at: i) + (y at: i) \\ mj].
		yj _ ((remainders at: j) - yj) * (inverses at: j) \\ mj.
		y at: j put: yj].
	x _ y at: k.
	k-1 to: 1 by: -1 do: [:i| x _ x * (moduli at: i) + (y at: i)].
	"it would be more correct to return the residue class mod m1*m2*..*mk"
	^ x! !

!CRT methodsFor: 'private' stamp: 'len 6/7/2023 13:48:48'!
moduli: anArray
	| one k mj p euclid |
	moduli _ anArray.
	"Precomputations:"
	one _ moduli first one.
	k _ moduli size.
	inverses _ Array new: k.
	inverses at: 1 put: one.
	2 to: k do: [:j|
		| u |
		mj _ moduli at: j.
		p _ one. 1 to: j-1 do: [:i| p _ p * (moduli at: i) \\ mj].
		euclid _ p xgcd: mj.
		(euclid at: 1) ~= one ifTrue: [^ self error: 'the moduli are not coprime'].
		p * (u _ euclid at: 2) + (mj * (euclid at: 3)) = one ifFalse: [self error: 'failed'].
		inverses at: j put: u]! !

!CRT class methodsFor: 'instance creation' stamp: 'len 4/14/2021 05:58:38'!
moduli: anArray
	^ self new moduli: anArray! !

!CRT class methodsFor: 'instance creation' stamp: 'len 6/23/2023 17:54:50'!
solve: aCollection
	| x m |
	x := aCollection first.
	m := x modulus.
	aCollection allButFirstDo: [:each| | xi mi euclid |
		xi := each.
		mi := xi modulus.
		euclid := m xgcd: mi.
		x := (euclid at: 2) * m * xi representative + ((euclid at: 3) * mi * x representative).
		m := m*mi.
		x := x % m].
	^ x lift! !

!ComplexBox methodsFor: 'accessing' stamp: 'len 11/8/2023 17:32:08'!
center
	^ Complex real: real center imaginary: imaginary center! !

!ComplexBox methodsFor: 'accessing' stamp: 'len 1/11/2016 02:58'!
imaginary
	^ imaginary! !

!ComplexBox methodsFor: 'accessing' stamp: 'len 6/5/2016 06:20'!
quarters
	| imaginaries reals |
	reals _ self real halves.
	imaginaries _ self imaginary halves.
	^ {self class real: (reals at: 1) imaginary: (imaginaries at: 1).
		self class real: (reals at: 1) imaginary: (imaginaries at: 2).
		self class real: (reals at: 2) imaginary: (imaginaries at: 1).
		self class real: (reals at: 2) imaginary: (imaginaries at: 2)}! !

!ComplexBox methodsFor: 'accessing' stamp: 'len 11/8/2023 17:34:21'!
radius2
	^ real radius squared + imaginary radius squared! !

!ComplexBox methodsFor: 'accessing' stamp: 'len 1/11/2016 02:58'!
real
	^ real! !

!ComplexBox methodsFor: 'accessing' stamp: 'len 11/11/2023 10:02:13'!
width
	self flag: #deprecated.
	^ real radius * 2! !

!ComplexBox methodsFor: 'printing' stamp: 'len 1/11/2016 02:57'!
printOn: aStream
	aStream print: real; nextPutAll: ' + '; print: imaginary; nextPut: $i! !

!ComplexBox methodsFor: 'testing' stamp: 'len 1/11/2016 02:54'!
includes: aComplex
	^ (real includes: aComplex real) and: [imaginary includes: aComplex imaginary]! !

!ComplexBox methodsFor: 'testing' stamp: 'len 11/8/2023 18:10:12'!
overlaps: aComplexBox
	^ (real overlaps: aComplexBox real) and: [imaginary overlaps: aComplexBox imaginary]! !

!ComplexBox methodsFor: 'private' stamp: 'len 11/8/2023 18:12:03'!
real: aRealBall imaginary: anotherRealBall
	real := aRealBall.
	imaginary := anotherRealBall! !

!ComplexBox class methodsFor: 'instance creation' stamp: 'len 11/8/2023 18:12:32'!
real: aRealBall imaginary: anotherRealBall
	^ self new real: aRealBall imaginary: anotherRealBall! !

!ComplexRootIsolator methodsFor: 'as yet unclassified' stamp: 'len 3/6/2017 16:56:02'!
T2: K at: m radius: r
	| t |
	t _ 0.
	1 to: self derivatives size - 1 do: [:j|
		| f |
		f _ derivatives at: j+1.
		t _ (f value: m) abs * (r ^ j) / j factorial + t].
	^ (derivatives first value: m) abs > (K * t)! !

!ComplexRootIsolator methodsFor: 'as yet unclassified' stamp: 'len 4/24/2018 17:53:58'!
T: K at: m radius: r
	| t |
	t _ 0.
	1 to: self derivatives size do: [:j|
		| f |
		f _ derivatives at: j.
		t _ (f value: m) abs * (r ^ j) / j factorial + t].
	^ (polynomial value: m) abs > (K * t)! !

!ComplexRootIsolator methodsFor: 'as yet unclassified' stamp: 'len 11/9/2023 10:26:25'!
atMostOneRootIn: aBall
	"If this holds, there's at most one root in the given disk."
	^ self T2: 3/2 at: aBall center radius: aBall radius
"	^ (self rootsIn: aBox) size > 1"! !

!ComplexRootIsolator methodsFor: 'as yet unclassified' stamp: 'len 11/12/2023 21:35:03'!
bigBounds
	"Answer a first estimate of an upper bound for the magnitude of all the complex roots."
	^ polynomial norm1 / polynomial leadingCoefficient max: 1! !

!ComplexRootIsolator methodsFor: 'as yet unclassified' stamp: 'len 11/9/2023 19:12:53'!
derivatives
	| f |
	derivatives ifNotNil: [^ derivatives].
	f := polynomial.
	^ derivatives := (1 to: f degree) collect: [:i| f := f derivative]! !

!ComplexRootIsolator methodsFor: 'as yet unclassified' stamp: 'len 4/24/2018 17:54:34'!
eightPointTest: m width: w
	| N NE E SE S SW W NW points values imaginaryCrossings realCrossings |
	N _ 1 i.
	NE _ 20/29 + (21/29) i.
	E _ 1.
	SE _ 20/29 - (21/29) i.
	S _ -1 i.
	SW _ -20/29 - (21/29) i.
	W _ -1.
	NW _ -20/29 + (21/29) i.
	points _ {N. NE. E. SE. S. SW. W. NW} collect: [:p| w*p + m].
	values _ points collect: [:p| polynomial value: p].
	realCrossings _ (1 to: values size) select: [:j| (values at: j) real isZero or: [(values at: j) real * (values atWrap: j+1) real < 0]].
	realCrossings size = 2 ifFalse: [^ false].
	imaginaryCrossings _ (1 to: values size) select: [:j| (values at: j) imaginary isZero or: [(values at: j) imaginary * (values atWrap: j+1) imaginary < 0]].
	imaginaryCrossings size = 2 ifFalse: [^ false].
	realCrossings first < imaginaryCrossings first
		ifTrue: [^ realCrossings second < imaginaryCrossings second].
	^ realCrossings first > imaginaryCrossings first
		and: [realCrossings second > imaginaryCrossings second]! !

!ComplexRootIsolator methodsFor: 'as yet unclassified' stamp: 'len 4/24/2018 18:20:26'!
polynomial
	^ polynomial! !

!ComplexRootIsolator methodsFor: 'as yet unclassified' stamp: 'len 12/23/2023 10:29:44'!
polynomial: aPolynomial
	polynomial := aPolynomial integralPrimitivePart! !

!ComplexRootIsolator methodsFor: 'as yet unclassified' stamp: 'len 11/12/2023 21:39:55'!
roots
	"Separate the roots in disks each of them containing one isolated root."
	| r |
	r := self bigBounds.
	^ self rootsInBox: (ComplexBox real: (Ball center: 0 radius: r) imaginary: (Ball center: 0 radius: r))! !

!ComplexRootIsolator methodsFor: 'as yet unclassified' stamp: 'len 11/12/2023 16:31:31'!
rootsInBox: aBox
	"Separate the roots in disjoint balls, each containing one isolated root."
	| queue disks |
	queue := OrderedCollection with: aBox.
	disks := OrderedCollection new.
	[queue notEmpty and: [disks size < polynomial degree]]
		whileTrue:
			[| B m δ |
			B := queue removeFirst.
			m := B center.
			δ := B width * 3 / 4. "> B radius, and a dyadic fraction"
			(self T: 1 at: m radius: δ)
				"if holds, then D(m,δ) constains no roots"
				ifFalse:
					[((self T2: 6 at: m radius: 4*δ) and: [self T2: 3/2 at: m radius: 8*δ])
						"if the second holds, then D(m,8*δ) contains at most one root"
						"the first is required so that if two disks overlap, we can discard either one of them"
						ifTrue:
							[(self eightPointTest: m width: B width)
								ifTrue:
									[| D i D2 |
									D := Ball center: m radius: 4*δ.
									(i := (1 to: disks size) detect: [:j| (D2 := disks at: j) overlaps: D] ifNone: []) isNil
										ifTrue: [disks add: D]
										ifFalse: [D2 radius < D radius ifTrue: [disks at: i put: D]]]]
						ifFalse:
							[queue addAll: B quarters]]].
	^ disks! !

!ComplexRootIsolator class methodsFor: 'instance creation' stamp: 'len 4/24/2018 18:01:29'!
on: aPolynomial
	^ self new polynomial: aPolynomial! !

!Division methodsFor: 'accessing' stamp: 'len 5/15/2020 05:40:12'!
dividend
	^ dividend! !

!Division methodsFor: 'accessing' stamp: 'len 5/15/2020 05:40:17'!
divisor
	^ divisor! !

!Division methodsFor: 'accessing' stamp: 'len 5/31/2022 16:41:25'!
exactQuotient
	"Answer the quotient of an exact division."
	self remainder isZero ifFalse: [^ DivisibilityError new signalReceiver: dividend selector: #/ argument: divisor].
	^ self quotient! !

!Division methodsFor: 'accessing' stamp: 'len 5/15/2020 06:05:51'!
quotient
	^ quotient ifNil: [quotient _ dividend // divisor]! !

!Division methodsFor: 'accessing' stamp: 'len 5/17/2020 07:32:15'!
remainder
	^ remainder ifNil: [remainder _ dividend - (divisor * self quotient)]! !

!Division methodsFor: 'accessing' stamp: 'len 7/28/2021 12:58:42'!
remainderAlone
	^ self remainder! !

!Division methodsFor: 'printing' stamp: 'len 5/29/2023 14:06:56'!
printOn: aStream
	aStream print: self dividend; nextPutAll: ' = '.
	(divisor includesAnyOf: ' +-/') ifTrue: [aStream withParentheses: [:aStream2| aStream2 print: divisor]] ifFalse: [aStream print: divisor].
	aStream 	nextPutAll: '*'.
	(self quotient includesAnyOf: ' +-/') ifTrue: [aStream withParentheses: [:aStream2| aStream2 print: self quotient]] ifFalse: [aStream print: self quotient].
	aStream nextPutAll: ' + '.
	(self remainder includesAnyOf: ' +-/') ifTrue: [aStream withParentheses: [:aStream2| aStream2 print: self remainder]] ifFalse: [aStream print: self remainder]! !

!Division methodsFor: 'private' stamp: 'len 5/29/2020 19:41:24'!
dividend: a divisor: b
	dividend _ a.
	b isZero ifTrue: [^ (ZeroDivide receiver: a selector: #// argument: b) signal].
	divisor _ b! !

!Division methodsFor: 'private' stamp: 'len 5/15/2020 05:44:56'!
quotient: anElement
	quotient _ anElement! !

!Division methodsFor: 'private' stamp: 'len 5/15/2020 05:44:49'!
remainder: anElement
	remainder _ anElement! !

!Division methodsFor: 'private' stamp: 'len 7/8/2022 11:17:05'!
validate
	super validate.
	self assert: divisor * self quotient + self remainder = dividend! !

!Division class methodsFor: 'instance creation' stamp: 'len 5/15/2020 06:14:59'!
divide: a by: b
	^ self new dividend: a divisor: b! !

!Division class methodsFor: 'instance creation' stamp: 'len 5/15/2020 05:45:23'!
dividend: a divisor: b quotient: q remainder: r
	^ self new dividend: a divisor: b; quotient: q; remainder: r! !

!ExtendedEuclid methodsFor: 'accessing' stamp: 'len 12/21/2022 13:28:52'!
bezout
	"Answer a tuple of Bézout coefficients for the receiver."
	bezout isNil ifTrue: [self run].
	^ bezout! !

!ExtendedEuclid methodsFor: 'accessing' stamp: 'len 12/23/2015 19:49'!
gcd
	gcd isNil ifTrue: [self run].
	^ gcd! !

!ExtendedEuclid methodsFor: 'printing' stamp: 'len 7/8/2022 11:06:23'!
printOn: aStream
	(1 to: elements size)
		do: [:i| aStream print: (elements at: i); nextPut: $*; print: (self bezout at: i)]
		separatedBy: [aStream nextPutAll: ' + '].
	aStream nextPutAll: ' = '; print: self gcd! !

!ExtendedEuclid methodsFor: 'private' stamp: 'len 12/23/2015 20:09'!
elements: anArray
	elements _ anArray! !

!ExtendedEuclid methodsFor: 'private' stamp: 'len 7/30/2021 10:43:43'!
run
	| a b zero one s1 t1 s t r1 r u |
	self assert: elements size = 2.
	a _ elements first. b _ elements second.
	zero _ a zero. one _ a one.
	s1 _ zero. s _ one.
	t1 _ one. t _ zero.
	r1 _ a normalized.
	r _ b normalized.
	[r1 isZero]
		whileFalse:
			[ | q temp |
			q _ r // r1.
			temp _ r1. r1 _ r - (q * r1). r _ temp.
			temp _ s1. s1 _ s - (q * s1). s _ temp.
			temp _ t1. t1 _ t - (q * t1). t _ temp].
	gcd _ r.
	s _ s * b normalization. t _ t * a normalization.
	u _ gcd normalization.
	s _ s * u. t _ t * u. gcd _ gcd * u.
	bezout _ {t. s}! !

!ExtendedEuclid methodsFor: 'private' stamp: 'len 7/8/2022 11:19:28'!
validate
	super validate.
	self assert: (elements * self bezout) sum = self gcd! !

!ExtendedEuclid methodsFor: 'private' stamp: 'len 4/28/2022 13:00:09'!
validate2
	| a b d u v |
	a _ elements at: 1.
	b _ elements at: 2.
	u _ self bezout at: 1.
	v _ self bezout at: 2.
	d _ self gcd.
	(a abs negated / d < (v * b sign) and: [v * b sign <= 0])
		ifFalse: [^ false].
	b = 0 ifTrue: [^ true].
	(1 <= (u * a sign) and: [u * a sign <= (b abs / d)])
		ifFalse: [^ false].
	^ true! !

!ExtendedEuclid methodsFor: 'private' stamp: 'len 7/8/2022 11:06:09'!
validateMinimal
	| a b d u v |
	(elements allSatisfy: [:each| each isInteger]) ifFalse: [^ self].
	a _ elements first.
	b _ elements second.
	d _ self gcd.
	u _ self bezout first.
	v _ self bezout last.
	self assert: a abs / d negated < (v * b sign).
	self assert: v * b sign <= 0.
	self assert: 1 <= (u * a sign).
	self assert: u * a sign <= (b abs / d)! !

!ExtendedEuclid class methodsFor: 'instance creation' stamp: 'len 12/23/2015 20:09'!
on: anArray
	^ self new elements: anArray! !

!FFT methodsFor: 'accessing' stamp: 'len 5/24/2023 13:36:42'!
modulus
	^ modulus! !

!FFT methodsFor: 'accessing' stamp: 'len 5/24/2023 13:36:48'!
size
	^ powers size! !

!FFT methodsFor: 'operations' stamp: 'len 12/27/2023 10:42:40'!
inverseTransform: anArray
	"Inverse-NTT based on the Gentleman-Sade butterfly.
	It takes an input in bit-reversed ordering and produces an output in standard ordering.
	See: Patrick Longa, Michael Naehrig, 'Speeding up the Number Theoretic Transform for Faster Ideal Lattice-Based Cryptography'."
	| n k m j₁ j₂ S U V h |
	self flag: #fixme. "TODO: implement K-RED and K-RED-2x (algorithm 4)"
	n := anArray size.
	self assert: n = self size.
	k := 1.
	m := n.
	[m > 1] whileTrue:
		[j₁ := 0.
		h := m // 2.
		0 to: h - 1 do: [:i|
			j₂ := j₁ + k - 1.
			S := inversePowers at: h + i + 1.
			j₁ to: j₂ do: [:j|
				U := anArray at: j + 1.
				V := anArray at: j + k + 1.
				anArray at: j + 1 put: U + V \\ modulus.
				anArray at: j + k + 1 put: U - V * S \\ modulus].
			j₁ := j₁ + (2 * k)].
		k := k*2.
		m := m // 2].
	1 to: n do: [:j| anArray at: j put: (anArray at: j) * inverseN \\ modulus].
	^ anArray! !

!FFT methodsFor: 'operations' stamp: 'len 12/27/2023 10:42:46'!
transform: anArray
	"NTT based on the Cooley-Tukey butterfly.
	It takes an input in standard ordering and produces an output in bit-reversed ordering.
	See: Patrick Longa, Michael Naehrig, 'Speeding up the Number Theoretic Transform for Faster Ideal Lattice-Based Cryptography'."
	| n k m j₁ j₂ S U V |
	self flag: #fixme. "TODO: implement K-RED and K-RED-2x (algorithm 3)"
	n := anArray size.
	self assert: n = self size.
	k := n.
	m := 1.
	[m < n] whileTrue:
		[k := k // 2.
		0 to: m-1 do: [:i|
			j₁ := 2 * i * k.
			j₂ := j₁ + k - 1.
			S := powers at: m + i + 1.
			j₁ to: j₂ do: [:j|
				U := anArray at: j + 1.
				V := (anArray at: j + k + 1) * S.
				anArray at: j + 1 put: U + V \\ modulus.
				anArray at: j + k + 1 put: U - V \\ modulus]].
		m := m * 2].
	^ anArray! !

!FFT methodsFor: 'printing' stamp: 'len 12/27/2023 09:55:52'!
printOn: aStream
	| factorization |
	aStream nextPutAll: self class name.
	factorization := (modulus - 1) factorization.
	factorization asSet sorted reversed
		do: [:pᵢ| | eᵢ |
			aStream nextPutAll: pᵢ printString sub.
			(eᵢ := factorization occurrencesOf: pᵢ) > 1
				ifTrue: [aStream nextPutAll: eᵢ printStringSuperscript sub]]
		separatedBy: [aStream nextPutAll: '·' sub].
	aStream nextPutAll: '+1' sub.
	aStream nextPutAll: '(2'; nextPutAll: (self size highBit - 1) printString super; nextPut: $)! !

!FFT methodsFor: 'private' stamp: 'len 12/27/2023 10:55:50'!
modulus: mod size: n
	| R x φ ω |
	modulus := mod.
	self assert: mod \\ (2*n) = 1.
	R := ℤ/mod.
	x := R primitiveRoot.
	ω := x^(mod-1 / n).
	self assert: (ω^n) isOne.
	φ := x^(mod-1 / (2*n)).
	self assert: φ^2 = ω.
	inverseN := (R !! n) inverse representative.
	powers := WordArray new: n.
	inversePowers := WordArray new: n.
	0 to: n-1 do: [:i|
		| iᵣ |
		iᵣ := (i bitReverse: n highBit - 1) + 1.
		powers at: iᵣ put: (φ ^ i) representative.
		inversePowers at: iᵣ put: (φ inverse ^ i) representative]! !

!FFT class methodsFor: 'examples' stamp: 'len 5/24/2023 00:57:41'!
example1
	^ self new: 512 mod: 12289! !

!FFT class methodsFor: 'examples' stamp: 'len 5/24/2023 00:57:56'!
example2
	^ self new: 1024 mod: 12289! !

!FFT class methodsFor: 'examples' stamp: 'len 5/24/2023 01:02:23'!
example3
	^ self new: 8 mod: 3*(2^8) + 1! !

!FFT class methodsFor: 'instance creation' stamp: 'len 5/24/2023 14:18:35'!
new: anInteger
	^ self new: anInteger bits: 0! !

!FFT class methodsFor: 'instance creation' stamp: 'len 5/24/2023 14:15:14'!
new: anInteger bits: anotherInteger
	| p t |
	self assert: anInteger isPowerOfTwo.
	t := anInteger*2.
	p := 1 << (anotherInteger - 1) + 1.
	[(p := p + anInteger) isProbablyPrime and: [p \\ t = 1]] whileFalse.
	^ self new: anInteger mod: p! !

!FFT class methodsFor: 'instance creation' stamp: 'len 5/24/2023 01:02:43'!
new: anInteger mod: aPrime
	^ self new modulus: aPrime size: anInteger! !

!GrayCode methodsFor: 'accessing' stamp: 'len 5/21/2023 14:58:23'!
at: anInteger
	| answer |
	answer := 0.
	1 to: anInteger - 1 do: [:i| answer := (increments at: i) bitXor: answer].
	^ answer! !

!GrayCode methodsFor: 'accessing' stamp: 'len 5/21/2023 23:11:15'!
incrementAt: anInteger
	^ increments at: anInteger-1! !

!GrayCode methodsFor: 'accessing' stamp: 'len 5/21/2023 23:24:48'!
indexOf: anInteger
	^ indices at: anInteger+1! !

!GrayCode methodsFor: 'accessing' stamp: 'len 5/21/2023 14:56:41'!
size
	^ indices size! !

!GrayCode methodsFor: 'private' stamp: 'len 5/21/2023 21:08:15'!
initialize: anInteger
	"We only keep indices and increments, and throw away the codewords because we don't need them."
	| G |
	G := #(0 1).
	2 to: anInteger do: [:i| G := G, (G reversed collect: [:each| each bitXor: 1 << (i - 1)])].
	indices := ((0 to: G size - 1) collect: [:each| G indexOf: each]) as: DoubleByteArray.
	increments := ((2 to: G size) collect: [:i| ((G at: i-1) bitXor: (G at: i)) highBit]) as: DoubleByteArray! !

!GrayCode class methodsFor: 'class initialization' stamp: 'len 5/21/2023 21:08:42'!
cacheSize
	^ 12! !

!GrayCode class methodsFor: 'class initialization' stamp: 'len 5/21/2023 21:08:57'!
initialize
	super initialize.
	Cache := Array new: self cacheSize! !

!GrayCode class methodsFor: 'instance creation' stamp: 'len 5/21/2023 15:09:20'!
new: anInteger
	anInteger > Cache size ifTrue: [^ self new initialize: anInteger].
	^ (Cache at: anInteger) ifNil: [Cache at: anInteger put: (self new initialize: anInteger)]! !

!LagrangeGaussReduction methodsFor: 'as yet unclassified' stamp: 'len 12/12/2015 21:55'!
computeShortVector
	| innerProduct a b A B t T n r |
	innerProduct _ vectorSpace innerProduct. "Euclidean inner product"

	"Initialization:"
	a _ v1. b _ v2.
	A _ innerProduct value: {a. a}.
	B _ innerProduct value: {b. b}.
	A < B ifTrue: [b _ v1. a _ v2. t _ A. A _ B. B _ t].
	
	["Euclidean step:"
	n _ innerProduct value: {a. b}.
	r _ (n/B) rounded. "nearest integer"
	T _ A - (2*r*n) + (r*r*B).
	T >= B]
		whileFalse:
			[t _ a - (r*b).
			a _ b.
			b _ t.
			A _ B.
			B _ T].
	
	shortVector _ b! !

!LagrangeGaussReduction methodsFor: 'as yet unclassified' stamp: 'len 12/12/2015 21:55'!
shortVector
	shortVector isNil ifTrue: [self computeShortVector].
	^ shortVector! !

!NewtonInterpolation methodsFor: 'as yet unclassified' stamp: 'len 6/8/2023 19:47:55'!
interpolate: values
	| k v vⱼ x u |
	k := points size.
	v := Array new: k.
	v at: 1 put: (values at: 1).
	2 to: k do: [:j|
		"αⱼ := points at: j."
		vⱼ := v at: j-1.
		j-2 to: 1 by: -1 do: [:i| vⱼ := vⱼ * ((points at: i) - (points at: j)) + (v at: i)].
		vⱼ := ((values at: j) - vⱼ) * (inverses at: j).
		v at: j put: vⱼ].
	x := points first parent polynomials x.
	u := v at: k.
	k-1 to: 1 by: -1 do: [:i| u := u * (x - (points at: i)) + (v at: i)].
	^ u! !

!NewtonInterpolation methodsFor: 'as yet unclassified' stamp: 'len 6/8/2023 19:37:06'!
points: anArray
	| one k α p |
	points := anArray.
	"Precomputations:"
	one := points first one.
	k := points size.
	inverses := Array new: k.
	inverses at: 1 put: one.
	2 to: k do: [:j|
		α := points at: j.
		p := one. 1 to: j-1 do: [:i| p := p * (α - (points at: i))].
		inverses at: j put: p inverse]! !

!NumericalComplexRootIsolator methodsFor: 'accessing' stamp: 'len 5/10/2019 08:30:57'!
rootNear: aComplex
"	[self roots do: [:each| (each approximation - aComplex) abs < epsilon ifTrue: [^ each]].
	self roots do: [:each| each refine]] repeat"
	^ self roots detectMin: [:each| (each approximation - aComplex) abs]! !

!NumericalComplexRootIsolator methodsFor: 'accessing' stamp: 'len 1/15/2016 05:57'!
tolerance
	^ tolerance! !

!NumericalComplexRootIsolator methodsFor: 'accessing' stamp: 'len 1/15/2016 05:53'!
tolerance: aNumber
	tolerance _ aNumber! !

!NumericalComplexRootIsolator methodsFor: 'private' stamp: 'len 1/13/2016 03:01'!
initialValue
	^ 1.3 + 0.314159 i! !

!NumericalComplexRootIsolator methodsFor: 'private' stamp: 'len 1/15/2016 06:09'!
initialize
	super initialize.
	tolerance _ 0.1! !

!NumericalComplexRootIsolator methodsFor: 'private' stamp: 'len 11/20/2023 10:25:25'!
roots
	| roots X P Q P2 Q2 n x v m c dx x1 v1 m1 realCoefficients |
	X := polynomial parent x.
	P := polynomial.
	Q := P.
	P2 := P derivative.
	Q2 := P2.
	n := P degree.
	roots := OrderedCollection new: n.
	realCoefficients := P coefficients allSatisfy: [:each| (each isKindOf: Number) or: [each imaginary isZero]].
	["Initialize root finding:"
	x := self initialValue.
	v := Q value: x.
	m := v abs².
	"Initialize recursion:"
	c := 0. dx := v / (Q2 value: x).
	[dx abs < tolerance]
		whileFalse:
			[x1 := x - dx.
			v1 := Q value: x1.
			m1 := v1 abs².
			m1 < m
				ifTrue: [x := x1. v := v1. m := m1. c := 0. dx := v / (Q2 value: x)]
				ifFalse: [c := c + 1. dx := dx / 4. c > 20 ifTrue: [self error: 'failed']]].
	"Polish root:"
	2 timesRepeat: [x := x - ((P value: x) / (P2 value: x))].
	"Divide:"
	((realCoefficients not or: [n = 1]) or: [x imaginary abs < tolerance "###"])
		ifTrue: "found one root"
			[x imaginary abs < tolerance ifTrue: [x := x real]. "###"
			roots add: (Ball center: x radius: tolerance).
			Q := Q // (X - x).
			Q2 := Q derivative. "###"
			n := n - 1]
		ifFalse: "found a root and (if the root is not real) also found its conjugate"
			[roots
				add: (Ball center: x radius: tolerance);
				add: (Ball center: x conjugate radius: tolerance).
			Q := Q // (X^2 - (X * (x real * 2)) + x abs squared).
			Q2 := Q derivative. "###"
			n := n - 2].
	n > 0] whileTrue.
	^ roots! !

!NumericalComplexRootIsolator class methodsFor: 'instance creation' stamp: 'len 1/9/2022 08:38:42'!
polynomial: aPolynomial
	^ self squarefreePolynomial: aPolynomial // (aPolynomial gcd: aPolynomial derivative)! !

!NumericalComplexRootIsolator class methodsFor: 'instance creation' stamp: 'len 1/9/2022 08:38:08'!
squarefreePolynomial: aPolynomial
	^ super polynomial: aPolynomial! !

!ProductReplacementRandomGenerator methodsFor: 'accessing' stamp: 'len 5/25/2019 04:34:49'!
generators: aCollection
	generators _ aCollection.
	state _ nil! !

!ProductReplacementRandomGenerator methodsFor: 'generating' stamp: 'len 5/25/2019 04:36:25'!
atRandom: aRandom
	"Product Replacement Algorithm. After the initial precomputation, every new random element takes one multiplication and 1/2 inversion in the group."
	| g h i |
	state isNil ifTrue: "initial precomputation takes about 60 multiplications / inversions in the group"
		[state _ generators asOrderedCollection.
		60 - (state size min: 10) timesRepeat: [self atRandom: aRandom]].
	g _ state atRandom: aRandom.
	[(state at: (i _ state size atRandom: aRandom)) == g and: [state size > 1 "otherwise fails with cyclic groups"]] whileTrue.
	(2 atRandom: aRandom) = 1 ifTrue: [g _ g inverse].
	h _ aRandom nextBoolean ifTrue: [g · (state at: i)] ifFalse: [(state at: i) · g].
	state size < 10 ifTrue: [state add: h] ifFalse: [state at: i put: h].
	^ h! !

!PseudoDivision methodsFor: 'accessing' stamp: 'len 3/8/2016 22:39'!
delta
	"Answer an integer delta such that the dividend multiplied by the divisor's leading coeficient raised to the delta equals the product of the quotient by the divisor plus the remainder (the pseudo-division relation)."
	^ self dividend degree - self divisor degree + 1 max: 0! !

!PseudoDivision methodsFor: 'accessing' stamp: 'len 12/11/2015 06:55'!
dividend
	^ dividend! !

!PseudoDivision methodsFor: 'accessing' stamp: 'len 12/2/2015 02:51'!
divisor
	^ divisor! !

!PseudoDivision methodsFor: 'accessing' stamp: 'len 5/31/2022 16:41:13'!
exactQuotient
	"Answer the quotient of an exact division."
	self remainder isZero ifFalse: [^ DivisibilityError new signalReceiver: dividend selector: #/ argument: divisor].
	^ self quotient / (divisor leadingCoefficient ^ self delta)! !

!PseudoDivision methodsFor: 'accessing' stamp: 'len 5/22/2022 11:06:15'!
quotient
	quotient isNil ifTrue: [remainder notNil ifTrue: [self error: 'should call #quotient first']. self run].
	^ quotient! !

!PseudoDivision methodsFor: 'accessing' stamp: 'len 5/22/2022 11:06:29'!
remainder
	remainder isNil ifTrue: [self run].
	^ remainder! !

!PseudoDivision methodsFor: 'accessing' stamp: 'len 7/28/2021 12:59:10'!
remainderAlone
	^ self remainder! !

!PseudoDivision methodsFor: 'printing' stamp: 'len 7/8/2016 05:47'!
printOn: aStream
	"Print a representation of the receiver on the stream aStream."

	aStream
		print: (self divisor leadingCoefficient ^ self delta);
		nextPut: $(;
		print: self dividend;
		nextPutAll: ') = (';
		print: self quotient;
		nextPutAll: ')(';
		print: self divisor;
		nextPutAll: ') + ';
		print: self remainder! !

!PseudoDivision methodsFor: 'private' stamp: 'len 12/11/2015 06:56'!
divide: aPolynomial by: anotherPolynomial
	dividend _ aPolynomial.
	divisor _ anotherPolynomial! !

!PseudoDivision methodsFor: 'private' stamp: 'len 10/28/2023 09:30:30'!
run
	"[Coh96] Algorithm 3.1.2 (Pseudo-Division)."
	| P m n d e lc s |
	divisor isZero ifTrue: [^ (ZeroDivide receiver: dividend selector: #// argument: divisor) signal].
	P := dividend parent.
	(m := dividend degree) < (n := divisor degree)
		ifTrue: [quotient := P zero. remainder := dividend. ^ self].
	d := divisor leadingCoefficient.
	remainder := dividend.
	quotient := P zero.
	e := m - n + 1.
	[remainder degree < n
		ifTrue: [| q | q := d ^ e. quotient := quotient * q. remainder := remainder * q. ^ self].
	lc := remainder leadingCoefficient.
	s := P coefficient: lc xTo: remainder degree - n.
	quotient := quotient * d + s.
	remainder := remainder * d - (divisor * s).
	e := e - 1] repeat! !

!PseudoDivision methodsFor: 'private' stamp: 'len 7/8/2022 11:19:17'!
validate
	super validate.
	self assert: dividend * (divisor leadingCoefficient ^ self delta) = (self quotient * divisor + self remainder)! !

!PseudoDivision class methodsFor: 'instance creation' stamp: 'len 12/11/2015 06:57'!
divide: aPolynomial by: anotherPolynomial
	"Answer a pseudo-division algorithm to divide aPolynomial by anotherPolynomial."
	^ self new divide: aPolynomial by: anotherPolynomial! !

!RealRootIsolator methodsFor: 'accessing' stamp: 'len 11/18/97 00:38'!
fourier
	"Answer the Budan-Fourier sequence for the polynomial of the receiver."

	fourier isNil ifTrue: [self computeFourier].
	^ fourier! !

!RealRootIsolator methodsFor: 'accessing' stamp: 'len 4/24/2018 18:20:19'!
polynomial
	^ polynomial! !

!RealRootIsolator methodsFor: 'accessing' stamp: 'len 6/5/2016 04:47'!
roots
	"Answer a collection with the roots of the polynomial."
	roots isNil ifTrue: [self separateRoots].
	^ roots! !

!RealRootIsolator methodsFor: 'accessing' stamp: 'len 8/23/97 18:10'!
sturm
	"Answer a sturm sequence for the polynomial of the receiver."

	sturm isNil ifTrue: [self computeSturm].
	^ sturm! !

!RealRootIsolator methodsFor: 'couting roots' stamp: 'len 11/12/2023 22:25:16'!
atMostOneRootIn: aBall
	^ (self moreThanOneRootBetween: aBall center - aBall radius and: aBall center + aBall radius) not! !

!RealRootIsolator methodsFor: 'couting roots' stamp: 'len 4/24/2018 17:59:22'!
lowerBoundNumberOfRootsBetween: leftBound and: rightBound
	"Answer a lower bound for the number of real roots in the open interval (leftBound, rightBound)."
	| answer last sign |
	answer _ 0.
	last _ 0.
	1 to: polynomial degree * 2 do: [:each|
		sign _ (polynomial value: (rightBound - leftBound) / each) sign.
		(last ~= sign and: [sign ~= 0]) ifTrue: [answer _ answer + 1].
		last _ sign].
	^ answer! !

!RealRootIsolator methodsFor: 'couting roots' stamp: 'len 1/16/2016 08:33'!
moreThanOneRootBetween: leftBound and: rightBound
	"Answer true if there are only one root in the interval (leftBound, rightBound]."

	| upper lower |
	sturm isNil "if the Sturm chain was not yet computed, first try some bounds and heuristics"
		ifTrue:
			[(upper _ self upperBoundNumberOfRootsBetween: leftBound and: rightBound) < 2
				ifTrue: [^ false].
			(upper even and: [self heuristicDetectOneRootBetween: leftBound and: rightBound])
				ifTrue: [^ true].
			lower _ self lowerBoundNumberOfRootsBetween: leftBound and: rightBound.
			lower > 1 ifTrue: [^ true].
			(upper even and: [lower > 0]) ifTrue: [^ true]].

	^ (self numberOfRootsBetween: leftBound and: rightBound) > 1! !

!RealRootIsolator methodsFor: 'couting roots' stamp: 'len 11/12/2023 21:40:13'!
numberOfNegativeRoots
	"Answer the number of negative roots."
	| fix |
	fix := (polynomial value: 0) = 0 ifTrue: [1] ifFalse: [0].
	^ (self numberOfRootsBetween: self bigBounds negated and: 0) - fix! !

!RealRootIsolator methodsFor: 'couting roots' stamp: 'len 11/12/2023 21:40:19'!
numberOfPositiveRoots
	"Answer the number of positive roots."
	^ self numberOfRootsBetween: 0 and: self bigBounds! !

!RealRootIsolator methodsFor: 'couting roots' stamp: 'len 11/12/2023 21:40:45'!
numberOfRoots
	"Answer the number of real roots of the receiver."
	| r |
	r := self bigBounds.
	^ self numberOfRootsBetween: r negated and: r! !

!RealRootIsolator methodsFor: 'couting roots' stamp: 'len 1/16/2016 08:03'!
numberOfRootsBetween: leftBound and: rightBound
	"Answer the number of real roots in the left open interval (leftBound, rightBound]."

	| leftSignChanges rightSignChanges a b |
	a _ leftBound asFraction.
	b _ rightBound asFraction.
	leftSignChanges _ 0.
	(self sturm collect: [ :each | (each value: a) sign])
		inject: 0 into: [ :lastSign :each |
			(lastSign ~= each and: [each ~= 0])
				ifTrue: [leftSignChanges _ leftSignChanges + 1].
			each].

	rightSignChanges _ 0.
	(self sturm collect: [ :each | (each value: b) sign])
		inject: 0 into: [ :lastSign :each |
			(lastSign ~= each and: [each ~= 0])
				ifTrue: [rightSignChanges _ rightSignChanges + 1].
			each].

	^ leftSignChanges - rightSignChanges! !

!RealRootIsolator methodsFor: 'couting roots' stamp: 'len 11/12/2023 22:24:29'!
upperBoundNumberOfRoots
	"Answer an upper bound for the number of real roots of the receiver."
	| r |
	r := self bigBounds.
	^ self upperBoundNumberOfRootsBetween: r negated and: r! !

!RealRootIsolator methodsFor: 'couting roots' stamp: 'len 11/24/2015 06:10'!
upperBoundNumberOfRootsBetween: leftBound and: rightBound
	"Answer an upper bound for the number of real roots
	in the open interval (leftBound, rightBound)."

	| leftSignChanges rightSignChanges |

	leftSignChanges _ 0.
	(self fourier collect: [ :each | (each value: leftBound) sign])
		inject: 0 into: [ :lastSign :each |
			(lastSign ~= each and: [each ~= 0])
				ifTrue: [leftSignChanges _ leftSignChanges + 1].
			each].

	rightSignChanges _ 0.
	(self fourier collect: [ :each | (each value: rightBound) sign])
		inject: 0 into: [ :lastSign :each |
			(lastSign ~= each and: [each ~= 0])
				ifTrue: [rightSignChanges _ rightSignChanges + 1].
			each].

	^ leftSignChanges - rightSignChanges! !

!RealRootIsolator methodsFor: 'initialization' stamp: 'len 4/24/2018 18:02:05'!
polynomial: aPolynomial
	polynomial _ aPolynomial! !

!RealRootIsolator methodsFor: 'operations' stamp: 'len 11/12/2023 21:41:26'!
separateRoots
	"Separate the roots in intervals each of them including an isolated root."
	| r |
	roots := SortedCollection sortBlock: [ :one :other | one center <= other center].
	r := self bigBounds.
	self separateRootsBetween: r negated and: r! !

!RealRootIsolator methodsFor: 'operations' stamp: 'len 11/10/2023 14:35:42'!
separateRootsBetween: leftBound and: rightBound
	"Separate the roots in the real interval given by the arguments."
	| r mid |
	r := self numberOfRootsBetween: leftBound and: rightBound.
	r = 0 ifTrue: [^ self].
	mid := leftBound + rightBound / 2. "2 for exact rationals or 2.0 to use floats."
	r = 1 ifTrue: [^ roots add: (Ball center: mid radius: rightBound - leftBound / 2)].
	self separateRootsBetween: leftBound and: mid.
	self separateRootsBetween: mid and: rightBound! !

!RealRootIsolator methodsFor: 'private' stamp: 'len 11/12/2023 21:35:25'!
bigBounds
	"Answer a first estimate of an upper bound for the magnitude of all the real roots."
	^ polynomial norm1 asFloat / polynomial leadingCoefficient max: 1! !

!RealRootIsolator methodsFor: 'private' stamp: 'len 4/24/2018 17:59:04'!
computeFourier
	"Compute the Budan-Fourier sequence for the polynomial of the receiver."
	| f |
	f _ polynomial.
	fourier _ (OrderedCollection new: f degree + 1) add: f; yourself.
	f degree timesRepeat: [fourier add: (f _ f derivative)]! !

!RealRootIsolator methodsFor: 'private' stamp: 'len 4/24/2018 17:59:08'!
computeSturm
	"Compute a sturmian sequence for the receiver."
	| f g r |
	f _ polynomial.
	g _ f derivative.
	sturm _ (OrderedCollection new: f degree + 1) add: f; add: g; yourself.
	[g degree > 0]
		whileTrue:
			[r _ sturm add: (f \\ g) negated.
			f _ g.
			g _ r]! !

!RealRootIsolator methodsFor: 'private' stamp: 'len 4/24/2018 17:59:00'!
heuristicDetectOneRootBetween: leftBound and: rightBound
	| first |
	first _ polynomial value: leftBound.
	2 to: 10 do: [:each|
		first ~= (polynomial value: (rightBound - leftBound) / each) sign
			ifTrue: [^ true]].
	^ false! !

!RealRootIsolator class methodsFor: 'instance creation' stamp: 'len 4/24/2018 18:01:20'!
on: aPolynomial
	^ self new polynomial: aPolynomial! !

!SchreierSims methodsFor: 'accessing' stamp: 'len 12/10/2023 11:25:57'!
base
	"A base of a group G acting on X is a finite sequence of distinct points B={x₁,..,xₙ} such that the stabilizer of B is {id}, i.e. the only element that fixes all xᵢ is the identity."
	^ base! !

!SchreierSims methodsFor: 'accessing' stamp: 'len 12/10/2023 11:26:03'!
order
	"Answer the order of the group."
	^ order! !

!SchreierSims methodsFor: 'accessing' stamp: 'len 12/10/2023 11:26:08'!
strongGenerators
	^ strongGenerators! !

!SchreierSims methodsFor: 'computing' stamp: 'len 12/10/2023 11:32:26'!
contains: anElement
	"Answer true if the group includes anElement."
	(strongGenerators includes: anElement) ifTrue: [^ true].
	^ (self strip: anElement) first = action group identity! !

!SchreierSims methodsFor: 'computing' stamp: 'len 5/8/2019 19:33:18'!
elementFromImage: anArray
	| image g |
	image _ anArray copy.
	g _ action group identity.
	trees withIndexDo: [:each :i|
		g _ (each trace: (image at: i)) · g.
		i to: base size do: [:j| image at: j put: (action value: {each traceInverse: (image at: i). image at: j})]].
	^ g! !

!SchreierSims methodsFor: 'computing' stamp: 'len 6/30/2016 10:02'!
imageOf: anElement
	^ base collect: [:each| action value: {anElement. each}]! !

!SchreierSims methodsFor: 'computing' stamp: 'len 12/11/2023 19:46:36'!
sift: anElement
	"Answer anElement as a word on the strong generators, or nil if it is not a member of the group."
	^ self notYetImplemented! !

!SchreierSims methodsFor: 'computing' stamp: 'len 12/11/2023 10:39:07'!
strip: anElement
	| g |
	g := anElement.
	trees withIndexDo: [:each :i| | b b₂ |
		b := each root.
		b₂ := action value: {g. b}.
		(each orbit includes: b₂) ifFalse: [^ {g. i}].
		g := g · (each traceInverse: b₂)].
	^ {g. trees size + 1}! !

!SchreierSims methodsFor: 'computing-private' stamp: 'len 12/10/2023 10:59:56'!
buildBSGS
	base _ OrderedCollection new.
	strongGenerators _ OrderedCollection new.
	self buildPartialBSGS.
	base size to: 1 by: -1 do: [:i| self schreierSimsStep: i]! !

!SchreierSims methodsFor: 'computing-private' stamp: 'len 12/10/2023 10:59:56'!
buildPartialBSGS
	| id |
	id _ action group identity.
	generators do: [:each| each = id ifFalse: [strongGenerators add: each]].
	strongGenerators copy do: [:s|
		(base allSatisfy: [:b| (s value: b) = b])
			ifTrue: [base add: (action space detect: [:one| action isFixedPoint: one])].
			s squared = id ifFalse: [base add: s inverse]]! !

!SchreierSims methodsFor: 'private' stamp: 'len 12/18/2023 11:26:48'!
action: aGroupAction
	| G |
	action := aGroupAction.
	G := action group.
	order := 1.
	base := OrderedCollection new.
	strongGenerators := OrderedCollection new.
	trees := OrderedCollection new.
	action space do: [:b| | T |
		G isTrivial ifTrue: [base := base asArray. strongGenerators := strongGenerators asArray. trees := trees asArray. ^ self].
		base add: b.
		strongGenerators addAll: G generators.
		T := SchreierTree root: b generators: G generators action: action.
		trees add: T.
		order := order * T orbit size.
		G := T stabilizer]! !

!SchreierTree methodsFor: 'accessing' stamp: 'len 6/24/2016 03:07'!
orbit
	^ orbit! !

!SchreierTree methodsFor: 'accessing' stamp: 'len 12/10/2023 11:26:48'!
root
	^ root! !

!SchreierTree methodsFor: 'accessing' stamp: 'len 6/26/2023 13:01:14'!
stabilizer
	"Answer the stabilizer of the root."
	| stabilizerGenerators id |
	stabilizerGenerators := Set new.
	id := action group identity.
	self orbit do: [:i|
		generators do: [:s|
			| g |
			g := (self traceInverse: (s value: i)) · s · (self trace: i).
			g = id ifFalse: [stabilizerGenerators add: g]]].
	^ action group sub: stabilizerGenerators! !

!SchreierTree methodsFor: 'accessing' stamp: 'len 12/6/2023 10:32:17'!
trace: aPoint
	"Trace the Schreier spanning tree (v,w) for the orbit containing aPoint.
	Answer the transversal u(aPoint), i.e. an element such that root^u(aPoint) = aPoint.
	This is the representative function, and in particular u(root^h) is a representative of the coset G_root * h, where G_root is the stabilizer at the root of this Schreier tree.
	For an element g in G, there's an h in G_root g = h * u(root^g), and h = h * u(root^h)^-1."
	| α u |
	u := action group identity.
	α := aPoint.
	[(v at: α) notNil]
		whileTrue:
			[u := u · (v at: α).
			α := w at: α].
	^ u! !

!SchreierTree methodsFor: 'accessing' stamp: 'len 12/23/2023 11:02:27'!
traceInverse: aPoint
	"Calculate inverses of coset representatives.
	See 'The Schreier-Sims Algorithm' pp 18. If we used a strong generating set closed under inversion, backward pointers would be unnecessary."
	| α u |
	u := action group identity.
	α := aPoint.
	[(v at: α) notNil]
		whileTrue:
			[u := (inverses at: α ifAbsentPut: [(v at: α) inverse]) · u.
			α := w at: α].
	^ u! !

!SchreierTree methodsFor: 'private' stamp: 'len 12/11/2023 20:42:09'!
root: aPoint generators: anArray action: aGroupAction
	| queue |
	root := aPoint.
	generators := anArray.
	action := aGroupAction.
	v := Dictionary new. "Schreier vector"
	w := Dictionary new. "backward pointers"
	inverses := Dictionary new. "inverses of the Schreier generators from v"
	orbit := Set with: aPoint.
	v at: aPoint put: nil. "-1"
	w at: aPoint put: nil. "-1"
	queue := OrderedCollection with: aPoint.
	[| a |
	a := queue removeFirst.
	1 to: generators size do: [:i|
		| x g |
		g := generators at: i.
		x := action value: {g. a}.
		(orbit includes: x)
			ifFalse:
				[orbit add: x.
				queue add: x.
				v at: x put: g.
				w at: x put: a]].
	queue isEmpty] whileFalse.
	"self validate"! !

!SchreierTree methodsFor: 'private' stamp: 'len 7/8/2022 11:16:55'!
validate
	super validate.
	self assert: (self stabilizer generators allSatisfy: [:each| (each value: root) = root])! !

!SchreierTree class methodsFor: 'instance creation' stamp: 'len 6/24/2016 03:07'!
root: aPoint generators: anArray action: aGroupAction
	^ self new root: aPoint generators: anArray action: aGroupAction! !

!TonelliShanks methodsFor: 'computing' stamp: 'len 3/6/2017 17:04:50'!
squareRootOf: anInteger
	| a y r x b m b2 t |
	anInteger == 0 ifTrue: [^ anInteger].
	a _ anInteger.
	y _ z. r _ e. x _ a raisedTo: q-1 // 2 modulo: p. b _ a*x squared \\ p. x _ a*x \\ p.
	[b == 1 ifTrue: [^ x].
	b2 _ b. m _ 1. [(b2 _ b2 squared \\ p) == 1] whileFalse: [m _ m + 1].
	(b raisedTo: (2 ^ m) modulo: p) == 1 ifFalse: [self halt].
	(m > 1 and: [(b raisedTo: (2 ^ (m-1)) modulo: p) == 1]) ifTrue: [self halt].
	m = r ifTrue: [^ nil]. "the input is not a quadratic residue modulo p"
	t _ y. r - m - 1 timesRepeat: [t _ t squared \\ p]. "t _ y ^ (2 ^ (r - m - 1)) mod p"
	y _ t squared \\ p. r _ m. x _ x * t \\ p. b _ b * y \\ p] repeat! !

!TonelliShanks methodsFor: 'private' stamp: 'len 5/12/2023 21:12:36'!
modulus: anInteger
	| n |
	anInteger == 2 ifTrue: [self error: 'modulus must be odd'].
	p _ anInteger.
	e _ (p - 1) lowBit - 1.
	q _ p - 1 bitShift: e negated.
	"find generator of the multiplicative group of units (ℤ/pℤ)*"
	[n _ (p - 1) atRandom.
	(n kronecker: p) == -1] whileFalse.
	z _ n raisedTo: q modulo: p.! !

!Echelonization methodsFor: 'accessing' stamp: 'len 5/12/2023 20:47:41'!
echelon
	echelon isNil ifTrue: [echelon _ matrix copy. transformation _ nil. self run].
	^ echelon! !

!Echelonization methodsFor: 'accessing' stamp: 'len 5/12/2023 20:47:53'!
echelonAndTransformation
	transformation isNil ifTrue: [echelon _ matrix copy. transformation _ matrix codomain id copy. self run].
	^ {echelon. transformation}! !

!Echelonization methodsFor: 'row operations' stamp: 'len 12/29/2022 10:24:10'!
addRow: i₁ times: anElement to: i₂
	self addRow: i₁ times: anElement to: i₂ startingAt: 1! !

!Echelonization methodsFor: 'row operations' stamp: 'len 12/29/2022 10:23:38'!
addRow: i₁ times: anElement to: i₂ startingAt: startColumn
	echelon addRow: i₁ times: anElement to: i₂ startingAt: startColumn.
	transformation ifNotNil: [transformation addRow: i₁ times: anElement to: i₂]! !

!Echelonization methodsFor: 'row operations' stamp: 'len 12/29/2022 10:24:22'!
multiplyRow: i by: anElement
	self multiplyRow: i by: anElement startingAt: 1! !

!Echelonization methodsFor: 'row operations' stamp: 'len 12/29/2022 10:24:57'!
multiplyRow: i by: anElement startingAt: startColumn
	echelon multiplyRow: i by: anElement startingAt: startColumn.
	transformation ifNotNil: [transformation multiplyRow: i by: anElement]! !

!Echelonization methodsFor: 'row operations' stamp: 'len 12/29/2022 10:25:20'!
swapRow: i with: j
	echelon swapRow: i with: j.
	transformation ifNotNil: [transformation swapRow: i with: j]! !

!Echelonization methodsFor: 'private' stamp: 'len 12/13/2022 13:15:17'!
matrix: aMatrix
	matrix _ aMatrix! !

!Echelonization class methodsFor: 'instance creation' stamp: 'len 5/19/2023 07:12:44'!
on: aMatrix
	^ self new matrix: aMatrix! !

!GaussJordanEchelonization methodsFor: 'accessing' stamp: 'len 12/29/2022 10:21:38'!
determinant
	| determinant |
	determinant _ matrix scalars one.
	self echelon diagonalDo: [:each| determinant _ determinant * each].
	^ determinant / determinantFactor! !

!GaussJordanEchelonization methodsFor: 'computing' stamp: 'len 6/17/2023 22:26:08'!
reduceStep: pivot
	"Perform the reduction step on row i and column j."
	| i j i₀ |
	i := pivot x.
	j := pivot y.
	"2. Column finished?"
	[i₀ := (echelon height to: i+1 by: -1)
		detect: [:k| (echelon isZeroAt: k@j) not]
		ifNone: [^ self multiplyRow: i by: (echelon at: pivot) normalization startingAt: j "and go to step 5"].
	i₀ > i ifTrue: [self swapRow: i₀ with: i].
	self multiplyRow: i by: (echelon at: pivot) inverse startingAt: j.
	"4. Reduce:"
	echelon height to: i+1 by: -1 do: [:k| self addRow: i times: (echelon at: k@j) negated to: k startingAt: j]] repeat! !

!GaussJordanEchelonization methodsFor: 'computing' stamp: 'len 6/17/2023 22:27:11'!
run
	| n m i j b |
	determinantFactor := matrix scalars one.
	m := echelon height.
	n := echelon width.
	(m = 0 or: [n = 0]) ifTrue: [^ self]. "nothing to do"
	i := 1.
	j := 1.
	[self reduceStep: i@j.
	(echelon isZeroAt: i@j)
		ifTrue:
			[i := i - 1]
		ifFalse:
			[b := echelon at: i@j.
			1 to: i-1 do: [:k| self addRow: i times: ((echelon at: k@j) / b) negated to: k startingAt: j]].
	j = n or: [i = m]] whileFalse: [i := i + 1. j := j + 1]! !

!GaussJordanEchelonization methodsFor: 'row operations' stamp: 'len 12/29/2022 10:29:39'!
multiplyRow: i by: anElement startingAt: startColumn
	super multiplyRow: i by: anElement startingAt: startColumn.
	determinantFactor _ determinantFactor * anElement! !

!GaussJordanEchelonization methodsFor: 'row operations' stamp: 'len 12/29/2022 10:34:48'!
swapRow: i with: j
	i = j ifTrue: [^ self].
	super swapRow: i with: j.
	determinantFactor _ determinantFactor negated! !

!HermiteEchelonization methodsFor: 'computing' stamp: 'len 6/17/2023 22:25:50'!
reduceStep: pivot
	"Perform the reduction step on row i and column j."
	| i j i₀ b |
	i := pivot x.
	j := pivot y.
	"2. Column finished?"
	[i₀ := (echelon height to: i+1 by: -1)
		detect: [:k| (echelon isZeroAt: k@j) not]
		ifNone: [^ self multiplyRow: i by: (echelon at: pivot) normalization startingAt: j "and go to step 5"].
	"3. Choose nonzero entry with smallest Euclidean valuation:"
	i₀ := ((i to: i₀) select: [:k| (echelon isZeroAt: k@j) not]) detectMin: [:k| (echelon at: k@j) gauge].
	i₀ > i ifTrue: [self swapRow: i₀ with: i].
	self multiplyRow: i by: (echelon at: pivot) normalization startingAt: j.
	b := echelon at: pivot.
	"4. Reduce:"
	echelon height to: i+1 by: -1 do: [:k| self addRow: i times: ((echelon at: k@j) // b) negated to: k startingAt: j]] repeat! !

!HermiteEchelonization methodsFor: 'computing' stamp: 'len 6/17/2023 22:25:39'!
run
	| n m i j b |
	m := echelon height.
	n := echelon width.
	(m = 0 or: [n = 0]) ifTrue: [^ self]. "nothing to do"
	"1. Initialize:"
	i := 1.
	j := 1.
	[self reduceStep: i@j.
	"5. Final reductions:"
	(echelon isZeroAt: i@j)
		ifTrue:
			[i := i - 1]
		ifFalse:
			[b := echelon at: i@j.
			1 to: i-1 do: [:k| self addRow: i times: ((echelon at: k@j) // b) negated to: k startingAt: j]].
	"6. Finished?"
	j = n or: [i = m]] whileFalse: [i := i + 1. j := j + 1]! !

!HowellEchelonization methodsFor: 'computing' stamp: 'len 6/12/2023 16:54:13'!
run
	| width height |
	width := echelon width.
	height := echelon height.
	(width = 0 or: [height = 0]) ifTrue: [^ self]. "nothing to do"
	"If more columns than rows, augment the matrix with zero rows to make it square:"
	width > height ifTrue:
		[self addZeroRows: width - height.
		height := width].
	"Put it in upper triangular form:"
	1 to: width do: [:j| j+1 to: height do: [:i| self cancel: j@j with: i]].
"	self assert: echelon isUpperTriangular."
	"Put it in Howell form:"
	self addZeroRows: 1. "augment with one zero row"
	1 to: width do: [:i|
		(echelon isZeroAt: i@i)
			ifTrue:
				[self copyRow: i to: height+1]"width"
			ifFalse:
				[self multiplyRow: i by: (echelon at: i@i) normalization.
				1 to: i-1 do: [:j| self addRow: i times: ((echelon at: j@i) // (echelon at: i@i)) negated to: j].
				self copyRow: i times: (echelon at: i@i) annihilator to: height+1].
		i+1 to: width do: [:j| self cancel: j@j with: height+1]].
	"Sort rows"
	self sort.
	"Output first m rows"
	echelon := echelon copyFromRow: 1 to: width.
	transformation ifNotNil: [transformation := transformation copyFromRow: 1 to: width]! !

!HowellEchelonization methodsFor: 'computing' stamp: 'len 12/29/2022 19:52:41'!
sort
	"Sort the rows to put the matrix in echelon form."
	| height width i j |
	height _ echelon height.
	width _ echelon width.
	i _ 1.
	j _ 1.
	[(echelon isZeroAt: i@j)
		ifTrue:
			[(i+1 to: height)
				detect: [:k| (echelon isZeroAt: k@j) not]
				ifFound: [:k| self swapRow: k with: i]
				ifNone: [i _ i - 1]].
	j _ j + 1.
	i _ i + 1.
	j <= width] whileTrue! !

!HowellEchelonization methodsFor: 'row operations' stamp: 'len 5/12/2023 20:48:22'!
addZeroRows: n
	echelon _ echelon ⊓ (echelon domain ⇒ (echelon scalars ^ n)) zero.
	transformation ifNotNil: [transformation _ transformation ⊓ (transformation domain ⇒ (echelon scalars ^ n)) zero]! !

!HowellEchelonization methodsFor: 'row operations' stamp: 'len 12/29/2022 16:32:55'!
cancel: aPoint with: i
	| mgcd |
	mgcd _ (echelon at: aPoint) xxgcd: (echelon at: i @ aPoint y).
	echelon cancelRow: aPoint x and: i with: mgcd.
	transformation ifNotNil: [transformation cancelRow: aPoint x and: i with: mgcd]! !

!HowellEchelonization methodsFor: 'row operations' stamp: 'len 12/29/2022 10:43:32'!
copyRow: i₁ times: anElement to: i₂
	self copyRow: i₁ times: anElement to: i₂ startingAt: 1! !

!HowellEchelonization methodsFor: 'row operations' stamp: 'len 12/29/2022 10:44:47'!
copyRow: i₁ times: anElement to: i₂ startingAt: startColumn
	echelon copyRow: i₁ times: anElement to: i₂ startingAt: startColumn.
	transformation ifNotNil: [transformation copyRow: i₁ times: anElement to: i₂]! !

!HowellEchelonization methodsFor: 'row operations' stamp: 'len 12/29/2022 10:45:21'!
copyRow: i₁ to: i₂
	self copyRow: i₁ to: i₂ startingAt: 1! !

!HowellEchelonization methodsFor: 'row operations' stamp: 'len 12/29/2022 10:46:16'!
copyRow: i₁ to: i₂ startingAt: startColumn
	echelon copyRow: i₁ to: i₂ startingAt: startColumn.
	transformation ifNotNil: [transformation copyRow: i₁ to: i₂]! !

!MultivariateDivision methodsFor: 'accessing' stamp: 'len 12/2/2015 02:48'!
dividend
	^ dividend! !

!MultivariateDivision methodsFor: 'accessing' stamp: 'len 12/2/2015 02:48'!
divisors
	^ divisors! !

!MultivariateDivision methodsFor: 'accessing' stamp: 'len 5/31/2022 16:40:54'!
exactQuotient
	self remainder isZero ifFalse: [^ DivisibilityError new signalReceiver: dividend selector: #/ argument: divisors].
	^ self quotient! !

!MultivariateDivision methodsFor: 'accessing' stamp: 'len 3/9/2016 07:55'!
quotient
	self quotients size = 1 ifFalse: [self error: 'not just one quotient'].
	^ self quotients first! !

!MultivariateDivision methodsFor: 'accessing' stamp: 'len 5/22/2022 11:06:05'!
quotients
	quotients isNil ifTrue: [self run].
	^ quotients! !

!MultivariateDivision methodsFor: 'accessing' stamp: 'len 5/22/2022 11:06:09'!
remainder
	remainder isNil ifTrue: [self run].
	^ remainder! !

!MultivariateDivision methodsFor: 'accessing' stamp: 'len 7/28/2021 07:41:51'!
remainderAlone
	| p head |
	remainder ifNotNil: [^ remainder].
	divisors isEmpty ifTrue: [^ remainder _ dividend].
	remainder _ dividend zero.
	p _ dividend.
	[p isZero] whileFalse:
		[head _ p leadingMonomial.
		divisors detect: [:fi| fi leadingMonomial | head]
			ifFound: [:fi| p _ p + (fi * (head / fi leadingMonomial) * (p leadingCoefficient negated / fi leadingCoefficient))]
			ifNone:
				[remainder _ remainder + p leadingTerm.
				p _ p tail]].
	^ remainder! !

!MultivariateDivision methodsFor: 'printing' stamp: 'len 1/24/98 12:49'!
printOn: aStream
	"Print a representation of the receiver on the stream aStream."

	aStream print: self dividend; nextPutAll: ' = '.
	(1 to: self divisors size) do: [ :each |
		aStream
			nextPut: $(; print: (self quotients at: each); nextPut: $);
			nextPut: $(; print: (self divisors at: each); nextPut: $);
			nextPutAll: ' + '].
	aStream print: self remainder! !

!MultivariateDivision methodsFor: 'private' stamp: 'len 12/6/2015 19:03'!
divide: aPolynomial by: anArrayOfPolynomials
	dividend _ aPolynomial.
	divisors _ anArrayOfPolynomials! !

!MultivariateDivision methodsFor: 'private' stamp: 'len 6/17/2023 14:42:37'!
run
	"Perform the division algorithm computing quotients and remainder."
	| R p s fᵢ qᵢ q m c i |
	R := dividend isTuple ifTrue: [dividend scalars] ifFalse: [dividend parent].
	quotients := Array new: divisors size withAll: R zero.
	divisors isEmpty ifTrue: [remainder := dividend. ^ self].
	remainder := dividend zero.
	s := divisors size.
	p := dividend.
	[p isZero] whileFalse:
		[m := p leadingMonomial.
		c := p leadingCoefficient.
		i := 1.
		[((fᵢ := divisors at: i) leadingMonomial | m and: [(qᵢ := c // fᵢ leadingCoefficient) isZero not]) or: [(i := i + 1) > s]] whileFalse.
		i <= s "i.e. found fi"
			ifTrue:
				[q := R coefficient: qᵢ monomial: m / fᵢ leadingMonomial.
				quotients at: i put: (quotients at: i) + q.
				p := p + (fᵢ * q negated)]
			ifFalse:
				[remainder := remainder + p leadingTerm.
				p := p tail]]! !

!MultivariateDivision methodsFor: 'private' stamp: 'len 7/8/2022 11:19:06'!
validate
	| total |
	super validate.
	total _ self remainder.
	self divisors with: self quotients do: [:f :q| total _ total + (f*q)].
	self assert: total = self dividend.

	self divisors with: self quotients do: [:f :q|
		self assert: (q isZero or: [(f*q) leadingMonomial <= self dividend leadingMonomial])].

	self remainder monomials do: [:each| self assert: (self divisors noneSatisfy: [:f| f leadingMonomial | each])]! !

!MultivariateDivision class methodsFor: 'instance creation' stamp: 'len 11/20/2016 15:19:29'!
divide: aPolynomial by: anArrayOfPolynomials
	^ self new divide: aPolynomial by: anArrayOfPolynomials! !

!StrongBuchberger methodsFor: 'accessing' stamp: 'len 5/19/2023 07:25:09'!
basis
	generators isNil ifTrue: [self run].
	^ self isRankOne
		ifTrue: [(matrix scalars^generators size !! generators) asRowMatrix]
		ifFalse: [Matrix to: matrix codomain columns: generators]! !

!StrongBuchberger methodsFor: 'accessing' stamp: 'len 1/12/2022 14:05:12'!
ordering
	^ matrix scalars ordering! !

!StrongBuchberger methodsFor: 'accessing' stamp: 'len 1/13/2022 08:09:29'!
scalars
	^ matrix scalars scalars! !

!StrongBuchberger methodsFor: 'computing' stamp: 'len 6/17/2023 14:39:17'!
autoreduce
	"Make the basis a reduced basis.
	Based on [BW93], algorithm REDGROEBNER (p. 216) and REDUCTION (p. 203)."
	| H |
	H := OrderedCollection new.
	1 to: generators size do: [:i| | f m c |
		f := generators at: i.
		m := f leadingMonomial.
		c := f leadingCoefficient.
		(((i+1 to: generators size) noneSatisfy: [:j| (generators at: j) leadingMonomial | m and: [(c // (generators at: j) leadingCoefficient) isZero not]])
			and: [H noneSatisfy: [:h| h leadingMonomial | m and: [(c // h leadingCoefficient) isZero not]]])
				ifTrue: [H add: f]].
	H := H asArray.
	generators := OrderedCollection new.
	H withIndexDo: [:h :i| | r |
		(r := h reductionFullBy: (H copyWithoutIndex: i)) isZero ifFalse: [generators add: r normalized]]! !

!StrongBuchberger methodsFor: 'computing' stamp: 'len 12/17/2022 10:01:15'!
process: anArray
	| i0 r queue |
	i0 _ generators size + 1.
	anArray do: [:f| (r _ f reductionBy: generators) isZero ifFalse: [generators add: r normalized]].
	queue _ OrderedCollection new.
	1 to: generators size do: [:i| | fi hi ci |
		fi _ generators at: i.
		hi _ fi leadingMonomial.
		ci _ fi leadingCoefficient.
		"Add A-polynomial:"
		(r _ fi * ci annihilator reductionBy: generators) isZero ifFalse: [queue add: r].
		(i+1 max: i0) to: generators size do: [:k| | fk hk |
			fk _ generators at: k.
			hk _ fk leadingMonomial.
			(hi lcm: hk) ifNotNil: [:m| | ck c s xgcd g |
				ck _ fk leadingCoefficient.
				c _ ci lcm: ck.
				"Add S-polynomial. Apply Buchberger Product Criterion (only applicable to rank 1) and Chain Criterion:"
				((self isRankOne not or: [hi * hk ~= m or: [ci * ck ~= c]]) and: [(1 to: i-1) noneSatisfy: [:j| (generators at: j) leadingMonomial | m and: [(generators at: j) leadingCoefficient | c]]]) ifTrue:
					[s _ fi * (m / hi) * (c / ci) - (fk * (m / hk) * (c / ck)).
					(r _ s reductionBy: generators) isZero ifFalse: [queue add: r]].
				xgcd _ ci xgcd: ck.
				"Add G-polynomial. Apply Chain Criterion for GCD:"
				((1 to: i-1) noneSatisfy: [:j| (generators at: j) leadingMonomial | m and: [(generators at: j) leadingCoefficient | (xgcd at: 1)]]) ifTrue:
					[g _ fi * (m / hi) * (xgcd at: 2) + (fk * (m / hk) * (xgcd at: 3)).
					(r _ g reductionBy: generators) isZero ifFalse: [queue add: r]]]]].
	^ queue! !

!StrongBuchberger methodsFor: 'computing' stamp: 'len 6/17/2023 14:46:51'!
run
	| queue |
	generators := OrderedCollection new.
	queue := OrderedCollection new.
	(self isRankOne ifTrue: [matrix asTuple asArray] ifFalse: [matrix columns])
		withIndexDo: [:each :i| each isZero ifFalse: [queue add: each]].
	[queue isEmpty] whileFalse:
		[queue := self process: (queue asSortedCollection: [:a :b| a leadingMonomial <= b leadingMonomial])].
	"This adds about 50% time in some cases:"
	self autoreduce.
	self sort
"	self validate"! !

!StrongBuchberger methodsFor: 'computing' stamp: 'len 12/17/2022 10:01:15'!
sort
	"Sort the basis to make an autoreduced basis unique."
	generators sort: [:a :b| self compare: a with: b]! !

!StrongBuchberger methodsFor: 'testing' stamp: 'len 1/10/2022 12:12:04'!
isRankOne
	^ matrix height = 1! !

!StrongBuchberger methodsFor: 'private' stamp: 'len 12/3/2023 21:23:03'!
compare: a with: b
	^ b leadingMonomial < a leadingMonomial or: [b leadingMonomial = a leadingMonomial and: [b leadingCoefficient gauge <= a leadingCoefficient gauge]]! !

!StrongBuchberger methodsFor: 'private' stamp: 'len 1/10/2022 12:12:41'!
matrix: aMatrix
	matrix _ aMatrix! !

!StrongBuchberger methodsFor: 'private' stamp: 'len 6/17/2023 12:41:14'!
validate
	self basis isStandardBasis ifFalse: [^ self error: 'not standard basis'].
	self assert: self basis isReducedStandardBasis.
	self assert: self basis isMinimalStandardBasis.
	(generators asArray sorted: [:a :b| self compare: a with: b]) = generators asArray ifFalse: [^ self error: 'not sorted']! !

!StrongBuchberger class methodsFor: 'instance creation' stamp: 'len 12/22/2022 19:12:29'!
on: aMatrix
	^ self new matrix: aMatrix! !

!Buchberger methodsFor: 'computing' stamp: 'len 12/17/2022 10:01:15'!
autoreduce
	"Make the basis a reduced basis.
	Based on [BW93], algorithm REDGROEBNER (p. 216) and REDUCTION (p. 203)."
	| H |
	H _ OrderedCollection new.
	1 to: generators size do: [:i| | f m |
		f _ generators at: i.
		m _ f leadingMonomial.
		(((i+1 to: generators size) noneSatisfy: [:j| (generators at: j) leadingMonomial | m])
			and: [H noneSatisfy: [:h| h leadingMonomial | m]])
				ifTrue: [H add: f]].
	H _ H asArray.
	generators _ OrderedCollection new.
	1 to: H size do: [:i| | h r |
		h _ H at: i.
		(r _ h reductionFullBy: (H copyWithoutIndex: i)) isZero ifFalse: [generators add: r normalized]]! !

!Buchberger methodsFor: 'computing' stamp: 'len 12/17/2022 10:01:15'!
process: anArray
	| i0 r queue |
	i0 _ generators size + 1.
	anArray do: [:f| (r _ f reductionBy: generators) isZero ifFalse: [generators add: r normalized]].
	queue _ OrderedCollection new.
	1 to: generators size do: [:i| | fi hi ci |
		fi _ generators at: i.
		hi _ fi leadingMonomial.
		ci _ fi leadingCoefficient.
		(i+1 max: i0) to: generators size do: [:k| | fk hk ck s |
			fk _ generators at: k.
			hk _ fk leadingMonomial.
			(hi lcm: hk) ifNotNil: [:m|
				"Add S-polynomial. Apply Buchberger Product Criterion (only applicable to rank 1) and Chain Criterion:"
				((self isRankOne not or: [m ~= (hi * hk)]) and: [((1 to: i-1) noneSatisfy: [:j| (generators at: j) leadingMonomial | m])])
					ifTrue:
						[ck _ fk leadingCoefficient.
						s _ fi * (m / hi) / ci + (fk * (m / hk) / ck negated).
						(r _ s reductionBy: generators) isZero ifFalse: [queue add: r]]]]].
	^ queue! !

!Buchberger methodsFor: 'private' stamp: 'len 12/3/2023 21:21:18'!
compare: a with: b
	^ b leadingMonomial <= a leadingMonomial! !

!ExtendedStrongBuchberger methodsFor: 'accessing' stamp: 'len 5/19/2023 07:25:40'!
transformation
	combinations isNil ifTrue: [self run].
	^ matrix scalars^combinations size to: matrix domain fill: [:i :j| (combinations at: j) at: i]! !

!ExtendedStrongBuchberger methodsFor: 'computing' stamp: 'len 12/24/2023 08:19:51'!
autoreduce
	"Make the basis a reduced basis.
	Based on [BW93], algorithm REDGROEBNER (p. 216) and REDUCTION (p. 203)."
	| H T |
	H := OrderedCollection new.
	T := OrderedCollection new.
	1 to: generators size do: [:i| | f m c |
		f := generators at: i.
		m := f leadingMonomial.
		c := f leadingCoefficient.
		(((i+1 to: generators size) noneSatisfy: [:j| (generators at: j) leadingMonomial | m and: [(c // (generators at: j) leadingCoefficient) isZero not]])
			and: [H noneSatisfy: [:h| h leadingMonomial | m and: [(c // h leadingCoefficient) isZero not]]])
				ifTrue: [H add: f. T add: (combinations at: i)]].
	H := H asArray.
	T := T asArray.
	H size > 1 ifFalse: [generators := H. combinations := T. ^ self].
	generators := OrderedCollection new.
	combinations := OrderedCollection new.
	1 to: H size do: [:i| | h division r u |
		h := H at: i.
		division := h divisionBy: (H copyWithoutIndex: i).
		(r := division remainder) isZero ifFalse:
			[u := r normalization.
			generators add: r*u.
			combinations add: (T at: i) - ((T copyWithoutIndex: i) · division quotients) * u]]! !

!ExtendedStrongBuchberger methodsFor: 'computing' stamp: 'len 12/24/2023 08:03:30'!
process: anArray
	| i0 division queue |
	i0 := generators size + 1.
	"Full reduction in this step produces a reduced basis:"
	anArray do: [:f|
		(division := f key divisionBy: generators) remainder isZero ifFalse:
			[| u |
			u := division remainder normalization.
			generators add: division remainder * u.
			combinations add: (combinations isEmpty ifTrue: [f value] ifFalse: [f value - (combinations · division quotients)])*u]].
	queue := OrderedCollection new.
	1 to: generators size do: [:i| | fi hi ci ai ann |
		fi := generators at: i.
		hi := fi leadingMonomial.
		ci := fi leadingCoefficient.
		ai := combinations at: i.
		"Add A-polynomial:"
		ann := ci annihilator.
		(division := fi * ann divisionBy: generators) remainder isZero ifFalse:
			[queue add: (Association key: division remainder value: ai * ann - (combinations · division quotients))].
		(i+1 max: i0) to: generators size do: [:k| | fk hk |
			fk := generators at: k.
			hk := fk leadingMonomial.
			(hi lcm: hk) ifNotNil: [:m| | ck ak c s xgcd g |
				ck := fk leadingCoefficient.
				ak := combinations at: k.
				c := ci lcm: ck.
				"Add S-polynomial. Apply Buchberger Product Criterion (only applicable to rank 1) and Chain Criterion:"
				((self isRankOne not or: [hi * hk ~= m or: [ci * ck ~= c]]) and: [(1 to: i-1) noneSatisfy: [:j| (generators at: j) leadingMonomial | m and: [(generators at: j) leadingCoefficient | c]]]) ifTrue:
					[s := fi * (m / hi) * (c / ci) + (fk * (m / hk) * (c negated / ck)).
					(division := s divisionBy: generators) remainder isZero ifFalse:
						[queue add: (Association key: division remainder value: ((ai * (matrix scalars one * (m / hi) * (c / ci)) + (ak * (matrix scalars one * (m / hk) * (c negated / ck)))) - (combinations · division quotients)))]].
				xgcd := ci xgcd: ck.
				"Add G-polynomial. Apply Chain Criterion for GCD:"
				((1 to: i-1) noneSatisfy: [:j| (generators at: j) leadingMonomial | m and: [(generators at: j) leadingCoefficient | (xgcd at: 1)]]) ifTrue:
					[g := fi * (m / hi) * (xgcd at: 2) + (fk * (m / hk) * (xgcd at: 3)).
					(division := g divisionBy: generators) remainder isZero ifFalse:
						[queue add: (Association key: division remainder value: ((ai * (matrix scalars one * (m / hi) * (xgcd at: 2)) + (ak * (matrix scalars one * (m / hk) * (xgcd at: 3)))) - (combinations · division quotients)))]]]]].
	^ queue! !

!ExtendedStrongBuchberger methodsFor: 'computing' stamp: 'len 6/17/2023 14:51:10'!
run
	| queue |
	self ordering isGlobal ifFalse: [^ self notYetImplemented].
	generators := OrderedCollection new.
	combinations := OrderedCollection new.
	queue := OrderedCollection new.
	(self isRankOne ifTrue: [matrix asTuple asArray] ifFalse: [matrix columns])
		withIndexDo: [:each :i| each isZero ifFalse: [queue add: (Association key: each value: (matrix domain x: i))]].
	[(queue := self process: (queue asSortedCollection: [:a :b| a key leadingMonomial <= b key leadingMonomial])) isEmpty] whileFalse.
	self autoreduce.
	self sort
"	self validate"! !

!ExtendedStrongBuchberger methodsFor: 'computing' stamp: 'len 12/17/2022 10:01:15'!
sort
	"Sort the basis to make an autoreduced basis unique."
	| temp |
	temp _ (1 to: generators size) collect: [:i| Association key: (generators at: i) value: (combinations at: i)].
	temp sort: [:a :b| self compare: a key with: b key].
	generators _ temp collect: [:each| each key].
	combinations _ temp collect: [:each| each value]! !

!ExtendedStrongBuchberger methodsFor: 'private' stamp: 'len 12/17/2022 10:03:13'!
validate
	super validate.
	matrix * self transformation = self basis ifFalse: [self error: 'change of basis failed']! !

!ExtendedBuchberger methodsFor: 'computing' stamp: 'len 12/24/2023 08:20:06'!
autoreduce
	"Make the basis a reduced basis.
	Based on [BW93], algorithm REDGROEBNER (p. 216) and REDUCTION (p. 203)."
	| H T |
	H := OrderedCollection new.
	T := OrderedCollection new.
	1 to: generators size do: [:i| | f m |
		f := generators at: i.
		m := f leadingMonomial.
		(((i+1 to: generators size) noneSatisfy: [:j| (generators at: j) leadingMonomial | m])
			and: [H noneSatisfy: [:h| h leadingMonomial | m]])
				ifTrue: [H add: f. T add: (combinations at: i)]].
	H := H asArray.
	T := T asArray.
	H size > 1 ifFalse: [generators := H. combinations := T. ^ self].
	generators := OrderedCollection new.
	combinations := OrderedCollection new.
	1 to: H size do: [:i| | h division r u |
		h := H at: i.
		division := h divisionBy: (H copyWithoutIndex: i).
		(r := division remainder) isZero ifFalse:
			[u := r normalization.
			generators add: r*u.
			combinations add: (T at: i) - ((T copyWithoutIndex: i) · division quotients) * u]]! !

!ExtendedBuchberger methodsFor: 'computing' stamp: 'len 12/24/2023 08:20:55'!
process: anArray
	| i0 division queue |
	i0 := generators size + 1.
	"Full reduction in this step produces a reduced basis:"
	anArray do: [:f|
		(division := f key divisionBy: generators) remainder isZero ifFalse:
			[| u |
			u := division remainder normalization.
			generators add: division remainder * u.
			combinations add: (combinations isEmpty ifTrue: [f value] ifFalse: [f value - (combinations · division quotients)])*u]].
	queue := OrderedCollection new.
	1 to: generators size do: [:i| | fi hi ci ai |
		fi := generators at: i.
		hi := fi leadingMonomial.
		ci := fi leadingCoefficient.
		ai := combinations at: i.
		(i+1 max: i0) to: generators size do: [:k| | fk hk ck s ak |
			fk := generators at: k.
			hk := fk leadingMonomial.
			(hi lcm: hk) ifNotNil: [:m|
				"Add S-polynomial. Apply Buchberger Product Criterion (only applicable to rank 1) and Chain Criterion:"
				((self isRankOne not or: [m ~= (hi * hk)]) and: [((1 to: i-1) noneSatisfy: [:j| (generators at: j) leadingMonomial | m])])
					ifTrue:
						[ck := fk leadingCoefficient.
						ak := combinations at: k.
						s := fi * (m / hi) / ci - (fk * (m / hk) / ck).
						(division := s divisionBy: generators) remainder isZero ifFalse:
							[queue add: (Association key: division remainder value: ((ai * (matrix scalars one * (m / hi) / ci) - (ak * (matrix scalars one * (m / hk) / ck))) - (combinations · division quotients)))]]]]].
	^ queue! !

!ExtendedBuchberger methodsFor: 'private' stamp: 'len 12/3/2023 21:22:32'!
compare: a with: b
	^ b leadingMonomial <= a leadingMonomial! !

!Object methodsFor: '*algebra' stamp: 'len 4/5/2024 19:10:16'!
adapt: anElement andSend: selector
	self parent ifNotNil: [:aDomain| (aDomain adapt: anElement) ifNotNil: [:adapted| ^ self perform: selector with: adapted]].
	anElement parent ifNotNil: [:aDomain| (aDomain adapt: self) ifNotNil: [:adapted| ^ adapted perform: selector with: anElement]].
	^ self error: 'coercion failed'! !

!Object methodsFor: '*algebra' stamp: 'len 11/6/2016 09:07'!
adaptToCollection: rcvr andSend: selector
	"If I am involved in arithmetic with a Collection, return a Collection of
	the results of each element combined with me in that expression."

	^ rcvr collect: [:element | element perform: selector with: self]! !

!Object methodsFor: '*algebra' stamp: 'len 5/22/2024 04:15:34'!
isDomain
	^ false! !

!Object methodsFor: '*algebra' stamp: 'len 4/22/2020 06:09:43'!
isElement
	"Answer true if the receiver is an element of a Domain, i.e. if it understands the message #parent and answers its parent Domain."
	^ self parent notNil! !

!Object methodsFor: '*algebra' stamp: 'len 5/19/2018 17:53:50'!
isEvaluable
	^ self isBlock! !

!Object methodsFor: '*algebra' stamp: 'len 4/2/2018 05:16:06'!
isMatrix
	^ false! !

!Object methodsFor: '*algebra' stamp: 'len 5/8/2020 15:46:36'!
isMorphism
	^ false! !

!Object methodsFor: '*algebra' stamp: 'len 8/5/2016 21:51'!
isReal
	"Answer true if the receiver is a real number."
	^ false! !

!Object methodsFor: '*algebra' stamp: 'len 5/22/2018 16:53:19'!
isSequenceable
	"Answer true if the receiver is some sort of ordered tuple of objects, understands #at: and #size and it's indexed by integers starting at 1."
	^ false! !

!Object methodsFor: '*algebra' stamp: 'len 3/28/2018 18:01:41'!
isTuple
	^ false! !

!Object methodsFor: '*algebra' stamp: 'len 4/22/2020 06:09:50'!
parent
	^ nil! !

!Object methodsFor: '*algebra' stamp: 'len 7/8/2022 11:11:29'!
validate
	"Check the internal invariants of this object and produce an error if any invariant is broken."
	^ self! !

!Object methodsFor: '*algebra' stamp: 'len 9/8/2022 12:00:40'!
∈ aCollection
	"Answer true if the receiver is a member of aCollection."
	^ aCollection includes: self! !

!Object methodsFor: '*algebra' stamp: 'len 4/5/2024 03:25:49'!
∉ aCollection
	"Answer true if the receiver is a member of aCollection."
	^ (self ∈ aCollection) not! !

!Object class methodsFor: '*algebra' stamp: 'len 4/5/2024 19:10:08'!
!! anObject
	(self newFrom: anObject) ifNotNil: [:anInstance| ^ anInstance].
	^ self error: 'coercion failed'! !

!Workspace methodsFor: '*algebra' stamp: 'len 11/23/2015 03:28'!
bindingOf: aString
	mustDeclareVariables ifTrue: [^ nil].
	(bindings includesKey: aString) ifFalse: [
		"aString first isUppercase
			ifTrue: [^nil]
			ifFalse: ["bindings at: aString put: nil]"]".
	^bindings associationAt: aString! !

!Magnitude methodsFor: '*algebra' stamp: 'len 12/3/2023 16:05:29'!
compare: aMagnitude
	self > aMagnitude ifTrue: [^ 1].
	self < aMagnitude ifTrue: [^ -1].
	^ 0! !

!Number methodsFor: '*algebra' stamp: 'len 7/4/2022 13:00:11'!
^ aNumber
	aNumber isInteger ifTrue: [^ self raisedToInteger: aNumber].
	aNumber isFraction ifTrue: [^ (self root: aNumber denominator) raisedToInteger: aNumber numerator].
	0 = aNumber ifTrue: [^ self class one].
	1 = aNumber ifTrue: [^ self].
	0 = self ifTrue: [
		aNumber < 0
			ifTrue: [^ ZeroDivide new signalReceiver: self selector: #'^' argument: aNumber]
			ifFalse: [^ self]].
	^ (aNumber * self ln) exp! !

!Number methodsFor: '*algebra' stamp: 'len 11/20/2023 10:24:48'!
abs²
	"Answer the square of the absolute value of the receiver."
	^ self squared! !

!Number methodsFor: '*algebra' stamp: 'len 8/9/2020 07:47:51'!
conjugate
	"Answer the complex conjugate of the receiver."

	^ self! !

!Number methodsFor: '*algebra' stamp: 'len 10/16/2022 10:43:52'!
gauge
	"Answer the value of the Euclidean function at the receiver."
	^ self abs! !

!Number methodsFor: '*algebra' stamp: 'len 6/4/2016 21:55'!
imaginary
	^ 0! !

!Number methodsFor: '*algebra' stamp: 'len 8/5/2016 21:44'!
isComplex
	^ true "real numbers are also complex numbers"! !

!Number methodsFor: '*algebra' stamp: 'len 4/25/2022 18:01:18'!
isMinusOne
	^ self  = -1! !

!Number methodsFor: '*algebra' stamp: 'len 4/25/2022 18:01:08'!
isOne
	^ self  = 1! !

!Number methodsFor: '*algebra' stamp: 'len 11/19/2015 17:20'!
isRational
	^ false! !

!Number methodsFor: '*algebra' stamp: 'len 8/5/2016 21:44'!
isReal
	^ true! !

!Number methodsFor: '*algebra' stamp: 'len 6/4/2016 21:54'!
real
	^ self! !

!Number methodsFor: '*algebra' stamp: 'len 5/23/2023 06:28:49'!
root: anInteger
	^ self nthRoot: anInteger! !

!Number methodsFor: '*algebra' stamp: 'len 11/10/2023 15:58:59'!
within: aNumber
	"Answer true if the receiver is within the closed ball at the origin of radius aNumber."
	^ self abs <= aNumber! !

!Float methodsFor: '*algebra' stamp: 'len 5/3/2020 07:43:34'!
inverse
	^ self reciprocal! !

!Float methodsFor: '*algebra' stamp: 'len 2/25/2016 17:17'!
squareRoot
	^ self sqrt! !

!Fraction methodsFor: '*algebra' stamp: 'len 11/23/2022 17:04:17'!
, aTuple
	^ ℚ !!!! {self} , aTuple! !

!Fraction methodsFor: '*algebra' stamp: 'len 6/5/2019 14:48:57'!
abs: p
	"Answer the p-adic absolute value of the receiver."
	^ (numerator abs: p) / (denominator abs: p)! !

!Fraction methodsFor: '*algebra' stamp: 'len 3/3/2021 15:03:13'!
asRational
	^ Rational reducedNumerator: numerator denominator: denominator! !

!Fraction methodsFor: '*algebra' stamp: 'len 2/10/2016 21:13'!
bitSize
	^ numerator bitSize + denominator bitSize! !

!Fraction methodsFor: '*algebra' stamp: 'len 1/8/2017 16:37:12'!
height
	^ numerator abs max: denominator! !

!Fraction methodsFor: '*algebra' stamp: 'len 10/11/2023 08:58:24'!
isIntegral
	"Note; this method should just return false, but actually it is possible to have Fractions with denominator 1 (see Integer>>asFraction)."
	self flag: #fixme. "Maybe remove this method, we use Ratonals, not Fractions."
	^ denominator = 1! !

!Fraction methodsFor: '*algebra' stamp: 'len 11/19/2015 17:20'!
isRational
	^ true! !

!Fraction methodsFor: '*algebra' stamp: 'len 5/23/2020 09:53:13'!
minimalPolynomial
	^ ℚ polynomials x - self! !

!Fraction methodsFor: '*algebra' stamp: 'len 6/5/2019 14:50:10'!
valuation: p
	"Answer the p-adic valuation of the receiver."
	^ (numerator valuation: p) - (denominator valuation: p)! !

!Integer methodsFor: '*algebra' stamp: 'len 5/23/2020 09:54:28'!
% anInteger
	^ ℤ / anInteger project: self! !

!Integer methodsFor: '*algebra' stamp: 'len 11/23/2022 17:04:09'!
, aTuple
	^ ℤ !!!! {self} , aTuple! !

!Integer methodsFor: '*algebra' stamp: 'len 5/12/2023 00:43:10'!
<< shiftCount
	^ self bitShift: shiftCount! !

!Integer methodsFor: '*algebra' stamp: 'len 5/12/2023 00:43:18'!
>> shiftCount
	^ self bitShift: shiftCount negated! !

!Integer methodsFor: '*algebra' stamp: 'len 5/31/2022 11:48:42'!
\ anInteger
	^ (self lift: anInteger) ifNil: [DivisibilityError new signalReceiver: self selector: #\ argument: anInteger]! !

!Integer methodsFor: '*algebra' stamp: 'len 5/27/2022 19:03:00'!
| anInteger
	"Answer true if the receiver divides the argument."
	anInteger = 0 ifTrue: [^ true].
	self = 0 ifTrue: [^ false].
	^ anInteger \\ self = 0! !

!Integer methodsFor: '*algebra' stamp: 'len 5/10/2020 10:58:50'!
~ anInteger
	^ self normalized = anInteger normalized! !

!Integer methodsFor: '*algebra' stamp: 'len 5/14/2023 13:40:36'!
÷ anInteger
	"Answer the exact division of the receiver by the argument.
	Asume that the argument divides the receiver."
	^ self // anInteger! !

!Integer methodsFor: '*algebra' stamp: 'len 12/12/2016 09:35:38'!
Stirling: anInteger
	"Answer the Stirling number of the second kind S(n,k).
	Stirling numbers of the second kind count the ways to partition a set of n things into k nonempty subsets."
	(anInteger > self or: [self < 0]) ifTrue: [^ DomainError signal].
	self = anInteger ifTrue: [^ 1].
	anInteger = 0 ifTrue: [^ 0].
	self+1 = anInteger ifTrue: [^ self choose: 2].
	anInteger = 2 ifTrue: [^ 2 ^ (self-1) - 1].
	^ anInteger*(self - 1 Stirling: anInteger) + (self - 1 Stirling: anInteger - 1)! !

!Integer methodsFor: '*algebra' stamp: 'len 3/3/2021 07:31:56'!
abs: p
	"Answer the p-adic absolute value of the receiver."
	| powers q |
	self = 0 ifTrue: [^ 0].
	q _ self abs.
	powers _ 1.
	[p | q] whileTrue: [powers _ powers * p. q _ q // p].
	^ powers asRational reciprocal! !

!Integer methodsFor: '*algebra' stamp: 'len 6/23/2023 23:06:38'!
additiveOrder
	^ self = 0 ifTrue: [1] ifFalse: [0]! !

!Integer methodsFor: '*algebra' stamp: 'len 5/21/2022 19:43:37'!
annihilator
	"Answer a generator of the ideal of all elements that multiplied by the receiver are zero."
	^ self = 0 ifTrue: [1] ifFalse: [0]! !

!Integer methodsFor: '*algebra' stamp: 'len 5/21/2022 19:44:22'!
annihilatorIdeal
	"Answer the ideal of all elements that multiplied by the receiver are zero."
	^ ℤ * self annihilator! !

!Integer methodsFor: '*algebra' stamp: 'len 6/15/2023 14:26:28'!
asIdeal
	^ ℤ * self! !

!Integer methodsFor: '*algebra' stamp: 'len 12/28/2021 18:49:57'!
asOrdinal
	^ Ordinal fromInteger: self! !

!Integer methodsFor: '*algebra' stamp: 'len 3/3/2021 15:03:36'!
asRational
	^ Rational reducedNumerator: self denominator: 1! !

!Integer methodsFor: '*algebra' stamp: 'len 5/10/2020 10:57:45'!
associates
	^ self = 0 ifTrue: [#(0)] ifFalse: [{self negated. self}]! !

!Integer methodsFor: '*algebra' stamp: 'len 5/9/2023 18:26:22'!
bitAutoconvolution
	^ self bitConvolution: self! !

!Integer methodsFor: '*algebra' stamp: 'len 5/3/2022 05:57:17'!
bitConvolution: anInteger
	| a b c |
	a _ self.
	b _ anInteger.
	c _ 0.
	self highBit timesRepeat:
		[a odd ifTrue: [c _ c bitXor: b].
		b _ b bitShift: 1.
		a _ a bitShift: -1].
	^ c! !

!Integer methodsFor: '*algebra' stamp: 'len 5/22/2023 17:44:10'!
bitCount
	"Answer the number of bits that are set, i.e. the number of 1s in the binary representation."
	| n |
	n := self digitLength * 4. "this will always be >= 32, because SmallInteger implements bitCount"
	^ (self bitShift: n negated) bitCount + (self bitAnd: (1 bitShift: n) - 1) bitCount

"Alternative method by Brian Kernighan. This goes through as many iterations as set bits.
	| answer v |
	answer := 0.
	v := self.
	[v = 0] whileFalse: [v := v bitAnd: v - 1. answer := answer + 1].
	^ answer

alternative2:
	answer _ 0.
	1 to: self digitLength do: [:i| answer _ answer + (self digitAt: i) bitCount].
	^ answer
"! !

!Integer methodsFor: '*algebra' stamp: 'len 1/4/2024 10:57:07'!
bitMatrixTimesMatrix8x8: anInteger
	"Answer the product of two 8x8 binary matrices, represented as 64-bit integers."
	| a b answer |
	a := self.
	b := anInteger.
	answer := (16r0101010101010101 bitAnd: a) * (16rFF bitAnd: b).
	answer := answer bitXor: (16r0101010101010101 bitAnd: (a := a bitShift: -1)) * (16rFF bitAnd: (b := b bitShift: -8)).
	answer := answer bitXor: (16r0101010101010101 bitAnd: (a := a bitShift: -1)) * (16rFF bitAnd: (b := b bitShift: -8)).
	answer := answer bitXor: (16r0101010101010101 bitAnd: (a := a bitShift: -1)) * (16rFF bitAnd: (b := b bitShift: -8)).
	answer := answer bitXor: (16r0101010101010101 bitAnd: (a := a bitShift: -1)) * (16rFF bitAnd: (b := b bitShift: -8)).
	answer := answer bitXor: (16r0101010101010101 bitAnd: (a := a bitShift: -1)) * (16rFF bitAnd: (b := b bitShift: -8)).
	answer := answer bitXor: (16r0101010101010101 bitAnd: (a := a bitShift: -1)) * (16rFF bitAnd: (b := b bitShift: -8)).
	^​ answer bitXor: (16r0101010101010101 bitAnd: (a bitShift: -1)) * (16rFF bitAnd: (b bitShift: -8)).

"	| answer |
	answer := 0.
	0 to: 7 do: [:i|
		| p r |
		p := 16r0101010101010101 bitAnd: (self bitShift: i negated).
		r := 16rFF bitAnd: (anInteger bitShift: i*-8).
		answer := answer bitXor: p*r].
	^ answer"! !

!Integer methodsFor: '*algebra' stamp: 'len 5/13/2023 08:02:17'!
bitParity
	"Answer 1 if there are an odd number of bits set, 0 otherwise."
	| sum |
	sum _ 0.
	1 to: self digitLength do: [:i| sum _ sum bitXor: (self digitAt: i)].
	^ sum bitParity8! !

!Integer methodsFor: '*algebra' stamp: 'len 6/10/2023 23:19:27'!
bitReduce: anInteger
	"If the receiver and the argument represent polynomials over Z/2Z,
	the answer represents the remainder of the polynomial division of the receiver by the argument."
	| answer m n |
	n := self highBit.
	m := anInteger highBit.
	answer := self.
	[n >= m] whileTrue:
		[(answer bitAt: n) = 1 ifTrue: [answer := answer bitXor: (anInteger bitShift: n - m)].
		n := n - 1].
	^ answer

"alternative: (sometimes faster)
	| m r n |
	(m := anInteger highBit) = 0 ifTrue: [^ self error: 'division by zero'].
	r := self.
	[(n := r highBit) >= m]
		whileTrue:
			[r := r bitXor: anInteger << (n-m)].
	^ r"! !

!Integer methodsFor: '*algebra' stamp: 'len 7/1/2016 23:03'!
bitSize
	self negative ifTrue: [^ self negated highBit + 1].
	^ self highBit! !

!Integer methodsFor: '*algebra' stamp: 'len 5/22/2023 18:03:53'!
bitSupport
	^ Iterator on: self performing: #bitSupportDo:! !

!Integer methodsFor: '*algebra' stamp: 'len 5/22/2023 18:03:07'!
bitSupportDo: aBlock
	| i v |
	i := 1.
	v := self.
	[v = 0] whileFalse:
		[v odd ifTrue: [aBlock value: i].
		v := v bitShift: -1.
		i := i + 1]! !

!Integer methodsFor: '*algebra' stamp: 'len 5/25/2023 18:01:07'!
bits: length at: index
	"Read the desired number of bits from the receiver starting at the given bit index."
	^ (self bitShift: 1 - index) bitAnd: (1 bitShift: length) - 1! !

!Integer methodsFor: '*algebra' stamp: 'len 5/25/2023 00:15:53'!
byteAt: anInteger
	^ self digitAt: anInteger! !

!Integer methodsFor: '*algebra' stamp: 'len 5/25/2023 00:16:24'!
byteAt: anInteger put: aByte
	^ self digitAt: anInteger put: aByte! !

!Integer methodsFor: '*algebra' stamp: 'len 12/12/2016 09:35:09'!
choose: anInteger
	"Answer the binomial coefficient (self anInteger)"
	" 6 choose: 3  "

	(anInteger < 0 or: [anInteger > self]) ifTrue: [^0].
	^(self - anInteger + 1 productTo: self) // anInteger factorial! !

!Integer methodsFor: '*algebra' stamp: 'len 6/29/2016 06:40'!
choose: anInteger q: q
	"Answer the q-binomial coefficient of self with anInteger.
	This counts the number of 'anInteger'-dimensional subspaces of a vector space of dimension 'self' over a finite field of order 'q' (power of a prime)."

	(anInteger < 0 or: [anInteger > self]) ifTrue: [^0].
	^ ((0 to: anInteger - 1) inject: 1 into: [:x :i| 1 - (q^(self-i)) * x]) / ((1 to: anInteger) inject: 1 into: [:x :i| 1 - (q^i) * x])! !

!Integer methodsFor: '*algebra' stamp: 'len 8/12/2022 12:50:26'!
colift: anInteger
	"Answer x such that xa = b, where a is the receiver and b is the argument. Answer nil if there's no solution.
	This is the right division of b by a, written b / a."
	anInteger = 0 ifTrue: [^ 0].
	^ anInteger \\ self = 0 ifTrue: [anInteger // self]! !

!Integer methodsFor: '*algebra' stamp: 'len 4/23/2016 19:35'!
count: aBlock
	| answer |
	answer _ 0.
	self timesRepeat: [aBlock value ifTrue: [answer _ answer + 1]].
	^ answer! !

!Integer methodsFor: '*algebra' stamp: 'len 6/21/2023 15:09:40'!
decompositionWith: anInteger into: aBlock
	"[Mil04, Algorithm 5].
	If the receiver is n and anInteger is r, compute integers n₀, n₁ such that:
		n = n₀ n₁
		gcd(n₀, n₁) = 1
		gcd(r, n₁) = 1
		any prime divisor of n₀ divides r.
	The algorithm works in time O(log max(r,n))."
	| n₀ n₁ s |
	n₀ := 1.
	n₁ := self.
	[(s := anInteger gcd: n₁) = 1 ifTrue: [^ aBlock value: n₀ value: n₁].
	n₀ := n₀ * s.
	n₁ := n₁ ÷ s] repeat! !

!Integer methodsFor: '*algebra' stamp: 'len 5/15/2020 06:15:20'!
divisionBy: anElement
	^ Division divide: self by: anElement! !

!Integer methodsFor: '*algebra' stamp: 'len 12/26/2016 21:24:14'!
divisors
	"Answer the collection of positive divisors of the receiver including 1 and self."
	^ Iterator on: self performing: #divisorsDo:! !

!Integer methodsFor: '*algebra' stamp: 'len 12/26/2016 21:23:53'!
divisorsDo: aBlock
	"Iterate over the positive divisors of the receiver, including 1 and self."
	| n sqrt |
	n _ self abs.
	sqrt _ n sqrtFloor.
	1 to: sqrt - 1
		do: [:k| n \\ k = 0 ifTrue: [aBlock value: k; value: n // k]].
	n \\ sqrt = 0
		ifTrue:
			[aBlock value: sqrt.
			sqrt * sqrt = n ifFalse: [aBlock value: n // sqrt]]! !

!Integer methodsFor: '*algebra' stamp: 'len 11/27/2023 15:58:13'!
evaluate: aPolynomial
	"Answer the result of evaluating aPolynomial at the receiver."
	^ aPolynomial value: self! !

!Integer methodsFor: '*algebra' stamp: 'len 8/5/2021 08:35:27'!
factorization
	"Answer a collection with the prime factors of the receiver (with multiplicity)."
	| answer |
	answer _ Bag new.
	self factorizationDo: [:p :e| answer add: p withOccurrences: e].
	^ answer! !

!Integer methodsFor: '*algebra' stamp: 'len 6/25/2023 09:56:44'!
factorizationDo: aBlock
	"Enumerate the prime factors of the receiver and their multiplicities."
	| n times p max |
	self = 0 ifTrue: [self error: 'factorization of zero'].
	n := self abs.
	n <= 1 ifTrue: [^ self].
	n even ifTrue:
		[aBlock value: 2 value: (times := n lowBit - 1).
		n := n bitShift: times negated].
	max := n sqrtFloor + 1.
	p := 1.
	[(p := p + 2) < max] whileTrue:
		[n \\ p = 0 ifTrue:
			[times := 1.
			n := n // p.
			[n \\ p = 0] whileTrue: [times := times + 1. n := n // p].
			aBlock value: p value: times.
			max := n sqrtFloor + 1]].
	n = 1 ifFalse: [aBlock value: n value: 1]! !

!Integer methodsFor: '*algebra' stamp: 'len 6/26/2023 01:33:34'!
factorizationFermat
	"If the receiver is the product of two primes p*q, answer p and q."
	| x y |
	x := self sqrtFloor + 1.
	y := x squared - self.
	[y isSquare] whileFalse:
		[x := x + 1.
		y := x squared - self].
	y := y sqrt.
	^ {x + y. x - y}! !

!Integer methodsFor: '*algebra' stamp: 'len 6/26/2023 01:33:39'!
factorizationFermatSievingOddAndEven
	"If the receiver is the product of two primes p*q, answer p and q.
	This is about 2x as fast as factorizationFermat."
	| x y |
	x := self sqrtFloor + 1.
	self \\ 4 = 1
		ifTrue:
			[x even ifTrue: [x := x + 1]]
		ifFalse:
			[x odd ifTrue: [x := x + 1]].
	y := x squared - self.
	[y isSquare] whileFalse:
		[x := x + 2.
		y := x squared - self].
	y := y sqrt.
	^ {x + y. x - y}! !

!Integer methodsFor: '*algebra' stamp: 'len 12/26/2023 10:38:42'!
gf16_mul: anInteger
	"Multiplication in 𝔽₁₆ := 𝔽₄[y]/(y²+y+x)."
	| a₀ a₁ b₀ b₁ a₀b₀ a₁b₁ a₀pa₁b₀pb₁ma₀b₀ rd₀ |
	a₀ := self bitAnd: 3.
	a₁ := (self bitShift: -2) bitAnd: 3.
	b₀ := anInteger bitAnd: 3.
	b₁ := (anInteger bitShift: -2) bitAnd: 3.
	a₀b₀ := a₀ gf4_mul: b₀.
	a₁b₁ := a₁ gf4_mul: b₁.
	a₀pa₁b₀pb₁ma₀b₀ := ((a₀ bitXor: a₁) gf4_mul: (b₀ bitXor: b₁)) bitXor: a₀b₀.
	rd₀ := a₁b₁ gf4_mul: 2.
	^ (a₀b₀ bitXor: rd₀) bitOr: (a₀pa₁b₀pb₁ma₀b₀ bitShift: 2)! !

!Integer methodsFor: '*algebra' stamp: 'len 12/26/2023 10:28:46'!
gf256_mul: anInteger
	"Multiplication in 𝔽₂₅₆ := 𝔽₁₆[x]/(x²+x+8)."
	| a₀ a₁ b₀ b₁ ab₀ ab₁ ab₂ |
	a₀ := self bitAnd: 15.
	a₁ := (self bitShift: -4) bitAnd: 15.
	b₀ := anInteger bitAnd: 15.
	b₁ := (anInteger bitShift: -4) bitAnd: 15.
	ab₀ := a₀ gf16_mul: b₀.
	ab₁ := (a₁ gf16_mul: b₀) bitXor: (a₀ gf16_mul: b₁).
	ab₂ := a₁ gf16_mul: b₁.
	ab₀ := ab₀ bitXor: (ab₂ gf16_mul: 8).
	ab₁ := ab₁ bitXor: ab₂.
	ab₀ := ab₀ bitXor: (ab₁ bitShift: 4).
	^ ab₀! !

!Integer methodsFor: '*algebra' stamp: 'len 12/27/2023 09:47:30'!
gf2to16_mul: anInteger
	"Multiplication in GF(2^16)."
	| a₀ a₁ b₀ b₁ a₀b₀ a₁b₁ a₀pa₁b₀pb₁ma₀b₀ rd₀ |
	a₀ := self bitAnd: 16rFF.
	a₁ := (self bitShift: -8) bitAnd: 16rFF.
	b₀ := anInteger bitAnd: 16rFF.
	b₁ := (anInteger bitShift: -8) bitAnd: 16rFF.
	a₀b₀ := a₀ gf256_mul: b₀.
	a₁b₁ := a₁ gf256_mul: b₁.
	a₀pa₁b₀pb₁ma₀b₀ := ((a₀ bitXor: a₁) gf256_mul: (b₀ bitXor: b₁)) bitXor: a₀b₀.
	rd₀ := a₁b₁ gf256_mul: 16r80.
	^ (a₀b₀ bitXor: rd₀) bitOr: (a₀pa₁b₀pb₁ma₀b₀ bitShift: 8)! !

!Integer methodsFor: '*algebra' stamp: 'len 12/27/2023 09:48:41'!
gf2to32_inv
	"Multiplicative inverse in GF(2^32) := 𝔽₆₅₅₃₆[x]/(x²+x+16r8000)."
	| r |
	r := self.
	30 timesRepeat: [r := r gf2to32_mul: r. r := r gf2to32_mul: self].
	^ r gf2to32_mul: r! !

!Integer methodsFor: '*algebra' stamp: 'len 12/27/2023 09:48:19'!
gf2to32_mul: anInteger
	"Multiplication in GF(2^32) := 𝔽₆₅₅₃₆[x]/(x²+x+16r8000)."
	| a₀ a₁ b₀ b₁ ab₀ ab₁ ab₂ |
	a₀ := self bitAnd: 16rFFFF.
	a₁ := (self bitShift: -16) bitAnd: 16rFFFF.
	b₀ := anInteger bitAnd: 16rFFFF.
	b₁ := (anInteger bitShift: -16) bitAnd: 16rFFFF.
	ab₀ := a₀ gf65536_mul: b₀.
	ab₁ := ((a₀ bitXor: a₁) gf65536_mul: (b₀ bitXor: b₁)) bitXor: ab₀.
	ab₂ := a₁ gf65536_mul: b₁.
	^ (ab₁ bitShift: 16) bitXor: (ab₀ bitXor: (ab₂ gf65536_mul: 16r8000))! !

!Integer methodsFor: '*algebra' stamp: 'len 12/26/2023 10:14:41'!
gf4_mul: anInteger
	"Multiplication in 𝔽₄ := 𝔽₂[x]/(x²+x+1)."
	| a₀ a₁ b₀ b₁ ab₀ ab₁ ab₂ |
	a₀ := self bitAnd: 1.
	a₁ := (self bitShift: -1) bitAnd: 1.
	b₀ := anInteger bitAnd: 1.
	b₁ := (anInteger bitShift: -1) bitAnd: 1.
	ab₀ := a₀ bitAnd: b₀.
	ab₁ := (a₁ bitAnd: b₀) bitXor: (a₀ bitAnd: b₁).
	ab₂ := a₁ bitAnd: b₁.
	ab₀ := ab₀ bitXor: ab₂.
	ab₁ := ab₁ bitXor: ab₂.
	ab₀ := ab₀ bitXor: (ab₁ bitShift: 1).
	^ ab₀! !

!Integer methodsFor: '*algebra' stamp: 'len 12/26/2023 10:46:30'!
gf65536_mul: anInteger
	"Multiplication in 𝔽₆₅₅₃₆ := 𝔽₂₅₆[x]/(x²+x+16r80)."
	| a₀ a₁ b₀ b₁ ab₀ ab₁ ab₂ |
	a₀ := self bitAnd: 16rFF.
	a₁ := (self bitShift: -8) bitAnd: 16rFF.
	b₀ := anInteger bitAnd: 16rFF.
	b₁ := (anInteger bitShift: -8) bitAnd: 16rFF.
	ab₀ := a₀ gf256_mul: b₀.
	ab₁ := ((a₀ bitXor: a₁) gf256_mul: (b₀ bitXor: b₁)) bitXor: ab₀.
	ab₂ := a₁ gf256_mul: b₁.
	^ (ab₁ bitShift: 8) bitXor: (ab₀ bitXor: (ab₂ gf256_mul: 16r80))! !

!Integer methodsFor: '*algebra' stamp: 'len 11/19/2016 21:03:03'!
height
	self = 0 ifTrue: [^ 1].
	^ self abs! !

!Integer methodsFor: '*algebra' stamp: 'len 5/29/2022 19:39:19'!
inverse
	self isUnit ifTrue: [^ self].
	^ DivisibilityError new signalReceiver: 1 selector: #/ argument: self! !

!Integer methodsFor: '*algebra' stamp: 'len 1/9/2022 08:31:42'!
isFundamentalDiscriminant
	| m r |
	r _ self \\ 4.
	r == 1 ifTrue: [^ self isSquarefree].
	r == 0 ifFalse: [^ false].
	m _ self // 4.
	r _ m \\ 4.
	^ (r == 2 or: [r == 3]) and: [m isSquarefree]! !

!Integer methodsFor: '*algebra' stamp: 'len 7/16/2019 17:23:08'!
isIdempotent
	^ self isUnit! !

!Integer methodsFor: '*algebra' stamp: 'len 7/30/2019 02:13:42'!
isIntegral
	^ true! !

!Integer methodsFor: '*algebra' stamp: 'len 7/16/2019 17:23:43'!
isIrreducible
	^ self isPrime! !

!Integer methodsFor: '*algebra' stamp: 'len 7/16/2019 17:22:24'!
isNilpotent
	"Answer true if self^n = 0 for some integer n >= 1."
	^ self = 0! !

!Integer methodsFor: '*algebra' stamp: 'len 6/23/2023 23:29:30'!
isPrime
	"Answer true if the receiver is a prime number. See isProbablyPrime for a probabilistic
	implementation that is much faster for large integers, and that is correct to an extremely
	high statistical level of confidence (effectively deterministic)."
	
	self <= 1 ifTrue: [^ false].
	self even ifTrue: [^ self = 2].
	self < 1029 ifTrue: [^ (3522777587723736049447994637992932749384026421409511721674352215129673638302223786179858271518502236265837398493945777137046860842981140826231075407076424168720306051611794253284352908295606350496881083115997689935091739508494842812776107849365641477123068724725571505032905335833473762565579647316770506005 bitAt: self-2) = 1].
	3 to: self sqrtFloor by: 2 do: [:each| self \\ each = 0 ifTrue: [^ false]].
	^ true! !

!Integer methodsFor: '*algebra' stamp: 'len 6/23/2023 23:21:32'!
isPrimePower
	"Answer true if the receiver is of the form p^k for a prime p and a k > 0."
	| first |
	self > 0 ifFalse: [^ false].
	self isPowerOfTwo ifTrue: [^ true].
	first := true.
	self factorizationDo: [:p :e| first ifFalse: [^ false]. first := false].
	^ true! !

!Integer methodsFor: '*algebra' stamp: 'len 11/19/2015 17:21'!
isRational
	^ true! !

!Integer methodsFor: '*algebra' stamp: 'len 7/16/2019 17:24:16'!
isReducible
	"A nonzero nonunit element is called 'reducible' if it is not irreducible."
	^ self isZero not and: [self isUnit not and: [self isIrreducible not]]! !

!Integer methodsFor: '*algebra' stamp: 'len 6/26/2023 01:36:40'!
isSquare
	"Answer true if the receiver is a perfect square, i.e. it has a square root."
	^ self sqrtFloor squared = self! !

!Integer methodsFor: '*algebra' stamp: 'len 1/9/2022 08:30:09'!
isSquarefree
	"Answer true if the factorization of the receiver is squarefree."
	self factorizationDo: [:p :e| e > 1 ifTrue: [^ false]].
	^ true

"
The limit of the density of squarefree positive integers < n is 6 / pi^2 ~ 0.6079271:
(1000 count: [100000 atRandom isSquareFree]) / 1000.0
"! !

!Integer methodsFor: '*algebra' stamp: 'len 7/16/2019 17:21:36'!
isUnit
	"Answer true if the receiver is invertible."
	^ self = 1 or: [self = -1]! !

!Integer methodsFor: '*algebra' stamp: 'len 12/4/2016 15:14:11'!
isZero
	^ self == 0! !

!Integer methodsFor: '*algebra' stamp: 'len 5/7/2022 07:29:44'!
isZeroDivisor
	"Answer true if there exists a nonzero element that multiplied by the receiver is zero."
	^ self = 0! !

!Integer methodsFor: '*algebra' stamp: 'len 4/10/2018 17:29:24'!
jacobi: m
	"Answer the Jacobi symbol of the receiver and the positive odd integer m.
	This is a generalization of the Legendre symbol that allows a composite argument m."

	^ self kronecker: m! !

!Integer methodsFor: '*algebra' stamp: 'len 4/10/2018 17:28:55'!
jacobiNew: m
	"Answer the Jacobi symbol of the receiver and the positive odd integer m.
	This is a generalization of the Legendre symbol that allows a composite argument m."

	"this is broken, it should satisfy: (3 jacobiNew: 11) = 1"
	| x y z answer |
	m odd ifFalse: [^ self error: 'the argument must by an odd positive integer'].
	(self gcd: m) = 1 ifFalse: [^ 0].
	x _ self \\ m.
	y _ m.
	answer _ 1.
	[x > 1] whileTrue:
		[[x \\ 4 = 0] whileTrue: [x _ x // 4].
		x \\ 2 = 0
			ifTrue:
				[x _ x // 2.
				y + 2 \\ 8 > 4 ifTrue: [answer _ answer negated]].
		z _ y \\ x.
		y _ x.
		x _ z].
	^ answer! !

!Integer methodsFor: '*algebra' stamp: 'len 8/20/97 02:26'!
jacobiOld: n
	"Answer the Jacoby symbol of the receiver and the argument."

	| a minusOne |
"	n odd ifFalse: [^ self error: 'the argument must by an odd positive integer']."
	a _ self \\ n.
	a = 2 ifTrue: [^ (n squared - 1) lowBit > 3 ifTrue: [1] ifFalse: [-1]].
	minusOne _ n - 1.
	a = minusOne ifTrue: [^ minusOne lowBit > 1 ifTrue: [1] ifFalse: [-1]].
	^ (a - 1 * minusOne) lowBit > 2
		ifTrue: [n jacobiOld: a] ifFalse: [(n jacobiOld: a) negated]! !

!Integer methodsFor: '*algebra' stamp: 'len 7/30/2021 11:23:17'!
kronecker: anInteger
	"Answer the Kronecker symbol (a | b) for a, b integers. This is the Legendre symbol when b is an odd prime.
	See [Coh96] Algorithm 1.4.10."
	| a b v k r |
	a _ self.
	b _ anInteger.
	"1. Test b = 0"
	b == 0 ifTrue: [^ a abs == 1 ifTrue: [1] ifFalse: [0]].
	"2. Remove 2's from b"
	(a even and: [b even]) ifTrue: [^ 0].
	v _ b lowBit - 1.
	b _ b bitShift: v negated.
	"v even ifTrue: [k _ 1] ifFalse: [k _ (-1) ^ (a squared - 1 / 8)]."
	v even ifTrue: [k _ 1] ifFalse: [k _ #(0 1 0 -1 0 -1 0 1) at: (a bitAnd: 7) + 1].
	b < 0 ifTrue: [b _ b negated. a < 0 ifTrue: [k _ k negated]].
	"3. Finished?"
	[a == 0 ifTrue: [^ b == 1 "b is odd and > 0" ifTrue: [k] ifFalse: [0]].
	v _ a lowBit - 1.
	a _ a bitShift: v negated.
	"v odd ifTrue: [k _ (-1) ^ (b squared - 1 / 8) * k]."
	v odd ifTrue: [k _ (#(0 1 0 -1 0 -1 0 1) at: (b bitAnd: 7) + 1) * k].
	"4. Apply reciprocity"
	"k _ (-1) ^ ((a - 1)*(b - 1)/4) * k."
	((a bitAnd: b) bitAnd: 2) == 0 ifFalse: [k _ k negated].
	r _ a abs.
	a _ b \\ r.
	b _ r] repeat! !

!Integer methodsFor: '*algebra' stamp: 'len 6/9/2023 18:54:36'!
legendre2: aPrime
	"[Coh+05, Algorithm 11.19]."
	| a p k v t r |
	self flag: #fixme.
	"TODO: compare when it is faster then the other implementation.
	For example, this is 6x faster with this implementation:
	[109608 legendre2: 163841] bench"
	a := self.
	p := aPrime.
	k := 1.
	[p = 1] whileFalse:
		[a = 0 ifTrue: [^ 0].
		v := 0.
		[a even] whileTrue: [v := v + 1. a := a bitShift: -1].
		v odd ifTrue: [t := p bitAnd: 2r111. (t = 3 or: [t = 5]) ifTrue: [k := k negated]].
		((a bitAnd: 2r11) = 3 and: [(p bitAnd: 2r11) = 3]) ifTrue: [k := k negated].
		r := a. a := p \\ r. p := r].
	^ k! !

!Integer methodsFor: '*algebra' stamp: 'len 12/26/2016 22:53:38'!
legendre: p
	"Answer the Legendre symbol (a | p) where p is an odd prime. This is:
		1 if a is a quadratic residue modulo p and a is not 0 modulo p;
		-1 if a is a quadratic non-residue modulo p;
		0 if a is 0 modulo p.
	See also >>jacobi: and >>kronecker:."
	| answer |
	answer _ self raisedToInteger: p - 1 // 2 modulo: p.
	answer > 1 ifTrue: [answer _ answer - p].
	^ answer! !

!Integer methodsFor: '*algebra' stamp: 'len 5/31/2022 11:51:29'!
lift: anInteger
	^ self colift: anInteger! !

!Integer methodsFor: '*algebra' stamp: 'len 5/23/2020 10:03:14'!
minimalPolynomial
	^ ℚ polynomials x - self! !

!Integer methodsFor: '*algebra' stamp: 'len 8/5/2021 08:39:48'!
moebius
	"Answer the Moebius function mu of the receiver."
	| factors |
	factors _ self factorization.
	factors asSet size = factors size ifFalse: [^ 0].
	^ factors size even ifTrue: [1] ifFalse: [-1]! !

!Integer methodsFor: '*algebra' stamp: 'len 4/30/2019 11:01:13'!
multichoose: anInteger
	"Answer 'd multichoose: n', the number of ways of counting n objects from a set of d elements where repetition is allowed and order does not matter."
	^ self + anInteger - 1 choose: anInteger! !

!Integer methodsFor: '*algebra' stamp: 'len 6/21/2023 15:00:42'!
multiplicativeOrder
	"Answer the order of the receiver as an element of the group of units.
	Return 0 if the receiver is not a unit."
	^ self == 1 ifTrue: [1] ifFalse: [self == -1 ifTrue: [2] ifFalse: [0]]! !

!Integer methodsFor: '*algebra' stamp: 'len 5/22/2023 18:35:52'!
nextBitPermutation
	"Answer the next bit permutation in lexicographical order."
	| t |
	t := (self bitOr: self - 1) + 1.
	^ t bitOr: ((t bitAnd: t negated) // (self bitAnd: self negated) bitShift: -1) - 1! !

!Integer methodsFor: '*algebra' stamp: 'len 12/10/2021 19:16:18'!
normalization
	"Answer a unit u such that 'self * u' is a unique choice of associate. See >>normalized."
	^ self < 0 ifTrue: [-1] ifFalse: [1]! !

!Integer methodsFor: '*algebra' stamp: 'len 7/30/2021 10:25:24'!
normalized
	"Answer a unique choice of associate. See >>normalization."
	^ self abs! !

!Integer methodsFor: '*algebra' stamp: 'len 12/13/2015 02:00'!
numberOfDivisors
	^ self primeSignature inject: 1 into: [:x :each| x * (each + 1)]! !

!Integer methodsFor: '*algebra' stamp: 'len 6/5/2023 13:33:55'!
olf
	"One-line factoring algorithm. See [Har11]."
	self flag: #fixme. "TODO"
	1 to: self - 1 do: [:i| | m s t |
		s := (self * i) sqrt ceiling.
		m := s squared \\ self.
		(t := m sqrtFloor) squared = m ifTrue: [^ self gcd: s - t]].
	^ self! !

!Integer methodsFor: '*algebra' stamp: 'len 5/5/2023 16:13:20'!
parent
	^ ℤ! !

!Integer methodsFor: '*algebra' stamp: 'len 7/2/2016 20:55'!
partitions
	^ Iterator on: self performing: #partitionsDo:! !

!Integer methodsFor: '*algebra' stamp: 'len 7/2/2016 20:57'!
partitionsDo: aBlock
	self < 0 ifTrue: [^ DomainError signal: 'negative number'].
	self = 0 ifTrue: [^ aBlock value: #()].
	self - 1 partitionsDo: [:each|
		aBlock value: #(1), each.
		(each size > 0 and: [each size < 2 or: [(each at: 2) > (each at: 1)]])
			ifTrue: [aBlock value: (each copy at: 1 put: (each at: 1) + 1; yourself)]]! !

!Integer methodsFor: '*algebra' stamp: 'len 12/10/2016 12:18:54'!
phi
	"Answer Euler's totient function phi of the receiver."
	^ (1 to: self) count: [:each| (self gcd: each) = 1]! !

!Integer methodsFor: '*algebra' stamp: 'len 6/24/2023 19:51:47'!
pollard
	"Answer a nontrivial factor of the receiver.
	This is Pollard's p-1 algorithm. This works well to find a prime factor p such that p - 1 is smooth."
	| N a x y p |
	N := self abs.
	a := N atRandom.
	x := N atRandom.
	y := x.
	[x := x squared + a \\ self.
	y := (y squared + a \\ self) squared + a \\ self.
	(p := y - x gcd: self) = 1 ifFalse: [^ p]] repeat! !

!Integer methodsFor: '*algebra' stamp: 'len 6/24/2023 19:51:39'!
pollard: L
	"Answer a nontrivial factor of the receiver, or nil if fail.
	This is Pollard's p-1 algorithm. It works well with numbers divisible by a prime p such that p - 1 is smooth with some small factor q^k where k*q <= L."
	| N A F |
	N := self abs.
	A := (2 to: N-1) atRandom.
	1 to: L do: [:i|
		A := A raisedTo: i modulo: N.
		(F := A - 1 gcd: N) = 1 ifFalse: [^ F]].
	^ nil! !

!Integer methodsFor: '*algebra' stamp: 'len 6/24/2023 19:50:52'!
pollardRho
	"Answer a nontrivial factor of the receiver, or nil if fail.
	This is Pollard's rho algorithm."
	| N x y d |
	N := self abs.
	x := 2.
	y := 2.
	[x := x squared + 1 \\ N.
	y := (y squared + 1 \\ N) squared + 1 \\ N.
	(d := x - y gcd: N) = 1] whileTrue.
	^ d = N ifFalse: [d]! !

!Integer methodsFor: '*algebra' stamp: 'len 6/24/2023 18:46:06'!
primePowerFactorizationOrNil
	| m |
	self isPrime ifTrue: [^ Bag with: self].
	self highBit + 1 to: 2 by: -1 do: [:k|
		(m := self root: k) isInteger
			ifTrue:
				[self assert: m^k = self.
				m isPrime ifFalse: [^ nil].
				^ Bag new add: m withOccurrences: k; yourself]].
	^ nil! !

!Integer methodsFor: '*algebra' stamp: 'len 12/3/2023 13:55:31'!
primeSignature
	| factors |
	factors := self factorization.
	^ (factors asSet sorted collect: [:each| factors occurrencesOf: each]) asArray! !

!Integer methodsFor: '*algebra' stamp: 'len 6/2/2024 16:42:06'!
printStringBlackboardBold
	| answer |
	answer := self abs printString collect: [:each| '𝟘𝟙𝟚𝟛𝟜𝟝𝟞𝟟𝟠𝟡' at: each asciiValue - 47].
	^ self negative ifTrue: ['⁻', answer] ifFalse: [answer]! !

!Integer methodsFor: '*algebra' stamp: 'len 6/2/2024 16:41:59'!
printStringSubscript
	| answer |
	answer := self abs printString collect: [:each| '₀₁₂₃₄₅₆₇₈₉' at: each asciiValue - 47].
	^ self negative ifTrue: ['₋', answer] ifFalse: [answer]! !

!Integer methodsFor: '*algebra' stamp: 'len 6/2/2024 16:41:52'!
printStringSuperscript
	| answer |
	answer := self abs printString collect: [:each| '⁰¹²³⁴⁵⁶⁷⁸⁹' at: each asciiValue - 47].
	^ self negative ifTrue: ['⁻', answer] ifFalse: [answer]! !

!Integer methodsFor: '*algebra' stamp: 'len 5/14/2020 12:34:33'!
quotientBy: anInteger modulo: m
	"Answer the Euclidean quotient of the receiver by anInteger modulo m.
	If the receiver is 'a' and anInteger is 'b', answer 'q' such that 'b*q = a mod m', or in other words 'b*q - a' is divisible by 'm' and 'q' is either 0 or the Euclidean degree of 'q' is strictly smaller than the Euclidean degree of 'm'."
	| f g fs gs h hs q r |
	f _ anInteger. fs _ 1.
	g _ m. gs _ 0.
	[g isZero] whileFalse:
		[q _ f // g. r _ f - (g*q).
		h _ g. hs _ gs.
		g _ r. gs _ fs - (q*gs).
		f _ h. fs _ hs].
	q _ self // f.
	^ fs * q \\ m! !

!Integer methodsFor: '*algebra' stamp: 'len 10/24/2023 16:10:31'!
radical
	"Answer the 'radical' or 'squarefree' part of the receiver. This is the product of the prime divisors."
	| answer |
	answer := self sign.
	self factorizationDo: [:p :e| answer := answer * p].
	^ answer! !

!Integer methodsFor: '*algebra' stamp: 'len 6/25/2023 13:32:23'!
raisedToInteger2: anInteger
	| n x y |
	anInteger = 0 ifTrue: [^ 1].
	anInteger > 0 ifTrue: [x := self. n := anInteger] ifFalse: [x := self reciprocal. n := anInteger negated].
	y := 1.
	[n > 1] whileTrue:	
		[n odd ifTrue: [y := x * y].
		x := x squared.
		n := n bitShift: -1].
	^ x * y! !

!Integer methodsFor: '*algebra' stamp: 'len 6/25/2023 13:33:59'!
raisedToInteger3: anInteger
	| n x y |
	anInteger = 0 ifTrue: [^ 1].
	anInteger > 0 ifTrue: [x := self. n := anInteger] ifFalse: [x := self reciprocal. n := anInteger negated].
	y := 1.
	1 to: n highBit do: [:i|
		(n bitAt: i) = 1 ifTrue: [y := x * y].
		x := x squared].
	^ x * y! !

!Integer methodsFor: '*algebra' stamp: 'len 12/4/2016 13:11:44'!
reciprocalModulo2: n
	"Answer an integer x such that self * x \\ n = 1, with 0 < x < n, or nil if it doesn't exist."
	| xgcd |
	self == 0 ifTrue: [^ nil].
	self == 1 ifTrue: [^ 1].
	xgcd _ self xgcd: n.
	^ (xgcd at: 1) == 1 ifTrue: [^ (xgcd at: 2) \\ n]! !

!Integer methodsFor: '*algebra' stamp: 'len 10/17/2023 14:09:39'!
reciprocalModulo: N
	"Answer an integer x such that self * x \\ N = 1, with 0 < x < N, or nil if x does not exist.
	The algorithm is a non extended euclidean modular inversion called NINV.
	It is described in this article:
		'Using an RSA Accelerator for Modular Inversion'
	by Martin Seysen. See http://www.iacr.org/archive/ches2005/017.pdf"

	| a u v f fPlusN b x x2 |
	N > 1 ifFalse: [^ nil].
	a := (self >= N or: [self < 0]) ifTrue: [self \\ N] ifFalse: [self].
	b := N highBit + 1.
	f := 1 bitShift: b.
	v := (a bitShift: b) + 1.
	u := N bitShift: b.
	fPlusN := f + N.
	[v >= fPlusN] whileTrue: [v := u \\ (u := v)].
	x := v - f.
	(x2 := x + N) > 0 ifFalse: [^ nil].
	^ x positive ifTrue: [x] ifFalse: [x2]! !

!Integer methodsFor: '*algebra' stamp: 'len 10/17/2023 14:12:40'!
reciprocalModulo: p to: m
	"Answer the multiplicative inverse of the receiver modulo p^m.
	See [Dum18, Algorithm 2': Recursive Hensel]."
	| h ph pm r t |
	self = 0 ifTrue: [^ nil].
	self = 1 ifTrue: [^ 1].
	p = 2 ifTrue: [^ self reciprocalModuloTwoTo: m].
	m = 1 ifTrue: [^ (self xgcd: p) at: 1].
	h := m even ifTrue: [m bitShift: -1] ifFalse: [m + 1 bitShift: -1].
	ph := p^h.
	pm := p^m.
	r := self \\ ph reciprocalModulo: p to: h.
	t := r squared * self \\ pm.
	^ r*2 - t \\ pm! !

!Integer methodsFor: '*algebra' stamp: 'len 5/15/2020 12:11:29'!
split: anInteger
	"Answer a factor of the argument splitting off the common factors between the argument and the receiver.
	Reference: 'Fast Algorithms for Linear Algebra Modulo N', Arne Storjohann, Thom Mulders."
	| a |
	a _ self.
	anInteger highBit highBit timesRepeat: [a _ a squared \\ anInteger].
	^ anInteger // (a gcd: anInteger)! !

!Integer methodsFor: '*algebra' stamp: 'len 1/9/2022 08:35:04'!
squarefreePart
	"Answer the unique integer z such that the receiver equals z * y^2 with z squarefree and y^2 a perfect square."
	| answer |
	answer _ self sign.
	self factorizationDo: [:p :e| e even ifFalse: [answer _ answer * p]].
	^ answer! !

!Integer methodsFor: '*algebra' stamp: 'len 12/12/2016 09:35:43'!
stirling: anInteger
	"Answer the Stirling number of the first kind s(n,k).
	Stirling numbers of the first kind count the ways to arrange n objects into k cycles."
	(anInteger > self or: [self < 0]) ifTrue: [^ DomainError signal].
	anInteger = 1 ifTrue: [^ (self - 1) factorial].
	self = anInteger ifTrue: [^ self Stirling: anInteger].
	self+1 = anInteger ifTrue: [^ self choose: 2].
	^ (self-1) * (self-1 stirling: anInteger) + (self-1 stirling: anInteger-1)! !

!Integer methodsFor: '*algebra' stamp: 'len 6/9/2019 07:58:03'!
valuation
	"Answer the Euclidean function at the receiver."
	^ self abs! !

!Integer methodsFor: '*algebra' stamp: 'len 6/23/2023 22:38:56'!
valuation2: p
	"Answer the p-adic valuation of the receiver.
	This is the exponent of the highest power of p that divides the receiver."
	"NOTE: this implementation is faster when p appears as factor to a high power, but otherwise slower."
	| answer q powers x |
	self = 0 ifTrue: [^ Infinity positive].
	p = 2 ifTrue: [^ self lowBit - 1].
	q := self abs.
	powers := OrderedCollection new.
	x := p.
	[q \\ x = 0] whileTrue: [powers add: x. x := x squared].
	powers isEmpty ifTrue: [^ 0].
	answer := 0.
	powers size to: 1 by: -1 do: [:k|
		x := powers at: k.
		q \\ x = 0 ifTrue: [answer := answer + (1 << (k-1)). q := q // x]].
	^ answer! !

!Integer methodsFor: '*algebra' stamp: 'len 6/23/2023 22:46:44'!
valuation3: p
	"Answer the p-adic valuation of the receiver.
	This is the exponent of the highest power of p that divides the receiver."
	| answer q k x |
	self = 0 ifTrue: [^ Infinity positive].
	p = 2 ifTrue: [^ self lowBit - 1].
	q := self abs.
	answer := 0.
	x := p.
	k := 1.
	[q \\ x = 0] whileTrue: [answer := answer + k. q := q // x. x := x squared. k := k * 2].
	answer = 0 ifFalse: [answer := answer + (q valuation3: p)].
	^ answer! !

!Integer methodsFor: '*algebra' stamp: 'len 6/23/2023 22:40:25'!
valuation: p
	"Answer the p-adic valuation of the receiver.
	This is the exponent of the highest power of p that divides the receiver."
	| answer q |
	self = 0 ifTrue: [^ Infinity positive].
	p = 2 ifTrue: [^ self lowBit - 1].
	q := self abs.
	answer := 0.
	self flag: #fixme. "this is slow, should divide by powers of p"
	[q \\ p = 0] whileTrue: [answer := answer + 1. q := q // p].
	^ answer! !

!Integer methodsFor: '*algebra' stamp: 'len 6/9/2023 09:59:10'!
xgcd: anInteger
	"Answer the GCD of the receiver and the argument and the Bézout coefficients.
	If the receiver is 'a', the argument is 'b' and their GCD is 'g', answer an array {g. s. t} where as + bt = g.
	This is the extended Euclidean algorithm."
	| a b s₁ t₁ s t r₁ r |
	a := self. b := anInteger.
	s₁ := 0. s := 1.
	t₁ := 1. t := 0.
	r₁ := a abs. r := b abs.
	[r₁ == 0]
		whileFalse:
			[ | q temp |
			q := r // r₁.
			temp := r₁. r₁ := r - (q * r₁). r := temp.
			temp := s₁. s₁ := s - (q * s₁). s := temp.
			temp := t₁. t₁ := t - (q * t₁). t := temp].
	s := s * b sign. t := t * a sign.
	^ {r. t. s}! !

!Integer methodsFor: '*algebra' stamp: 'len 5/26/2022 12:36:54'!
xxgcd: anInteger
	"(More) Extended GCD.
	If the receiver is 'a', the argument is 'b' and their GCD is 'g'. answer an array {g. s. t. u. v} where as + bt = g, au + bv = 0, and sv - ut = 1, i.e. answer the coefficients of a unimodular matrix such that:.
		[s  t] [a]     [g]
		[u v] [b] = [0]."
	| xgcd g |
	(self = 0 and: [anInteger = 0]) ifTrue: [^ {0. 1. 0. 0. 1}].
	^ (xgcd _ self xgcd: anInteger), {(anInteger // (g _ xgcd at: 1)) negated. self // g}! !

!Integer methodsFor: '*algebra' stamp: 'len 5/12/2023 00:50:10'!
∧ anInteger
	^ self bitAnd: anInteger! !

!Integer methodsFor: '*algebra' stamp: 'len 5/12/2023 00:50:23'!
∨ anInteger
	^ self bitOr: anInteger! !

!Integer methodsFor: '*algebra' stamp: 'len 5/12/2023 00:49:51'!
⊕ anInteger
	^ self bitXor: anInteger! !

!Integer methodsFor: '*algebra' stamp: 'len 5/23/2022 11:37:19'!
⊥ anInteger
	"Answer true if the receiver and the argument are coprime."
	^ (self gcd: anInteger) = 1! !

!LargePositiveInteger methodsFor: '*algebra' stamp: 'len 5/14/2023 13:43:01'!
÷ anInteger
	"Answer the exact division of the receiver by the argument.
	Asume that the argument divides the receiver."
	^ (self digitDiv: anInteger neg: false) first! !

!LargePositiveInteger methodsFor: '*algebra' stamp: 'len 5/25/2023 15:45:22'!
bits: length at: index
	"Read the desired number of bits from the receiver starting at the given bit index."
	| i bits start₀ start stop |
	start₀ := index - 1.
	start := (start₀ bitShift: -3) + 1.
	start <= self size ifFalse: [^ 0].
	stop := (start₀ + length bitShift: -3) + 1 min: self size.
	start <= stop ifFalse: [^ 0].
	bits := 0.
	i := start.
	[i <= stop] whileTrue: [bits := bits bitXor: ((self at: i) bitShift: 8 * (i - start)). i := i + 1].
	^ (bits bitShift: (start₀ bitAnd: 7) negated) bitAnd: (1 bitShift: length) - 1! !

!LargePositiveInteger methodsFor: '*algebra' stamp: 'len 5/25/2023 15:41:11'!
bits: length at: index xor: bits
	"XOR the desired number of bits over the receiver starting at the given bit index."
	| i start₀ start stop |
	start₀ := index - 1.
	start := (start₀ bitShift: -3) + 1.
	stop := (start₀ + length bitShift: -3) + 1.
	i := start.
	[i <= stop] whileTrue: [self at: i put: ((self at: i) bitXor: ((bits bitShift: start₀ \\ 8 - (8 * (i - start))) bitAnd: 16rFF)). i := i + 1].
	^ bits! !

!LargePositiveInteger methodsFor: '*algebra' stamp: 'len 5/25/2023 00:18:40'!
copyFrom: start to: stop 
	"Answer a copy of a subset of the receiver, starting from element at 
	index start until element at index stop."

	| newSize |
	newSize := stop - start + 1 max: 0.
	newSize = 0 ifTrue: [^ 0].
	^ (self species new: newSize)
		replaceFrom: 1 to: newSize with: self startingAt: start;
		normalize! !

!SmallInteger methodsFor: '*algebra' stamp: 'len 5/17/2023 10:43:31'!
bitConvolution16: anInteger
	| a b c |
	a _ self.
	b _ anInteger.
	c _ 0.
	0 to: 15 do: [:i|
		(a bitAnd: 1) = 1 ifTrue: [c _ c bitXor: (b bitShift: i)].
		a _ a bitShift: -1].
	^ c! !

!SmallInteger methodsFor: '*algebra' stamp: 'len 5/18/2023 01:02:30'!
bitConvolution30: anInteger
	| a b c |
	a _ self.
	b _ anInteger.
	c _ 0.
	0 to: 29 do: [:i|
		(a bitAnd: 1) = 1 ifTrue: [c _ c bitXor: (b bitShift: i)].
		a _ a bitShift: -1].
	^ c! !

!SmallInteger methodsFor: '*algebra' stamp: 'len 5/17/2023 10:40:15'!
bitConvolution32: anInteger
	| a b c |
	a _ self.
	b _ anInteger.
	c _ 0.
	0 to: 31 do: [:i|
		(a bitAnd: 1) = 1 ifTrue: [c _ c bitXor: (b bitShift: i)].
		a _ a bitShift: -1].
	^ c! !

!SmallInteger methodsFor: '*algebra' stamp: 'len 5/13/2023 07:47:19'!
bitCount
	"Answer the number of bits that are set, i.e. the number of 1s in the binary representation."
	^ (self bitShift: -32) bitCount32 + (self bitAnd: 16rFFFFFFFF) bitCount32! !

!SmallInteger methodsFor: '*algebra' stamp: 'len 1/3/2024 18:25:01'!
bitCount32
	"Answer the number of bits that are set, i.e. the number of 1s in the binary representation.
	Assume the receiver has at most 32 bits.
	Adapted from Hacker's Delight [War02]."
	| x |
	x := self.
	x := x - ((x bitShift: -1) bitAnd: 16r55555555).
	x := (x bitAnd: 16r33333333) + ((x bitShift: -2) bitAnd: 16r33333333).
	x := x + (x bitShift: -4) bitAnd: 16r0F0F0F0F.
	x := x + (x bitShift: -8).
	x := x + (x bitShift: -16).
	^ x bitAnd: 16r3F! !

!SmallInteger methodsFor: '*algebra' stamp: 'len 5/22/2023 14:42:42'!
bitMix16: anInteger
	^ (((self bitShift: 16) bitXor: self) bitAnd: 16rFFFF0000) bitOr: (((anInteger bitShift: -16) bitXor: anInteger) bitAnd: 16r0000FFFF)! !

!SmallInteger methodsFor: '*algebra' stamp: 'len 5/22/2023 14:39:51'!
bitMix1: anInteger
	^ (((self bitShift: 1) bitXor: self) bitAnd: 16rAAAAAAAA) bitOr: (((anInteger bitShift: -1) bitXor: anInteger) bitAnd: 16r55555555)! !

!SmallInteger methodsFor: '*algebra' stamp: 'len 5/22/2023 14:41:04'!
bitMix2: anInteger
	^ (((self bitShift: 2) bitXor: self) bitAnd: 16rCCCCCCCC) bitOr: (((anInteger bitShift: -2) bitXor: anInteger) bitAnd: 16r33333333)! !

!SmallInteger methodsFor: '*algebra' stamp: 'len 5/22/2023 14:41:33'!
bitMix4: anInteger
	^ (((self bitShift: 4) bitXor: self) bitAnd: 16rF0F0F0F0) bitOr: (((anInteger bitShift: -4) bitXor: anInteger) bitAnd: 16r0F0F0F0F)! !

!SmallInteger methodsFor: '*algebra' stamp: 'len 5/22/2023 14:42:13'!
bitMix8: anInteger
	^ (((self bitShift: 8) bitXor: self) bitAnd: 16rFF00FF00) bitOr: (((anInteger bitShift: -8) bitXor: anInteger) bitAnd: 16r00FF00FF)! !

!SmallInteger methodsFor: '*algebra' stamp: 'len 5/13/2023 19:06:34'!
bitParity
	"Answer 1 if there are an odd number of bits set, 0 otherwise.
	Adapted from Hacker's Delight [War02]."
	^ (self bitXor: (self bitShift: -32)) bitParity32! !

!SmallInteger methodsFor: '*algebra' stamp: 'len 5/13/2023 19:06:43'!
bitParity16
	"Answer 1 if there are an odd number of bits set, 0 otherwise.
	Assume the receiver has at most 16 bits.
	Adapted from Hacker's Delight [War02]."
	| n |
	n _ self.
	n _ n bitXor: (n bitShift: -8).
	n _ n bitXor: (n bitShift: -4).
	n _ n bitAnd: 16rF.
	^ (16r6996 bitShift: n negated) bitAnd: 1! !

!SmallInteger methodsFor: '*algebra' stamp: 'len 5/13/2023 19:06:47'!
bitParity32
	"Answer 1 if there are an odd number of bits set, 0 otherwise.
	Assume the receiver has at most 32 bits.
	Adapted from Hacker's Delight [War02]."
	| n |
	n _ self.
	n _ n bitXor: (n bitShift: -16).
	n _ n bitXor: (n bitShift: -8).
	n _ n bitXor: (n bitShift: -4).
	n _ n bitAnd: 16rF.
	^ (16r6996 bitShift: n negated) bitAnd: 1! !

!SmallInteger methodsFor: '*algebra' stamp: 'len 5/13/2023 19:06:52'!
bitParity8
	"Answer 1 if there are an odd number of bits set, 0 otherwise.
	Assume the receiver has at most 8 bits.
	Adapted from Hacker's Delight [War02]."
	| n |
	n _ self.
	n _ n bitXor: (n bitShift: -4).
	n _ n bitAnd: 16rF.
	^ (16r6996 bitShift: n negated) bitAnd: 1! !

!SmallInteger methodsFor: '*algebra' stamp: 'len 7/12/2019 05:24:51'!
raisedToInteger: anInteger
	self == -1 ifTrue: [^ anInteger odd ifTrue: [-1] ifFalse: [1]].
	^ super raisedToInteger: anInteger! !

!Class methodsFor: '*algebra' stamp: 'len 4/10/2024 04:25:59'!
includes: anObject
	^ anObject isKindOf: self! !

!Class methodsFor: '*algebra' stamp: 'len 12/1/2016 09:03:19'!
newSubclass
	"Answer a new subclass of the receiver. The new subclass will be unnamed and uncategorized, and if no instances exist it can be subject of garbage collection."
	| newMetaclass |
	newMetaclass _ Metaclass new.
	newMetaclass
		superclass: self class
		methodDictionary: MethodDictionary new
		format: self class format.
	^ newMetaclass new
		superclass: self
		methodDictionary: MethodDictionary new
		format: self format! !

!BlockClosure methodsFor: '*algebra' stamp: 'len 5/1/2022 10:18:05'!
count
	"Evaluate the receiver multiple times while it responds true.
	Answer the number of times it was evaluated."
	| count |
	count _ 0.
	self whileTrue: [count _ count + 1].
	^ count! !

!Collection methodsFor: '*algebra' stamp: 'len 5/5/2024 07:18:01'!
apply: aMap
	^ self collect: aMap! !

!Collection methodsFor: '*algebra' stamp: 'len 7/24/2024 08:40:34'!
asSetObject
	^ SetObject elements: self asSet! !

!Collection methodsFor: '*algebra' stamp: 'len 5/25/2018 18:10:51'!
atRandom: aRandom bits: bitSize
	^ self atRandom: aRandom! !

!Collection methodsFor: '*algebra' stamp: 'len 1/30/2018 21:35:53'!
atRandomBits: anInteger
	^ self atRandom! !

!Collection methodsFor: '*algebra' stamp: 'len 5/4/2023 23:55:29'!
bitSize
	^ self sum: [:each| each bitSize] ifEmpty: [0]! !

!Collection methodsFor: '*algebra' stamp: 'len 5/7/2023 01:18:00'!
gcd
	| answer |
	answer _ nil.
	self do: [:each|
		answer _ answer isNil ifTrue: [each] ifFalse: [answer gcd: each].
		"answer isOne ifTrue: [^ answer]"].
	^ answer! !

!Collection methodsFor: '*algebra' stamp: 'len 5/6/2019 02:58:39'!
inverse
	^ self collect: [:a | a inverse]! !

!Collection methodsFor: '*algebra' stamp: 'len 5/8/2018 07:15:12'!
printElementsOn: aStream
	aStream nextPut: $(.
	self do: [:element| aStream print: element] separatedBy: [aStream nextPutAll: ', '].
	aStream nextPut: $)! !

!Collection methodsFor: '*algebra' stamp: 'len 5/30/2023 13:44:11'!
squared
	^ self collect: [:each | each squared]! !

!Collection methodsFor: '*algebra' stamp: 'len 6/23/2019 04:34:56'!
upTo: max do: aBlock
	"Iterate over the elements of the receiver, just like #do:, but stop after max elements."
	| k |
	k _ 1.
	self do: [:each|
		k > max ifTrue: [^ self].
		aBlock value: each.
		k _ k+1]! !

!SequenceableCollection methodsFor: '*algebra' stamp: 'len 10/3/2023 12:33:00'!
allProducts
	| answer |
	answer := Set new.
	self allProductsDo: [:each| answer add: each].
	^ answer! !

!SequenceableCollection methodsFor: '*algebra' stamp: 'len 10/3/2023 12:34:31'!
allProductsDo: aBlock
	self isEmpty ifTrue: [^ self].
	self size = 1 ifTrue: [^ self last do: aBlock].
	self last do: [:y| self allButLast allProductsDo: [:x| aBlock value: x*y]]! !

!SequenceableCollection methodsFor: '*algebra' stamp: 'len 5/5/2024 07:18:30'!
apply: aMap
	^ aMap isBlock ifTrue: [self collect: aMap] ifFalse: [aMap codomain new: self size fill: [:i| aMap value: (self at: i)]]! !

!Array methodsFor: '*algebra' stamp: 'len 6/9/2024 08:09:56'!
into: aBlock
	^ aBlock valueWithArguments: self! !

!Array methodsFor: '*algebra' stamp: 'len 5/29/2023 13:49:47'!
printOn: aStream
	self == Smalltalk specialObjectsArray
		ifTrue: [aStream nextPutAll: 'Smalltalk specialObjectsArray' ]
		ifFalse:
			[aStream withParentheses: [:aStream2|
				self do: [:each| aStream2 print: each] separatedBy: [aStream2 nextPutAll: ', ']]]! !

!ByteArray methodsFor: '*algebra' stamp: 'len 12/28/2023 11:16:34'!
asForm
	^ Form extent: self size @ 1 depth: 8 bits: self! !

!ByteArray methodsFor: '*algebra' stamp: 'len 5/11/2023 15:28:48'!
weight
	"Answer the Hamming weight of the receiver, i.e. the number of entries that are not zero."
	^ self count: [:each| each ~~ 0]! !

!WordArray methodsFor: '*algebra' stamp: 'len 12/28/2023 11:16:49'!
asForm
	^ Form extent: self size @ 1 depth: 32 bits: self! !

!WordArray methodsFor: '*algebra' stamp: 'len 1/3/2024 09:35:39'!
bitSize
	^ self size * 32! !

!WordArray methodsFor: '*algebra' stamp: 'len 5/11/2023 15:29:25'!
weight
	"Answer the Hamming weight of the receiver, i.e. the number of entries that are not zero."
	^ self count: [:each| each ~~ 0]! !

!DoubleByteArray methodsFor: '*algebra' stamp: 'len 12/28/2023 11:17:06'!
asForm
	^ Form extent: self size @ 1 depth: 16 bits: self! !

!DoubleByteArray methodsFor: '*algebra' stamp: 'len 5/12/2023 14:35:24'!
weight
	"Answer the Hamming weight of the receiver, i.e. the number of entries that are not zero."
	^ self count: [:each| each ~~ 0]! !

!Interval methodsFor: '*algebra' stamp: 'len 11/14/2016 13:59'!
isStandard
	"Answer true if the receiver is an interval [1..n]."
	^ start = 1 and: [stop isInteger and: [stop >= 1 and: [stop - start + 1 = count]]]! !

!Interval methodsFor: '*algebra' stamp: 'len 11/14/2016 10:15'!
printOn: aStream
	self increment = 1
		ifTrue: [aStream nextPut: $[; print: start; nextPutAll: '..'; print: stop; nextPut: $]]
		ifFalse: [self storeOn: aStream]! !

!Interval methodsFor: '*algebra' stamp: 'len 11/14/2016 10:14'!
storeOn: aStream
	aStream nextPut: $(; print: start; nextPutAll: ' to: '; print: stop.
	self increment ~= 1 ifTrue: [aStream nextPutAll: ' by: '; print: self increment].
	aStream nextPut: $)! !

!Bag methodsFor: '*algebra' stamp: 'len 8/5/2021 08:32:53'!
printOn: aStream
	aStream nextPut: ${.
	self asSet
		do: [:each|
			| times |
			times _ self occurrencesOf: each.
			(each printString isAlphaNumeric or: [times = 1])
				ifTrue: [aStream print: each]
				ifFalse: [aStream nextPut: $(; print: each; nextPut: $)].
			times > 1 ifTrue: [aStream nextPutAll: times printString super]]
		separatedBy: [aStream nextPutAll: ', '].
	aStream nextPut: $}! !

!Set methodsFor: '*algebra' stamp: 'len 11/7/2016 09:28'!
printOn: aStream
	(self isMemberOf: Set)
		ifFalse: [^ super printOn: aStream].
	aStream nextPut: ${.
	self do: [:each| aStream print: each] separatedBy: [aStream nextPutAll: ', '].
	aStream nextPut: $}! !

!Dictionary methodsFor: '*algebra' stamp: 'len 6/19/2023 15:14:17'!
+ aDictionary
	| answer |
	answer := self copy.
	aDictionary keysAndValuesDo: [:key :value| answer at: key addAndRemoveIfZero: value].
	^ answer! !

!Dictionary methodsFor: '*algebra' stamp: 'len 6/19/2023 15:14:28'!
- aDictionary
	| answer |
	answer := self copy.
	aDictionary keysAndValuesDo: [:key :value| answer at: key addAndRemoveIfZero: value negated].
	^ answer! !

!Dictionary methodsFor: '*algebra' stamp: 'len 11/30/2016 14:47:44'!
at: key add: value
	| index assoc |
	index _ self findElementOrNil: key.
	assoc _ array at: index.
	assoc
		ifNil:
			[value isZero ifFalse: [self atNewIndex: index put: (Association key: key value: value)]]
		ifNotNil:
			[|newValue|
			newValue _ assoc value + value.
			assoc value: newValue.
			^ newValue].
	^ value! !

!Dictionary methodsFor: '*algebra' stamp: 'len 11/30/2016 14:47:14'!
at: key addAndRemoveIfZero: value
	| index assoc |
	index _ self findElementOrNil: key.
	assoc _ array at: index.
	assoc
		ifNil:
			[value isZero ifFalse: [self atNewIndex: index put: (Association key: key value: value)]]
		ifNotNil:
			[|newValue|
			newValue _ assoc value + value.
			newValue isZero
				ifTrue:
					[array at: index put: nil.
					tally _ tally - 1.
					self fixCollisionsFrom: index]
				ifFalse: [assoc value: newValue].
			^ newValue].
	^ value! !

!Dictionary methodsFor: '*algebra' stamp: 'len 3/6/2017 19:54:46'!
printElementsOn: aStream
	aStream nextPut: ${.
	self keysSortedSafely do:
		[:key | aStream print: key; nextPutAll: '->'; print: (self at: key)] separatedBy: [aStream space].
	aStream nextPut: $}! !

!SortedDictionary methodsFor: '*algebra' stamp: 'len 11/30/2022 10:21:01'!
autoconvolution
	^ self convolution: self! !

!SortedDictionary methodsFor: '*algebra' stamp: 'len 4/27/2022 13:39:42'!
collectByKey: aBlock
	| dictionary newAssociations |
	dictionary _ Dictionary new: associations size.
	associations do: [:each| dictionary at: (aBlock value: each key) add: each value].
	newAssociations _ OrderedCollection new: dictionary size.
	newAssociations resetTo: 1.
	dictionary associationsDo: [:each| each value isZero ifFalse: [newAssociations add: each]].
	newAssociations sort.
	^ self class associations: newAssociations! !

!SortedDictionary methodsFor: '*algebra' stamp: 'len 8/21/2022 08:21:25'!
convolution: aSortedDictionary
	| dictionary newAssociations |
	dictionary _ Dictionary new: self size + aSortedDictionary size.
	self associationsDo: [:each|
		aSortedDictionary associationsDo: [:other|
			dictionary at: each key * other key add: each value * other value]].
	newAssociations _ OrderedCollection new: dictionary size.
	newAssociations resetTo: 1.
	dictionary associationsDo: [:each| each value isZero ifFalse: [newAssociations add: each]].
	newAssociations sort.
	^ self class associations: newAssociations! !

!SortedDictionary methodsFor: '*algebra' stamp: 'len 6/16/2023 14:29:40'!
printOn: aStream
	aStream nextPut: ${.
	associations do: [:each | aStream print: each] separatedBy: [aStream nextPutAll: ', '].
	aStream nextPut: $}! !

!SortedDictionary methodsFor: '*algebra' stamp: 'len 4/27/2022 13:39:29'!
selectByKey: aBlock
	| newAssociations |
	newAssociations _ OrderedCollection new.
	newAssociations resetTo: 1.
	newAssociations do: [:each| (aBlock value: each key) ifTrue: [newAssociations add: each copy]].
	^ self class associations: newAssociations! !

!Graph methodsFor: '*algebra-comparing' stamp: 'len 7/23/2016 04:06'!
~ aGraph
	"Answer true if the receiver is isomorphic to aGraph."
	| n G H |
	self isLabeled ifTrue: [self notYetImplemented].
	self species = aGraph species ifFalse: [^ false].
	(n _ self size) = aGraph size ifFalse: [^ false].
	"we could insert some heuristic tests here, comparing easy-to-compute invariants"
	G _ self asStandard.
	H _ aGraph asStandard.
	(SymmetricGroup new: n) do: [:each| (G apply: each) = H ifTrue: [^ true]].
	^ false! !

!Graph methodsFor: '*algebra-operations' stamp: 'len 6/2/2020 11:51:18'!
adjacencyMatrix
	"Answer the adjacency matrix of the receiver, assuming that the vertices are the integers {1,..,n}.
	If the graph is labelled, use the labels as entries in the matrix."
	| n matrix |
	n _ self order.
	matrix _ (ℤ^n) endomorphisms zero.
	self edgesAndLabelsDo: [:edge :label| matrix at: edge key @ edge value add: (label ifNil: [1])].
	^ matrix! !

!Graph methodsFor: '*algebra-operations' stamp: 'len 11/23/2022 21:23:48'!
adjacencyMatrix: vertices
	"Answer the adjacency matrix of the receiver, using the vertex ordering given by the argument."
	^ (ℤ^vertices size) endomorphisms fill: [:i :j| self multiplicityFrom: (vertices at: i) to: (vertices at: j)]! !

!Graph methodsFor: '*algebra-operations' stamp: 'len 12/18/2023 11:20:19'!
automorphisms
	"Answer the group of symmetries of the receiver, i.e. the group of permutations of vertices that don't change the graph."
	| S |
	S := SymmetricGroup on: self values.
	^ S sub: (S select: [:each| (self apply: each) = self])! !

!Graph methodsFor: '*algebra-operations' stamp: 'len 7/25/2016 02:37'!
automorphismsWithInvariant: aBlock
	"Answer the group of symmetries of the receiver, i.e. the group of permutations of vertices that don't change the graph."
	| partition |
	partition _ Dictionary new.
	self nodesDo: [:each| (partition at: (aBlock value: each) ifAbsentPut: [OrderedCollection new]) add: each value].
	^ self automorphismsWithPartition: partition! !

!Graph methodsFor: '*algebra-operations' stamp: 'len 6/26/2023 12:48:14'!
automorphismsWithPartition: aCollection
	"Answer the group of symmetries of the receiver, i.e. the group of permutations of vertices that don't change the graph."
	| product automorphisms |
	product := CartesianProduct components: (aCollection collect: [:each| SymmetricGroup on: each]).
	automorphisms := OrderedCollection new.
	product do: [:each|
		| f |
		f := each product.
		(self apply: f) = self ifTrue: [automorphisms add: f]].
	^ (SymmetricGroup on: self values) sub: automorphisms! !

!Graph methodsFor: '*algebra-operations' stamp: 'len 7/13/2016 22:06'!
chromaticNumber
	"The minimum number of colors to do a proper coloring of the graph."
	| chi |
	chi _ self chromaticPolynomial.
	^ (1 to: self size) detect: [:i| (chi value: i) > 0]! !

!Graph methodsFor: '*algebra-operations' stamp: 'len 5/23/2020 09:34:55'!
chromaticPolynomial
	"The chromatic polynomial P(G,k) is a polynomial in k that counts the number of k-colorings of G."
	^ self chromaticPolynomialAt: ℤ polynomials x! !

!Graph methodsFor: '*algebra-operations' stamp: 'len 7/14/2016 06:50'!
chromaticPolynomialAt: k
	"The chromatic polynomial P(G,k) is a polynomial in k that counts the number of k-colorings of G. Answer the evaluation at k."
	self isEdgeless ifTrue: [^ k ^ self size].
	self edgesDo: [:each|
		each key = each value
			ifFalse: [^ ((self - each) chromaticPolynomialAt: k) - ((self / each) chromaticPolynomialAt: k)]].
	^ k*0! !

!Graph methodsFor: '*algebra-random' stamp: 'len 12/18/2023 10:33:57'!
shuffledBy: aRandom
	| values1 values2 |
	values1 := self values asArray.
	values2 := values1 shuffledBy: aRandom.
	^ self collect: [:each| values2 at: (values1 indexOf: each)]! !

!UndirectedGraph methodsFor: '*algebra-operations' stamp: 'len 5/25/2024 06:45:43'!
flowPolynomial
	"The flow polynomial F(G,k) is a polynomial in k that counts the number of nowhere-zero k-flows of G."
	| x |
	x := ℤ polynomials x.
	^ (-1)^(self size + self numberOfEdges + self connectedComponents size) * (self tuttePolynomial value: {0. 1 - x})! !

!UndirectedGraph methodsFor: '*algebra-operations' stamp: 'len 5/25/2024 06:46:45'!
tuttePolynomial
	| P K G |
	P := ℤ polynomialsIn: #(x y).
	self isEdgeless ifTrue: [^ P one].
	K := self connectedComponents size.
	self edgesDo: [:e|
		e key = e value "it's a loop"
			ifTrue: [^ P y * (self - e) tuttePolynomial]
			ifFalse:
				[G := self - e.
				G connectedComponents size > K "it's a bridge"
					ifTrue: [^ P x * (self / e) tuttePolynomial]
					ifFalse: [^ G tuttePolynomial + (self / e) tuttePolynomial]]].
	^ self error: 'inconsistency, this line should have been reaached'! !

!Stream methodsFor: '*algebra' stamp: 'len 1/26/2024 14:09:55'!
open: openCharacter close: closeCharacter enclosing: aBlock
	| h innerStream innerText |
	self isText ifFalse: [self nextPut: openCharacter. aBlock value: self. self nextPut: closeCharacter. ^ self].
	innerStream := '' asText writeStream.
	aBlock value: innerStream.
	innerText := innerStream contents.
	h := 0.
	innerText attributesFrom: 1 to: innerText size do: [:each|
		each anchoredFormOrMorph ifNotNil: [:anObject|
			(anObject is: #Morph)
				ifTrue: [h := h max: anObject morphHeight]
				ifFalse: [(anObject is: #Form) ifTrue: [h := h max: anObject height]]]].
	h > 0 ifFalse: [^ self nextPut: openCharacter; nextPutAll: innerText; nextPut: closeCharacter].
	self nextPutAll: (openCharacter asText pointSize: h); nextPutAll: innerText; nextPutAll: (closeCharacter asText pointSize: h)! !

!Stream methodsFor: '*algebra' stamp: 'len 5/29/2023 23:42:38'!
withAngleBrackets: aBlock
	self open: $⟨ close: $⟩ enclosing: aBlock! !

!Stream methodsFor: '*algebra' stamp: 'len 5/29/2023 23:43:01'!
withBraces: aBlock
	self open: ${ close: $} enclosing: aBlock! !

!Stream methodsFor: '*algebra' stamp: 'len 5/29/2023 23:42:13'!
withBrackets: aBlock
	self open: $[ close: $] enclosing: aBlock! !

!Stream methodsFor: '*algebra' stamp: 'len 5/29/2023 23:43:24'!
withParentheses: aBlock
	self open: $( close: $) enclosing: aBlock! !

!Complex methodsFor: '*algebra' stamp: 'len 1/22/2017 08:13:12'!
^ aNumber
	^ self raisedTo: aNumber! !

!Complex methodsFor: '*algebra' stamp: 'len 11/20/2023 10:25:37'!
abs²
	"Answer the square of the absolute value of the receiver."
	^ real squared + imaginary squared! !

!Complex methodsFor: '*algebra' stamp: 'len 11/10/2023 19:17:14'!
asFloat
	^ self class real: real asFloat imaginary: imaginary asFloat! !

!Complex methodsFor: '*algebra' stamp: 'len 11/10/2023 11:00:38'!
asNumber
	^ self! !

!Complex methodsFor: '*algebra' stamp: 'len 8/9/2020 07:47:37'!
conjugate
	^self class real: real imaginary: imaginary negated! !

!Complex methodsFor: '*algebra' stamp: 'len 12/6/2016 13:18:52'!
isInfinite
	^ real isInfinite or: [imaginary isInfinite]! !

!Complex methodsFor: '*algebra' stamp: 'len 8/5/2016 21:45'!
isReal
	^ self imaginary isZero! !

!Complex methodsFor: '*algebra' stamp: 'len 12/26/2015 19:56'!
one
	^ self class real: real one imaginary: imaginary zero! !

!Complex methodsFor: '*algebra' stamp: 'len 11/29/2016 11:42:24'!
printOn: aStream
	(real ~= 0 or: [imaginary = 0])
		ifTrue:
			[aStream print: real.
			imaginary = 0
				ifFalse:
					[aStream space.
					imaginary positive
						ifTrue: [aStream nextPut: $+]
						ifFalse: [aStream nextPut: $-].
					aStream space.
					imaginary abs = 1 ifFalse: [aStream print: imaginary abs].
					aStream nextPutAll: 'i' italic]]
		ifFalse:
			[imaginary negative
				ifTrue: [aStream nextPut: $-].
			imaginary abs = 1 ifFalse: [aStream print: imaginary abs].
			aStream nextPutAll: 'i' italic]! !

!Complex methodsFor: '*algebra' stamp: 'len 1/4/2022 12:51:00'!
rounded
	^ self class real: real rounded imaginary: imaginary rounded! !

!Complex methodsFor: '*algebra' stamp: 'len 11/20/2023 10:25:01'!
within: aNumber
	"Answer true if the receiver is within the closed ball at the origin of radius aNumber."
	^ self abs² <= aNumber squared! !

!Complex methodsFor: '*algebra' stamp: 'len 12/26/2015 19:56'!
zero
	^ self class real: real zero imaginary: imaginary zero! !
BinaryArray initialize!
TernaryArray initialize!
ModularIntegerRing initialize!
PrimeField initialize!
CyclotomicField initialize!
Functor initialize!
MonoidMap initialize!
GroupMap initialize!
RingMap initialize!
SchemeMorphism initialize!
SimplicialMap initialize!
GrayCode initialize!
