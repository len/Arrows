'From Cuis 4.2 of 25 July 2013 [latest update: #2847] on 10 October 2016 at 5:49:12.69796 pm'!
'Description Please enter a description for this package'!
!provides: 'Mathematics' 1 210!
!classDefinition: #DyadicFraction category: #'Mathematics-Kernel-Support'!
Number subclass: #DyadicFraction
	instanceVariableNames: 'numerator shift'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Support'!
!classDefinition: 'DyadicFraction class' category: #'Mathematics-Kernel-Support'!
DyadicFraction class
	instanceVariableNames: ''!

!classDefinition: #RealAlgebraicNumber category: #'Mathematics-Number Fields'!
Number subclass: #RealAlgebraicNumber
	instanceVariableNames: 'polynomial irreducible bounds rightSign'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Number Fields'!
!classDefinition: 'RealAlgebraicNumber class' category: #'Mathematics-Number Fields'!
RealAlgebraicNumber class
	instanceVariableNames: ''!

!classDefinition: #ContinuedFraction category: #'Mathematics-Sequences'!
Number subclass: #ContinuedFraction
	instanceVariableNames: 'coefficients'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Sequences'!
!classDefinition: 'ContinuedFraction class' category: #'Mathematics-Sequences'!
ContinuedFraction class
	instanceVariableNames: ''!

!classDefinition: #MutualAssociation category: #'Mathematics-Graphs-Parts'!
Association subclass: #MutualAssociation
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Graphs-Parts'!
!classDefinition: 'MutualAssociation class' category: #'Mathematics-Graphs-Parts'!
MutualAssociation class
	instanceVariableNames: ''!

!classDefinition: #Aleph category: #'Mathematics-Kernel-Support'!
Magnitude subclass: #Aleph
	instanceVariableNames: 'order'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Support'!
!classDefinition: 'Aleph class' category: #'Mathematics-Kernel-Support'!
Aleph class
	instanceVariableNames: ''!

!classDefinition: #Infinity category: #'Mathematics-Kernel-Support'!
Magnitude subclass: #Infinity
	instanceVariableNames: 'sign'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Support'!
!classDefinition: 'Infinity class' category: #'Mathematics-Kernel-Support'!
Infinity class
	instanceVariableNames: ''!

!classDefinition: #OrderedTuple category: #'Mathematics-Kernel-Tuples'!
ArrayedCollection subclass: #OrderedTuple
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Tuples'!
!classDefinition: 'OrderedTuple class' category: #'Mathematics-Kernel-Tuples'!
OrderedTuple class
	instanceVariableNames: ''!

!classDefinition: #BitTuple category: #'Mathematics-Kernel-Tuples'!
OrderedTuple subclass: #BitTuple
	instanceVariableNames: 'integer size'
	classVariableNames: 'One Zero'
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Tuples'!
!classDefinition: 'BitTuple class' category: #'Mathematics-Kernel-Tuples'!
BitTuple class
	instanceVariableNames: ''!

!classDefinition: #ModularTuple category: #'Mathematics-Kernel-Tuples'!
OrderedTuple subclass: #ModularTuple
	instanceVariableNames: 'representatives modulus'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Tuples'!
!classDefinition: 'ModularTuple class' category: #'Mathematics-Kernel-Tuples'!
ModularTuple class
	instanceVariableNames: ''!

!classDefinition: #Tuple category: #'Mathematics-Kernel-Tuples'!
OrderedTuple subclass: #Tuple
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Tuples'!
!classDefinition: 'Tuple class' category: #'Mathematics-Kernel-Tuples'!
Tuple class
	instanceVariableNames: ''!

!classDefinition: #BitArray category: #'Mathematics-ETC'!
ArrayedCollection subclass: #BitArray
	instanceVariableNames: 'bytes length'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-ETC'!
!classDefinition: 'BitArray class' category: #'Mathematics-ETC'!
BitArray class
	instanceVariableNames: ''!

!classDefinition: #LinearBasis category: #'Mathematics-Modules-Support'!
SequenceableCollection subclass: #LinearBasis
	instanceVariableNames: 'ambient vectors'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Modules-Support'!
!classDefinition: 'LinearBasis class' category: #'Mathematics-Modules-Support'!
LinearBasis class
	instanceVariableNames: ''!

!classDefinition: #GroebnerBasis category: #'Mathematics-Polynomials-Domains'!
SequenceableCollection subclass: #GroebnerBasis
	instanceVariableNames: 'polynomials ordering isMinimal'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Polynomials-Domains'!
!classDefinition: 'GroebnerBasis class' category: #'Mathematics-Polynomials-Domains'!
GroebnerBasis class
	instanceVariableNames: ''!

!classDefinition: #SparseTuple category: #'Mathematics-Kernel-Tuples'!
Dictionary2 subclass: #SparseTuple
	instanceVariableNames: 'zero'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Tuples'!
!classDefinition: 'SparseTuple class' category: #'Mathematics-Kernel-Tuples'!
SparseTuple class
	instanceVariableNames: ''!

!classDefinition: #KeyedSet category: #'Mathematics-Kernel-Support'!
Set subclass: #KeyedSet
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Support'!
!classDefinition: 'KeyedSet class' category: #'Mathematics-Kernel-Support'!
KeyedSet class
	instanceVariableNames: ''!

!classDefinition: #Iterator category: #'Mathematics-Kernel-Support'!
Collection subclass: #Iterator
	instanceVariableNames: 'block'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Support'!
!classDefinition: 'Iterator class' category: #'Mathematics-Kernel-Support'!
Iterator class
	instanceVariableNames: ''!

!classDefinition: #AbstractGraph category: #'Mathematics-Graphs'!
Collection subclass: #AbstractGraph
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Graphs'!
!classDefinition: 'AbstractGraph class' category: #'Mathematics-Graphs'!
AbstractGraph class
	instanceVariableNames: ''!

!classDefinition: #Digraph category: #'Mathematics-Graphs'!
AbstractGraph subclass: #Digraph
	instanceVariableNames: 'nodes nodeCreator type'
	classVariableNames: 'InitializationBlocks'
	poolDictionaries: ''
	category: 'Mathematics-Graphs'!
!classDefinition: 'Digraph class' category: #'Mathematics-Graphs'!
Digraph class
	instanceVariableNames: ''!

!classDefinition: #RootedDigraph category: #'Mathematics-Graphs'!
Digraph subclass: #RootedDigraph
	instanceVariableNames: 'roots'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Graphs'!
!classDefinition: 'RootedDigraph class' category: #'Mathematics-Graphs'!
RootedDigraph class
	instanceVariableNames: ''!

!classDefinition: #Graph category: #'Mathematics-Graphs'!
AbstractGraph subclass: #Graph
	instanceVariableNames: 'digraph'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Graphs'!
!classDefinition: 'Graph class' category: #'Mathematics-Graphs'!
Graph class
	instanceVariableNames: ''!

!classDefinition: #YoungTableau category: #'Mathematics-Combinatorics'!
Collection subclass: #YoungTableau
	instanceVariableNames: 'rows'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Combinatorics'!
!classDefinition: 'YoungTableau class' category: #'Mathematics-Combinatorics'!
YoungTableau class
	instanceVariableNames: ''!

!classDefinition: #CompositeGraphMorph category: #'Mathematics-Graphs-Morphic'!
LayoutMorph subclass: #CompositeGraphMorph
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Graphs-Morphic'!
!classDefinition: 'CompositeGraphMorph class' category: #'Mathematics-Graphs-Morphic'!
CompositeGraphMorph class
	instanceVariableNames: ''!

!classDefinition: #GraphMorph category: #'Mathematics-Graphs-Morphic'!
RectangleLikeMorph subclass: #GraphMorph
	instanceVariableNames: 'graph nodeToMorph edgeToMorph focusNode dimension lastMousePosition components'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Graphs-Morphic'!
!classDefinition: 'GraphMorph class' category: #'Mathematics-Graphs-Morphic'!
GraphMorph class
	instanceVariableNames: ''!

!classDefinition: #SpringGraphMorph category: #'Mathematics-Graphs-Morphic'!
GraphMorph subclass: #SpringGraphMorph
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Graphs-Morphic'!
!classDefinition: 'SpringGraphMorph class' category: #'Mathematics-Graphs-Morphic'!
SpringGraphMorph class
	instanceVariableNames: ''!

!classDefinition: #FunctionPlotMorph category: #'Mathematics-Morphic'!
RectangleLikeMorph subclass: #FunctionPlotMorph
	instanceVariableNames: 'backgroundColor fillColor textColor function xMin xMax yMin yMax evaluationPoints values firstMousePosition lastMousePosition'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Morphic'!
!classDefinition: 'FunctionPlotMorph class' category: #'Mathematics-Morphic'!
FunctionPlotMorph class
	instanceVariableNames: ''!

!classDefinition: #HistogramMorph category: #'Mathematics-Morphic'!
RectangleLikeMorph subclass: #HistogramMorph
	instanceVariableNames: 'backgroundColor textColor tallies extraBinsForClampedValues lowBinCenter highBinCenter'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Morphic'!
!classDefinition: 'HistogramMorph class' category: #'Mathematics-Morphic'!
HistogramMorph class
	instanceVariableNames: ''!

!classDefinition: #MultiplicationTableMorph category: #'Mathematics-Morphic'!
RectangleLikeMorph subclass: #MultiplicationTableMorph
	instanceVariableNames: 'elements colors operation'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Morphic'!
!classDefinition: 'MultiplicationTableMorph class' category: #'Mathematics-Morphic'!
MultiplicationTableMorph class
	instanceVariableNames: ''!

!classDefinition: #ScalarPlotMorph category: #'Mathematics-Morphic'!
RectangleLikeMorph subclass: #ScalarPlotMorph
	instanceVariableNames: 'function palette xMin xMax yMin yMax form'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Morphic'!
!classDefinition: 'ScalarPlotMorph class' category: #'Mathematics-Morphic'!
ScalarPlotMorph class
	instanceVariableNames: ''!

!classDefinition: #ScatterPlotMorph category: #'Mathematics-Morphic'!
RectangleLikeMorph subclass: #ScatterPlotMorph
	instanceVariableNames: 'points transformation max min positionBlock colorBlock sizeBlock lastMousePosition'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Morphic'!
!classDefinition: 'ScatterPlotMorph class' category: #'Mathematics-Morphic'!
ScatterPlotMorph class
	instanceVariableNames: ''!

!classDefinition: #GraphEdgeMorph category: #'Mathematics-Graphs-Morphic'!
Morph subclass: #GraphEdgeMorph
	instanceVariableNames: 'color source target width drawArrowHead label labelMorph multiplicity'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Graphs-Morphic'!
!classDefinition: 'GraphEdgeMorph class' category: #'Mathematics-Graphs-Morphic'!
GraphEdgeMorph class
	instanceVariableNames: ''!

!classDefinition: #SpringEdgeMorph category: #'Mathematics-Graphs-Morphic'!
GraphEdgeMorph subclass: #SpringEdgeMorph
	instanceVariableNames: 'desiredDistance'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Graphs-Morphic'!
!classDefinition: 'SpringEdgeMorph class' category: #'Mathematics-Graphs-Morphic'!
SpringEdgeMorph class
	instanceVariableNames: ''!

!classDefinition: #GraphNodeMorph category: #'Mathematics-Graphs-Morphic'!
Morph subclass: #GraphNodeMorph
	instanceVariableNames: 'node x dx extent color shape label labelMorph'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Graphs-Morphic'!
!classDefinition: 'GraphNodeMorph class' category: #'Mathematics-Graphs-Morphic'!
GraphNodeMorph class
	instanceVariableNames: ''!

!classDefinition: #SpringNodeMorph category: #'Mathematics-Graphs-Morphic'!
GraphNodeMorph subclass: #SpringNodeMorph
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Graphs-Morphic'!
!classDefinition: 'SpringNodeMorph class' category: #'Mathematics-Graphs-Morphic'!
SpringNodeMorph class
	instanceVariableNames: ''!

!classDefinition: #Diagram category: #'Mathematics-Kernel'!
Object subclass: #Diagram
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel'!
!classDefinition: 'Diagram class' category: #'Mathematics-Kernel'!
Diagram class
	instanceVariableNames: ''!

!classDefinition: #SubgroupSeries category: #'Mathematics-Groups'!
Diagram subclass: #SubgroupSeries
	instanceVariableNames: 'subgroups'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Groups'!
!classDefinition: 'SubgroupSeries class' category: #'Mathematics-Groups'!
SubgroupSeries class
	instanceVariableNames: ''!

!classDefinition: #ChainComplex category: #'Mathematics-Homology'!
Diagram subclass: #ChainComplex
	instanceVariableNames: 'arrows'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Homology'!
!classDefinition: 'ChainComplex class' category: #'Mathematics-Homology'!
ChainComplex class
	instanceVariableNames: ''!

!classDefinition: #Domain category: #'Mathematics-Kernel'!
Object subclass: #Domain
	instanceVariableNames: 'properties'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel'!
!classDefinition: 'Domain class' category: #'Mathematics-Kernel'!
Domain class
	instanceVariableNames: ''!

!classDefinition: #AbelianGroup category: #'Mathematics-Kernel-Domains'!
Domain subclass: #AbelianGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Domains'!
!classDefinition: 'AbelianGroup class' category: #'Mathematics-Kernel-Domains'!
AbelianGroup class
	instanceVariableNames: ''!

!classDefinition: #DirectSum category: #'Mathematics-Kernel-Domains'!
AbelianGroup subclass: #DirectSum
	instanceVariableNames: 'components'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Domains'!
!classDefinition: 'DirectSum class' category: #'Mathematics-Kernel-Domains'!
DirectSum class
	instanceVariableNames: ''!

!classDefinition: #Ideal category: #'Mathematics-Rings'!
AbelianGroup subclass: #Ideal
	instanceVariableNames: 'ring generators'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Rings'!
!classDefinition: 'Ideal class' category: #'Mathematics-Rings'!
Ideal class
	instanceVariableNames: ''!

!classDefinition: #IntegerIdeal category: #'Mathematics-Kernel-Domains-Concrete'!
Ideal subclass: #IntegerIdeal
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Domains-Concrete'!
!classDefinition: 'IntegerIdeal class' category: #'Mathematics-Kernel-Domains-Concrete'!
IntegerIdeal class
	instanceVariableNames: ''!

!classDefinition: #PolynomialIdeal category: #'Mathematics-Polynomials-Domains'!
Ideal subclass: #PolynomialIdeal
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Polynomials-Domains'!
!classDefinition: 'PolynomialIdeal class' category: #'Mathematics-Polynomials-Domains'!
PolynomialIdeal class
	instanceVariableNames: ''!

!classDefinition: #MonomialIdeal category: #'Mathematics-Polynomials-Domains'!
PolynomialIdeal subclass: #MonomialIdeal
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Polynomials-Domains'!
!classDefinition: 'MonomialIdeal class' category: #'Mathematics-Polynomials-Domains'!
MonomialIdeal class
	instanceVariableNames: ''!

!classDefinition: #Ring category: #'Mathematics-Rings'!
AbelianGroup subclass: #Ring
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Rings'!
!classDefinition: 'Ring class' category: #'Mathematics-Rings'!
Ring class
	instanceVariableNames: ''!

!classDefinition: #GaussianIntegers category: #'Mathematics-Kernel-Domains-Concrete'!
Ring subclass: #GaussianIntegers
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Domains-Concrete'!
!classDefinition: 'GaussianIntegers class' category: #'Mathematics-Kernel-Domains-Concrete'!
GaussianIntegers class
	instanceVariableNames: ''!

!classDefinition: #Integers category: #'Mathematics-Kernel-Domains-Concrete'!
Ring subclass: #Integers
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Domains-Concrete'!
!classDefinition: 'Integers class' category: #'Mathematics-Kernel-Domains-Concrete'!
Integers class
	instanceVariableNames: ''!

!classDefinition: #PAdicIntegers category: #'Mathematics-Kernel-Domains-Concrete'!
Ring subclass: #PAdicIntegers
	instanceVariableNames: 'p'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Domains-Concrete'!
!classDefinition: 'PAdicIntegers class' category: #'Mathematics-Kernel-Domains-Concrete'!
PAdicIntegers class
	instanceVariableNames: ''!

!classDefinition: #DirectProductRing category: #'Mathematics-Rings'!
Ring subclass: #DirectProductRing
	instanceVariableNames: 'components'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Rings'!
!classDefinition: 'DirectProductRing class' category: #'Mathematics-Rings'!
DirectProductRing class
	instanceVariableNames: ''!

!classDefinition: #FreeAlgebra category: #'Mathematics-Rings'!
Ring subclass: #FreeAlgebra
	instanceVariableNames: 'scalars words'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Rings'!
!classDefinition: 'FreeAlgebra class' category: #'Mathematics-Rings'!
FreeAlgebra class
	instanceVariableNames: ''!

!classDefinition: #GroupRing category: #'Mathematics-Rings'!
Ring subclass: #GroupRing
	instanceVariableNames: 'group scalars'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Rings'!
!classDefinition: 'GroupRing class' category: #'Mathematics-Rings'!
GroupRing class
	instanceVariableNames: ''!

!classDefinition: #QuotientRing category: #'Mathematics-Rings'!
Ring subclass: #QuotientRing
	instanceVariableNames: 'ideal'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Rings'!
!classDefinition: 'QuotientRing class' category: #'Mathematics-Rings'!
QuotientRing class
	instanceVariableNames: ''!

!classDefinition: #ModularIntegers category: #'Mathematics-Kernel-Domains-Concrete'!
QuotientRing subclass: #ModularIntegers
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Domains-Concrete'!
!classDefinition: 'ModularIntegers class' category: #'Mathematics-Kernel-Domains-Concrete'!
ModularIntegers class
	instanceVariableNames: ''!

!classDefinition: #CoordinateRing category: #'Mathematics-Geometry-Algebraic'!
QuotientRing subclass: #CoordinateRing
	instanceVariableNames: 'variety'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Algebraic'!
!classDefinition: 'CoordinateRing class' category: #'Mathematics-Geometry-Algebraic'!
CoordinateRing class
	instanceVariableNames: ''!

!classDefinition: #Field category: #'Mathematics-Fields'!
Ring subclass: #Field
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Fields'!
!classDefinition: 'Field class' category: #'Mathematics-Fields'!
Field class
	instanceVariableNames: ''!

!classDefinition: #ComplexNumbers category: #'Mathematics-Kernel-Domains-Concrete'!
Field subclass: #ComplexNumbers
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Domains-Concrete'!
!classDefinition: 'ComplexNumbers class' category: #'Mathematics-Kernel-Domains-Concrete'!
ComplexNumbers class
	instanceVariableNames: ''!

!classDefinition: #ExtendedComplexNumbers category: #'Mathematics-Kernel-Domains-Concrete'!
Field subclass: #ExtendedComplexNumbers
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Domains-Concrete'!
!classDefinition: 'ExtendedComplexNumbers class' category: #'Mathematics-Kernel-Domains-Concrete'!
ExtendedComplexNumbers class
	instanceVariableNames: ''!

!classDefinition: #PAdicNumbers category: #'Mathematics-Kernel-Domains-Concrete'!
Field subclass: #PAdicNumbers
	instanceVariableNames: 'p'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Domains-Concrete'!
!classDefinition: 'PAdicNumbers class' category: #'Mathematics-Kernel-Domains-Concrete'!
PAdicNumbers class
	instanceVariableNames: ''!

!classDefinition: #Reals category: #'Mathematics-Kernel-Domains-Concrete'!
Field subclass: #Reals
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Domains-Concrete'!
!classDefinition: 'Reals class' category: #'Mathematics-Kernel-Domains-Concrete'!
Reals class
	instanceVariableNames: ''!

!classDefinition: #FractionField category: #'Mathematics-Fields'!
Field subclass: #FractionField
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Fields'!
!classDefinition: 'FractionField class' category: #'Mathematics-Fields'!
FractionField class
	instanceVariableNames: ''!

!classDefinition: #Rationals category: #'Mathematics-Kernel-Domains-Concrete'!
FractionField subclass: #Rationals
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Domains-Concrete'!
!classDefinition: 'Rationals class' category: #'Mathematics-Kernel-Domains-Concrete'!
Rationals class
	instanceVariableNames: ''!

!classDefinition: #RationalFunctions category: #'Mathematics-Polynomials-Domains'!
FractionField subclass: #RationalFunctions
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Polynomials-Domains'!
!classDefinition: 'RationalFunctions class' category: #'Mathematics-Polynomials-Domains'!
RationalFunctions class
	instanceVariableNames: ''!

!classDefinition: #FunctionField category: #'Mathematics-Geometry-Algebraic'!
FractionField subclass: #FunctionField
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Algebraic'!
!classDefinition: 'FunctionField class' category: #'Mathematics-Geometry-Algebraic'!
FunctionField class
	instanceVariableNames: ''!

!classDefinition: #ResidueField category: #'Mathematics-Fields'!
Field subclass: #ResidueField
	instanceVariableNames: 'ideal'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Fields'!
!classDefinition: 'ResidueField class' category: #'Mathematics-Fields'!
ResidueField class
	instanceVariableNames: ''!

!classDefinition: #PrimeField category: #'Mathematics-Fields'!
ResidueField subclass: #PrimeField
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Fields'!
!classDefinition: 'PrimeField class' category: #'Mathematics-Fields'!
PrimeField class
	instanceVariableNames: ''!

!classDefinition: #AlgebraicExtension category: #'Mathematics-Number Fields'!
Field subclass: #AlgebraicExtension
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Number Fields'!
!classDefinition: 'AlgebraicExtension class' category: #'Mathematics-Number Fields'!
AlgebraicExtension class
	instanceVariableNames: ''!

!classDefinition: #NumberField category: #'Mathematics-Number Fields'!
AlgebraicExtension subclass: #NumberField
	instanceVariableNames: 'adjoint'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Number Fields'!
!classDefinition: 'NumberField class' category: #'Mathematics-Number Fields'!
NumberField class
	instanceVariableNames: ''!

!classDefinition: #CyclotomicField category: #'Mathematics-Number Fields'!
NumberField subclass: #CyclotomicField
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Number Fields'!
!classDefinition: 'CyclotomicField class' category: #'Mathematics-Number Fields'!
CyclotomicField class
	instanceVariableNames: ''!

!classDefinition: #QuadraticField category: #'Mathematics-Number Fields'!
NumberField subclass: #QuadraticField
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Number Fields'!
!classDefinition: 'QuadraticField class' category: #'Mathematics-Number Fields'!
QuadraticField class
	instanceVariableNames: ''!

!classDefinition: #AlgebraicNumbers category: #'Mathematics-Number Fields'!
Field subclass: #AlgebraicNumbers
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Number Fields'!
!classDefinition: 'AlgebraicNumbers class' category: #'Mathematics-Number Fields'!
AlgebraicNumbers class
	instanceVariableNames: ''!

!classDefinition: #RealAlgebraicNumbers category: #'Mathematics-Number Fields'!
Field subclass: #RealAlgebraicNumbers
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Number Fields'!
!classDefinition: 'RealAlgebraicNumbers class' category: #'Mathematics-Number Fields'!
RealAlgebraicNumbers class
	instanceVariableNames: ''!

!classDefinition: #PolynomialRing category: #'Mathematics-Polynomials-Domains'!
Ring subclass: #PolynomialRing
	instanceVariableNames: 'scalars rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Polynomials-Domains'!
!classDefinition: 'PolynomialRing class' category: #'Mathematics-Polynomials-Domains'!
PolynomialRing class
	instanceVariableNames: ''!

!classDefinition: #LaurentSeriesRing category: #'Mathematics-Sequences'!
Ring subclass: #LaurentSeriesRing
	instanceVariableNames: 'scalars'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Sequences'!
!classDefinition: 'LaurentSeriesRing class' category: #'Mathematics-Sequences'!
LaurentSeriesRing class
	instanceVariableNames: ''!

!classDefinition: #PowerSeriesRing category: #'Mathematics-Sequences'!
Ring subclass: #PowerSeriesRing
	instanceVariableNames: 'scalars'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Sequences'!
!classDefinition: 'PowerSeriesRing class' category: #'Mathematics-Sequences'!
PowerSeriesRing class
	instanceVariableNames: ''!

!classDefinition: #PuiseuxSeriesRing category: #'Mathematics-Sequences'!
Ring subclass: #PuiseuxSeriesRing
	instanceVariableNames: 'scalars'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Sequences'!
!classDefinition: 'PuiseuxSeriesRing class' category: #'Mathematics-Sequences'!
PuiseuxSeriesRing class
	instanceVariableNames: ''!

!classDefinition: #SymmetricPolynomialRing category: #'Mathematics-ETC'!
Ring subclass: #SymmetricPolynomialRing
	instanceVariableNames: 'polynomials'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-ETC'!
!classDefinition: 'SymmetricPolynomialRing class' category: #'Mathematics-ETC'!
SymmetricPolynomialRing class
	instanceVariableNames: ''!

!classDefinition: #Module category: #'Mathematics-Modules'!
AbelianGroup subclass: #Module
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Modules'!
!classDefinition: 'Module class' category: #'Mathematics-Modules'!
Module class
	instanceVariableNames: ''!

!classDefinition: #FreeModule category: #'Mathematics-Modules'!
Module subclass: #FreeModule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Modules'!
!classDefinition: 'FreeModule class' category: #'Mathematics-Modules'!
FreeModule class
	instanceVariableNames: ''!

!classDefinition: #DirectSumModule category: #'Mathematics-Modules'!
FreeModule subclass: #DirectSumModule
	instanceVariableNames: 'components'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Modules'!
!classDefinition: 'DirectSumModule class' category: #'Mathematics-Modules'!
DirectSumModule class
	instanceVariableNames: ''!

!classDefinition: #FreeAbelianGroup category: #'Mathematics-Modules'!
FreeModule subclass: #FreeAbelianGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Modules'!
!classDefinition: 'FreeAbelianGroup class' category: #'Mathematics-Modules'!
FreeAbelianGroup class
	instanceVariableNames: ''!

!classDefinition: #Lattice category: #'Mathematics-Lattices'!
FreeAbelianGroup subclass: #Lattice
	instanceVariableNames: 'basis'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Lattices'!
!classDefinition: 'Lattice class' category: #'Mathematics-Lattices'!
Lattice class
	instanceVariableNames: ''!

!classDefinition: #LinearMaps category: #'Mathematics-Modules'!
FreeModule subclass: #LinearMaps
	instanceVariableNames: 'domain codomain'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Modules'!
!classDefinition: 'LinearMaps class' category: #'Mathematics-Modules'!
LinearMaps class
	instanceVariableNames: ''!

!classDefinition: #DualModule category: #'Mathematics-Modules'!
LinearMaps subclass: #DualModule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Modules'!
!classDefinition: 'DualModule class' category: #'Mathematics-Modules'!
DualModule class
	instanceVariableNames: ''!

!classDefinition: #MatrixModule category: #'Mathematics-Modules'!
FreeModule subclass: #MatrixModule
	instanceVariableNames: 'scalars numberOfRows numberOfColumns'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Modules'!
!classDefinition: 'MatrixModule class' category: #'Mathematics-Modules'!
MatrixModule class
	instanceVariableNames: ''!

!classDefinition: #QuotientModule category: #'Mathematics-Modules'!
FreeModule subclass: #QuotientModule
	instanceVariableNames: 'subspace'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Modules'!
!classDefinition: 'QuotientModule class' category: #'Mathematics-Modules'!
QuotientModule class
	instanceVariableNames: ''!

!classDefinition: #ScalarModule category: #'Mathematics-Modules'!
FreeModule subclass: #ScalarModule
	instanceVariableNames: 'scalars'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Modules'!
!classDefinition: 'ScalarModule class' category: #'Mathematics-Modules'!
ScalarModule class
	instanceVariableNames: ''!

!classDefinition: #Submodule category: #'Mathematics-Modules'!
FreeModule subclass: #Submodule
	instanceVariableNames: 'basis'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Modules'!
!classDefinition: 'Submodule class' category: #'Mathematics-Modules'!
Submodule class
	instanceVariableNames: ''!

!classDefinition: #TupleModule category: #'Mathematics-Modules'!
FreeModule subclass: #TupleModule
	instanceVariableNames: 'scalars dimension'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Modules'!
!classDefinition: 'TupleModule class' category: #'Mathematics-Modules'!
TupleModule class
	instanceVariableNames: ''!

!classDefinition: #VectorSpace category: #'Mathematics-Modules'!
FreeModule subclass: #VectorSpace
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Modules'!
!classDefinition: 'VectorSpace class' category: #'Mathematics-Modules'!
VectorSpace class
	instanceVariableNames: ''!

!classDefinition: #BilinearForms category: #'Mathematics-Multilinear'!
VectorSpace subclass: #BilinearForms
	instanceVariableNames: 'vectorSpace domain'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Multilinear'!
!classDefinition: 'BilinearForms class' category: #'Mathematics-Multilinear'!
BilinearForms class
	instanceVariableNames: ''!

!classDefinition: #Tensors category: #'Mathematics-Multilinear'!
VectorSpace subclass: #Tensors
	instanceVariableNames: 'type vectorSpace'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Multilinear'!
!classDefinition: 'Tensors class' category: #'Mathematics-Multilinear'!
Tensors class
	instanceVariableNames: ''!

!classDefinition: #HomogeneousPolynomialSpace category: #'Mathematics-Polynomials-Domains'!
VectorSpace subclass: #HomogeneousPolynomialSpace
	instanceVariableNames: 'polynomials degree'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Polynomials-Domains'!
!classDefinition: 'HomogeneousPolynomialSpace class' category: #'Mathematics-Polynomials-Domains'!
HomogeneousPolynomialSpace class
	instanceVariableNames: ''!

!classDefinition: #PolynomialSpace category: #'Mathematics-Polynomials-Domains'!
VectorSpace subclass: #PolynomialSpace
	instanceVariableNames: 'polynomials degree'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Polynomials-Domains'!
!classDefinition: 'PolynomialSpace class' category: #'Mathematics-Polynomials-Domains'!
PolynomialSpace class
	instanceVariableNames: ''!

!classDefinition: #AlgebraicExtensionSpace category: #'Mathematics-Number Fields'!
VectorSpace subclass: #AlgebraicExtensionSpace
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Number Fields'!
!classDefinition: 'AlgebraicExtensionSpace class' category: #'Mathematics-Number Fields'!
AlgebraicExtensionSpace class
	instanceVariableNames: ''!

!classDefinition: #LieAlgebra category: #'Mathematics-Lie'!
VectorSpace subclass: #LieAlgebra
	instanceVariableNames: 'space'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Lie'!
!classDefinition: 'LieAlgebra class' category: #'Mathematics-Lie'!
LieAlgebra class
	instanceVariableNames: ''!

!classDefinition: #LieAlgebraIdeal category: #'Mathematics-Lie'!
LieAlgebra subclass: #LieAlgebraIdeal
	instanceVariableNames: 'subspace'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Lie'!
!classDefinition: 'LieAlgebraIdeal class' category: #'Mathematics-Lie'!
LieAlgebraIdeal class
	instanceVariableNames: ''!

!classDefinition: #TensorProductSpace category: #'Mathematics-Multilinear'!
FreeModule subclass: #TensorProductSpace
	instanceVariableNames: 'left right'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Multilinear'!
!classDefinition: 'TensorProductSpace class' category: #'Mathematics-Multilinear'!
TensorProductSpace class
	instanceVariableNames: ''!

!classDefinition: #SyzygyModule category: #'Mathematics-Polynomials-Domains'!
FreeModule subclass: #SyzygyModule
	instanceVariableNames: 'polynomials'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Polynomials-Domains'!
!classDefinition: 'SyzygyModule class' category: #'Mathematics-Polynomials-Domains'!
SyzygyModule class
	instanceVariableNames: ''!

!classDefinition: #DivisorsGroup category: #'Mathematics-Geometry-Algebraic-Schemes'!
FreeModule subclass: #DivisorsGroup
	instanceVariableNames: 'scheme'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Algebraic-Schemes'!
!classDefinition: 'DivisorsGroup class' category: #'Mathematics-Geometry-Algebraic-Schemes'!
DivisorsGroup class
	instanceVariableNames: ''!

!classDefinition: #ExteriorPower category: #'Mathematics-ETC'!
FreeModule subclass: #ExteriorPower
	instanceVariableNames: 'space degree'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-ETC'!
!classDefinition: 'ExteriorPower class' category: #'Mathematics-ETC'!
ExteriorPower class
	instanceVariableNames: ''!

!classDefinition: #CartesianProduct category: #'Mathematics-Kernel-Domains'!
Domain subclass: #CartesianProduct
	instanceVariableNames: 'components'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Domains'!
!classDefinition: 'CartesianProduct class' category: #'Mathematics-Kernel-Domains'!
CartesianProduct class
	instanceVariableNames: ''!

!classDefinition: #EquivalenceClass category: #'Mathematics-Kernel-Domains'!
Domain subclass: #EquivalenceClass
	instanceVariableNames: 'representative'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Domains'!
!classDefinition: 'EquivalenceClass class' category: #'Mathematics-Kernel-Domains'!
EquivalenceClass class
	instanceVariableNames: ''!

!classDefinition: #EquivalenceRelation category: #'Mathematics-Kernel-Domains'!
Domain subclass: #EquivalenceRelation
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Domains'!
!classDefinition: 'EquivalenceRelation class' category: #'Mathematics-Kernel-Domains'!
EquivalenceRelation class
	instanceVariableNames: ''!

!classDefinition: #FormalSet category: #'Mathematics-Kernel-Domains'!
Domain subclass: #FormalSet
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Domains'!
!classDefinition: 'FormalSet class' category: #'Mathematics-Kernel-Domains'!
FormalSet class
	instanceVariableNames: ''!

!classDefinition: #Magma category: #'Mathematics-Kernel-Domains'!
Domain subclass: #Magma
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Domains'!
!classDefinition: 'Magma class' category: #'Mathematics-Kernel-Domains'!
Magma class
	instanceVariableNames: ''!

!classDefinition: #Quasigroup category: #'Mathematics-Kernel-Domains'!
Magma subclass: #Quasigroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Domains'!
!classDefinition: 'Quasigroup class' category: #'Mathematics-Kernel-Domains'!
Quasigroup class
	instanceVariableNames: ''!

!classDefinition: #Loop category: #'Mathematics-Kernel-Domains'!
Quasigroup subclass: #Loop
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Domains'!
!classDefinition: 'Loop class' category: #'Mathematics-Kernel-Domains'!
Loop class
	instanceVariableNames: ''!

!classDefinition: #Semigroup category: #'Mathematics-Kernel-Domains'!
Magma subclass: #Semigroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Domains'!
!classDefinition: 'Semigroup class' category: #'Mathematics-Kernel-Domains'!
Semigroup class
	instanceVariableNames: ''!

!classDefinition: #Monoid category: #'Mathematics-Kernel-Domains'!
Semigroup subclass: #Monoid
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Domains'!
!classDefinition: 'Monoid class' category: #'Mathematics-Kernel-Domains'!
Monoid class
	instanceVariableNames: ''!

!classDefinition: #FreeMonoid category: #'Mathematics-Kernel-Domains-Concrete'!
Monoid subclass: #FreeMonoid
	instanceVariableNames: 'symbols'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Domains-Concrete'!
!classDefinition: 'FreeMonoid class' category: #'Mathematics-Kernel-Domains-Concrete'!
FreeMonoid class
	instanceVariableNames: ''!

!classDefinition: #Group category: #'Mathematics-Groups'!
Monoid subclass: #Group
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Groups'!
!classDefinition: 'Group class' category: #'Mathematics-Groups'!
Group class
	instanceVariableNames: ''!

!classDefinition: #DirectProductGroup category: #'Mathematics-Groups'!
Group subclass: #DirectProductGroup
	instanceVariableNames: 'components'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Groups'!
!classDefinition: 'DirectProductGroup class' category: #'Mathematics-Groups'!
DirectProductGroup class
	instanceVariableNames: ''!

!classDefinition: #FreeGroup category: #'Mathematics-Groups'!
Group subclass: #FreeGroup
	instanceVariableNames: 'symbols'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Groups'!
!classDefinition: 'FreeGroup class' category: #'Mathematics-Groups'!
FreeGroup class
	instanceVariableNames: ''!

!classDefinition: #QuotientGroup category: #'Mathematics-Groups'!
Group subclass: #QuotientGroup
	instanceVariableNames: 'base subgroup'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Groups'!
!classDefinition: 'QuotientGroup class' category: #'Mathematics-Groups'!
QuotientGroup class
	instanceVariableNames: ''!

!classDefinition: #SemidirectProductGroup category: #'Mathematics-Groups'!
Group subclass: #SemidirectProductGroup
	instanceVariableNames: 'left right action'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Groups'!
!classDefinition: 'SemidirectProductGroup class' category: #'Mathematics-Groups'!
SemidirectProductGroup class
	instanceVariableNames: ''!

!classDefinition: #PermutationGroup category: #'Mathematics-Groups-Permutations'!
Group subclass: #PermutationGroup
	instanceVariableNames: 'space'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Groups-Permutations'!
!classDefinition: 'PermutationGroup class' category: #'Mathematics-Groups-Permutations'!
PermutationGroup class
	instanceVariableNames: ''!

!classDefinition: #AlternatingGroup category: #'Mathematics-Groups-Permutations'!
PermutationGroup subclass: #AlternatingGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Groups-Permutations'!
!classDefinition: 'AlternatingGroup class' category: #'Mathematics-Groups-Permutations'!
AlternatingGroup class
	instanceVariableNames: ''!

!classDefinition: #SymmetricGroup category: #'Mathematics-Groups-Permutations'!
PermutationGroup subclass: #SymmetricGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Groups-Permutations'!
!classDefinition: 'SymmetricGroup class' category: #'Mathematics-Groups-Permutations'!
SymmetricGroup class
	instanceVariableNames: ''!

!classDefinition: #LinearGroup category: #'Mathematics-Groups-Linear'!
Group subclass: #LinearGroup
	instanceVariableNames: 'space'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Groups-Linear'!
!classDefinition: 'LinearGroup class' category: #'Mathematics-Groups-Linear'!
LinearGroup class
	instanceVariableNames: ''!

!classDefinition: #GeneralLinearGroup category: #'Mathematics-Groups-Linear'!
LinearGroup subclass: #GeneralLinearGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Groups-Linear'!
!classDefinition: 'GeneralLinearGroup class' category: #'Mathematics-Groups-Linear'!
GeneralLinearGroup class
	instanceVariableNames: ''!

!classDefinition: #OrthogonalGroup category: #'Mathematics-Groups-Linear'!
LinearGroup subclass: #OrthogonalGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Groups-Linear'!
!classDefinition: 'OrthogonalGroup class' category: #'Mathematics-Groups-Linear'!
OrthogonalGroup class
	instanceVariableNames: ''!

!classDefinition: #ScalarGroup category: #'Mathematics-Groups-Linear'!
LinearGroup subclass: #ScalarGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Groups-Linear'!
!classDefinition: 'ScalarGroup class' category: #'Mathematics-Groups-Linear'!
ScalarGroup class
	instanceVariableNames: ''!

!classDefinition: #SpecialLinearGroup category: #'Mathematics-Groups-Linear'!
LinearGroup subclass: #SpecialLinearGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Groups-Linear'!
!classDefinition: 'SpecialLinearGroup class' category: #'Mathematics-Groups-Linear'!
SpecialLinearGroup class
	instanceVariableNames: ''!

!classDefinition: #SpecialOrthogonalGroup category: #'Mathematics-Groups-Linear'!
LinearGroup subclass: #SpecialOrthogonalGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Groups-Linear'!
!classDefinition: 'SpecialOrthogonalGroup class' category: #'Mathematics-Groups-Linear'!
SpecialOrthogonalGroup class
	instanceVariableNames: ''!

!classDefinition: #SpecialScalarGroup category: #'Mathematics-Groups-Linear'!
LinearGroup subclass: #SpecialScalarGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Groups-Linear'!
!classDefinition: 'SpecialScalarGroup class' category: #'Mathematics-Groups-Linear'!
SpecialScalarGroup class
	instanceVariableNames: ''!

!classDefinition: #MatrixGroup category: #'Mathematics-Groups-Linear'!
Group subclass: #MatrixGroup
	instanceVariableNames: 'space matrices'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Groups-Linear'!
!classDefinition: 'MatrixGroup class' category: #'Mathematics-Groups-Linear'!
MatrixGroup class
	instanceVariableNames: ''!

!classDefinition: #GeneralLinearMatrixGroup category: #'Mathematics-Groups-Linear'!
MatrixGroup subclass: #GeneralLinearMatrixGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Groups-Linear'!
!classDefinition: 'GeneralLinearMatrixGroup class' category: #'Mathematics-Groups-Linear'!
GeneralLinearMatrixGroup class
	instanceVariableNames: ''!

!classDefinition: #OrthogonalMatrixGroup category: #'Mathematics-Groups-Linear'!
MatrixGroup subclass: #OrthogonalMatrixGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Groups-Linear'!
!classDefinition: 'OrthogonalMatrixGroup class' category: #'Mathematics-Groups-Linear'!
OrthogonalMatrixGroup class
	instanceVariableNames: ''!

!classDefinition: #ScalarMatrixGroup category: #'Mathematics-Groups-Linear'!
MatrixGroup subclass: #ScalarMatrixGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Groups-Linear'!
!classDefinition: 'ScalarMatrixGroup class' category: #'Mathematics-Groups-Linear'!
ScalarMatrixGroup class
	instanceVariableNames: ''!

!classDefinition: #SpecialLinearMatrixGroup category: #'Mathematics-Groups-Linear'!
MatrixGroup subclass: #SpecialLinearMatrixGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Groups-Linear'!
!classDefinition: 'SpecialLinearMatrixGroup class' category: #'Mathematics-Groups-Linear'!
SpecialLinearMatrixGroup class
	instanceVariableNames: ''!

!classDefinition: #SpecialOrthogonalMatrixGroup category: #'Mathematics-Groups-Linear'!
MatrixGroup subclass: #SpecialOrthogonalMatrixGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Groups-Linear'!
!classDefinition: 'SpecialOrthogonalMatrixGroup class' category: #'Mathematics-Groups-Linear'!
SpecialOrthogonalMatrixGroup class
	instanceVariableNames: ''!

!classDefinition: #SpecialScalarMatrixGroup category: #'Mathematics-Groups-Linear'!
MatrixGroup subclass: #SpecialScalarMatrixGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Groups-Linear'!
!classDefinition: 'SpecialScalarMatrixGroup class' category: #'Mathematics-Groups-Linear'!
SpecialScalarMatrixGroup class
	instanceVariableNames: ''!

!classDefinition: #AffineGroup category: #'Mathematics-Groups-Affine'!
Group subclass: #AffineGroup
	instanceVariableNames: 'space'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Groups-Affine'!
!classDefinition: 'AffineGroup class' category: #'Mathematics-Groups-Affine'!
AffineGroup class
	instanceVariableNames: ''!

!classDefinition: #EuclideanGroup category: #'Mathematics-Groups-Affine'!
AffineGroup subclass: #EuclideanGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Groups-Affine'!
!classDefinition: 'EuclideanGroup class' category: #'Mathematics-Groups-Affine'!
EuclideanGroup class
	instanceVariableNames: ''!

!classDefinition: #GeneralAffineGroup category: #'Mathematics-Groups-Affine'!
AffineGroup subclass: #GeneralAffineGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Groups-Affine'!
!classDefinition: 'GeneralAffineGroup class' category: #'Mathematics-Groups-Affine'!
GeneralAffineGroup class
	instanceVariableNames: ''!

!classDefinition: #SpecialAffineGroup category: #'Mathematics-Groups-Affine'!
AffineGroup subclass: #SpecialAffineGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Groups-Affine'!
!classDefinition: 'SpecialAffineGroup class' category: #'Mathematics-Groups-Affine'!
SpecialAffineGroup class
	instanceVariableNames: ''!

!classDefinition: #SpecialEuclideanGroup category: #'Mathematics-Groups-Affine'!
AffineGroup subclass: #SpecialEuclideanGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Groups-Affine'!
!classDefinition: 'SpecialEuclideanGroup class' category: #'Mathematics-Groups-Affine'!
SpecialEuclideanGroup class
	instanceVariableNames: ''!

!classDefinition: #ProjectiveGroup category: #'Mathematics-Groups-Projective'!
Group subclass: #ProjectiveGroup
	instanceVariableNames: 'space'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Groups-Projective'!
!classDefinition: 'ProjectiveGroup class' category: #'Mathematics-Groups-Projective'!
ProjectiveGroup class
	instanceVariableNames: ''!

!classDefinition: #ProjectiveGeneralLinearGroup category: #'Mathematics-Groups-Projective'!
ProjectiveGroup subclass: #ProjectiveGeneralLinearGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Groups-Projective'!
!classDefinition: 'ProjectiveGeneralLinearGroup class' category: #'Mathematics-Groups-Projective'!
ProjectiveGeneralLinearGroup class
	instanceVariableNames: ''!

!classDefinition: #ProjectiveSpecialLinearGroup category: #'Mathematics-Groups-Projective'!
ProjectiveGroup subclass: #ProjectiveSpecialLinearGroup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Groups-Projective'!
!classDefinition: 'ProjectiveSpecialLinearGroup class' category: #'Mathematics-Groups-Projective'!
ProjectiveSpecialLinearGroup class
	instanceVariableNames: ''!

!classDefinition: #UnitsGroup category: #'Mathematics-Rings'!
Group subclass: #UnitsGroup
	instanceVariableNames: 'ring'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Rings'!
!classDefinition: 'UnitsGroup class' category: #'Mathematics-Rings'!
UnitsGroup class
	instanceVariableNames: ''!

!classDefinition: #CoxeterGroup category: #'Mathematics-Lie'!
Group subclass: #CoxeterGroup
	instanceVariableNames: 'diagram'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Lie'!
!classDefinition: 'CoxeterGroup class' category: #'Mathematics-Lie'!
CoxeterGroup class
	instanceVariableNames: ''!

!classDefinition: #Monomials category: #'Mathematics-Monomials'!
Monoid subclass: #Monomials
	instanceVariableNames: 'rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Monomials'!
!classDefinition: 'Monomials class' category: #'Mathematics-Monomials'!
Monomials class
	instanceVariableNames: ''!

!classDefinition: #Morphisms category: #'Mathematics-Kernel-Domains'!
Domain subclass: #Morphisms
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Domains'!
!classDefinition: 'Morphisms class' category: #'Mathematics-Kernel-Domains'!
Morphisms class
	instanceVariableNames: ''!

!classDefinition: #QuotientSet category: #'Mathematics-Kernel-Domains'!
Domain subclass: #QuotientSet
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Domains'!
!classDefinition: 'QuotientSet class' category: #'Mathematics-Kernel-Domains'!
QuotientSet class
	instanceVariableNames: ''!

!classDefinition: #Category category: #'Mathematics-Kernel-Categories'!
Domain subclass: #Category
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Categories'!
!classDefinition: 'Category class' category: #'Mathematics-Kernel-Categories'!
Category class
	instanceVariableNames: ''!

!classDefinition: #AbelianGroups category: #'Mathematics-Kernel-Categories'!
Category subclass: #AbelianGroups
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Categories'!
!classDefinition: 'AbelianGroups class' category: #'Mathematics-Kernel-Categories'!
AbelianGroups class
	instanceVariableNames: ''!

!classDefinition: #Modules category: #'Mathematics-Kernel-Categories'!
AbelianGroups subclass: #Modules
	instanceVariableNames: 'scalars'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Categories'!
!classDefinition: 'Modules class' category: #'Mathematics-Kernel-Categories'!
Modules class
	instanceVariableNames: ''!

!classDefinition: #ComplexBox category: #'Mathematics-Kernel-Domains-Concrete'!
Domain subclass: #ComplexBox
	instanceVariableNames: 'real imaginary'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Domains-Concrete'!
!classDefinition: 'ComplexBox class' category: #'Mathematics-Kernel-Domains-Concrete'!
ComplexBox class
	instanceVariableNames: ''!

!classDefinition: #ComplexDisk category: #'Mathematics-Kernel-Domains-Concrete'!
Domain subclass: #ComplexDisk
	instanceVariableNames: 'center radius'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Domains-Concrete'!
!classDefinition: 'ComplexDisk class' category: #'Mathematics-Kernel-Domains-Concrete'!
ComplexDisk class
	instanceVariableNames: ''!

!classDefinition: #Naturals category: #'Mathematics-Kernel-Domains-Concrete'!
Domain subclass: #Naturals
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Domains-Concrete'!
!classDefinition: 'Naturals class' category: #'Mathematics-Kernel-Domains-Concrete'!
Naturals class
	instanceVariableNames: ''!

!classDefinition: #RealBox category: #'Mathematics-Kernel-Domains-Concrete'!
Domain subclass: #RealBox
	instanceVariableNames: 'components'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Domains-Concrete'!
!classDefinition: 'RealBox class' category: #'Mathematics-Kernel-Domains-Concrete'!
RealBox class
	instanceVariableNames: ''!

!classDefinition: #RealInterval category: #'Mathematics-Kernel-Domains-Concrete'!
Domain subclass: #RealInterval
	instanceVariableNames: 'left right rightOpen leftOpen'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Domains-Concrete'!
!classDefinition: 'RealInterval class' category: #'Mathematics-Kernel-Domains-Concrete'!
RealInterval class
	instanceVariableNames: ''!

!classDefinition: #SemialgebraicInterval category: #'Mathematics-Geometry-Semialgebraic'!
RealInterval subclass: #SemialgebraicInterval
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Semialgebraic'!
!classDefinition: 'SemialgebraicInterval class' category: #'Mathematics-Geometry-Semialgebraic'!
SemialgebraicInterval class
	instanceVariableNames: ''!

!classDefinition: #RightCoset category: #'Mathematics-Groups'!
Domain subclass: #RightCoset
	instanceVariableNames: 'subgroup representative'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Groups'!
!classDefinition: 'RightCoset class' category: #'Mathematics-Groups'!
RightCoset class
	instanceVariableNames: ''!

!classDefinition: #Coset category: #'Mathematics-Groups'!
RightCoset subclass: #Coset
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Groups'!
!classDefinition: 'Coset class' category: #'Mathematics-Groups'!
Coset class
	instanceVariableNames: ''!

!classDefinition: #Grassmannian category: #'Mathematics-Modules'!
Domain subclass: #Grassmannian
	instanceVariableNames: 'space rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Modules'!
!classDefinition: 'Grassmannian class' category: #'Mathematics-Modules'!
Grassmannian class
	instanceVariableNames: ''!

!classDefinition: #LinearCode category: #'Mathematics-Codes'!
Domain subclass: #LinearCode
	instanceVariableNames: 'subspace'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Codes'!
!classDefinition: 'LinearCode class' category: #'Mathematics-Codes'!
LinearCode class
	instanceVariableNames: ''!

!classDefinition: #CyclicCode2 category: #'Mathematics-Codes'!
LinearCode subclass: #CyclicCode2
	instanceVariableNames: 'generator'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Codes'!
!classDefinition: 'CyclicCode2 class' category: #'Mathematics-Codes'!
CyclicCode2 class
	instanceVariableNames: ''!

!classDefinition: #PolynomialCode category: #'Mathematics-Codes'!
LinearCode subclass: #PolynomialCode
	instanceVariableNames: 'generator'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Codes'!
!classDefinition: 'PolynomialCode class' category: #'Mathematics-Codes'!
PolynomialCode class
	instanceVariableNames: ''!

!classDefinition: #CyclicCode category: #'Mathematics-Codes'!
PolynomialCode subclass: #CyclicCode
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Codes'!
!classDefinition: 'CyclicCode class' category: #'Mathematics-Codes'!
CyclicCode class
	instanceVariableNames: ''!

!classDefinition: #AffineLinearSpace category: #'Mathematics-Geometry-Affine'!
Domain subclass: #AffineLinearSpace
	instanceVariableNames: 'direction representative'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Affine'!
!classDefinition: 'AffineLinearSpace class' category: #'Mathematics-Geometry-Affine'!
AffineLinearSpace class
	instanceVariableNames: ''!

!classDefinition: #AffineMaps category: #'Mathematics-Geometry-Affine'!
AffineLinearSpace subclass: #AffineMaps
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Affine'!
!classDefinition: 'AffineMaps class' category: #'Mathematics-Geometry-Affine'!
AffineMaps class
	instanceVariableNames: ''!

!classDefinition: #ProjectiveLinearSpace category: #'Mathematics-Geometry-Projective'!
Domain subclass: #ProjectiveLinearSpace
	instanceVariableNames: 'vectorSpace'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Projective'!
!classDefinition: 'ProjectiveLinearSpace class' category: #'Mathematics-Geometry-Projective'!
ProjectiveLinearSpace class
	instanceVariableNames: ''!

!classDefinition: #ProjectiveMaps category: #'Mathematics-Geometry-Projective'!
ProjectiveLinearSpace subclass: #ProjectiveMaps
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Projective'!
!classDefinition: 'ProjectiveMaps class' category: #'Mathematics-Geometry-Projective'!
ProjectiveMaps class
	instanceVariableNames: ''!

!classDefinition: #AlgebraicSet category: #'Mathematics-Geometry-Algebraic'!
Domain subclass: #AlgebraicSet
	instanceVariableNames: 'space ideal'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Algebraic'!
!classDefinition: 'AlgebraicSet class' category: #'Mathematics-Geometry-Algebraic'!
AlgebraicSet class
	instanceVariableNames: ''!

!classDefinition: #Quadric category: #'Mathematics-Lattices'!
AlgebraicSet subclass: #Quadric
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Lattices'!
!classDefinition: 'Quadric class' category: #'Mathematics-Lattices'!
Quadric class
	instanceVariableNames: ''!

!classDefinition: #Scheme category: #'Mathematics-Geometry-Algebraic-Schemes'!
Domain subclass: #Scheme
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Algebraic-Schemes'!
!classDefinition: 'Scheme class' category: #'Mathematics-Geometry-Algebraic-Schemes'!
Scheme class
	instanceVariableNames: ''!

!classDefinition: #AffineScheme category: #'Mathematics-Geometry-Algebraic-Schemes'!
Scheme subclass: #AffineScheme
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Algebraic-Schemes'!
!classDefinition: 'AffineScheme class' category: #'Mathematics-Geometry-Algebraic-Schemes'!
AffineScheme class
	instanceVariableNames: ''!

!classDefinition: #AffinePlaneCurve category: #'Mathematics-Geometry-Algebraic-Schemes'!
AffineScheme subclass: #AffinePlaneCurve
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Algebraic-Schemes'!
!classDefinition: 'AffinePlaneCurve class' category: #'Mathematics-Geometry-Algebraic-Schemes'!
AffinePlaneCurve class
	instanceVariableNames: ''!

!classDefinition: #AffineSpace category: #'Mathematics-Geometry-Algebraic-Schemes'!
AffineScheme subclass: #AffineSpace
	instanceVariableNames: 'coordinateRing'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Algebraic-Schemes'!
!classDefinition: 'AffineSpace class' category: #'Mathematics-Geometry-Algebraic-Schemes'!
AffineSpace class
	instanceVariableNames: ''!

!classDefinition: #Spectrum category: #'Mathematics-Geometry-Algebraic-Schemes'!
AffineScheme subclass: #Spectrum
	instanceVariableNames: 'coordinateRing'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Algebraic-Schemes'!
!classDefinition: 'Spectrum class' category: #'Mathematics-Geometry-Algebraic-Schemes'!
Spectrum class
	instanceVariableNames: ''!

!classDefinition: #ProjectiveScheme category: #'Mathematics-Geometry-Algebraic-Schemes'!
Scheme subclass: #ProjectiveScheme
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Algebraic-Schemes'!
!classDefinition: 'ProjectiveScheme class' category: #'Mathematics-Geometry-Algebraic-Schemes'!
ProjectiveScheme class
	instanceVariableNames: ''!

!classDefinition: #ProjectiveSpace category: #'Mathematics-Geometry-Algebraic-Schemes'!
ProjectiveScheme subclass: #ProjectiveSpace
	instanceVariableNames: 'coordinateRing'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Algebraic-Schemes'!
!classDefinition: 'ProjectiveSpace class' category: #'Mathematics-Geometry-Algebraic-Schemes'!
ProjectiveSpace class
	instanceVariableNames: ''!

!classDefinition: #EllipticCurve category: #'Mathematics-ETC'!
ProjectiveScheme subclass: #EllipticCurve
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-ETC'!
!classDefinition: 'EllipticCurve class' category: #'Mathematics-ETC'!
EllipticCurve class
	instanceVariableNames: ''!

!classDefinition: #SemialgebraicSet category: #'Mathematics-Geometry-Semialgebraic'!
Domain subclass: #SemialgebraicSet
	instanceVariableNames: 'cells'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Semialgebraic'!
!classDefinition: 'SemialgebraicSet class' category: #'Mathematics-Geometry-Semialgebraic'!
SemialgebraicSet class
	instanceVariableNames: ''!

!classDefinition: #Cone category: #'Mathematics-Geometry-Polytopes'!
Domain subclass: #Cone
	instanceVariableNames: 'vectors'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Polytopes'!
!classDefinition: 'Cone class' category: #'Mathematics-Geometry-Polytopes'!
Cone class
	instanceVariableNames: ''!

!classDefinition: #ConicalHull category: #'Mathematics-Geometry-Polytopes'!
Domain subclass: #ConicalHull
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Polytopes'!
!classDefinition: 'ConicalHull class' category: #'Mathematics-Geometry-Polytopes'!
ConicalHull class
	instanceVariableNames: ''!

!classDefinition: #ConvexHull category: #'Mathematics-Geometry-Polytopes'!
Domain subclass: #ConvexHull
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Polytopes'!
!classDefinition: 'ConvexHull class' category: #'Mathematics-Geometry-Polytopes'!
ConvexHull class
	instanceVariableNames: ''!

!classDefinition: #Halfspace category: #'Mathematics-Geometry-Polytopes'!
Domain subclass: #Halfspace
	instanceVariableNames: 'inequality'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Polytopes'!
!classDefinition: 'Halfspace class' category: #'Mathematics-Geometry-Polytopes'!
Halfspace class
	instanceVariableNames: ''!

!classDefinition: #Polyhedron category: #'Mathematics-Geometry-Polytopes'!
Domain subclass: #Polyhedron
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Polytopes'!
!classDefinition: 'Polyhedron class' category: #'Mathematics-Geometry-Polytopes'!
Polyhedron class
	instanceVariableNames: ''!

!classDefinition: #Polytope category: #'Mathematics-Geometry-Polytopes'!
Polyhedron subclass: #Polytope
	instanceVariableNames: 'space points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Polytopes'!
!classDefinition: 'Polytope class' category: #'Mathematics-Geometry-Polytopes'!
Polytope class
	instanceVariableNames: ''!

!classDefinition: #Polygon category: #'Mathematics-Geometry-Polytopes'!
Polytope subclass: #Polygon
	instanceVariableNames: 'vertices'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Polytopes'!
!classDefinition: 'Polygon class' category: #'Mathematics-Geometry-Polytopes'!
Polygon class
	instanceVariableNames: ''!

!classDefinition: #LineSegment category: #'Mathematics-Geometry-Polytopes'!
Polygon subclass: #LineSegment
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Polytopes'!
!classDefinition: 'LineSegment class' category: #'Mathematics-Geometry-Polytopes'!
LineSegment class
	instanceVariableNames: ''!

!classDefinition: #DirectedLineSegment category: #'Mathematics-Geometry-Polytopes'!
LineSegment subclass: #DirectedLineSegment
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Polytopes'!
!classDefinition: 'DirectedLineSegment class' category: #'Mathematics-Geometry-Polytopes'!
DirectedLineSegment class
	instanceVariableNames: ''!

!classDefinition: #Quadrangle category: #'Mathematics-Geometry-Polytopes'!
Polygon subclass: #Quadrangle
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Polytopes'!
!classDefinition: 'Quadrangle class' category: #'Mathematics-Geometry-Polytopes'!
Quadrangle class
	instanceVariableNames: ''!

!classDefinition: #Triangle category: #'Mathematics-Geometry-Polytopes'!
Polygon subclass: #Triangle
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Polytopes'!
!classDefinition: 'Triangle class' category: #'Mathematics-Geometry-Polytopes'!
Triangle class
	instanceVariableNames: ''!

!classDefinition: #SemistandardTableaux category: #'Mathematics-Combinatorics'!
Domain subclass: #SemistandardTableaux
	instanceVariableNames: 'shape alphabet'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Combinatorics'!
!classDefinition: 'SemistandardTableaux class' category: #'Mathematics-Combinatorics'!
SemistandardTableaux class
	instanceVariableNames: ''!

!classDefinition: #StandardTableaux category: #'Mathematics-Combinatorics'!
SemistandardTableaux subclass: #StandardTableaux
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Combinatorics'!
!classDefinition: 'StandardTableaux class' category: #'Mathematics-Combinatorics'!
StandardTableaux class
	instanceVariableNames: ''!

!classDefinition: #SimplicialComplex category: #'Mathematics-Homology'!
Domain subclass: #SimplicialComplex
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Homology'!
!classDefinition: 'SimplicialComplex class' category: #'Mathematics-Homology'!
SimplicialComplex class
	instanceVariableNames: ''!

!classDefinition: #CoxeterSystem category: #'Mathematics-Lie'!
Domain subclass: #CoxeterSystem
	instanceVariableNames: 'group generators matrix diagram'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Lie'!
!classDefinition: 'CoxeterSystem class' category: #'Mathematics-Lie'!
CoxeterSystem class
	instanceVariableNames: ''!

!classDefinition: #MetricSpace category: #'Mathematics-ETC'!
Domain subclass: #MetricSpace
	instanceVariableNames: 'elements distance'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-ETC'!
!classDefinition: 'MetricSpace class' category: #'Mathematics-ETC'!
MetricSpace class
	instanceVariableNames: ''!

!classDefinition: #Presheaf category: #'Mathematics-Topology'!
Domain subclass: #Presheaf
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Topology'!
!classDefinition: 'Presheaf class' category: #'Mathematics-Topology'!
Presheaf class
	instanceVariableNames: ''!

!classDefinition: #TopologicalSpace category: #'Mathematics-Topology'!
Domain subclass: #TopologicalSpace
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Topology'!
!classDefinition: 'TopologicalSpace class' category: #'Mathematics-Topology'!
TopologicalSpace class
	instanceVariableNames: ''!

!classDefinition: #Morphism category: #'Mathematics-Kernel'!
Object subclass: #Morphism
	instanceVariableNames: 'properties'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel'!
!classDefinition: 'Morphism class' category: #'Mathematics-Kernel'!
Morphism class
	instanceVariableNames: ''!

!classDefinition: #Function category: #'Mathematics-Kernel'!
Morphism subclass: #Function
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel'!
!classDefinition: 'Function class' category: #'Mathematics-Kernel'!
Function class
	instanceVariableNames: ''!

!classDefinition: #AbelianGroupHomomorphism category: #'Mathematics-Kernel-Support'!
Function subclass: #AbelianGroupHomomorphism
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Support'!
!classDefinition: 'AbelianGroupHomomorphism class' category: #'Mathematics-Kernel-Support'!
AbelianGroupHomomorphism class
	instanceVariableNames: ''!

!classDefinition: #RingHomomorphism category: #'Mathematics-Rings'!
AbelianGroupHomomorphism subclass: #RingHomomorphism
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Rings'!
!classDefinition: 'RingHomomorphism class' category: #'Mathematics-Rings'!
RingHomomorphism class
	instanceVariableNames: ''!

!classDefinition: #FieldHomomorphism category: #'Mathematics-Fields'!
RingHomomorphism subclass: #FieldHomomorphism
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Fields'!
!classDefinition: 'FieldHomomorphism class' category: #'Mathematics-Fields'!
FieldHomomorphism class
	instanceVariableNames: ''!

!classDefinition: #LinearMap category: #'Mathematics-Modules-Support'!
AbelianGroupHomomorphism subclass: #LinearMap
	instanceVariableNames: 'domainBasis codomainBasis matrix'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Modules-Support'!
!classDefinition: 'LinearMap class' category: #'Mathematics-Modules-Support'!
LinearMap class
	instanceVariableNames: ''!

!classDefinition: #LinearForm category: #'Mathematics-Modules-Support'!
LinearMap subclass: #LinearForm
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Modules-Support'!
!classDefinition: 'LinearForm class' category: #'Mathematics-Modules-Support'!
LinearForm class
	instanceVariableNames: ''!

!classDefinition: #GroupAction category: #'Mathematics-Groups'!
Function subclass: #GroupAction
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Groups'!
!classDefinition: 'GroupAction class' category: #'Mathematics-Groups'!
GroupAction class
	instanceVariableNames: ''!

!classDefinition: #GroupHomomorphism category: #'Mathematics-Groups'!
Function subclass: #GroupHomomorphism
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Groups'!
!classDefinition: 'GroupHomomorphism class' category: #'Mathematics-Groups'!
GroupHomomorphism class
	instanceVariableNames: ''!

!classDefinition: #Conjugation category: #'Mathematics-Groups'!
GroupHomomorphism subclass: #Conjugation
	instanceVariableNames: 'element elementInverse'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Groups'!
!classDefinition: 'Conjugation class' category: #'Mathematics-Groups'!
Conjugation class
	instanceVariableNames: ''!

!classDefinition: #GroupRepresentation category: #'Mathematics-Groups'!
GroupHomomorphism subclass: #GroupRepresentation
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Groups'!
!classDefinition: 'GroupRepresentation class' category: #'Mathematics-Groups'!
GroupRepresentation class
	instanceVariableNames: ''!

!classDefinition: #Permutation category: #'Mathematics-Groups-Permutations'!
Function subclass: #Permutation
	instanceVariableNames: 'map'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Groups-Permutations'!
!classDefinition: 'Permutation class' category: #'Mathematics-Groups-Permutations'!
Permutation class
	instanceVariableNames: ''!

!classDefinition: #PermutationCycle category: #'Mathematics-Groups-Permutations'!
Permutation subclass: #PermutationCycle
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Groups-Permutations'!
!classDefinition: 'PermutationCycle class' category: #'Mathematics-Groups-Permutations'!
PermutationCycle class
	instanceVariableNames: ''!

!classDefinition: #StandardPermutation category: #'Mathematics-Groups-Permutations'!
Permutation subclass: #StandardPermutation
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Groups-Permutations'!
!classDefinition: 'StandardPermutation class' category: #'Mathematics-Groups-Permutations'!
StandardPermutation class
	instanceVariableNames: ''!

!classDefinition: #SemilinearMap category: #'Mathematics-Modules-Support'!
Function subclass: #SemilinearMap
	instanceVariableNames: 'domainBasis codomainBasis matrix automorphism'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Modules-Support'!
!classDefinition: 'SemilinearMap class' category: #'Mathematics-Modules-Support'!
SemilinearMap class
	instanceVariableNames: ''!

!classDefinition: #SesquilinearForm category: #'Mathematics-Modules-Support'!
Function subclass: #SesquilinearForm
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Modules-Support'!
!classDefinition: 'SesquilinearForm class' category: #'Mathematics-Modules-Support'!
SesquilinearForm class
	instanceVariableNames: ''!

!classDefinition: #BilinearForm category: #'Mathematics-Multilinear'!
Function subclass: #BilinearForm
	instanceVariableNames: 'basis matrix'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Multilinear'!
!classDefinition: 'BilinearForm class' category: #'Mathematics-Multilinear'!
BilinearForm class
	instanceVariableNames: ''!

!classDefinition: #Sequence category: #'Mathematics-Sequences'!
Function subclass: #Sequence
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Sequences'!
!classDefinition: 'Sequence class' category: #'Mathematics-Sequences'!
Sequence class
	instanceVariableNames: ''!

!classDefinition: #LinearRecursiveSequence category: #'Mathematics-Sequences'!
Sequence subclass: #LinearRecursiveSequence
	instanceVariableNames: 'coefficients initialValues'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Sequences'!
!classDefinition: 'LinearRecursiveSequence class' category: #'Mathematics-Sequences'!
LinearRecursiveSequence class
	instanceVariableNames: ''!

!classDefinition: #QuadraticForm category: #'Mathematics-Lattices'!
Function subclass: #QuadraticForm
	instanceVariableNames: 'basis matrix'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Lattices'!
!classDefinition: 'QuadraticForm class' category: #'Mathematics-Lattices'!
QuadraticForm class
	instanceVariableNames: ''!

!classDefinition: #AffineMap category: #'Mathematics-Geometry-Affine'!
Function subclass: #AffineMap
	instanceVariableNames: 'linearPart translation'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Affine'!
!classDefinition: 'AffineMap class' category: #'Mathematics-Geometry-Affine'!
AffineMap class
	instanceVariableNames: ''!

!classDefinition: #ProjectiveMap category: #'Mathematics-Geometry-Projective'!
Function subclass: #ProjectiveMap
	instanceVariableNames: 'linearMap'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Projective'!
!classDefinition: 'ProjectiveMap class' category: #'Mathematics-Geometry-Projective'!
ProjectiveMap class
	instanceVariableNames: ''!

!classDefinition: #MoebiusTransformation category: #'Mathematics-Geometry-Projective'!
ProjectiveMap subclass: #MoebiusTransformation
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Projective'!
!classDefinition: 'MoebiusTransformation class' category: #'Mathematics-Geometry-Projective'!
MoebiusTransformation class
	instanceVariableNames: ''!

!classDefinition: #PolynomialFunction category: #'Mathematics-Geometry-Algebraic'!
Function subclass: #PolynomialFunction
	instanceVariableNames: 'domain representative'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Algebraic'!
!classDefinition: 'PolynomialFunction class' category: #'Mathematics-Geometry-Algebraic'!
PolynomialFunction class
	instanceVariableNames: ''!

!classDefinition: #PolynomialMap category: #'Mathematics-Geometry-Algebraic'!
Function subclass: #PolynomialMap
	instanceVariableNames: 'domain codomain components'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Algebraic'!
!classDefinition: 'PolynomialMap class' category: #'Mathematics-Geometry-Algebraic'!
PolynomialMap class
	instanceVariableNames: ''!

!classDefinition: #RationalMap category: #'Mathematics-Geometry-Algebraic'!
Function subclass: #RationalMap
	instanceVariableNames: 'domain codomain components'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Algebraic'!
!classDefinition: 'RationalMap class' category: #'Mathematics-Geometry-Algebraic'!
RationalMap class
	instanceVariableNames: ''!

!classDefinition: #RealRootFunction category: #'Mathematics-Geometry-Semialgebraic'!
Function subclass: #RealRootFunction
	instanceVariableNames: 'polynomials index'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Semialgebraic'!
!classDefinition: 'RealRootFunction class' category: #'Mathematics-Geometry-Semialgebraic'!
RealRootFunction class
	instanceVariableNames: ''!

!classDefinition: #ChainMap category: #'Mathematics-Homology'!
Function subclass: #ChainMap
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Homology'!
!classDefinition: 'ChainMap class' category: #'Mathematics-Homology'!
ChainMap class
	instanceVariableNames: ''!

!classDefinition: #SimplicialMap category: #'Mathematics-Homology'!
Function subclass: #SimplicialMap
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Homology'!
!classDefinition: 'SimplicialMap class' category: #'Mathematics-Homology'!
SimplicialMap class
	instanceVariableNames: ''!

!classDefinition: #Identity category: #'Mathematics-Kernel'!
Morphism subclass: #Identity
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel'!
!classDefinition: 'Identity class' category: #'Mathematics-Kernel'!
Identity class
	instanceVariableNames: ''!

!classDefinition: #Functor category: #'Mathematics-Kernel-Categories'!
Morphism subclass: #Functor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Categories'!
!classDefinition: 'Functor class' category: #'Mathematics-Kernel-Categories'!
Functor class
	instanceVariableNames: ''!

!classDefinition: #SchemeMorphism category: #'Mathematics-Geometry-Algebraic-Schemes'!
Morphism subclass: #SchemeMorphism
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Algebraic-Schemes'!
!classDefinition: 'SchemeMorphism class' category: #'Mathematics-Geometry-Algebraic-Schemes'!
SchemeMorphism class
	instanceVariableNames: ''!

!classDefinition: #SpectrumMorphism category: #'Mathematics-Geometry-Algebraic-Schemes'!
SchemeMorphism subclass: #SpectrumMorphism
	instanceVariableNames: 'oposite'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Algebraic-Schemes'!
!classDefinition: 'SpectrumMorphism class' category: #'Mathematics-Geometry-Algebraic-Schemes'!
SpectrumMorphism class
	instanceVariableNames: ''!

!classDefinition: #PresheafMorphism category: #'Mathematics-Topology'!
Morphism subclass: #PresheafMorphism
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Topology'!
!classDefinition: 'PresheafMorphism class' category: #'Mathematics-Topology'!
PresheafMorphism class
	instanceVariableNames: ''!

!classDefinition: #RandomGenerator category: #'Mathematics-Kernel'!
Object subclass: #RandomGenerator
	instanceVariableNames: 'domain bits random'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel'!
!classDefinition: 'RandomGenerator class' category: #'Mathematics-Kernel'!
RandomGenerator class
	instanceVariableNames: ''!

!classDefinition: #GroupRandomGenerator category: #'Mathematics-Groups'!
RandomGenerator subclass: #GroupRandomGenerator
	instanceVariableNames: 'state'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Groups'!
!classDefinition: 'GroupRandomGenerator class' category: #'Mathematics-Groups'!
GroupRandomGenerator class
	instanceVariableNames: ''!

!classDefinition: #Element category: #'Mathematics-Kernel-Elements'!
Object subclass: #Element
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Elements'!
!classDefinition: 'Element class' category: #'Mathematics-Kernel-Elements'!
Element class
	instanceVariableNames: ''!

!classDefinition: #GroupElement category: #'Mathematics-Kernel-Elements'!
Element subclass: #GroupElement
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Elements'!
!classDefinition: 'GroupElement class' category: #'Mathematics-Kernel-Elements'!
GroupElement class
	instanceVariableNames: ''!

!classDefinition: #GroupAdditiveElement category: #'Mathematics-Kernel-Elements'!
GroupElement subclass: #GroupAdditiveElement
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Elements'!
!classDefinition: 'GroupAdditiveElement class' category: #'Mathematics-Kernel-Elements'!
GroupAdditiveElement class
	instanceVariableNames: ''!

!classDefinition: #GroupCompositiveElement category: #'Mathematics-Kernel-Elements'!
GroupElement subclass: #GroupCompositiveElement
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Elements'!
!classDefinition: 'GroupCompositiveElement class' category: #'Mathematics-Kernel-Elements'!
GroupCompositiveElement class
	instanceVariableNames: ''!

!classDefinition: #RingElement category: #'Mathematics-Kernel-Elements'!
Element subclass: #RingElement
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Elements'!
!classDefinition: 'RingElement class' category: #'Mathematics-Kernel-Elements'!
RingElement class
	instanceVariableNames: ''!

!classDefinition: #RingCompositiveElement category: #'Mathematics-Kernel-Elements'!
RingElement subclass: #RingCompositiveElement
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Elements'!
!classDefinition: 'RingCompositiveElement class' category: #'Mathematics-Kernel-Elements'!
RingCompositiveElement class
	instanceVariableNames: ''!

!classDefinition: #FormalFraction category: #'Mathematics-Kernel-Support'!
Object subclass: #FormalFraction
	instanceVariableNames: 'numerator denominator'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Support'!
!classDefinition: 'FormalFraction class' category: #'Mathematics-Kernel-Support'!
FormalFraction class
	instanceVariableNames: ''!

!classDefinition: #PAdicNumber category: #'Mathematics-Kernel-Support'!
FormalFraction subclass: #PAdicNumber
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Support'!
!classDefinition: 'PAdicNumber class' category: #'Mathematics-Kernel-Support'!
PAdicNumber class
	instanceVariableNames: ''!

!classDefinition: #RationalFunction category: #'Mathematics-Polynomials'!
FormalFraction subclass: #RationalFunction
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Polynomials'!
!classDefinition: 'RationalFunction class' category: #'Mathematics-Polynomials'!
RationalFunction class
	instanceVariableNames: ''!

!classDefinition: #FormalSum category: #'Mathematics-Kernel-Support'!
Object subclass: #FormalSum
	instanceVariableNames: 'coefficients'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Support'!
!classDefinition: 'FormalSum class' category: #'Mathematics-Kernel-Support'!
FormalSum class
	instanceVariableNames: ''!

!classDefinition: #FreePolynomial category: #'Mathematics-Kernel-Support'!
FormalSum subclass: #FreePolynomial
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Support'!
!classDefinition: 'FreePolynomial class' category: #'Mathematics-Kernel-Support'!
FreePolynomial class
	instanceVariableNames: ''!

!classDefinition: #Divisor category: #'Mathematics-Geometry-Algebraic-Schemes'!
FormalSum subclass: #Divisor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Algebraic-Schemes'!
!classDefinition: 'Divisor class' category: #'Mathematics-Geometry-Algebraic-Schemes'!
Divisor class
	instanceVariableNames: ''!

!classDefinition: #SimplicialChain category: #'Mathematics-Homology'!
FormalSum subclass: #SimplicialChain
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Homology'!
!classDefinition: 'SimplicialChain class' category: #'Mathematics-Homology'!
SimplicialChain class
	instanceVariableNames: ''!

!classDefinition: #ModularInteger category: #'Mathematics-Kernel-Support'!
Object subclass: #ModularInteger
	instanceVariableNames: 'representative modulus'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Support'!
!classDefinition: 'ModularInteger class' category: #'Mathematics-Kernel-Support'!
ModularInteger class
	instanceVariableNames: ''!

!classDefinition: #PAdicInteger category: #'Mathematics-Kernel-Support'!
Object subclass: #PAdicInteger
	instanceVariableNames: 'digits'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Support'!
!classDefinition: 'PAdicInteger class' category: #'Mathematics-Kernel-Support'!
PAdicInteger class
	instanceVariableNames: ''!

!classDefinition: #Quaternion category: #'Mathematics-Kernel-Support'!
Object subclass: #Quaternion
	instanceVariableNames: 'a b c d'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Support'!
!classDefinition: 'Quaternion class' category: #'Mathematics-Kernel-Support'!
Quaternion class
	instanceVariableNames: ''!

!classDefinition: #Residue category: #'Mathematics-Kernel-Support'!
Object subclass: #Residue
	instanceVariableNames: 'representative ideal'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Support'!
!classDefinition: 'Residue class' category: #'Mathematics-Kernel-Support'!
Residue class
	instanceVariableNames: ''!

!classDefinition: #SLP category: #'Mathematics-Kernel-Support'!
Object subclass: #SLP
	instanceVariableNames: 'word'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Support'!
!classDefinition: 'SLP class' category: #'Mathematics-Kernel-Support'!
SLP class
	instanceVariableNames: ''!

!classDefinition: #Word category: #'Mathematics-Kernel-Support'!
Object subclass: #Word
	instanceVariableNames: 'syllables'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Kernel-Support'!
!classDefinition: 'Word class' category: #'Mathematics-Kernel-Support'!
Word class
	instanceVariableNames: ''!

!classDefinition: #GroupPresentation category: #'Mathematics-Groups'!
Object subclass: #GroupPresentation
	instanceVariableNames: 'generators relators'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Groups'!
!classDefinition: 'GroupPresentation class' category: #'Mathematics-Groups'!
GroupPresentation class
	instanceVariableNames: ''!

!classDefinition: #SemidirectProductElement category: #'Mathematics-Groups'!
Object subclass: #SemidirectProductElement
	instanceVariableNames: 'parent left right'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Groups'!
!classDefinition: 'SemidirectProductElement class' category: #'Mathematics-Groups'!
SemidirectProductElement class
	instanceVariableNames: ''!

!classDefinition: #SchreierSims category: #'Mathematics-Groups-Algorithms'!
Object subclass: #SchreierSims
	instanceVariableNames: 'action generators base strongGeneratingSet trees order'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Groups-Algorithms'!
!classDefinition: 'SchreierSims class' category: #'Mathematics-Groups-Algorithms'!
SchreierSims class
	instanceVariableNames: ''!

!classDefinition: #SchreierTree category: #'Mathematics-Groups-Algorithms'!
Object subclass: #SchreierTree
	instanceVariableNames: 'root generators action v w orbit'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Groups-Algorithms'!
!classDefinition: 'SchreierTree class' category: #'Mathematics-Groups-Algorithms'!
SchreierTree class
	instanceVariableNames: ''!

!classDefinition: #Matrix category: #'Mathematics-Modules-Matrices'!
Object subclass: #Matrix
	instanceVariableNames: 'parent'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Modules-Matrices'!
!classDefinition: 'Matrix class' category: #'Mathematics-Modules-Matrices'!
Matrix class
	instanceVariableNames: ''!

!classDefinition: #ColumnMatrix category: #'Mathematics-Modules-Matrices'!
Matrix subclass: #ColumnMatrix
	instanceVariableNames: 'columns'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Modules-Matrices'!
!classDefinition: 'ColumnMatrix class' category: #'Mathematics-Modules-Matrices'!
ColumnMatrix class
	instanceVariableNames: ''!

!classDefinition: #DenseMatrix category: #'Mathematics-Modules-Matrices'!
Matrix subclass: #DenseMatrix
	instanceVariableNames: 'coefficients'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Modules-Matrices'!
!classDefinition: 'DenseMatrix class' category: #'Mathematics-Modules-Matrices'!
DenseMatrix class
	instanceVariableNames: ''!

!classDefinition: #RowMatrix category: #'Mathematics-Modules-Matrices'!
Matrix subclass: #RowMatrix
	instanceVariableNames: 'rows'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Modules-Matrices'!
!classDefinition: 'RowMatrix class' category: #'Mathematics-Modules-Matrices'!
RowMatrix class
	instanceVariableNames: ''!

!classDefinition: #SparseMatrix category: #'Mathematics-Modules-Matrices'!
Matrix subclass: #SparseMatrix
	instanceVariableNames: 'coefficients'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Modules-Matrices'!
!classDefinition: 'SparseMatrix class' category: #'Mathematics-Modules-Matrices'!
SparseMatrix class
	instanceVariableNames: ''!

!classDefinition: #LinearEquation category: #'Mathematics-Modules-Support'!
Object subclass: #LinearEquation
	instanceVariableNames: 'form value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Modules-Support'!
!classDefinition: 'LinearEquation class' category: #'Mathematics-Modules-Support'!
LinearEquation class
	instanceVariableNames: ''!

!classDefinition: #LinearSystem category: #'Mathematics-Modules-Support'!
Object subclass: #LinearSystem
	instanceVariableNames: 'equations solver'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Modules-Support'!
!classDefinition: 'LinearSystem class' category: #'Mathematics-Modules-Support'!
LinearSystem class
	instanceVariableNames: ''!

!classDefinition: #GramSchmidt category: #'Mathematics-Modules-Algorithms'!
Object subclass: #GramSchmidt
	instanceVariableNames: 'basis innerProduct orthogonalBasis matrix'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Modules-Algorithms'!
!classDefinition: 'GramSchmidt class' category: #'Mathematics-Modules-Algorithms'!
GramSchmidt class
	instanceVariableNames: ''!

!classDefinition: #HermiteNormalForm2 category: #'Mathematics-Modules-Algorithms'!
Object subclass: #HermiteNormalForm2
	instanceVariableNames: 'matrix'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Modules-Algorithms'!
!classDefinition: 'HermiteNormalForm2 class' category: #'Mathematics-Modules-Algorithms'!
HermiteNormalForm2 class
	instanceVariableNames: ''!

!classDefinition: #HermiteNormalFormCRT category: #'Mathematics-Modules-Algorithms'!
Object subclass: #HermiteNormalFormCRT
	instanceVariableNames: 'matrix HNF'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Modules-Algorithms'!
!classDefinition: 'HermiteNormalFormCRT class' category: #'Mathematics-Modules-Algorithms'!
HermiteNormalFormCRT class
	instanceVariableNames: ''!

!classDefinition: #JordanNormalForm category: #'Mathematics-Modules-Algorithms'!
Object subclass: #JordanNormalForm
	instanceVariableNames: 'matrix blocks'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Modules-Algorithms'!
!classDefinition: 'JordanNormalForm class' category: #'Mathematics-Modules-Algorithms'!
JordanNormalForm class
	instanceVariableNames: ''!

!classDefinition: #LinearSystemSolver category: #'Mathematics-Modules-Algorithms'!
Object subclass: #LinearSystemSolver
	instanceVariableNames: 'system reducer kernelBasis particular'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Modules-Algorithms'!
!classDefinition: 'LinearSystemSolver class' category: #'Mathematics-Modules-Algorithms'!
LinearSystemSolver class
	instanceVariableNames: ''!

!classDefinition: #MatrixReducer category: #'Mathematics-Modules-Algorithms'!
Object subclass: #MatrixReducer
	instanceVariableNames: 'matrix extension currentPivot pivots determinantFactor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Modules-Algorithms'!
!classDefinition: 'MatrixReducer class' category: #'Mathematics-Modules-Algorithms'!
MatrixReducer class
	instanceVariableNames: ''!

!classDefinition: #GaussBareiss category: #'Mathematics-Modules-Algorithms'!
MatrixReducer subclass: #GaussBareiss
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Modules-Algorithms'!
!classDefinition: 'GaussBareiss class' category: #'Mathematics-Modules-Algorithms'!
GaussBareiss class
	instanceVariableNames: ''!

!classDefinition: #GaussianElimination category: #'Mathematics-Modules-Algorithms'!
MatrixReducer subclass: #GaussianElimination
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Modules-Algorithms'!
!classDefinition: 'GaussianElimination class' category: #'Mathematics-Modules-Algorithms'!
GaussianElimination class
	instanceVariableNames: ''!

!classDefinition: #QRDecomposition category: #'Mathematics-Modules-Algorithms'!
Object subclass: #QRDecomposition
	instanceVariableNames: 'matrix Q R'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Modules-Algorithms'!
!classDefinition: 'QRDecomposition class' category: #'Mathematics-Modules-Algorithms'!
QRDecomposition class
	instanceVariableNames: ''!

!classDefinition: #SmithNormalForm category: #'Mathematics-Modules-Algorithms'!
Object subclass: #SmithNormalForm
	instanceVariableNames: 'matrix diagonal'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Modules-Algorithms'!
!classDefinition: 'SmithNormalForm class' category: #'Mathematics-Modules-Algorithms'!
SmithNormalForm class
	instanceVariableNames: ''!

!classDefinition: #SimpleTensor category: #'Mathematics-Multilinear'!
Object subclass: #SimpleTensor
	instanceVariableNames: 'left right'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Multilinear'!
!classDefinition: 'SimpleTensor class' category: #'Mathematics-Multilinear'!
SimpleTensor class
	instanceVariableNames: ''!

!classDefinition: #Tensor category: #'Mathematics-Multilinear'!
Object subclass: #Tensor
	instanceVariableNames: 'components'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Multilinear'!
!classDefinition: 'Tensor class' category: #'Mathematics-Multilinear'!
Tensor class
	instanceVariableNames: ''!

!classDefinition: #Monomial category: #'Mathematics-Monomials'!
Object subclass: #Monomial
	instanceVariableNames: 'exponents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Monomials'!
!classDefinition: 'Monomial class' category: #'Mathematics-Monomials'!
Monomial class
	instanceVariableNames: ''!

!classDefinition: #MonomialOrdering category: #'Mathematics-Monomials-Orderings'!
Object subclass: #MonomialOrdering
	instanceVariableNames: 'indeterminates'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Monomials-Orderings'!
!classDefinition: 'MonomialOrdering class' category: #'Mathematics-Monomials-Orderings'!
MonomialOrdering class
	instanceVariableNames: ''!

!classDefinition: #LexicographicOrdering category: #'Mathematics-Monomials-Orderings'!
MonomialOrdering subclass: #LexicographicOrdering
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Monomials-Orderings'!
!classDefinition: 'LexicographicOrdering class' category: #'Mathematics-Monomials-Orderings'!
LexicographicOrdering class
	instanceVariableNames: ''!

!classDefinition: #ReverseLexicographicOrdering category: #'Mathematics-Monomials-Orderings'!
MonomialOrdering subclass: #ReverseLexicographicOrdering
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Monomials-Orderings'!
!classDefinition: 'ReverseLexicographicOrdering class' category: #'Mathematics-Monomials-Orderings'!
ReverseLexicographicOrdering class
	instanceVariableNames: ''!

!classDefinition: #TotalLexicographicOrdering category: #'Mathematics-Monomials-Orderings'!
MonomialOrdering subclass: #TotalLexicographicOrdering
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Monomials-Orderings'!
!classDefinition: 'TotalLexicographicOrdering class' category: #'Mathematics-Monomials-Orderings'!
TotalLexicographicOrdering class
	instanceVariableNames: ''!

!classDefinition: #TotalReverseLexicographicOrdering category: #'Mathematics-Monomials-Orderings'!
MonomialOrdering subclass: #TotalReverseLexicographicOrdering
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Monomials-Orderings'!
!classDefinition: 'TotalReverseLexicographicOrdering class' category: #'Mathematics-Monomials-Orderings'!
TotalReverseLexicographicOrdering class
	instanceVariableNames: ''!

!classDefinition: #WeightedMonomialOrdering category: #'Mathematics-Monomials-Orderings'!
MonomialOrdering subclass: #WeightedMonomialOrdering
	instanceVariableNames: 'weights'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Monomials-Orderings'!
!classDefinition: 'WeightedMonomialOrdering class' category: #'Mathematics-Monomials-Orderings'!
WeightedMonomialOrdering class
	instanceVariableNames: ''!

!classDefinition: #Polynomial category: #'Mathematics-Polynomials'!
Object subclass: #Polynomial
	instanceVariableNames: 'parent'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Polynomials'!
!classDefinition: 'Polynomial class' category: #'Mathematics-Polynomials'!
Polynomial class
	instanceVariableNames: ''!

!classDefinition: #MultivariatePolynomial category: #'Mathematics-Polynomials'!
Polynomial subclass: #MultivariatePolynomial
	instanceVariableNames: 'coefficients'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Polynomials'!
!classDefinition: 'MultivariatePolynomial class' category: #'Mathematics-Polynomials'!
MultivariatePolynomial class
	instanceVariableNames: ''!

!classDefinition: #UnivariatePolynomial category: #'Mathematics-Polynomials'!
Polynomial subclass: #UnivariatePolynomial
	instanceVariableNames: 'coefficients'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Polynomials'!
!classDefinition: 'UnivariatePolynomial class' category: #'Mathematics-Polynomials'!
UnivariatePolynomial class
	instanceVariableNames: ''!

!classDefinition: #FiniteFieldPolynomialFactorizer category: #'Mathematics-Polynomials-Algorithms'!
Object subclass: #FiniteFieldPolynomialFactorizer
	instanceVariableNames: 'polynomial factors'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Polynomials-Algorithms'!
!classDefinition: 'FiniteFieldPolynomialFactorizer class' category: #'Mathematics-Polynomials-Algorithms'!
FiniteFieldPolynomialFactorizer class
	instanceVariableNames: ''!

!classDefinition: #IntegerPolynomialFactorizer category: #'Mathematics-Polynomials-Algorithms'!
Object subclass: #IntegerPolynomialFactorizer
	instanceVariableNames: 'polynomial factors'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Polynomials-Algorithms'!
!classDefinition: 'IntegerPolynomialFactorizer class' category: #'Mathematics-Polynomials-Algorithms'!
IntegerPolynomialFactorizer class
	instanceVariableNames: ''!

!classDefinition: #MultiPolynomialDivision category: #'Mathematics-Polynomials-Algorithms'!
Object subclass: #MultiPolynomialDivision
	instanceVariableNames: 'dividend divisors ordering quotients remainder'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Polynomials-Algorithms'!
!classDefinition: 'MultiPolynomialDivision class' category: #'Mathematics-Polynomials-Algorithms'!
MultiPolynomialDivision class
	instanceVariableNames: ''!

!classDefinition: #PolynomialDivision category: #'Mathematics-Polynomials-Algorithms'!
Object subclass: #PolynomialDivision
	instanceVariableNames: 'dividend divisor quotient remainder'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Polynomials-Algorithms'!
!classDefinition: 'PolynomialDivision class' category: #'Mathematics-Polynomials-Algorithms'!
PolynomialDivision class
	instanceVariableNames: ''!

!classDefinition: #PolynomialInterpolator category: #'Mathematics-Polynomials-Algorithms'!
Object subclass: #PolynomialInterpolator
	instanceVariableNames: 'polynomial corrector'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Polynomials-Algorithms'!
!classDefinition: 'PolynomialInterpolator class' category: #'Mathematics-Polynomials-Algorithms'!
PolynomialInterpolator class
	instanceVariableNames: ''!

!classDefinition: #PolynomialPseudoDivision category: #'Mathematics-Polynomials-Algorithms'!
Object subclass: #PolynomialPseudoDivision
	instanceVariableNames: 'dividend divisor quotient remainder'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Polynomials-Algorithms'!
!classDefinition: 'PolynomialPseudoDivision class' category: #'Mathematics-Polynomials-Algorithms'!
PolynomialPseudoDivision class
	instanceVariableNames: ''!

!classDefinition: #ProbabilisticPolynomialFactorizer category: #'Mathematics-Polynomials-Algorithms'!
Object subclass: #ProbabilisticPolynomialFactorizer
	instanceVariableNames: 'polynomial factors irreducible done'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Polynomials-Algorithms'!
!classDefinition: 'ProbabilisticPolynomialFactorizer class' category: #'Mathematics-Polynomials-Algorithms'!
ProbabilisticPolynomialFactorizer class
	instanceVariableNames: ''!

!classDefinition: #RootFinder category: #'Mathematics-Polynomials-Algorithms'!
Object subclass: #RootFinder
	instanceVariableNames: 'polynomial'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Polynomials-Algorithms'!
!classDefinition: 'RootFinder class' category: #'Mathematics-Polynomials-Algorithms'!
RootFinder class
	instanceVariableNames: ''!

!classDefinition: #ComplexRootFinder category: #'Mathematics-Polynomials-Algorithms'!
RootFinder subclass: #ComplexRootFinder
	instanceVariableNames: 'squareFreePolynomial derivatives roots'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Polynomials-Algorithms'!
!classDefinition: 'ComplexRootFinder class' category: #'Mathematics-Polynomials-Algorithms'!
ComplexRootFinder class
	instanceVariableNames: ''!

!classDefinition: #FiniteFieldRootFinder category: #'Mathematics-Polynomials-Algorithms'!
RootFinder subclass: #FiniteFieldRootFinder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Polynomials-Algorithms'!
!classDefinition: 'FiniteFieldRootFinder class' category: #'Mathematics-Polynomials-Algorithms'!
FiniteFieldRootFinder class
	instanceVariableNames: ''!

!classDefinition: #NumericComplexRootFinder category: #'Mathematics-Polynomials-Algorithms'!
RootFinder subclass: #NumericComplexRootFinder
	instanceVariableNames: 'tolerance'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Polynomials-Algorithms'!
!classDefinition: 'NumericComplexRootFinder class' category: #'Mathematics-Polynomials-Algorithms'!
NumericComplexRootFinder class
	instanceVariableNames: ''!

!classDefinition: #RationalRootFinder category: #'Mathematics-Polynomials-Algorithms'!
RootFinder subclass: #RationalRootFinder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Polynomials-Algorithms'!
!classDefinition: 'RationalRootFinder class' category: #'Mathematics-Polynomials-Algorithms'!
RationalRootFinder class
	instanceVariableNames: ''!

!classDefinition: #RealRootFinder category: #'Mathematics-Polynomials-Algorithms'!
RootFinder subclass: #RealRootFinder
	instanceVariableNames: 'squareFreePolynomial sturm fourier roots'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Polynomials-Algorithms'!
!classDefinition: 'RealRootFinder class' category: #'Mathematics-Polynomials-Algorithms'!
RealRootFinder class
	instanceVariableNames: ''!

!classDefinition: #AlgebraicNumber category: #'Mathematics-Number Fields'!
Object subclass: #AlgebraicNumber
	instanceVariableNames: 'polynomial irreducible approximation radius'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Number Fields'!
!classDefinition: 'AlgebraicNumber class' category: #'Mathematics-Number Fields'!
AlgebraicNumber class
	instanceVariableNames: ''!

!classDefinition: #DirichletSeries category: #'Mathematics-Sequences'!
Object subclass: #DirichletSeries
	instanceVariableNames: 'coefficients'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Sequences'!
!classDefinition: 'DirichletSeries class' category: #'Mathematics-Sequences'!
DirichletSeries class
	instanceVariableNames: ''!

!classDefinition: #PowerSeries category: #'Mathematics-Sequences'!
Object subclass: #PowerSeries
	instanceVariableNames: 'coefficients'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Sequences'!
!classDefinition: 'PowerSeries class' category: #'Mathematics-Sequences'!
PowerSeries class
	instanceVariableNames: ''!

!classDefinition: #LLL category: #'Mathematics-Lattices'!
Object subclass: #LLL
	instanceVariableNames: 'basis delta orthogonalBasis mu'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Lattices'!
!classDefinition: 'LLL class' category: #'Mathematics-Lattices'!
LLL class
	instanceVariableNames: ''!

!classDefinition: #LatticeCovering category: #'Mathematics-Lattices'!
Object subclass: #LatticeCovering
	instanceVariableNames: 'lattice'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Lattices'!
!classDefinition: 'LatticeCovering class' category: #'Mathematics-Lattices'!
LatticeCovering class
	instanceVariableNames: ''!

!classDefinition: #LatticePacking category: #'Mathematics-Lattices'!
Object subclass: #LatticePacking
	instanceVariableNames: 'lattice'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Lattices'!
!classDefinition: 'LatticePacking class' category: #'Mathematics-Lattices'!
LatticePacking class
	instanceVariableNames: ''!

!classDefinition: #GraphNode category: #'Mathematics-Graphs-Parts'!
Object subclass: #GraphNode
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Graphs-Parts'!
!classDefinition: 'GraphNode class' category: #'Mathematics-Graphs-Parts'!
GraphNode class
	instanceVariableNames: ''!

!classDefinition: #ExplicitGraphNode category: #'Mathematics-Graphs-Parts'!
GraphNode subclass: #ExplicitGraphNode
	instanceVariableNames: 'inNeighbors outNeighbors'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Graphs-Parts'!
!classDefinition: 'ExplicitGraphNode class' category: #'Mathematics-Graphs-Parts'!
ExplicitGraphNode class
	instanceVariableNames: ''!

!classDefinition: #LabeledExplicitGraphNode category: #'Mathematics-Graphs-Parts'!
ExplicitGraphNode subclass: #LabeledExplicitGraphNode
	instanceVariableNames: 'label'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Graphs-Parts'!
!classDefinition: 'LabeledExplicitGraphNode class' category: #'Mathematics-Graphs-Parts'!
LabeledExplicitGraphNode class
	instanceVariableNames: ''!

!classDefinition: #ImplicitGraphNode category: #'Mathematics-Graphs-Parts'!
GraphNode subclass: #ImplicitGraphNode
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Graphs-Parts'!
!classDefinition: 'ImplicitGraphNode class' category: #'Mathematics-Graphs-Parts'!
ImplicitGraphNode class
	instanceVariableNames: ''!

!classDefinition: #ImplicitGraphNodeCollection category: #'Mathematics-Graphs-Parts'!
ImplicitGraphNode subclass: #ImplicitGraphNodeCollection
	instanceVariableNames: 'collectionBlock'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Graphs-Parts'!
!classDefinition: 'ImplicitGraphNodeCollection class' category: #'Mathematics-Graphs-Parts'!
ImplicitGraphNodeCollection class
	instanceVariableNames: ''!

!classDefinition: #ImplicitGraphNodeIterator category: #'Mathematics-Graphs-Parts'!
ImplicitGraphNode subclass: #ImplicitGraphNodeIterator
	instanceVariableNames: 'iterator'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Graphs-Parts'!
!classDefinition: 'ImplicitGraphNodeIterator class' category: #'Mathematics-Graphs-Parts'!
ImplicitGraphNodeIterator class
	instanceVariableNames: ''!

!classDefinition: #DAGFrontier category: #'Mathematics-Graphs-Algorithms'!
Object subclass: #DAGFrontier
	instanceVariableNames: 'frontier bag'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Graphs-Algorithms'!
!classDefinition: 'DAGFrontier class' category: #'Mathematics-Graphs-Algorithms'!
DAGFrontier class
	instanceVariableNames: ''!

!classDefinition: #Dijkstra category: #'Mathematics-Graphs-Algorithms'!
Object subclass: #Dijkstra
	instanceVariableNames: 'graph source predecessor distance'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Graphs-Algorithms'!
!classDefinition: 'Dijkstra class' category: #'Mathematics-Graphs-Algorithms'!
Dijkstra class
	instanceVariableNames: ''!

!classDefinition: #FloydWarshall category: #'Mathematics-Graphs-Algorithms'!
Object subclass: #FloydWarshall
	instanceVariableNames: 'graph distances'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Graphs-Algorithms'!
!classDefinition: 'FloydWarshall class' category: #'Mathematics-Graphs-Algorithms'!
FloydWarshall class
	instanceVariableNames: ''!

!classDefinition: #AffineFrame category: #'Mathematics-Geometry-Affine'!
Object subclass: #AffineFrame
	instanceVariableNames: 'origin basis'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Affine'!
!classDefinition: 'AffineFrame class' category: #'Mathematics-Geometry-Affine'!
AffineFrame class
	instanceVariableNames: ''!

!classDefinition: #BarycentricFrame category: #'Mathematics-Geometry-Affine'!
Object subclass: #BarycentricFrame
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Affine'!
!classDefinition: 'BarycentricFrame class' category: #'Mathematics-Geometry-Affine'!
BarycentricFrame class
	instanceVariableNames: ''!

!classDefinition: #HomogeneousTuple category: #'Mathematics-Geometry-Projective'!
Object subclass: #HomogeneousTuple
	instanceVariableNames: 'coordinates'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Projective'!
!classDefinition: 'HomogeneousTuple class' category: #'Mathematics-Geometry-Projective'!
HomogeneousTuple class
	instanceVariableNames: ''!

!classDefinition: #ProjectiveChart category: #'Mathematics-Geometry-Projective'!
Object subclass: #ProjectiveChart
	instanceVariableNames: 'frame index origin'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Projective'!
!classDefinition: 'ProjectiveChart class' category: #'Mathematics-Geometry-Projective'!
ProjectiveChart class
	instanceVariableNames: ''!

!classDefinition: #ProjectiveFrame category: #'Mathematics-Geometry-Projective'!
Object subclass: #ProjectiveFrame
	instanceVariableNames: 'space points unit'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Projective'!
!classDefinition: 'ProjectiveFrame class' category: #'Mathematics-Geometry-Projective'!
ProjectiveFrame class
	instanceVariableNames: ''!

!classDefinition: #PolynomialSystem category: #'Mathematics-Geometry-Algebraic'!
Object subclass: #PolynomialSystem
	instanceVariableNames: 'equations'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Algebraic'!
!classDefinition: 'PolynomialSystem class' category: #'Mathematics-Geometry-Algebraic'!
PolynomialSystem class
	instanceVariableNames: ''!

!classDefinition: #SchemePoint category: #'Mathematics-Geometry-Algebraic-Schemes'!
Object subclass: #SchemePoint
	instanceVariableNames: 'morphism'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Algebraic-Schemes'!
!classDefinition: 'SchemePoint class' category: #'Mathematics-Geometry-Algebraic-Schemes'!
SchemePoint class
	instanceVariableNames: ''!

!classDefinition: #CylindricalAlgebraicDecomposition category: #'Mathematics-Geometry-Semialgebraic'!
Object subclass: #CylindricalAlgebraicDecomposition
	instanceVariableNames: 'polynomials components'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Semialgebraic'!
!classDefinition: 'CylindricalAlgebraicDecomposition class' category: #'Mathematics-Geometry-Semialgebraic'!
CylindricalAlgebraicDecomposition class
	instanceVariableNames: ''!

!classDefinition: #SemialgebraicCell category: #'Mathematics-Geometry-Semialgebraic'!
Object subclass: #SemialgebraicCell
	instanceVariableNames: 'projection left right'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Semialgebraic'!
!classDefinition: 'SemialgebraicCell class' category: #'Mathematics-Geometry-Semialgebraic'!
SemialgebraicCell class
	instanceVariableNames: ''!

!classDefinition: #BooleanConnective category: #'Mathematics-Geometry-Tarski'!
Object subclass: #BooleanConnective
	instanceVariableNames: 'left right'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Tarski'!
!classDefinition: 'BooleanConnective class' category: #'Mathematics-Geometry-Tarski'!
BooleanConnective class
	instanceVariableNames: ''!

!classDefinition: #ConjunctionConnective category: #'Mathematics-Geometry-Tarski'!
BooleanConnective subclass: #ConjunctionConnective
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Tarski'!
!classDefinition: 'ConjunctionConnective class' category: #'Mathematics-Geometry-Tarski'!
ConjunctionConnective class
	instanceVariableNames: ''!

!classDefinition: #DisjunctionConnective category: #'Mathematics-Geometry-Tarski'!
BooleanConnective subclass: #DisjunctionConnective
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Tarski'!
!classDefinition: 'DisjunctionConnective class' category: #'Mathematics-Geometry-Tarski'!
DisjunctionConnective class
	instanceVariableNames: ''!

!classDefinition: #ImplicationConnective category: #'Mathematics-Geometry-Tarski'!
BooleanConnective subclass: #ImplicationConnective
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Tarski'!
!classDefinition: 'ImplicationConnective class' category: #'Mathematics-Geometry-Tarski'!
ImplicationConnective class
	instanceVariableNames: ''!

!classDefinition: #PolynomialEquation category: #'Mathematics-Geometry-Tarski'!
Object subclass: #PolynomialEquation
	instanceVariableNames: 'polynomial'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Tarski'!
!classDefinition: 'PolynomialEquation class' category: #'Mathematics-Geometry-Tarski'!
PolynomialEquation class
	instanceVariableNames: ''!

!classDefinition: #PolynomialInequality category: #'Mathematics-Geometry-Tarski'!
Object subclass: #PolynomialInequality
	instanceVariableNames: 'polynomial'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Tarski'!
!classDefinition: 'PolynomialInequality class' category: #'Mathematics-Geometry-Tarski'!
PolynomialInequality class
	instanceVariableNames: ''!

!classDefinition: #QuantifiedSentence category: #'Mathematics-Geometry-Tarski'!
Object subclass: #QuantifiedSentence
	instanceVariableNames: 'prefix matrix'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Tarski'!
!classDefinition: 'QuantifiedSentence class' category: #'Mathematics-Geometry-Tarski'!
QuantifiedSentence class
	instanceVariableNames: ''!

!classDefinition: #Quantifier category: #'Mathematics-Geometry-Tarski'!
Object subclass: #Quantifier
	instanceVariableNames: 'indeterminate'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Tarski'!
!classDefinition: 'Quantifier class' category: #'Mathematics-Geometry-Tarski'!
Quantifier class
	instanceVariableNames: ''!

!classDefinition: #ExistentialQuantifier category: #'Mathematics-Geometry-Tarski'!
Quantifier subclass: #ExistentialQuantifier
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Tarski'!
!classDefinition: 'ExistentialQuantifier class' category: #'Mathematics-Geometry-Tarski'!
ExistentialQuantifier class
	instanceVariableNames: ''!

!classDefinition: #UniversalQuantifier category: #'Mathematics-Geometry-Tarski'!
Quantifier subclass: #UniversalQuantifier
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Geometry-Tarski'!
!classDefinition: 'UniversalQuantifier class' category: #'Mathematics-Geometry-Tarski'!
UniversalQuantifier class
	instanceVariableNames: ''!

!classDefinition: #YoungDiagram category: #'Mathematics-Combinatorics'!
Object subclass: #YoungDiagram
	instanceVariableNames: 'shape'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Combinatorics'!
!classDefinition: 'YoungDiagram class' category: #'Mathematics-Combinatorics'!
YoungDiagram class
	instanceVariableNames: ''!

!classDefinition: #Simplex category: #'Mathematics-Homology'!
Object subclass: #Simplex
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Homology'!
!classDefinition: 'Simplex class' category: #'Mathematics-Homology'!
Simplex class
	instanceVariableNames: ''!

!classDefinition: #BerlekampMassey category: #'Mathematics-Algorithms'!
Object subclass: #BerlekampMassey
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Algorithms'!
!classDefinition: 'BerlekampMassey class' category: #'Mathematics-Algorithms'!
BerlekampMassey class
	instanceVariableNames: ''!

!classDefinition: #CRT category: #'Mathematics-Algorithms'!
Object subclass: #CRT
	instanceVariableNames: 'moduli C'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Algorithms'!
!classDefinition: 'CRT class' category: #'Mathematics-Algorithms'!
CRT class
	instanceVariableNames: ''!

!classDefinition: #DFT category: #'Mathematics-Algorithms'!
Object subclass: #DFT
	instanceVariableNames: 'ring n alpha'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Algorithms'!
!classDefinition: 'DFT class' category: #'Mathematics-Algorithms'!
DFT class
	instanceVariableNames: ''!

!classDefinition: #ExtendedEuclid category: #'Mathematics-Algorithms'!
Object subclass: #ExtendedEuclid
	instanceVariableNames: 'elements gcd combination'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Algorithms'!
!classDefinition: 'ExtendedEuclid class' category: #'Mathematics-Algorithms'!
ExtendedEuclid class
	instanceVariableNames: ''!

!classDefinition: #LagrangeGaussReduction category: #'Mathematics-Algorithms'!
Object subclass: #LagrangeGaussReduction
	instanceVariableNames: 'vectorSpace v1 v2 shortVector'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Algorithms'!
!classDefinition: 'LagrangeGaussReduction class' category: #'Mathematics-Algorithms'!
LagrangeGaussReduction class
	instanceVariableNames: ''!

!classDefinition: #ModifiedBerlekampMassey category: #'Mathematics-Algorithms'!
Object subclass: #ModifiedBerlekampMassey
	instanceVariableNames: 'input field minimalPolynomial'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Algorithms'!
!classDefinition: 'ModifiedBerlekampMassey class' category: #'Mathematics-Algorithms'!
ModifiedBerlekampMassey class
	instanceVariableNames: ''!

!classDefinition: #NTT category: #'Mathematics-Algorithms'!
Object subclass: #NTT
	instanceVariableNames: 'modulus primitive'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Algorithms'!
!classDefinition: 'NTT class' category: #'Mathematics-Algorithms'!
NTT class
	instanceVariableNames: ''!

!classDefinition: #WuRittProcess category: #'Mathematics-Algorithms'!
Object subclass: #WuRittProcess
	instanceVariableNames: 'polynomials characteristicSet'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Algorithms'!
!classDefinition: 'WuRittProcess class' category: #'Mathematics-Algorithms'!
WuRittProcess class
	instanceVariableNames: ''!

!classDefinition: #AutomaticPalette category: #'Mathematics-Morphic'!
Object subclass: #AutomaticPalette
	instanceVariableNames: 'map'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Morphic'!
!classDefinition: 'AutomaticPalette class' category: #'Mathematics-Morphic'!
AutomaticPalette class
	instanceVariableNames: ''!

!classDefinition: #ContinuousPalette category: #'Mathematics-Morphic'!
Object subclass: #ContinuousPalette
	instanceVariableNames: 'colors min max'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Morphic'!
!classDefinition: 'ContinuousPalette class' category: #'Mathematics-Morphic'!
ContinuousPalette class
	instanceVariableNames: ''!

!classDefinition: #DiscretePalette category: #'Mathematics-Morphic'!
Object subclass: #DiscretePalette
	instanceVariableNames: 'colors map'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Morphic'!
!classDefinition: 'DiscretePalette class' category: #'Mathematics-Morphic'!
DiscretePalette class
	instanceVariableNames: ''!

!classDefinition: #CoxeterDiagram category: #'Mathematics-Lie'!
Object subclass: #CoxeterDiagram
	instanceVariableNames: 'matrix'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Lie'!
!classDefinition: 'CoxeterDiagram class' category: #'Mathematics-Lie'!
CoxeterDiagram class
	instanceVariableNames: ''!

!classDefinition: #RootSystem category: #'Mathematics-Lie'!
Object subclass: #RootSystem
	instanceVariableNames: 'roots ambient'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Lie'!
!classDefinition: 'RootSystem class' category: #'Mathematics-Lie'!
RootSystem class
	instanceVariableNames: ''!

!classDefinition: #Expression category: #'Mathematics-Expressions'!
Object subclass: #Expression
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Expressions'!
!classDefinition: 'Expression class' category: #'Mathematics-Expressions'!
Expression class
	instanceVariableNames: ''!

!classDefinition: #ConstantExpression category: #'Mathematics-Expressions'!
Expression subclass: #ConstantExpression
	instanceVariableNames: 'constant'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Expressions'!
!classDefinition: 'ConstantExpression class' category: #'Mathematics-Expressions'!
ConstantExpression class
	instanceVariableNames: ''!

!classDefinition: #FunctionExpression category: #'Mathematics-Expressions'!
Expression subclass: #FunctionExpression
	instanceVariableNames: 'function arguments'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Expressions'!
!classDefinition: 'FunctionExpression class' category: #'Mathematics-Expressions'!
FunctionExpression class
	instanceVariableNames: ''!

!classDefinition: #PowerExpression category: #'Mathematics-Expressions'!
Expression subclass: #PowerExpression
	instanceVariableNames: 'base exponent'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Expressions'!
!classDefinition: 'PowerExpression class' category: #'Mathematics-Expressions'!
PowerExpression class
	instanceVariableNames: ''!

!classDefinition: #ProductExpression category: #'Mathematics-Expressions'!
Expression subclass: #ProductExpression
	instanceVariableNames: 'factors'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Expressions'!
!classDefinition: 'ProductExpression class' category: #'Mathematics-Expressions'!
ProductExpression class
	instanceVariableNames: ''!

!classDefinition: #SumExpression category: #'Mathematics-Expressions'!
Expression subclass: #SumExpression
	instanceVariableNames: 'terms'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Expressions'!
!classDefinition: 'SumExpression class' category: #'Mathematics-Expressions'!
SumExpression class
	instanceVariableNames: ''!

!classDefinition: #VariableExpression category: #'Mathematics-Expressions'!
Expression subclass: #VariableExpression
	instanceVariableNames: 'name'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-Expressions'!
!classDefinition: 'VariableExpression class' category: #'Mathematics-Expressions'!
VariableExpression class
	instanceVariableNames: ''!

!classDefinition: #DocumentationGenerator category: #'Mathematics-ETC'!
Object subclass: #DocumentationGenerator
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-ETC'!
!classDefinition: 'DocumentationGenerator class' category: #'Mathematics-ETC'!
DocumentationGenerator class
	instanceVariableNames: ''!

!classDefinition: #ElementaryTensorOld category: #'Mathematics-ETC'!
Object subclass: #ElementaryTensorOld
	instanceVariableNames: 'left right'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-ETC'!
!classDefinition: 'ElementaryTensorOld class' category: #'Mathematics-ETC'!
ElementaryTensorOld class
	instanceVariableNames: ''!

!classDefinition: #EllipticCurveElement category: #'Mathematics-ETC'!
Object subclass: #EllipticCurveElement
	instanceVariableNames: 'curve point'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-ETC'!
!classDefinition: 'EllipticCurveElement class' category: #'Mathematics-ETC'!
EllipticCurveElement class
	instanceVariableNames: ''!

!classDefinition: #GaussianElimination2 category: #'Mathematics-ETC'!
Object subclass: #GaussianElimination2
	instanceVariableNames: 'matrix extension subreducer pivots columns inverse determinant'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-ETC'!
!classDefinition: 'GaussianElimination2 class' category: #'Mathematics-ETC'!
GaussianElimination2 class
	instanceVariableNames: ''!

!classDefinition: #Knapsack category: #'Mathematics-ETC'!
Object subclass: #Knapsack
	instanceVariableNames: 'maximumWeight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-ETC'!
!classDefinition: 'Knapsack class' category: #'Mathematics-ETC'!
Knapsack class
	instanceVariableNames: ''!

!classDefinition: #Maxel category: #'Mathematics-ETC'!
Object subclass: #Maxel
	instanceVariableNames: 'pixels'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-ETC'!
!classDefinition: 'Maxel class' category: #'Mathematics-ETC'!
Maxel class
	instanceVariableNames: ''!

!classDefinition: #OEIS category: #'Mathematics-ETC'!
Object subclass: #OEIS
	instanceVariableNames: 'entries'
	classVariableNames: 'Default'
	poolDictionaries: ''
	category: 'Mathematics-ETC'!
!classDefinition: 'OEIS class' category: #'Mathematics-ETC'!
OEIS class
	instanceVariableNames: ''!

!classDefinition: #Pixel category: #'Mathematics-ETC'!
Object subclass: #Pixel
	instanceVariableNames: 'row column'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-ETC'!
!classDefinition: 'Pixel class' category: #'Mathematics-ETC'!
Pixel class
	instanceVariableNames: ''!

!classDefinition: #SturmChain category: #'Mathematics-ETC'!
Object subclass: #SturmChain
	instanceVariableNames: 'chain'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-ETC'!
!classDefinition: 'SturmChain class' category: #'Mathematics-ETC'!
SturmChain class
	instanceVariableNames: ''!

!classDefinition: #TensorOld category: #'Mathematics-ETC'!
Object subclass: #TensorOld
	instanceVariableNames: 'contents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mathematics-ETC'!
!classDefinition: 'TensorOld class' category: #'Mathematics-ETC'!
TensorOld class
	instanceVariableNames: ''!


!DyadicFraction commentStamp: '<historical>' prior: 0!
My instances represent dyadic fractions, i.e. fractions of the form a / 2^n where a is integer and n is >= 0.

Example:
	(DyadicFraction numerator: 5 shift: 3) + (DyadicFraction numerator: 3 shift: 2)
!

!RealAlgebraicNumber commentStamp: '<historical>' prior: 0!
My instances are real algebraic numbers, i.e. real zeros of polynomials with integer (or rational) coefficients.!

!ContinuedFraction commentStamp: '<historical>' prior: 0!
My instances are finite or infinite continued fractions.

The finite case correspondes to rational numbers, for example:
  36/17 as: ContinuedFraction

But continued fractions can be infinite:
  ContinuedFraction e

Given a Float, and assuming the number is actually rational, its continued fraction expansion can be used to guess the rational number by truncating it when the convergents start to get too big (in bitsize terms), or when the coefficients of the continued fraction get too big:
  2.117647 as: ContinuedFraction :: convergents
!

!Aleph commentStamp: '<historical>' prior: 0!
My instances are aleph numbers, i.e. cardinalities of infinite sets. Aleph-naught is the cardinality of the natural numbers. Assuming the continuum hypothesis, aleph-one is taken to be the cardinality of the real numbers.!

!Infinity commentStamp: '<historical>' prior: 0!
My instances are the real +infinity or -infinity.

For some examples try these:
	Infinity positive * Infinity negative.
	Infinity positive * 2.
	Infinity positive - 7811234871239847.
	Infinity negative / -199.
	Infinity positive reciprocal.
	Infinity positive > Infinity negative.
	Infinity negative < -19238479182374598172349871234.
	Infinity negative > 0.
	Infinity negative min: Infinity positive.

The following are examples of undeterminations (they produce an error):
	Infinity positive + Infinity negative.
	Infinity positive * 0.
	Infinity positive / Infinity positive.
	Infinity positive raisedToInteger: 0.
!

!Tuple commentStamp: '<historical>' prior: 0!
My instances are n-tuples, i.e. finite ordered lists of n objects (usually numbers), indexed by integers 1 to n.

Example:
	(1,2,3,4)
!

!LinearBasis commentStamp: '<historical>' prior: 0!
My instances are bases for linear spaces of finite dimension.

Example:
	| V |
	V _ QQ ** 3.
	LinearBasis on: V vectors: {(1, 2, 3). (3, 2, 3). (2, 0, 0)}!

!GroebnerBasis commentStamp: '<historical>' prior: 0!
My instances are Groebner bases.

Let polynomials f1..fm in F[x1,..,xn] and define an ideal I = <f1,...,fm>. For a fixed monomial ordering, a subset G = {g1,...,gm} of I is called a Groebner basis for I if every f in I is reducible by G, i.e. there exists g in G such that its leading monomial lm(g) divides lm(f).

When all fi's are linear, then a Groebner basis corresponds to "row echelon form" or "triangular system.". When they are univariate, then a Groebner basis corresponds to gcd(f1,...,fm). In general, a Groebner basis for an ideal I consists of all the "smallest polynomials" in I under the given monomial ordering.
 
Example:
	| Qxy x y grlex f1 f2 |
	Qxy _ QQ polynomialsIn: #(1 2).
	x _ Qxy x.
	y _ Qxy y.
	grlex _ MonomialOrdering tlex: #(1 2).
	f1 _ x**3 - (2*x*y).
	f2 _ x**2*y - (2*y*y) + x.
	GroebnerBasis from: {f1. f2} ordering: grlex
!

!Iterator commentStamp: '<historical>' prior: 0!
An Iterator is a read-only collection that evaluates a block to yield the elements of the collection.!

!Digraph commentStamp: '<historical>' prior: 0!
My instances are directed graphs (digraphs). The vertices (values) can be arbitrary objects, and the edges are Associations v1 -> v2. It uses a sparse representation, implemented as a collection of nodes (GraphNodes) where each node knows its neighbors.

Some properties of the graph are encoded in the class of its nodes (e.g. whether the graph is ordered, has a fixed arity, or the edges are labeled). The 'creation block' is initialized so that appropriate nodes are made.

Structure:
 nodes 			Set of GraphNodes
 nodeCreator 	a block which is evaluated to create a new node
 type 			a Symbol indicating what the default node type is!

!RootedDigraph commentStamp: '<historical>' prior: 0!
My instances are directed graphs with some distinguished vertices that we call 'roots'.

Structure:
 roots 		Set of root objects
!

!Graph commentStamp: '<historical>' prior: 0!
My instances are undirected graphs. The vertices (values) can be arbitrary objects, and the edges are MutualAssociations v1 <-> v2.

Internally, graphs are represented as symmetric digraphs (i.e., whenever the edge v1 -> v2 is present, v2 -> v1 is also present).

Structure:
 digraph 		The associated directed graph (which is always symmetric)!

!GraphMorph commentStamp: '<historical>' prior: 0!
My instances have submorphs that are GraphNodeMorph and GraphEdgeMorph (or subclasses). My subclasses implement different layouts.

Examples:
	| A4 a b |
	A4 _ AlternatingGroup on: (1 to: 4).
	a _ Permutation image: (2,1,4,3).
	b _ Permutation image: (2,3,1,4).
	(A4 cayleyGraphMorph: {a.b}) openInWorld.

	| R W |
	R _ RootSystem example1.
	W _ R dual weylGroup.
	(W cayleyGraphMorph: {W atRandom. W atRandom}) openInWorld

	| G |
	G _ Graph exampleImplicitGraph.
	SpringGraphMorph new graph: G; openInWorld 

	| G |
	G _ RootedDigraph exampleSmallLabelledTree.
	SpringGraphMorph new graph: G; openInWorld 
!

!HistogramMorph commentStamp: '<historical>' prior: 0!
Histograms to be used for statistical purposes. Useful, for example, for many image processing algorithms. See http://en.wikipedia.org/wiki/Histogram .
Counts are currently held in a WordArray, and limited to about 4 billion counts (32 bit unsigned integers)

A good number of bins can be n^(1/2) or n^(1/3), where n is the total number of samples. See Wikipedia article for rationale.!

!Diagram commentStamp: '<historical>' prior: 0!
My instances are commutative diagrams.
!

!ChainComplex commentStamp: '<historical>' prior: 0!
My instances are (bounded) chain complexes.

A chain complex (Ci,di) is a sequence of abelian groups or modules conected by homomorphisms (called boundary operators or differentials) di:Ai->A{i-1} such that the composition between any two consecutive maps is zero: di @ d{i+1} = 0.

A bounded chain complex is one where only a finite number of Ci are not {0}.

Chain complexes form a cateogory with chain maps as morphisms.!

!Domain commentStamp: '<historical>' prior: 0!
My instances are mathematical structures, such as groups, rings, fields, vector spaces, modules, etc.

Domains are connected by Morphisms, which in many cases are Functions. From the point of view of category theory, Domains and Functions are respectively 'objects' and 'morphisms' of (small) categories.

Domains often have an underlying set: the set of elements. The cardinality of a domain can be finite or infinite, and countable or uncountable (see Aleph and >>size). When the underlying set is finite, #asSet returns a Smalltalk Set. When it is countable, it is possible to iterate over its element (see >>do:).  Also, when it makes sense to take elements at random, #atRandom:, #atRandom:bits: or similar messages are implemented.

Examples:
	QQ**(3@3) atRandomBits: 100.
	(ZZ mod: 5) asSet.

Domains can be built from other domains by composition (in the OOP sense), for example by taking products or coproducts (cartesian products, direct products, direct sums), quotients, localizations, extensions, duals, etc. These operations are also morphisms (functors, more precisely), and are mostly implemented as Smalltalk messages.

Examples:
	ZZ  QQ polynomials.
	QQ**3  QQ asSelfVectorSpace.

Domains, as categorical objects, can have subobjects. Groups have subgroups, vector spaces have subspaces, rings have subrings and ideals, etc. In general, there is an #ambient object, and there is a protocol for inclusion testing: #<, #<=, #>=, #>.

Some domains, such as field extensions and localizations, have associated canonical embeddings, and should implement #embed: and #embedding. Other domains, such as quotient objects, have canonical projections and should implement #project: and #projection. N-ary products and coproducts should implement #projection: for the i-th projection map (and coproducts also implement #embedding: for the i-th coprojection).

Examples:
	(ZZ  QQ) projection: 2.
	QQ polynomials fractions embedding.

Given two domains A and B in the same category, the set of morphisms between them Hom(A,B) is obtained by sending the message 'A -> B' (so #-> is the Hom(A,-) functor). The identity morphism is returned by the message #id. And a morphism from A to B can be constructed by sending 'A to: B evaluating: [:x| ...]'.

Subclasses most frequently reimplement the following messages:
- #= and #<=
- #includes:
- #size
- #do:
- #atRandom::bits:
- #printOn:
- #product: and #coproduct:
- #->, #id and #to:evaluating:

References:
	https://en.wikipedia.org/wiki/Algebraic_structure
	https://en.wikipedia.org/wiki/Category_theory
	https://en.wikipedia.org/wiki/Subobject
	https://en.wikipedia.org/wiki/Product_(category_theory)
	https://en.wikipedia.org/wiki/Coproduct
!

!AbelianGroup commentStamp: '<historical>' prior: 0!
My instances are additive (abelian, commutative) groups. Subclasses are structures that build up from an abelian group, such as modules, vector spaces, rings, ideals, etc.

Group-specific behaviour is not implemented here. My instances are viewed not as groups but as some structure that has an underlying abelian group structure, and in order to operate with the group structure it must be converted to a Group (see >>asGroup).

As an abelian category, morphisms and objects can be added, and kernels and cokernels exist.!

!DirectSum commentStamp: '<historical>' prior: 0!
My instances are direct sums of abelian groups (or objects in an abelian category, see AbelianGroup).

Direct sums are equipped with projection homomorphisms to the i-th component (>>projection:) and coprojections or embeddings from the i-th component (>>embedding:).!

!Ideal commentStamp: '<historical>' prior: 0!
My instances are finitely-generated ideals of a commutative ring.

For an arbitrary ring R, a subset I <= R is called a two-sided ideal (or simply ideal) of R if it's a subgroup of R (as group under addition) and "absorbs multiplication by elements of R", i.e. I * R = I and R * I = I.

Equivalently, an ideal of R is a R-submodule of R.

Ideals are the ring theory analog of normal subgroups from group theory. They are 'normal subobjects' that are in one-to-one correspondence with certain congruences, and this allows to quotient by them. Given a ring R and an ideal I, the quotient R/I can be constructed (see QuotientRing). Ideals are the kernels of ring homomorphisms.

References:
	https://en.wikipedia.org/wiki/Ideal_(ring_theory)!

!IntegerIdeal commentStamp: '<historical>' prior: 0!
My instances are ideals of integers. They are cyclic, i.e. they are all multiples of a given integer (the #generator).!

!PolynomialIdeal commentStamp: '<historical>' prior: 0!
My instances are ideals of polynomials.!

!MonomialIdeal commentStamp: '<historical>' prior: 0!
My instances are ideals generated by a list of monomials.!

!Ring commentStamp: '<historical>' prior: 0!
My instances are rings with unit, i.e. structures with a set R of elements, a distinguished element 1 (the multiplicative identity) and two binary operations + and * such that:
- R is an abelian group under addition;
- R is a monoid under multiplication;
- multiplication is distributive with respect to addition.

The idea of 'ring' appears naturally in mathematics when considering the endomorphisms of abelian groups (or other abelian categories) under composition.

Rings can be commutative or non-commutative. Some specific kinds of commutative rings are given with the following class of inclusions:
	commutative rings > integral domains > integrity closed domains > unique factorization domains > principal ideal domains > euclidean domains > fields > finite fields.

Rings can be constructed from existing rings by taking quotients by an ideal (see QuotientRing), by making transcendental extensions (see PolynomialRing), etc.

Rings can also be made into fields by 'adding the missing multiplicative inverses' (or localization), for example by constructing the fractions of an integral domain (see FractionField).

References:
	https://en.wikipedia.org/wiki/Ring_(mathematics)!

!Integers commentStamp: '<historical>' prior: 0!
My singletion global instance ZZ is the ring of integer numbers.!

!GroupRing commentStamp: '<historical>' prior: 0!
My instances are group rings. Given a ring R and a group G, the group ring R[G] can be seen as a ring or as a free R-module with basis one-to-one with G. As a ring, its addition law is that of the free module, and the multiplication extends by linearity the given group law on the basis.

When the ring R is commutative, the group ring is also referred to as a group algebra.

Categorically, the group ring construction is left adjoint to the group of units (see UnitsGroup). It's also a 'category algebra' analogous to the monoid ring for monoids and  incidence algebra for posets.

References:
	https://en.wikipedia.org/wiki/Group_ring!

!QuotientRing commentStamp: '<historical>' prior: 0!
My instances are quotient rings (also called factor rings, difference rings or residue class rings). 

Given a commutative ring R and a two-sided-ideal I of R, the quotient ring R/I is the set of cosets of I in R by the equivalence relation a ~ b if a - b is in I. If the ideal is maximal, the resulting quotient ring is a field (see ResidueField). If it's only prime, the quotient ring is an integral domain.

Example:
	| I |
	I _ ZZ * 3.
	(ZZ/I) elements.

References:
	https://en.wikipedia.org/wiki/Quotient_ring!

!ModularIntegers commentStamp: '<historical>' prior: 0!
My instances are rings of integers mod m, i.e. Z/<m>.!

!CoordinateRing commentStamp: 'len 6/4/2016 03:42' prior: 0!
My instances are the coordinate ring K[V] of an affine variety V (over a field K). The elements are morphisms from V to K, i.e. polynomial functions in K[X] restricted to V, also called 'regular functions'. This is isomorphic to the quotient ring K[X] / I(V).

Elements of the coordinate ring act as functions on the algebraic set, just as elements of the original polynomial ring act as functions on the (affine or projective) space of their variables.

The following sets are in bijection (naturally):
1. The points of V.
2. K-algebra homomorphisms K[V] -> K.
3. Maximal ideals in K[V].
!

!Field commentStamp: '<historical>' prior: 0!
A field is a nonzero commutative division ring, or equivalently a ring whose nonzero elements form an abelian group under multiplication. See subclasses for concrete examples.

References:
	https://en.wikipedia.org/wiki/Field_(mathematics)!

!ComplexNumbers commentStamp: '<historical>' prior: 0!
I'm the field of complex numbers.!

!ExtendedComplexNumbers commentStamp: '<historical>' prior: 0!
I'm the field of complex numbers extended with the point a infinity.!

!Reals commentStamp: '<historical>' prior: 0!
I'm the field of real numbers.!

!FractionField commentStamp: '<historical>' prior: 0!
My instances are fields of fractions (ratios, quotients) with numerator and (nonzero) denominator in an integral domain. See Ring>>fractions.

For example, the field of fractions of the integers is the rational numbers:
	ZZ fractions

The field of fractions is a particular case of the more general construction of the localization of a ring or module.

References:
	https://en.wikipedia.org/wiki/Field_of_fractions!

!Rationals commentStamp: '<historical>' prior: 0!
My singletion global instance QQ is the field of rational numbers.!

!RationalFunctions commentStamp: '<historical>' prior: 0!
My instances are rational functions, i.e. the field of fractions of a given polynomial ring.

Example:
	"x / y in Q[x,y]"
	| F |
	F _ QQ polynomialsIn: #(x y) :: fractions.
	(F x: 1) / (F x: 2)
!

!FunctionField commentStamp: '<historical>' prior: 0!
My instances are fields of fractions of coordinate rings of (affine) algebraic varieties.!

!ResidueField commentStamp: '<historical>' prior: 0!
My instances are quotients of a ring by a maximal ideal. They are special cases of quotient rings (and thus, they are polynorphic with QuotientRing).!

!PrimeField commentStamp: '<historical>' prior: 0!
My instances are fields of order p prime, i.e. the residue field Z/<p> of integers modulo p.!

!AlgebraicExtension commentStamp: '<historical>' prior: 0!
My instances are (finite) algebraic extensions E/F of a field F. They are defined by an irreducible polynomial f with coefficients in F, and is isomorphic to F[x]/<f>.

Example:
	QQ extension: QQ polynomials x**4 - 2
!

!NumberField commentStamp: '<historical>' prior: 0!
My instances are number fields, i.e. finite (and thus algebraic) field extensions of the rational numbers Q. Number fields can also be viewed as vector spaces over Q.

Example:
	QQ adjoint: RealAlgebraicNumber sqrt2
!

!AlgebraicNumbers commentStamp: '<historical>' prior: 0!
I'm the field of (complex) algebraic numbers, i.e. the algebraic closure of Q.!

!RealAlgebraicNumbers commentStamp: '<historical>' prior: 0!
I'm the field of real algebraic numbers, i.e. real zeros of polynomials with integer or rational coefficients.!

!PolynomialRing commentStamp: '<historical>' prior: 0!
My instances are polynomial rings in one or many indeterminates.

Example:
	"Polynomial in Z[x]"
	| R x |
	R _ ZZ polynomials.
	x _ R x.
	x**2 - x + 1

Example:
	"Polynomial in Z[x] by tuple of coefficients"
	ZZ polynomials coefficients: #(3 -2 1)

Example:
	"Polynomial in Q[x,y]"
	| R x y |
	R _ ZZ polynomialsIn: #(x y). "these are just names for printing"
	x _ R x: 1.
	y _ R x: 2.
	(x - y) ** 2
!

!Module commentStamp: 'len 6/23/2016 01:23' prior: 0!
My instances are right R-modules.
!

!FreeModule commentStamp: '<historical>' prior: 0!
My instances are free right R-modules, i.e. right R-modules with a basis. They are isomorphic to R^n.!

!FreeAbelianGroup commentStamp: '<historical>' prior: 0!
My instances are abelian groups with a basis, i.e. free Z-modules. They are isomorphic to Z^n.

TODO:
- membership: compute Hermite normal form of the matrix of the basis
- or use LLL!

!Lattice commentStamp: '<historical>' prior: 0!
A lattice is the set of integer linear combinations of a basis of a real vector space. This is a subgroup of the vector space (as abelian group) isomorphic to Z^n.!

!LinearMaps commentStamp: '<historical>' prior: 0!
My instances are R-modules (or K-vector spaces) of linear transformations from a R-module (or K-vector space) A to another one B, i.e. Hom(A,B), the space of module homomorphisms between two R-modules.

Example:
	QQ ** 3 -> (QQ ** 2).
!

!DualModule commentStamp: '<historical>' prior: 0!
My instances are vector spaces of linear forms (see LinearForm), i.e linear maps from a R-module M to R (or from a vector space to the ground field). This is the (algebraic) dual of M and it is noted M*.
!

!MatrixModule commentStamp: '<historical>' prior: 0!
My instances are modules (or vector spaces) of matrices of n rows by m columns over a given ring (or field).!

!QuotientModule commentStamp: '<historical>' prior: 0!
My instances are quotient modules M/S (read "M mod S") of a given module M modulo a submodule S.

The elements of a quotient modules are affine submodules (flats) S + x with x in M, and they form a module. See AffineSubspace.

References:
	https://en.wikipedia.org/wiki/Quotient_module
	https://en.wikipedia.org/wiki/Quotient_space_(linear_algebra)!

!ScalarModule commentStamp: '<historical>' prior: 0!
My instances are one-dimensional free modules (or vector spaces) of scalars, i.e. a ring R viewed as a R-module (or a field K viewed as a K-vector space).!

!Submodule commentStamp: '<historical>' prior: 0!
My instances are finitely-generated submodules of a given module (or linear subspaces of a given vector space).

Example:
	QQ ** 3 span: {(1,0,0). (0,2,1)}
!

!TupleModule commentStamp: '<historical>' prior: 0!
My instances are modules (or vector spaces) of n-tuples over a given ring (or field).!

!VectorSpace commentStamp: '<historical>' prior: 0!
My instances are finitely-generated vector spaces. My subclasses might define concrete vector spaces by specifying a standard basis, so that it's possible to compute with it.

Examples of vector spaces are tuples, matrices and linear transformations.
!

!HomogeneousPolynomialSpace commentStamp: '<historical>' prior: 0!
My instances are modules of multivariate homogeneous polynomials of degree d in n variables, for fixed d and n.!

!PolynomialSpace commentStamp: '<historical>' prior: 0!
My instances are vector spaces of univariate polynomials of degree <= n, for a fixed n.!

!AlgebraicExtensionSpace commentStamp: '<historical>' prior: 0!
My instances are (finite) algebraic extensions E/F of a field F seen as an F-vector space.

Example:
	QQ extension: QQ polynomials x**4 - 2 :: asVectorSpace
!

!ExteriorPower commentStamp: 'len 8/1/2016 23:59' prior: 0!
TODO:
- elements: k-vectors (ExteriorProduct or ExteriorVector?)
- ExteriorAlgebra as a graded algebra, direct sum of /\^i(V) for i in [1..n]!

!CartesianProduct commentStamp: '<historical>' prior: 0!
My instances are cartesian products. See Domain>>,.

Example:
  (ZZ, QQ)

References:
	https://en.wikipedia.org/wiki/Cartesian_product
!

!EquivalenceClass commentStamp: '<historical>' prior: 0!
Given a set X and an equivalence relation ~, the equivalence class of an element a is the set of elements equivalent to a: [a] = {x in X such that x ~ a}. An member of an equivalence class is called a 'representative'.

Elements of quotient objects (elements of QuotientRings, QuotientSpaces, etc) are polymorphic with EquivalenceClass.

See EquivalenceRelation.

References:
	https://en.wikipedia.org/wiki/Equivalence_class!

!EquivalenceRelation commentStamp: '<historical>' prior: 0!
An equivalence relation on X is a binary relation ~ on X with the following properties:
- For every element a in X, a ~ a (reflexivity);
- For every two elements a, b in X, if a ~ b then b ~ a (symmetry);
- For every three elements a, b, c in X, if a ~ b and b ~ c then a ~ c (transitivity).

See EquivalenceClass.

References:
	https://en.wikipedia.org/wiki/Equivalence_relation!

!FormalSet commentStamp: '<historical>' prior: 0!
My instances are mathematical sets, i.e. objects in the category of sets. They arise when seeing a Smalltalk Set as a mathematical set, or when seeing any other Domain as a set (as applying the forgetful functor to the cateogry of sets).

Examples:
	#(1 2 3) asSet as: FormalSet.
	ZZ as: FormalSet.
!

!Magma commentStamp: '<historical>' prior: 0!
My instances are magmas. They consist of a set and a binary operation, with no other requirements.!

!Quasigroup commentStamp: '<historical>' prior: 0!
Quasigroups consist of a set and a binary operation (like a magma), obeying the Latin square property: each element occurs exactly once in each row and exactly once in each column of the multiplication table.!

!Loop commentStamp: '<historical>' prior: 0!
A Loop is a Quasigrop with an identity element.!

!Semigroup commentStamp: '<historical>' prior: 0!
Semigroups consist of a set and an associative binary operation, most often denoted multiplicatively.!

!Monoid commentStamp: '<historical>' prior: 0!
My instances are monoids. They consist of a set, an associative binary operation and an identity element.!

!FreeMonoid commentStamp: '<historical>' prior: 0!
My instances are free monoids. A free monoid is a monoid whose elements are words in a finite set of arbitrary objects (symbols), together with word concatenation as monoid operation.!

!Group commentStamp: '<historical>' prior: 0!
My instances are groups. They consist of a set, with an associative binary operation, an inverse map (every element has an inverse), and an identity element.

Groups can be represented explicitly as a set of elements, plus a distinguished 'identity' element, group operation and inverse map. They can be also defined and represented more compactly by a set of generators.

Some specific groups (such as permutation groups and matrix groups) can be represented in more efficient ways, and operate with more efficient algorithms. See subclasses.

References:
	https://en.wikipedia.org/wiki/Group_(mathematics)!

!DirectProductGroup commentStamp: '<historical>' prior: 0!
My instances are direct products of rings. Elements are tuples, and multiplication and addition are defined component wise.!

!FreeGroup commentStamp: '<historical>' prior: 0!
My instances are free groups on a given set of symbols. Their elements are (non-commutative) words on the set of symbols.!

!QuotientGroup commentStamp: '<historical>' prior: 0!
My instances are quotient groups (or factor groups) G/N (read "G mod N"), i.e. the quotient of a group G by a normal subgroup N. The elements are the cosets of N (see Coset).

References:
	https://en.wikipedia.org/wiki/Quotient_group!

!PermutationGroup commentStamp: '<historical>' prior: 0!
My instances are permutation groups, i.e. subgroups of the symmetric group Sym(X) of permutations on the elements of a set X (which we call 'space').

Elements of the space X are refered to as 'points', while the word 'element' is used for elements of the group itself (permutations). The group acts naturally on the space X by the action p^x |-> p(x).!

!AlternatingGroup commentStamp: '<historical>' prior: 0!
My instances are the alternating group Alt(X) of even permutations on the elements of a set X (which we call 'space').!

!SymmetricGroup commentStamp: '<historical>' prior: 0!
My instances are the symmetric group Sym(X) of permutations on the elements of a set X (which we call 'space').

Examples:
	SymmetricGroup new: 3.
	SymmetricGroup on: #(a b c).!

!LinearGroup commentStamp: '<historical>' prior: 0!
My instances are groups of linear transformations acting on a vector space. They are subgroups of the general linear group GL(V).

These groups act naturally on the domain vector space by the action g^v |-> g(v).!

!GeneralLinearGroup commentStamp: '<historical>' prior: 0!
My instances are the general linear group GL(V) of automorphisms of a vector space V. The elements are invertible linear transformations from V to itself (see LinearMap, LinearGroup).

Examples (two equivalent ways to create GL(V):
	GeneralLinearGroup on: QQ ** 3.
	(QQ ** 3) automorphisms!

!OrthogonalGroup commentStamp: '<historical>' prior: 0!
My instances are O(V), the Orthogonal Group of a vector space V. This is the group of automorphisms that preserve the inner product.
!

!MatrixGroup commentStamp: '<historical>' prior: 0!
My instances are groups of nxn (non-singular) matrices acting on the tuple space K^n. They are subgroups of the general linear matrix group GL(n,K) of nxn invertible matrices with coefficients in the field K.

These groups act naturally on the vector space K^n by the action A^v |-> A*v. (Or the corresponding left action).!

!GeneralLinearMatrixGroup commentStamp: '<historical>' prior: 0!
My instances are the general linear (matrix) group GL(n,K) of nxn invertible matrices with coefficients in K, acting on the tuple space K^n.

Example:
	GeneralLinearMatrixGroup on: QQ ** 3
!

!SpecialLinearMatrixGroup commentStamp: '<historical>' prior: 0!
My instances are SL(V), the Special Linear Group of a vector space V. This is the group of unimodular automorphisms (transformations of determinant 1).!

!AffineGroup commentStamp: '<historical>' prior: 0!
My instances are groups of (invertible) affine maps acting on an affine space. They are subgroups of the general affine group GA(V).!

!EuclideanGroup commentStamp: '<historical>' prior: 0!
My instances are the Euclidean group E(n) or ISO(n), the symmetry group of n-dimensional Euclidean space. Its elements are the isometries associated with the Euclidean metric, and are called Euclidean motions (they are affine maps).

E(n) includes the subgroup E*(n) or SE(n) of isometries preserving orientation, also called rigid motions or special Euclidean group.!

!GeneralAffineGroup commentStamp: '<historical>' prior: 0!
My instances are the (general) affine group of an affine space, consisting of all invertible affine transformations from the space into itself.

If the scalar field is R, C or H, this is a Lie group.!

!SpecialAffineGroup commentStamp: '<historical>' prior: 0!
My instances are the special affine group of an affine space, consisting of all invertible affine transformations from the space into itself that preserve volumes.!

!SpecialEuclideanGroup commentStamp: '<historical>' prior: 0!
My instances are the special Euclidean group SE(n) or E*(n), a subgroup of the Euclidean group E(n) that consists of rigid motions, i.e. isometries preserving orientation.
!

!ProjectiveGroup commentStamp: '<historical>' prior: 0!
My instances are groups of projective maps acting on a projective space. They are subgroups of the projective general linear group PGL(V).!

!UnitsGroup commentStamp: '<historical>' prior: 0!
My instances are sets of ring units. They have a group structure.

Given a ring R, the group of units of R is the set of elements of R that have multiplicative inverse, and they form a group under multiplication. For a field F (or more generally a division ring), the units are all non-zero elements F \ {0}.

Categorically, this construction is a functor from the cateogory of rings to the category of groups. This functor has a left adjoint which is the integral group ring construction (see GroupRing).

References:
	https://en.wikipedia.org/wiki/Unit_(ring_theory)!

!Monomials commentStamp: '<historical>' prior: 0!
My instances are (commutative) monoids of monomials in n indeterminates.!

!Morphisms commentStamp: '<historical>' prior: 0!
My instances are Hom(A,B) objects for domain A and codomain B.!

!QuotientSet commentStamp: '<historical>' prior: 0!
My instances are quotients of a set by an equivalence relation. The elements are equivalence classes. See EquivalenceRelation and EquivalenceClass.!

!Naturals commentStamp: '<historical>' prior: 0!
My singletion global instance NN is the set of natural numbers 1, 2, 3, ...!

!RealBox commentStamp: '<historical>' prior: 0!
My instances are boxes in R^n built by the cartesian product of one-dimensional intervals (instances of RealInterval).

Example:
	RealBox new
		add: (RealInterval closed: -1 closed: 1);
		add: (RealInterval open: 3 open: 4);
		add: (RealInterval closed: 0 open: Infinity positive);
		yourself.
!

!RealInterval commentStamp: '<historical>' prior: 0!
My instances are real intervals in the real line. Each of my instances can have finite or infinite and open or closed bounds.

For some examples try this:
	RealInterval open: 1 closed: 2.
	RealInterval open: 0 open: Infinity positive.
	RealInterval closed: -1 closed: 1.
	RealInterval open: Infinity negative open: Infinity positive.
!

!SemialgebraicInterval commentStamp: '<historical>' prior: 0!
My instances are components of a cell complex of R^1. See SemialgebraicCell.
!

!RightCoset commentStamp: 'len 8/14/2016 06:04' prior: 0!
My instances are right cosets of a subgroup H of a group G: {Hg : g in G}.!

!Coset commentStamp: '<historical>' prior: 0!
My instances are (left) cosets of a subgroup H of a group G: {gH : g in G}.!

!Grassmannian commentStamp: '<historical>' prior: 0!
The Grassmannian Gr(r.V) is the set of r-dimensional subspaces of the vector space V.!

!LinearCode commentStamp: '<historical>' prior: 0!
My instances are linear codes.

In coding theory, a linear code is an error-correcting code for which any linear combination of codewords is also a codeword. Thus, linear codes can be seen as a vector space (or more precisely as a subspace of a vector space).

References:
	https://en.wikipedia.org/wiki/Linear_code
!

!PolynomialCode commentStamp: '<historical>' prior: 0!
My instances are polynomial codes.

In coding theory, a polynomial code is a type of linear code whose set of valid codewords consists of those polynomials (usually of some fixed length) that are divisible by some fixed polynomial (of shorter length, called the generator polynomial).

References:
	https://en.wikipedia.org/wiki/Polynomial_code
!

!AffineLinearSpace commentStamp: '<historical>' prior: 0!
My instances are affine spaces contained in a given vector space, i.e. flats, or linear varieties, linear manifolds, or translated subspaces (cosets) of a vector space.

Affine spaces are essentially vector spaces where the origin 0 was "forgotten", i.e. there's no distinguished origin. Its elements are called points, not vectors, but they are the same objects.

Affine spaces appear when considering the solutions of non-homogeneous linear systems, or the set of all the vectors in the domain of a linear map that are mapped to a given vector in the codomain of the transformation (which is called the fiber of the vector).

The morphisms are AffineMaps (or affinities).

Example:
	| V S f |
	V _ QQ ** 3.
	S _ V span: {(1, 1, 1). (2, 0, -2)}.
	f _ LinearMap projectionOn: S.
	f fiberAt: (1, 2, 3).
!

!ProjectiveLinearSpace commentStamp: '<historical>' prior: 0!
My instances are projective spaces P(V) formed by the projectivization of a given finite-dimensional K-vector space V. It's isomorphic to the subspaces of dimension 1 in V, this is to say that the points of projective space P(V) are in correspondence with the lines through the origin in V (and projective lines are in correspondence with subspaces of dimension 2, and so on).

Projective space can also be viewed as the set quotient V-{0}/~ by the equivalence relation x ~ c*x where c is a constant in K. Or, as the grassmannian Gr(1,V).

The morphisms are ProjectiveMaps (or projectivities).

References:
	https://en.wikipedia.org/wiki/Projective_space
!

!AlgebraicSet commentStamp: '<historical>' prior: 0!
My instances are sets of zeros of multivariate polynomials in an algebraically closed field. They are geometric manifestations of solutions of systems of polynomial equations.

Given a an ideal I, the algebraic set consisting of the zeros of all polynomials in I is denoted V(I). Conversely, every algebraic set has an associated ideal I(V) that consists of all polynomials that vanish at all the points of the algebraic set.

If I is radical, then I(V(I)) = I. There is a one-to-one correspondence between radical ideals and algebraic sets.

An algebraic set is called 'irreducible' (or an algebraic variety) if it cannot be decomposed as the union of other algebraic sets. 

If I is a prime ideal, then V(I) is irreducible. There's an one-to-ono correspondence between prime ideals and irreducible algebraic sets (or algebraic varieties). The maximal ideals correspond to points.

Algebraic sets are equiped with the Zariski topology. The closed subsets are varieties V(I).!

!Scheme commentStamp: '<historical>' prior: 0!
My instances are schemes over a commutative ring.

A scheme is a space that locally looks like a particularilly simple ringed space: an affine scheme. More preciselly, a scheme is a locally ringed space with an open cover by affine schemes (the spectra of unital commutative rings).

A morphism of schemes is a morphism of the underlying locally ringed spaces.

References:
	https://en.wikipedia.org/wiki/Scheme_(mathematics)!

!AffineScheme commentStamp: '<historical>' prior: 0!
My instances are affine schemes.

Example:
	| R x y |
	R _ ZZ polynomialsIn: #(x y).
	x _ R x.
	y _ R y.
	AffineScheme ideal: R * (x**2 + (y**2) - 1)

Or equivalently:
	| R x y |
	R _ ZZ polynomialsIn: #(x y).
	x _ R x.
	y _ R y.
	(R / (R * (x**2 + (y**2) - 1))) spec
!

!AffineSpace commentStamp: '<historical>' prior: 0!
My instances are affine spaces R^n as schemes, i.e. Spec(R[x1,...,xn]) for some commutative ring R.!

!Spectrum commentStamp: '<historical>' prior: 0!
My instances are spectra of commutative rings. Given a commutative ring R, the spectrum of R denoted Spec(R) is the set of all prime ideals of R.

Spec(R) is an affine scheme. Its coordinate ring is R.

References:
	https://en.wikipedia.org/wiki/Spectrum_of_a_ring!

!ProjectiveSpace commentStamp: '<historical>' prior: 0!
My instances are projective spaces RP^n as schemes, i.e. Proj(R[x1,...,xn]) for some graded commutative ring R.!

!SemialgebraicSet commentStamp: '<historical>' prior: 0!
My instances are semialgebraic sets, i.e. subsets of R^n expressable as finite union and intersection of sets of the form:
	{(x1,...,xn) | sign(f(x1,...,xn)) = s}
where f is a polynomial in R[x1,...,xn] and s is 1, -1 or 0.

Semialgebraic sets are closed under union, intersection, complementation and projection. Furthermore, the boundary and closure of a semialgebraic set is again a semialgebraic set. Semialgebraic sets are the natural generalization of algebraic sets (zeros of polynomials) in such a way to make them be closed under projection.

This implementation is based on the Cylindrical Algebraic Decomposition process. Each SemialgebraicSet is made of the union of SemialgebraicCells (or SemialgebraicIntervals in R^1). For more details on the implementation of semialgebraic sets, refer to the comment of class CylindricalAlgebraicDecomposition.

Some examples of semialgebraic sets are:
	open unitary circle in R^2:
		SemialgebraicSet circle.
	unitary circunference in R^2:
		SemialgebraicSet circunference.
!

!SimplicialComplex commentStamp: '<historical>' prior: 0!
My instances are abstract simplicial complexes. These are combinatorial objects consisting of a collection of simplices (the 'faces' of the simplicial complex) with the following properties:
- every face of a simplex is also in the complex;
- the intersection of two simplices is either empty or a common face of both simplices.

Also can be seen as a subset of the power set of some set V, often V={1,...,n}, closed under inclusion.!

!Morphism commentStamp: '<historical>' prior: 0!
I'm an abstract superclass for functions and other morphisms.

Examples (three equivalent ways to construct a homomorphism):
	QQ**3 to: QQ**3 evaluating: [:v| (v x - v y, v x, v z)].
	QQ**3 -> (QQ**3) evaluating: [:v| (v x - v y, v x, v z)].
	(QQ**3) endomorphisms evaluating: [:v| (v x - v y, v x, v z)].

References:
	https://en.wikipedia.org/wiki/Morphism
!

!Function commentStamp: 'len 10/10/2016 16:26' prior: 0!
My instances are functions, i.e. maps from a mathematical structure (domain) to another structure (codomain). Evaluated at elements of the domain (>>#value:) they produce elements of the codomain. See Domain.

In general a Function is a morphism of sets. If the function preserves some mathematical structure, it is called a morphism of some category corresponding to the preserved structure. For example linear maps are morphisms of vector spaces, continuous functions are morphisms of topological spaces, and group homomorphisms are morphisms of groups.

Example:
	Function from: ZZ to: ZZ evaluating: [:x| x squared + 1].

Examples (three equivalent ways to construct homomorphisms):
	"These constructions are similar to the explicit construction above, but they actually return homomorphisms of the corresponding category, not arbitrary functions (in this case LinearMaps, morphisms of vector spaces):"
	QQ**3 to: QQ**3 evaluating: [:v| (v x - v y, v x, v z)].
	QQ**3 -> (QQ**3) evaluating: [:v| (v x - v y, v x, v z)].
	(QQ**3) endomorphisms evaluating: [:v| (v x - v y, v x, v z)].

In general, functions are defined by a domain, a codomain, and an expression that can be evaluated at elements of the domain and answers elements of the codomain. One such expression can be a Smalltalk block, another Function, or in general any Smalltalk object that admits evaluation, such as polynomials:

Examples (two ways to define the Frobenius endomorphism):
	(ZZ mod: 6) endomorphisms evaluating: [:x| x**6].
	(ZZ mod: 6) endomorphisms evaluating: (ZZ mod: 6) polynomials x ** 6.

Note that functions defined by polynomials or other symbolic expressions, as opposed to functions defined by Smalltalk blocks, are printed more explicitly (as a formula).

References:
	https://en.wikipedia.org/wiki/Function_(set_theory)
	https://en.wikipedia.org/wiki/Morphism
!

!LinearMap commentStamp: '<historical>' prior: 0!
My instances are linear transformations between spaces of finite dimension, i.e. morphisms of vector spaces or free modules.

Example:
	| V S |
	V _ QQ ** 3.
	S _ V span: {(1, 1, 1). (2, 0, -2)}.
	LinearMap projectionOn: S.
!

!LinearForm commentStamp: '<historical>' prior: 0!
My instances are linear forms (linear functionals, one-forms, covectors), i.e. linear maps from a vector space to the field of scalars.

All the linear forms on a vector space form the dual vector space (see DualSpace).!

!GroupAction commentStamp: '<historical>' prior: 0!
My instances are (left) group actions.

Given a group G and a set X, a (left) group action phi:GxX -> X is a function that satisfies:
- Identity: phi(id,x) = x;
- Compatibility: phi(g, phi(h,x)) = phi(g*h, x).

The group G is said to 'act' on X (on the left). The set X is called a (left) G-set (or G-space, G-module, depending on the category of X). Here we just call it 'space'.

References:
	https://en.wikipedia.org/wiki/Group_action!

!GroupHomomorphism commentStamp: '<historical>' prior: 0!
My instances are morphisms of groups.!

!Conjugation commentStamp: '<historical>' prior: 0!
My instances are group homomorphisms defined as conjugation by a given element.!

!GroupRepresentation commentStamp: '<historical>' prior: 0!
Given a group and an object X, a group representation is a group homomorphism from G to the automorphisms group Aut(X). X is called the representation space. Informally speaking, a representation allows us to view a group as symmetries of an object.

For example, a linear representation of a group G on a vector space V is a group homomorphism G -> GL(V). A permutation representation of G on a set X is a group homomorphism G -> Sym(X). 
Any group action can be seen as a permutation representation. In turn, any representation phi has an associated action on the representation space that maps (g,x) -> phi(g)(x).

References:
	https://en.wikipedia.org/wiki/Group_representation!

!Permutation commentStamp: '<historical>' prior: 0!
My instances are bijective functions from a domain to itself. Permutations under composition form groups (see PermutationGroup).!

!PermutationCycle commentStamp: '<historical>' prior: 0!
My instances are cycles. See Permutation>>cyclesDo:.
!

!StandardPermutation commentStamp: '<historical>' prior: 0!
My instances are permutations whose domain is the set {1,2,...,n} for somo natural number n. They are more efficient than arbitrary permutations, and often it's worth to convert a permutation to a standard form (by choosing an ordering of its domain) before computing with it (see Permutation>>asStandard:).!

!BilinearForm commentStamp: '<historical>' prior: 0!
My instances are bilinear forms, i.e. functions from VxV to F where V is a vector space over the field F that satisfy:
	B(v+cv`, w) = B(v, w) + cB(v`, w)
	B(v, w+cw`) = B(v, w) + cB(v, w`)
!

!Sequence commentStamp: '<historical>' prior: 0!
My instances are functions with domain the natural numbers (1,2,...). They can be evaluated at an index (#value: and #at:), and can also be iterated over like collections (#do:, #collect:, #select, etc).

Examples:
	Sequence fibonacci.
	Sequence primes.

Each sequence has an associated generating series, which is the formal power series whose coefficients are the sequence (see PowerSeries):
	Sequence fibonacci generatingSeries
and Dirichlet series (see DirichletSeries):
	Sequence fibonacci dirichletSeries
!

!LinearRecursiveSequence commentStamp: '<historical>' prior: 0!
My instances are constant-recursive (or C-recursive or C-finite) sequences, i.e. sequences satisfying homogeneous linear recurrences with constant coefficients:
	a(n) = c_1 a(n-1) + ... + c_d a(n-d)

These sequences are closed under:
- addition a(n)+b(n)
- (Hadamard or termwise) multiplication a(n)*b(n)
- convolution (Cauchy multiplication)
- interlacing {a(1),b(1),a(2),b(2),...}
- scalar multiplication a(n)*c
- (left) shift a(n+k), k>0
- indefinite sumation a(1)+a(2)+...+a(n)
- multisection a(mn+r), 0 <= r < m.

Power series whose coefficients are linear recursive sequences are closed under:
- addition
- multiplication
- derivation

Example:
	LinearRecursiveSequence fibonacci.
	LinearRecursiveSequence fibonacci generatingFunction

Example:
	| f |
	f _ LinearRecursiveSequence fibonacci * LinearRecursiveSequence pellNumbers.
	f minimalPolynomial
!

!AffineMap commentStamp: '<historical>' prior: 0!
My instances are affine transformations (affine maps or affinities), i.e. morphisms of affine spaces.

References:
	https://en.wikipedia.org/wiki/Affine_transformation!

!ProjectiveMap commentStamp: '<historical>' prior: 0!
My instances are projective transformations from a projective space P(V) to another P(W). These transformations map points to points and lines to lines, etc, preserving incidence. Projective transformation, projective collineation and homography are synonyms.!

!PolynomialFunction commentStamp: '<historical>' prior: 0!
My instances are polynomial functions on an algebraic variety.!

!PolynomialMap commentStamp: '<historical>' prior: 0!
My instances are polynomial maps between algebraic varieties.!

!RationalMap commentStamp: '<historical>' prior: 0!
My instances are rational maps between algebraic varieties.!

!RealRootFunction commentStamp: '<historical>' prior: 0!
My instances are defined by an integer index and a set of rational multivariate polynomials. 

The RealRootFunction with index k and polynomial f in n+1 indeterminates represents the continuous real function going from a connected subset of R^n (a semialgebraic set) to R and whose value at (a1,...,an) is the k-th real root of f(a1,...,an, x) as univariate polynomial in x.

A RealRootFunction with two or more defining polynomials is equivalent to the one defined by the product of all the polynomials.!

!ChainMap commentStamp: '<historical>' prior: 0!
A chain map between two chain complexes (Ci,di) and (C`i,d`i) is a sequence of homomorphisms fi:Ci->C`i that commutes with the boundary operator in the two complexes: d`i @ fi = f{i-1} @ di. They send cycles to cycles and boundaries to boundaries, and this descends to a map in homology fi* : Hi -> H`i.

Chain maps are morphisms in the category of chain complexes.!

!Identity commentStamp: '<historical>' prior: 0!
My instances are identity morphisms.!

!GroupRandomGenerator commentStamp: '<historical>' prior: 0!
I am the Product Replacement Algorithm for generating random elements in a group from a set of generators. Essentially, it performs a random walk on a Cayley graph.!

!FormalFraction commentStamp: '<historical>' prior: 0!
My instances are elements of a fraction field, i.e. fractions with numerator and denominator in a given integral domain. See class FractionField.!

!RationalFunction commentStamp: '<historical>' prior: 0!
My instances are rational functions, i.e. fractions where the numerator and denominator are polynomials.

For examples see RationalFunctions.!

!FormalSum commentStamp: '<historical>' prior: 0!
My instances are formal linear combinations of arbitrary objects.!

!FreePolynomial commentStamp: '<historical>' prior: 0!
My instances are elements of the free algebra in a finite set of objects.

A free polynomial is a formal linear combination of words, that in turn are formal (non-commutative) products of arbitrary objects.!

!SimplicialChain commentStamp: '<historical>' prior: 0!
A simplicial k-chain is a formal linear combination of k-simplices.!

!Quaternion commentStamp: 'len 11/20/2015 00:39' prior: 0!
My instances are quaternions. Quaternions constitute an example of non-commutative field.
!

!Residue commentStamp: '<historical>' prior: 0!
My instances are elements of a quotient ring, i.e. residue classes modulo an ideal. See QuotientRing and ResidueField.!

!Word commentStamp: '<historical>' prior: 0!
A word is a (non-commutative) formal product of a finite ordered list of objects.!

!LinearEquation commentStamp: '<historical>' prior: 0!
My instances are linear equations, i.e. expressions of the form
	f(v) = b,
where the left side is a LinearForm and the right side is a constant value.
!

!LinearSystem commentStamp: '<historical>' prior: 0!
My instances are systems of linear equations.!

!GramSchmidt commentStamp: '<historical>' prior: 0!
I am the Modified (stabilized) Gram-Schmidt basis orthogonalization algorithm.

Input: a basis B = {v_1, ..., v_n} of m-tuples;
Output: another basis, namely B' = {v_1', ..., v_n'} generating the same subspace and satisfying:
	o. v_1' = v_1;
	o. v_i' is the orthogonal projection of v_i onto the space generated by the first i-1 vectors.
Furthermore, the algorithm computes a lower triangular matrix, M, such that:
	B = B'^t M.

The algorithm performs O(2mn^2) arithmetic operations.

Example:
	| V basis |
	V _ Rationals new ** 3.
	basis _ LinearBasis generators: {(1, 1, 0). (0, 1, 1). (1, 0, 1)} on: V.
	(GramSchmidt basis: basis) orthogonalBasis
!

!GaussBareiss commentStamp: '<historical>' prior: 0!
I am the Gauss-Bereiss algorithm.

My instances perform division-free Gaussian elimination on a matrix with coefficients in a ring, and compute the echelon form.

Input: a matrix with coefficients in a commutative ring;
Output: the reduced echelon form and the determinant.

The algorithm performs O(n^3) ring operations for nxn matrices. While the standard Gaussian elimination suffers from exponential intermediate coefficients growth, the Bareiss algorithm has bit complexity O(n^5).
!

!GaussianElimination commentStamp: '<historical>' prior: 0!
I am the Gaussian Elimination algorithm.

My instances perform Gaussian reduction on the matrix to compute echelon form, linear dependency of the columns, rank, determinant, inverse matrix, etc.

Input: a matrix with coefficients in a field;
Output: the reduced echelon form of the matrix, determinant and left inverse.

The algorithm performs O(2n^3/3) field operations for nxn matrices, but due to exponential growth of intermediate coefficients it can be impractical in many situations (like with rational coefficients).!

!QRDecomposition commentStamp: '<historical>' prior: 0!
My instances are QR factorizations of a given real or complex matrix A, such that A = Q*R where Q is unitary (orthogonal) and R is upper triangular. Morover, if A is nonsingular, the diagonal of R may be taken to be positive, in which case the factorization is unique.!

!Monomial commentStamp: '<historical>' prior: 0!
My instances are (commutative) power products of one or many variables. They form a monoid (see Monomials). Also, their formal linear combinations over a ring are Polynomials.!

!MonomialOrdering commentStamp: '<historical>' prior: 0!
My instances are monomial orderings.
!

!LexicographicOrdering commentStamp: '<historical>' prior: 0!
The lexicographic ordering is the 'dictionary' ordering.

The lexicographic ordering has the property that for each subring S[x1..xn] <= R, and each polynomial f in R, f is in S iff its leading monomial is in S.

Elimination by the lexicographic ordering produces elements of an ideal which are free of the first variable.!

!TotalLexicographicOrdering commentStamp: '<historical>' prior: 0!
The total (or graded) lexicographic ordering first compares the total degree of the monomials, and takes the monomial with largest total degree. If two monomials have the same total degree, the lexicographic ordering is used to break the tie.

The total lexicographic ordering has the property that for each subring S[x1..xn] <= R, and each homogeneous polynomial f in R, f is in S iff its leading monomial is in S.

Elimination by the total lexicographic ordering produces elements of an homogeneous ideal which are free of the first variable.!

!TotalReverseLexicographicOrdering commentStamp: '<historical>' prior: 0!
The total (or graded) reverse lexicographic ordering first compares the total degree of the monomials, and takes the monomial with largest total degree. If two monomials have the same total degree, the reverse lexicographic ordering is used to break the tie (this is the lexicographic ordering on the reversed list of indeterminates (xn, ..., x1).

The total reverse lexicographic ordering has the property that for each subring S[x1..xn] <= R, and each homogeneous polynomial f in S[x1..xi], xi divides f iff it divides the leading monomial.

Elimination by the total reverse lexicographic ordering produces elements of a homogeneous ideal which are divisible by the last variable.!

!WeightedMonomialOrdering commentStamp: '<historical>' prior: 0!
My instances are monomial orderings defined by weight tuples.

For monomials in n variables, there are n!! (n factorial) orderings. In certain applications such as Groebner bases it's desirable to easily construct new monomial orderings.

ideterminates 		an array with the indeterminates (variables) in order;
weights 				n-tuples with real coefficients.

Suppose you have two monomials:
	a = x1^a1 x2^a2 ... xn^an
	b = x1^b1 x2^b2 ... xn^bn
where some of the ai or bi may be 0. And suppose the variables are ordered x1 < x2 < ... < xn. If we are asked for the truth of a < b, we enumerate the weights and for each one, (w1, w2, ..., wn) we do:
	aSum = a1 w1 + a2 w2 + ... + an wn,
	bSum = b1 w1 + b2 w2 + ... + bn wn;
if aSum < bSum, then a < b; if aSum > bSum, then a > b; if aSum = bSum, we continue with the next weight, until there are no more weights (then, a should equal b...).

Theorem: For any monomial ordering in a finite number of variables, there is a collection of weights that models the ordering. So, with this idea we can contruct any ordering.
!

!Polynomial commentStamp: '<historical>' prior: 0!
My instances are polynomials in one or many indeterminates, with coefficients in a commutative ring.

Subclasses implement particular representations, such as dense univariate polynomials (represented as arrays of coefficients) or sparse polynomials (representad as dictionaries monomial -> coefficient).

For examples, see PolynomialRing.
!

!MultivariatePolynomial commentStamp: '<historical>' prior: 0!
My instances are polynomials in sparse representation. The coefficients of a sparse polynomial are stored as a SparseTuple indexed by monomials.!

!UnivariatePolynomial commentStamp: '<historical>' prior: 0!
My instances are univariate polynomials in dense representation. The coefficients of a dense polynomial are stored as a Tuple indexed by degree.!

!MultiPolynomialDivision commentStamp: '<historical>' prior: 0!
I am the multivariate polynomial division algorithm for polynomials over a field.

Input: dividend and divisors f,f1,..,fs in K[x1..xd], and a monomial ordering;
Output: quotient and remander polynomials q1..qs,r in K[x1..xd] such that f = q1*f1 + ... + qn*fn + r, such that:
1. LM(qifi) <= LM(f);
2. None of the monomials in r is divisible by any LM(fi).

The algorithm performs O(n^d m^d) operations in the coefficients field K, where n is the total degree of f and m is the maximal total degree of f1..fs.!

!PolynomialDivision commentStamp: '<historical>' prior: 0!
I am the long division algorithm for univariate polynomials over a field.

Input: dividend and divisor polynomials f,g in K[x], where K is a field;
Output: quotient and remander polynomials q,r in K[x] such that f = q*g + r, deg(r) < deg(g).

The algorithm performs O(n^2) arithmetic operations for dense polynomials of degree n.!

!NumericComplexRootFinder commentStamp: '<historical>' prior: 0!
My instances separate complex roots of polynomials with real or complex coefficients. This is Newton's modified algorithm [1], and the convergence is quadratic. The polynomial is assumed to be squarefree.

Input: a square-free polynomial of degree n with real or complex coefficients, and a desired minimum absolute error (tolerance);
Output: a collection of the n complex roots of the polynomial.

[1] "A Course In Computational Algebraic Number Theory", Cohen, Algorithm 3.6.6.!

!AlgebraicNumber commentStamp: '<historical>' prior: 0!
My instances are complex algebraic numbers, i.e. zeroes of polynomials with integer coefficients.

Structure:
 polynomial		Polynomial -- a square-free polynomial that is zero at the receiver
 irreducible	Boolean -- true if the polynomial is the minimal polynomial
 approximation	Fraction/Float -- a rational approximation of the receiver
 radius			Fraction/Float -- the absolute error of the approximation, and it's guaranteed that the polynomial has no other roots around the approximation value within this radius

!

!DirichletSeries commentStamp: '<historical>' prior: 0!
My instances are formal Dirichlet series, i.e. formal series in an indeterminate x of the form: sum a(n) * n^{-x} for n >= 1.

Examples:
	DirichletSeries coefficients: Sequence moebius.
	Sequence liouville dirichletSeries.

Structure:
 coefficients	Sequence -- the coefficients of the Dirichlet series
!

!PowerSeries commentStamp: '<historical>' prior: 0!
My instances are formal power series.

Examples:
	PowerSeries coefficients: Sequence fibonacci.
	Sequence fibonacci generatingSeries.
	PowerSeries cos squared + PowerSeries sin squared.

Structure:
 coefficients	Sequence -- the coefficients of the power series
!

!LLL commentStamp: '<historical>' prior: 0!
I am the Lenstra-Lenstra-Lovasz algorithm.

Input: integer lattice of dimension d given by a basis {b1, ..., bd};
Output: an almost H-reduced basis of the lattice.

The algorithm takes at most O(d^6 ln^3(B)), where the input vectors bi all satisfy |bi|^2 <= B. In practice however, this upper bound is quite pessimistic.
!

!GraphNode commentStamp: '<historical>' prior: 0!
GraphNode is an abstract class of nodes that are held in a graph.

Each node holds on to a corresponding object that is the value of that node.

Subclasses add state/behaviour to represent edges in the graph.!

!ExplicitGraphNode commentStamp: '<historical>' prior: 0!
An ExplicitGraphNode stores the edges in a collection, an instance variable. The type of the collection varies as to whether the graph is ordered, of fixed arity, etc.

To change the edge collection, addNeighbor: and removeNeighbor: messages are supplied.
!

!LabeledExplicitGraphNode commentStamp: '<historical>' prior: 0!
A LabeledExplicitGraphNode associates a label with each neighbor, and a label with the node itself; i.e. nodes and edges are labeled.

When adding neighbors, the edge label must be given.!

!ImplicitGraphNode commentStamp: '<historical>' prior: 0!
An ImplicitGraphNode has the edge structure represented within the value, and therefore forwards messages to the value to access edges.

To change the edge collection, you must send messages to the value.

Subclasses decide as to whether the value can yield a collection of edges more efficiently than iterating over them.!

!ImplicitGraphNodeCollection commentStamp: '<historical>' prior: 0!
I access the collection of edges by evaluating my block.!

!ImplicitGraphNodeIterator commentStamp: '<historical>' prior: 0!
I can iterate over the collection of edges by evaluating the iterator.!

!DAGFrontier commentStamp: '<historical>' prior: 0!
A DAGFrontier is used to iterate a directed acyclic graph (DAG) respecting the dependencies between nodes.  A client does not create it directly, but sends the message "frontier" to the DAG in question.

At any moment it holds a "frontier" of nodes that can be accessed.  When any node in the frontier has been processed, it can be removed from the frontier, and the frontier will be updated if necessary (in situ).

Instance variables:
frontier		<Set> of nodes on the frontier, empty if the whole DAG has been enumerated.
bag		<Bag> of nodes, used to calculate updates to the frontier.

Clients of this class must *not* modify the frontier set, only access it.
!

!Dijkstra commentStamp: '<historical>' prior: 0!
I am Dijkstra's algorithm for computing distances and shortest paths in a graph from a fixed starting node (source). If the graph is edge-labeled, the labels are used as weights.

Pre-Input: a graph G = (V, E), and a node (source);
Input: a target node;
Output: the shortest distance from the source node to the target node, or a shortest path.

The initial precomputation takes time O(|V|^2). Afterwards, it's possible to compute disntances in time O(log |V|) and shortest paths of length k in O(k log |V|). The O(log |V|) comes from the dictionary lookup operation, a lookup in a hash table.!

!FloydWarshall commentStamp: '<historical>' prior: 0!
I am the Floyd-Warshall algorithm for solving the all-pairs shortest path problem (for weighted graphs). I compute distances and shortest paths in a graph. If the graph is edge-labeled, the labels are used as weights.

Pre-Input: a graph G = (V, E);
Input: a pair of nodes (source and target);
Output: the shortest distance from the source node to the target node, or a shortest path.

The initial precomputation takes time O(|V|^3). Afterwards, it's possible to compute distances in time O(log |V|) and shortest paths of length k in O(k log |V|). The O(log |V|) comes from the dictionary lookup operation, a lookup in a hash table.

While (after initial precomputation) Dijkstra's algorithm is able to efficiently compute distances from a fixed source node, Floyd-Warshall's computes distances from any two arbitrary nodes. However, for sparse graphs with non-negative edge weights a better choice is to use Dijkstra's algorithm with binary heaps, which gives a time complexity of O(|V| |E| log |V|).!

!PolynomialSystem commentStamp: '<historical>' prior: 0!
My instances represent systems of polynomial equations.

Example:
	| Qxy x y |
	Qxy _ Rationals new polynomialsIn: #(x y).
	x _ Qxy x.
	y _ Qxy y.
	PolynomialSystem new
		add: (x*x eq: 1);
		add: (y*y - (x*x) eq: 3);
		yourself
!

!CylindricalAlgebraicDecomposition commentStamp: '<historical>' prior: 0!
My instances decompose R^n into connected components (SemialgebraicCells) such that a given set of polynomials keeps sign-invariant over each of the components. This decomposition is called Cylindrical Algebraic Decomposition (CAD), and what is obtainded is called a Cell Complex of R^n. Each of the components is a SemialgebraicCell (or SemialgebraicInterval in R^1).

The univariate case is easy. Suppose we have to find the CAD of R with respect to the polynomial set {f1, ..., fn}. Then we find all the real roots of f1, ..., fn, a1 < a2 < ... < am, and the CAD we were looking for is:
	[-infinity, a1), [a1, a1], (a1, a2), [a2, a2], (a2, a3), ... [am, am], (am, +infinity].
All this can be effectively computed when using Sturm theory when the polynomials have rational coefficients. See the comments in AlgebraicNumber and AlgebraicPolynomialRootFinder. Each component can be asked for a sample point in it, and the sample points can be constructed in this way:
	the sample point of [-infinity, a1) is a1 - 1;
	the sample point of (am, +infinity] is am + 1;
	the sampel point of [ai, ai] is ai;
	and the sample point of (ai, a{i+1}) is ai + a{i+1} / 2 (the middle).

An example: decide wether the sentence x^2 + 1 > 0 is true or false. First we find the CAD of R with respect to {x^2 + 1}. The roots of x^2 + 1 are -1 and 1, so the CAD is
	[-infinity, -1), [-1, -1], (-1, 1), [1, 1] and (1, +infinity]
and the respective sample points are
	-2, -1, 0, 1 and 2.
We know that the polynomial x^2 + 1 is sign invariant over each of the components of the CAD, so if it's positive in all the components, it's positive over all R. So we evaluate x^2 + 1 at each of the sample points and check that it's positive, and then we can conclude that the sentence is true.

The construction of the CAD in the multivariate case is performed inductively. Suppose we want the CAD of R^k with respect to the set of real polynomials F = {f1, ..., fn} in k indeterminates. Then we produce another set of polynomials Phi(F) = {g1, ..., gm} in k-1 indeterminates that have some nice properties that makes this construction valid (for more information on this see Algorithmic Algebra, B. Mishra, Springer-Verlag, 1993). Now we inductively compute K', the CAD of R^{k-1} with respect to Phi(F), and name the components C1, ... Ct. Each component can be asked for a sample point in it. Let f = f1 f2 ... fn (the product of the polynomials in F). Furthermore, we define the functions zj:R^{k-1} -> R to be at the point (a1, ..., a{k-1}) the j-th root of f(a1, ..., a{k-1}, x) as univariate polynomial in x. Phi(F) is defined in such a way to make the number of roots of f be invariant over each C in K', and to make each zj to be a continuous function over each C in K'. Finally we can construct K, the CAD of R^k. Each cell in K will be of two kinds:
	1. For each cell C in K', C x [-infinity, +infinity].
	2. For each cell C in K', suppose the number of roots of f are r. Then we have the following cells:
		C0* = {(p, x) | x < z1(p), p in C}
		C1 = {(p, x) | x = z1(p), p in C}
		C1* = {(p, x) | z1(p < x < z2(p), p in C}
		C2 = {(p, x) | x = z2(p), p in C}
			...
		Cm = {(p, x) | x = zm(p), p in C}
		Cm* = {(p, x) | zm(p) < x, p in C}.
Sample points for each of the cells constructed can be easyly computed.

Finally, we cite the Collin's Theorem. Given a finite set of multivariate polynomials F in Q[x1,...,xn] we can effectively construct the followings:
- A F-sign-invariat cylindrical algebraic decomposition K of R^n into semialgebraic connected cells. Each cell C in K is homeomorphic to R^d for some 0 <= d <= n;
- A sample algebraic point in each cell in K and defining polynomials for each sample point;
- Quantifier-free defining sentences for each cell C in K.

!

!SemialgebraicCell commentStamp: '<historical>' prior: 0!
My instances are components of a cell complex of R^n, where n>1. For the case n=1 SemialgebraicInterval is used. (See the comments in the class SemialgebraicSet and CylindricalAlgebraicDecomposition).

Each SemialgebraicCell in R^n is represented as the extension of a SemialgebraicCell or SemialgebraicInterval in R^{n-1}.
!

!BooleanConnective commentStamp: '<historical>' prior: 0!
I am an abstract superclass for boolean connectives that are employed in the building of Tarski sentences. My concrete subclases are ConjunctionConnective (AND), DisjunctionConnective (OR) and ImplicationConective.
!

!ConjunctionConnective commentStamp: 'len 5/31/2016 05:54' prior: 0!
My instances are conjunctions of two Tarski sentences.

For an example try this:
	| Fxy x y |
	Fxy _ Rationals new polynomialsIn: #(x y).
	x _ Fxy x.
	y _ Fxy y.
	ConjunctionConnective left: (x squared + y squared gneq: 1) right: (x eq: 1).
!

!DisjunctionConnective commentStamp: '<historical>' prior: 0!
My instances are disjunctions of two Tarski sentences.

For an example try this:
	| Fxy x y |
	Fxy _ Rationals new polynomialsIn: #(x y).
	x _ Fxy x.
	y _ Fxy y.
	DisjunctionConnective
		left: (x squared + y squared lneq: 1) right: (x squared + y squared eq: 1).
!

!ImplicationConnective commentStamp: '<historical>' prior: 0!
My instances are implications whose predicate and conclusion are Tarski sentences.

For an example try this:
	| Fxy x y |
	Fxy _ Rationals new polynomialsIn: #(x y).
	x _ Fxy x.
	y _ Fxy y.
	ImplicationConnective left: (x squared + y squared eq: 0) right: (x eq: 0).
!

!PolynomialEquation commentStamp: '<historical>' prior: 0!
My instances are polynomial equations.

For an example try:
	| Fxy x y |
	Fxy _ Rationals new polynomialsIn: #(x y).
	x _ Fxy x.
	y _ Fxy y.
	PolynomialEquation polynomial: x*x + (y*y) - 1.

which is equivalent to:
	| Fxy x y |
	Fxy _ Rationals new polynomialsIn: #(x y).
	x _ Fxy x.
	y _ Fxy y.
	x*x + (y*y) eq: 1.
!

!PolynomialInequality commentStamp: '<historical>' prior: 0!
My instances are polynomial inequalities.

For an example try:
	| Fxy x y |
	Fxy _ Rationals new polynomialsIn: #(x y).
	x _ Fxy x.
	y _ Fxy y.
	PolynomialInequality polynomial: x*x + (y*y) - 1.

which is equivalent to:
	| Fxy x y |
	Fxy _ Rationals new polynomialsIn: #(x y).
	x _ Fxy x.
	y _ Fxy y.
	x*x + (y*y) lneq: 1.
!

!QuantifiedSentence commentStamp: '<historical>' prior: 0!
My instances are Tarski sentences represented by a list of quantifiers (prefix) and by the sentence subject of the quantification (matrix).

For an example try this:
	| Qxy x y |
	Qxy _ Rationals new polynomialsIn: #(x y).
	x _ Qxy x.
	y _ Qxy y.
	(QuantifiedSentence matrix: (y squared gneq: x))
		add: (ExistentialQuantifier indeterminate: 1);
		add: (UniversalQuantifier indeterminate: 2);
		yourself.

Tarski sentences can be tested for truth (just sending the message #truth). The algorithm uses the mechinery of Cylindrical Algebraic Decomposition (CAD) of R^n and Semialgebraic Sets. and has a very bad time complexity, but it's useful in small examples.
!

!Quantifier commentStamp: '<historical>' prior: 0!
I am an abstract superclass for real quantifiers that are employed in the building of Tarski sentences. My concrete subclases are UniversalQuantifier and ExistentialQuantifier.
!

!ExistentialQuantifier commentStamp: '<historical>' prior: 0!
My instances are existential quantifiers in one indeterminate.

For an example try:
	ExistentialQuantifier indeterminate: 3.
!

!UniversalQuantifier commentStamp: '<historical>' prior: 0!
My instances are universal quantifiers in one indeterminate.

For an example try:
	UniversalQuantifier indeterminate: 3.
!

!Simplex commentStamp: '<historical>' prior: 0!
My instances are (abstract) n-simplices.!

!BerlekampMassey commentStamp: '<historical>' prior: 0!
I am the Berlekamp-Massey algorithm. The initial purpose of this algorithm was to evaluate Binary BCH codes, but it has found many uses, including inverting matrices of constant diagonal, solving linear recurrences (synthesizing LFSRs with a specified output sequence), etc.

Input: a_1..a_{2n} the first 2n coefficients of a linear recursive sequence over a field K of order at most n (the minimal polynomial has degree bound n);
Output: the minimal polynomial of the sequence.

The algorithm performs O(n^2/2) multiplications; more precisely, at most 2 floor(n^2/4) - n + 1 multiplications.!

!CRT commentStamp: '<historical>' prior: 0!
I am the Chinese Remainder Theorem. My instances find solutions to systems of linear Diophantine equations x = x_i (mod m_i). The algorithm works on any Euclidean domain.

Input: x_1...x_k, k elements in an Euclidean domain, and m_1,...,m_k pairwise coprime, defining the Diophantine system x = x_i (mod m_i);
Output: x such that x = x_i (mod m_i) for 1<=i<=k.
!

!ExtendedEuclid commentStamp: 'len 3/21/2016 03:16' prior: 0!
I am the Euclid's extended algorithm.

Input: an array of two elements in an Euclidean domain {a. b}
Output: the GCD of a with b, and {u. v} such that a*u + b*v = (a,b).

In the case of integers, if |a|<=|b| the output |u| and |v| are unique and satisfy:
	-|a| / d < v*sign(b) <= 0.
	1 <= u*sign(a) <= |b| / d
where d = gcd(a,b).

For integers, the algorithm takes time O(ln^3 N) where |a|,|b| <= N. For polynomials of degree n, it is O(n^3).!

!LagrangeGaussReduction commentStamp: '<historical>' prior: 0!
I am the Lagrange-Gauss reduction algorithm. My instances perform reduction of lattice basis of rank 2, and the algorithm it is essentially Euclid's algorithm.

Input: a vector space V and two independent vectors {v1,v2} that generate a lattice;
Output: a short vector in the lattice.
!

!ModifiedBerlekampMassey commentStamp: '<historical>' prior: 0!
I am a modified [1] Berlekamp-Massey algorithm. This modified version admits lazy evaluation.

Input: a_1..a_{2n} the first 2n coefficients of a linear recursive sequence over a field K of order at most n (the minimal polynomial has degree bound n);
Output: the minimal polynomial of the sequence.

[1] 'The Berlekamp-Massey Algorithm revisited', Nadie Ben Atti, Gema M Diaz-Toca, Henri Lombardi.
!

!NTT commentStamp: '<historical>' prior: 0!
My instances are Number Theoretic Transforms, the analog of DFTs for the field of integers modulo a prime p. Special cases are the Fermat Number Transform (p = 2^k + 1) and the Mersenne Number Transform (p = 2^k - 1).

The (pseudo) number theoretic transform may be meaningful in the ring Z/<m> even when the modulo m is not prime, provided a principal root of order n exists.!

!WuRittProcess commentStamp: 'len 12/30/2015 05:43' prior: 0!
I'm the Ritt-Wu process.

Input: a set of polynomials F = {f1,...,fr} in K[x1,...,xn];
Output: an extended characteristic set (or ascending chain, or Wu characteristic set) of F.
!

!GaussianElimination2 commentStamp: '<historical>' prior: 0!
I am the Gaussian Elimination algorithm.

Given a matrix M with coefficients in a field, my instances perform Gaussian reduction on the matrix to compute linear dependency of the columns, rank, determinant, inverse matrix, etc.!

!Object methodsFor: '*mathematics' stamp: 'len 11/19/2015 17:01'!
isInfinity
	^ false! !

!Object methodsFor: '*mathematics' stamp: 'len 8/5/2016 21:51'!
isReal
	"Answer true if the receiver is a real number."
	^ false! !

!Number methodsFor: '*mathematics' stamp: 'len 11/19/2015 17:23'!
** aNumber
	^ self raisedTo: aNumber! !

!Number methodsFor: '*mathematics' stamp: 'len 11/19/2015 18:42'!
, anObject
	^ (Tuple withAll: {self}), anObject! !

!Number methodsFor: '*mathematics' stamp: 'len 11/19/2015 18:42'!
adaptToQuaternion: rcvr andSend: selector
	^ rcvr perform: selector with: self asQuaternion! !

!Number methodsFor: '*mathematics' stamp: 'len 11/19/2015 19:41'!
asQuaternion
	^ Quaternion a: self b: self zero c: self zero d: self zero! !

!Number methodsFor: '*mathematics' stamp: 'len 6/23/2016 23:27'!
conjugated
	"Answer the complex conjugate of the receiver."

	^ self! !

!Number methodsFor: '*mathematics' stamp: 'len 6/4/2016 21:55'!
imaginary
	^ 0! !

!Number methodsFor: '*mathematics' stamp: 'len 3/17/2016 03:40'!
isAlgebraic
	^ false! !

!Number methodsFor: '*mathematics' stamp: 'len 8/5/2016 21:44'!
isComplex
	^ true "real numbers are also complex numbers"! !

!Number methodsFor: '*mathematics' stamp: 'len 11/19/2015 17:20'!
isRational
	^ false! !

!Number methodsFor: '*mathematics' stamp: 'len 8/5/2016 21:44'!
isReal
	^ true! !

!Number methodsFor: '*mathematics' stamp: 'len 1/12/2016 03:18'!
norm
	^ self abs! !

!Number methodsFor: '*mathematics' stamp: 'len 1/13/2016 02:54'!
norm2
	^ self squared! !

!Number methodsFor: '*mathematics' stamp: 'len 11/19/2015 20:58'!
one
	^ 1! !

!Number methodsFor: '*mathematics' stamp: 'len 6/4/2016 21:54'!
real
	^ self! !

!Number methodsFor: '*mathematics' stamp: 'len 11/19/2015 20:58'!
zero
	^ 0! !

!Float methodsFor: '*mathematics' stamp: 'len 1/13/2016 03:55'!
adaptToAlgebraic: rcvr andSend: selector
	^ rcvr asComplexFloat perform: selector with: self asComplex! !

!Float methodsFor: '*mathematics' stamp: 'len 1/13/2016 03:52'!
adaptToRealAlgebraic: rcvr andSend: selector
	^ rcvr asFloat perform: selector with: self! !

!Float methodsFor: '*mathematics' stamp: 'len 2/25/2016 17:17'!
squareRoot
	^ self sqrt! !

!Fraction methodsFor: '*mathematics' stamp: 'len 1/13/2016 03:55'!
adaptToAlgebraic: rcvr andSend: selector
	^ rcvr perform: selector with: (AlgebraicNumber fromRational: self)! !

!Fraction methodsFor: '*mathematics' stamp: 'len 1/13/2016 03:55'!
adaptToRealAlgebraic: rcvr andSend: selector
	^ rcvr perform: selector with: (RealAlgebraicNumber fromRational: self)! !

!Fraction methodsFor: '*mathematics' stamp: 'len 2/10/2016 21:13'!
bitSize
	^ numerator bitSize + denominator bitSize! !

!Fraction methodsFor: '*mathematics' stamp: 'len 11/19/2015 17:20'!
isRational
	^ true! !

!Fraction methodsFor: '*mathematics' stamp: 'len 2/13/2016 06:13'!
squareRoot
	^ RealAlgebraicNumber sqrt: self! !

!Integer methodsFor: '*mathematics' stamp: 'len 3/30/2016 21:59'!
% anInteger
	^ ModularInteger representative: self \\ anInteger modulo: anInteger! !

!Integer methodsFor: '*mathematics' stamp: 'len 8/1/2016 08:54'!
| anInteger
	"Answer true if the receiver divides anInteger."
	^ self ~= 0 and: [anInteger \\ self = 0]! !

!Integer methodsFor: '*mathematics' stamp: 'len 12/4/2015 20:13'!
Stirling: anInteger
	"Answer the Stirling number of the second kind S(n,k).
	Stirling numbers of the second kind count the ways to partition a set of n things into k nonempty subsets."
	(anInteger > self or: [self < 0]) ifTrue: [^ DomainError signal].
	self = anInteger ifTrue: [^ 1].
	anInteger = 0 ifTrue: [^ 0].
	self+1 = anInteger ifTrue: [^ self take: 2].
	anInteger = 2 ifTrue: [^ 2 ** (self-1) - 1].
	^ anInteger*(self - 1 Stirling: anInteger) + (self - 1 Stirling: anInteger - 1)! !

!Integer methodsFor: '*mathematics' stamp: 'len 1/13/2016 03:56'!
adaptToAlgebraic: rcvr andSend: selector
	^ rcvr perform: selector with: (AlgebraicNumber fromRational: self)! !

!Integer methodsFor: '*mathematics' stamp: 'len 1/13/2016 03:56'!
adaptToRealAlgebraic: rcvr andSend: selector
	^ rcvr perform: selector with: (RealAlgebraicNumber fromRational: self)! !

!Integer methodsFor: '*mathematics' stamp: 'len 7/2/2016 05:45'!
bitCount
	"Answer the number of bits that are set, i.e. the number of 1s in the binary representation."
	| n |
	self = 0 ifTrue: [^ 0].
	self = 1 ifTrue: [^ 1].
	n _ self digitLength * 8. "this will always be >= 32, because SmallInteger implements bitCount"
	n _ n // 2.
	^ (self bitShift: n negated) bitCount + (self bitAnd: (1 bitShift: n) - 1) bitCount! !

!Integer methodsFor: '*mathematics' stamp: 'len 7/2/2016 05:43'!
bitParity
	"Answer 1 if there are an odd number of bits set, 0 otherwise."
	| n |
	self = 0 ifTrue: [^ 0].
	self = 1 ifTrue: [^ 1].
	n _ self digitLength * 8. "this will always be >= 32, because SmallInteger implements bitParity"
	n _ n // 2.
	^ ((self bitShift: n negated) bitXor: (self bitAnd: (1 bitShift: n) - 1)) bitParity! !

!Integer methodsFor: '*mathematics' stamp: 'len 7/2/2016 05:43'!
bitParity2
	"Answer 1 if there are an odd number of bits set, 0 otherwise."
	| i n |
	self = 0 ifTrue: [^ 0].
	self = 1 ifTrue: [^ 1].
	i _ self digitLength * 8. "this will always be >= 32, because SmallInteger implements bitParity"
	n _ self.
	[i _ i bitShift: -1.
	i > 30] whileTrue:
		[n _ n bitXor: (n bitShift: i negated)].
	^ (n bitAnd: (1 bitShift: i) - 1) bitParity! !

!Integer methodsFor: '*mathematics' stamp: 'len 7/1/2016 23:03'!
bitSize
	self negative ifTrue: [^ self negated highBit + 1].
	^ self highBit! !

!Integer methodsFor: '*mathematics' stamp: 'len 6/21/2016 04:18'!
choose: anInteger
	"Answer the binomial coefficient (self anInteger)"
	" 6 take: 3  "

	(anInteger < 0 or: [anInteger > self]) ifTrue: [^0].
	^(self - anInteger + 1 productTo: self) // anInteger factorial! !

!Integer methodsFor: '*mathematics' stamp: 'len 6/29/2016 06:40'!
choose: anInteger q: q
	"Answer the q-binomial coefficient of self with anInteger.
	This counts the number of 'anInteger'-dimensional subspaces of a vector space of dimension 'self' over a finite field of order 'q' (power of a prime)."

	(anInteger < 0 or: [anInteger > self]) ifTrue: [^0].
	^ ((0 to: anInteger - 1) inject: 1 into: [:x :i| 1 - (q**(self-i)) * x]) / ((1 to: anInteger) inject: 1 into: [:x :i| 1 - (q**i) * x])! !

!Integer methodsFor: '*mathematics' stamp: 'len 4/23/2016 19:35'!
count: aBlock
	| answer |
	answer _ 0.
	self timesRepeat: [aBlock value ifTrue: [answer _ answer + 1]].
	^ answer! !

!Integer methodsFor: '*mathematics' stamp: 'len 11/19/2015 18:29'!
denominator
	^ 1! !

!Integer methodsFor: '*mathematics' stamp: 'len 7/16/97 02:13'!
descendentPower: n
	"Answer the descendent power of the receiver raised to the argument."
	| mid |
	n = 0 ifTrue: [^ 1].
	n = 1 ifTrue: [^ self].
	n negative ifTrue: [^ (self descendentPower: n negated) reciprocal].
	mid _ n bitShift: -1.
	^ n even ifTrue: [
		(self - mid descendentPower: mid) * (self descendentPower: mid)
	] ifFalse: [
		(self - mid descendentPower: mid + 1) * (self descendentPower: mid)
	]! !

!Integer methodsFor: '*mathematics' stamp: 'len 6/27/2016 23:20'!
divisors
	"Answer the collection of positive divisors of the receiver including 1 and self."
	| answer |
	answer _ Set2 new.
	self divisorsDo: [:each| answer add: each].
	^ answer! !

!Integer methodsFor: '*mathematics' stamp: 'len 12/4/2015 23:25'!
divisorsDo: aBlock
	"Iterate over the positive divisors of the receiver, including 1 and self."
	| n |
	n _ self abs.
	1 to: (n bitShift: -2) + 1
		do: [:k| n \\ k = 0 ifTrue: [aBlock value: k; value: n // k]]! !

!Integer methodsFor: '*mathematics' stamp: 'len 7/27/2016 01:56'!
factors
	"Answer a collection with the prime factors of the receiver (with multiplicity)."
	| n p answer times |
	n _ self abs.
	answer _ Bag new.
	n <= 1 ifTrue: [^ answer].
	n even ifTrue:
		[answer add: 2 withOccurrences: (times _ n lowBit - 1).
		n _ n bitShift: times negated].

	p _ 3.
	[p <= n] whileTrue:
		[p isPrime ifTrue:
			[times _ 0.
			[n \\ p = 0] whileTrue: [times _ times + 1. n _ n // p].
			times > 0 ifTrue: [answer add: p withOccurrences: times]].
		p _ p + 2].

	^ answer! !

!Integer methodsFor: '*mathematics' stamp: 'len 11/24/97 20:45'!
factors2
	"Answer a collection with the prime factors of the receiver."

	| n p answer times |

	n _ self abs.
	n <= 1 ifTrue: [^ Bag new].
	answer _ Bag new.
	n even ifTrue: [
		answer add: 2 withOccurrences: (times _ n lowBit - 1).
		n _ n bitShift: times negated].

	p _ 3.
	[p <= (n // p)] whileTrue: [
		p isPrime ifTrue: [
			times _ 0.
			[n \\ p = 0] whileTrue: [times _ times + 1. n _ n // p].
			times > 0 ifTrue: [answer add: p withOccurrences: times]].
		p _ p + 2].
	(p = n or: [n = 1]) ifFalse: [answer add: n].
	^ answer! !

!Integer methodsFor: '*mathematics' stamp: 'len 11/19/2015 17:21'!
isRational
	^ true! !

!Integer methodsFor: '*mathematics' stamp: 'len 8/20/97 02:25'!
jacobi: m
	"Answer the Jacobi symbol of the receiver and the argument."

	| x y z answer |
	m odd ifFalse: [^ self error: 'the argument must by an odd positive integer'].
	(self gcd: m) = 1 ifFalse: [^ 0].
	x _ self \\ m.
	y _ m.
	answer _ 1.
	[x > 1] whileTrue: [
		[x \\ 4 = 0] whileTrue: [x _ x // 4].
		x \\ 2 = 0 ifTrue: [
			x _ x // 2.
			y + 2 \\ 8 > 4 ifTrue: [answer _ answer negated]
		].
		z _ y \\ x.
		y _ x.
		x _ z
	].
	^ answer! !

!Integer methodsFor: '*mathematics' stamp: 'len 8/20/97 02:26'!
jacobiOld: n
	"Answer the Jacoby symbol of the receiver and the argument."

	| a minusOne |
"	n odd ifFalse: [^ self error: 'the argument must by an odd positive integer']."
	a _ self \\ n.
	a = 2 ifTrue: [^ (n squared - 1) lowBit > 3 ifTrue: [1] ifFalse: [-1]].
	minusOne _ n - 1.
	a = minusOne ifTrue: [^ minusOne lowBit > 1 ifTrue: [1] ifFalse: [-1]].
	^ (a - 1 * minusOne) lowBit > 2
		ifTrue: [n jacobiOld: a] ifFalse: [(n jacobiOld: a) negated]! !

!Integer methodsFor: '*mathematics' stamp: 'len 4/10/2016 06:13'!
kronecker: anInteger
	| b v |
	self flag: #fix."todo"
	anInteger = 0 ifTrue: [^ self abs = 1 ifTrue: [1] ifFalse: [0]].
	(self even and: [anInteger even]) ifTrue: [^ 0].
	v _ anInteger lowBit - 1.
	b _ anInteger bitShift: v negated.
	"..."! !

!Integer methodsFor: '*mathematics' stamp: 'len 11/28/2015 07:08'!
moebius
	"Answer the Moebius function mu of the receiver."
	| factors |
	factors _ self factors.
	factors asSet size = factors size ifFalse: [^ 0].
	^ factors size even ifTrue: [1] ifFalse: [-1]! !

!Integer methodsFor: '*mathematics' stamp: 'len 12/13/2015 02:00'!
numberOfDivisors
	^ self primeSignature inject: 1 into: [:x :each| x * (each + 1)]! !

!Integer methodsFor: '*mathematics' stamp: 'len 11/19/2015 18:29'!
numerator
	^ self! !

!Integer methodsFor: '*mathematics' stamp: 'len 7/2/2016 20:55'!
partitions
	^ Iterator on: self performing: #partitionsDo:! !

!Integer methodsFor: '*mathematics' stamp: 'len 7/2/2016 20:57'!
partitionsDo: aBlock
	self < 0 ifTrue: [^ DomainError signal: 'negative number'].
	self = 0 ifTrue: [^ aBlock value: #()].
	self - 1 partitionsDo: [:each|
		aBlock value: #(1), each.
		(each size > 0 and: [each size < 2 or: [(each at: 2) > (each at: 1)]])
			ifTrue: [aBlock value: (each copy at: 1 put: (each at: 1) + 1; yourself)]]! !

!Integer methodsFor: '*mathematics' stamp: 'len 9/17/97 02:05'!
pollard
	"Answer a non trivial factor of the receiver.
	The Pollard method is used."

	| interval a x y p count |

	interval _ 1 to: self abs.
	a _ interval atRandom.
	x _ interval atRandom.
	y _ x.
	count _ 1.
	[x _ x squared + a \\ self.
	y _ (y squared + a \\ self) squared + a \\ self.
	(p _ y - x gcd: self) = 1
		ifFalse: [^ Array with: p with: count].
	count _ count + 1. true] whileTrue.! !

!Integer methodsFor: '*mathematics' stamp: 'len 12/13/2015 01:49'!
primeSignature
	| factors |
	factors _ self factors.
	^ (factors asSet asSortedCollection collect: [:each| factors occurrencesOf: each]) asArray! !

!Integer methodsFor: '*mathematics' stamp: 'len 3/23/2016 20:58'!
primitiveRoot
	"When the receiver is a prime p, answer a primitive root modulo p."
	| a order primeFactors |
	order _ self - 1.
	primeFactors _ order factors asSet.
	a _ 2.
	[primeFactors anySatisfy: [:pi| (a raisedTo: order / pi modulo: self) = 1]]
		whileTrue:
			[a _ a + 1.
			a >= self ifTrue: [self error: 'no primitive element, the modulo is not prime']].
	^ a! !

!Integer methodsFor: '*mathematics' stamp: 'len 2/13/2016 06:13'!
squareRoot
	^ RealAlgebraicNumber sqrt: self! !

!Integer methodsFor: '*mathematics' stamp: 'len 12/4/2015 20:04'!
stirling: anInteger
	"Answer the Stirling number of the first kind s(n,k).
	Stirling numbers of the first kind count the ways to arrange n objects into k cycles."
	(anInteger > self or: [self < 0]) ifTrue: [^ DomainError signal].
	anInteger = 1 ifTrue: [^ (self - 1) factorial].
	self = anInteger ifTrue: [^ self Stirling: anInteger].
	self+1 = anInteger ifTrue: [^ self take: 2].
	^ (self-1) * (self-1 stirling: anInteger) + (self-1 stirling: anInteger-1)! !

!SmallInteger methodsFor: '*mathematics' stamp: 'len 7/2/2016 05:40'!
bitCount
	| v count |
	v _ self.
	count _ 0.
	[v = 0] whileFalse: [v _ v bitAnd: v - 1. count _ count + 1].
	^ count
	
	"HACKMEM:
	| count |
	self flag: #fix.
	count _ self - ((self >> 1) bitAnd: 8r33333333333) - ((self >> 1) bitAnd: 8r11111111111).
	^ (count + (count >> 3) bitAnd: 8r30707070707) \\ 63
"
! !

!SmallInteger methodsFor: '*mathematics' stamp: 'len 7/2/2016 05:43'!
bitParity
	"Answer 1 if there are an odd number of bits set, 0 otherwise."
	| v parity |
	v _ self.
	parity _ 0.
	[v = 0] whileFalse: [parity _ parity bitXor: (v bitAnd: 1). v _ v bitShift: -1].
	^ parity

"	n _ self.
	n _ n bitXor: (n bitShift: -16).
	n _ n bitXor: (n bitShift: -8).
	n _ n bitXor: (n bitShift: -4).
	n _ n bitAnd: 16rF.
	^ (16r6996 bitShift: n negated) bitAnd: 1
"! !

!Complex methodsFor: '*mathematics' stamp: 'len 11/19/2015 17:24'!
** aNumber
	^ self raisedTo: aNumber! !

!Complex methodsFor: '*mathematics' stamp: 'len 8/5/2016 21:45'!
isReal
	^ self imaginary isZero! !

!Complex methodsFor: '*mathematics' stamp: 'len 3/3/2016 01:01'!
norm
	^ (real squared + imaginary squared) squareRoot! !

!Complex methodsFor: '*mathematics' stamp: 'len 1/11/2016 05:54'!
norm2
	^ real squared + imaginary squared! !

!Complex methodsFor: '*mathematics' stamp: 'len 12/26/2015 19:56'!
one
	^ self class real: real one imaginary: imaginary zero! !

!Complex methodsFor: '*mathematics' stamp: 'len 12/26/2015 19:56'!
zero
	^ self class real: real zero imaginary: imaginary zero! !

!BlockClosure methodsFor: '*mathematics' stamp: 'len 4/24/2016 06:00'!
count
	| count |
	count _ 0.
	self whileTrue: [count _ count + 1].
	^ count! !

!Collection methodsFor: '*mathematics' stamp: 'len 8/12/2016 21:17'!
< aCollection
	"Answer true if the receiver is a proper subcollection of aCollection."
	^ self <= aCollection and: [self size < aCollection size]! !

!Collection methodsFor: '*mathematics' stamp: 'len 8/12/2016 21:16'!
<= aCollection
	"Answer true if the receiver is a subcollection of aCollection."
	(aCollection isKindOf: self species) ifFalse: [^ false].
	self size <= aCollection size ifFalse: [^ false].
	^ self allSatisfy: [:each| aCollection includes: each]! !

!Collection methodsFor: '*mathematics' stamp: 'len 8/12/2016 21:11'!
> aCollection
	"Answer true if aCollection is a proper subcollection of the receiver."
	^ aCollection < self! !

!Collection methodsFor: '*mathematics' stamp: 'len 8/12/2016 21:12'!
>= aCollection
	"Answer true if aCollection is a subcollection of the receiver."
	^ aCollection <= self! !

!Collection methodsFor: '*mathematics' stamp: 'len 9/1/2016 07:50'!
 aCollection
	^ self intersection: aCollection! !

!Collection methodsFor: '*mathematics' stamp: 'len 9/1/2016 07:50'!
 aCollection
	^ self union: aCollection! !

!Collection methodsFor: '*mathematics' stamp: 'len 2/18/2003 21:40'!
anyIfNone: aBlock
	"Answer a representative sample of the receiver. This method can
	be helpful when needing to preinfer the nature of the contents of 
	semi-homogeneous collections."

	self do: [:each | ^ each].
	^aBlock value! !

!Collection methodsFor: '*mathematics' stamp: 'len 10/6/2016 10:19'!
apply: aMorphism
	^ self collect: aMorphism! !

!Collection methodsFor: '*mathematics' stamp: 'len 2/13/2003 23:19'!
copyEmpty
	^ self species new! !

!Collection methodsFor: '*mathematics' stamp: 'len 2/13/2003 23:19'!
copyEmpty: anInteger
	^ self species new: anInteger! !

!Collection methodsFor: '*mathematics' stamp: 'len 2/23/2016 22:55'!
gather: aBlock
	^ Array streamContents:
		[:stream | self do: [:each | stream nextPutAll: (aBlock value: each)]]! !

!Collection methodsFor: '*mathematics' stamp: 'len 6/23/2016 05:29'!
isFinite
	^ true! !

!Collection methodsFor: '*mathematics' stamp: 'len 6/23/2016 05:29'!
isInfinite
	^ false! !

!Collection methodsFor: '*mathematics' stamp: 'len 4/25/2016 07:52'!
plot: aFunction
	^ FunctionPlotMorph new evaluationPoints: self; function: aFunction! !

!Collection class methodsFor: '*mathematics-instance creation'!
accumulate: iteratorBlock
	"Return a new instance of myself by evaluating the iteratorBlock.
	Examples:
		| x oc set |
		x := #( 1 2 3 4 1 ).
		oc := OrderedCollection accumulate: [ :incBlock | x do: incBlock].
		Transcript cr; show: oc printString.
		set := Set accumulate: [ :incBlock | x do: incBlock].
		Transcript cr; show: set printString"

	| collection | 
	collection := self new.
	iteratorBlock value: [ :element | collection add: element].
	^collection! !

!Collection class methodsFor: '*mathematics-instance creation'!
accumulate: iteratorSymbol on: collection
	"Return a new instance of myself by sending the iteratorSymbol to the collection.
	Examples:
		| x oc set |
		x := #( 1 2 3 4 1 ).
		oc := OrderedCollection accumulate: #do: on: x.
		Transcript cr; show: oc printString.
		set := Set accumulate: #do: on: x.
		Transcript cr; show: set printString"

	| newCollection | 
	newCollection := self new.
	collection perform: iteratorSymbol with: [ :element | newCollection add: element].
	^newCollection! !

!SequenceableCollection methodsFor: '*mathematics' stamp: 'len 8/12/2016 22:01'!
<= aCollection
	"Answer true if the receiver is a subcollection of aCollection."
	(aCollection isKindOf: self species) ifFalse: [^ false].
	self size <= aCollection size ifFalse: [^ false].
	^ (aCollection indexOfSubCollection: self startingAt: 1) > 0! !

!SequenceableCollection methodsFor: '*mathematics' stamp: 'len 3/23/2016 05:04'!
at: anInteger add: anObject
	^ self at: anInteger put: (self at: anInteger) + anObject! !

!SequenceableCollection methodsFor: '*mathematics' stamp: 'len 8/2/2016 05:26'!
combinations: r
	^ Iterator on: [:aBlock| self combinations: r atATimeDo: aBlock]! !

!SequenceableCollection methodsFor: '*mathematics' stamp: 'len 3/24/2016 02:52'!
convolution: aCollection
	| answer |
	self isEmpty ifTrue: [^ self].
	aCollection isEmpty ifTrue: [^ aCollection].
	answer _ self species new: self size + aCollection size.
	answer atAllPut: (self at: 1) - (self at: 1).
	1 to: self size do: [:i|
		1 to: aCollection size do: [:k|
			answer at: i+k-1 add: (self at: i) * (aCollection at: k)]].
	^ answer! !

!SequenceableCollection methodsFor: '*mathematics' stamp: 'len 8/2/2016 05:27'!
permutations
	^ Iterator on: [:aBlock| self permutationsDo: aBlock]! !

!SequenceableCollection methodsFor: '*mathematics' stamp: 'len 7/17/2016 22:13'!
plot
	^ FunctionPlotMorph new evaluationPoints: (1 to: self size); function: (Function evaluating: [:n| self at: n])! !

!Set methodsFor: '*mathematics' stamp: 'len 4/27/2016 02:28'!
add: newObject ifAbsent: aBlock
	"Include newObject as one of the receiver's elements, but only if
	not already present. Answer newObject."

	| index |
	newObject ifNil: [self error: 'Sets cannot meaningfully contain nil as an element'].
	index _ self findElementOrNil: newObject.
	(array at: index) ifNil: [self atNewIndex: index put: newObject. aBlock value].
	^ newObject! !

!Set methodsFor: '*mathematics' stamp: 'len 5/12/2016 23:24'!
add: newObject ifPresent: aBlock
	"Include newObject as one of the receiver's elements, but only if
	not already present. Answer newObject."

	| index |
	newObject ifNil: [self error: 'Sets cannot meaningfully contain nil as an element'].
	index _ self findElementOrNil: newObject.
	(array at: index) isNil
		ifTrue: [self atNewIndex: index put: newObject]
		ifFalse: [aBlock value].
	^ newObject! !

!Set methodsFor: '*mathematics' stamp: 'len 6/13/2016 01:03'!
powerset
	"Answer all subsets of the receiver, including self and {}."
	| e answer |
	self isEmpty ifTrue: [^ OrderedCollection with: self].
	e _ self anyOne.
	answer _ (self copyWithout: e) powerset.
	answer copy do: [:each| answer add: (each copyWith: e)].
	^ answer! !

!Point methodsFor: '*mathematics' stamp: 'len 2/25/2016 17:01'!
norm
	^ (x*x + (y*y)) sqrt! !

!Point methodsFor: '*mathematics' stamp: 'len 2/25/2016 17:00'!
norm2
	^ x*x + (y*y)! !

!StrikeFont class methodsFor: '*mathematics-character shapes' stamp: 'len 6/24/2016 21:49'!
buildMathFont
	"
	StrikeFont buildMathFont
	"
	#(5 6 7 8 9 10 11 12 14 17 22) do: [:pointSize| self buildMathFont: pointSize]! !

!StrikeFont class methodsFor: '*mathematics-character shapes' stamp: 'len 6/17/2016 03:09'!
buildMathFont: pointSize
	| font normal larger muchLarger |
	font _ AbstractFont familyName: 'DejaVu Sans Mono' pointSize: pointSize.
	normal _ AbstractFont familyName: 'DejaVu Sans' pointSize: pointSize.
	#(2 1 3 0) detect: [:one| (larger _ (AbstractFont familyName: 'DejaVu Sans' pointSize: pointSize+one)) notNil].
	#(4 3 2 1 0) detect: [:one| (muchLarger _ (AbstractFont familyName: 'DejaVu Sans' pointSize: pointSize+one)) notNil].
	"replace some math glyphs with their normal counterpart, because the monospaced glyphs are too too small (and some are missing):"
	'' do: [:each|
		font takeAllGlyphFor: each from: each in: normal].
	'' do: [:each|
		font takeAllGlyphFor: each from: each in: larger].
	'' do: [:each|
		font takeAllGlyphFor: each from: each in: muchLarger].
	"make arrows bigger"
	'' do: [:each|
		font takeAllGlyphFor: each from: each in: larger]! !

!DyadicFraction methodsFor: 'arithmetic' stamp: 'len 1/16/2016 08:00'!
* aDyadicFraction
	aDyadicFraction isInteger ifTrue: [^ self class numerator: numerator * aDyadicFraction shift: shift].
	^ self class
		numerator: numerator * aDyadicFraction numerator
		shift: shift + aDyadicFraction shift! !

!DyadicFraction methodsFor: 'arithmetic' stamp: 'len 1/15/2016 08:00'!
+ aDyadicFraction
	^ self shift <= aDyadicFraction shift
		ifTrue:
			[self class
				numerator: (numerator bitShift: aDyadicFraction shift - shift) + aDyadicFraction numerator
				shift: aDyadicFraction shift]
		ifFalse:
			[self class
				numerator: (aDyadicFraction numerator bitShift: shift - aDyadicFraction shift) + numerator
				shift: shift]! !

!DyadicFraction methodsFor: 'arithmetic' stamp: 'len 1/16/2016 08:13'!
- aNumber
	^ self + aNumber negated! !

!DyadicFraction methodsFor: 'arithmetic' stamp: 'len 1/16/2016 07:49'!
/ anInteger
	| n |
	n _ anInteger abs.
	n isPowerOfTwo ifFalse: [DomainError signal: 'only can divide by a power of 2'].
	^ self class
		numerator: (anInteger positive ifTrue: [numerator] ifFalse: [numerator negated])
		shift: shift + n highBit - 1! !

!DyadicFraction methodsFor: 'comparing' stamp: 'len 1/17/2016 08:03'!
< aDyadicFraction
	"Answer whether the receiver is less than the argument."
	self sign ~= aDyadicFraction sign ifTrue: [^ self sign < aDyadicFraction sign].
	shift = aDyadicFraction shift ifTrue: [^ numerator < aDyadicFraction numerator].
"	numerator = aDyadicFraction numerator ifTrue: [^ numerator positive and: [shift > aDyadicFraction shift]]."
	^ (numerator bitShift: aDyadicFraction shift) < (aDyadicFraction numerator bitShift: shift)! !

!DyadicFraction methodsFor: 'comparing' stamp: 'len 1/16/2016 07:58'!
= aDyadicFraction
	^ numerator = aDyadicFraction numerator and: [shift = aDyadicFraction shift]! !

!DyadicFraction methodsFor: 'converting' stamp: 'len 1/16/2016 08:14'!
asFloat
	^ self asFraction asFloat! !

!DyadicFraction methodsFor: 'converting' stamp: 'len 1/16/2016 05:34'!
asFraction
	^ Fraction numerator: self numerator denominator: self denominator! !

!DyadicFraction methodsFor: 'private' stamp: 'len 1/15/2016 07:45'!
denominator
	^ 1 bitShift: shift! !

!DyadicFraction methodsFor: 'comparing' stamp: 'len 6/28/2016 09:12'!
hash
	^ numerator hashMultiply + shift! !

!DyadicFraction methodsFor: 'testing' stamp: 'len 1/15/2016 07:48'!
isZero
	^ numerator isZero! !

!DyadicFraction methodsFor: 'arithmetic' stamp: 'len 1/15/2016 07:47'!
negated
	^ self class numerator: numerator negated shift: shift! !

!DyadicFraction methodsFor: 'private' stamp: 'len 1/16/2016 08:15'!
normalize
	[numerator even and: [shift > 0]]
		whileTrue:
			[numerator _ numerator bitShift: -1.
			shift _ shift - 1]! !

!DyadicFraction methodsFor: 'private' stamp: 'len 1/15/2016 07:30'!
numerator
	^ numerator! !

!DyadicFraction methodsFor: 'constants' stamp: 'len 1/15/2016 07:48'!
one
	^ self class numerator: 1 shift: 0! !

!DyadicFraction methodsFor: 'printing' stamp: 'len 1/15/2016 08:01'!
printOn: aStream base: base
	aStream nextPut: $(.
	numerator printOn: aStream base: base.
	aStream nextPutAll: '/2^'; print: shift; nextPut: $)! !

!DyadicFraction methodsFor: 'mathematical functions' stamp: 'len 1/16/2016 06:04'!
raisedToInteger: anInteger
	anInteger < 0 ifTrue: [^ self reciprocal raisedToInteger: anInteger negated].
	anInteger = 0 ifTrue: [^ self one].
	^ self class numerator: (numerator raisedToInteger: anInteger) shift: shift + anInteger! !

!DyadicFraction methodsFor: 'private' stamp: 'len 1/16/2016 08:15'!
setNumerator: a shift: n
	numerator _ a asInteger.
	shift _ n asInteger.
	self normalize! !

!DyadicFraction methodsFor: 'private' stamp: 'len 1/15/2016 07:46'!
shift
	^ shift! !

!DyadicFraction methodsFor: 'testing' stamp: 'len 1/16/2016 08:05'!
sign
	^ numerator sign! !

!DyadicFraction methodsFor: 'constants' stamp: 'len 1/15/2016 07:48'!
zero
	^ self class numerator: 0 shift: 0! !

!DyadicFraction class methodsFor: 'instance creation' stamp: 'len 1/16/2016 05:36'!
fromFraction: aFraction
	^ self numerator: aFraction numerator shift: aFraction denominator highBit - 1! !

!DyadicFraction class methodsFor: 'instance creation' stamp: 'len 1/16/2016 07:57'!
fromInteger: anInteger
	anInteger isInteger ifFalse: [DomainError signal].
	^ self numerator: anInteger shift: 0! !

!DyadicFraction class methodsFor: 'instance creation' stamp: 'len 1/15/2016 07:46'!
numerator: anInteger shift: n
	^ self new setNumerator: anInteger shift: n! !

!RealAlgebraicNumber methodsFor: 'arithmetic' stamp: 'len 6/5/2016 20:28'!
* aNumber
	| f b |
	aNumber class = self class
		ifFalse: [^ aNumber adaptToRealAlgebraic: self andSend: #*].
	aNumber isZero ifTrue: [^ aNumber].
	self isZero ifTrue: [^ self].
	f _ RealRootFinder polynomial:
		(self polynomial zeroProduct: aNumber polynomial).
	[b _ self bounds * aNumber bounds.
	f moreThanOneRootBetween: b left and: b right]
		whileTrue:
			[self refineWith: aNumber].
	^ self class polynomial: f polynomial bounds: b! !

!RealAlgebraicNumber methodsFor: 'arithmetic' stamp: 'len 6/5/2016 20:29'!
+ aNumber
	| f b |
	aNumber class = self class
		ifFalse: [^ aNumber adaptToRealAlgebraic: self andSend: #+].
	aNumber isZero ifTrue: [^ self].
	self isZero ifTrue: [^ aNumber].
	f _ RealRootFinder polynomial:
		(self polynomial zeroAddition: aNumber polynomial).
	[b _ self bounds + aNumber bounds.
	f moreThanOneRootBetween: b left and: b right]
		whileTrue:
			[self refineWith: aNumber].
	^ self class polynomial: f polynomial bounds: b! !

!RealAlgebraicNumber methodsFor: 'arithmetic' stamp: 'len 11/9/2015 14:28'!
- anObject
	^ self + anObject negated! !

!RealAlgebraicNumber methodsFor: 'arithmetic' stamp: 'len 11/9/2015 14:29'!
/ anObject
	^ self * anObject reciprocal! !

!RealAlgebraicNumber methodsFor: 'comparing' stamp: 'len 6/4/2016 21:32'!
< anObject
	"Answer whether the receiver is less than the argument."

	anObject class = self class ifFalse: [^ (self - anObject) sign = -1].
	(self = anObject) ifTrue: [^ false].
	[self bounds intersects: anObject bounds] whileTrue: [self refineWith: anObject].
	^ self rightBound < anObject leftBound! !

!RealAlgebraicNumber methodsFor: 'comparing' stamp: 'len 6/4/2016 21:32'!
= anObject
	anObject isNumber ifFalse: [^ false].
	self == anObject ifTrue: [^ true].
	anObject class = self class
		ifFalse: [^ anObject adaptToRealAlgebraic: self andSend: #=].
	(self bounds intersects: anObject bounds) ifFalse: [^ false].
	(self polynomial gcd: anObject polynomial) isConstant
		ifTrue: [^ false].
	^ (self - anObject) isZero! !

!RealAlgebraicNumber methodsFor: 'approximating' stamp: 'len 6/4/2016 22:22'!
absoluteError
	"Answer the maximun current error in the rational approximation of the receiver."
	^ bounds length / 2! !

!RealAlgebraicNumber methodsFor: 'converting' stamp: 'len 6/4/2016 21:25'!
adaptToAlgebraic: rcvr andSend: selector
	^ rcvr perform: selector with: (AlgebraicNumber polynomial: polynomial approximation: bounds midpoint radius: bounds length / 2)! !

!RealAlgebraicNumber methodsFor: 'converting' stamp: 'len 11/19/2015 21:39'!
adaptToFloat: rcvr andSend: selector
	^ rcvr perform: selector with: self asFloat! !

!RealAlgebraicNumber methodsFor: 'converting' stamp: 'len 11/19/2015 21:40'!
adaptToFraction: rcvr andSend: selector
	^ (self class fromRational: rcvr) perform: selector with: self! !

!RealAlgebraicNumber methodsFor: 'converting' stamp: 'len 11/19/2015 21:39'!
adaptToInteger: rcvr andSend: selector
	^ (self class fromRational: rcvr) perform: selector with: self! !

!RealAlgebraicNumber methodsFor: 'approximating' stamp: 'len 6/4/2016 21:23'!
approximation
	"Answer the current rational approximation of the receiver."
	^ bounds midpoint! !

!RealAlgebraicNumber methodsFor: 'converting' stamp: 'len 6/4/2016 23:06'!
asFloat
	"Answer a Float approximation of the receiver."

	self refineTo: 0.000001.
	^ self approximation asFloat! !

!RealAlgebraicNumber methodsFor: 'converting' stamp: 'len 3/21/2016 22:51'!
asRational
	"Convert the receiver to Fraction or Integer."
	| alpha |
	self leftBound = self rightBound ifTrue: [^ self leftBound].
	self polynomial degree < 2
		ifTrue:
			[alpha _ polynomial independentCoefficient negated / polynomial leadingCoefficient.
			self bounds: (RealInterval open: alpha closed: alpha).
			^ alpha].
	(RationalRootFinder polynomial: self polynomial)
		roots do: [ :each |
			(each between: self leftBound and: self rightBound)
				ifTrue: [self bounds: (RealInterval open: each closed: each). ^ each]].
	self error: 'the number is irrational'! !

!RealAlgebraicNumber methodsFor: 'approximating' stamp: 'len 1/16/2016 06:27'!
bounds
	^ bounds! !

!RealAlgebraicNumber methodsFor: 'accessing-private' stamp: 'len 1/17/2016 02:57'!
bounds: aRealInterval
	bounds _ aRealInterval.
	rightSign _ nil! !

!RealAlgebraicNumber methodsFor: 'accessing' stamp: 'len 5/27/2016 02:03'!
denominator
	"The denominator of an algebraic number is the smallest positive integer that multiplied by the algebraic number is an algebraic integer."
	^ self minimalPolynomial coefficients inject: 1 into: [:denominator :each| denominator lcm: each denominator]! !

!RealAlgebraicNumber methodsFor: 'comparing' stamp: 'len 12/13/97 03:56'!
hash
	"Answer the hash value for the receiver."

	^ self truncated hash! !

!RealAlgebraicNumber methodsFor: 'testing' stamp: 'len 8/4/97 19:28'!
isAlgebraic
	"Answer true if the receiver is an AlgebraicNumber."

	^ true! !

!RealAlgebraicNumber methodsFor: 'testing' stamp: 'len 5/27/2016 02:06'!
isAlgebraicInteger
	"An algebraic number is an 'algebraic integer' if it's the root of a monic polynomial in Z[x], in particular if it's minimal polynomial has integer coefficients."
	^ self minimalPolynomial coefficients allSatisfy: [:each| each isInteger]! !

!RealAlgebraicNumber methodsFor: 'testing' stamp: 'len 3/3/2016 01:59'!
isRational
	"Answer true if the receiver is a rational number."
	self polynomial degree < 2 ifTrue: [^ true].
	self rightBound = self leftBound ifTrue: [^ true].
	(RationalRootFinder polynomial: self polynomial)
		roots do: [:each|
			(self bounds includes: each)
				ifTrue: [self bounds: (RealInterval closed: each closed: each). ^ true]].
	^ false! !

!RealAlgebraicNumber methodsFor: 'testing' stamp: 'len 11/19/2015 21:33'!
isZero
	^ self leftBound = 0 and: [self rightBound = 0]
"	^ self isRational and: [self asRational = 0]"! !

!RealAlgebraicNumber methodsFor: 'accessing-private' stamp: 'len 1/16/2016 06:38'!
leftBound
	^ bounds left! !

!RealAlgebraicNumber methodsFor: 'accessing-private' stamp: 'len 1/16/2016 07:05'!
leftBound: aFraction
	bounds _ RealInterval open: aFraction closed: bounds right! !

!RealAlgebraicNumber methodsFor: 'accessing' stamp: 'len 3/20/2016 06:25'!
minimalPolynomial
	irreducible ifTrue: [^ polynomial].
	polynomial _ polynomial factors asSet detect: [:one| (one value: self) isZero].
	irreducible _ true.
	^ polynomial! !

!RealAlgebraicNumber methodsFor: 'arithmetic' stamp: 'len 6/5/2016 20:30'!
negated
	"Answer the additive inverse of the receiver."
	self isZero ifTrue: [^ self].
	^ self class
		polynomial: polynomial zeroNegation
		irreducible: irreducible
		bounds: bounds negated! !

!RealAlgebraicNumber methodsFor: 'private' stamp: 'len 4/29/2016 07:45'!
normalize
	"Change the representation of the receiver such that if the receiver is not 0 then 0 is not in the rational approximation interval."
	| p sign |
	self leftBound sign = self rightBound sign ifTrue: [^ self].
	polynomial independentCoefficient isZero
		ifTrue: [^ self leftBound: 0; rightBound: 0].
	"for every real root r not 0: |r| > 1 / (1 + f normInfinite), from Cauchy and Landau inequalities"
	p _ 1 / (1 + self polynomial normInfinite).
	p negated < self leftBound
		ifTrue: [^ self leftBound: p].
	p > self rightBound
		ifTrue: [^ self rightBound: p negated].
	sign _ (self polynomial value: p negated) sign.
	sign ~= (self polynomial value: self leftBound) sign
		ifTrue: [self rightBound: p negated; rightSign: sign]
		ifFalse: [(self polynomial value: p) sign ~= self rightSign
				ifTrue: [self leftBound: p]
				ifFalse: [self leftBound: 0; rightBound: 0]].
	self leftBound > self rightBound ifTrue: [self error: 'interval normalization error']! !

!RealAlgebraicNumber methodsFor: 'accessing' stamp: 'len 6/3/2016 20:51'!
polynomial
	^ polynomial! !

!RealAlgebraicNumber methodsFor: 'initialization' stamp: 'len 4/29/2016 07:47'!
polynomial: aPolynomial irreducible: aBoolean bounds: aRealInterval
	polynomial _ aPolynomial.
	polynomial isMonic ifFalse: [polynomial _ polynomial / polynomial leadingCoefficient].
	irreducible _ aBoolean.
	bounds _ aRealInterval.
"	irreducible ifFalse: [polynomial _ polynomial reduced]. actually this makes it slower"
"	self irreducible
		ifTrue: [self polynomial: aPolynomial]
		ifFalse: [
			self polynomial:
				(aPolynomial squareFreeFactorizationOLD asSet
					detect: [ :one | (one valueAt: left) sign ~= (one valueAt: right)])]."
	self normalize.
	self reduce! !

!RealAlgebraicNumber methodsFor: 'printing' stamp: 'len 3/21/2016 22:27'!
printOn: aStream base: base
	polynomial degree < 4 "too slow" ifTrue: [self isRational ifTrue: [self asRational printOn: aStream base: base. ^ self]].
"	polynomial degree = 2 ifTrue: [^ self printQuadraticOn: aStream base: base]."
	(self asFloat roundTo: 0.00001) printOn: aStream base: base.
	aStream nextPutAll: '..'

	"aStream
		nextPutAll: self class name;
		space;
		nextPut: $(;
		print: self polynomial;
		nextPutAll: '; ~ ';
		print: self asFloat;
		nextPut: $)"! !

!RealAlgebraicNumber methodsFor: 'arithmetic' stamp: 'len 6/3/2016 20:50'!
reciprocal
	"Answer the multiplicative inverse of the receiver."
	self isZero ifTrue: [^ ZeroDivide signal].
	^ self class
		polynomial: polynomial zeroReciprocal
		irreducible: irreducible
		bounds: bounds reciprocal! !

!RealAlgebraicNumber methodsFor: 'private' stamp: 'len 4/29/2016 07:47'!
reduce
	irreducible ifTrue: [^ self].
	self isRational
		ifTrue:
			[polynomial _ polynomial species x - self asRational.
			irreducible _ true]! !

!RealAlgebraicNumber methodsFor: 'approximating' stamp: 'len 6/4/2016 23:06'!
refine
	"Refine the rational interval approximation of the receiver."
	self refineAt: self approximation! !

!RealAlgebraicNumber methodsFor: 'approximating' stamp: 'len 1/17/2016 02:57'!
refineAt: aFraction
	"Refine the rational interval approximation of the receiver to one of both (leftBound, aFraction] or (aFraction, rightBound]."
	| sign |
	self rightSign = (sign _ (self polynomial value: aFraction) sign)
		ifTrue: [self rightBound: aFraction; rightSign: sign]
		ifFalse: [self leftBound: aFraction].
	sign = 0 ifTrue: [self leftBound: aFraction. self rightBound: aFraction]! !

!RealAlgebraicNumber methodsFor: 'approximating' stamp: 'len 1/16/2016 07:10'!
refineTo: aNumber
	"Refine the receiver up to get an approximation error < aNumber."
	[self absoluteError >= aNumber] whileTrue: [self refine]! !

!RealAlgebraicNumber methodsFor: 'approximating' stamp: 'len 1/17/2016 07:44'!
refineWith: aRealAlgebraicNumber
	"Refine the rational interval approximation of either the receiver or the argument, depending on which is less precise at the moment."
	self relativeError > aRealAlgebraicNumber relativeError
		ifTrue: [self refine]
		ifFalse: [aRealAlgebraicNumber refine]! !

!RealAlgebraicNumber methodsFor: 'approximating' stamp: 'len 6/4/2016 23:10'!
relativeError
	"Answer the relative error in the current rational approximation."
	self isZero ifTrue: [^ 0].
	^ self absoluteError / self approximation abs! !

!RealAlgebraicNumber methodsFor: 'accessing-private' stamp: 'len 1/16/2016 06:38'!
rightBound
	^ bounds right! !

!RealAlgebraicNumber methodsFor: 'accessing-private' stamp: 'len 1/17/2016 02:57'!
rightBound: aFraction
	bounds _ RealInterval open: bounds left closed: aFraction.
	rightSign _ nil! !

!RealAlgebraicNumber methodsFor: 'accessing-private' stamp: 'len 1/17/2016 03:06'!
rightSign
	rightSign isNil ifTrue: [rightSign _ (self polynomial value: self rightBound) sign].
	^ rightSign! !

!RealAlgebraicNumber methodsFor: 'accessing-private' stamp: 'len 1/17/2016 02:59'!
rightSign: anInteger
	rightSign _ anInteger! !

!RealAlgebraicNumber methodsFor: 'mathematical functions' stamp: 'len 8/8/97 20:54'!
sign
	"Answer 1, -1 or 0, depending on the sign of the receiver."

	^ self leftBound sign! !

!RealAlgebraicNumber methodsFor: 'mathematical functions' stamp: 'len 6/4/2016 22:57'!
squareRoot
	self isRational ifFalse: [^ self notYetImplemented].
	self negative ifTrue: [^ self negated squareRoot i].
	self isZero ifTrue: [^ self].
	^ self class
		polynomial: self polynomial zeroSquareRoot
 		bounds: (RealInterval open: 0 open: (self asRational max: 1))! !

!RealAlgebraicNumber methodsFor: 'mathematical functions' stamp: 'len 1/16/2016 06:27'!
squared
	"Answer the square of the receiver."

	| x odd even |
	x _ self polynomial species x.
	odd _ self polynomial odd.
	even _ self polynomial even.
	^ self class
		polynomial: odd squared * x - even squared
		bounds: self bounds squared! !

!RealAlgebraicNumber methodsFor: 'truncation and round off' stamp: 'len 1/17/2016 02:20'!
truncated
	"Answer the integer nearest the receiver toward zero."
	| t |
	self absoluteError truncated > 0 ifTrue: [self refineTo: 9/10].
	^ (t _ self rightBound truncated) = self rightBound
		ifTrue: [self refineAt: t.
				self rightBound truncated]
		ifFalse: [t]! !

!RealAlgebraicNumber class methodsFor: 'instance creation' stamp: 'len 7/15/2016 18:36'!
fromRational: anIntegerOrFraction
	"Answer an instance of the receiver representing the rational number anIntegerOrFraction."
	| q x |
	q _ anIntegerOrFraction asFraction.
	x _ QQ polynomials x.
	^ self
		minimalPolynomial: x * q denominator - q numerator
 		bounds: (RealInterval open: anIntegerOrFraction closed: anIntegerOrFraction)! !

!RealAlgebraicNumber class methodsFor: 'instance creation' stamp: 'len 1/16/2016 06:49'!
minimalPolynomial: aPolynomial bounds: aRealInterval
	"Answer an instance of the receiver representing the unique zero of aPolynomial in the given rational interval."
	^ self new polynomial: aPolynomial irreducible: true bounds: aRealInterval! !

!RealAlgebraicNumber class methodsFor: 'examples' stamp: 'len 7/15/2016 18:36'!
phi
	"Answer the Phidias number or Golden Ratio."
	| x |
	x _ QQ polynomials x.
	^ self minimalPolynomial: x**2 - x - 1 bounds: (RealInterval open: 1 open: 2)! !

!RealAlgebraicNumber class methodsFor: 'instance creation' stamp: 'len 1/16/2016 06:40'!
polynomial: aPolynomial bounds: aRealInterval
	"Answer an instance of the receiver representing the unique zero of aPolynomial in the given interval."
	^ self polynomial: aPolynomial irreducible: false bounds: aRealInterval! !

!RealAlgebraicNumber class methodsFor: 'instance creation' stamp: 'len 1/16/2016 07:40'!
polynomial: aPolynomial irreducible: aBoolean bounds: aRealInterval
	"Answer an instance of the receiver representing the unique zero of aPolynomial in the given rational interval, and set the irreducibility flag for aPolynomial to aBoolean.
	Assume the polynomial is square-free."
	^ self new polynomial: aPolynomial irreducible: aBoolean bounds: aRealInterval! !

!RealAlgebraicNumber class methodsFor: 'examples' stamp: 'len 7/15/2016 18:36'!
sqrt2
	"Answer an instance of the receiver representing the square root of 2."
	^ self
		minimalPolynomial: QQ polynomials x squared - 2
 		bounds: (RealInterval open: 1 open: 2)! !

!RealAlgebraicNumber class methodsFor: 'examples' stamp: 'len 7/15/2016 18:37'!
sqrt: aNumber
	"Answer a square root of the rational argument."
	aNumber positive ifFalse: [^ DomainError signal: 'negative square root'].
	^ self
		minimalPolynomial: QQ polynomials x squared - aNumber
 		bounds: (RealInterval open: 0 open: (aNumber max: 1))! !

!ContinuedFraction methodsFor: 'converting' stamp: 'len 3/27/2016 04:47'!
asFraction
	coefficients size isInfinity ifTrue: [self error: 'infinite continued fraction'].
	^ self convergentAt: coefficients size! !

!ContinuedFraction methodsFor: 'accessing' stamp: 'len 12/2/2015 00:07'!
coefficients
	^ coefficients! !

!ContinuedFraction methodsFor: 'initialization' stamp: 'len 12/4/2015 01:38'!
coefficients: aSequence
	coefficients _ ((aSequence isKindOf: Tuple) or: [aSequence isKindOf: Sequence])
		ifTrue: [aSequence]
		ifFalse: [Tuple withAll: aSequence]! !

!ContinuedFraction methodsFor: 'convergents' stamp: 'len 3/27/2016 04:46'!
convergentAt: anInteger
	| n x |
	coefficients size > 0 ifFalse: [^ Infinity positive].
	n _ coefficients size min: anInteger.
	x _ coefficients at: n.
	(1 to: n-1) reverseDo: [:i| x _ x reciprocal + (coefficients at: i)].
	^ x! !

!ContinuedFraction methodsFor: 'convergents' stamp: 'len 7/15/2016 18:31'!
convergents
	^ Sequence to: QQ evaluating: [:i| self convergentAt: i]! !

!ContinuedFraction methodsFor: 'convergents' stamp: 'len 3/27/2016 04:51'!
convergentsDo: aBlock
	| p1 p2 q1 q2 |
	p2 _ 0.
	p1 _ 1.
	q2 _ 1.
	q1 _ 0.
	coefficients withIndexDo: [:ai :i| | pi qi | pi _ ai*p1 + p2. qi _ ai*q1 + q2. aBlock value: pi/qi. p2 _ p1. p1 _ pi. q2 _ q1. q1 _ qi]! !

!ContinuedFraction methodsFor: 'convergents' stamp: 'len 3/27/2016 04:43'!
convergentsUpTo: n
	| answer |
	answer _ OrderedCollection new: n.
	self convergentsDo: [:each| answer size < n ifFalse: [^ answer]. answer add: each]! !

!ContinuedFraction methodsFor: 'initialization' stamp: 'len 12/4/2015 21:57'!
fromFraction: aFraction
	| x a |
	aFraction isInfinity ifTrue: [coefficients _ Tuple empty. ^ self].
	coefficients _ OrderedCollection new.
	x _ aFraction.
	a _ x floor.
	coefficients add: a.
	[x _ x - a.
	x ~= 0]
		whileTrue:
			[x _ x reciprocal.
			a _ x floor.
			coefficients add: a].
	coefficients _ Tuple withAll: coefficients asArray! !

!ContinuedFraction methodsFor: 'testing' stamp: 'len 12/4/2015 01:48'!
isFinite
	^ coefficients size isInfinity not! !

!ContinuedFraction methodsFor: 'arithmetic' stamp: 'len 12/3/2015 02:17'!
negated
	^ self class coefficients: coefficients negated! !

!ContinuedFraction methodsFor: 'printing' stamp: 'len 12/4/2015 00:48'!
printOn: aStream base: base
	| separator |
	aStream nextPut: $[.
	separator _ $;.
	(1 to: (coefficients size min: 10)) do: [:i| (coefficients at: i) printOn: aStream base: base] separatedBy: [aStream nextPut: separator. separator _ $,].
	coefficients size isInfinity ifTrue: [aStream nextPutAll: '...'].
	aStream nextPut: $]! !

!ContinuedFraction methodsFor: 'arithmetic' stamp: 'len 12/4/2015 01:45'!
reciprocal
	^ (coefficients at: 1) = 0
		ifTrue: [self class coefficients: (coefficients copyFrom: 2 to: coefficients size)]
		ifFalse: [self class coefficients: 0, coefficients]! !

!ContinuedFraction class methodsFor: 'instance creation' stamp: 'len 12/2/2015 00:10'!
coefficients: anArray
	^ self new coefficients: anArray! !

!ContinuedFraction class methodsFor: 'examples' stamp: 'len 12/4/2015 22:17'!
e
	^ self coefficients: (Sequence evaluating: [:n| n=1 ifTrue: [2] ifFalse: [n \\ 3 = 0 ifTrue: [2*n/3] ifFalse: [1]]])! !

!ContinuedFraction class methodsFor: 'instance creation' stamp: 'len 3/27/2016 05:07'!
fromFloat: aFloat
	^ self fromFraction: aFloat asFraction! !

!ContinuedFraction class methodsFor: 'instance creation' stamp: 'len 12/1/2015 23:04'!
fromFraction: aFraction
	^ self new fromFraction: aFraction! !

!ContinuedFraction class methodsFor: 'instance creation' stamp: 'len 4/30/2016 04:34'!
newFrom: aNumber
	aNumber isFloat ifTrue: [^ self fromFloat: aNumber].
	aNumber isFraction ifTrue: [^ self fromFraction: aNumber].
	^ super newFrom: aNumber! !

!ContinuedFraction class methodsFor: 'examples' stamp: 'len 12/4/2015 01:14'!
phi
	"Answer the golden ratio."
	^ self coefficients: (Sequence constant: 1)! !

!MutualAssociation methodsFor: 'comparing' stamp: 'len 7/13/2016 07:55'!
= anAssociation
	(anAssociation isKindOf: Association)
		ifFalse: [^ false].
	^ key = anAssociation key
		ifTrue: [value = anAssociation value]
		ifFalse: [value = anAssociation key and: [key = anAssociation value]]! !

!MutualAssociation methodsFor: 'comparing' stamp: 'len 7/13/2016 07:31'!
hash
	^ key hash bitXor: value hash! !

!MutualAssociation methodsFor: 'printing' stamp: 'len 7/13/2016 07:31'!
printOn: aStream
	aStream
		print: key;
		nextPutAll: ' <-> ';
		print: value! !

!MutualAssociation class methodsFor: 'instance creation' stamp: 'len 7/23/2016 06:39'!
newFrom: anAssociation
	^ self with: anAssociation key with: anAssociation value! !

!MutualAssociation class methodsFor: 'instance creation' stamp: 'len 7/13/2016 07:33'!
with: anObject with: anotherObject
	^ self key: anObject value: anotherObject! !

!Aleph methodsFor: 'arithmetic' stamp: 'len 4/22/2016 02:39'!
* anObject
	anObject = 0 ifTrue: [^ self errorUndetermined].
	^ self max: anObject! !

!Aleph methodsFor: 'arithmetic' stamp: 'len 6/4/2016 19:12'!
** aNumber
	(aNumber isInteger and: [aNumber > 0]) ifTrue: [^ self].
	DomainError signal: 'only integer positive exponents allowed'! !

!Aleph methodsFor: 'comparing' stamp: 'len 4/22/2016 05:06'!
< anObject
	anObject class = self class ifTrue: [^ order < anObject order].
	^ false! !

!Aleph methodsFor: 'comparing' stamp: 'len 4/22/2016 05:06'!
= anObject
	^ self class == anObject class and: [order = anObject order]! !

!Aleph methodsFor: 'converting' stamp: 'len 4/22/2016 05:11'!
adaptToNumber: rcvr andSend: selector
	selector == #+ ifTrue:[^self + rcvr].
	selector == #* ifTrue:[^self * rcvr].
	selector == #/ ifTrue:[^ rcvr isNumber ifTrue: [0] ifFalse: [self errorUndetermined]].
	selector == #> ifTrue:[^false].
	selector == #>= ifTrue:[^false].
	selector == #< ifTrue:[^true].
	selector == #<= ifTrue:[^true].
	^super adaptToNumber: rcvr andSend: selector! !

!Aleph methodsFor: 'comparing' stamp: 'len 6/28/2016 09:04'!
hash
	^ self class hash + order hash! !

!Aleph methodsFor: 'testing' stamp: 'len 4/22/2016 05:06'!
isCountable
	^ order = 0! !

!Aleph methodsFor: 'testing' stamp: 'len 4/22/2016 04:54'!
isFinite
	^ false! !

!Aleph methodsFor: 'testing' stamp: 'len 4/22/2016 04:54'!
isInfinite
	^ true! !

!Aleph methodsFor: 'accessing' stamp: 'len 4/22/2016 05:06'!
order
	^ order! !

!Aleph methodsFor: 'initialization' stamp: 'len 4/22/2016 05:06'!
order: anInteger
	order _ anInteger! !

!Aleph methodsFor: 'printing' stamp: 'len 6/7/2016 21:43'!
printOn: aStream
	aStream nextPut: Character aleph; nextPutAll: order printString sub! !

!Aleph class methodsFor: 'instance creation' stamp: 'len 4/22/2016 02:37'!
new
	^ self new: 0! !

!Aleph class methodsFor: 'instance creation' stamp: 'len 4/22/2016 05:07'!
new: anInteger
	^ self basicNew order: anInteger! !

!Infinity methodsFor: 'arithmetic' stamp: 'len 11/14/97 14:49'!
* anObject
	"Answer the product of the receiver by the argument."

	anObject = 0 ifTrue: [^ self errorUndetermined].
	^ self class sign: self sign * anObject sign! !

!Infinity methodsFor: 'arithmetic' stamp: 'len 1/16/2016 06:05'!
** aNumber
	^ self raisedTo: aNumber! !

!Infinity methodsFor: 'arithmetic' stamp: 'len 12/13/97 02:26'!
+ anObject
	"Answer the sum of the receiver and the argument."

	(anObject isInfinity and: [self sign ~= anObject sign])
		ifTrue: [^ self errorUndetermined].
	^ self! !

!Infinity methodsFor: 'arithmetic' stamp: 'len 11/12/97 21:30'!
- anObject
	"Answer the difference between the receiver and the argument."

	^ self + anObject negated! !

!Infinity methodsFor: 'arithmetic' stamp: 'len 10/9/97 20:24'!
/ anObject
	"Answer the division of the receiver by the argument."

	^ self * anObject reciprocal! !

!Infinity methodsFor: 'comparing' stamp: 'len 11/9/2015 15:19'!
< anObject
	anObject isInfinity ifTrue: [^ self sign < anObject sign].
	^ self negative! !

!Infinity methodsFor: 'comparing' stamp: 'len 11/9/2015 15:19'!
<= aMagnitude
	^ self < aMagnitude! !

!Infinity methodsFor: 'comparing' stamp: 'len 11/9/2015 15:19'!
= anObject
	^ self class == anObject class and: [self sign = anObject sign]! !

!Infinity methodsFor: 'comparing' stamp: 'len 11/9/2015 15:19'!
> anObject
	anObject isInfinity ifTrue: [^ self sign > anObject sign].
	^ self positive! !

!Infinity methodsFor: 'comparing' stamp: 'len 11/9/2015 15:19'!
>= aMagnitude
	^ self > aMagnitude! !

!Infinity methodsFor: 'converting' stamp: 'len 11/11/2015 05:00'!
adaptToNumber: rcvr andSend: selector
	selector == #+ ifTrue:[^self + rcvr].
	selector == #* ifTrue:[^self * rcvr].
	selector == #- ifTrue:[^self negated + rcvr].
	selector == #/ ifTrue:[^ rcvr isInfinite ifTrue: [self errorUndetermined] ifFalse: [0]].
	selector == #> ifTrue:[^self < rcvr].
	selector == #>= ifTrue:[^self <= rcvr].
	selector == #< ifTrue:[^self > rcvr].
	selector == #<= ifTrue:[^self >= rcvr].
	^super adaptToNumber: rcvr andSend: selector! !

!Infinity methodsFor: 'private' stamp: 'len 10/9/97 20:29'!
errorUndetermined
	^ self error: 'undetermined'! !

!Infinity methodsFor: 'comparing' stamp: 'len 6/28/2016 09:19'!
hash
	^ self sign hash + self class hash! !

!Infinity methodsFor: 'testing' stamp: 'len 11/19/2015 17:00'!
isInfinity
	^ true! !

!Infinity methodsFor: 'arithmetic' stamp: 'len 11/12/97 21:31'!
negated
	"Answer a copy of the receiver with the sign changed."

	^ self class sign: self sign negated! !

!Infinity methodsFor: 'testing' stamp: 'len 11/14/97 14:50'!
negative
	"Answer true if the receiver is negative."

	^ self sign negative! !

!Infinity methodsFor: 'testing' stamp: 'len 11/14/97 14:50'!
positive
	"Answer true if the receiver is positive."

	^ self sign positive! !

!Infinity methodsFor: 'printing' stamp: 'len 4/11/2016 23:43'!
printOn: aStream
	self negative ifTrue: [aStream nextPut: $-].
	aStream nextPut: Character infinity
"	aStream nextPutAll: 'infinity'"! !

!Infinity methodsFor: 'arithmetic' stamp: 'len 1/16/2016 06:08'!
raisedTo: aNumber
	aNumber isInteger ifTrue: [^ self raisedToInteger: aNumber].
	^ DomainError signal! !

!Infinity methodsFor: 'arithmetic' stamp: 'len 11/9/2015 23:18'!
raisedToInteger: anInteger
	anInteger = 0 ifTrue: [^ self errorUndetermined].
	anInteger negative ifTrue: [^ 0].
	^ anInteger odd ifTrue: [self] ifFalse: [self negated]! !

!Infinity methodsFor: 'arithmetic' stamp: 'len 11/12/97 21:32'!
reciprocal
	"Answer zero. (1 / self)"

	^ 0! !

!Infinity methodsFor: 'accessing' stamp: 'len 10/9/97 20:17'!
sign
	"Answer the sign of the receiver."

	^ sign! !

!Infinity methodsFor: 'accessing-private' stamp: 'len 10/9/97 20:16'!
sign: anInteger
	sign _ anInteger! !

!Infinity methodsFor: 'arithmetic' stamp: 'len 10/17/97 04:09'!
squared
	"Answer the square of the receiver."

	^ self class positive! !

!Infinity methodsFor: 'testing' stamp: 'len 11/14/97 14:51'!
strictlyPositive
	"Answer true if the receiver is strictly positive."

	^ self positive! !

!Infinity class methodsFor: 'instance creation' stamp: 'len 10/17/97 04:07'!
negative
	"Answer a new instance of the receiver representing -infinity."

	^ self sign: -1! !

!Infinity class methodsFor: 'instance creation' stamp: 'len 10/17/97 04:07'!
positive
	"Answer a new instance of the receiver representing +infinity."

	^ self sign: 1! !

!Infinity class methodsFor: 'instance creation' stamp: 'len 11/23/2015 02:41'!
projective
	"Answer a new instance of the receiver representing the projective (unsigned) infinity."

	^ self sign: 0! !

!Infinity class methodsFor: 'instance creation' stamp: 'len 10/9/97 20:27'!
sign: anInteger
	"Answer a new instance of the receiver with sign anInteger."

	^ self new sign: anInteger! !

!OrderedTuple methodsFor: 'arithmetic' stamp: 'len 4/16/2016 07:50'!
% anInteger
	anInteger = 2 ifTrue: [^ BitTuple new: self size evaluating: [:i| (self at: i) % 2]].
	^ self collect: [:each| each % anInteger]! !

!OrderedTuple methodsFor: 'arithmetic' stamp: 'len 8/30/2016 04:10'!
* anObject
	(anObject is: #Tuple)
		ifTrue: [^ self class new: (self size min: anObject size) evaluating: [:i| (self at: i) * (anObject at: i)]].
	^ self collect: [:each| each * anObject]! !

!OrderedTuple methodsFor: 'arithmetic' stamp: 'len 3/29/2016 18:50'!
/ aNumber
	^ self collect: [:each| each / aNumber]! !

!OrderedTuple methodsFor: 'arithmetic' stamp: 'len 3/29/2016 18:50'!
// aNumber
	^ self collect: [:each| each // aNumber]! !

!OrderedTuple methodsFor: 'arithmetic' stamp: 'len 3/29/2016 19:02'!
<< anInteger
	^ self >> anInteger negated! !

!OrderedTuple methodsFor: 'arithmetic' stamp: 'len 3/29/2016 18:45'!
<<< anInteger
	^ self >>> anInteger negated! !

!OrderedTuple methodsFor: 'comparing' stamp: 'len 7/2/2016 06:39'!
= anObject
	self == anObject ifTrue: [^ true].
	(anObject isKindOf: OrderedTuple) ifFalse: [^ false].
	self size = anObject size ifFalse: [^ false].
	1 to: self size do: [:i|
		(self at: i) = (anObject at: i) ifFalse: [^ false]].
	^ true! !

!OrderedTuple methodsFor: 'arithmetic' stamp: 'len 3/29/2016 19:02'!
>> anInteger
	^ self shift: anInteger! !

!OrderedTuple methodsFor: 'arithmetic' stamp: 'len 3/29/2016 18:46'!
>>> anInteger
	| fill |
	(anInteger == 0 or: [self isEmpty]) ifTrue: [^ self].
	anInteger < 0 ifTrue: [^ self copyFrom: anInteger negated + 1 to: self size].
	fill _ self class new: anInteger.
	fill atAllPut: (self at: 1) - (self at: 1).
	^ fill, self! !

!OrderedTuple methodsFor: 'arithmetic' stamp: 'len 3/29/2016 18:46'!
\\ aNumber
	^ self collect: [:each| each \\ aNumber]! !

!OrderedTuple methodsFor: 'converting' stamp: 'len 3/29/2016 18:53'!
adaptToNumber: aNumber andSend: selector
	selector == #* ifTrue:[^ self collect: [:each| aNumber * each]].
	^ super adaptToNumber: aNumber andSend: selector! !

!OrderedTuple methodsFor: 'converting' stamp: 'len 4/8/2016 22:34'!
adaptToRealAlgebraic: aNumber andSend: selector
	^ self adaptToNumber: aNumber andSend: selector! !

!OrderedTuple methodsFor: 'operations' stamp: 'len 3/29/2016 18:54'!
apply: aMorphism
	"Apply a homomorphism to the coefficients of the receiver."
	^ self collect: aMorphism! !

!OrderedTuple methodsFor: 'accessing' stamp: 'len 3/29/2016 18:54'!
bitSize
	| answer |
	answer _ 0.
	self do: [:each| answer _ answer + each bitSize].
	^ answer! !

!OrderedTuple methodsFor: 'arithmetic' stamp: 'len 3/29/2016 18:54'!
conjugated
	^ self collect: [:each| each conjugated]! !

!OrderedTuple methodsFor: 'arithmetic' stamp: 'len 3/30/2016 06:41'!
convolution: aTuple
	| answer |
	self isEmpty ifTrue: [^ self].
	aTuple isEmpty ifTrue: [^ aTuple].
	answer _ self class new: self size + aTuple size.
	answer atAllPut: (self at: 1) zero.
	self withIndexDo: [:xi :i|
		aTuple withIndexDo: [:yj :j|
			answer at: i+j-1 add: xi*yj]].
	^ answer! !

!OrderedTuple methodsFor: 'accessing' stamp: 'len 3/29/2016 19:05'!
dimension
	^ self size! !

!OrderedTuple methodsFor: 'arithmetic' stamp: 'len 4/6/2016 07:18'!
dot: aTuple
	| answer |
	answer _ (self at: 1) * (aTuple at: 1).
	2 to: (self size min: aTuple size) do: [:i| answer _ answer + ((self at: i) * (aTuple at: i))].
	^ answer! !

!OrderedTuple methodsFor: 'converting' stamp: 'len 3/29/2016 18:59'!
homogeneous
	^ HomogeneousTuple coordinates: self! !

!OrderedTuple methodsFor: 'converting' stamp: 'len 3/29/2016 19:00'!
homogenized
	^ HomogeneousTuple coordinates: (self, self first one)! !

!OrderedTuple methodsFor: 'accessing' stamp: 'len 3/29/2016 19:05'!
indices
	^ 1 to: self size! !

!OrderedTuple methodsFor: 'testing' stamp: 'len 3/29/2016 19:04'!
is: aSymbol
	^ aSymbol == #Tuple or: [super is: aSymbol]! !

!OrderedTuple methodsFor: 'testing' stamp: 'len 7/9/2016 02:49'!
isOrdered
	^ true! !

!OrderedTuple methodsFor: 'testing' stamp: 'len 7/9/2016 02:50'!
isSparse
	^ false! !

!OrderedTuple methodsFor: 'testing' stamp: 'len 3/29/2016 19:04'!
isZero
	^ self allSatisfy: [:each| each isZero]! !

!OrderedTuple methodsFor: 'arithmetic' stamp: 'len 3/29/2016 18:56'!
negated
	^ self collect: [:each| each negated]! !

!OrderedTuple methodsFor: 'arithmetic' stamp: 'len 3/29/2016 19:03'!
norm
	^ self norm2 squareRoot! !

!OrderedTuple methodsFor: 'arithmetic' stamp: 'len 3/29/2016 19:03'!
norm2
	^ self dot: self! !

!OrderedTuple methodsFor: 'arithmetic' stamp: 'len 7/17/2016 23:21'!
pointwiseProduct: aTuple
	"Answer the pointwise product with the argument, also called Hadamard product."
	^ self class new: (self size min: aTuple size) evaluating: [:i| (self at: i) * (aTuple at: i)]! !

!OrderedTuple methodsFor: 'printing' stamp: 'len 3/29/2016 19:04'!
printOn: aStream
	aStream nextPut: $(.
	self do: [:x| aStream print: x] separatedBy: [aStream nextPutAll: ','].
	aStream nextPut: $)! !

!OrderedTuple methodsFor: 'operations' stamp: 'len 4/16/2016 08:45'!
support
	^ self indices reject: [:each| (self at: each) isZero]! !

!OrderedTuple methodsFor: 'operations' stamp: 'len 4/16/2016 08:43'!
weight
	^ self count: [:each| each isZero not]! !

!OrderedTuple methodsFor: 'arithmetic' stamp: 'len 4/10/2016 06:44'!
wrap: n
	"Perform a cyclic right shift."
	^ self class new: self size evaluating: [:i| (self at: i-1-n \\ self size + 1)]! !

!OrderedTuple methodsFor: 'accessing' stamp: 'len 3/29/2016 19:06'!
x
	^ self at: 1! !

!OrderedTuple methodsFor: 'accessing' stamp: 'len 3/29/2016 19:06'!
y
	^ self at: 2! !

!OrderedTuple methodsFor: 'accessing' stamp: 'len 3/29/2016 19:06'!
z
	^ self at: 3! !

!OrderedTuple class methodsFor: 'instance creation' stamp: 'len 7/1/2016 21:42'!
new: anInteger evaluating: aBlock
	| array |
	array _ Array new: anInteger.
	1 to: anInteger do: [:i| array at: i put: (aBlock value: i)].
	^ self withAll: array! !

!OrderedTuple class methodsFor: 'instance creation' stamp: 'len 3/30/2016 06:51'!
with: anObject
	^ self withAll: {anObject}! !

!BitTuple methodsFor: 'arithmetic' stamp: 'len 3/29/2016 06:16'!
* aBit
	^ ((aBit isInteger and: [aBit even]) or: [aBit isZero]) ifTrue: [self zero] ifFalse: [self]! !

!BitTuple methodsFor: 'arithmetic' stamp: 'len 7/2/2016 00:51'!
+ aBitTuple
	^ self class new: (self size max: aBitTuple size) fromInteger: (integer bitXor: aBitTuple asInteger)! !

!BitTuple methodsFor: 'copying' stamp: 'len 7/2/2016 00:48'!
, anObject
	((anObject is: #Tuple) or: [anObject is: #Array])
		ifFalse: [^ self copyWith: anObject].
	anObject class = self class
		ifTrue: [^ self class new: size + anObject size fromInteger: (integer bitXor: (anObject asInteger bitShift: size))].
	^ self , (anObject as: self class)! !

!BitTuple methodsFor: 'arithmetic' stamp: 'len 3/28/2016 06:51'!
- aBitTuple
	^ self + aBitTuple! !

!BitTuple methodsFor: 'comparing' stamp: 'len 6/30/2016 06:49'!
= aTuple
	self class = aTuple class ifFalse: [^ super = aTuple].
	^ size = aTuple size and: [integer = aTuple asInteger]! !

!BitTuple methodsFor: 'arithmetic' stamp: 'len 7/2/2016 00:48'!
>>> anInteger
	^ self class new: (size + anInteger max: 0) fromInteger: (integer bitShift: anInteger)! !

!BitTuple methodsFor: 'converting' stamp: 'len 3/28/2016 04:45'!
asInteger
	^ integer! !

!BitTuple methodsFor: 'accessing' stamp: 'len 3/29/2016 06:09'!
at: anInteger
	^ (integer bitAt: anInteger) = 1 ifTrue: [One] ifFalse: [Zero]! !

!BitTuple methodsFor: 'accessing' stamp: 'len 3/30/2016 22:44'!
at: anInteger put: aBit
	| bit |
	anInteger > size ifTrue: [self error: 'index out of bounds'].
	bit _ aBit.
	bit isInteger ifTrue: [bit _ bit % 2].
	(self at: anInteger) = bit
		ifFalse: [integer _ integer bitXor: 1 << (anInteger - 1)].
	^ bit! !

!BitTuple methodsFor: 'arithmetic' stamp: 'len 3/29/2016 06:05'!
convolution: aBitTuple
	| a b c |
	a _ integer.
	b _ aBitTuple asInteger.
	c _ 0.
	1 to: a highBit do: [:i|
		(a bitAt: i) = 1 ifTrue: [c _ c bitXor: b].
		b _ b bitShift: 1].
	^ self class fromInteger: c! !

!BitTuple methodsFor: 'copying' stamp: 'len 7/2/2016 00:49'!
copyFrom: start to: stop 
	"Answer a copy of a subset of the receiver, starting from element at 
	index start until element at index stop."

	| newSize |
	newSize _ stop - start + 1 max: 0.
	start = 1 ifTrue: [^ self class new: newSize fromInteger: integer].
	^ self class new: newSize fromInteger: (integer bitShift: 1 - start)! !

!BitTuple methodsFor: 'arithmetic' stamp: 'len 7/2/2016 00:44'!
dot: aBitTuple
	^ (integer bitAnd: aBitTuple asInteger) bitParity = 0 ifTrue: [Zero] ifFalse: [One]

"	^ self hadamard: aBitTuple :: sum
"

"	| x |
	x _ self asInteger bitAnd: aBitTuple asInteger.
	[x > 1]
		whileTrue: [x _ x >> (x highBit // 2) bitAnd: x].
	^ x"! !

!BitTuple methodsFor: 'comparing' stamp: 'len 6/30/2016 06:50'!
hash
	^ integer hash! !

!BitTuple methodsFor: 'initialization' stamp: 'len 3/28/2016 05:41'!
integer: anInteger size: anotherInteger
	integer _ anInteger.
	size _ anotherInteger! !

!BitTuple methodsFor: 'arithmetic' stamp: 'len 3/28/2016 07:30'!
negated
	^ self! !

!BitTuple methodsFor: 'arithmetic' stamp: 'len 3/28/2016 07:27'!
norm
	^ self sum! !

!BitTuple methodsFor: 'arithmetic' stamp: 'len 3/28/2016 07:27'!
norm2
	^ self sum! !

!BitTuple methodsFor: 'arithmetic' stamp: 'len 7/1/2016 22:58'!
parity
	"Answer 1 if the receiver has an odd number of bits on, 0 if it has an even number of bits on."
	| n parity |
	integer = 0 ifTrue: [^ 0].
"	n _ integer >> (integer lowBit - 1). skip initial zeros, we could also skip chunks of zeros in the middle"
	n _ integer.
	parity _ 0.
	[n = 0] whileFalse: [parity _ parity bitXor: (n bitAnd: 1). n _ n >> 1].
	^ parity! !

!BitTuple methodsFor: 'arithmetic' stamp: 'len 7/17/2016 23:22'!
pointwiseProduct: aBitTuple
	"Answer the pointwise product with the argument, also called Hadamard product."
	^ self class new: (self size min: aBitTuple size) fromInteger: (integer bitAnd: aBitTuple asInteger)! !

!BitTuple methodsFor: 'printing' stamp: 'len 3/28/2016 04:52'!
printOn: aStream
	1 to: self size do: [:i| aStream print: (self at: i)]! !

!BitTuple methodsFor: 'arithmetic' stamp: 'len 7/2/2016 06:01'!
reversed
	^ self class new: self size fromInteger: (integer bitReverse: self size)! !

!BitTuple methodsFor: 'arithmetic' stamp: 'len 7/2/2016 00:49'!
shift: anInteger
	^ self class new: size fromInteger: (integer bitShift: anInteger)! !

!BitTuple methodsFor: 'accessing' stamp: 'len 3/28/2016 06:49'!
size
	^ size! !

!BitTuple methodsFor: 'arithmetic' stamp: 'len 7/2/2016 00:39'!
sum
	"Answer the sum of the bits, i.e. the parity."
	^ integer bitParity = 0 ifTrue: [Zero] ifFalse: [One]! !

!BitTuple methodsFor: 'arithmetic' stamp: 'len 7/2/2016 00:49'!
zero
	^ self class new: self size fromInteger: 0! !

!BitTuple class methodsFor: 'instance creation' stamp: 'len 7/2/2016 00:50'!
fromInteger: anInteger
	^ self new: anInteger highBit fromInteger: anInteger! !

!BitTuple class methodsFor: 'initialization' stamp: 'len 7/15/2016 18:24'!
initialize
	| Z2 |
	super initialize.
	Z2 _ ZZ modPrime: 2.
	One _ Z2 one.
	Zero _ Z2 zero! !

!BitTuple class methodsFor: 'instance creation' stamp: 'len 7/2/2016 00:50'!
new: anInteger
	^ self new: anInteger fromInteger: 0! !

!BitTuple class methodsFor: 'instance creation' stamp: 'len 7/2/2016 00:50'!
new: anInteger evaluating: aBlock
	| integer |
	integer _ 0.
	anInteger to: 1 by: -1 do:
		[:i| integer _ (integer bitShift: 1) bitXor: (aBlock value: i) representative].
	^ self new: anInteger fromInteger: integer! !

!BitTuple class methodsFor: 'instance creation' stamp: 'len 7/2/2016 00:47'!
new: n fromInteger: anInteger
	^ self basicNew integer: anInteger size: n! !

!BitTuple class methodsFor: 'instance creation' stamp: 'len 3/29/2016 18:22'!
newFrom: anObject
	anObject isInteger ifTrue: [^ self fromInteger: anObject].
	^ super newFrom: anObject! !

!ModularTuple methodsFor: 'arithmetic' stamp: 'len 6/29/2016 06:01'!
* aNumber
	^ self class representatives: (representatives collect: [:each| each * aNumber \\ modulus]) modulus: modulus! !

!ModularTuple methodsFor: 'arithmetic' stamp: 'len 6/29/2016 05:59'!
+ aTuple
	| a an b bn c |
	(an _ self size) <= (bn _ aTuple size) ifFalse: [^ aTuple + self].
	a _ representatives.
	b _ aTuple representatives.
	c _ representatives class new: bn.
	1 to: an do: [:i|
		c at: i put: (a at: i) + (c at: i) \\ modulus].
	c replaceFrom: an+1 to: bn with: b startingAt: an+1.
	^ self class representatives: c modulus: modulus! !

!ModularTuple methodsFor: 'comparing' stamp: 'len 6/30/2016 06:51'!
= aTuple
	self class = aTuple class ifFalse: [^ super = aTuple].
	^ modulus = aTuple modulus and: [representatives = aTuple representatives]! !

!ModularTuple methodsFor: 'accessing-private' stamp: 'len 6/29/2016 05:50'!
arrayClass
	modulus <= 255 ifTrue: [^ ByteArray].
	modulus <= 16rFFFFFFFF ifTrue: [^ WordArray].
	^ Array! !

!ModularTuple methodsFor: 'accessing' stamp: 'len 4/25/2016 00:28'!
at: anInteger
	^ (representatives at: anInteger ifAbsent: [0]) % modulus! !

!ModularTuple methodsFor: 'accessing' stamp: 'len 4/25/2016 00:28'!
at: anInteger put: aModularInteger
	aModularInteger isInteger ifTrue: [^ representatives at: anInteger put: aModularInteger \\ modulus].
	representatives at: anInteger put: aModularInteger representative.
	^ aModularInteger! !

!ModularTuple methodsFor: 'comparing' stamp: 'len 6/30/2016 06:52'!
hash
	^ representatives hash! !

!ModularTuple methodsFor: 'accessing-private' stamp: 'len 4/25/2016 00:28'!
modulus
	^ modulus! !

!ModularTuple methodsFor: 'accessing-private' stamp: 'len 4/25/2016 00:28'!
modulus: anInteger
	modulus _ anInteger! !

!ModularTuple methodsFor: 'arithmetic' stamp: 'len 6/29/2016 06:00'!
negated
	^ self class representatives: (representatives collect: [:each| modulus - each]) modulus: modulus! !

!ModularTuple methodsFor: 'printing' stamp: 'len 6/30/2016 06:56'!
printOn: aStream
	modulus > 16 ifTrue: [^ super printOn: aStream].
	1 to: self size do: [:i| (representatives at: i) printOn: aStream base: 16]! !

!ModularTuple methodsFor: 'accessing-private' stamp: 'len 3/31/2016 07:43'!
representatives
	^ representatives! !

!ModularTuple methodsFor: 'accessing-private' stamp: 'len 3/31/2016 07:43'!
representatives: anArray
	representatives _ anArray! !

!ModularTuple methodsFor: 'accessing' stamp: 'len 3/31/2016 07:47'!
size
	^ representatives size! !

!Tuple methodsFor: 'arithmetic' stamp: 'len 3/29/2016 09:13'!
+ aTuple
	| zero |
	self size = aTuple size ifTrue: [^ self class new: self size evaluating: [:i| (self at: i) + (aTuple at: i)]].
	zero _ (self at: 1 ifAbsent: [aTuple at: 1]) zero.
	^ self class new: (self size max: aTuple size) evaluating: [:i| (self at: i ifAbsent: [zero]) + (aTuple at: i ifAbsent: [zero])]! !

!Tuple methodsFor: 'copying' stamp: 'len 4/9/2016 20:41'!
, anObject
	((anObject is: #Tuple) or: [anObject is: #Array])
		ifTrue: [^ self class withAll: (elements, anObject asArray)].
	^ self class withAll: (elements copyWith: anObject)! !

!Tuple methodsFor: 'arithmetic' stamp: 'len 3/30/2016 02:40'!
- aTuple
	| zero |
	self size = aTuple size ifTrue: [^ self class new: self size evaluating: [:i| (self at: i) - (aTuple at: i)]].
	zero _ (self at: 1 ifAbsent: [aTuple at: 1]) zero.
	^ self class new: (self size max: aTuple size) evaluating: [:i| (self at: i ifAbsent: [zero]) - (aTuple at: i ifAbsent: [zero])]! !

!Tuple methodsFor: 'converting' stamp: 'len 3/29/2016 18:57'!
asArray
	^ elements! !

!Tuple methodsFor: 'accessing' stamp: 'len 11/4/2015 22:44'!
at: anInteger
	^ elements at: anInteger! !

!Tuple methodsFor: 'accessing' stamp: 'len 3/29/2016 08:57'!
at: anInteger ifAbsent: aBlock
	^ elements at: anInteger ifAbsent: aBlock! !

!Tuple methodsFor: 'accessing-private' stamp: 'len 11/5/2015 01:21'!
at: anInteger put: anObject
	^ elements at: anInteger put: anObject! !

!Tuple methodsFor: 'iterating' stamp: 'len 11/4/2015 23:05'!
collect: aBlock
	^ self class withAll: (elements collect: aBlock)! !

!Tuple methodsFor: 'copying' stamp: 'len 11/5/2015 00:34'!
copy
	^ self class withAll: elements copy! !

!Tuple methodsFor: 'copying' stamp: 'len 3/31/2016 08:40'!
copyFrom: start to: stop
	^ self class withAll: (elements copyFrom: start to: stop)
"	^ self class
		new: end - start + 1
		evaluating: [:i| self at: start + i - 1]"! !

!Tuple methodsFor: 'iterating' stamp: 'len 11/4/2015 23:04'!
do: aBlock
	elements do: aBlock! !

!Tuple methodsFor: 'initialization' stamp: 'len 11/30/2015 06:18'!
elements: anArray
	elements _ anArray! !

!Tuple methodsFor: 'testing' stamp: 'len 11/10/2015 17:28'!
includes: anObject
	^ elements includes: anObject! !

!Tuple methodsFor: 'accessing' stamp: 'len 12/21/2015 22:49'!
last
	^ self at: self size! !

!Tuple methodsFor: 'operations' stamp: 'len 3/29/2016 17:59'!
shift: anInteger
	| newElements zero n |
	anInteger == 0 ifTrue: [^ self].
	newElements _ Array new: self size.
	zero _ (self at: 1) - (self at: 1).
	n _ self size min: anInteger max: self size negated.
	n > 0
		ifTrue:
			[1 to: n do: [:i| newElements at: i put: zero].
			1+n to: self size do: [:i| newElements at: i put: (self at: i-n)]]
		ifFalse:
			[self size + n + 1 to: self size do: [:i| newElements at: i put: zero].
			1 to: self size + n do: [ :i | newElements at: i put: (self at: i-n)]].
	^ self class withAll: newElements! !

!Tuple methodsFor: 'accessing' stamp: 'len 11/20/2015 06:05'!
size
	^ elements size! !

!Tuple methodsFor: 'accessing-private' stamp: 'len 3/21/2016 05:13'!
swap: i with: j
	elements swap: i with: j! !

!Tuple methodsFor: 'iterating' stamp: 'len 2/28/2016 07:59'!
withIndexDo: aBlock
	elements withIndexDo: aBlock! !

!Tuple methodsFor: 'operations' stamp: 'len 4/10/2016 06:44'!
wrap: n
	"Perform a cyclic right shift."
	| newElements |
	newElements _ Array new: self size.
	0 to: self size - 1 do: [:i| newElements at: i+1 put: (self at: i-n \\ self size + 1) ].
	^ self class withAll: newElements! !

!Tuple class methodsFor: 'instance creation' stamp: 'len 11/30/2015 06:15'!
empty
	^ self withAll: #()! !

!Tuple class methodsFor: 'instance creation' stamp: 'len 3/26/2016 23:23'!
new: anInteger
	^ self withAll: (Array new: anInteger)! !

!Tuple class methodsFor: 'instance creation' stamp: 'len 3/26/2016 23:24'!
withAll: anArray
	^ self basicNew elements: anArray asArray! !

!BitArray methodsFor: 'arithmetic' stamp: 'len 12/21/2015 22:15'!
* aBitArray
	| answer |
	answer _ self class new: (self size max: aBitArray size).
	1 to: answer byteSize do: [:i|
		answer byteAt: i put: ((self byteAt: i) bitAnd: (aBitArray byteAt: i))].
	^ answer! !

!BitArray methodsFor: 'arithmetic' stamp: 'len 12/21/2015 22:14'!
+ aBitArray
	| answer |
	answer _ self class new: (self size max: aBitArray size).
	1 to: answer byteSize do: [:i|
		answer byteAt: i put: ((self byteAt: i) bitXor: (aBitArray byteAt: i))].
	^ answer! !

!BitArray methodsFor: 'converting' stamp: 'len 12/21/2015 22:17'!
asByteArray
	^ bytes! !

!BitArray methodsFor: 'converting' stamp: 'len 12/21/2015 22:21'!
asInteger
	"Answer the receiver as a possitive integer."
	| answer i |
	answer _ 0.
	i _ 0.
	bytes do: [:each| answer _ answer + (each bitShift: i). i _ i + 8].
	^ answer! !

!BitArray methodsFor: 'accessing' stamp: 'len 12/21/2015 22:30'!
at: anInteger
	^ (bytes at: anInteger - 1 // 8 + 1 ifAbsent: [^ 0]) bitAt: anInteger - 1 \\ 8 + 1! !

!BitArray methodsFor: 'accessing' stamp: 'len 12/21/2015 22:07'!
at: anInteger put: aBit
	| i i0 b |
	i _ anInteger - 1 // 8 + 1.
	i0 _ anInteger - 1 \\ 8 + 1.
	b _ bytes at: i.
	(b bitAt: i0) == aBit
		ifFalse: [b _ b bitXor: (1 bitShift: i0-1)].
	bytes at: i put: b.
	^ aBit! !

!BitArray methodsFor: 'accessing' stamp: 'len 12/21/2015 22:16'!
byteAt: anInteger
	^ bytes at: anInteger ifAbsent: [0]! !

!BitArray methodsFor: 'accessing' stamp: 'len 12/21/2015 22:16'!
byteAt: anInteger put: aByte
	^ bytes at: anInteger put: aByte! !

!BitArray methodsFor: 'initialization' stamp: 'len 12/21/2015 20:31'!
bytes: aByteArray length: anInteger
	bytes _ aByteArray.
	length _ anInteger! !

!BitArray methodsFor: 'printing' stamp: 'len 12/21/2015 20:42'!
printOn: aStream
	1 to: self size do: [:i| aStream print: (self at: i)]! !

!BitArray methodsFor: 'accessing' stamp: 'len 12/21/2015 20:41'!
size
	^ length! !

!BitArray class methodsFor: 'instance creation' stamp: 'len 12/21/2015 20:41'!
new: anInteger
	^ self new: anInteger bytes: (ByteArray new: (anInteger / 8) ceiling)! !

!BitArray class methodsFor: 'instance creation' stamp: 'len 12/21/2015 20:40'!
new: anInteger bytes: aByteArray
	^ self basicNew bytes: aByteArray length: anInteger! !

!BitArray class methodsFor: 'instance creation' stamp: 'len 12/21/2015 22:26'!
random: anInteger
	| answer |
	answer _ self new: anInteger.
	1 to: answer size do: [:i| answer at: i put: 2 atRandom - 1].
	^ answer! !

!LinearBasis methodsFor: 'comparing' stamp: 'len 7/1/2016 21:35'!
= aLinearBasis
	self == aLinearBasis ifTrue: [^ true].
	^ ambient = aLinearBasis ambient and: [vectors = aLinearBasis vectors]! !

!LinearBasis methodsFor: 'operations' stamp: 'len 7/14/2016 23:08'!
 aLinearBasis
	| sum |
	sum _ ambient  aLinearBasis ambient.
	^ self class on: sum vectors: (self vectors collect: [:each| Tuple with: each with: aLinearBasis ambient zero]), (aLinearBasis vectors collect: [:each| Tuple with: ambient zero with: each])! !

!LinearBasis methodsFor: 'accessing' stamp: 'len 11/7/2015 01:53'!
add: anObject
	^ vectors add: anObject! !

!LinearBasis methodsFor: 'accessing' stamp: 'len 11/7/2015 01:37'!
addAll: aCollection
	aCollection do: [ :each | self add: each].
	^ aCollection! !

!LinearBasis methodsFor: 'accessing' stamp: 'len 5/23/2016 19:28'!
ambient
	"Answer the ambient vector space."
	^ ambient! !

!LinearBasis methodsFor: 'accessing-private' stamp: 'len 5/23/2016 04:44'!
ambient: aVectorSpace
	ambient _ aVectorSpace! !

!LinearBasis methodsFor: 'operations' stamp: 'len 7/10/2016 05:23'!
apply: aLinearMap
	| answer vector |
	answer _ self class on: (aLinearMap isBlock ifTrue: [ambient] ifFalse: [aLinearMap codomain]).
	self do: [:each|
		(answer generates: (vector _ aLinearMap value: each))
			ifFalse: [answer add: vector]].
	^ answer! !

!LinearBasis methodsFor: 'accessing' stamp: 'len 11/7/2015 03:04'!
at: anInteger
	^ vectors at: anInteger! !

!LinearBasis methodsFor: 'accessing' stamp: 'len 11/7/2015 03:05'!
at: anInteger put: anObject
	^ vectors at: anInteger put: anObject! !

!LinearBasis methodsFor: 'operations' stamp: 'len 5/23/2016 04:43'!
changeTo: aLinearBasis
	"Answer the matrix for changing from the receiver to aLinearBasis."
	| matrix |
	matrix _ (ambient scalars ** (self size @ aLinearBasis size)) new.
	self do: [ :each | matrix addRow: (aLinearBasis coordinatesOf: each)].
	^ matrix transposed! !

!LinearBasis methodsFor: 'iterating' stamp: 'len 5/23/2016 04:32'!
collect: aBlock
	"Answer a copy of the receiver with the vectors mapped by aBlock."

	| answer |
	answer _ self species on: ambient.
	self do: [:each| answer add: (aBlock value: each)].
	^ answer! !

!LinearBasis methodsFor: 'coordinates' stamp: 'len 5/23/2016 04:32'!
coordinateSpace
	^ ambient scalars ** self size! !

!LinearBasis methodsFor: 'coordinates' stamp: 'len 5/25/2016 19:54'!
coordinatesOf
	"Answer the linear isomorphism mapping a vector to its coordinates in the receiver."
	^ LinearMap
		from: self
		to: self coordinateSpace basis
		matrix: (ambient scalars ** (self size @ self size)) identity! !

!LinearBasis methodsFor: 'coordinates' stamp: 'len 5/23/2016 04:43'!
coordinatesOf: anObject
	"Answer the coordinates of anObject when expressed as a linear combination of the vectors of the receiver.
	Answer nil if anObject is independent from the receiver."

	| m reducer coords answer |
	1 to: self size do: [ :i |
		(self at: i) = anObject ifTrue: [^ self coordinateSpace e: i]].
	m _ self matrix rowAugmented: (ambient coordinatesOf: anObject).
	reducer _ m transposed reducer.
	coords _ reducer reduced lastColumn.
	^ reducer rank > self size
		ifFalse:
			[answer _ self coordinateSpace zero copy.
			reducer pivots do: [:each| answer at: each x put: (coords at: each y)].
			answer]! !

!LinearBasis methodsFor: 'copying' stamp: 'len 5/23/2016 04:42'!
copy
	^ self class on: ambient :: addAll: self; yourself! !

!LinearBasis methodsFor: 'copying' stamp: 'len 5/23/2016 04:42'!
copyFrom: startIndex to: endIndex
	| answer |
	answer _ self class on: ambient.
	startIndex to: endIndex do: [:i| answer add: (self at: i)].
	^ answer! !

!LinearBasis methodsFor: 'iterating' stamp: 'len 11/7/2015 01:58'!
do: aBlock 
	vectors do: aBlock! !

!LinearBasis methodsFor: 'operations' stamp: 'len 5/23/2016 04:32'!
dual
	| answer extendedBasis |
	extendedBasis _ self extended.
	answer _ self class on: ambient dual.
	self do: [:each|
		answer add:
			(LinearForm
				from: extendedBasis coordinates: (extendedBasis coordinatesOf: each))].
	^ answer! !

!LinearBasis methodsFor: 'coordinates' stamp: 'len 7/10/2016 07:31'!
elementAt: aTuple 
	"Answer the vector with coordinates aTuple when expressed as a linear combination of the receiver."
	| answer |
"	self assert: aTuple size = self size."
	1 to: aTuple size do: [ :each |
		answer _ answer isNil
			ifTrue: [(self at: each) * (aTuple at: each)]
			ifFalse: [(self at: each) * (aTuple at: each) + answer]].
	^ answer! !

!LinearBasis methodsFor: 'operations' stamp: 'len 5/23/2016 04:43'!
extended
	"Answer a basis spanning to all the ambient space, adding generating vectors if needed."

	| answer |
	answer _ self copy.
	ambient basis do: [:each|
		(answer generates: each) ifFalse: [answer add: each]].
	^ answer! !

!LinearBasis methodsFor: 'accessing' stamp: 'len 10/17/97 02:54'!
first
	"Answer the first vector of the receiver."

	^ self at: 1! !

!LinearBasis methodsFor: 'testing' stamp: 'len 11/8/2015 04:57'!
generates: anObject
	"Answer true if the argument is dependent to the receiver."

	self isEmpty ifTrue: [^ anObject isZero].
	^ (self coordinatesOf: anObject) notNil! !

!LinearBasis methodsFor: 'operations' stamp: 'len 5/23/2016 04:32'!
gramian
	"Answer the Gramian of the receiver, or Gram matrix.
	If M is the generator matrix of the receiver (self matrix), then the Gramian is M * M transposed."
	^ ambient scalars ** (self size @ self size)
		evaluating:
			[:i :j| ambient innerProduct value: {(self at: i). (self at: j)}]! !

!LinearBasis methodsFor: 'comparing' stamp: 'len 11/7/2015 01:57'!
hash
	^ vectors hash! !

!LinearBasis methodsFor: 'testing' stamp: 'len 11/26/2015 02:39'!
includes: anObject
	^ vectors includes: anObject! !

!LinearBasis methodsFor: 'initialization' stamp: 'len 11/7/2015 01:58'!
initialize
	vectors _ OrderedCollection new! !

!LinearBasis methodsFor: 'testing' stamp: 'len 11/7/2015 02:11'!
isEmpty
	^ self size = 0! !

!LinearBasis methodsFor: 'testing' stamp: 'len 5/23/2016 04:42'!
isOrthogonal
	self do: [:v|
		self do: [:w|
			(v ~~ w and: [(ambient innerProduct value: {v.w}) isZero not])
				ifTrue: [^ false]]].
	^ true! !

!LinearBasis methodsFor: 'testing' stamp: 'len 5/23/2016 04:43'!
isOrthonormal
	self isOrthogonal ifFalse: [^ false].
	self do: [:v| (ambient innerProduct value: {v.v}) = ambient scalars one ifFalse: [^ false]].
	^ true! !

!LinearBasis methodsFor: 'accessing' stamp: 'len 1/27/98 05:23'!
last
	"Answer the last vector of the receiver."

	^ self at: self size! !

!LinearBasis methodsFor: 'accessing' stamp: 'len 7/15/2016 05:09'!
matrix
	"Answer the generator matrix M, i.e. the matrix whose rows are the canonical coordinates of the vectors of the receiver.
	Vectors in the linear subspace generated by the receiver are of the form (a1,...,an)*M."
	
	| rows |
	rows _ OrderedCollection new: self size.
	self do: [:v| rows add: (ambient coordinatesOf: v)].
	^ (ambient scalars ** (self size @ (rows max: [:each| each size]))) rows: rows! !

!LinearBasis methodsFor: 'operations' stamp: 'len 12/23/2015 05:19'!
orthogonalized
	"Answer the receiver orthogonalized by the Gram-Schmidt process."
	^ (GramSchmidt basis: self) orthogonalBasis! !

!LinearBasis methodsFor: 'operations' stamp: 'len 2/6/2016 20:40'!
orthonormalized
	"Answer the receiver orthonormalized by the Gram-Schmidt process."
	^ (GramSchmidt basis: self) orthonormalBasis! !

!LinearBasis methodsFor: 'printing' stamp: 'len 12/10/2015 03:27'!
printOn: aStream
	aStream nextPut: ${.
	vectors do: [:each| aStream print: each] separatedBy: [aStream nextPutAll: '; '].
	aStream nextPut: $}! !

!LinearBasis methodsFor: 'iterating' stamp: 'len 5/23/2016 04:43'!
select: aBlock 
	"Evaluate aBlock with each of the receiver's elements as the argument. 
	Collect into a new collection like the receiver, only those elements for 
	which aBlock evaluates to true. Answer the new collection."

	| newCollection |
	newCollection _ self class on: ambient.
	self do: [:each | (aBlock value: each) ifTrue: [newCollection add: each]].
	^ newCollection! !

!LinearBasis methodsFor: 'accessing' stamp: 'len 11/7/2015 01:54'!
size
	"Answer the number of vectors in the receiver."

	^ vectors size! !

!LinearBasis methodsFor: 'accessing' stamp: 'len 10/7/2016 08:50'!
span
	"Answer the subspace generated by the vectors of the receiver."
	^ Submodule basis: self! !

!LinearBasis methodsFor: 'coordinates' stamp: 'len 5/25/2016 19:54'!
vectorAt
	"Answer the linear isomorphism mapping a Tuple to the vector with those coordinates in the receiver."
	^ LinearMap
		from: self coordinateSpace basis
		to: self
		matrix: (ambient scalars ** (self size @ self size)) identity! !

!LinearBasis methodsFor: 'coordinates' stamp: 'len 7/10/2016 07:31'!
vectorAt: aTuple 
	"Answer the vector with coordinates aTuple when expressed as a linear combination of the receiver."
	^ self elementAt: aTuple! !

!LinearBasis methodsFor: 'accessing-private' stamp: 'len 11/7/2015 01:56'!
vectors
	^ vectors! !

!LinearBasis methodsFor: 'accessing-private' stamp: 'len 3/5/2016 01:31'!
vectors: aCollection
	vectors _ aCollection! !

!LinearBasis class methodsFor: 'instance creation' stamp: 'len 8/21/97 00:37'!
new
	^ super new initialize! !

!LinearBasis class methodsFor: 'instance creation' stamp: 'len 5/23/2016 04:44'!
on: aVectorSpace
	^ self new ambient: aVectorSpace! !

!LinearBasis class methodsFor: 'instance creation' stamp: 'len 1/2/2016 07:58'!
on: aVectorSpace matrix: aMatrix
	^ self on: aVectorSpace vectors: (aMatrix rows collect: [:each| aVectorSpace vectorAt: each])! !

!LinearBasis class methodsFor: 'instance creation' stamp: 'len 3/5/2016 01:31'!
on: aVectorSpace vectors: aCollection 
	"Answer a new instance of the receiver with the given vectors."
	^ self on: aVectorSpace :: vectors: aCollection; yourself! !

!GroebnerBasis methodsFor: 'accessing' stamp: 'len 11/20/2015 05:09'!
add: aPolynomial
	^ polynomials add: aPolynomial! !

!GroebnerBasis methodsFor: 'accessing' stamp: 'len 11/20/2015 05:09'!
addAll: aCollection
	^ polynomials addAll: aCollection! !

!GroebnerBasis methodsFor: 'iterating' stamp: 'len 7/8/2016 20:57'!
apply: aMorphism
	| answer |
	answer _ self copyEmpty.
	self do: [:each| answer add: (aMorphism value: each)].
	^ answer! !

!GroebnerBasis methodsFor: 'accessing' stamp: 'len 11/20/2015 05:58'!
at: anInteger
	^ polynomials at: anInteger! !

!GroebnerBasis methodsFor: 'operations' stamp: 'len 6/22/2016 03:51'!
coordinatesOf: aPolynomial 
	^ (MultiPolynomialDivision
		divide: aPolynomial
		by: self
		ordering: self ordering) quotients! !

!GroebnerBasis methodsFor: 'copying' stamp: 'len 11/24/2015 00:00'!
copy
	"Answer a copy of the reciever."
	^ self class new polynomials: polynomials copy; ordering: ordering; isMinimal: isMinimal! !

!GroebnerBasis methodsFor: 'copying' stamp: 'len 7/8/2016 20:57'!
copyEmpty
	^ self class new ordering: ordering! !

!GroebnerBasis methodsFor: 'copying' stamp: 'len 11/23/2015 23:54'!
copyWithout: aPolynomial
	^ self class new ordering: ordering; polynomials: (polynomials copyWithout: aPolynomial)! !

!GroebnerBasis methodsFor: 'iterating' stamp: 'len 11/20/2015 05:20'!
do: aBlock
	polynomials do: aBlock! !

!GroebnerBasis methodsFor: 'accessing' stamp: 'len 11/21/2015 00:10'!
first
	^ self at: 1! !

!GroebnerBasis methodsFor: 'accessing' stamp: 'len 11/21/2015 00:25'!
indeterminates
	^ ordering indeterminates! !

!GroebnerBasis methodsFor: 'operations' stamp: 'len 7/7/2016 07:34'!
initial
	"Answer the Groebner basis made of all leading monomials of polynomials in the receiver."
	| answer |
	answer _ self class new ordering: ordering.
	self do: [:each| | lt | lt _ each leadingTerm. (answer reduces: lt) ifFalse: [answer add: lt]].
	^ answer! !

!GroebnerBasis methodsFor: 'initialization' stamp: 'len 11/23/2015 23:56'!
initialize
	polynomials _ OrderedCollection new.
	isMinimal _ false! !

!GroebnerBasis methodsFor: 'testing' stamp: 'len 7/7/2016 02:22'!
isMinimal
	"A Groebner basis G is minimal when for all p in G:
	1. LC(p) = 1;
	2. LT(p) is not in <G-{p}>."
	| one |
	one _ self first scalars one.
	"Check all polynomials are monic:"
	self do: [:each| (ordering leadingCoefficientOf: each) ~= one ifTrue: [^ false]].
	self do: [:each| "Check if the basis without it still generates its leading term:"
		((self copyWithout: each) reduces: (ordering leadingTermOf: each))
				ifTrue: [^ false]].
	^ true! !

!GroebnerBasis methodsFor: 'accessing-private' stamp: 'len 11/24/2015 00:04'!
isMinimal: aBoolean
	isMinimal _ aBoolean! !

!GroebnerBasis methodsFor: 'testing' stamp: 'len 7/7/2016 02:23'!
isReduced
	"A Groebner basis G is reduced when for all p in G:
	1. LC(p) = 1;
	2. No monomial of p is contained in <G-{p}>."
	| one subBasis |
	one _ self first scalars one.
	"Check all polynomials are monic:"
	self do: [:each| (ordering leadingCoefficientOf: each) ~= one ifTrue: [^ false]].
	self do: [:each| "Check if the basis without it still generates its monomials:"
		subBasis _ self copyWithout: each.
		each terms do: [:other| (subBasis reduces: other) ifTrue: [^ false]]].
	^ true! !

!GroebnerBasis methodsFor: 'testing' stamp: 'len 6/3/2016 04:17'!
isTrivial
	"Answer true if the basis is {1}."
	^ polynomials size = 1 and: [polynomials first isConstant and: [polynomials first isMonic]]
"	^ polynomials anySatisfy: [:f| f isConstant]"! !

!GroebnerBasis methodsFor: 'operations' stamp: 'len 3/1/2016 19:50'!
minimal
	"Answer the minimal Groebner basis of the receiver."
	| monics leadings goods answer |
	isMinimal == true ifTrue: [^ self].
	monics _ polynomials collect: [:each | each / (each coefficientAt: (self ordering headOf: each))].
	leadings _ (1 to: monics size) collect: [:each | ordering headOf: (monics at: each)].
	goods _ (1 to: monics size) asSet.
	1 to: monics size do: [:each |
		(goods
			detect: [:one | each ~= one and: [(leadings at: one) | (leadings at: each)]]
			ifNone: []) notNil ifTrue: [goods remove: each]].
	answer _ self class new ordering: ordering.
	goods do: [:each | answer add: (monics at: each)].
	answer isMinimal: true.
	^ answer! !

!GroebnerBasis methodsFor: 'accessing' stamp: 'pdm 3/9/98 16:30'!
ordering
	"Answer the monomial ordering of the receiver."
	^ ordering! !

!GroebnerBasis methodsFor: 'accessing-private' stamp: 'pdm 8/17/1998 20:48'!
ordering: aMonomialOrdering 
	"Change the monomial ordering of the receiver."
	ordering _ aMonomialOrdering! !

!GroebnerBasis methodsFor: 'operations' stamp: 'len 6/22/2016 03:52'!
polynomialAt: aTuple
	^ (1 to: aTuple size) sum: [:i| (self at: i) * (aTuple at: i)]! !

!GroebnerBasis methodsFor: 'accessing-private' stamp: 'len 11/23/2015 23:51'!
polynomials: aCollection
	polynomials _ aCollection! !

!GroebnerBasis methodsFor: 'printing' stamp: 'len 11/24/2015 07:18'!
printOn: aStream
	aStream nextPut: ${.
	polynomials do: [:each| aStream print: each] separatedBy: [aStream nextPutAll: '. '].
	aStream nextPut: $}! !

!GroebnerBasis methodsFor: 'operations' stamp: 'len 9/7/2016 02:44'!
reduce: aPolynomial 
	"Answer the remainder of the argument when divided by the receiver."
	| division |
	division _ MultiPolynomialDivision
		divide: aPolynomial
		by: self
		ordering: self ordering.
"	division verify ifFalse: [self halt]."
	^ division remainder! !

!GroebnerBasis methodsFor: 'operations' stamp: 'len 7/7/2016 21:02'!
reduced
	| minimal |
	minimal _ self minimal.
	minimal isReduced ifFalse: [self halt].
	^ minimal! !

!GroebnerBasis methodsFor: 'testing' stamp: 'len 7/7/2016 05:08'!
reduces: aPolynomial
	self isEmpty ifTrue: [^ false].
	^ (self reduce: aPolynomial) isZero! !

!GroebnerBasis methodsFor: 'accessing' stamp: 'len 11/20/2015 05:10'!
size
	^ polynomials size! !

!GroebnerBasis methodsFor: 'private' stamp: 'len 3/6/2016 20:37'!
species
	^ Array! !

!GroebnerBasis methodsFor: 'private' stamp: 'len 7/7/2016 04:45'!
verify
	1 to: self size do: [:i|
		| fi hi ci |
		fi _ self at: i.
		hi _ ordering headOf: fi.
		ci _ fi coefficientAt: hi.
		i+1 to: self size do: [:j|
			| fj hj cj lcm |
			fj _ self at: j.
			hj _ ordering headOf: fj.
			cj _ fj coefficientAt: hj.
			lcm _ hi lcm: hj.
			(self reduces: fi * (lcm / hi) / ci - (fj * (lcm / hj) / cj))
				ifFalse: [^ false halt]]].
	^ true! !

!GroebnerBasis class methodsFor: 'instance creation' stamp: 'len 7/7/2016 20:44'!
from2: aCollection ordering: aMonomialOrdering 
	"Buchberger algorithm.
	Answer a Groebner basis obtainded from the given polynomials and ordering."
	| basis newPolynomials rem lcm fi hi ci fk hk ck heads start |
	aCollection anyOne scalars isField ifFalse: [^ DomainError signal: 'not over a field'].
	basis _ self new ordering: aMonomialOrdering; addAll: aCollection; yourself.
	heads _ Dictionary2 new.
	start _ 1.
	[newPolynomials _ OrderedCollection new.
	1 to: basis size do: [:i|
		fi _ basis at: i.
		hi _ heads at: i ifAbsentPut: [aMonomialOrdering headOf: fi].
		ci _ fi coefficientAt: hi.
		i+start to: basis size do: [:k|
			fk _ basis at: k.
			hk _ heads at: k ifAbsentPut: [aMonomialOrdering headOf: fk].
			ck _ fk coefficientAt: hk.
			lcm _ hi lcm: hk.
"			(lcm ~= (hi * hk) and: [heads anySatisfy: [:any| any | lcm]]) ifFalse:"
			rem _ basis reduce: fi * (lcm / hi) / ci - (fk * (lcm / hk) / ck).
			rem isZero ifFalse: ["Display fill: (i@k*4 extent: 3@3) fillColor: Color yellow." newPolynomials add: rem]]].
	newPolynomials isEmpty]
		whileFalse: "this is like Magma's ReduceByNew=True"
			[start _ basis size.
			basis add: newPolynomials first.
			newPolynomials allButFirstDo: [:each| (basis reduce: each) isZero ifFalse: [basis add: each]]].
	^ basis! !

!GroebnerBasis class methodsFor: 'instance creation' stamp: 'len 7/7/2016 20:44'!
from3: aCollection ordering: aMonomialOrdering 
	"Answer a new instance of the receiver representing a Groebner basis obtainded from aCollection of polynomials operating with the ordering aMonomialOrdering."
	| basis fi hi ci fk hk ck lcm rem heads start i |
	aCollection anyOne scalars isField ifFalse: [^ DomainError signal: 'not over a field'].
	basis _ self new ordering: aMonomialOrdering; addAll: aCollection; yourself.
	heads _ Dictionary2 new.
	start _ 1.
	i _ 0.
	[(i _ i + 1) <= basis size] whileTrue:
		[fi _ basis at: i.
		hi _ heads at: i ifAbsentPut: [aMonomialOrdering headOf: fi].
		ci _ fi coefficientAt: hi.
		i+start to: basis size do: [:k|
			[fk _ basis at: k.
			hk _ heads at: k ifAbsentPut: [aMonomialOrdering headOf: fk].
			ck _ fk coefficientAt: hk.
			lcm _ hi lcm: hk.
			rem _ basis reduce: fi * (lcm / hi) / ci - (fk * (lcm / hk) / ck).
			rem isZero ifFalse: ["Display fill: (i@k*4 extent: 3@3) fillColor: Color yellow." basis add: rem]]]].
	^ basis! !

!GroebnerBasis class methodsFor: 'instance creation' stamp: 'len 7/7/2016 20:45'!
from4: aCollection ordering: aMonomialOrdering 
	"Buchberger algorithm.
	Answer a Groebner basis obtainded from the given polynomials and ordering."
	| basis newPolynomials rem lcm fi hi ci fk hk ck heads start pairsDone |
	aCollection anyOne scalars isField ifFalse: [^ DomainError signal: 'not over a field'].
	basis _ self new ordering: aMonomialOrdering; addAll: aCollection; yourself.
	heads _ Dictionary2 new.
	start _ 1.
	pairsDone _ Set new.
	[newPolynomials _ OrderedCollection new.
	1 to: basis size do: [:i|
		fi _ basis at: i.
		hi _ heads at: i ifAbsentPut: [aMonomialOrdering headOf: fi].
		ci _ fi coefficientAt: hi.
		i+1"start" to: basis size do: [:k|
			pairsDone add: i@k ifAbsent: [fk _ basis at: k.
			hk _ heads at: k ifAbsentPut: [aMonomialOrdering headOf: fk].
			ck _ fk coefficientAt: hk.
			lcm _ hi lcm: hk.
			lcm = (hi * hk) ifFalse:
				[rem _ basis reduce: fi * (lcm / hi) / ci - (fk * (lcm / hk) / ck).
				rem isZero ifFalse: ["Display fill: (i@k*4 extent: 3@3) fillColor: Color yellow." newPolynomials add: rem]]]]].
	newPolynomials isEmpty]
		whileFalse: "this is like Magma's ReduceByNew=True"
			[start _ basis size.
			basis add: newPolynomials first.
			newPolynomials allButFirstDo: [:each| (basis reduce: each) isZero ifFalse: [basis add: each]]].
	^ basis! !

!GroebnerBasis class methodsFor: 'instance creation' stamp: 'len 3/16/2016 04:30'!
from: aCollection
	"Answer a new instance of the receiver representing a Groebner basis obtainded from aCollection of generators."
	^ self from: aCollection ordering: aCollection anyOne species ordering! !

!GroebnerBasis class methodsFor: 'instance creation' stamp: 'len 7/9/2016 00:11'!
from: aCollection ordering: aMonomialOrdering 
	"Buchberger algorithm.
	Answer a Groebner basis obtainded from the given polynomials and ordering."
	| G S heads |
	aCollection anyOne scalars isField ifFalse: [^ DomainError signal: 'not over a field'].
	G _ self new ordering: aMonomialOrdering; yourself.
	S _ aCollection.
	heads _ OrderedCollection new.
	[S do: [:f| (G reduces: f) ifFalse: [G add: f]].
	S _ Set2 new.
	1 to: G size do: [:i| | fi hi ci |
		fi _ G at: i.
		hi _ i = (heads size + 1) ifTrue: [heads add: (aMonomialOrdering headOf: fi)] ifFalse: [heads at: i].
		ci _ fi coefficientAt: hi.
		i+1 to: G size do: [:k| | fk hk ck lcm r |
			fk _ G at: k.
			hk _ k = (heads size + 1) ifTrue: [heads add: (aMonomialOrdering headOf: fk)] ifFalse: [heads at: k].
			lcm _ hi lcm: hk.
			"Buchberger criterium 1 and 2:"
			(lcm ~= (hi * hk) and: [((1 to: i-1) noneSatisfy: [:j| (heads at: j) | lcm])])
				ifTrue:
					[ck _ fk coefficientAt: hk.
					r _ G reduce: fi * (lcm / hi) / ci - (fk * (lcm / hk) / ck).
					r isZero
"						ifTrue: [Display fill: (i@k*4 extent: 3@3) fillColor: Color red]"
						ifFalse: [
"							Display fill: (i@k*4 extent: 3@3) fillColor: Color green."
							S add: r]]]].
	S isEmpty] whileFalse.
"	G verify ifFalse: [self halt]."
	^ G! !

!GroebnerBasis class methodsFor: 'instance creation' stamp: 'len 11/20/2015 05:16'!
new
	^ super new initialize! !

!SparseTuple methodsFor: 'arithmetic' stamp: 'len 3/1/2016 02:51'!
* aNumber
	^ self collect: [:each| each*aNumber]! !

!SparseTuple methodsFor: 'arithmetic' stamp: 'len 3/1/2016 03:49'!
+ aSparseTuple
	| answer |
	answer _ self copy.
	aSparseTuple keysAndValuesDo: [:key :value| answer at: key add: value].
	^ answer! !

!SparseTuple methodsFor: 'arithmetic' stamp: 'len 3/2/2016 03:51'!
- aSparseTuple
	| answer |
	answer _ self copy.
	aSparseTuple keysAndValuesDo: [:key :value| answer at: key add: value negated].
	^ answer! !

!SparseTuple methodsFor: 'accessing' stamp: 'len 3/1/2016 02:49'!
at: anObject
	^ self at: anObject ifAbsent: [zero]! !

!SparseTuple methodsFor: 'accessing' stamp: 'len 3/2/2016 02:19'!
at: key add: value
	| index assoc |
	index _ self findElementOrNil: key.
	assoc _ array at: index.
	assoc
		ifNil:
			[value isZero ifFalse: [self atNewIndex: index put: (Association key: key value: value)]]
		ifNotNil:
			[|newValue|
			newValue _ assoc value + value.
			newValue isZero
				ifTrue:
					[array at: index put: nil.
					tally _ tally - 1.
					self fixCollisionsFrom: index]
				ifFalse: [assoc value: newValue].
			^ newValue].
	^ value! !

!SparseTuple methodsFor: 'accessing' stamp: 'len 3/1/2016 02:51'!
at: key put: value
	value isZero ifTrue: [self removeKey: key ifAbsent: []. ^ value].
	^ super at: key put: value! !

!SparseTuple methodsFor: 'accessing' stamp: 'len 3/1/2016 16:02'!
bitSize
	| answer |
	answer _ 0.
	self keysAndValuesDo: [:key :value| answer _ answer + key bitSize + value bitSize].
	^ answer! !

!SparseTuple methodsFor: 'enumerating' stamp: 'len 3/19/2016 04:03'!
collect2: aBlock
	"this doesn't work because it can produce zeros"
	^ self copy associationsDo: [:each| each value: (aBlock value: each value)]! !

!SparseTuple methodsFor: 'enumerating' stamp: 'len 3/28/2016 06:39'!
collectNoZero: aBlock
	"The result of aBlock must never be zero."
	^ self copy associationsDo: [:each| each value: (aBlock value: each value)]! !

!SparseTuple methodsFor: 'arithmetic' stamp: 'len 7/5/2016 06:50'!
convolution: aSparseTuple
	| answer |
	answer _ self class new: self size + aSparseTuple size zero: zero.
	self keysAndValuesDo: [:key :value|
		aSparseTuple keysAndValuesDo: [:key2 :value2|
			answer at: key*key2 add: value*value2]].
	^ answer! !

!SparseTuple methodsFor: 'arithmetic' stamp: 'len 3/28/2016 01:27'!
dot: aSparseTuple
	| answer |
	self size <= aSparseTuple size ifFalse: [^ aSparseTuple dot: self].
	answer _ zero.
	self keysAndValuesDo: [:key :value|
		aSparseTuple at: key ifPresent: [:value2| answer _ answer + (value*value2)]].
	^ answer	! !

!SparseTuple methodsFor: 'initialization' stamp: 'len 3/1/2016 03:00'!
initialize
	super initialize.
	zero _ 0! !

!SparseTuple methodsFor: 'testing' stamp: 'len 7/9/2016 02:50'!
isOrdered
	^ false! !

!SparseTuple methodsFor: 'testing' stamp: 'len 7/9/2016 02:50'!
isSparse
	^ true! !

!SparseTuple methodsFor: 'testing' stamp: 'len 3/1/2016 03:16'!
isZero
	^ self isEmpty! !

!SparseTuple methodsFor: 'arithmetic' stamp: 'len 3/28/2016 06:40'!
negated
	^ self collectNoZero: [:each| each negated]! !

!SparseTuple methodsFor: 'arithmetic' stamp: 'len 7/17/2016 23:21'!
pointwiseProduct: aSparseTuple
	"Answer the pointwise product with the argument, also called Hadamard product."
	| answer |
	self size <= aSparseTuple size ifFalse: [^ aSparseTuple pointwiseProduct: self]. "assuming it's commutative"
	answer _ self copyEmpty.
	self keysAndValuesDo: [:key :value|
		answer at: key put: value * (aSparseTuple at: key)].
	^ answer! !

!SparseTuple methodsFor: 'private' stamp: 'len 3/1/2016 03:00'!
setZero: anObject
	zero _ anObject! !

!SparseTuple methodsFor: 'enumerating' stamp: 'len 3/5/2016 01:42'!
withIndexDo: elementAndIndexBlock 
	"Just like with:do: except that the iteration index supplies the second argument to the block."
	self keysAndValuesDo: [:key :value| elementAndIndexBlock value: value value: key]! !

!SparseTuple methodsFor: 'arithmetic' stamp: 'len 7/5/2016 06:52'!
zero
	^ self class zero: zero! !

!SparseTuple class methodsFor: 'instance creation' stamp: 'len 7/5/2016 06:49'!
new: anInteger zero: anObject
	^ (self new: anInteger) setZero: anObject! !

!SparseTuple class methodsFor: 'instance creation' stamp: 'len 3/1/2016 04:27'!
zero: anObject
	^ self new setZero: anObject! !

!KeyedSet methodsFor: 'accessing' stamp: 'len 2/26/2016 21:26'!
at: anObject
	"Answer an object in the receiver that is equal to anObject,
	nil if no such object is found. Relies heavily on hash properties"
	| index |
	^(index _ self scanFor: anObject) = 0 ifFalse: [array at: index]! !

!KeyedSet methodsFor: 'accessing' stamp: 'len 2/26/2016 23:16'!
at: anObject ifAbsent: exceptionBlock
	| index |
	^ ((index _ self scanFor: anObject) = 0 ifFalse: [array at: index]) ifNil: exceptionBlock! !

!KeyedSet methodsFor: 'accessing' stamp: 'len 2/26/2016 21:31'!
at: anObject ifAbsentPut: aBlock
	"Answer an object in the receiver that is equal to anObject, or evaluate aBlock to get one and add it to the receiver,
	Relies heavily on hash properties, it is important that the following holds: aBlock value = anObject."
	| index |
	anObject ifNil: [self error: 'Sets cannot meaningfully contain nil as an element'].
	index _ self findElementOrNil: anObject.
	^ (array at: index) ifNil: [self atNewIndex: index put: aBlock value]! !

!Iterator methodsFor: 'adding'!
add: anObject
	"Iterators are read-only"
	self shouldNotImplement! !

!Iterator methodsFor: 'private'!
block: aBlock
	block := aBlock! !

!Iterator methodsFor: 'enumerating'!
do: aBlock
	block value: aBlock! !

!Iterator methodsFor: 'enumerating'!
findFirst: aBlock
	"Answer the index of the first element of the receiver
	for which aBlock evaluates as true."

	| index |
	index := 1.
	self do: [ :el | (aBlock value: el) ifTrue: [^index].  index := index + 1].
	^0! !

!Iterator methodsFor: 'enumerating'!
findLast: aBlock
	"Answer the index of the last element of the receiver
	for which aBlock evaluates as true."

	| index last |
	index := 1.
	last := 0.
	self do: [ :el | (aBlock value: el) ifTrue: [last := index].  index := index + 1].
	^last! !

!Iterator methodsFor: 'accessing'!
identityIndexOf: anElement 
	"Answer the identity index of anElement within the receiver.  If the receiver does
	not contain anElement, answer 0."

	^self identityIndexOf: anElement ifAbsent: [0]! !

!Iterator methodsFor: 'accessing'!
identityIndexOf: anElement ifAbsent: exceptionBlock 
	"Answer the identity index of anElement within the receiver.  If the receiver does
	not contain anElement, answer the result of evaluating the exceptionBlock."

	| index |
	index := 1.
	self do: [ :el | el == anElement ifTrue: [^index].  index := index + 1].
	^exceptionBlock value! !

!Iterator methodsFor: 'accessing'!
indexOf: anElement 
	"Answer the index of anElement within the receiver.  If the receiver does
	not contain anElement, answer 0."

	^self indexOf: anElement ifAbsent: [0]! !

!Iterator methodsFor: 'accessing'!
indexOf: anElement ifAbsent: exceptionBlock 
	"Answer the index of anElement within the receiver.  If the receiver does
	not contain anElement, answer the result of evaluating the exceptionBlock."

	| index |
	index := 1.
	self do: [ :el | el = anElement ifTrue: [^index].  index := index + 1].
	^exceptionBlock value! !

!Iterator methodsFor: 'enumerating'!
keysAndValuesDo: aBlock  
	"Evaluate aBlock with each of the receiver's key/value pairs
	(e.g. indexes and elements) as the arguments."

	| index |
	index := 1.
	self do: [:el | aBlock value: index value: el.  index := index + 1]! !

!Iterator methodsFor: 'removing'!
remove: oldObject ifAbsent: anExceptionBlock 
	"Iterators are read-only."
	self shouldNotImplement! !

!Iterator methodsFor: 'private'!
species
	^OrderedCollection! !

!Iterator class methodsFor: 'instance creation' stamp: 'len 2/28/2016 20:32'!
on: aBlock
	^ self new block: aBlock! !

!Iterator class methodsFor: 'instance creation' stamp: 'len 2/14/2016 21:45'!
on: anObject performing: aSymbol
	^ self new block: [:aBlock| anObject perform: aSymbol with: aBlock]! !

!AbstractGraph methodsFor: 'operations' stamp: 'len 9/1/2016 07:48'!
+ aGraphOrEdge
	"Answer the dijoint union of the receiver with the argument. Assume they are disjoint."
	(aGraphOrEdge isKindOf: Association)
		ifFalse: [^ self  aGraphOrEdge].
	(self hasEdge: aGraphOrEdge)
		ifFalse: [^ self copy addEdge: aGraphOrEdge; yourself]! !

!AbstractGraph methodsFor: 'operations' stamp: 'len 7/13/2016 22:04'!
- anEdge
	"Answer the graph obtained by removing anEdge."
	(self hasEdge: anEdge)
		ifTrue: [^ self copy removeEdge: anEdge; yourself]! !

!AbstractGraph methodsFor: 'operations' stamp: 'len 7/13/2016 22:05'!
/ anEdge
	"Answer the graph obtained by contracting the given edge a -> b, by removing the edge and collapsing a with b in a single node."

	| answer newNode found |
	(self hasEdge: anEdge) ifFalse: [^ self].
	answer _ self copyEmpty.
	newNode _ anEdge.
	answer add: newNode.
	self nodesDo: [:each| (each = anEdge key or: [each = anEdge value]) ifFalse: [answer add: each]].
	found _ false.
	self edgesDo: [:each|
		(each = anEdge and: [found not])
			ifTrue: [found _ true]
			ifFalse:
				[| e |
				e _ each.
				(e key = anEdge key or: [e key = anEdge value])
					ifTrue: [e _ newNode -> e value].
				(e value = anEdge key or: [e value = anEdge value])
					ifTrue: [e _ e key -> newNode].
				answer addEdge: e]].
	^ answer! !

!AbstractGraph methodsFor: 'comparing' stamp: 'len 8/12/2016 21:18'!
< aGraph
	"Answer true if the receiver is a proper subgraph of aGraph."
	(aGraph isKindOf: self species) ifFalse: [^ aGraph >= self].
	self size < aGraph size ifFalse: [^ false].
	self nodesDo: [:each|
		| node |
		(aGraph includes: each value) ifFalse: [^ false].
		node _ aGraph nodeAt: each value.
		each neighborsDo: [:n| (node hasEdgeTo: n value) ifFalse: [^ false]]].
	^ true! !

!AbstractGraph methodsFor: 'comparing' stamp: 'len 8/12/2016 21:45'!
<= aGraph
	"Answer true if the receiver is a subgraph of aGraph."
	(aGraph isKindOf: self species) ifFalse: [^ aGraph >= self].
	self size <= aGraph size ifFalse: [^ false].
	self nodesDo: [:each|
		| node |
		(aGraph includes: each value) ifFalse: [^ false].
		node _ aGraph nodeAt: each value.
		each neighborsDo: [:n| (node hasEdgeTo: n value) ifFalse: [^ false]]].
	^ true! !

!AbstractGraph methodsFor: 'comparing' stamp: 'len 7/21/2016 00:07'!
= aGraph
	^ (aGraph isKindOf: self species) and: [self nodes = aGraph nodes and: [self edges asBag = aGraph edges asBag]]! !

!AbstractGraph methodsFor: 'comparing' stamp: 'len 8/12/2016 21:47'!
> aGraph
	"Answer true if aGraph is a proper subgraph of the receiver."
	^ aGraph < self! !

!AbstractGraph methodsFor: 'comparing' stamp: 'len 8/12/2016 21:47'!
>= aGraph
	"Answer true if aGraph is a subgraph of the receiver."
	^ aGraph <= self! !

!AbstractGraph methodsFor: 'comparing' stamp: 'len 7/23/2016 04:06'!
~ aGraph
	"Answer true if the receiver is isomorphic to aGraph."
	| n G H |
	self isLabeled ifTrue: [self notYetImplemented].
	self species = aGraph species ifFalse: [^ false].
	(n _ self size) = aGraph size ifFalse: [^ false].
	"we could insert some heuristic tests here, comparing easy-to-compute invariants"
	G _ self asStandard.
	H _ aGraph asStandard.
	(SymmetricGroup new: n) do: [:each| (G apply: each) = H ifTrue: [^ true]].
	^ false! !

!AbstractGraph methodsFor: 'operations' stamp: 'len 9/1/2016 07:48'!
 aGraph
	"Answer the graph whose vertices and edges is the intersection of the vertices and edges of the receiver and the argument."
	| answer |
	answer _ self copyEmpty.
	aGraph nodesDo: [:each|
		(self nodeAt: each ifAbsent: [])
			ifNotNil: [:node|
				answer add: each.
				each neighborsDo: [:n|
					(node hasEdgeTo: n)
						ifTrue: [answer addEdgeFrom: each to: n]]]].
	^ answer! !

!AbstractGraph methodsFor: 'operations' stamp: 'len 9/1/2016 07:48'!
 aGraph
	"Answer the graph whose vertices and edges are the union of the vertices and edges of the receiver and the argument."
	| answer |
	answer _ self copy.
	aGraph do: [:each| answer add: each].
	aGraph edgesDo: [:each| answer addEdgeFrom: each key to: each value].
	^ answer! !

!AbstractGraph methodsFor: 'adding/removing' stamp: 'len 7/13/2016 21:55'!
addEdge: edge 
	"Add an edge (represented by an Association)."

	self addEdgeFrom: edge key to: edge value.
	^ edge! !

!AbstractGraph methodsFor: 'adding/removing' stamp: 'len 7/13/2016 21:55'!
addEdge: edge label: label
	"Add an edge (represented by an Association), with given label.
	pre: (self nodeAt: edge key) isLabeled"

	self addEdgeFrom: edge key to: edge value label: label.
	^edge! !

!AbstractGraph methodsFor: 'adding/removing' stamp: 'len 7/13/2016 23:54'!
addEdges: aCollection
	aCollection do: [:each| self addEdge: each].
	^ aCollection! !

!AbstractGraph methodsFor: 'operations' stamp: 'len 7/20/2016 23:43'!
adjacencyMatrix
	"Answer the adjacency matrix of the receiver, assuming that the vertices are the integers {1,..,n}.
	If the graph is labelled, use the labels as entries in the matrix."
	| n matrix |
	n _ self order.
	matrix _ (ZZ ** (n@n)) zero.
	self edgesAndLabelsDo: [:edge :label| matrix at: edge key at: edge value add: (label ifNil: [1])].
	^ matrix! !

!AbstractGraph methodsFor: 'operations' stamp: 'len 7/19/2016 23:20'!
adjacencyMatrix: vertices
	"Answer the adjacency matrix of the receiver, using the vertex ordering given by the argument."
	^ ZZ ** (vertices size @ vertices size) evaluating: [:i :j| self multiplicityFrom: (vertices at: i) to: (vertices at: j)]! !

!AbstractGraph methodsFor: 'iterating' stamp: 'len 7/23/2016 04:06'!
apply: aMorphism
	"Answer a new graph like the receiver but with vertices values mapped by aMorphism."
	^ self collect: aMorphism! !

!AbstractGraph methodsFor: 'converting' stamp: 'len 7/30/2016 07:33'!
asMorph
	| answer components |
	(components _ self components) size = 1
		ifTrue: [^ SpringGraphMorph new graph: self].
	answer _ CompositeGraphMorph newRow.
	components do: [:each|
		answer addComponent: (SpringGraphMorph new graph: each)].
	^ answer! !

!AbstractGraph methodsFor: 'converting' stamp: 'len 7/21/2016 02:12'!
asStandard
	^ self asStandard: self values asArray! !

!AbstractGraph methodsFor: 'converting' stamp: 'len 7/21/2016 02:12'!
asStandard: verticesArray
	^ self collect: [:each| verticesArray indexOf: each]! !

!AbstractGraph methodsFor: 'operations' stamp: 'len 7/25/2016 02:32'!
automorphisms
	"Answer the group of symmetries of the receiver, i.e. the group of permutations of vertices that don't change the graph."
	^ (SymmetricGroup on: self values) select: [:each| (self apply: each) = self]! !

!AbstractGraph methodsFor: 'operations' stamp: 'len 7/25/2016 02:37'!
automorphismsWithInvariant: aBlock
	"Answer the group of symmetries of the receiver, i.e. the group of permutations of vertices that don't change the graph."
	| partition |
	partition _ Dictionary new.
	self nodesDo: [:each| (partition at: (aBlock value: each) ifAbsentPut: [OrderedCollection new]) add: each value].
	^ self automorphismsWithPartition: partition! !

!AbstractGraph methodsFor: 'operations' stamp: 'len 7/25/2016 02:46'!
automorphismsWithPartition: aCollection
	"Answer the group of symmetries of the receiver, i.e. the group of permutations of vertices that don't change the graph."
	| product automorphisms |
	product _ CartesianProduct components: (aCollection collect: [:each| SymmetricGroup on: each]).
	automorphisms _ OrderedCollection new.
	product do: [:each|
		| f |
		f _ each product.
		(self apply: f) = self ifTrue: [automorphisms add: f]].
	^ PermutationGroup on: self values elements: automorphisms! !

!AbstractGraph methodsFor: 'statistics' stamp: 'len 7/13/2016 23:11'!
averageDegree
	"The average degree of the graph."
	"^ 2 * self numberOfEdges / self size"
	| sum |
	sum _ self nodes sum: [:node | node degree].
	^ sum / self size! !

!AbstractGraph methodsFor: 'statistics' stamp: 'len 7/13/2016 23:11'!
averagePathLength
	"The average path length of the graph."
	| sum n progress max |
	self flag: #bug. "bug with implicit graph since nodes are labelled with integer"
	sum := 0.
	n := 2.
	max := (self order * (self order - 1) / 2) asFloat.
	"p _ 1 / self order."
	progress := ProgressMorph label: 'Average path length progress'.
	progress submorphs first color: Color paleGreen lighter lighter lighter.
	progress submorphs first borderWidth: 1.
	progress openInWorld.
	self
		nodesDo: [:node1 | 
			n
				to: self order
				do: [:node2 | sum := sum
								+ (self
										breadthFirstPathFrom: node1
										to: (self nodeAt: node2))].
			n := n + 1.
			progress incrDone: self order - n / max].
	progress delete.
	^ (sum / max) asFloat! !

!AbstractGraph methodsFor: 'statistics' stamp: 'len 7/13/2016 23:11'!
averagePathLength2
	"The average path length of the graph."
	| sum n max |
	sum := 0.
	n := 2.
	max := (self order * (self order - 1) / 2) asFloat.
	self
		nodesDo: [:node1 | 
			n
				to: self order
				do: [:node2 | sum := sum
								+ (self
										breadthFirstPathFrom: node1
										to: (self nodeAt: node2))].
			n := n + 1.].
	^ (sum / max) asFloat! !

!AbstractGraph methodsFor: 'statistics' stamp: 'len 7/13/2016 23:11'!
averagePathLengthAcuteAt
	"The aproximate average path length of the graph."
	| sum n progress p max nodesList |
	sum _ 0.
	n _ 2.
	max _ 0.
	progress _ ProgressMorph label: 'Average path length progress'.
	progress submorphs first color: Color paleGreen lighter lighter lighter.
	progress submorphs first borderWidth: 1.
	progress openInWorld.
	nodesList _ OrderedCollection new.
	(0.1 * self order) rounded
		timesRepeat: [nodesList
				add: self nodes atRandom].
	p _ 1 / nodesList size.
	nodesList
		do: [:node1 | 
			n
				to: nodesList size
				do: [:node2 | 
					max _ max + 1.
					sum _ sum
								+ (self
										breadthFirstPathFrom: node1
										to: (self nodeAt: node2))].
			n _ n + 1.
			progress incrDone: p].
	progress delete.
	^ (sum / max) asFloat! !

!AbstractGraph methodsFor: 'statistics' stamp: 'len 7/13/2016 23:11'!
averagePathLengthAcuteAt: percentage
	"The aproximate average path length of the graph."
	| sum n max nodesList |
	sum _ 0.
	n _ 2.
	max _ (self order * (self order - 1) / 2) asFloat.
	"p _ 1 / self order. 
	progress _ ProgressMorph label: 'Average path length progress'. 
	progress submorphs first color: Color paleGreen lighter lighter lighter. 
	progress submorphs first borderWidth: 1. 
	progress openInWorld."
	nodesList := OrderedCollection new.
	(percentage * self order) timesRepeat: [nodesList add: self nodes atRandom].
	nodesList
				do: [:node1 | 
					n
						to: nodesList size
						do: [:node2 | sum _ sum
										+ (self
												breadthFirstPathFrom: node1
												to: (self nodeAt: node2))].
					n _ n + 1].
	"progress delete."
	^ (sum / max) asFloat! !

!AbstractGraph methodsFor: 'operations' stamp: 'len 7/13/2016 23:13'!
breadthFirstPath2From: origin to: target with: visitedNodes 
	| queue node nodesLevels |
	nodesLevels _ Dictionary new.
	nodesLevels at: origin value put: 0.
	queue _ OrderedCollection with: origin.
	visitedNodes add: origin.
	[queue isEmpty]
		whileFalse: [node _ queue removeFirst.
			node neighborsDo:
				[:each | (visitedNodes includes: each)
						ifFalse: [queue addLast: each.
							visitedNodes add: each.
							nodesLevels at: each value put: (nodesLevels at: node value)
									+ 1.
							each = target
								ifTrue: [^ nodesLevels at: each value]]]].
	"No path From origin to target, i.e. the two subgraph are not conected"
	^ 0! !

!AbstractGraph methodsFor: 'operations' stamp: 'len 7/13/2016 23:13'!
breadthFirstPathFrom: source to: target 
	| visitedNodes |
	(source isLeaf
			or: [target isLeaf])
		ifTrue: [^ 0]
		ifFalse: [visitedNodes _ Set new.
			^ self
				breadthFirstPath2From: source
				to: target
				with: visitedNodes]! !

!AbstractGraph methodsFor: 'operations' stamp: 'len 7/13/2016 23:13'!
breadthFirstPathFrom: origin to: target with: visitedNodes 
	| queue node nodesLevels |
	nodesLevels _ Bag new.
	queue _ OrderedCollection with: origin.
	visitedNodes add: origin.
	[queue isEmpty]
		whileFalse: [node _ queue removeFirst.
			node neighborsDo:
				[:each | (visitedNodes includes: each)
						ifFalse: [queue addLast: each.
							visitedNodes add: each.
							nodesLevels add: each withOccurrences: (nodesLevels occurrencesOf: node)
									+ 1.
							each = target
								ifTrue: [^ nodesLevels occurrencesOf: each]]]].
	"No path From origin to target, i.e. the two subgraph are not conected"
	^ 0! !

!AbstractGraph methodsFor: 'operations' stamp: 'len 7/20/2016 23:56'!
cartesian: aGraph
	"Answer the cartesian product of the receiver with the argument. This is a commutative and associative operation (for unlabeled graphs)."
	| G |
	G _ self copyEmpty.
	self do: [:x| aGraph do: [:y| G add: (x, y)]].
	self do: [:x| aGraph edgesDo: [:e| G addEdgeFrom: (x, e key) to: (x, e value)]].
	self edgesDo: [:e| aGraph do: [:y| G addEdgeFrom: (e key, y) to: (e value, y)]].
	^ G! !

!AbstractGraph methodsFor: 'operations' stamp: 'len 7/13/2016 22:06'!
center
	"Answer the center of the receiver, i.e. the subset of vertices with maximal eccentricity.
	Using Dijsktra shortest path algorithm this computation requires time O(|V|^3)."
	| radius |
	radius _ self radius.
	^ self values select: [:each| (self eccentricityOf: each) = radius]! !

!AbstractGraph methodsFor: 'operations' stamp: 'len 7/13/2016 22:06'!
chromaticNumber
	"The minimum number of colors to do a proper coloring of the graph."
	| chi |
	chi _ self chromaticPolynomial.
	^ (1 to: self size) detect: [:i| (chi value: i) > 0]! !

!AbstractGraph methodsFor: 'operations' stamp: 'len 7/15/2016 18:23'!
chromaticPolynomial
	"The chromatic polynomial P(G,k) is a polynomial in k that counts the number of k-colorings of G."
	^ self chromaticPolynomialAt: ZZ polynomials x! !

!AbstractGraph methodsFor: 'operations' stamp: 'len 7/14/2016 06:50'!
chromaticPolynomialAt: k
	"The chromatic polynomial P(G,k) is a polynomial in k that counts the number of k-colorings of G. Answer the evaluation at k."
	self isEdgeless ifTrue: [^ k ** self size].
	self edgesDo: [:each|
		each key = each value
			ifFalse: [^ ((self - each) chromaticPolynomialAt: k) - ((self / each) chromaticPolynomialAt: k)]].
	^ k*0! !

!AbstractGraph methodsFor: 'operations' stamp: 'len 7/13/2016 22:06'!
circumference
	"Answer the length of the longest cycle."
	^ self notYetImplemented! !

!AbstractGraph methodsFor: 'statistics' stamp: 'len 7/13/2016 23:11'!
clusteringCoefficient
	| sum |
	sum _ 0.
	self nodesDo: [:node | node degree > 1 ifTrue: [sum _ sum + node clusteringCoefficient]].
	^ (sum / self order) asFloat! !

!AbstractGraph methodsFor: 'iterating' stamp: 'len 7/13/2016 22:03'!
collect: aBlock
	"Answer a new graph like the receiver but with vertices values mapped by aBlock."
	| answer |
	answer _ self copyEmpty.
	self nodesDo: [:each| answer add: (aBlock value: each value)].
	self edgesDo: [:each| answer addEdgeFrom: (aBlock value: each key) to: (aBlock value: each value)].
	^ answer! !

!AbstractGraph methodsFor: 'iterating' stamp: 'len 7/20/2016 23:50'!
collect: aBlock labels: labelBlock
	"Answer a new graph like the receiver but with vertices values mapped by aBlock."
	| answer |
	answer _ self copyEmpty.
	self do: [:each| answer add: (aBlock value: each)].
	self edgesAndLabelsDo: [:each :label| answer addEdgeFrom: (aBlock value: each key) to: (aBlock value: each value) label: (labelBlock value: label)].
	^ answer! !

!AbstractGraph methodsFor: 'operations' stamp: 'len 7/13/2016 22:06'!
components
	"Answer the Strongly Connected Components of the receiver."
	^ Set accumulate: [:aBlock | self componentsDo: aBlock]! !

!AbstractGraph methodsFor: 'accessing' stamp: 'len 7/13/2016 21:53'!
degree
	self isEmpty ifTrue: [^ 0].
	^ self nodes max: [:each| each degree]! !

!AbstractGraph methodsFor: 'statistics' stamp: 'len 7/13/2016 23:11'!
degreeDistribution
	"The distribution degree of the graph."
	| b |
	b _ Bag new: self size.
	self nodesDo: [:each| b add: each degree].
	^ b frequencyDistribution! !

!AbstractGraph methodsFor: 'accessing' stamp: 'len 7/14/2016 08:36'!
density
	"Answer a measure of the graph density (vs sparsity), a number between 0 and 1.
	A graph is dense if the number of edges is close to the maximum (for the given number of vertices).
	pre: assume the graph is simple."
	| V E |
	V _ self size.
	E _ self numberOfEdges.
	^ self isDirected ifTrue: [2*E/(V*(V-1))] ifFalse: [E/(V*(V-1))]! !

!AbstractGraph methodsFor: 'operations' stamp: 'len 7/13/2016 22:07'!
diameter
	^ self nodes max: [:each| self eccentricityOf: each]! !

!AbstractGraph methodsFor: 'operations' stamp: 'len 7/13/2016 23:05'!
distanceFrom: source to: target
	^ (Dijkstra graph: self source: source) distanceTo: target! !

!AbstractGraph methodsFor: 'iterating' stamp: 'len 7/20/2016 23:34'!
do: aBlock
	"Iterate over the vertices of the receiver (the values, not GraphNodes)."
	self nodesDo: [:each| aBlock value: each value]! !

!AbstractGraph methodsFor: 'operations' stamp: 'len 7/13/2016 23:05'!
eccentricityOf: anObject
	^ (Dijkstra graph: self source: anObject) eccentricity! !

!AbstractGraph methodsFor: 'random' stamp: 'len 7/13/2016 23:14'!
edgeAtRandom
	^ Random withDefaultDo: [:aRandom| self edgeAtRandom: aRandom]! !

!AbstractGraph methodsFor: 'accessing' stamp: 'len 7/13/2016 21:53'!
edges
	^ Iterator on: self performing: #edgesDo:! !

!AbstractGraph methodsFor: 'operations' stamp: 'len 7/13/2016 22:07'!
girth
	"Answer the length of the shortest cycle."
	^ self notYetImplemented! !

!AbstractGraph methodsFor: 'testing' stamp: 'len 7/13/2016 22:31'!
hasEdge: edge
	^ self hasEdgeFrom: edge key to: edge value! !

!AbstractGraph methodsFor: 'testing' stamp: 'len 7/29/2016 06:34'!
hasEdgeFrom: a to: b
	^ (self nodeAt: a ifAbsent: [^ false]) hasEdgeTo: b! !

!AbstractGraph methodsFor: 'testing' stamp: 'len 7/13/2016 22:31'!
hasLoop
	self nodesDo: [:each| each hasLoop ifTrue: [^ true]].
	^ false! !

!AbstractGraph methodsFor: 'comparing' stamp: 'len 7/13/2016 21:58'!
hash
	^ self nodes hash! !

!AbstractGraph methodsFor: 'testing' stamp: 'len 7/13/2016 22:32'!
includes: anObject
	"Answer whether anObject is one of the vertices of the receiver."
	^ self nodes includes: anObject! !

!AbstractGraph methodsFor: 'testing' stamp: 'len 7/13/2016 22:32'!
isChain
	"Answer whether the graph is a chain - path graph."
	^ (self select: [:each| each isAnExtremity]) size + (self select:[:each| each isMiddle]) size = self order! !

!AbstractGraph methodsFor: 'testing' stamp: 'len 7/13/2016 22:32'!
isComplete
	self nodesDo: [:x| self nodesDo: [:y| (x hasEdgeTo: y) ifFalse: [^ false]]].
	^ true! !

!AbstractGraph methodsFor: 'testing' stamp: 'len 7/13/2016 22:33'!
isConnected
	| count |
	count _ 0.
	self componentsDo: [:each| count _ count + 1. count > 1 ifTrue: [^ false]].
	^ true! !

!AbstractGraph methodsFor: 'testing' stamp: 'len 7/13/2016 22:33'!
isCubic
	^ self nodes allSatisfy: [:each| each degree = 3]! !

!AbstractGraph methodsFor: 'testing' stamp: 'len 7/13/2016 22:33'!
isCyclic
	[self topologicalSort] on: Error do: [^ true].
	^ false
"	| remainingNodes |
	remainingNodes _ self nodes copy.
	[remainingNodes isEmpty]
		whileFalse:
			[Transcript show: 'pick'; newLine.
			remainingNodes anyOne walkPre: [:each|
					Transcript show: each printString; newLine.
					remainingNodes remove: each ifAbsent: [^ true]] post: [:ignore]].
	Transcript show: 'done'; newLine.
	^ false"! !

!AbstractGraph methodsFor: 'testing' stamp: 'len 7/13/2016 22:33'!
isEdgeless
	^ self numberOfEdges = 0! !

!AbstractGraph methodsFor: 'testing' stamp: 'len 7/13/2016 22:33'!
isEmpty
	"Answer whether the receiver contains any elements."

	^ self nodes isEmpty! !

!AbstractGraph methodsFor: 'testing' stamp: 'len 7/29/2016 08:12'!
isEulerian
	"Answer true if the receiver has an Eurlerian path."
	| count |
	self flag: #fix. "it should be 'has an Eulerian circuit', and isSemiEulerian must be implemented."
	count _ 0.
	self nodesDo: [:each| each degree odd ifTrue: [(count _ count + 1) > 2 ifTrue: [^ false]]].
	^ count = 0 or: [count = 2]! !

!AbstractGraph methodsFor: 'testing' stamp: 'len 7/13/2016 22:33'!
isHamiltonian
	"Answer true if the receiver has a Hamiltonian cycle (or Hamiltonian circuit, vertex tour, or graph cycle), which is a cycle that visits each node once except for the start/end node that is visited twice."
	^ self closure isComplete "Bondy-Chvatai theorem"! !

!AbstractGraph methodsFor: 'testing' stamp: 'len 7/13/2016 22:34'!
isReflexive
	^ self nodes allSatisfy: [:each| each isReflexive]! !

!AbstractGraph methodsFor: 'testing' stamp: 'len 7/13/2016 22:34'!
isRegular
	| n |
	self isEmpty ifTrue: [^ true].
	n _ self nodes anyOne degree.
	^ self nodes allSatisfy: [:each| each degree = n]! !

!AbstractGraph methodsFor: 'testing' stamp: 'len 7/29/2016 08:11'!
isSemiEulerian
	"Answer true if the receiver has an Eurlerian path but not an Eulerian circuit."
	self notYetImplemented! !

!AbstractGraph methodsFor: 'testing' stamp: 'len 7/13/2016 22:34'!
isSimple
	"A graph is simple if doesn't countain multiple edges with the same endpoints."
	^ self nodes allSatisfy: [:each| each isSimple]! !

!AbstractGraph methodsFor: 'testing' stamp: 'len 7/13/2016 22:34'!
isTraceable
	"Answer true if the receiver has a Hamiltonian path (or traceable path), which is a path that visits each vertex exactly once."
	^ self notYetImplemented! !

!AbstractGraph methodsFor: 'testing' stamp: 'len 7/13/2016 22:37'!
isUndirected
	^ self isDirected not! !

!AbstractGraph methodsFor: 'operations' stamp: 'len 7/20/2016 23:19'!
join: aGraph
	"Answer the graph with all edges that connect the vertices of the receiver with the vertices of the argument. This is a commutative operation (for unlabeled graphs)."
	| answer |
	answer _ self copyEmpty.
	self edgesDo: [:each| (aGraph includes: each value) ifTrue: [answer addEdge: each]].
	aGraph edgesDo: [:each| (self includes: each key) ifTrue: [answer addEdge: each]].
	^ answer! !

!AbstractGraph methodsFor: 'operations' stamp: 'len 7/20/2016 23:54'!
line
	"Answer the line graph of the receiver, i.e. the graph L(G) such that:
	 - each edge of G is a vertex of L(G);
	 - if two edges of G share a common endpoint, the correspondng vertices in L(G) are connected." 
	| answer |
	self flag: #fix.
	answer _ self copyEmpty.
	self fullEdgesDo: [:each| "each contains GraphNodes, not values"
		each value neighborsDo: [:n|
			answer addEdgeFrom: each to: (Association key: each value value value: n value)]].
	^ answer! !

!AbstractGraph methodsFor: 'operations' stamp: 'len 7/13/2016 22:08'!
maxmimumDegree
	^ self nodes inject: Infinity negative into: [:maximum :each| maximum max: each degree]! !

!AbstractGraph methodsFor: 'operations' stamp: 'len 7/13/2016 22:08'!
minimumDegree
	^ self nodes inject: Infinity positive into: [:minimum :each| minimum min: each degree]! !

!AbstractGraph methodsFor: 'operations' stamp: 'len 7/13/2016 22:08'!
multiplicity
	^ self edges max: [:each| self multiplicityFrom: each key to: each value]! !

!AbstractGraph methodsFor: 'operations' stamp: 'len 7/13/2016 22:08'!
multiplicityFrom: source to: target
	^ (self nodeAt: source) neighbors occurrencesOf: target! !

!AbstractGraph methodsFor: 'operations' stamp: 'len 7/20/2016 23:22'!
neighborhoodOf: node
	"Answer the subgraph of everything that is reachable from the given vertex."
	^ self subgraphInducedBy: (self nodeAt: node) neighbors! !

!AbstractGraph methodsFor: 'accessing' stamp: 'len 7/13/2016 22:24'!
nodeAt: anObject
	^ self nodeAt: anObject ifAbsent: [self errorNotFound: anObject]! !

!AbstractGraph methodsFor: 'accessing' stamp: 'len 7/13/2016 22:24'!
nodeAt: anObject ifAbsent: exceptionBlock
	^ self nodes at: anObject ifAbsent: exceptionBlock! !

!AbstractGraph methodsFor: 'accessing' stamp: 'len 7/13/2016 21:53'!
numberOfEdges
	"This is commonly known as the size of the graph, but the size message returns the order (number of vertices), as this fits in better with Smalltalk usage."
	| count |
	count _ 0.
	self nodesDo: [:each| count _ count + each neighbors size].
	^ count! !

!AbstractGraph methodsFor: 'accessing' stamp: 'len 7/13/2016 21:54'!
order
	"The size of a graph G=(V,E) is the number of vertices |V|, contrary to the more common convention of defining it as |E|."
	^ self size! !

!AbstractGraph methodsFor: 'printing' stamp: 'len 7/13/2016 22:54'!
printOn: aStream
	self isEmpty ifTrue: [aStream nextPut: Character emptySet. ^ self].
	super printOn: aStream! !

!AbstractGraph methodsFor: 'operations' stamp: 'len 7/25/2016 08:47'!
quotient
	| Q |
	self isLabeled ifFalse: [DomainError signal: 'not a lebeled graph'].
	Q _ self copyEmpty.
	self nodesDo: [:each| Q add: each label].
	self fullEdgesAndLabelsDo: [:each :label| Q addEdgeFrom: each key label to: each value label label: label].
	^ Q! !

!AbstractGraph methodsFor: 'operations' stamp: 'len 7/13/2016 22:08'!
radius
	^ self nodes min: [:each| self eccentricityOf: each]
"	^ (FloydWarshall graph: self) radius"! !

!AbstractGraph methodsFor: 'operations' stamp: 'len 7/20/2016 23:47'!
reflexive
	"Answer the reflexive closure of the receiver."
	| answer |
	answer _ self copy.
	answer nodesDo: [:each | each hasLoop ifFalse: [answer addEdgeFrom: each to: each]].
	^ answer! !

!AbstractGraph methodsFor: 'adding/removing' stamp: 'len 7/13/2016 22:17'!
removeEdge: anEdge
	"Remove the given edge.
	pre: the edge must be in the graph."
	self removeEdge: anEdge ifAbsent: [self errorNotFound: anEdge]! !

!AbstractGraph methodsFor: 'adding/removing' stamp: 'len 7/13/2016 22:16'!
removeEdge: edge ifAbsent: exceptionBlock 
	"Remove the given edge, evaluate exceptionBlock if it doesn't exist.
	pre: both the source and target of the edge must be in the graph."
	^self removeEdgeFrom: edge key to: edge value ifAbsent: exceptionBlock! !

!AbstractGraph methodsFor: 'adding/removing' stamp: 'len 7/13/2016 22:17'!
removeEdgeFrom: src to: dest
	"Remove the given edge.
	pre: the edge must be in the graph."
	^self removeEdgeFrom: src to: dest ifAbsent: [self errorNotFound: src -> dest]! !

!AbstractGraph methodsFor: 'iterating' stamp: 'len 7/20/2016 23:54'!
select: aBlock
	"Answer the subgraph of the receiver whose vertices satisfy aBlock."
	| answer |
	answer _ self copyEmpty.
	self do: [:each| (aBlock value: each) ifTrue: [answer add: each]].
	self edgesDo: [:each|
		((aBlock value: each key) and: [aBlock value: each value])
			ifTrue: [answer addEdgeFrom: each key to: each value]].
	^ answer! !

!AbstractGraph methodsFor: 'operations' stamp: 'len 7/13/2016 23:05'!
shortestPathFrom: source to: target
	^ (Dijkstra graph: self source: source) shortestPathTo: target! !

!AbstractGraph methodsFor: 'random' stamp: 'len 7/21/2016 01:53'!
shuffled
	^ Random withDefaultDo: [:aRandom| self shuffledBy: aRandom]! !

!AbstractGraph methodsFor: 'random' stamp: 'len 7/21/2016 01:53'!
shuffledBy: aRandom
	^ self collect: ((SymmetricGroup on: self values) atRandom: aRandom)! !

!AbstractGraph methodsFor: 'accessing' stamp: 'len 7/13/2016 21:54'!
size
	"The size of a graph G=(V,E) is the number of vertices |V|, contrary to the more common convention of defining it as |E|."
	^ self nodes size! !

!AbstractGraph methodsFor: 'operations' stamp: 'len 7/20/2016 23:55'!
subgraphInducedBy: aSet
	"Answer the subgraph induces by aSet of vertices."
	| answer |
	answer _ self copy.
	self edgesDo: [:each|
		((aSet includes: each key) and: [aSet includes: each value])
			ifTrue: [answer addEdge: each]].
	^ answer! !

!AbstractGraph methodsFor: 'operations' stamp: 'len 7/13/2016 23:06'!
symmetric
	"Answer the symmetric closure of the receiver."
	| answer |
	answer _ self copy.
	self edgesDo: [:each | answer addEdge: (Association key: each value value: each key)].
	^ answer! !

!AbstractGraph methodsFor: 'operations' stamp: 'len 7/20/2016 23:55'!
tensor: aGraph
	"Answer the tensor product (or direct graph product, categorical graph product, cardinal graph product, Kronecker graph product) of the receiver with the argument. This is a commutative operation (for unlabeled graphs)."
	| G |
	G _ self class ordered.
	self do: [:x| aGraph do: [:y| G add: (x, y)]].
	self edgesDo: [:e1|
		aGraph edgesDo: [:e2|
			G addEdgeFrom: (e1 key, e2 key) to: (e1 value, e2 value)]].
	^ G! !

!AbstractGraph methodsFor: 'operations' stamp: 'len 7/13/2016 22:12'!
topologicalSort
	"Answer a topological sort of the receiver. This is a linear ordering of its vertices such that for each edge a -> b, a comes before to b in the ordering.
	This is Kahn's algorithm."
	| answer G S n |
	answer _ OrderedCollection new.
	G _ self copy.
	S _ G nodes select: [:each| each inDegree = 0].
	[S notEmpty]
		whileTrue:
			[n _ S anyOne.
			S remove: n.
			answer add: n.
			n neighbors do: [:m|
				n removeNeighbor: m.
				m inDegree = 0 ifTrue: [S add: m]]].
	G isEdgeless ifFalse: [^ self error: 'the graph has at least one cycle'].
	^ answer! !

!AbstractGraph methodsFor: 'operations' stamp: 'len 7/13/2016 23:06'!
transposed
	"Answer the transpose of the receiver. This is the graphs where edges a->b are inverted as b->a."
	| answer |
	answer _ self copyEmpty.
	self edgesDo: [:each | answer addEdge: (Association key: each value value: each key)].
	^ answer! !

!AbstractGraph methodsFor: 'accessing' stamp: 'len 7/23/2016 04:32'!
values
	"Answer the set of vertices of the receievr ('values', as opposed to 'nodes' which are GraphNodes)."
	^ self nodes collect: [:each| each value]! !

!AbstractGraph class methodsFor: 'examples' stamp: 'len 7/20/2016 19:17'!
C: n
	"Answer the cycle of n vertices 1 -> 2 -> ... -> n -> 1."
	| C |
	C _ self unordered.
	1 to: n-1 do: [:i| C addEdge: i->(i+1)].
	n >= 1 ifTrue: [C addEdge: n -> 1]. "the extremal case of n = 1 is just a loop"
	^ C! !

!AbstractGraph class methodsFor: 'examples' stamp: 'len 7/14/2016 00:12'!
K: n
	"Answer the n-complete graph."
	| K |
	K _ self unordered.
	1 to: n do: [:i| K add: i].
	1 to: n do: [:i| 1 to: i do: [:j| i ~= j ifTrue: [K addEdge: i->j]]].
	^ K! !

!AbstractGraph class methodsFor: 'examples' stamp: 'len 7/13/2016 22:40'!
N: n
	"Answer the null graph with n vertices {1..n}."
	^ self unordered addAll: (1 to: n); yourself! !

!AbstractGraph class methodsFor: 'examples' stamp: 'len 7/20/2016 19:16'!
P: n
	"Answer the path of n vertices 1 -> 2 -> ... -> n."
	| P |
	n > 1 ifFalse: [self error: 'path graph only definted for >= 2 vertices'].
	P _ self unordered.
	1 to: n-1 do: [:i| P addEdge: i->(i+1)].
	^ P! !

!AbstractGraph class methodsFor: 'examples' stamp: 'len 7/13/2016 22:40'!
S: n
	"Answer the star graph of n vertices."
	| S |
	S _ self unordered.
	2 to: n do: [:i| S addEdge: 1 -> i].
	^ S! !

!AbstractGraph class methodsFor: 'examples' stamp: 'len 7/13/2016 22:40'!
W: n
	"Answer the wheel graph of n vertices."
	| W |
	W _ self unordered.
	2 to: n do: [:i| W addEdge: 1 -> i; addEdge: i -> (i=n ifTrue: [2] ifFalse: [i+1])].
	^ W! !

!AbstractGraph class methodsFor: 'examples' stamp: 'len 7/13/2016 22:40'!
cube
	^ self cube: 3! !

!AbstractGraph class methodsFor: 'examples' stamp: 'len 7/13/2016 22:40'!
cube: n
	"Answer an n-cube."
	| G H |
	G _ self unordered addEdge: 1 -> 2; yourself.
	H _ G.
	n - 1 timesRepeat: [H _ H cartesian: G].
	^ H! !

!AbstractGraph class methodsFor: 'examples' stamp: 'len 7/13/2016 22:40'!
desargues
	"Answer the Desargues graph."
	^ self petersen: 10 order: 3! !

!AbstractGraph class methodsFor: 'examples' stamp: 'len 7/13/2016 22:40'!
dodecahedron
	^ self petersen: 10 order: 2! !

!AbstractGraph class methodsFor: 'examples' stamp: 'len 7/13/2016 22:41'!
durer
	"Answer the Durer graph."
	^ self petersen: 6 order: 2! !

!AbstractGraph class methodsFor: 'examples' stamp: 'len 7/13/2016 22:46'!
exampleImplicitGraph
	"Graph exampleImplicitGraph. BUG : There is a problem when you don't  
	test classes without subclasses, maybe a problem in the block creation  
	for ImplicitGraphNode (cf. Graph>>initialize)"
	| tree |
	tree _ self implicitCollection: [:class | class subclasses].
	Magnitude withAllSubclasses
		do: [:class| "class subclasses isEmpty ifFalse: ["tree add: class"]"].
	^ tree! !

!AbstractGraph class methodsFor: 'examples' stamp: 'len 7/13/2016 22:46'!
exampleImplicitGraph2
	| forest |
	forest := self implicitCollection: [:class | class ~= ProtoObject ifTrue: [{class superclass}] ifFalse:[#()]].
	(Smalltalk organization listAtCategoryNamed: 'Mathematics-Graphs') do: [:className| forest add: (Smalltalk at: className)].
	^ forest! !

!AbstractGraph class methodsFor: 'examples' stamp: 'len 7/13/2016 22:47'!
exampleImplicitGraph3
	"Graph exampleImplicitGraph3"
	| tree |
	tree _ self implicitIteratorBlock: [:class| [:aBlock| class subclasses do: aBlock]].
	RootedDigraph withAllSuperclasses do: [:class| tree add: class].
	^tree! !

!AbstractGraph class methodsFor: 'examples' stamp: 'len 7/13/2016 23:54'!
icosahedron
	^ self unordered addEdges:
		{1->2. 2->3. 3->1.
		4->5. 5->6. 6->7. 7->8. 8->9. 9->4.
		1->9. 1->4. 1->5. 2->5. 2->6. 2->7. 3->7. 3->8. 3->9.
		10->11. 11->12. 12->10.
		10->4. 10->5. 10->6. 11->6. 11->7. 11->8. 12->8. 12->9. 12->4}; yourself! !

!AbstractGraph class methodsFor: 'examples' stamp: 'len 7/13/2016 22:41'!
moebiusKantor
	"Answer the Moebius-Kantor graph."
	^ self petersen: 8 order: 3! !

!AbstractGraph class methodsFor: 'examples' stamp: 'len 7/13/2016 22:41'!
nauru
	"Answer the Nauru graph."
	^ self petersen: 12 order: 5! !

!AbstractGraph class methodsFor: 'private' stamp: 'len 7/13/2016 22:50'!
new
	^ self error: 'Graphs should not be created with new.'! !

!AbstractGraph class methodsFor: 'examples' stamp: 'len 7/13/2016 23:54'!
octahedron
	^ self unordered addEdges: {1->2. 2->3. 3->1. 1->4. 2->4. 2->5. 3->5. 3->6. 1->6. 4->5. 5->6. 6->4}; yourself! !

!AbstractGraph class methodsFor: 'examples' stamp: 'len 7/13/2016 23:54'!
petersen
	^ self unordered addEdges:
		{1->2. 2->3. 3->4. 4->5. 5->1.
		1->6. 2->7. 3->8. 4->9. 5->10.
		6->8. 6->9. 7->9. 7->10. 8->10}; yourself! !

!AbstractGraph class methodsFor: 'examples' stamp: 'len 7/13/2016 23:55'!
petersen: n order: k
	"Answer the generalized Petersen graph G(n,k)."
	| G |
	k < (n/2) ifFalse: [^ DomainError signal].
	G _ self unordered.
	0 to: n-1 do: [:i|
		G addEdges: {i->(i+1\\n). i->(i+n). i+n->(i+k\\n+n)}].
	^ G ! !

!AbstractGraph class methodsFor: 'examples' stamp: 'len 7/13/2016 22:41'!
prism: n
	"Answer an n-prism."
	^ self petersen: n order: 1! !

!AbstractGraph class methodsFor: 'examples' stamp: 'len 7/13/2016 23:55'!
square
	^ self unordered addEdges: {1 -> 2. 2 -> 3. 3 -> 4. 4 -> 1}; yourself! !

!AbstractGraph class methodsFor: 'examples' stamp: 'len 7/13/2016 23:55'!
triangle
	^ self unordered addEdges: {1->2. 2->3. 3->1}; yourself! !

!Digraph methodsFor: 'adding/removing' stamp: 'len 7/11/2016 06:56'!
add: anObject
	"Create a new GraphNode for the value (if necessary), and add it to the graph. You shouldn't be calling this unless you're sure what you're doing. Better to add nodes by adding edges."
	^ nodes at: anObject ifAbsentPut: [nodeCreator value: ((anObject isKindOf: GraphNode) ifTrue: [anObject value] ifFalse: [anObject])]! !

!Digraph methodsFor: 'adding/removing' stamp: 'len 4/29/2016 22:29'!
addEdgeFrom: source to: target 
	| sourceNode targetNode |
	sourceNode _ self add: source.
	targetNode _ self add: target.
	sourceNode addNeighbor: targetNode! !

!Digraph methodsFor: 'adding/removing' stamp: 'len 5/25/2016 04:05'!
addEdgeFrom: source to: target label: label
	"pre: (self nodeAt: edge key) isLabeled"
	| sourceNode targetNode |
	sourceNode _ self add: source.
	targetNode _ self add: target.
	sourceNode addNeighbor: targetNode label: label! !

!Digraph methodsFor: 'initialization' stamp: 'len 2/14/2016 22:14'!
arity: n
	type _ #(#arity).
	nodeCreator _ (InitializationBlocks at: #arity) value: n! !

!Digraph methodsFor: 'initialization' stamp: 'len 2/20/2016 06:37'!
arityLabeled: n
	type _ #(#arity #labeled).
	nodeCreator _ (InitializationBlocks at: #arityLabeled) value: n! !

!Digraph methodsFor: 'converting' stamp: 'len 5/25/2016 03:15'!
asRooted
	| answer |
	answer _ RootedDigraph unordered.
	answer addAll: self.
	self edgesDo: [:each| answer addEdge: each].
	answer findRoots.
	^ answer! !

!Digraph methodsFor: 'converting' stamp: 'len 7/13/2016 23:13'!
asUndirected
	^ Graph digraph: self symmetric! !

!Digraph methodsFor: 'random' stamp: 'len 7/11/2016 05:32'!
atRandom: aRandom
	^ (nodes atRandom: aRandom) value! !

!Digraph methodsFor: 'initialization' stamp: 'len 2/14/2016 22:15'!
binary
	type _ #(#binary).
	nodeCreator _ InitializationBlocks at: #binary! !

!Digraph methodsFor: 'initialization' stamp: 'len 2/20/2016 06:38'!
binaryLabeled
	type _ #(#binary #labeled).
	nodeCreator _ InitializationBlocks at: #binaryLabeled! !

!Digraph methodsFor: 'operations' stamp: 'len 7/21/2016 02:43'!
complement
	"Answer the complement graph, i.e. the graph where two edges are connected iff they are *not* connected in the receiver."
	| answer |
	answer _ self copyEmpty.
	self nodesDo: [:x|
		| neighbors |
		answer add: x.
		neighbors _ x neighbors.
		self nodesDo: [:y| (neighbors includes: y) ifFalse: [answer addEdgeFrom: x to: y]]].
	^ answer! !

!Digraph methodsFor: 'iterating' stamp: 'len 7/13/2016 22:25'!
componentsDo: aBlock
	"Iterate over the Strongly Connected Components of the receiver."
	| component remainingNodes node |
	remainingNodes _ self nodes copy.
	[remainingNodes isEmpty]
		whileFalse:
			[node _ remainingNodes anyOne.
			component _ self copyEmpty.
			node markDo: [:each|
				component nodes add: each.
				remainingNodes remove: each ifAbsent: []].
			aBlock value: component]! !

!Digraph methodsFor: 'copying' stamp: 'len 7/13/2016 22:56'!
copy
	^ self collect: [:each| each]! !

!Digraph methodsFor: 'copying' stamp: 'len 2/16/2016 22:19'!
copyEmpty
	"Return a graph of the same type with no nodes or edges."
	^self isImplicit
		ifTrue: [self class ordered]
		ifFalse: [super copy initialize]! !

!Digraph methodsFor: 'random' stamp: 'len 7/11/2016 05:59'!
edgeAtRandom: aRandom
	| count |
	3 timesRepeat:
		[| source |
		(source _ nodes atRandom: aRandom) neighbors
			ifNotEmpty: [:neighbors| ^ source -> (neighbors atRandom: aRandom)]].
	count _ self numberOfEdges atRandom.
	self edgesDo: [:each| (count _ count - 1) > 0 ifFalse: [^ each]].
	self error: 'inconsitency problem, edge not found'! !

!Digraph methodsFor: 'iterating' stamp: 'len 7/20/2016 23:39'!
edgesAndLabelsDo: aBinaryBlock
	self nodesDo: [:node| node neighborsAndLabelsDo: [:n :label| aBinaryBlock value: (Association key: node value value: n value) value: label]]! !

!Digraph methodsFor: 'iterating' stamp: 'len 7/20/2016 23:39'!
edgesDo: aBlock
	self nodesDo: [:node| node neighborsDo: [:n| aBlock value: (Association key: node value value: n value)]]! !

!Digraph methodsFor: 'iterating' stamp: 'len 7/20/2016 23:39'!
fullEdgesAndLabelsDo: aBinaryBlock
	self nodesDo: [:node| node neighborsAndLabelsDo: [:n :label| aBinaryBlock value: (Association key: node value: n) value: label]]! !

!Digraph methodsFor: 'iterating' stamp: 'len 7/20/2016 23:39'!
fullEdgesDo: aBlock
	self nodesDo: [:node| node neighborsDo: [:n| aBlock value: (Association key: node value: n)]]! !

!Digraph methodsFor: 'initialization' stamp: 'len 2/14/2016 22:15'!
implicitCollection: collectionBlock
	type _ #(#implicitCollection).
	nodeCreator _ (InitializationBlocks at: #implicitCollection) value: self value: collectionBlock! !

!Digraph methodsFor: 'initialization' stamp: 'len 2/14/2016 22:15'!
implicitIteratorBlock: iteratorBlock
	type _ #(#implicitIteratorBlock).
	nodeCreator _ (InitializationBlocks at: #implicitIteratorBlock) value: self value: iteratorBlock! !

!Digraph methodsFor: 'initialization' stamp: 'len 2/26/2016 21:40'!
initialize
	nodes _ KeyedSet new! !

!Digraph methodsFor: 'private' stamp: 'len 7/13/2016 22:37'!
isDirected
	^ true! !

!Digraph methodsFor: 'private' stamp: 'timestamp) (no'!
isImplicit
	"Is the node creator for implicit nodes?"
	^(type includes: #implicitCollection) or: [type includes: #implicitIteratorBlock]! !

!Digraph methodsFor: 'private' stamp: 'len 2/20/2016 06:38'!
isLabeled
	"Is the node creator for labeled nodes?"
	^type includes: #labeled! !

!Digraph methodsFor: 'testing' stamp: 'len 7/13/2016 20:56'!
isOrdered
	^ self type includes: #ordered! !

!Digraph methodsFor: 'testing' stamp: 'len 7/23/2016 07:29'!
isOriented
	self nodesDo: [:each|
		each neighborsDo: [:neighbor|
			(neighbor hasEdgeTo: each) ifTrue: [^ false]]].
	^ true! !

!Digraph methodsFor: 'testing' stamp: 'len 2/17/2016 03:38'!
isSymmetric
	^ nodes allSatisfy: [:each| each isSymmetric]! !

!Digraph methodsFor: 'testing' stamp: 'len 2/17/2016 03:37'!
isTransitive
	^ nodes allSatisfy: [:each| each isTransitive]! !

!Digraph methodsFor: 'testing' stamp: 'len 7/13/2016 20:56'!
isUnordered
	^ self type includes: #unordered! !

!Digraph methodsFor: 'testing' stamp: 'len 2/17/2016 02:42'!
isWeaklyConnected
	"A graph is said to be 'weakly connected' when its symmetric closure is connected."
	^ self symmetric isConnected! !

!Digraph methodsFor: 'private' stamp: 'timestamp) (no'!
nodeCreator: n
	nodeCreator := n! !

!Digraph methodsFor: 'accessing' stamp: 'len 2/14/2016 21:42'!
nodes
	^ nodes! !

!Digraph methodsFor: 'iterating' stamp: 'len 7/20/2016 23:42'!
nodesDo: aBlock
	self isImplicit
		ifTrue: [nodes asOrderedCollection do: aBlock]
		ifFalse: [nodes do: aBlock]! !

!Digraph methodsFor: 'initialization' stamp: 'len 2/14/2016 22:15'!
ordered
	type _ #(#ordered).
	nodeCreator _ InitializationBlocks at: #ordered! !

!Digraph methodsFor: 'initialization' stamp: 'len 2/20/2016 06:37'!
orderedLabeled
	type _ #(#ordered #labeled).
	nodeCreator _ InitializationBlocks at: #orderedLabeled! !

!Digraph methodsFor: 'adding/removing' stamp: 'timestamp) (no'!
remove: aGraphNode ifAbsent: exceptionBlock 
	"Remove the given node, evaluate exceptionBlock if it's not part of the graph.
	pre: the node shouldn't be the target of an edge."
	^nodes remove: aGraphNode ifAbsent: exceptionBlock! !

!Digraph methodsFor: 'adding/removing' stamp: 'len 5/25/2016 04:03'!
removeEdgeFrom: source to: target ifAbsent: exceptionBlock 
	"Remove the given edge, evaluate exceptionBlock if it doesn't exist. 
	pre: both the source and target of the edge must be in the graph."
	| sourceNode targetNode |
	sourceNode _ self nodeAt: source.
	targetNode _ self nodeAt: target.
	(sourceNode hasEdgeTo: targetNode)
		ifTrue: [sourceNode removeNeighbor: targetNode]
		ifFalse: [^ exceptionBlock value]! !

!Digraph methodsFor: 'accessing' stamp: 'len 2/14/2016 21:55'!
type
	^ type! !

!Digraph methodsFor: 'initialization' stamp: 'len 2/14/2016 22:16'!
unordered
	type _ #(#unordered).
	nodeCreator _ InitializationBlocks at: #unordered! !

!Digraph methodsFor: 'initialization' stamp: 'len 2/20/2016 06:35'!
unorderedLabeled
	type _ #(#unordered #labeled).
	nodeCreator _ InitializationBlocks at: #unorderedLabeled! !

!Digraph class methodsFor: 'instance creation' stamp: 'len 7/13/2016 22:50'!
arity: n
	"Create a new ordered graph with fixed arity."
	^ self basicNew initialize arity: n! !

!Digraph class methodsFor: 'instance creation' stamp: 'len 7/13/2016 22:50'!
arityLabeled: n
	"Create a new labeled, ordered graph with fixed arity."
	^ self basicNew initialize arityLabeled: n! !

!Digraph class methodsFor: 'instance creation' stamp: 'len 7/13/2016 22:51'!
binary
	"Create an ordered graph with arity of 2 (ie each vertex has exactly two connecting edges)."
	^ self basicNew initialize binary! !

!Digraph class methodsFor: 'instance creation' stamp: 'len 7/13/2016 22:51'!
binaryLabeled
	"Create an labeled, ordered graph with arity of 2 (ie each vertex has exactly two connecting edges)."
	^ self basicNew initialize binaryLabeled! !

!Digraph class methodsFor: 'instance creation' stamp: 'len 7/13/2016 22:51'!
implicitCollection: collectionBlock
	"Create a new graph, using the structure implicit in existing objects.
	Each node is the graph is accessed by evaluating collectionBlock to yield a collection of neighbouring nodes."
	^ self basicNew initialize implicitCollection: collectionBlock! !

!Digraph class methodsFor: 'instance creation' stamp: 'len 7/13/2016 22:51'!
implicitIteratorBlock: iteratorBlock
	"Create a new graph, using the structure implicit in existing objects.
	Each node is the graph is accessed by evaluating iteratorBlock to iterate over a collection of neighbouring nodes."
	^ self basicNew initialize implicitIteratorBlock: iteratorBlock! !

!Digraph class methodsFor: 'initialization' stamp: 'len 7/14/2016 03:05'!
initialize
	"Digraph initialize"
	InitializationBlocks	_ Dictionary new.
	InitializationBlocks
		at: #binary
		put: [:value | ExplicitGraphNode binary: value];
		at: #arity
		put: [:n | [:value | ExplicitGraphNode on: value arity: n]];
		at: #ordered
		put: [:value | ExplicitGraphNode ordered: value];
		at: #unordered
		put: [:value | ExplicitGraphNode newOn: value];
		at: #arityLabeled
		put: [:n | [:value | LabeledExplicitGraphNode on: value arity: n]];
		at: #binaryLabeled
		put: [:value | LabeledExplicitGraphNode binary: value];
		at: #orderedLabeled
		put: [:value | LabeledExplicitGraphNode ordered: value];
		at: #unorderedLabeled
		put: [:value | LabeledExplicitGraphNode newOn: value];
		at: #implicitCollection
		put: [:graph :collectionBlock | [:value | ImplicitGraphNode
				on: value
				collectionBlock: [(collectionBlock value: value)
						collect: [:node | graph add: node]]]];
		at: #implicitIteratorBlock
		put: [:graph :iteratorBlock | [:value | 
			| iterator | 
			iterator := iteratorBlock value: value.
			ImplicitGraphNode
				on: value
				iteratorBlock: [:aBlock | iterator
						value: [:node | aBlock
								value: (graph nodes add: node)]]]]! !

!Digraph class methodsFor: 'instance creation' stamp: 'len 7/13/2016 22:51'!
ordered
	"Create a new ordered graph."
	^ self basicNew initialize ordered! !

!Digraph class methodsFor: 'instance creation' stamp: 'len 7/13/2016 22:51'!
orderedLabeled
	"Create a new labeled, ordered graph."
	^ self basicNew initialize orderedLabeled! !

!Digraph class methodsFor: 'instance creation' stamp: 'len 7/13/2016 22:51'!
unordered
	"Create a new unordered graph."
	^ self basicNew initialize unordered! !

!Digraph class methodsFor: 'instance creation' stamp: 'len 7/13/2016 22:51'!
unorderedLabeled
	"Create a new labeled, unordered graph."
	^ self basicNew initialize unorderedLabeled! !

!RootedDigraph methodsFor: 'adding' stamp: 'len 2/19/2016 21:17'!
addEdgeFrom: source to: target
	super addEdgeFrom: source to: target.
	roots remove: target ifAbsent: []! !

!RootedDigraph methodsFor: 'adding' stamp: 'len 2/19/2016 21:17'!
addEdgeFrom: source to: target label: label
	super addEdgeFrom: source to: target label: label.
	roots remove: target ifAbsent: []! !

!RootedDigraph methodsFor: 'adding' stamp: 'len 7/11/2016 06:23'!
addRoot: anObject
	"Add anObject as a root of the graph."
	| node |
	node _ self add: anObject.
	roots add: node value.
	^ node! !

!RootedDigraph methodsFor: 'iterating' stamp: 'timestamp) (no'!
breadthFirstDo: aBlock
	"Evaluate aBlock for each set of nodes at a given depth in the graph.
	A node is at depth n if the longest path to that node from a root has n steps.
	pre: self isCyclic not"

	| df current |
	df := self frontier.
	[current := df frontier copy.
	current isEmpty] whileFalse:
		[aBlock value: current.
		df removeAll: current]! !

!RootedDigraph methodsFor: 'adding' stamp: 'timestamp) (no'!
buildFromRoots: rootCollection
	"Build the graph with given roots.
	The nodes should all be ImplicitGraphNodes, or have outgoing edges attached."
	self roots: rootCollection.
	self markDo: [ :junk ]! !

!RootedDigraph methodsFor: 'iterating' stamp: 'len 7/21/2016 00:02'!
collect: aBlock
	"Answer a new graph like the receiver but with vertices values mapped by aBlock.
	Note that aBlock is evaluated on the nodes, not the values."
	| answer |
	answer _ super copyEmpty.
	answer roots: (roots collect: aBlock).
	self do: [:each| answer add: (aBlock value: each)].
	self edgesDo: [:each| answer addEdgeFrom: (aBlock value: each key) to: (aBlock value: each value)].
	^ answer! !

!RootedDigraph methodsFor: 'iterating' stamp: 'len 7/21/2016 00:02'!
collect: aBlock labels: labelBlock
	"Answer a new graph like the receiver but with vertices values mapped by aBlock.
	Note that aBlock is evaluated on the nodes, not the values."
	| answer |
	answer _ super copyEmpty.
	self rootNodes do: [:each| answer addRoot: (aBlock value: each)].
	self do: [:each| answer add: (aBlock value: each)].
	self edgesAndLabelsDo: [:each :label| answer addEdgeFrom: (aBlock value: each key) to: (aBlock value: each value) label: (labelBlock value: label)].
	^ answer! !

!RootedDigraph methodsFor: 'copying' stamp: 'len 2/19/2016 21:38'!
copyEmpty
	"Return a new graph of the same type, with the same roots, but no edges."
	^ super copyEmpty roots: roots copy asSet! !

!RootedDigraph methodsFor: 'operations' stamp: 'timestamp) (no'!
depthList
	"Partitions the DAG, returning a SequenceableCollection of Sets of nodes in the graph.  Element n in the SequenceableCollection is the Set of nodes in the graph reachable in n-1 steps by the longest route from a root."
	^OrderedCollection accumulate: [ :incBlock | self breadthFirstDo: incBlock]! !

!RootedDigraph methodsFor: 'initialization' stamp: 'len 2/26/2016 23:01'!
findRoots
	"Find all nodes that are not the targets of an edge and make them the roots."
	roots _ self values.
	self nodesDo: [:node| node neighborsDo: [:n| roots remove: n value ifAbsent: []]]! !

!RootedDigraph methodsFor: 'iterating' stamp: 'len 2/17/2016 01:20'!
frontier
	"Return a DAGFrontier object, capable of iterating over this DAG."
	^ DAGFrontier on: self! !

!RootedDigraph methodsFor: 'initialization' stamp: 'timestamp) (no'!
initialize
	super initialize.
	roots := Set new! !

!RootedDigraph methodsFor: 'testing' stamp: 'len 6/24/2016 17:11'!
isCyclic
	"Is the graph cyclic?"

	| frontier remaining |
	frontier := self rootNodes.
	"Build a Bag of non-root nodes, each node once in the Bag for every predecessor."
	remaining := Bag new.
	nodes do: [:node | remaining addAll: node neighbors].
	
	[| next |
	next := frontier anyIfNone: [^remaining isEmpty not].
	frontier remove: next.
	next neighborsDo: 
			[:neighbor | 
			(remaining remove: neighbor) = 0 ifTrue: [frontier add: neighbor]]] 
			repeat! !

!RootedDigraph methodsFor: 'testing' stamp: 'timestamp) (no'!
isEmpty
	"Answer whether the receiver contains any elements."

	^roots isEmpty! !

!RootedDigraph methodsFor: 'testing' stamp: 'timestamp) (no'!
isTree
	"Is the graph a tree (more accurately, a forest)?
	It is if every node has at most one predecessor."
	| visited |
	visited := Set new.
	nodes do: [ :node |
		node neighborsDo: [ :neighbor |
			(visited includes: neighbor) ifTrue: [^false].
			visited add: neighbor]].
	^true! !

!RootedDigraph methodsFor: 'iterating' stamp: 'len 6/27/2016 23:23'!
markDo: aBlock
	"Visit each node in the graph once, applying aBlock.
	A node is only visited after at least one of its predecessors, but not necessarily after all the predecessors."
	| todo visited |
	todo _ self rootNodes as: Set2.
	visited _ Set2 new.
	[todo isEmpty] whileFalse:
		[| node |
		node _ todo anyOne.
		visited add: node.
		aBlock value: node.
		node neighborsDo:
			[ :child |
				(visited includes: child)
					ifFalse: [todo add: child]].
		todo remove: node]! !

!RootedDigraph methodsFor: 'iterating' stamp: 'len 6/24/2016 17:11'!
preOrderDo: aBlock 
	"Walk the graph, evaluating aBlock for each node.  Evaluate each node before its successors, but in no particular order when there is a choice.
	pre: self isCyclic not"

	| frontier remaining |
	frontier := self rootNodes.
	"Build a Bag of non-root nodes, each node once in the Bag for every predecessor."
	remaining := Bag new.
	nodes do: [:node | remaining addAll: node neighbors].
	
	[| next |
	next := frontier anyIfNone: [^self].
	aBlock value: next.
	frontier remove: next.
	next neighborsDo: 
			[:neighbor | 
			(remaining remove: neighbor) = 0 ifTrue: [frontier add: neighbor]]] 
			repeat! !

!RootedDigraph methodsFor: 'operations' stamp: 'timestamp) (no'!
reduce
	"Remove all redundant edges to form the transitive reduction.

	Based on Algorithm 4 in 'An Algorithm for Finding a Minimum Equivalent Graph of a Digraph', by D. M. Moyles and G. L. Thompson, JACM 16(3), July 1969, pp455-60 (with obvious simplifications for acyclic graphs)."
	
	self rootNodes do: [ :root | self reduceStep: root with: OrderedCollection new]! !

!RootedDigraph methodsFor: 'operations' stamp: 'len 6/27/2016 23:24'!
reduceSlow
	"Remove all redundant edges to form the transitive reduction.

	Based on Algorithm 4 in 'An Algorithm for Finding a Minimum Equivalent Graph of a Digraph', by D. M. Moyles and G. L. Thompson, JACM 16(3), July 1969, pp455-60 (with obvious simplifications for acyclic graphs).
	
	This version sometimes builds huge sets!!"
	
	| seqSet |
	seqSet _ Set2 accumulate: [ :incBlock |
				self rootNodes do: [ :root | incBlock value: (Array with: root)]].

	[seqSet isEmpty] whileFalse:
		[| newSeqSet |
"Transcript show: seqSet size printString ; cr."
		newSeqSet _ Set2 new.
		seqSet do: [ :seq || tail |
			tail _ seq last.
			tail neighborsDo: [ :neighbor |
				seq do: [ :node |
					(node ~= tail and: [node hasEdgeTo: neighbor])
						ifTrue: [
"Transcript show: node printString, ' -> ', neighbor printString ; cr."
								self removeEdgeFrom: node to: neighbor]].
				newSeqSet add: (seq copyWith: neighbor)]].
		seqSet _ newSeqSet]! !

!RootedDigraph methodsFor: 'operations' stamp: 'len 5/7/2016 04:13'!
reduceStep: node with: sofar 
	node degree = 0 ifTrue: [^self].
	node neighbors copy do: 
			[:succ | 
			sofar 
				do: [:done | (done hasEdgeTo: succ) ifTrue: [self removeEdgeFrom: done to: succ]].
			sofar addLast: node.
			self reduceStep: succ with: sofar.
			sofar removeLast]! !

!RootedDigraph methodsFor: 'removing' stamp: 'len 5/7/2016 04:13'!
removeAllFrom: aNode 
	"Remove the subtree below aNode (and associated edges), excluding aNode itself.
	Note that nodes are removed from the graph without being sent any messages."

	aNode walkPre: [:junk | ]
		post: 
			[:child | 
			child == aNode 
				ifTrue: [aNode neighbors copy do: [:n | aNode removeNeighbor: n]]
				ifFalse: [self remove: child]]! !

!RootedDigraph methodsFor: 'accessing' stamp: 'len 7/21/2016 00:04'!
root
	"pre: roots size = 1"
	^ roots anyOne! !

!RootedDigraph methodsFor: 'accessing' stamp: 'len 2/26/2016 23:21'!
rootNode
	"return the GraphNode for the root.
	pre: roots size = 1"
	^self nodeAt: roots anyOne! !

!RootedDigraph methodsFor: 'accessing' stamp: 'len 2/26/2016 23:22'!
rootNodes
	"Return the GraphNodes for the roots."
	^roots collect: [ :root | self nodeAt: root]! !

!RootedDigraph methodsFor: 'accessing' stamp: 'len 7/21/2016 00:03'!
roots
	^ roots! !

!RootedDigraph methodsFor: 'initialization' stamp: 'len 4/29/2016 22:28'!
roots: aCollection
	roots _ aCollection asSet.
	roots do: [:each| self add: each]! !

!RootedDigraph methodsFor: 'adding' stamp: 'len 2/26/2016 05:10'!
roots: rootNodes children: aBlock
	"Build the graph with given rootNodes.
	Evaluate aBlock for each node to obtain a Collection of its children."
	^self roots: rootNodes childrenGenerator:
		[ :node | [ :iterationBlock | (aBlock value: node) do: iterationBlock]]! !

!RootedDigraph methodsFor: 'adding' stamp: 'timestamp) (no'!
roots: rootNodes children: aBlock label: labelBlock
	"Build the graph with given rootNodes.
	Evaluate aBlock for each node to obtain a Collection of its children."
	^self
		roots: rootNodes 
		childrenGenerator: [ :node | [ :iterationBlock | (aBlock value: node) do: iterationBlock]]
		label: labelBlock! !

!RootedDigraph methodsFor: 'adding' stamp: 'timestamp) (no'!
roots: rootNodes childrenGenerator: aBlock
	"Build the graph with given rootNodes.
	Evaluate aBlock for each node to obtain an iterator over a Collection of its children."
	^self roots: rootNodes childrenGenerator: aBlock label: nil! !

!RootedDigraph methodsFor: 'adding' stamp: 'len 2/26/2016 20:55'!
roots: rootNodes childrenGenerator: aBlock label: labelBlock
	"Build the graph with given rootNodes.
	Evaluate aBlock for each node to obtain an iterator over a Collection of its children.
	Evaluate labelBlock (if not nil) for each node and child to obtain a label for the edge."
	| todo |
	self roots: rootNodes.
	todo := rootNodes asSet copy.
	[todo isEmpty] whileFalse:
		[| node |
		node := todo anyOne.
		(aBlock value: node) value:
			[ :child |
				(self includes: child) ifFalse: [todo add: child].
				labelBlock isNil
					ifTrue: [self addEdgeFrom: node to: child]
					ifFalse: [self addEdgeFrom: node to: child label: (labelBlock value: node value: child)]].
			todo remove: node].
	^self! !

!RootedDigraph methodsFor: 'adding' stamp: 'len 2/26/2016 05:03'!
roots: rootNodes childrenLabelGenerator: aBlock
	"Build the graph with given rootNodes.
	Evaluate aBlock for each node to obtain an iterator over a Collection of its children and labels."
	| todo |
	self roots: rootNodes.
	todo := rootNodes asSet copy.
	[todo isEmpty] whileFalse:
		[| node |
		node := todo anyOne.
		(aBlock value: node) value:
			[ :child :label |
				(self includes: child) ifFalse: [todo add: child].
				self addEdgeFrom: node to: child label: label].
			todo remove: node].
	^self! !

!RootedDigraph methodsFor: 'adding' stamp: 'timestamp) (no'!
roots: rootNodes childrenMsg: msg
	"Build the graph with given rootNodes.
	Send msg to each node to obtain a Collection of its children."
	^self roots: rootNodes childrenGenerator:
		[ :node | [ :iterationBlock | (node perform: msg) do: iterationBlock]]! !

!RootedDigraph methodsFor: 'testing' stamp: 'len 5/5/2016 01:50'!
test
	^ #[1 2 3 4]! !

!RootedDigraph methodsFor: 'iterating' stamp: 'len 2/14/2003 20:06'!
walkPre: preBlock post: postBlock
	"Recursively walk the tree(s).  Apply preBlock to each node, then walk the subtree below node, then apply postBlock to the node."
	self rootNodes do: [ :root | root walkPre: preBlock post: postBlock]! !

!RootedDigraph class methodsFor: 'examples' stamp: 'timestamp) (no'!
exampleDAG
	"RootedGraph exampleDAG."
	| d |
	d := self unordered.
	d addRoot: #r1.
	d addRoot: #r2.
	d addEdge: #r1 -> #n1.
	d addEdge: #r1 -> #n2.
	d addEdge: #r2 -> #n2.
	d addEdge: #n1 -> #n3.
	d addEdge: #n2 -> #n3.
	^d! !

!RootedDigraph class methodsFor: 'examples' stamp: 'len 2/12/2003 22:59'!
exampleForest
	"RootedGraph exampleForest"
	^self unordered roots: (Set with: Number with: Stream) children: [ :class | class subclasses]! !

!RootedDigraph class methodsFor: 'examples' stamp: 'timestamp) (no'!
exampleImplicitLargeTree
	"RootedGraph exampleImplicitLargeTree"
	^(self
		implicitCollection:
			[ :class |
				class == Class
					ifTrue: [#()]
					ifFalse: [class subclasses asSortedCollection: [ :x :y | x name < y name]]]) 		buildFromRoots: (Array with: Object)! !

!RootedDigraph class methodsFor: 'examples' stamp: 'timestamp) (no'!
exampleImplicitSmallTree
	"RootedGraph exampleImplicitSmallTree"
	^(self implicitCollection: [ :class | class subclasses]) buildFromRoots: (Set with: Number)! !

!RootedDigraph class methodsFor: 'examples' stamp: 'len 2/12/2003 22:58'!
exampleLargeTree
	"RootedGraph exampleLargeTree"
	^self ordered roots: (Array with: Object) children:
		[ :class | class == Class
					ifTrue: [#()]
					ifFalse: [class subclasses asSortedCollection: [ :x :y | x name < y name]]]! !

!RootedDigraph class methodsFor: 'examples' stamp: 'len 2/20/2016 06:36'!
exampleMediumLabelledTree
	"RootedGraph exampleMediumLabelledTree"
	^self unorderedLabeled
		roots: (Set with: Collection)
		children: [ :class | class subclasses]
		label: [ :src :trg |
				trg isVariable
					ifTrue: [trg isBits ifTrue: [#variableByte] ifFalse: [#variable]]
					ifFalse: [#normal]]! !

!RootedDigraph class methodsFor: 'examples' stamp: 'len 2/25/2016 20:44'!
exampleMediumTree
	^self unordered roots: (Set with: Collection) children: [ :class | class subclasses]! !

!RootedDigraph class methodsFor: 'examples' stamp: 'len 2/14/2003 23:43'!
exampleMediumTree2
	^self unordered roots: (Set with: Collection) children: [ :class | class subclasses]! !

!RootedDigraph class methodsFor: 'examples' stamp: 'len 2/20/2016 06:36'!
exampleSmallLabelledTree
	"RootedGraph exampleSmallLabelledTree"
	^self unorderedLabeled
		roots: (Set with: Number)
		children: [ :class | class subclasses]
		label: [ :src :trg | trg category]! !

!RootedDigraph class methodsFor: 'examples' stamp: 'len 2/20/2016 06:36'!
exampleSmallLabelledTree2
	"RootedGraph exampleSmallLabelledTree2"
	^self unorderedLabeled
		roots: (Set with: Magnitude)
		children: [ :class | class subclasses]
		label: [ :src :trg |
				trg isVariable
					ifTrue: [trg isBits ifTrue: [#variableByte] ifFalse: [#variable]]
					ifFalse: [#normal]]! !

!RootedDigraph class methodsFor: 'examples' stamp: 'len 2/12/2003 22:42'!
exampleSmallTree
	"RootedGraph exampleSmallTree"
	^self unordered roots: (Set with: Number) children: [ :class | class subclasses]! !

!RootedDigraph class methodsFor: 'examples' stamp: 'len 2/18/2003 22:09'!
exampleSmallTree2
	"RootedGraph exampleSmallTree2"
	^self unordered roots: (Set with: Magnitude) childrenMsg: #subclasses! !

!Graph methodsFor: 'adding/removing' stamp: 'len 7/13/2016 22:52'!
add: anObject
	^ digraph add: anObject! !

!Graph methodsFor: 'adding/removing' stamp: 'len 5/25/2016 04:07'!
addEdgeFrom: source to: target 
	| sourceNode targetNode |
	sourceNode _ self add: source.
	targetNode _ self add: target.
	sourceNode addNeighbor: targetNode.
	targetNode addNeighbor: sourceNode! !

!Graph methodsFor: 'adding/removing' stamp: 'len 5/25/2016 04:06'!
addEdgeFrom: source to: target label: label
	"pre: (self nodeAt: edge key) isLabeled"
	| sourceNode targetNode |
	sourceNode _ self add: source.
	targetNode _ self add: target.
	sourceNode addNeighbor: targetNode label: label.
	targetNode addNeighbor: sourceNode label: label! !

!Graph methodsFor: 'converting' stamp: 'len 7/13/2016 22:29'!
asDirected
	^ digraph! !

!Graph methodsFor: 'random' stamp: 'len 7/13/2016 23:14'!
atRandom: aRandom
	^ digraph atRandom: aRandom! !

!Graph methodsFor: 'operations' stamp: 'len 7/21/2016 02:44'!
complement
	^ self class digraph: digraph complement! !

!Graph methodsFor: 'iterating' stamp: 'len 7/13/2016 22:58'!
componentsDo: aBlock
	digraph componentsDo: [:each| aBlock value: (self class digraph: each)]! !

!Graph methodsFor: 'copying' stamp: 'len 7/13/2016 22:57'!
copy
	^ self class digraph: digraph copy! !

!Graph methodsFor: 'copying' stamp: 'len 7/13/2016 22:30'!
copyEmpty
	^ self class digraph: digraph copyEmpty! !

!Graph methodsFor: 'initialization' stamp: 'len 7/13/2016 22:29'!
digraph: aDigraph
	digraph _ aDigraph! !

!Graph methodsFor: 'random' stamp: 'len 7/13/2016 23:15'!
edgeAtRandom: aRandom
	^ (digraph edgeAtRandom: aRandom) as: MutualAssociation! !

!Graph methodsFor: 'iterating' stamp: 'len 7/13/2016 23:16'!
edgesAndLabelsDo: aBinaryBlock
	| visited |
	visited _ Set2 new.
	digraph edgesAndLabelsDo: [:each :label|
		(visited includes: each value -> each key)
			ifFalse: [aBinaryBlock value: (each as: MutualAssociation) value: label].
		visited add: each]! !

!Graph methodsFor: 'iterating' stamp: 'len 7/13/2016 23:16'!
edgesDo: aBlock
	| visited |
	visited _ Set2 new.
	digraph edgesDo: [:each|
		(visited includes: each value -> each key)
			ifFalse: [aBlock value: (each as: MutualAssociation)].
		visited add: each]! !

!Graph methodsFor: 'operations' stamp: 'len 7/15/2016 18:25'!
flowPolynomial
	"The flow polynomial F(G,k) is a polynomial in k that counts the number of nowhere-zero k-flows of G."
	| x |
	x _ ZZ polynomials x.
	^ (-1)**(self size + self numberOfEdges + self components size) * (self tuttePolynomial value: {0. 1 - x})! !

!Graph methodsFor: 'iterating' stamp: 'len 7/20/2016 23:43'!
fullEdgesAndLabelsDo: aBinaryBlock
	| visited |
	visited _ Set2 new.
	digraph fullEdgesAndLabelsDo: [:each :label|
		(visited includes: each value -> each key)
			ifFalse: [aBinaryBlock value: (each as: MutualAssociation) value: label].
		visited add: each]! !

!Graph methodsFor: 'iterating' stamp: 'len 7/20/2016 23:43'!
fullEdgesDo: aBlock
	| visited |
	visited _ Set2 new.
	digraph fullEdgesDo: [:each|
		(visited includes: each value -> each key)
			ifFalse: [aBlock value: (each as: MutualAssociation)].
		visited add: each]! !

!Graph methodsFor: 'testing' stamp: 'len 7/13/2016 22:37'!
isDirected
	^ false! !

!Graph methodsFor: 'testing' stamp: 'len 7/21/2016 02:13'!
isImplicit
	^ digraph isImplicit! !

!Graph methodsFor: 'testing' stamp: 'len 7/21/2016 02:13'!
isLabeled
	^ digraph isLabeled! !

!Graph methodsFor: 'testing' stamp: 'len 7/21/2016 02:13'!
isOrdered
	^ digraph isOrdered! !

!Graph methodsFor: 'testing' stamp: 'len 7/13/2016 22:35'!
isSymmetric
	^ true! !

!Graph methodsFor: 'testing' stamp: 'len 7/13/2016 22:35'!
isTransitive
	^ true! !

!Graph methodsFor: 'accessing' stamp: 'len 7/13/2016 22:53'!
nodes
	^ digraph nodes! !

!Graph methodsFor: 'iterating' stamp: 'len 7/13/2016 22:53'!
nodesDo: aBlock
	digraph nodesDo: aBlock! !

!Graph methodsFor: 'accessing' stamp: 'len 7/13/2016 21:45'!
numberOfEdges
	^ digraph numberOfEdges / 2! !

!Graph methodsFor: 'testing' stamp: 'len 7/13/2016 22:36'!
occurrencesOf: anObject 
	"Answer how many of the receiver's elements are equal to anObject."

	^(self includes: anObject) ifTrue: [1] ifFalse: [0]! !

!Graph methodsFor: 'adding/removing' stamp: 'len 7/13/2016 22:59'!
remove: aGraphNode ifAbsent: exceptionBlock 
	"Remove the given node, evaluate exceptionBlock if it's not part of the graph.
	pre: the node shouldn't be the target of an edge."
	^ digraph remove: aGraphNode ifAbsent: exceptionBlock! !

!Graph methodsFor: 'adding/removing' stamp: 'len 5/25/2016 04:04'!
removeEdgeFrom: source to: target ifAbsent: exceptionBlock 
	"Remove the given edge, evaluate exceptionBlock if it doesn't exist. 
	pre: both the source and target of the edge must be in the graph."
	| sourceNode targetNode |
	sourceNode _ self nodeAt: source.
	targetNode _ self nodeAt: target.
	(sourceNode hasEdgeTo: targetNode)
		ifTrue:
			[sourceNode removeNeighbor: targetNode.
			targetNode removeNeighbor: sourceNode]
		ifFalse: [^ exceptionBlock value]! !

!Graph methodsFor: 'operations' stamp: 'len 7/13/2016 22:13'!
symmetric
	^ self! !

!Graph methodsFor: 'operations' stamp: 'len 7/13/2016 22:13'!
transposed
	^ self! !

!Graph methodsFor: 'operations' stamp: 'len 7/15/2016 18:25'!
tuttePolynomial
	| P K G` |
	P _ ZZ polynomialsIn: #(x y).
	self isEdgeless ifTrue: [^ P one].
	K _ self components size.
	self edgesDo: [:e|
		e key = e value "it's a loop"
			ifTrue: [^ P y * (self - e) tuttePolynomial]
			ifFalse:
				[G` _ self - e.
				G` components size > K "it's a bridge"
					ifTrue: [^ P x * (self / e) tuttePolynomial]
					ifFalse: [^ G` tuttePolynomial + (self / e) tuttePolynomial]]].
	^ self error: 'inconsistency, this line should have been reaached'! !

!Graph methodsFor: 'accessing' stamp: 'len 7/16/2016 08:25'!
type
	^ digraph type! !

!Graph class methodsFor: 'instance creation' stamp: 'len 7/13/2016 22:43'!
arity: n
	"Create a new ordered graph with fixed arity."
	^ self digraph: (Digraph arity: n)! !

!Graph class methodsFor: 'instance creation' stamp: 'len 7/13/2016 22:43'!
arityLabeled: n
	"Create a new labeled, ordered graph with fixed arity."
	^ self digraph: (Digraph arityLabeled: n)! !

!Graph class methodsFor: 'instance creation' stamp: 'len 7/13/2016 22:43'!
binary
	"Create an ordered graph with arity of 2 (ie each vertex has exactly two connecting edges)."
	^ self digraph: Digraph binary! !

!Graph class methodsFor: 'instance creation' stamp: 'len 7/13/2016 22:44'!
binaryLabeled
	"Create an labeled, ordered graph with arity of 2 (ie each vertex has exactly two connecting edges)."
	^ self digraph: Digraph binaryLabeled! !

!Graph class methodsFor: 'private' stamp: 'len 7/13/2016 22:27'!
digraph: aDigraph
	^ self basicNew digraph: aDigraph! !

!Graph class methodsFor: 'instance creation' stamp: 'len 7/13/2016 22:44'!
implicitCollection: collectionBlock
	"Create a new graph, using the structure implicit in existing objects.
	Each node is the graph is accessed by evaluating collectionBlock to yield a collection of neighbouring nodes."
	^ self digraph: (Digraph implicitCollection: collectionBlock)! !

!Graph class methodsFor: 'instance creation' stamp: 'len 7/13/2016 22:44'!
implicitIteratorBlock: iteratorBlock
	"Create a new graph, using the structure implicit in existing objects.
	Each node is the graph is accessed by evaluating iteratorBlock to iterate over a collection of neighbouring nodes."
	^ self digraph: (Digraph implicitIteratorBlock: iteratorBlock)! !

!Graph class methodsFor: 'instance creation' stamp: 'len 7/13/2016 22:45'!
ordered
	"Create a new ordered graph."
	^ self digraph: Digraph ordered! !

!Graph class methodsFor: 'instance creation' stamp: 'len 7/13/2016 22:45'!
orderedLabeled
	"Create a new labeled, ordered graph."
	^ self digraph: Digraph orderedLabeled! !

!Graph class methodsFor: 'instance creation' stamp: 'len 7/13/2016 22:45'!
unordered
	"Create a new unordered graph."
	^ self digraph: Digraph unordered! !

!Graph class methodsFor: 'instance creation' stamp: 'len 7/13/2016 22:45'!
unorderedLabeled
	"Create a new labeled, unordered graph."
	^ self digraph: Digraph unorderedLabeled! !

!YoungTableau methodsFor: 'accessing' stamp: 'len 8/1/2016 02:52'!
at: aPoint
	^ (rows at: aPoint x) at: aPoint y! !

!YoungTableau methodsFor: 'accessing' stamp: 'len 8/1/2016 02:52'!
at: aPoint put: anObject
	^ (rows at: aPoint x) at: aPoint y put: anObject! !

!YoungTableau methodsFor: 'copying' stamp: 'len 7/11/2016 22:07'!
copy
	^ self class rows: (rows collect: [:each| each copy])! !

!YoungTableau methodsFor: 'accessing' stamp: 'len 8/1/2016 03:19'!
diagram
	^ YoungDiagram shape: self shape! !

!YoungTableau methodsFor: 'enumerating' stamp: 'len 7/11/2016 22:11'!
do: aBlock
	rows do: [:each| each do: aBlock]! !

!YoungTableau methodsFor: 'testing' stamp: 'len 8/1/2016 02:36'!
isSemistandard
	self withIndexDo: [:each :index|
		(index x > 1 and: [each < (self at: index x - 1 @ index y)])
			ifTrue: [^ false].
		(index y > 1 and: [each < (self at: index x @ (index y - 1))])
			ifTrue: [^ false]].
	^ true! !

!YoungTableau methodsFor: 'testing' stamp: 'len 7/12/2016 00:15'!
isStandard
	"if it is semistandard and content = (1,1,..,1)"
	self withIndexDo: [:each :index|
		(index x > 1 and: [each <= (self at: index x - 1 @ index y)])
			ifTrue: [^ false].
		(index y > 1 and: [each <= (self at: index x @ (index y - 1))])
			ifTrue: [^ false]].
	^ true! !

!YoungTableau methodsFor: 'arithmetic' stamp: 'len 7/11/2016 22:02'!
negated
	self numberOfRows = 1 ifTrue: [^ self].
	^ self copy at: 1@1 put: (self at: 1@2); at: 1@2 put: (self at: 1@1); yourself! !

!YoungTableau methodsFor: 'accessing' stamp: 'len 7/11/2016 22:35'!
numberOfColumns
	^ rows first size! !

!YoungTableau methodsFor: 'accessing' stamp: 'len 7/11/2016 22:34'!
numberOfRows
	^ rows size! !

!YoungTableau methodsFor: 'printing' stamp: 'len 7/11/2016 22:08'!
printOn: aStream
	self rows do: [:row|
		aStream nextPut: $[.
		row do: [:each| aStream print: each] separatedBy: [aStream nextPut: $|].
		aStream nextPut: $]] separatedBy: [aStream cr; space]! !

!YoungTableau methodsFor: 'accessing' stamp: 'len 7/12/2016 00:07'!
rank
	^ rows sum: [:each| each size]! !

!YoungTableau methodsFor: 'accessing' stamp: 'len 7/11/2016 21:47'!
rows
	^ rows! !

!YoungTableau methodsFor: 'initialization' stamp: 'len 7/11/2016 21:37'!
rows: anArray
	rows _ anArray! !

!YoungTableau methodsFor: 'accessing' stamp: 'len 7/11/2016 22:34'!
shape
	^ rows collect: [:each| each size]! !

!YoungTableau methodsFor: 'arithmetic' stamp: 'len 7/11/2016 21:56'!
sign
	self notYetImplemented! !

!YoungTableau methodsFor: 'accessing' stamp: 'len 7/12/2016 00:06'!
weight
	| answer |
	answer _ Array new: self rank.
	answer atAllPut: 0.
	self do: [:each| answer at: each put: (answer at: each) + 1].
	^ answer! !

!YoungTableau methodsFor: 'enumerating' stamp: 'len 8/1/2016 02:54'!
withIndexDo: aBlock
	rows withIndexDo: [:row :i| row withIndexDo: [:each :j| aBlock value: each value: i@j]]! !

!YoungTableau class methodsFor: 'instance creation' stamp: 'len 7/11/2016 21:47'!
rows: anArray
	^ self basicNew rows: anArray! !

!YoungTableau class methodsFor: 'instance creation' stamp: 'len 7/11/2016 22:33'!
shape: anArray
	^ self rows: (anArray collect: [:each| Array new: each])! !

!CompositeGraphMorph methodsFor: 'as yet unclassified' stamp: 'len 7/30/2016 07:36'!
addComponent: aGraphMorph
	self addMorph: aGraphMorph proportionalWidth: 1! !

!CompositeGraphMorph methodsFor: 'as yet unclassified' stamp: 'len 7/30/2016 07:41'!
componentsDo: aBlock
	self submorphsDo: [:each| (each isKindOf: GraphMorph) ifTrue: [aBlock value: each]]! !

!CompositeGraphMorph methodsFor: 'as yet unclassified' stamp: 'len 7/30/2016 07:41'!
dimension: anInteger
	self componentsDo: [:each| each dimension: anInteger]! !

!CompositeGraphMorph methodsFor: 'as yet unclassified' stamp: 'len 7/31/2016 05:08'!
edgeAt: anEdge 
	^ self nodeAt: anEdge ifAbsent: [self error: 'edge not found']! !

!CompositeGraphMorph methodsFor: 'as yet unclassified' stamp: 'len 7/31/2016 05:08'!
edgeAt: anEdge ifAbsent: exceptionBlock
	self componentsDo: [:each| (each edgeAt: anEdge ifAbsent: []) ifNotNil: [:edge| ^edge]].
	^ exceptionBlock value! !

!CompositeGraphMorph methodsFor: 'as yet unclassified' stamp: 'len 7/31/2016 05:02'!
edgesAndLabelsDo: aBlock 
	self componentsDo: [:each| each edgesAndLabelsDo: aBlock]! !

!CompositeGraphMorph methodsFor: 'as yet unclassified' stamp: 'len 7/30/2016 07:43'!
hideLabels
	self componentsDo: [:each| each hideLabels]! !

!CompositeGraphMorph methodsFor: 'as yet unclassified' stamp: 'len 7/30/2016 07:38'!
initialize
	super initialize.
	self color: Color transparent.
	self morphExtent: 600 @ 300! !

!CompositeGraphMorph methodsFor: 'as yet unclassified' stamp: 'len 7/31/2016 05:06'!
nodeAt: anObject 
	^ self nodeAt: anObject ifAbsent: [self error: 'node not found']! !

!CompositeGraphMorph methodsFor: 'as yet unclassified' stamp: 'len 7/31/2016 05:05'!
nodeAt: anObject ifAbsent: exceptionBlock
	self componentsDo: [:each| (each nodeAt: anObject ifAbsent: []) ifNotNil: [:node| ^node]].
	^ exceptionBlock value! !

!CompositeGraphMorph methodsFor: 'as yet unclassified' stamp: 'len 7/31/2016 05:03'!
nodesDo: aBlock
	self componentsDo: [:each| each nodesDo: aBlock]! !

!GraphMorph methodsFor: 'event handling' stamp: 'len 2/19/2016 02:05'!
acceptDroppingMorph: aMorph event: evt
	(aMorph isKindOf: self nodeClass)
		ifTrue: [self addMorph: aMorph.
				"self focusOn: aMorph node".
				^ self startStepping].
	^ super acceptDroppingMorph: aMorph event: evt! !

!GraphMorph methodsFor: 'private' stamp: 'len 2/12/2003 23:34'!
addEdge: anEdge
	^ self addEdge: anEdge label: nil! !

!GraphMorph methodsFor: 'private' stamp: 'len 7/14/2016 05:25'!
addEdge: anEdge label: label 
	| src dest |
	src _ self graph nodeAt: anEdge key.
	dest _ self graph nodeAt: anEdge value.
	^ self privateAddEdgeFrom: src to: dest label: label! !

!GraphMorph methodsFor: 'private' stamp: 'len 7/14/2016 05:42'!
addNode: aGraphNode 
	| morph |
	(nodeToMorph includesKey: aGraphNode)
		ifTrue: [^ nodeToMorph at: aGraphNode].
	morph _ self nodeClass new node: aGraphNode.
	morph dimension: dimension.
	nodeToMorph at: aGraphNode put: morph.
	morph morphPosition: self morphWidth asInteger atRandom @ self morphHeight asInteger atRandom.
	self addMorph: morph.
"	aGraphNode
		neighborsAndLabelsDo: [:each :label|
			self addNode: each.
			self privateAddEdgeFrom: aGraphNode to: each label: label]."
	^ morph! !

!GraphMorph methodsFor: 'stepping' stamp: 'len 7/9/2016 22:47'!
alignToCenter
	| centerOfMass delta |
	centerOfMass _ nodeToMorph anyOne x * 0. "0@0"
	self nodesDo: [:each| centerOfMass _ centerOfMass + each x].
	centerOfMass _ centerOfMass / graph size.
	centerOfMass isZero ifTrue: [^ self].
	delta _ centerOfMass negated.
	self nodesDo: [:each| each translateBy: delta]! !

!GraphMorph methodsFor: 'event handling' stamp: 'len 7/9/2016 22:52'!
allowSubmorphExtraction
	" allow extraction so submorphs can be grabbed and dragged to a new position.
	  usefull to rearrange the vertices manually"
	^ true! !

!GraphMorph methodsFor: 'layout' stamp: 'sam 6/1/2004 14:37'!
clearAll
	self clearEdges.
	self clearNodes.
	! !

!GraphMorph methodsFor: 'layout' stamp: 'len 2/14/2016 22:48'!
clearEdges
	self edgesDo: [:edgeMorph| edgeMorph delete].
	self initializeEdgeToMorph! !

!GraphMorph methodsFor: 'layout' stamp: 'len 2/14/2016 22:48'!
clearNodes
	self nodesDo: [:nodeMorph | nodeMorph delete].
	self initializeNodeToMorph! !

!GraphMorph methodsFor: 'accessing' stamp: 'len 7/9/2016 22:45'!
dimension
	^ dimension! !

!GraphMorph methodsFor: 'accessing' stamp: 'len 7/9/2016 22:45'!
dimension: anInteger
	dimension _ anInteger.
	self nodesDo: [:each| each dimension: anInteger].
	self startStepping! !

!GraphMorph methodsFor: 'accessing' stamp: 'len 7/31/2016 05:09'!
edgeAt: anEdge
	^ self edgeAt: anEdge ifAbsent: [self error: 'edge not found']! !

!GraphMorph methodsFor: 'accessing' stamp: 'len 7/31/2016 05:09'!
edgeAt: anEdge ifAbsent: exceptionBlock
	| edge |
	edge _ anEdge key -> anEdge value.
	graph isDirected ifFalse: [edge _ edge as: MutualAssociation].
	^ edgeToMorph at: edge ifAbsent: exceptionBlock! !

!GraphMorph methodsFor: 'private' stamp: 'len 7/9/2016 22:26'!
edgeClass
	^ GraphEdgeMorph! !

!GraphMorph methodsFor: 'accessing' stamp: 'len 5/4/2016 06:50'!
edges
	^ Iterator on: self performing: #edgesDo:! !

!GraphMorph methodsFor: 'iterating' stamp: 'len 2/29/2016 21:44'!
edgesAndLabelsDo: aBlock
	graph edgesAndLabelsDo: [:each :label| aBlock value: (self edgeAt: each) value: label]! !

!GraphMorph methodsFor: 'iterating' stamp: 'len 2/15/2003 19:02'!
edgesDo: aBlock
	edgeToMorph do: aBlock! !

!GraphMorph methodsFor: 'accessing' stamp: 'Samir Saidani 12/16/2003 02:02'!
focusNode
	^focusNode! !

!GraphMorph methodsFor: 'accessing' stamp: 'len 7/9/2016 23:00'!
focusOn: aNode
	focusNode _ graph nodeAt: aNode.
	nodeToMorph at: focusNode ifPresent: [:aMorph| aMorph freeze].
	self startStepping! !

!GraphMorph methodsFor: 'accessing' stamp: 'len 2/14/2016 22:45'!
graph
	^ graph! !

!GraphMorph methodsFor: 'accessing' stamp: 'len 7/14/2016 05:42'!
graph: aGraph
	self clearAll.
	graph _ aGraph.
	graph nodesDo: [:each| self addNode: each].
	graph edgesAndLabelsDo: [:each :label| self addEdge: each label: label].
	graph
		when: #addNode: send: #addNode: to: self;
		when: #addEdge: send: #addEdge: to: self;
		when: #removeNode: send: #removeNode: to: self;
		when: #removeEdge: send: #removeEdge: to: self.
	(graph isKindOf: RootedDigraph)
		ifTrue: [self focusOn: graph rootNode]
		ifFalse: [self focusOn: graph anyOne]! !

!GraphMorph methodsFor: 'event handling' stamp: 'len 7/9/2016 22:51'!
handlesMouseDown: aMouseButtonEvent
	"Do I want to receive mouseDown events (mouseDown:, mouseMove:, mouseUp:)?"
	^true! !

!GraphMorph methodsFor: 'accessing' stamp: 'len 7/9/2016 22:45'!
hideLabels
	self nodesDo: [:each| each hideLabel].
	self edgesDo: [:each| each hideLabel]! !

!GraphMorph methodsFor: 'initialization' stamp: 'len 7/14/2016 02:56'!
initialize
	super initialize.
	self morphExtent: 300 @ 300.
	self color: Color transparent.
	self initializeNodeToMorph.
	self initializeEdgeToMorph.
	dimension _ 3! !

!GraphMorph methodsFor: 'initialization' stamp: 'Samir Saidani 12/7/2003 19:25'!
initializeEdgeToMorph
	edgeToMorph _ Dictionary new! !

!GraphMorph methodsFor: 'initialization' stamp: 'Samir Saidani 12/7/2003 19:25'!
initializeNodeToMorph
	nodeToMorph _ Dictionary new! !

!GraphMorph methodsFor: 'event handling' stamp: 'len 7/9/2016 22:51'!
mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition
	super mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition.
	lastMousePosition _ localEventPosition! !

!GraphMorph methodsFor: 'event handling' stamp: 'len 7/9/2016 22:51'!
mouseMove: aMouseMoveEvent localPosition: localEventPosition
	lastMousePosition isNil
		ifFalse:
			[aMouseMoveEvent shiftPressed
				ifTrue:
					[| bounds d |
					bounds _ self morphLocalBounds.
					d _ (localEventPosition dist: lastMousePosition) / (bounds width min: bounds height).
					localEventPosition y >= lastMousePosition y ifTrue: [d _ d negated].
					self scaleEdgesBy: 2.0 ** d]
				ifFalse: [self rotateNodesBy: lastMousePosition - localEventPosition]].
	lastMousePosition _ localEventPosition! !

!GraphMorph methodsFor: 'accessing' stamp: 'len 7/31/2016 05:07'!
nodeAt: anObject
	^ nodeToMorph at: anObject! !

!GraphMorph methodsFor: 'accessing' stamp: 'len 7/31/2016 05:06'!
nodeAt: anObject ifAbsent: exceptionBlock
	^ nodeToMorph at: anObject ifAbsent: exceptionBlock! !

!GraphMorph methodsFor: 'private' stamp: 'len 7/9/2016 22:26'!
nodeClass
	^ GraphNodeMorph! !

!GraphMorph methodsFor: 'iterating' stamp: 'len 2/15/2003 18:58'!
nodesDo: aBlock
	nodeToMorph do: aBlock! !

!GraphMorph methodsFor: 'accessing' stamp: 'len 2/17/2016 23:11'!
origin
	^ (nodeToMorph at: (focusNode ifNil: [^ self morphExtent // 2])) morphBounds center! !

!GraphMorph methodsFor: 'accessing' stamp: 'len 7/9/2016 22:45'!
perturbate: n
	self nodesDo: [:each| each perturbate: n].
	self startStepping! !

!GraphMorph methodsFor: 'private' stamp: 'len 7/14/2016 05:38'!
privateAddEdgeFrom: source to: target label: label
	| edge morph |
	edge _ source -> target.
	graph isDirected ifFalse: [edge _ edge as: MutualAssociation].
	(edgeToMorph includesKey: edge)
		ifTrue: [^ (edgeToMorph at: edge) incrementMultiplicity].
	morph _ self edgeClass new.
	edgeToMorph at: edge put: morph.
	morph source: (nodeToMorph at: source); target: (nodeToMorph at: target).
	morph label: label.
	graph isDirected ifTrue: [morph showArrowHead] ifFalse: [morph hideArrowHead].
	self addMorphBack: morph.
	^ morph! !

!GraphMorph methodsFor: 'as yet unclassified' stamp: 'len 7/9/2016 22:53'!
privateExtent: aPoint
	^ (super privateExtent: aPoint) ifTrue: [self startStepping]; yourself! !

!GraphMorph methodsFor: 'private' stamp: 'len 7/14/2016 05:39'!
privateRemoveEdgeFrom: source to: target label: label 
	| edge |
	edge _ source -> target.
	graph isDirected ifFalse: [edge _ edge as: MutualAssociation].
	(edgeToMorph removeKey: edge ifAbsent: [^ self]) delete! !

!GraphMorph methodsFor: 'private' stamp: 'timestamp) (no'!
removeEdge: anEdge 
	^ self removeEdge: anEdge label: nil! !

!GraphMorph methodsFor: 'private' stamp: 'len 2/17/2016 23:06'!
removeEdge: anEdge label: label 
	^ self privateRemoveEdgeFrom: anEdge key to: anEdge value label: label! !

!GraphMorph methodsFor: 'event handling' stamp: 'len 7/9/2016 22:51'!
rotateNodesBy: aPoint
	| xSpeed ySpeed |
	self dimension < 3 ifTrue: [^ self].
	xSpeed _ Float pi / self morphLocalBounds width.
	ySpeed _ Float pi / self morphLocalBounds height.
"	self dimension = 2 ifTrue: [self nodesDo: [:each| |p pp| p _ each x. pp _ p x @ p y rotatedBy: aPoint y * ySpeed negated + (aPoint x * xSpeed). each x: (pp x, pp y)]. ^ self]."
	self nodesDo: [:each| | p xz yz |
		p _ each x.
		xz _ p x @ p z.
		xz _ xz rotatedBy: aPoint x * xSpeed.
		yz _ p y @ xz y.
		yz _ yz rotatedBy: aPoint y * ySpeed.
		p _ (xz x, yz x, yz y).
		each x: p.
		each dx: p * 0. "optimization, dont rotate the velocities"].
	self startStepping! !

!GraphMorph methodsFor: 'stepping' stamp: 'len 7/9/2016 22:48'!
step
	| maxDelta |
	self nodesDo: [:each| each dampBy: 1.1]. "damping"
	self alignToCenter.
	maxDelta _ 0.
	self nodesDo: [:each| maxDelta _ maxDelta max: each doMove].
	self edgesDo: [:each| each adjustBounds].
	self redrawNeeded.
	maxDelta < 0.1 ifTrue: [self stopStepping]! !

!GraphMorph methodsFor: 'stepping' stamp: 'len 7/9/2016 22:48'!
stepTime
	^ 0! !

!GraphMorph methodsFor: 'stepping' stamp: 'len 7/9/2016 22:48'!
wantsSteps
	^ true! !

!SpringGraphMorph methodsFor: 'event handling' stamp: 'len 2/8/2003 00:38'!
allowSubmorphExtraction
	" allow extraction so submorphs can be grabbed and dragged to a new position.
	  usefull to rearrange the vertices manually"
	^ true! !

!SpringGraphMorph methodsFor: 'stepping' stamp: 'len 4/30/2016 02:22'!
approachComponents
	| componentsDesiredDistance |
	(components isNil or: [components size < 2])
		ifTrue: [^ self].
	componentsDesiredDistance _ 1.
	components do: [:each|
		components do: [:other|
			each == other
				ifFalse:
					[| source target f currentDistance diff delta |
					source _ each atRandom.
					target _ other atRandom.
					(currentDistance _ (diff _ source x + source dx - target x - target dx) norm) > componentsDesiredDistance
						ifTrue:
							[f _ (componentsDesiredDistance - currentDistance) asFloat / (currentDistance * 4).
							delta _ diff * f / 2.
							"target dx: target dx - delta."
							source dx: source dx + (delta/other size)]]]]! !

!SpringGraphMorph methodsFor: 'stepping' stamp: 'len 2/25/2016 16:36'!
aproachConnectedNodes
	self edgesDo: [:each| each approachNodes]! !

!SpringGraphMorph methodsFor: 'accessing' stamp: 'len 4/26/2016 02:06'!
desiredDistance: aNumber
	^ self edgesDo: [:each| each desiredDistance: aNumber]! !

!SpringGraphMorph methodsFor: 'private' stamp: 'len 2/15/2003 18:10'!
edgeClass
	^ SpringEdgeMorph! !

!SpringGraphMorph methodsFor: 'accessing' stamp: 'len 5/25/2016 03:15'!
graph: aGraph
	| morph desiredDistance |
	super graph: aGraph.
	(aGraph isKindOf: RootedDigraph)
		ifTrue: [morph _ nodeToMorph at: aGraph rootNode.
				morph morphAlign: morph morphBounds center with: self morphExtent // 2].
	aGraph size < 100
		ifTrue: [desiredDistance _ (self morphLocalBounds area / (aGraph radius min: 10) / 2) sqrt.
			components _ graph components asArray collect: [:each| each asArray collect: [:node| nodeToMorph at: node]]]
		ifFalse:
			[desiredDistance _ 10.
			components _ nil].
	self edgesDo: [:each| each desiredDistance: desiredDistance "/ each source node degree sqrt"]! !

!SpringGraphMorph methodsFor: 'private' stamp: 'len 2/25/2016 17:42'!
nodeClass
	^ SpringNodeMorph! !

!SpringGraphMorph methodsFor: 'event handling' stamp: 'len 4/27/2016 08:01'!
scaleEdgesBy: aNumber
	self edgesDo: [:each| each desiredDistance: each desiredDistance * aNumber].
	self startStepping! !

!SpringGraphMorph methodsFor: 'stepping' stamp: 'len 2/19/2016 04:17'!
separateAllNodes
	self nodesDo: [:each | each separateFromAllNodes]! !

!SpringGraphMorph methodsFor: 'stepping' stamp: 'len 4/30/2016 02:23'!
step
	| maxDelta |
	self nodesDo: [:each| each dampBy: 1.1]. "damping"
	self aproachConnectedNodes; separateAllNodes; "approachComponents;" alignToCenter.
	maxDelta _ 0.
	self nodesDo: [:each| maxDelta _ maxDelta max: each doMove].
	self edgesDo: [:each| each adjustBounds].
	self redrawNeeded.
	maxDelta < 0.1 ifTrue: [self stopStepping]! !

!FunctionPlotMorph methodsFor: 'private' stamp: 'len 1/2/2016 06:07'!
computeEvaluationPoints
	evaluationPoints _ xMin to: xMax by: 1/100.0! !

!FunctionPlotMorph methodsFor: 'private' stamp: 'len 4/27/2016 22:23'!
computeValues
	values _ self evaluationPoints collect: [:x| [function value: x] on: Error do: [0]].
	yMin isNil
		ifTrue:
			[yMin _ values min.
			yMax _ values max]! !

!FunctionPlotMorph methodsFor: 'drawing' stamp: 'len 4/28/2016 05:42'!
drawOn: aCanvas
	| rect p lastP font |
	values isNil ifTrue: [self computeValues].
	rect _ self morphLocalBounds.
	aCanvas fillRectangle: rect color: backgroundColor.
	aCanvas line: (self localToMorphic:0@yMin)-(0@1) to: (self localToMorphic: 0 @ yMax)+(0@1) width: 1 color: textColor.
	aCanvas line: (self localToMorphic: xMin@0)+(1@0) to: (self localToMorphic: xMax@0)-(1@0) width: 1 color: textColor.

	lastP _ nil.
	self evaluationPoints with: values do: [:x :value|
		| y |
		y _ value ifNil: [0].
		(y between: yMin and: yMax)
			ifTrue:
				[p _ (self xToMorphic: x)@(self yToMorphic: y).
				p _ p rounded.
				lastP notNil
					ifTrue:
						[| y0 |
						aCanvas line: lastP to: p width: 1 color: color.
						y0 _ (self yToMorphic: 0) rounded.
						y > 0
							ifTrue: [aCanvas fillRectangle: (lastP corner: (p x @ (y0 min: rect bottom))) color: fillColor]
							ifFalse: [aCanvas fillRectangle: (lastP x @ (y0 max: rect top) corner: p) color: fillColor]].
					lastP _ p]
			ifFalse:
				[lastP _ nil]].

	font _ AbstractFont default. " Preferences standardButtonFont."
	aCanvas drawString: (yMax roundTo: 0.01) printString at: rect left + 2 @ (rect top + 2) font: font color: textColor.
	aCanvas drawString: (yMin roundTo: 0.01)  printString at: rect left + 2 @ (rect bottom - (font height * 2) - 2) font: font color: textColor.
	aCanvas drawString: (xMax roundTo: 0.01) printString at: rect right - (font widthOfString: (xMax  roundTo: 0.01) printString) - 2 @ (rect bottom - font height - 2) font: font color: textColor.
	aCanvas drawString: (xMin roundTo: 0.01) printString at: rect left + 2 + 20 @ (rect bottom - font height - 2) font: font color: textColor! !

!FunctionPlotMorph methodsFor: 'accessing' stamp: 'len 1/2/2016 06:03'!
evaluationPoints
	evaluationPoints isNil ifTrue: [self computeEvaluationPoints].
	^ evaluationPoints! !

!FunctionPlotMorph methodsFor: 'accessing' stamp: 'len 4/27/2016 21:36'!
evaluationPoints: aCollection
	xMin _ aCollection first.
	xMax _ aCollection last.
	evaluationPoints _ aCollection.
	values _ nil! !

!FunctionPlotMorph methodsFor: 'accessing' stamp: 'len 1/6/2016 02:53'!
function: aFunction
	function _ aFunction.
	yMin _ nil. yMax _ nil! !

!FunctionPlotMorph methodsFor: 'event handling' stamp: 'len 4/27/2016 21:11'!
handlesMouseDown: aMouseButtonEvent
	"Do I want to receive mouseDown events (mouseDown:, mouseMove:, mouseUp:)?"
	^true! !

!FunctionPlotMorph methodsFor: 'initialization' stamp: 'len 4/24/2016 02:15'!
initialize
	super initialize.
	extent _ 280@175.
	color _ Color lightGray.
	backgroundColor _ Color transparent.
	fillColor _ Color transparent.
	textColor _ Color gray alpha: 0.5! !

!FunctionPlotMorph methodsFor: 'drawing' stamp: 'len 4/28/2016 05:40'!
localToMorphic: aPoint
	^(self xToMorphic: aPoint x) @ (self yToMorphic: aPoint y)! !

!FunctionPlotMorph methodsFor: 'drawing' stamp: 'len 4/27/2016 22:04'!
morphicToLocal: aPoint
	| bounds |
	bounds _ self morphLocalBounds.
	^ aPoint x - bounds left / bounds width * (xMax - xMin) + xMin @ (aPoint y - bounds top / bounds height * (yMax - yMin) + yMin)! !

!FunctionPlotMorph methodsFor: 'event handling' stamp: 'len 4/27/2016 21:57'!
mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition
	super mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition.
	firstMousePosition _ lastMousePosition _ localEventPosition! !

!FunctionPlotMorph methodsFor: 'event handling' stamp: 'len 6/24/2016 21:36'!
mouseButton1Up: aMouseButtonEvent localPosition: localEventPosition
	super mouseButton1Up: aMouseButtonEvent localPosition: localEventPosition.
	self flag: #fix.
"	mouseMoveEventHandler _ nil"! !

!FunctionPlotMorph methodsFor: 'event handling' stamp: 'len 4/27/2016 22:16'!
mouseMove: aMouseMoveEvent localPosition: localEventPosition
	firstMousePosition isNil
		ifTrue: [firstMousePosition _ localEventPosition]
		ifFalse:
			[aMouseMoveEvent shiftPressed
				ifTrue:
					[| bounds anchor delta |
					bounds _ self morphLocalBounds.
					delta _ localEventPosition - lastMousePosition / (bounds width max: bounds height).
					self scaleBy: 2.0 ** delta x negated @ (2.0 ** delta y) anchor: firstMousePosition]
				ifFalse:
					[| bounds delta |
					bounds _ self morphLocalBounds.
					delta _ localEventPosition - lastMousePosition / (bounds width max: bounds height).
					self scrollBy: delta]].
	lastMousePosition _ localEventPosition! !

!FunctionPlotMorph methodsFor: 'event handling' stamp: 'len 4/27/2016 22:21'!
scaleBy: aPoint anchor: anchorPoint
	| p |
	p _ self morphicToLocal: anchorPoint.
	self evaluationPoints: (self evaluationPoints collect: [:each| each - p x * aPoint x + p x]).
	self redrawNeeded! !

!FunctionPlotMorph methodsFor: 'event handling' stamp: 'len 4/27/2016 21:33'!
scrollBy: aPoint
	| dx dy |
	dx _ xMin - xMax * aPoint x.
	self evaluationPoints: (self evaluationPoints collect: [:each| each + dx]).
	dy _ yMax - yMin * aPoint y.
	yMin _ yMin + dy.
	yMax _ yMax + dy.
	self redrawNeeded! !

!FunctionPlotMorph methodsFor: 'drawing' stamp: 'len 12/4/2015 05:00'!
xToMorphic: x
	^x - xMin / (xMax - xMin ) * extent x! !

!FunctionPlotMorph methodsFor: 'accessing' stamp: 'len 4/21/2016 05:29'!
yMin: min yMax: max
	yMin _ min.
	yMax _ max! !

!FunctionPlotMorph methodsFor: 'drawing' stamp: 'len 12/4/2015 05:00'!
yToMorphic: y
	^yMax - y / (yMax - yMin ) * extent y! !

!FunctionPlotMorph class methodsFor: 'examples' stamp: 'len 4/21/2016 05:28'!
example
	"
	FunctionPlotMorph example
	"
	| sin |
	sin _ Function evaluating: [:x| x sin].
	^ FunctionPlotMorph new evaluationPoints: (0.0 to: Float pi * 2 count: 100); function: sin; color: (Color red alpha: 0.5)! !

!FunctionPlotMorph class methodsFor: 'examples' stamp: 'len 4/21/2016 05:30'!
example2
	"
	FunctionPlotMorph example2
	"
	^ FunctionPlotMorph new
		color: (Color skyBlue alpha: 0.5);
		function: Sequence phi;
		evaluationPoints: (1 to: 150)! !

!FunctionPlotMorph class methodsFor: 'examples' stamp: 'len 4/21/2016 05:31'!
example3
	"
	FunctionPlotMorph example3
	"
	^ FunctionPlotMorph new
		evaluationPoints: (1 to: 150);
		function: Sequence calkinWilf;
		color: (Color yellow alpha: 0.5)! !

!FunctionPlotMorph class methodsFor: 'examples' stamp: 'len 4/21/2016 05:31'!
example4
	"
	FunctionPlotMorph example4
	"
	^ FunctionPlotMorph new
		evaluationPoints: (1 to: 5);
		function: Sequence primes;
		yMin: 0 yMax: 12;
		color: (Color orange alpha: 0.5)! !

!HistogramMorph methodsFor: 'building' stamp: 'jmv 4/10/2015 16:12'!
accumulate

	2 to: tallies size do: [ :i |
		tallies at: i put: (tallies at: i) + (tallies at: i-1) ]! !

!HistogramMorph methodsFor: 'building' stamp: 'jmv 4/10/2015 16:13'!
accumulated

	^self copy accumulate! !

!HistogramMorph methodsFor: 'building' stamp: 'jmv 4/6/2015 11:37'!
addValue: aNumber

	| i |
	i _ self indexFor: aNumber.
	tallies at: i put: (tallies at: i) + 1! !

!HistogramMorph methodsFor: 'accessing' stamp: 'jmv 4/10/2015 16:11'!
countAt: value
	^tallies at: (self indexFor: value)! !

!HistogramMorph methodsFor: 'drawing' stamp: 'len 4/27/2016 08:18'!
drawOn: aCanvas
	| rect x dx y min max font |
	rect _ self morphLocalBounds.
	aCanvas fillRectangle: rect color: backgroundColor.
	min _ 0. max _ tallies max.
	max = min ifTrue: [^ self].
	dx _ rect width asFloat / tallies size.
	x _ rect left.
	tallies do: [:v|
		| bar |
		y _ (max-v) / (max-min) * rect height asFloat.
		y _ y min: rect height.
		y _ y max: 0.
		bar _ x truncated @ y corner: ((x _ x + dx) ceiling @ rect bottom).
		aCanvas fillRectangle: bar color: color].
	
	font _ AbstractFont default. " Preferences standardButtonFont."
	aCanvas drawString: max printString at: rect left + 2 @ (rect top + 2) font: font color: textColor.
	aCanvas drawString: min printString at: rect left + 2 @ (rect bottom - font height - 2) font: font color: textColor
! !

!HistogramMorph methodsFor: 'as yet unclassified' stamp: 'len 4/24/2016 05:38'!
handlesMouseDown: evt
	^ true! !

!HistogramMorph methodsFor: 'as yet unclassified' stamp: 'len 4/24/2016 05:35'!
handlesMouseOver: evt
	^ true! !

!HistogramMorph methodsFor: 'private' stamp: 'len 4/25/2016 07:39'!
indexFor: aValue
	| slotIndex |
	slotIndex _ ((aValue - lowBinCenter / (highBinCenter -lowBinCenter )) * (tallies size-1)) rounded + 1.
	^slotIndex min: tallies size max: 1.! !

!HistogramMorph methodsFor: 'initialization' stamp: 'len 4/27/2016 07:28'!
initialize
	super initialize.
	extent _ 280@175.
	color _ Color darkGray.
	backgroundColor _ Color transparent.
	textColor _ Color gray alpha: 0.5! !

!HistogramMorph methodsFor: 'building' stamp: 'len 12/27/2015 22:45'!
inverted
	"For accumulated histograms, compute de inverse cummulative function.
	This is not an exact inverse, and is so far an experiment.
	Some tests to ensure good properties, and maybe more work, are in order. "
	| answer answerTallies n i k |
	n _ self regularTalliesCount.
	answerTallies _ WordArray new: n.
	answer _ HistogramMorph basicNew
		tallies: answerTallies
		lowBinCenter: 0
		highBinCenter: n
		extraBinsForClampedValues: false.
	i _ 1.
	k _ 1.0 * n / tallies last.
	1 to: n do: [ :j |
		[ (tallies at: i) * k < j ] whileTrue: [ i _ i + 1 ].
		answerTallies at: j put: i
		].
	^answer! !

!HistogramMorph methodsFor: 'as yet unclassified' stamp: 'len 4/25/2016 07:46'!
mouseMove: aMouseMoveEvent localPosition: localEventPosition
	| i |
	i _ (localEventPosition x * tallies size / self morphLocalBounds width) truncated + 1.
	i _ (i min: tallies size) max: 1.
	self showBalloon: i printString, ' -> ', (tallies at: i) printString! !

!HistogramMorph methodsFor: 'copying' stamp: 'jmv 4/10/2015 16:16'!
postCopy
	tallies _ tallies copy! !

!HistogramMorph methodsFor: 'private' stamp: 'jmv 4/6/2015 11:18'!
regularTalliesCount

	^ extraBinsForClampedValues
		ifTrue: [ tallies size - 2 ]
		ifFalse: [ tallies size ]! !

!HistogramMorph methodsFor: 'private' stamp: 'len 4/25/2016 07:29'!
tallies: anArray lowBinCenter: aNumber highBinCenter: anotherNumber extraBinsForClampedValues: aBoolean
	tallies _ anArray.
	lowBinCenter _ aNumber.
	highBinCenter _ anotherNumber.
	extraBinsForClampedValues _ aBoolean.
	tallies size < 300 ifTrue: [extent _ (extent x / tallies size) truncated + 1 * tallies size @ extent y]! !

!HistogramMorph class methodsFor: 'examples' stamp: 'len 4/23/2016 04:02'!
example
	"
	HistogramMorph example
	"
	| r h |
	r _ Random new.
	h _ HistogramMorph new: 500 min: 0 max: 1.
	100000 timesRepeat: [h addValue: r next].
	h openInHand! !

!HistogramMorph class methodsFor: 'examples' stamp: 'len 7/15/2016 18:26'!
example2
	"
	HistogramMorph example2
	"
	| h S n |
	S _ ZZ ** 4.
	n _ 40.
	h _ HistogramMorph new: 500 min: 0 max: n.
	100000 timesRepeat: [h addValue: (S atRandom: n) bitSize].
	h openInHand! !

!HistogramMorph class methodsFor: 'examples' stamp: 'len 4/24/2016 02:44'!
example3
	"primes conspiracy"
	| h p r |
	h _ HistogramMorph new: 22 min: 1 max: 100.
	p _ 2. r _ p \\ 10.
	100 timesRepeat:
		[| p` r` |
		p` _ p nextPrime. r` _ p` \\ 10.
		h addValue: (r * 10 + r`).
		r _ r`. p _ p`].
	^ h! !

!HistogramMorph class methodsFor: 'instance creation' stamp: 'len 4/23/2016 04:02'!
new: binCount lowBinCenter: lowBinCenter highBinCenter: highBinCenter
	"lowBinCenter is the center value of the lowest bin.
	highBinCenter is the center value of the highest bin.
	
	Values lower than the lower bound of the first bin go in the fist bin,
	and values higher or equal than the upper bound of the last bin go in the last bin.
		(i.e., out of range values are simply clamped)
		
	For example, the following will give a histogram where first and last bins have half the counts as all the rest:
		| h r |
		h _ Histogram binCount: 10 lowBinCenter: 0 highBinCenter: 100.
		r _ Random new.
		10000 timesRepeat: [ h addValue: r next * 100  ].
		h plot
		
	Maybe what we wanted was:
		| h r |
		h _ Histogram binCount: 10 lowBinCenter: 5 highBinCenter: 95.
		r _ Random new.
		10000 timesRepeat: [ h addValue: r next  * 100 ].
		h plot
	
	Or more simply
		| h r |
		h _ Histogram binCount: 10 minValue: 0 maxValue: 100.
		r _ Random new.
		10000 timesRepeat: [ h addValue: r next  * 100 ].
		h plot
"

	^self new
		tallies: (WordArray new: binCount)
		lowBinCenter: lowBinCenter
		highBinCenter: highBinCenter
		extraBinsForClampedValues: false! !

!HistogramMorph class methodsFor: 'instance creation' stamp: 'len 4/23/2016 04:03'!
new: binCount min: min max: max
	"min is the lower bound of the lowest bin.
	max is the upper bound of the highest bin.
	
	Values lower than min go in the fist bin, and values higher or equal than max go in the last bin.
		(i.e., out of range values are simply clamped)

		| h r |
		h _ Histogram binCount: 10 minValue: 0.0 maxValue: 1.0.
		r _ Random new.
		10000 timesRepeat: [ h addValue: r next  ].
		h plot

	"

	^self new: binCount min: min max: max extraBinsForClampedValues: false! !

!HistogramMorph class methodsFor: 'instance creation' stamp: 'len 4/23/2016 04:01'!
new: regularBinCount min: min max: max extraBinsForClampedValues: aBoolean
	"min is the lower bound of the lowest bin.
	max is the upper bound of the highest bin.
	
	If aBoolean is false, values lower than min go in the fist bin, and values higher or equal than max go in the last bin.
		(i.e., out of range values are simply clamped)
	If aBoolean, then extra bins are added at each end for these 'out of range' values

		| h r |
		h _ Histogram binCount: 10 minValue: 0.0 maxValue: 1.0 extraBinsForClampedValues: true.
		r _ Random new.
		10000 timesRepeat: [ h addValue: r next  ].
		h plot
	"

	| tallies highBinCenter lowBinCenter halfBinWidth |
	halfBinWidth _ max - min / regularBinCount / 2.0.
	aBoolean
		ifTrue: [
			tallies _ WordArray new: regularBinCount + 2.
			lowBinCenter _ min - halfBinWidth.
			highBinCenter _ max + halfBinWidth ]
		ifFalse: [
			tallies _ WordArray new: regularBinCount.
			lowBinCenter _ min + halfBinWidth.
			highBinCenter _ max - halfBinWidth ].
	^self new
		tallies: tallies
		lowBinCenter: lowBinCenter
		highBinCenter: highBinCenter
		extraBinsForClampedValues: aBoolean! !

!HistogramMorph class methodsFor: 'instance creation' stamp: 'len 8/14/2016 00:10'!
new: binCount samples: aCollection
	| answer |
	answer _ self new: binCount min: aCollection min max: aCollection max.
	aCollection do: [:each| answer addValue: each].
	^ answer! !

!MultiplicationTableMorph methodsFor: 'as yet unclassified' stamp: 'len 7/31/2016 05:20'!
drawOn: aCanvas
	| h w |
	w _ extent x / elements size.
	h _ extent y / elements size.
	w > 10
		ifTrue:
			[1 to: elements size do: [:i|
				1 to: elements size do: [:j|
					aCanvas fillRectangle: ((i-1*w @ (j-1*h)) truncated corner: (i*w-1 @ (j*h-1)) truncated) color: (colors at: (operation value: {elements at: i. elements at: j}))]]]
		ifFalse:
			[1 to: elements size do: [:i|
				1 to: elements size do: [:j|
					aCanvas fillRectangle: ((i-1*w @ (j-1*h)) truncated corner: (i*w @ (j*h)) truncated) color: (colors at: (operation value: {elements at: i. elements at: j}))]]]
		! !

!MultiplicationTableMorph methodsFor: 'as yet unclassified' stamp: 'len 7/31/2016 01:47'!
elements: anArray
	elements _ anArray asArray! !

!MultiplicationTableMorph methodsFor: 'as yet unclassified' stamp: 'len 8/16/2016 04:03'!
initialize
	super initialize.
	self morphExtent: 150@150.
	colors _ AutomaticPalette new! !

!MultiplicationTableMorph methodsFor: 'as yet unclassified' stamp: 'len 7/31/2016 04:28'!
morphExtent: aPoint
	| max |
	max _ aPoint x max: aPoint y.
	super morphExtent: max @ max! !

!MultiplicationTableMorph methodsFor: 'as yet unclassified' stamp: 'len 7/31/2016 01:47'!
operation: aBinaryOperation
	operation _ aBinaryOperation! !

!MultiplicationTableMorph class methodsFor: 'as yet unclassified' stamp: 'len 7/31/2016 01:48'!
elements: anArray operation: aBinaryOperation
	^ self new elements: anArray; operation: aBinaryOperation! !

!ScalarPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 8/17/2016 23:44'!
drawOn: aCanvas
	| r |
	r _ 1.
	0 to: extent x - r by: r do: [:x|
		0 to: extent y - r by: r do: [:y|
			aCanvas fillRectangle: (x@y extent: r@r) color: (palette at: (function value: (self morphToDomain: x@y)))]]
! !

!ScalarPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 8/17/2016 23:23'!
function: aFunction
	function _ aFunction! !

!ScalarPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 8/17/2016 23:50'!
initialize
	super initialize.
	extent _ 100@100.
	function _ [:v| v x cos * v y sin].
	xMin _ -4. xMax _ 4.
	yMin _ -4. yMax _ 4.
	palette _ ContinuousPalette default min: -1.0; max: 1.0! !

!ScalarPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 8/17/2016 23:30'!
morphToDomain: aPoint
	^ (aPoint x * (xMax - xMin) / extent x + xMin, (aPoint y * (yMax - yMin) / extent y + yMin))! !

!ScatterPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 8/16/2016 03:45'!
applyRotationBy: aPoint
	| bounds xSpeed ySpeed rotation |
	self dimension < 3 ifTrue: [^ self].
	bounds _ self morphLocalBounds.
	xSpeed _ Float pi / bounds width.
	ySpeed _ Float pi / bounds height.
	rotation _ (QQ**self dimension) endomorphisms evaluating: [:p|
		| xz yz |
		xz _ p x @ p z.
		xz _ xz rotatedBy: aPoint x * xSpeed.
		yz _ p y @ xz y.
		yz _ yz rotatedBy: aPoint y * ySpeed.
		(xz x, yz x, yz y), (p copyFrom: 4 to: p size)].
	transformation _ rotation @ (transformation ifNil: [rotation identity]).
	self redrawNeeded! !

!ScatterPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 8/16/2016 02:00'!
applyScaleBy: aNumber
	transformation _ transformation * aNumber.
	self redrawNeeded! !

!ScatterPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 8/21/2016 07:13'!
colorBy: aBlock
	colorBlock _ aBlock.
	self redrawNeeded! !

!ScatterPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 8/15/2016 18:57'!
dimension
	^ points anyOne size! !

!ScatterPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 8/21/2016 07:19'!
drawOn: aCanvas
	| bounds range boxColor w |
	bounds _ self morphLocalBounds insetBy: 1.
	range _ max - min.
	"draw box:"
	self dimension >= 3 ifTrue:
		[boxColor _ Color white alpha: 0.2.
		self drawPolyline: {(-1,-1,-1). (-1,1,-1). (-1,1,1). (1,1,1). (1,-1,1). (1,-1,-1). (-1,-1,-1). (-1,-1,1). (-1,1,1)} color: boxColor on: aCanvas.
		self drawPolyline: {(1,-1,1). (-1,-1,1)} color: boxColor on: aCanvas.
		self drawPolyline: {(1,1,-1). (1,1,1)} color: boxColor on: aCanvas.
		self drawPolyline: {(1,-1,-1). (1,1,-1). (-1,1,-1)} color: boxColor on: aCanvas].
	
	"draw points:"
	w _ extent x min: extent y.
	points withIndexDo: [:each :k|
		| p xy z r shade c |
		p _ positionBlock value: each.
		p _ p collect: [:xi| xi - min / range - 0.5 * 2].
		transformation ifNotNil: [p _ transformation value: p].
		xy _ p x / 2 + 0.5 * w @ (p y / 2 + 0.5 * w).
		z _ p size >= 3 ifTrue: [(p z / 2 + 0.5 max: 0.0) min: 1.0] ifFalse: [1.0].
		r _ z * (sizeBlock value: each) :: rounded + 1.
		shade _ z / 2 + 0.5.
		c _ colorBlock value: each.
		c _ c mixed: shade with: Color black.
		c _ c alpha: c alpha * (shade / 2 + 0.5).
		(bounds containsPoint: xy) ifTrue:
			[aCanvas fillRectangle: (Rectangle center: xy extent: r@r) color: c]]! !

!ScatterPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 8/19/2016 18:39'!
drawPolyline: anArray color: aColor on: aCanvas
	| w lastPoint |
	w _ extent x min: extent y.
	lastPoint _ nil.
	anArray do: [:each|
		| p xy |
		p _ transformation ifNil: [each] ifNotNil: [transformation value: each].
		xy _ p x / 2 + 0.5 * w @ (p y / 2 + 0.5 * w).
		lastPoint ifNotNil: [aCanvas line: lastPoint to: xy width: 1 color: aColor].
		lastPoint _ xy]! !

!ScatterPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 8/13/2016 04:51'!
handlesMouseDown: aMouseButtonEvent
	"Do I want to receive mouseDown events (mouseDown:, mouseMove:, mouseUp:)?"
	^true! !

!ScatterPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 8/19/2016 18:30'!
initialize
	| palette |
	super initialize.
	color _ Color white.
	extent _ 250@250.
	transformation _ nil.
	positionBlock _ [:aTuple| aTuple copyFrom: 1 to: (aTuple size min: 3)].
	palette _ ContinuousPalette default.
	colorBlock _ [:aTuple| palette at: (positionBlock value: aTuple) norm2 / (max - min) squared].
	sizeBlock _ [:aTuple| 3]! !

!ScatterPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 8/13/2016 04:51'!
mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition
	super mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition.
	lastMousePosition _ localEventPosition! !

!ScatterPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 8/16/2016 01:59'!
mouseMove: aMouseMoveEvent localPosition: localEventPosition
	lastMousePosition isNil
		ifFalse:
			[aMouseMoveEvent shiftPressed
				ifTrue:
					[| bounds d |
					bounds _ self morphLocalBounds.
					d _ (localEventPosition dist: lastMousePosition) / (bounds width min: bounds height).
					localEventPosition y >= lastMousePosition y ifTrue: [d _ d negated].
					self applyScaleBy: 2.0 ** d]
				ifFalse: [self applyRotationBy: lastMousePosition - localEventPosition]].
	lastMousePosition _ localEventPosition! !

!ScatterPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 8/21/2016 07:14'!
points: anArray
	points _ anArray.
	max _ points max: [:each| each max].
	min _ points min: [:each| each min].
	transformation _ QQ**self dimension :: id.
	self redrawNeeded! !

!ScatterPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 8/21/2016 07:13'!
positionBy: aBlock
	positionBlock _ aBlock.
	self redrawNeeded! !

!ScatterPlotMorph methodsFor: 'as yet unclassified' stamp: 'len 8/21/2016 07:13'!
sizeBy: aBlock
	sizeBlock _ aBlock.
	self redrawNeeded! !

!ScatterPlotMorph class methodsFor: 'as yet unclassified' stamp: 'len 8/19/2016 23:33'!
example
	| palette |
	palette _ ContinuousPalette default.
	^ (self timeDelayPlot: (Sequence primes difference first: 1000))
			colorBy: [:each| palette at: each bitSize / 40.0]! !

!ScatterPlotMorph class methodsFor: 'as yet unclassified' stamp: 'len 8/19/2016 05:21'!
example2
	| samples |
	samples _ 1 to: 1000 :: collect: [:i| Random new next].
	^ self timeDelayPlot: samples! !

!ScatterPlotMorph class methodsFor: 'as yet unclassified' stamp: 'len 8/19/2016 05:22'!
example3
	| samples |
	samples _ 1 to: 1000 :: collect: [:i| | r | r _ Random new. 100 timesRepeat: [r next]. r next].
	^ self timeDelayPlot: samples! !

!ScatterPlotMorph class methodsFor: 'as yet unclassified' stamp: 'len 8/18/2016 06:38'!
timeDelayPlot: anArray
	^ self timeDelayPlot: anArray lag: 1! !

!ScatterPlotMorph class methodsFor: 'as yet unclassified' stamp: 'len 8/18/2016 06:39'!
timeDelayPlot: anArray dimension: m lag: r
	^ self new
		points: ((m*r+1 to: anArray size) collect: [:i|
			Tuple new: m evaluating: [:j| anArray at: i-(j-1*r)]])! !

!ScatterPlotMorph class methodsFor: 'as yet unclassified' stamp: 'len 8/18/2016 06:39'!
timeDelayPlot: anArray lag: r
	^ self timeDelayPlot: anArray dimension: 3 lag: r! !

!GraphEdgeMorph methodsFor: 'private' stamp: 'len 2/19/2016 19:04'!
adjustBounds
	| newBounds |
	newBounds _ (self externalize: self sourcePoint) rect: (self externalize: self targetPoint).
	self morphBounds: newBounds.
	labelMorph ifNotNil: [labelMorph morphAlign: labelMorph morphBounds center with: newBounds extent // 2]! !

!GraphEdgeMorph methodsFor: 'accessing' stamp: 'len 7/9/2016 22:11'!
alpha
	^ source alpha + target alpha / 2.0! !

!GraphEdgeMorph methodsFor: 'accessing' stamp: 'len 7/9/2016 22:26'!
color
	^ color alpha: self alpha! !

!GraphEdgeMorph methodsFor: 'accessing' stamp: 'len 7/9/2016 22:27'!
color: aColor
	color _ aColor! !

!GraphEdgeMorph methodsFor: 'drawing' stamp: 'len 3/1/2016 01:44'!
direction
	^ (self targetPoint - self sourcePoint) normalized! !

!GraphEdgeMorph methodsFor: 'drawing' stamp: 'len 7/14/2016 06:17'!
drawArcOn: aCanvas from: sourcePoint to: targetPoint
	multiplicity odd
		ifTrue: [aCanvas line: sourcePoint to: targetPoint width: width color: color].
	1 to: multiplicity - (multiplicity \\ 2) do: [:i|
		self drawCurveOn: aCanvas from: sourcePoint to: targetPoint curvature: i+1//2 * (i odd ifTrue: [1] ifFalse: [-1])]! !

!GraphEdgeMorph methodsFor: 'drawing' stamp: 'len 7/14/2016 05:20'!
drawArrowOn: aCanvas from: aPoint to: anotherPoint
	| sourcePoint targetPoint direction |
	sourcePoint _ aPoint.
	targetPoint _ anotherPoint.
	direction _ (targetPoint - sourcePoint) normalized.
	target identityHash < source identityHash
		ifTrue:
			[ | shift |
			shift _ (direction rotatedBy: Float pi/2) * 4.
			sourcePoint _ sourcePoint + shift.
			targetPoint _ targetPoint + shift].
	targetPoint _ targetPoint - (direction * target morphExtent x).
	sourcePoint _ sourcePoint + (direction * source morphExtent x).
	self drawArcOn: aCanvas from: sourcePoint to: targetPoint.
	aCanvas line: targetPoint - (direction*3) - ((direction rotatedBy: Float pi / 4) * 4)
		to: targetPoint width: width color: self color.
	aCanvas line: targetPoint - (direction*2) - ((direction rotatedBy: Float pi / 4) * 4)
		to: targetPoint width: width color: self color.
	aCanvas line: targetPoint - (direction*3) - ((direction rotatedBy: Float pi * 7 / 4) * 4)
		to: targetPoint width: width color: self color.
	aCanvas line: targetPoint - (direction*2) - ((direction rotatedBy: Float pi * 7 / 4) * 4)
		to: targetPoint width: width color: self color.

"	self sourcePoint = self targetPoint
		ifFalse: [aCanvas
				drawThinArrowFrom: self sourcePoint
				to: self targetPoint
				width: 1
				color: self color]"
			
	"| circle string |  
	circle _ EllipseMorph new extent: 20 @ 20;  
	 
	color: (Color  
	r: 1.0  
	g: 0.452  
	b: 0.065).  
	circle align: circle center with: self center.  
	self addMorph: circle.  
	string _ StringMorph new contents: 'test'.  
	string align: string bounds leftCenter with: bounds rightCenter + (4 @  
	0). self addMorph: string"
"	| aa |
	aa _ PolygonMorph new.
	aa computeArrowFormAt: self sourcePoint from: self destinationPoint.
	self addMorph: aa"
! !

!GraphEdgeMorph methodsFor: 'drawing' stamp: 'len 7/14/2016 05:44'!
drawCurveOn: aCanvas from: sourcePoint to: targetPoint curvature: curvature
	| perp previous |
	perp _ targetPoint - sourcePoint / 10.0 rotatedBy: Float pi / 2.
	0.0 to: 1.0 count: 15 do: [:i|
		| current |
		current _ sourcePoint * i + (targetPoint * (1.0-i)).
		current _ current + ((0.5 - (0.5-i) abs) sqrt * curvature * perp).
		previous ifNotNil: [aCanvas line: previous to: current width: width color: color].
		previous _ current]! !

!GraphEdgeMorph methodsFor: 'drawing' stamp: 'len 7/14/2016 02:51'!
drawLoopOn: aCanvas at: aPoint
	aCanvas frameEllipse: (aPoint - (10@20) extent: 20@20) borderWidth: width color: self color! !

!GraphEdgeMorph methodsFor: 'drawing' stamp: 'len 7/14/2016 05:21'!
drawOn: aCanvas 
	"frameRectangle: self bounds color: Color black;"
	| sourcePoint targetPoint |
	"aCanvas frameRectangle: self morphLocalBounds borderWidth: 1 color: Color red."
	[sourcePoint _ self sourcePoint.
	targetPoint _ self targetPoint] on: Error do: [^ self].
	targetPoint = sourcePoint ifTrue: [^ self drawLoopOn: aCanvas at: targetPoint].
	drawArrowHead ifTrue: [^ self drawArrowOn: aCanvas from: sourcePoint to: targetPoint].
	self drawArcOn: aCanvas from: sourcePoint to: targetPoint! !

!GraphEdgeMorph methodsFor: 'accessing' stamp: 'len 2/19/2016 03:25'!
hideArrowHead
	drawArrowHead _ false! !

!GraphEdgeMorph methodsFor: 'private' stamp: 'len 2/19/2016 19:01'!
hideLabel
	labelMorph notNil ifTrue: [labelMorph delete. labelMorph _ nil]! !

!GraphEdgeMorph methodsFor: 'accessing' stamp: 'len 7/14/2016 05:33'!
incrementMultiplicity
	multiplicity _ multiplicity + 1! !

!GraphEdgeMorph methodsFor: 'initialization' stamp: 'len 7/14/2016 05:37'!
initialize
	super initialize.
	self color: Color gray.
	width _ 1.
	drawArrowHead _ true.
	multiplicity _ 1! !

!GraphEdgeMorph methodsFor: 'accessing' stamp: 'len 2/19/2016 19:00'!
label
	^ label! !

!GraphEdgeMorph methodsFor: 'accessing' stamp: 'len 2/19/2016 19:00'!
label: aString
	label _ aString.
	label notNil ifTrue: [self showLabel] ifFalse: [self hideLabel]! !

!GraphEdgeMorph methodsFor: 'geometry testing' stamp: 'len 4/28/2016 05:50'!
morphContainsPoint: aLocalPoint
	^ super morphContainsPoint: aLocalPoint! !

!GraphEdgeMorph methodsFor: 'accessing' stamp: 'len 2/19/2016 03:25'!
showArrowHead
	drawArrowHead _ true! !

!GraphEdgeMorph methodsFor: 'private' stamp: 'len 4/30/2016 06:56'!
showLabel
	(labelMorph notNil or: [label isNil]) ifTrue: [^ self].
	labelMorph _ StringMorph contents: label asString font: Preferences standardMenuFont.
	labelMorph color: Color white.
	self addMorph: labelMorph.
	labelMorph morphAlign: labelMorph morphBounds leftCenter with: self morphBounds rightCenter + (1@0)! !

!GraphEdgeMorph methodsFor: 'accessing' stamp: 'Samir Saidani 6/23/2003 21:17'!
source
	^ source! !

!GraphEdgeMorph methodsFor: 'accessing' stamp: 'Samir Saidani 6/23/2003 21:17'!
source: aMorph
	source _ aMorph! !

!GraphEdgeMorph methodsFor: 'accessing' stamp: 'len 3/1/2016 01:48'!
sourcePoint
	^ self internalizeFromWorld: source morphBoundsInWorld center! !

!GraphEdgeMorph methodsFor: 'stepping' stamp: 'len 2/26/2016 03:03'!
step
	(source owner isNil or: [target owner isNil]) ifTrue: [^ self delete].
	self adjustBounds! !

!GraphEdgeMorph methodsFor: 'stepping' stamp: 'Samir Saidani 6/23/2003 21:17'!
stepTime
	^ 0! !

!GraphEdgeMorph methodsFor: 'accessing' stamp: 'len 2/15/2016 22:56'!
target
	^ target! !

!GraphEdgeMorph methodsFor: 'accessing' stamp: 'len 2/15/2016 22:56'!
target: aMorph
	target _ aMorph! !

!GraphEdgeMorph methodsFor: 'accessing' stamp: 'len 2/17/2016 22:20'!
targetPoint
	^ self internalizeFromWorld: target morphBoundsInWorld center! !

!GraphEdgeMorph methodsFor: 'stepping' stamp: 'len 2/17/2016 22:15'!
wantsSteps
	^ true! !

!GraphEdgeMorph methodsFor: 'accessing' stamp: 'len 2/18/2016 06:16'!
width
	^ width! !

!GraphEdgeMorph methodsFor: 'accessing' stamp: 'len 2/18/2016 06:16'!
width: anInteger
	"Set the width of the line to draw."
	width _ anInteger! !

!SpringEdgeMorph methodsFor: 'moving' stamp: 'len 2/25/2016 17:08'!
approachNodes
	"Connected nodes are tied with a rubber band."
	| f currentDistance diff delta |
	(currentDistance _ (diff _ source x + source dx - target x - target dx) norm) > desiredDistance
		ifTrue:
			[f _ (desiredDistance - currentDistance) asFloat / (currentDistance * 4).
			delta _ diff * f / 2.
			target dx: target dx - delta.
			source dx: source dx + delta]! !

!SpringEdgeMorph methodsFor: 'moving' stamp: 'len 4/27/2016 07:57'!
desiredDistance
	^ desiredDistance! !

!SpringEdgeMorph methodsFor: 'moving' stamp: 'len 2/15/2003 18:07'!
desiredDistance: anInteger
	"Set the distance I want between my vertices."
	desiredDistance _ anInteger! !

!SpringEdgeMorph methodsFor: 'initialization' stamp: 'Michael Piel 4/21/2004 11:12'!
initialize
	super initialize.
	desiredDistance _ 100! !

!SpringEdgeMorph methodsFor: 'stepping' stamp: 'len 2/26/2016 03:04'!
step
	(source owner isNil or: [target owner isNil]) ifTrue: [^ self delete].
"	self approachNodes."
	self adjustBounds! !

!SpringEdgeMorph methodsFor: 'stepping' stamp: 'len 2/24/2016 21:12'!
wantsSteps
	^ false! !

!GraphNodeMorph methodsFor: 'accessing' stamp: 'len 7/9/2016 22:39'!
alpha
	self dimension > 2 ifFalse: [^ 1.0].
	(owner isNil or: [x z >= 0]) ifTrue: [^ 1.0].
	^ (x z / owner morphExtent y + 1) squared min: 1.0 max: 0.0! !

!GraphNodeMorph methodsFor: 'accessing' stamp: 'len 7/9/2016 22:25'!
color
	^ color! !

!GraphNodeMorph methodsFor: 'accessing' stamp: 'len 7/9/2016 22:25'!
color: aColor
	color _ aColor! !

!GraphNodeMorph methodsFor: 'moving' stamp: 'len 7/9/2016 22:40'!
dampBy: aNumber
	dx _ dx / aNumber! !

!GraphNodeMorph methodsFor: 'accessing' stamp: 'len 7/9/2016 22:39'!
dimension
	^ x size! !

!GraphNodeMorph methodsFor: 'accessing' stamp: 'len 7/9/2016 22:40'!
dimension: anInteger
	| n |
	(n _ x size) = anInteger
		ifTrue: [^ self].
	n > anInteger
		ifTrue:
			[x _ x copyFrom: 1 to: anInteger.
			dx _ dx copyFrom: 1 to: anInteger]
		ifFalse:
			[| z |
			z _ Tuple new: anInteger - n evaluating: [:i| 0].
			x _ x, z.
			dx _ dx, z]! !

!GraphNodeMorph methodsFor: 'moving' stamp: 'len 7/9/2016 22:40'!
doMove
	| bounds delta |
	x _ x + dx.
	bounds _ owner morphLocalBounds.
	self morphPosition: bounds center + ((x at: 1) @ (x at: 2)).
	(bounds containsRect: self morphBounds)
		ifFalse: [delta _ 2 * (self morphBounds amountToTranslateWithin: bounds).
					x _ x + (delta x, delta y).
					self morphPosition: bounds center + ((x at: 1) @ (x at: 2)).
					dx _ dx * 0 "0@0"].
	^ dx norm! !

!GraphNodeMorph methodsFor: 'drawing' stamp: 'len 5/4/2016 06:37'!
drawOn: aCanvas
	(extent x abs < 2 and: [extent y abs < 2]) ifTrue: [^ self].
	shape == #circle
		ifTrue: [aCanvas fillEllipse: self morphLocalBounds color: self color. ^ self].
	shape == #square
		ifTrue: [aCanvas fillRectangle: self morphLocalBounds color: self color. ^ self].
	shape == #squareFrame
		ifTrue: [aCanvas frameRectangle: self morphLocalBounds borderWidth: 1 color: self color. ^ self].
	shape == #circleFrame
		ifTrue: [aCanvas frameEllipse: self morphLocalBounds borderWidth: 1 color: self color. ^ self].
	"otherwise do nothing"
	^ self! !

!GraphNodeMorph methodsFor: 'accessing' stamp: 'len 7/9/2016 22:41'!
dx
	^ dx! !

!GraphNodeMorph methodsFor: 'accessing' stamp: 'len 7/9/2016 22:41'!
dx: aVector
	dx _ aVector! !

!GraphNodeMorph methodsFor: 'accessing' stamp: 'len 7/9/2016 22:30'!
extent
	^ extent! !

!GraphNodeMorph methodsFor: 'accessing' stamp: 'len 7/9/2016 22:30'!
extent: aPoint
	extent _ aPoint! !

!GraphNodeMorph methodsFor: 'moving' stamp: 'len 7/9/2016 22:54'!
freeze
	dx _ dx * 0.0! !

!GraphNodeMorph methodsFor: 'private' stamp: 'len 2/18/2016 21:42'!
hideLabel
	labelMorph notNil ifTrue: [labelMorph delete. labelMorph _ nil]! !

!GraphNodeMorph methodsFor: 'initialization' stamp: 'len 7/9/2016 22:59'!
initialize
	super initialize.
	self color: Color gray.
	x _ (0,0).
	dx _ x.
	shape _ #circle.
	extent _ 10@10! !

!GraphNodeMorph methodsFor: 'accessing' stamp: 'len 2/18/2016 21:42'!
label
	^ label! !

!GraphNodeMorph methodsFor: 'accessing' stamp: 'len 2/18/2016 21:43'!
label: aString
	label _ aString.
	label notNil ifTrue: [self showLabel] ifFalse: [self hideLabel]! !

!GraphNodeMorph methodsFor: 'moving' stamp: 'len 7/9/2016 22:31'!
morphExtent
	^ extent! !

!GraphNodeMorph methodsFor: 'accessing' stamp: 'len 2/12/2003 23:20'!
node
	^ node! !

!GraphNodeMorph methodsFor: 'accessing' stamp: 'len 4/8/2016 23:02'!
node: aGraphNode 
	node _ aGraphNode.
	self label: node value printText! !

!GraphNodeMorph methodsFor: 'moving' stamp: 'len 7/9/2016 22:42'!
perturbate: n
	dx _ dx + (dx collect: [:xi| n atRandom - n])! !

!GraphNodeMorph methodsFor: 'moving' stamp: 'len 7/9/2016 22:42'!
perturbation
	^ x collect: [:xi| 3 atRandom - 2]! !

!GraphNodeMorph methodsFor: 'accessing' stamp: 'len 2/26/2016 03:13'!
radius: aNumber
	self morphExtent: aNumber @ aNumber! !

!GraphNodeMorph methodsFor: 'accessing' stamp: 'len 2/18/2016 21:25'!
shape
	^ shape! !

!GraphNodeMorph methodsFor: 'accessing' stamp: 'len 2/18/2016 21:31'!
shape: aShapeSymbol
	shape _ aShapeSymbol.
	self redrawNeeded! !

!GraphNodeMorph methodsFor: 'private' stamp: 'len 4/30/2016 06:55'!
showLabel
	(labelMorph notNil or: [label isNil]) ifTrue: [^ self].
	labelMorph _ StringMorph contents: label font: Preferences standardMenuFont.
	labelMorph color: Color white.
	self addMorph: labelMorph.
	labelMorph morphAlign: labelMorph morphBounds leftCenter with: self morphBounds rightCenter + (1@0)! !

!GraphNodeMorph methodsFor: 'moving' stamp: 'len 7/9/2016 22:42'!
translateBy: delta
	dx _ dx + delta! !

!GraphNodeMorph methodsFor: 'accessing' stamp: 'len 2/18/2016 21:07'!
value
	^ node value! !

!GraphNodeMorph methodsFor: 'accessing' stamp: 'len 7/9/2016 22:14'!
x
	^ x! !

!GraphNodeMorph methodsFor: 'accessing' stamp: 'len 7/9/2016 22:14'!
x: aPoint
	x _ aPoint! !

!SpringNodeMorph methodsFor: 'event handling testing' stamp: 'len 7/9/2016 22:10'!
aboutToBeGrabbedBy: aHand 
	super aboutToBeGrabbedBy: aHand.
	(owner isKindOf: GraphMorph) ifTrue: ["owner focusOn: node; stopStepping"]! !

!SpringNodeMorph methodsFor: 'moving' stamp: 'len 2/25/2016 16:56'!
approachPoint: aPoint
	| dx` x1 x2 diff |
	dx` _ dx - dx. "0@0."
	x1 _ x.
	x2 _ aPoint.
	x1 = x2 ifTrue: [^ self].
	diff _ x1 - x2.
	dx` _ dx` + (diff / diff norm2).
	dx` isZero ifFalse: [dx _ dx + (dx` / dx` norm * 2)]! !

!SpringNodeMorph methodsFor: 'event handling testing' stamp: 'sam 2/10/2004 01:56'!
handlesMouseDown: evt 
	evt shiftPressed
		ifFalse: [^ super handlesMouseDown: evt]
		ifTrue: [^ true]! !

!SpringNodeMorph methodsFor: 'private' stamp: 'len 2/29/2016 21:28'!
nearbyNodesDo: aBlock
	| count |
	count _ 0.
	node markDo: [:each |
		count _ count + 1.
		count > 40 ifTrue: [^ self].
		aBlock value: (owner nodeAt: each)]! !

!SpringNodeMorph methodsFor: 'moving' stamp: 'len 7/9/2016 22:15'!
separateFromAllNodes
	| dx` x1 x2 |
	(owner isKindOf: SpringGraphMorph) ifFalse: [^ self].
	dx` _ dx - dx. "0@0"
	x1 _ x.
	owner nodesDo: [:each|
		x2 _ each x + each dx.
		self == each
			ifFalse:
				[x1 = x2
					ifTrue: [dx` _ dx` + self perturbation]
					ifFalse:
						[| diff |
						diff _ x1 - x2.
						dx` _ dx` + (diff / diff norm2)]]].
	dx` isZero ifFalse: [dx _ dx + (dx` / dx` norm * 2)]! !

!SpringNodeMorph methodsFor: 'event handling testing' stamp: 'len 2/18/2016 06:02'!
wantsToBeDroppedInto: aMorph
	^ aMorph isKindOf: SpringGraphMorph! !

!Diagram methodsFor: 'accessing' stamp: 'len 6/13/2016 03:38'!
arrows
	^ self subclassResponsibility! !

!Diagram methodsFor: 'converting' stamp: 'len 6/13/2016 03:40'!
asGraph
	| answer |
	answer _ Digraph unorderedLabeled.
	self arrows do: [:each|
		answer addEdgeFrom: each domain to: each codomain label: each].
	^ answer! !

!Diagram methodsFor: 'accessing' stamp: 'len 6/13/2016 03:39'!
objects
	| objects |
	objects _ Set new.
	self arrows do: [:each|
		objects add: each domain; add: each codomain].
	^ objects! !

!Diagram methodsFor: 'printing' stamp: 'len 4/27/2016 02:35'!
printOn: aStream
	self arrows do: [:each| each arrowPrintOn: aStream] separatedBy: [aStream nextPutAll: ', ']! !

!SubgroupSeries methodsFor: 'accessing' stamp: 'len 5/1/98 17:35'!
add: aSubgroup
	^ self subgroups add: aSubgroup! !

!SubgroupSeries methodsFor: 'accessing' stamp: 'len 5/1/98 17:34'!
at: anInteger
	^ self subgroups at: anInteger! !

!SubgroupSeries methodsFor: 'enumerating' stamp: 'len 5/1/98 17:35'!
do: aBlock
	self subgroups do: aBlock! !

!SubgroupSeries methodsFor: 'initialization' stamp: 'len 5/1/98 17:32'!
initialize
	self subgroups: OrderedCollection new! !

!SubgroupSeries methodsFor: 'testing' stamp: 'len 5/1/98 17:52'!
isAbelian
	"Answer true if the receiver is an abelian tower of subgroups."
	self isNormal ifFalse: [^ false].
	2 to: self size do: [ :each | ((self at: each - 1) / (self at: each)) isAbelian ifFalse: [^ false]].
	^ true! !

!SubgroupSeries methodsFor: 'testing' stamp: 'len 5/3/98 01:07'!
isCyclic
	"Answer true if the receiver is a cyclic tower of subgroups."
	self isNormal ifFalse: [^ false].
	2 to: self size do: [ :each | ((self at: each - 1) / (self at: each)) isCyclic ifFalse: [^ false]].
	^ true! !

!SubgroupSeries methodsFor: 'testing' stamp: 'len 5/1/98 17:47'!
isNormal
	"Answer true if the receiver is a normal tower of subgroups."
	2 to: self size do: [ :each | ((self at: each) isNormalIn: (self at: each - 1)) ifFalse: [^ false]].
	^ true! !

!SubgroupSeries methodsFor: 'accessing' stamp: 'len 2/8/2016 03:55'!
objects
	^ subgroups! !

!SubgroupSeries methodsFor: 'accessing' stamp: 'len 5/4/2016 06:25'!
size
	^ subgroups size! !

!SubgroupSeries methodsFor: 'accessing' stamp: 'len 5/1/98 17:33'!
subgroups
	^ subgroups! !

!SubgroupSeries methodsFor: 'accessing-private' stamp: 'len 5/1/98 17:33'!
subgroups: aCollection
	subgroups _ aCollection! !

!SubgroupSeries class methodsFor: 'instance creation' stamp: 'len 11/6/2015 22:36'!
new
	^ super new initialize! !

!ChainComplex methodsFor: 'as yet unclassified' stamp: 'len 6/13/2016 03:47'!
arrows
	^ arrows! !

!ChainComplex methodsFor: 'as yet unclassified' stamp: 'len 6/13/2016 04:34'!
homology: i
	^ (self arrows at: i) kernel / (self arrows at: i+1) image! !

!ChainComplex methodsFor: 'as yet unclassified' stamp: 'len 6/22/2016 03:25'!
isExact
	"A chain complex is 'exact' if the image of each arrow is exactly the kernel of the next arrow."
	^ (1 to: self arrows size - 1) allSatisfy: [:i| (self arrows at: i) image = (self arrows at: i+1) kernel]! !

!ChainComplex methodsFor: 'as yet unclassified' stamp: 'len 6/13/2016 04:37'!
printOn: aStream
	aStream print: self arrows first domain.
	self arrows allButFirstDo: [:each| aStream nextPutAll: '  '; print: each codomain].! !

!Domain methodsFor: 'operations' stamp: 'len 4/18/2016 23:30'!
* aDomain
	"This is a convenience method for doing categorical products. Subclasses can reimplement it to mean something different from the categorical product in order to match customary notation."
	^ self product: aDomain! !

!Domain methodsFor: 'operations' stamp: 'len 11/10/2015 22:47'!
** anInteger
	| components |
	components _ Array new: anInteger.
	components atAllPut: self.
	^ CartesianProduct components: components! !

!Domain methodsFor: 'operations' stamp: 'len 4/18/2016 23:30'!
+ aDomain
	"This is a convenience method for doing coproducts. Subclasses can reimplement it to mean something different from the coproduct in order to match customary notation."
	^ self coproduct: aDomain! !

!Domain methodsFor: 'operations' stamp: 'len 4/21/2016 05:08'!
, aDomain
	"Answer the cartesian set product of the receiver with the argument."
	^ self cartesian: aDomain! !

!Domain methodsFor: 'morphisms' stamp: 'len 9/2/2016 05:38'!
-> aDomain
	"Answer the morphisms that go from the receiver A to the argument B: Hom(A,B)."
	^ Morphisms from: self to: aDomain! !

!Domain methodsFor: 'operations' stamp: 'len 4/27/2016 02:49'!
/ anEquivalenceRelation
	| relation |
	relation _ anEquivalenceRelation isBlock ifTrue: [EquivalenceRelation on: self evaluating: anEquivalenceRelation] ifFalse: [anEquivalenceRelation].
	^ QuotientSet by: relation! !

!Domain methodsFor: 'comparing' stamp: 'len 8/12/2016 21:51'!
< aDomain
	"Answer true if the receiver is a proper subobject of aDomain (strict inclusion)."
	aDomain isFinite ifTrue: [^ self size < aDomain size and: [self elements allSatisfy: [:each| aDomain includes: each]]].
	self isFinite ifTrue: [self do: [:each| (aDomain includes: each) ifFalse: [^ false]]. ^ true].
	^ aDomain > self! !

!Domain methodsFor: 'comparing' stamp: 'len 8/12/2016 21:49'!
<= aDomain
	"Answer true if the receiver is a subobject of aDomain (inclusion)."
	^ self = aDomain or: [self < aDomain]! !

!Domain methodsFor: 'comparing' stamp: 'len 10/9/2016 08:55'!
= aDomain
	self == aDomain ifTrue: [^ true].
	self size = aDomain size ifFalse: [^ false].
	self isFinite ifTrue: [^ self asSet = aDomain asSet].
	^ super = aDomain! !

!Domain methodsFor: 'comparing' stamp: 'len 8/12/2016 21:49'!
> aDomain
	"Answer true if aDomain is a proper subobject of the receiver (strict inclusion)."
	^ aDomain < self! !

!Domain methodsFor: 'comparing' stamp: 'len 8/12/2016 21:50'!
>= aDomain
	"Answer true if aDomain is a subobject of the receiver (inclusion)."
	^ aDomain <= self! !

!Domain methodsFor: 'comparing' stamp: 'len 7/16/2016 05:22'!
~ aDomain
	"Answer true if the receiver is isomorphic to the argument."
	^ self = aDomain "not much more we can test at this abstract level, subclasses should reimplement"! !

!Domain methodsFor: 'operations' stamp: 'len 8/29/2016 16:36'!
 aDomain
	"This is a convenience method for doing categorical products. Subclasses can reimplement it to mean something different from the categorical product in order to match customary notation."
	^ self product: aDomain! !

!Domain methodsFor: 'operations' stamp: 'len 8/29/2016 16:33'!
 aDomain
	"This is a convenience method for doing categorical products. Subclasses can reimplement it to mean something different from the categorical product in order to match customary notation."
	^ self product: aDomain! !

!Domain methodsFor: 'operations' stamp: 'len 6/24/2016 05:31'!
 aDomain
	"This is a convenience method for doing coproducts. Subclasses can reimplement it to mean something different from the coproduct in order to match customary notation."
	^ self coproduct: aDomain! !

!Domain methodsFor: 'operations' stamp: 'len 9/1/2016 07:53'!
 aCollection
	"Answer the intersection of the receiver and the argument."
	^ self select: [:each| aCollection includes: each]! !

!Domain methodsFor: 'iterating' stamp: 'len 5/1/2016 23:22'!
allSatisfy: aBlock
	self do: [:each| (aBlock value: each) ifFalse: [^ false]].
	^ true! !

!Domain methodsFor: 'accessing' stamp: 'len 8/17/2016 17:57'!
ambient
	"Domains can be subobjects of other domains, for example subspeces are subobjects of vector spaces.
	Answer the ambient domain of which the receiver is a subobject."
	^ properties at: #ambient ifAbsent: [self]! !

!Domain methodsFor: 'iterating' stamp: 'len 5/1/2016 23:21'!
anySatisfy: aBlock
	self do: [:each| (aBlock value: each) ifTrue: [^ true]].
	^ false! !

!Domain methodsFor: 'morphisms' stamp: 'len 6/24/2016 05:34'!
apply: aMorphism
	^ self collect: aMorphism! !

!Domain methodsFor: 'converting' stamp: 'len 7/25/2016 22:14'!
asArray
	properties at: #elements ifPresent: [:aCollectionOrDomain| ^ aCollectionOrDomain asArray].
	^ (Iterator on: self performing: #do:) asArray! !

!Domain methodsFor: 'converting' stamp: 'len 4/25/2016 20:58'!
asSet
	properties at: #elements ifPresent: [:aCollectionOrDomain| ^ aCollectionOrDomain asSet].
	^ (Iterator on: self performing: #do:) asSet! !

!Domain methodsFor: 'random' stamp: 'len 6/28/2016 08:38'!
atRandom
	"Answer an element in the receiver choosen at random. This will fail if the receiver is not finite."
	^ Random withDefaultDo: [:aRandom| self atRandom: aRandom]! !

!Domain methodsFor: 'random' stamp: 'len 6/10/2016 23:26'!
atRandom: aRandom
	"Answer an element in the receiver choosen at random. This will fail if the receiver is not finite."
	properties at: #elements ifPresent: [:aCollection| aCollection atRandom: aRandom].
	^ self atRandom: aRandom bits: Infinity positive! !

!Domain methodsFor: 'random' stamp: 'len 6/10/2016 23:20'!
atRandom: aRandom bits: bitSize
	"Answer an element of the receiver of at most n bits (as measured by #bitSize). The total number of elements that could be returned shouldn't exceed 2^n."
	properties at: #elements ifPresent: [:aCollection| ^ (aCollection is: #Domain) ifTrue: [aCollection atRandom: aRandom bits: bitSize] ifFalse: [aCollection atRandom: aRandom]].
	^ self subclassResponsibility! !

!Domain methodsFor: 'random' stamp: 'len 7/5/2016 02:29'!
atRandomBits: bitSize
	"Answer an element of the receiver of at most n bits (as measured by #bitSize). The total number of elements that could be returned shouldn't exceed 2^n."
	^ Random withDefaultDo: [:aRandom| self atRandom: aRandom bits: bitSize]! !

!Domain methodsFor: 'operations' stamp: 'len 4/21/2016 05:08'!
cartesian: aDomain
	"Answer the cartesian set product of the receiver with the argument."
	^ (CartesianProduct components: {self}), aDomain! !

!Domain methodsFor: 'iterating' stamp: 'len 8/31/2016 03:33'!
collect: aBlock
	| elements |
	elements _ Set new.
	self do: [:each| elements add: (aBlock value: each)].
	^ elements as: FormalSet! !

!Domain methodsFor: 'operations' stamp: 'len 4/18/2016 23:31'!
coproduct: aDomain
	"Answer the categorical sum (or coproduct) of the receiver with the argument."
	^ self subclassResponsibility! !

!Domain methodsFor: 'copying' stamp: 'len 5/1/2016 23:35'!
copyEmpty
	^ self species new! !

!Domain methodsFor: 'iterating' stamp: 'len 7/29/2016 06:45'!
detect: aBlock
	"Evaluate aBlock with each of the receiver's elements as the argument. 
	Answer the first element for which aBlock evaluates to true."

	^ self detect: aBlock ifNone: [self error: 'Element is not in the domain']! !

!Domain methodsFor: 'iterating' stamp: 'len 9/3/2016 07:19'!
detect: aBlock ifNone: exceptionBlock
	"Evaluate aBlock with each of the receiver's elements as the argument. 
	Answer the first element for which aBlock evaluates to true. If none 
	evaluate to true, then evaluate the argument, exceptionBlock."

	self do: [:each | (aBlock value: each) ifTrue: [^each]].
	^ exceptionBlock value! !

!Domain methodsFor: 'iterating' stamp: 'len 7/29/2016 06:44'!
do: aBlock
	(properties at: #elements ifAbsent: [self subclassResponsibility]) do: aBlock! !

!Domain methodsFor: 'iterating' stamp: 'len 4/25/2016 09:44'!
do: elementBlock separatedBy: separatorBlock
	| beforeFirst | 
	"Evaluate the elementBlock for all elements in the receiver,
	and evaluate the separatorBlock between."

	beforeFirst _ true.
	self do: [ :element |
		beforeFirst
			ifTrue: [beforeFirst _ false]
			ifFalse: [separatorBlock value].
		elementBlock value: element]! !

!Domain methodsFor: 'accessing' stamp: 'len 4/25/2016 20:50'!
elements
	properties at: #elements ifPresent: [:aCollectionOrDomain| ^ aCollectionOrDomain].
	^ Iterator on: self performing: #do:! !

!Domain methodsFor: 'accessing-private' stamp: 'len 4/22/2016 17:18'!
elements: aCollection
	properties at: #elements put: aCollection! !

!Domain methodsFor: 'morphisms' stamp: 'len 1/5/2016 04:02'!
endomorphisms
	^ self -> self! !

!Domain methodsFor: 'accessing' stamp: 'len 10/6/2016 10:26'!
generator
	self generators size = 1 ifFalse: [self error: 'more than one generator'].
	^ self generators anyOne! !

!Domain methodsFor: 'accessing' stamp: 'len 7/2/2016 16:48'!
generators
	"Subclases can use this or reimplement it when it makes sense."
	^ properties at: #generators ifAbsent: []! !

!Domain methodsFor: 'accessing' stamp: 'len 7/2/2016 16:49'!
generators: aCollection
	"Subclases can use this or reimplement it when it makes sense."
	properties at: #generators put: aCollection asArray! !

!Domain methodsFor: 'comparing' stamp: 'len 4/23/2016 00:41'!
hash
	^ self isFinite ifTrue: [self size hash] ifFalse: [super hash]! !

!Domain methodsFor: 'morphisms' stamp: 'len 8/31/2016 03:42'!
id
	"Answer the identity morphism."
	^ Identity on: self! !

!Domain methodsFor: 'testing' stamp: 'len 6/23/2016 07:04'!
includes: anElement
	^ self elements includes: anElement! !

!Domain methodsFor: 'testing' stamp: 'len 6/24/2016 05:59'!
includesAllOf: aCollection 
	"Answer whether all the elements of aCollection are in the receiver."
	aCollection do: [:each| (self includes: each) ifFalse: [^ false]].
	^ true! !

!Domain methodsFor: 'initialization' stamp: 'len 11/23/2015 03:03'!
initialize
	properties _ IdentityDictionary new! !

!Domain methodsFor: 'testing' stamp: 'len 4/23/2016 00:24'!
is: aSymbol
	^ aSymbol == #Set or: [aSymbol == #Domain or: [super is: aSymbol]]! !

!Domain methodsFor: 'testing-domains' stamp: 'len 4/27/2016 02:55'!
isAbelianGroup
	^ self isModule! !

!Domain methodsFor: 'testing' stamp: 'len 8/27/2016 21:42'!
isAmbient
	^ self ambient = self! !

!Domain methodsFor: 'testing-domains' stamp: 'len 4/27/2016 02:54'!
isCommutativeRing
	^ self isRing and: [self isCommutative]! !

!Domain methodsFor: 'testing-domains' stamp: 'len 2/11/2016 22:18'!
isComplex
	^ false! !

!Domain methodsFor: 'testing' stamp: 'len 8/10/2016 01:05'!
isCoproduct
	"Answer true if the receiver is some kind of categorical coproduct, such as direct sum of vector spaces or of other abelian groups."
	^ false! !

!Domain methodsFor: 'testing' stamp: 'len 8/6/2016 03:48'!
isCountable
	^ self isFinite or: [self size isCountable]! !

!Domain methodsFor: 'testing-domains' stamp: 'len 2/5/2016 20:22'!
isField
	^ false! !

!Domain methodsFor: 'testing' stamp: 'len 5/12/2016 10:08'!
isFinite
	^ properties at: #isFinite ifAbsent: [self size isInfinite not]! !

!Domain methodsFor: 'testing-domains' stamp: 'len 3/9/2016 04:35'!
isFractionField
	^ false! !

!Domain methodsFor: 'testing-domains' stamp: 'len 2/5/2016 20:23'!
isFreeModule
	^ self isVectorSpace! !

!Domain methodsFor: 'testing-domains' stamp: 'len 2/5/2016 20:23'!
isGroup
	^ self isRing! !

!Domain methodsFor: 'testing' stamp: 'len 6/17/2016 22:20'!
isInfinite
	^ self isFinite not! !

!Domain methodsFor: 'testing' stamp: 'len 4/22/2016 14:02'!
isInitial
	^ properties at: #isInitial ifAbsent: [self size = 0]! !

!Domain methodsFor: 'testing-domains' stamp: 'len 2/5/2016 20:23'!
isModule
	^ self isVectorSpace! !

!Domain methodsFor: 'testing-domains' stamp: 'len 2/14/2016 18:08'!
isMonoid
	^ self isGroup! !

!Domain methodsFor: 'testing' stamp: 'len 8/10/2016 01:04'!
isProduct
	"Answer true if the receiver is some kind of categorical product, such as cartesian product of sets, direct product of groups, etc."
	^ false! !

!Domain methodsFor: 'testing' stamp: 'len 10/7/2016 09:52'!
isQuotient
	"Answer true if the receiver is some kind of quotient object, such as a quotient of sets, gropus, vector spaces, etc."
	^ false! !

!Domain methodsFor: 'testing-domains' stamp: 'len 2/11/2016 22:18'!
isReal
	^ false! !

!Domain methodsFor: 'testing-domains' stamp: 'len 2/5/2016 20:23'!
isRing
	^ self isField! !

!Domain methodsFor: 'testing-domains' stamp: 'len 2/14/2016 18:08'!
isSemigroup
	^ self isMonoid! !

!Domain methodsFor: 'testing' stamp: 'len 4/22/2016 14:05'!
isTerminal
	^ properties at: #isTerminal ifAbsent: [self size = 1]! !

!Domain methodsFor: 'testing-domains' stamp: 'len 2/5/2016 20:24'!
isVectorSpace
	^ false! !

!Domain methodsFor: 'accessing' stamp: 'len 4/20/2016 23:58'!
name
	^ properties at: #name ifAbsent: [self printString]! !

!Domain methodsFor: 'accessing' stamp: 'len 11/23/2015 03:04'!
name: aString
	properties at: #name put: aString! !

!Domain methodsFor: 'accessing' stamp: 'len 6/13/2016 00:48'!
null
	"Answer the null or zero object in the category of the receiver, i.e. an object that is both intial and terminal. For example {id} in the case of groups (the trivial group)."
	^ properties at: #null! !

!Domain methodsFor: 'copying' stamp: 'len 3/19/2016 22:41'!
postCopy
	super postCopy.
	properties _ properties copy! !

!Domain methodsFor: 'printing' stamp: 'len 6/6/2016 08:47'!
printOn: aStream
	"Subclasses should reimplement defaultPrintOn: instead of this method."
	properties at: #name ifPresent: [:aString| aStream nextPutAll: aString bold. ^ self].
	properties at: #elements ifPresent: [:aCollection|
		(aCollection is: #Domain) ifTrue: [aStream print: aCollection. ^ self].
		aStream nextPut: ${. "Wildberger notation for unordered sets: elements separated by spaces"
		aCollection asSet do: [:each| aStream print: each] separatedBy: [aStream nextPutAll: ' '].
		aStream nextPut: $}.
		^ self].
	^ super printOn: aStream! !

!Domain methodsFor: 'operations' stamp: 'len 4/23/2016 00:58'!
product: aDomain
	"Answer the categorical product of the receiver with the argument. The most general case (at least within concrete categories) is the cartesian product of sets."
	^ self cartesian: aDomain! !

!Domain methodsFor: 'accessing' stamp: 'len 11/23/2015 02:47'!
properties
	^ properties! !

!Domain methodsFor: 'accessing' stamp: 'len 6/20/2016 02:44'!
propertyAt: aSymbol
	^ self propertyAt: aSymbol ifAbsent: [self error: 'no such property']! !

!Domain methodsFor: 'accessing' stamp: 'len 6/20/2016 02:43'!
propertyAt: aSymbol ifAbsent: exceptionBlock
	^ properties at: aSymbol ifAbsent: exceptionBlock! !

!Domain methodsFor: 'accessing' stamp: 'len 6/20/2016 02:45'!
propertyAt: aSymbol ifAbsentPut: aBlock
	^ properties at: aSymbol ifAbsentPut: aBlock! !

!Domain methodsFor: 'accessing' stamp: 'len 6/20/2016 02:44'!
propertyAt: aSymbol put: anObject
	^ properties at: aSymbol put: anObject! !

!Domain methodsFor: 'iterating' stamp: 'len 8/31/2016 03:34'!
select: aBlock
	| elements |
	elements _ Set new.
	self do: [:each| (aBlock value: each) ifTrue: [elements add: each]].
	^ elements as: FormalSet! !

!Domain methodsFor: 'accessing' stamp: 'len 4/25/2016 09:46'!
size
	^ properties at: #size ifAbsentPut: [self asSet size]! !

!Domain methodsFor: 'private' stamp: 'len 10/3/2016 09:38'!
species
	"Answer a class appropiate for the subobjects of the receiver."
	^ self class! !

!Domain methodsFor: 'morphisms' stamp: 'len 8/31/2016 05:41'!
to: aDomain evaluating: aBlock
	"Answer a morphism to the specified codomain (in the same category), evaluating as the given block."
	^ Function from: self to: aDomain evaluating: aBlock! !

!Domain methodsFor: 'iterating' stamp: 'len 8/1/2016 03:53'!
upTo: maximumNumberOfElements
	| answer |
	answer _ OrderedCollection new.
	self do: [:each|
		answer size >= maximumNumberOfElements ifTrue: [^ answer].
		answer add: each].
	^ answer! !

!Domain methodsFor: 'iterating' stamp: 'len 7/25/2016 23:46'!
upTo: max do: aBlock
	"Iterate over the elements of the receiver, just like #do:, but stop after max elements."
	| k |
	k _ 1.
	self do: [:each|
		k > max ifTrue: [^ self].
		aBlock value: each.
		k _ k+1]! !

!Domain class methodsFor: 'instance creation' stamp: 'len 11/23/2015 05:05'!
new
	^ super new initialize! !

!Domain class methodsFor: 'instance creation' stamp: 'len 4/23/2016 03:40'!
newFrom: anObject
	^ self new elements: anObject! !

!AbelianGroup methodsFor: 'operations' stamp: 'len 10/9/2016 20:58'!
 anAbelianGroup
	^ DirectSum components: {self. anAbelianGroup}! !

!AbelianGroup methodsFor: 'accessing' stamp: 'len 10/9/2016 09:09'!
addition
	^ ((self, self) to: self evaluating: [:each| each first + each second]) name: '+'! !

!AbelianGroup methodsFor: 'accessing' stamp: 'len 10/9/2016 09:00'!
additionInverseMap
	^ (self to: self evaluating: [:x| x negated]) name: '-id'! !

!AbelianGroup methodsFor: 'converting' stamp: 'len 7/9/2016 00:10'!
asGroup
	self generators ifNotNil: [:aCollection| ^ Group additive generators: aCollection].
	^ Group additive elements: self! !

!AbelianGroup methodsFor: 'operations' stamp: 'len 10/9/2016 21:01'!
coproduct: anAbelianGroup
	"Answer the categorical product, i.e. direct sum of the receiver and the argument."
	^ anAbelianGroup isAbelianGroup
		ifTrue: [self  anAbelianGroup]
		ifFalse: [super product: anAbelianGroup]! !

!AbelianGroup methodsFor: 'testing' stamp: 'len 12/9/2015 02:26'!
isAbelian
	^ true! !

!AbelianGroup methodsFor: 'testing' stamp: 'len 11/8/2015 01:32'!
isAbelianGroup
	^ true! !

!AbelianGroup methodsFor: 'testing' stamp: 'len 11/28/2015 09:09'!
isInitial
	^ self isTrivial! !

!AbelianGroup methodsFor: 'testing' stamp: 'len 4/22/2016 14:03'!
isTerminal
	^ self isTrivial! !

!AbelianGroup methodsFor: 'testing' stamp: 'len 2/28/2016 07:25'!
isTorsionFree
	^ self torsion isTrivial! !

!AbelianGroup methodsFor: 'testing' stamp: 'len 11/28/2015 09:10'!
isTrivial
	^ self size = 1! !

!AbelianGroup methodsFor: 'operations' stamp: 'len 10/9/2016 21:01'!
product: anAbelianGroup
	"Answer the categorical product, i.e. direct sum of the receiver and the argument."
	^ anAbelianGroup isAbelianGroup
		ifTrue: [self  anAbelianGroup]
		ifFalse: [super product: anAbelianGroup]! !

!AbelianGroup methodsFor: 'morphisms' stamp: 'len 10/10/2016 08:49'!
to: anAbelianGroup evaluating: aBlock
	^ AbelianGroupHomomorphism from: self to: anAbelianGroup evaluating: aBlock! !

!AbelianGroup methodsFor: 'accessing' stamp: 'len 7/15/2016 04:16'!
torsion
	"Answer the torsion subgroup of the receiver, i.e. the set of elements e such that exists non-zero integer m with e*m = 0."
	^ properties at: #torsion! !

!AbelianGroup methodsFor: 'accessing' stamp: 'len 11/23/2015 07:24'!
zero
	^ properties at: #zero! !

!DirectSum methodsFor: 'accessing' stamp: 'len 10/9/2016 10:41'!
arity
	^ components size! !

!DirectSum methodsFor: 'converting' stamp: 'len 10/9/2016 10:43'!
asCartesianProduct
	^ CartesianProduct components: components! !

!DirectSum methodsFor: 'accessing' stamp: 'len 10/9/2016 10:41'!
at: anInteger
	^ components at: anInteger! !

!DirectSum methodsFor: 'random' stamp: 'len 10/10/2016 09:35'!
atRandom: aRandom
	^ components collect: [:each| each atRandom: aRandom]! !

!DirectSum methodsFor: 'random' stamp: 'len 10/10/2016 09:35'!
atRandom: aRandom bits: bitSize
	| n |
	n _ bitSize / self arity.
	^ components collect: [:each| each atRandom: aRandom bits: n]! !

!DirectSum methodsFor: 'accessing-private' stamp: 'len 10/9/2016 10:43'!
components
	^ components! !

!DirectSum methodsFor: 'accessing-private' stamp: 'len 10/9/2016 10:43'!
components: anArray
	components _ anArray as: Tuple! !

!DirectSum methodsFor: 'morphisms' stamp: 'len 10/10/2016 08:39'!
embedding: i
	^ ((self at: i) to: self evaluating: [:x| components withIndexCollect: [:each :k| k = i ifTrue: [x] ifFalse: [each zero]]]) name: 'i', i printText sub! !

!DirectSum methodsFor: 'testing' stamp: 'len 10/9/2016 10:45'!
includes: anObject
	anObject size = components size ifFalse: [^ false].
	components with: anObject do: [:V :x| (V includes: x) ifFalse: [^ false]].
	^ true! !

!DirectSum methodsFor: 'testing' stamp: 'len 10/9/2016 10:45'!
isCoproduct
	^ true! !

!DirectSum methodsFor: 'printing' stamp: 'len 10/10/2016 08:44'!
printOn: aStream
	components do: [:each| aStream print: each] separatedBy: [aStream nextPut: Character oplus]! !

!DirectSum methodsFor: 'morphisms' stamp: 'len 10/10/2016 08:38'!
projection: i
	^ (self to: (self at: i) evaluating: [:x| x at: i]) name: Character pi asText, i printText sub! !

!DirectSum methodsFor: 'accessing' stamp: 'len 10/9/2016 10:42'!
size
	^ components product: [:each| each size]! !

!DirectSum methodsFor: 'accessing' stamp: 'len 10/10/2016 09:33'!
zero
	^ components collect: [:each| each zero]! !

!DirectSum class methodsFor: 'instance creation' stamp: 'len 10/10/2016 08:40'!
components: anArray
	^ self new components: anArray! !

!Ideal methodsFor: 'operations' stamp: 'len 9/26/2016 16:54'!
* anElementOrIdeal
	"The product is included in the intersection: I*J <= I /\ J.
	When the ideals are comaximal, the equality holds."
	| newGenerators |
	(ring includes: anElementOrIdeal) ifTrue: [^ self class on: ring generators: generators * anElementOrIdeal].
	anElementOrIdeal ring = ring ifFalse: [^ DomainError signal: 'ideal from different rings'].
	newGenerators _ Set new.
	generators do: [:a| anElementOrIdeal generators do: [:b| newGenerators add: a*b]].
	^ self class on: ring generators: newGenerators! !

!Ideal methodsFor: 'operations' stamp: 'len 9/26/2016 16:52'!
+ anIdeal 
	anIdeal ring = ring ifFalse: [^ DomainError signal: 'ideals from different rings'].
	^ self class on: ring generators: (generators asSet copy addAll: anIdeal generators; yourself)! !

!Ideal methodsFor: 'operations' stamp: 'len 9/1/2016 07:54'!
/\ anIdeal
	"Meet."
	^ self  anIdeal! !

!Ideal methodsFor: 'comparing' stamp: 'len 12/14/2015 18:55'!
< anIdeal
	"Answer true if the receiver is strictly included in the argument."
	^ self ~= anIdeal and: [self <= anIdeal]! !

!Ideal methodsFor: 'comparing' stamp: 'len 8/24/2016 22:01'!
<= anIdeal
	"Answer true if the receiver is included in the argument."
	self == anIdeal ifTrue: [^ true].
	generators do: [:each | (anIdeal includes: each) ifFalse: [^ false]].
	^ true! !

!Ideal methodsFor: 'comparing' stamp: 'len 11/28/2015 06:07'!
= anIdeal
	self == anIdeal ifTrue: [^ true].
	(anIdeal isKindOf: Ideal) ifFalse: [^ false].
	^ self <= anIdeal and: [anIdeal <= self]! !

!Ideal methodsFor: 'operations' stamp: 'len 6/5/2016 22:46'!
\/ anIdeal
	"Join."
	^ self + anIdeal! !

!Ideal methodsFor: 'operations' stamp: 'len 9/26/2016 16:55'!
 anIdeal
	^ ring * (self generator lcm: anIdeal generator)! !

!Ideal methodsFor: 'operations' stamp: 'len 9/26/2016 16:54'!
annihilator
	^ (ring * ring zero) colon: self! !

!Ideal methodsFor: 'morphisms' stamp: 'len 10/5/2016 10:29'!
apply: aMorphism
	"Apply a ring homomorphism phi to the receiver, sending each generator g to phi(g)."
	aMorphism isBlock
		ifTrue: [^ ring * (generators collect: aMorphism)].
	aMorphism domain = ring
		ifTrue: [^ aMorphism codomain * (generators collect: aMorphism)].
	^ DomainError signal! !

!Ideal methodsFor: 'operations' stamp: 'len 12/21/2015 02:56'!
colon: anIdeal
	"Answer the colon quotient I:J of the receiver I with the argument J."
	^ self subclassResponsibility! !

!Ideal methodsFor: 'copying' stamp: 'len 9/26/2016 16:52'!
copy
	"Answer a copy of the receiver."
	^ self class on: ring generators: self generators copy! !

!Ideal methodsFor: 'iterating' stamp: 'len 9/26/2016 16:52'!
do: aBlock
	ring isCommutative
		ifTrue:
			[ring do: [:each| generators do: [:g| aBlock value: each * g]]]
		ifFalse:
			[ring do: [:each| generators do: [:g| aBlock value: each * g; value: g * each]]]! !

!Ideal methodsFor: 'accessing' stamp: 'len 9/26/2016 16:56'!
generator
	| generator |
	generators size = 1 ifTrue: [^ generators anyOne].
	generators size = 0 ifTrue: [^ ring zero].
	ring isPID ifFalse: [^ self error: 'not a principal ideal domain'].
	generators do: [:each| generator _ generator isNil ifTrue: [each] ifFalse: [generator gcd: each]].
	generators _ {generator}! !

!Ideal methodsFor: 'accessing' stamp: 'pdm 3/22/98 17:24'!
generators
	"Answer a generators set of the receiver."
	^ generators! !

!Ideal methodsFor: 'accessing-private' stamp: 'pdm 3/22/98 17:19'!
generators: aCollection 
	generators _ aCollection! !

!Ideal methodsFor: 'comparing' stamp: 'len 9/26/2016 16:55'!
hash
	^ ring hash + self class hash! !

!Ideal methodsFor: 'testing' stamp: 'len 9/26/2016 16:57'!
includes: anObject
	(self ring includes: anObject) ifFalse: [^ false].
	self isZero ifTrue: [^ anObject isZero].
	^ (self reduce: anObject) isZero! !

!Ideal methodsFor: 'operations-elements' stamp: 'len 9/26/2016 16:54'!
inverseOf: anObject
	| euclid |
	ring isEuclidean ifFalse: [^ nil].
	euclid _ ExtendedEuclid on: {anObject. self generator}.
	euclid gcd = ring one ifFalse: [^ nil].
	^ euclid combination first! !

!Ideal methodsFor: 'testing' stamp: 'len 1/4/2016 03:29'!
isMaximal
	^ properties at: #isMaximal! !

!Ideal methodsFor: 'testing' stamp: 'len 9/26/2016 16:57'!
isOne
	"Answer true if the receiver is the unit ideal <1> that equals the whole ambient ring."
	^ self includes: self ring one! !

!Ideal methodsFor: 'testing' stamp: 'len 12/7/2015 00:19'!
isPrime
	^ properties at: #isPrime! !

!Ideal methodsFor: 'testing' stamp: 'len 9/26/2016 16:54'!
isPrincipal
	generators size = 1 ifTrue: [^ true].
	ring isPID ifTrue: [^ true].
	^ properties at: #isPrincipal! !

!Ideal methodsFor: 'testing' stamp: 'len 9/26/2016 16:58'!
isProper
	^ self ~= self ring! !

!Ideal methodsFor: 'testing' stamp: 'len 8/30/2016 06:58'!
isZero
	"Answer true if the receiver is the zero ideal {0}."
	generators do: [:each | each isZero ifFalse: [^ false]].
	^ true! !

!Ideal methodsFor: 'printing' stamp: 'len 9/26/2016 16:58'!
printOn: aStream
	self isZero ifTrue: [aStream nextPut: ${; print: self ring zero; nextPut: $}. ^ self].
	aStream nextPut: $<.
	generators do: [:each| aStream print: each] separatedBy: [aStream nextPutAll: ', '].
	aStream nextPut: $>! !

!Ideal methodsFor: 'operations' stamp: 'len 4/25/2016 21:02'!
quotient
	"Answer the quotient ring of the base ring by the receiver."
	^ QuotientRing by: self! !

!Ideal methodsFor: 'operations' stamp: 'len 2/13/2016 02:49'!
radical
	^ self subclassResponsibility! !

!Ideal methodsFor: 'operations-elements' stamp: 'len 10/6/2016 09:35'!
reduce: anElement
	"Answer the normal form of anElement with respect to the receiver. Subclasses should override."
	^ anElement \\ self generator! !

!Ideal methodsFor: 'accessing' stamp: 'len 9/26/2016 16:53'!
ring
	"Answer the ring of this ideal."
	^ ring! !

!Ideal methodsFor: 'accessing-private' stamp: 'len 9/26/2016 16:55'!
ring: aRing
	ring _ aRing! !

!Ideal class methodsFor: 'instance creation' stamp: 'len 9/26/2016 16:55'!
on: aRing generators: aCollection
	^ self new ring: aRing; generators: aCollection! !

!IntegerIdeal methodsFor: 'morphisms' stamp: 'len 9/26/2016 16:55'!
 anIdeal
	^ ring * (self generator lcm: anIdeal generator)! !

!IntegerIdeal methodsFor: 'random' stamp: 'len 4/19/2016 20:05'!
atRandom: aRandom bits: bitSize
	^ ((0-bitSize//2 to: bitSize//2) atRandom: aRandom) * self generator! !

!IntegerIdeal methodsFor: 'operations-elements' stamp: 'len 12/8/2015 01:03'!
inverseOf: anInteger
	^ anInteger reciprocalModulo: self generator! !

!IntegerIdeal methodsFor: 'testing' stamp: 'len 1/4/2016 03:30'!
isMaximal
	^ self isPrime! !

!IntegerIdeal methodsFor: 'testing' stamp: 'len 9/21/2016 17:38'!
isPrime
	^ properties at: #isPrime ifAbsentPut:[self isZero or: [self generator isPrime]]! !

!IntegerIdeal methodsFor: 'morphisms' stamp: 'len 9/26/2016 16:55'!
radical
	^ ring * (self generator factors asSet inject: 1 into: [:x :each| x*each])! !

!IntegerIdeal methodsFor: 'random' stamp: 'len 4/19/2016 22:57'!
remainderAtRandom: aRandom
	^ (self generator abs atRandom: aRandom) - 1! !

!PolynomialIdeal methodsFor: 'comparing' stamp: 'len 4/5/2016 17:38'!
= anObject
	^ super = anObject
"	self == anObject ifTrue: [^ true].
	self species == anObject species ifFalse: [^ false].
	self flag: #fix." "this is wrong, both groebner basis should at least use the same ordering"
"	^ self groebner reduced = anObject groebner reduced"! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 9/26/2016 16:58'!
 anIdeal
	| R R` t T TminusOne G1 G2 G` G |
	R _ self ring.
	R` _ R scalars polynomialsIn: R rank + 1 ordering: #lex.
	t _ R` rank. "index of last indeterminate"
	T _ R` x: t.
	TminusOne _ T - T one.
	G1 _ generators collect: [:f| T*(f as: R`)].
	G2 _ anIdeal generators collect: [:g| TminusOne*(g as: R`)].
	G` _ GroebnerBasis from: G1, G2.
	G _ GroebnerBasis new ordering: (MonomialOrdering lex: R rank).
	G` do: [:each| (each has: t) ifFalse: [G add: (each as: R)]].
	^ self species on: R generators: G! !

!PolynomialIdeal methodsFor: 'random' stamp: 'len 9/26/2016 16:58'!
atRandom: aRandom bits: bitSize
	^ self generators sum: [:each| each * (self ring atRandom: aRandom bits: bitSize / self generators size)]! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 9/26/2016 16:58'!
colon: anIdeal
	"Answer the colon quotient I:J of the receiver I with the argument J."
	"Cox IVA 205p"
	| answer |
	answer _ self ring * self ring one. "<1>"
	anIdeal generators do: [:g|
		answer _ answer  (self ring * ((self ring * g  self) groebnerBasis apply: [:h| h / g]))].
	^ answer! !

!PolynomialIdeal methodsFor: 'accessing' stamp: 'len 7/4/2016 06:33'!
degree
	"Answer the degree of the ideal, i.e. the number of monomials that are not multiple of any leading monomial in the Groebner basis."
	| G count leadingMonomials |
	leadingMonomials _ Set new.
	G _ self groebnerBasis minimal.
	G do: [:each| leadingMonomials add: each leadingMonomial].
	count _ 0.
	G do: [:each|
		each monomialsDo: [:monomial|
			(leadingMonomials anySatisfy: [:lm| lm | monomial])
					ifFalse: [count _ count + 1]]].
	^ count! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 8/2/2016 02:19'!
eliminate: anIndeterminate
	"Answer the elimination ideal computed by eliminating anIndeterminate."
	^ self eliminateAll: {anIndeterminate}
	
"	| G indets |
	G _ self groebnerBasis.
	(G anySatisfy: [:f| indets _ (G ordering headOf: f) indeterminates. indets size = 1 and: [indets includes: anIndeterminate]]) ifFalse: [^ self error: 'there''s no eliminant'].
	self notYetImplemented"

	"algorithm to compute eliminants:
input: ideal I in K[x1..xn] and indet xi
output: univariate eliminant g(xi) or there's no eliminant
1. compute groebner basis G of I in any monomial ordering
2. if no initial term of any element of G is a pure power of xi, then halt, no eliminant
3. compute the sequence 1 mod G, xi mod G, xi^2 mod G, ... until a linear dependence is found
  anxi^n+...+a1xi+a0 mod G = 0
where n is minimal, then output eliminant g(xi) = sum akxi^k
"! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 9/26/2016 16:56'!
eliminateAll: aCollection
	"Answer the elimination ideal for the indeterminates in aCollection = {xi}, i.e. the subideal of polynomials without indeterminates {xi}."
	| indeterminates ordering G |
	indeterminates _ aCollection asArray , (ring ordering indeterminates reject: [:each| aCollection includes: each]).
	ordering _ MonomialOrdering lex: indeterminates.
	G _ GroebnerBasis from: generators ordering: ordering.
	^ self class on: ring generators: (G minimal asArray select: [:each| (aCollection noneSatisfy:[:none| each has: none])])! !

!PolynomialIdeal methodsFor: 'accessing-private' stamp: 'len 7/4/2016 06:33'!
generators: aCollection
	super generators: aCollection.
	(aCollection isKindOf: GroebnerBasis)
		ifTrue: [properties at: #groebnerBasis put: aCollection]! !

!PolynomialIdeal methodsFor: 'accessing' stamp: 'len 7/4/2016 06:32'!
groebnerBasis
	"Answer a Groebner basis of the receiver."
	^ properties at: #groebnerBasis ifAbsentPut: [GroebnerBasis from: self generators]! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 9/26/2016 16:58'!
homogenized
	"Answer the homogenization of the receiver introducing a new indeterminate."
	| R R` ordering G |
	R _ self ring.
	R` _ R scalars polynomialsIn: R rank + 1.
	"Must use a graded monomial ordering such as tlex or trevlex:"
	self flag: #fix.
	ordering _ MonomialOrdering trevlex: R rank. "should it be R`?"
	G _ GroebnerBasis from: generators ordering: ordering.
	^ R` * (G collect: [:each| (each as: R`) homogenizedIn: R` rank])! !

!PolynomialIdeal methodsFor: 'testing' stamp: 'len 7/9/2016 08:19'!
includes: aPolynomial 
	"(Ideal Membership Problem)
	Answer true if the receiver includes aPolynomial.
	This works on any Groebner basis (any monomial ordering)."
	^ (self reduce: aPolynomial) isZero! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 9/26/2016 16:59'!
initial
	"Answer the initial ideal, i.e. the ideal of all leading monomials of the receiver."
	^ MonomialIdeal on: self ring generators: self groebnerBasis initial! !

!PolynomialIdeal methodsFor: 'testing' stamp: 'len 12/15/2015 21:13'!
isHomogeneous
	^ generators allSatisfy: [:each| each isHomogeneous]! !

!PolynomialIdeal methodsFor: 'testing' stamp: 'len 12/15/2015 03:19'!
isRadical
	^ self = self radical! !

!PolynomialIdeal methodsFor: 'testing' stamp: 'len 7/9/2016 05:20'!
isSquareFree
	^ self = self squareFree! !

!PolynomialIdeal methodsFor: 'testing' stamp: 'len 7/6/2016 06:16'!
isTrivial
	"Answer true if the receiver is <1>."
	(self generators anySatisfy: [:g| g isConstant]) ifTrue: [^ true].
	^ self groebnerBasis anySatisfy: [:g| g isConstant]! !

!PolynomialIdeal methodsFor: 'testing' stamp: 'len 9/26/2016 16:59'!
isUnivariate
	^ self ring isUnivariate! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 7/9/2016 05:21'!
radical
	self flag: #fix. "this is not right, maybe only works for Q[x1..xn] and monomial ideals"
	^ self squareFree! !

!PolynomialIdeal methodsFor: 'testing' stamp: 'len 9/26/2016 16:59'!
radicalIncludes: aPolynomial
	"(Radical Membership Problem)
	Answer true if the radical of the receiver includes aPolynomial."
	| R R` t X |
	R _ self ring.
	R` _ R scalars polynomialsIn: R rank + 1.
	t _ R` x: R rank + 1.
	X _ OrderedCollection new.
	self generators do: [:g| X add: (g as: R`)].
	X add: (aPolynomial as: R`) * t - R` one.
	^ (R` * X) isTrivial! !

!PolynomialIdeal methodsFor: 'operations-elements' stamp: 'len 10/6/2016 09:35'!
reduce: aPolynomial
	"Answer the normal form of anElement with respect to the receiver."
	self isUnivariate ifTrue: [^ aPolynomial \\ self generator].
	^ self groebnerBasis reduce: aPolynomial! !

!PolynomialIdeal methodsFor: 'random' stamp: 'len 9/26/2016 16:56'!
remainderAtRandom: aRandom
	self isPrincipal ifFalse: [^ self error: 'not yet implemented'].
	ring isUnivariate ifFalse: [^ self error: 'not yet implemented'].
	^ ring coefficients: ((0 to: self generator degree - 1) collect: [:i| ring scalars atRandom: aRandom])! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 3/15/2016 18:05'!
saturation: anIdeal
	"Answer the saturation I:J^infinity of the receiver I with the argument J."
	"Cox IVA 205p"
	self notYetImplemented! !

!PolynomialIdeal methodsFor: 'operations' stamp: 'len 9/26/2016 16:59'!
squareFree
	^ self class on: self ring generators: (self generators collect: [:each| each squareFree])! !

!PolynomialIdeal methodsFor: 'accessing' stamp: 'len 12/31/2015 22:28'!
variety
	"Answer the algebraic variety that is the set of zeroes of all polynomials in the receiver."
	^ AlgebraicSet ideal: self! !

!PolynomialIdeal class methodsFor: 'examples' stamp: 'len 7/15/2016 18:35'!
cyclic: n
	^ self cyclic: n over: QQ! !

!PolynomialIdeal class methodsFor: 'examples' stamp: 'len 7/6/2016 06:41'!
cyclic: n over: scalars
	| P singles generators |
	P _ scalars polynomialsIn: n.
	singles _ (1 to: n) collect: [:i| P x: i].
	generators _ OrderedCollection new.
	1 to: n-1 do: [:k | | f |
		f _ P zero.
		singles combinations: k atATimeDo: [:each| f _ f + each product].
		generators add: f].
	generators add: singles product - 1.
	^ self on: P generators: generators! !

!PolynomialIdeal class methodsFor: 'examples' stamp: 'len 7/15/2016 18:35'!
katsura2
	| P x y |
	P _ QQ polynomialsIn: #(x y).
	x _ P x.
	y _ P y.
	^ self on: P generators: {x + (y*2) - 1. x**2 + (y**2 * 2) - x}! !

!PolynomialIdeal class methodsFor: 'examples' stamp: 'len 7/15/2016 18:35'!
katsura3
	| P x y z |
	P _ QQ polynomialsIn: #(x y z).
	x _ P x: #x.
	y _ P x: #y.
	z _ P x: #z.
	^ self on: P generators: {x + (y*2) + (z*2) - 1. x**2 + (y**2 * 2) + (z**2 * 2) - x. x*y*2 + (y*z*2) - y}! !

!PolynomialIdeal class methodsFor: 'examples' stamp: 'len 7/15/2016 18:35'!
katsura4
	| P x y z t |
	P _ QQ polynomialsIn: #(x y z t).
	x _ P x: #x.
	y _ P x: #y.
	z _ P x: #z.
	t _ P x: #t.
	^ self on: P generators: {x + (y*2) + (z*2) + (t*2) - 1.
		x**2 + (y**2 * 2) + (z**2 * 2) + (t**2 * 2) - x.
		x*y*2 + (y*z*2) + (z*t*2) - y.
		y**2 + (x*z*2) + (y*t*2) - z}! !

!PolynomialIdeal class methodsFor: 'examples' stamp: 'len 7/15/2016 18:35'!
katsura5
	| P x y z t u |
	P _ QQ polynomialsIn: #(x y z t u).
	x _ P x: #x.
	y _ P x: #y.
	z _ P x: #z.
	t _ P x: #t.
	u _ P x: #u.
	^ self on: P generators: {x + (y*2) + (z*2) + (t*2) + (u*2) - 1.
		x**2 + (y**2 * 2) + (z**2 * 2) + (t**2 * 2) + (u**2 * 2) - x.
		x*y*2 + (y*z*2) + (z*t*2) + (t*u*2) - y.
		y**2 + (x*z*2) + (y*t*2) + (z*u*2) - z.
		y*z*2 + (x*t*2) + (y*u*2) - t}! !

!MonomialIdeal methodsFor: 'operations' stamp: 'len 7/9/2016 05:16'!
radical
	"This works for monomial ideals."
	^ self squareFree! !

!MonomialIdeal methodsFor: 'private' stamp: 'len 7/7/2016 07:39'!
species
	^ PolynomialIdeal! !

!Ring methodsFor: 'operations' stamp: 'len 6/29/2016 03:48'!
% anObject
	^ self mod: anObject! !

!Ring methodsFor: 'operations' stamp: 'len 12/5/2015 23:51'!
* anElementOrArray
	^ (self includes: anElementOrArray)
			ifTrue: [Ideal on: self generators: {anElementOrArray}]
			ifFalse: [Ideal on: self generators: anElementOrArray]! !

!Ring methodsFor: 'operations' stamp: 'len 10/7/2016 08:44'!
** n
"	n isInfinity ifTrue: [^ InfiniteTupleSpace over: self]."
	^ n isPoint ifTrue: [MatrixModule new: n over: self] ifFalse: [TupleModule new: n over: self]! !

!Ring methodsFor: 'operations' stamp: 'len 9/26/2016 16:51'!
/ anIdeal
	self = anIdeal ring ifFalse: [^ DomainError signal: 'the ideal doesn''t belong to the receiver ring'].
	^ QuotientRing by: anIdeal! !

!Ring methodsFor: 'operations' stamp: 'len 10/9/2016 21:11'!
 aRing
	^ DirectProductRing components: {self. aRing}! !

!Ring methodsFor: 'operations' stamp: 'len 6/10/2016 05:38'!
PG: n
	"Answer the projective space of dimension n. When the receiver is the finite field GF(q) this is PG(n,q)."
	^ (self ** (n + 1)) projective! !

!Ring methodsFor: 'converting' stamp: 'len 8/29/2016 16:30'!
asIdeal
	"Answer the receiver R viewed as an ideal of itself."
	^ self * self one! !

!Ring methodsFor: 'converting' stamp: 'len 10/7/2016 08:41'!
asSelfModule
	"Answer the receiver R viewed as R-module."
	^ ScalarModule over: self! !

!Ring methodsFor: 'accessing' stamp: 'len 11/28/2015 03:56'!
characteristic
	^ properties at: #characteristic! !

!Ring methodsFor: 'operations' stamp: 'len 12/14/2015 23:24'!
fractions
	"Answer the fraction field of the receiver, assuming it is an integral domain."
	self isIntegralDomain ifFalse: [DomainError signal: 'not an integer domain'].
	^ FractionField over: self! !

!Ring methodsFor: 'operations' stamp: 'len 1/20/2016 13:42'!
freeAlgebra
	^ FreeAlgebra over: self! !

!Ring methodsFor: 'operations' stamp: 'len 6/30/2016 02:27'!
freeAlgebraIn: aCollection
	"Answer the free algebra in the given indeterminates over the receiver."
	^ FreeAlgebra on: aCollection over: self! !

!Ring methodsFor: 'operations' stamp: 'len 6/30/2016 02:34'!
freeModuleIn: aCollection
	"Answer the free module in the given indeterminates over the receiver."
	^ FreeModule on: aCollection over: self! !

!Ring methodsFor: 'morphisms' stamp: 'len 10/10/2016 14:13'!
frobenius
	"Answer the Frobenius endomorphism, assuming the receiver is of characteristic p prime."
	| p |
	p _ self characteristic.
	^ self to: self evaluating: self polynomials x ** p! !

!Ring methodsFor: 'testing' stamp: 'len 8/17/2016 17:54'!
hasOne
	"Answer true if the receiver is a ring with one, i.e. includes the element 1."
	^ self includes: self one! !

!Ring methodsFor: 'testing' stamp: 'len 11/28/2015 23:53'!
isCommutative
	^ properties at: #isCommutative ifAbsent: [self isIntegralDomain]! !

!Ring methodsFor: 'testing' stamp: 'len 8/31/2016 08:49'!
isCompositive
	^ self multiplication name = '@'! !

!Ring methodsFor: 'testing' stamp: 'len 11/28/2015 23:44'!
isDedekindDomain
	"A Ddedekind domain is an integral domain in which every non-zero proper ideal factors into a product of prime ideals."
	^ properties at: #isDedekindDomain! !

!Ring methodsFor: 'testing' stamp: 'len 5/12/2016 23:33'!
isDivisionRing
	"A division ring, or skewfield, is a ring where division is possible, i.e. every non-zero element has a multiplicative inverse. The only difference with a field is that a division ring is not requiered to be commutative."
	self isField ifTrue: [^ true].
	^ properties at: #isDivisionRing ifAbsent: [false]! !

!Ring methodsFor: 'testing' stamp: 'len 11/28/2015 23:50'!
isEuclidean
	^ properties at: #isEuclidean ifAbsent: [self isField]! !

!Ring methodsFor: 'testing' stamp: 'len 11/23/2015 03:00'!
isField
	^ properties at: #isField ifAbsent: [false]! !

!Ring methodsFor: 'testing' stamp: 'len 11/28/2015 23:25'!
isGCDDomain
	"A GCD domain is an integral domain with the property that any two non-zero elements have GCD (or equivalently any two non-zero elements have a LCM)."
	^ properties at: #isGCDDomain! !

!Ring methodsFor: 'testing' stamp: 'len 11/28/2015 09:10'!
isInitial
	^ self isTrivial! !

!Ring methodsFor: 'testing' stamp: 'len 11/28/2015 23:51'!
isIntegralDomain
	"A ring is an integral domain if the product of any two non-zero elements is non-zero."
	^ properties at: #isIntegralDomain ifAbsent: [self isIntegrallyClosedDomain]! !

!Ring methodsFor: 'testing' stamp: 'len 11/28/2015 23:51'!
isIntegrallyClosedDomain
	"A ring is an integrally closed domain if it is an integral domain whose integral closure in its field of fractions is the ring itself."
	^ properties at: #isIntegrallyClosedDomain ifAbsent: [self isUFD]! !

!Ring methodsFor: 'testing' stamp: 'len 11/28/2015 23:41'!
isNoetherian
	^ properties at: #isNoetherian! !

!Ring methodsFor: 'testing' stamp: 'len 11/28/2015 23:49'!
isPID
	"A principal ideal domain (PID) is an integral domain in which every ideal is principal, i.e. can be generated by a single element."
	^ properties at: #isPID ifAbsent: [self isEuclidean]! !

!Ring methodsFor: 'testing' stamp: 'len 11/7/2015 22:01'!
isRing
	^ true! !

!Ring methodsFor: 'testing' stamp: 'len 11/28/2015 09:10'!
isTrivial
	^ self size = 1! !

!Ring methodsFor: 'testing' stamp: 'len 11/28/2015 23:49'!
isUFD
	"A unique factorization domain (UFD) is a commutative ring in which every non-zero non-unit element can be written as a product of prime elements (or irreducible elements), uniquely up to order and units."
	^ properties at: #isUFD ifAbsent: [self isPID or: [self isEuclidean]]! !

!Ring methodsFor: 'testing' stamp: 'len 5/12/2016 23:11'!
isUnit: anElement
	self isDivisionRing ifTrue: [^ anElement isZero not].
	^ self subclassResponsibility! !

!Ring methodsFor: 'operations' stamp: 'len 11/22/2015 06:26'!
mod: anObject
	^ self / (self * anObject)! !

!Ring methodsFor: 'accessing' stamp: 'len 10/9/2016 09:01'!
multiplication
	^ ((self, self) to: self evaluating: [:each| each first * each second]) name: '*'! !

!Ring methodsFor: 'accessing' stamp: 'len 10/9/2016 09:01'!
multiplicationInverseMap
	^ (self to: self evaluating: [:each| each reciprocal]) name: 'x^-1'! !

!Ring methodsFor: 'accessing' stamp: 'len 11/23/2015 02:55'!
one
	^ properties at: #one! !

!Ring methodsFor: 'accessing-private' stamp: 'len 5/29/2016 17:54'!
one: anElement
	properties at: #one put: anElement! !

!Ring methodsFor: 'operations' stamp: 'len 9/26/2016 17:05'!
oneIdeal
	^ self * self one! !

!Ring methodsFor: 'operations' stamp: 'len 3/26/2016 05:42'!
polynomials
	^ self polynomialsIn: #(x)! !

!Ring methodsFor: 'operations' stamp: 'len 7/8/2016 19:54'!
polynomialsIn: anIntegerOrCollection
	"Answer the ring of multivariate polynomials over the receiver in the given indeterminates."
	^ self polynomialsIn: anIntegerOrCollection ordering: #trevlex! !

!Ring methodsFor: 'operations' stamp: 'len 7/19/2016 01:12'!
polynomialsIn: anIntegerOrCollection ordering: aMonomialOrdering
	"Answer the ring of multivariate polynomials over the receiver over the given indeterminates."
	| answer |
	anIntegerOrCollection isInteger
		ifTrue: [^ PolynomialRing new: anIntegerOrCollection over: self ordering: aMonomialOrdering].
	answer _ PolynomialRing new: anIntegerOrCollection size over: self ordering: aMonomialOrdering.
	answer indeterminateNames: anIntegerOrCollection.
	^ answer! !

!Ring methodsFor: 'operations' stamp: 'len 10/9/2016 21:11'!
product: aRing
	^ self  aRing! !

!Ring methodsFor: 'operations' stamp: 'len 9/26/2016 06:46'!
spec
	"Answer the spectrum of the receiver, Spec(R)."
	self isCommutative ifFalse: [DomainError signal: 'non-commutative ring'].
	^ Spectrum on: self! !

!Ring methodsFor: 'morphisms' stamp: 'len 10/4/2016 08:48'!
to: aRing evaluating: aBlock
	"Answer the ring homomorphism to aRing evaluating as the given block."
	(aRing isKindOf: Ring) ifFalse: [^ super to: aRing evaluating: aBlock].
	^ RingHomomorphism from: self to: aRing evaluating: aBlock! !

!Ring methodsFor: 'tuples' stamp: 'len 4/12/2016 02:51'!
tuple: anArray
	^ self tupleClass withAll: anArray! !

!Ring methodsFor: 'tuples' stamp: 'len 4/22/2016 21:53'!
tuple: anInteger evaluating: aBlock
	^ self tupleClass new: anInteger evaluating: aBlock! !

!Ring methodsFor: 'tuples' stamp: 'len 7/19/2016 02:46'!
tupleClass
	^ Tuple! !

!Ring methodsFor: 'operations' stamp: 'len 6/30/2016 04:03'!
units
	"Answer the multiplicative group of units of the receiver (i.e., elements that have multiplicative inverse)."
	^ UnitsGroup on: self! !

!Ring methodsFor: 'accessing' stamp: 'len 12/18/2015 01:36'!
valuation
	"Answer the valuation function of the receiver, if it is an Euclidean domain."
	^ properties at: #valuation! !

!Ring methodsFor: 'accessing' stamp: 'len 11/28/2015 03:57'!
zero
	^ properties at: #zero ifAbsentPut: [self one - self one]! !

!Ring methodsFor: 'operations' stamp: 'len 9/26/2016 17:05'!
zeroIdeal
	^ self * self zero! !

!GaussianIntegers methodsFor: 'testing' stamp: 'len 6/5/2016 06:10'!
includes: anObject
	^ anObject isInteger or: [anObject isComplex and: [anObject real isInteger and: [anObject imaginary isInteger]]]! !

!GaussianIntegers methodsFor: 'testing' stamp: 'len 6/5/2016 06:08'!
isCountable
	^ true! !

!GaussianIntegers methodsFor: 'testing' stamp: 'len 6/5/2016 06:08'!
isFinite
	^ false! !

!GaussianIntegers methodsFor: 'testing' stamp: 'len 6/5/2016 06:15'!
isPID
	^ true! !

!GaussianIntegers methodsFor: 'accessing' stamp: 'len 6/5/2016 06:13'!
one
	^ 1! !

!GaussianIntegers methodsFor: 'printing' stamp: 'len 6/8/2016 21:04'!
printOn: aStream
	aStream nextPutAll: Character ZZ asString, '[i]'! !

!GaussianIntegers methodsFor: 'accessing' stamp: 'len 6/5/2016 06:14'!
size
	^ Aleph new: 0! !

!GaussianIntegers methodsFor: 'accessing' stamp: 'len 6/5/2016 06:13'!
zero
	^ 0! !

!Integers methodsFor: 'operations' stamp: 'len 12/5/2015 23:51'!
* anIntegerOrArray
	^ (self includes: anIntegerOrArray)
			ifTrue: [IntegerIdeal on: self generators: {anIntegerOrArray}]
			ifFalse: [IntegerIdeal on: self generators: anIntegerOrArray]! !

!Integers methodsFor: 'operations' stamp: 'len 6/29/2016 03:47'!
/ anIdeal
	^ ModularIntegers by: (anIdeal isInteger ifTrue: [self * anIdeal] ifFalse: [anIdeal])! !

!Integers methodsFor: 'comparing' stamp: 'len 6/1/2016 23:56'!
<= aDomain
	^ aDomain isRing and: [(aDomain includes: 1) and: [aDomain includes: 0]]! !

!Integers methodsFor: 'comparing' stamp: 'len 11/10/2015 23:14'!
= anObject
	^ anObject class == self class! !

!Integers methodsFor: 'random' stamp: 'len 4/19/2016 22:12'!
atRandom: aRandom bits: bitSize
	| n |
	bitSize isInfinity ifTrue: [^ self error: 'infinite bitsize'].
	bitSize < 1 ifTrue: [^ self error: 'bitsize should be > 1'].
	n _ 2**(bitSize truncated - 1).
	^ (0-n to: n) atRandom: aRandom! !

!Integers methodsFor: 'accessing' stamp: 'len 11/5/2015 17:34'!
characteristic
	^ 0! !

!Integers methodsFor: 'iterating' stamp: 'len 11/10/2015 17:57'!
do: aBlock
	| i |
	aBlock value: 0.
	i _ 1.
	[ aBlock value: i; value: i negated. i _ i + 1 ] repeat! !

!Integers methodsFor: 'operations' stamp: 'len 7/15/2016 18:31'!
fractions
	^ QQ! !

!Integers methodsFor: 'operations' stamp: 'len 6/30/2016 02:37'!
freeModuleIn: aCollection
	"Answer the free abelian group in the given indeterminates (a Z-module)."
	^ FreeAbelianGroup on: aCollection! !

!Integers methodsFor: 'comparing' stamp: 'len 12/14/2015 01:59'!
hash
	^ self class hash! !

!Integers methodsFor: 'testing' stamp: 'len 11/23/2015 02:37'!
includes: anObject
	^ anObject isInteger! !

!Integers methodsFor: 'testing' stamp: 'len 11/7/2015 21:58'!
isCountable
	^ true! !

!Integers methodsFor: 'testing' stamp: 'len 11/4/2015 21:52'!
isEuclidean
	^ true! !

!Integers methodsFor: 'testing' stamp: 'len 11/7/2015 21:58'!
isFinite
	^ false! !

!Integers methodsFor: 'testing' stamp: 'len 12/28/2015 04:34'!
isInvertible: anElement
	^ anElement == 1 or: [anElement == -1]! !

!Integers methodsFor: 'testing' stamp: 'len 2/11/2016 22:19'!
isReal
	^ true! !

!Integers methodsFor: 'testing' stamp: 'len 5/12/2016 23:13'!
isUnit: anInteger
	^ anInteger = 1 or: [anInteger = -1]! !

!Integers methodsFor: 'operations' stamp: 'len 8/10/2016 06:08'!
modPrime: anInteger
	^ PrimeField new: anInteger! !

!Integers methodsFor: 'elements' stamp: 'len 11/5/2015 19:19'!
one
	^ 1! !

!Integers methodsFor: 'printing' stamp: 'len 6/8/2016 21:35'!
printOn: aStream
	aStream nextPut: Character ZZ! !

!Integers methodsFor: 'accessing' stamp: 'len 4/24/2016 02:58'!
size
	^ Aleph new! !

!Integers methodsFor: 'accessing' stamp: 'len 7/17/2016 23:53'!
valuation
	^ Function from: self to: self evaluating: [:x| x abs]! !

!Integers methodsFor: 'elements' stamp: 'len 11/3/2015 20:50'!
zero
	^ 0! !

!Integers class methodsFor: 'initialization' stamp: 'len 8/5/2016 21:32'!
initialize
	super initialize.
	Smalltalk at: #ZZ put: self new! !

!PAdicIntegers methodsFor: 'testing' stamp: 'len 12/7/2015 01:29'!
isIntegralDomain
	^ true! !

!PAdicIntegers methodsFor: 'elements' stamp: 'len 3/27/2016 02:02'!
one
	^ PAdicInteger fromNatural: 1 p: p! !

!PAdicIntegers methodsFor: 'accessing' stamp: 'len 12/7/2015 01:16'!
p
	^ p! !

!PAdicIntegers methodsFor: 'initialization' stamp: 'len 12/7/2015 01:16'!
p: aPrime
	p _ aPrime! !

!PAdicIntegers methodsFor: 'printing' stamp: 'len 7/17/2016 23:05'!
printOn: aStream
	aStream nextPut: Character ZZ; nextPutAll: p printString sub! !

!PAdicIntegers methodsFor: 'morphisms' stamp: 'len 7/17/2016 23:27'!
project: anInteger
	^ PAdicInteger fromNatural: anInteger p: p! !

!PAdicIntegers methodsFor: 'elements' stamp: 'len 3/27/2016 02:03'!
zero
	^ PAdicInteger fromNatural: 0 p: p! !

!PAdicIntegers class methodsFor: 'instance creation' stamp: 'len 12/7/2015 01:15'!
p: aPrime
	^ self new p: aPrime! !

!DirectProductRing methodsFor: 'comparing' stamp: 'len 8/29/2016 04:13'!
= anObject
	^ (anObject isKindOf: DirectProductGroup) and: [anObject components = components]! !

!DirectProductRing methodsFor: 'accessing' stamp: 'len 8/29/2016 04:09'!
arity
	^ components size! !

!DirectProductRing methodsFor: 'converting' stamp: 'len 8/29/2016 04:11'!
asCartesianProduct
	^ CartesianProduct components: components! !

!DirectProductRing methodsFor: 'accessing' stamp: 'len 8/29/2016 04:09'!
at: anInteger
	^ components at: anInteger! !

!DirectProductRing methodsFor: 'random' stamp: 'len 8/29/2016 04:12'!
atRandom: aRandom
	^ self asCartesianProduct atRandom: aRandom! !

!DirectProductRing methodsFor: 'random' stamp: 'len 8/29/2016 04:12'!
atRandom: aRandom bits: bits
	^ self asCartesianProduct atRandom: aRandom bits: bits! !

!DirectProductRing methodsFor: 'accessing-private' stamp: 'len 8/29/2016 04:10'!
components
	^ components! !

!DirectProductRing methodsFor: 'accessing-private' stamp: 'len 8/29/2016 04:10'!
components: anArray
	components _ anArray as: Tuple! !

!DirectProductRing methodsFor: 'iterating' stamp: 'len 8/29/2016 04:11'!
do: aBlock
	self asCartesianProduct do: aBlock! !

!DirectProductRing methodsFor: 'comparing' stamp: 'len 8/29/2016 04:13'!
hash
	^ components hash! !

!DirectProductRing methodsFor: 'testing' stamp: 'len 8/29/2016 04:14'!
includes: anObject
	anObject size = components size ifFalse: [^ false].
	components with: anObject do: [:G :x| (G includes: x) ifFalse: [^ false]].
	^ true! !

!DirectProductRing methodsFor: 'testing' stamp: 'len 8/29/2016 04:14'!
isProduct
	^ true! !

!DirectProductRing methodsFor: 'accessing' stamp: 'len 8/29/2016 04:10'!
one
	^ components collect: [:each| each one]! !

!DirectProductRing methodsFor: 'printing' stamp: 'len 8/29/2016 04:12'!
printOn: aStream
	components do: [:each| aStream print: each] separatedBy: [aStream nextPut: Character times]! !

!DirectProductRing methodsFor: 'morphisms' stamp: 'len 10/10/2016 08:42'!
projection: i
	^ (self to: (self at: i) evaluating: [:x| x at: i]) name: Character pi asText, i printText sub! !

!DirectProductRing methodsFor: 'accessing' stamp: 'len 8/29/2016 04:10'!
size
	^ components product: [:each| each size]! !

!DirectProductRing methodsFor: 'accessing' stamp: 'len 8/29/2016 04:10'!
zero
	^ components collect: [:each| each zero]! !

!DirectProductRing class methodsFor: 'instance creation' stamp: 'len 8/29/2016 04:09'!
components: anArray
	^ self new components: anArray! !

!FreeAlgebra methodsFor: 'comparing' stamp: 'len 8/25/2016 08:22'!
= anObject
	self == anObject ifTrue: [^ true].
	^ (anObject isKindOf: FreeAlgebra) and: [anObject scalars = scalars and: [anObject words = words]]! !

!FreeAlgebra methodsFor: 'elements' stamp: 'len 3/2/2016 05:54'!
coefficient: aNumber word: aWord
	^ self new coefficientAt: aWord put: aNumber; yourself! !

!FreeAlgebra methodsFor: 'elements' stamp: 'len 8/25/2016 08:19'!
coefficients: aCollection
	^ FreePolynomial coefficients: aCollection! !

!FreeAlgebra methodsFor: 'elements' stamp: 'len 8/25/2016 08:26'!
constant: aNumber
	^ self coefficient: aNumber word: words identity! !

!FreeAlgebra methodsFor: 'comparing' stamp: 'len 8/25/2016 08:21'!
hash
	^ scalars hash + words hash hashMultiply! !

!FreeAlgebra methodsFor: 'testing' stamp: 'len 8/25/2016 08:28'!
includes: anObject
	anObject coefficients keysAndValuesDo: [:key :value|
		(words includes: key) ifFalse: [^ false].
		(scalars includes: value) ifFalse: [^ false]].
	^ true! !

!FreeAlgebra methodsFor: 'accessing' stamp: 'len 8/25/2016 08:22'!
indeterminates
	^ words symbols! !

!FreeAlgebra methodsFor: 'testing' stamp: 'len 3/5/2016 04:24'!
isAssociative
	^ true! !

!FreeAlgebra methodsFor: 'testing' stamp: 'len 8/25/2016 08:29'!
isCommutative
	^ words isCommutative and: [scalars isCommutative]! !

!FreeAlgebra methodsFor: 'testing' stamp: 'len 8/25/2016 08:30'!
isCountable
	^ words isCountable and: [scalars isCountable]! !

!FreeAlgebra methodsFor: 'testing' stamp: 'len 8/25/2016 08:30'!
isFinite
	^ words isFinite and: [scalars isFinite]! !

!FreeAlgebra methodsFor: 'elements' stamp: 'len 8/25/2016 08:19'!
new
	^ FreePolynomial new! !

!FreeAlgebra methodsFor: 'elements' stamp: 'len 1/20/2016 14:06'!
one
	^ self constant: scalars one! !

!FreeAlgebra methodsFor: 'printing' stamp: 'len 8/25/2016 08:22'!
printOn: aStream
	aStream print: scalars.
	aStream nextPut: ${.
	self indeterminates
		do: [:i| aStream print: (Word x: i)]
		separatedBy: [aStream nextPut: $,].
	aStream nextPut: $}! !

!FreeAlgebra methodsFor: 'accessing' stamp: 'len 3/5/2016 04:30'!
rank
	self flag: #fix. "conflicts with FreeModule|rank"
	^ self indeterminates size! !

!FreeAlgebra methodsFor: 'accessing' stamp: 'len 1/20/2016 14:58'!
scalars
	^ scalars! !

!FreeAlgebra methodsFor: 'accessing-private' stamp: 'len 1/20/2016 13:39'!
scalars: aCommutativeRing
	scalars _ aCommutativeRing! !

!FreeAlgebra methodsFor: 'accessing' stamp: 'len 8/25/2016 08:27'!
words
	^ words! !

!FreeAlgebra methodsFor: 'accessing-private' stamp: 'len 8/25/2016 08:24'!
words: aMonoid
	words _ aMonoid! !

!FreeAlgebra methodsFor: 'elements' stamp: 'len 8/25/2016 08:21'!
x
	^ self x: self indeterminates first! !

!FreeAlgebra methodsFor: 'elements' stamp: 'len 3/2/2016 05:56'!
x: anIndeterminate
	^ self coefficient: scalars one word: (Word x: anIndeterminate)! !

!FreeAlgebra methodsFor: 'elements' stamp: 'len 8/25/2016 08:22'!
y
	^ self x: self indeterminates second! !

!FreeAlgebra methodsFor: 'elements' stamp: 'len 8/25/2016 08:21'!
z
	^ self x: self indeterminates third! !

!FreeAlgebra methodsFor: 'elements' stamp: 'len 3/2/2016 05:55'!
zero
	^ self new! !

!FreeAlgebra class methodsFor: 'instance creation' stamp: 'len 6/30/2016 02:27'!
new: anInteger over: aRing
	^ self on: (1 to: anInteger) over: aRing! !

!FreeAlgebra class methodsFor: 'instance creation' stamp: 'len 8/25/2016 08:25'!
on: aCollection over: aRing
	^ self words: (FreeMonoid on: aCollection) over: aRing! !

!FreeAlgebra class methodsFor: 'instance creation' stamp: 'len 1/20/2016 13:38'!
over: aRing
	^ self new: 1 over: aRing! !

!FreeAlgebra class methodsFor: 'instance creation' stamp: 'len 8/25/2016 08:24'!
words: aMonoid over: aRing
	^ self new words: aMonoid; scalars: aRing! !

!GroupRing methodsFor: 'comparing' stamp: 'len 8/26/2016 01:30'!
<= aGroupRing
	(aGroupRing isKindOf: GroupRing) ifFalse: [^ super <= aGroupRing].
	^ self scalars <= aGroupRing scalars and: [self group <= aGroupRing group]! !

!GroupRing methodsFor: 'comparing' stamp: 'len 8/25/2016 08:35'!
= anObject
	self == anObject ifTrue: [^ true].
	^ (anObject isKindOf: GroupRing) and: [anObject scalars = scalars and: [anObject group = group]]! !

!GroupRing methodsFor: 'morphisms' stamp: 'len 8/25/2016 08:36'!
embed: aGroupElement
	^ FreePolynomial new coefficientAt: aGroupElement put: scalars one! !

!GroupRing methodsFor: 'morphisms' stamp: 'len 10/10/2016 08:56'!
embedding
	^ (Function from: self group to: self evaluating: [:g| self embed: g]) name: 'i' "should be a group homomorphism in Hom(Grp,Ab)?"! !

!GroupRing methodsFor: 'accessing' stamp: 'len 8/7/2016 08:36'!
group
	^ group! !

!GroupRing methodsFor: 'accessing-private' stamp: 'len 8/7/2016 08:37'!
group: aGroup
	group _ aGroup! !

!GroupRing methodsFor: 'comparing' stamp: 'len 8/25/2016 08:35'!
hash
	^ scalars hash + group hash hashMultiply! !

!GroupRing methodsFor: 'testing' stamp: 'len 8/25/2016 08:36'!
includes: anObject
	anObject coefficients keysAndValuesDo: [:key :value|
		(group includes: key) ifFalse: [^ false].
		(scalars includes: value) ifFalse: [^ false]].
	^ true! !

!GroupRing methodsFor: 'testing' stamp: 'len 8/25/2016 08:37'!
isCommutative
	^ scalars isCommutative and: [group isCommutative]! !

!GroupRing methodsFor: 'testing' stamp: 'len 8/25/2016 08:38'!
isCountable
	^ scalars isCountable and: [group isCountable]! !

!GroupRing methodsFor: 'testing' stamp: 'len 8/25/2016 08:38'!
isFinite
	^ scalars isFinite and: [group isFinite]! !

!GroupRing methodsFor: 'accessing' stamp: 'len 8/7/2016 08:40'!
one
	^ self embed: self group identity! !

!GroupRing methodsFor: 'printing' stamp: 'len 8/7/2016 08:38'!
printOn: aStream
	aStream print: self scalars; nextPut: $[; print: self group; nextPut: $]! !

!GroupRing methodsFor: 'accessing' stamp: 'len 8/7/2016 08:38'!
scalars
	^ scalars! !

!GroupRing methodsFor: 'accessing-private' stamp: 'len 8/7/2016 08:38'!
scalars: aRing
	scalars _ aRing! !

!GroupRing class methodsFor: 'instance creation' stamp: 'len 8/7/2016 08:39'!
on: aGroup over: aRing
	^ self new group: aGroup; scalars: aRing! !

!QuotientRing methodsFor: 'comparing' stamp: 'len 12/14/2015 01:57'!
= anObject
	self == anObject ifTrue: [^ true].
	(anObject isKindOf: QuotientRing) ifFalse: [^ false].
	^ ideal = anObject ideal! !

!QuotientRing methodsFor: 'random' stamp: 'len 4/19/2016 23:05'!
atRandom: aRandom
	^ self project: (ideal remainderAtRandom: aRandom)
"	^ self project: (ideal ring atRandom: aRandom)"! !

!QuotientRing methodsFor: 'random' stamp: 'len 10/7/2016 07:12'!
atRandom: aRandom bits: bitSize
"	^ self atRandom: aRandom"
	^ self project: (ideal ring atRandom: aRandom bits: bitSize)! !

!QuotientRing methodsFor: 'accessing' stamp: 'len 9/26/2016 16:49'!
base
	^ ideal ring! !

!QuotientRing methodsFor: 'private' stamp: 'len 10/10/2016 08:52'!
buildProjection
	"Answer the natural projection, or quotient map, or canonical homomorphism. This takes elements from the base ring to the corresponding residue class in the quotient ring."
	| answer |
	answer _ self base to: self evaluating: [:each| self project: each].
	answer name: Character pi asString.
	answer properties
		at: #kernel put: ideal;
		at: #image put: self;
		at: #rightInverse put: (self to: self base evaluating: [:each| each representative]).
	^ answer! !

!QuotientRing methodsFor: 'morphisms' stamp: 'len 2/5/2016 19:52'!
conjugation
	"Answer the companion automorphism of the receiver, i.e. the Frobenius automorphism."
	^ self frobenius! !

!QuotientRing methodsFor: 'iterating' stamp: 'len 9/26/2016 16:49'!
do: aBlock
	| visited |
	self flag: #fix. "does this work in any ring? depends on ring|#do:"
	visited _ Set2 new.
	ideal ring do: [:each|
		| q |
		visited add: (q _ self project: each) ifPresent: [^ self].
		aBlock value: q]! !

!QuotientRing methodsFor: 'private' stamp: 'len 3/29/2016 23:45'!
elementClass
	^ properties at: #elementClass ifAbsentPut: [Residue]! !

!QuotientRing methodsFor: 'accessing' stamp: 'len 10/10/2016 16:29'!
generators
	^ (self base generators ifNil: [^ nil]) apply: self projection! !

!QuotientRing methodsFor: 'comparing' stamp: 'len 12/14/2015 01:57'!
hash
	^ ideal hash! !

!QuotientRing methodsFor: 'accessing' stamp: 'len 11/21/2015 17:14'!
ideal
	^ ideal! !

!QuotientRing methodsFor: 'accessing-private' stamp: 'len 11/21/2015 17:13'!
ideal: anIdeal
	ideal _ anIdeal! !

!QuotientRing methodsFor: 'testing' stamp: 'len 9/26/2016 16:49'!
includes: anObject
	anObject class = self elementClass ifFalse: [^ false].
	^ ideal ring includes: anObject representative! !

!QuotientRing methodsFor: 'testing' stamp: 'len 9/26/2016 16:49'!
isCommutative
	ideal ring isCommutative ifTrue: [^ true]. "if the ring is not commutative, we dont know if the quotient is or not"
	^ super isCommutative! !

!QuotientRing methodsFor: 'testing' stamp: 'len 9/26/2016 16:49'!
isEuclidean
	^ ideal ring isEuclidean! !

!QuotientRing methodsFor: 'testing' stamp: 'len 9/26/2016 16:50'!
isField
	"Answer true if the receiver forms a residue field."
	^ properties at: #isField ifAbsentPut: [ideal ring isTrivial not and: [ideal ring isCommutative and: [ideal isMaximal]]]! !

!QuotientRing methodsFor: 'testing' stamp: 'len 9/26/2016 16:50'!
isIntegralDomain
	^ properties at: #isIntegralDomain ifAbsentPut: [(ideal ring isTrivial not and: [ideal ring isCommutative and: [ideal isPrime]]) or: [self isIntegrallyClosedDomain]]! !

!QuotientRing methodsFor: 'testing' stamp: 'len 8/10/2016 01:01'!
isQuotient
	^ true! !

!QuotientRing methodsFor: 'testing' stamp: 'len 11/23/2015 21:34'!
isReduced
	"A quotient ring is reduced iff the ideal is radical."
	^ ideal isRadical! !

!QuotientRing methodsFor: 'accessing' stamp: 'len 4/25/2016 00:30'!
modulus
	^ self ideal generator! !

!QuotientRing methodsFor: 'accessing' stamp: 'len 9/26/2016 16:50'!
one
	^ self project: ideal ring one! !

!QuotientRing methodsFor: 'printing' stamp: 'len 9/26/2016 16:50'!
printOn: aStream
	(ideal ring printString includes: $/)
		ifTrue: [aStream nextPut: $(; print: ideal ring; nextPut: $)]
		ifFalse: [aStream print: ideal ring].
	aStream nextPut: $/; print: ideal! !

!QuotientRing methodsFor: 'morphisms' stamp: 'len 7/7/2016 20:46'!
project: anElement
	^ self elementClass representative: (ideal reduce: anElement) ideal: ideal! !

!QuotientRing methodsFor: 'morphisms' stamp: 'len 10/6/2016 09:53'!
projection
	"Answer the natural projection, or quotient map, or canonical homomorphism. This takes elements from the base ring to the corresponding residue class in the quotient ring."
	^ properties at: #projection ifAbsentPut: [self buildProjection]! !

!QuotientRing methodsFor: 'accessing' stamp: 'len 8/24/2016 19:04'!
relation
	^ EquivalenceRelation on: self base evaluating: [:a :b| ideal includes: a - b]! !

!QuotientRing methodsFor: 'accessing' stamp: 'len 9/26/2016 16:50'!
zero
	^ self project: ideal ring zero! !

!QuotientRing class methodsFor: 'instance creation' stamp: 'len 11/28/2015 05:54'!
by: anIdeal
	^ self new ideal: anIdeal! !

!ModularIntegers methodsFor: 'random' stamp: 'len 4/25/2016 00:26'!
atRandom: aRandom
	^ self project: (self modulus atRandom: aRandom) - 1! !

!ModularIntegers methodsFor: 'random' stamp: 'len 4/19/2016 22:14'!
atRandom: aRandom bits: bitSize
	^ self atRandom: aRandom! !

!ModularIntegers methodsFor: 'accessing' stamp: 'len 4/25/2016 00:26'!
characteristic
	^ self modulus! !

!ModularIntegers methodsFor: 'private' stamp: 'len 4/15/2016 21:10'!
elementClass
	^ ModularInteger! !

!ModularIntegers methodsFor: 'testing' stamp: 'len 5/12/2016 23:20'!
isField
	^ properties at: #isField ifAbsentPut: [self modulus isPrime]! !

!ModularIntegers methodsFor: 'testing' stamp: 'len 5/12/2016 23:34'!
isUnit: anElement
	^ (anElement representative gcd: self modulus) = 1! !

!ModularIntegers methodsFor: 'accessing' stamp: 'len 4/25/2016 00:27'!
size
	^ self modulus! !

!ModularIntegers methodsFor: 'private' stamp: 'len 4/25/2016 00:27'!
tupleClass
	self flag: #fix.
	^ self modulus = 2 ifTrue: [^ BitTuple] ifFalse: [Tuple] "ModularTuple"! !

!CoordinateRing methodsFor: 'operations' stamp: 'len 6/3/2016 23:22'!
fractions
	^ FunctionField over: self! !

!CoordinateRing methodsFor: 'testing' stamp: 'len 3/5/2016 07:25'!
includes: anObject
	^ (anObject isKindOf: PolynomialFunction) and: [anObject domain = variety]! !

!CoordinateRing methodsFor: 'printing' stamp: 'len 4/21/2016 00:08'!
printOn: aStream
	aStream print: variety groundField; nextPut: $[; print: variety; nextPut: $]! !

!CoordinateRing methodsFor: 'morphisms' stamp: 'len 7/7/2016 20:44'!
project: aPolynomial
	^ PolynomialFunction from: variety representative: (variety ideal reduce: aPolynomial)! !

!CoordinateRing methodsFor: 'accessing' stamp: 'len 2/8/2016 02:27'!
variety
	^ variety! !

!CoordinateRing methodsFor: 'accessing-private' stamp: 'len 2/8/2016 02:27'!
variety: anAlgebraicVariety
	variety _ anAlgebraicVariety! !

!CoordinateRing class methodsFor: 'instance creation' stamp: 'len 4/25/2016 21:02'!
on: anAlgebraicVariety
	^ (self by: anAlgebraicVariety ideal) variety: anAlgebraicVariety! !

!Field methodsFor: 'operations' stamp: 'len 12/15/2015 22:30'!
algebraicClosure
	self isAlgebraicallyClosed ifTrue: [^ self].
	^ properties at: #algebraicClosure! !

!Field methodsFor: 'converting' stamp: 'len 10/7/2016 08:43'!
asSelfVectorSpace
	"Answer the receiver K viewed as K-vector space."
	^ self asSelfModule! !

!Field methodsFor: 'morphisms' stamp: 'len 2/5/2016 19:54'!
conjugation
	"Answer the companion automorphism of the receiver."
	^ self id! !

!Field methodsFor: 'operations' stamp: 'len 12/9/2015 02:34'!
cyclotomicRing: n
	"Answer the n-th cyclotomic ring on the receiver."
	| Fx phi |
	Fx _ self polynomials.
	phi _ Fx cyclotomic: n. "cyclotomic polynomial of order n"
	^ Fx mod: phi "answer the quotient ring modulo <phi>"! !

!Field methodsFor: 'operations' stamp: 'len 6/4/2016 17:49'!
extension: aPolynomial
	"Answer the algebraic extension of the receiver defined by the given irreducible polynomial."
	aPolynomial scalars = self ifFalse: [self error: 'polynomial coefficients not from this field'].
	^ AlgebraicExtension polynomial: aPolynomial! !

!Field methodsFor: 'operations' stamp: 'len 6/30/2016 02:34'!
freeVectorSpaceIn: aCollection
	"Answer the free vector space in the given indeterminates over the receiver."
	^ VectorSpace on: aCollection over: self! !

!Field methodsFor: 'testing' stamp: 'len 12/14/2015 23:49'!
isAlgebraicallyClosed
	^ properties at: #isAlgebraicallyClosed ifAbsent: [false]! !

!Field methodsFor: 'testing' stamp: 'len 11/28/2015 23:55'!
isCommutative
	^ true! !

!Field methodsFor: 'testing' stamp: 'len 11/7/2015 22:00'!
isField
	^ true! !

!Field methodsFor: 'testing' stamp: 'len 5/14/2016 06:53'!
isGlobalField
	^ false! !

!Field methodsFor: 'testing' stamp: 'len 4/22/2016 14:10'!
isInitial
	"The category of fields has no initial objects."
	^ false! !

!Field methodsFor: 'testing' stamp: 'len 12/28/2015 04:33'!
isInvertible: anElement
	self characteristic = 0 ifTrue: [^ anElement isZero not].
	^ anElement reciprocal notNil! !

!Field methodsFor: 'testing' stamp: 'len 2/8/2016 20:50'!
isPerfect
	"A field is perfect if either it has characteristic 0 or has characteristic p and every element in the field has a p-th root in the field."
	(self characteristic = 0 or: [self isFinite]) ifTrue: [^ true].
	^ properties at: #isPerfect! !

!Field methodsFor: 'testing' stamp: 'len 2/8/2016 20:26'!
isPrime
	"A prime field is a field with no proper subfields."
	^ properties at: #isPrime! !

!Field methodsFor: 'testing' stamp: 'len 4/22/2016 14:10'!
isTerminal
	"The category of fields has no terminal objects."
	^ false! !

!Field methodsFor: 'testing' stamp: 'len 8/10/2016 06:03'!
isUnit: anElement
	^ anElement isZero not! !

!Field methodsFor: 'operations' stamp: 'len 7/15/2016 18:24'!
primeSubfield
	"A prime field is a field with no proper subfields. Every subfield contains a prime subfield, that is either isomorphic to Q or Z_p for some prime p."
	self flag: #fix. "the subfield is isomorphic, not equal"
	^ self characteristic = 0
		ifTrue: [QQ]
		ifFalse: [ZZ modPrime: self characteristic]! !

!Field methodsFor: 'morphisms' stamp: 'len 10/4/2016 08:51'!
to: aField evaluating: aBlock
	"Answer the group homomorphism from the receiver to the argument."
	(aField isKindOf: Field) ifFalse: [^ super to: aField evaluating: aBlock].
	^ FieldHomomorphism from: self to: aField evaluating: aBlock! !

!Field methodsFor: 'accessing' stamp: 'len 7/17/2016 23:54'!
valuation
	"Answer the trivial valuation of the receiver as an Euclidean domain."
	| one |
	one _ self one.
	^ Function from: self to: QQ evaluating: [:x| one]! !

!Field class methodsFor: 'examples' stamp: 'len 8/10/2016 06:23'!
GF: q
	"Answer the Galois field of order q = p^n."
	| factors n p F P f |
	factors _ q factors.
	factors asSet size = 1 ifFalse: [^ self error: 'not power of a prime'].
	n _ factors size.
	p _ factors anyOne.
	F _ ZZ modPrime: p.
	n = 1 ifTrue: [^ F].
	P _ F polynomials.
	f _ P findIrreducibleOfDegree: n.
	^ (F extension: f) name: 'GF(',p printString,'^',n printString,')'! !

!ComplexNumbers methodsFor: 'accessing' stamp: 'len 8/6/2016 03:44'!
characteristic
	^ 0! !

!ComplexNumbers methodsFor: 'accessing' stamp: 'len 10/4/2016 08:59'!
conjugation
	^ self to: self evaluating: [:x| x conjugated]! !

!ComplexNumbers methodsFor: 'iterating' stamp: 'len 8/6/2016 03:50'!
do: aBlock
	^ self shouldNotImplement! !

!ComplexNumbers methodsFor: 'converting' stamp: 'len 8/5/2016 21:53'!
extended
	^ ExtendedComplexNumbers new! !

!ComplexNumbers methodsFor: 'testing' stamp: 'len 8/5/2016 21:50'!
includes: anObject
	^ anObject isComplex! !

!ComplexNumbers methodsFor: 'testing' stamp: 'len 8/12/2016 04:48'!
isAlgebraicallyClosed
	^ true! !

!ComplexNumbers methodsFor: 'testing' stamp: 'len 8/5/2016 21:55'!
isComplex
	^ true! !

!ComplexNumbers methodsFor: 'accessing' stamp: 'len 8/6/2016 03:45'!
one
	^ 1! !

!ComplexNumbers methodsFor: 'printing' stamp: 'len 8/5/2016 21:35'!
printOn: aStream
	aStream nextPut: Character CC! !

!ComplexNumbers methodsFor: 'accessing' stamp: 'len 8/6/2016 03:44'!
size
	^ Aleph new: 1! !

!ComplexNumbers methodsFor: 'accessing' stamp: 'len 8/6/2016 03:45'!
zero
	^ 0! !

!ComplexNumbers class methodsFor: 'initialization' stamp: 'len 8/5/2016 21:34'!
initialize
	super initialize.
	Smalltalk at: #CC put: self new! !

!ExtendedComplexNumbers methodsFor: 'testing' stamp: 'len 8/5/2016 21:49'!
includes: anObject
	^ anObject isComplex or: [anObject isInfinity]! !

!ExtendedComplexNumbers methodsFor: 'testing' stamp: 'len 8/5/2016 21:55'!
isComplex
	^ true! !

!ExtendedComplexNumbers methodsFor: 'printing' stamp: 'len 8/5/2016 21:48'!
printOn: aStream
	aStream nextPut: Character CC; nextPutAll: ' U {'; nextPut: Character infinity; nextPut: $}
"	aStream nextPut: Character CC; nextPutAll: Character infinity asString sub"! !

!PAdicNumbers methodsFor: 'as yet unclassified' stamp: 'len 7/17/2016 23:33'!
p: aPrime
	p _ aPrime! !

!PAdicNumbers methodsFor: 'as yet unclassified' stamp: 'len 7/17/2016 23:33'!
printOn: aStream
	aStream nextPut: Character QQ; nextPutAll: p printString sub! !

!PAdicNumbers class methodsFor: 'as yet unclassified' stamp: 'len 7/17/2016 23:33'!
p: aPrime
	^ self new p: aPrime! !

!Reals methodsFor: 'accessing' stamp: 'len 8/6/2016 03:45'!
characteristic
	^ 0! !

!Reals methodsFor: 'iterating' stamp: 'len 8/6/2016 03:50'!
do: aBlock
	^ self shouldNotImplement! !

!Reals methodsFor: 'testing' stamp: 'len 8/5/2016 21:50'!
includes: anObject
	^ anObject isReal! !

!Reals methodsFor: 'testing' stamp: 'len 8/5/2016 21:55'!
isReal
	^ true! !

!Reals methodsFor: 'printing' stamp: 'len 8/5/2016 21:35'!
printOn: aStream
	aStream nextPut: Character RR! !

!Reals methodsFor: 'accessing' stamp: 'len 8/6/2016 03:45'!
size
	^ Aleph new: 1! !

!Reals class methodsFor: 'initialization' stamp: 'len 8/5/2016 21:33'!
initialize
	super initialize.
	Smalltalk at: #RR put: self new! !

!FractionField methodsFor: 'comparing' stamp: 'len 12/14/2015 01:58'!
= anObject
	self == anObject ifTrue: [^ true].
	^ (anObject isKindOf: FractionField) and: [anObject integralDomain = self integralDomain]! !

!FractionField methodsFor: 'random' stamp: 'len 4/19/2016 21:12'!
atRandom: aRandom
	| a b |
	a _ self embedding value: (self integralDomain atRandom: aRandom).
	[b _ self embedding value: (self integralDomain  atRandom: aRandom). b isZero] whileTrue.
	^ a / b! !

!FractionField methodsFor: 'random' stamp: 'len 4/22/2016 22:00'!
atRandom: aRandom bits: bitSize
	| a b |
	bitSize < 2 ifTrue: [^ self embedding value: (self integralDomain atRandom: aRandom bits: bitSize)].
	a _ self embedding value: (self integralDomain atRandom: aRandom bits: bitSize / 2).
	[b _ self embedding value: (self integralDomain  atRandom: aRandom bits: bitSize / 2). b isZero] whileTrue.
	^ a / b! !

!FractionField methodsFor: 'morphisms' stamp: 'len 4/19/2016 21:11'!
embed: anObject
	^ FormalFraction numerator: anObject denominator: self integralDomain one! !

!FractionField methodsFor: 'morphisms' stamp: 'len 10/10/2016 08:56'!
embedding
	"Answer the embedding map from the integral domain into the receiver."
	^ properties at: #embedding ifAbsentPut: [(self integralDomain to: self evaluating: [:x| self embed: x]) name: 'i']! !

!FractionField methodsFor: 'comparing' stamp: 'len 11/30/2015 23:19'!
hash
	^ self class hash + self integralDomain hash! !

!FractionField methodsFor: 'testing' stamp: 'len 4/19/2016 21:12'!
includes: anObject
	^ (anObject isKindOf: FormalFraction)
		and: [(self integralDomain includes: anObject numerator)
			and: [self integralDomain includes: anObject denominator]]! !

!FractionField methodsFor: 'accessing' stamp: 'len 4/19/2016 21:10'!
integralDomain
	^ properties at: #integralDomain! !

!FractionField methodsFor: 'accessing-private' stamp: 'len 4/19/2016 21:11'!
integralDomain: aRing
	properties at: #integralDomain put: aRing! !

!FractionField methodsFor: 'testing' stamp: 'len 3/9/2016 04:35'!
isFractionField
	^ true! !

!FractionField methodsFor: 'elements' stamp: 'len 4/19/2016 21:12'!
one
	^ self embedding value: self integralDomain one! !

!FractionField methodsFor: 'printing' stamp: 'len 4/21/2016 00:06'!
printOn: aStream
	aStream nextPutAll: 'Frac('; print: self integralDomain; nextPut: $)
"	aStream nextPutAll: 'Quot('; print: integralDomain; nextPut: $)"! !

!FractionField methodsFor: 'elements' stamp: 'len 4/19/2016 21:12'!
zero
	^ self embedding value: self integralDomain zero! !

!FractionField class methodsFor: 'instance creation' stamp: 'len 11/27/2015 19:45'!
over: anIntegralDomain
	^ self new integralDomain: anIntegralDomain! !

!Rationals methodsFor: 'comparing' stamp: 'len 6/1/2016 23:56'!
<= aDomain
	^ aDomain isField and: [(aDomain includes: 1) and: [aDomain includes: 0]]! !

!Rationals methodsFor: 'comparing' stamp: 'len 11/10/2015 23:14'!
= anObject
	^ anObject class == self class! !

!Rationals methodsFor: 'operations' stamp: 'len 5/18/2016 22:22'!
adjoin: anAlgebraicNumber
	^ NumberField adjoint: anAlgebraicNumber! !

!Rationals methodsFor: 'operations' stamp: 'len 4/17/2016 06:45'!
algebraicClosure
	^ AlgebraicNumbers new! !

!Rationals methodsFor: 'morphisms' stamp: 'len 5/2/2016 02:30'!
automorphisms
	^ Group compositive elements: {self id}! !

!Rationals methodsFor: 'accessing' stamp: 'len 11/5/2015 17:35'!
characteristic
	^ 0! !

!Rationals methodsFor: 'iterating' stamp: 'len 12/21/2015 22:42'!
do: aBlock
	"Iterate over the rational numbers by breadth-first traversal of the Calkin-Wilf tree. This is an extension of the Calkin-Wilf sequence to include 0 and the negative numbers."
	aBlock value: 0.
	self positiveDo: [:each| aBlock value: each; value: each negated]! !

!Rationals methodsFor: 'morphisms' stamp: 'len 1/2/2016 04:15'!
embed: anInteger
	^ anInteger "because in Smalltalk Fractions of denominator 1 are always reduced to their Integer numerator"! !

!Rationals methodsFor: 'morphisms' stamp: 'len 10/10/2016 08:58'!
embedding
	^ properties at: #embedding ifAbsentPut: [(self integralDomain to: self evaluating: [:x| x]) name: 'i'] "because in Smalltalk Fractions of denominator 1 are always reduced to their Integer numerator"! !

!Rationals methodsFor: 'comparing' stamp: 'len 6/28/2016 09:27'!
hash
	^ self class hash! !

!Rationals methodsFor: 'testing' stamp: 'len 1/11/2016 05:56'!
includes: anObject
	^ anObject isNumber and: [anObject isRational or: [anObject isFloat]]! !

!Rationals methodsFor: 'accessing' stamp: 'len 7/15/2016 18:29'!
integralDomain
	^ ZZ! !

!Rationals methodsFor: 'testing' stamp: 'len 11/7/2015 22:05'!
isCountable
	^ true! !

!Rationals methodsFor: 'testing' stamp: 'len 11/7/2015 22:05'!
isFinite
	^ false! !

!Rationals methodsFor: 'testing' stamp: 'len 2/8/2016 20:26'!
isPrime
	"Q is a prime field (it has no proper subfields)."
	^ true! !

!Rationals methodsFor: 'testing' stamp: 'len 2/11/2016 22:19'!
isReal
	^ true! !

!Rationals methodsFor: 'elements' stamp: 'len 11/2/2015 15:53'!
one
	^ 1! !

!Rationals methodsFor: 'iterating' stamp: 'len 12/21/2015 22:42'!
positiveDo: aBlock
	"Iterate over the rational numbers by breadth-first traversal of the Calkin-Wilf tree."
	| q |
	q _ 1.
	[aBlock value: q. q _ 1 / (2 * q floor - q + 1)] repeat! !

!Rationals methodsFor: 'printing' stamp: 'len 6/8/2016 21:05'!
printOn: aStream
	aStream nextPut: Character QQ! !

!Rationals methodsFor: 'operations' stamp: 'len 4/17/2016 06:44'!
realClosure
	^ RealAlgebraicNumbers new! !

!Rationals methodsFor: 'accessing' stamp: 'len 4/24/2016 03:00'!
size
	^ Aleph new! !

!Rationals methodsFor: 'accessing' stamp: 'len 7/17/2016 23:53'!
valuation
	"Answer the absolute value valuation."
	^ Function from: self to: self evaluating: [:x| x abs]! !

!Rationals methodsFor: 'accessing' stamp: 'len 7/15/2016 18:21'!
valuation: p
	"Answer the p-adic valuation."
	^ Function from: self to: NN evaluating: [:x| p / ((x numerator factors occurrencesOf: p) - (x denominator factors occurrencesOf: p))]! !

!Rationals methodsFor: 'elements' stamp: 'len 11/2/2015 15:53'!
zero
	^ 0! !

!Rationals class methodsFor: 'initialization' stamp: 'len 8/5/2016 21:33'!
initialize
	super initialize.
	Smalltalk at: #QQ put: self new! !

!RationalFunctions methodsFor: 'accessing' stamp: 'len 7/8/2016 23:38'!
characteristic
	^ self scalars characteristic! !

!RationalFunctions methodsFor: 'morphisms' stamp: 'len 1/2/2016 04:14'!
embed: aPolynomial
	^ RationalFunction numerator: aPolynomial denominator: self polynomials one! !

!RationalFunctions methodsFor: 'morphisms' stamp: 'len 10/10/2016 08:57'!
embedding
	"Answer the embedding map from the base polynomials ring into the receiver."
	^ properties at: #embedding ifAbsentPut: [(self polynomials to: self evaluating: [:f| self embed: f]) name: 'i']! !

!RationalFunctions methodsFor: 'accessing' stamp: 'len 11/27/2015 20:13'!
indeterminates
	^ self polynomials indeterminates! !

!RationalFunctions methodsFor: 'testing' stamp: 'len 11/27/2015 20:13'!
isUnivariate
	^ self polynomials isUnivariate! !

!RationalFunctions methodsFor: 'accessing' stamp: 'len 11/27/2015 20:12'!
polynomials
	^ self integralDomain! !

!RationalFunctions methodsFor: 'accessing-private' stamp: 'len 11/27/2015 20:12'!
polynomials: aPolynomials
	self integralDomain: aPolynomials! !

!RationalFunctions methodsFor: 'printing' stamp: 'len 7/11/2016 01:12'!
printOn: aStream
	aStream print: self scalars.
	aStream nextPut: $(.
	self polynomials ordering indeterminates
		do: [:i| aStream print: (self polynomials x: i)]
		separatedBy: [aStream nextPut: $,].
	aStream nextPut: $)! !

!RationalFunctions methodsFor: 'accessing' stamp: 'len 11/27/2015 20:14'!
scalars
	^ self polynomials scalars! !

!RationalFunctions methodsFor: 'elements' stamp: 'len 4/16/2016 07:11'!
x
	^ self embed: self polynomials x! !

!RationalFunctions methodsFor: 'elements' stamp: 'len 7/8/2016 23:37'!
x: anIndeterminate
	^ self embed: (self polynomials x: anIndeterminate)! !

!RationalFunctions class methodsFor: 'instance creation' stamp: 'len 11/11/2015 01:23'!
polynomials: aPolynomials
	^ self new polynomials: aPolynomials! !

!FunctionField methodsFor: 'printing' stamp: 'len 6/3/2016 23:24'!
printOn: aStream
	aStream print: self variety groundField; nextPut: $(; print: self variety; nextPut: $)! !

!FunctionField methodsFor: 'accessing' stamp: 'len 6/3/2016 23:24'!
variety
	^ self integralDomain variety! !

!ResidueField methodsFor: 'comparing' stamp: 'len 12/14/2015 01:57'!
= anObject
	self == anObject ifTrue: [^ true].
	(anObject isKindOf: ResidueField) ifFalse: [^ false].
	^ ideal = anObject ideal! !

!ResidueField methodsFor: 'random' stamp: 'len 10/7/2016 07:11'!
atRandom: aRandom
	^ self project: (ideal remainderAtRandom: aRandom)
"	^ self project: (ideal ring atRandom: aRandom)"! !

!ResidueField methodsFor: 'random' stamp: 'len 10/7/2016 07:11'!
atRandom: aRandom bits: bitSize
"	^ self atRandom: aRandom"
	^ self project: (ideal ring atRandom: aRandom bits: bitSize)! !

!ResidueField methodsFor: 'private' stamp: 'len 10/10/2016 08:52'!
buildProjection
	"Answer the natural projection, or quotient map, or canonical homomorphism. This takes elements from the base ring to the corresponding residue class in the quotient ring."
	| answer |
	answer _ ideal ring to: self evaluating: [:each| self project: each].
	answer name: Character pi asString.
	answer properties
		at: #kernel put: ideal;
		at: #image put: self;
		at: #rightInverse put: (RingHomomorphism from: self to: ideal ring evaluating: [:each| each representative]).
	^ answer! !

!ResidueField methodsFor: 'morphisms' stamp: 'len 2/5/2016 19:52'!
conjugation
	"Answer the companion automorphism of the receiver, i.e. the Frobenius automorphism."
	^ self frobenius! !

!ResidueField methodsFor: 'iterating' stamp: 'len 9/26/2016 16:51'!
do: aBlock
	| visited |
	self flag: #fix. "does this work in any ring? depends on ring|#do:"
	visited _ Set2 new.
	ideal ring do: [:each|
		| q |
		visited add: (q _ self project: each) ifPresent: [^ self].
		aBlock value: q]! !

!ResidueField methodsFor: 'private' stamp: 'len 3/29/2016 23:45'!
elementClass
	^ properties at: #elementClass ifAbsentPut: [Residue]! !

!ResidueField methodsFor: 'comparing' stamp: 'len 12/14/2015 01:57'!
hash
	^ ideal hash! !

!ResidueField methodsFor: 'accessing' stamp: 'len 11/21/2015 17:14'!
ideal
	^ ideal! !

!ResidueField methodsFor: 'accessing-private' stamp: 'len 11/21/2015 17:13'!
ideal: anIdeal
	ideal _ anIdeal! !

!ResidueField methodsFor: 'testing' stamp: 'len 9/26/2016 16:51'!
includes: anObject
	anObject class = self elementClass ifFalse: [^ false].
	^ ideal ring includes: anObject representative! !

!ResidueField methodsFor: 'testing' stamp: 'len 8/10/2016 01:01'!
isQuotient
	^ true! !

!ResidueField methodsFor: 'testing' stamp: 'len 11/23/2015 21:34'!
isReduced
	"A quotient ring is reduced iff the ideal is radical."
	^ ideal isRadical! !

!ResidueField methodsFor: 'accessing' stamp: 'len 4/25/2016 00:30'!
modulus
	^ self ideal generator! !

!ResidueField methodsFor: 'accessing' stamp: 'len 9/26/2016 16:51'!
one
	^ self project: ideal ring one! !

!ResidueField methodsFor: 'printing' stamp: 'len 9/26/2016 16:51'!
printOn: aStream
	(ideal ring printString includes: $/)
		ifTrue: [aStream nextPut: $(; print: ideal ring; nextPut: $)]
		ifFalse: [aStream print: ideal ring].
	aStream nextPut: $/; print: ideal! !

!ResidueField methodsFor: 'morphisms' stamp: 'len 7/7/2016 20:46'!
project: anElement
	^ self elementClass representative: (ideal reduce: anElement) ideal: ideal! !

!ResidueField methodsFor: 'morphisms' stamp: 'len 10/6/2016 09:53'!
projection
	"Answer the natural projection, or quotient map, or canonical homomorphism. This takes elements from the base ring to the corresponding residue class in the quotient ring."
	^ properties at: #projection ifAbsentPut: [self buildProjection]! !

!ResidueField methodsFor: 'accessing' stamp: 'len 8/24/2016 19:06'!
relation
	^ EquivalenceRelation on: self base evaluating: [:a :b| ideal includes: a - b]! !

!ResidueField methodsFor: 'accessing' stamp: 'len 9/26/2016 16:51'!
zero
	^ self project: ideal ring zero! !

!ResidueField class methodsFor: 'instance creation' stamp: 'len 11/28/2015 05:54'!
by: anIdeal
	^ self new ideal: anIdeal! !

!PrimeField methodsFor: 'random' stamp: 'len 8/10/2016 06:02'!
atRandom: aRandom
	^ self project: (self modulus atRandom: aRandom) - 1! !

!PrimeField methodsFor: 'random' stamp: 'len 10/10/2016 09:00'!
atRandom: aRandom bits: bitSize
	^ self atRandom: aRandom! !

!PrimeField methodsFor: 'accessing' stamp: 'len 8/10/2016 06:02'!
characteristic
	^ self modulus! !

!PrimeField methodsFor: 'private' stamp: 'len 8/10/2016 06:01'!
computePrimitiveRoot
	"When the receiver is a field Z/<p>, answer a primitive root modulo p."
	| m a order primeFactors |
	m _ self modulus.
	order _ m - 1.
	primeFactors _ order factors asSet.
	a _ 2.
	[primeFactors anySatisfy: [:pi| (a raisedTo: order / pi modulo: m) = 1]]
		whileTrue:
			[a _ a + 1.
			a >= m ifTrue: [self error: 'no primitive element, the modulus is not prime']].
	^ a! !

!PrimeField methodsFor: 'private' stamp: 'len 8/10/2016 06:16'!
elementClass
	^ ModularInteger! !

!PrimeField methodsFor: 'accessing' stamp: 'len 8/10/2016 06:04'!
primitiveRoot
	"When the receiver is a field Z/<p>, answer a primitive root modulo p."
	^ properties at: #primitiveRoot ifAbsentPut: [self computePrimitiveRoot]! !

!PrimeField methodsFor: 'accessing' stamp: 'len 8/10/2016 06:03'!
size
	^ self modulus! !

!PrimeField methodsFor: 'tuples' stamp: 'len 8/10/2016 06:05'!
tupleClass
	self flag: #fix.
	^ self modulus = 2 ifTrue: [^ BitTuple] ifFalse: [Tuple] "ModularTuple"! !

!PrimeField class methodsFor: 'as yet unclassified' stamp: 'len 8/10/2016 06:09'!
new: aPrime
	^ self by: ZZ * aPrime! !

!AlgebraicExtension methodsFor: 'converting' stamp: 'len 3/19/2016 03:18'!
asQuotientRing
	^ properties at: #quotientRing ifAbsentPut: [self baseField polynomials mod: self polynomial]! !

!AlgebraicExtension methodsFor: 'converting' stamp: 'len 6/4/2016 17:51'!
asVectorSpace
	^ self as: AlgebraicExtensionSpace! !

!AlgebraicExtension methodsFor: 'random' stamp: 'len 4/18/2016 04:01'!
atRandom: aRandomGenerator
	^ self asQuotientRing atRandom: aRandomGenerator! !

!AlgebraicExtension methodsFor: 'random' stamp: 'len 4/19/2016 22:54'!
atRandom: aRandomGenerator bits: bitSize
	^ self asQuotientRing atRandom: aRandomGenerator bits: bitSize! !

!AlgebraicExtension methodsFor: 'morphisms' stamp: 'len 10/5/2016 09:51'!
automorphisms
	"Answer the Galous group of the receiver (assuming the receiver is a Galois extension)."
	self isFinite ifTrue: [^ Group compositive generators: {self frobenius}].
	self flag: #fix. "This is actually isomorphic to the Galois group, not the actual Galois group, it should act on elements of the extension and it's not the full symmetric group."
	^ SymmetricGroup on: (self embeddings collect: [:each| each value: self x])! !

!AlgebraicExtension methodsFor: 'accessing' stamp: 'len 3/19/2016 03:21'!
baseField
	^ self polynomial scalars! !

!AlgebraicExtension methodsFor: 'accessing' stamp: 'len 3/19/2016 04:18'!
characteristic
	^ self baseField characteristic! !

!AlgebraicExtension methodsFor: 'elements-operations' stamp: 'len 6/21/2016 05:39'!
characteristicPolynomialOf2: anElement
	| x |
	x _ AlgebraicNumbers new polynomials x.
	^ (self embeddings product: [:each| x - (each value: anElement)]) as: self baseField polynomials! !

!AlgebraicExtension methodsFor: 'elements-operations' stamp: 'len 6/4/2016 17:39'!
characteristicPolynomialOf: anElement
	^ (self asVectorSpace endomorphisms evaluating: [:x| x * anElement]) characteristicPolynomial! !

!AlgebraicExtension methodsFor: 'accessing' stamp: 'len 3/18/2016 22:31'!
degree
	^ self polynomial degree! !

!AlgebraicExtension methodsFor: 'iterating' stamp: 'len 3/19/2016 04:22'!
do: aBlock
	self asQuotientRing do: aBlock! !

!AlgebraicExtension methodsFor: 'morphisms' stamp: 'len 9/26/2016 16:47'!
embed: aNumber
	"This is the field homomorphism that embeds the base field into the receiver."
	^ self asQuotientRing project: (self asQuotientRing ideal ring embed: aNumber)! !

!AlgebraicExtension methodsFor: 'morphisms' stamp: 'len 10/10/2016 08:55'!
embedding
	"Answer the field homomorphism that embeds the base field into the receiver."
	^ properties at: #embedding ifAbsentPut: [(self baseField to: self evaluating: [:x| self embed: x]) name: 'i']! !

!AlgebraicExtension methodsFor: 'morphisms' stamp: 'len 6/4/2016 19:30'!
embeddings
	"Answer the n distinct embeddings of the receiver in the algebraic closure of the base field, where n is the degree of the receiver. In the case of number fields, the embeddings go to the complex algebraic numbers.
	When the receiver is a Galois extension, the embeddings send each element to one of its conjugates, and their images are the same."
	^ properties at: #embeddings ifAbsentPut: [self embeddingsIn: self baseField algebraicClosure]! !

!AlgebraicExtension methodsFor: 'morphisms' stamp: 'len 8/31/2016 05:43'!
embeddingsIn: aField
	^ (self polynomial rootsIn: aField)
		collect: [:x| self to: aField evaluating: [:alpha| alpha representative value: x]]! !

!AlgebraicExtension methodsFor: 'testing' stamp: 'len 3/18/2016 22:34'!
includes: anObject
	^ self asQuotientRing includes: anObject! !

!AlgebraicExtension methodsFor: 'testing' stamp: 'len 3/19/2016 04:07'!
isField
	^ true! !

!AlgebraicExtension methodsFor: 'testing' stamp: 'len 5/14/2016 06:54'!
isGlobalField
	^ true! !

!AlgebraicExtension methodsFor: 'elements-operations' stamp: 'len 6/21/2016 05:38'!
minimalPolynomialOf2: anElement
	^ (self preferedEmbedding value: anElement) minimalPolynomial! !

!AlgebraicExtension methodsFor: 'elements-operations' stamp: 'len 6/4/2016 23:56'!
minimalPolynomialOf: anElement
	^ (self asVectorSpace endomorphisms evaluating: [:x| x * anElement]) minimalPolynomial
"	| x |
	x _ self polynomials x.
	^ anElement conjugates product: [:each| x - each] :: as: self baseField polynomials"! !

!AlgebraicExtension methodsFor: 'elements-operations' stamp: 'len 6/21/2016 05:29'!
normOf: anElement
	"Answer the absolute norm of anElement."
	| f |
	f _ self minimalPolynomialOf: anElement.
	^ f independentCoefficient / f leadingCoefficient * (f degree even ifTrue: [1] ifFalse: [-1])! !

!AlgebraicExtension methodsFor: 'accessing' stamp: 'len 3/18/2016 22:41'!
one
	^ self embed: self baseField one! !

!AlgebraicExtension methodsFor: 'accessing' stamp: 'len 3/18/2016 22:31'!
polynomial
	^ properties at: #polynomial! !

!AlgebraicExtension methodsFor: 'accessing-private' stamp: 'len 5/12/2016 10:04'!
polynomial: aPolynomial
	properties at: #polynomial put: aPolynomial! !

!AlgebraicExtension methodsFor: 'printing' stamp: 'len 10/5/2016 09:50'!
printOn: aStream
	(properties includesKey: #name) ifTrue: [^ super printOn: aStream].
	aStream print: self baseField; nextPut: $(; print: self polynomial; nextPut: $)! !

!AlgebraicExtension methodsFor: 'accessing' stamp: 'len 3/19/2016 04:24'!
size
	^ self baseField size ** self degree! !

!AlgebraicExtension methodsFor: 'elements-operations' stamp: 'len 6/4/2016 23:54'!
symmetricFunction: i of: anElement
	^ self notYetImplemented! !

!AlgebraicExtension methodsFor: 'elements-operations' stamp: 'len 6/21/2016 05:30'!
traceOf: anElement
	"Answer the absolute trace of anElement."
	| f |
	f _ self minimalPolynomialOf: anElement.
	^ (f coefficientAtDegree: f degree - 1) / f leadingCoefficient! !

!AlgebraicExtension methodsFor: 'accessing' stamp: 'len 9/26/2016 16:47'!
x
	"Answer the transcendental element of the receiver."
	^ self asQuotientRing project: self asQuotientRing ideal ring x! !

!AlgebraicExtension class methodsFor: 'instance creation' stamp: 'len 5/12/2016 10:05'!
polynomial: aPolynomial
	"Answer a new algebraic field extension K(f) where f is the given polynomial in K[x]. The polynomial must be irreducible, otherwise there would be zero divisors."
	^ self new polynomial: aPolynomial! !

!NumberField methodsFor: 'accessing' stamp: 'len 1/11/2016 02:03'!
adjoint
	^ adjoint! !

!NumberField methodsFor: 'accessing-private' stamp: 'len 1/11/2016 02:03'!
adjoint: anAlgebraicNumber
	adjoint _ anAlgebraicNumber! !

!NumberField methodsFor: 'operations' stamp: 'len 1/10/2016 22:34'!
archimedeanPlaces
	^ self notYetImplemented! !

!NumberField methodsFor: 'accessing' stamp: 'len 7/15/2016 18:35'!
baseField
	^ QQ! !

!NumberField methodsFor: 'accessing' stamp: 'len 1/10/2016 22:35'!
basis
	^ self integralBasis! !

!NumberField methodsFor: 'accessing' stamp: 'len 1/11/2016 02:22'!
degree
	^ adjoint minimalPolynomial degree! !

!NumberField methodsFor: 'accessing' stamp: 'len 3/19/2016 09:14'!
discriminant
	"The discriminant of an integral basis is independent of the choice of basis and it's called the discriminant of the field K and denoted d(K)."
	^ self integralBasis discriminant! !

!NumberField methodsFor: 'operations' stamp: 'len 1/10/2016 21:52'!
integers
	"Answer the ring of integers of the receiver."
	^ self notYetImplemented! !

!NumberField methodsFor: 'accessing' stamp: 'len 1/11/2016 03:48'!
integralBasis
	^ self notYetImplemented "COHEN 6.1.8"! !

!NumberField methodsFor: 'testing' stamp: 'len 1/10/2016 23:15'!
isQuadraticField
	^ self degree = 2! !

!NumberField methodsFor: 'testing' stamp: 'len 9/26/2016 17:48'!
isTotallyImaginary
	"Answer true if no embedding into the complex numbers has image contained in the real numbers."
	^ self signature first = 0! !

!NumberField methodsFor: 'testing' stamp: 'len 9/26/2016 17:47'!
isTotallyReal
	"Answer true if every embedding into the complex numbers has image contained in the real numbers."
	^ self signature second = 0! !

!NumberField methodsFor: 'operations' stamp: 'len 1/10/2016 22:34'!
nonArchimedeanPlaces
	^ self notYetImplemented! !

!NumberField methodsFor: 'accessing' stamp: 'len 3/19/2016 09:17'!
polynomial
	^ self adjoint minimalPolynomial! !

!NumberField methodsFor: 'morphisms' stamp: 'len 6/4/2016 21:16'!
preferedEmbedding
	^ self embeddings detect: [:one| (one value: self x) = adjoint]! !

!NumberField methodsFor: 'printing' stamp: 'len 4/21/2016 00:06'!
printOn: aStream
	aStream print: self baseField; nextPut: $(; print: adjoint; nextPut: $)! !

!NumberField methodsFor: 'morphisms' stamp: 'len 4/17/2016 06:43'!
realEmbeddings
	^ self embeddingsIn: RealAlgebraicNumbers new! !

!NumberField methodsFor: 'operations' stamp: 'len 1/11/2016 03:53'!
regulator
	^ self notYetImplemented! !

!NumberField methodsFor: 'accessing' stamp: 'len 3/19/2016 09:33'!
signature
	"Answer the signature (r1,r2) of the receiver, i.e. r1 the number of embeddings whose image is real, and 2*r2 the number of non-real complex embeddings."
	^ self polynomial signature! !

!NumberField class methodsFor: 'instance creation' stamp: 'len 1/11/2016 02:03'!
adjoint: anAlgebraicNumber
	^ self new adjoint: anAlgebraicNumber! !

!NumberField class methodsFor: 'instance creation' stamp: 'len 9/26/2016 17:56'!
polynomial: aPolynomial
	^ self adjoint: (aPolynomial rootsIn: CC) anyOne! !

!QuadraticField class methodsFor: 'instance creation' stamp: 'len 5/20/2016 02:43'!
sqrt: anInteger
	^ self adjoint: (AlgebraicNumber sqrt: anInteger)! !

!AlgebraicNumbers methodsFor: 'comparing' stamp: 'len 12/26/2015 20:05'!
= anObject
	^ anObject class == self class! !

!AlgebraicNumbers methodsFor: 'comparing' stamp: 'len 4/19/2016 21:38'!
> aDomain
	^ (aDomain isKindOf: Rationals) or: [(aDomain isKindOf: Integers) or: [aDomain isKindOf: RealAlgebraicNumbers]]! !

!AlgebraicNumbers methodsFor: 'accessing' stamp: 'len 11/22/2015 01:41'!
characteristic
	^ 0! !

!AlgebraicNumbers methodsFor: 'morphisms' stamp: 'len 10/4/2016 08:56'!
conjugation
	^ self to: self evaluating: [:x| x conjugated]! !

!AlgebraicNumbers methodsFor: 'comparing' stamp: 'len 12/26/2015 20:05'!
hash
	^ self class hash! !

!AlgebraicNumbers methodsFor: 'testing' stamp: 'len 12/26/2015 19:57'!
includes: anObject
	^ anObject isInteger or: [anObject isFraction or: [anObject isKindOf: Complex]]! !

!AlgebraicNumbers methodsFor: 'testing' stamp: 'len 12/15/2015 19:31'!
isAlgebraicallyClosed
	^ true! !

!AlgebraicNumbers methodsFor: 'testing' stamp: 'len 2/11/2016 22:19'!
isComplex
	^ true! !

!AlgebraicNumbers methodsFor: 'accessing' stamp: 'len 3/6/2016 21:08'!
one
	^ 1! !

!AlgebraicNumbers methodsFor: 'printing' stamp: 'len 6/8/2016 21:05'!
printOn: aStream
	aStream nextPut: Character CC! !

!AlgebraicNumbers methodsFor: 'accessing' stamp: 'len 4/29/2016 07:38'!
size
	^ Aleph new: 0! !

!AlgebraicNumbers methodsFor: 'accessing' stamp: 'len 3/6/2016 21:08'!
zero
	^ 0! !

!RealAlgebraicNumbers methodsFor: 'comparing' stamp: 'len 6/1/2016 23:58'!
< aDomain
	^ ((aDomain isKindOf: Rationals) or: [aDomain isKindOf: Integers]) or: [super < aDomain]! !

!RealAlgebraicNumbers methodsFor: 'comparing' stamp: 'len 11/10/2015 23:37'!
= anObject
	^ anObject class == self class! !

!RealAlgebraicNumbers methodsFor: 'comparing' stamp: 'len 4/19/2016 21:39'!
> aDomain
	^ (aDomain isKindOf: Rationals) or: [aDomain isKindOf: Integers]! !

!RealAlgebraicNumbers methodsFor: 'operations' stamp: 'len 4/17/2016 06:45'!
algebraicClosure
	^ AlgebraicNumbers new! !

!RealAlgebraicNumbers methodsFor: 'accessing' stamp: 'len 11/5/2015 17:35'!
characteristic
	^ 0! !

!RealAlgebraicNumbers methodsFor: 'comparing' stamp: 'len 12/17/2015 03:54'!
hash
	^ self class hash! !

!RealAlgebraicNumbers methodsFor: 'testing' stamp: 'len 1/10/2016 23:37'!
includes: anObject
	^ (anObject isKindOf: RealAlgebraicNumber) or: [anObject isFraction or: [anObject isInteger]]! !

!RealAlgebraicNumbers methodsFor: 'testing' stamp: 'len 1/6/2016 04:07'!
isCountable
	^ true "this is the algebraic reals"! !

!RealAlgebraicNumbers methodsFor: 'testing' stamp: 'len 12/17/2015 03:55'!
isFinite
	^ false! !

!RealAlgebraicNumbers methodsFor: 'testing' stamp: 'len 2/11/2016 22:19'!
isReal
	^ true! !

!RealAlgebraicNumbers methodsFor: 'elements' stamp: 'len 2/11/2016 19:36'!
one
	^ 1! !

!RealAlgebraicNumbers methodsFor: 'printing' stamp: 'len 6/8/2016 21:05'!
printOn: aStream
	aStream nextPut: Character RR! !

!RealAlgebraicNumbers methodsFor: 'accessing' stamp: 'len 4/29/2016 07:38'!
size
	^ Aleph new: 0! !

!RealAlgebraicNumbers methodsFor: 'elements' stamp: 'len 2/11/2016 19:36'!
zero
	^ 0! !

!PolynomialRing methodsFor: 'operations' stamp: 'len 12/5/2015 23:52'!
* aPolynomialOrArray
	^ (self includes: aPolynomialOrArray)
			ifTrue: [PolynomialIdeal on: self generators: {aPolynomialOrArray}]
			ifFalse: [PolynomialIdeal on: self generators: aPolynomialOrArray]! !

!PolynomialRing methodsFor: 'comparing' stamp: 'len 7/19/2016 01:12'!
< aDomain
	(aDomain isKindOf: PolynomialRing) ifFalse: [^ false].
	self rank = aDomain rank ifFalse: [^ false].
	self scalars < aDomain scalars ifFalse: [^ false].
	^ true! !

!PolynomialRing methodsFor: 'comparing' stamp: 'len 8/24/2016 22:03'!
<= aDomain
	"Answer true if the receiver is included in the argument, i.e. it's a subring of the argument."
	(aDomain isKindOf: PolynomialRing) ifFalse: [^ false].
	self rank = aDomain rank ifFalse: [^ false].
	self scalars <= aDomain scalars ifFalse: [^ false].
	^ true! !

!PolynomialRing methodsFor: 'comparing' stamp: 'len 7/19/2016 01:12'!
= anObject
	self == anObject ifTrue: [^ true].
	^ (anObject isKindOf: PolynomialRing) and: [anObject scalars = scalars and: [anObject rank = rank]]! !

!PolynomialRing methodsFor: 'comparing' stamp: 'len 7/19/2016 01:12'!
> aDomain
	(aDomain isKindOf: PolynomialRing) ifFalse: [^ false].
	self rank = aDomain rank ifFalse: [^ false].
	self scalars > aDomain scalars ifFalse: [^ false].
	^ true! !

!PolynomialRing methodsFor: 'comparing' stamp: 'len 7/19/2016 01:12'!
>= aDomain
	(aDomain isKindOf: PolynomialRing) ifFalse: [^ false].
	self rank = aDomain rank ifFalse: [^ false].
	self scalars >= aDomain scalars ifFalse: [^ false].
	^ true! !

!PolynomialRing methodsFor: 'comparing' stamp: 'len 8/30/2016 07:09'!
~ aPolynomialRing
	"Answer true if the receiver is canonically isomorphic to the argument."
	"R[x][y] ~ R[x,y]"
	self notYetImplemented! !

!PolynomialRing methodsFor: 'converting' stamp: 'len 5/21/2016 00:16'!
asMultivariate
	| answer |
	self isUnivariate ifFalse: [^ self].
	answer _ self scalars scalars polynomialsIn: self scalars rank + 1.
	(self indeterminateNames notNil and: [self scalars indeterminateNames notNil])
		ifTrue: [answer indeterminateNames: self scalars indeterminateNames, self indeterminateNames].
	^ answer! !

!PolynomialRing methodsFor: 'converting' stamp: 'len 5/20/2016 23:16'!
asUnivariate
	self isUnivariate ifTrue: [^ self].
	self indeterminateNames notNil
		ifTrue: [^ self scalars polynomialsIn: self indeterminateNames allButLast :: polynomialsIn: {self indeterminateNames last}].
	^ self scalars polynomialsIn: self rank - 1 :: polynomials! !

!PolynomialRing methodsFor: 'converting' stamp: 'len 5/23/2016 04:09'!
asUnivariateIn: anIndeterminate
	(self indeterminates includes: anIndeterminate) ifFalse: [^ self error: 'indeterminate not found'].
	anIndeterminate = self indeterminates last ifFalse: [^ self error: 'bad indeterminate'].
	^ self asUnivariate! !

!PolynomialRing methodsFor: 'converting' stamp: 'len 6/11/2016 22:30'!
asVectorSpaceMaxDegree: n
	^ PolynomialSpace new polynomials: self; degree: n! !

!PolynomialRing methodsFor: 'random' stamp: 'len 7/5/2016 02:51'!
atRandom: aRandom bits: bitSize
	^ self atRandom: aRandom bits: bitSize maxDegree: (bitSize**(1/rank) min: bitSize - 1) truncated! !

!PolynomialRing methodsFor: 'random' stamp: 'len 7/5/2016 02:48'!
atRandom: aRandom bits: bitSize maxDegree: d
	| answer term n |
	self isUnivariate
		ifTrue: [^ self coefficients: (scalars ** (d+1) atRandom: aRandom bits: bitSize)].
	answer _ self zero.
	n _ 2**rank.
	n timesRepeat:
		[term _ ((1 to: d) product: [:i| self x: (rank atRandom: aRandom) to: (2 atRandom: aRandom) - 1]) * (scalars atRandom: aRandom bits: bitSize/(rank*d)).
		answer _ answer + term].
	^ answer! !

!PolynomialRing methodsFor: 'random' stamp: 'len 8/10/2016 06:28'!
atRandom: aRandom maxDegree: d
	self isUnivariate ifFalse: [^ self notYetImplemented].
	^ self coefficients: (self scalars ** (d+1) evaluating: [:i| self scalars atRandom: aRandom])! !

!PolynomialRing methodsFor: 'random' stamp: 'len 7/5/2016 02:29'!
atRandomBits: bitSize maxDegree: d
	^ Random withDefaultDo: [:aRandom| self atRandom: aRandom bits: bitSize maxDegree: d]! !

!PolynomialRing methodsFor: 'random' stamp: 'len 2/24/2016 23:33'!
atRandomDegree: d
	"Answer a polynomial of degree d choosen at random with a uniform distribution."
	self isUnivariate ifFalse: [^ self notYetImplemented].
	^ self coefficients: (self scalars ** d) atRandom, self scalars one! !

!PolynomialRing methodsFor: 'random' stamp: 'len 2/25/2016 00:18'!
atRandomMaxDegree: d
	"Answer a polynomial of degree at most d choosen at random with a uniform distribution."
	self isUnivariate ifFalse: [^ self notYetImplemented].
	^ self coefficients: (self scalars ** (d+1)) atRandom! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 11/5/2015 17:35'!
characteristic
	^ scalars characteristic! !

!PolynomialRing methodsFor: 'examples' stamp: 'len 3/1/2016 22:32'!
chebyshevOfOrder: n
	"Answer the n-th Chebyshev polynomial."

	| answer c m k |
	n <= 0 ifTrue: [^ self one].
	c _ (1 bitShift: n - 1).
	m _ 4.
	k _ n - 1.
	answer _ self coefficient: scalars one * c degree: n.
	n - 1 to: 1 by: -2 do: [ :each |
		c _ ((c * (each + 1) * each) / (k * m)) negated.
		m _ m + 4.
		k _ k - 1.
		c = 0 ifFalse: [answer _ answer + (self coefficient: scalars one * c degree: each - 1)]].
	^ answer! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 7/9/2016 03:28'!
coefficient: aNumber degree: anInteger
	^ self coefficients: (self scalars tuple: {aNumber}) >>> anInteger! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 10/6/2016 15:35'!
coefficient: aNumber monomial: aMonomial
	| coefficients |
	self isUnivariate
		ifFalse:
			[coefficients _ SparseTuple zero: self scalars zero.
			coefficients at: aMonomial put: aNumber]
		ifTrue:
			[| n zero |
			n _ aMonomial degree + 1.
			zero _ aNumber zero.
			coefficients _ self scalars tuple: n evaluating: [:i| i=n ifTrue: [aNumber] ifFalse: [zero]]].
	^ (self polynomialClass coefficients: coefficients) parent: self! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 5/20/2016 03:38'!
coefficient: aNumber x: anIndeterminate to: anInteger
	| i |
	i _ anIndeterminate isInteger
		ifTrue: [anIndeterminate]
		ifFalse: [self indeterminateNames indexOf: anIndeterminate ifAbsent: [^ self error: 'unknown indeterminate']].
	^ self coefficient: aNumber monomial: (Monomial x: i to: anInteger)! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 10/6/2016 15:36'!
coefficients: aTuple
	| tuple |
	self isUnivariate ifFalse: [^ (MultivariatePolynomial coefficients: aTuple) parent: self].
	tuple _ aTuple class = self scalars tupleClass
		ifTrue: [aTuple]
		ifFalse: [(aTuple isKindOf: SparseTuple)
			ifTrue:
				[| n |
				n _ 0.
				aTuple keysDo: [:each| n _ n max: each degree].
				self scalars tuple: n+1 evaluating: [:i| aTuple at: (Monomial x: 1 to: i-1)]]
			ifFalse: [self scalars tuple: aTuple]].
	^ (UnivariatePolynomial coefficients: tuple) parent: self! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 7/9/2016 03:31'!
constant: aNumber
	self isUnivariate ifTrue: [^ self coefficients: (self scalars tuple: {aNumber})].
	^ self coefficient: aNumber monomial: Monomial identity! !

!PolynomialRing methodsFor: 'examples' stamp: 'len 6/1/2016 21:03'!
continuantOfOrder: n
	"Answer the continuant polynomial of order n."
	"(Rationals new polynomialsIn: 3) continuantOfOrder: 3"

	n = 0 ifTrue: [^ self one].
	n = 1 ifTrue: [^ self x: 1].
	^ (self continuantOfOrder: n - 1) * (self x: n) + (self continuantOfOrder: n - 2)! !

!PolynomialRing methodsFor: 'examples' stamp: 'len 11/28/2015 07:25'!
cyclotomic: n
	"Answer the n-th cyclotomic polynomial."
	| one x answer numerator denominator |
	one _ self one.
	x _ self x.
	n = 1 ifTrue: [^ x - one].
	n isPrime
		ifTrue: [answer _ one. n-1 timesRepeat: [answer _ answer * x + one]. ^ answer].
	numerator _ one.
	denominator _ one.
	n divisorsDo: [:d| | mu |
		mu _ (n/d) moebius.
		mu = 1 ifTrue: [numerator _ numerator * (x**d - one)].
		mu = -1 ifTrue: [denominator _ denominator * (x**d - one)]].
	^ numerator // denominator! !

!PolynomialRing methodsFor: 'examples' stamp: 'len 11/26/2015 03:44'!
determinantOfOrder: n
	"Answer the determinant polynomial of order n."
	"Polynomial determinantOfOrder: 3"

	n = 0 ifTrue: [^ self zero].
	^ (self ** (n@n) evaluating: [:i :j| self x: n * (j - 1) + i]) determinant! !

!PolynomialRing methodsFor: 'iterating' stamp: 'len 12/21/2015 23:09'!
do: aBlock
	| k |
	self scalars isFinite ifFalse: [^ self notYetImplemented].
	self isUnivariate ifFalse: [^ self notYetImplemented].
	aBlock value: self zero.
	k _ 1.
	[(self scalars ** k) do: [:t| t last isZero ifFalse: [aBlock value: (self coefficients: t)]].
	k _ k + 1] repeat! !

!PolynomialRing methodsFor: 'morphisms' stamp: 'len 1/2/2016 04:13'!
embed: aScalar
	^ self constant: aScalar! !

!PolynomialRing methodsFor: 'morphisms' stamp: 'len 10/10/2016 08:56'!
embedding
	"Answer the embedding map from the base ring into the receiver."
	^ properties at: #embedding ifAbsentPut: [(RingHomomorphism from: scalars to: self evaluating: [:x| self constant: x]) name: 'i']! !

!PolynomialRing methodsFor: 'operations' stamp: 'len 10/4/2016 09:02'!
expansion: anInteger
	"Answer the canonical embedding into the polynomials in n+anInteger indeterminates.
	Perhaps this should be called 'embedding' instead of 'expansion'."
	| codomain |
	anInteger > 0 ifFalse: [self error: 'out of bounds'].
	codomain _ (self scalars polynomialsIn: self rank + anInteger).
	^ self to: codomain evaluating: [:aPolynomial| aPolynomial as: codomain]! !

!PolynomialRing methodsFor: 'examples' stamp: 'len 11/6/2015 03:45'!
fibonacciOfOrder: n
	"Answer the n-th Fibonacci polynomial."
	"Polynomial fibonacciOfOrder: 3"

	n negative ifTrue: [^ self notYetImplemented].
	n = 0 ifTrue: [^ self zero].
	n = 1 ifTrue: [^ self one].
	^ (self fibonacciOfOrder: n - 1) - (self x * (self fibonacciOfOrder: n - 2))! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 8/10/2016 06:26'!
findIrreducibleOfDegree: n
	| one x p random |
	one _ scalars one.
	x _ self x.
	1 to: n-1 do: [:k|
		p _ x**n + (x**k) + one.
		p isIrreducible ifTrue: [^ p]].
	"self error: 'irreducible polynomial not found'"
	random _ Random new.
	[(p _ self atRandom: random maxDegree: n) degree = n and: [p isIrreducible]] whileFalse.
	^ p! !

!PolynomialRing methodsFor: 'operations' stamp: 'len 11/24/2015 05:32'!
fractions
	scalars isField ifFalse: [^ self error: 'scalars are not a field'].
	^ RationalFunctions polynomials: self! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 10/2/2016 10:34'!
generators
	^ (1 to: self rank) collect: [:i| self x: i]! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 6/4/2016 05:13'!
has: anIndeterminate
	^ self indeterminates includes: anIndeterminate! !

!PolynomialRing methodsFor: 'comparing' stamp: 'len 6/28/2016 09:23'!
hash
	^ scalars hash + rank! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 6/1/2016 23:50'!
includes: anObject
	^ (anObject isKindOf: Polynomial) and: [anObject species <= self]! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 6/4/2016 05:12'!
indeterminate
	"Answer the univariate indeterminate."
	^ 1! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 5/20/2016 23:05'!
indeterminateNames
	^ properties at: #indeterminateNames ifAbsent: [self isUnivariate ifTrue: [#(x)]]! !

!PolynomialRing methodsFor: 'accessing-private' stamp: 'len 5/20/2016 03:28'!
indeterminateNames: aCollection
	properties at: #indeterminateNames put: aCollection! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 6/4/2016 05:12'!
indeterminates
	^ 1 to: rank! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 12/19/2015 03:38'!
interpolate: aCollection
	"Answer a polynomial f that for each pair k -> v of the argument evaluates to f(k) = v.
	(Lagrange polynomials.)"
	| answer x |
	self isUnivariate ifFalse: [^ self error: 'not yet implemented'].
	x _ self x.
	answer _ self zero.
	aCollection do: [:a| | p |
		p _ self one.
		aCollection do: [:b|
			a ~~ b ifTrue: [p _ p * ((x - b key) / (a key - b key))]].
		answer _ p * a value + answer].
	^ answer! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 11/4/2015 21:52'!
isCommutative
	^ scalars isCommutative! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 11/4/2015 21:51'!
isEuclidean
	^ scalars isEuclidean! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 11/29/2015 00:16'!
isGCDDomain
	^ scalars isField or: [scalars isUFD]! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 11/29/2015 00:26'!
isIntegralDomain
	scalars isIntegralDomain ifTrue: [^ true].
	^ super isIntegralDomain! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 11/29/2015 00:27'!
isNoetherian
	scalars isNoetherian ifTrue: [^ true]. "Hilber's basis theorem"
	^ super isNoetherian! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 12/8/2015 06:10'!
isPID
	"Univariate polynomials over a field are principal ideal domains."
	^ scalars isField and: [self isUnivariate]! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 11/4/2015 21:51'!
isRing
	^ scalars isRing! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 11/29/2015 00:26'!
isUFD
	scalars isUFD ifTrue: [^ true]. "proof based on Gauss lemma"
	^ super isUFD! !

!PolynomialRing methodsFor: 'testing' stamp: 'len 7/9/2016 03:25'!
isUnivariate
	^ rank = 1! !

!PolynomialRing methodsFor: 'operations' stamp: 'len 12/28/2015 20:20'!
modPrime: anObject
	| answer |
	self assert: self scalars isField.
	answer _ self mod: anObject.
	answer properties
		at: #isIntegralDomain put: true;
		at: #isNumberField put: true;
		at: #isField put: true.
	^ answer! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 6/26/2016 01:42'!
monomial: aMonomial
	^ self coefficient: self scalars one monomial: aMonomial! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 10/6/2016 15:35'!
new
	^ self polynomialClass new parent: self! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 7/9/2016 03:01'!
newFrom: aPolynomial
	(aPolynomial indeterminates allSatisfy: [:each| self has: each])
		ifFalse: [self halt].
	^ self coefficients:
		(((aPolynomial isKindOf: UnivariatePolynomial) and: [self isUnivariate not])
			ifTrue: [aPolynomial asSparsePolynomial coefficients]
			ifFalse: [aPolynomial coefficients])! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 11/3/2015 20:21'!
one
	^ self constant: scalars one! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 7/3/2016 04:18'!
ordering
	^ properties at: #ordering ifAbsentPut: [MonomialOrdering tlex: self rank]! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 7/2/2016 23:41'!
ordering: aMonomialOrdering
	| ordering |
	ordering _ aMonomialOrdering isSymbol
		ifTrue: [MonomialOrdering perform: (aMonomialOrdering,':') asSymbol with: self rank]
		ifFalse: [aMonomialOrdering].
	properties at: #ordering put: ordering! !

!PolynomialRing methodsFor: 'converting' stamp: 'len 4/24/2016 06:37'!
over: aRing
	^ self copy scalars: aRing! !

!PolynomialRing methodsFor: 'private' stamp: 'len 7/19/2016 01:08'!
polynomialClass
	^ properties at: #polynomialClass ifAbsent: [self isUnivariate ifTrue: [UnivariatePolynomial] ifFalse: [MultivariatePolynomial]]! !

!PolynomialRing methodsFor: 'printing' stamp: 'len 4/21/2016 00:10'!
printOn: aStream
	aStream print: scalars.
	aStream nextPut: $[.
	self ordering indeterminates
		do: [:i| aStream print: (self x: i)]
		separatedBy: [aStream nextPut: $,].
	aStream nextPut: $]! !

!PolynomialRing methodsFor: 'operations' stamp: 'len 9/26/2016 06:46'!
proj
	"Answer the projective space associated to the receiver, Proj(R)."
	^ ProjectiveSpace coordinateRing: self! !

!PolynomialRing methodsFor: 'morphisms' stamp: 'len 10/4/2016 09:03'!
projection: anInteger
	"Answer the canonical projection on the polynomials in anInteger indeterminates."
	| codomain |
	(anInteger between: 0 and: self rank) ifFalse: [self error: 'out of bounds'].
	codomain _ (self scalars polynomialsIn: anInteger).
	^ self to: codomain evaluating: [:aPolynomial| aPolynomial as: codomain]! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 6/4/2016 05:13'!
rank
	"The rank of a polynomial ring is the number of indeterminates. Univariate polynomials have rank 1."
	^ rank! !

!PolynomialRing methodsFor: 'accessing-private' stamp: 'len 6/4/2016 05:12'!
rank: anInteger
	rank _ anInteger! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 11/2/2015 16:09'!
scalars
	^ scalars! !

!PolynomialRing methodsFor: 'accessing-private' stamp: 'len 11/9/2015 04:16'!
scalars: aRing
	scalars _ aRing! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 4/24/2016 02:59'!
size
	^ Aleph new * self scalars size! !

!PolynomialRing methodsFor: 'operations' stamp: 'len 9/26/2016 06:46'!
spec
	"Answer the spectrum of the receiver, Spec(R)."
	^ AffineSpace coordinateRing: self! !

!PolynomialRing methodsFor: 'examples' stamp: 'len 8/2/2016 05:28'!
symmetric: r
	"Answer the r-th symmetric polynomial whose terms are all monomials formed by the product of r distinct indeterminates."
	^ ((1 to: self rank) combinations: r) sum: [:each| each product: [:i| self x: i]]! !

!PolynomialRing methodsFor: 'accessing' stamp: 'len 7/17/2016 23:54'!
valuation
	^ self scalars isField ifTrue: [Function from: self to: NN evaluating: [:f| f degree]]! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 5/20/2016 03:34'!
x
	^ self x: self indeterminates first! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 3/26/2016 02:44'!
x: anIndeterminate
	^ self x: anIndeterminate to: 1! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 3/26/2016 02:44'!
x: anIndeterminate to: n
	^ self coefficient: scalars one x: anIndeterminate to: n! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 4/6/2016 07:03'!
xTo: degree
	^ self x: self indeterminate to: degree! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 5/20/2016 03:34'!
y
	^ self x: self indeterminates second! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 5/20/2016 03:34'!
z
	^ self x: self indeterminates third! !

!PolynomialRing methodsFor: 'elements' stamp: 'len 3/23/2016 05:21'!
zero
	^ self constant: self scalars zero! !

!PolynomialRing class methodsFor: 'instance creation' stamp: 'len 6/4/2016 05:11'!
new: anInteger over: aRing
	^ self new scalars: aRing; rank: anInteger! !

!PolynomialRing class methodsFor: 'instance creation' stamp: 'len 5/20/2016 03:25'!
new: anInteger over: aRing ordering: aMonomialOrdering
	^ self new rank: anInteger; scalars: aRing; ordering: aMonomialOrdering! !

!LaurentSeriesRing methodsFor: 'as yet unclassified' stamp: 'len 8/4/2016 03:53'!
printOn: aStream
	aStream print: scalars; nextPutAll: '((x))'! !

!PowerSeriesRing methodsFor: 'accessing' stamp: 'len 4/15/2016 20:49'!
one
	^ PowerSeries fromPolynomial: self scalars polynomials one! !

!PowerSeriesRing methodsFor: 'printing' stamp: 'len 4/21/2016 00:10'!
printOn: aStream
	aStream print: scalars; nextPutAll: '[[x]]'! !

!PowerSeriesRing methodsFor: 'accessing' stamp: 'len 4/15/2016 20:36'!
scalars
	^ scalars! !

!PowerSeriesRing methodsFor: 'accessing-private' stamp: 'len 4/15/2016 20:36'!
scalars: aRing
	scalars _ aRing! !

!PowerSeriesRing methodsFor: 'accessing' stamp: 'len 4/15/2016 20:49'!
zero
	^ PowerSeries fromPolynomial: self scalars polynomials zero! !

!PowerSeriesRing class methodsFor: 'instance creation' stamp: 'len 4/15/2016 20:36'!
over: aRing
	^ self new scalars: aRing! !

!PuiseuxSeriesRing methodsFor: 'as yet unclassified' stamp: 'len 8/4/2016 03:53'!
printOn: aStream
	aStream print: scalars; nextPutAll: '<<x>>'! !

!SymmetricPolynomialRing methodsFor: 'as yet unclassified' stamp: 'len 8/2/2016 09:50'!
generators
	^ (1 to: self rank) collect: [:i| polynomials symmetric: i]! !

!Module methodsFor: 'morphisms' stamp: 'len 10/7/2016 08:40'!
-> aModule
	"Answer the morphisms that go from the receiver A to the argument B: Hom(A,B)."
	(aModule isKindOf: ScalarModule)
		ifTrue: [^ self dual].
	^ LinearMaps from: self to: aModule! !

!Module methodsFor: 'accessing' stamp: 'len 2/14/2016 18:05'!
characteristic
	^ self scalars characteristic! !

!Module methodsFor: 'testing' stamp: 'len 2/28/2016 07:54'!
isModule
	^ true! !

!Module methodsFor: 'printing' stamp: 'len 4/21/2016 00:00'!
printOn: aStream
	aStream nextPutAll: 'a '; print: self scalars; nextPutAll: '-module'! !

!Module methodsFor: 'accessing' stamp: 'len 10/9/2016 09:01'!
scalarAction
	^ (self, self scalars) to: self evaluating: [:each| each first * each second]! !

!Module methodsFor: 'accessing' stamp: 'len 2/14/2016 18:01'!
scalars
	^ properties at: #scalars! !

!Module methodsFor: 'accessing-private' stamp: 'len 4/23/2016 06:00'!
scalars: aRing
	properties at: #scalars put: aRing! !

!FreeModule methodsFor: 'operations' stamp: 'len 10/7/2016 08:40'!
/ aSubmodule
	"Answer the quotient of the receiver by the submodule aSubmodule,
	i.e. the module obtained by 'collapsing' the submodule to zero."
	^ (aSubmodule asSubmoduleOf: self) quotient! !

!FreeModule methodsFor: 'operations' stamp: 'len 9/1/2016 07:53'!
/\ aModule
	"Meet."
	^ self  aModule! !

!FreeModule methodsFor: 'comparing' stamp: 'len 7/14/2016 23:18'!
< aModule
	"Answer true if the receiver is strictly included in the argument, i.e. it's a proper submodule of the argument."
	^ self rank < aModule rank and: [self <= aModule]! !

!FreeModule methodsFor: 'comparing' stamp: 'len 8/24/2016 22:00'!
<= aModule
	"Answer true if the receiver is included in the argument, i.e. it's a submodule of the argument."
	self == aModule ifTrue: [^ true].
	self rank <= aModule rank ifFalse: [^ false].
	self basis do: [:each| (aModule includes: each) ifFalse: [^ false]].
	^ true! !

!FreeModule methodsFor: 'comparing' stamp: 'len 7/14/2016 23:22'!
= anObject
	self == anObject ifTrue: [^ true].
	(anObject isKindOf: FreeModule) ifFalse: [^ false].
	self scalars = anObject scalars ifFalse: [^ false].
	self rank = anObject rank ifFalse: [^ false].
	1 to: self rank do: [:i| (anObject includes: (self e: i)) ifFalse: [^ false]].
	^ true! !

!FreeModule methodsFor: 'operations' stamp: 'len 7/14/2016 23:23'!
\/ aModule
	"Join."
	^ self + aModule! !

!FreeModule methodsFor: 'comparing' stamp: 'len 7/14/2016 23:58'!
~ aModule
	"Answer true if the receiver is isomorphic to the argument."
	aModule isFreeModule
		ifFalse: [^ super ~ aModule].
	^ self = aModule or: [self scalars = aModule scalars and: [self rank = aModule rank]]! !

!FreeModule methodsFor: 'operations' stamp: 'len 10/7/2016 08:37'!
 aFreeModule
	^ DirectSumModule components: {self. aFreeModule}! !

!FreeModule methodsFor: 'operations' stamp: 'len 7/14/2016 23:24'!
 aModule
	^ TensorProductSpace left: self right: aModule! !

!FreeModule methodsFor: 'operations' stamp: 'len 10/7/2016 09:28'!
 aSubmodule
	self ambient = aSubmodule ambient ifFalse: [^ self error: 'abients don''t match'].
	self <= aSubmodule ifTrue: [^ self].
	aSubmodule <= self ifTrue: [^ aSubmodule].
	^ self subclassResponsibility! !

!FreeModule methodsFor: 'accessing' stamp: 'len 7/15/2016 04:24'!
ambient
	^ self basis ambient! !

!FreeModule methodsFor: 'operations' stamp: 'len 7/15/2016 00:34'!
annihilator
	"Answer the annihilator of the receiver, i.e. the space of all linear forms that are 0 at all vectors in the receiver."
	^ self dual null! !

!FreeModule methodsFor: 'morphisms' stamp: 'len 7/14/2016 23:24'!
apply: aLinearMap
	"Answer the receiver transformed by aLinearMap."
	^ (self basis apply: aLinearMap) span! !

!FreeModule methodsFor: 'converting' stamp: 'len 8/30/2016 05:47'!
asAffineSpace
	self isVectorSpace ifFalse: [DomainError signal: 'not a vector space'].
	^ AffineLinearSpace representative: self zero direction: self! !

!FreeModule methodsFor: 'converting' stamp: 'len 7/15/2016 00:01'!
asSubmoduleOf: aModule
	self flag: #fix. "avoid computing linear independence again"
	^ aModule span: self basis! !

!FreeModule methodsFor: 'random' stamp: 'len 4/19/2016 20:12'!
atRandom: aRandom
	^ self elementAt: (self coordinateSpace atRandom: aRandom)! !

!FreeModule methodsFor: 'random' stamp: 'len 4/19/2016 21:30'!
atRandom: aRandom bits: bitSize
	self rank = 0 ifTrue: [^ self zero].
	^ self elementAt: (self coordinateSpace atRandom: aRandom bits: bitSize)! !

!FreeModule methodsFor: 'morphisms' stamp: 'len 8/31/2016 08:29'!
automorphisms
	^ GeneralLinearGroup on: self! !

!FreeModule methodsFor: 'basis' stamp: 'len 4/25/2016 06:28'!
basis
	^ properties at: #basis ifAbsentPut: [LinearBasis on: self vectors: (self indices collect: [:i| (self e: i)])]! !

!FreeModule methodsFor: 'basis' stamp: 'len 8/25/2016 21:02'!
codimension
	^ self ambient dimension - self dimension! !

!FreeModule methodsFor: 'basis' stamp: 'len 7/10/2016 23:06'!
coordinateRing
	"The coordinate ring of a R-module of rank n (or K-vector space of dimension n) is the polynomial ring R[x1..xn] (K[x1..xn]."
	^ self scalars polynomialsIn: self rank! !

!FreeModule methodsFor: 'basis' stamp: 'len 2/28/2016 07:45'!
coordinateSpace
	^ self scalars ** self rank! !

!FreeModule methodsFor: 'basis' stamp: 'len 4/25/2016 06:38'!
coordinatesOf: anElement
	^ self scalars tuple: self generators size evaluating: [:i| (anElement coefficientAt: (self generators at: i)) ifNil: [self scalars zero]]! !

!FreeModule methodsFor: 'basis' stamp: 'len 10/7/2016 08:46'!
corank
	^ self ambient rank - self rank! !

!FreeModule methodsFor: 'basis' stamp: 'len 7/15/2016 00:04'!
dimension
	"Custom notation for vector spaces."
	^ self rank! !

!FreeModule methodsFor: 'iterating' stamp: 'len 7/19/2016 23:46'!
do: aBlock
	self coordinateSpace do: [:each| aBlock value: (self elementAt: each)]! !

!FreeModule methodsFor: 'operations' stamp: 'len 10/7/2016 08:38'!
dual
	^ DualModule from: self! !

!FreeModule methodsFor: 'basis' stamp: 'len 10/4/2016 09:53'!
e: anInteger
	^ (properties at: #basis ifAbsent: [^ FormalSum with: (self generators at: anInteger)]) at: anInteger! !

!FreeModule methodsFor: 'basis' stamp: 'len 7/10/2016 07:37'!
elementAt: aTuple
	"Answer a module element with the given coordinates in the canonical basis."
	| answer |
	answer _ self zero.
	aTuple withIndexDo: [:each :i| answer _ (self e: i) * each + answer].
	^ answer! !

!FreeModule methodsFor: 'accessing' stamp: 'len 4/25/2016 06:37'!
generators
	^ properties at: #generators ifAbsent: [self basis]! !

!FreeModule methodsFor: 'operations' stamp: 'len 7/15/2016 00:31'!
grassmannian: r
	"Answer the set of r-dimensional subspaces of the receiver."
	self isVectorSpace ifFalse: [DomainError signal: 'not a vector space'].
	self assert: (r <= self dimension and: [r >= 0]).
	^ Grassmannian new: r over: self! !

!FreeModule methodsFor: 'comparing' stamp: 'len 7/14/2016 23:22'!
hash
	^ self scalars hash + self rank hashMultiply! !

!FreeModule methodsFor: 'operations' stamp: 'len 8/30/2016 05:47'!
hull: aCollection
	"Answer the affine hull (flat) spanned by the vectors in aCollection."
	| vectors x0 |
	vectors _ aCollection asArray.
	x0 _ vectors at: 1.
	^ AffineLinearSpace
		representative: x0
		direction: (self span: ((2 to: vectors size) collect: [:i| x0 - (vectors at: i)]))! !

!FreeModule methodsFor: 'morphisms' stamp: 'len 8/31/2016 03:48'!
id
	"Answer the identity morphism."
	^ LinearMap from: self to: self evaluating: [:x| x]! !

!FreeModule methodsFor: 'testing' stamp: 'len 7/15/2016 00:30'!
includes: anObject
"	^ (anObject isKindOf: LinearCombination) and: [anObject coefficients keys allSatisfy: [:each| self generators includes: each]]"
	^ (self coordinatesOf: anObject) notNil! !

!FreeModule methodsFor: 'basis' stamp: 'len 4/25/2016 21:30'!
indices
	^ 1 to: (properties at: #generators ifAbsent: [^ 1 to: self rank]) size! !

!FreeModule methodsFor: 'accessing' stamp: 'len 7/15/2016 00:36'!
innerProduct
	"Answer the bilinear form defining the Euclidean inner product."
	^ properties at: #innerProduct ifAbsentPut:
		[BilinearForm
			from: (self, self)
			evaluating: [:each| (self coordinatesOf: each first) dot: (self coordinatesOf: each second)]]! !

!FreeModule methodsFor: 'testing' stamp: 'len 2/28/2016 07:55'!
isCountable
	^ self scalars isCountable or: [self isTrivial]! !

!FreeModule methodsFor: 'testing' stamp: 'len 4/25/2016 06:39'!
isFinite
	^ self generators isEmpty or: [self scalars isFinite]! !

!FreeModule methodsFor: 'testing' stamp: 'len 7/15/2016 04:14'!
isFreeAbelianGroup
	"Answer true if the receiver is a Z-module."
	^ self scalars class = Integers! !

!FreeModule methodsFor: 'testing' stamp: 'len 2/28/2016 07:54'!
isFreeModule
	^ true! !

!FreeModule methodsFor: 'testing' stamp: 'len 7/14/2016 23:58'!
isInitial
	^ self isTrivial! !

!FreeModule methodsFor: 'testing' stamp: 'len 7/14/2016 23:58'!
isTrivial
	^ self rank = 0! !

!FreeModule methodsFor: 'testing' stamp: 'len 7/14/2016 23:58'!
isVectorSpace
	^ self scalars isField! !

!FreeModule methodsFor: 'accessing' stamp: 'len 7/15/2016 00:36'!
norm
	^ properties at: #norm ifAbsentPut:
		[Function from: self to: self scalars "should go to the reals"
			evaluating: [:x| (self innerProduct value: {x. x conjugated}) squareRoot]]! !

!FreeModule methodsFor: 'accessing' stamp: 'len 7/15/2016 00:36'!
norm2
	"Answer the squared norm."
	^ properties at: #norm2 ifAbsentPut:
		[Function from: self to: self scalars
			evaluating: [:x| (self innerProduct value: {x. x conjugated})]]! !

!FreeModule methodsFor: 'accessing' stamp: 'len 8/4/2016 22:33'!
null
	"Answer the trivial submodule."
	^ self span: #()! !

!FreeModule methodsFor: 'operations' stamp: 'len 10/7/2016 09:02'!
perp
	"Answer the orthogonal complement of the receiver."
	^ self null! !

!FreeModule methodsFor: 'printing' stamp: 'len 7/15/2016 00:35'!
printOn: aStream
	aStream print: self scalars; nextPut: $-; nextPutAll: (self isVectorSpace ifTrue: ['vector space '] ifFalse: ['module']); print: self basis! !

!FreeModule methodsFor: 'operations' stamp: 'len 7/14/2016 23:56'!
product: aModule
	"Answer the categorical product, i.e. direct sum of the receiver and the argument."
	^ (aModule isFreeModule and: [aModule scalars = self scalars])
		ifTrue: [self  aModule]
		ifFalse: [super product: aModule]! !

!FreeModule methodsFor: 'operations' stamp: 'len 8/30/2016 05:45'!
projective
	"Answer the projective subspace induced by the receiver, consisting of the 1-dimension subspaces."
	self isVectorSpace ifFalse: [^ DomainError signal: 'not a vector space'].
	^ ProjectiveLinearSpace on: self! !

!FreeModule methodsFor: 'basis' stamp: 'len 2/24/2016 02:24'!
rank
	^ self basis size! !

!FreeModule methodsFor: 'morphisms' stamp: 'len 7/14/2016 23:56'!
rotations
	^ SpecialOrthogonalGroup on: self! !

!FreeModule methodsFor: 'accessing' stamp: 'len 3/19/2016 02:51'!
size
	^ self scalars size ** self rank! !

!FreeModule methodsFor: 'operations' stamp: 'len 10/7/2016 08:51'!
span: aCollection
	"Answer the subspace spanned by the vectors in aCollection."
	| basis |
	self flag: #fix. "avoid computing linear independence again"
"	(aCollection isKindOf: LinearBasis)
		ifTrue:
			[basis _ LinearBasis on: self vectors: aCollection vectors]
		ifFalse:
			[basis _ LinearBasis on: self.
			aCollection do: [:each| (basis generates: each) ifFalse: [basis add: each]]]."
	basis _ LinearBasis on: self.
	aCollection do: [:each| (basis generates: each) ifFalse: [basis add: each]].
	^ Submodule basis: basis! !

!FreeModule methodsFor: 'operations' stamp: 'len 7/14/2016 23:57'!
tensors: aPair
	^ Tensors type: aPair on: self! !

!FreeModule methodsFor: 'morphisms' stamp: 'len 8/31/2016 03:54'!
to: aModule evaluating: aBlock
	"Answer the module homomorphism from the receiver to the argument."
	(aModule isKindOf: Module) ifFalse: [^ super to: aModule evaluating: aBlock].
	^ LinearMap from: self to: aModule evaluating: aBlock! !

!FreeModule methodsFor: 'testing' stamp: 'len 7/15/2016 00:21'!
torsion
	"Free modules are torsionless."
	^ self null! !

!FreeModule methodsFor: 'basis' stamp: 'len 7/15/2016 00:04'!
vectorAt: aTuple
	"Custom notation for vector spaces."
	^ self elementAt: aTuple! !

!FreeModule methodsFor: 'elements' stamp: 'len 5/12/2016 10:09'!
zero
	^ properties at: #zero ifAbsentPut: [| e | (e _ self e: 1) - e]! !

!FreeModule class methodsFor: 'instance creation' stamp: 'len 6/30/2016 02:26'!
new: anInteger over: aRing
	^ self on: (1 to: anInteger) over: aRing! !

!FreeModule class methodsFor: 'instance creation' stamp: 'len 4/25/2016 06:38'!
on: aCollection over: aRing
	^ self new generators: aCollection; scalars: aRing! !

!DirectSumModule methodsFor: 'accessing' stamp: 'len 2/16/2016 07:31'!
arity
	^ components size! !

!DirectSumModule methodsFor: 'converting' stamp: 'len 5/1/2016 18:54'!
asCartesianProduct
	^ CartesianProduct components: components! !

!DirectSumModule methodsFor: 'accessing' stamp: 'len 2/12/2016 20:12'!
at: anInteger
	^ components at: anInteger! !

!DirectSumModule methodsFor: 'accessing-private' stamp: 'len 11/10/2015 22:53'!
components
	^ components! !

!DirectSumModule methodsFor: 'accessing-private' stamp: 'len 6/11/2016 16:45'!
components: anArray
	components _ anArray as: Tuple! !

!DirectSumModule methodsFor: 'basis' stamp: 'len 5/29/2016 17:49'!
coordinatesOf: anArray
	"Answer the coordinates of the argument in the canonic basis."
	| answer |
	components with: anArray do: [:V :v|
		| coordinates |
		coordinates _ V coordinatesOf: v.
		answer _ answer isNil ifTrue: [coordinates] ifFalse: [answer, coordinates]].
	^ answer! !

!DirectSumModule methodsFor: 'basis' stamp: 'len 11/30/2015 07:11'!
dimension
	^ components sum: [:each| each dimension]! !

!DirectSumModule methodsFor: 'basis' stamp: 'len 12/10/2015 04:22'!
e: anInteger
	^ components collect: [:each| each e: anInteger]! !

!DirectSumModule methodsFor: 'morphisms' stamp: 'len 10/10/2016 08:44'!
embedding: i
	^ ((self at: i) to: self evaluating: [:x| components withIndexCollect: [:each :k| k = i ifTrue: [x] ifFalse: [each zero]]]) name: 'i', i printText sub! !

!DirectSumModule methodsFor: 'testing' stamp: 'len 2/12/2016 20:14'!
includes: anObject
	anObject size = components size ifFalse: [^ false].
	components with: anObject do: [:V :x| (V includes: x) ifFalse: [^ false]].
	^ true! !

!DirectSumModule methodsFor: 'testing' stamp: 'len 4/22/2016 13:44'!
isCoproduct
	^ true! !

!DirectSumModule methodsFor: 'printing' stamp: 'len 10/10/2016 08:45'!
printOn: aStream
	components do: [:each| aStream print: each] separatedBy: [aStream nextPut: Character oplus]! !

!DirectSumModule methodsFor: 'morphisms' stamp: 'len 10/10/2016 08:42'!
projection: i
	^ (self to: (self at: i) evaluating: [:x| x at: i]) name: Character pi asText, i printText sub! !

!DirectSumModule methodsFor: 'accessing' stamp: 'len 11/10/2015 22:56'!
scalars
	components do: [ :each | ^ each scalars].
	^ nil! !

!DirectSumModule methodsFor: 'accessing' stamp: 'len 2/16/2016 07:32'!
size
	^ components product: [:each| each size]! !

!DirectSumModule class methodsFor: 'accessing-private' stamp: 'len 11/10/2015 22:58'!
components: anArray
	^ self new components: anArray! !

!FreeAbelianGroup methodsFor: 'testing' stamp: 'len 2/24/2016 04:09'!
isInfiniteCyclic
	^ self basis size = 1! !

!FreeAbelianGroup methodsFor: 'accessing' stamp: 'len 3/3/2016 07:16'!
presentation
	| commutators |
	commutators _ OrderedCollection new.
	self generators do: [:x|
		self generators do: [:y|
			commutators add: x * y * x reciprocal * y reciprocal]].
	self flag: #fix. "generators are additive or multiplicative?"
	^ GroupPresentation generators: self basis relators: commutators! !

!FreeAbelianGroup methodsFor: 'accessing' stamp: 'len 7/19/2016 03:03'!
scalars
	^ ZZ! !

!FreeAbelianGroup class methodsFor: 'instance creation' stamp: 'len 6/30/2016 02:27'!
new: anInteger
	^ self on: (1 to: anInteger)! !

!FreeAbelianGroup class methodsFor: 'instance creation' stamp: 'len 4/25/2016 06:38'!
on: aCollection
	^ self new generators: aCollection! !

!Lattice methodsFor: 'operations' stamp: 'len 5/23/2016 04:36'!
* anObject
	(self ambient scalars includes: anObject) ifTrue: [^ self class basis: (self basis collect: [:each| each * anObject])].
	^ super * anObject! !

!Lattice methodsFor: 'operations' stamp: 'len 7/14/2016 22:53'!
 aLattice
	^ self class basis: basis  aLattice basis! !

!Lattice methodsFor: 'accessing' stamp: 'len 5/23/2016 19:28'!
ambient
	"Answer the ambient vector space."
	^ basis ambient! !

!Lattice methodsFor: 'morphisms' stamp: 'len 7/10/2016 05:26'!
apply: aLinearMap
	^ self class basis: (self basis apply: aLinearMap)! !

!Lattice methodsFor: 'basis' stamp: 'len 12/9/2015 02:18'!
basis
	^ basis! !

!Lattice methodsFor: 'private' stamp: 'len 12/9/2015 02:18'!
basis: aLinearBasis
	basis _ aLinearBasis! !

!Lattice methodsFor: 'basis' stamp: 'len 3/3/2016 07:27'!
coordinatesOf: anElement
	^ self basis coordinatesOf: anElement! !

!Lattice methodsFor: 'invariants' stamp: 'len 1/1/2016 00:37'!
coveringRadius
	^ properties at: #coveringRadius! !

!Lattice methodsFor: 'invariants' stamp: 'len 12/30/2015 19:52'!
determinant
	"The determinant det(L) of a lattice L is defined as the volume of its fundamental paralleleliped."
	^ basis gramian determinant! !

!Lattice methodsFor: 'invariants' stamp: 'len 12/30/2015 19:52'!
determinant2
	"The determinant det(L) of a lattice L is defined as the volume of its fundamental paralleleliped."
	| B |
	B _ basis matrix.
	"B square means the lattice is full-rank:"
	^ B isSquare ifTrue: [B determinant abs] ifFalse: [(B transposed * B) determinant squareRoot]! !

!Lattice methodsFor: 'basis' stamp: 'len 10/5/2016 09:35'!
dimension
	self flag: #fix. "what's the dimension of a lattice? the ambient dimension or its rank as Z-module?"
	^ super dimension
"	^ self ambient dimension"! !

!Lattice methodsFor: 'operations' stamp: 'len 6/20/2016 08:20'!
dual
	"Answer the dual lattice of the receiver (or reciprocal lattice, or polar lattice)."
	| B Bdual dualBasis |
	B _ basis matrix.
	Bdual _ B * (B transposed * B) leftInverse.
	self flag: #fix. "transposed or not transposed"
	self flag: #fix. "shouln't be a lattice of linear forms?"
	dualBasis _ LinearBasis on: basis ambient matrix: Bdual transposed. "<- transposed or not?"
	^ self class basis: dualBasis! !

!Lattice methodsFor: 'basis' stamp: 'len 3/3/2016 07:25'!
e: anInteger
	^ self basis at: anInteger! !

!Lattice methodsFor: 'basis' stamp: 'len 3/3/2016 07:19'!
elementAt: aTuple
	^ basis vectorAt: aTuple! !

!Lattice methodsFor: 'invariants' stamp: 'len 12/10/2015 01:00'!
fundamentalParallelepiped
	^ self notYetImplemented! !

!Lattice methodsFor: 'invariants' stamp: 'len 12/30/2015 20:02'!
fundamentalVolume
	"Answer the volume of the fundamental region."
	^ self determinant sqrt! !

!Lattice methodsFor: 'testing' stamp: 'len 11/30/2015 03:50'!
includes: anObject
	^ (basis coordinatesOf: anObject) allSatisfy: [:each| each isInteger]! !

!Lattice methodsFor: 'accessing' stamp: 'len 5/23/2016 04:36'!
innerProduct
	^ basis ambient innerProduct! !

!Lattice methodsFor: 'testing' stamp: 'len 12/10/2015 00:58'!
isFullRank
	^ self rank = self dimension! !

!Lattice methodsFor: 'testing' stamp: 'len 12/30/2015 21:50'!
isIntegral
	"Answer true if the receiver is integral, i.e. if the inner product of any two lattice vectors is an integer. This is true iff the Gram matrix contains only integer entries. Equivalently, a lattice L is integral if and only if it is contained in its dual L*: L <= L*. Also, an integral lattice L has the property: L <= L* <= L / det(L)."
	basis gramian do: [:each| each isInteger ifFalse: [^ false]].
	^ true! !

!Lattice methodsFor: 'testing' stamp: 'len 1/5/2016 18:39'!
isRootLattice
	self isIntegral ifFalse: [^ false].
	basis do: [:v| (self innerProduct value: v value: v) = 2 ifFalse: [^ false]].
	^ true! !

!Lattice methodsFor: 'testing' stamp: 'len 12/30/2015 22:04'!
isSelfDual
	"A self-dual lattice is a lattice L that equals it's dual L*, L = L*.
	A (integral) lattice is self-dual iff it is unimodular."
	self flag: #fix. "all self-dual lattices are integral?"
	^ self isUnimodular! !

!Lattice methodsFor: 'testing' stamp: 'len 12/30/2015 21:51'!
isUnimodular
	^ self isIntegral and: [self determinant abs = 1]! !

!Lattice methodsFor: 'invariants' stamp: 'len 1/1/2016 00:37'!
packingRadius
	^ properties at: #packingRadius! !

!Lattice methodsFor: 'printing' stamp: 'len 4/21/2016 00:01'!
printOn: aStream
	aStream nextPutAll: '<'.
	basis do: [:each| aStream print: each] separatedBy: [aStream nextPutAll: '; '].
	aStream nextPutAll: '>'! !

!Lattice methodsFor: 'accessing' stamp: 'len 12/30/2015 22:13'!
quadraticForm
	^ QuadraticForm from: basis matrix: basis gramian! !

!Lattice methodsFor: 'basis' stamp: 'len 12/30/2015 21:03'!
reducedBasis
	^ properties at: #reducedBasis ifAbsentPut: [(LLL basis: basis) reducedBasis]! !

!Lattice methodsFor: 'accessing' stamp: 'len 12/30/2015 21:02'!
shortVector
	^ self reducedBasis at: 1! !

!Lattice methodsFor: 'invariants' stamp: 'len 12/30/2015 22:10'!
thetaSeries
	"Answer the theta series of the lattice."
	^ properties at: #thetaSeries! !

!Lattice class methodsFor: 'examples' stamp: 'len 7/15/2016 18:32'!
A: n
	"Answer the lattice A_n = {(x0,...,xn) in Z^{n+1} : x0 + ... + xn = 0}."
	| V t B |
	V _ QQ ** (n+1).
	t _ (-1,1), (QQ ** (n-1)) zero.
	B _ LinearBasis on: V.
	n timesRepeat: [B add: t. t _ t >> 1].
	^ self basis: B! !

!Lattice class methodsFor: 'examples' stamp: 'len 7/15/2016 18:32'!
Adual: n
	"Answer the dual of A_n."
	| V B |
	V _ QQ ** (n+1).
	B _ LinearBasis on: V.
	1 to: n do: [:i| B add: (1, (V e: i) negated)].
	B add: (QQ tuple: n+1 evaluating: [:i| i=1 ifTrue: [n negated / (n+1)] ifFalse: [1 / (n+1)]]).
	^ self basis: B! !

!Lattice class methodsFor: 'examples' stamp: 'len 7/15/2016 18:32'!
D4
	"Answer the D4 lattice, which is self-dual."
	| V B |
	V _ QQ ** 4.
	B _ LinearBasis on: V vectors: {(1,0,0,0). (0,1,0,0). (0,0,1,0). (1,1,1,1)/2}.
	^ self basis: B! !

!Lattice class methodsFor: 'examples' stamp: 'len 7/15/2016 18:33'!
D: n
	"Answer the checkboard lattice D_n = {(x1,...,xn) in Z^n : x0 + ... + xn is even}."
	| V t0 t B |
	V _ QQ ** n.
	B _ LinearBasis on: V.
	t0 _ (-1,-1), (QQ ** (n-2)) zero.
	B add: t0.
	t _ (1,-1), (QQ ** (n-2)) zero.
	n-1 timesRepeat: [B add: t. t _ t >> 1].
	^ self basis: B! !

!Lattice class methodsFor: 'examples' stamp: 'len 7/15/2016 18:33'!
Ddual: n
	"Answer the dual of D_n."
	| V B |
	V _ QQ ** n.
	B _ LinearBasis on: V.
	1 to: n-1 do: [:i| B add: (V e: i)].
	B add: (QQ tuple: n evaluating: [:i| 1/2]).
	^ self basis: B! !

!Lattice class methodsFor: 'examples' stamp: 'len 7/15/2016 18:33'!
E8
	| V t0 t B answer |
	V _ QQ ** 8.
	B _ LinearBasis on: V.
	t0 _ (2,0,0,0,0,0,0,0).
	B add: t0.
	t _ (-1,1,0,0,0,0,0,0).
	6 timesRepeat: [B add: t. t _ t >> 1].
	B add: (1,1,1,1,1,1,1,1)/2.
	answer _ self basis: B.
	answer properties
		at: #minimalNorm put: 2;
		at: #kissingNumber put: 240;
		at: #CoxeterNumber put: 30;
		at: #packingRadius put: 1/2 sqrt;
		at: #density put: Float pi ** 4 / 384;
		at: #thickness put: Float pi ** 4 / 24.
	^ answer
		! !

!Lattice class methodsFor: 'examples' stamp: 'len 7/15/2016 18:34'!
Z: n
	"Answer the n-dimensional cubic or integer lattice Z^n."
	^ self basis: (QQ ** n) basis! !

!Lattice class methodsFor: 'instance creation' stamp: 'len 12/9/2015 02:18'!
basis: aLinearBasis
	^ self new basis: aLinearBasis! !

!Lattice class methodsFor: 'examples' stamp: 'len 7/15/2016 18:34'!
bcc
	"Answer the body-centered cubic lattice (bcc).
	D*_3 is equivalent to bcc."
	| V B |
	V _ QQ ** 3.
	B _ LinearBasis on: V vectors: {(2,0,0). (0,2,0). (1,1,1)}.
	^ self basis: B! !

!Lattice class methodsFor: 'examples' stamp: 'len 7/15/2016 18:34'!
fcc
	"Answer the face-centered cubic lattice (fcc).
	Both A_3 and D_3 are equivalent to the fcc."
	| V B |
	V _ QQ ** 3.
	B _ LinearBasis on: V vectors: {(-1,-1,0). (1,-1,0). (0,1,-1)}.
	^ self basis: B! !

!Lattice class methodsFor: 'instance creation' stamp: 'len 1/1/2016 00:36'!
matrix: aMatrix
	"Answer a lattice with generator matrix aMatrix."
	^ self basis: aMatrix rowSpace basis! !

!LinearMaps methodsFor: 'converting' stamp: 'len 8/25/2016 21:07'!
asAffineSpace
	self isVectorSpace ifFalse: [DomainError signal: 'not a vector space'].
	^ AffineMaps representative: self zero direction: self! !

!LinearMaps methodsFor: 'converting' stamp: 'len 5/22/2016 03:48'!
asLieAlgebra
	^ LieAlgebra on: self bracket: (Function from: (self cartesian: self) to: self evaluating: [:each| each first @ each second - (each second @ each first)])! !

!LinearMaps methodsFor: 'accessing' stamp: 'len 11/7/2015 04:34'!
codomain
	^ codomain! !

!LinearMaps methodsFor: 'accessing-private' stamp: 'len 11/7/2015 04:31'!
codomain: aVectorSpace
	codomain _ aVectorSpace! !

!LinearMaps methodsFor: 'basis' stamp: 'len 12/10/2015 03:48'!
coordinatesOf: aLinearMap
	"Answer the coordinates of aLinearMap with respect to the domain and codomain basis."

	^ self matrices coordinatesOf: (self matrixOf: aLinearMap)! !

!LinearMaps methodsFor: 'accessing' stamp: 'len 11/7/2015 04:34'!
domain
	^ domain! !

!LinearMaps methodsFor: 'accessing-private' stamp: 'len 11/7/2015 04:31'!
domain: aVectorSpace
	domain _ aVectorSpace! !

!LinearMaps methodsFor: 'basis' stamp: 'len 1/5/2016 03:28'!
e: anInteger
	"Answer the anInteger-th canonic vector."
	^ LinearMap
		from: self domain basis
		to: self codomain basis
		matrix: (self matrices e: anInteger)! !

!LinearMaps methodsFor: 'elements' stamp: 'len 1/5/2016 03:21'!
evaluating: aBlock
	^ LinearMap from: domain to: codomain evaluating: aBlock! !

!LinearMaps methodsFor: 'elements' stamp: 'len 2/11/2016 20:50'!
identity
	^ self matrix: self matrices identity! !

!LinearMaps methodsFor: 'testing' stamp: 'len 8/23/2016 21:58'!
includes: aLinearMap
	^ (aLinearMap isKindOf: LinearMap) and: [aLinearMap domain = self domain and: [aLinearMap codomain = self codomain]]! !

!LinearMaps methodsFor: 'testing' stamp: 'len 2/13/2016 00:19'!
isEndomorphisms
	^ domain = codomain! !

!LinearMaps methodsFor: 'private' stamp: 'len 1/5/2016 03:20'!
matrices
	"Answer the vector space of the matrices associated to the transformations of the receiver."
	^ self scalars ** (self codomain dimension @ self domain dimension)! !

!LinearMaps methodsFor: 'elements' stamp: 'len 2/11/2016 06:04'!
matrix: aMatrix
	"Answer the linear transformation associated to the given matrix in the canonical basis for the domain and codomain vector spaces."
	^ LinearMap from: domain basis to: codomain basis matrix: aMatrix! !

!LinearMaps methodsFor: 'private' stamp: 'len 1/5/2016 03:20'!
matrixOf: aLinearMap
	"Answer the matrix associated to aLinearTransformation with respect to the domain and codomain basis."
	| answer |
	answer _ self matrices new.
	self domain basis do: [:each|
		answer addRow: (self codomain coordinatesOf: (aLinearMap value: each))].
	^ answer transposed! !

!LinearMaps methodsFor: 'elements' stamp: 'len 4/23/2016 03:56'!
newFrom: anObject
	(anObject isBlock or: [anObject is: #Function]) ifTrue: [^ self evaluating: anObject].
	(anObject is: #Matrix) ifTrue: [^ self matrix: anObject].
	(self scalars includes: anObject) ifTrue: [^ self scalar: anObject].
	DomainError signal! !

!LinearMaps methodsFor: 'operations' stamp: 'len 10/9/2016 08:35'!
opposite
	^ self class from: self domain to: self codomain! !

!LinearMaps methodsFor: 'printing' stamp: 'len 8/1/2016 09:02'!
printOn: aStream
	"Delegate in order to print the standard notation:"
	(Morphisms from: self domain to: self codomain) printOn: aStream! !

!LinearMaps methodsFor: 'operations' stamp: 'len 8/25/2016 21:17'!
projective
	"Answer the projective subspace induced by the receiver, consisting of the 1-dimension subspaces."
	self isVectorSpace ifFalse: [^ DomainError signal: 'not a vector space'].
	^ ProjectiveMaps on: self! !

!LinearMaps methodsFor: 'basis' stamp: 'len 10/5/2016 09:32'!
rank
	^ self domain rank * self codomain rank! !

!LinearMaps methodsFor: 'elements' stamp: 'len 2/11/2016 20:10'!
scalar: aNumber
	^ self evaluating: [:x| x * aNumber]! !

!LinearMaps methodsFor: 'accessing' stamp: 'len 11/7/2015 03:43'!
scalars
	"Answer the algebraic ambient of scalars."

	^ self domain scalars! !

!LinearMaps class methodsFor: 'instance creation' stamp: 'len 11/7/2015 03:40'!
from: aVectorSpace to: anotherVectorSpace
	^ self new
		domain: aVectorSpace;
		codomain: anotherVectorSpace! !

!DualModule methodsFor: 'accessing-private' stamp: 'len 10/7/2016 08:43'!
domain: aModule
	super domain: aModule.
	self codomain: aModule scalars asSelfModule! !

!DualModule methodsFor: 'basis' stamp: 'len 12/10/2015 03:56'!
e: anInteger
	"Answer the anInteger-th canonic vector."

	^ LinearForm
		from: self domain basis
		matrix: (self matrices e: anInteger)! !

!DualModule methodsFor: 'elements' stamp: 'len 1/5/2016 03:21'!
evaluating: aBlock
	^ LinearForm from: domain to: codomain evaluating: aBlock! !

!DualModule methodsFor: 'morphisms' stamp: 'len 4/3/2016 16:23'!
map
	"Answer the natural isomorphism from the vector space to the dual.
	See LinearForm>>#asVector."
	self flag: #fix. "this is not natural"
	^ LinearMap from: domain to: self evaluating: [:v| self vectorAt: (domain coordinatesOf: v)]! !

!DualModule methodsFor: 'printing' stamp: 'len 6/19/2016 00:25'!
printOn: aStream
	aStream print: self domain; nextPutAll: '*' super! !

!DualModule methodsFor: 'elements' stamp: 'len 6/1/2016 06:08'!
x
	"As for polynomials."
	^ self x: 1! !

!DualModule methodsFor: 'elements' stamp: 'len 6/1/2016 06:07'!
x: i
	"As for polynomials."
	^ self e: i! !

!DualModule methodsFor: 'elements' stamp: 'len 6/1/2016 06:08'!
y
	"As for polynomials."
	^ self x: 2! !

!DualModule methodsFor: 'elements' stamp: 'len 6/1/2016 06:08'!
z
	"As for polynomials."
	^ self x: 3! !

!DualModule class methodsFor: 'instance creation' stamp: 'len 11/7/2015 04:29'!
from: aVectorSpace
	"Answer the linear ambient of linear forms with domain in aVectorSpace."

	^ self new domain: aVectorSpace! !

!MatrixModule methodsFor: 'comparing' stamp: 'len 10/7/2016 08:39'!
= anObject
	self == anObject ifTrue: [^ true].
	^ (anObject isKindOf: MatrixModule) and: [anObject scalars = self scalars and: [self numberOfRows = anObject numberOfRows and: [self numberOfColumns = anObject numberOfColumns]]]! !

!MatrixModule methodsFor: 'converting' stamp: 'len 5/22/2016 03:48'!
asLieAlgebra
	^ LieAlgebra on: self bracket: (Function from: (self cartesian: self) to: self evaluating: [:each| each first * each second - (each second * each first)])! !

!MatrixModule methodsFor: 'converting' stamp: 'len 8/4/2016 09:18'!
asRing
	self isSquare ifFalse: [self error: 'not square matrices'].
	^ (self as: Ring) one: self identity! !

!MatrixModule methodsFor: 'elements' stamp: 'len 10/6/2016 15:33'!
columns: anArray
	^ (ColumnMatrix columns: anArray) parent: self! !

!MatrixModule methodsFor: 'basis' stamp: 'len 11/23/2015 02:31'!
coordinatesOf: aMatrix
	^ aMatrix asTuple! !

!MatrixModule methodsFor: 'elements' stamp: 'len 10/6/2016 15:33'!
dense: aTuple
	^ DenseMatrix new coefficients: aTuple; parent: self! !

!MatrixModule methodsFor: 'elements' stamp: 'len 3/3/2016 18:57'!
diagonal: aTuple
	^ self evaluatingDiagonal: [:i| aTuple at: i]! !

!MatrixModule methodsFor: 'basis' stamp: 'len 11/26/2015 03:53'!
e: anInteger
	| one zero m |
	one _ scalars one.
	zero _ scalars zero.
	m _ numberOfColumns.
	^ self evaluating: [:i :j| (i-1)*m + j = anInteger ifTrue: [one] ifFalse: [zero]]! !

!MatrixModule methodsFor: 'basis' stamp: 'len 7/8/2016 03:03'!
elementAt: aTuple
	^ self evaluating: [:i :j| aTuple at: (i-1)*numberOfColumns + j]

"	| answer |
	answer _ self zero.
	aTuple withIndexDo: [:each :i| answer _ (self e: i) * each + answer].
	^ answer"! !

!MatrixModule methodsFor: 'elements' stamp: 'len 7/15/2016 05:09'!
evaluating: aBlock
	^ self rows: ((1 to: numberOfRows) collect: [:i| self scalars tuple: self numberOfColumns evaluating: [:j| aBlock value: i value: j]])! !

!MatrixModule methodsFor: 'elements' stamp: 'len 1/7/2016 06:41'!
evaluatingDiagonal: aBlock
	| zero |
	zero _ self scalars zero.
	^ self evaluating: [:i :j| i == j ifTrue: [aBlock value: i] ifFalse: [zero]]! !

!MatrixModule methodsFor: 'comparing' stamp: 'len 6/28/2016 09:24'!
hash
	^ scalars hash + numberOfRows hash hashMultiply + numberOfColumns! !

!MatrixModule methodsFor: 'elements' stamp: 'len 11/26/2015 03:42'!
identity
	^ self scalar: scalars one! !

!MatrixModule methodsFor: 'testing' stamp: 'len 11/26/2015 01:37'!
includes: anObject
	(anObject is: #Matrix) ifFalse: [^ false].
	anObject do: [ :each | (scalars includes: each) ifFalse: [^ false]].
	^ true! !

!MatrixModule methodsFor: 'testing' stamp: 'len 3/5/2016 00:32'!
isAssociative
	^ self isSquare and: [scalars isCommutativeRing]! !

!MatrixModule methodsFor: 'testing' stamp: 'len 11/26/2015 15:34'!
isCommutative
	^ self isRing and: [numberOfColumns = 1]! !

!MatrixModule methodsFor: 'testing' stamp: 'len 11/7/2015 22:05'!
isCountable
	^ scalars isCountable! !

!MatrixModule methodsFor: 'testing' stamp: 'len 11/7/2015 22:05'!
isFinite
	^ scalars isFinite! !

!MatrixModule methodsFor: 'testing' stamp: 'len 11/7/2015 22:02'!
isModule
	^ scalars isRing! !

!MatrixModule methodsFor: 'testing' stamp: 'len 11/26/2015 15:32'!
isRing
	^ self isSquare and: [scalars isRing]! !

!MatrixModule methodsFor: 'testing' stamp: 'len 11/3/2015 20:57'!
isSquare
	^ numberOfRows = numberOfColumns! !

!MatrixModule methodsFor: 'accessing' stamp: 'len 3/23/2016 00:29'!
matrixClass
	^ properties at: #matrixClass ifAbsentPut: [RowMatrix]! !

!MatrixModule methodsFor: 'elements' stamp: 'len 10/6/2016 15:33'!
new
	^ self matrixClass new parent: self! !

!MatrixModule methodsFor: 'elements' stamp: 'len 10/6/2016 15:33'!
newFrom: aMatrix
	^ aMatrix copy parent: self! !

!MatrixModule methodsFor: 'accessing' stamp: 'len 11/3/2015 21:42'!
numberOfColumns
	^ numberOfColumns! !

!MatrixModule methodsFor: 'accessing' stamp: 'len 11/3/2015 21:42'!
numberOfRows
	^ numberOfRows! !

!MatrixModule methodsFor: 'initialization' stamp: 'len 4/23/2016 06:14'!
numberOfRows: n columns: m
	numberOfRows _ n.
	numberOfColumns _ m! !

!MatrixModule methodsFor: 'elements' stamp: 'len 11/26/2015 04:36'!
one
	^ self scalar: scalars one! !

!MatrixModule methodsFor: 'converting' stamp: 'len 4/23/2016 06:12'!
over: aRing
	^ self copy scalars: aRing! !

!MatrixModule methodsFor: 'printing' stamp: 'len 6/8/2016 01:53'!
printOn: aStream
	aStream print: self scalars.
	aStream isText
		ifTrue: [aStream nextPutAll: (numberOfRows printString, Character times asString, numberOfColumns printString) super]
		ifFalse: [aStream nextPutAll: '^('; print: numberOfRows; nextPut: Character times; print: numberOfColumns; nextPut: $)]! !

!MatrixModule methodsFor: 'basis' stamp: 'len 7/15/2016 00:40'!
rank
	^ numberOfRows * numberOfColumns! !

!MatrixModule methodsFor: 'elements' stamp: 'len 10/6/2016 15:33'!
rows: anArray
	^ (RowMatrix rows: anArray) parent: self! !

!MatrixModule methodsFor: 'elements' stamp: 'len 2/6/2016 19:57'!
scalar: aNumber
	| zero |
	zero _ scalars zero.
	^ self evaluating: [:i :j| i=j ifTrue: [aNumber] ifFalse: [zero]]! !

!MatrixModule methodsFor: 'accessing' stamp: 'len 11/3/2015 21:43'!
scalars
	^ scalars! !

!MatrixModule methodsFor: 'initialization' stamp: 'len 4/23/2016 06:15'!
scalars: aDomain
	scalars _ aDomain! !

!MatrixModule methodsFor: 'accessing' stamp: 'len 11/9/2015 23:18'!
size
	^ scalars size ** (self numberOfRows * self numberOfColumns)! !

!MatrixModule methodsFor: 'elements' stamp: 'len 10/6/2016 15:33'!
sparse: aSparseTuple
	^ SparseMatrix new coefficients: aSparseTuple; parent: self! !

!MatrixModule methodsFor: 'operations' stamp: 'len 11/26/2015 01:34'!
transposed
	^ self isSquare
		ifTrue: [self]
		ifFalse: [self class new: self numberOfColumns @ self numberOfRows over: scalars]! !

!MatrixModule methodsFor: 'elements' stamp: 'len 11/26/2015 04:36'!
zero
	^ self scalar: scalars zero! !

!MatrixModule class methodsFor: 'instance creation' stamp: 'len 4/23/2016 06:15'!
new: dimension over: aDomain
	^ self new numberOfRows: dimension x columns: dimension y; scalars: aDomain! !

!QuotientModule methodsFor: 'accessing' stamp: 'len 8/24/2016 19:05'!
base
	^ subspace ambient! !

!QuotientModule methodsFor: 'private' stamp: 'len 10/10/2016 08:52'!
buildProjection
	"Answer the quotient map, the canonical projection from the ambient vector space to the quotient space, i.e. the mapping pi:V->V/S that assigns to every v in V the affine subspace v+S."
	| answer |
	answer _ self base to: self evaluating: [:each| self project: each].
	answer name: Character pi asString.
	answer properties
		at: #kernel put: subspace;
		at: #image put: self;
		at: #rightInverse put: (self to: self base evaluating: [:each| each representative]).
	^ answer! !

!QuotientModule methodsFor: 'basis' stamp: 'len 6/4/2016 04:20'!
coordinatesOf: anAffineSubspace
	| v |
	v _ anAffineSubspace representative.
	v _ v - (subspace project: v).
	^ subspace perp basis coordinatesOf: v! !

!QuotientModule methodsFor: 'basis' stamp: 'len 8/30/2016 05:47'!
e: anInteger
	^ AffineLinearSpace representative: (subspace perp e: anInteger) direction: subspace! !

!QuotientModule methodsFor: 'testing' stamp: 'len 8/30/2016 05:47'!
includes: anObject
	^ (anObject isKindOf: AffineLinearSpace) and: [anObject direction = subspace]! !

!QuotientModule methodsFor: 'testing' stamp: 'len 8/10/2016 01:02'!
isQuotient
	^ true! !

!QuotientModule methodsFor: 'printing' stamp: 'len 6/25/2016 01:41'!
printOn: aStream
	(subspace ambient printString includes: $/)
		ifTrue: [aStream nextPut: $(; print: subspace ambient; nextPut: $)]
		ifFalse: [aStream print: subspace ambient].
	aStream nextPut: $/.
	(subspace printString includes: $/)
		ifTrue: [aStream nextPut: $(; print: subspace; nextPut: $)]
		ifFalse: [aStream print: subspace]! !

!QuotientModule methodsFor: 'morphisms' stamp: 'len 10/6/2016 10:36'!
project: aVector
	^ AffineLinearSpace representative: aVector direction: subspace! !

!QuotientModule methodsFor: 'morphisms' stamp: 'len 10/6/2016 09:55'!
projection
	"Answer the natural projection, or quotient map, or canonical homomorphism. This takes elements from the base module or vector space to the corresponding coset (an affine subspace) in the quotient."
	^ properties at: #projection ifAbsentPut: [self buildProjection]! !

!QuotientModule methodsFor: 'basis' stamp: 'len 10/7/2016 08:45'!
rank
	^ subspace corank! !

!QuotientModule methodsFor: 'accessing' stamp: 'len 8/24/2016 19:05'!
relation
	^ EquivalenceRelation on: self base evaluating: [:x :y| subspace includes: x - y]! !

!QuotientModule methodsFor: 'accessing' stamp: 'len 5/25/2016 19:58'!
scalars
	^ subspace scalars! !

!QuotientModule methodsFor: 'accessing' stamp: 'len 11/9/2015 16:17'!
subspace
	^ subspace! !

!QuotientModule methodsFor: 'accessing-private' stamp: 'len 11/25/2015 01:21'!
subspace: aLinearSubspace
	subspace _ aLinearSubspace! !

!QuotientModule class methodsFor: 'instance creation' stamp: 'len 11/22/2015 01:14'!
by: aLinearSubspace
	^ self new subspace: aLinearSubspace! !

!ScalarModule methodsFor: 'basis' stamp: 'len 4/22/2016 21:55'!
coordinatesOf: anObject
	"Answer the coordinates of the argument in the canonic basis."
	^ self scalars tuple: {anObject}! !

!ScalarModule methodsFor: 'basis' stamp: 'len 11/19/2015 19:18'!
e: anInteger
	"Answer the anInteger-th canonic vector."
	^ self scalars one! !

!ScalarModule methodsFor: 'printing' stamp: 'len 4/21/2016 00:04'!
printOn: aStream
	aStream print: scalars! !

!ScalarModule methodsFor: 'basis' stamp: 'len 7/15/2016 00:40'!
rank
	^ 1! !

!ScalarModule methodsFor: 'accessing' stamp: 'len 11/7/2015 02:57'!
scalars
	^ scalars! !

!ScalarModule methodsFor: 'accessing-private' stamp: 'len 2/19/98 01:06'!
scalars: anAlgebraicAmbient
	scalars _ anAlgebraicAmbient! !

!ScalarModule class methodsFor: 'instance creation' stamp: 'len 11/7/2015 03:33'!
over: aField
	^ self new scalars: aField! !

!Submodule methodsFor: 'operations' stamp: 'len 8/30/2016 05:47'!
+ anObject
	| sum |
	(self ambient includes: anObject) ifTrue: [^ AffineLinearSpace representative: anObject direction: self].
	"assume anObject isVectorSpace"
	sum _ self basis copy.
	anObject basis do: [:each| (sum generates: each) ifFalse: [sum add: each]].
	^ self class basis: sum
	
"alternative but 5-10 times slower:
	^ (self basis matrix transposed | aLinearSubspace basis matrix transposed) image apply: self space basis vectorAt
"! !

!Submodule methodsFor: 'operations' stamp: 'len 10/7/2016 09:29'!
 aModule
	aModule = self ambient ifTrue: [^ self].
	^ LinearSystem new
		addAll: self equations;
		addAll: aModule equations;
		kernel! !

!Submodule methodsFor: 'operations' stamp: 'len 5/23/2016 04:25'!
annihilator
	"Answer the annihilator of the receiver, i.e. the space of all linear forms that are 0 at all vectors in the receiver."
	^ self class basis: (self basis extended dual copyFrom: self dimension + 1 to: self ambient dimension)! !

!Submodule methodsFor: 'converting' stamp: 'len 6/9/2016 06:16'!
asAlgebraicVariety
	^ AlgebraicSet on: self ambient asAffineSpace ideal: self equations asPolynomialSystem ideal! !

!Submodule methodsFor: 'basis' stamp: 'len 11/7/2015 03:50'!
basis
	^ basis! !

!Submodule methodsFor: 'accessing-private' stamp: 'len 8/21/97 01:54'!
basis: aLinearBasis
	basis _ aLinearBasis! !

!Submodule methodsFor: 'basis' stamp: 'len 11/25/2015 01:11'!
coordinatesOf: anObject
	^ basis coordinatesOf: anObject! !

!Submodule methodsFor: 'operations' stamp: 'len 4/21/2016 05:41'!
dual
	^ basis dual span! !

!Submodule methodsFor: 'basis' stamp: 'len 11/25/2015 01:11'!
e: anInteger
	^ basis at: anInteger! !

!Submodule methodsFor: 'accessing' stamp: 'len 6/1/2016 06:04'!
equations
	"Answer a linear system defining the receiver."
	| answer |
	answer _ LinearSystem new.
	self annihilator basis do: [:each| answer add: (each eq: self scalars zero)].
	^ answer! !

!Submodule methodsFor: 'accessing' stamp: 'len 6/4/2016 01:44'!
generator
	self dimension = 1 ifFalse: [^ self error: 'not a line'].
	^ self basis first! !

!Submodule methodsFor: 'testing' stamp: 'len 5/25/2016 20:04'!
includes: anObject
	(self ambient includes: anObject) ifFalse: [^ false].
	^ basis generates: anObject! !

!Submodule methodsFor: 'testing' stamp: 'len 1/8/2016 06:23'!
isNonDegenerate
	^ self radical isTrivial! !

!Submodule methodsFor: 'testing' stamp: 'len 5/23/2016 04:26'!
isProper
	^ self ~= self ambient! !

!Submodule methodsFor: 'operations' stamp: 'len 5/23/2016 04:26'!
perp
	"Answer the orthogonal complement of the receiver."
	^ self ambient span: (self annihilator basis vectors collect: [:f| f asVector])

"alternative:
	| k n |
	k _ self dimension.
	n _ self space dimension.
	^ (self basis extended orthogonalized copyFrom: k + 1 to: n) span

alternative 2:
	^ self projection kernel

alternative 3:?
	^ basis dual asArray inject: self space into: [:answer :each| answer intersection: each kernel]	
"! !

!Submodule methodsFor: 'operations' stamp: 'len 9/1/2016 08:01'!
perp2
	"Answer the orthogonal complement of the receiver."
	^ basis dual asArray inject: self ambient into: [:answer :each| answer  each kernel]

"alternative:
	| k n |
	k _ self dimension.
	n _ self space dimension.
	^ (self basis extended orthogonalized copyFrom: k + 1 to: n) span

alternative 2:
	^ self projection kernel"! !

!Submodule methodsFor: 'operations' stamp: 'len 4/3/2016 07:46'!
perp3
	"Answer the orthogonal complement of the receiver."
	^ self projection kernel

"alternative:
	| k n |
	k _ self dimension.
	n _ self space dimension.
	^ (self basis extended orthogonalized copyFrom: k + 1 to: n) span"! !

!Submodule methodsFor: 'printing' stamp: 'len 6/4/2016 04:52'!
printOn: aStream
	| first |
	self basis = self ambient basis ifTrue: [self ambient printOn: aStream. ^ self].
	self isTrivial ifTrue: [aStream nextPut: ${; print: self zero; nextPut: $}. ^ self].
	first _ true.
	aStream nextPut: $<.
	self basis do: [ :each |
		first ifFalse: [aStream nextPutAll: '; '].
		aStream print: each.
		first _ false].
	aStream nextPut: $>! !

!Submodule methodsFor: 'morphisms' stamp: 'len 1/2/2016 04:16'!
project: aVector
	^ self projection value: aVector! !

!Submodule methodsFor: 'morphisms' stamp: 'len 7/4/2016 04:48'!
projection
	"Answer an orthogonal projection on the receiver. A projection P is a linear transformation from the ambient vector space to a subspace such that P^2 = P (idempotent)."
	| answer B B` K matrix |
	answer _ properties at: #projection ifAbsent: [].
	answer notNil ifTrue: [^ answer].
	B _ basis orthogonalized.
	B` _ basis extended orthogonalized.
	K _ self scalars.
	matrix _ (K ** (B size @ B` size)) evaluatingDiagonal: [:i| K one"(B at: i) norm2"].
	answer _ LinearMap from: B` to: B matrix: matrix.
	properties at: #projection put: answer.
	^ answer! !

!Submodule methodsFor: 'operations' stamp: 'len 10/7/2016 08:40'!
quotient
	"Answer the quotient space of the ambient space by the receiver."
	^ QuotientModule by: self! !

!Submodule methodsFor: 'operations' stamp: 'len 9/1/2016 08:01'!
radical
	^ self  self perp! !

!Submodule methodsFor: 'basis' stamp: 'len 10/7/2016 08:58'!
rank
	^ basis size! !

!Submodule methodsFor: 'accessing' stamp: 'len 5/23/2016 04:26'!
scalars
	^ self ambient scalars! !

!Submodule methodsFor: 'elements' stamp: 'len 5/23/2016 04:26'!
zero
	^ self ambient zero! !

!Submodule class methodsFor: 'instance creation' stamp: 'len 8/21/97 01:45'!
basis: aLinearBasis
	"Answer a new instance of the receiver representing the
	linear space generated by the basis aLinearBasis."

	^ self new basis: aLinearBasis! !

!TupleModule methodsFor: 'comparing' stamp: 'len 10/7/2016 08:44'!
= anObject
	self == anObject ifTrue: [^ true].
	^ (anObject isKindOf: TupleModule) and: [anObject scalars = self scalars and: [self dimension = anObject dimension]]! !

!TupleModule methodsFor: 'random' stamp: 'len 4/19/2016 20:13'!
atRandom: aRandom
	^ scalars tuple: self dimension evaluating: [:i| scalars atRandom: aRandom]! !

!TupleModule methodsFor: 'random' stamp: 'len 4/19/2016 22:10'!
atRandom: aRandom bits: bitSize
	| n |
	n _ bitSize / self dimension.
	^ scalars tuple: self dimension evaluating: [:i| scalars atRandom: aRandom bits: n]! !

!TupleModule methodsFor: 'basis' stamp: 'len 11/23/2015 02:34'!
coordinatesOf: aTuple
	^ aTuple! !

!TupleModule methodsFor: 'basis' stamp: 'len 11/2/2015 16:14'!
dimension
	^ dimension! !

!TupleModule methodsFor: 'iterating' stamp: 'len 7/25/2016 23:45'!
do: aBlock
	self upTo: scalars size rank: dimension do: aBlock! !

!TupleModule methodsFor: 'basis' stamp: 'len 4/12/2016 05:36'!
e: anInteger
	^ self scalars tuple: dimension evaluating: [:k| k = anInteger ifTrue: [scalars one] ifFalse: [scalars zero]]! !

!TupleModule methodsFor: 'basis' stamp: 'len 7/10/2016 07:35'!
elementAt: aTuple
	"Answer the vector with coordinates aTuple in the canonical basis (i.e, the standard basis)."
	^ aTuple! !

!TupleModule methodsFor: 'elements' stamp: 'len 4/14/2016 06:45'!
evaluating: aBlock
	^ scalars tuple: dimension evaluating: aBlock! !

!TupleModule methodsFor: 'comparing' stamp: 'len 6/28/2016 09:38'!
hash
	^ scalars hash + dimension! !

!TupleModule methodsFor: 'testing' stamp: 'len 3/30/2016 07:05'!
includes: anObject
	(anObject is: #Tuple) ifFalse: [^ false].
	anObject do: [:each| (scalars includes: each) ifFalse: [^ false]].
	^ true! !

!TupleModule methodsFor: 'testing' stamp: 'len 11/7/2015 22:06'!
isCountable
	^ scalars isCountable! !

!TupleModule methodsFor: 'testing' stamp: 'len 11/7/2015 22:06'!
isFinite
	^ scalars isFinite! !

!TupleModule methodsFor: 'testing' stamp: 'len 11/5/2015 19:23'!
isModule
	^ scalars isRing! !

!TupleModule methodsFor: 'elements' stamp: 'len 7/19/2016 02:45'!
newFrom: anArray
	^ scalars tupleClass newFrom: anArray! !

!TupleModule methodsFor: 'converting' stamp: 'len 4/24/2016 06:36'!
over: aRing
	^ self copy scalars: aRing! !

!TupleModule methodsFor: 'printing' stamp: 'len 6/7/2016 21:52'!
printOn: aStream
	aStream print: self scalars.
	aStream isText
		ifTrue: [aStream nextPutAll: self dimension printString super]
		ifFalse: [aStream nextPutAll: '^'; print: self dimension]! !

!TupleModule methodsFor: 'morphisms' stamp: 'len 10/10/2016 08:43'!
projection: i
	^ LinearForm from: self evaluating: [:x| x at: i]! !

!TupleModule methodsFor: 'basis' stamp: 'len 7/15/2016 00:06'!
rank
	^ dimension! !

!TupleModule methodsFor: 'accessing' stamp: 'len 11/2/2015 17:34'!
scalars
	^ scalars! !

!TupleModule methodsFor: 'private' stamp: 'len 4/24/2016 06:36'!
scalars: aDomain
	scalars _ aDomain! !

!TupleModule methodsFor: 'initialization' stamp: 'len 4/19/2016 21:38'!
setDimension: n scalars: aDomain
	dimension _ n.
	scalars _ aDomain! !

!TupleModule methodsFor: 'iterating' stamp: 'len 7/26/2016 00:19'!
upTo: max rank: n do: aBlock
	| k |
	n = 0 ifTrue: [^ aBlock value: (scalars tuple: #())].
	k _ 1.
	scalars upTo: max do: [:s|
		self upTo: k rank: n-1 do: [:p|
			aBlock value: (p,s).
			(p includes: s) ifTrue: [scalars upTo: k-1 do: [:t| aBlock value: (p,t)]]].
		k _ k + 1]! !

!TupleModule methodsFor: 'elements' stamp: 'len 4/22/2016 21:57'!
zero
	| contents |
	contents _ Array new: self dimension.
	contents atAllPut: self scalars zero.
	^ scalars tuple: contents! !

!TupleModule class methodsFor: 'instance creation' stamp: 'len 4/19/2016 21:37'!
new: dimension over: aDomain
	^ self new setDimension: dimension scalars: aDomain! !

!VectorSpace methodsFor: 'converting' stamp: 'len 10/7/2016 09:01'!
asSubspaceOf: aVectorSpace
	^ super asSubmoduleOf: aVectorSpace! !

!VectorSpace methodsFor: 'basis' stamp: 'len 7/15/2016 00:45'!
dimension
	^ self basis size! !

!VectorSpace methodsFor: 'basis' stamp: 'len 7/15/2016 00:45'!
rank
	^ self dimension! !

!BilinearForms methodsFor: 'operations' stamp: 'len 1/8/2016 06:55'!
alternate
	"Answer the subspace of alternating bilinear forms."
	^ self notYetImplemented! !

!BilinearForms methodsFor: 'accessing' stamp: 'len 11/27/2015 06:32'!
codomain
	^ self scalars! !

!BilinearForms methodsFor: 'basis' stamp: 'len 1/8/2016 06:43'!
coordinatesOf: aBilinearForm
	"Answer the coordinates of aBilinearForm with respect to the domain canonical basis."
	^ self matrices coordinatesOf: (self matrixOf: aBilinearForm)! !

!BilinearForms methodsFor: 'basis' stamp: 'len 1/8/2016 06:49'!
dimension
	^ vectorSpace dimension squared! !

!BilinearForms methodsFor: 'accessing' stamp: 'len 4/19/2016 03:39'!
domain
	^ (vectorSpace, vectorSpace)! !

!BilinearForms methodsFor: 'basis' stamp: 'len 1/8/2016 06:49'!
e: anInteger
	"Answer the anInteger-th canonic vector."
	^ BilinearForm
		from: vectorSpace basis
		matrix: (self matrices e: anInteger)! !

!BilinearForms methodsFor: 'elements' stamp: 'len 1/8/2016 06:51'!
evaluating: aBlock
	^ BilinearForm from: self domain evaluating: aBlock! !

!BilinearForms methodsFor: 'private' stamp: 'len 1/8/2016 06:52'!
matrices
	"Answer the vector space of the matrices associated to the bilinear forms of the receiver."
	^ self scalars ** (vectorSpace dimension @ vectorSpace dimension)! !

!BilinearForms methodsFor: 'private' stamp: 'len 1/8/2016 06:52'!
matrixOf: aBilinearForm
	"Answer the matrix associated to aBilinearForm with respect to the canonical basis."
	^ self matrices
		evaluating: [:i :j|
			aBilinearForm value: (vectorSpace e: i) value: (vectorSpace e: j)]! !

!BilinearForms methodsFor: 'elements' stamp: 'len 4/23/2016 03:53'!
newFrom: anObject
	^ self evaluating: anObject! !

!BilinearForms methodsFor: 'printing' stamp: 'len 4/21/2016 00:01'!
printOn: aStream
	aStream nextPutAll: 'Bil('; print: vectorSpace; nextPut: $)! !

!BilinearForms methodsFor: 'accessing' stamp: 'len 1/8/2016 06:53'!
scalars
	^ vectorSpace scalars! !

!BilinearForms methodsFor: 'operations' stamp: 'len 1/8/2016 06:56'!
symmetric
	"Answer the subspace of symmetric bilinear forms."
	^ self notYetImplemented! !

!BilinearForms methodsFor: 'accessing-private' stamp: 'len 1/8/2016 06:53'!
vectorSpace: aVectorSpace
	vectorSpace _ aVectorSpace! !

!BilinearForms class methodsFor: 'instance creation' stamp: 'len 1/8/2016 06:50'!
on: aVectorSpace
	^ self new vectorSpace: aVectorSpace! !

!Tensors methodsFor: 'accessing' stamp: 'len 11/29/2015 00:38'!
contravariantOrder
	^ self type first! !

!Tensors methodsFor: 'basis' stamp: 'len 1/26/98 18:51'!
coordinatesOf: aTensor
	"Answer the coordinates of the argument in the canonic basis."

	self notYetImplemented! !

!Tensors methodsFor: 'accessing' stamp: 'len 11/29/2015 00:38'!
covariantOrder
	^ self type second! !

!Tensors methodsFor: 'basis' stamp: 'len 11/27/2015 05:29'!
dimension
	^ vectorSpace dimension ** (type first * type second)! !

!Tensors methodsFor: 'basis' stamp: 'len 11/27/2015 05:46'!
e: anInteger
	"Answer the anInteger-th canonic vector."
	| i n answer |
	i _ anInteger.
	n _ vectorSpace dimension.
	answer _ Tensor new.
	type first timesRepeat: [answer add: (vectorSpace e: i \\ n + 1). i _ i // n].
	type second timesRepeat: [answer add: (vectorSpace dual e: i \\ n + 1). i _ i // n].
	^ answer! !

!Tensors methodsFor: 'printing' stamp: 'len 4/21/2016 00:04'!
printOn: aStream
	aStream print: type; nextPutAll: '-tensors('; print: vectorSpace; nextPut: $)! !

!Tensors methodsFor: 'accessing' stamp: 'len 11/27/2015 05:20'!
scalars
	^ vectorSpace scalars! !

!Tensors methodsFor: 'accessing' stamp: 'len 11/29/2015 00:39'!
type
	^ type! !

!Tensors methodsFor: 'accessing-private' stamp: 'len 11/29/2015 00:43'!
type: aPair
	type _ aPair! !

!Tensors methodsFor: 'accessing' stamp: 'len 11/27/2015 05:20'!
vectorSpace
	^ vectorSpace! !

!Tensors methodsFor: 'accessing-private' stamp: 'len 11/27/2015 05:19'!
vectorSpace: aVectorSpace
	vectorSpace _ aVectorSpace! !

!Tensors class methodsFor: 'instance creation' stamp: 'len 11/27/2015 05:20'!
type: aPair on: aVectorSpace
	^ self new type: aPair; vectorSpace: aVectorSpace! !

!HomogeneousPolynomialSpace methodsFor: 'basis' stamp: 'len 6/24/2016 05:47'!
dimension
	| n |
	n _ polynomials rank.
	^ degree + n - 1 choose: degree! !

!HomogeneousPolynomialSpace methodsFor: 'basis' stamp: 'len 6/24/2016 05:51'!
e: anInteger
	^ self ordering e: anInteger degree: degree! !

!HomogeneousPolynomialSpace methodsFor: 'accessing' stamp: 'len 6/24/2016 05:51'!
ordering
	^ polynomials ordering! !

!HomogeneousPolynomialSpace methodsFor: 'printing' stamp: 'len 7/6/2016 08:39'!
printOn: aStream
	aStream print: polynomials; nextPutAll: degree printString sub! !

!PolynomialSpace methodsFor: 'basis' stamp: 'len 4/12/2016 08:08'!
coordinatesOf: aPolynomial
	| coefficients |
	coefficients _ aPolynomial coefficients.
	^ coefficients, ((1 to: self dimension - coefficients size) collect: [:each| self scalars zero])! !

!PolynomialSpace methodsFor: 'accessing' stamp: 'len 7/10/2016 07:39'!
degree
	^ degree! !

!PolynomialSpace methodsFor: 'accessing-private' stamp: 'len 4/6/2016 07:07'!
degree: anInteger
	degree _ anInteger! !

!PolynomialSpace methodsFor: 'morphisms' stamp: 'len 10/4/2016 12:14'!
differential
	^ self to: self evaluating: [:f| f derivative]! !

!PolynomialSpace methodsFor: 'basis' stamp: 'len 4/6/2016 07:06'!
dimension
	^ degree + 1! !

!PolynomialSpace methodsFor: 'basis' stamp: 'len 4/6/2016 07:03'!
e: anInteger
	^ polynomials xTo: anInteger - 1! !

!PolynomialSpace methodsFor: 'basis' stamp: 'len 7/10/2016 07:39'!
elementAt: aTuple
	^ polynomials coefficients: aTuple! !

!PolynomialSpace methodsFor: 'morphisms' stamp: 'len 6/19/2016 04:18'!
integral: a to: b
	^ self dual evaluating: [:f| f integral: a to: b]! !

!PolynomialSpace methodsFor: 'accessing-private' stamp: 'len 4/6/2016 07:07'!
polynomials: aPolynomials
	polynomials _ aPolynomials! !

!PolynomialSpace methodsFor: 'printing' stamp: 'len 6/7/2016 21:44'!
printOn: aStream
	aStream print: polynomials; nextPutAll: ('<', (degree+1) printString) sub! !

!PolynomialSpace methodsFor: 'accessing' stamp: 'len 4/6/2016 07:04'!
scalars
	^ polynomials scalars! !

!AlgebraicExtensionSpace methodsFor: 'basis' stamp: 'len 6/4/2016 18:08'!
coordinatesOf: aVector
	^ self scalars tuple: self dimension evaluating: [:i| aVector representative coefficientAtDegree: i-1]! !

!AlgebraicExtensionSpace methodsFor: 'basis' stamp: 'len 6/4/2016 17:52'!
dimension
	^ self elements degree! !

!AlgebraicExtensionSpace methodsFor: 'basis' stamp: 'len 6/4/2016 18:19'!
e: anInteger
	^ self elements x ** (anInteger - 1)! !

!AlgebraicExtensionSpace methodsFor: 'accessing' stamp: 'len 6/4/2016 17:53'!
scalars
	^ self elements baseField! !

!LieAlgebra methodsFor: 'as yet unclassified' stamp: 'len 5/23/2016 03:57'!
bracket
	^ properties at: #bracket! !

!LieAlgebra methodsFor: 'as yet unclassified' stamp: 'len 5/23/2016 03:56'!
bracket: aFunction
	properties at: #bracket put: aFunction! !

!LieAlgebra methodsFor: 'as yet unclassified' stamp: 'len 5/21/2016 18:54'!
characters
	^ self notYetImplemented! !

!TensorProductSpace methodsFor: 'as yet unclassified' stamp: 'len 6/19/2016 02:40'!
e: anInteger
	^ SimpleTensor left: (left e: anInteger - 1 // left dimension + 1) right: (right e: anInteger - 1 \\ right dimension + 1)! !

!TensorProductSpace methodsFor: 'as yet unclassified' stamp: 'len 6/19/2016 02:42'!
left: aVectorSpace
	left _ aVectorSpace! !

!TensorProductSpace methodsFor: 'as yet unclassified' stamp: 'len 6/19/2016 02:45'!
printOn: aStream
	aStream print: left; space; nextPut: Character otimes; space; print: right! !

!TensorProductSpace methodsFor: 'as yet unclassified' stamp: 'len 7/15/2016 00:40'!
rank
	^ left rank * right rank! !

!TensorProductSpace methodsFor: 'as yet unclassified' stamp: 'len 6/19/2016 02:43'!
right: aVectorSpace
	right _ aVectorSpace! !

!TensorProductSpace methodsFor: 'as yet unclassified' stamp: 'len 6/4/2016 00:59'!
scalars
	^ left scalars! !

!TensorProductSpace class methodsFor: 'as yet unclassified' stamp: 'len 6/19/2016 02:42'!
left: aVectorSpace right: anotherVectorSpace
	^ self new left: aVectorSpace; right: anotherVectorSpace! !

!SyzygyModule methodsFor: 'as yet unclassified' stamp: 'len 7/10/2016 00:00'!
printOn: aStream
	aStream nextPutAll: 'Syz('.
	polynomials do: [:each| aStream print: each] separatedBy: [aStream nextPutAll: ', '].
	aStream nextPut: $)! !

!DivisorsGroup methodsFor: 'as yet unclassified' stamp: 'len 10/5/2016 10:01'!
printOn: aStream
	aStream nextPutAll: 'Div' bold.
	(self scalars isKindOf: Integers) ifFalse: [aStream print: self scalars printText sub].
	aStream nextPut: $(; print: scheme; nextPut: $)! !

!DivisorsGroup methodsFor: 'as yet unclassified' stamp: 'len 10/4/2016 12:11'!
scheme
	^ scheme! !

!DivisorsGroup methodsFor: 'as yet unclassified' stamp: 'len 10/4/2016 12:11'!
scheme: aScheme
	scheme _ aScheme! !

!DivisorsGroup class methodsFor: 'as yet unclassified' stamp: 'len 10/5/2016 10:00'!
on: aScheme
	^ self on: aScheme over: ZZ! !

!DivisorsGroup class methodsFor: 'as yet unclassified' stamp: 'len 10/5/2016 10:00'!
on: aScheme over: aRing
	^ self new scheme: aScheme; scalars: aRing! !

!ExteriorPower methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 23:50'!
degree
	^ degree! !

!ExteriorPower methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 23:50'!
degree: anInteger
	degree _ anInteger! !

!ExteriorPower methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 23:52'!
printOn: aStream
	aStream nextPutAll: '/\'; nextPutAll: (aStream isText ifTrue: [self degree printString super] ifFalse: ['^', self degree printString]); nextPut: $(; print: self space; nextPut: $)! !

!ExteriorPower methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 23:54'!
rank
	^ self space rank choose: self degree! !

!ExteriorPower methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 23:50'!
space
	^ space! !

!ExteriorPower methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 23:50'!
space: aFreeModule
	space _ aFreeModule! !

!CartesianProduct methodsFor: 'comparing' stamp: 'len 12/9/2015 04:51'!
= anObject
	^ (anObject isKindOf: CartesianProduct) and: [anObject components = components]! !

!CartesianProduct methodsFor: 'accessing' stamp: 'len 2/16/2016 07:29'!
arity
	^ components size! !

!CartesianProduct methodsFor: 'accessing' stamp: 'len 2/12/2016 04:11'!
at: anInteger
	^ components at: anInteger! !

!CartesianProduct methodsFor: 'random' stamp: 'len 4/19/2016 20:28'!
atRandom: aRandom
	^ components collect: [:each| each atRandom: aRandom]! !

!CartesianProduct methodsFor: 'random' stamp: 'len 4/19/2016 20:28'!
atRandom: aRandom bits: bitSize
	| n |
	n _ bitSize / components size.
	^ components collect: [:each| each atRandom: aRandom bits: n]! !

!CartesianProduct methodsFor: 'operations' stamp: 'len 4/21/2016 05:08'!
cartesian: aDomain
	^ aDomain class == self class
		ifTrue: [self class components: components, aDomain components]
		ifFalse: [self class components: (components copyWith: aDomain)]! !

!CartesianProduct methodsFor: 'accessing-private' stamp: 'len 11/10/2015 22:13'!
components
	^ components! !

!CartesianProduct methodsFor: 'accessing-private' stamp: 'len 6/11/2016 16:46'!
components: anArray
	components _ anArray as: Tuple! !

!CartesianProduct methodsFor: 'iterating' stamp: 'len 7/29/2016 06:53'!
do: aBlock
	(self components allSatisfy: [:each| each isFinite])
		ifFalse: [^ self upTo: self size rank: self arity do: aBlock].
	self upToComponent: self arity do: aBlock! !

!CartesianProduct methodsFor: 'comparing' stamp: 'len 11/10/2015 23:19'!
hash
	^ components hash! !

!CartesianProduct methodsFor: 'testing' stamp: 'len 4/8/2016 02:33'!
includes: anObject
	components size = anObject size ifFalse: [^ false].
	1 to: components size do: [:i|
		((components at: i) includes: (anObject at: i))
			ifFalse: [^ false]].
	^ true! !

!CartesianProduct methodsFor: 'testing' stamp: 'len 4/22/2016 13:42'!
isProduct
	^ true! !

!CartesianProduct methodsFor: 'printing' stamp: 'len 6/7/2016 00:50'!
printOn: aStream
	components do: [:each| aStream print: each] separatedBy: [aStream nextPut: Character times]! !

!CartesianProduct methodsFor: 'morphisms' stamp: 'len 10/10/2016 08:41'!
projection: i
	^ (self to: (self at: i) evaluating: [:x| x at: i]) name: Character pi asText, i printText sub! !

!CartesianProduct methodsFor: 'accessing' stamp: 'len 2/12/2016 20:09'!
size
	^ components product: [:each| each size]! !

!CartesianProduct methodsFor: 'iterating' stamp: 'len 7/29/2016 06:55'!
upTo: max rank: n do: aBlock
	| k |
	self notYetImplemented.
	n = 0 ifTrue: [^ aBlock value: Tuple new].
	k _ 1.
	(self at: n) upTo: max do: [:s|
		self upTo: k rank: n-1 do: [:p|
			aBlock value: (p,s).
			"(self at: n) upTo: k-1 do: [:t| (p includes: s) ifTrue: [aBlock value: (p,t)]]"].
		k _ k + 1]! !

!CartesianProduct methodsFor: 'iterating' stamp: 'len 7/25/2016 06:22'!
upToComponent: k do: aBlock
	k = 0 ifTrue: [aBlock value: Tuple new. ^ self].
	self upToComponent: k-1 do: [:each| (self at: k) do: [:last| aBlock value: each,last]]! !

!CartesianProduct class methodsFor: 'instance creation' stamp: 'len 11/10/2015 22:17'!
components: anArray
	^ self new components: anArray! !

!EquivalenceClass methodsFor: 'comparing' stamp: 'len 4/25/2016 09:14'!
= anEquivalenceClass
	^ anEquivalenceClass includes: self representative! !

!EquivalenceClass methodsFor: 'iterating' stamp: 'len 4/25/2016 09:33'!
do: aBlock
	self relation domain do: [:each| (self relation includes: {each. self representative}) ifTrue: [aBlock value: each]]! !

!EquivalenceClass methodsFor: 'comparing' stamp: 'len 4/25/2016 09:13'!
hash
	^ self class hash! !

!EquivalenceClass methodsFor: 'testing' stamp: 'len 4/24/2016 04:40'!
includes: anElement
	^ self relation includes: {anElement. self representative}! !

!EquivalenceClass methodsFor: 'printing' stamp: 'len 4/24/2016 04:37'!
printOn: aStream
	aStream nextPut: $[; print: self representative; nextPut: $]! !

!EquivalenceClass methodsFor: 'accessing' stamp: 'len 4/24/2016 04:39'!
relation
	^ properties at: #relation! !

!EquivalenceClass methodsFor: 'accessing-private' stamp: 'len 4/24/2016 04:38'!
relation: anEquivalenceRelation
	properties at: #relation put: anEquivalenceRelation! !

!EquivalenceClass methodsFor: 'accessing' stamp: 'len 4/25/2016 08:40'!
representative
	^ representative! !

!EquivalenceClass methodsFor: 'accessing-private' stamp: 'len 4/25/2016 08:40'!
representative: anElement
	representative _ anElement! !

!EquivalenceClass class methodsFor: 'instance creation' stamp: 'len 4/25/2016 09:23'!
representative: anElement relation: anEquivalenceRelation
	^ self new representative: anElement; relation: anEquivalenceRelation! !

!EquivalenceRelation methodsFor: 'accessing-private' stamp: 'len 4/25/2016 08:47'!
block: aBlock
	properties at: #block put: aBlock! !

!EquivalenceRelation methodsFor: 'iterating' stamp: 'len 4/25/2016 08:55'!
do: aBlock
	self domain do: [:x|
		self domain do: [:y|
			| r |
			(self includes: (r _ {x.y})) ifTrue: [aBlock value: r]]]! !

!EquivalenceRelation methodsFor: 'accessing' stamp: 'len 4/25/2016 08:49'!
domain
	^ properties at: #domain! !

!EquivalenceRelation methodsFor: 'accessing-private' stamp: 'len 4/25/2016 08:49'!
domain: aDomain
	properties at: #domain put: aDomain! !

!EquivalenceRelation methodsFor: 'testing' stamp: 'len 4/25/2016 09:23'!
includes: anArray
	^ (properties at: #block) valueWithArguments: anArray! !

!EquivalenceRelation methodsFor: 'testing' stamp: 'len 4/24/2016 04:25'!
isReflexive
	^ true! !

!EquivalenceRelation methodsFor: 'testing' stamp: 'len 4/24/2016 04:24'!
isSymmetric
	^ true! !

!EquivalenceRelation methodsFor: 'testing' stamp: 'len 4/24/2016 04:25'!
isTransitive
	^ true! !

!EquivalenceRelation methodsFor: 'printing' stamp: 'len 4/25/2016 09:27'!
printOn: aStream
	((properties includesKey: #name) or: [properties includesKey: #elements])
		ifTrue: [^ super printOn: aStream].
	aStream nextPut: $~! !

!EquivalenceRelation class methodsFor: 'instance creation' stamp: 'len 4/25/2016 08:48'!
on: aDomain evaluating: aBlock
	^ self new domain: aDomain; block: aBlock! !

!FormalSet methodsFor: 'operations' stamp: 'len 8/9/2016 23:30'!
/ anEquivalenceRelation
	| relation |
	relation _ anEquivalenceRelation isBlock ifTrue: [EquivalenceRelation on: self evaluating: anEquivalenceRelation] ifFalse: [anEquivalenceRelation].
	^ QuotientSet by: relation! !

!FormalSet methodsFor: 'morphisms' stamp: 'len 8/15/2016 03:26'!
automorphisms
	^ SymmetricGroup on: self! !

!FormalSet methodsFor: 'operations' stamp: 'len 9/1/2016 07:51'!
coproduct: aFormalSet
	"The coproduct in the category of sets is the disjoint union."
	^ self species newFrom: ((self elements collect: [:each| (each, 0)])  (aFormalSet elements collect: [:each| (each, 1)]))! !

!FormalSet methodsFor: 'accessing' stamp: 'len 8/14/2016 05:28'!
null
	"Answer the empty set, i.e. the null object in the category of sets."
	^ self class newFrom: (Set new: 0)! !

!FormalSet methodsFor: 'morphisms' stamp: 'len 8/31/2016 03:36'!
to: aDomain evaluating: aBlock
	^ Function from: self to: aDomain evaluating: aBlock! !

!Magma methodsFor: 'copying' stamp: 'len 5/1/2016 23:33'!
copyEmpty
	^ super copyEmpty operation: self operation! !

!Magma methodsFor: 'testing' stamp: 'len 7/9/2016 00:04'!
isCommutative
	| op X |
	properties at: #isCommutative ifPresent: [:aBoolean| ^ aBoolean].
	op _ self operation.
	X _ self generators ifNil: [self].
	X do: [:x| X do: [:y| (op value: {x.y}) = (op value: {y.x}) ifFalse: [^ false]]].
	^ true! !

!Magma methodsFor: 'morphic' stamp: 'len 7/31/2016 01:50'!
multiplicationTable
	| elements |
	elements _ self elements asArray asSortedCollection: [:a :b|
		| str |
		str _ a printString.
		({'id'. '0'. '1'} includes: str) or: [str <= b printString]].
	^ MultiplicationTableMorph elements: elements operation: self operation! !

!Magma methodsFor: 'morphic' stamp: 'len 8/16/2016 04:02'!
multiplicationTable2
	| elements op table palette p |
	op _ self operation.
	palette _ DiscretePalette default.
	table _ LayoutMorph newRow color: Color red.
	table morphExtent: 150@150.
	elements _ self elements asArray asSortedCollection: [:a :b|
		| str |
		str _ a printString.
		({'id'. '0'. '1'} includes: str) or: [str <= b printString]].
	p _ 1 / elements size.
	elements do: [:x| | column |
		column _ LayoutMorph newColumn color: Color green.
		elements do: [:y| | cell xy |
			xy _ op value: {x. y}.
			cell _ RectangleLikeMorph new color: (palette at: xy).
			cell setBalloonText: xy printString.
			column addMorph: cell proportionalHeight: p].
		table addMorph: column proportionalWidth: p].
	^ table! !

!Magma methodsFor: 'accessing' stamp: 'len 10/9/2016 09:03'!
operation
	^ properties at: #operation ifAbsentPut: [((self, self) to: self evaluating: [:each| each first * each second]) name: '*']! !

!Magma methodsFor: 'accessing-private' stamp: 'len 10/7/2016 07:02'!
operation: aFunction
	properties at: #operation put: (aFunction as: (self, self) -> self)! !

!Loop methodsFor: 'accessing' stamp: 'len 4/23/2016 03:38'!
identity
	^ properties at: #identity! !

!Loop methodsFor: 'accessing-private' stamp: 'len 4/23/2016 03:38'!
identity: anElement
	properties at: #identity put: anElement! !

!Monoid methodsFor: 'copying' stamp: 'len 5/1/2016 23:36'!
copyEmpty
	^ super copyEmpty identity: self identity! !

!Monoid methodsFor: 'accessing' stamp: 'len 2/13/2016 20:40'!
identity
	^ properties at: #identity! !

!Monoid methodsFor: 'accessing-private' stamp: 'len 4/22/2016 17:23'!
identity: anElement
	properties at: #identity put: anElement! !

!Monoid methodsFor: 'testing' stamp: 'len 2/14/2016 18:08'!
isMonoid
	^ true! !

!FreeMonoid methodsFor: 'random' stamp: 'len 4/19/2016 20:31'!
atRandom: aRandom bits: bitSize
	| answer n |
	answer _ self identity.
	n _ symbols size.
	bitSize // n highBit
		timesRepeat:
			[((n + 1) atRandom: aRandom) = 1
				ifFalse: [answer _ (Word x: (symbols atRandom: aRandom)) * answer]].
	^ answer! !

!FreeMonoid methodsFor: 'accessing' stamp: 'len 2/13/2016 20:18'!
generators
	^ symbols collect: [:each| Word x: each]! !

!FreeMonoid methodsFor: 'accessing' stamp: 'len 2/13/2016 20:36'!
identity
	^ Word empty! !

!FreeMonoid methodsFor: 'testing' stamp: 'len 2/13/2016 20:16'!
includes: aWord
	aWord do: [:i :exp| ((symbols includes: i) and: [exp >= 0]) ifFalse: [^ false]].
	^ true! !

!FreeMonoid methodsFor: 'testing' stamp: 'len 7/2/2016 16:55'!
isCommutative
	^ symbols size <= 1! !

!FreeMonoid methodsFor: 'testing' stamp: 'len 2/13/2016 20:42'!
isCountable
	^ true! !

!FreeMonoid methodsFor: 'printing' stamp: 'len 4/23/2016 05:46'!
printOn: aStream
	aStream nextPut: ${.
	symbols do: [:i| aStream print: (Word x: i)] separatedBy: [aStream nextPut: $,].
	aStream nextPutAll: '}*'! !

!FreeMonoid methodsFor: 'morphisms' stamp: 'len 10/9/2016 09:04'!
projection: anObject
	"Answer the 'string projection' endomorphism that removes all occurrences of a letter from a string."
	^ self to: (self copyWithout: anObject) evaluating: [:w| w copyWithout: anObject]! !

!FreeMonoid methodsFor: 'accessing' stamp: 'len 2/14/2016 20:58'!
rank
	^ symbols size! !

!FreeMonoid methodsFor: 'accessing' stamp: 'len 4/22/2016 17:24'!
size
	^ symbols size > 0 ifTrue: [Aleph new] ifFalse: [1]! !

!FreeMonoid methodsFor: 'accessing' stamp: 'len 2/14/2016 21:10'!
symbols
	^ symbols! !

!FreeMonoid methodsFor: 'accessing-private' stamp: 'len 2/14/2016 21:11'!
symbols: aCollection
	symbols _ aCollection! !

!FreeMonoid class methodsFor: 'instance creation' stamp: 'len 6/30/2016 02:25'!
new: anInteger
	^ self on: (1 to: anInteger)! !

!FreeMonoid class methodsFor: 'instance creation' stamp: 'len 2/14/2016 21:10'!
on: aCollection
	^ self new symbols: aCollection! !

!Group methodsFor: 'operations' stamp: 'len 4/29/2016 08:00'!
* anElement
	^ RightCoset on: self representative: anElement! !

!Group methodsFor: 'operations' stamp: 'len 5/2/2016 09:15'!
/ aSubgroup
	"Answer the quotient group (or factor group) of the receiver by the argument.
	Assume aSubgroup is normal in the receiver, otherwise this is just the set of left cosets."
	^ QuotientGroup on: self by: aSubgroup

	"Answer the left factor group (or left quotient group) of the receiver by the argument.
	If aSubgroup is not normal in the receiver, this is just the set of left cosets."
"	^ self collect: [:each| LeftCoset on: aSubgroup representative: each]"! !

!Group methodsFor: 'operations' stamp: 'len 5/2/2016 09:15'!
\ aSubgroup
	"Answer the right factor group (or right quotient group) of the receiver by the argument. If aGroup is not normal in the receiver, this is just the set of right cosets."
	^ self collect: [:each| RightCoset on: aSubgroup representative: each]! !

!Group methodsFor: 'operations' stamp: 'len 10/9/2016 21:12'!
 aGroup
	^ DirectProductGroup components: {self. aGroup}! !

!Group methodsFor: 'operations' stamp: 'len 2/9/2016 06:34'!
abelianization
	"Answer the receiver 'made abelian'."
	| answer |
	answer _ self / self commutator.
	answer properties at: #isCommutative put: true.
	^ answer! !

!Group methodsFor: 'private' stamp: 'len 10/9/2016 08:59'!
additiveInverseMap
	^ (self to: self evaluating: [:each| each negated]) name: '-id'! !

!Group methodsFor: 'private' stamp: 'len 4/19/2016 03:41'!
additiveOperation
	^ (GroupAction from: (self, self) to: self evaluating: [:each| each first + each second]) name: '+'! !

!Group methodsFor: 'morphisms' stamp: 'len 5/22/2016 03:44'!
adjointAction
	^ GroupAction from: (self, self) to: self evaluating: [:each| self operation value: {self operation value: {each first. each second}. self inverseMap value: each first}]! !

!Group methodsFor: 'random' stamp: 'len 5/29/2016 18:03'!
atRandom: aRandom bits: bitSize
	properties at: #elements ifPresent: [:aCollection| ^ (aCollection is: #Domain) ifTrue: [aCollection atRandom: aRandom bits: bitSize] ifFalse: [aCollection atRandom: aRandom]].
	(properties includesKey: #generators)
		ifTrue: [^ (GroupRandomGenerator on: self random: aRandom) bits: bitSize; next].
	^ self subclassResponsibility! !

!Group methodsFor: 'graphs' stamp: 'len 5/25/2016 03:44'!
cayleyGraph: generators
	"Answer the 'colored' Cayley graph of the receiver for the given set of generators.
	The set of generators is usually assumed to be symmetric (contains all inverses too) and to not contain the identity."
	| op G |
	self isFinite ifFalse: [^ self error: 'not a finite group'].
	op _ self operation.
	G _ Digraph unorderedLabeled.
	self do: [:g|
		generators do: [:x|
			G addEdgeFrom: g to: (op value: {g.x}) label: x]].
	^ G! !

!Group methodsFor: 'graphs' stamp: 'len 4/29/2016 07:14'!
cayleyGraphMorph
	^ self cayleyGraphMorph: self generators! !

!Group methodsFor: 'graphs' stamp: 'len 8/16/2016 04:03'!
cayleyGraphMorph: generators
	"Answer the colored Cayley graph of the receiver for the given set of generators.
	The set of generators is usually assumed to be symmetric (contains all inverses too) and to not contain the identity."
	| G answer colors |
	G _ self cayleyGraph: generators.
	answer _ G asMorph.
	colors _ AutomaticPalette new.
	generators do: [:each| colors at: each].
	generators do: [:each| (answer nodeAt: each) color: (colors at: each); morphExtent: 12@10].
	answer edgesAndLabelsDo: [:each :label| each hideLabel; color: (colors at: label)].
	answer nodesDo: [:each| each color: Color transparent; morphExtent: 0@0].
	(answer nodeAt: self identity) color: Color white; shape: #square; morphExtent: 10@10.
	^ answer! !

!Group methodsFor: 'operations-endo' stamp: 'len 5/1/2016 22:58'!
center
	^ self centralizerOf: self! !

!Group methodsFor: 'operations-endo' stamp: 'len 5/1/2016 22:58'!
centralizerOf: aCollection
	| op |
	op _ self operation.
	^ self select: [:x| aCollection allSatisfy: [:y| (op value: {x. y}) = (op value: {y. x})]]! !

!Group methodsFor: 'iterating' stamp: 'len 5/1/2016 23:44'!
collect: aBlock
	"Answer the subgroup resulting of mapping the elements of the receiver by aBlock."
	| elements |
	elements _ Set new.
	self do: [:each| elements add: (aBlock value: each)].
	^ self copyEmpty elements: elements! !

!Group methodsFor: 'operations-endo' stamp: 'len 7/27/2016 07:46'!
commutator
	"Answer the commutator group [G,G] of the receiver G, also called the derived group and noted G`.
	This is the smallest normal subgroup of G such that the quotient G / [G,G] is commutative."
	^ self commutator: self! !

!Group methodsFor: 'operations-endo' stamp: 'len 7/27/2016 07:52'!
commutator2: aGroup
	"Answer the commutator group [G,H] of the receiver G with the argument H."
	| op inverseMap generators |
	generators _ Set2 new.
	op _ self operation.
	inverseMap _ self inverseMap.
	self generators do: [:x|
		aGroup generators do: [:y|
			| xInv yInv |
			xInv _ inverseMap value: x.
			yInv _ inverseMap value: y.
"			answer add: x * y * x reciprocal * y reciprocal]]."
			generators add: (op value: {op value: {op value: {x.y}. xInv}. yInv})]].
	^ (self copyEmpty generators: self generators, aGroup generators) normalClosureOf: generators! !

!Group methodsFor: 'operations-endo' stamp: 'len 5/20/2016 20:19'!
commutator: aSubgroup
	"Answer the commutator group [G,H] of the receiver G with the argument H,"
	| op inverseMap elements |
	elements _ Set new.
	op _ self operation.
	inverseMap _ self inverseMap.
	self do: [:x|
		aSubgroup do: [:y|
			| xInv yInv |
			xInv _ inverseMap value: x.
			yInv _ inverseMap value: y.
"			answer add: x * y * x reciprocal * y reciprocal]]."
			elements add: (op value: {op value: {op value: {x.y}. xInv}. yInv})]].
	^ self copyEmpty elements: elements! !

!Group methodsFor: 'private' stamp: 'len 10/9/2016 08:59'!
compositiveInverseMap
	^ (self to: self evaluating: [:each| each inverse]) name: 'inverse'! !

!Group methodsFor: 'private' stamp: 'len 4/19/2016 03:41'!
compositiveOperation
	^ (GroupAction from: (self, self) to: self evaluating: [:each| each first @ each second]) name: '@'! !

!Group methodsFor: 'private' stamp: 'len 5/1/2016 23:23'!
computeExponent
	| answer |
	answer _ 1.
	self do: [:each| answer _ answer max: (self orderOf: each)].
	^ answer! !

!Group methodsFor: 'private' stamp: 'len 8/30/2016 19:48'!
computeGenerators
	"The receiver is a finite group represented explicitly as a set of its elements, or at least can be iterated over. This method computes a set of generators."
	| n op generators elements |
	(properties includesKey: #elements) ifFalse: [^ nil].
	n _ self order.
	op _ self operation.
	generators _ OrderedCollection new.
	elements _ Set2 with: self identity.
	self elements do: [:g|
		elements size = n ifTrue: [^ generators].
		(elements includes: g)
			ifFalse:
				[| previous |
				generators add: g.
				[(previous _ elements copy) do: [:x|
					generators do: [:y|
						| xy |
						xy _ op value: {x. y}.
						elements add: xy]].
				previous size = elements size] whileFalse]].
	^ generators! !

!Group methodsFor: 'operations' stamp: 'len 7/27/2016 07:17'!
conjugacyClassOf: anElement
	^ self conjugation orbitOf: anElement! !

!Group methodsFor: 'operations' stamp: 'len 7/27/2016 07:11'!
conjugacyClasses
	^ self conjugation orbits! !

!Group methodsFor: 'private' stamp: 'len 7/27/2016 07:15'!
conjugate: x with: y
	| op |
	op _ self operation.
	^ op value: {op value: {self inverseMap value: y. x}. y}! !

!Group methodsFor: 'morphisms' stamp: 'len 4/19/2016 03:41'!
conjugation
	^ GroupAction from: (self, self) to: self evaluating: [:each| self conjugate: each first with: each second]! !

!Group methodsFor: 'operations' stamp: 'len 10/9/2016 21:15'!
coproduct: aGroup
	self flag: #fix. "the free product is usually noted *"
	^ self freeProduct: aGroup! !

!Group methodsFor: 'copying' stamp: 'len 5/1/2016 23:38'!
copyEmpty
	^ super copyEmpty inverseMap: self inverseMap! !

!Group methodsFor: 'graphs' stamp: 'len 7/29/2016 06:39'!
cycleGraph
	| op G elements id |
	self isFinite ifFalse: [^ self error: 'not a finite group'].
	G _ Graph unordered.
	op _ self operation.
	id _ self identity.
	elements _ self elements asSet copyWithout: id.
	[elements isEmpty]
		whileFalse:
			[| e g |
			e _ elements anyOne.
			g _ id.
			[| g` |
			g` _ op value: {g. e}.
			(G hasEdgeFrom: g to: g`) ifFalse: [G addEdgeFrom: g to: g`].
			(g _ g`) = id] whileFalse: [elements remove: g ifAbsent: []]].
	^ G! !

!Group methodsFor: 'graphs' stamp: 'len 5/25/2016 03:46'!
cycleGraph2
	| op G elements id |
	self flag: #fix. "incorrect, test dihedral 4, 5.."
	self isFinite ifFalse: [^ self error: 'not a finite group'].
	G _ Graph unordered.
	op _ self operation.
	id _ self identity.
	elements _ self elements asSet copyWithout: id.
	[elements isEmpty]
		whileFalse:
			[| e g |
			e _ elements remove: elements anyOne.
			g _ id.
			[| g` |
			g` _ op value: {g. e}.
			G addEdgeFrom: g to: g`.
			(g _ g`) = id] whileFalse].
	^ G! !

!Group methodsFor: 'graphs' stamp: 'len 7/29/2016 06:30'!
cycleGraphMorph
	| answer |
	answer _ self cycleGraph asMorph.
"	answer hideLabels."
	(answer nodeAt: self identity) color: Color white; shape: #square.
	^ answer! !

!Group methodsFor: 'private' stamp: 'len 5/2/2016 02:25'!
defaultInverseMap
	^ self multiplicativeInverseMap
"	self do: [:each|
		(each isKindOf: Function) ifTrue: [^ self compositiveInverseMap].
		(each class canUnderstand: #reciprocal) ifTrue: [^ self multiplicativeInverseMap].
		(each class canUnderstand: #negated) ifTrue: [^ self additiveInverseMap].
		^ self error: 'unable to determine group operation']"! !

!Group methodsFor: 'private' stamp: 'len 5/2/2016 02:25'!
defaultOperation
	^ self multiplicativeOperation
"	self do: [:each|
		(each isKindOf: Function) ifTrue: [^ self compositiveOperation].
		(each class canUnderstand: #reciprocal) ifTrue: [^ self multiplicativeOperation].
		(each class canUnderstand: #negated) ifTrue: [^ self additiveOperation].
		^ self error: 'unable to determine group operation']"! !

!Group methodsFor: 'morphisms-series' stamp: 'len 5/1/2016 23:02'!
derivedSeriesDo: aBlock
	"For finite groups the derived series terminates in a perfect group (called the perfect core), which may or may not be trivial."
	| G G` |
	G _ self.
	[G` _ G commutator.
	aBlock value: G`.
	G order = G` order ifTrue: [^ self].
	G _ G`] repeat! !

!Group methodsFor: 'iterating' stamp: 'len 6/30/2016 18:57'!
do: aBlock
	| generators current previous op |
	properties at: #elements ifPresent: [:aCollection| aCollection do: aBlock. ^ self].
	"iterate all elements from the generators:"
	self flag: #fix. "this is too expensive"
	op _ self operation.
	generators _ self generators.
	current _ generators asSet.
	current do: aBlock.
	[previous _ current.
	current _ current copy.
	previous do: [:x|
		generators do: [:y|
			| xy |
			xy _ op value: {x. y}.
			current add: xy ifAbsent: [aBlock value: xy]]].
	previous size < current size] whileTrue.
	properties at: #elements put: current! !

!Group methodsFor: 'accessing' stamp: 'len 5/1/2016 23:23'!
exponent
	"Answer the exponent of the receiver, i.e. the maximum order of an element."
	^ properties at: #exponent ifAbsentPut: [self computeExponent]! !

!Group methodsFor: 'accessing' stamp: 'len 6/30/2016 03:24'!
generator
	self generators size = 1 ifFalse: [self error: 'not cyclic'].
	^ self generators anyOne! !

!Group methodsFor: 'accessing' stamp: 'len 8/30/2016 19:46'!
generators
	properties at: #generators ifPresent: [:aCollection| ^ aCollection].
	^ properties at: #generators put: (self computeGenerators ifNil: [^ nil])! !

!Group methodsFor: 'operations' stamp: 'len 8/4/2016 22:32'!
groupAlgebraOver: aField
	self flag: #fix. "use group multiplication, same as >>groupRingOver:?"
	^ aField freeAlgebraIn: self elements! !

!Group methodsFor: 'operations' stamp: 'len 7/15/2016 18:26'!
groupRing
	^ self groupRingOver: ZZ! !

!Group methodsFor: 'operations' stamp: 'len 8/7/2016 08:43'!
groupRingOver: aRing
	^ GroupRing on: self over: aRing! !

!Group methodsFor: 'operations-endo' stamp: 'len 5/1/2016 22:59'!
hypoabelianization
	^ self / self perfectCore! !

!Group methodsFor: 'accessing' stamp: 'len 2/9/2016 07:22'!
identity
	"Answer the identity element of the receiver."
	^ properties at: #identity ifAbsent: [self do: [:each| ^ properties at: #identity put: (self operation value: {each. self inverseMap value: each})]]! !

!Group methodsFor: 'accessing' stamp: 'len 2/16/2016 05:21'!
indexOf: aSubgroup
	^ (self / aSubgroup) size! !

!Group methodsFor: 'morphisms' stamp: 'len 5/2/2016 09:29'!
innerAutomorphisms
	^ Group compositive elements: (self elements collect: [:a| Conjugation by: a in: self])! !

!Group methodsFor: 'accessing' stamp: 'len 2/8/2016 04:02'!
inverseMap
	^ properties at: #inverseMap ifAbsentPut: [self defaultInverseMap]! !

!Group methodsFor: 'accessing-private' stamp: 'len 5/1/2016 22:37'!
inverseMap: aFunction
	properties at: #inverseMap put: (aFunction as: self -> self)! !

!Group methodsFor: 'testing' stamp: 'len 1/6/2016 05:47'!
isAbelian
	^ self isCommutative! !

!Group methodsFor: 'testing' stamp: 'len 8/31/2016 08:48'!
isAdditive
	^ self operation name = '+'! !

!Group methodsFor: 'testing' stamp: 'len 8/31/2016 08:48'!
isCompositive
	^ self operation name = '@'! !

!Group methodsFor: 'testing' stamp: 'len 5/2/2016 02:32'!
isCyclic
	"Answer true if the receiver is generated by one element."
	self do: [:each| (self span: {each}) size = self size ifTrue: [^ true]].
	^ false! !

!Group methodsFor: 'testing' stamp: 'len 11/7/2015 22:01'!
isGroup
	^ true! !

!Group methodsFor: 'testing' stamp: 'len 5/2/2016 02:32'!
isHypoabelian
	^ self perfectCore isTrivial! !

!Group methodsFor: 'testing' stamp: 'len 11/28/2015 09:09'!
isInitial
	^ self isTrivial! !

!Group methodsFor: 'testing' stamp: 'len 8/31/2016 08:47'!
isMultiplicative
	^ self operation name = '*'! !

!Group methodsFor: 'testing' stamp: 'len 5/2/2016 02:32'!
isNilpotent
	| termination |
	self lowerCentralSeriesDo: [:each| termination _ each].
	^ termination isTrivial! !

!Group methodsFor: 'testing' stamp: 'len 7/1/2016 08:13'!
isNormalIn: aGroup
	"Answer true if the receiver is normal as subgroup of aGroup, i.e. if it is a subgroup invariant under conjugation."
	| inverseMap op |
	op _ self operation.
	inverseMap _ self inverseMap.
	self do: [:x|
		aGroup do: [:y|
			| yInv |
			yInv _ inverseMap value: y.
"			(self includes: other * each * other reciprocal)"
			(self includes: (op value: {op value: {y.x}. yInv}))
				ifFalse: [^ false]]].
	^ true! !

!Group methodsFor: 'testing' stamp: 'len 7/27/2016 07:53'!
isPerfect
	^ self isTrivial not and: [self = self commutator]! !

!Group methodsFor: 'testing' stamp: 'len 5/2/2016 02:31'!
isSolvable
	^ self perfectCore isTrivial

" alternative implementations:
	| G G` |
	G _ self.
	[G isCyclic ifTrue: [^ true].
	G isTrivial ifTrue: [^ false].
	G` _ G commutator.
	G` order = G order ifTrue: [^ false].
	G _ G`] repeat

 or:
	| G G` |
	G _ self.
	[G isTrivial ifTrue: [^ true].
	G` _ G commutator.
	G` order = G order ifTrue: [^ false].
	G _ G`] repeat"
! !

!Group methodsFor: 'testing' stamp: 'len 4/22/2016 14:04'!
isTerminal
	^ self isTrivial! !

!Group methodsFor: 'testing' stamp: 'len 2/16/2016 05:28'!
isTrivial
	"Answer true if the receiver is the trivial group {id}."
	^ self order = 1! !

!Group methodsFor: 'morphisms' stamp: 'len 5/22/2016 03:42'!
leftAction
	^ GroupAction from: (self, self) to: self evaluating: [:each| self operation value: {each first. each second}]! !

!Group methodsFor: 'morphisms-series' stamp: 'len 5/1/2016 23:03'!
lowerCentralSeriesDo: aBlock
	| G G` |
	G _ self.
	[G` _ G commutator: self.
	aBlock value: G`.
	G order = G` order ifTrue: [^ self].
	G _ G`] repeat! !

!Group methodsFor: 'private' stamp: 'len 10/9/2016 08:58'!
multiplicativeInverseMap
	^ (self to: self evaluating: [:each| each reciprocal]) name: 'x^-1'! !

!Group methodsFor: 'private' stamp: 'len 4/19/2016 03:41'!
multiplicativeOperation
	^ (GroupAction from: (self, self) to: self evaluating: [:each| each first * each second]) name: '*'! !

!Group methodsFor: 'operations-endo' stamp: 'len 7/27/2016 06:22'!
normalClosureOf: aSubset
	"From Handbook of Computational Group Theory (Holt) 74p.
	The normal closure of A <= G in G (denoted A^G) is the smallest normal subgroup of G that contains A, i.e. the intersection of all normal subgroups that contain A. Equivalently, it is the set A^G := {g^-1 * a * g | g in G, a in A}."
	| X Y Z random N |
	self flag: #fix. "test and fix, replace >>mormalizerOf:?"
	X _ self generators.
	Y _ aSubset.
	Z _ Y.
	random _ self random.
	N _ self copyEmpty generators: Z.
	["test whether <Z> = <Y>^<X>"
	X allSatisfy: [:g| Z allSatisfy: [:h| N includes: (self conjugate: h with: g)]]]
		whileFalse:
			["add some new random conjugates to Z"
			| random2 |
			random2 _ N random.
			10 timesRepeat:
				[| h g hg |
				g _ random next.
				h _ random2 next.
				hg _ self conjugate: h with: g. "h^g"
				(N includes: hg) ifFalse: [Z add: hg. N _ self copyEmpty generators: Z. random2 _ N random]]].
	^ N! !

!Group methodsFor: 'operations-endo' stamp: 'len 7/1/2016 08:16'!
normalizerOf: aCollection
	"Answer the normal closure of aCollection in the receiver, i.e. the smallest normal subgroup that contains aCollection."
	| inverseMap op |
	op _ self operation.
	inverseMap _ self inverseMap.
	^ self select: [:x| (aCollection collect: [:y| op value: {op value: {x.y}. inverseMap value: x}]) = aCollection]! !

!Group methodsFor: 'accessing' stamp: 'len 8/4/2016 22:33'!
null
	"Answer the trivial subgroup."
	^ self span: #()! !

!Group methodsFor: 'accessing' stamp: 'len 2/8/2016 04:00'!
operation
	^ properties at: #operation ifAbsentPut: [self defaultOperation]! !

!Group methodsFor: 'accessing' stamp: 'len 1/6/2016 05:49'!
order
	^ self size! !

!Group methodsFor: 'accessing' stamp: 'len 6/18/2016 04:02'!
orderOf: anElement
	"Answer the order of the argument in the receiver, i.e. the minimum e such that g^e = 1.
	COHEN Algorithm 1.4.3 (Order of an Element)."
	| h factors id e g1 |
	h _ self size.
	factors _ h factors.
	e _ h.
	id _ self identity.
	factors asSet do: [:p|
		e _ e / (p ** (factors occurrencesOf: p)).
		g1 _ self raise: anElement to: e.
		[g1 = id] whileFalse: [g1 _ self raise: g1 to: p. e _ e*p]].
	^ e! !

!Group methodsFor: 'accessing' stamp: 'len 7/27/2016 02:01'!
orderOf: anElement boundedBy: n
	"Alternative to orderOf:, from Handbook of Computational Group Theory (Holt), 73p. Runs in time at most O(log(n)^3)."
	| id |
	n = 1 ifTrue: [^ 1].
	id _ self identity.
	n factors asSet do: [:p| (self raise: anElement to: n/p) = id ifTrue: [^ self orderOf: anElement boundedBy: n/p]].
	^ n! !

!Group methodsFor: 'morphisms' stamp: 'len 1/6/2016 05:51'!
outerAutomorphisms
	^ self automorphisms / self innerAutomorphisms! !

!Group methodsFor: 'operations-endo' stamp: 'len 5/1/2016 22:59'!
perfectCore
	| answer |
	self derivedSeriesDo: [:each| answer _ each].
	^ answer! !

!Group methodsFor: 'accessing' stamp: 'len 2/15/2016 21:10'!
presentation
	^ properties at: #presentation! !

!Group methodsFor: 'printing' stamp: 'len 5/13/2016 09:21'!
printOn: aStream
	| generators |
	((properties includesKey: #name) or: [(generators _ self generators) isNil])
		ifTrue: [^ super printOn: aStream].
	aStream nextPut: $<.
	generators do: [:each| aStream print: each] separatedBy: [aStream nextPutAll: '; '].
	aStream nextPut: $>! !

!Group methodsFor: 'operations' stamp: 'len 10/9/2016 21:12'!
product: aGroup
	^ self  aGroup! !

!Group methodsFor: 'private' stamp: 'len 6/18/2016 04:03'!
raise: anElement to: anInteger
	| op |
	anInteger = 1 ifTrue: [^ anElement].
	anInteger = 0 ifTrue: [^ self identity].
	anInteger < 0 ifTrue: [^ self raise: (self inverseMap value: anElement) to: anInteger negated].
	op _ self operation.
	^ op value:
		{self raise: (op value: {anElement. anElement}) to: anInteger // 2.
		self raise: anElement to: anInteger \\ 2}! !

!Group methodsFor: 'random' stamp: 'len 8/17/2016 16:43'!
random
	^ GroupRandomGenerator on: self! !

!Group methodsFor: 'morphisms' stamp: 'len 5/22/2016 03:41'!
rightAction
	^ GroupAction from: (self, self) to: self evaluating: [:each| self operation value: {each second. self inverseMap value: each first}]! !

!Group methodsFor: 'morphisms' stamp: 'len 5/16/2016 04:14'!
rightCosetAction
	self flag: #fix."nil"
	^ GroupAction from: (self, nil "set of subgroups?") to: nil "set of right cosets" evaluating: [:each| each first * each second]! !

!Group methodsFor: 'morphisms' stamp: 'len 4/19/2016 03:42'!
rightRegularAction
	^ GroupAction from: (self, self) to: self evaluating: [:each| each first * each second]! !

!Group methodsFor: 'iterating' stamp: 'len 5/1/2016 23:45'!
select: aBlock
	"Answer the subgroup resulting of the selection by aBlock."
	| elements |
	elements _ Set new.
	self do: [:each| (aBlock value: each) ifTrue: [elements add: each]].
	^ self copyEmpty elements: elements! !

!Group methodsFor: 'operations' stamp: 'len 2/13/2016 07:23'!
semidirect: aGroup action: aGroupAction
	^ SemidirectProductGroup left: self right: aGroup action: aGroupAction! !

!Group methodsFor: 'operations' stamp: 'len 5/1/2016 23:45'!
span: aCollection
	"Answer the subgroup generated by the argument."
	^ self copyEmpty generators: aCollection! !

!Group methodsFor: 'private' stamp: 'len 5/1/2016 23:40'!
species
	^ Group! !

!Group methodsFor: 'morphisms' stamp: 'len 8/31/2016 03:55'!
to: aGroup evaluating: aBlock
	"Answer the group homomorphism from the receiver to the argument."
	(aGroup isKindOf: Group) ifFalse: [^ super to: aGroup evaluating: aBlock].
	^ GroupHomomorphism from: self to: aGroup evaluating: aBlock! !

!Group methodsFor: 'accessing' stamp: 'len 8/4/2016 22:33'!
trivial
	"Answer the trivial subgroup."
	^ self null! !

!Group methodsFor: 'morphisms-series' stamp: 'len 5/1/2016 23:06'!
upperCentralSeriesDo: aBlock
	| Z inverseMap op |
	op _ self operation.
	inverseMap _ self inverseMap.
	Z _ self trivial.
	[Z _ self select: [:x| self allSatisfy: [:y| Z includes: (op value: {op value: {x.y}. inverseMap value: x})]].
	aBlock value: Z.
	Z order = self order] whileFalse! !

!Group methodsFor: 'morphisms-series' stamp: 'len 5/1/2016 23:04'!
upperCentralSeriesQuotientsDo: aBlock
	| Z` |
	Z` _ self trivial.
	self upperCentralSeriesDo: [:Z| aBlock value: Z / Z`. Z` _ Z]! !

!Group class methodsFor: 'instance creation' stamp: 'len 6/24/2016 22:28'!
additive
	| G |
	G _ self new.
	G operation: G additiveOperation.
	G inverseMap: G additiveInverseMap.
	^ G! !

!Group class methodsFor: 'example' stamp: 'len 5/14/2016 00:33'!
alternating: aCollection
	"Answer the group of alternate permutations of aCollection."
	^ ((self symmetric: aCollection) select: [:each| each even]) name: 'Alt' bold, '(', aCollection printText, ')'! !

!Group class methodsFor: 'instance creation' stamp: 'len 6/24/2016 22:27'!
compositive
	| G |
	G _ self new.
	G operation: G compositiveOperation.
	G inverseMap: G compositiveInverseMap.
	^ G! !

!Group class methodsFor: 'example' stamp: 'len 5/13/2016 08:54'!
cyclic: n
	^ self integersMod: n! !

!Group class methodsFor: 'example' stamp: 'len 5/14/2016 00:34'!
integersMod: anInteger
	"Answer the cyclic group of integers modulo anInteger."
	^ self additive elements: ((0 to: anInteger-1) collect: [:x| x % anInteger]) asSet; name: 'Z' bold, anInteger printString sub! !

!Group class methodsFor: 'instance creation' stamp: 'len 6/24/2016 22:28'!
multiplicative
	| G |
	G _ self new.
	G operation: G multiplicativeOperation.
	G inverseMap: G multiplicativeInverseMap.
	^ G! !

!Group class methodsFor: 'example' stamp: 'len 5/14/2016 02:45'!
quaternions
	"Answer the quaternionic group."
	^ self multiplicative generators: {Quaternion i. Quaternion j}; name: 'H' bold! !

!Group class methodsFor: 'example' stamp: 'len 5/14/2016 00:33'!
symmetric: aCollection
	"Answer the group of permutations of aCollection."
	| generators X |
	generators _ OrderedCollection new.
	X _ aCollection isInteger ifTrue: [1 to: aCollection] ifFalse: [aCollection asArray].
	1 to: X size do: [:i| | xi |
		xi _ X at: i.
		i+1 to: X size do: [:j|
			generators add: (Permutation transpose: xi with: (X at: j))]].
	^ self compositive generators: generators; name: 'Sym' bold, '(', aCollection printText, ')'! !

!Group class methodsFor: 'example' stamp: 'len 7/15/2016 18:26'!
unitsModulo: m
	"Answer the multiplicative group of units of integers modulo m."
	| elements element Zm pi |
	elements _ Set new.
	Zm _ ZZ mod: m.
	pi _ Zm projection.
	1 to: m - 1 do: [:each|
		(element _ pi value: each) isUnit
			ifTrue: [elements add: element]].
	^ self multiplicative elements: elements! !

!DirectProductGroup methodsFor: 'comparing' stamp: 'len 2/12/2016 20:05'!
= anObject
	^ (anObject isKindOf: DirectProductGroup) and: [anObject components = components]! !

!DirectProductGroup methodsFor: 'accessing' stamp: 'len 2/16/2016 07:30'!
arity
	^ components size! !

!DirectProductGroup methodsFor: 'converting' stamp: 'len 4/19/2016 20:39'!
asCartesianProduct
	^ CartesianProduct components: components! !

!DirectProductGroup methodsFor: 'accessing' stamp: 'len 2/12/2016 20:02'!
at: anInteger
	^ components at: anInteger! !

!DirectProductGroup methodsFor: 'random' stamp: 'len 4/19/2016 20:39'!
atRandom: aRandom
	^ self asCartesianProduct atRandom: aRandom! !

!DirectProductGroup methodsFor: 'random' stamp: 'len 4/19/2016 20:39'!
atRandom: aRandom bits: bits
	^ self asCartesianProduct atRandom: aRandom bits: bits! !

!DirectProductGroup methodsFor: 'accessing-private' stamp: 'len 2/12/2016 20:00'!
components
	^ components! !

!DirectProductGroup methodsFor: 'accessing-private' stamp: 'len 6/11/2016 16:46'!
components: anArray
	components _ anArray as: Tuple! !

!DirectProductGroup methodsFor: 'iterating' stamp: 'len 7/29/2016 06:51'!
do: aBlock
	self asCartesianProduct do: aBlock! !

!DirectProductGroup methodsFor: 'comparing' stamp: 'len 2/12/2016 20:05'!
hash
	^ components hash! !

!DirectProductGroup methodsFor: 'accessing' stamp: 'len 4/22/2016 20:49'!
identity
	^ components collect: [:each| each identity]! !

!DirectProductGroup methodsFor: 'testing' stamp: 'len 2/12/2016 20:14'!
includes: anObject
	anObject size = components size ifFalse: [^ false].
	components with: anObject do: [:G :x| (G includes: x) ifFalse: [^ false]].
	^ true! !

!DirectProductGroup methodsFor: 'accessing' stamp: 'len 10/9/2016 09:10'!
inverseMap
	^ self to: self evaluating: [:x| x withIndexCollect: [:xi :i| (self at: i) inverseMap value: xi]]! !

!DirectProductGroup methodsFor: 'testing' stamp: 'len 4/22/2016 13:43'!
isProduct
	^ true! !

!DirectProductGroup methodsFor: 'accessing' stamp: 'len 10/9/2016 09:03'!
operation
	^ GroupAction from: (self, self) to: self evaluating: [:x| x first withIndexCollect: [:xi :i| (self at: i) operation value: {xi. x second at: i}]]! !

!DirectProductGroup methodsFor: 'printing' stamp: 'len 6/11/2016 21:02'!
printOn: aStream
	components do: [:each| aStream print: each] separatedBy: [aStream nextPut: Character times]! !

!DirectProductGroup methodsFor: 'morphisms' stamp: 'len 10/10/2016 08:42'!
projection: i
	^ (self to: (self at: i) evaluating: [:x| x at: i]) name: Character pi asText, i printText sub! !

!DirectProductGroup methodsFor: 'accessing' stamp: 'len 2/12/2016 20:10'!
size
	^ components product: [:each| each size]! !

!DirectProductGroup class methodsFor: 'instance creation' stamp: 'len 2/12/2016 20:02'!
components: anArray
	^ self new components: anArray! !

!FreeGroup methodsFor: 'comparing' stamp: 'len 7/27/2016 08:02'!
~ aFreeGroup
	"Answer true if the receiver is isomorphic to the argument."
	^ ((aFreeGroup isKindOf: FreeGroup) and: [self rank = aFreeGroup rank]) or: [super ~ aFreeGroup]! !

!FreeGroup methodsFor: 'elements' stamp: 'len 4/19/2016 20:42'!
atRandom: aRandom bits: bitSize
	| answer |
	answer _ self identity.
	bitSize // symbols size highBit
		timesRepeat:
			[answer _ (Word x: (symbols atRandom: aRandom) to: (#(-1 1) atRandom: aRandom)) * answer].
	^ answer! !

!FreeGroup methodsFor: 'accessing' stamp: 'len 2/14/2016 21:13'!
generators
	^ symbols collect: [:each| Word x: each]! !

!FreeGroup methodsFor: 'accessing' stamp: 'len 2/13/2016 17:27'!
identity
	^ Word empty! !

!FreeGroup methodsFor: 'testing' stamp: 'len 2/13/2016 20:16'!
includes: aWord
	aWord do: [:i :exp| (symbols includes: i) ifFalse: [^ false]].
	^ true! !

!FreeGroup methodsFor: 'testing' stamp: 'len 7/2/2016 16:56'!
isCommutative
	^ symbols size <= 1! !

!FreeGroup methodsFor: 'testing' stamp: 'len 2/13/2016 20:42'!
isCountable
	^ true! !

!FreeGroup methodsFor: 'testing' stamp: 'len 2/13/2016 17:31'!
isFinitelyGenerated
	^ true! !

!FreeGroup methodsFor: 'accessing' stamp: 'len 3/3/2016 07:13'!
presentation
	^ GroupPresentation free: self generators! !

!FreeGroup methodsFor: 'printing' stamp: 'len 4/21/2016 00:15'!
printOn: aStream
	aStream nextPutAll: 'F('; print: symbols; nextPut: $)! !

!FreeGroup methodsFor: 'accessing' stamp: 'len 2/14/2016 20:59'!
rank
	^ symbols size! !

!FreeGroup methodsFor: 'accessing' stamp: 'len 4/22/2016 21:50'!
size
	^ symbols size > 0 ifTrue: [Aleph new] ifFalse: [1]! !

!FreeGroup methodsFor: 'accessing' stamp: 'len 2/14/2016 21:09'!
symbols
	^ symbols! !

!FreeGroup methodsFor: 'accessing-private' stamp: 'len 2/14/2016 21:09'!
symbols: aCollection
	symbols _ aCollection! !

!FreeGroup class methodsFor: 'instance creation' stamp: 'len 6/30/2016 02:24'!
new: anInteger
	^ self on: (1 to: anInteger)! !

!FreeGroup class methodsFor: 'instance creation' stamp: 'len 2/14/2016 21:09'!
on: aCollection
	^ self new symbols: aCollection! !

!QuotientGroup methodsFor: 'random' stamp: 'len 5/1/2016 22:55'!
atRandom: aRandomGenerator bits: bitSize
	^ self project: (base atRandom: aRandomGenerator bits: bitSize)! !

!QuotientGroup methodsFor: 'accessing' stamp: 'len 2/8/2016 04:41'!
base
	^ base! !

!QuotientGroup methodsFor: 'accessing-private' stamp: 'len 2/8/2016 04:41'!
base: aGroup
	base _ aGroup! !

!QuotientGroup methodsFor: 'private' stamp: 'len 10/10/2016 08:51'!
buildProjection
	"Answer the natural projection, or quotient map, or canonical homomorphism. This takes elements from the base group to the corresponding coset in the quotient group."
	| answer |
	answer _ self base to: self evaluating: [:each| self project: each].
	answer name: Character pi asString.
	answer properties
		at: #kernel put: subgroup;
		at: #image put: self;
		at: #rightInverse put: (self to: self base evaluating: [:each| each representative]).
	^ answer! !

!QuotientGroup methodsFor: 'private' stamp: 'len 10/7/2016 07:05'!
defaultInverseMap
	^ self base inverseMap as: self -> self! !

!QuotientGroup methodsFor: 'private' stamp: 'len 10/7/2016 07:04'!
defaultOperation
	^ self base operation as: (self, self) -> self! !

!QuotientGroup methodsFor: 'iterating' stamp: 'len 6/27/2016 23:22'!
do: aBlock
	| visited |
	visited _ Set2 new.
	base do: [:each| | x |
		visited add: (x _ self project: each) ifAbsent: [aBlock value: x]]! !

!QuotientGroup methodsFor: 'accessing' stamp: 'len 2/8/2016 05:01'!
identity
	^ self project: base identity! !

!QuotientGroup methodsFor: 'testing' stamp: 'len 8/10/2016 00:59'!
isQuotient
	^ true! !

!QuotientGroup methodsFor: 'printing' stamp: 'len 6/25/2016 01:42'!
printOn: aStream
	(base printString includes: $/)
		ifTrue: [aStream nextPut: $(; print: base; nextPut: $)]
		ifFalse: [aStream print: base].
	aStream nextPut: $/.
	(subgroup printString includes: $/)
		ifTrue: [aStream nextPut: $(; print: subgroup; nextPut: $)]
		ifFalse: [aStream print: subgroup].
! !

!QuotientGroup methodsFor: 'morphisms' stamp: 'len 8/12/2016 08:13'!
project: anElement
	^ Coset on: subgroup representative: anElement! !

!QuotientGroup methodsFor: 'morphisms' stamp: 'len 10/6/2016 09:53'!
projection
	"Answer the natural projection, or quotient map, or canonical homomorphism. This takes elements from the base group to the corresponding coset in the quotient group."
	^ properties at: #projection ifAbsentPut: [self buildProjection]! !

!QuotientGroup methodsFor: 'accessing' stamp: 'len 4/26/2016 08:07'!
relation
	| inv op |
	op _ self base operation.
	inv _ self base inverseMap.
	^ EquivalenceRelation on: self base evaluating: [:x :y| subgroup includes: (op value: {x. inv value: y})]! !

!QuotientGroup methodsFor: 'accessing' stamp: 'len 5/2/2016 02:14'!
size
	^ super size
"	^ properties at: #size ifAbsentPut: [base indexOf: subgroup]"! !

!QuotientGroup methodsFor: 'accessing' stamp: 'len 2/8/2016 04:27'!
subgroup
	^ subgroup! !

!QuotientGroup methodsFor: 'accessing-private' stamp: 'len 2/8/2016 04:27'!
subgroup: aGroup
	subgroup _ aGroup! !

!QuotientGroup class methodsFor: 'instance creation' stamp: 'len 2/8/2016 04:42'!
on: aGroup by: aNormalSubgroup
	^ self new base: aGroup; subgroup: aNormalSubgroup! !

!SemidirectProductGroup methodsFor: 'accessing' stamp: 'len 2/12/2016 06:15'!
action
	^ action! !

!SemidirectProductGroup methodsFor: 'accessing-private' stamp: 'len 2/12/2016 06:17'!
action: anAction
	action _ anAction! !

!SemidirectProductGroup methodsFor: 'accessing' stamp: 'len 2/16/2016 07:30'!
arity
	^ 2! !

!SemidirectProductGroup methodsFor: 'converting' stamp: 'len 4/19/2016 20:55'!
asCartesianProduct
	^ (left, right)! !

!SemidirectProductGroup methodsFor: 'random' stamp: 'len 4/19/2016 20:52'!
atRandom: aRandom
	^ self project: (self asCartesianProduct atRandom: aRandom)! !

!SemidirectProductGroup methodsFor: 'random' stamp: 'len 4/19/2016 20:52'!
atRandom: aRandom bits: bitSize
	^ self project: (self asCartesianProduct atRandom: aRandom bits: bitSize)! !

!SemidirectProductGroup methodsFor: 'private' stamp: 'len 2/12/2016 06:07'!
defaultInverseMap
	^ self multiplicativeInverseMap! !

!SemidirectProductGroup methodsFor: 'private' stamp: 'len 2/12/2016 06:07'!
defaultOperation
	^ self multiplicativeOperation! !

!SemidirectProductGroup methodsFor: 'iterating' stamp: 'len 2/12/2016 06:57'!
do: aBlock
	left do: [:g| right do: [:h| aBlock value: (self project: {g.h})]]! !

!SemidirectProductGroup methodsFor: 'accessing' stamp: 'len 4/22/2016 20:49'!
identity
	^ self project: {left identity. right identity}! !

!SemidirectProductGroup methodsFor: 'testing' stamp: 'len 6/29/2016 21:21'!
isProduct
	^ true! !

!SemidirectProductGroup methodsFor: 'accessing' stamp: 'len 2/12/2016 06:16'!
left
	^ left! !

!SemidirectProductGroup methodsFor: 'accessing-private' stamp: 'len 2/12/2016 06:17'!
left: aGroup
	left _ aGroup! !

!SemidirectProductGroup methodsFor: 'printing' stamp: 'len 4/21/2016 00:16'!
printOn: aStream
	aStream print: left; nextPutAll: ' X| '; print: right! !

!SemidirectProductGroup methodsFor: 'morphisms' stamp: 'len 10/6/2016 15:35'!
project: anArray
	"Project a cartesian product of two elements to their semidirect product."
	^ SemidirectProductElement new
		parent: self;
		left: (anArray at: 1);
		right: (anArray at: 2)! !

!SemidirectProductGroup methodsFor: 'morphisms' stamp: 'len 10/10/2016 08:53'!
projection
	"Answer the projection from the cartesian product of two groups to their semidirect product."
	^ ((left, right) to: self evaluating: [:each| self project: each]) name: Character pi asString! !

!SemidirectProductGroup methodsFor: 'accessing' stamp: 'len 2/12/2016 06:16'!
right
	^ right! !

!SemidirectProductGroup methodsFor: 'accessing-private' stamp: 'len 2/12/2016 06:17'!
right: aGroup
	right _ aGroup! !

!SemidirectProductGroup methodsFor: 'accessing' stamp: 'len 2/12/2016 06:55'!
size
	^ left size * right size! !

!SemidirectProductGroup class methodsFor: 'instance creation' stamp: 'len 2/12/2016 06:16'!
left: aGroup right: anotherGroup action: anAction
	^ self new left: aGroup; right: anotherGroup; action: anAction! !

!PermutationGroup methodsFor: 'comparing' stamp: 'len 7/27/2016 06:41'!
= anObject
	self == anObject ifTrue: [^ true].
	(anObject isKindOf: self species)
		ifFalse: [^ super = anObject].
	self generators ifNotNil: [:g1| anObject generators ifNotNil: [:g2| g1 asSet = g2 asSet ifTrue: [^ true]]].
	self size = anObject size ifFalse: [^ false].
	anObject generators ifNotNil: [:generators| ^ self includesAllOf: generators].
	self generators ifNotNil: [:generators| ^ anObject includesAllOf: generators].
	^ super = anObject! !

!PermutationGroup methodsFor: 'accessing' stamp: 'len 5/6/2016 02:49'!
action
	"Answer the natural action that sends (s, x) to s(x)."
	^ GroupAction from: (self, space) to: space evaluating: [:each| each first value: each second]! !

!PermutationGroup methodsFor: 'accessing' stamp: 'len 5/23/2016 19:34'!
ambient
	"Answer the ambient group."
	^ SymmetricGroup on: space! !

!PermutationGroup methodsFor: 'converting' stamp: 'len 5/25/2016 05:21'!
asLinearGroupOver: aRing
	"Return a linear group over aRing isomorphic to the receiver.
	Assume the space of the receiver is an interval (1 to: n)."
	| n V |
	n _ self degree.
	V _ aRing**n.
	^ (LinearGroup on: V)
		generators: (self generators collect: [:g| V -> V evaluating: [:x| x withIndexCollect: [:xi :i| x at: (g value: i)]]])! !

!PermutationGroup methodsFor: 'converting' stamp: 'len 7/15/2016 18:28'!
asMatrixGroup
	"Return a matrix group isomorphic to the receiver.
	Assume the space of the receiver is an interval (1 to: n)."
	| Z2 n generators |
	Z2 _ ZZ mod: 2.
	n _ self degree.
	generators _ self generators collect: [:g| Z2**(n@n) evaluating: [:i :j| (g at: i) = j ifTrue: [1] ifFalse: [0]]].
	^ (MatrixGroup on: Z2**n) generators: generators! !

!PermutationGroup methodsFor: 'private' stamp: 'len 6/24/2016 03:30'!
computeSize
	"Schreier-Sims algorithm."
	| G answer |
	G _ self.
	answer _ 1.
	space do: [:b| | tree |
		G isTrivial ifTrue: [^ answer].
		tree _ SchreierTree root: b generators: G generators action: G action.
		answer _ answer * tree orbit size.
		G _ tree stabilizer].
	self error: 'what?'.
	^ answer! !

!PermutationGroup methodsFor: 'copying' stamp: 'len 7/23/2016 06:25'!
copyEmpty
	^ super copyEmpty space: space! !

!PermutationGroup methodsFor: 'accessing' stamp: 'len 2/16/2016 05:48'!
degree
	^ self space size! !

!PermutationGroup methodsFor: 'testing' stamp: 'len 5/23/2016 19:35'!
isSubgroupOfAn
	"Monte Carlo test."
	| random |
	self flag: #fix.
	self isTransitive ifFalse: [^ false].
	random _ self random.
	20 timesRepeat:
		[random next isPurple ifTrue: [^ true]].
	^ false! !

!PermutationGroup methodsFor: 'accessing' stamp: 'len 6/30/2016 03:19'!
size
	^ properties at: #size ifAbsentPut: [super size]"self computeSize]"! !

!PermutationGroup methodsFor: 'accessing' stamp: 'len 2/15/2016 21:52'!
space
	^ space! !

!PermutationGroup methodsFor: 'accessing-private' stamp: 'len 5/13/2016 02:47'!
space: aCollection
	space _ aCollection! !

!PermutationGroup methodsFor: 'private' stamp: 'len 3/4/2016 20:36'!
species
	^ PermutationGroup! !

!PermutationGroup class methodsFor: 'examples' stamp: 'len 6/29/2016 00:42'!
M11
	"Answer the Mathieu group on 11 points. With order 7920, this is the smallest of the 26 sporadic simple groups."
	| s1 s2 |
	"ALTERNATIVELY:
	s1 _ Permutation new: 11 cycles: #((1 2 3 4 5 6 7 8 9 10 11).
	s2 _ Permutation new: 11 cycles: #((3 7 11 8) (4 10 5 6)).
	"
	s1 _ Permutation new: 11 cycles: #((1 10) (2 8) (3 11) (5 7)).
	s2 _ Permutation new: 11 cycles: #((1 4 7 6) (2 11 10 9)).
	^ self on: (1 to: 11) generators: {s1. s2}! !

!PermutationGroup class methodsFor: 'examples' stamp: 'len 6/29/2016 00:43'!
M12
	"Answer the Mathieu group on 12 points, the second smallest of the 26 sporadic simple groups, with order 95040."
	| s1 s2 s3 |
	s1 _ Permutation new: 12 cycles: #((1 2 3 4 5 6 7 8 9 10 11)).
	s2 _ Permutation new: 12 cycles: #((3 7 11 8) (4 10 5 6)).
	s3 _ Permutation new: 12 cycles: #((1 12) (2 11) (3 6) (4 8) (5 9) (7 10)).
	^ self on: (1 to: 12) generators: {s1. s2. s3}! !

!PermutationGroup class methodsFor: 'examples' stamp: 'len 5/14/2016 00:30'!
cyclic: n
	"Answer the cyclic group of order n as a permutation group."
	^ self on: (1 to: n) generators: {Permutation cycle: (1 to: n)} :: name: 'C' bold, n printString sub! !

!PermutationGroup class methodsFor: 'examples' stamp: 'len 5/16/2016 07:24'!
dihedral: order
	"Answer the Dihedral group of order n as a permutation group."
	| n s r |
	order even ifFalse: [self error: 'order should be even'].
	n _ order // 2.
	r _ Permutation cycle: (1 to: n).
	s _ Permutation on: (1 to: n) evaluating: [:i| n - i + 1].
	^ self on: (1 to: n) generators: {s. r} :: name: 'Dih' bold, order printString sub! !

!PermutationGroup class methodsFor: 'examples' stamp: 'len 6/29/2016 00:40'!
hessian
	"Answer the Hessian group, a finite group of order 216 introduced by Jordan and named after Otto Hesse."
	| s1 s2 |
	s1 _ Permutation new: 9 cycles: #((1 2 4) (5 6 8) (3 9 7)).
	s2 _ Permutation new: 9 cycles: #((4 5 6) (7 9 8)).
	^ self on: (1 to: 9) generators: {s1. s2}! !

!PermutationGroup class methodsFor: 'examples' stamp: 'len 7/4/2016 05:02'!
klein
	"Answer the Klein four-group (or Vierergruppe) as a permutation group."
	| a b |
	a _ Permutation image: #(2 1 4 3).
	b _ Permutation image: #(3 4 1 2).
	"c _ Permutation values: #(4 3 2 1)."
	^ self on: (1 to: 4) generators: {a.b} :: name: 'V' bold! !

!PermutationGroup class methodsFor: 'instance creation' stamp: 'len 5/2/2016 01:33'!
new: n
	^ self on: (1 to: n)! !

!PermutationGroup class methodsFor: 'instance creation' stamp: 'len 7/23/2016 06:32'!
new: n generators: aCollection
	^ self on: (1 to: n) generators: aCollection! !

!PermutationGroup class methodsFor: 'instance creation' stamp: 'len 2/15/2016 21:50'!
on: aCollection
	^ self new space: aCollection! !

!PermutationGroup class methodsFor: 'instance creation' stamp: 'len 7/25/2016 02:45'!
on: aCollection elements: anotherCollection
	^ self new space: aCollection; elements: anotherCollection! !

!PermutationGroup class methodsFor: 'instance creation' stamp: 'len 5/12/2016 10:11'!
on: aCollection generators: anotherCollection
	^ (self on: aCollection) generators: anotherCollection! !

!AlternatingGroup methodsFor: 'random' stamp: 'len 6/28/2016 08:48'!
atRandom: aRandom bits: bitSize
	| S answer |
	S _ self ambient.
	[(answer _ S atRandom: aRandom bits: bitSize) even] whileFalse.
	^ answer! !

!AlternatingGroup methodsFor: 'private' stamp: 'len 8/30/2016 19:44'!
computeGenerators
	| answer X |
	answer _ OrderedCollection new.
	X _ space asArray.
	1 to: X size - 2 do: [:i| answer add: (Permutation cycle: {i. i+1. i+2})].
	^ answer! !

!AlternatingGroup methodsFor: 'iterating' stamp: 'len 6/28/2016 06:10'!
do: aBlock
	| domain |
	domain _ self space asArray.
	domain permutationsDo: [:each| |p| (p _ Permutation keys: domain values: each) even ifTrue: [aBlock value: p]]! !

!AlternatingGroup methodsFor: 'testing' stamp: 'len 6/29/2016 00:26'!
includes: aPermutation
	^ (aPermutation is: #Permutation) and: ["aPermutation domain <= space and: ["aPermutation even]! !

!AlternatingGroup methodsFor: 'testing' stamp: 'len 2/16/2016 05:54'!
isSimple
	^ self degree >= 5! !

!AlternatingGroup methodsFor: 'printing' stamp: 'len 5/14/2016 00:35'!
printOn: aStream
	aStream nextPutAll: 'Alt' bold; nextPut: $(; print: space; nextPut: $)! !

!AlternatingGroup methodsFor: 'accessing' stamp: 'len 2/16/2016 05:49'!
size
	^ self degree factorial / 2! !

!SymmetricGroup methodsFor: 'comparing' stamp: 'len 5/1/2016 06:32'!
>= anObject
	(anObject isKindOf: PermutationGroup)
		ifTrue: [^ self space >= anObject space].
	^ super >= anObject! !

!SymmetricGroup methodsFor: 'accessing' stamp: 'len 6/24/2016 08:44'!
ambient
	^ self! !

!SymmetricGroup methodsFor: 'elements' stamp: 'len 6/28/2016 06:10'!
atRandom: aRandom
	| domain |
	domain _ self space asArray.
	^ Permutation keys: domain values: (domain shuffledBy: aRandom)! !

!SymmetricGroup methodsFor: 'elements' stamp: 'len 4/19/2016 22:45'!
atRandom: aRandom bits: bits
	^ self atRandom: aRandom! !

!SymmetricGroup methodsFor: 'operations' stamp: 'len 2/16/2016 05:50'!
commutator
	^ AlternatingGroup on: space! !

!SymmetricGroup methodsFor: 'private' stamp: 'len 8/30/2016 20:41'!
computeGenerators
	| answer X |
	answer _ OrderedCollection new.
	X _ space asArray.
	2 to: X size do: [:i| answer add: (Permutation transpose: (X at: 1) with: (X at: i))].
	^ answer
"alternatively: Coxeter generators, the set of (i,i+1) all the adjacent transpositions"! !

!SymmetricGroup methodsFor: 'iterating' stamp: 'len 6/28/2016 06:10'!
do: aBlock
	| domain |
	domain _ self space asArray.
	domain permutationsDo: [:each| aBlock value: (Permutation keys: domain values: each)]! !

!SymmetricGroup methodsFor: 'testing' stamp: 'len 2/15/2016 21:51'!
includes: aPermutation
	^ (aPermutation isKindOf: Permutation) and: [aPermutation domain <= space]! !

!SymmetricGroup methodsFor: 'testing' stamp: 'len 2/16/2016 05:55'!
isAlmostSimple
	^ self degree >= 5! !

!SymmetricGroup methodsFor: 'printing' stamp: 'len 5/14/2016 00:36'!
printOn: aStream
	aStream nextPutAll: 'Sym' bold; nextPut: $(; print: space; nextPut: $)! !

!SymmetricGroup methodsFor: 'accessing' stamp: 'len 2/16/2016 05:50'!
size
	^ self degree factorial! !

!LinearGroup methodsFor: 'accessing' stamp: 'len 5/6/2016 02:47'!
action
	"Answer the natural action that sends (f, v) to f(v)."
	^ GroupAction from: (self, space) to: space evaluating: [:each| each first value: each second]! !

!LinearGroup methodsFor: 'operations' stamp: 'len 3/18/2016 03:33'!
affine
	self flag: #fix.
	^ AffineGroup linear: self! !

!LinearGroup methodsFor: 'accessing' stamp: 'len 5/23/2016 19:31'!
ambient
	"Answer the ambient group."
	^ space automorphisms "the general linear group GL(V)"! !

!LinearGroup methodsFor: 'operations' stamp: 'len 7/11/2016 20:57'!
asMatrixGroup
	self flag: #fix. "the matrix depends on the basis"
	^ (MatrixGroup on: space coordinateSpace) generators: (self generators collect: [:g| g matrix])! !

!LinearGroup methodsFor: 'copying' stamp: 'len 7/23/2016 06:26'!
copyEmpty
	^ super copyEmpty space: space! !

!LinearGroup methodsFor: 'private' stamp: 'len 2/11/2016 19:59'!
defaultInverseMap
	^ self compositiveInverseMap! !

!LinearGroup methodsFor: 'private' stamp: 'len 2/11/2016 19:59'!
defaultOperation
	^ self compositiveOperation! !

!LinearGroup methodsFor: 'accessing' stamp: 'len 6/20/2016 19:36'!
degree
	^ space dimension! !

!LinearGroup methodsFor: 'iterating' stamp: 'len 6/23/2016 07:02'!
do: aBlock
	self flag: #fix.
	^ super do: aBlock
"	space endomorphisms do: [:each| (self includes: each) ifTrue: [aBlock value: each]]"! !

!LinearGroup methodsFor: 'invariants' stamp: 'len 8/3/2016 08:15'!
hilbertSeries
	"This is the sum of dim(S_d ^G z^d for d>=0 (by Molien's formula, 1897), i.e. it counts the homogeneous polynomials of a given degree d that are invariants for the group."
	| order |
	order _ self size.
	order | self scalars characteristic ifTrue: [self error: 'group order divides characteristic'].
	^ (self elements sum: [:g| g characteristicPolynomial asRationalFunction reciprocal]) / order! !

!LinearGroup methodsFor: 'accessing' stamp: 'len 2/11/2016 20:01'!
identity
	^ space id! !

!LinearGroup methodsFor: 'testing' stamp: 'len 2/22/2016 00:27'!
isFinite
	^ self scalars isFinite or: [super isFinite]! !

!LinearGroup methodsFor: 'invariants' stamp: 'len 8/2/2016 10:26'!
polynomialAction
	"Answer the action of the receiver on the polynomial ring K[x1...xn]."
	| R |
	R _ self space coordinateRing.
	^ GroupAction from: (self, R) to: R evaluating: [:each| each second @ each first]! !

!LinearGroup methodsFor: 'printing' stamp: 'len 5/25/2016 05:09'!
printOn: aStream
	self class = LinearGroup ifTrue: [^ super printOn: aStream].
	aStream nextPutAll: self shortName bold; nextPut: $(; print: space; nextPut: $)! !

!LinearGroup methodsFor: 'invariants' stamp: 'len 8/2/2016 10:27'!
reynolds
	"Answer the Reynolds operator. Properties:
	- K-linear map S -> S^G;
	- restricts to the identity on S^G;
	- it's an S^G-module homomorphisms: R(p*q) = p*R(q) for all invariants p in S^G."
	| order action |
	order _ self size.
	action _ self polynomialAction.
	^ self space coordinateRing -> self invariantsRing evaluating: [:p| (self sum: [:g| action value: {g. p}]) / order]! !

!LinearGroup methodsFor: 'accessing' stamp: 'len 2/11/2016 20:15'!
scalars
	^ space scalars! !

!LinearGroup methodsFor: 'printing' stamp: 'len 2/11/2016 20:01'!
shortName
	^ self class name! !

!LinearGroup methodsFor: 'accessing' stamp: 'len 2/11/2016 19:57'!
space
	^ space! !

!LinearGroup methodsFor: 'accessing-private' stamp: 'len 2/11/2016 19:57'!
space: aVectorSpace
	space _ aVectorSpace! !

!LinearGroup methodsFor: 'private' stamp: 'len 2/12/2016 22:38'!
species
	^ LinearGroup! !

!LinearGroup class methodsFor: 'instance creation' stamp: 'len 2/11/2016 20:28'!
on: aVectorSpace
	^ self new space: aVectorSpace! !

!GeneralLinearGroup methodsFor: 'comparing' stamp: 'len 5/1/2016 06:34'!
>= anObject
	(anObject isKindOf: LinearGroup) ifTrue: [^ space >= anObject space].
	^ super >= anObject! !

!GeneralLinearGroup methodsFor: 'operations' stamp: 'len 6/4/2016 04:35'!
affine
	^ GeneralAffineGroup on: space asAffineSpace! !

!GeneralLinearGroup methodsFor: 'accessing' stamp: 'len 6/24/2016 08:44'!
ambient
	^ self! !

!GeneralLinearGroup methodsFor: 'operations' stamp: 'len 4/17/2016 06:58'!
asMatrixGroup
	^ GeneralLinearMatrixGroup on: space coordinateSpace! !

!GeneralLinearGroup methodsFor: 'random' stamp: 'len 8/30/2016 20:08'!
atRandom: aRandom
	| answer |
	[(answer _ self space endomorphisms atRandom: aRandom) isInvertible] whileFalse.
	^ answer! !

!GeneralLinearGroup methodsFor: 'random' stamp: 'len 8/30/2016 20:08'!
atRandom: aRandom bits: bitSize
	| answer |
	[(answer _ self space endomorphisms atRandom: aRandom bits: bitSize) isInvertible] whileFalse.
	^ answer! !

!GeneralLinearGroup methodsFor: 'operations' stamp: 'len 2/11/2016 20:20'!
center
	^ ScalarGroup on: space! !

!GeneralLinearGroup methodsFor: 'operations' stamp: 'len 4/17/2016 07:08'!
commutator
	(space dimension = 2 and: [space scalars size = 2])
		ifFalse: [^ SpecialLinearGroup on: space].
	^ properties at: #commutator ifAbsentPut: [super commutator]! !

!GeneralLinearGroup methodsFor: 'testing' stamp: 'len 5/22/2016 22:17'!
includes: aLinearMap
	^ (space endomorphisms includes: aLinearMap) and: [aLinearMap determinant isZero not]! !

!GeneralLinearGroup methodsFor: 'operations' stamp: 'len 2/11/2016 20:17'!
orthogonal
	^ OrthogonalGroup on: space! !

!GeneralLinearGroup methodsFor: 'operations' stamp: 'len 8/5/2016 05:14'!
projective
	"Answer the projective (general) linear group PGL(V) which is the quotient of the receiver by its center (the scalar transformations)."
	^ ProjectiveGeneralLinearGroup on: space projective! !

!GeneralLinearGroup methodsFor: 'printing' stamp: 'len 2/11/2016 20:04'!
shortName
	^ 'GL'! !

!GeneralLinearGroup methodsFor: 'accessing' stamp: 'len 6/17/2016 22:19'!
size
	| q n |
	self space isInfinite ifTrue: [^ self space size]. "?"
	(self space scalars isField and: [self space scalars isFinite])
		ifFalse: [^ super size].
	q _ self space scalars size.
	n _ self space dimension.
	^ q ** (n*(n-1)/2) * ((1 to: n) inject: 1 into: [:x :k| q**k - 1 * x])! !

!GeneralLinearGroup methodsFor: 'operations' stamp: 'len 2/12/2016 18:58'!
special
	^ SpecialLinearGroup on: space! !

!OrthogonalGroup methodsFor: 'operations' stamp: 'len 6/4/2016 04:35'!
affine
	^ EuclideanGroup on: space asAffineSpace! !

!OrthogonalGroup methodsFor: 'operations' stamp: 'len 8/30/2016 20:14'!
asMatrixGroup
	^ OrthogonalMatrixGroup on: space coordinateSpace! !

!OrthogonalGroup methodsFor: 'random' stamp: 'len 4/19/2016 20:43'!
atRandom: aRandom
	| answer v |
	answer _ space id.
	space dimension "heuristic"
		timesRepeat:
			[[(v _ space atRandom: aRandom) isZero] whileTrue.
			answer _ answer @ (self reflectionAt: v)].
	^ answer! !

!OrthogonalGroup methodsFor: 'random' stamp: 'len 4/19/2016 22:47'!
atRandom: aRandom bits: bitSize
	| answer v |
	answer _ space id.
	space dimension "heuristic"
		timesRepeat:
			[[(v _ space atRandom: aRandom bits: bitSize / space dimension) isZero] whileTrue.
			answer _ answer @ (self reflectionAt: v)].
	^ answer! !

!OrthogonalGroup methodsFor: 'operations' stamp: 'len 2/11/2016 22:07'!
coxeter: aMatrix
	"Answer the geometric Coxeter group associated with the Coxeter matrix aMatrix."
	^ self notYetImplemented! !

!OrthogonalGroup methodsFor: 'testing' stamp: 'len 5/22/2016 22:17'!
includes: aLinearMap
	^ (space endomorphisms includes: aLinearMap) and: [aLinearMap isOrthogonal]! !

!OrthogonalGroup methodsFor: 'elements' stamp: 'len 2/11/2016 20:05'!
reflectionAt: aVector
	"Answer the orthogonal reflection with mirror hyperplane perpendicular to aVector."
	^ space endomorphisms evaluating: [:v| v - ((space innerProduct value: {v. aVector}) * 2 / (space innerProduct value: {aVector. aVector}) * aVector)]! !

!OrthogonalGroup methodsFor: 'printing' stamp: 'len 2/11/2016 20:06'!
shortName
	^ 'O'! !

!OrthogonalGroup methodsFor: 'operations' stamp: 'len 2/12/2016 18:59'!
special
	^ SpecialOrthogonalGroup on: space! !

!ScalarGroup methodsFor: 'operations' stamp: 'len 4/23/2016 06:09'!
asMatrixGroup
	^ ScalarMatrixGroup on: space coordinateSpace! !

!ScalarGroup methodsFor: 'random' stamp: 'len 4/19/2016 20:46'!
atRandom: aRandom
	^ space endomorphisms scalar: (space scalars atRandom: aRandom)! !

!ScalarGroup methodsFor: 'random' stamp: 'len 4/19/2016 20:45'!
atRandom: aRandom bits: bitSize
	^ space endomorphisms scalar: (space scalars atRandom: aRandom bits: bitSize / space dimension)! !

!ScalarGroup methodsFor: 'accessing' stamp: 'len 2/12/2016 02:17'!
dimension
	^ 1! !

!ScalarGroup methodsFor: 'iterating' stamp: 'len 2/11/2016 20:11'!
do: aBlock
	| endos |
	endos _ space endomorphisms.
	self scalars do: [:each| aBlock value: (endos scalar: each)]! !

!ScalarGroup methodsFor: 'testing' stamp: 'len 5/22/2016 22:18'!
includes: aLinearMap
	^ (space endomorphisms includes: aLinearMap) and: [aLinearMap isScalar]! !

!ScalarGroup methodsFor: 'testing' stamp: 'len 2/12/2016 02:19'!
isCommutative
	^ space scalars isCommutative! !

!ScalarGroup methodsFor: 'printing' stamp: 'len 2/11/2016 20:08'!
shortName
	^ 'Z'! !

!ScalarGroup methodsFor: 'operations' stamp: 'len 2/12/2016 19:01'!
special
	^ SpecialScalarGroup on: space! !

!SpecialLinearGroup methodsFor: 'operations' stamp: 'len 4/23/2016 06:09'!
asMatrixGroup
	^ SpecialLinearMatrixGroup on: space coordinateSpace! !

!SpecialLinearGroup methodsFor: 'operations' stamp: 'len 2/11/2016 20:20'!
center
	^ SpecialScalarGroup on: space! !

!SpecialLinearGroup methodsFor: 'testing' stamp: 'len 5/22/2016 22:18'!
includes: aLinearMap
	^ (space endomorphisms includes: aLinearMap) and: [aLinearMap determinant = space scalars one]! !

!SpecialLinearGroup methodsFor: 'operations' stamp: 'len 6/10/2016 05:38'!
projective
	"Answer the projective special linear group PSL(V) which is the quotient of the receiver by its center {Id, -Id}."
	^ ProjectiveSpecialLinearGroup on: space projective! !

!SpecialLinearGroup methodsFor: 'printing' stamp: 'len 2/11/2016 20:13'!
shortName
	^ 'SL'! !

!SpecialOrthogonalGroup methodsFor: 'operations' stamp: 'len 2/12/2016 18:44'!
affine
	^ SpecialEuclideanGroup on: space affine! !

!SpecialOrthogonalGroup methodsFor: 'operations' stamp: 'len 4/23/2016 06:09'!
asMatrixGroup
	^ SpecialOrthogonalMatrixGroup on: space coordinateSpace! !

!SpecialOrthogonalGroup methodsFor: 'testing' stamp: 'len 5/22/2016 22:18'!
includes: aLinearMap
	^ (space endomorphisms includes: aLinearMap) and: [aLinearMap isOrthogonal and: [aLinearMap determinant = self scalars one]]! !

!SpecialOrthogonalGroup methodsFor: 'printing' stamp: 'len 2/11/2016 20:20'!
shortName
	^ 'SO'! !

!SpecialScalarGroup methodsFor: 'operations' stamp: 'len 4/23/2016 06:09'!
asMatrixGroup
	^ SpecialScalarMatrixGroup on: space coordinateSpace! !

!SpecialScalarGroup methodsFor: 'testing' stamp: 'len 5/22/2016 22:30'!
includes: aLinearMap
	self flag: #fix. "what? this is just {id}?"
	^ (space endomorphisms includes: aLinearMap) and: [aLinearMap isScalar and: [aLinearMap determinant = space scalars one]]! !

!SpecialScalarGroup methodsFor: 'testing' stamp: 'len 2/12/2016 19:01'!
isCommutative
	^ space scalars isCommutative! !

!SpecialScalarGroup methodsFor: 'printing' stamp: 'len 2/11/2016 20:19'!
shortName
	^ 'SZ'! !

!MatrixGroup methodsFor: 'accessing' stamp: 'len 8/5/2016 23:22'!
action
	"Answer the natural action that sends (M, x) to M*x."
	^ self rightAction! !

!MatrixGroup methodsFor: 'accessing' stamp: 'len 5/23/2016 19:32'!
ambient
	"Answer the ambient group."
	^ GeneralLinearMatrixGroup on: space! !

!MatrixGroup methodsFor: 'copying' stamp: 'len 7/23/2016 06:27'!
copyEmpty
	^ super copyEmpty space: space! !

!MatrixGroup methodsFor: 'private' stamp: 'len 2/11/2016 05:01'!
defaultInverseMap
	^ self multiplicativeInverseMap! !

!MatrixGroup methodsFor: 'private' stamp: 'len 2/11/2016 05:01'!
defaultOperation
	^ self multiplicativeOperation! !

!MatrixGroup methodsFor: 'accessing' stamp: 'len 6/20/2016 19:37'!
degree
	^ space dimension! !

!MatrixGroup methodsFor: 'iterating' stamp: 'len 6/23/2016 07:03'!
do: aBlock
	self flag: #fix.
	^ super do: aBlock
"	matrices do: [:each| (self includes: each) ifTrue: [aBlock value: each]]"! !

!MatrixGroup methodsFor: 'invariants' stamp: 'len 8/3/2016 08:15'!
hilbertSeries
	"This is the sum of dim(S_d ^G z^d for d>=0 (by Molien's formula, 1897), i.e. it counts the homogeneous polynomials of a given degree d that are invariants for the group."
	| order |
	order _ self size.
	order | self scalars characteristic ifTrue: [self error: 'group order divides characteristic'].
	^ (self elements sum: [:g| g characteristicPolynomial asRationalFunction reciprocal]) / order! !

!MatrixGroup methodsFor: 'accessing' stamp: 'len 2/13/2016 07:40'!
identity
	^ matrices identity! !

!MatrixGroup methodsFor: 'testing' stamp: 'len 2/22/2016 00:27'!
isFinite
	^ self scalars isFinite or: [super isFinite]! !

!MatrixGroup methodsFor: 'accessing' stamp: 'len 8/5/2016 23:22'!
leftAction
	"Answer the natural action that sends (M, x) to x*M."
	^ GroupAction from: (self, space) to: space evaluating: [:each| each second * each first]! !

!MatrixGroup methodsFor: 'invariants' stamp: 'len 8/2/2016 10:24'!
polynomialAction
	"Answer the action of the receiver on the polynomial ring K[x1...xn]."
	| R X |
	R _ space coordinateRing.
	X _ R tuple: R rank evaluating: [:i| R x: i].
	^ GroupAction from: (self, R) to: R evaluating: [:each| each second value: each first * X]! !

!MatrixGroup methodsFor: 'printing' stamp: 'len 6/7/2016 21:47'!
printOn: aStream
	self class = MatrixGroup ifTrue: [^ super printOn: aStream].
	aStream isText
		ifTrue:
			[aStream nextPutAll: self shortName bold; nextPutAll: space dimension printString sub; nextPut: $(; print: self scalars; nextPut: $)]
		ifFalse:
			[aStream nextPutAll: self shortName; nextPut: $(; print: self scalars; nextPut: $,; print: space dimension; nextPut: $)]! !

!MatrixGroup methodsFor: 'invariants' stamp: 'len 10/4/2016 12:28'!
reynolds
	"Answer the Reynolds operator. Properties:
	- K-linear map S -> S^G;
	- restricts to the identity on S^G;
	- it's an S^G-module homomorphisms: R(p*q) = p*R(q) for all invariants p in S^G."
	| order action |
	order _ self size.
	action _ self polynomialAction.
	^ self space coordinateRing to: self invariantsRing evaluating: [:p| (self sum: [:g| action value: {g. p}]) / order]! !

!MatrixGroup methodsFor: 'accessing' stamp: 'len 8/5/2016 23:21'!
rightAction
	"Answer the natural action that sends (M, x) to M*x."
	^ GroupAction from: (self, space) to: space evaluating: [:each| each first * each second]! !

!MatrixGroup methodsFor: 'accessing' stamp: 'len 2/13/2016 07:45'!
scalars
	^ space scalars! !

!MatrixGroup methodsFor: 'printing' stamp: 'len 2/11/2016 05:04'!
shortName
	^ self subclassResponsibility! !

!MatrixGroup methodsFor: 'accessing' stamp: 'len 2/13/2016 07:46'!
space
	^ space! !

!MatrixGroup methodsFor: 'accessing-private' stamp: 'len 2/13/2016 07:40'!
space: aTuples
	space _ aTuples.
	matrices _ aTuples scalars ** (space dimension @ space dimension)! !

!MatrixGroup methodsFor: 'private' stamp: 'len 2/12/2016 22:38'!
species
	^ MatrixGroup! !

!MatrixGroup class methodsFor: 'examples' stamp: 'len 7/10/2016 23:29'!
C3
	"Answer the cyclic matrix group of order 3."
	| V M a |
	V _ (Field GF: 5) ** 2.
	M _ V scalars ** (2@2).
	a _ M elementAt: (0,1,-1,-1) % 5.
	^ self on: V generators: {a}! !

!MatrixGroup class methodsFor: 'examples' stamp: 'len 7/10/2016 23:29'!
C4
	"Answer the cyclic matrix group of order 4."
	| V M a |
	V _ (Field GF: 7) ** 2.
	M _ V scalars ** (2@2).
	a _ M elementAt: (0,-1,1,0) % 7.
	^ self on: V generators: {a}! !

!MatrixGroup class methodsFor: 'examples' stamp: 'len 8/2/2016 10:14'!
klein
	"Answer the Klein four-group (or Vierergruppe) as a matrix group."
	| V M a b |
	V _ QQ ** 2.
	M _ V scalars ** (2@2).
	a _ M elementAt: (1,0,0,-1).
	b _ a negated.
	^ self on: V generators: {a. b} ":: name: 'V' bold"! !

!MatrixGroup class methodsFor: 'instance creation' stamp: 'len 2/13/2016 07:39'!
on: aTuples
	^ self new space: aTuples! !

!MatrixGroup class methodsFor: 'instance creation' stamp: 'len 7/9/2016 07:42'!
on: aTuples generators: aCollection
	^ (self on: aTuples) generators: aCollection! !

!GeneralLinearMatrixGroup methodsFor: 'comparing' stamp: 'len 5/1/2016 06:35'!
>= anObject
	(anObject isKindOf: MatrixGroup) ifTrue: [^ space >= anObject space].
	^ super >= anObject! !

!GeneralLinearMatrixGroup methodsFor: 'accessing' stamp: 'len 6/24/2016 08:44'!
ambient
	^ self! !

!GeneralLinearMatrixGroup methodsFor: 'random' stamp: 'len 8/30/2016 20:10'!
atRandom: aRandom
	| answer |
	[(answer _ matrices atRandom: aRandom) isSingular] whileTrue.
	^ answer! !

!GeneralLinearMatrixGroup methodsFor: 'random' stamp: 'len 8/30/2016 20:10'!
atRandom: aRandom bits: bitSize
	| answer |
	[(answer _ matrices atRandom: aRandom bits: bitSize) isSingular] whileTrue.
	^ answer! !

!GeneralLinearMatrixGroup methodsFor: 'operations' stamp: 'len 2/13/2016 07:42'!
center
	^ ScalarMatrixGroup on: space! !

!GeneralLinearMatrixGroup methodsFor: 'operations' stamp: 'len 2/13/2016 07:43'!
commutator
	(self dimension = 2 and: [self scalars size = 2])
		ifFalse: [^ SpecialLinearMatrixGroup on: space].
	^ properties at: #commutator! !

!GeneralLinearMatrixGroup methodsFor: 'testing' stamp: 'len 5/22/2016 22:32'!
includes: aMatrix
	^ (matrices includes: aMatrix) and: [aMatrix determinant isZero not]! !

!GeneralLinearMatrixGroup methodsFor: 'operations' stamp: 'len 2/13/2016 07:42'!
orthogonal
	^ OrthogonalMatrixGroup on: space! !

!GeneralLinearMatrixGroup methodsFor: 'printing' stamp: 'len 2/11/2016 05:04'!
shortName
	^ 'GL'! !

!GeneralLinearMatrixGroup methodsFor: 'accessing' stamp: 'len 4/28/2016 02:36'!
size
	| q n |
	(self space scalars isField and: [self space scalars isFinite])
		ifFalse: [^ super size].
	q _ self space scalars size.
	n _ self space dimension .
	^ q ** (n*(n-1)/2) * ((1 to: n) inject: 1 into: [:x :k| q**k - 1 * x])! !

!GeneralLinearMatrixGroup methodsFor: 'operations' stamp: 'len 2/13/2016 07:43'!
special
	"Answer the special linear group SL(n) which is a subgroup of the receiver."
	^ SpecialLinearMatrixGroup on: space! !

!OrthogonalMatrixGroup methodsFor: 'testing' stamp: 'len 2/11/2016 05:14'!
includes: aMatrix
	^ (matrices includes: aMatrix) and: [aMatrix isOrthogonal]! !

!OrthogonalMatrixGroup methodsFor: 'printing' stamp: 'len 2/11/2016 05:14'!
shortName
	^ 'O'! !

!OrthogonalMatrixGroup methodsFor: 'operations' stamp: 'len 2/13/2016 07:44'!
special
	^ SpecialOrthogonalMatrixGroup on: space! !

!ScalarMatrixGroup methodsFor: 'random' stamp: 'len 4/19/2016 20:48'!
atRandom: aRandom
	^ matrices scalar: (self scalars atRandom: aRandom)! !

!ScalarMatrixGroup methodsFor: 'random' stamp: 'len 4/19/2016 20:49'!
atRandom: aRandom bits: bitSize
	^ matrices scalar: (self scalars atRandom: aRandom bits: bitSize / space dimension)! !

!ScalarMatrixGroup methodsFor: 'accessing' stamp: 'len 2/12/2016 02:18'!
dimension
	^ 1! !

!ScalarMatrixGroup methodsFor: 'iterating' stamp: 'len 2/11/2016 05:58'!
do: aBlock
	self scalars do: [:each| aBlock value: (matrices scalar: each)]! !

!ScalarMatrixGroup methodsFor: 'testing' stamp: 'len 5/22/2016 22:32'!
includes: aMatrix
	^ (matrices includes: aMatrix) and: [aMatrix isScalar]! !

!ScalarMatrixGroup methodsFor: 'testing' stamp: 'len 2/12/2016 02:19'!
isCommutative
	^ matrices scalars isCommutative! !

!ScalarMatrixGroup methodsFor: 'printing' stamp: 'len 2/11/2016 05:21'!
shortName
	^ 'Z'! !

!SpecialLinearMatrixGroup methodsFor: 'operations' stamp: 'len 6/8/2016 05:40'!
asAlgebraicVariety
	| n m P det |
	n _ matrices numberOfRows.
	m _ matrices numberOfColumns.
	P _ self scalars polynomialsIn: n*m.
	det _ ((matrices over: P) evaluating: [:i :j| P x: i - 1 * m + j]) determinant.
	^ P * (det - self scalars one) :: variety! !

!SpecialLinearMatrixGroup methodsFor: 'operations' stamp: 'len 2/13/2016 07:43'!
center
	^ SpecialScalarMatrixGroup on: space! !

!SpecialLinearMatrixGroup methodsFor: 'testing' stamp: 'len 5/22/2016 22:32'!
includes: aMatrix
	^ (matrices includes: aMatrix) and: [aMatrix determinant = self scalars one]! !

!SpecialLinearMatrixGroup methodsFor: 'printing' stamp: 'len 2/11/2016 05:20'!
shortName
	^ 'SL'! !

!SpecialOrthogonalMatrixGroup methodsFor: 'testing' stamp: 'len 5/22/2016 22:32'!
includes: aMatrix
	^ (matrices includes: aMatrix) and: [aMatrix isOrthogonal and: [aMatrix determinant = self scalars one]]! !

!SpecialOrthogonalMatrixGroup methodsFor: 'printing' stamp: 'len 2/11/2016 05:20'!
shortName
	^ 'SO'! !

!SpecialScalarMatrixGroup methodsFor: 'testing' stamp: 'len 2/12/2016 19:02'!
isCommutative
	^ matrices scalars isCommutative! !

!SpecialScalarMatrixGroup methodsFor: 'printing' stamp: 'len 2/11/2016 05:38'!
shortName
	^ 'SZ'! !

!AffineGroup methodsFor: 'accessing' stamp: 'len 5/6/2016 02:47'!
action
	"Answer the natural action that sends (f, p) to f(p)."
	^ GroupAction from: (self, space) to: space evaluating: [:each| each first value: each second]! !

!AffineGroup methodsFor: 'accessing' stamp: 'len 5/23/2016 19:47'!
ambient
	"Answer the ambient group."
	^ space automorphisms "the general affine group GA(A)"! !

!AffineGroup methodsFor: 'operations' stamp: 'len 2/13/2016 07:24'!
asSemidirectProduct
	self flag: #fix. "the action is wrong"
	^ SemidirectProductGroup left: space direction right: self linear action: self linear id! !

!AffineGroup methodsFor: 'accessing' stamp: 'len 2/11/2016 21:49'!
identity
	^ space id! !

!AffineGroup methodsFor: 'testing' stamp: 'len 5/22/2016 22:34'!
includes: anAffineMap
	^ self notYetImplemented! !

!AffineGroup methodsFor: 'operations' stamp: 'len 2/12/2016 18:27'!
linear
	^ properties at: #linear! !

!AffineGroup methodsFor: 'printing' stamp: 'len 4/29/2016 18:33'!
printOn: aStream
	self class == AffineGroup ifTrue: [aStream nextPutAll: 'Aff('; print: self linear; nextPut: $). ^ self].
	aStream nextPutAll: self shortName bold.
	aStream nextPut: $(; print: space; nextPut: $)! !

!AffineGroup methodsFor: 'accessing' stamp: 'len 2/13/2016 07:47'!
scalars
	^ space scalars! !

!AffineGroup methodsFor: 'printing' stamp: 'len 4/18/2016 08:43'!
shortName
	^ self subclassResponsibility! !

!AffineGroup methodsFor: 'accessing' stamp: 'len 2/11/2016 05:45'!
space
	^ space! !

!AffineGroup methodsFor: 'accessing-private' stamp: 'len 2/11/2016 05:45'!
space: anAffineSpace
	space _ anAffineSpace! !

!AffineGroup methodsFor: 'private' stamp: 'len 2/12/2016 22:37'!
species
	^ AffineGroup! !

!AffineGroup class methodsFor: 'instance creation' stamp: 'len 2/11/2016 05:45'!
on: anAffineSpace
	^ self new space: anAffineSpace! !

!EuclideanGroup methodsFor: 'random' stamp: 'len 5/14/2016 09:08'!
atRandom: aRandom
	^ AffineMap linearPart: (space direction automorphisms orthogonal atRandom: aRandom) translation: (space atRandom: aRandom)! !

!EuclideanGroup methodsFor: 'random' stamp: 'len 5/14/2016 09:08'!
atRandom: aRandom bits: bitSize
	| n |
	n _ bitSize sqrtFloor.
	^ AffineMap linearPart: (space direction automorphisms orthogonal atRandom: aRandom bits: bitSize - n) translation: (space atRandom: aRandom bits: n)! !

!EuclideanGroup methodsFor: 'accessing' stamp: 'len 2/12/2016 01:40'!
dimension
	| n |
	n _ space dimension.
	^ n * (n + 1) / 2! !

!EuclideanGroup methodsFor: 'testing' stamp: 'len 2/12/2016 01:38'!
includes: anAffineMap
	^ anAffineMap domain = space and: [anAffineMap isEndomorphism and: [anAffineMap isIsometry]]! !

!EuclideanGroup methodsFor: 'operations' stamp: 'len 2/12/2016 18:29'!
linear
	^ space direction automorphisms orthogonal! !

!EuclideanGroup methodsFor: 'printing' stamp: 'len 4/18/2016 08:40'!
shortName
	^ 'E'! !

!EuclideanGroup methodsFor: 'operations' stamp: 'len 2/12/2016 18:37'!
special
	"Answer the special Euclidean group SE(A), the group of direct isometries, i.e. isometries preserving orientation, also called 'rigid motions'. This is a subgroup of the receiver."
	^ SpecialEuclideanGroup on: space! !

!GeneralAffineGroup methodsFor: 'random' stamp: 'len 5/14/2016 09:08'!
atRandom: aRandom
	^ AffineMap linearPart: (space direction automorphisms atRandom: aRandom) translation: (space atRandom: aRandom)! !

!GeneralAffineGroup methodsFor: 'random' stamp: 'len 5/14/2016 09:08'!
atRandom: aRandom bits: bitSize
	| n |
	n _ bitSize sqrtFloor.
	^ AffineMap linearPart: (space direction automorphisms atRandom: aRandom bits: bitSize - n) translation: (space atRandom: aRandom bits: n)! !

!GeneralAffineGroup methodsFor: 'operations' stamp: 'len 2/12/2016 18:28'!
euclidean
	"Answer the Euclidean group E(A), the group of isometries, i.e. distance-preserving morphisms, also called 'motionss'. This is a subgroup of the receiver."
	^ EuclideanGroup on: space! !

!GeneralAffineGroup methodsFor: 'testing' stamp: 'len 5/22/2016 22:35'!
includes: anAffineMap
	^ anAffineMap domain = space and: [anAffineMap isEndomorphism and: [anAffineMap isMonomorphism]]! !

!GeneralAffineGroup methodsFor: 'operations' stamp: 'len 2/12/2016 18:30'!
linear
	^ space direction automorphisms! !

!GeneralAffineGroup methodsFor: 'printing' stamp: 'len 4/18/2016 08:39'!
shortName
	^ 'GA'! !

!GeneralAffineGroup methodsFor: 'operations' stamp: 'len 2/12/2016 18:49'!
special
	^ SpecialAffineGroup on: space! !

!SpecialAffineGroup methodsFor: 'testing' stamp: 'len 2/12/2016 18:55'!
includes: anAffineMap
	^ anAffineMap domain = space and: [anAffineMap isEndomorphism and: [anAffineMap matrix determinant = space scalars one]]! !

!SpecialAffineGroup methodsFor: 'operations' stamp: 'len 2/12/2016 18:55'!
linear
	^ SpecialLinearGroup on: space direction! !

!SpecialAffineGroup methodsFor: 'printing' stamp: 'len 4/18/2016 08:40'!
shortName
	^ 'SA'! !

!SpecialEuclideanGroup methodsFor: 'testing' stamp: 'len 2/12/2016 01:44'!
includes: anAffineMap
	^ anAffineMap domain = space and: [anAffineMap isEndomorphism and: [anAffineMap isIsometry and: [anAffineMap matrix determinant = space scalars one]]]! !

!SpecialEuclideanGroup methodsFor: 'operations' stamp: 'len 2/12/2016 18:38'!
linear
	^ space direction rotations! !

!SpecialEuclideanGroup methodsFor: 'printing' stamp: 'len 4/18/2016 08:40'!
shortName
	^ 'SE'! !

!ProjectiveGroup methodsFor: 'as yet unclassified' stamp: 'len 5/6/2016 02:49'!
action
	"Answer the natural action that sends (f, p) to f(p)."
	^ GroupAction from: (self, space) to: space evaluating: [:each| each first value: each second]! !

!ProjectiveGroup methodsFor: 'as yet unclassified' stamp: 'len 2/12/2016 22:02'!
linear
	^ properties at: #linear! !

!ProjectiveGroup methodsFor: 'as yet unclassified' stamp: 'len 8/5/2016 05:13'!
printOn: aStream
	self class = ProjectiveGroup ifTrue: [^ super printOn: aStream].
	aStream nextPutAll: self shortName bold; nextPut: $(; print: space vectorSpace; nextPut: $)! !

!ProjectiveGroup methodsFor: 'as yet unclassified' stamp: 'len 2/12/2016 22:02'!
space
	^ space! !

!ProjectiveGroup methodsFor: 'as yet unclassified' stamp: 'len 2/12/2016 22:02'!
space: aProjectiveSpace
	space _ aProjectiveSpace! !

!ProjectiveGroup methodsFor: 'as yet unclassified' stamp: 'len 3/4/2016 20:36'!
species
	^ ProjectiveGroup! !

!ProjectiveGroup class methodsFor: 'as yet unclassified' stamp: 'len 10/7/2016 08:41'!
moebius
	"Answer the Moebius group Aut(C)."
	^ AlgebraicNumbers new asSelfVectorSpace projective automorphisms! !

!ProjectiveGroup class methodsFor: 'instance creation' stamp: 'len 2/12/2016 22:03'!
on: aProjectiveSpace
	^ self new space: aProjectiveSpace! !

!ProjectiveGeneralLinearGroup methodsFor: 'as yet unclassified' stamp: 'len 8/5/2016 02:54'!
shortName
	^ 'PGL'! !

!ProjectiveSpecialLinearGroup methodsFor: 'as yet unclassified' stamp: 'len 8/5/2016 02:56'!
shortName
	^ 'PSL'! !

!UnitsGroup methodsFor: 'iterating' stamp: 'len 5/12/2016 23:17'!
do: aBlock
	ring do: [:each| (self includes: each) ifTrue: [aBlock value: each]]! !

!UnitsGroup methodsFor: 'accessing' stamp: 'len 4/10/2016 06:17'!
identity
	^ ring one! !

!UnitsGroup methodsFor: 'testing' stamp: 'len 5/12/2016 23:05'!
includes: anElement
	^ ring isUnit: anElement! !

!UnitsGroup methodsFor: 'accessing' stamp: 'len 4/22/2016 17:29'!
inverseMap
	^ self multiplicativeInverseMap! !

!UnitsGroup methodsFor: 'accessing' stamp: 'len 4/22/2016 17:29'!
operation
	^ self multiplicativeOperation! !

!UnitsGroup methodsFor: 'printing' stamp: 'len 9/5/2016 17:32'!
printOn: aStream
	aStream print: ring; nextPutAll: Character times asString super ! !

!UnitsGroup methodsFor: 'accessing-private' stamp: 'len 5/12/2016 23:14'!
ring: aRing
	ring _ aRing! !

!UnitsGroup class methodsFor: 'instance creation' stamp: 'len 5/12/2016 23:09'!
on: aRing
	^ self new ring: aRing! !

!CoxeterGroup methodsFor: 'as yet unclassified' stamp: 'len 4/18/2016 01:25'!
diagram
	^ diagram! !

!CoxeterGroup methodsFor: 'as yet unclassified' stamp: 'len 4/18/2016 01:24'!
diagram: aGraph
	diagram _ aGraph! !

!CoxeterGroup methodsFor: 'as yet unclassified' stamp: 'len 4/18/2016 01:39'!
gramMatrix
	^ self matrix collect: [:x| -2 * (Float pi / x) cos]! !

!CoxeterGroup methodsFor: 'as yet unclassified' stamp: 'len 4/18/2016 01:39'!
isHyperbolic
	^ (self gramMatrix spectrum count: [:each| each negative]) = 1! !

!CoxeterGroup methodsFor: 'as yet unclassified' stamp: 'len 7/20/2016 23:49'!
presentation
	| generators relators |
	generators _ diagram values collect: [:each| Word x: each].
	relators _ OrderedCollection new.
	diagram edgesAndLabelsDo: [:each :label|
		label isInfinity
			ifFalse: [relators add: (Word x: each key) * (Word x: each value) ** (label ifNil: [3])]].
	^ GroupPresentation generators: generators relators: relators! !

!CoxeterGroup class methodsFor: 'as yet unclassified' stamp: 'len 4/18/2016 01:25'!
diagram: aGraph
	^ self new diagram: aGraph! !

!CoxeterGroup class methodsFor: 'as yet unclassified' stamp: 'len 5/25/2016 03:46'!
matrix: aMatrix
	| n graph |
	n _ aMatrix numberOfColumns.
	graph _ Graph unorderedLabeled.
	graph addAll: (1 to: n).
	1 to: n do: [:i|
		1 to: n do: [:j|
			| m |
			m _ aMatrix at: i@j.
			m = 3 ifTrue: [graph addEdgeFrom: i to: j label: nil].
			m > 3 ifTrue: [graph addEdgeFrom: i to: j label: m]]].
	^ self diagram: graph! !

!Monomials methodsFor: 'comparing' stamp: 'len 6/30/2016 00:21'!
= anObject
	^ (anObject isKindOf: Monomials) and: [anObject rank = rank]! !

!Monomials methodsFor: 'random' stamp: 'len 7/15/2016 18:20'!
atRandom: aRandom bits: bitSize
	^ Monomial exponents: ((NN ** self rank atRandom: aRandom bits: bitSize) collect: [:x| x - 1]) asArray! !

!Monomials methodsFor: 'iterating' stamp: 'len 7/15/2016 18:20'!
do: aBlock
	NN ** self rank do: [:each| aBlock value: (Monomial exponents: (each collect: [:x| x - 1]) asArray)]! !

!Monomials methodsFor: 'accessing' stamp: 'len 6/30/2016 00:36'!
generators
	^ (1 to: rank) collect: [:i| self x: i]! !

!Monomials methodsFor: 'comparing' stamp: 'len 6/30/2016 00:21'!
hash
	^ self rank + self class hash! !

!Monomials methodsFor: 'accessing' stamp: 'len 6/30/2016 00:29'!
identity
	^ Monomial new: rank! !

!Monomials methodsFor: 'testing' stamp: 'len 6/30/2016 00:12'!
includes: aMonomial
	^ (aMonomial isKindOf: Monomial) and: [aMonomial lastIndeterminate <= rank]! !

!Monomials methodsFor: 'accessing' stamp: 'len 7/4/2016 01:30'!
indeterminateNames
	^ properties at: #indeterminateNames ifAbsent: [self isUnivariate ifTrue: [#(x)]]! !

!Monomials methodsFor: 'accessing-private' stamp: 'len 7/4/2016 01:31'!
indeterminateNames: aCollection
	properties at: #indeterminateNames put: aCollection! !

!Monomials methodsFor: 'accessing' stamp: 'len 6/28/2016 23:38'!
indeterminates
	^ 1 to: rank! !

!Monomials methodsFor: 'testing' stamp: 'len 6/30/2016 00:36'!
isCommutative
	^ true! !

!Monomials methodsFor: 'testing' stamp: 'len 6/30/2016 00:36'!
isCountable
	^ true! !

!Monomials methodsFor: 'testing' stamp: 'len 6/30/2016 00:36'!
isFinite
	^ false! !

!Monomials methodsFor: 'testing' stamp: 'len 7/4/2016 01:33'!
isUnivariate
	^ self rank = 1! !

!Monomials methodsFor: 'accessing' stamp: 'len 7/4/2016 01:28'!
ordering
	^ properties at: #ordering ifAbsentPut: [MonomialOrdering tlex: self rank]! !

!Monomials methodsFor: 'accessing' stamp: 'len 7/4/2016 01:29'!
ordering: aMonomialOrdering
	| ordering |
	ordering _ aMonomialOrdering isSymbol
		ifTrue: [MonomialOrdering perform: (aMonomialOrdering,':') asSymbol with: self rank]
		ifFalse: [aMonomialOrdering].
	properties at: #ordering put: ordering! !

!Monomials methodsFor: 'printing' stamp: 'len 6/28/2016 23:38'!
printOn: aStream
	aStream nextPut: $[.
	self indeterminates
		do: [:i| aStream print: (Monomial x: i)]
		separatedBy: [aStream nextPut: $,].
	aStream nextPutAll: ']*'! !

!Monomials methodsFor: 'accessing' stamp: 'len 6/28/2016 23:37'!
rank
	^ rank! !

!Monomials methodsFor: 'accessing-private' stamp: 'len 6/28/2016 23:37'!
rank: anInteger
	rank _ anInteger! !

!Monomials methodsFor: 'elements' stamp: 'len 6/30/2016 00:37'!
x: anInteger
	^ Monomial x: anInteger! !

!Monomials class methodsFor: 'as yet unclassified' stamp: 'len 6/30/2016 00:08'!
new: anInteger
	^ self new rank: anInteger! !

!Morphisms methodsFor: 'accessing' stamp: 'len 4/19/2016 04:51'!
codomain
	^ properties at: #codomain! !

!Morphisms methodsFor: 'accessing-private' stamp: 'len 4/19/2016 04:52'!
codomain: aDomain
	properties at: #codomain put: aDomain! !

!Morphisms methodsFor: 'accessing' stamp: 'len 4/19/2016 04:51'!
domain
	^ properties at: #domain! !

!Morphisms methodsFor: 'accessing-private' stamp: 'len 4/19/2016 04:52'!
domain: aDomain
	properties at: #domain put: aDomain! !

!Morphisms methodsFor: 'elements' stamp: 'len 8/31/2016 03:37'!
evaluating: aBlock
	^ self domain to: self codomain evaluating: aBlock! !

!Morphisms methodsFor: 'elements' stamp: 'len 8/31/2016 03:41'!
identity
	^ self isEndomorphisms ifTrue: [self domain id]! !

!Morphisms methodsFor: 'testing' stamp: 'len 10/4/2016 09:02'!
includes: aMorphism
	^ (aMorphism isKindOf: Morphism) and: [aMorphism domain = self domain and: [aMorphism codomain = self codomain]]! !

!Morphisms methodsFor: 'testing' stamp: 'len 4/19/2016 04:53'!
isEndomorphisms
	^ self domain = self codomain! !

!Morphisms methodsFor: 'elements' stamp: 'len 4/23/2016 03:47'!
newFrom: anObject
	^ self evaluating: anObject! !

!Morphisms methodsFor: 'operations' stamp: 'len 8/25/2016 21:11'!
opposite
	^ self class from: self domain to: self codomain! !

!Morphisms methodsFor: 'printing' stamp: 'len 10/5/2016 10:01'!
printOn: aStream
	self isEndomorphisms
		ifTrue: [aStream nextPutAll: 'Endo' bold; nextPut: $(; print: self domain; nextPut: $)]
		ifFalse: [aStream nextPutAll: 'Hom' bold; nextPut: $(; print: self domain; nextPut: $,; print: self codomain; nextPut: $)]! !

!Morphisms class methodsFor: 'instance creation' stamp: 'len 4/19/2016 04:53'!
from: aDomain to: anotherDomain
	^ self new domain: aDomain; codomain: anotherDomain! !

!QuotientSet methodsFor: 'accessing' stamp: 'len 4/26/2016 07:26'!
base
	^ self relation domain! !

!QuotientSet methodsFor: 'iterating' stamp: 'len 8/14/2016 06:17'!
do: aBlock
	| visited |
	visited _ Set new.
	self base do: [:each|
		| x |
		x _ self project: each.
		visited add: x ifAbsent: [aBlock value: x]]! !

!QuotientSet methodsFor: 'testing' stamp: 'len 8/10/2016 01:01'!
isQuotient
	^ true! !

!QuotientSet methodsFor: 'printing' stamp: 'len 4/25/2016 09:25'!
printOn: aStream
	aStream print: self relation domain; nextPut: $/; print: self relation
"	| domain |
	domain _ self relation domain.
	(domain printString allSatisfy: [:each|each isAlphaNumeric])
		ifTrue: [aStream print: domain]
		ifFalse: [aStream nextPut: $(; print: domain; nextPut: $)].
	aStream nextPut: $/; print: self relation"! !

!QuotientSet methodsFor: 'morphisms' stamp: 'len 4/24/2016 04:46'!
project: anElement
	^ EquivalenceClass representative: anElement relation: self relation! !

!QuotientSet methodsFor: 'morphisms' stamp: 'len 10/10/2016 08:52'!
projection
	^ (Function from: self base to: self evaluating: [:v| self project: v]) name: Character pi asString! !

!QuotientSet methodsFor: 'accessing' stamp: 'len 4/24/2016 04:40'!
relation
	^ properties at: #relation! !

!QuotientSet methodsFor: 'accessing-private' stamp: 'len 4/25/2016 08:53'!
relation: anEquivalenceRelation
	properties at: #relation put: anEquivalenceRelation! !

!QuotientSet class methodsFor: 'instance creation' stamp: 'len 4/25/2016 21:02'!
by: anEquivalenceRelation
	^ self new relation: anEquivalenceRelation! !

!Category methodsFor: 'as yet unclassified' stamp: 'len 10/9/2016 08:48'!
isAbelian
	^ false! !

!AbelianGroups methodsFor: 'as yet unclassified' stamp: 'len 10/9/2016 08:48'!
isAbelian
	^ true! !

!AbelianGroups methodsFor: 'as yet unclassified' stamp: 'len 10/9/2016 08:49'!
printOn: aStream
	aStream nextPutAll: 'Ab'! !

!Modules methodsFor: 'as yet unclassified' stamp: 'len 10/9/2016 08:46'!
printOn: aStream
	aStream print: scalars; nextPutAll: (scalars isField ifTrue: ['-Vect'] ifFalse: ['-Mod'])! !

!Modules methodsFor: 'as yet unclassified' stamp: 'len 10/9/2016 08:43'!
scalars
	^ scalars! !

!Modules methodsFor: 'as yet unclassified' stamp: 'len 10/9/2016 08:44'!
scalars: aCommutativeRing
	scalars _ aCommutativeRing! !

!Modules class methodsFor: 'as yet unclassified' stamp: 'len 10/9/2016 08:47'!
over: aCommutativeRing
	^ self new scalars: aCommutativeRing! !

!ComplexBox methodsFor: 'accessing' stamp: 'len 1/16/2016 05:56'!
area
	^ self measure! !

!ComplexBox methodsFor: 'accessing' stamp: 'len 1/16/2016 05:59'!
closure
	^ self class real: real closure imaginary: imaginary closure! !

!ComplexBox methodsFor: 'testing' stamp: 'len 1/16/2016 05:50'!
closureIncludes: aComplex
	^ (real closureIncludes: aComplex real) and: [imaginary closureIncludes: aComplex imaginary]! !

!ComplexBox methodsFor: 'accessing' stamp: 'len 1/11/2016 02:58'!
imaginary
	^ imaginary! !

!ComplexBox methodsFor: 'accessing-private' stamp: 'len 1/11/2016 02:53'!
imaginary: aRealInterval
	imaginary _ aRealInterval! !

!ComplexBox methodsFor: 'testing' stamp: 'len 1/11/2016 02:54'!
includes: aComplex
	^ (real includes: aComplex real) and: [imaginary includes: aComplex imaginary]! !

!ComplexBox methodsFor: 'testing' stamp: 'len 1/16/2016 05:52'!
intersects: aComplexBox
	^ (real intersects: aComplexBox real) and: [imaginary intersects: aComplexBox imaginary]! !

!ComplexBox methodsFor: 'testing' stamp: 'len 1/11/2016 03:40'!
isBounded
	^ real isBounded and: [imaginary isBounded]! !

!ComplexBox methodsFor: 'testing' stamp: 'len 1/11/2016 03:40'!
isClosed
	^ real isClosed and: [imaginary isClosed]! !

!ComplexBox methodsFor: 'testing' stamp: 'len 1/11/2016 03:41'!
isOpen
	^ real isOpen and: [imaginary isOpen]! !

!ComplexBox methodsFor: 'accessing' stamp: 'len 1/11/2016 02:55'!
measure
	^ real measure * imaginary measure! !

!ComplexBox methodsFor: 'accessing' stamp: 'len 1/15/2016 07:21'!
midpoint
	^ Complex real: real midpoint imaginary: imaginary midpoint! !

!ComplexBox methodsFor: 'printing' stamp: 'len 1/11/2016 02:57'!
printOn: aStream
	aStream print: real; nextPutAll: ' + '; print: imaginary; nextPut: $i! !

!ComplexBox methodsFor: 'accessing' stamp: 'len 6/5/2016 06:20'!
quarters
	| imaginaries reals |
	reals _ self real halves.
	imaginaries _ self imaginary halves.
	^ {self class real: (reals at: 1) imaginary: (imaginaries at: 1).
		self class real: (reals at: 1) imaginary: (imaginaries at: 2).
		self class real: (reals at: 2) imaginary: (imaginaries at: 1).
		self class real: (reals at: 2) imaginary: (imaginaries at: 2)}! !

!ComplexBox methodsFor: 'accessing' stamp: 'len 6/5/2016 04:08'!
radius2
	^ real length squared + imaginary length squared / 4! !

!ComplexBox methodsFor: 'accessing' stamp: 'len 1/11/2016 02:58'!
real
	^ real! !

!ComplexBox methodsFor: 'accessing-private' stamp: 'len 1/11/2016 02:53'!
real: aRealInterval
	real _ aRealInterval! !

!ComplexBox methodsFor: 'accessing' stamp: 'len 1/11/2016 03:42'!
sample
	"Answer a sample point in the receiver."
	^ Complex real: real sample imaginary: imaginary sample! !

!ComplexBox methodsFor: 'accessing' stamp: 'len 6/5/2016 21:42'!
width
	^ real length min: imaginary length! !

!ComplexBox class methodsFor: 'instance creation' stamp: 'len 6/4/2016 21:53'!
center: aComplex radius: aNumber
	^ self
		real: (RealInterval closed: aComplex real - aNumber closed: aComplex real + aNumber)
		imaginary: (RealInterval closed: aComplex imaginary - aNumber closed: aComplex imaginary + aNumber)! !

!ComplexBox class methodsFor: 'instance creation' stamp: 'len 1/11/2016 03:43'!
real: aRealInterval imaginary: anotherRealInterval
	^ self new real: aRealInterval; imaginary: anotherRealInterval! !

!ComplexBox class methodsFor: 'instance creation' stamp: 'len 6/5/2016 04:07'!
with: aComplex with: anotherComplex
	^ self
		real: (RealInterval with: aComplex real with: anotherComplex real)
		imaginary: (RealInterval with: aComplex imaginary with: anotherComplex imaginary)! !

!ComplexDisk methodsFor: 'arithmetic' stamp: 'len 6/5/2016 20:46'!
* aDisk
	^ self class center: aDisk center * self center radius: self radius * aDisk radius! !

!ComplexDisk methodsFor: 'arithmetic' stamp: 'len 6/30/2016 04:37'!
+ aDisk
	^ self class center: aDisk center + self center radius: self radius + aDisk radius! !

!ComplexDisk methodsFor: 'accessing' stamp: 'len 1/13/2016 22:30'!
center
	^ center! !

!ComplexDisk methodsFor: 'accessing-private' stamp: 'len 6/5/2016 20:47'!
center: aComplex
	center _ aComplex! !

!ComplexDisk methodsFor: 'accessing' stamp: 'len 6/30/2016 04:43'!
enclosingBox
	"Answer a ComplexBox that encloses the receiver."
	^ ComplexBox center: self center radius: self radius! !

!ComplexDisk methodsFor: 'testing' stamp: 'len 6/5/2016 20:44'!
includes: anObject
	^ (anObject - center) norm2 <= radius squared! !

!ComplexDisk methodsFor: 'testing' stamp: 'len 6/5/2016 04:13'!
intersects: aBall
	self flag: #fix.
	^ (aBall center - center) norm2 <= (self radius + aBall radius) squared! !

!ComplexDisk methodsFor: 'accessing' stamp: 'len 1/15/2016 07:21'!
midpoint
	^ self center! !

!ComplexDisk methodsFor: 'printing' stamp: 'len 6/5/2016 20:42'!
printOn: aStream
	aStream nextPutAll: 'D('; print: self center; nextPut: $,; print: self radius; nextPut: $)! !

!ComplexDisk methodsFor: 'accessing' stamp: 'len 6/5/2016 20:42'!
radius
	^ radius! !

!ComplexDisk methodsFor: 'accessing-private' stamp: 'len 6/5/2016 20:47'!
radius: aNumber
	radius _ aNumber! !

!ComplexDisk class methodsFor: 'instance creation' stamp: 'len 6/5/2016 20:47'!
center: aComplex radius: aNumber
	^ self new center: aComplex; radius: aNumber! !

!Naturals methodsFor: 'comparing' stamp: 'len 12/14/2015 01:55'!
= anObject
	^ self class == anObject class! !

!Naturals methodsFor: 'random' stamp: 'len 6/30/2016 00:34'!
atRandom: aRandom bits: bitSize
	^ (aRandom nextBits: bitSize truncated) + 1! !

!Naturals methodsFor: 'iterating' stamp: 'len 12/3/2015 20:12'!
do: aBlock
	| n |
	n _ 1.
	[aBlock value: n. n _ n + 1] repeat! !

!Naturals methodsFor: 'comparing' stamp: 'len 12/14/2015 01:55'!
hash
	^ self class hash! !

!Naturals methodsFor: 'accessing' stamp: 'len 2/13/2016 20:41'!
identity
	^ 1! !

!Naturals methodsFor: 'testing' stamp: 'len 2/13/2016 20:41'!
isCommutative
	^ true! !

!Naturals methodsFor: 'testing' stamp: 'len 12/3/2015 20:12'!
isCountable
	^ true! !

!Naturals methodsFor: 'testing' stamp: 'len 12/5/2015 02:09'!
isFinite
	^ false! !

!Naturals methodsFor: 'testing' stamp: 'len 2/11/2016 22:19'!
isReal
	^ true! !

!Naturals methodsFor: 'printing' stamp: 'len 6/8/2016 21:05'!
printOn: aStream
	aStream nextPut: Character NN! !

!Naturals methodsFor: 'accessing' stamp: 'len 4/24/2016 02:58'!
size
	^ Aleph new! !

!Naturals methodsFor: 'morphisms' stamp: 'len 9/17/2016 06:52'!
to: aDomain evaluating: aBlock
	"Answer a sequence with values in aDomain."
	^ Sequence to: aDomain evaluating: aBlock! !

!Naturals class methodsFor: 'initialization' stamp: 'len 8/5/2016 21:33'!
initialize
	super initialize.
	Smalltalk at: #NN put: self new! !

!RealBox methodsFor: 'comparing' stamp: 'len 12/19/97 22:06'!
= anObject
	"Answer true if the receiver equals the argument."

	self size = anObject size ifFalse: [^ false].
	1 to: self size do: [ :each | (self at: each) = (anObject at: each) ifFalse: [^ false]].
	^ true! !

!RealBox methodsFor: 'accessing' stamp: 'len 1/11/2016 02:33'!
add: aRealInterval
	^ components add: aRealInterval! !

!RealBox methodsFor: 'accessing' stamp: 'len 12/13/97 15:21'!
addAll: aCollection
	"Add the elements in the argument to the receiver. Answer the argument."

	aCollection do: [ :each | self add: each].
	^ aCollection! !

!RealBox methodsFor: 'accessing' stamp: 'len 1/11/2016 02:33'!
at: anInteger
	"Answer the anInteger-th component of the receiver."
	^ components at: anInteger! !

!RealBox methodsFor: 'accessing' stamp: 'len 1/11/2016 02:34'!
cartesian: aBox
	"Answer the cartesian product of the receiver by the argument."
	^ self copy addAll: aBox; yourself! !

!RealBox methodsFor: 'accessing-private' stamp: 'len 1/11/2016 02:37'!
components
	^ components! !

!RealBox methodsFor: 'accessing-private' stamp: 'len 1/11/2016 02:37'!
components: aCollection
	components _ aCollection! !

!RealBox methodsFor: 'accessing' stamp: 'len 1/11/2016 02:35'!
dimension
	^ components inject: 0 into: [:sum :each| sum + each]! !

!RealBox methodsFor: 'enumerating' stamp: 'len 1/11/2016 02:38'!
do: aBlock
	"Enumerate the components of the receiver."
	components do: aBlock! !

!RealBox methodsFor: 'accessing' stamp: 'len 1/11/2016 02:35'!
first
	^ self at: 1! !

!RealBox methodsFor: 'comparing' stamp: 'len 6/28/2016 09:28'!
hash
	"Answer the hash value of the receiver."

	^ self size = 0
		ifTrue: [0]
		ifFalse: [self first hash hashMultiply + self last hash hashMultiply + self size hash]! !

!RealBox methodsFor: 'testing' stamp: 'len 1/11/2016 02:40'!
includes: aTuple
	1 to: self size do: [:each|
		((self at: each) includes: (aTuple at: each)) ifFalse: [^ false]].
	^ true! !

!RealBox methodsFor: 'initialization' stamp: 'len 1/11/2016 02:38'!
initialize
	components _ OrderedCollection new: 3! !

!RealBox methodsFor: 'testing' stamp: 'len 1/11/2016 02:40'!
isBounded
	self do: [:each| each isBounded ifFalse: [^ false]].
	^ true! !

!RealBox methodsFor: 'testing' stamp: 'len 1/11/2016 02:40'!
isClosed
	self do: [:each| each isClosed ifFalse: [^ false]].
	^ true! !

!RealBox methodsFor: 'testing' stamp: 'len 1/11/2016 02:41'!
isOpen
	self do: [ :each | each isOpen ifFalse: [^ false]].
	^ true! !

!RealBox methodsFor: 'accessing' stamp: 'len 1/11/2016 02:35'!
last
	^ self at: self size! !

!RealBox methodsFor: 'accessing' stamp: 'len 1/11/2016 02:36'!
measure
	^ components inject: 1 into: [:measure :each| measure * each measure]! !

!RealBox methodsFor: 'accessing' stamp: 'len 1/15/2016 07:20'!
midpoint
	^ Tuple withAll: ((1 to: self size) collect: [:each| each midpoint])! !

!RealBox methodsFor: 'printing' stamp: 'len 6/7/2016 00:51'!
printOn: aStream
	components do: [:each| aStream print: each] separatedBy: [aStream nextPut: Character times]! !

!RealBox methodsFor: 'accessing' stamp: 'len 1/11/2016 02:36'!
sample
	"Answer a sample point in the receiver."
	^ Tuple new: self size evaluating: [:each| (self at: each) sample]! !

!RealBox methodsFor: 'accessing' stamp: 'len 1/11/2016 02:37'!
size
	^ components size! !

!RealBox class methodsFor: 'instance creation' stamp: 'len 12/13/97 02:52'!
new
	^ super new initialize! !

!RealInterval methodsFor: 'arithmetic' stamp: 'len 12/13/97 03:19'!
* anInterval
	"Answer the product of the receiver by the argument."

	| l1l2 l1r2 r1l2 r1r2 |
	l1l2 _ self left * anInterval left.
	l1r2 _ self left * anInterval right.
	r1l2 _ self right * anInterval left.
	r1r2 _ self right * anInterval right.
	^ self copy
		left: ((l1l2 min: l1r2) min: (r1l2 min: r1r2));
		right: ((l1l2 max: l1r2) max: (r1l2 max: r1r2))! !

!RealInterval methodsFor: 'arithmetic' stamp: 'len 12/13/97 03:20'!
+ anInterval
	"Answer the sum of the receiver and the argument."

	^ self copy
		left: self left + anInterval left;
		right: self right + anInterval right! !

!RealInterval methodsFor: 'arithmetic' stamp: 'len 12/13/97 03:36'!
- anInterval
	"Answer the difference of the receiver and the argument."

	^ self + anInterval negated! !

!RealInterval methodsFor: 'arithmetic' stamp: 'len 12/13/97 02:14'!
/ anInterval
	"Answer the quotient of the receiver by the argument."

	^ self * anInterval reciprocal! !

!RealInterval methodsFor: 'comparing' stamp: 'len 1/16/2016 05:57'!
= anInterval
	^ left = anInterval left and: [right = anInterval right and: [self isLeftOpen = anInterval isLeftOpen and: [self isRightOpen = anInterval isRightOpen]]]! !

!RealInterval methodsFor: 'operations' stamp: 'len 1/11/2016 02:41'!
cartesian: anInterval
	"Answer the cartesian product of the receiver by the argument."
	| answer |
	answer _ RealBox new add: self; yourself.
	anInterval do: [:each| answer add: each].
	^ answer! !

!RealInterval methodsFor: 'converting' stamp: 'len 12/13/97 02:31'!
close
	"Answer a closed inverval with the same bounds that the receiver."

	self isClosed ifFalse: [^ self copy leftOpen: false; rightOpen: false]! !

!RealInterval methodsFor: 'converting' stamp: 'len 12/13/97 02:40'!
closeLeft
	"Answer a closed left interval with the same bounds that the receiver."

	self isLeftClosed ifFalse: [^ self copy leftOpen: false]! !

!RealInterval methodsFor: 'converting' stamp: 'len 12/13/97 02:35'!
closeRight
	"Answer a closed right interval with the same bounds that the receiver."

	self isRightClosed ifFalse: [^ self copy rightOpen: false]! !

!RealInterval methodsFor: 'operations' stamp: 'len 1/16/2016 05:59'!
closure
	^ self class closed: left closed: right! !

!RealInterval methodsFor: 'testing' stamp: 'len 3/31/2016 17:54'!
closureIncludes: anObject
	(anObject is: #Tuple) ifTrue: [^ anObject dimension = 1 and: [self includes: anObject first]].
	^ anObject between: left and: right! !

!RealInterval methodsFor: 'accessing' stamp: 'len 12/19/97 22:10'!
dimension
	"Answer the dimension of the receiver."

	self isEmpty ifTrue: [^ Infinity negative].
	self left = self right ifTrue: [^ 0].
	^ 1! !

!RealInterval methodsFor: 'accessing' stamp: 'len 6/5/2016 06:26'!
halves
	| m |
	m _ self midpoint.
	^ {self copy right: m; rightOpen: false . self copy left: m; leftOpen: true}! !

!RealInterval methodsFor: 'comparing' stamp: 'len 6/28/2016 09:30'!
hash
	^ self left hash hashMultiply + self right hash + self isRightOpen hash + self isLeftOpen hash hashMultiply! !

!RealInterval methodsFor: 'constants' stamp: 'len 12/13/97 03:20'!
identity
	"Answer the identity element for the receiver."

	^ self copy left: 1; right: 1! !

!RealInterval methodsFor: 'testing' stamp: 'len 3/31/2016 17:54'!
includes: anObject
	(anObject is: #Tuple) ifTrue: [^ anObject dimension = 1 and: [self includes: (anObject at: 1)]].
	(self left > anObject or: [self right < anObject])
		ifTrue: [^ false].
	(self left < anObject and: [self right > anObject])
		ifTrue: [^ true].
	((self isLeftClosed and: [anObject = self left])
	or: [self isRightClosed and: [anObject = self right]])
		ifTrue: [^ true].
	^ false! !

!RealInterval methodsFor: 'accessing' stamp: 'len 12/13/97 03:22'!
inf
	"Answer the infimun of the receiver."

	^ self left! !

!RealInterval methodsFor: 'operations' stamp: 'len 6/2/2016 07:29'!
interior
	^ self class open: left open: right! !

!RealInterval methodsFor: 'testing' stamp: 'len 6/4/2016 21:43'!
intersects: anInterval
	"Answer true if the receiver overlaps the argument."
	self right < anInterval left ifTrue: [^ false].
	self left > anInterval right ifTrue: [^ false].
	self right = anInterval left ifTrue: [^ self isRightClosed and: [anInterval isLeftClosed]].
	self left = anInterval right ifTrue: [^ self isLeftClosed and: [anInterval isRightClosed]].
	^ true! !

!RealInterval methodsFor: 'testing' stamp: 'len 12/13/97 03:29'!
isBounded
	"Answer true if the receiver is bounded."

	^ self isLeftBounded and: [self isRightBounded]! !

!RealInterval methodsFor: 'testing' stamp: 'len 12/13/97 02:36'!
isClosed
	"Answer true if the receiver is closed."

	^ self isLeftClosed and: [self isRightClosed]! !

!RealInterval methodsFor: 'testing' stamp: 'len 12/13/97 03:23'!
isEmpty
	"Answer true if the receiver is empty."

	^ self isLeftBounded
		ifTrue: [self right < self left]
		ifFalse: [self left > self right]! !

!RealInterval methodsFor: 'testing' stamp: 'len 6/2/2016 05:16'!
isFinite
	^ left = right and: [leftOpen not | rightOpen not]! !

!RealInterval methodsFor: 'testing' stamp: 'len 12/13/97 02:14'!
isHalfOpen
	"Answer true if the receiver is hald-open."

	^ self isClosed not and: [self isOpen not]! !

!RealInterval methodsFor: 'testing' stamp: 'len 12/13/97 02:23'!
isLeftBounded
	"Answer true if the receiver is left bounded."

	^ self left isInfinity not! !

!RealInterval methodsFor: 'testing' stamp: 'len 12/13/97 02:33'!
isLeftClosed
	"Answer true if the receiver is left closed."

	^ self isLeftOpen not! !

!RealInterval methodsFor: 'testing' stamp: 'len 12/13/97 02:36'!
isLeftOpen
	"Answer true if the receiver is left open."

	^ leftOpen! !

!RealInterval methodsFor: 'testing' stamp: 'len 12/13/97 02:38'!
isOpen
	"Answer true if the receiver is open."

	^ self isLeftOpen and: [self isRightOpen]! !

!RealInterval methodsFor: 'testing' stamp: 'len 12/13/97 02:24'!
isRightBounded
	"Answer true if the receiver is right bounded."

	^ self right isInfinity not! !

!RealInterval methodsFor: 'testing' stamp: 'len 12/13/97 02:35'!
isRightClosed
	"Answer true if the receiver is right closed."

	^ self isRightOpen not! !

!RealInterval methodsFor: 'testing' stamp: 'len 12/13/97 02:37'!
isRightOpen
	"Answer true if the receiver is open right."

	^ rightOpen! !

!RealInterval methodsFor: 'accessing' stamp: 'len 12/13/97 03:21'!
left
	"Answer the left bound of the receiver."

	^ left! !

!RealInterval methodsFor: 'accessing-private' stamp: 'len 12/13/97 03:18'!
left: aNumber
	left _ aNumber! !

!RealInterval methodsFor: 'accessing-private' stamp: 'len 12/13/97 02:30'!
leftOpen: aBoolean
	leftOpen _ aBoolean! !

!RealInterval methodsFor: 'accessing' stamp: 'len 1/16/2016 05:56'!
length
	^ self measure! !

!RealInterval methodsFor: 'accessing' stamp: 'len 12/13/97 03:24'!
max
	"Answer the maximum of the receiver."

	self isRightOpen ifTrue: [^ self error: 'there''s not maximum'].
	^ self right! !

!RealInterval methodsFor: 'accessing' stamp: 'len 1/11/2016 02:43'!
measure
	^ self right - self left! !

!RealInterval methodsFor: 'accessing' stamp: 'len 1/15/2016 07:19'!
midpoint
	^ left + right / 2! !

!RealInterval methodsFor: 'accessing' stamp: 'len 12/13/97 03:23'!
min
	"Answer the minimum of the receiver."

	self isLeftOpen ifTrue: [^ self error: 'there''s not minimun'].
	^ self left! !

!RealInterval methodsFor: 'arithmetic' stamp: 'len 12/13/97 03:20'!
negated
	"Answer the additive inverse of the receiver."

	^ self copy
		right: self left negated;
		left: self right negated;
		leftOpen: self isRightOpen;
		rightOpen: self isLeftOpen! !

!RealInterval methodsFor: 'constants' stamp: 'len 12/13/97 03:20'!
null
	"Answer the null element for the receiver."

	^ self copy left: 0; right: 0! !

!RealInterval methodsFor: 'converting' stamp: 'len 12/13/97 02:32'!
open
	"Answer an open inverval with the same bounds that the receiver."

	self isOpen ifFalse: [^ self copy leftOpen: true; rightOpen: true]! !

!RealInterval methodsFor: 'converting' stamp: 'len 12/13/97 02:38'!
openLeft
	"Answer an open left interval with the same bounds that the receiver."

	self isLeftOpen ifFalse: [^ self copy leftOpen: true]! !

!RealInterval methodsFor: 'converting' stamp: 'len 12/13/97 02:39'!
openRight
	"Answer an open right interval with the same bounds that the receiver."

	self isRightOpen ifFalse: [^ self copy rightOpen: true]! !

!RealInterval methodsFor: 'printing' stamp: 'len 12/13/97 03:23'!
printOn: aStream
	"Print a representation of the receiver in the stream aStream."

	aStream
		nextPut: (self isLeftOpen ifTrue: [ $( ] ifFalse: [ $[ ]);
		print: self left;
		nextPutAll: ', ';
		print: self right;
		nextPut: (self isRightOpen ifTrue: [ $) ] ifFalse: [ $] ])! !

!RealInterval methodsFor: 'arithmetic' stamp: 'len 1/16/2016 05:48'!
reciprocal
	"Answer the multiplicative inverse of the receiver."
	(self closureIncludes: 0) ifTrue: [^ ZeroDivide signal].
	^ self copy
		left: self right reciprocal;
		right: self left reciprocal! !

!RealInterval methodsFor: 'accessing' stamp: 'len 12/13/97 03:21'!
right
	"Answer the right bound of the receiver."

	^ right! !

!RealInterval methodsFor: 'accessing-private' stamp: 'len 12/13/97 03:21'!
right: aNumber
	right _ aNumber! !

!RealInterval methodsFor: 'accessing-private' stamp: 'len 12/13/97 02:32'!
rightOpen: aBoolean
	rightOpen _ aBoolean! !

!RealInterval methodsFor: 'accessing' stamp: 'len 12/15/97 20:56'!
sample
	"Answer a sample point in the receiver."

	self isEmpty ifTrue: [^ self error: 'empty interval'].
	self isLeftClosed ifTrue: [^ Tuple with: self left].
	self isRightClosed ifTrue: [^ Tuple with: self right].
	(self isLeftBounded and: [self isRightBounded])
		ifTrue: [^ Tuple with: self left + self right / 2].
	self isLeftBounded ifTrue: [^ Tuple with: self left + 1].
	self isRightBounded ifTrue: [^ Tuple with: self right - 1].
	^ Tuple with: 0! !

!RealInterval methodsFor: 'initialization' stamp: 'len 12/13/97 03:18'!
setLeftBound: leftBound rightBound: rightBound leftOpen: leftOpenBool rightOpen: rightOpenBool
	left _ leftBound.
	right _ rightBound.
	"If the interval is left-closed or right-closed and two points are
	the same, then the interval is a single point... so it's closed."
	((leftOpenBool & rightOpenBool) not and: [left = right])
		ifTrue: [leftOpen _ false.
				rightOpen _ false]
		ifFalse: [leftOpen _ leftOpenBool.
				rightOpen _ rightOpenBool]! !

!RealInterval methodsFor: 'testing' stamp: 'len 12/13/97 03:23'!
sign
	"Answer 1 if the receiver is greater than 0, -1 if less than 0, else 0."

	self left > 0 ifTrue: [^ 1].
	self right < 0 ifTrue: [^ -1].
	^ 0! !

!RealInterval methodsFor: 'arithmetic' stamp: 'len 1/16/2016 06:58'!
squared
	^ self * self! !

!RealInterval methodsFor: 'accessing' stamp: 'len 12/13/97 03:24'!
sup
	"Answer the supremum of the receiver."

	^ self right! !

!RealInterval class methodsFor: 'instance creation' stamp: 'len 12/13/97 02:29'!
closed: left closed: right
	"Answer a new [left, right] interval."

	^ self new setLeftBound: left rightBound: right leftOpen: false rightOpen: false! !

!RealInterval class methodsFor: 'instance creation' stamp: 'len 12/13/97 02:30'!
closed: left open: right
	"Answer a new [left, right) interval."

	^ self new setLeftBound: left rightBound: right leftOpen: false rightOpen: true! !

!RealInterval class methodsFor: 'instance creation' stamp: 'len 12/13/97 02:30'!
open: left closed: right
	"Answer a new (left, right] interval."

	^ self new setLeftBound: left rightBound: right leftOpen: true rightOpen: false! !

!RealInterval class methodsFor: 'instance creation' stamp: 'len 12/13/97 02:30'!
open: left open: right
	"Answer a new (left, right) interval."

	^ self new setLeftBound: left rightBound: right leftOpen: true rightOpen: true! !

!SemialgebraicInterval methodsFor: 'operations' stamp: 'len 1/8/98 20:35'!
boundary
	"Answer the boundary of the receiver."

	^ SemialgebraicSet new
		add: (self class between: self left and: self left);
		add: (self class between: self right and: self right);
		yourself! !

!SemialgebraicInterval methodsFor: 'operations' stamp: 'len 1/8/98 20:29'!
closure
	"Answer the closure of the receiver."

	^ self boundary copy add: self; yourself! !

!SemialgebraicInterval methodsFor: 'operations' stamp: 'len 1/16/98 21:58'!
interior
	"Answer the interior of the receiver."

	^ self closure copyWithoutAll: self boundary! !

!SemialgebraicInterval methodsFor: 'testing' stamp: 'len 2/6/98 13:33'!
isCylindricalOver: aCell
	"Answer true if the receiver is cylindrical over aCell."

	^ self = aCell! !

!SemialgebraicInterval methodsFor: 'accessing' stamp: 'len 1/17/98 13:49'!
polynomials
	"Answer the polynomials defining the receiver."

	| answer |
	answer _ Set new.
	self left isInfinity ifFalse: [answer add: self left polynomial].
	self right isInfinity ifFalse: [answer add: self right polynomial].
	^ answer! !

!SemialgebraicInterval methodsFor: 'printing' stamp: 'len 6/2/2016 02:09'!
printOn: aStream
	"aStream nextPut: ${; print: self sentence; nextPut: $}"
	self dimension >= 0
		ifFalse: [aStream nextPut: Character emptySet. ^ self].
	self dimension = 0
		ifTrue: [aStream nextPut: ${; print: self sample; nextPut: $}. ^ self].
	super printOn: aStream! !

!SemialgebraicInterval methodsFor: 'accessing' stamp: 'len 2/6/98 12:38'!
projection
	"Answer the projection of the receiver."
	^ nil! !

!SemialgebraicInterval methodsFor: 'accessing' stamp: 'len 6/1/2016 23:32'!
rank
	"Answer the number of indeterminates involved to define the receiver."
	^ 1! !

!SemialgebraicInterval methodsFor: 'accessing' stamp: 'len 1/17/2016 01:50'!
sample
	"Answer a sample point in the receiver."

	self isEmpty ifTrue: [^ self error: 'empty interval'].
	self left = self right ifTrue: [^ Tuple with: self left].
	(self isLeftBounded and: [self isRightBounded])
		ifTrue: [[self left rightBound <= self right leftBound]
					whileFalse: [self left refineWith: self right].
				^ Tuple with: self left rightBound + self right leftBound / 2].
	self isLeftBounded ifTrue: [^ Tuple with: self left rightBound + 1].
	self isRightBounded ifTrue: [^ Tuple with: self right leftBound - 1].
	^ Tuple with: 0! !

!SemialgebraicInterval methodsFor: 'accessing' stamp: 'len 3/18/2016 06:44'!
sentence
	"Answer a quantifier-free defining sentence for the receiver."

	| answer sample sign sentence |
	sample _ self sample.
	self polynomials do: [:each|
		sentence :=
			(sign _ (each value: sample) sign) = 0
				ifTrue: [each eq: 0]
				ifFalse: [sign = -1 ifTrue: [each lneq: 0] ifFalse: [each gneq: 0]].
		answer _ answer isNil ifTrue: [sentence] ifFalse: [answer & sentence]].
	^ answer! !

!SemialgebraicInterval class methodsFor: 'instance creation' stamp: 'len 12/20/97 02:35'!
between: leftBound and: rightBound
	"Answer a new instance of the receiver representing the
	univariate cell which is bounded by the given bounds."

	(leftBound = rightBound or: [leftBound isInfinity and: [rightBound isInfinity]])
		ifTrue: [^ self closed: leftBound closed: rightBound].
	leftBound isInfinity
		ifTrue: [^ self closed: leftBound open: rightBound].
	rightBound isInfinity
		ifTrue: [^ self open: leftBound closed: rightBound].
	^ self open: leftBound open: rightBound! !

!RightCoset methodsFor: 'arithmetic' stamp: 'len 2/13/2016 06:55'!
* aCoset
	^ self class on: subgroup representative: representative * aCoset representative! !

!RightCoset methodsFor: 'arithmetic' stamp: 'len 2/13/2016 06:55'!
+ aCoset
	^ self class on: subgroup representative: representative + aCoset representative! !

!RightCoset methodsFor: 'comparing' stamp: 'len 2/9/2016 07:03'!
= aCoset
	| inverseMap op |
	op _ subgroup operation.
	inverseMap _ subgroup inverseMap.
	^ subgroup includes: (op value: {representative. inverseMap value: aCoset representative})! !

!RightCoset methodsFor: 'arithmetic' stamp: 'len 2/13/2016 06:56'!
@ aCoset
	^ self class on: subgroup representative: representative @ aCoset representative! !

!RightCoset methodsFor: 'arithmetic' stamp: 'len 9/21/2016 16:58'!
 aCoset
	^ self class on: subgroup representative: representative  aCoset representative! !

!RightCoset methodsFor: 'enumerating' stamp: 'len 2/9/2016 07:04'!
do: aBlock
	"Enumerate the elements of the receiver."
	| op |
	op _ subgroup operation.
	subgroup do: [:each| aBlock value: (op value: {each. representative})]! !

!RightCoset methodsFor: 'comparing' stamp: 'len 11/25/2015 02:29'!
hash
	^ subgroup hash! !

!RightCoset methodsFor: 'testing' stamp: 'len 2/9/2016 07:05'!
includes: anElement
	| op inverseMap |
	op _ subgroup operation.
	inverseMap _ subgroup inverseMap.
	^ subgroup includes: (op value: {anElement. inverseMap value: representative})! !

!RightCoset methodsFor: 'arithmetic' stamp: 'len 2/13/2016 06:55'!
inverse
	^ self class on: subgroup representative: representative inverse! !

!RightCoset methodsFor: 'arithmetic' stamp: 'len 2/13/2016 06:55'!
negated
	^ self class on: subgroup representative: representative negated! !

!RightCoset methodsFor: 'printing' stamp: 'len 4/26/2016 08:09'!
printOn: aStream
	aStream nextPut: $[; print: representative; nextPut: $]
"	| op |
	op _ subgroup operation name ifNil: ['*']..
	aStream print: subgroup; space; nextPutAll: op; space; print: representative"! !

!RightCoset methodsFor: 'arithmetic' stamp: 'len 2/13/2016 06:55'!
reciprocal
	^ self class on: subgroup representative: representative reciprocal! !

!RightCoset methodsFor: 'accessing' stamp: 'len 11/25/2015 02:29'!
representative
	^ representative! !

!RightCoset methodsFor: 'accessing-private' stamp: 'len 11/25/2015 02:29'!
representative: anObject
	representative _ anObject! !

!RightCoset methodsFor: 'accessing' stamp: 'len 11/25/2015 02:29'!
subgroup
	^ subgroup! !

!RightCoset methodsFor: 'accessing-private' stamp: 'len 4/28/98 07:14'!
subgroup: aSubgroup
	subgroup _ aSubgroup! !

!RightCoset class methodsFor: 'instance creation' stamp: 'len 2/13/2016 06:57'!
on: aSubgroup representative: anObject
	^ self new subgroup: aSubgroup; representative: anObject! !

!Coset methodsFor: 'comparing' stamp: 'len 2/9/2016 07:01'!
= aCoset
	| inverseMap op |
	op _ subgroup operation.
	inverseMap _ subgroup inverseMap.
	^ subgroup includes: (op value: {representative. inverseMap value: aCoset representative})! !

!Coset methodsFor: 'enumerating' stamp: 'len 2/9/2016 07:02'!
do: aBlock
	"Enumerate the elements of the receiver."
	| op |
	op _ subgroup operation.
	self subgroup do: [:each| aBlock value: (op value: {representative. each})]! !

!Coset methodsFor: 'testing' stamp: 'len 2/9/2016 07:06'!
includes: anElement
	| op inverseMap |
	op _ subgroup operation.
	inverseMap _ subgroup inverseMap.
	^ subgroup includes: (op value: {inverseMap value: representative. anElement})! !

!Coset methodsFor: 'printing' stamp: 'len 4/26/2016 07:47'!
printOn: aStream
	super printOn: aStream
"	| op |
	op _ subgroup operation name ifNil: ['*']..
	aStream print: representative; space; nextPutAll: op; space; print: subgroup"! !

!Coset class methodsFor: 'instance creation' stamp: 'len 2/13/2016 06:57'!
on: aSubgroup representative: anObject
	^ self new subgroup: aSubgroup; representative: anObject! !

!Grassmannian methodsFor: 'comparing' stamp: 'len 4/20/2016 23:55'!
= aGrassmannian
	^ (aGrassmannian isKindOf: Grassmannian) and: [aGrassmannian space = self space]! !

!Grassmannian methodsFor: 'morphisms' stamp: 'len 4/21/2016 01:13'!
asHomogeneousSpace
	^ self notYetImplemented! !

!Grassmannian methodsFor: 'morphisms' stamp: 'len 6/10/2016 05:37'!
asProjectiveSpace
	self rank = 1 ifTrue: [^ space projective].
	^ self error: 'Grassmannian of rank > 1'! !

!Grassmannian methodsFor: 'random' stamp: 'len 4/21/2016 16:58'!
atRandom: aRandom bits: bits
	| basis |
	basis _ LinearBasis on: space.
	[basis size < rank]
		whileTrue:
			[ | v |
			[v _ space atRandom: aRandom bits: bits / rank.
			basis generates: v] whileTrue.
			basis add: v].
	^ basis span! !

!Grassmannian methodsFor: 'morphisms' stamp: 'len 4/21/2016 16:58'!
dual
	^ space dual grassmannian: space dimension - rank! !

!Grassmannian methodsFor: 'testing' stamp: 'len 4/21/2016 16:58'!
includes: aLinearSubspace
	^ space >= aLinearSubspace and: [aLinearSubspace rank = rank]! !

!Grassmannian methodsFor: 'morphisms' stamp: 'len 6/28/2016 23:34'!
pluckerEmbedding
	"Answer the Plucker embedding, a natural embedding of the Grassmannian into a projective space."
	^ self notYetImplemented "need to implement the wedge product"! !

!Grassmannian methodsFor: 'printing' stamp: 'len 4/29/2016 18:35'!
printOn: aStream
	aStream nextPutAll: 'Gr' bold; nextPut: $(; print: rank; nextPut: $,; print: space; nextPut: $)! !

!Grassmannian methodsFor: 'accessing' stamp: 'len 4/21/2016 16:58'!
rank
	^ rank! !

!Grassmannian methodsFor: 'private' stamp: 'len 4/21/2016 16:59'!
rank: anInteger
	rank _ anInteger! !

!Grassmannian methodsFor: 'accessing' stamp: 'len 6/29/2016 06:41'!
size
	self space isFinite ifFalse: [^ self space size].
	^ self space dimension choose: self rank q: self space scalars size! !

!Grassmannian methodsFor: 'accessing' stamp: 'len 4/20/2016 23:55'!
space
	^ space! !

!Grassmannian methodsFor: 'private' stamp: 'len 4/20/2016 23:56'!
space: aVectorSpace
	space _ aVectorSpace! !

!Grassmannian class methodsFor: 'instance creation' stamp: 'len 4/21/2016 17:01'!
new: anInteger over: aSpace
	^ self new space: aSpace; rank: anInteger! !

!LinearCode methodsFor: 'comparing' stamp: 'len 4/3/2016 23:27'!
<= aLinearCode
	^ self asVectorSpace <= aLinearCode asVectorSpace! !

!LinearCode methodsFor: 'comparing' stamp: 'len 4/3/2016 23:25'!
= aLinearCode
	^ (aLinearCode isKindOf: LinearCode) and: [self asVectorSpace = aLinearCode asVectorSpace]! !

!LinearCode methodsFor: 'accessing' stamp: 'len 5/23/2016 19:28'!
ambient
	"Answer the ambient vector space."
	^ self asVectorSpace ambient! !

!LinearCode methodsFor: 'converting' stamp: 'len 10/6/2016 10:05'!
asLattice
	"A linear code in a finite field or ring can be lifted to a lattice."
	| S F lift |
	S _ self asVectorSpace.
	F _ S scalars.
	lift _ S -> (S apply: F projection section) evaluating: [:each| each apply: F section].
	^ Lattice basis: (S basis apply: lift)! !

!LinearCode methodsFor: 'converting' stamp: 'len 3/31/2016 02:33'!
asVectorSpace
	^ subspace! !

!LinearCode methodsFor: 'random' stamp: 'len 5/12/2016 09:59'!
atRandom: aRandom bits: bitSize
	^ self asVectorSpace atRandom: aRandom bits: bitSize! !

!LinearCode methodsFor: 'morphisms' stamp: 'len 4/20/2016 20:56'!
automorphisms
	"Answer the subgroup of Perm(F^k) (permutation of coordinates) that leave the receiver invariant.
	The automorphisms of a code and it's dual are the same."
	self notYetImplemented! !

!LinearCode methodsFor: 'accessing' stamp: 'len 7/15/2016 18:27'!
completeWeightEnumerator
	"Answer the complete weight enumerator polynomial."
	| F P |
	F _ self ambient scalars elements asArray.
	P _ ZZ polynomialsIn: F size.
	^ self elements sum: [:each| P monomial: (Monomial exponents: (F collect: [:i| each occurrencesOf: i]))]! !

!LinearCode methodsFor: 'private' stamp: 'len 2/15/2016 20:35'!
computeMinimumDistance
	| answer w |
	answer _ Infinity positive.
	w _ self weight.
	self do: [:each| each isZero ifFalse: [answer _ answer min: (w value: each)]].
	^ answer! !

!LinearCode methodsFor: 'accessing' stamp: 'len 5/12/2016 07:19'!
dimension
	^ self rank! !

!LinearCode methodsFor: 'accessing' stamp: 'len 10/9/2016 09:06'!
distance
	"Answer the Hamming distance function."
	| k V |
	k _ self dimension.
	V _ self ambient.
	^ (V, V) to: ZZ evaluating: [:xy| | x y | x _ V coordinatesOf: xy first. y _ V coordinatesOf: xy second. (1 to: k) count: [:i| (x at: i) ~= (y at: i)]]! !

!LinearCode methodsFor: 'graphs' stamp: 'len 5/25/2016 03:46'!
distanceGraph: d
	"Answer the graph of the codewords of the receiver, with two codewords adjacent if their Hamming distance is d."
	| h G |
	h _ self distance. "the Hamming distance function"
	G _ Graph unordered.
	self elements do: [:x|
		self elements do: [:y|
			(h value: {x.y}) = d
				ifTrue: [G addEdgeFrom: x to: y]]].
	^ G! !

!LinearCode methodsFor: 'iterating' stamp: 'len 5/12/2016 07:08'!
do: aBlock
	self asVectorSpace do: aBlock! !

!LinearCode methodsFor: 'operations' stamp: 'len 5/12/2016 07:07'!
dual
	"Answer the dual or orthogonal code of the receiver."
	^ LinearCode subspace: self asVectorSpace perp! !

!LinearCode methodsFor: 'accessing' stamp: 'len 5/12/2016 07:07'!
generatorMatrix
	^ self asVectorSpace basis matrix! !

!LinearCode methodsFor: 'comparing' stamp: 'len 4/3/2016 23:25'!
hash
	^ self asVectorSpace hash! !

!LinearCode methodsFor: 'testing' stamp: 'len 5/12/2016 07:08'!
includes: aCodeword
	^ self asVectorSpace includes: aCodeword! !

!LinearCode methodsFor: 'testing' stamp: 'len 5/18/2016 06:28'!
isCyclic
	"A code is called a cylic code if for each codeword (c1,...,cn) it also contains the cyclic right shifted word (cn,c1,c2,...,cn-1), i.e. the code is invariant under cylic shifts."
	self do: [:each| (self includes: (each wrap: 1)) ifFalse: [^ false]].
	^ true! !

!LinearCode methodsFor: 'testing' stamp: 'len 5/12/2016 07:30'!
isMaximumDistanceSeparable
	"Any linear [n,k,d] code satisfies k + d <= n + 1 (Singleton bound). If a code satisfies k + d = n + 1 it's called Maximum Distance Separable (MDS)."
	| n k d |
	n _ self length.
	k _ self rank.
	d _ self minimumDistance.
	^ k + d = (n + 1)! !

!LinearCode methodsFor: 'testing' stamp: 'len 5/23/2016 04:38'!
isSelfDual
	self ambient dimension even ifFalse: [^ false].
	self dimension = (self ambient dimension / 2) ifFalse: [^ false].
	^ self = self dual! !

!LinearCode methodsFor: 'testing' stamp: 'len 4/3/2016 23:20'!
isSelfOrthogonal
	^ self asVectorSpace <= self dual asVectorSpace! !

!LinearCode methodsFor: 'morphisms' stamp: 'len 2/15/2016 20:26'!
isometries
	"Answer the subgroup of Iso(F^k) that leave the receiver invariant."
	self notYetImplemented! !

!LinearCode methodsFor: 'accessing' stamp: 'len 5/23/2016 04:38'!
length
	"Answer the length of a codeword."
	^ self ambient dimension! !

!LinearCode methodsFor: 'accessing' stamp: 'len 6/25/2016 03:33'!
minimumDistance
	"Answer the minimum Hamming distance between codewords.
	If the minimum distance is d, the code can correct (d-1)/2 errors."
	^ properties at: #minimumDistance ifAbsentPut: [self computeMinimumDistance]! !

!LinearCode methodsFor: 'accessing' stamp: 'len 5/12/2016 10:12'!
parityCheckMatrix
	^ self dual generatorMatrix! !

!LinearCode methodsFor: 'printing' stamp: 'len 6/7/2016 21:45'!
printOn: aStream
	aStream nextPut: $[; print: self length; nextPut: $,; print: self rank; nextPut: $,; print: self minimumDistance; nextPut: $].
	aStream isText
		ifTrue: [aStream nextPutAll: self ambient scalars size printString sub]
		ifFalse: [aStream nextPut: $-; print: self ambient scalars size]! !

!LinearCode methodsFor: 'accessing' stamp: 'len 5/12/2016 07:19'!
rank
	^ self asVectorSpace dimension! !

!LinearCode methodsFor: 'accessing' stamp: 'len 4/3/2016 23:08'!
rate
	^ (self size log: 2) / self length! !

!LinearCode methodsFor: 'accessing' stamp: 'len 2/15/2016 20:33'!
relativeDistance
	^ self minimumDistance / self length! !

!LinearCode methodsFor: 'accessing' stamp: 'len 5/12/2016 07:08'!
size
	"Answer the number of codewords."
	^ self asVectorSpace size! !

!LinearCode methodsFor: 'accessing-private' stamp: 'len 1/1/2016 06:35'!
subspace: aLinearSubspace
	subspace _ aLinearSubspace! !

!LinearCode methodsFor: 'graphs' stamp: 'len 5/25/2016 03:47'!
tannerGraph
	| matrix G |
	matrix _ self parityCheckMatrix.
	G _ Graph unordered.
	1 to: matrix numberOfRows do: [:i|
		1 to: matrix numberOfColumns do: [:j|
			(matrix at: i@j) isZero not
				ifTrue:
					[| subcode digit |
					subcode _ matrix rowAt: i.
					digit _ matrix columnAt: j.
					G addEdgeFrom: subcode to: digit]]].
	^ G! !

!LinearCode methodsFor: 'accessing' stamp: 'len 7/15/2016 18:27'!
weight
	"Answer the Hamming weight function."
	| V |
	V _ self ambient.
	^ Function from: V to: ZZ evaluating: [:x| (V coordinatesOf: x) asArray count: [:each| each isZero not]]! !

!LinearCode methodsFor: 'accessing' stamp: 'len 2/15/2016 20:44'!
weightDistribution
	| answer w |
	w _ self weight.
	answer _ Bag new.
	self do: [:each| answer add: (w value: each)].
	^ answer! !

!LinearCode methodsFor: 'accessing' stamp: 'len 1/1/2016 00:06'!
weightDistribution: aCodeword
	"Answer the weight distribution wrt aCodeword."
	self notYetImplemented! !

!LinearCode methodsFor: 'accessing' stamp: 'len 7/15/2016 18:27'!
weightEnumerator
	"Answer the Hamming weight enumerator polynomial."
	| P x y weights answer n |
	P _ ZZ polynomialsIn: #(x y).
	x _ P x.
	y _ P y.
	answer _ P zero.
	n _ self ambient dimension.
	weights _ self weightDistribution.
	weights asSet do: [:i| answer _ x ** (n - i) * (y ** i) * (weights occurrencesOf: i) + answer].
	^ answer! !

!LinearCode class methodsFor: 'examples' stamp: 'len 6/25/2016 08:05'!
G11
	"Answer the perfect ternary Golary code [11,6,5]."
	| F A |
	F _ Field GF: 3.
	A _ (F ** (6@11)) new.
	A addRow: (1,0,0,0,0,0, 1,1,1,1,1) % 3.
	A addRow: (0,1,0,0,0,0, 0,1,2,2,1) % 3.
	A addRow: (0,0,1,0,0,0, 1,0,1,2,2) % 3.
	A addRow: (0,0,0,1,0,0, 2,1,0,1,2) % 3.
	A addRow: (0,0,0,0,1,0, 2,2,1,0,1) % 3.
	A addRow: (0,0,0,0,0,1, 1,2,2,1,0) % 3.
	^ self matrix: A! !

!LinearCode class methodsFor: 'examples' stamp: 'len 6/25/2016 08:05'!
G12
	"Answer the extended ternary Golary code [12,6,6]."
	| F A |
	F _ Field GF: 3.
	A _ (F ** (6@11)) new.
	A addRow: (1,0,0,0,0,0, 0,1,1,1,1,1) % 3.
	A addRow: (0,1,0,0,0,0, 1,0,1,2,2,1) % 3.
	A addRow: (0,0,1,0,0,0, 1,1,0,1,2,2) % 3.
	A addRow: (0,0,0,1,0,0, 1,2,1,0,1,2) % 3.
	A addRow: (0,0,0,0,1,0, 1,2,2,1,0,1) % 3.
	A addRow: (0,0,0,0,0,1, 1,1,2,2,1,0) % 3.
	^ self matrix: A! !

!LinearCode class methodsFor: 'examples' stamp: 'len 8/31/2016 05:38'!
G24
	"Answer the extended binary Golary code [24,12,8].
	Its generator matrix is I|A, where I is the 12x12 identity matrix and A is the complement of the adjacency matrix of the icosahedron."
	| F A |
	F _ ZZ mod: 2.
	A _ Graph icosahedron adjacencyMatrix: (1 to: 12).
	A _ A apply: (Function from: A scalars to: F evaluating: [:x| x = 0 ifTrue: [F one] ifFalse: [F zero]]).
	^ self matrix: A species identity | A! !

!LinearCode class methodsFor: 'examples' stamp: 'len 3/31/2016 01:45'!
H7
	"Answer the [7,4,3] Hamming code, which is the binary cyclic code of length 7 with generator polynomial 1 + x + x^3."
	| F A c |
	F _ Field GF: 2.
	A _ (F ** (4@7)) new.
	A addRow: (c _ (1,1,0,1,0,0,0) % 2).
	3 timesRepeat: [A addRow: (c _ c >> 1)].
	^ self matrix: A! !

!LinearCode class methodsFor: 'examples' stamp: 'len 6/26/2016 01:28'!
H8
	"Answer the extended Hamming code [8,4,4]."
	| F A |
	F _ Field GF: 2.
	A _ (F ** (4@8)) new.
	A addRow: (1,0,0,0, 0,1,1,1) % 2.
	A addRow: (0,1,0,0, 1,0,1,1) % 2.
	A addRow: (0,0,1,0, 1,1,0,1) % 2.
	A addRow: (0,0,0,1, 1,1,1,0) % 2.
	^ self matrix: A! !

!LinearCode class methodsFor: 'examples' stamp: 'len 5/12/2016 09:42'!
hadamard8
	"Answer the [8,3,4] Hadamard code."
	| F A |
	F _ Field GF: 2.
	A _ (F ** (3@8)) new.
	A addRow: (0,0,0,0,1,1,1,1) % 2.
	A addRow: (0,0,1,1,0,0,1,1) % 2.
	A addRow: (0,1,0,1,0,1,0,1) % 2.
	^ self matrix: A! !

!LinearCode class methodsFor: 'instance creation' stamp: 'len 1/1/2016 06:02'!
matrix: aMatrix
	"Answer a linear code with generator matrix aMatrix."
	^ self subspace: aMatrix rowSpace! !

!LinearCode class methodsFor: 'examples' stamp: 'len 5/12/2016 09:41'!
simplex
	"Answer the [7,3,4] simplex code, which is the dual code of the Hamming code."
	| F A |
	F _ Field GF: 2.
	A _ (F ** (3@7)) new.
	A addRow: (0,0,0,1,1,1,1) % 2.
	A addRow: (0,1,1,0,0,1,1) % 2.
	A addRow: (1,0,1,0,1,0,1) % 2.
	^ self matrix: A! !

!LinearCode class methodsFor: 'instance creation' stamp: 'len 1/1/2016 06:34'!
subspace: aLinearSubspace
	^ self new subspace: aLinearSubspace! !

!LinearCode class methodsFor: 'examples' stamp: 'len 4/8/2016 01:46'!
tetracode
	"Answer the tetracode, a self dual code of minimum distance 3."
	^ self subspace: ((Field GF: 3) ** 4 span: {(1,1,1,0) % 3. (0,1,2,1) % 3})! !

!CyclicCode2 methodsFor: 'converting' stamp: 'len 5/17/2016 21:26'!
asIdeal
	^ generator ideal! !

!CyclicCode2 methodsFor: 'accessing' stamp: 'len 5/18/2016 07:24'!
checkPolynomial
	| x one |
	x _ generator species x.
	one _ generator species one.
	^ x ** self length - one / generator! !

!CyclicCode2 methodsFor: 'accessing' stamp: 'len 5/18/2016 07:21'!
dimension
	^ self length - generator degree! !

!CyclicCode2 methodsFor: 'iterating' stamp: 'len 5/18/2016 06:30'!
do: aBlock
	self asIdeal do: aBlock! !

!CyclicCode2 methodsFor: 'operations' stamp: 'len 5/18/2016 07:30'!
dual
	^ self class new: self length generator: self generator reversed! !

!CyclicCode2 methodsFor: 'accessing' stamp: 'len 5/17/2016 21:02'!
generator
	^ generator! !

!CyclicCode2 methodsFor: 'accessing-private' stamp: 'len 5/18/2016 07:21'!
generator: aPolynomial
	generator _ aPolynomial.
"
	| n V g x |
	generator _ aPolynomialResidue.
	n _ generator modulus degree.
	V _ generator ispecies asVectorSpaceMaxDegree: n.
	basis _ LinearBasis on: V.
	g _ generator.
	x _ generator representative species x mod: generator modulus.
	[basis includes: g] whileFalse: [basis add: g. g _ g * x].
	self subspace: basis span"! !

!CyclicCode2 methodsFor: 'testing' stamp: 'len 5/18/2016 07:27'!
includes: aCodeword
	| x |
	x _ generator species x.
	^ self checkPolynomial * aCodeword \\ (x ** self length - x one) :: isZero! !

!CyclicCode2 methodsFor: 'testing' stamp: 'len 5/18/2016 07:22'!
isIrreducible
	^ generator isIrreducible! !

!CyclicCode2 class methodsFor: 'examples' stamp: 'len 5/18/2016 07:20'!
H7
	"Answer the Hamming code of length 7."
	| F Fx x |
	F _ Field GF: 2.
	Fx _ F polynomials.
	x _ Fx x.
	^ self new: 7 generator: x**3 + x + 1! !

!CyclicCode2 class methodsFor: 'instance creation' stamp: 'len 5/18/2016 07:20'!
new: n generator: aPolynomial
	| F |
	F _ aPolynomial scalars.
	^ (self new subspace: (F extension: aPolynomial) asVectorSpace) generator: aPolynomial! !

!PolynomialCode methodsFor: 'encoding/decoding' stamp: 'len 5/12/2016 09:33'!
decode: aPolynomial
	self flag: #fix. "add error-detection and correction"
	^ aPolynomial // generator! !

!PolynomialCode methodsFor: 'encoding/decoding' stamp: 'len 5/12/2016 09:31'!
encode: aPolynomial
	| f |
	f _ aPolynomial shift: generator degree.
	^ f - (f \\ generator)! !

!PolynomialCode methodsFor: 'accessing' stamp: 'len 4/4/2016 20:19'!
generator
	^ generator! !

!PolynomialCode methodsFor: 'accessing-private' stamp: 'len 4/4/2016 20:19'!
generator: aPolynomial
	generator _ aPolynomial! !

!PolynomialCode methodsFor: 'testing' stamp: 'len 5/12/2016 07:17'!
includes: aCodeword
	^ aCodeword | generator! !

!PolynomialCode methodsFor: 'testing' stamp: 'len 5/12/2016 07:51'!
isCyclic
	| n x |
	n _ self length.
	x _ generator species x.
	^ generator | (x ** n - x species one)! !

!PolynomialCode methodsFor: 'accessing' stamp: 'len 5/12/2016 07:20'!
rank
	^ self length - generator degree! !

!PolynomialCode methodsFor: 'accessing' stamp: 'len 5/3/2016 08:28'!
size
	^ generator species scalars size ** (self length - generator degree)! !

!PolynomialCode class methodsFor: 'examples' stamp: 'len 6/29/2016 21:55'!
G23
	"Answer the perfect binary Golay code [23,12,7]."
	| F Fx x g |
	F _ Field GF: 2.
	Fx _ F polynomials.
	x _ Fx x.
	g _ x**11 + (x**10) + (x**6) + (x**5) + (x**4) + (x**2) + Fx one.
	^ self new: 23 generator: g! !

!PolynomialCode class methodsFor: 'examples' stamp: 'len 6/29/2016 21:57'!
H7
	"Answer the Hamming code [7,4,3]."
	| F Fx x g |
	F _ Field GF: 2.
	Fx _ F polynomials.
	x _ Fx x.
	g _ x**3 + x + Fx one.
	^ self new: 7 generator: g! !

!PolynomialCode class methodsFor: 'instance creation' stamp: 'len 5/12/2016 07:42'!
generator: aPolynomial
	^ self new: aPolynomial degree generator: aPolynomial! !

!PolynomialCode class methodsFor: 'instance creation' stamp: 'len 6/29/2016 21:52'!
new: n generator: aPolynomial
	| V W subspace |
	V _ aPolynomial species asVectorSpaceMaxDegree: n - 1.
	W _ aPolynomial species asVectorSpaceMaxDegree: n - aPolynomial degree - 1.
	subspace _ V span: (W collect: [:f| aPolynomial * f]).
	^ (self subspace: subspace) generator: aPolynomial! !

!CyclicCode methodsFor: 'as yet unclassified' stamp: 'len 6/29/2016 22:18'!
checkPolynomial
	| x one |
	x _ generator species x.
	one _ generator species one.
	^ x ** self length - one / generator! !

!CyclicCode methodsFor: 'as yet unclassified' stamp: 'len 6/29/2016 22:18'!
dual
	^ self class new: self length generator: self generator reversed! !

!CyclicCode methodsFor: 'as yet unclassified' stamp: 'len 6/29/2016 22:18'!
includes: aCodeword
	| x |
	x _ generator species x.
	^ self checkPolynomial * aCodeword \\ (x ** self length - x one) :: isZero! !

!CyclicCode methodsFor: 'as yet unclassified' stamp: 'len 6/29/2016 22:18'!
isIrreducible
	^ generator isIrreducible! !

!AffineLinearSpace methodsFor: 'operations' stamp: 'len 6/4/2016 04:24'!
* aScalar
	(self scalars includes: aScalar)
		ifTrue: [^ self class representative: representative * aScalar direction: direction].
	^ super * aScalar "if it's not a scalar"! !

!AffineLinearSpace methodsFor: 'operations' stamp: 'len 8/30/2016 05:47'!
+ anObject
	(anObject isKindOf: AffineLinearSpace)
		ifTrue: [^ self class representative: representative + anObject representative direction: direction + anObject direction].
	(anObject isKindOf: VectorSpace)
		ifTrue: [^ self class representative: representative direction: direction + anObject].
	(direction ambient includes: anObject)
		ifTrue: [^ self class representative: representative + anObject direction: direction].
	DomainError signal! !

!AffineLinearSpace methodsFor: 'operations' stamp: 'len 6/11/2016 17:03'!
- anObject
	^ self + anObject negated! !

!AffineLinearSpace methodsFor: 'morphisms' stamp: 'len 9/2/2016 05:38'!
-> aDomain
	"Answer the morphisms that go from the receiver A to the argument B: Hom(A,B)."
	^ AffineMaps from: self to: aDomain! !

!AffineLinearSpace methodsFor: 'operations' stamp: 'len 8/30/2016 05:47'!
/ aLinearSubspace
	direction >= aLinearSubspace ifFalse: [DomainError signal: 'not a linear subspace'].
	self flag: #fix. "wtf"
	^ self class representative: (AffineLinearSpace representative: representative direction: aLinearSubspace) direction: direction / aLinearSubspace! !

!AffineLinearSpace methodsFor: 'operations' stamp: 'len 9/1/2016 07:52'!
/\ anAffineSubspace
	"Meet."
	^ self  anAffineSubspace! !

!AffineLinearSpace methodsFor: 'comparing' stamp: 'len 12/26/2015 20:01'!
< anAffineSubspace
	"Answer true if the receiver is strictly included in the argument."
	^ self dimension < anAffineSubspace dimension and: [self <= anAffineSubspace]! !

!AffineLinearSpace methodsFor: 'comparing' stamp: 'len 8/24/2016 22:04'!
<= anAffineSubspace
	"Answer true if the receiver is included in the argument."
	self == anAffineSubspace ifTrue: [^ true].
	self dimension <= anAffineSubspace dimension ifFalse: [^ false].
	self isEmpty ifTrue: [^ true].
	^ (anAffineSubspace includes: representative) and: [direction <= anAffineSubspace direction]! !

!AffineLinearSpace methodsFor: 'comparing' stamp: 'len 8/30/2016 05:47'!
= anObject
	self == anObject ifTrue: [^ true].
	(anObject isKindOf: AffineLinearSpace) ifFalse: [^ false].
	self isEmpty ifTrue: [^ anObject isEmpty].
	^ direction = anObject direction and: [anObject includes: representative]! !

!AffineLinearSpace methodsFor: 'operations' stamp: 'len 9/1/2016 07:42'!
\/ anAffineSubspace
	"Join."
	^ self + anAffineSubspace! !

!AffineLinearSpace methodsFor: 'operations' stamp: 'len 9/1/2016 07:52'!
 anAffineSubspace
	| system |
	self isEmpty ifTrue: [^ self].
	anAffineSubspace isEmpty ifTrue: [^ anAffineSubspace].
	system _ self equations copy.
	anAffineSubspace equations do: [ :each | system add: each].
	^ system solutions! !

!AffineLinearSpace methodsFor: 'accessing' stamp: 'len 6/4/2016 04:25'!
ambient
	"Answer the ambient affine space where the receiver lives."
	^ self class representative: direction zero direction: direction ambient! !

!AffineLinearSpace methodsFor: 'morphisms' stamp: 'len 6/4/2016 04:26'!
apply: aMap
	"Answer the receiver transformed by anAffineMap."
	(aMap isKindOf: AffineMap)
		ifTrue: [^ self class representative: (aMap value: representative) direction: (direction apply: aMap linearPart)].
	^ self class representative: (aMap value: representative) direction: (direction apply: aMap)! !

!AffineLinearSpace methodsFor: 'random' stamp: 'len 6/4/2016 04:29'!
atRandom: aRandom
	^ (direction atRandom: aRandom) + representative! !

!AffineLinearSpace methodsFor: 'random' stamp: 'len 6/4/2016 04:30'!
atRandom: aRandom bits: bitSize
	^ (direction atRandom: aRandom bits: bitSize) + representative! !

!AffineLinearSpace methodsFor: 'morphisms' stamp: 'len 8/31/2016 08:27'!
automorphisms
	"Answer the general affine group GA(A)."
	^ GeneralAffineGroup on: self! !

!AffineLinearSpace methodsFor: 'accessing' stamp: 'len 2/9/2016 21:23'!
codimension
	^ direction codimension! !

!AffineLinearSpace methodsFor: 'coordinates' stamp: 'len 6/9/2016 00:39'!
coordinatesOf: aPoint
	^ direction coordinatesOf: aPoint - representative! !

!AffineLinearSpace methodsFor: 'accessing' stamp: 'len 6/4/2016 04:21'!
dimension
	^ representative isNil ifTrue: [-1] ifFalse: [direction dimension]! !

!AffineLinearSpace methodsFor: 'accessing' stamp: 'len 5/23/2016 19:44'!
direction
	"Answer the 'difference space' or 'direction', a linear subspace parallel to the receiver."
	^ direction! !

!AffineLinearSpace methodsFor: 'accessing-private' stamp: 'len 2/9/2016 21:29'!
direction: aVectorSpace
	direction _ aVectorSpace! !

!AffineLinearSpace methodsFor: 'iterating' stamp: 'len 6/4/2016 04:30'!
do: aBlock
	direction do: [:each| aBlock value: each + representative]! !

!AffineLinearSpace methodsFor: 'accessing' stamp: 'len 6/4/2016 04:29'!
equations
	"Answer a linear system defining the receiver."
	| kernel particular answer |
	kernel _ direction equations.
	particular _ self ambient coordinatesOf: representative.
	answer _ LinearSystem new.
	kernel do: [:each| answer add: (each form eq: (each form value: particular))].
	^ answer! !

!AffineLinearSpace methodsFor: 'accessing' stamp: 'len 6/4/2016 04:18'!
frame
	^ AffineFrame origin: representative basis: direction basis! !

!AffineLinearSpace methodsFor: 'comparing' stamp: 'len 2/9/2016 21:25'!
hash
	^ self isEmpty ifTrue: [0] ifFalse: [direction hash]! !

!AffineLinearSpace methodsFor: 'morphisms' stamp: 'len 8/25/2016 06:24'!
id
	"Answer the identity morphism."
	^ AffineMap from: self to: self evaluating: [:x| x]! !

!AffineLinearSpace methodsFor: 'testing' stamp: 'len 6/4/2016 04:32'!
includes: anObject
	^ self isEmpty not and: [direction includes: anObject - representative]! !

!AffineLinearSpace methodsFor: 'testing' stamp: 'len 11/9/2015 16:23'!
isEmpty
	^ self dimension = -1! !

!AffineLinearSpace methodsFor: 'testing' stamp: 'len 1/5/2016 00:05'!
isHyperplane
	^ self codimension = 1! !

!AffineLinearSpace methodsFor: 'testing' stamp: 'len 1/5/2016 00:04'!
isLine
	^ self dimension = 1! !

!AffineLinearSpace methodsFor: 'testing' stamp: 'len 1/5/2016 00:04'!
isPlane
	^ self dimension = 2! !

!AffineLinearSpace methodsFor: 'testing' stamp: 'len 1/5/2016 00:04'!
isPoint
	^ self dimension = 0! !

!AffineLinearSpace methodsFor: 'testing' stamp: 'len 6/4/2016 04:29'!
isZero
	^ direction includes: representative! !

!AffineLinearSpace methodsFor: 'morphisms' stamp: 'len 8/31/2016 08:28'!
motions
	"Answer the Euclidean group E(A), the group of isometries, i.e. distance-preserving morphisms, also called 'motionss'. This is a subgroup of the general affine group GA(A)."
	^ EuclideanGroup on: self! !

!AffineLinearSpace methodsFor: 'operations' stamp: 'len 6/4/2016 04:21'!
negated
	^ self class representative: representative negated direction: direction! !

!AffineLinearSpace methodsFor: 'testing' stamp: 'len 2/9/2016 21:24'!
parallel: anAffineSubspace "|| anAffineSubspace"
	^ direction <= anAffineSubspace direction or: [direction >= anAffineSubspace direction]! !

!AffineLinearSpace methodsFor: 'coordinates' stamp: 'len 6/9/2016 00:40'!
pointAt: aTuple
	^ (direction vectorAt: aTuple) + representative! !

!AffineLinearSpace methodsFor: 'printing' stamp: 'len 6/8/2016 06:15'!
printOn: aStream
	direction ambient = direction ifTrue: [aStream print: direction. ^ self].
	self isEmpty ifTrue: [aStream nextPut: Character emptySet. ^ self].
	self dimension = 0 ifTrue: [aStream nextPut: ${; print: representative; nextPut: $}. ^ self].
	aStream print: direction; nextPutAll: ' + '; print: representative! !

!AffineLinearSpace methodsFor: 'operations' stamp: 'len 6/4/2016 00:19'!
product: anAffineSubspace
	^ self class on: (direction product: anAffineSubspace direction)! !

!AffineLinearSpace methodsFor: 'operations' stamp: 'len 10/7/2016 08:41'!
projectiveClosure
	^ (direction  self scalars asSelfModule) projective! !

!AffineLinearSpace methodsFor: 'accessing' stamp: 'len 6/4/2016 04:18'!
representative
	^ representative! !

!AffineLinearSpace methodsFor: 'accessing-private' stamp: 'len 6/4/2016 04:30'!
representative: aPoint
	representative _ aPoint! !

!AffineLinearSpace methodsFor: 'morphisms' stamp: 'len 8/31/2016 08:28'!
rigidMotions
	"Answer the special Euclidean group SE(A), the group of direct isometries, i.e. isometries preserving orientation, also called 'rigid motions'. This is a subgroup of the Euclidean group of motions (see >>motions) which in turn is a subgroup of the general affine group GA(A)."
	^ SpecialEuclideanGroup on: self! !

!AffineLinearSpace methodsFor: 'accessing' stamp: 'len 2/9/2016 21:25'!
scalars
	^ direction scalars! !

!AffineLinearSpace methodsFor: 'operations' stamp: 'len 6/4/2016 04:31'!
span
	"Answer the linear span of the receiver."
	(direction includes: representative) ifTrue: [^ direction].
	^ (direction basis copyWith: representative) span! !

!AffineLinearSpace methodsFor: 'operations' stamp: 'len 6/11/2016 16:55'!
span: aCollection
	"Answer the subspace spanned by the points in aCollection."
	| p |
	p _ aCollection anyOne.
	^ self class representative: p direction: (direction span: ((aCollection copyWithout: p) collect: [:each| each - p]))! !

!AffineLinearSpace methodsFor: 'morphisms' stamp: 'len 8/31/2016 03:38'!
to: anAffineSpace evaluating: aBlock
	(anAffineSpace isKindOf: AffineLinearSpace) ifFalse: [^ super to: anAffineSpace evaluating: aBlock].
	^ AffineMap from: self to: anAffineSpace evaluating: aBlock! !

!AffineLinearSpace class methodsFor: 'instance creation' stamp: 'len 6/4/2016 04:22'!
representative: aVector direction: aVectorSpace
	^ self new direction: aVectorSpace; representative: aVector! !

!AffineMaps methodsFor: 'accessing' stamp: 'len 8/25/2016 21:08'!
codomain
	^ self direction codomain asAffineSpace! !

!AffineMaps methodsFor: 'accessing' stamp: 'len 8/25/2016 21:08'!
domain
	^ self direction domain asAffineSpace! !

!AffineMaps methodsFor: 'elements' stamp: 'len 8/25/2016 21:09'!
evaluating: aBlock
	^ AffineMap from: self domain to: self codomain evaluating: aBlock! !

!AffineMaps methodsFor: 'elements' stamp: 'len 8/25/2016 21:09'!
identity
	^ self evaluating: [:x| x]! !

!AffineMaps methodsFor: 'printing' stamp: 'len 8/25/2016 21:08'!
printOn: aStream
	"Delegate in order to print the standard notation:"
	(Morphisms from: self domain to: self codomain) printOn: aStream! !

!AffineMaps methodsFor: 'elements' stamp: 'len 8/25/2016 21:10'!
scalar: aNumber
	^ self evaluating: [:x| x * aNumber]! !

!AffineMaps methodsFor: 'elements' stamp: 'len 8/25/2016 21:10'!
translation: aVector
	^ self evaluating: [:x| x + aVector]! !

!ProjectiveLinearSpace methodsFor: 'operations' stamp: 'len 11/20/2015 22:06'!
+ aProjectiveSubspace
	^ self class on: vectorSpace + aProjectiveSubspace vectorSpace! !

!ProjectiveLinearSpace methodsFor: 'morphisms' stamp: 'len 9/2/2016 05:39'!
-> aProjectiveSpace
	"Answer the morphisms that go from the receiver A to the argument B: Hom(A,B)."
	^ (vectorSpace -> aProjectiveSpace vectorSpace) projective! !

!ProjectiveLinearSpace methodsFor: 'operations' stamp: 'len 9/1/2016 07:54'!
/\ aProjectiveSubspace
	"Meet."
	^ self  aProjectiveSubspace! !

!ProjectiveLinearSpace methodsFor: 'comparing' stamp: 'len 11/20/2015 22:07'!
< aProjectiveSubspace
	"Answer true if the receiver is strictly included in the argument."

	^ vectorSpace < aProjectiveSubspace vectorSpace! !

!ProjectiveLinearSpace methodsFor: 'comparing' stamp: 'len 11/20/2015 22:07'!
<= aProjectiveSubspace
	"Answer true if the receiver is included in the argument."

	^ vectorSpace <= aProjectiveSubspace vectorSpace! !

!ProjectiveLinearSpace methodsFor: 'comparing' stamp: 'len 8/30/2016 05:46'!
= anObject
	^ (anObject isKindOf: ProjectiveLinearSpace) and: [vectorSpace = anObject vectorSpace]! !

!ProjectiveLinearSpace methodsFor: 'operations' stamp: 'len 6/5/2016 23:10'!
\ anHyperplane
	"Answer the difference of the receiver with an hyperplane, i.e. an affine space."
	^ self notYetImplemented! !

!ProjectiveLinearSpace methodsFor: 'operations' stamp: 'len 6/5/2016 22:47'!
\/ aProjectiveSubspace
	"Join."
	^ self + aProjectiveSubspace! !

!ProjectiveLinearSpace methodsFor: 'operations' stamp: 'len 9/1/2016 07:54'!
 aProjectiveSubspace
	"Answer the intersection between the receiver and the argument."

	^ self class on: (vectorSpace  aProjectiveSubspace vectorSpace)! !

!ProjectiveLinearSpace methodsFor: 'accessing' stamp: 'len 5/23/2016 19:48'!
ambient
	"Answer the ambient space (a projective space)."
	^ self class on: vectorSpace ambient! !

!ProjectiveLinearSpace methodsFor: 'converting' stamp: 'len 8/25/2016 20:18'!
asGrassmannian
	"A projective space is the set of lines through the origin of a vector space, i.e. subspaces of dimension 1. That's the grassmannian Gr(1,V)."
	^ vectorSpace grassmannian: 1! !

!ProjectiveLinearSpace methodsFor: 'random' stamp: 'len 4/19/2016 20:30'!
atRandom: aRandom
	| v |
	[(v _ vectorSpace atRandom: aRandom) isZero] whileTrue.
	^ self project: v! !

!ProjectiveLinearSpace methodsFor: 'random' stamp: 'len 4/19/2016 20:30'!
atRandom: aRandom bits: bitSize
	| v |
	[(v _ vectorSpace atRandom: aRandom bits: bitSize) isZero] whileTrue.
	^ self project: v! !

!ProjectiveLinearSpace methodsFor: 'morphisms' stamp: 'len 8/5/2016 05:14'!
automorphisms
	^ ProjectiveGeneralLinearGroup on: self! !

!ProjectiveLinearSpace methodsFor: 'accessing' stamp: 'len 1/3/2016 05:23'!
chart: anInteger
	"Answer the anInteger-th canonic chart."
	^ ProjectiveChart
		frame: self frame
		index: anInteger
		origin: (vectorSpace e: anInteger)! !

!ProjectiveLinearSpace methodsFor: 'accessing' stamp: 'len 6/4/2016 05:56'!
chartAt: anHyperplane
	"Answer the chart that puts anHyperplane at infinity and its complement as affine space."
	^ ProjectiveChart infinity: anHyperplane! !

!ProjectiveLinearSpace methodsFor: 'accessing' stamp: 'len 11/20/2015 22:11'!
codimension
	^ vectorSpace codimension! !

!ProjectiveLinearSpace methodsFor: 'testing' stamp: 'len 1/5/2016 00:04'!
collinear: aProjectiveSubspace
	"Answer true if the receiver and the argument are within a line."
	^ (self + aProjectiveSubspace) dimension <= 1! !

!ProjectiveLinearSpace methodsFor: 'coordinates' stamp: 'len 11/21/2015 07:02'!
coordinatesOf: anObject
	"Answer the coordinates of the argument in the receiver."

	^ (vectorSpace coordinatesOf: (self vectorFromPoint: anObject)) homogeneous! !

!ProjectiveLinearSpace methodsFor: 'testing' stamp: 'len 1/5/2016 00:04'!
coplanar: aProjectiveSubspace
	"Answer true if the receiver and the argument are within a plane."
	^ (self + aProjectiveSubspace) dimension <= 2! !

!ProjectiveLinearSpace methodsFor: 'accessing' stamp: 'len 11/20/2015 22:12'!
dimension
	^ vectorSpace dimension - 1! !

!ProjectiveLinearSpace methodsFor: 'operations' stamp: 'len 2/4/2016 19:58'!
dual
	"Answer the dual projective space of the receiver.
	For a projective plane C = (P,L,I) given by points P, lines L, and an incidence relation I, the duality maps points to lines and lines to points preserving incidence: C* = (L,P,I*).
	In the more general case of a projective space of dimension n, the duality interchanges points with hyperplanes and objects of dimension r with objects of dimension n - 1 - r."
	^ self class on: vectorSpace annihilator! !

!ProjectiveLinearSpace methodsFor: 'coordinates' stamp: 'len 6/4/2016 01:38'!
e: anInteger
	"Answer the anInteger-th canonic point."

	^ self project: (vectorSpace e: anInteger)! !

!ProjectiveLinearSpace methodsFor: 'morphisms' stamp: 'len 6/3/2016 23:30'!
embed: aPoint
	"Assumeing the underlying vector space is V (+) K, embed aPoint from A(V) into the receiver."
	^ self project: {aPoint. vectorSpace scalars one}! !

!ProjectiveLinearSpace methodsFor: 'morphisms' stamp: 'len 10/10/2016 08:56'!
embedding
	"Answer the embedding A(V) -> P(VK), assuming the underlying vector space is VK."
	^ ((vectorSpace at: 1) asAffineSpace to: self evaluating: [:p| self embed: p]) name: 'i'! !

!ProjectiveLinearSpace methodsFor: 'accessing' stamp: 'len 1/3/2016 05:27'!
frame
	"Answer the canonic frame of the receiver."
	| answer |
	answer _ ProjectiveFrame on: self; unit: self unit.
	1 to: self dimension + 1 do: [:i| answer add: (self e: i)].
	^ answer! !

!ProjectiveLinearSpace methodsFor: 'comparing' stamp: 'len 6/28/2016 09:26'!
hash
	^ vectorSpace hash + self class hash! !

!ProjectiveLinearSpace methodsFor: 'morphisms' stamp: 'len 8/25/2016 06:25'!
id
	"Answer the identity morphism."
	^ ProjectiveMap from: self to: self evaluating: [:x| x]! !

!ProjectiveLinearSpace methodsFor: 'testing' stamp: 'len 3/23/2016 21:49'!
includes: aPoint
	^ vectorSpace includes: (self vectorFromPoint: aPoint)! !

!ProjectiveLinearSpace methodsFor: 'testing' stamp: 'len 1/5/2016 00:03'!
isEmpty
	^ self dimension = -1! !

!ProjectiveLinearSpace methodsFor: 'testing' stamp: 'len 1/5/2016 00:05'!
isHyperplane
	^ self codimension = 1! !

!ProjectiveLinearSpace methodsFor: 'testing' stamp: 'len 11/21/2015 06:14'!
isLine
	^ self dimension = 1! !

!ProjectiveLinearSpace methodsFor: 'testing' stamp: 'len 11/20/2015 21:00'!
isPappian
	^ self isPlane and: [self scalars isCommutative]! !

!ProjectiveLinearSpace methodsFor: 'testing' stamp: 'len 11/20/2015 20:59'!
isPlane
	^ self dimension = 2! !

!ProjectiveLinearSpace methodsFor: 'testing' stamp: 'len 11/21/2015 06:14'!
isPoint
	^ self dimension = 0! !

!ProjectiveLinearSpace methodsFor: 'coordinates' stamp: 'len 6/4/2016 01:38'!
pointAt: anHomogeneousTuple
	"Answer the point with the given homogenous coordinates in the receiver."

	^ self project: (vectorSpace vectorAt: anHomogeneousTuple asTuple)! !

!ProjectiveLinearSpace methodsFor: 'printing' stamp: 'len 9/1/2016 03:12'!
printOn: aStream
	self isAmbient
		ifTrue:
			[aStream nextPut: Character PP; nextPut: $(; print: vectorSpace; nextPut: $).
			^ self].
	aStream nextPut: $[.
	self dimension = 0 "a point"
		ifTrue:
			[| v |
			v _ vectorSpace basis first.
			(v isKindOf: Tuple) ifTrue: [v do: [:each| aStream print: each] separatedBy: [aStream nextPut: $:]]]
		ifFalse:
			[aStream print: vectorSpace].
	aStream nextPut: $]! !

!ProjectiveLinearSpace methodsFor: 'morphisms' stamp: 'len 6/4/2016 02:23'!
project: aVector
	^ self class on: (vectorSpace span: {aVector})! !

!ProjectiveLinearSpace methodsFor: 'morphisms' stamp: 'len 10/10/2016 08:51'!
projection
	"Answer the canonical projection V\{0} -> P(V)."
	^ (Function from: vectorSpace to: self evaluating: [:v| self project: v]) name: Character pi asString! !

!ProjectiveLinearSpace methodsFor: 'accessing' stamp: 'len 11/20/2015 22:13'!
scalars
	^ vectorSpace scalars! !

!ProjectiveLinearSpace methodsFor: 'accessing' stamp: 'len 8/25/2016 19:16'!
size
	^ self asGrassmannian size! !

!ProjectiveLinearSpace methodsFor: 'testing' stamp: 'len 9/1/2016 08:01'!
skew: aProjectiveSubspace
	"Answer true if the receiver and the argument are skew."

	^ (self  aProjectiveSubspace) isEmpty! !

!ProjectiveLinearSpace methodsFor: 'accessing' stamp: 'len 6/4/2016 01:38'!
unit
	"Answer the unit point of the receiver."

	| unit |
	1 to: self dimension + 1 do: [ :each |
		unit _ unit isNil
			ifTrue: [vectorSpace e: each]
			ifFalse: [unit + (vectorSpace e: each)]].
	^ self project: unit! !

!ProjectiveLinearSpace methodsFor: 'coordinates' stamp: 'len 6/4/2016 02:23'!
vectorFromPoint: aPoint
	^ aPoint vectorSpace generator! !

!ProjectiveLinearSpace methodsFor: 'accessing' stamp: 'len 11/22/2015 00:02'!
vectorSpace
	^ vectorSpace! !

!ProjectiveLinearSpace methodsFor: 'accessing-private' stamp: 'len 11/20/2015 22:13'!
vectorSpace: aVectorSpace
	vectorSpace _ aVectorSpace! !

!ProjectiveLinearSpace class methodsFor: 'instance creation' stamp: 'len 11/20/2015 22:04'!
on: aVectorSpace
	"Answer a new instance of the receiver representing
	the projective space P(V) over a vector space V."

	^ self new vectorSpace: aVectorSpace! !

!ProjectiveMaps methodsFor: 'accessing' stamp: 'len 8/25/2016 21:14'!
codomain
	^ vectorSpace codomain projective! !

!ProjectiveMaps methodsFor: 'accessing' stamp: 'len 8/25/2016 21:14'!
domain
	^ vectorSpace domain projective! !

!ProjectiveMaps methodsFor: 'elements' stamp: 'len 8/25/2016 21:19'!
evaluating: aBlock
	^ ProjectiveMap from: self domain to: self codomain evaluating: aBlock! !

!ProjectiveMaps methodsFor: 'elements' stamp: 'len 8/25/2016 21:20'!
identity
	^ self evaluating: [:x| x]! !

!ProjectiveMaps methodsFor: 'printing' stamp: 'len 8/25/2016 21:15'!
printOn: aStream
	"Delegate in order to print the standard notation:"
	(Morphisms from: self domain to: self codomain) printOn: aStream! !

!ProjectiveMaps methodsFor: 'as yet unclassified' stamp: 'len 8/25/2016 21:23'!
vectorFromPoint: aProjectiveMap
	^ aProjectiveMap linearMap! !

!AlgebraicSet methodsFor: 'operations' stamp: 'len 9/1/2016 07:52'!
/\ anAlgebraicSet
	"Meet."
	^ self  anAlgebraicSet! !

!AlgebraicSet methodsFor: 'comparing' stamp: 'len 12/14/2015 18:25'!
< anAlgebraicSet
	^ self ideal > anAlgebraicSet ideal! !

!AlgebraicSet methodsFor: 'comparing' stamp: 'len 12/14/2015 18:25'!
<= anAlgebraicSet
	^ self ideal >= anAlgebraicSet ideal! !

!AlgebraicSet methodsFor: 'comparing' stamp: 'len 12/14/2015 18:26'!
= anObject
	^ anObject species = self species and: [self ideal = anObject ideal]! !

!AlgebraicSet methodsFor: 'operations' stamp: 'len 12/26/2015 19:51'!
\ anAlgebraicSet
	"Answer the difference of the receiver with the argument, whose associated ideal is the ideal (colon) quotient of the respective ideals."
	^ self class on: space ideal: (ideal colon: anAlgebraicSet ideal)! !

!AlgebraicSet methodsFor: 'operations' stamp: 'len 9/1/2016 07:49'!
\/ anAlgebraicSet
	"Join."
	^ self  anAlgebraicSet! !

!AlgebraicSet methodsFor: 'operations' stamp: 'len 9/1/2016 07:52'!
 anAlgebraicSet
	^ self class on: space ideal: ideal + anAlgebraicSet ideal! !

!AlgebraicSet methodsFor: 'operations' stamp: 'len 9/1/2016 07:48'!
 anAlgebraicSet
	^ self class on: space ideal: ideal  anAlgebraicSet ideal

"alternatively:
	^ self class on: space ideal: ideal * anAlgebraicSet ideal
although the intersection is harder to compute, it behaves better with radicalization, because the intersection of two radical ideals is radical and we don't need to compute radicals again"! !

!AlgebraicSet methodsFor: 'morphisms' stamp: 'len 3/4/2016 07:56'!
apply: aPolynomialMap
	"Answer the receiver transformed by the given regular map."
	^ self notYetImplemented! !

!AlgebraicSet methodsFor: 'accessing' stamp: 'len 6/4/2016 03:36'!
coordinateRing
	"Answer the corodinate ring of the receiver, noted K[V], the ring of morphisms from V to K are polynomial functions in K[X] restricted to V. This is isomorphic to K[X] / I(V).
	Elements of the coordinate ring act as functions on the algebraic set, just as elements of the original polynomial ring act as functions on the (affine or projective) space of their variables."
	self isAffine ifFalse: [self error: 'only affine varieties have coordinate rings'].
	^ CoordinateRing on: self! !

!AlgebraicSet methodsFor: 'accessing' stamp: 'len 12/15/2015 20:43'!
degree
	^ ideal degree! !

!AlgebraicSet methodsFor: 'accessing' stamp: 'len 7/4/2016 06:32'!
dimension
	"This is the trascendence degree of the function field over the ground field."
	| indeterminates G |
	G _ ideal groebnerBasis minimal.
	indeterminates _ G indeterminates asSet copy.
	G do: [:each|
		indeterminates removeAllFoundIn: (G ordering headOf: each) indeterminates].
	^ indeterminates size! !

!AlgebraicSet methodsFor: 'accessing' stamp: 'len 6/3/2016 20:27'!
equations
	"Answer a polynomial system defining the receiver."
	| answer zero |
	answer _ PolynomialSystem new.
	zero _ self groundField zero.
	ideal generators do: [:each| answer add: (each eq: zero)].
	^ answer! !

!AlgebraicSet methodsFor: 'accessing' stamp: 'len 6/3/2016 23:24'!
functionField
	"Answer the function field (or field of rational functions) of the receiver. This is the fractions field of the coordinate ring and it's noted K(V) (analogous to the coordinate ring noted K[V])."
	^ self coordinateRing fractions! !

!AlgebraicSet methodsFor: 'accessing' stamp: 'len 12/15/2015 22:45'!
groundField
	^ space scalars! !

!AlgebraicSet methodsFor: 'comparing' stamp: 'len 12/14/2015 18:26'!
hash
	^ self ideal hash! !

!AlgebraicSet methodsFor: 'morphisms' stamp: 'len 8/25/2016 06:23'!
id
	"Answer the identity morphism. This is a polynomial mapping."
	^ self notYetImplemented! !

!AlgebraicSet methodsFor: 'accessing' stamp: 'len 11/22/2015 02:20'!
ideal
	^ ideal! !

!AlgebraicSet methodsFor: 'accessing-private' stamp: 'len 12/15/2015 22:10'!
ideal: anIdeal
	ideal _ anIdeal radical! !

!AlgebraicSet methodsFor: 'testing' stamp: 'len 9/6/2016 04:00'!
includes: aPoint
	"Answer true if the receiver includes the argument."
	| p |
	(space includes: aPoint) ifFalse: [^ false].
	p _ space coordinatesOf: aPoint.
	^ ideal generators allSatisfy: [:each | (each value: p) isZero]! !

!AlgebraicSet methodsFor: 'testing' stamp: 'len 8/30/2016 05:48'!
isAffine
	^ space isKindOf: AffineLinearSpace! !

!AlgebraicSet methodsFor: 'testing' stamp: 'len 7/4/2016 06:32'!
isEmpty
	"Answer true if the receiver is empty. 
	Ref. Algorithmic Algebra, B. Mishra, pag. 142-145."
	self flag: #fix. "should only test if the basis is {1}, and only works on an agebraically closed field"
	ideal groebnerBasis
		do: [:each | (each isConstant and: [each isZero not]) ifTrue: [^ true]].
	self space scalars isAlgebraicallyClosed ifFalse: [self error: 'the ground field is not algebraically closed'].
	^ false! !

!AlgebraicSet methodsFor: 'testing' stamp: 'len 9/26/2016 16:47'!
isFinite
	"This works for any Groebner basis, no matter the ordering."
	ideal ring indeterminates do: [:x|
		(ideal groebnerBasis anySatisfy: [:f| | d m | m _ f leadingMonomial. d _ m degree. d > 0 and: [d = (m degreeIn: x)]])
			ifFalse: [^ false]].
	^ true! !

!AlgebraicSet methodsFor: 'testing' stamp: 'len 8/27/2016 17:56'!
isIrreducible
	^ ideal isPrime "IFF. Alternatively, iif the coordinate ring is an integral domain"! !

!AlgebraicSet methodsFor: 'testing' stamp: 'len 8/30/2016 05:45'!
isProjective
	^ space isKindOf: ProjectiveLinearSpace! !

!AlgebraicSet methodsFor: 'testing' stamp: 'len 12/15/2015 20:34'!
isVariety
	^ self isIrreducible! !

!AlgebraicSet methodsFor: 'printing' stamp: 'len 4/21/2016 00:10'!
printOn: aStream
	aStream nextPutAll: 'V('.
	ideal generators do: [:each| aStream print: each] separatedBy: [aStream nextPutAll: ', '].
	aStream nextPut: $)! !

!AlgebraicSet methodsFor: 'operations' stamp: 'len 6/4/2016 00:32'!
product: anAlgebraicSet
	^ self class on: (space product: anAlgebraicSet space) ideal: (self ideal product: anAlgebraicSet ideal)! !

!AlgebraicSet methodsFor: 'morphisms' stamp: 'len 12/16/2015 22:13'!
project: anIndeterminate
	"Answer the projection of the receiver by eliminating the given indeterminate."
	^ self class ideal: (ideal eliminate: anIndeterminate)! !

!AlgebraicSet methodsFor: 'operations' stamp: 'len 6/10/2016 05:41'!
projectiveClosure
	"The projective closure of an affine variety is the projective variety corresponding to the homogenized ideal."
	self groundField isAlgebraicallyClosed ifFalse: [self error: 'the ground field is not algebraically closed']. "otherwise the variety obtained can be bigger than the actual projective closure"
	self isAffine ifFalse: [self error: 'only affine varieties can be projectivized'].
	^ self class on: space projectiveClosure ideal: ideal homogenized! !

!AlgebraicSet methodsFor: 'accessing' stamp: 'len 12/15/2015 22:07'!
space
	^ space! !

!AlgebraicSet methodsFor: 'accessing-private' stamp: 'len 12/15/2015 22:07'!
space: anAffineSpace
	space _ anAffineSpace! !

!AlgebraicSet methodsFor: 'private' stamp: 'len 3/6/2016 07:36'!
species
	^ AlgebraicSet! !

!AlgebraicSet class methodsFor: 'examples' stamp: 'len 6/1/2016 20:53'!
ellipticCurve
	"This is a projective variety, an elliptic curve in P**2."
	| C Cxyz x y z |
	C _ AlgebraicNumbers new.
	Cxyz _ C polynomialsIn: 3.
	x _ Cxyz x.
	y _ Cxyz y.
	z _ Cxyz z.
	^ self ideal: Cxyz * {(x**3) - (x * (z**2)) - (y**2 * z)}! !

!AlgebraicSet class methodsFor: 'instance creation' stamp: 'len 5/13/2016 07:33'!
equation: aPolynomialEquation
	| g |
	g _ aPolynomialEquation polynomial.
	^ self ideal: g species * g! !

!AlgebraicSet class methodsFor: 'examples' stamp: 'len 5/13/2016 07:32'!
example
	"This is an algebraic set that is not empty, it is irrededucible and cannot be written as the union of two proper algebraic subsets, thus it it an affine algebraic variety."
	| C Cxy x y |
	C _ AlgebraicNumbers new.
	Cxy _ C polynomialsIn: #(x y).
	x _ Cxy x.
	y _ Cxy y.
	^ self ideal: Cxy * {x + y - 1}! !

!AlgebraicSet class methodsFor: 'instance creation' stamp: 'len 9/26/2016 16:47'!
ideal: anIdeal
	| K n |
	K _ anIdeal ring scalars algebraicClosure.
	n _ anIdeal ring rank.
	^ anIdeal isHomogeneous
		ifTrue: [self on: (K ** n) projective ideal: anIdeal]
		ifFalse: [self on: (K ** n) asAffineSpace ideal: anIdeal]! !

!AlgebraicSet class methodsFor: 'examples' stamp: 'len 6/1/2016 20:53'!
kleinQuartic
	"This is a projective variety, a curve in P**2(C)."
	| C Cxyz x y z |
	C _ AlgebraicNumbers new.
	Cxyz _ C polynomialsIn: 3.
	x _ Cxyz x.
	y _ Cxyz y.
	z _ Cxyz z.
	^ self ideal: Cxyz * {x**3*y + (y**3*z) + (z**3*x)}! !

!AlgebraicSet class methodsFor: 'instance creation' stamp: 'len 2/3/2016 21:17'!
on: anAffineOrProjectiveSpace ideal: anIdeal
	^ self new space: anAffineOrProjectiveSpace; ideal: anIdeal! !

!AlgebraicSet class methodsFor: 'examples' stamp: 'len 4/17/2016 06:45'!
twistedCubic
	"This is the twisted cubic affine variety, parameterized by (x, x**2, x**3) in C**3."
	| C Cxyz x y z |
	C _ AlgebraicNumbers new.
	Cxyz _ C polynomialsIn: #(x y z).
	x _ Cxyz x.
	y _ Cxyz y.
	z _ Cxyz z.
	^ self ideal: Cxyz * {y - (x**2). z - (x**3)}! !

!AlgebraicSet class methodsFor: 'examples' stamp: 'len 6/1/2016 20:53'!
unitCircle
	"This is the (complex) unit circle affine algebraic variety."
	| C Cxy x y |
	C _ AlgebraicNumbers new.
	Cxy _ C polynomialsIn: 2.
	x _ Cxy x.
	y _ Cxy y.
	^ self ideal: Cxy * {x**2 + (y**2) - 1}! !

!Scheme methodsFor: 'accessing' stamp: 'len 10/4/2016 09:19'!
codimension
	^ self ambient dimension - self dimension! !

!Scheme methodsFor: 'accessing' stamp: 'len 10/4/2016 09:19'!
dimension
	^ self subclassResponsibility! !

!Scheme methodsFor: 'as yet unclassified' stamp: 'len 10/4/2016 12:13'!
divisors
	"Answer the divisors class group of the receiver."
	^ DivisorsGroup on: self! !

!Scheme methodsFor: 'as yet unclassified' stamp: 'len 10/5/2016 09:59'!
divisorsOver: aRing
	"Answer the divisors class group of the receiver."
	^ DivisorsGroup on: self over: aRing! !

!Scheme methodsFor: 'testing' stamp: 'len 8/27/2016 21:43'!
isAffine
	^ false! !

!Scheme methodsFor: 'testing' stamp: 'len 8/28/2016 02:52'!
isConnected
	"Answer true if the receiver as a topological space is connected."
	^ properties at: #isConnected! !

!Scheme methodsFor: 'testing' stamp: 'len 8/28/2016 02:51'!
isIrreducible
	"Answer true if the receiver as a topological space is irreducible."
	^ properties at: #isIrreducible! !

!Scheme methodsFor: 'testing' stamp: 'len 8/27/2016 21:43'!
isProjective
	^ false! !

!Scheme methodsFor: 'as yet unclassified' stamp: 'len 9/26/2016 06:49'!
terminalObject
	^ ZZ spec! !

!AffineScheme methodsFor: 'comparing' stamp: 'len 8/27/2016 20:47'!
< anAffineScheme
	^ self ideal > anAffineScheme ideal! !

!AffineScheme methodsFor: 'comparing' stamp: 'len 8/27/2016 20:43'!
<= anAffineScheme
	^ self ideal >= anAffineScheme ideal! !

!AffineScheme methodsFor: 'comparing' stamp: 'len 8/27/2016 20:44'!
= anObject
	^ (anObject isKindOf: AffineScheme) and: [self ideal = anObject ideal]! !

!AffineScheme methodsFor: 'operations' stamp: 'len 8/27/2016 21:26'!
\ anAffineScheme
	"Answer the difference of the receiver with the argument, whose associated ideal is the ideal (colon) quotient of the respective ideals."
	^ self species ideal: (self ideal colon: anAffineScheme ideal)! !

!AffineScheme methodsFor: 'operations' stamp: 'len 9/1/2016 07:58'!
 anAffineScheme
	"Answer the intersection of the receiver and the argument."
	^ self species ideal: self ideal + anAffineScheme ideal! !

!AffineScheme methodsFor: 'operations' stamp: 'len 9/1/2016 07:57'!
 anAffineScheme
	"Answer the union of the receiver and the argument."
	^ self species ideal: self ideal  anAffineScheme ideal! !

!AffineScheme methodsFor: 'operations' stamp: 'len 9/26/2016 13:44'!
affineSpaceIn: n
	"Answer the affine n-space over the receiver."
	^ AffineSpace new: n over: self coordinateRing
"	^ (self coordinateRing polynomialsIn: n) spec"! !

!AffineScheme methodsFor: 'accessing' stamp: 'len 9/26/2016 16:46'!
ambient
	^ AffineSpace coordinateRing: self ideal ring! !

!AffineScheme methodsFor: 'accessing' stamp: 'len 9/22/2016 07:59'!
coordinateRing
	^ self ideal quotient! !

!AffineScheme methodsFor: 'accessing' stamp: 'len 8/27/2016 21:27'!
degree
	^ self ideal degree! !

!AffineScheme methodsFor: 'accessing' stamp: 'len 8/27/2016 21:26'!
dimension
	"This is the trascendence degree of the function field over the ground field."
	| indeterminates G |
	G _ self ideal groebnerBasis minimal.
	indeterminates _ G indeterminates asSet copy.
	G do: [:each|
		indeterminates removeAllFoundIn: (G ordering headOf: each) indeterminates].
	^ indeterminates size! !

!AffineScheme methodsFor: 'accessing' stamp: 'len 8/27/2016 20:41'!
functionField
	"Answer the function field (or field of rational functions) of the receiver. This is the fractions field of the coordinate ring and it's noted K(V) (analogous to the coordinate ring noted K[V])."
	^ self coordinateRing fractions! !

!AffineScheme methodsFor: 'comparing' stamp: 'len 8/27/2016 20:44'!
hash
	^ self ideal hash! !

!AffineScheme methodsFor: 'accessing' stamp: 'len 8/27/2016 21:28'!
ideal
	^ properties at: #ideal! !

!AffineScheme methodsFor: 'accessing-private' stamp: 'len 8/27/2016 21:28'!
ideal: aPolynomialIdeal
	properties at: #ideal put: aPolynomialIdeal! !

!AffineScheme methodsFor: 'testing' stamp: 'len 8/27/2016 21:43'!
isAffine
	^ true! !

!AffineScheme methodsFor: 'printing' stamp: 'len 10/10/2016 13:54'!
printOn: aStream
	aStream nextPutAll: 'Spec '; print: self coordinateRing! !

!AffineScheme methodsFor: 'operations' stamp: 'len 8/27/2016 21:27'!
project: anIndeterminate
	"Answer the projection of the receiver by eliminating the given indeterminate."
	^ self species ideal: (self ideal eliminate: anIndeterminate)! !

!AffineScheme methodsFor: 'operations' stamp: 'len 8/30/2016 07:11'!
projectiveClosure
	"The projective closure of an affine variety is the projective variety corresponding to the homogenized ideal."
	(self scalars isField and: [self scalars isAlgebraicallyClosed])
		ifFalse: [self error: 'the ground field is not algebraically closed']. "otherwise the variety obtained can be bigger than the actual projective closure"
	^ ProjectiveScheme ideal: self ideal homogenized! !

!AffineScheme methodsFor: 'private' stamp: 'len 8/28/2016 00:13'!
species
	^ AffineScheme! !

!AffineScheme class methodsFor: 'instance creation' stamp: 'len 8/27/2016 19:22'!
ideal: anIdeal
	^ self new ideal: anIdeal! !

!AffinePlaneCurve methodsFor: 'as yet unclassified' stamp: 'len 8/29/2016 16:44'!
= anAffinePlaneCurve
	(anAffinePlaneCurve isKindOf: AffinePlaneCurve) ifFalse: [^ super = anAffinePlaneCurve].
	^ self polynomial = anAffinePlaneCurve polynomial "should be up to multiplication by a constant"! !

!AffinePlaneCurve methodsFor: 'as yet unclassified' stamp: 'len 8/29/2016 16:46'!
components
	^ self polynomial factors collect: [:each| self class polynomial: each]! !

!AffinePlaneCurve methodsFor: 'as yet unclassified' stamp: 'len 8/29/2016 16:45'!
degree
	^ self polynomial degree! !

!AffinePlaneCurve methodsFor: 'as yet unclassified' stamp: 'len 8/31/2016 08:14'!
isSingularAt: aPoint
	^ self polynomial gradient allSatisfy: [:each| (each value: aPoint) isZero]! !

!AffinePlaneCurve methodsFor: 'as yet unclassified' stamp: 'len 8/29/2016 16:42'!
polynomial
	^ self ideal generator! !

!AffinePlaneCurve methodsFor: 'as yet unclassified' stamp: 'len 10/6/2016 15:38'!
tangentAt: aPoint
	| g P |
	g _ self polynomial.
	P _ g parent.
	^ AffinePlaneCurve polynomial: (P indeterminates inject: P zero into: [:sum :i| (P x: i) - (aPoint at: i) * ((g derivativeIn: i) value: aPoint) + sum])! !

!AffinePlaneCurve class methodsFor: 'instance creation' stamp: 'len 10/6/2016 15:38'!
polynomial: aPolynomial
	^ self ideal: aPolynomial parent * aPolynomial! !

!AffineSpace methodsFor: 'accessing' stamp: 'len 8/27/2016 19:03'!
ambient
	^ self! !

!AffineSpace methodsFor: 'morphisms' stamp: 'len 8/31/2016 08:28'!
automorphisms
	"Answer the general affine group GA(A)."
	^ GeneralAffineGroup on: self! !

!AffineSpace methodsFor: 'accessing' stamp: 'len 8/27/2016 18:56'!
coordinateRing
	^ coordinateRing! !

!AffineSpace methodsFor: 'accessing-private' stamp: 'len 8/27/2016 18:56'!
coordinateRing: aPolynomialRing
	coordinateRing _ aPolynomialRing! !

!AffineSpace methodsFor: 'accessing' stamp: 'len 8/27/2016 19:46'!
dimension
	^ self coordinateRing rank! !

!AffineSpace methodsFor: 'accessing' stamp: 'len 9/26/2016 17:04'!
ideal
	"Answer the defining ideal of the receiver, considered as a subscheme of itself."
	^ self coordinateRing zeroIdeal! !

!AffineSpace methodsFor: 'accessing-private' stamp: 'len 8/27/2016 21:48'!
ideal: anIdeal
	self shouldNotImplement! !

!AffineSpace methodsFor: 'morphisms' stamp: 'len 8/31/2016 08:28'!
motions
	"Answer the Euclidean group E(A), the group of isometries, i.e. distance-preserving morphisms, also called 'motionss'. This is a subgroup of the general affine group GA(A)."
	^ EuclideanGroup on: self! !

!AffineSpace methodsFor: 'printing' stamp: 'len 8/27/2016 19:48'!
printOn: aStream
	aStream print: self scalars; nextPutAll: self dimension printString super! !

!AffineSpace methodsFor: 'operations' stamp: 'len 8/28/2016 00:13'!
projectiveClosure
	^ ProjectiveSpace new: self dimension over: self scalars! !

!AffineSpace methodsFor: 'morphisms' stamp: 'len 8/31/2016 08:28'!
rigidMotions
	"Answer the special Euclidean group SE(A), the group of direct isometries, i.e. isometries preserving orientation, also called 'rigid motions'. This is a subgroup of the Euclidean group of motions (see >>motions) which in turn is a subgroup of the general affine group GA(A)."
	^ SpecialEuclideanGroup on: self! !

!AffineSpace methodsFor: 'accessing' stamp: 'len 8/27/2016 19:47'!
scalars
	^ self coordinateRing scalars! !

!AffineSpace class methodsFor: 'instance creation' stamp: 'len 8/27/2016 19:24'!
coordinateRing: aPolynomialRing
	^ self new coordinateRing: aPolynomialRing! !

!AffineSpace class methodsFor: 'instance creation' stamp: 'len 8/27/2016 18:56'!
new: dimension over: aCommutativeRing
	^ self new coordinateRing: (aCommutativeRing polynomialsIn: dimension)! !

!Spectrum methodsFor: 'comparing' stamp: 'len 8/30/2016 06:13'!
< anObject
	^ self coordinateRing < anObject coordinateRing! !

!Spectrum methodsFor: 'comparing' stamp: 'len 8/30/2016 06:13'!
<= anObject
	^ self coordinateRing <= anObject coordinateRing! !

!Spectrum methodsFor: 'comparing' stamp: 'len 8/30/2016 06:13'!
= anObject
	^ self coordinateRing = anObject coordinateRing! !

!Spectrum methodsFor: 'accessing' stamp: 'len 8/30/2016 06:19'!
absoluteDimension
	^ self coordinateRing krullDimension! !

!Spectrum methodsFor: 'accessing' stamp: 'len 8/29/2016 18:05'!
coordinateRing
	^ coordinateRing! !

!Spectrum methodsFor: 'accessing-private' stamp: 'len 8/29/2016 18:04'!
coordinateRing: aRing
	coordinateRing _ aRing! !

!Spectrum methodsFor: 'comparing' stamp: 'len 8/30/2016 06:14'!
hash
	^ self coordinateRing hash! !

!Spectrum methodsFor: 'accessing' stamp: 'len 8/30/2016 07:04'!
ideal
	^ self coordinateRing * #() "zero ideal"! !

!Spectrum methodsFor: 'accessing-private' stamp: 'len 8/30/2016 06:12'!
ideal: anIdeal
	self shouldNotImplement! !

!Spectrum methodsFor: 'testing' stamp: 'len 9/26/2016 16:52'!
includes: anIdeal
	^ anIdeal ring = self coordinateRing and: [anIdeal isPrime]! !

!Spectrum methodsFor: 'testing' stamp: 'len 8/30/2016 06:17'!
isNoetherian
	^ self coordinateRing isNoetherian! !

!Spectrum methodsFor: 'testing' stamp: 'len 9/26/2016 06:50'!
isTerminal
	^ coordinateRing isKindOf: Integers! !

!Spectrum methodsFor: 'accessing' stamp: 'len 8/30/2016 06:19'!
relativeDimension
	^ self coordinateRing krullDimension - self baseRing krullDimension! !

!Spectrum class methodsFor: 'instance creation' stamp: 'len 8/29/2016 18:04'!
on: aRing
	^ self new coordinateRing: aRing! !

!ProjectiveScheme methodsFor: 'operations' stamp: 'len 9/1/2016 07:59'!
 aProjectiveScheme
	"Answer the intersection of the receiver and the argument."
	^ self species ideal: self ideal + aProjectiveScheme ideal! !

!ProjectiveScheme methodsFor: 'operations' stamp: 'len 9/1/2016 07:59'!
 aProjectiveScheme
	"Answer the union of the receiver and the argument."
	^ self species ideal: self ideal * aProjectiveScheme ideal! !

!ProjectiveScheme methodsFor: 'accessing' stamp: 'len 9/26/2016 16:48'!
ambient
	^ ProjectiveSpace coordinateRing: self ideal ring! !

!ProjectiveScheme methodsFor: 'accessing' stamp: 'len 9/22/2016 08:03'!
coordinateRing
	^ self ideal quotient! !

!ProjectiveScheme methodsFor: 'accessing' stamp: 'len 8/27/2016 21:44'!
ideal
	^ properties at: #ideal! !

!ProjectiveScheme methodsFor: 'accessing-private' stamp: 'len 8/27/2016 21:45'!
ideal: anHomogeneousPolynomialIdeal
	properties at: #ideal put: anHomogeneousPolynomialIdeal! !

!ProjectiveScheme methodsFor: 'testing' stamp: 'len 8/27/2016 21:44'!
isProjective
	^ true! !

!ProjectiveScheme methodsFor: 'printing' stamp: 'len 10/10/2016 13:53'!
printOn: aStream
	aStream nextPutAll: 'Proj '; print: self coordinateRing! !

!ProjectiveScheme methodsFor: 'private' stamp: 'len 8/28/2016 02:42'!
species
	^ ProjectiveScheme! !

!ProjectiveScheme class methodsFor: 'instance creation' stamp: 'len 8/27/2016 21:48'!
ideal: anHomogeneousPolynomialIdeal
	^ self new ideal: anHomogeneousPolynomialIdeal! !

!ProjectiveSpace methodsFor: 'accessing' stamp: 'len 8/27/2016 19:03'!
ambient
	^ self! !

!ProjectiveSpace methodsFor: 'accessing' stamp: 'len 8/27/2016 18:59'!
coordinateRing
	^ coordinateRing! !

!ProjectiveSpace methodsFor: 'accessing-private' stamp: 'len 8/27/2016 18:59'!
coordinateRing: aPolynomialRing
	coordinateRing _ aPolynomialRing! !

!ProjectiveSpace methodsFor: 'accessing' stamp: 'len 8/27/2016 19:47'!
dimension
	^ self coordinateRing rank - 1! !

!ProjectiveSpace methodsFor: 'accessing-private' stamp: 'len 8/27/2016 21:48'!
ideal: anIdeal
	self shouldNotImplement! !

!ProjectiveSpace methodsFor: 'printing' stamp: 'len 9/1/2016 04:21'!
printOn: aStream
	aStream print: self scalars; nextPut: Character PP; nextPutAll: self dimension printString super! !

!ProjectiveSpace methodsFor: 'accessing' stamp: 'len 8/27/2016 19:47'!
scalars
	^ self coordinateRing scalars! !

!ProjectiveSpace class methodsFor: 'instance creation' stamp: 'len 8/27/2016 19:24'!
coordinateRing: aPolynomialRing
	^ self new coordinateRing: aPolynomialRing! !

!ProjectiveSpace class methodsFor: 'instance creation' stamp: 'len 8/27/2016 19:02'!
new: dimension over: aCommutativeRing
	^ self new coordinateRing: (aCommutativeRing polynomialsIn: dimension+1)! !

!EllipticCurve methodsFor: 'operations' stamp: 'len 2/3/2016 20:28'!
discriminant
	^ (self a**3 * 4 + (self b**2 * 27)) * (-16)! !

!EllipticCurve methodsFor: 'testing' stamp: 'len 11/3/2015 01:19'!
isSingular
	^ self discriminant == 0! !

!EllipticCurve class methodsFor: 'instance creation' stamp: 'len 8/24/2016 03:20'!
over: aField a: a b: b
	"Answer the curve y^2 = x^3 + ax + b homogenized."
	| P x y z ideal |
	P _ aField polynomialsIn: #(x y z).
	x _ P x. y _ P y. z _ P z.
	ideal _ P * (x**3 + (x * (z**2) * a) + (z**3*b) - (y**2*z)).
	^ self ideal: ideal! !

!SemialgebraicSet methodsFor: 'operations' stamp: 'len 9/1/2016 07:54'!
/\ aSemialgebraicSet
	"Meet."
	^ self  aSemialgebraicSet! !

!SemialgebraicSet methodsFor: 'comparing' stamp: 'len 6/2/2016 05:23'!
= aSemialgebraicSet
	self == aSemialgebraicSet ifTrue: [^ true].
	(aSemialgebraicSet isKindOf: SemialgebraicSet) ifFalse: [^ false].
	self cells do: [ :each | (aSemialgebraicSet cells includes: each) ifFalse: [^ false]].
	aSemialgebraicSet cells do: [ :each | (self cells includes: each) ifFalse: [^ false]].
	^ true! !

!SemialgebraicSet methodsFor: 'operations' stamp: 'len 6/2/2016 08:11'!
\ aSemialgebraicSet
	"Answer the difference of the receiver with the argument,"
	^ self copyWithoutAll: aSemialgebraicSet cells! !

!SemialgebraicSet methodsFor: 'operations' stamp: 'len 9/1/2016 07:51'!
\/ aSemialgebraicSet
	"Join."
	^ self  aSemialgebraicSet! !

!SemialgebraicSet methodsFor: 'operations' stamp: 'len 9/1/2016 07:54'!
 aSemialgebraicSet
	self flag: #fix. "this is wrong"
	^ self class cells: self cells  aSemialgebraicSet cells! !

!SemialgebraicSet methodsFor: 'operations' stamp: 'len 9/1/2016 07:56'!
 aSemialgebraicSet
	^ self class cells: self cells  aSemialgebraicSet cells! !

!SemialgebraicSet methodsFor: 'accessing' stamp: 'len 1/9/98 21:34'!
add: aCell
	"Add the argument to the cells of the receiver. Answer the argument."

	^ self cells add: aCell! !

!SemialgebraicSet methodsFor: 'accessing' stamp: 'len 12/14/97 21:48'!
addAll: aCollection
	"Add the elements in the argument to the cells of the receiver. Answer the argument."

	aCollection do: [ :each | self add: each].
	^ aCollection! !

!SemialgebraicSet methodsFor: 'operations' stamp: 'len 6/2/2016 08:13'!
boundary
	| answer |
	answer _ self class new.
	self cells do: [:each| answer addAll: each boundary cells].
	^ answer! !

!SemialgebraicSet methodsFor: 'accessing' stamp: 'len 6/2/2016 04:48'!
boundingBox
	"Answer a tight bounding box of the receiver, assuming it's bounded."
	^ self notYetImplemented! !

!SemialgebraicSet methodsFor: 'accessing' stamp: 'len 5/30/2016 08:48'!
cells
	^ cells! !

!SemialgebraicSet methodsFor: 'accessing-private' stamp: 'len 12/14/97 21:46'!
cells: aCollection
	cells _ aCollection! !

!SemialgebraicSet methodsFor: 'operations' stamp: 'len 6/2/2016 08:12'!
closure
	| answer |
	answer _ self class new.
	self cells do: [ :each | answer addAll: each closure cells].
	^ answer! !

!SemialgebraicSet methodsFor: 'iterating' stamp: 'len 2/6/98 12:37'!
collect: aBlock 
	"Evaluate aBlock with each of the receiver's elements as the argument. 
	Collect the resulting values into a collection like the receiver. Answer 
	the new collection."

	| newCollection |
	newCollection _ self species new.
	self do: [:each | newCollection add: (aBlock value: each)].
	^newCollection! !

!SemialgebraicSet methodsFor: 'operations' stamp: 'len 2/2/2016 22:26'!
complement
	^ self notYetImplemented! !

!SemialgebraicSet methodsFor: 'accessing' stamp: 'len 8/26/2016 06:55'!
connectivityGraph
	"Answer the connectivity graph of the cell complex of the receiver."
	| answer |
	answer _ Graph unordered.
	self cells do: [:v|
		| vBar |
		vBar _ v closure.
		self cells do: [:u|
			(vBar cells includes: u) ifTrue: [answer addEdgeFrom: u to: v]]].
	^ answer! !

!SemialgebraicSet methodsFor: 'testing' stamp: 'len 6/2/2016 05:18'!
connects: aTuple with: anotherTuple
	"Answer true if there exists a path in the receiver connecting the two points."

	| a b |
	a _ self cells detect: [:one| one includes: aTuple] ifNone: [^ false].
	b _ self cells detect: [:one| one includes: anotherTuple] ifNone: [^ false].
	self flag: #fix. "inefficient"
	self connectivityGraph componentsDo: [:each|
		(each includes: a)
			ifTrue: [^ each includes: b]
			ifFalse: [(each includes: b) ifTrue: [^ false]]].
	^ false! !

!SemialgebraicSet methodsFor: 'copying' stamp: 'len 6/2/2016 05:20'!
copy
	^ self class cells: self cells copy! !

!SemialgebraicSet methodsFor: 'copying' stamp: 'len 6/2/2016 05:20'!
copyWithoutAll: aCollection
	"Answer a copy of the receiver without all the cells in aCollection."

	^ self class cells: (self cells select: [:each| (aCollection includes: each) not])! !

!SemialgebraicSet methodsFor: 'accessing' stamp: 'len 6/2/2016 05:03'!
cylinderAt: aCell
	"Answer the subset of the receiver cylindrical over aCell."

	^ self class cells: (self cells select: [:each| each isCylindricalOver: aCell])! !

!SemialgebraicSet methodsFor: 'iterating' stamp: 'len 1/10/98 00:24'!
detect: aBlock ifNone: exceptionBlock 
	"Evaluate aBlock with each of the receiver's elements as the argument. 
	Answer the first element for which aBlock evaluates to true. If none 
	evaluate to true, then evaluate the argument, exceptionBlock."

	self do: [:each | (aBlock value: each) ifTrue: [^ each]].
	^ exceptionBlock value! !

!SemialgebraicSet methodsFor: 'accessing' stamp: 'len 6/2/2016 04:42'!
dimension
	"Answer the topological dimension of the receiver."
	self isEmpty ifTrue: [^ -1].
	^ self cells max: [:each| each dimension]! !

!SemialgebraicSet methodsFor: 'iterating' stamp: 'len 8/26/2016 06:54'!
do: aBlock
	self cells do: aBlock! !

!SemialgebraicSet methodsFor: 'comparing' stamp: 'len 6/28/2016 09:36'!
hash
	^ self cells inject: self class hash into: [:answer :each| answer + each hash]! !

!SemialgebraicSet methodsFor: 'testing' stamp: 'len 6/2/2016 05:19'!
includes: anObject
	(anObject is: #Tuple)
		ifTrue: [^ self cells anySatisfy: [:any| any includes: anObject]].
	^ false! !

!SemialgebraicSet methodsFor: 'operations' stamp: 'len 6/2/2016 08:13'!
interior
	^ self closure \ self boundary! !

!SemialgebraicSet methodsFor: 'testing' stamp: 'len 6/2/2016 04:07'!
isBounded
	^ self cells allSatisfy: [:each| each isBounded]! !

!SemialgebraicSet methodsFor: 'testing' stamp: 'len 6/2/2016 04:43'!
isClosed
	^ self cells allSatisfy: [:each| each isClosed]! !

!SemialgebraicSet methodsFor: 'testing' stamp: 'len 6/2/2016 04:49'!
isConnected
	^ self connectivityGraph isConnected! !

!SemialgebraicSet methodsFor: 'testing' stamp: 'len 2/6/98 12:35'!
isEmpty
	"Answer true if the receiver is empty."

	^ self cells isEmpty! !

!SemialgebraicSet methodsFor: 'testing' stamp: 'len 6/2/2016 04:48'!
isFinite
	^ self cells allSatisfy: [:each| each isFinite]! !

!SemialgebraicSet methodsFor: 'testing' stamp: 'len 6/2/2016 04:43'!
isOpen
	^ self cells allSatisfy: [:each| each isOpen]! !

!SemialgebraicSet methodsFor: 'accessing' stamp: 'len 6/2/2016 04:01'!
polynomials
	^ self cells inject: Set new into: [:answer :each| answer addAll: each polynomials; yourself]! !

!SemialgebraicSet methodsFor: 'printing' stamp: 'len 6/2/2016 05:18'!
printOn: aStream
	"aStream nextPut: ${; print: self sentence; nextPut: $}"	
	self isEmpty ifTrue: [aStream nextPut: Character emptySet].
	self cells do: [:each| aStream print: each] separatedBy: [aStream nextPutAll: ' U ' bold]! !

!SemialgebraicSet methodsFor: 'accessing' stamp: 'len 6/1/2016 22:58'!
projectionAt: anInteger
	"Answer the first anInteger components of the receiver."
	| answer |
	answer _ self class new.
	self cells do: [:each| answer addAll: (each projectionAt: anInteger)].
	^ answer! !

!SemialgebraicSet methodsFor: 'accessing' stamp: 'len 6/2/2016 04:25'!
rank
	^ self cells anyOne rank! !

!SemialgebraicSet methodsFor: 'accessing' stamp: 'len 6/2/2016 04:41'!
sample
	"Answer a sample point in the receiver."

	^ self cells anyOne sample! !

!SemialgebraicSet methodsFor: 'iterating' stamp: 'len 1/16/98 22:08'!
select: aBlock 
	"Evaluate aBlock with each of the receiver's elements as the argument. 
	Collect into a new collection like the receiver, only those elements for 
	which aBlock evaluates to true. Answer the new collection."

	| newCollection |
	newCollection _ self species new.
	self do: [:each | (aBlock value: each) ifTrue: [newCollection add: each]].
	^newCollection! !

!SemialgebraicSet methodsFor: 'accessing' stamp: 'len 7/15/2016 18:38'!
sentence
	"Answer a quantifier-free defining sentence for the receiver."

	self isEmpty ifTrue: [^ QQ polynomials x squared lneq: 0].
	^ self cells collect: [:each| each sentence] andFold: [:a :b| a | b]! !

!SemialgebraicSet class methodsFor: 'examples' stamp: 'len 7/15/2016 18:38'!
ball
	"Answer the open unitary ball in R^3."
	"SemialgebraicSet ball."
	| Qxyz x y z |
	Qxyz _ QQ polynomialsIn: #(x y z).
	x _ Qxyz x.
	y _ Qxyz y.
	z _ Qxyz z.
	^ self cad: {x squared + y squared + z squared - 1}
		:: select: [ :each | each sample norm2 < 1]! !

!SemialgebraicSet class methodsFor: 'instance creation' stamp: 'len 5/30/2016 08:44'!
cad: aPolynomialSet
	"Answer the CAD (Cylindrical Algebraic Decomposition) of R^n by the polynomials in aPolynomialSet."

	^ self cells: (CylindricalAlgebraicDecomposition polynomials: aPolynomialSet) components! !

!SemialgebraicSet class methodsFor: 'instance creation' stamp: 'len 5/30/2016 08:46'!
cells: aCollection
	^ super new cells: aCollection! !

!SemialgebraicSet class methodsFor: 'examples' stamp: 'len 7/15/2016 18:38'!
circle
	"Answer the open unitary circle in R^2."
	"SemialgebraicSet circle."
	| Qxy x y |
	Qxy _ QQ polynomialsIn: #(x y).
	x _ Qxy x.
	y _ Qxy y.
	^ self cad: {x squared + y squared - 1}
		:: select: [ :each | each sample norm2 < 1]! !

!SemialgebraicSet class methodsFor: 'examples' stamp: 'len 7/15/2016 18:38'!
circunference
	"Answer the open unitary circunference in R^2."
	"SemialgebraicSet circunference."
	| Qxy x y |
	Qxy _ QQ polynomialsIn: #(x y).
	x _ Qxy x.
	y _ Qxy y.
	^ self cad: {x squared + y squared - 1}
		:: select: [ :each | each sample norm2 = 1]! !

!SemialgebraicSet class methodsFor: 'examples' stamp: 'len 7/15/2016 18:38'!
closedCircle
	"Answer the closed unitary circle in R^2."
	| Qxy x y |
	Qxy _ QQ polynomialsIn: #(x y).
	x _ Qxy x.
	y _ Qxy y.
	^ self cad: {x squared + y squared - 1}
		:: select: [ :each | each sample norm2 <= 1]! !

!SemialgebraicSet class methodsFor: 'instance creation' stamp: 'len 5/30/2016 08:46'!
new
	^ self cells: Set new! !

!SemialgebraicSet class methodsFor: 'examples' stamp: 'len 7/15/2016 18:38'!
sphere
	"Answer the open unitary sphere in R^3."
	"SemialgebraicSet sphere."
	| Qxyz x y z |
	Qxyz _ QQ polynomialsIn: #(x y z).
	x _ Qxyz x.
	y _ Qxyz y.
	z _ Qxyz z.
	^ self cad: {x squared + y squared + z squared - 1}
		:: select: [ :each | each sample norm2 = 1]! !

!Polytope methodsFor: 'arithmetic' stamp: 'len 4/17/2016 03:29'!
* aPolytope
	^ self notYetImplemented! !

!Polytope methodsFor: 'arithmetic' stamp: 'len 4/17/2016 03:32'!
+ aPolytope
	"Answer the Minkowski sum of the receiver and the argument."
	
	| newPoints |
	newPoints _ OrderedCollection new: self points size * aPolytope points size.
	self points do: [:p|
		aPolytope points do: [:q|
			newPoints add: p+q]].
	^ self class points: newPoints! !

!Polytope methodsFor: 'arithmetic' stamp: 'len 9/1/2016 08:06'!
 aPolytope
	^ self notYetImplemented! !

!Polytope methodsFor: 'as yet unclassified' stamp: 'len 4/17/2016 04:40'!
boundary
	^ self notYetImplemented! !

!Polytope methodsFor: 'as yet unclassified' stamp: 'len 4/17/2016 04:40'!
interior
	^ self notYetImplemented! !

!Polytope methodsFor: 'accessing' stamp: 'len 4/17/2016 03:27'!
points
	^ points! !

!Polytope methodsFor: 'accessing' stamp: 'len 4/17/2016 03:27'!
points: aCollection
	points _ aCollection! !

!Polytope methodsFor: 'as yet unclassified' stamp: 'len 4/17/2016 04:40'!
relativeInterior
	^ self notYetImplemented! !

!Polytope methodsFor: 'accessing' stamp: 'len 4/17/2016 03:53'!
space
	^ space! !

!Polytope methodsFor: 'accessing' stamp: 'len 4/17/2016 03:54'!
space: aVectorSpace
	space _ aVectorSpace! !

!Polytope class methodsFor: 'instance creation' stamp: 'len 4/17/2016 03:36'!
points: aCollection
	^ self new points: aCollection! !

!Polygon methodsFor: 'accessing' stamp: 'len 1/12/2016 19:28'!
area
	^ self notYetImplemented! !

!Polygon methodsFor: 'testing' stamp: 'len 1/12/2016 19:30'!
boundaryIncludes: aPoint
	^ self edges anySatisfy: [:any| any includes: aPoint]! !

!Polygon methodsFor: 'accessing' stamp: 'len 1/12/2016 19:27'!
edges
	^ (1 to: vertices size)
		collect:
			[:i| (LineSegment from: (vertices at: i) to: (vertices at: i \\ vertices size + 1))]! !

!Polygon methodsFor: 'testing' stamp: 'len 1/12/2016 19:29'!
includes: aPoint
	^ self notYetImplemented! !

!Polygon methodsFor: 'testing' stamp: 'len 1/12/2016 19:31'!
isConvex
	^ self notYetImplemented! !

!Polygon methodsFor: 'testing' stamp: 'len 1/12/2016 20:10'!
isSimple
	^ self notYetImplemented! !

!Polygon methodsFor: 'accessing' stamp: 'len 1/12/2016 19:28'!
perimeter
	vertices isEmpty ifTrue: [^ 0].
	^ self edges sum: [:each| each length]! !

!Polygon methodsFor: 'printing' stamp: 'len 1/12/2016 19:43'!
printOn: aStream
	aStream nextPut: $[.
	vertices do: [:each| aStream print: each] separatedBy: [aStream nextPutAll: ', '].
	aStream nextPut: $]! !

!Polygon methodsFor: 'accessing' stamp: 'len 1/12/2016 19:23'!
vertices
	^ vertices! !

!Polygon methodsFor: 'accessing-private' stamp: 'len 1/12/2016 19:22'!
vertices: aCollection
	vertices _ aCollection! !

!Polygon class methodsFor: 'instance creation' stamp: 'len 3/23/2016 21:26'!
vertices: aCollection
	^ self new vertices: aCollection! !

!LineSegment methodsFor: 'accessing' stamp: 'len 2/27/2016 08:07'!
direction
	^ vertices first - vertices second! !

!LineSegment methodsFor: 'testing' stamp: 'len 1/12/2016 19:39'!
includes: aPoint
	^ self notYetImplemented! !

!LineSegment methodsFor: 'accessing' stamp: 'len 1/12/2016 19:20'!
length
	^ self direction norm! !

!LineSegment methodsFor: 'accessing' stamp: 'len 2/27/2016 08:08'!
midpoint
	^ vertices sum / 2! !

!LineSegment class methodsFor: 'instance creation' stamp: 'len 3/23/2016 21:24'!
from: aPoint to: anotherPoint
	^ self new vertices: {aPoint. anotherPoint}! !

!DirectedLineSegment methodsFor: 'as yet unclassified' stamp: 'len 1/12/2016 19:35'!
= aLineSegment
	aLineSegment class = self class ifFalse: [^ false].
	^ self p1 = aLineSegment p1 and: [self p2 = aLineSegment p2]! !

!Quadrangle methodsFor: 'as yet unclassified' stamp: 'len 1/12/2016 19:59'!
bimedians
	^ self notYetImplemented! !

!Quadrangle methodsFor: 'as yet unclassified' stamp: 'len 1/12/2016 19:59'!
maltitudes
	^ self notYetImplemented! !

!Triangle methodsFor: 'as yet unclassified' stamp: 'len 1/12/2016 19:57'!
altitudes
	^ self notYetImplemented! !

!Triangle methodsFor: 'as yet unclassified' stamp: 'len 1/12/2016 20:00'!
centroid
	^ self notYetImplemented! !

!Triangle methodsFor: 'as yet unclassified' stamp: 'len 1/12/2016 20:00'!
circumcenter
	^ self notYetImplemented! !

!Triangle methodsFor: 'as yet unclassified' stamp: 'len 1/12/2016 20:00'!
incenter
	^ self notYetImplemented! !

!Triangle methodsFor: 'as yet unclassified' stamp: 'len 1/12/2016 19:57'!
internalAngleBisectors
	^ self notYetImplemented! !

!Triangle methodsFor: 'as yet unclassified' stamp: 'len 1/12/2016 19:56'!
medians
	| edges |
	edges _ self edges.
	^ OrderedCollection new
		add: (LineSegment from: (edges at: 1) midpoint to: (vertices at: 3));
		add: (LineSegment from: (edges at: 2) midpoint to: (vertices at: 1));
		add: (LineSegment from: (edges at: 3) midpoint to: (vertices at: 2));
		yourself
	! !

!Triangle methodsFor: 'as yet unclassified' stamp: 'len 1/12/2016 20:00'!
ninePointCenter
	^ self notYetImplemented! !

!Triangle methodsFor: 'as yet unclassified' stamp: 'len 1/12/2016 20:00'!
orthocenter
	^ self notYetImplemented! !

!Triangle methodsFor: 'as yet unclassified' stamp: 'len 1/12/2016 19:57'!
perpendicularBisectors
	^ self notYetImplemented! !

!SemistandardTableaux methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 02:31'!
alphabet
	^ alphabet! !

!SemistandardTableaux methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 02:32'!
alphabet: anArray
	alphabet _ anArray! !

!SemistandardTableaux methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 03:25'!
diagram
	^ YoungDiagram shape: shape! !

!SemistandardTableaux methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 03:29'!
shape
	^ shape! !

!SemistandardTableaux methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 03:29'!
shape: aPartition
	shape _ aPartition! !

!SemistandardTableaux class methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 03:28'!
alphabet: anArray shape: aPartition
	^ self new alphabet: anArray; shape: aPartition! !

!SemistandardTableaux class methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 03:28'!
new: anInteger shape: aPartition
	^ self alphabet: (1 to: anInteger) shape: aPartition! !

!StandardTableaux methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 03:24'!
size
	| answer Y |
	answer _ alphabet size factorial.
	Y _ self diagram.
	Y do: [:each|
		answer _ answer / (Y hookLengthAt: each)].
	^ answer
! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 2/29/2016 08:26'!
/ aFace
	"Answer the link of the face aFace."
	^ self notYetImplemented! !

!SimplicialComplex methodsFor: 'homology' stamp: 'len 8/5/2016 19:28'!
boundaries: i
	^ (self boundaryMap: i) kernel! !

!SimplicialComplex methodsFor: 'homology' stamp: 'len 10/4/2016 12:29'!
boundaryMap: i
	^ (self chains: i) to: (self chains: i-1) evaluating: [:x| x boundary]! !

!SimplicialComplex methodsFor: 'subobjects' stamp: 'len 6/13/2016 01:09'!
cells
	^ self faces: self dimension! !

!SimplicialComplex methodsFor: 'homology' stamp: 'len 6/12/2016 06:10'!
chains: p
	"Answer the p-chain group."
	^ FreeAbelianGroup on: (self faces: p) asArray! !

!SimplicialComplex methodsFor: 'homology' stamp: 'len 6/12/2016 06:12'!
chains: p over: anAbelianGroup
	"Answer the p-chain group."
	(anAbelianGroup isKindOf: Integers)
		ifTrue: [^ self chains: p].
	anAbelianGroup isField
		ifTrue: [^ VectorSpace on: (self faces: p) asArray over: anAbelianGroup].
	anAbelianGroup isRing
		ifTrue: [^ FreeModule on: (self faces: p) asArray over: anAbelianGroup].
	DomainError signal! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 6/13/2016 09:43'!
closedStarOf: aCollection
	^ self closureOf: (self starOf: aCollection)! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 6/11/2016 23:53'!
closureOf: aCollection
	| simplices |
	simplices _ self elements copyAs: Set.
	self elements do: [:each|
		simplices addAll: each closure].
	^ self class newFrom: simplices! !

!SimplicialComplex methodsFor: 'homology' stamp: 'len 8/5/2016 19:26'!
coboundaries: i
	^ (self coboundaryMap: i-1) image! !

!SimplicialComplex methodsFor: 'homology' stamp: 'len 10/4/2016 12:29'!
coboundaryMap: i
	^ (self cochains: i) to: (self cochains: i+1) evaluating: [:x| x boundary]! !

!SimplicialComplex methodsFor: 'homology' stamp: 'len 6/12/2016 06:14'!
cochains: p
	"Answer the p-cochain group."
	^ (self chains: p) dual! !

!SimplicialComplex methodsFor: 'homology' stamp: 'len 6/12/2016 06:13'!
cochains: p over: anAbelianGroup
	"Answer the p-cochain group."
	^ (self chains: p over: anAbelianGroup) dual! !

!SimplicialComplex methodsFor: 'homology' stamp: 'len 8/5/2016 19:27'!
cocycles: i
	^ (self coboundaryMap: i) kernel! !

!SimplicialComplex methodsFor: 'homology' stamp: 'len 8/5/2016 19:28'!
cohomology: i
	^ (self cocycles: i) / (self coboundaries: i)! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 2/29/2016 08:25'!
coskeleton: n
	"Answer the n-coskeleton of the receiver."
	^ self notYetImplemented! !

!SimplicialComplex methodsFor: 'homology' stamp: 'len 8/5/2016 19:16'!
cycles: i
	^ (self boundaryMap: i-1) image! !

!SimplicialComplex methodsFor: 'invariants' stamp: 'len 6/11/2016 22:52'!
dimension
	^ self elements max: [:each| each dimension]! !

!SimplicialComplex methodsFor: 'subobjects' stamp: 'len 4/21/2016 04:37'!
edges
	^ self faces: 1! !

!SimplicialComplex methodsFor: 'private' stamp: 'len 6/11/2016 22:53'!
elements: aCollection
	super elements: (aCollection collect: [:each| (each isKindOf: Simplex) ifTrue: [each] ifFalse: [each as: Simplex]])! !

!SimplicialComplex methodsFor: 'invariants' stamp: 'len 6/11/2016 22:52'!
euler
	"Answer the Euler characteristic of the receiver."
	^ (0 to: self dimension) sum: [:p| self elements count: [:each| each dimension = p]]! !

!SimplicialComplex methodsFor: 'subobjects' stamp: 'len 6/27/2016 23:25'!
faces: m
	^ Set2 accumulate: [:aBlock| self faces: m do: aBlock]! !

!SimplicialComplex methodsFor: 'subobjects' stamp: 'len 6/11/2016 22:45'!
faces: m do: aBlock
	"Iterate over the m-faces of the receiver."
	self do: [:each| each faces: m do: aBlock]! !

!SimplicialComplex methodsFor: 'subobjects' stamp: 'len 4/21/2016 04:37'!
facets
	^ self faces: self dimension - 1! !

!SimplicialComplex methodsFor: 'homology' stamp: 'len 8/5/2016 19:28'!
homology: i
	^ (self cycles: i) / (self boundaries: i)! !

!SimplicialComplex methodsFor: 'testing' stamp: 'len 6/13/2016 16:29'!
isConnected
	^ (self skeleton: 1) asGraph isConnected! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 6/12/2016 08:43'!
linkOf: aFace
	"Answer the link of the face aFac, the complex of all faces of simplices in the star that do not intersect aFace."
	^ self notYetImplemented! !

!SimplicialComplex methodsFor: 'printing' stamp: 'len 4/23/2016 05:34'!
printOn: aStream
	aStream print: self dimension; nextPutAll: '-complex '.
	self shortPrintOn: aStream! !

!SimplicialComplex methodsFor: 'subobjects' stamp: 'len 4/21/2016 04:38'!
ridges
	^ self faces: self dimension - 2! !

!SimplicialComplex methodsFor: 'printing' stamp: 'len 6/11/2016 23:13'!
shortPrintOn: aStream
	aStream nextPut: ${.
	self elements do: [:each| each shortPrintOn: aStream] separatedBy: [aStream nextPut: $,].
	aStream nextPut: $}
	! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 6/11/2016 23:54'!
skeleton: n
	"Answer the n-skeleton of the receiver."
	^ self class newFrom: (self elements collect: [:each| each dimension <= n])! !

!SimplicialComplex methodsFor: 'operations' stamp: 'len 6/11/2016 23:30'!
starOf: aCollection
	| simplices |
	simplices _ Set new.
	aCollection do: [:each|
		self do: [:other| (each intersects: other) ifTrue: [simplices add: other]]].
	^ self newFrom: simplices! !

!SimplicialComplex methodsFor: 'subobjects' stamp: 'len 4/21/2016 04:37'!
vertices
	^ self faces: 0! !

!SimplicialComplex class methodsFor: 'examples' stamp: 'len 4/21/2016 03:58'!
cylinder
	^ self notYetImplemented! !

!SimplicialComplex class methodsFor: 'examples' stamp: 'len 4/21/2016 03:57'!
kleinBottle
	^ self notYetImplemented! !

!SimplicialComplex class methodsFor: 'examples' stamp: 'len 4/21/2016 03:58'!
moebiusStrip
	^ self notYetImplemented! !

!SimplicialComplex class methodsFor: 'examples' stamp: 'len 4/21/2016 04:06'!
sphere: n
	^ self notYetImplemented! !

!SimplicialComplex class methodsFor: 'examples' stamp: 'len 4/21/2016 03:57'!
torus
	^ self notYetImplemented! !

!CoxeterSystem methodsFor: 'as yet unclassified' stamp: 'len 5/25/2016 03:46'!
computeDiagram
	| n graph |
	n _ matrix numberOfColumns.
	graph _ Graph unorderedLabeled.
	graph addAll: (1 to: n).
	1 to: n do: [:i|
		1 to: n do: [:j|
			| m |
			m _ matrix at: i@j.
			m = 3 ifTrue: [graph addEdgeFrom: i to: j label: nil].
			m > 3 ifTrue: [graph addEdgeFrom: i to: j label: m]]].
	^ graph! !

!CoxeterSystem methodsFor: 'as yet unclassified' stamp: 'len 4/18/2016 07:54'!
diagram
	^ diagram ifNil: [diagram _ self computeDiagram]! !

!CoxeterSystem methodsFor: 'as yet unclassified' stamp: 'len 4/18/2016 07:57'!
diagram: aGraph
	diagram _ aGraph! !

!CoxeterSystem methodsFor: 'as yet unclassified' stamp: 'len 4/18/2016 07:55'!
matrix
	^ matrix ifNil: [matrix _ self computeMatrix]! !

!CoxeterSystem methodsFor: 'as yet unclassified' stamp: 'len 4/18/2016 07:57'!
matrix: aMatrix
	matrix _ aMatrix! !

!CoxeterSystem methodsFor: 'as yet unclassified' stamp: 'len 7/20/2016 23:50'!
presentation
	| generators relators |
	generators _ self diagram values collect: [:each| Word x: each].
	relators _ OrderedCollection new.
	self diagram edgesAndLabelsDo: [:each :label|
		label isInfinity
			ifFalse: [relators add: (Word x: each key) * (Word x: each value) ** (label ifNil: [3])]].
	^ GroupPresentation generators: generators relators: relators! !

!CoxeterSystem methodsFor: 'as yet unclassified' stamp: 'len 4/18/2016 03:17'!
reflections
	"Answer the conjugates of the generators."
	^ self notYetImplemented! !

!CoxeterSystem methodsFor: 'as yet unclassified' stamp: 'len 4/18/2016 08:02'!
schlafliMatrix
	^ self matrix collect: [:x| -2 * (Float pi / x) cos]! !

!CoxeterSystem methodsFor: 'as yet unclassified' stamp: 'len 4/18/2016 03:28'!
simpleReflections
	^ generators! !

!Presheaf methodsFor: 'as yet unclassified' stamp: 'len 10/3/2016 10:06'!
globalSections
	^ self sectionsOver: self space! !

!Presheaf methodsFor: 'as yet unclassified' stamp: 'len 10/3/2016 10:10'!
restrictionMapFrom: V to: U
	^ self subclassResponsibility! !

!Presheaf methodsFor: 'as yet unclassified' stamp: 'len 10/3/2016 10:07'!
sectionsOver: U
	"Answer the abelian group corresponding to the given open set."
	^ self subclassResponsibility! !

!TopologicalSpace methodsFor: 'as yet unclassified' stamp: 'len 10/3/2016 10:21'!
base
	^ self subclassResponsibility! !

!TopologicalSpace methodsFor: 'as yet unclassified' stamp: 'len 10/3/2016 10:08'!
isOpen: aSubset
	^ self subclassResponsibility! !

!Morphism methodsFor: 'operations' stamp: 'len 10/10/2016 15:12'!
@ aMorphism
	"Answer the composition of the receiver with the argument."
	^ self subclassResponsibility! !

!Morphism methodsFor: 'operations' stamp: 'len 10/5/2016 10:05'!
@@ anInteger
	"Answer the receiver composed with itself anInteger times."
	anInteger = 1 ifTrue: [^ self].
	anInteger = 0 ifTrue: [^ self identity].
	anInteger > 1
		ifTrue: [^ (self @ self @@ (anInteger // 2))
				@ (self @@ (anInteger \\ 2))].
	^ (self @@ anInteger negated) inverse! !

!Morphism methodsFor: 'operations' stamp: 'len 9/21/2016 16:55'!
 aMorphism
	^ self subclassResponsibility! !

!Morphism methodsFor: 'operations' stamp: 'len 10/5/2016 11:09'!
 anInteger
	"Answer the receiver composed with itself anInteger times."
	anInteger = 1 ifTrue: [^ self].
	anInteger = 0 ifTrue: [^ self identity].
	anInteger > 1
		ifTrue: [^ (self  self  (anInteger // 2))
				 (self  (anInteger \\ 2))].
	^ (self  anInteger negated) inverse! !

!Morphism methodsFor: 'printing' stamp: 'len 8/8/2016 05:52'!
arrowPrintOn: aStream
	aStream print: self domain; nextPut: $; print: self codomain! !

!Morphism methodsFor: 'printing' stamp: 'len 8/8/2016 05:52'!
arrowPrintString
	| limit limitedString |
	limit _ 100.
	limitedString _ String streamContents: [:s | self arrowPrintOn: s] limitedTo: limit.
	limitedString size < limit ifTrue: [^ limitedString].
	^ limitedString , '...etc...'! !

!Morphism methodsFor: 'accessing' stamp: 'len 8/8/2016 05:53'!
codomain
	^ properties at: #codomain! !

!Morphism methodsFor: 'accessing-private' stamp: 'len 8/8/2016 06:44'!
codomain: aDomain
	properties at: #codomain put: aDomain! !

!Morphism methodsFor: 'accessing' stamp: 'len 8/8/2016 06:42'!
coimage
	^ self domain / self kernel! !

!Morphism methodsFor: 'accessing' stamp: 'len 8/8/2016 06:42'!
cokernel
	^ self codomain / self image! !

!Morphism methodsFor: 'accessing' stamp: 'len 8/8/2016 05:53'!
domain
	^ properties at: #domain! !

!Morphism methodsFor: 'accessing-private' stamp: 'len 8/8/2016 06:44'!
domain: aDomain
	properties at: #domain put: aDomain! !

!Morphism methodsFor: 'testing' stamp: 'len 8/8/2016 06:01'!
hasLeftInverse
	^ self leftInverse notNil! !

!Morphism methodsFor: 'testing' stamp: 'len 8/8/2016 06:01'!
hasRightInverse
	^ self rightInverse notNil! !

!Morphism methodsFor: 'accessing' stamp: 'len 10/5/2016 11:11'!
identity
	^ self domain id! !

!Morphism methodsFor: 'accessing' stamp: 'len 8/8/2016 06:42'!
image
	^ properties at: #image ifAbsent: [self domain apply: self]! !

!Morphism methodsFor: 'initialization' stamp: 'len 8/8/2016 05:54'!
initialize
	properties _ IdentityDictionary new! !

!Morphism methodsFor: 'operations' stamp: 'len 8/8/2016 05:46'!
inverse
	self isEndomorphism ifFalse: [self error: 'ambiguous inverse'].
	^ self leftInverse! !

!Morphism methodsFor: 'testing' stamp: 'len 8/8/2016 06:02'!
isAutomorphism
	^ self isEndomorphism and: [self isIsomorphism]! !

!Morphism methodsFor: 'testing' stamp: 'len 8/8/2016 06:02'!
isBimorphism
	^ self isIsomorphism! !

!Morphism methodsFor: 'testing' stamp: 'len 8/8/2016 06:02'!
isEndomorphism
	^ self domain = self codomain! !

!Morphism methodsFor: 'testing' stamp: 'len 8/8/2016 06:38'!
isIdentity
	^ false! !

!Morphism methodsFor: 'testing' stamp: 'len 8/8/2016 06:02'!
isInvertible
	^ self inverse notNil! !

!Morphism methodsFor: 'testing' stamp: 'len 8/8/2016 06:38'!
isIsomorphism
	^ self isEpimorphism and: [self isMonomorphism]! !

!Morphism methodsFor: 'testing' stamp: 'len 8/8/2016 06:03'!
isSplitEpimorphism
	^ self hasRightInverse! !

!Morphism methodsFor: 'testing' stamp: 'len 8/8/2016 06:03'!
isSplitMonomorphism
	^ self hasLeftInverse! !

!Morphism methodsFor: 'accessing' stamp: 'len 8/8/2016 06:42'!
kernel
	^ properties at: #kernel! !

!Morphism methodsFor: 'operations' stamp: 'len 8/8/2016 05:49'!
leftInverse
	^ properties at: #leftInverse! !

!Morphism methodsFor: 'printing' stamp: 'len 8/8/2016 05:52'!
name
	^ properties at: #name ifAbsent: [self printString]! !

!Morphism methodsFor: 'printing' stamp: 'len 8/8/2016 05:52'!
name: aString
	properties at: #name put: aString! !

!Morphism methodsFor: 'accessing' stamp: 'len 10/6/2016 15:42'!
parent
	"A morphism f:A->B belongs to Hom(A,B)."
	^ self domain -> self codomain! !

!Morphism methodsFor: 'printing' stamp: 'len 8/8/2016 05:51'!
printOn: aStream
	(properties includesKey: #name)
		ifTrue:
			[| name |
			name _ properties at: #name.
			(name is: #Text) ifFalse: [name _ name italic].
			aStream nextPutAll: name]
		ifFalse:
			[super printOn: aStream].
	aStream nextPut: $:.
	self arrowPrintOn: aStream! !

!Morphism methodsFor: 'accessing' stamp: 'len 8/8/2016 05:46'!
properties
	^ properties! !

!Morphism methodsFor: 'accessing' stamp: 'len 8/8/2016 06:42'!
retraction
	^ self leftInverse! !

!Morphism methodsFor: 'operations' stamp: 'len 8/8/2016 05:49'!
rightInverse
	^ properties at: #rightInverse! !

!Morphism methodsFor: 'accessing' stamp: 'len 8/8/2016 06:42'!
section
	^ self rightInverse! !

!Morphism class methodsFor: 'instance creation' stamp: 'len 8/8/2016 05:53'!
new
	^ super new initialize! !

!Function methodsFor: 'operations' stamp: 'len 10/10/2016 09:17'!
* anObject
	^ (self codomain includes: anObject)
		ifTrue: [self species from: self domain to: self codomain evaluating: [:each| (self value: each) * anObject]]
		ifFalse: [self species from: self domain to: self codomain evaluating: [:each| (self value: each) * (anObject value: each)]]! !

!Function methodsFor: 'operations' stamp: 'len 2/12/2016 05:51'!
** anObject
	^ (anObject isKindOf: Function)
		ifTrue: [self species from: self domain to: self codomain evaluating: [:each| (self value: each) ** (anObject value: each)]]
		ifFalse: [self species from: self domain to: self codomain evaluating: [:each| (self value: each) ** anObject]]! !

!Function methodsFor: 'operations' stamp: 'len 10/10/2016 09:17'!
+ anObject
	^ (self codomain includes: anObject)
		ifTrue: [self species from: self domain to: self codomain evaluating: [:each| (self value: each) + anObject]]
		ifFalse: [self species from: self domain to: self codomain evaluating: [:each| (self value: each) + (anObject value: each)]]! !

!Function methodsFor: 'operations' stamp: 'len 12/3/2015 20:33'!
- aFunction
	^ self + aFunction negated! !

!Function methodsFor: 'operations' stamp: 'len 12/3/2015 20:33'!
/ aFunction
	^ self * aFunction reciprocal! !

!Function methodsFor: 'comparing' stamp: 'len 2/12/2016 05:36'!
= aFunction
	self == aFunction ifTrue: [^ true].
	(self domain = aFunction domain and: [self codomain = aFunction codomain])
		ifFalse: [^ false].
	self domain isFinite ifFalse: [^ self error: 'unable to check equality'].
	self domain do: [:each| (self value: each) = (aFunction value: each) ifFalse: [^ false]].
	^ true! !

!Function methodsFor: 'operations' stamp: 'len 10/10/2016 15:12'!
@ aFunction
	"Answer the composition of the receiver with the argument."
	aFunction class == Identity ifTrue: [^ self].
	self domain >= aFunction codomain ifFalse: [DomainError signal: 'domains don''t match'].
	^ self species from: aFunction domain to: self codomain evaluating: [:x| self value: (aFunction value: x)]! !

!Function methodsFor: 'operations' stamp: 'len 9/21/2016 16:51'!
 aFunction
	aFunction class == Identity ifTrue: [^ self].
	self codomain <= aFunction domain ifFalse: [DomainError signal: 'domains don''t match'].
	^ self species from: self domain to: aFunction codomain evaluating: [:x| aFunction value: (self value: x)]! !

!Function methodsFor: 'operations' stamp: 'len 12/27/2015 22:08'!
backwardDifference: n at: h
	^ self species
		from: self domain
		to: self codomain
		evaluating: [:x| (0 to: n) sum: [:i| (-1)**i * (n take: i) * (self value: x + (i*h))]]! !

!Function methodsFor: 'operations' stamp: 'len 12/27/2015 22:09'!
centralDifference: n at: h
	^ self species
		from: self domain
		to: self codomain
		evaluating: [:x| (0 to: n) sum: [:i| (-1)**i * (n take: i) * (self value: x + ((n/2 - i)*h))]]! !

!Function methodsFor: 'operations' stamp: 'len 4/19/2016 21:40'!
corestrictedTo: aDomain
	^ self species from: self domain to: aDomain evaluating: [:x| self value: x]! !

!Function methodsFor: 'private' stamp: 'len 10/10/2016 14:05'!
expression
	^ properties at: #expression ifAbsent: [self]! !

!Function methodsFor: 'private' stamp: 'len 10/10/2016 14:06'!
expression: anExpression
	properties at: #expression put: ((anExpression isKindOf: Function) ifTrue: [anExpression expression] ifFalse: [anExpression])! !

!Function methodsFor: 'operations' stamp: 'len 12/27/2015 22:08'!
forwardDifference: n at: h
	^ self species
		from: self domain
		to: self codomain
		evaluating: [:x| (0 to: n) sum: [:i| (-1)**(n-i) * (n take: i) * (self value: x + ((n-i)*h))]]! !

!Function methodsFor: 'comparing' stamp: 'len 8/6/2016 10:29'!
hash
	^ self domain hash hashMultiply + self codomain hash! !

!Function methodsFor: 'testing' stamp: 'len 4/16/2016 18:53'!
isBiyective
	^ self isInjective and: [self isSurjective]! !

!Function methodsFor: 'testing' stamp: 'len 8/24/2016 20:37'!
isEpimorphism
	^ self isSurjective! !

!Function methodsFor: 'testing' stamp: 'len 2/9/2016 04:25'!
isInjective
	^ self hasLeftInverse! !

!Function methodsFor: 'testing' stamp: 'len 4/16/2016 19:16'!
isMonomorphism
	^ self isInjective! !

!Function methodsFor: 'testing' stamp: 'len 2/9/2016 04:25'!
isSurjective
	^ self hasRightInverse! !

!Function methodsFor: 'testing' stamp: 'len 2/15/2016 04:56'!
isTrivial
	^ self kernel = self domain! !

!Function methodsFor: 'operations' stamp: 'len 2/12/2016 05:48'!
negated
	^ self species from: self domain to: self codomain evaluating: [:each| (self value: each) negated]! !

!Function methodsFor: 'morphic' stamp: 'len 4/24/2016 02:04'!
plot: aCollection
	^ FunctionPlotMorph new evaluationPoints: aCollection; function: self! !

!Function methodsFor: 'printing' stamp: 'len 10/10/2016 14:12'!
printOn: aStream
	(self expression isBlock not and: [(self expression isKindOf: Function) not])
		ifTrue: [aStream print: self expression]
		ifFalse: [super printOn: aStream]! !

!Function methodsFor: 'operations' stamp: 'len 2/12/2016 05:48'!
reciprocal
	^ self species from: self domain to: self codomain evaluating: [:each| (self value: each) reciprocal]! !

!Function methodsFor: 'operations' stamp: 'len 4/19/2016 21:40'!
restrictedTo: aDomain
	^ self species from: aDomain to: self codomain evaluating: [:x| self value: x]! !

!Function methodsFor: 'private' stamp: 'len 12/3/2015 20:34'!
species
	^ Function! !

!Function methodsFor: 'operations' stamp: 'len 6/23/2016 20:36'!
squared
	^ self * self! !

!Function methodsFor: 'evaluating' stamp: 'len 10/10/2016 14:01'!
value: anObject
"	(self domain includes: anObject) ifFalse: [^ anObject apply: self]."
	self flag: #fix. "check argument"
	^ (properties at: #expression) value: anObject! !

!Function class methodsFor: 'instance creation' stamp: 'len 10/10/2016 13:59'!
evaluating: anExpression
	^ self new expression: anExpression! !

!Function class methodsFor: 'instance creation' stamp: 'len 10/10/2016 13:59'!
from: aDomain to: anotherDomain evaluating: anExpression
	^ self new domain: aDomain; codomain: anotherDomain; expression: anExpression! !

!Function class methodsFor: 'instance creation' stamp: 'len 10/2/2016 09:31'!
newFrom: aFunction
	^ self from: aFunction domain to: aFunction codomain evaluating: aFunction! !

!AbelianGroupHomomorphism methodsFor: 'as yet unclassified' stamp: 'len 10/10/2016 16:36'!
= anObject
	(anObject isKindOf: RingHomomorphism) ifFalse: [^ super = anObject].
	(anObject domain = self domain and: [anObject codomain = self codomain])
		ifFalse: [^ false].
	^ (self domain generators ifNil: [self domain]) allSatisfy: [:each| (self value: each) = (anObject value: each)]! !

!AbelianGroupHomomorphism methodsFor: 'as yet unclassified' stamp: 'len 10/10/2016 09:14'!
is: aSymbol
	^ aSymbol == #AbelianGroupHomomorphism or: [super is: aSymbol]! !

!AbelianGroupHomomorphism methodsFor: 'as yet unclassified' stamp: 'len 10/10/2016 08:49'!
species
	^ AbelianGroupHomomorphism! !

!RingHomomorphism methodsFor: 'as yet unclassified' stamp: 'len 10/10/2016 16:36'!
= anObject
	(anObject isKindOf: RingHomomorphism) ifFalse: [^ super = anObject].
	(anObject domain = self domain and: [anObject codomain = self codomain])
		ifFalse: [^ false].
	^ (self domain generators ifNil: [self domain]) allSatisfy: [:each| (self value: each) = (anObject value: each)]! !

!RingHomomorphism methodsFor: 'as yet unclassified' stamp: 'len 10/10/2016 09:14'!
is: aSymbol
	^ aSymbol == #RingHomomorphism or: [super is: aSymbol]! !

!RingHomomorphism methodsFor: 'as yet unclassified' stamp: 'len 10/5/2016 10:27'!
isZero
	"A ring homomorphism to a non-trivial ring cannot be zero, because 1 maps to 1."
	^ (self value: self domain one) = self codomain zero
"	^ self codomain isTrivial"! !

!RingHomomorphism methodsFor: 'as yet unclassified' stamp: 'len 10/3/2016 09:01'!
spec
	"This is the Spec functor. Answer the scheme homomorphism induced by the receiver, i.e. given a ring homomorphism f:R->S, Spec(f) is a scheme homomorphism Spec(S)->Spec(R)."
	self notYetImplemented! !

!RingHomomorphism methodsFor: 'as yet unclassified' stamp: 'len 10/10/2016 08:35'!
species
	^ RingHomomorphism! !

!FieldHomomorphism methodsFor: 'as yet unclassified' stamp: 'len 10/10/2016 16:37'!
= anObject
	(anObject isKindOf: FieldHomomorphism) ifFalse: [^ super = anObject].
	(anObject domain = self domain and: [anObject codomain = self codomain])
		ifFalse: [^ false].
	^ (self domain generators ifNil: [self domain]) allSatisfy: [:each| (self value: each) = (anObject value: each)]! !

!FieldHomomorphism methodsFor: 'as yet unclassified' stamp: 'len 10/10/2016 09:14'!
is: aSymbol
	^ aSymbol == #FieldHomomorphism or: [super is: aSymbol]! !

!FieldHomomorphism methodsFor: 'as yet unclassified' stamp: 'len 10/10/2016 08:35'!
species
	^ FieldHomomorphism! !

!LinearMap methodsFor: 'arithmetic' stamp: 'len 1/8/2016 06:32'!
* anObject
	^ self class from: domainBasis to: codomainBasis matrix: matrix * anObject! !

!LinearMap methodsFor: 'arithmetic' stamp: 'len 7/1/2016 21:34'!
+ aLinearMap
	(self domainBasis = aLinearMap domainBasis
		and: [self codomainBasis = aLinearMap codomainBasis])
			ifTrue:
				[^ self class from: domainBasis to: codomainBasis matrix: matrix + aLinearMap matrix].
	(self domain = aLinearMap domain and: [self codomain = aLinearMap codomain])
			ifFalse: [^ self error: 'domain or codomain don''t match'].
	^ self class
		from: self domain
		to: self codomain
		evaluating: [:v| (self value: v) + (aLinearMap value: v)]! !

!LinearMap methodsFor: 'comparing' stamp: 'len 4/29/2016 18:56'!
= aLinearMap
	self == aLinearMap ifTrue: [^ true].
	(aLinearMap isKindOf: LinearMap) ifFalse: [^ false].
	self domainBasis = aLinearMap domainBasis ifTrue: [^ self matrix = aLinearMap matrix].
	self domain = aLinearMap domain ifFalse: [^ false].
	self domainBasis do: [:each|
		(self value: each) = (aLinearMap value: each)
			ifFalse: [^ false]].
	^ true! !

!LinearMap methodsFor: 'arithmetic' stamp: 'len 8/24/2016 21:57'!
@ aLinearMap
	"Answer the composition of the receiver with the argument."
	domainBasis = aLinearMap codomainBasis
		ifTrue: [^ self class from: aLinearMap domainBasis to: codomainBasis matrix: matrix * aLinearMap matrix].
	self domain >= aLinearMap codomain ifFalse: [^ DomainError signal: 'domains don''t match'].
	^ self class
		from: aLinearMap domain
		to: self codomain
		evaluating: [:each| self value: (aLinearMap value: each)]! !

!LinearMap methodsFor: 'arithmetic' stamp: 'len 10/4/2016 12:28'!
 aLinearMap
	"Answer the tensor product of the receiver with the argument."
	^ self domain  aLinearMap domain
		to: (self codomain  aLinearMap codomain)
"		matrix: self matrix  aLinearMap matrix" "must change to the same basis"
		evaluating: [:each| SimpleTensor left: (self value: (each at: 1)) right: (aLinearMap value: (each at: 2))]! !

!LinearMap methodsFor: 'arithmetic' stamp: 'len 9/21/2016 16:54'!
 aLinearMap
	"Answer the composition of the receiver with the argument."
	codomainBasis = aLinearMap domainBasis
		ifTrue: [^ self class from: domainBasis to: aLinearMap codomainBasis matrix: matrix * aLinearMap matrix].
	self codomain <= aLinearMap domain ifFalse: [^ DomainError signal: 'domains don''t match'].
	^ self class
		from: self domain
		to: aLinearMap codomain
		evaluating: [:each| aLinearMap value: (self value: each)]! !

!LinearMap methodsFor: 'operations' stamp: 'len 12/16/2015 22:03'!
adjoint
	^ self class from: domainBasis dual to: codomainBasis dual matrix: matrix! !

!LinearMap methodsFor: 'eigenvalues' stamp: 'len 2/6/2016 21:37'!
algebraicMultiplicityAt: anEigenvalue
	^ self characteristicPolynomial multiplicityAt: anEigenvalue! !

!LinearMap methodsFor: 'accessing' stamp: 'len 2/8/2016 23:58'!
automorphism
	"Answer the field automorphism associated with the receiver, looking at the receiver as a semilinear transformation. This is the identity automorphism."
	^ self domain scalars id! !

!LinearMap methodsFor: 'accessing-private' stamp: 'len 2/9/2016 00:04'!
automorphism: aFieldAutomorphism
	^ self shouldNotImplement! !

!LinearMap methodsFor: 'accessing' stamp: 'len 12/28/2015 21:10'!
bitSize
	^ matrix bitSize! !

!LinearMap methodsFor: 'operations' stamp: 'len 3/20/2016 07:43'!
characteristicPolynomial
	^ self matrix characteristicPolynomial! !

!LinearMap methodsFor: 'accessing' stamp: 'len 11/7/2015 23:21'!
codomain
	^ self codomainBasis span! !

!LinearMap methodsFor: 'accessing' stamp: 'len 1/25/98 20:03'!
codomainBasis
	"Answer the basis of the codomain of the receiver."

	^ codomainBasis! !

!LinearMap methodsFor: 'accessing-private' stamp: 'len 1/25/98 19:58'!
codomainBasis: aLinearBasis
	codomainBasis _ aLinearBasis! !

!LinearMap methodsFor: 'private' stamp: 'len 8/24/2016 21:39'!
computeLeftInverse
	^ self isMonomorphism
		ifTrue:
			[self class
				from: codomainBasis
				to: domainBasis
				matrix: matrix leftInverse]! !

!LinearMap methodsFor: 'private' stamp: 'len 8/24/2016 21:14'!
computeRightInverse
	^ self isEpimorphism
		ifTrue:
			[self class
				from: codomainBasis
				to: domainBasis
				matrix: matrix rightInverse]! !

!LinearMap methodsFor: 'operations' stamp: 'len 11/9/2015 16:01'!
corank
	^ self cokernel dimension! !

!LinearMap methodsFor: 'operations' stamp: 'len 2/13/2016 19:08'!
corestrictedTo: aLinearSubspace
	"Answer a linear transformation like the receiver but with codomain restricted to aLinearSubspace."
	^ self class
		from: self domain
		to: aLinearSubspace
		evaluating: [:each | self value: each]! !

!LinearMap methodsFor: 'operations' stamp: 'len 1/8/2016 06:33'!
determinant
	^ matrix determinant! !

!LinearMap methodsFor: 'accessing' stamp: 'len 11/7/2015 23:21'!
domain
	^ self domainBasis span! !

!LinearMap methodsFor: 'accessing' stamp: 'len 1/25/98 20:03'!
domainBasis
	"Answer the basis of the domain of the receiver."

	^ domainBasis! !

!LinearMap methodsFor: 'accessing-private' stamp: 'len 1/25/98 19:58'!
domainBasis: aLinearBasis
	domainBasis _ aLinearBasis! !

!LinearMap methodsFor: 'operations' stamp: 'len 2/6/2016 22:14'!
dual
	"Answer the transpose (or dual, or adjoint) of the receiver.
	This is the 'operator adjoint', not to be confused with the 'Hilbert adjoint' that is defined for an operator in an inner product space."
	^ self class from: domainBasis dual to: codomainBasis dual matrix: matrix adjoint! !

!LinearMap methodsFor: 'eigenvalues' stamp: 'len 2/6/2016 21:25'!
eigenspaceAt: anEigenvalue
	^ (self - (self identity * anEigenvalue)) kernel! !

!LinearMap methodsFor: 'eigenvalues' stamp: 'len 2/11/2016 22:15'!
eigenvalues
	^ matrix eigenvalues! !

!LinearMap methodsFor: 'operations' stamp: 'len 2/22/2016 08:10'!
fiberAt2: aVector
	"Answer the fiber of aVector under the receiver. The answer is an affine subspace (a linear variety or flat)."
	| system coordinate tuple |
	tuple _ codomainBasis coordinatesOf: aVector.
	system _ LinearSystem new.
	coordinate _ 1.
	matrix rowsDo: [:each|
		system add: ((LinearForm from: domainBasis coordinates: each) eq: (tuple at: coordinate)).
		coordinate _ coordinate + 1].
	^ system solutions "apply: domainBasis vectorAt"! !

!LinearMap methodsFor: 'operations' stamp: 'len 2/22/2016 08:28'!
fiberAt: aVector
	"Answer the fiber of aVector under the receiver. The answer is an affine subspace (a linear variety or flat)."
	| system coordinate tuple |
	tuple _ codomainBasis coordinatesOf: aVector.
	system _ LinearSystem new.
	coordinate _ 1.
	matrix rowsDo: [:each|
		system add: ((LinearForm from: domainBasis coordinates: each) eq: (tuple at: coordinate)).
		coordinate _ coordinate + 1].
	^ system solutions apply: domainBasis vectorAt! !

!LinearMap methodsFor: 'eigenvalues' stamp: 'len 2/6/2016 21:37'!
geometricMultiplicityAt: anEigenvalue
	^ (self eigenspaceAt: anEigenvalue) dimension! !

!LinearMap methodsFor: 'accessing' stamp: 'len 6/23/2016 20:38'!
identity
	^ self class from: domainBasis to: codomainBasis matrix: matrix species identity! !

!LinearMap methodsFor: 'operations' stamp: 'len 2/22/2016 00:54'!
image
	^ properties at: #image ifAbsentPut: [self codomain span: (self domainBasis collect: [:each| self value: each])]! !

!LinearMap methodsFor: 'arithmetic' stamp: 'len 1/25/98 20:37'!
inverse
	"Answer the inverse of the receiver. Answer nil if the receiver is not an isomorphism."

	^ self domain dimension = self codomain dimension ifTrue: [self leftInverse]! !

!LinearMap methodsFor: 'testing' stamp: 'len 8/30/2016 20:23'!
is: aSymbol
	^ aSymbol == #ModuleHomomorphism or: [super is: aSymbol]! !

!LinearMap methodsFor: 'testing' stamp: 'len 9/1/97 23:23'!
isConstant
	"Answer true if the receiver is a constant transformation."

	^ self rank <= 1! !

!LinearMap methodsFor: 'testing' stamp: 'len 1/7/2016 21:51'!
isIdempotent
	^ self @ self = self! !

!LinearMap methodsFor: 'testing' stamp: 'len 2/11/2016 03:45'!
isIdentity
	self isEndomorphism ifFalse: [^ false].
	self domainBasis do: [:each| (self value: each) = each ifFalse: [^ false]].
	^ true! !

!LinearMap methodsFor: 'testing' stamp: 'len 4/16/2016 19:17'!
isInjective
	^ self rank = self domainBasis size! !

!LinearMap methodsFor: 'testing' stamp: 'len 2/11/2016 21:28'!
isInvertible
	^ matrix isInvertible! !

!LinearMap methodsFor: 'testing' stamp: 'len 2/11/2016 21:33'!
isOrthogonal
	^ matrix isOrthogonal! !

!LinearMap methodsFor: 'testing' stamp: 'len 1/7/2016 21:51'!
isProjection
	^ self isIdempotent! !

!LinearMap methodsFor: 'testing' stamp: 'len 2/11/2016 06:22'!
isScalar
	^ self matrix isScalar! !

!LinearMap methodsFor: 'testing' stamp: 'len 3/17/2016 05:11'!
isSemisimple
	^ self matrix isSemisimple! !

!LinearMap methodsFor: 'testing' stamp: 'len 4/16/2016 19:16'!
isSurjective
	^ self rank = self codomainBasis size! !

!LinearMap methodsFor: 'testing' stamp: 'len 2/15/2016 04:58'!
isTrivial
	^ self isZero! !

!LinearMap methodsFor: 'testing' stamp: 'len 2/8/2016 20:37'!
isUnimodular
	^ self matrix isUnimodular! !

!LinearMap methodsFor: 'testing' stamp: 'len 1/8/2016 06:34'!
isZero
	^ matrix isZero! !

!LinearMap methodsFor: 'operations' stamp: 'len 2/22/2016 08:28'!
kernel
	^ properties at: #kernel ifAbsentPut: [matrix kernel apply: domainBasis vectorAt]! !

!LinearMap methodsFor: 'operations' stamp: 'len 5/23/2016 04:40'!
kernel2
	^ properties at: #kernel ifAbsentPut: [(self fiberAt: self codomainBasis ambient zero) direction] "!! 3-5 times slower than the other implementaiton"! !

!LinearMap methodsFor: 'arithmetic' stamp: 'len 8/25/2016 00:49'!
leftInverse
	"Answer a left inverse (or retraction) of the receiver.
	Answer nil if the receiver is not a monomorphism."
	^ properties at: #leftInverse ifAbsentPut: [self computeLeftInverse]! !

!LinearMap methodsFor: 'accessing' stamp: 'len 2/9/2016 00:00'!
matrix
	"Answer the matrix associated to the receiver with respect to the chosen domain and codomain bases."
	^ matrix! !

!LinearMap methodsFor: 'accessing-private' stamp: 'len 1/25/98 19:59'!
matrix: aMatrix
	matrix _ aMatrix! !

!LinearMap methodsFor: 'operations' stamp: 'len 6/4/2016 18:10'!
minimalPolynomial
	^ self matrix minimalPolynomial! !

!LinearMap methodsFor: 'arithmetic' stamp: 'len 1/8/2016 06:35'!
negated
	"Answer the additive inverse of the receiver."

	^ self class
		from: domainBasis
		to: codomainBasis
		matrix: matrix negated! !

!LinearMap methodsFor: 'operations' stamp: 'len 2/6/2016 22:35'!
nullity
	"Answer the dimension of the kernel of the receiver."
	^ matrix numberOfRows - matrix rank! !

!LinearMap methodsFor: 'printing' stamp: 'len 6/23/2016 23:15'!
printOn: aStream
	self isIdentity ifTrue: [aStream nextPutAll: 'id'. ^ self].
	self negated isIdentity ifTrue: [aStream nextPutAll: '-id'. ^ self].
	aStream nextPut: $(.
	matrix rows
		do: [:each| aStream print: (domainBasis dual vectorAt: each)]
		separatedBy: [aStream nextPutAll: ', '].
	aStream nextPut: $)! !

!LinearMap methodsFor: 'operations' stamp: 'len 6/10/2016 06:02'!
projective
	"Answer the projective transofmration P(f:V->W) := P(V)->P(W) indiced by the receiver."
	^ ProjectiveMap linearMap: self! !

!LinearMap methodsFor: 'operations' stamp: 'len 1/8/2016 06:35'!
rank
	^ matrix rank! !

!LinearMap methodsFor: 'operations' stamp: 'len 2/13/2016 19:08'!
restrictedTo: aLinearSubspace 
	"Answer a linear transformation like the receiver but with domain restricted to aLinearSubspace."
	^ self class
		from: aLinearSubspace
		to: self codomain
		evaluating: [:each | self value: each]! !

!LinearMap methodsFor: 'arithmetic' stamp: 'len 8/25/2016 00:49'!
rightInverse
	"Answer a right inverse (or section) of the receiver.
	Answer nil if the receiver is not an epimorphism."
	^ properties at: #rightInverse ifAbsentPut: [self computeRightInverse]! !

!LinearMap methodsFor: 'eigenvalues' stamp: 'len 2/6/2016 21:29'!
spectrum
	^ matrix spectrum! !

!LinearMap methodsFor: 'operations' stamp: 'len 1/8/2016 06:35'!
trace
	^ matrix trace! !

!LinearMap methodsFor: 'operations' stamp: 'len 2/27/2016 07:16'!
value: aVector
	"Answer the evaluation of the receiver at the argument."

	^ codomainBasis
		vectorAt: matrix * (domainBasis coordinatesOf: aVector)! !

!LinearMap class methodsFor: 'instance creation' stamp: 'len 5/23/2016 04:40'!
from: domain to: codomain evaluating: aBlock
	"Answer a new instance of the receiver using the one argument block aBlock for evaluating each vector in the domainBasis."
	| domainBasis codomainBasis matrix |
	domainBasis _ domain basis.
	codomainBasis _ codomain basis.
	matrix _ (domainBasis ambient scalars ** (domainBasis size @ codomainBasis size)) new.
	domainBasis do: [:each |
		matrix addRow: (codomainBasis coordinatesOf: (aBlock value: each))].
	^ self from: domainBasis to: codomainBasis matrix: matrix transposed! !

!LinearMap class methodsFor: 'instance creation' stamp: 'len 1/25/98 20:31'!
from: aLinearBasis to: anotherLinearBasis matrix: aMatrix
	"Answer a new instance of the reciever with the domain
	and codomain bases given by the arguments and with
	the associated matrix aMatrix."

	^ self new
		domainBasis: aLinearBasis;
		codomainBasis: anotherLinearBasis;
		matrix: aMatrix! !

!LinearMap class methodsFor: 'instance creation' stamp: 'len 1/5/2016 03:18'!
projectionOn: aLinearSubspace
	"Answer a projection on aLinearSubspace.
	A projection P is a linear transformation from a vector space to itself such that P^2 = P (idempotent)."
	| basis obasis domainBasis domain |
	basis _ aLinearSubspace basis.
	obasis _ aLinearSubspace perp basis.
"	K _ basis space scalars.
	matrix _ (K ** (basis size @ (basis size + obasis size))) identity."
	domainBasis _ basis copy addAll: obasis; yourself.
	domain _ domainBasis span.
	^ self from: domain to: domain evaluating: [:v| (basis includes: v) ifTrue: [v] ifFalse: [v-v]]! !

!LinearForm methodsFor: 'converting' stamp: 'len 6/7/2016 07:22'!
asPolynomial
	| coordinates P |
	coordinates _ self coordinates.
	P _ self domain scalars polynomialsIn: coordinates size.
	^ (P tuple: P rank evaluating: [:i| P x: i]) dot: coordinates! !

!LinearForm methodsFor: 'converting' stamp: 'len 5/23/2016 04:39'!
asTuple
	"Answer the coordinates of the receiver in the canonical basis."
	^ (self restrictedTo: domainBasis ambient) matrix asTuple

	"^ self domain dual coordinatesOf: self"! !

!LinearForm methodsFor: 'converting' stamp: 'len 5/23/2016 04:39'!
asVector
	"Answer the vector corresponding to the receiver according to the natural isomorphism from the vector space to its dual.
	See DualSpace>>#map."
	self flag: #fix. "this is not natural"
	^ domainBasis ambient vectorAt: self asTuple! !

!LinearForm methodsFor: 'accessing' stamp: 'len 5/23/2016 04:39'!
coordinates
	"Answer the coordinates of the receiver in the canonical basis."
	^ (self restrictedTo: domainBasis ambient) matrix asTuple! !

!LinearForm methodsFor: 'operations' stamp: 'len 8/20/97 21:03'!
eq: anObject
	"Answer the equation 'self = anObject'."

	^ LinearEquation form: self value: anObject! !

!LinearForm methodsFor: 'operations' stamp: 'len 5/23/2016 04:40'!
image2
	^ self kernel dimension < self domainBasis ambient dimension
		ifTrue: [self codomain]
		ifFalse: [self codomain null]! !

!LinearForm methodsFor: 'printing' stamp: 'len 4/21/2016 00:21'!
printOn: aStream
	self asPolynomial printOn: aStream! !

!LinearForm class methodsFor: 'instance creation' stamp: 'len 3/28/2016 01:23'!
from: aLinearBasis coordinates: aTuple
	"Answer a new instance of the receiver representing the linear form with coordinates aTuple and with domain given by aLinearBasis."
	^ self from: aLinearBasis span evaluating: [:each| (aLinearBasis coordinatesOf: each) dot: aTuple]! !

!LinearForm class methodsFor: 'instance creation' stamp: 'len 10/7/2016 08:42'!
from: aModule evaluating: aBlock 
	"Answer a new instance of the receiver using the one argument block aBlock for evaluating each vector in the given basis."
	^ self from: aModule to: aModule scalars asSelfModule evaluating: aBlock! !

!LinearForm class methodsFor: 'instance creation' stamp: 'len 10/7/2016 08:42'!
from: aLinearBasis matrix: aMatrix
	^ self from: aLinearBasis to: aLinearBasis ambient scalars asSelfModule basis matrix: aMatrix! !

!GroupAction methodsFor: 'graphs' stamp: 'len 5/25/2016 03:45'!
actionGraph: groupGenerators
	"Answer the action diagram with respect to the given group generators.
	This is similar to a Cayley diagram.
	The connected components of the action diagram are the orbits of the action."
	| G |
	self space isFinite ifFalse: [^ self error: 'not a finite space'].
	G _ Digraph unorderedLabeled.
	groupGenerators do: [:g|
		self space do: [:x|
			G addEdgeFrom: x to: (self value: {g.x}) label: g]].
	^ G! !

!GroupAction methodsFor: 'graphs' stamp: 'len 5/18/2016 21:23'!
actionGraphMorph
	^ self actionGraphMorph: self group generators! !

!GroupAction methodsFor: 'graphs' stamp: 'len 8/16/2016 04:02'!
actionGraphMorph: generators
	| G answer colors |
	G _ self actionGraph: generators.
	answer _ G asMorph.
	colors _ DiscretePalette default.
	answer edgesAndLabelsDo: [:each :label| each hideLabel; color: (colors at: label)].
	answer nodesDo: [:each| each color: Color transparent; morphExtent: 0@0].
	^ answer! !

!GroupAction methodsFor: 'converting' stamp: 'len 8/1/2016 08:48'!
asPermutationRepresentation
	^ GroupRepresentation
		from: self group
		to: (SymmetricGroup on: self space)
		evaluating: [:g| Permutation on: self space evaluating: [:x| self value: {g.x}]]! !

!GroupAction methodsFor: 'accessing' stamp: 'len 6/29/2016 08:46'!
degree
	^ self space size! !

!GroupAction methodsFor: 'accessing' stamp: 'len 2/13/2016 06:31'!
fixedPoints
	^ self space select: [:each| self isFixedPoint: each]! !

!GroupAction methodsFor: 'accessing' stamp: 'len 6/22/2016 07:36'!
fixedPointsOf: anElement
	"Dual idea to the stabilizer. The fixed points are the orbits of size 1."
	^ self space select: [:each| (self value: {anElement. each}) = each]! !

!GroupAction methodsFor: 'accessing' stamp: 'len 2/13/2016 08:02'!
group
	^ self domain at: 1! !

!GroupAction methodsFor: 'testing' stamp: 'len 7/27/2016 07:31'!
isFaithful
	"A group action G x X -> X is faithful (or effective) if the homomorphism G -> Sym(X) has trivial kernel {id}."
	^ properties at: #isFaithful ifAbsentPut: [self kernel isTrivial]! !

!GroupAction methodsFor: 'testing' stamp: 'len 2/13/2016 08:02'!
isFixedPoint: aPoint
	"Answer true if the argument is a fixed point of the receiver."
	self group do: [:each| (self value: {each. aPoint}) = aPoint ifFalse: [^ false]].
	^ true! !

!GroupAction methodsFor: 'testing' stamp: 'len 7/27/2016 07:34'!
isImprimitive
	^ self isPrimitive not! !

!GroupAction methodsFor: 'testing' stamp: 'len 7/27/2016 07:36'!
isPrimitive
	^ self orbits allSatisfy: [:each| each size = 1 or: [each size = self space size]]! !

!GroupAction methodsFor: 'testing' stamp: 'len 7/27/2016 07:30'!
isRegular
	^ self isTransitive and: [(self stabilizerOf: self space anyOne) isTrivial]! !

!GroupAction methodsFor: 'testing' stamp: 'len 7/27/2016 07:28'!
isTransitive
	^ self orbits size = 1! !

!GroupAction methodsFor: 'accessing' stamp: 'len 7/27/2016 07:31'!
kernel
	"This is also the intersection of all the stabilizers."
	^ self group select: [:g| self space allSatisfy: [:x| (self value: {g.x}) = x]]
	"^ self asPermutationRepresentation kernel"! !

!GroupAction methodsFor: 'accessing' stamp: 'len 6/27/2016 23:20'!
orbitOf: aPoint
	"Answer the set of points to which aPoint can be 'moved' by elements of the group G.
	All the orbits form a partition of the underlying set (space) X, and it's written X/G and called the quotient of the action. In geometric situations it may be called the orbit space, and in algebraic situations it is called the space of coinvariants (in contrast with the space of invariants, that are the fixed points)."
	| answer generators |
	(generators _ self group generators) isNil
		ifTrue:
			[answer _ Set2 new.
			self group do: [:each| answer add: (self value: {each. aPoint})].
			^ answer].
	^ (SchreierTree root: aPoint generators: generators action: self) orbit! !

!GroupAction methodsFor: 'accessing' stamp: 'len 5/16/2016 05:28'!
orbits
	"Answer the quotient of the action, also called space of orbits in geometric situations and space of coinvariants in algebraic situations."
	| answer |
	answer _ Set new.
	self space do: [:each| answer add: (self orbitOf: each)].
	^ answer! !

!GroupAction methodsFor: 'accessing' stamp: 'len 2/16/2016 04:29'!
space
	"Answer the underlying set X of the action G x X -> X."
	^ self codomain! !

!GroupAction methodsFor: 'accessing' stamp: 'len 5/13/2016 02:26'!
stabilizerOf: aPoint
	"Answer the stabilizer subgroup (or isotropy group or little group) of aPoint, defined as the set of elements that 'fix' aPoint. The stabilizer of fixed points is the whole group, and the kernel of the action homomorphism G -> Sym(X) is the intersection of all stabilizers."
	^ self group select: [:each| (self value: {each. aPoint}) = aPoint]! !

!GroupHomomorphism methodsFor: 'comparing' stamp: 'len 5/2/2016 09:35'!
= anObject
	(anObject isKindOf: GroupHomomorphism) ifFalse: [^ super = anObject].
	(anObject domain = self domain and: [anObject codomain = self codomain])
		ifFalse: [^ false].
	^ (self domain generators ifNil: [self domain]) allSatisfy: [:each| (self value: each) = (anObject value: each)]! !

!GroupHomomorphism methodsFor: 'accessing' stamp: 'len 2/12/2016 05:46'!
fiberAt: anElement
	"Answer the fiber of the receiver at anElement, a Coset.
	Answer nil if the element is not in the image of the receiver."
	^ self kernel * (self domain detect: [:one| (self value: one) = anElement] ifNone: [^ nil])! !

!GroupHomomorphism methodsFor: 'accessing' stamp: 'len 8/1/2016 09:16'!
image
	"Answer the image of the receiver."
	^ self domain collect: [:each| self value: each]! !

!GroupHomomorphism methodsFor: 'arithmetic' stamp: 'len 8/1/2016 09:17'!
inverse
	"Answer the compositional inverse of the receiver."
	^ self class
		from: self codomain to: self domain
		evaluating: [ :each | self domain detect: [ :one | (self value: one) = each]]! !

!GroupHomomorphism methodsFor: 'testing' stamp: 'len 8/30/2016 20:23'!
is: aSymbol
	^ aSymbol == #GroupHomomorphism or: [super is: aSymbol]! !

!GroupHomomorphism methodsFor: 'testing' stamp: 'len 11/7/2015 16:46'!
isInjective
	^ self kernel isTrivial! !

!GroupHomomorphism methodsFor: 'testing' stamp: 'len 11/7/2015 16:49'!
isSurjective
	^ self image = self codomain! !

!GroupHomomorphism methodsFor: 'accessing' stamp: 'len 8/1/2016 09:16'!
kernel
	"Answer the kernel of the receiver."
	^ self codomain select: [:each| (self value: each) = self codomain identity]! !

!GroupHomomorphism methodsFor: 'private' stamp: 'len 7/27/2016 02:52'!
mapping
	^ properties at: #mapping ifAbsent: []! !

!GroupHomomorphism methodsFor: 'private' stamp: 'len 7/27/2016 02:52'!
mapping: aDictionary
	properties at: #mapping put: aDictionary! !

!GroupHomomorphism methodsFor: 'private' stamp: 'len 10/10/2016 08:34'!
species
	^ GroupHomomorphism! !

!GroupHomomorphism class methodsFor: 'instance creation' stamp: 'len 8/1/2016 09:15'!
from: aDomain to: anotherDomain mapping: aDictionary
	^ self new domain: aDomain; codomain: anotherDomain; mapping: aDictionary! !

!GroupHomomorphism class methodsFor: 'instance creation' stamp: 'len 7/27/2016 02:51'!
mapping: aDictionary
	^ self new mapping: aDictionary! !

!Conjugation methodsFor: 'comparing' stamp: 'len 5/2/2016 09:31'!
= anObject
	(anObject isKindOf: Conjugation) ifFalse: [^ super = anObject].
	^ anObject domain = self domain and: [anObject codomain = self codomain and: [self element = anObject element]]! !

!Conjugation methodsFor: 'accessing-private' stamp: 'len 5/2/2016 09:31'!
element
	^ element! !

!Conjugation methodsFor: 'accessing-private' stamp: 'len 2/12/2016 06:34'!
element: anElement
	element _ anElement.
	elementInverse _ self domain inverseMap value: element! !

!Conjugation methodsFor: 'comparing' stamp: 'len 5/2/2016 09:31'!
hash
	^ element hash! !

!Conjugation methodsFor: 'accessing' stamp: 'len 2/12/2016 06:37'!
image
	^ self codomain! !

!Conjugation methodsFor: 'arithmetic' stamp: 'len 2/12/2016 06:42'!
inverse
	^ self class by: elementInverse in: self domain! !

!Conjugation methodsFor: 'accessing' stamp: 'len 2/12/2016 06:37'!
kernel
	^ self domain null! !

!Conjugation methodsFor: 'evaluating' stamp: 'len 2/12/2016 06:36'!
value: anElement
	| op |
	op _ self domain operation.
	^ op value: {op value: {element. anElement}. elementInverse}! !

!Conjugation class methodsFor: 'instance creation' stamp: 'len 5/12/2016 10:06'!
by: anElement in: aGroup
	^ self new domain: aGroup; codomain: aGroup; element: anElement! !

!GroupRepresentation methodsFor: 'accessing' stamp: 'len 8/1/2016 08:52'!
action
	"Answer the associated group action on the representation space."
	^ GroupAction from: (self domain, self space) to: self space evaluating: [:each| (self value: each first) value: each second]! !

!GroupRepresentation methodsFor: 'invariants' stamp: 'len 8/25/2016 04:16'!
character
	"Answer the character of the receiver, assuming it's a linear or matrix representation."
	"This is a class function, i.e. it's constant on conjugacy classes, because similar matrices (or linear maps) have the same trace."
	self space isModule ifFalse: [^ self error: 'not a linear or matrix representation'].
	^ Function from: self domain to: self space scalars evaluating: [:g| (self value: g) trace] "should be a GroupHomomorphism?"! !

!GroupRepresentation methodsFor: 'accessing' stamp: 'len 8/1/2016 08:48'!
space
	"Answer the representation space."
	^ self codomain space! !

!Permutation methodsFor: 'arithmetic' stamp: 'len 8/25/2016 00:32'!
* aPermutation
	"Answer the product of the receiver with the argument. This is group product operation, and it's function composition in reverse order."
	| answer |
	answer _ self species new.
	self changesDo: [:each|
		answer at: each put: (aPermutation at: (self at: each))].
	aPermutation changesDo: [:each|
		answer at: each put: (aPermutation at: (self at: each))].
	^ answer! !

!Permutation methodsFor: 'comparing' stamp: 'len 6/29/2016 00:26'!
= aPermutation
	(aPermutation isKindOf: self species) ifFalse: [^ super = aPermutation].
	map keysAndValuesDo: [:key :value| (aPermutation at: key) = value ifFalse: [^ false]].
	aPermutation map size <= map size ifTrue: [^ true].
	aPermutation map keysAndValuesDo: [:key :value| value = (self at: key) ifFalse: [^ false]].
	^ true! !

!Permutation methodsFor: 'arithmetic' stamp: 'len 8/25/2016 00:55'!
@ aPermutation
	"Answer the composition of the receiver with the argument."
	^ aPermutation * self! !

!Permutation methodsFor: 'arithmetic' stamp: 'len 9/21/2016 16:56'!
 aPermutation
	"Answer the composition of the receiver with the argument."
	^ self * aPermutation! !

!Permutation methodsFor: 'accessing' stamp: 'len 5/6/98 05:01'!
aChange
	"Answer an element changed by the receiver (or nil if there are no one)."

	self changesDo: [ :each | ^ each].
	^ nil! !

!Permutation methodsFor: 'converting' stamp: 'len 7/4/2016 02:56'!
asArray
	^ (1 to: map size) collect: [:each| self at: each]! !

!Permutation methodsFor: 'converting' stamp: 'len 7/21/2016 02:11'!
asStandard: anArray
	^ StandardPermutation image: (anArray collect: [:each| anArray indexOf: (self at: each)])! !

!Permutation methodsFor: 'accessing' stamp: 'len 6/28/2016 07:01'!
at: anObject
	^ map at: anObject ifAbsent: [anObject]! !

!Permutation methodsFor: 'accessing' stamp: 'len 6/28/2016 07:01'!
at: anObject put: anotherObject
	anObject = anotherObject ifTrue: [^ anotherObject].
	^ map at: anObject put: anotherObject! !

!Permutation methodsFor: 'accessing' stamp: 'len 6/28/2016 07:34'!
changes
	"Answer the elements changed by the receiver."
	^ Iterator on: self performing: #changesDo:! !

!Permutation methodsFor: 'iterating' stamp: 'len 6/28/2016 07:25'!
changesDo: aBlock
	map keysDo: aBlock! !

!Permutation methodsFor: 'accessing' stamp: 'len 6/28/2016 07:01'!
codomain
	^ self domain! !

!Permutation methodsFor: 'accessing' stamp: 'len 5/2/2016 04:06'!
cycleAt: anObject
	"Answer the cycle generated by anObject."

	| answer last |
	answer _ PermutationCycle new.
	last _ anObject.
	[answer at: last put: (last _ self at: last). last = anObject] whileFalse.
	^ answer! !

!Permutation methodsFor: 'accessing' stamp: 'len 5/2/2016 04:41'!
cycles
	"Answer the cycles of the receiver."
	^ Iterator on: self performing: #cyclesDo:! !

!Permutation methodsFor: 'iterating' stamp: 'len 6/28/2016 07:34'!
cyclesDo: aBlock
	"Iterate over the cycles of the receiver."
	| left first next cycle |
	left _ self changes copyAs: Set2.
	[left size > 0] whileTrue: [
		cycle _ PermutationCycle new.
		first _ left anyOne.
		next _ first.
		[cycle at: next put: (next _ self at: next).
		left remove: next.
		next ~= first] whileTrue.
		aBlock value: cycle]! !

!Permutation methodsFor: 'accessing' stamp: 'len 8/31/2016 03:34'!
domain
	^ map keys as: FormalSet! !

!Permutation methodsFor: 'testing' stamp: 'len 10/1/97 19:09'!
even
	"Answer true if the receiver is odd."

	^ self sign = 1! !

!Permutation methodsFor: 'testing' stamp: 'len 8/25/2016 00:38'!
hasLeftInverse
	^ true! !

!Permutation methodsFor: 'testing' stamp: 'len 8/25/2016 00:38'!
hasRightInverse
	^ true! !

!Permutation methodsFor: 'comparing' stamp: 'len 6/28/2016 08:59'!
hash
	| answer |
	answer _ 0.
"	self changesDo: [:each| answer _ answer + each hash]."
	map keysAndValuesDo: [:key :value| key = value ifFalse: [answer _ key hash hashMultiply + value hash + answer]].
	^ answer! !

!Permutation methodsFor: 'arithmetic' stamp: 'len 6/28/2016 07:25'!
identity
	"Answer the identity permutation."
	^ self species new! !

!Permutation methodsFor: 'arithmetic' stamp: 'len 6/28/2016 07:29'!
inverse
	"Answer the compositive inverse of the receiver."

	| answer |
	answer _ self species new.
	self changesDo: [:each| answer at: (self at: each) put: each].
	^ answer! !

!Permutation methodsFor: 'testing' stamp: 'len 6/29/2016 00:25'!
is: aSymbol
	^ aSymbol == #Permutation or: [super is: aSymbol]! !

!Permutation methodsFor: 'testing' stamp: 'len 5/6/98 05:03'!
isConjugateWith: aPermutation
	"Answer true if the receiver and the argument are conjugate."

	^ self type = aPermutation type! !

!Permutation methodsFor: 'testing' stamp: 'len 9/28/97 01:16'!
isCycle
	"Answer true if the receiver is a cycle."

	^ self cycles size = 1! !

!Permutation methodsFor: 'testing' stamp: 'len 6/28/2016 07:40'!
isIdentity
	"Answer true if the receiver is the identity permutation."

	^ self changes size = 0! !

!Permutation methodsFor: 'testing' stamp: 'len 9/28/97 01:17'!
isTransposition
	"Answer true if the receiver is a transposition."

	^ self size = 2! !

!Permutation methodsFor: 'arithmetic' stamp: 'len 8/25/2016 00:36'!
leftInverse
	^ self inverse! !

!Permutation methodsFor: 'accessing-private' stamp: 'len 5/6/98 04:50'!
map
	^ map! !

!Permutation methodsFor: 'accessing-private' stamp: 'len 6/28/2016 07:13'!
map: aCollection
	map _ aCollection! !

!Permutation methodsFor: 'testing' stamp: 'len 10/1/97 19:08'!
odd
	"Answer true if the receiver is odd."

	^ self sign = -1! !

!Permutation methodsFor: 'arithmetic' stamp: 'len 11/25/2015 04:34'!
one
	^ self identity! !

!Permutation methodsFor: 'accessing' stamp: 'len 6/28/2016 09:49'!
order
	self isIdentity ifTrue: [^ 1].
	^ self cycles inject: 1 into: [:last :each| last lcm: each order]! !

!Permutation methodsFor: 'accessing' stamp: 'len 6/28/2016 09:47'!
order2
	| answer next |
	answer _ 1.
	next _ self.
	[next isIdentity] whileFalse: [next _ next * self. answer _ answer + 1].
	^ answer! !

!Permutation methodsFor: 'operations' stamp: 'len 7/4/2016 03:04'!
permute: anArray
	"Answer the permutation of the elements of anArray induced by the receiver."
	| answer |
	answer _ Array new: anArray size.
	1 to: anArray size do: [:i| answer at: i put: (anArray at: (self at: i))].
	^ answer! !

!Permutation methodsFor: 'printing' stamp: 'len 10/1/97 18:59'!
printOn: aStream
	"Print a representation of the receiver on the stream aStream."

	self isIdentity
		ifTrue: [aStream nextPutAll: 'id']
		ifFalse: [self cyclesDo: [ :each | each printOn: aStream]]! !

!Permutation methodsFor: 'arithmetic' stamp: 'len 4/30/98 04:24'!
reciprocal
	"Answer the multiplication inverse of the receiver."

	^ self inverse! !

!Permutation methodsFor: 'arithmetic' stamp: 'len 8/25/2016 00:36'!
rightInverse
	^ self inverse! !

!Permutation methodsFor: 'accessing' stamp: 'len 10/1/97 19:00'!
sign
	"Answer the sign of the receiver."

	| answer |
	answer _ 1.
	self cyclesDo: [ :each | answer _ answer * each sign].
	^ answer

	"^ self transpositions size even ifTrue: [1] ifFalse: [-1]"! !

!Permutation methodsFor: 'private' stamp: 'len 9/29/97 19:14'!
species
	^ Permutation! !

!Permutation methodsFor: 'accessing' stamp: 'len 6/28/2016 07:04'!
transpositions
	"Answer the decomposition of the receiver in product of transpositions."

	| answer last value |
	answer _ OrderedCollection new.
	self changesDo: [:each|	
		last _ each.
		answer reverseDo: [:one| last _ one at: last].
		(value _ self at: each) = last
			ifFalse: [answer addFirst: (self species transpose: last with: value)]].
	^ answer! !

!Permutation methodsFor: 'accessing' stamp: 'len 4/27/98 21:03'!
type
	"Answer the type of the receiver."
	^ (self cycles asSortedCollection: [ :a :b | a size <= b size]) collect: [ :each | each size]! !

!Permutation methodsFor: 'operations' stamp: 'len 11/27/2015 23:13'!
value: anObject
	"Answer the value of the receiver at the argument."

	^ self at: anObject! !

!Permutation class methodsFor: 'instance creation' stamp: 'len 5/2/2016 04:11'!
cycle: aCollection
	| answer first last |
	answer _ PermutationCycle new.
	aCollection do: [:each|
		first isNil
			ifTrue: [first _ each]
			ifFalse: [answer at: last put: each].
		last _ each].
	answer at: last put: first.
	^ answer! !

!Permutation class methodsFor: 'instance creation' stamp: 'len 5/13/2016 02:31'!
cycles: anArray
	^ anArray inject: Permutation new into: [:answer :each| answer @ (self cycle: each)]! !

!Permutation class methodsFor: 'instance creation' stamp: 'len 7/4/2016 05:01'!
image: anArray
	^ StandardPermutation image: anArray! !

!Permutation class methodsFor: 'instance creation' stamp: 'len 6/28/2016 06:09'!
keys: anArray values: anotherArray
	| answer |
	answer _ self new.
	anArray with: anotherArray do: [:x :y| answer at: x put: y].
	^ answer! !

!Permutation class methodsFor: 'instance creation' stamp: 'len 6/28/2016 07:13'!
new
	"Answer a new instance of the receiver representing the identity permutation."
	^ super new map: Dictionary2 new! !

!Permutation class methodsFor: 'instance creation' stamp: 'len 7/4/2016 05:01'!
new: anInteger
	^ StandardPermutation image: (1 to: anInteger) asArray! !

!Permutation class methodsFor: 'instance creation' stamp: 'len 6/29/2016 00:38'!
new: n cycle: aCollection
	| answer first last |
	answer _ StandardPermutation new: n.
	aCollection do: [:each|
		first isNil
			ifTrue: [first _ each]
			ifFalse: [answer at: last put: each].
		last _ each].
	answer at: last put: first.
	^ answer! !

!Permutation class methodsFor: 'instance creation' stamp: 'len 6/29/2016 00:38'!
new: n cycles: anArray
	^ anArray inject: (self new: n) into: [:answer :each| answer @ (self new: n cycle: each)]! !

!Permutation class methodsFor: 'instance creation' stamp: 'len 5/16/2016 05:25'!
on: aSet evaluating: aBlock
	| answer |
	answer _ self new.
	aSet do: [:each| answer at: each put: (aBlock value: each)].
	^ answer! !

!Permutation class methodsFor: 'instance creation' stamp: 'len 5/2/2016 04:07'!
transpose: anObject with: anotherObject
	"Answer the tranposition of anObject with anotherObject."
	^ self new
		at: anObject put: anotherObject;
		at: anotherObject put: anObject;
		yourself! !

!PermutationCycle methodsFor: 'accessing' stamp: 'len 5/6/98 04:59'!
cycleAt: anObject
	"Answer the cycle generated by anObject."
	^ (self at: anObject) = anObject ifTrue: [self class new] ifFalse: [self]! !

!PermutationCycle methodsFor: 'accessing' stamp: 'len 5/2/2016 03:57'!
cycles
	"Answer the cycles of the receiver."
	^ {self}! !

!PermutationCycle methodsFor: 'iterating' stamp: 'len 5/2/2016 04:42'!
cyclesDo: aBlock
	"Iterate over the cycles of the receiver."
	aBlock value: self! !

!PermutationCycle methodsFor: 'testing' stamp: 'len 5/6/98 04:58'!
isCycle
	"Answer true if the receiver is a cycle."
	^ true! !

!PermutationCycle methodsFor: 'accessing' stamp: 'len 6/28/2016 09:43'!
order
	^ self changes size! !

!PermutationCycle methodsFor: 'printing' stamp: 'len 5/6/98 04:58'!
printOn: aStream
	"Print a representation of the receiver on the stream aStream.
	The receiver is supposed to be a cycle."

	| first last changes |
	self isIdentity ifTrue: [aStream nextPutAll: 'id'].
	changes _ self changes.
	first _ (changes detect: [ :one | one isInteger not] ifNone: []) isNil
			ifTrue: [changes asSortedCollection last] ifFalse: [self aChange].
	last _ first.
	aStream nextPut: $(.
	[aStream print: (last _ self at: last). last = first] whileFalse: [aStream space].
	aStream nextPut: $)! !

!PermutationCycle methodsFor: 'accessing' stamp: 'len 6/28/2016 08:40'!
sign
	"Answer the sign of the receiver."
	^ self changes size odd ifTrue: [1] ifFalse: [-1]! !

!PermutationCycle methodsFor: 'accessing' stamp: 'len 5/6/98 04:59'!
transpositions
	"Answer the decomposition of the receiver in product of transpositions."
	| answer first last |
	answer _ OrderedCollection new.
	first _ self aChange.
	last _ first.
	self size - 1 timesRepeat: [
		answer addFirst: (self species transpose: first with: (last _ self at: last))].
	^ answer! !

!StandardPermutation methodsFor: 'arithmetic' stamp: 'len 8/25/2016 00:54'!
* aPermutation
	"Answer the composition of the receiver with the argument."

	| otherMap newMap |
	(aPermutation class == self class and: [map size = aPermutation map size])
		ifFalse: [^ super @ aPermutation].
	otherMap _ aPermutation map.
	newMap _ Array new: map size.
	1 to: map size do: [:i|
		newMap at: i put: (otherMap at: (map at: i))]. 
	^ self class image: newMap! !

!StandardPermutation methodsFor: 'comparing' stamp: 'len 6/28/2016 08:55'!
= aPermutation
	(aPermutation isKindOf: self class) ifFalse: [^ super = aPermutation].
	^ map = aPermutation map! !

!StandardPermutation methodsFor: 'converting' stamp: 'len 6/28/2016 23:57'!
asPermutationIn: anArray
	^ self species keys: anArray values: (map collect: [:each| anArray at: each])! !

!StandardPermutation methodsFor: 'iterating' stamp: 'len 6/28/2016 07:35'!
changesDo: aBlock
	1 to: map size do: [:i| (map at: i) = i ifFalse: [aBlock value: i]]! !

!StandardPermutation methodsFor: 'accessing' stamp: 'len 6/29/2016 00:24'!
degree
	^ map size! !

!StandardPermutation methodsFor: 'accessing' stamp: 'len 8/31/2016 03:34'!
domain
	^ (1 to: map size) as: FormalSet! !

!StandardPermutation methodsFor: 'arithmetic' stamp: 'len 6/29/2016 00:24'!
identity
	"Answer the identity permutation."
	^ self class new: self degree! !

!StandardPermutation methodsFor: 'arithmetic' stamp: 'len 7/4/2016 05:02'!
inverse
	"Answer the compositive inverse of the receiver."
	| values |
	values _ map copy.
	1 to: map size do: [:i| values at: (map at: i) put: i].
	^ self class image: values! !

!StandardPermutation class methodsFor: 'instance creation' stamp: 'len 7/4/2016 06:34'!
image: anArray
	^ self basicNew map: anArray! !

!SemilinearMap methodsFor: 'accessing' stamp: 'len 2/9/2016 00:07'!
automorphism
	^ automorphism! !

!SemilinearMap methodsFor: 'accessing-private' stamp: 'len 2/9/2016 00:18'!
automorphism: aFieldAutomorphism
	automorphism _ aFieldAutomorphism! !

!SemilinearMap methodsFor: 'accessing' stamp: 'len 6/24/2016 21:36'!
bitSize
	^ matrix bitSize! !

!SemilinearMap methodsFor: 'accessing' stamp: 'len 2/9/2016 00:02'!
codomain
	^ self codomainBasis span! !

!SemilinearMap methodsFor: 'accessing' stamp: 'len 2/9/2016 00:17'!
codomainBasis
	^ codomainBasis! !

!SemilinearMap methodsFor: 'accessing-private' stamp: 'len 2/9/2016 00:18'!
codomainBasis: aLinearBasis
	codomainBasis _ aLinearBasis! !

!SemilinearMap methodsFor: 'accessing' stamp: 'len 2/9/2016 00:02'!
domain
	^ self domainBasis span! !

!SemilinearMap methodsFor: 'accessing' stamp: 'len 2/9/2016 00:18'!
domainBasis
	^ domainBasis! !

!SemilinearMap methodsFor: 'accessing-private' stamp: 'len 2/9/2016 00:18'!
domainBasis: aLinearBasis
	domainBasis _ aLinearBasis! !

!SemilinearMap methodsFor: 'accessing' stamp: 'len 2/9/2016 00:18'!
matrix
	"Answer the matrix associated to the receiver with respect to the chosen domain and codomain bases."
	^ matrix! !

!SemilinearMap methodsFor: 'accessing-private' stamp: 'len 2/9/2016 00:18'!
matrix: aMatrix
	matrix _ aMatrix! !

!SemilinearMap methodsFor: 'operations' stamp: 'len 2/27/2016 07:19'!
value: aVector
	^ codomainBasis
		vectorAt:
			matrix * ((domainBasis coordinatesOf: aVector) apply: automorphism)! !

!SemilinearMap class methodsFor: 'as yet unclassified' stamp: 'len 2/9/2016 00:10'!
automorphism: aFieldAutomorphism linearMap: aLinearMap
	^ self new automorphism: aFieldAutomorphism; linearMap: aLinearMap! !

!BilinearForm methodsFor: 'arithmetic' stamp: 'len 1/8/2016 05:07'!
* anObject
	^ self class from: basis matrix: matrix * anObject! !

!BilinearForm methodsFor: 'arithmetic' stamp: 'len 1/5/2016 03:07'!
+ aBilinearForm
	self domain = aBilinearForm domain ifFalse: [^ self error: 'domains don''t match'].
	^ self class
		from: self domain
		evaluating: [:each| (self value: each) + (aBilinearForm value: each)]! !

!BilinearForm methodsFor: 'converting' stamp: 'len 6/1/2016 20:04'!
asPolynomial
	| n P x y |
	n _ basis size.
	P _ self scalars polynomialsIn: ((1 to: n) collect: [:i| 'x' asText, i printString sub]), ((1 to: n) collect: [:i| 'y' asText, i printString sub]).
	x _ Tuple new: n evaluating: [:i| P x: i].
	y _ Tuple new: n evaluating: [:i| P x: n+i].
	^ x dot: matrix * y! !

!BilinearForm methodsFor: 'converting' stamp: 'len 6/8/2016 21:27'!
asQuadraticForm
	"Answer the associated quadratic form."
	^ QuadraticForm from: basis matrix: matrix! !

!BilinearForm methodsFor: 'accessing' stamp: 'len 1/8/2016 05:22'!
basis
	^ basis! !

!BilinearForm methodsFor: 'accessing-private' stamp: 'len 1/8/2016 05:11'!
basis: aLinearBasis
	basis _ aLinearBasis! !

!BilinearForm methodsFor: 'accessing' stamp: 'len 12/28/2015 21:09'!
bitSize
	^ matrix bitSize! !

!BilinearForm methodsFor: 'accessing' stamp: 'len 1/8/2016 06:36'!
codomain
	^ self scalars! !

!BilinearForm methodsFor: 'accessing' stamp: 'len 4/19/2016 03:39'!
domain
	| V |
	V _ basis span.
	^ (V, V)! !

!BilinearForm methodsFor: 'testing' stamp: 'len 1/8/2016 06:30'!
isAlternate
	"A bilinear form B is called 'alternate' if B(v,v) = 0 for all v."
	matrix isSkewSymmetric ifFalse: [^ false].
	matrix diagonalDo: [:each| each isZero ifFalse: [^ false]].
	^ true! !

!BilinearForm methodsFor: 'testing' stamp: 'len 1/8/2016 06:30'!
isAlternating
	"A bilinear form B is called 'alternating' if B(v,v) = 0 for all v."
	matrix isSkewSymmetric ifFalse: [^ false].
	matrix diagonalDo: [:each| each isZero ifFalse: [^ false]].
	^ true! !

!BilinearForm methodsFor: 'testing' stamp: 'len 1/8/2016 06:25'!
isNonDegenerate
	"A bilinear form B is called 'non-degenerate' if B(v,w) = 0 for all w implies v = 0.
	B is non-degenerate iff the left and right radicals are trivial."
	^ self rank = self domain dimension! !

!BilinearForm methodsFor: 'testing' stamp: 'len 1/7/2016 23:40'!
isReflexive
	"A bilinear form B is called 'reflexive' if B(v,w) = 0 implies B(w,v) = 0 for all v,w."
	^ self isSymmetric or: [self isAlternating]! !

!BilinearForm methodsFor: 'testing' stamp: 'len 1/8/2016 06:30'!
isSkewSymmetric
	"A bilinear form B is called 'skew-symmetric' if B(v,w) = -B(w,v) for all v,w."
	^ matrix isSkewSymmetric! !

!BilinearForm methodsFor: 'testing' stamp: 'len 1/8/2016 06:30'!
isSymmetric
	"A bilinear form B is called 'symmetric' if B(v,w) = B(w,v) for all v,w."
	^ matrix isSymmetric! !

!BilinearForm methodsFor: 'operations' stamp: 'len 10/4/2016 12:27'!
left
	"Answer the linear map from the domain to its dual that fixes the right argument. If the bilinear form is non-degenerate, this map is an isomorphism."
	| V Vdual |
	V _ self domain at: 1.
	Vdual _ V dual.
	^ V to: Vdual evaluating: [:v| Vdual evaluating: [:w| self value: w value: v]]! !

!BilinearForm methodsFor: 'operations' stamp: 'len 1/8/2016 06:06'!
leftRadical
	^ self left kernel! !

!BilinearForm methodsFor: 'accessing' stamp: 'len 11/7/2015 23:26'!
matrix
	^ matrix! !

!BilinearForm methodsFor: 'accessing-private' stamp: 'len 8/23/97 15:35'!
matrix: aMatrix
	matrix _ aMatrix! !

!BilinearForm methodsFor: 'arithmetic' stamp: 'len 1/8/2016 05:08'!
negated
	^ self class from: basis matrix: matrix negated! !

!BilinearForm methodsFor: 'printing' stamp: 'len 6/1/2016 20:01'!
printOn: aStream
	basis size = basis ambient dimension
		ifTrue: [(self class
					fromHalf: basis ambient
					evaluating: [:each| self value: each]) asPolynomial
						printOn: aStream]
		ifFalse: [aStream print: self asPolynomial; nextPutAll: ' | '; print: self domain]! !

!BilinearForm methodsFor: 'operations' stamp: 'len 1/8/2016 06:29'!
rank
	^ matrix rank! !

!BilinearForm methodsFor: 'operations' stamp: 'len 10/4/2016 12:27'!
right
	"Answer the linear map from the domain to its dual that fixes the left argument. If the bilinear form is non-degenerate, this map is an isomorphism."
	| V Vdual |
	V _ self domain at: 2.
	Vdual _ V dual.
	^ V to: Vdual evaluating: [:v| Vdual evaluating: [:w| self value: v value: w]]! !

!BilinearForm methodsFor: 'operations' stamp: 'len 1/8/2016 06:06'!
rightRadical
	^ self right kernel! !

!BilinearForm methodsFor: 'accessing' stamp: 'len 5/23/2016 04:34'!
scalars
	^ basis ambient scalars! !

!BilinearForm methodsFor: 'operations' stamp: 'len 1/8/2016 05:09'!
skewSymmetricPart
	| two |
	two _ self scalars one * 2.
	^ self class
		from: basis
		matrix: matrix - matrix transposed / two! !

!BilinearForm methodsFor: 'operations' stamp: 'len 1/8/2016 05:09'!
symmetricPart
	| two |
	two _ self scalars one * 2.
	^ self class
		from: basis
		matrix: matrix + matrix transposed / two! !

!BilinearForm methodsFor: 'operations' stamp: 'len 1/8/2016 06:29'!
transposed
	"The transposed of a bilinear form B(x,y) is B(y,x)."
	^ self class from: basis matrix: matrix transposed! !

!BilinearForm methodsFor: 'operations' stamp: 'len 11/30/2015 05:59'!
value: anArray
	self assert: anArray size = 2.
	^ self value: anArray first value: anArray second! !

!BilinearForm methodsFor: 'operations' stamp: 'len 3/28/2016 01:22'!
value: anObject value: anotherObject
	| left right |
	left _ basis coordinatesOf: anObject.
	right _ basis coordinatesOf: anotherObject.
	^ left dot: (matrix * right)! !

!BilinearForm class methodsFor: 'instance creation' stamp: 'len 1/8/2016 23:08'!
from: aCartesianProduct evaluating: aBlock 
	| V basis matrix n |
	V _ aCartesianProduct components first.
	basis _ V basis.
	n _ basis size.
	matrix _ V scalars ** (n@n)
					evaluating: [:i :j|
						aBlock value: {(basis at: i). (basis at: j)}].
	^ self from: basis matrix: matrix! !

!BilinearForm class methodsFor: 'instance creation' stamp: 'len 1/8/2016 05:11'!
from: aLinearBasis matrix: aMatrix
	"Answer a new instance of the receiver representing the bilinear form associated to aMatrix in the given bases."
	^ self new basis: aLinearBasis; matrix: aMatrix! !

!BilinearForm class methodsFor: 'instance creation' stamp: 'len 1/8/2016 18:27'!
fromHalf: aVectorSpace evaluating: aBlock 
	| basis matrix n |
	basis _ aVectorSpace basis.
	n _ basis size.
	matrix _ aVectorSpace scalars ** (n@n)
					evaluating: [:i :j|
						aBlock value: {(basis at: i). (basis at: j)}].
	^ self from: basis matrix: matrix! !

!Sequence methodsFor: 'operations' stamp: 'len 12/24/2015 02:59'!
<< anInteger
	^ self shift: anInteger negated! !

!Sequence methodsFor: 'operations' stamp: 'len 12/24/2015 02:59'!
>> anInteger
	^ self shift: anInteger! !

!Sequence methodsFor: 'accessing' stamp: 'len 10/10/2016 14:06'!
at: anInteger
	^ anInteger >= 0 ifTrue: [super value: anInteger]! !

!Sequence methodsFor: 'operations' stamp: 'len 12/27/2015 02:11'!
average
	^ self species to: self codomain evaluating: [:N| ((1 to: N) sum: [:n| self at: n]) / N]! !

!Sequence methodsFor: 'comparing' stamp: 'len 12/5/2015 01:11'!
beginsWith: aSequenceableCollection
	1 to: aSequenceableCollection size do: [:i| (self at: i) = (aSequenceableCollection at: i) ifFalse: [^ false]].
	^ true! !

!Sequence methodsFor: 'series' stamp: 'len 12/29/2015 04:25'!
bellSeries: p
	^ PowerSeries coefficients: (self species to: self codomain evaluating: [:n| self at: p**(n-1)])! !

!Sequence methodsFor: 'operations' stamp: 'len 8/6/2016 00:53'!
binomialTransform
	"The binomial transform is its own inverse, it's an involution."
	^ self species to: self codomain evaluating: [:n| (0 to: n) sum: [:k| (-1)**(n-k) * (n take: k) * (self at: k)]]! !

!Sequence methodsFor: 'operations' stamp: 'len 12/27/2015 02:10'!
binomialTransform2
	^ self species to: self codomain evaluating: [:n| (0 to: n) sum: [:k| (n take: k) * (self at: k)]]! !

!Sequence methodsFor: 'accessing' stamp: 'len 7/15/2016 18:29'!
codomain
	^ properties at: #codomain ifAbsent: [ZZ]! !

!Sequence methodsFor: 'iterating' stamp: 'len 12/3/2015 20:34'!
collect: aBlock
	^ self species evaluating: [:i| aBlock value: (self at: i)]! !

!Sequence methodsFor: 'operations' stamp: 'len 12/28/2015 19:24'!
convolution: aSequence
	^ self species to: self codomain evaluating: [:n| (0 to: n-1) sum: [:i| (self at: self startIndex + i) * (aSequence at: aSequence startIndex+n-1-i)]]! !

!Sequence methodsFor: 'copying' stamp: 'len 12/4/2015 00:55'!
copyFrom: start to: end
	end isInfinity
		ifTrue: [^ self shift: 1 - start].
	^ (start to: end) collect: [:i| self at: i]! !

!Sequence methodsFor: 'iterating' stamp: 'len 4/25/2016 07:08'!
count: aBlock
	^ (self collect: [:each| (aBlock value: each) ifTrue: [1] ifFalse: [0]]) sum! !

!Sequence methodsFor: 'operations' stamp: 'len 8/15/2016 18:28'!
difference
	"Answer the 'difference' sequence of the receiver, or delta, or discrete derivative."
	^ (self shift: -1) - self! !

!Sequence methodsFor: 'operations' stamp: 'len 12/27/2015 02:11'!
dirichlet: aSequence
	"Answer the Dirichlet convolution of the receiver with the argument, assuming both are arithmetic functions (i.e. functions from the natural numbers to the complex numbers).
	The set of arithmetic functions form a commutative ring (the Dirichlet ring) under pointwise addition and Dirichlet convolution."
	^ self species to: self codomain evaluating: [:n| n divisors sum: [:d| (self at: d) * (aSequence at: n/d)]]! !

!Sequence methodsFor: 'series' stamp: 'len 12/29/2015 04:25'!
dirichletSeries
	"Answer the Dirichlet series generating function of the receiver."
	^ DirichletSeries coefficients: self! !

!Sequence methodsFor: 'iterating' stamp: 'len 12/27/2015 03:45'!
do: aBlock
	1 to: self size do: [:each| aBlock value: (self at: each)]! !

!Sequence methodsFor: 'accessing' stamp: 'len 7/15/2016 18:21'!
domain
	^ properties at: #domain ifAbsent: [NN]! !

!Sequence methodsFor: 'comparing' stamp: 'len 12/27/2015 01:29'!
equals: aSequence upTo: n
	^ self beginsWith: (aSequence copyFrom: 1 to: n)! !

!Sequence methodsFor: 'series' stamp: 'len 12/29/2015 04:25'!
exponentialSeries
	"Answer the exponential generating function of the receiver."
	^ PowerSeries coefficients: (self species to: self codomain evaluating: [:n| (self at: n) / (n-1) factorial])! !

!Sequence methodsFor: 'copying' stamp: 'len 4/20/2016 21:25'!
first: n
	^ self copyFrom: 1 to: n! !

!Sequence methodsFor: 'series' stamp: 'len 12/29/2015 04:26'!
generatingSeries
	"Answer the ordinary generating function of the receiver."
	^ self ordinaryGeneratingSeries! !

!Sequence methodsFor: 'comparing' stamp: 'len 12/27/2015 03:56'!
hash
	^ (self at: 1) hash + (self at: 3) hash + (self at: 5) hash! !

!Sequence methodsFor: 'printing' stamp: 'len 4/25/2016 07:23'!
lookup
	^ OEIS default lookup: self! !

!Sequence methodsFor: 'operations' stamp: 'len 12/27/2015 02:11'!
moebiusInverse
	"This is equivalent to the Dirichlet convolution of the Moebius arithmetic function with the receiver.
	If f(n) and g(n) are two arithmetic functions satisfying g = f * 1 (Dirichlet convolution of f with the constant function 1), then the Moebius inversion formula can be used to retrieve f as f = mu * g. It is said that f and g and Moebius transforms of each other."
	^ self species to: self codomain evaluating: [:n| n divisors sum: [:d| d moebius * (self at: n/d)]]! !

!Sequence methodsFor: 'series' stamp: 'len 12/29/2015 04:26'!
ordinaryGeneratingSeries
	"Answer the ordinary generating function of the receiver."
	^ PowerSeries coefficients: self! !

!Sequence methodsFor: 'operations' stamp: 'len 7/17/2016 23:23'!
pointwiseProduct: aSequence
	^ self class evaluating: [:i| (self at: i) * (aSequence at: i)]! !

!Sequence methodsFor: 'printing' stamp: 'len 4/26/2016 06:42'!
printLimit
	^ properties at: #printLimit ifAbsent: [17]! !

!Sequence methodsFor: 'printing' stamp: 'len 4/26/2016 06:42'!
printLimit: anInteger
	properties at: #printLimit put: anInteger! !

!Sequence methodsFor: 'printing' stamp: 'len 8/6/2016 00:59'!
printOn: aStream
	(self startIndex to: self printLimit) do: [:i| aStream print: (self at: i)] separatedBy: [aStream nextPutAll:', ' ].
	aStream nextPutAll: '...'! !

!Sequence methodsFor: 'printing' stamp: 'len 4/26/2016 06:46'!
printOn: aStream base: base
	(1 to: self printLimit) do: [:i| (self at: i) printOn: aStream base: base] separatedBy: [aStream nextPutAll:', ' ].
	aStream nextPutAll: '...'! !

!Sequence methodsFor: 'printing' stamp: 'len 4/26/2016 06:47'!
printStringBase: base
	^ String streamContents:
		[:aStream| self printOn: aStream base: base]! !

!Sequence methodsFor: 'operations' stamp: 'len 12/27/2015 19:48'!
product
	"Answer the indefinite product of the receiver."
	^ self species to: self codomain evaluating: [:i| (1 to: i) collect: [:k| self at: k] andFold: [:a :b| a*b]]! !

!Sequence methodsFor: 'converting' stamp: 'len 4/24/2016 04:55'!
readStream
	^ ReadStream on: self! !

!Sequence methodsFor: 'iterating' stamp: 'len 12/3/2015 23:16'!
select: aBlock
	^ self species evaluating: [:i|
		| k j value |
		k _ 1.
		j _ 1.
		[[aBlock value: (value _ self at: k)] whileFalse: [k _ k + 1]. j < i] whileTrue: [j _ j + 1. k _ k + 1].
		value]! !

!Sequence methodsFor: 'operations' stamp: 'len 12/27/2015 02:12'!
shift: anInteger
	^ self species to: self codomain evaluating: [:i| self at: i-anInteger]! !

!Sequence methodsFor: 'accessing' stamp: 'len 4/24/2016 03:00'!
size
	^ properties at: #size ifAbsent: [Aleph new]! !

!Sequence methodsFor: 'private' stamp: 'len 12/3/2015 20:34'!
species
	^ Sequence! !

!Sequence methodsFor: 'accessing' stamp: 'len 12/27/2015 01:44'!
startIndex
	^ properties at: #startIndex ifAbsent: [1]! !

!Sequence methodsFor: 'private' stamp: 'len 8/6/2016 00:58'!
startIndex: anInteger
	properties at: #startIndex put: anInteger! !

!Sequence methodsFor: 'operations' stamp: 'len 12/27/2015 02:12'!
stirlingInverseTransform
	^ self species to: self codomain evaluating: [:n| (1 to: n) sum: [:k| (n stirling: k) * (self at: k)]]! !

!Sequence methodsFor: 'operations' stamp: 'len 12/27/2015 02:12'!
stirlingTransform
	^ self species to: self codomain evaluating: [:n| (1 to: n) sum: [:k| (n Stirling: k) * (self at: k)]]! !

!Sequence methodsFor: 'operations' stamp: 'len 12/27/2015 19:48'!
sum
	"Answer the indefinite sum of the receiver."
	^ self species to: self codomain evaluating: [:i| (1 to: i) sum: [:k| self at: k]]! !

!Sequence methodsFor: 'evaluating' stamp: 'len 12/4/2015 04:00'!
value: aNumber
	^ self at: aNumber asInteger! !

!Sequence methodsFor: 'iterating' stamp: 'len 3/27/2016 04:44'!
withIndexDo: aBlock
	| i |
	i _ 1.
	self do: [:each| aBlock value: each value: i. i _ i + 1]! !

!Sequence class methodsFor: 'examples' stamp: 'len 12/4/2015 01:53'!
Omega
	"Number of prime divisors of n counted with multiplicity. A001222."
	^ Sequence evaluating: [:n| n factors size]! !

!Sequence class methodsFor: 'examples' stamp: 'len 12/4/2015 22:50'!
aliquot
	"Answer the a(n) or s(n) function that is the sum of the proper divisors of n (aliquot parts of n).
	If a(n) = n, n is a perfect number. If a(n) = n - 1, it is almost perfect. If a(n) > n, it is an abundant number."
	^ Sequence evaluating: [:n| n divisors sum - n]! !

!Sequence class methodsFor: 'examples' stamp: 'len 4/16/2016 19:33'!
bbs: s p: p q: q
	"Answer the Blum Blum Shub sequence for the given parameters."
	| lambda m |
	lambda _ p - 1 lcm: q - 1.
	m _ p * q.
	^ self evaluating: [:i| s raisedTo: (2 raisedTo: i modulo: lambda) modulo: m]! !

!Sequence class methodsFor: 'examples' stamp: 'len 8/6/2016 00:58'!
bellNumbers
	^ (Sequence evaluating: [:n| (0 to: n) sum: [:k| n Stirling: k]]) startIndex:0! !

!Sequence class methodsFor: 'examples' stamp: 'len 7/15/2016 18:38'!
calkinWilf
	"Sequence that enumerates the positive rational numbers by a breadth-first traversal of the Calkin-Wilf tree."
	^ Sequence
		to: QQ
		evaluating:
			[:n| | q |
			q _ 1.
			n-1 timesRepeat: [q _ 1 / (2 * q floor - q + 1)].
			q]! !

!Sequence class methodsFor: 'examples' stamp: 'len 12/4/2015 01:10'!
catalanNumbers
	^ Sequence evaluating: [:n| (2*(n-1) take: n-1) / n]! !

!Sequence class methodsFor: 'intance creation' stamp: 'len 7/15/2016 18:29'!
constant: anInteger
	anInteger isInteger
		ifFalse: [^ DomainError signal: 'argument is not integer'].
	^ self to: ZZ constant: anInteger! !

!Sequence class methodsFor: 'intance creation' stamp: 'len 7/15/2016 18:29'!
dynamic: aBlock
	^ self to: ZZ dynamic: aBlock! !

!Sequence class methodsFor: 'intance creation' stamp: 'len 7/15/2016 18:30'!
evaluating: aBlock
	^ self to: ZZ evaluating: aBlock! !

!Sequence class methodsFor: 'examples' stamp: 'len 7/6/2016 23:52'!
fibonacci
	^ Sequence recurrence: [:f :n| n=1 ifTrue: [0] ifFalse: [n=2 ifTrue: [1] ifFalse: [(f at: n-1) + (f at: n-2)]]]! !

!Sequence class methodsFor: 'examples' stamp: 'len 7/15/2016 18:38'!
harmonicNumbers
	^ Sequence to: QQ evaluating: [:n| (1 to: n) sum: [:k| 1/k]]! !

!Sequence class methodsFor: 'examples' stamp: 'len 7/17/2016 22:10'!
hensel: aPolynomial at: anIntegerRoot mod: p
	"Answer the p-adic expansion by Hensel lemma."
	| x |
	x _ aPolynomial species x.
	^ self recurrence:
		[:f :n|
		n = 1
			ifTrue: [anIntegerRoot]
			ifFalse:
				[| g a |
				g _ (f at: n-1) + (p**(n-1) * x).
				a _ (aPolynomial value: g % (p**n)) roots anyOne representative.
				(g value: a) \\ (p**n)]]! !

!Sequence class methodsFor: 'examples' stamp: 'len 7/6/2016 23:45'!
highlyCompositeNumbers
	^ self recurrence: [:f :n| | i max |
		n = 1
			ifTrue: [1]
			ifFalse:
				[i _ f at: n-1.
				max _ i numberOfDivisors.
				[(i _ i + 1) numberOfDivisors > max] whileFalse. i]]! !

!Sequence class methodsFor: 'examples' stamp: 'len 12/5/2015 00:20'!
id
	^ Sequence evaluating: [:n| n]! !

!Sequence class methodsFor: 'examples' stamp: 'len 12/4/2015 01:53'!
liouville
	"Answer the Liouville function."
	| Omega |
	Omega _ Sequence Omega.
	^ Sequence evaluating: [:n| (-1) ** (Omega at: n)]! !

!Sequence class methodsFor: 'examples' stamp: 'len 12/8/2015 01:09'!
mangoldt
	"Answer the von Mangoldt function (float)."
	^ Sequence evaluating: [:n| | factors | factors _ n factors. factors asSet size = 1 ifTrue: [factors anyOne ln] ifFalse: [0]]! !

!Sequence class methodsFor: 'examples' stamp: 'len 12/5/2015 04:53'!
mangoldt2
	"Answer the log2 von Mangoldt function."
	^ Sequence evaluating: [:n| | factors | factors _ n factors. factors asSet size = 1 ifTrue: [factors anyOne highBit] ifFalse: [0]]! !

!Sequence class methodsFor: 'examples' stamp: 'len 12/4/2015 01:54'!
moebius
	^ Sequence evaluating: [:n| n moebius]! !

!Sequence class methodsFor: 'examples' stamp: 'len 12/4/2015 01:54'!
omega
	"Number of distinct primes dividing n. A001221."
	^ Sequence evaluating: [:n| n factors asSet size]! !

!Sequence class methodsFor: 'examples' stamp: 'len 12/5/2015 01:13'!
one
	^ self constant: 1! !

!Sequence class methodsFor: 'examples' stamp: 'len 7/2/2016 21:03'!
partitions
	"Answer the partition function p(n) = number of partition of n. OEIS A000041."
	^ self evaluating: [:n| n partitions size]! !

!Sequence class methodsFor: 'examples' stamp: 'len 12/4/2015 23:30'!
phi
	"Answer Euler's totient function."
	^ self evaluating: [:a| (1 to: a) count: [:b| (a gcd: b) = 1]]! !

!Sequence class methodsFor: 'examples' stamp: 'len 8/15/2016 18:29'!
primeGaps
	| p |
	p _ 2.
	^ Sequence streamming: [p negated + (p _ p nextPrime)]
"	^ Sequence primes difference"! !

!Sequence class methodsFor: 'examples' stamp: 'len 4/27/2016 20:52'!
primes
	^ Sequence recurrence: [:f :i| i = 1 ifTrue: [2] ifFalse: [(f at: i-1) nextPrime]]
"	^ Sequence evaluating: [:i|
		| n count |
		n _ 2.
		count _ 1.
		[count = i] whileFalse: [n _ n nextPrime. count _ count + 1].
		n]"! !

!Sequence class methodsFor: 'intance creation' stamp: 'len 7/15/2016 18:30'!
recurrence: aBinaryBlock
	^ self to: ZZ recurrence: aBinaryBlock! !

!Sequence class methodsFor: 'examples' stamp: 'len 12/4/2015 22:39'!
sigma
	"Answer the sigma(n) function, i.e. the sum of the positive divisors of n.
	The number n is said to be a perfect number iff sigma(n) = 2*n."
	^ Sequence evaluating: [:n| n divisors sum]! !

!Sequence class methodsFor: 'examples' stamp: 'len 12/4/2015 22:44'!
sigma: x
	"Answer the sigma(x,n) function."
	^ Sequence evaluating: [:n| n divisors sum: [:d| d**x]]! !

!Sequence class methodsFor: 'intance creation' stamp: 'len 7/15/2016 18:30'!
streamming: aBlock
	^ self to: ZZ streamming: aBlock! !

!Sequence class methodsFor: 'examples' stamp: 'len 12/4/2015 01:54'!
tau
	"Number of divisors of n, also called d(n) and sigma_O(n). A000005."
	^ Sequence evaluating: [:n| n divisors size]! !

!Sequence class methodsFor: 'intance creation' stamp: 'len 4/19/2016 21:42'!
to: aDomain constant: anObject
	^ self to: aDomain evaluating: [:n| anObject]! !

!Sequence class methodsFor: 'intance creation' stamp: 'len 5/11/2016 23:16'!
to: aDomain dynamic: aBlock
	^ self to: aDomain evaluating:
			[:n| | x |
			x _ 0.
			n timesRepeat: [x _ aBlock value: x].
			x]! !

!Sequence class methodsFor: 'intance creation' stamp: 'len 7/15/2016 18:21'!
to: aDomain evaluating: aBlock
	^ self from: NN to: aDomain evaluating: aBlock! !

!Sequence class methodsFor: 'intance creation' stamp: 'len 7/6/2016 23:51'!
to: aDomain recurrence: aBlock
	| cache |
	cache _ OrderedCollection new.
	^ self to: aDomain evaluating:
			[:n|
			"(n isInteger and: [n > 0]) ifFalse: [DomainError signal]."
			[cache size < n] whileTrue: [cache add: (aBlock value: cache value: cache size + 1)].
			cache at: n]! !

!Sequence class methodsFor: 'intance creation' stamp: 'len 7/6/2016 23:51'!
to: aDomain streamming: aBlock
	| cache |
	cache _ OrderedCollection new.
	^ self to: aDomain evaluating:
			[:n|
			"(n isInteger and: [n > 0]) ifFalse: [DomainError signal]."
			[cache size < n] whileTrue: [cache add: aBlock value].
			cache at: n]! !

!LinearRecursiveSequence methodsFor: 'operations' stamp: 'len 12/24/2015 03:35'!
* anObject
	(anObject isKindOf: self class)
		ifTrue: [^ self class to: self codomain evaluating: super * anObject maxOrder: self order * anObject order].
	(self codomain includes: anObject)
		ifTrue: [^ self class to: self codomain evaluating: super * anObject maxOrder: self order].
	^ super * anObject! !

!LinearRecursiveSequence methodsFor: 'operations' stamp: 'len 12/24/2015 03:29'!
+ aSequence
	(aSequence isKindOf: self class) ifFalse: [^ super + aSequence].
	^ self class to: self codomain evaluating: super + aSequence maxOrder: self order + aSequence order! !

!LinearRecursiveSequence methodsFor: 'comparing' stamp: 'len 8/6/2016 00:41'!
= aSequence
	| f g |
	(aSequence isKindOf: LinearRecursiveSequence)
		ifFalse: [^ super = aSequence].
	f _ self minimal.
	g _ aSequence minimal.
	^ f coefficients = g coefficients and: [f initialValues = g initialValues]! !

!LinearRecursiveSequence methodsFor: 'accessing' stamp: 'len 4/11/2016 23:07'!
at: n
	self order = 0 ifTrue: [^ self codomain zero].
	n <= initialValues size ifTrue: [^ initialValues at: n].
	^ (self matrix ** (n - self order) * initialValues) last
"	answer _ 0.
	1 to: self order do: [:i |
		answer _ (self at: n - self order + i - 1) * (coefficients at: i) + answer].
	^ answer"! !

!LinearRecursiveSequence methodsFor: 'accessing' stamp: 'len 12/27/2015 01:41'!
characteristicPolynomial
	^ self codomain polynomials coefficients: (coefficients negated copyWith: self codomain one)! !

!LinearRecursiveSequence methodsFor: 'accessing' stamp: 'len 12/27/2015 03:49'!
coefficients
	^ coefficients! !

!LinearRecursiveSequence methodsFor: 'accessing-private' stamp: 'len 12/3/2015 23:02'!
coefficients: anArray
	coefficients _ anArray! !

!LinearRecursiveSequence methodsFor: 'operations' stamp: 'len 12/24/2015 03:28'!
convolution: aSequence
	(aSequence isKindOf: self class) ifFalse: [^ super convolution: aSequence].
	^ self class to: self codomain evaluating: (super convolution: aSequence) maxOrder: self order * aSequence order! !

!LinearRecursiveSequence methodsFor: 'series' stamp: 'len 3/23/2016 00:02'!
generatingFunction
	| r s |
	"Answer the generating function of the receiver, which is a rational function that equals its ordinary generating series."
	s _ self characteristicPolynomial reversed.
	r _ self codomain polynomials coefficients:
		((0 to: self order - 1) collect: [:j|
			(self at: j+1) - ((1 to: j) sum: [:i| (s coefficientAtDegree: i) * (self at: j-i+1)])]).
	^ RationalFunction numerator: r denominator: s! !

!LinearRecursiveSequence methodsFor: 'accessing' stamp: 'len 12/27/2015 03:49'!
initialValues
	^ initialValues! !

!LinearRecursiveSequence methodsFor: 'accessing-private' stamp: 'len 12/29/2015 02:16'!
initialValues: anArray
	initialValues _ anArray.
	(initialValues isKindOf: Tuple) ifFalse: [initialValues _ Tuple withAll: initialValues]! !

!LinearRecursiveSequence methodsFor: 'testing' stamp: 'len 12/27/2015 02:08'!
isMinimal
	^ self minimalPolynomial = self characteristicPolynomial! !

!LinearRecursiveSequence methodsFor: 'testing' stamp: 'len 4/11/2016 23:10'!
isZero
	^ self minimal order = 0! !

!LinearRecursiveSequence methodsFor: 'accessing' stamp: 'len 12/30/2015 04:03'!
matrix
	^ properties at: #matrix ifAbsentPut: [self characteristicPolynomial companion transposed]! !

!LinearRecursiveSequence methodsFor: 'operations' stamp: 'len 12/27/2015 19:17'!
minimal
	^ properties at: #minimal ifAbsentPut: [self class to: self codomain evaluating: self maxOrder: self order]! !

!LinearRecursiveSequence methodsFor: 'accessing' stamp: 'len 12/27/2015 02:08'!
minimalPolynomial
	^ self minimal characteristicPolynomial! !

!LinearRecursiveSequence methodsFor: 'operations' stamp: 'len 12/24/2015 03:31'!
negated
	^ self class to: self codomain evaluating: super negated maxOrder: self order! !

!LinearRecursiveSequence methodsFor: 'accessing' stamp: 'len 12/28/2015 23:45'!
order
	^ coefficients size! !

!LinearRecursiveSequence methodsFor: 'printing' stamp: 'len 12/27/2015 01:25'!
printLimit
	^ self order + 10 min: super printLimit! !

!LinearRecursiveSequence methodsFor: 'operations' stamp: 'len 12/27/2015 01:54'!
shift: anInteger
	anInteger > 0 ifTrue: [^ super shift: anInteger].
	^ self class to: self codomain evaluating: (super shift: anInteger) maxOrder: self order squared! !

!LinearRecursiveSequence methodsFor: 'operations' stamp: 'len 12/24/2015 03:39'!
squared
	| n |
	n _ self order.
	^ self class to: self codomain evaluating: super squared maxOrder: n*(n-1)/2! !

!LinearRecursiveSequence methodsFor: 'accessing' stamp: 'len 12/27/2015 01:44'!
startIndex
	^ 1! !

!LinearRecursiveSequence methodsFor: 'operations' stamp: 'len 12/27/2015 19:49'!
sum
	"Answer the indefinite sum of the receiver."
	^ self class to: self codomain evaluating: super sum maxOrder: self order squared! !

!LinearRecursiveSequence class methodsFor: 'examples' stamp: 'len 12/27/2015 03:42'!
fibonacci
	^ LinearRecursiveSequence initialValues: #(0 1) coefficients: #(1 1)! !

!LinearRecursiveSequence class methodsFor: 'examples' stamp: 'len 7/15/2016 18:34'!
geometric: aNumber
	(aNumber isInteger or: [aNumber isFraction])
		ifFalse: [^ DomainError signal: 'argument is not rational'].
	^ self to: QQ initialValues: #(1) coefficients: {aNumber}! !

!LinearRecursiveSequence class methodsFor: 'examples' stamp: 'len 7/15/2016 18:34'!
identity
	^ self to: QQ initialValues: #(1 2) coefficients: #(-1 2)! !

!LinearRecursiveSequence class methodsFor: 'instance creation' stamp: 'len 7/15/2016 18:27'!
initialValues: anArray coefficients: anotherArray
	^ self to: ZZ initialValues: anArray coefficients: anotherArray! !

!LinearRecursiveSequence class methodsFor: 'examples' stamp: 'len 12/24/2015 03:01'!
jacobsthalNumbers
	^ LinearRecursiveSequence initialValues: #(0 1) coefficients: #(2 1)! !

!LinearRecursiveSequence class methodsFor: 'examples' stamp: 'len 12/24/2015 03:01'!
lucasNumbers
	^ LinearRecursiveSequence initialValues: #(2 1) coefficients: #(1 1)! !

!LinearRecursiveSequence class methodsFor: 'examples' stamp: 'len 12/24/2015 03:01'!
pellNumbers
	^ LinearRecursiveSequence initialValues: #(0 1) coefficients: #(1 2)! !

!LinearRecursiveSequence class methodsFor: 'instance creation' stamp: 'len 12/27/2015 19:42'!
to: codomain constant: anObject
	^ self to: codomain initialValues: {anObject} coefficients: {anObject one}! !

!LinearRecursiveSequence class methodsFor: 'instance creation' stamp: 'len 8/6/2016 00:46'!
to: codomain evaluating: aBlock maxOrder: n
	| initialValues bm f |
	initialValues _ (1 to: 2*n) collect: aBlock.
	bm _ ModifiedBerlekampMassey new
		field: (codomain isField ifTrue: [codomain] ifFalse: [codomain fractions]);
		input: initialValues.
	f _ bm minimalPolynomial.
	^ self to: codomain initialValues: (initialValues copyFrom: 1 to: f degree) minimalPolynomial:f! !

!LinearRecursiveSequence class methodsFor: 'instance creation' stamp: 'len 3/30/2016 03:54'!
to: codomain initialValues: anArray characteristicPolynomial: aPolynomial
	^ self to: codomain initialValues: anArray coefficients: aPolynomial tail negated coefficients! !

!LinearRecursiveSequence class methodsFor: 'instance creation' stamp: 'len 12/27/2015 03:39'!
to: codomain initialValues: anArray coefficients: anotherArray
	^ self new initialValues: anArray; coefficients: anotherArray! !

!LinearRecursiveSequence class methodsFor: 'instance creation' stamp: 'len 12/27/2015 19:17'!
to: codomain initialValues: anArray minimalPolynomial: aPolynomial
	| answer |
	answer _ self to: codomain initialValues: anArray characteristicPolynomial: aPolynomial.
	answer properties at: #minimal put: answer.
	^ answer! !

!LinearRecursiveSequence class methodsFor: 'instance creation' stamp: 'len 12/30/2015 05:45'!
to: codomain initialValues: initialArray periodic: periodArray
	| coefficients |
	coefficients _ Array new: initialArray size + periodArray size.
	coefficients atAllPut: periodArray first zero.
	coefficients at: initialArray size + 1 put: periodArray first one.
	^ self to: codomain initialValues: initialArray, periodArray coefficients: coefficients! !

!LinearRecursiveSequence class methodsFor: 'instance creation' stamp: 'len 12/27/2015 03:41'!
to: codomain periodic: anArray
	| coefficients |
	coefficients _ Array new: anArray size.
	coefficients atAllPut: anArray first zero.
	coefficients at: 1 put: anArray first one.
	^ self to: codomain initialValues: anArray coefficients: coefficients! !

!QuadraticForm methodsFor: 'arithmetic' stamp: 'len 1/8/2016 05:21'!
* anObject
	^ self class from: basis matrix: matrix * anObject! !

!QuadraticForm methodsFor: 'arithmetic' stamp: 'len 1/8/2016 05:19'!
+ aQuadraticForm
	self domain = aQuadraticForm domain ifFalse: [^ self error: 'domains don''t match'].
	self flag: #fix.
	basis ~= aQuadraticForm basis ifFalse: [self notYetImplemented].
	^ self class
		from: basis
		matrix: matrix + aQuadraticForm matrix! !

!QuadraticForm methodsFor: 'converting' stamp: 'len 6/8/2016 21:30'!
asBilinearForm
	"Answer the bilinear form associated with the receiver (assuming the characteristic is not 2). This is, via the polarization identity: B(v,w) = (Q(v+w) - Q(v-w)) / 4."
	^ BilinearForm from: basis matrix: matrix! !

!QuadraticForm methodsFor: 'converting' stamp: 'len 3/28/2016 01:26'!
asPolynomial
	| n P x |
	n _ self domain dimension.
	P _ self scalars polynomialsIn: n.
	x _ Tuple new: n evaluating: [:i| P x: i].	
	^ x dot: matrix * x! !

!QuadraticForm methodsFor: 'accessing' stamp: 'len 1/8/2016 05:21'!
basis
	^ basis! !

!QuadraticForm methodsFor: 'accessing-private' stamp: 'len 1/8/2016 05:21'!
basis: aLinearBasis
	basis _ aLinearBasis! !

!QuadraticForm methodsFor: 'accessing' stamp: 'len 12/30/2015 21:15'!
bitSize
	^ matrix bitSize! !

!QuadraticForm methodsFor: 'accessing' stamp: 'len 12/30/2015 21:16'!
codomain
	^ self scalars! !

!QuadraticForm methodsFor: 'accessing' stamp: 'len 1/8/2016 05:19'!
domain
	^ basis span! !

!QuadraticForm methodsFor: 'testing' stamp: 'len 1/8/2016 06:25'!
isRegular
	^ self asBilinearForm isNonDegenerate! !

!QuadraticForm methodsFor: 'accessing' stamp: 'len 12/30/2015 21:16'!
matrix
	^ matrix! !

!QuadraticForm methodsFor: 'accessing-private' stamp: 'len 12/30/2015 21:17'!
matrix: aMatrix
	matrix _ aMatrix! !

!QuadraticForm methodsFor: 'arithmetic' stamp: 'len 1/8/2016 05:21'!
negated
	^ self class from: basis matrix: matrix negated! !

!QuadraticForm methodsFor: 'printing' stamp: 'len 4/21/2016 00:22'!
printOn: aStream
	aStream print: self asPolynomial! !

!QuadraticForm methodsFor: 'accessing' stamp: 'len 1/8/2016 06:36'!
rank
	^ matrix rank! !

!QuadraticForm methodsFor: 'accessing' stamp: 'len 5/23/2016 04:41'!
scalars
	^ basis ambient scalars! !

!QuadraticForm methodsFor: 'evaluating' stamp: 'len 5/31/2016 06:36'!
value: aVector
	| v |
	v _ basis coordinatesOf: aVector.
	^ v dot: (matrix * v)! !

!QuadraticForm methodsFor: 'accessing' stamp: 'len 6/9/2016 00:22'!
zeros
	^ Quadric on: self domain ideal: self asPolynomial asIdeal! !

!QuadraticForm class methodsFor: 'instance creation' stamp: 'len 1/8/2016 05:19'!
from: aLinearBasis matrix: aMatrix
	"Answer a new instance of the receiver representing the quadratic form associated to aMatrix in the given bases."
	aMatrix isSymmetric ifFalse: [self error: 'matrix not symmetric'].
	^ self new basis: aLinearBasis; matrix: aMatrix! !

!AffineMap methodsFor: 'arithmetic' stamp: 'len 5/14/2016 09:06'!
* aNumber
	^ self class linearPart: linearPart * aNumber translation: translation * aNumber! !

!AffineMap methodsFor: 'arithmetic' stamp: 'len 5/14/2016 09:07'!
+ anObject
	(anObject isKindOf: AffineMap)
		ifTrue: [^ self class linearPart: linearPart + anObject linearPart translation: translation + anObject translation].
	(self codomain includes: anObject)
		ifTrue: [^ self class linearPart: linearPart translation: translation + anObject].
	^ DomainError signal! !

!AffineMap methodsFor: 'comparing' stamp: 'len 5/14/2016 09:09'!
= anAffineMap
	^ linearPart = anAffineMap linearPart and: [translation = anAffineMap translation]! !

!AffineMap methodsFor: 'arithmetic' stamp: 'len 2/11/2016 21:42'!
@ anAffineMap
	self domain >= anAffineMap codomain ifFalse: [^ DomainError signal: 'domains don''t match'].
	^ self class from: anAffineMap domain to: self codomain evaluating: [:x| self value: (anAffineMap value: x)]! !

!AffineMap methodsFor: 'arithmetic' stamp: 'len 9/21/2016 16:52'!
 anAffineMap
	self codomain <= anAffineMap domain ifFalse: [^ DomainError signal: 'domains don''t match'].
	^ self class from: self domain to: anAffineMap codomain evaluating: [:x| anAffineMap value: (self value: x)]! !

!AffineMap methodsFor: 'accessing' stamp: 'len 5/14/2016 09:11'!
bitSize
	^ linearPart bitSize + translation bitSize! !

!AffineMap methodsFor: 'accessing' stamp: 'len 8/30/2016 05:48'!
codomain
	^ AffineLinearSpace representative: translation direction: linearPart codomain! !

!AffineMap methodsFor: 'accessing' stamp: 'len 5/14/2016 09:11'!
codomainFrame
	^ AffineFrame origin: translation basis: linearPart codomainBasis! !

!AffineMap methodsFor: 'accessing' stamp: 'len 6/4/2016 04:34'!
domain
	^ linearPart domain asAffineSpace! !

!AffineMap methodsFor: 'accessing' stamp: 'len 5/14/2016 09:11'!
domainFrame
	^ AffineFrame origin: linearPart domain zero basis: linearPart domainBasis! !

!AffineMap methodsFor: 'operations' stamp: 'len 5/14/2016 09:11'!
fiberAt: aPoint
	^ linearPart fiberAt: aPoint - translation! !

!AffineMap methodsFor: 'comparing' stamp: 'len 5/14/2016 09:11'!
hash
	^ linearPart hash! !

!AffineMap methodsFor: 'operations' stamp: 'len 8/30/2016 05:48'!
image
	^ AffineLinearSpace representative: translation direction: linearPart image! !

!AffineMap methodsFor: 'arithmetic' stamp: 'len 2/11/2016 21:47'!
inverse
	"Answer the inverse of the receiver. Answer nil if the receiver is not an isomorphism."
	^ self domain dimension = self codomain dimension ifTrue: [self leftInverse]! !

!AffineMap methodsFor: 'testing' stamp: 'len 2/12/2016 01:37'!
isEuclidean
	"Answer true if the receiver is an Euclidean motion, i.e. if it preserves distances.
	The Euclidean nitions of an affine space A form a group, the Euclidean group E(A) (sometimes called group of motions M(A) or group of isometries ISO(A))."
	^ self isIsometry! !

!AffineMap methodsFor: 'testing' stamp: 'len 5/14/2016 09:11'!
isIdentity
	^ translation isZero and: [linearPart isIdentity]! !

!AffineMap methodsFor: 'testing' stamp: 'len 5/14/2016 09:10'!
isInjective
	^ linearPart isInjective! !

!AffineMap methodsFor: 'testing' stamp: 'len 5/14/2016 09:10'!
isIsometry
	"Answer true if the receiver is an isometry, i.e. if it preserves distances.
	The isometries of an affine space A form a group, the Euclidean group E(A) (sometimes called group of Euclidean motions M(A) or group of isometries ISO(A))."
	^ linearPart isOrthogonal! !

!AffineMap methodsFor: 'testing' stamp: 'len 5/14/2016 09:10'!
isSurjective
	^ linearPart isSurjective! !

!AffineMap methodsFor: 'arithmetic' stamp: 'len 8/25/2016 00:48'!
leftInverse
	"Answer a left inverse (or retraction) of the receiver.
	Answer nil if the receiver is not a monomorphism."
	^ linearPart leftInverse ifNotNil: [:aLinearMap| self class linearPart: aLinearMap translation: (aLinearMap value: translation negated)]! !

!AffineMap methodsFor: 'accessing-private' stamp: 'len 5/14/2016 09:06'!
linearPart
	"This is a group homomorphism GA(V) -> GL(V)."
	^ linearPart! !

!AffineMap methodsFor: 'accessing-private' stamp: 'len 5/14/2016 09:06'!
linearPart: aLinearMap
	linearPart _ aLinearMap! !

!AffineMap methodsFor: 'accessing' stamp: 'len 5/14/2016 09:10'!
matrix
	| K zero A b |
	K _ linearPart domain scalars.
	zero _ K zero.
	A _ linearPart matrix.
	b _ linearPart codomainBasis coordinatesOf: translation.
	^ K ** (A dimension + (1@1))
		evaluating: [:i :j|
			(i <= A numberOfRows and: [j <= A numberOfColumns])
				ifTrue: [A at: i@j]
				ifFalse: [j = A numberOfColumns + 1
					ifTrue: [i <= b size ifTrue: [b at: i] ifFalse: [K one]]
					ifFalse: [zero]]]! !

!AffineMap methodsFor: 'arithmetic' stamp: 'len 5/14/2016 09:07'!
negated
	^ self class linearPart: linearPart negated translation: translation negated! !

!AffineMap methodsFor: 'printing' stamp: 'len 5/14/2016 09:11'!
printOn: aStream
	self isIdentity ifTrue: [aStream nextPutAll: 'id'. ^ self].
	self negated isIdentity ifTrue: [aStream nextPutAll: '-id'. ^ self].
	aStream print: linearPart; nextPutAll: ' + '; print: translation! !

!AffineMap methodsFor: 'arithmetic' stamp: 'len 8/25/2016 00:49'!
rightInverse
	"Answer a right inverse (or section) of the receiver.
	Answer nil if the receiver is not an epimorphism."
	^ linearPart rightInverse ifNotNil: [:aLinearMap| self class linearPart: aLinearMap translation: (aLinearMap value: translation negated)]! !

!AffineMap methodsFor: 'accessing-private' stamp: 'len 2/11/2016 21:38'!
translation
	^ translation! !

!AffineMap methodsFor: 'accessing-private' stamp: 'len 11/20/2015 15:58'!
translation: aVector
	translation _ aVector! !

!AffineMap methodsFor: 'operations' stamp: 'len 5/14/2016 09:10'!
value: aPoint
	^ (linearPart value: aPoint) + translation! !

!AffineMap class methodsFor: 'instance creation' stamp: 'len 6/4/2016 04:36'!
from: domain to: codomain evaluating: aBlock
	| linearMap translation |
	translation _ aBlock value: domain representative.
	linearMap _ LinearMap
		from: domain direction
		to: codomain direction
		evaluating: [:p| (aBlock value: p - domain representative) - translation].
	^ self linearPart: linearMap translation: translation! !

!AffineMap class methodsFor: 'instance creation' stamp: 'len 1/3/2016 04:38'!
from: anAffineFrame to: anotherAffineFrame matrix: aMatrix
	^ self notYetImplemented! !

!AffineMap class methodsFor: 'instance creation' stamp: 'len 5/14/2016 09:06'!
linearPart: aLinearMap translation: aVector
	^ self new linearPart: aLinearMap; translation: aVector! !

!ProjectiveMap methodsFor: 'comparing' stamp: 'len 2/22/2016 00:56'!
= aProjectiveMap
	(aProjectiveMap isKindOf: ProjectiveMap) ifFalse: [^ false].
	^ (linearMap domain -> linearMap codomain span: {linearMap})
		= (aProjectiveMap linearMap domain -> aProjectiveMap linearMap codomain) span: {aProjectiveMap linearMap}! !

!ProjectiveMap methodsFor: 'arithmetic' stamp: 'len 1/5/2016 00:10'!
@ aProjectiveMap
	"Answer the composition of the receiver with the argument."
	^ self class linearMap: linearMap @ aProjectiveMap linearMap! !

!ProjectiveMap methodsFor: 'arithmetic' stamp: 'len 9/21/2016 16:58'!
 aProjectiveMap
	"Answer the composition of the receiver with the argument."
	^ self class linearMap: linearMap  aProjectiveMap linearMap! !

!ProjectiveMap methodsFor: 'accessing' stamp: 'len 8/30/2016 05:46'!
codomain
	^ ProjectiveLinearSpace on: linearMap codomain! !

!ProjectiveMap methodsFor: 'operations' stamp: 'len 6/4/2016 04:55'!
corestrictedTo: aProjectiveSubspace
	"Answer a new projectivity like the receiver but with codomain restricted to aProjectiveSubspace."
	^ self class linearMap: (linearMap corestrictedTo: aProjectiveSubspace vectorSpace)! !

!ProjectiveMap methodsFor: 'accessing' stamp: 'len 8/30/2016 05:46'!
domain
	^ ProjectiveLinearSpace on: linearMap domain! !

!ProjectiveMap methodsFor: 'comparing' stamp: 'len 2/22/2016 00:57'!
hash
	^ (linearMap domain -> linearMap codomain span: {linearMap}) hash! !

!ProjectiveMap methodsFor: 'accessing' stamp: 'len 8/30/2016 05:46'!
image
	^ ProjectiveLinearSpace on: linearMap image! !

!ProjectiveMap methodsFor: 'arithmetic' stamp: 'len 2/25/98 18:14'!
inverse
	"Answer the inverse of the receiver. Answer nil if the receiver is not an isomorphism."

	^ self domain dimension = self codomain dimension ifTrue: [self leftInverse]! !

!ProjectiveMap methodsFor: 'arithmetic' stamp: 'len 8/25/2016 00:49'!
leftInverse
	"Answer a left inverse (or retraction) of the receiver.
	Answer nil if the receiver is not a monomorphism."
	^ linearMap leftInverse ifNotNil: [:aLinearMap| self class linearMap: aLinearMap]! !

!ProjectiveMap methodsFor: 'accessing' stamp: 'len 11/20/2015 16:33'!
linearMap
	"Answer the linear transformation associated to the receiver."

	^ linearMap! !

!ProjectiveMap methodsFor: 'accessing-private' stamp: 'len 11/21/2015 07:40'!
linearMap: aLinearMap
	linearMap _ aLinearMap! !

!ProjectiveMap methodsFor: 'accessing' stamp: 'len 11/20/2015 18:04'!
matrix
	^ linearMap matrix! !

!ProjectiveMap methodsFor: 'printing' stamp: 'len 11/20/2015 17:47'!
printOn: aStream
	aStream nextPut: $[; print: linearMap; nextPut: $]! !

!ProjectiveMap methodsFor: 'operations' stamp: 'len 6/4/2016 04:56'!
restrictedTo: aProjectiveSubspace
	"Answer a new projectivity like the receiver but with domain restricted to aProjectiveSubspace."
	^ self class linearMap: (linearMap restrictedTo: aProjectiveSubspace vectorSpace)! !

!ProjectiveMap methodsFor: 'arithmetic' stamp: 'len 8/25/2016 00:49'!
rightInverse
	"Answer a right inverse (or section) of the receiver.
	Answer nil if the receiver is not an epimorphism."
	^ linearMap rightInverse ifNotNil: [:aLinearMap| self class linearMap: aLinearMap]! !

!ProjectiveMap methodsFor: 'operations' stamp: 'len 6/10/2016 05:38'!
value: aPoint
	"Answer the value of the receiver at the given projective point, line, etc."
	^ (aPoint vectorSpace apply: linearMap) projective! !

!ProjectiveMap class methodsFor: 'instance creation' stamp: 'len 6/4/2016 03:10'!
from: P to: P` evaluating: aBlock
	self flag: #fix.
	^ self linearMap: (LinearMap from: P vectorSpace to: P` vectorSpace evaluating: [:v| P` vectorFromPoint: (aBlock value: (P project: v))])! !

!ProjectiveMap class methodsFor: 'examples' stamp: 'len 8/24/2016 19:26'!
hyperplane: aProjectiveSubspace center: aPoint
	"Answer the central collineation with invariant hyperplane aProjectiveSubspace and center aPoint."
	| a basis c space |
	a _ aProjectiveSubspace ambient vectorFromPoint: aPoint.
	basis _ aProjectiveSubspace vectorSpace basis extended.
	c _ basis last -
			((LinearMap projectionOn: aProjectiveSubspace vectorSpace)
				value: basis last).
	space _ basis span.
	^ self linearMap:
			(LinearMap
				from: space to: space
				evaluating: [ :v |
					(aProjectiveSubspace vectorSpace includes: v) ifTrue: [v] ifFalse: [a + c]])! !

!ProjectiveMap class methodsFor: 'instance creation' stamp: 'len 1/5/2016 00:56'!
linearMap: aLinearMap
	"Answer the homography with associated linear transformation aLinearMap."
	^ self new linearMap: aLinearMap! !

!PolynomialFunction methodsFor: 'operations' stamp: 'len 7/7/2016 20:45'!
* anObject
	(anObject isKindOf: PolynomialFunction)
		ifFalse: [^ self class from: domain representative: (domain ideal reduce: representative * anObject)].
	^ self class from: domain representative: (domain ideal reduce: representative * anObject representative)! !

!PolynomialFunction methodsFor: 'operations' stamp: 'len 7/7/2016 20:45'!
+ aPolynomialFunction
	^ self class from: domain representative: (domain ideal reduce: representative + aPolynomialFunction representative)! !

!PolynomialFunction methodsFor: 'comparing' stamp: 'len 3/4/2016 07:47'!
= aPolynomialFunction
	^ self domain ideal includes: self representative - aPolynomialFunction representative! !

!PolynomialFunction methodsFor: 'accessing' stamp: 'len 12/15/2015 20:13'!
codomain
	^ domain groundField! !

!PolynomialFunction methodsFor: 'accessing' stamp: 'len 12/15/2015 20:12'!
domain
	^ domain! !

!PolynomialFunction methodsFor: 'accessing-private' stamp: 'len 12/16/2015 23:10'!
domain: anAlgebraicVariety
	domain _ anAlgebraicVariety! !

!PolynomialFunction methodsFor: 'comparing' stamp: 'len 3/4/2016 07:47'!
hash
	^ self domain hash! !

!PolynomialFunction methodsFor: 'operations' stamp: 'len 3/4/2016 19:54'!
negated
	^ self class from: domain representative: representative negated "no need to compute remainder again, right?"! !

!PolynomialFunction methodsFor: 'printing' stamp: 'len 4/21/2016 00:22'!
printOn: aStream
	aStream nextPut: $[; print: representative; nextPut: $]! !

!PolynomialFunction methodsFor: 'accessing' stamp: 'len 12/15/2015 20:14'!
representative
	^ representative! !

!PolynomialFunction methodsFor: 'accessing-private' stamp: 'len 12/15/2015 20:13'!
representative: aPolynomial
	representative _ aPolynomial! !

!PolynomialFunction methodsFor: 'evaluating' stamp: 'len 6/4/2016 05:23'!
value: aPoint
	^ representative value: (domain space coordinatesOf: aPoint)! !

!PolynomialFunction class methodsFor: 'instance creation' stamp: 'len 12/15/2015 20:12'!
from: anAlgebraicVariety representative: aPolynomial
	^ self new domain: anAlgebraicVariety; representative: aPolynomial! !

!PolynomialMap methodsFor: 'operations' stamp: 'len 3/4/2016 19:42'!
* anObject
	^ self class from: domain to: codomain components: components * anObject! !

!PolynomialMap methodsFor: 'operations' stamp: 'len 3/4/2016 19:41'!
+ aPolynomialMap
	(domain = aPolynomialMap domain and: [codomain = aPolynomialMap codomain])
		ifFalse: [^ DomainError signal].
	^ self class from: domain to: codomain components: components + aPolynomialMap components! !

!PolynomialMap methodsFor: 'comparing' stamp: 'len 3/4/2016 07:53'!
= aPolynomialMap
	^ self domain = aPolynomialMap domain and: [self codomain = aPolynomialMap codomain and: [components = aPolynomialMap components]]! !

!PolynomialMap methodsFor: 'operations' stamp: 'len 9/21/2016 16:57'!
@ aPolynomialMap
	self domain = aPolynomialMap codomain ifFalse: [^ DomainError signal].
	(aPolynomialMap isKindOf: PolynomialFunction)
		ifTrue: [^ PolynomialFunction from: self domain representative: (self domain ideal reduce: (aPolynomialMap representative value: components))].
	^ self notYetImplemented! !

!PolynomialMap methodsFor: 'operations' stamp: 'len 9/21/2016 16:57'!
 aPolynomialMap
	self codomain = aPolynomialMap domain ifFalse: [^ DomainError signal].
	(aPolynomialMap isKindOf: PolynomialFunction)
		ifTrue: [^ PolynomialFunction from: self domain representative: (self domain ideal reduce: (aPolynomialMap representative value: components))].
	^ self notYetImplemented! !

!PolynomialMap methodsFor: 'accessing' stamp: 'len 12/15/2015 19:59'!
codomain
	^ codomain! !

!PolynomialMap methodsFor: 'accessing-private' stamp: 'len 12/15/2015 19:59'!
codomain: anAlgebraicVariety
	codomain _ anAlgebraicVariety! !

!PolynomialMap methodsFor: 'accessing-private' stamp: 'len 6/4/2016 05:29'!
components: anArray
	components _ anArray! !

!PolynomialMap methodsFor: 'accessing' stamp: 'len 12/15/2015 19:59'!
domain
	^ domain! !

!PolynomialMap methodsFor: 'accessing-private' stamp: 'len 12/15/2015 19:59'!
domain: anAlgebraicVariety
	domain _ anAlgebraicVariety! !

!PolynomialMap methodsFor: 'comparing' stamp: 'len 3/4/2016 07:53'!
hash
	^ components hash! !

!PolynomialMap methodsFor: 'accessing' stamp: 'len 3/4/2016 07:44'!
identity
	^ self notYetImplemented! !

!PolynomialMap methodsFor: 'accessing' stamp: 'len 12/18/2015 23:27'!
jacobian
	"Answer the Jacobian matrix of the receiver."
	| R |
	R _ self components first species.
	^ R ** (codomain dimension @ domain dimension) evaluating: [:i :j| (components at: i) derivativeIn: j]! !

!PolynomialMap methodsFor: 'operations' stamp: 'len 3/4/2016 07:45'!
leftInverse
	^ self notYetImplemented! !

!PolynomialMap methodsFor: 'operations' stamp: 'len 3/4/2016 07:52'!
negated
	^ self class from: domain to: codomain components: components negated! !

!PolynomialMap methodsFor: 'printing' stamp: 'len 4/21/2016 00:22'!
printOn: aStream 
	aStream nextPut: $[.
	components
		do: [:each| aStream print: each]
		separatedBy: [aStream nextPutAll: ', '].
	aStream nextPut: $]! !

!PolynomialMap methodsFor: 'evaluating' stamp: 'len 6/4/2016 05:27'!
value: aPoint
	| t |
	t _ self domain space coordinatesOf: aPoint.
	^ self codomain space pointAt: (components collect: [:each| each representative value: t])! !

!PolynomialMap class methodsFor: 'instance creation' stamp: 'len 12/15/2015 20:04'!
from: anAlgebraicVariety to: anotherAlgebraicVariety components: aTupleOfPolynomials
	^ self new domain: anAlgebraicVariety; codomain: anotherAlgebraicVariety; components: aTupleOfPolynomials! !

!RationalMap methodsFor: 'arithmetic' stamp: 'len 3/16/2016 05:27'!
* anObject
	^ self class from: domain to: codomain components: components * anObject! !

!RationalMap methodsFor: 'arithmetic' stamp: 'len 3/16/2016 05:33'!
+ aRationalParametrization
	(domain = aRationalParametrization domain and: [codomain = aRationalParametrization codomain])
		ifFalse: [^ DomainError signal].
	^ self class from: domain to: codomain components: components + aRationalParametrization components! !

!RationalMap methodsFor: 'accessing' stamp: 'len 3/16/2016 05:26'!
codomain
	^ codomain! !

!RationalMap methodsFor: 'accessing' stamp: 'len 3/16/2016 05:26'!
domain
	^ domain! !

!RationalMap methodsFor: 'accessing' stamp: 'len 8/2/2016 09:49'!
equations
	"Answer the parametric equations."
	^ self notYetImplemented! !

!RationalMap methodsFor: 'accessing' stamp: 'len 7/19/2016 01:04'!
implicit
	| normal tindets y n generators g ordering basis answer |
	self flag: #fix.
	normal _ self copy normalize.
	tindets _ normal parameters asSortedCollection.
	y _ tindets last + 1.
	n _ self size.
	generators _ OrderedCollection new.
	1 to: n do: [:each | generators add: (normal at: each) denominator * (Polynomial x: each) - (normal at: each) numerator].
	normal do: [:each | g _ g isNil
					ifTrue: [each denominator]
					ifFalse: [g * each denominator]].
	generators add: g identity - (g * (Polynomial x: y)).
	ordering _ MonomialOrdering lex: (1 to: n), tindets , {y}.
	ordering _ ordering inverse.
	basis _ (GroebnerBasis from: generators ordering: ordering) minimal.
	answer _ PolynomialSystem new.
	basis do: [:each | ((each degreeIn: y)
			= 0 and: [(tindets detect: [:one | (each degreeIn: one)
					> 0]
				ifNone: []) isNil])
			ifTrue: [answer add: (each eq: each null)]].
	^ answer! !

!RationalMap methodsFor: 'accessing' stamp: 'len 8/2/2016 02:06'!
implicit2
	| normal tindets y n generators g ordering basis answer |
	self flag: #fix.
	normal _ self copy normalize.
	tindets _ normal parameters asSortedCollection.
	y _ tindets last + 1.
	n _ self size.
	generators _ OrderedCollection new.
	1 to: n do: [:each | generators add: (normal at: each) denominator * (Polynomial x: each) - (normal at: each) numerator].
	normal do: [:each | g _ g isNil
					ifTrue: [each denominator]
					ifFalse: [g * each denominator]].
	generators add: g identity - (g * (Polynomial x: y)).
	ordering _ MonomialOrdering lex: (1 to: n), tindets , {y}.
	ordering _ ordering inverse.
	basis _ (GroebnerBasis from: generators ordering: ordering) minimal.
	answer _ PolynomialSystem new.
	basis do: [:each | ((each degreeIn: y)
			= 0 and: [(tindets detect: [:one | (each degreeIn: one)
					> 0]
				ifNone: []) isNil])
			ifTrue: [answer add: (each eq: each null)]].
	^ answer! !

!RationalMap methodsFor: 'arithmetic' stamp: 'len 3/16/2016 05:37'!
negated
	^ self class from: domain to: codomain components: components negated! !

!RationalMap methodsFor: 'private' stamp: 'len 12/14/2015 22:54'!
normalize
	| max indets |
	indets _ Set new.
	self do: [:each | indets addAll: each indeterminates].
	indets _ indets asSortedCollection.
	max _ self size max: indets last.
	1 to: indets size do: [:each | self rename: (indets at: each) to: max + each]! !

!RationalMap methodsFor: 'accessing' stamp: 'len 8/2/2016 02:10'!
parameters
	"this is the set of indeterminates present in the components, i.e. the parameters of the rational parametrization"
	| answer |
	answer _ Set new.
	components do: [:each|
		each indeterminates do: [:any| ((each numerator degreeIn: any) > 0 or: [(each numerator degreeIn: any) > 0]) ifTrue: [answer add: any]]].
	^ answer! !

!RationalMap methodsFor: 'printing' stamp: 'len 4/21/2016 00:22'!
printOn: aStream 
	aStream nextPut: $(.
	components
		do: [:each| aStream print: each]
		separatedBy: [aStream nextPutAll: ', '].
	aStream nextPut: $)! !

!RationalMap methodsFor: 'private' stamp: 'len 7/11/2016 05:42'!
rename: anInteger to: anotherInteger 
	"Rename the anInteger-th indeterminate of the receiver to anotherInteger. "
	components _ components collect: [:each| each rename: anInteger to: anotherInteger]! !

!RationalMap class methodsFor: 'instance creation' stamp: 'len 3/16/2016 05:38'!
from: domain to: codomain components: anArrayOfRationalFunctions
	^ self new domain: domain; codomain: codomain; components: anArrayOfRationalFunctions! !

!RealRootFunction methodsFor: 'as yet unclassified' stamp: 'len 5/30/2016 06:44'!
= aPolynomialRootFunction
	(aPolynomialRootFunction isKindOf: self class) ifFalse: [^ false].
	^ self polynomial = aPolynomialRootFunction polynomial and: [self index = aPolynomialRootFunction index]! !

!RealRootFunction methodsFor: 'accessing' stamp: 'len 4/17/2016 06:42'!
codomain
	^ RealAlgebraicNumbers new! !

!RealRootFunction methodsFor: 'accessing' stamp: 'len 5/30/2016 06:58'!
domain
	^ RealAlgebraicNumbers new ** (self polynomials anyOne species rank - 1)! !

!RealRootFunction methodsFor: 'as yet unclassified' stamp: 'len 6/28/2016 09:30'!
hash
	^ self polynomial hash hashMultiply + self index hash! !

!RealRootFunction methodsFor: 'accessing' stamp: 'len 3/17/2016 23:52'!
index
	^ index! !

!RealRootFunction methodsFor: 'accessing-private' stamp: 'len 12/14/97 21:11'!
index: anInteger
	index _ anInteger! !

!RealRootFunction methodsFor: 'accessing' stamp: 'len 5/30/2016 06:38'!
polynomial
	^ self polynomials product! !

!RealRootFunction methodsFor: 'accessing' stamp: 'len 3/17/2016 23:52'!
polynomials
	^ polynomials! !

!RealRootFunction methodsFor: 'accessing-private' stamp: 'len 5/30/2016 06:01'!
polynomials: aPolynomialSet
	(aPolynomialSet allSatisfy: [:each| each species scalars class == Rationals]) ifFalse: [self error: 'not polynomials in Q[x]'].
	polynomials _ aPolynomialSet! !

!RealRootFunction methodsFor: 'as yet unclassified' stamp: 'len 5/30/2016 07:02'!
printOn: aStream
	polynomials do: [:f|
		aStream nextPut: $(; print: f; nextPut: $)].
	aStream space; print: index; nextPutAll: '-root'.! !

!RealRootFunction methodsFor: 'operations' stamp: 'len 6/1/2016 22:48'!
value: aTuple
	| roots f polys Rx x |
	aTuple size = self domain rank ifFalse: [self error: 'the arity of the argument should match the number of indeterminates'].
	roots _ Set new.
	polys _ Set new.
	Rx _ RealAlgebraicNumbers new polynomials.
	x _  Rx x.
	self polynomials do: [:each|
		f _ (each value: ((aTuple collect: [:t| Rx constant: t]), x))
				coefficientsApply: [:coeff|
					coeff isAlgebraic ifTrue: [coeff asRational] ifFalse: [coeff]].
		polys do: [:some| f _ f // (f gcd: some)].
		roots addAll: (RealRootFinder polynomial: f) roots.
		polys add: f].
	^ roots asSortedCollection at: self index! !

!RealRootFunction class methodsFor: 'instance creation' stamp: 'len 3/17/2016 04:21'!
polynomial: aPolynomial index: anInteger
	"Answer a new instance of the receiver representing the anInteger-th root function for the polynomial aPolynomial."

	^ self polynomials: {aPolynomial} index: anInteger! !

!RealRootFunction class methodsFor: 'instance creation' stamp: 'len 12/14/97 21:50'!
polynomials: aPolynomialSet index: anInteger
	"Answer a new instance of the receiver representing the
	anInteger-th root function for the polynomials in aPolynomialSet."

	^ self new polynomials: aPolynomialSet; index: anInteger! !

!Identity methodsFor: 'comparing' stamp: 'len 4/23/2016 03:52'!
= aFunction
	^ self domain = aFunction domain and: [self codomain = aFunction codomain and: [aFunction isIdentity]]! !

!Identity methodsFor: 'operations' stamp: 'len 10/10/2016 15:12'!
@ aFunction
	"Answer the composition of the receiver with the argument."
	^ aFunction! !

!Identity methodsFor: 'operations' stamp: 'len 9/21/2016 16:52'!
 aFunction
	^ aFunction! !

!Identity methodsFor: 'accessing' stamp: 'len 4/19/2016 04:57'!
codomain
	^ self domain! !

!Identity methodsFor: 'private' stamp: 'len 4/19/2016 04:57'!
domain: aDomain
	properties at: #domain put: aDomain! !

!Identity methodsFor: 'testing' stamp: 'len 2/9/2016 04:20'!
hasLeftInverse
	^ true! !

!Identity methodsFor: 'testing' stamp: 'len 2/9/2016 04:20'!
hasRightInverse
	^ true! !

!Identity methodsFor: 'testing' stamp: 'len 2/9/2016 04:21'!
isEpimorphism
	^ true! !

!Identity methodsFor: 'testing' stamp: 'len 2/9/2016 06:03'!
isIdentity
	^ true! !

!Identity methodsFor: 'testing' stamp: 'len 2/9/2016 04:22'!
isMonomorphism
	^ true! !

!Identity methodsFor: 'operations' stamp: 'len 2/9/2016 04:20'!
leftInverse
	^ self! !

!Identity methodsFor: 'printing' stamp: 'len 4/21/2016 00:21'!
printOn: aStream
	aStream nextPutAll: 'id'! !

!Identity methodsFor: 'operations' stamp: 'len 2/9/2016 04:20'!
rightInverse
	^ self! !

!Identity methodsFor: 'operations' stamp: 'len 2/9/2016 04:01'!
value: anObject
	^ anObject! !

!Identity class methodsFor: 'instance creation' stamp: 'len 4/19/2016 04:56'!
on: aDomain
	^ self new domain: aDomain! !

!Functor methodsFor: 'as yet unclassified' stamp: 'len 10/9/2016 08:50'!
arrowPrintOn: aStream
	aStream print: self domain; nextPutAll: ' => '; print: self codomain! !

!SpectrumMorphism methodsFor: 'as yet unclassified' stamp: 'len 10/4/2016 09:43'!
codomain
	^ oposite domain spec! !

!SpectrumMorphism methodsFor: 'as yet unclassified' stamp: 'len 10/4/2016 09:43'!
domain
	^ oposite codomain spec! !

!SpectrumMorphism methodsFor: 'as yet unclassified' stamp: 'len 10/4/2016 09:43'!
oposite
	^ oposite! !

!SpectrumMorphism methodsFor: 'as yet unclassified' stamp: 'len 10/4/2016 09:43'!
oposite: aRingHomomorphism
	oposite _ aRingHomomorphism! !

!SpectrumMorphism class methodsFor: 'as yet unclassified' stamp: 'len 10/4/2016 09:43'!
oposite: aRingHomomorphism
	^ self new oposite: aRingHomomorphism! !

!RandomGenerator methodsFor: 'accessing' stamp: 'len 4/19/2016 22:03'!
bits: anInteger
	anInteger >= 1 ifFalse: [^ self error: 'bitsize must be >= 1'].
	bits _ anInteger! !

!RandomGenerator methodsFor: 'generating' stamp: 'len 6/27/2016 23:22'!
distinct: n
	"Answer n distinct elements choosen at random."
	| answer |
	answer _ Set2 new: n.
	[answer size < n] whileTrue: [answer add: self next].
	^ answer! !

!RandomGenerator methodsFor: 'accessing' stamp: 'len 4/19/2016 04:04'!
domain
	^ domain! !

!RandomGenerator methodsFor: 'private' stamp: 'len 4/19/2016 22:04'!
domain: aDomain
	domain _ aDomain.
	bits _ Infinity positive! !

!RandomGenerator methodsFor: 'generating' stamp: 'len 4/19/2016 22:04'!
next
	^ domain atRandom: random bits: bits! !

!RandomGenerator methodsFor: 'generating' stamp: 'len 2/17/2016 01:25'!
next: n
	^ (1 to: n) collect: [:each| self next]! !

!RandomGenerator methodsFor: 'printing' stamp: 'len 5/6/2016 02:32'!
printOn: aStream
	aStream nextPutAll: 'Random('; print: domain; nextPut: $)! !

!RandomGenerator methodsFor: 'private' stamp: 'len 4/19/2016 21:47'!
random: aRandom
	random _ aRandom! !

!RandomGenerator class methodsFor: 'instance creation' stamp: 'len 4/19/2016 04:03'!
on: aDomain
	| random |
	random _ Random new.
	80 timesRepeat: [random next].
	^ self on: aDomain random: random! !

!RandomGenerator class methodsFor: 'instance creation' stamp: 'len 4/19/2016 04:03'!
on: aDomain random: aRandom
	^ self new domain: aDomain; random: aRandom! !

!GroupRandomGenerator methodsFor: 'accessing' stamp: 'len 2/17/2016 01:23'!
generators: aCollection
	state _ aCollection asOrderedCollection.
	60 - (state size min: 10) timesRepeat: [self next] "initial precomputation takes about 60 multiplications / inversions in the group"! !

!GroupRandomGenerator methodsFor: 'generating' stamp: 'len 8/30/2016 19:53'!
next
	"Product Replacement Algorithm. After the initial precomputation, every new random element takes one multiplication and 1/2 inversion in the group."
	| g g` i |
	state isNil ifTrue: [self generators: self domain generators].
	g _ state atRandom: random.
	[(state at: (i _ state size atRandom: random)) == g and: [state size > 1 "otherwise fails with cyclic groups"]] whileTrue.
	(2 atRandom: random) = 1 ifTrue: [g _ self domain inverseMap value: g].
	g` _ self domain operation value: ({g. state at: i} shuffledBy: random).
	state size < 10 ifTrue: [state add: g`] ifFalse: [state at: i put: g`].
	^ g`! !

!Element methodsFor: 'comparing' stamp: 'len 8/4/2016 03:21'!
= anObject
	"Comparison is delegated to the value of the node.
	Argument and receiver are reversed to dereference through other Elements."
	^ anObject = value! !

!Element methodsFor: 'comparing' stamp: 'len 6/23/2016 02:24'!
hash
	^ value hash! !

!Element methodsFor: 'printing' stamp: 'len 6/23/2016 02:25'!
printOn: aStream
	aStream print: value! !

!Element methodsFor: 'private' stamp: 'len 6/23/2016 02:23'!
setValue: anObject
	value _ anObject! !

!Element methodsFor: 'accessing' stamp: 'len 6/23/2016 02:23'!
value
	^ value! !

!Element class methodsFor: 'instance creation' stamp: 'len 6/23/2016 02:24'!
on: anObject
	^ self new setValue: anObject! !

!GroupElement methodsFor: 'arithmetic' stamp: 'len 6/23/2016 02:47'!
* anObject
	^ self class on: value * anObject value! !

!GroupElement methodsFor: 'arithmetic' stamp: 'len 7/8/2016 05:38'!
** anInteger
	anInteger = 1 ifTrue: [^ self].
	anInteger = 0 ifTrue: [^ self one].
	anInteger < 0
		ifTrue: [^ (self ** anInteger negated) reciprocal].
	^ (self * self ** (anInteger // 2)) * (self ** (anInteger \\ 2))! !

!GroupElement methodsFor: 'arithmetic' stamp: 'len 6/23/2016 02:45'!
/ anObject
	^ self * anObject reciprocal! !

!GroupElement methodsFor: 'arithmetic' stamp: 'len 6/23/2016 04:48'!
identity
	^ self one! !

!GroupElement methodsFor: 'arithmetic' stamp: 'len 6/23/2016 04:48'!
inverse
	^ self reciprocal! !

!GroupElement methodsFor: 'arithmetic' stamp: 'len 6/23/2016 04:48'!
one
	^ self class on: value one! !

!GroupElement methodsFor: 'arithmetic' stamp: 'len 6/23/2016 02:47'!
reciprocal
	^ self class on: value reciprocal! !

!GroupAdditiveElement methodsFor: 'arithmetic' stamp: 'len 6/23/2016 02:28'!
* anObject
	anObject class == self class ifTrue: [^ self class on: self value + anObject value].
	^ self class on: self value * anObject "?"! !

!GroupAdditiveElement methodsFor: 'arithmetic' stamp: 'len 6/23/2016 02:35'!
** anInteger
	^ self class on: value * anInteger! !

!GroupAdditiveElement methodsFor: 'arithmetic' stamp: 'len 6/23/2016 04:50'!
one
	^ self class on: value zero! !

!GroupAdditiveElement methodsFor: 'arithmetic' stamp: 'len 6/23/2016 04:50'!
reciprocal
	^ self class on: value negated! !

!GroupCompositiveElement methodsFor: 'arithmetic' stamp: 'len 6/23/2016 02:16'!
* anObject
	anObject class == self class ifTrue: [^ self class on: self value @ anObject value].
	^ self class on: self value * anObject! !

!GroupCompositiveElement methodsFor: 'arithmetic' stamp: 'len 6/23/2016 02:37'!
** anInteger
	^ self class on: value @@ anInteger! !

!GroupCompositiveElement methodsFor: 'arithmetic' stamp: 'len 6/23/2016 04:49'!
one
	^ self class on: value identity! !

!GroupCompositiveElement methodsFor: 'arithmetic' stamp: 'len 6/23/2016 04:50'!
reciprocal
	^ self class on: value inverse! !

!RingElement methodsFor: 'arithmetic' stamp: 'len 6/23/2016 04:47'!
* anObject
	^ self class on: value * anObject value! !

!RingElement methodsFor: 'arithmetic' stamp: 'len 7/8/2016 05:42'!
** anInteger
	"Answer the receiver raised to the power anInteger."
	anInteger = 1 ifTrue: [^ self].
	anInteger = 0 ifTrue: [^ self one].
	anInteger < 0 ifTrue: [^ self reciprocal ** anInteger negated].
	^ self squared ** (anInteger // 2) * (self ** (anInteger \\ 2))! !

!RingElement methodsFor: 'arithmetic' stamp: 'len 6/23/2016 02:46'!
+ anObject
	^ self class on: value + anObject value! !

!RingElement methodsFor: 'arithmetic' stamp: 'len 6/23/2016 02:46'!
- anObject
	^ self + anObject negated! !

!RingElement methodsFor: 'arithmetic' stamp: 'len 6/23/2016 02:46'!
/ anObject
	^ self * anObject reciprocal! !

!RingElement methodsFor: 'arithmetic' stamp: 'len 6/23/2016 02:47'!
negated
	^ self class on: value negated! !

!RingElement methodsFor: 'arithmetic' stamp: 'len 8/29/2016 16:48'!
one
	^ self class on: value one! !

!RingElement methodsFor: 'arithmetic' stamp: 'len 6/23/2016 04:47'!
reciprocal
	^ self class on: value reciprocal! !

!RingElement methodsFor: 'arithmetic' stamp: 'len 8/29/2016 16:48'!
zero
	^ self class on: value zero! !

!RingCompositiveElement methodsFor: 'arithmetic' stamp: 'len 6/23/2016 04:46'!
* anObject
	anObject class == self class ifTrue: [^ self class on: self value @ anObject value].
	^ self class on: self value * anObject! !

!RingCompositiveElement methodsFor: 'arithmetic' stamp: 'len 6/23/2016 02:43'!
** anInteger
	^ self class on: value @@ anInteger! !

!RingCompositiveElement methodsFor: 'arithmetic' stamp: 'len 8/29/2016 16:48'!
one
	^ self class on: value identity! !

!RingCompositiveElement methodsFor: 'arithmetic' stamp: 'len 6/23/2016 04:46'!
reciprocal
	^ self class on: value inverse! !

!FormalFraction methodsFor: 'arithmetic' stamp: 'len 4/5/2016 18:02'!
* anObject
	(anObject isRational or: [anObject isKindOf: FormalFraction])
		ifTrue: [^ self class numerator: numerator * anObject numerator denominator: denominator * anObject denominator].
	^ self class numerator: numerator * anObject denominator: denominator! !

!FormalFraction methodsFor: 'arithmetic' stamp: 'len 3/30/2016 03:38'!
** anInteger
	anInteger = 1 ifTrue: [^ self].
	^ self class
		numerator: numerator ** anInteger
		denominator: denominator ** anInteger! !

!FormalFraction methodsFor: 'arithmetic' stamp: 'len 11/28/2015 06:33'!
+ anObject
	^ self class
			numerator: numerator * anObject denominator + (denominator * anObject numerator)
			denominator: denominator * self denominator! !

!FormalFraction methodsFor: 'arithmetic' stamp: 'len 11/28/2015 06:34'!
- anObject
	^ self + anObject negated! !

!FormalFraction methodsFor: 'arithmetic' stamp: 'len 11/28/2015 06:34'!
/ anObject
	^ self * anObject reciprocal! !

!FormalFraction methodsFor: 'comparing' stamp: 'len 4/5/2016 18:02'!
= aFormalFraction
	^ (aFormalFraction isKindOf: FormalFraction) and: [numerator * aFormalFraction denominator = (denominator * aFormalFraction numerator)]! !

!FormalFraction methodsFor: 'accessing' stamp: 'len 12/28/2015 20:31'!
bitSize
	^ numerator bitSize + denominator bitSize! !

!FormalFraction methodsFor: 'accessing' stamp: 'len 11/28/2015 06:28'!
denominator
	^ denominator! !

!FormalFraction methodsFor: 'comparing' stamp: 'len 11/28/2015 06:36'!
hash
	^ 0! !

!FormalFraction methodsFor: 'testing' stamp: 'len 11/28/2015 06:36'!
isZero
	^ numerator isZero! !

!FormalFraction methodsFor: 'arithmetic' stamp: 'len 11/28/2015 06:42'!
negated 
	^ self class
		numerator: numerator negated
		denominator: denominator! !

!FormalFraction methodsFor: 'accessing' stamp: 'len 11/28/2015 06:28'!
numerator
	^ numerator! !

!FormalFraction methodsFor: 'constants' stamp: 'len 11/28/2015 06:38'!
one
	^ self class numerator: numerator one denominator: denominator one! !

!FormalFraction methodsFor: 'printing' stamp: 'len 11/28/2015 06:44'!
printOn: aStream
	| string |
	aStream print: self numerator; nextPutAll: ' / '.
	string _ self denominator printString.
	((string includes: $+) or: [string includes: $-])
		ifTrue: [aStream nextPut: $(; print: self denominator; nextPut: $)]
		ifFalse: [aStream print: self denominator]! !

!FormalFraction methodsFor: 'private' stamp: 'len 7/11/2016 01:18'!
reduce
	| gcd |
	numerator isZero ifTrue: [denominator _ numerator one. ^ self].
	gcd _ numerator gcd: denominator.
	numerator _ numerator / gcd.
	denominator _ denominator / gcd! !

!FormalFraction methodsFor: 'private' stamp: 'len 11/28/2015 06:33'!
setNumerator: anObject denominator: anotherObject
	numerator _ anObject.
	denominator _ anotherObject.
	self reduce! !

!FormalFraction methodsFor: 'arithmetic' stamp: 'len 11/28/2015 06:38'!
squared
	^ self class
		numerator: self numerator squared
		denominator: self denominator squared! !

!FormalFraction methodsFor: 'constants' stamp: 'len 11/28/2015 06:38'!
zero
	^ self class numerator: numerator zero denominator: denominator one! !

!FormalFraction class methodsFor: 'instance creation' stamp: 'len 11/28/2015 06:30'!
numerator: anObject denominator: anotherObject
	^ self new setNumerator: anObject denominator: anotherObject! !

!PAdicNumber methodsFor: 'accessing' stamp: 'len 12/8/2015 03:24'!
norm
	^ self isZero ifTrue: [0] ifFalse: [self p ** self valuation negated]! !

!PAdicNumber methodsFor: 'accessing' stamp: 'len 12/7/2015 03:44'!
p
	^ self numerator p! !

!PAdicNumber methodsFor: 'accessing' stamp: 'len 12/7/2015 03:43'!
valuation
	^ self numerator valuation - self denominator valuation! !

!RationalFunction methodsFor: 'arithmetic' stamp: 'len 12/28/2015 19:41'!
* anObject
	"Answer the multiplication of the receiver and the argument."

	anObject class = self class ifTrue: [
"		g1 _ self numerator gcd: anObject denominator.
		g2 _ self denominator gcd: anObject numerator.
		newNumerator _ self numerator // g1 * (anObject numerator // g2).
		newDenominator _ self denominator // g2 * (anObject denominator // g1).
		^ (newDenominator = 1 or: [newNumerator isNull])
			ifTrue: [newNumerator]
			ifFalse: [self class numerator: newNumerator denominator: newDenominator]"
		^ self class numerator: self numerator * anObject numerator denominator: self denominator * anObject denominator].
	^ self class numerator: self numerator * anObject denominator: self denominator! !

!RationalFunction methodsFor: 'arithmetic' stamp: 'len 4/16/2016 07:14'!
+ anObject
	"Answer the sum of the receiver and the argument."

	anObject class = self class ifTrue: [
		"denGcd _ self denominator gcd: anObject denominator.
		rden1  _ self denominator // denGcd.
		rden2 _ anObject denominator // denGcd.
		crossProduct _ self numerator * rden2 + (anObject numerator * rden1).
		crossGcd _ crossProduct gcd: denGcd.
		((newDen _ denGcd // crossGcd * rden1 * rden2) = 1 or: [crossProduct isNull])
			ifTrue: [^ crossProduct // crossGcd].
		^ self class
			numerator: crossProduct // crossGcd
			denominator: newDen"
		^ self class
			numerator: self numerator * anObject denominator + (self denominator * anObject numerator)
			denominator: self numerator * self denominator].

	^ self numerator + (self denominator * anObject) / self denominator! !

!RationalFunction methodsFor: 'comparing' stamp: 'len 12/28/2015 04:43'!
= anObject
	anObject class == self class
		ifTrue: [^ self numerator * anObject denominator = (self denominator * anObject numerator)].
	^ self numerator = (anObject * self denominator)! !

!RationalFunction methodsFor: 'converting' stamp: 'len 11/11/2015 04:46'!
adaptToNumber: rcvr andSend: selector
	"If I am involved in arithmetic with an Number, convert it to a RationalFunction."
	self notYetImplemented! !

!RationalFunction methodsFor: 'operations' stamp: 'len 11/28/2015 06:35'!
degree
	^ self numerator degree - self denominator degree! !

!RationalFunction methodsFor: 'operations' stamp: 'len 9/3/97 23:49'!
derivative
	"Answer the derivative of the receiver."

	| num gcd |
	num _
		self denominator * self numerator derivative
		- (self numerator * self denominator derivative).
	gcd _ self denominator gcd: num.
	^ self class numerator: num // gcd denominator: (self denominator // gcd) squared * gcd! !

!RationalFunction methodsFor: 'operations' stamp: 'len 9/3/97 23:35'!
derivativeOfOrder: anInteger
	"Answer the anInteger-th derivative of the receiver."

	| answer |
	answer _ self.
	anInteger timesRepeat: [answer _ answer derivative].
	^ answer! !

!RationalFunction methodsFor: 'accessing' stamp: 'pdm 3/22/98 20:53'!
indeterminates
	^ Set new addAll: self numerator indeterminates; addAll: self denominator indeterminates; yourself! !

!RationalFunction methodsFor: 'roots and poles' stamp: 'len 2/12/2016 02:56'!
poles
	^ denominator roots! !

!RationalFunction methodsFor: 'roots and poles' stamp: 'len 2/12/2016 02:56'!
polesIn: aField
	^ denominator rootsIn: aField! !

!RationalFunction methodsFor: 'printing' stamp: 'len 7/11/2016 01:14'!
printOn: aStream
	"Print a representation of the reseiver on the stream aStream."

	| |
	self denominator = self denominator one ifTrue: [aStream print: self numerator. ^ self].
	self numerator terms size > 1
		ifTrue: [aStream nextPut: $(; print: self numerator; nextPut: $)]
		ifFalse: [aStream print: self numerator].
	aStream nextPutAll: ' / '.
	self denominator terms size > 1
		ifTrue: [aStream nextPut: $(; print: self denominator; nextPut: $)]
		ifFalse: [aStream print: self denominator]! !

!RationalFunction methodsFor: 'arithmetic' stamp: 'len 4/16/2016 07:19'!
reciprocal 
	"Answer the multiplicative inverse of the receiver."

	| mult |
	mult _ self numerator leadingCoefficient reciprocal.
"	self numerator isConstant ifTrue: [^ denominator * mult]."
	^ self class numerator: denominator * mult denominator: numerator * mult! !

!RationalFunction methodsFor: 'private' stamp: 'len 7/11/2016 01:17'!
reduce
	"Reduce the receiver dividing the numerator and the denominator
	by them GCD and making the denominator monic."
	| gcd mult num den |
	(num _ numerator) isZero ifTrue: [denominator _ num one. ^ num].
	den _ denominator.
	gcd _ num gcd: den.
	num _ num // gcd.
	den _ den // gcd.
	mult _ den leadingCoefficient reciprocal.
	numerator _ num * mult.
	denominator _ den * mult! !

!RationalFunction methodsFor: 'roots and poles' stamp: 'len 2/12/2016 02:56'!
roots
	^ numerator roots! !

!RationalFunction methodsFor: 'roots and poles' stamp: 'len 2/12/2016 02:56'!
rootsIn: aField
	^ numerator rootsIn: aField! !

!RationalFunction methodsFor: 'accessing' stamp: 'len 11/19/2015 19:23'!
scalars
	^ numerator scalars! !

!RationalFunction methodsFor: 'operations' stamp: 'len 11/24/2015 06:19'!
value: anObject
	"Answer the result of evaluating the receiver at the argument."

	^ (self numerator value: anObject) / (self denominator value: anObject)! !

!FormalSum methodsFor: 'arithmetic' stamp: 'len 3/5/2016 04:40'!
* aNumber
	^ self species coefficients: coefficients * aNumber! !

!FormalSum methodsFor: 'arithmetic' stamp: 'len 3/5/2016 04:40'!
+ aFormalLinearCombination
	^ self species coefficients: coefficients + aFormalLinearCombination coefficients! !

!FormalSum methodsFor: 'arithmetic' stamp: 'len 3/1/2016 03:40'!
- aFormalLinearCombination
	^ self + aFormalLinearCombination negated! !

!FormalSum methodsFor: 'arithmetic' stamp: 'len 3/2/2016 05:59'!
/ aNumber
	^ self * aNumber reciprocal! !

!FormalSum methodsFor: 'comparing' stamp: 'len 2/28/2016 04:32'!
= anAbelianWord
	^ coefficients = anAbelianWord coefficients! !

!FormalSum methodsFor: 'accessing' stamp: 'len 3/5/2016 04:50'!
coefficientAt: anElement
	^ coefficients at: anElement ifAbsent: []! !

!FormalSum methodsFor: 'accessing' stamp: 'len 3/2/2016 06:00'!
coefficientAt: anElement add: aNumber
	^ coefficients at: anElement add: aNumber! !

!FormalSum methodsFor: 'accessing' stamp: 'len 3/2/2016 06:00'!
coefficientAt: anElement put: aNumber
	^ coefficients at: anElement put: aNumber! !

!FormalSum methodsFor: 'accessing' stamp: 'len 2/28/2016 04:29'!
coefficients
	^ coefficients! !

!FormalSum methodsFor: 'accessing' stamp: 'len 3/1/2016 03:39'!
coefficients: aSparseTuple
	coefficients _ aSparseTuple! !

!FormalSum methodsFor: 'comparing' stamp: 'len 2/28/2016 04:32'!
hash
	^ coefficients hash! !

!FormalSum methodsFor: 'testing' stamp: 'len 2/28/2016 04:23'!
isZero
	^ coefficients isEmpty! !

!FormalSum methodsFor: 'arithmetic' stamp: 'len 3/5/2016 04:40'!
negated
	^ self species coefficients: coefficients negated! !

!FormalSum methodsFor: 'printing' stamp: 'len 4/25/2016 06:46'!
printCoefficient: c on: aStream
	"Print the coefficient of the receiver on the stream aStream."

	| string numeric |
	string _ c printString.
	string first = $-
		ifTrue: [aStream nextPut: $-. string _ c negated printString].
	numeric _ string allSatisfy: [:each| each isDigit].
	aStream nextPutAll:
		((numeric or: [string first = $(]) ifTrue: [string] ifFalse: ['(', string, ')'])! !

!FormalSum methodsFor: 'printing' stamp: 'len 4/25/2016 06:47'!
printOn2: aStream
	| elements |
	self flag: #fix. "copy form Polynomial"
	self isZero ifTrue: [aStream nextPutAll: '0'. ^ self].
	elements _ coefficients keys asSortedCollection: [:a :b| a printString <= b printString].
	aStream print: (coefficients at: elements first); print: elements first.
	elements allButFirstDo: 
		[:each| | coefficient |
		(coefficient _ coefficients at: each) < 0
			ifTrue: [aStream nextPutAll: ' - '; print: coefficient negated; print: each]
			ifFalse: [coefficient  > 0
				ifTrue: [aStream nextPutAll: ' + '; print: coefficient; print: each]]]! !

!FormalSum methodsFor: 'printing' stamp: 'len 7/2/2016 16:46'!
printOn: aStream
	| elements c |
	self isZero ifTrue: [aStream nextPutAll: '0'. ^ self].
	elements _ coefficients keys asSortedCollection: [:a :b| a printString <= b printString].
	c _ self coefficientAt: elements first.
	c printString first = $-
		ifTrue: [c _ c negated. aStream nextPut: $-].
	c ~= c one ifTrue: [self printCoefficient: c on: aStream].
	((elements first isKindOf: Word) and: [elements first isEmpty])
		ifFalse: [aStream print: elements first].
	elements allButFirst do: [:each|
		c _ self coefficientAt: each.
		c printString first = $-
			ifTrue: [aStream nextPutAll: ' - '. c _ c negated]
			ifFalse: [aStream nextPutAll: ' + '].
		c ~= c one ifTrue: [self printCoefficient: c on: aStream].
		((each isKindOf: Word) and: [each isEmpty])
			ifFalse: [aStream print: each]]! !

!FormalSum methodsFor: 'accessing' stamp: 'len 6/29/2016 23:24'!
value
	| answer |
	answer _ nil.
	coefficients keysAndValuesDo: [:key :value|
		answer _ answer ifNil: [key value * value] ifNotNil: [key value * value + answer]].
	^ answer! !

!FormalSum class methodsFor: 'instance creation' stamp: 'len 2/28/2016 04:30'!
coefficients: aDictionary
	^ self new coefficients: aDictionary! !

!FormalSum class methodsFor: 'instance creation' stamp: 'len 3/1/2016 03:41'!
new
	^ super new coefficients: SparseTuple new! !

!FormalSum class methodsFor: 'instance creation' stamp: 'len 2/28/2016 04:47'!
with: anElement
	^ self with: anElement times: 1! !

!FormalSum class methodsFor: 'instance creation' stamp: 'len 3/1/2016 03:42'!
with: anElement times: n
	^ self coefficients: (SparseTuple new at: anElement put: n; yourself)! !

!FreePolynomial methodsFor: 'arithmetic' stamp: 'len 3/23/2016 07:25'!
* anObject
	((self scalars includes: anObject) or: [anObject isInteger])
		ifTrue: [^ self coefficientsApply: [:each| each * anObject]].
	((anObject isKindOf: Polynomial) and: [anObject scalars includes: self])
		ifTrue: [^ anObject coefficientsApply: [:each| self * each]].
	(self species includes: anObject)
		ifTrue:
			[^ self species coefficients: (coefficients convolution: anObject coefficients)].
	(anObject isKindOf: Word)
		ifTrue: [^ self mapMonomials: [:each| each*anObject]].
	^ DomainError signal! !

!FreePolynomial methodsFor: 'arithmetic' stamp: 'len 7/8/2016 05:38'!
** anInteger
	"Answer the receiver raised to the power anInteger."
	(anInteger isInteger and: [anInteger >= 0])
		ifFalse: [^ self error: 'undefinted'].
	anInteger = 0 ifTrue: [^ self one].
	anInteger = 1 ifTrue: [^ self].
	^ self squared ** (anInteger // 2) * (self ** (anInteger \\ 2))! !

!FreePolynomial methodsFor: 'accessing' stamp: 'len 3/3/2016 05:27'!
degree
	"Answer the total degree of the receiver."
	self isZero ifTrue: [^ Infinity negative].
	^ self monomials max: [:each| each length]! !

!FreePolynomial methodsFor: 'arithmetic' stamp: 'len 3/2/2016 05:35'!
squared
	^ self * self! !

!Divisor methodsFor: 'as yet unclassified' stamp: 'len 10/8/2016 19:49'!
degree
	| answer |
	answer _ 0.
	self coefficients keysDo: [:each| answer _ answer + each].
	^ answer! !

!SimplicialChain methodsFor: 'operations' stamp: 'len 3/5/2016 04:52'!
boundary
	"The boundary of a chain is the linear combination of the boundary of the simplices in the chain. The boundary of a k-chain is a (k-1)-chain."
	| answer |
	answer _ self species new.
	self coefficients keysAndValuesDo: [:key :value| answer _ answer + (key boundary * value)].
	^ answer! !

!SimplicialChain methodsFor: 'accessing' stamp: 'len 2/29/2016 07:15'!
dimension
	^ (coefficients anyIfNone: [^ -1]) dimension! !

!SimplicialChain methodsFor: 'testing' stamp: 'len 2/23/2016 03:33'!
isCycle
	^ self boundary isZero! !

!ModularInteger methodsFor: 'arithmetic' stamp: 'len 4/25/2016 00:23'!
* aModularInteger
	aModularInteger isInteger ifTrue: [^ self class representative: representative * aModularInteger \\ modulus modulo: modulus].
	^ self class representative: representative * aModularInteger representative \\ modulus modulo: modulus! !

!ModularInteger methodsFor: 'arithmetic' stamp: 'len 7/8/2016 05:40'!
** anInteger
	anInteger = 1 ifTrue: [^ self].
	anInteger = 0 ifTrue: [^ self one].
	anInteger < 0 ifTrue: [^ self reciprocal ** anInteger negated].
	^ (self * self ** (anInteger // 2)) * (self ** (anInteger \\ 2))! !

!ModularInteger methodsFor: 'arithmetic' stamp: 'len 4/25/2016 00:24'!
+ aModularInteger
	| r |
	aModularInteger isInteger ifTrue: [^ self class representative: representative + aModularInteger \\ modulus modulo: modulus].
	r _ representative + aModularInteger representative.
	r >= modulus ifTrue: [r _ r - modulus].
	^ self class representative: r modulo: modulus! !

!ModularInteger methodsFor: 'copying' stamp: 'len 4/25/2016 00:24'!
, aTuple
	^ ((modulus = 2 ifTrue: [BitTuple] ifFalse: [Tuple]) withAll: {self}), aTuple! !

!ModularInteger methodsFor: 'arithmetic' stamp: 'len 4/25/2016 00:25'!
- aModularInteger
	| r |
	aModularInteger isInteger ifTrue: [^ self class representative: representative - aModularInteger \\ modulus modulo: modulus].
	r _ representative + (modulus - aModularInteger representative).
	r >= modulus ifTrue: [r _ r - modulus].
	^ self class representative: r modulo: modulus! !

!ModularInteger methodsFor: 'arithmetic' stamp: 'len 3/29/2016 20:47'!
/ aModularInteger
	^ self * aModularInteger reciprocal! !

!ModularInteger methodsFor: 'comparing' stamp: 'len 4/25/2016 00:25'!
= aModularInteger
	aModularInteger class = self class ifFalse: [^ false].
	aModularInteger == self ifTrue: [^ true].
	^ aModularInteger representative = representative and: [aModularInteger modulus = modulus]! !

!ModularInteger methodsFor: 'converting' stamp: 'len 4/25/2016 00:24'!
adaptToInteger: rcvr andSend: selector
	^ (self class representative: rcvr \\ modulus modulo: modulus) perform: selector with: self! !

!ModularInteger methodsFor: 'accessing' stamp: 'len 4/21/2016 05:55'!
bitSize
	^ representative bitSize! !

!ModularInteger methodsFor: 'comparing' stamp: 'len 3/29/2016 20:48'!
hash
	^ representative hash! !

!ModularInteger methodsFor: 'accessing' stamp: 'len 7/15/2016 18:28'!
ideal
	^ ZZ * modulus! !

!ModularInteger methodsFor: 'testing' stamp: 'len 4/25/2016 00:22'!
isQuadraticResidue
	(#(-1 0) includes: (representative jacobi: modulus))
		ifTrue: [^ false].
	^ self notYetImplemented! !

!ModularInteger methodsFor: 'testing' stamp: 'len 3/30/2016 00:03'!
isZero
	^ representative = 0! !

!ModularInteger methodsFor: 'accessing' stamp: 'len 4/25/2016 00:26'!
modulus
	^ modulus! !

!ModularInteger methodsFor: 'accessing-private' stamp: 'len 4/25/2016 00:27'!
modulus: anInteger
	modulus _ anInteger! !

!ModularInteger methodsFor: 'arithmetic' stamp: 'len 4/25/2016 00:24'!
negated
	representative = 0 ifTrue: [^ self].
	^ self class representative: modulus - representative modulo: modulus! !

!ModularInteger methodsFor: 'arithmetic' stamp: 'len 4/25/2016 00:23'!
one
	^ self class representative: 1 modulo: modulus! !

!ModularInteger methodsFor: 'printing' stamp: 'len 3/29/2016 20:49'!
printOn: aStream
	aStream print: representative! !

!ModularInteger methodsFor: 'arithmetic' stamp: 'len 4/25/2016 00:24'!
reciprocal
	^ self class representative: (representative reciprocalModulo: modulus) modulo: modulus! !

!ModularInteger methodsFor: 'accessing' stamp: 'len 3/29/2016 20:49'!
representative
	^ representative! !

!ModularInteger methodsFor: 'accessing-private' stamp: 'len 3/29/2016 23:52'!
representative: anInteger
	representative _ anInteger! !

!ModularInteger methodsFor: 'arithmetic' stamp: 'len 4/25/2016 00:25'!
zero
	^ self class representative: 0 modulo: modulus! !

!ModularInteger class methodsFor: 'instance creation' stamp: 'len 3/29/2016 23:52'!
representative: anInteger ideal: anIdeal
	^ self representative: anInteger modulo: anIdeal generator! !

!ModularInteger class methodsFor: 'instance creation' stamp: 'len 4/25/2016 00:27'!
representative: anInteger modulo: anotherInteger
	^ self new representative: anInteger; modulus: anotherInteger! !

!PAdicInteger methodsFor: 'arithmetic' stamp: 'len 7/17/2016 23:24'!
* anObject
	anObject isInteger
		ifTrue: [^ self class digits: digits * anObject].
	^ self class digits: (digits pointwiseProduct: anObject digits)! !

!PAdicInteger methodsFor: 'arithmetic' stamp: 'len 7/17/2016 23:18'!
+ aPAdicInteger
	^ self class digits: digits + aPAdicInteger digits! !

!PAdicInteger methodsFor: 'arithmetic' stamp: 'len 7/17/2016 23:24'!
- aPAdicInteger
	^ self class digits: self digits - aPAdicInteger digits! !

!PAdicInteger methodsFor: 'comparing' stamp: 'len 12/7/2015 03:01'!
= aPAdicInteger
	^ aPAdicInteger class == self class and: [digits = aPAdicInteger digits]! !

!PAdicInteger methodsFor: 'accessing' stamp: 'len 7/17/2016 23:31'!
at: anInteger
	"Answer the digit corresponding to p^(anInteger-1)."
	anInteger > digits size ifTrue: [^ digits last].
	^ digits at: anInteger! !

!PAdicInteger methodsFor: 'accessing-private' stamp: 'len 12/7/2015 02:54'!
digits
	^ digits! !

!PAdicInteger methodsFor: 'initialization' stamp: 'len 7/17/2016 23:29'!
digits: anArray
	| n |
	digits _ anArray as: Tuple.
	n _ (digits size to: 2 by: -1) detect: [:i| (digits at: i) representative ~= (digits at: i-1) representative] ifNone: [^ self].
	n < digits size ifTrue: [digits _ digits copyFrom: 1 to: n]! !

!PAdicInteger methodsFor: 'comparing' stamp: 'len 12/7/2015 03:01'!
hash
	^ digits hash! !

!PAdicInteger methodsFor: 'testing' stamp: 'len 12/7/2015 03:45'!
isUniformizing
	"Answer true if the receiver is a uniformizing element."
	^ self valuation = 1! !

!PAdicInteger methodsFor: 'testing' stamp: 'len 7/17/2016 23:30'!
isZero
	^ digits isZero! !

!PAdicInteger methodsFor: 'arithmetic' stamp: 'len 12/7/2015 03:02'!
negated
	^ self class digits: digits negated! !

!PAdicInteger methodsFor: 'accessing' stamp: 'len 12/8/2015 03:24'!
norm
	^ self isZero ifTrue: [0] ifFalse: [self p ** self valuation negated]! !

!PAdicInteger methodsFor: 'constants' stamp: 'len 12/7/2015 03:13'!
one
	^ self class fromNatural: 1 p: self p! !

!PAdicInteger methodsFor: 'accessing' stamp: 'len 7/17/2016 23:10'!
p
	^ digits first modulus! !

!PAdicInteger methodsFor: 'printing' stamp: 'len 12/7/2015 03:00'!
printOn: aStream
	aStream nextPut: $(.
	digits do: [:each| aStream print: each representative] separatedBy: [aStream nextPutAll: ','].
	aStream nextPutAll: '..)'! !

!PAdicInteger methodsFor: 'accessing' stamp: 'len 12/7/2015 02:55'!
size
	^ digits size! !

!PAdicInteger methodsFor: 'accessing' stamp: 'len 7/17/2016 23:32'!
valuation
	self isZero ifTrue: [^ Infinity positive].
	^ (digits findFirst: [:each| each isZero not]) - 1! !

!PAdicInteger methodsFor: 'constants' stamp: 'len 12/7/2015 03:13'!
zero
	^ self class fromNatural: 0 p: self p! !

!PAdicInteger class methodsFor: 'instance creation' stamp: 'len 7/17/2016 23:29'!
digits: anArray
	^ self new digits: anArray! !

!PAdicInteger class methodsFor: 'instance creation' stamp: 'len 7/17/2016 23:27'!
fromNatural: anInteger p: aPrime
	| I digits |
	I _ ZZ.
	digits _ OrderedCollection new.
	[I _ I * aPrime.
	digits add: (ZZ/I project: anInteger).
	I generator > anInteger ifTrue: [^ self digits: digits]] repeat! !

!Quaternion methodsFor: 'arithmetic' stamp: 'len 11/11/2015 05:29'!
* anObject
	| a0 a1 a2 a3 b0 b1 b2 b3 |
	(anObject isKindOf: Number)
		ifTrue: [^ self class a: a * anObject b: b * anObject c: c * anObject d: d * anObject].
	(anObject isKindOf: Quaternion)
		ifFalse: [^ anObject adaptToQuaternion: self andSend: #*].
	a0 _ self a. a1 _ self b. a2 _ self c. a3 _ self d.
	b0 _ anObject a. b1 _ anObject b. b2 _ anObject c. b3 _ anObject d.
	^ self class
		a: a0 * b0 - (a1 * b1) - (a2 * b2) - (a3 * b3)
		b: a0 * b1 + (a1 * b0) + (a2 * b3) - (a3 * b2)
		c: a0 * b2 + (a2 * b0) + (a3 * b1) - (a1 * b3)
		d: a0 * b3 + (a3 * b0) + (a1 * b2) - (a2 * b1)! !

!Quaternion methodsFor: 'arithmetic' stamp: 'len 7/8/2016 05:48'!
** anInteger
	"Answer the receiver raised to the power anInteger."
	anInteger = 1 ifTrue: [^ self].
	anInteger = 0 ifTrue: [^ self one].
	anInteger < 0 ifTrue: [^ (self ** anInteger negated) reciprocal].
	^ self squared ** (anInteger // 2) * (self ** (anInteger \\ 2))! !

!Quaternion methodsFor: 'arithmetic' stamp: 'len 11/11/2015 05:30'!
+ anObject
	(anObject isKindOf: Number)
		ifTrue: [^ self class a: a + anObject b: b c: c d: d].
	(anObject isKindOf: Quaternion)
		ifFalse: [^ anObject adaptToQuaternion: self andSend: #+].
	^ self class
		a: self a + anObject a
		b: self b + anObject b
		c: self c + anObject c
		d: self d + anObject d! !

!Quaternion methodsFor: 'arithmetic' stamp: 'len 11/11/2015 05:12'!
- anObject
	^ self + anObject negated! !

!Quaternion methodsFor: 'arithmetic' stamp: 'len 11/11/2015 05:12'!
/ anObject
	^ self * anObject reciprocal! !

!Quaternion methodsFor: 'comparing' stamp: 'len 11/11/2015 05:31'!
= anObject
	anObject isNumber ifFalse: [^ false].
	(anObject isKindOf: Number)
		ifTrue: [^ a = anObject and: [b = 0 and: [c = 0 and: [d = 0]]]].
	(anObject isKindOf: Quaternion)
		ifFalse: [^ anObject adaptToQuaternion: self andSend: #=].
	^ self a = anObject a
		and: [self b = anObject b
			and: [self c = anObject c
				and: [self d = anObject d]]]! !

!Quaternion methodsFor: 'accessing' stamp: 'len 2/25/98 02:43'!
a
	"Answer the 'a' component of the receiver."

	^ a! !

!Quaternion methodsFor: 'accessing-private' stamp: 'len 2/25/98 02:41'!
a: aNumber b: bNumber c: cNumber d: dNumber
	a _ aNumber.
	b _ bNumber.
	c _ cNumber.
	d _ dNumber! !

!Quaternion methodsFor: 'converting' stamp: 'len 11/11/2015 04:55'!
adaptToNumber: rcvr andSend: selector
	"If I am involved in arithmetic with a Number, convert it to a Quaternion."
	^ (Quaternion a: rcvr b: 0 c: 0 d: 0) perform: selector with: self! !

!Quaternion methodsFor: 'converting' stamp: 'len 2/25/98 03:21'!
asQuaternion
	^ self! !

!Quaternion methodsFor: 'accessing' stamp: 'len 2/25/98 02:43'!
b
	"Answer the 'b' component of the receiver."

	^ b! !

!Quaternion methodsFor: 'accessing' stamp: 'len 2/25/98 02:43'!
c
	"Answer the 'c' component of the receiver."

	^ c! !

!Quaternion methodsFor: 'arithmetic' stamp: 'len 2/25/98 02:47'!
conjugated
	"Answer the conjugate of the receiver."

	^ self class
		a: self a
		b: self b negated
		c: self c negated
		d: self d negated! !

!Quaternion methodsFor: 'accessing' stamp: 'len 2/25/98 02:43'!
d
	"Answer the 'd' component of the receiver."

	^ d! !

!Quaternion methodsFor: 'comparing' stamp: 'len 6/28/2016 09:27'!
hash
	^ ((a hash hashMultiply + b hash) hashMultiply + c hash) hashMultiply + d hash! !

!Quaternion methodsFor: 'arithmetic' stamp: 'len 2/25/98 03:29'!
i
	"Answer the receiver multiplicated by i."

	^ self class a: self b negated b: self a c: self d d: self c negated! !

!Quaternion methodsFor: 'testing' stamp: 'len 2/25/98 03:05'!
isNumber
	^ true! !

!Quaternion methodsFor: 'testing' stamp: 'len 4/16/2016 19:18'!
isZero
	"Answer true if the receiver is null."
	^ self a isZero and: [self b isZero and: [self c isZero and: [self d isZero]]]! !

!Quaternion methodsFor: 'arithmetic' stamp: 'len 2/25/98 03:29'!
j
	"Answer the receiver multiplicated by j."

	^ self class a: self c negated b: self d negated c: self a d: self b! !

!Quaternion methodsFor: 'arithmetic' stamp: 'len 2/25/98 03:30'!
k
	"Answer the receiver multiplicated by k."

	^ self class a: self d negated b: self c c: self b negated d: self a! !

!Quaternion methodsFor: 'arithmetic' stamp: 'len 2/25/98 02:46'!
negated
	"Answer the additive inverse of the receiver."

	^ self class
		a: self a negated
		b: self b negated
		c: self c negated
		d: self d negated! !

!Quaternion methodsFor: 'mathematical functions' stamp: 'len 2/25/98 02:59'!
norm2
	"Answer the square norm of the receiver."

	^ self a squared + self b squared + self c squared + self d squared! !

!Quaternion methodsFor: 'constants' stamp: 'len 11/19/2015 19:35'!
one
	| zero |
	zero _ a zero.
	^ self class a: a one b: zero c: zero d: zero! !

!Quaternion methodsFor: 'printing' stamp: 'len 11/19/2015 19:36'!
printOn: aStream
	"Print a representation of the receiver on the stream aStream."

	| something number |
	self isZero ifTrue: [aStream print: 0. ^ self].
	something _ false.
	a isZero ifFalse: [aStream print: a. something _ true].
	b isZero ifFalse: [number _ b.
						something
							ifTrue: [aStream nextPutAll: (number positive
								ifTrue: [' + ']
								ifFalse: [number _ number negated. ' - '])]
							ifFalse: [number negative
								ifTrue: [aStream nextPut: $-.
										number _ number negated]].
						number = number one ifFalse: [aStream print: number; space].
						aStream nextPut: $i. something _ true].
	c isZero ifFalse: [number _ c.
						something
							ifTrue: [aStream nextPutAll: (number positive
								ifTrue: [' + ']
								ifFalse: [number _ number negated. ' - '])]
							ifFalse: [number negative
								ifTrue: [aStream nextPut: $-.
										number _ number negated]].
						number = number one ifFalse: [aStream print: number; space].
						aStream nextPut: $j. something _ true].
	d isZero ifFalse: [number _ d.
						something
							ifTrue: [aStream nextPutAll: (number positive
								ifTrue: [' + ']
								ifFalse: [number _ number negated. ' - '])]
							ifFalse: [number negative
								ifTrue: [aStream nextPut: $-.
										number _ number negated]].
						number = number one ifFalse: [aStream print: number; space].
						aStream nextPut: $k. something _ true]! !

!Quaternion methodsFor: 'arithmetic' stamp: 'len 2/25/98 02:58'!
reciprocal
	"Answer the multiplicative inverse of the receiver."

	^ self conjugated / self norm2! !

!Quaternion methodsFor: 'mathematical functions' stamp: 'len 11/11/2015 05:16'!
squared
	^ self * self! !

!Quaternion methodsFor: 'constants' stamp: 'len 11/19/2015 19:35'!
zero
	| zero |
	zero _ a zero.
	^ self class a: zero one b: zero c: zero d: zero! !

!Quaternion class methodsFor: 'instance creation' stamp: 'len 2/25/98 02:42'!
a: aNumber b: bNumber c: cNumber d: dNumber
	"Answer a new instance of the receiver with the given components."

	^ self new a: aNumber b: bNumber c: cNumber d: dNumber! !

!Quaternion class methodsFor: 'examples' stamp: 'len 5/3/98 00:19'!
i
	^ Quaternion a: 0 b: 1 c: 0 d: 0! !

!Quaternion class methodsFor: 'examples' stamp: 'len 5/3/98 00:20'!
j
	^ Quaternion a: 0 b: 0 c: 1 d: 0! !

!Quaternion class methodsFor: 'examples' stamp: 'len 5/3/98 00:20'!
k
	^ Quaternion a: 0 b: 0 c: 0 d: 1! !

!Residue methodsFor: 'arithmetic' stamp: 'len 3/22/2016 02:44'!
* anObject
	anObject isInteger ifTrue: [^ self project: representative * anObject].
	^ self project: representative * anObject representative! !

!Residue methodsFor: 'arithmetic' stamp: 'len 7/8/2016 05:41'!
** anInteger
	"Answer the receiver raised to the power anInteger."
	anInteger = 1 ifTrue: [^ self].
	anInteger = 0 ifTrue: [^ self one].
	anInteger < 0 ifTrue: [^ (self ** anInteger negated) reciprocal].
	^ self squared ** (anInteger // 2) * (self ** (anInteger \\ 2))! !

!Residue methodsFor: 'arithmetic' stamp: 'len 3/22/2016 02:44'!
+ aResidue
	^ self project: representative + aResidue representative! !

!Residue methodsFor: 'converting' stamp: 'len 11/23/2015 06:20'!
, aTuple
	^ (Tuple withAll: {self}), aTuple! !

!Residue methodsFor: 'arithmetic' stamp: 'len 3/22/2016 02:44'!
- aResidue
	^ self + aResidue negated! !

!Residue methodsFor: 'arithmetic' stamp: 'len 3/22/2016 02:45'!
/ aResidue
	^ self * aResidue reciprocal! !

!Residue methodsFor: 'comparing' stamp: 'len 3/29/2016 20:52'!
= aResidue
	aResidue class = self class ifFalse: [^ false].
"	^ (self - aResidue) isZero"
	^ representative = aResidue representative! !

!Residue methodsFor: 'converting' stamp: 'len 3/22/2016 02:48'!
adaptToInteger: rcvr andSend: selector
	^ (self class representative: rcvr modulo: ideal) perform: selector with: self! !

!Residue methodsFor: 'accessing' stamp: 'len 12/28/2015 20:32'!
bitSize
	^ representative bitSize! !

!Residue methodsFor: 'conjugation' stamp: 'len 9/26/2016 16:53'!
conjugated
	^ self ** self ideal ring characteristic! !

!Residue methodsFor: 'conjugation' stamp: 'len 4/20/2016 20:23'!
conjugates
	^ Iterator on: [:aBlock| self conjugatesDo: aBlock]! !

!Residue methodsFor: 'conjugation' stamp: 'len 9/26/2016 16:53'!
conjugatesDo: aBlock
	"Iterate over the conjugancy class of the receiver, i.e. all the conjugates including the receiver."
	| alpha |
	alpha _ self.
	[aBlock value: alpha.
	alpha _ alpha ** self ideal ring characteristic.
	alpha = self] whileFalse! !

!Residue methodsFor: 'comparing' stamp: 'len 3/22/2016 02:46'!
hash
	^ ideal hash! !

!Residue methodsFor: 'accessing' stamp: 'len 3/22/2016 02:30'!
ideal
	^ ideal! !

!Residue methodsFor: 'accessing-private' stamp: 'len 3/22/2016 02:30'!
ideal: anIdeal
	ideal _ anIdeal! !

!Residue methodsFor: 'testing' stamp: 'len 3/22/2016 02:49'!
includes: aRingElement
	^ self = (self project: aRingElement)! !

!Residue methodsFor: 'testing' stamp: 'len 1/2/2016 22:34'!
isUnit
	^ (self ideal inverseOf: representative) notNil! !

!Residue methodsFor: 'testing' stamp: 'len 11/25/2015 03:10'!
isZero
	"^ (ideal remainderOf: representative) isZero"
	^ representative isZero! !

!Residue methodsFor: 'accessing' stamp: 'len 4/25/2016 00:30'!
modulus
	^ ideal generator! !

!Residue methodsFor: 'arithmetic' stamp: 'len 3/22/2016 02:45'!
negated
	^ self project: representative negated! !

!Residue methodsFor: 'constants' stamp: 'len 3/22/2016 02:47'!
one
	^ self project: representative one! !

!Residue methodsFor: 'printing' stamp: 'len 12/21/2015 22:51'!
printOn: aStream
	aStream print: representative"; nextPutAll: ' mod '; print: ideal"! !

!Residue methodsFor: 'private' stamp: 'len 7/7/2016 20:46'!
project: aRepresentative
	^ self class representative: (ideal reduce: aRepresentative) ideal: ideal! !

!Residue methodsFor: 'arithmetic' stamp: 'len 3/22/2016 02:46'!
reciprocal
	^ self project: ((self ideal inverseOf: representative) ifNil: [^ self error: 'not invertible'])! !

!Residue methodsFor: 'accessing' stamp: 'len 11/25/2015 03:11'!
representative
	^ representative! !

!Residue methodsFor: 'accessing-private' stamp: 'len 11/25/2015 03:12'!
representative: anObject
	representative _ anObject! !

!Residue methodsFor: 'arithmetic' stamp: 'len 6/4/2016 18:04'!
squared
	^ self * self! !

!Residue methodsFor: 'constants' stamp: 'len 3/22/2016 02:47'!
zero
	^ self project: representative zero! !

!Residue class methodsFor: 'instance creation' stamp: 'len 3/29/2016 23:46'!
representative: anObject ideal: anIdeal
	^ self new representative: anObject; ideal: anIdeal! !

!SLP methodsFor: 'as yet unclassified' stamp: 'len 7/26/2016 23:37'!
* aSLP
	^ self class word: (Word syllables: {word -> 1. aSLP word -> 1})! !

!SLP methodsFor: 'as yet unclassified' stamp: 'len 7/26/2016 23:40'!
** anInteger
	anInteger = 0 ifTrue: [^ self class word: Word empty].
	anInteger = 1 ifTrue: [^ self].
	^ self class word: (Word x: word to: anInteger)! !

!SLP methodsFor: 'as yet unclassified' stamp: 'len 7/26/2016 23:00'!
printOn: aStream
	word printOn: aStream! !

!SLP methodsFor: 'as yet unclassified' stamp: 'len 7/26/2016 22:59'!
reciprocal
	^ self class word: (Word x: word to: -1)! !

!SLP methodsFor: 'as yet unclassified' stamp: 'len 7/26/2016 23:33'!
value
	| answer |
	answer _ word value.
	[answer isKindOf: Word] whileTrue: [answer _ answer value].
	^ answer! !

!SLP methodsFor: 'as yet unclassified' stamp: 'len 7/26/2016 22:59'!
word
	^ word! !

!SLP methodsFor: 'as yet unclassified' stamp: 'len 7/26/2016 22:58'!
word: aWord
	word _ aWord! !

!SLP class methodsFor: 'as yet unclassified' stamp: 'len 7/26/2016 23:33'!
value: anObject
	^ self word: (Word x: anObject)! !

!SLP class methodsFor: 'as yet unclassified' stamp: 'len 7/26/2016 23:00'!
word: aWord
	^ self new word: aWord! !

!Word methodsFor: 'arithmetic' stamp: 'len 3/3/2016 05:25'!
* aWord
	| x y |
	self isEmpty ifTrue: [^ aWord].
	aWord isEmpty ifTrue: [^ self].
	syllables last key = aWord syllables first key
		ifFalse: [^ self class syllables: syllables, aWord syllables].
	x _ syllables as: OrderedCollection.
	y _ aWord syllables as: OrderedCollection.
	[x notEmpty and: [y notEmpty and: [x last key = y first key]]]
		whileTrue:
			[| xn y1 exponent |
			xn _ x removeLast.
			y1 _ y removeFirst.
			(exponent _ xn value + y1 value) = 0
				ifFalse: [^ self class syllables: (x, {Association key: xn key value: exponent}, y) asArray]].
	^ self class syllables: (x, y) asArray! !

!Word methodsFor: 'arithmetic' stamp: 'len 7/8/2016 05:42'!
** anInteger
	anInteger = 1 ifTrue: [^ self].
	anInteger = 0 ifTrue: [^ self class empty].
	anInteger < 0 ifTrue: [^ self reciprocal ** anInteger negated].
	^ self squared ** (anInteger // 2) * (self ** (anInteger \\ 2))! !

!Word methodsFor: 'arithmetic' stamp: 'len 2/20/2016 05:34'!
/ aWord
	^ self * aWord reciprocal! !

!Word methodsFor: 'comparing' stamp: 'len 3/3/2016 05:23'!
= aWord
	^ syllables = aWord syllables! !

!Word methodsFor: 'iterating' stamp: 'len 3/3/2016 05:23'!
do: aBinaryBlock
	syllables do: [:each| aBinaryBlock value: each key value: each value]! !

!Word methodsFor: 'comparing' stamp: 'len 3/3/2016 05:23'!
hash
	^ syllables hash! !

!Word methodsFor: 'testing' stamp: 'len 3/3/2016 05:23'!
isEmpty
	^ syllables isEmpty! !

!Word methodsFor: 'accessing' stamp: 'len 3/3/2016 05:26'!
length
	^ syllables sum: [:each| each value abs]! !

!Word methodsFor: 'printing' stamp: 'len 7/2/2016 16:29'!
printExponent: anInteger on: aStream
	| exponent |
	(exponent _ anInteger printString) = '1'
		ifTrue: [^ self].
	aStream isText
		ifTrue:
			[aStream nextPutAll: exponent super.
			^ self].
	aStream nextPut: $^.
	exponent size = 1
		ifTrue: [aStream nextPutAll: exponent]
		ifFalse: [aStream nextPut: ${; nextPutAll: exponent; nextPut: $}]! !

!Word methodsFor: 'printing' stamp: 'len 7/26/2016 23:52'!
printIndeterminate: indeterminate on: aStream
	indeterminate isInteger
		ifFalse:
			[indeterminate class = self class
				ifTrue: [aStream nextPut: $(; print: indeterminate; nextPut: $)]
				ifFalse: [aStream print: indeterminate]. ^ self].
	aStream isText
		ifTrue: [aStream nextPut: $x; nextPutAll: indeterminate printString sub]
		ifFalse: [aStream halt nextPutAll: '{x', indeterminate printString, '}']! !

!Word methodsFor: 'printing' stamp: 'len 7/2/2016 16:31'!
printOn: aStream
	self isEmpty ifTrue: [aStream print: 1. ^ self].
	self do: [:i :exp| exp = 0 ifFalse: [self printIndeterminate: i on: aStream. self printExponent: exp on: aStream]]! !

!Word methodsFor: 'arithmetic' stamp: 'len 3/3/2016 05:21'!
reciprocal
	^ self class syllables: (syllables collect: [:each| Association key: each key value: each value negated]) reversed! !

!Word methodsFor: 'arithmetic' stamp: 'len 3/3/2016 05:23'!
reversed
	^ self class syllables: syllables reversed! !

!Word methodsFor: 'arithmetic' stamp: 'len 7/8/2016 05:50'!
squared
	^ self * self! !

!Word methodsFor: 'accessing' stamp: 'len 3/3/2016 05:24'!
syllables
	^ syllables! !

!Word methodsFor: 'accessing-private' stamp: 'len 3/3/2016 05:21'!
syllables: anArray
	syllables _ anArray! !

!Word methodsFor: 'accessing' stamp: 'len 6/29/2016 23:23'!
value
	^ syllables product: [:each| each key ** each value]! !

!Word class methodsFor: 'instance creation' stamp: 'len 6/30/2016 02:31'!
empty
	^ self syllables: #()! !

!Word class methodsFor: 'instance creation' stamp: 'len 6/30/2016 02:31'!
new
	^ self shouldNotImplement! !

!Word class methodsFor: 'instance creation' stamp: 'len 6/30/2016 02:30'!
syllables: anArray
	^ self basicNew syllables: anArray! !

!Word class methodsFor: 'instance creation' stamp: 'len 2/12/2016 07:30'!
x: i
	^ self x: i to: 1! !

!Word class methodsFor: 'instance creation' stamp: 'len 3/3/2016 05:24'!
x: i to: k
	"Answer a new instance of the receiver with only one indeterminate, xi, raised to n."
	k = 0 ifTrue: [^ self empty].
	^ self syllables: {i -> k}! !

!GroupPresentation methodsFor: 'morphisms' stamp: 'len 10/9/2016 21:14'!
* aPresentation
	"Answer the free product of the receiver with the argument."
	^ self class generators: (generators, aPresentation generators) relators: (relators, aPresentation relators)! !

!GroupPresentation methodsFor: 'morphisms' stamp: 'len 10/9/2016 21:13'!
 aPresentation
	^ self class generators: (generators, aPresentation generators) relators: (relators, aPresentation relators, (self commutatorWith: aPresentation))! !

!GroupPresentation methodsFor: 'accessing' stamp: 'len 2/12/2016 07:49'!
deficiency
	^ generators size - relators size! !

!GroupPresentation methodsFor: 'accessing' stamp: 'len 11/27/2015 21:34'!
generators
	^ generators! !

!GroupPresentation methodsFor: 'accessing-private' stamp: 'len 11/27/2015 21:35'!
generators: aCollection
	generators _ aCollection! !

!GroupPresentation methodsFor: 'printing' stamp: 'len 2/12/2016 07:34'!
printOn: aStream
	aStream nextPut: $<.
	generators do: [:each| aStream print: each] separatedBy: [aStream nextPut: $,].
	aStream nextPutAll: ' | '.
	relators isEmpty ifTrue: [aStream nextPut: Character emptySet].
	relators do: [:each| aStream print: each; nextPutAll: '=1'] separatedBy: [aStream nextPut: $,].
	aStream nextPut: $>! !

!GroupPresentation methodsFor: 'accessing' stamp: 'len 11/27/2015 21:34'!
relators
	^ relators! !

!GroupPresentation methodsFor: 'accessing-private' stamp: 'len 11/27/2015 21:35'!
relators: aCollection
	relators _ aCollection! !

!GroupPresentation class methodsFor: 'examples' stamp: 'len 2/13/2016 08:37'!
C: n
	"Answer the cyclic group of order n."
	| x |
	x _ Word x: 1.
	^ self generators: {x} relators: {x**n}! !

!GroupPresentation class methodsFor: 'examples' stamp: 'len 2/13/2016 08:37'!
D: n
	"Answer the dihedral group of order n."
	| x1 x2 |
	x1 _ Word x: 1.
	x2 _ Word x: 2.
	^ self generators: {x1. x2} relators: {x1**n. x2**2. (x1*x2)**2}! !

!GroupPresentation class methodsFor: 'examples' stamp: 'len 11/27/2015 21:46'!
free: aCollection
	"Answer the free group on aCollection."
	^ self generators: aCollection relators: #()! !

!GroupPresentation class methodsFor: 'instance creation' stamp: 'len 11/27/2015 21:45'!
generators: aCollection relators: anotherCollection
	^ self new generators: aCollection; relators: anotherCollection! !

!SemidirectProductElement methodsFor: 'arithmetic' stamp: 'len 10/6/2016 15:37'!
* aSemidirectProduct
	^ self parent
		project:
			{parent left operation value: {left. aSemidirectProduct left}.
			parent right operation value: {parent action value: {aSemidirectProduct left. right}. aSemidirectProduct right}}! !

!SemidirectProductElement methodsFor: 'arithmetic' stamp: 'len 2/12/2016 06:14'!
/ aSemidirectProduct
	^ self * aSemidirectProduct reciprocal! !

!SemidirectProductElement methodsFor: 'constants' stamp: 'len 2/12/2016 06:09'!
identity
	^ self species identity! !

!SemidirectProductElement methodsFor: 'accessing' stamp: 'len 5/5/98 00:18'!
left
	"Answer the left component of the receiver."
	^ left! !

!SemidirectProductElement methodsFor: 'accessing-private' stamp: 'len 5/5/98 00:17'!
left: anObject
	left _ anObject! !

!SemidirectProductElement methodsFor: 'private' stamp: 'len 10/6/2016 15:37'!
parent
	^ parent! !

!SemidirectProductElement methodsFor: 'accessing-private' stamp: 'len 10/6/2016 15:37'!
parent: aSemidirectProductGroup
	parent _ aSemidirectProductGroup! !

!SemidirectProductElement methodsFor: 'printing' stamp: 'len 2/12/2016 06:10'!
printOn: aStream
	aStream nextPut: $(; print: left; nextPutAll: ', '; print: right; nextPut: $)! !

!SemidirectProductElement methodsFor: 'arithmetic' stamp: 'len 10/6/2016 15:36'!
reciprocal
	| leftInverse rightInverse |
	leftInverse _ parent left inverseMap value: left.
	rightInverse _ parent right inverseMap value: right.
	^ parent project: {leftInverse. parent right inverseMap value: (parent action value: {leftInverse. rightInverse})}! !

!SemidirectProductElement methodsFor: 'accessing' stamp: 'len 5/5/98 00:18'!
right
	"Answer the right component of the receiver."
	^ right! !

!SemidirectProductElement methodsFor: 'accessing-private' stamp: 'len 5/5/98 00:17'!
right: anObject
	right _ anObject! !

!SchreierSims methodsFor: 'accessing-private' stamp: 'len 6/22/2016 07:31'!
action: aGroupAction
	action _ aGroupAction! !

!SchreierSims methodsFor: 'accessing' stamp: 'len 6/30/2016 09:02'!
base
	"A base of a group G acting on X is a finite sequence of distinct points B={x1,..,xn} such that the stabilizer of B is {id}, i.e. the only element that fixes all xi is the identity."
	base ifNil: [self run].
	^ base! !

!SchreierSims methodsFor: 'computing-private' stamp: 'len 7/1/2016 05:46'!
buildBSGS
	base _ OrderedCollection new.
	strongGeneratingSet _ OrderedCollection new.
	self buildPartialBSGS.
	base size to: 1 by: -1 do: [:i| self schreierSimsStep: i]! !

!SchreierSims methodsFor: 'computing-private' stamp: 'len 7/1/2016 00:39'!
buildPartialBSGS
	| id |
	id _ action group identity.
	generators do: [:each| each = id ifFalse: [strongGeneratingSet add: each]].
	strongGeneratingSet copy do: [:s|
		(base allSatisfy: [:b| (s value: b) = b])
			ifTrue: [base add: (action space detect: [:one| action isFixedPoint: one])].
			s squared = id ifFalse: [base add: s inverse]]! !

!SchreierSims methodsFor: 'computing' stamp: 'len 6/30/2016 10:08'!
elementFromImage: anArray
	| image g |
	image _ anArray copy.
	g _ action group identity.
	trees withIndexDo: [:each :i|
		g _ (each trace: (image at: i)) * g.
		i to: base size do: [:j| image at: j put: (action value: {each traceInverse: (image at: i). image at: j})]].
	^ g! !

!SchreierSims methodsFor: 'accessing-private' stamp: 'len 6/22/2016 16:32'!
generators: aCollection
	generators _ aCollection asArray! !

!SchreierSims methodsFor: 'computing' stamp: 'len 6/30/2016 10:02'!
imageOf: anElement
	^ base collect: [:each| action value: {anElement. each}]! !

!SchreierSims methodsFor: 'computing' stamp: 'len 6/30/2016 10:13'!
includes: anElement
	"Answer true if the group includes anElement."
	^ (self strip: anElement) = action group identity! !

!SchreierSims methodsFor: 'accessing' stamp: 'len 6/30/2016 10:13'!
order
	"Answer the order of the group."
	order ifNil: [self run].
	^ order! !

!SchreierSims methodsFor: 'computing-private' stamp: 'len 7/19/2016 08:37'!
run
	| G |
	G _ action group.
	order _ 1.
	base _ OrderedCollection new.
	strongGeneratingSet _ OrderedCollection new.
	trees _ OrderedCollection new.
	G action space do: [:b| | tree |
		G isTrivial ifTrue: [^ order].
		tree _ SchreierTree root: b generators: G generators action: G action.
		trees add: tree.
		order _ order * tree orbit size.
		G _ tree stabilizer].
	self error: 'what?'.
	^ order! !

!SchreierSims methodsFor: 'computing' stamp: 'len 6/30/2016 09:55'!
strip: anElement
	| g |
	g _ anElement.
	trees withIndexDo: [:each :i| | b b` |
		b _ each root.
		b` _ action value: {g. b}.
		(each orbits includes: b`)
			ifFalse: [^ {g. i}].
		g _ g * (each traceInverse: b`)].
	^ {g. trees size + 1}! !

!SchreierSims methodsFor: 'accessing' stamp: 'len 6/25/2016 20:06'!
strongGeneratingSet
	strongGeneratingSet ifNil: [self run].
	^ strongGeneratingSet! !

!SchreierTree methodsFor: 'accessing' stamp: 'len 6/24/2016 03:07'!
orbit
	^ orbit! !

!SchreierTree methodsFor: 'initialization' stamp: 'len 6/27/2016 23:24'!
root: aPoint generators: anArray action: aGroupAction
	| queue |
	root _ aPoint.
	generators _ anArray.
	action _ aGroupAction.
	v _ Dictionary2 new. "Schreier vector"
	w _ Dictionary2 new. "backward pointers"
	orbit _ Set2 with: aPoint.
	v at: aPoint put: nil. "-1"
	w at: aPoint put: nil. "-1"
	queue _ OrderedCollection with: aPoint.
	[| a |
	a _ queue removeFirst.
	1 to: generators size do: [:i|
		| x g |
		g _ generators at: i.
		x _ action value: {g. a}.
		(orbit includes: x)
			ifFalse:
				[orbit add: x.
				queue add: x.
				v at: x put: g.
				w at: x put: a]].
	queue isEmpty] whileFalse! !

!SchreierTree methodsFor: 'accessing' stamp: 'len 6/29/2016 08:57'!
stabilizer
	"Answer the stabilizer of the root."
	^ self notYetImplemented! !

!SchreierTree methodsFor: 'accessing' stamp: 'len 6/30/2016 09:43'!
trace: aPoint
	"Trace the Schreier spanning tree (v,w) for the orbit containing aPoint.
	Answer the transversal u(aPoint), i.e. an element such that root^u(aPoint) = aPoint.
	This is the representative function, and in particular u(root^h) is a representative of the coset G_root * h, where G_root is the stabilizer at the root of this Schreier tree.
	For an element g in G, there's an h in G_root g = h * u(root^g), and h = h * u(root^h)^-1."
	| alpha u |
	u _ action group identity.
	alpha _ aPoint.
	[(v at: alpha) notNil]
		whileTrue:
			[u _ (v at: alpha) * u.
			alpha _ w at: alpha].
	^ u! !

!SchreierTree methodsFor: 'accessing' stamp: 'len 6/30/2016 09:33'!
traceInverse: aPoint
	"Calculate inverses of coset representatives. See 'the schreier-sims algorithm' pp 18. Assumes we're using a (strong) generating set that is closed under inversion. This makes backward pointers unnecesary."
	| alpha u |
	u _ action group identity.
	alpha _ aPoint.
	[(v at: alpha) notNil]
		whileTrue:
			[u _ u * (v at: alpha) reciprocal.
			alpha _ w at: alpha].
	^ u! !

!SchreierTree class methodsFor: 'instance creation' stamp: 'len 6/24/2016 03:07'!
root: aPoint generators: anArray action: aGroupAction
	^ self new root: aPoint generators: anArray action: aGroupAction! !

!Matrix methodsFor: 'arithmetic' stamp: 'len 3/28/2016 01:23'!
* anObject
	(anObject is: #Matrix) ifTrue: [^ self dot: anObject].
	(anObject is: #Tuple) ifTrue: [^ self dotProductWithTuple: anObject].
	(self scalars includes: anObject) ifFalse: [^ DomainError signal].
	^ self collect: [:each| each * anObject]! !

!Matrix methodsFor: 'arithmetic' stamp: 'len 7/8/2016 05:39'!
** anInteger
	"Answer the receiver raised to the power anInteger."
	anInteger = 1 ifTrue: [^ self].
	anInteger = 0 ifTrue: [^ self identity].
	anInteger < 0 ifTrue: [^ self reciprocal ** anInteger negated].
	^ (self squared ** (anInteger // 2)) * (self ** (anInteger \\ 2))! !

!Matrix methodsFor: 'arithmetic' stamp: 'len 3/23/2016 00:25'!
+ aMatrix
	self species = aMatrix species ifFalse: [^ DomainError signal: 'matrices of different species'].
	^ self species evaluating: [:i :j| (self at: i@j) + (aMatrix at: i@j)]! !

!Matrix methodsFor: 'arithmetic' stamp: 'len 3/23/2016 00:21'!
- aMatrix
	^ self + aMatrix negated! !

!Matrix methodsFor: 'arithmetic' stamp: 'len 11/5/2015 06:05'!
/ anObject
	^ self * anObject reciprocal! !

!Matrix methodsFor: 'comparing' stamp: 'len 3/23/2016 00:31'!
= anObject
	(anObject isKindOf: Matrix) ifFalse: [^ false].
	self numberOfRows = anObject numberOfRows ifFalse: [^ false].
	self numberOfColumns = anObject numberOfColumns ifFalse: [^ false].
	1 to: self numberOfRows do: [:i|
		1 to: self numberOfColumns do: [:j|
			(self at: i@j) = (anObject at: i@j) ifFalse: [^ false]]].
	^ true! !

!Matrix methodsFor: 'operations' stamp: 'len 2/23/2016 21:46'!
| aMatrix
	"Answer the receiver augmented with the columns of aMatrix."
	^ self columnAugmented: aMatrix! !

!Matrix methodsFor: 'comparing' stamp: 'len 7/16/2016 05:02'!
~ aMatrix
	"Answer true if the receiver is similar to aMatrix.
	Two matrices A and B are 'similar' if there exists an invertible matrix P such that B = P^-1 * A * P."
	^ self characteristicMatrix SNF = aMatrix characteristicMatrix SNF! !

!Matrix methodsFor: 'arithmetic' stamp: 'len 6/17/2016 02:54'!
 aMatrix
	^ self kronecker: aMatrix! !

!Matrix methodsFor: 'reduction' stamp: 'len 7/16/2016 01:27'!
HNF
	"Answer the Hermite normal form of the receiver."
	(self scalars isKindOf: Integers) ifFalse: [^ DomainError signal: 'coefficients ring is not Z'].
	^ HermiteNormalForm2 new matrix: self copy; run! !

!Matrix methodsFor: 'reduction' stamp: 'len 3/21/2016 23:35'!
QR
	"Answer the QR factorization of the receiver."
	^ QRDecomposition new matrix: self! !

!Matrix methodsFor: 'reduction' stamp: 'len 7/15/2016 23:53'!
SNF
	"Answer the diagonal of the Smith normal form of the receiver, ordered such that each element divides the next one."
	self scalars isPID ifFalse: [^ DomainError signal: 'coefficients ring is not a PID'].
	^ SmithNormalForm new matrix: self copy; diagonal! !

!Matrix methodsFor: 'converting' stamp: 'len 2/10/2016 21:38'!
adaptToNumber: aNumber andSend: selector
	selector == #* ifFalse: [^ super adaptToNumber: aNumber andSend: selector].
	^ self collect: [:each| aNumber * each]! !

!Matrix methodsFor: 'operations' stamp: 'len 6/23/2016 23:26'!
adjoint
	"Answer the conjugate transpose A* of the receiver A (also called Hermitian conjugate, bedaggered matrix, adjoint matrix or transjugate)."
	self species scalars isReal ifTrue: [^ self transposed].
	self species scalars isComplex ifTrue: [^ self transposed conjugated].
	^ self error: 'not real or complex matrix'! !

!Matrix methodsFor: 'operations' stamp: 'len 12/22/2015 21:12'!
adjugate
	"Answer the adjugate matrix (or classical adjoint matrix) of the receiver. This is the matrix such that multiplicated at the left by the receiver equals the scalar matrix with the determinant of the receiver in the diagonal."
	^ (self characteristicPolynomial shift: -1) negated value: self! !

!Matrix methodsFor: 'operations' stamp: 'len 6/25/2016 05:51'!
apply: aMorphism
	"Apply a homomorphism to the coefficients of the receiver."
	aMorphism domain = self species scalars
		ifTrue: [^ (self species over: aMorphism codomain) evaluating: [:i :j| aMorphism value: (self at: i at: j)]].
	^ DomainError signal! !

!Matrix methodsFor: 'converting' stamp: 'len 12/23/2015 05:12'!
asTuple
	"Answer the receiver converted to Tuple by concatenating its rows (which is also the coordinates of the receiver in the canonical basis)."
	| answer |
	self rowsDo: [:each| answer _ answer isNil ifTrue: [each] ifFalse: [answer, each]].
	^ answer! !

!Matrix methodsFor: 'accessing' stamp: 'len 7/16/2016 00:05'!
at: aPoint
	"Answer the coefficient at i@j (row i, column j)."
	^ self at: aPoint x at: aPoint y! !

!Matrix methodsFor: 'accessing' stamp: 'len 7/19/2016 23:23'!
at: i at: j add: anObject
	self at: i at: j put: (self at: i at: j) + anObject! !

!Matrix methodsFor: 'accessing' stamp: 'len 7/16/2016 00:05'!
at: aPoint put: anObject
	"Answer the coefficient at i@j (row i, column j)."
	^ self at: aPoint x at: aPoint y put: anObject! !

!Matrix methodsFor: 'operations' stamp: 'len 8/25/2016 06:38'!
berkowitz
	"Answer the coefficients of the characteristic polynomial of the receiver. It's computed by the Berkowitz algorithm, using small space in comparision with classic gaussian elimination."
	| vect C Ar R S Q one |
	one _ self scalars one.
	self numberOfRows = 1 ifTrue: [^ self scalars tuple: { one negated. (self at: 1@1) }].
	self numberOfRows = 2 ifTrue:
			[^ self scalars tuple:
				{one.
				((self at: 1@1) + (self at: 2@2)) negated.
				(self at: 1@1) * (self at: 2@2) - ((self at: 1@2) * (self at: 2@1))}].

	vect _ self scalars tuple:
		{one.
		(self at: 2@2) negated - (self at: 1@1).
		(self at: 2@2) * (self at: 1@1) - ((self at: 1@2) * (self at: 2@1))}.

	3 to: self numberOfRows do: [:r|
		C _ (self scalars ** (r+1 @ r)) zero.
		Ar _ self copyFrom: 1@1 to: r-1 @ (r-1).

		R _ (self rowAt: r) copyFrom: 1 to: r-1.
		S _ (self columnAt: r) copyFrom: 1 to: r-1.

		C at: 1@1 put: one negated.
		C at: 2@1 put: (self at: r@r).
		C at: 3@1 put: (R dot: S).

		Q _ Ar * S.

		C at: 4@1 put: (R dot: Q).

		3 to: r-1 do: [ :i |
			Q _ Ar * Q.
			C at: i+2 @ 1 put: (R dot: Q)].

		2 to: r do: [ :i |
			0 to: r+1-i do: [ :j |
				C at: i+j @ i put: (C at: j+1 @ 1)]].

		vect _ C * vect].

	^ vect! !

!Matrix methodsFor: 'operations' stamp: 'len 12/10/2015 04:36'!
berkowitz: x
	| polcar vect r power |

	r _ self numberOfRows + 1.
	vect _ self berkowitz.
	polcar _ x zero.
	power _ x one.
	r to: 1 by: -1 do: [ :i |
		polcar _ power * (vect at: i) + polcar.
		power _ power * x].

	^ r odd ifTrue: [polcar] ifFalse: [polcar negated]! !

!Matrix methodsFor: 'accessing' stamp: 'len 3/23/2016 00:17'!
bitSize
	^ self rows inject: 0 into: [:x :each| x + each bitSize]! !

!Matrix methodsFor: 'operations' stamp: 'len 8/25/2016 06:57'!
characteristicMatrix
	"Answer the characteristic matrix A - xI."
	| P x |
	P _ self scalars polynomials.
	x _ P x.
	^ P ** self dimension
		evaluating: [:i :j|
			i == j
				ifTrue: [(P constant: (self at: i @ j)) - x]
				ifFalse: [P constant: (self at: i @ j)]]! !

!Matrix methodsFor: 'operations' stamp: 'len 8/25/2016 06:54'!
characteristicMatrix2
	"Answer the characteristic matrix xI - A."
	| P MP |
	P _ self scalars polynomials.
	MP _ self species over: P.
	^ (MP scalar: P x) - (self as: MP)! !

!Matrix methodsFor: 'operations' stamp: 'len 8/25/2016 06:52'!
characteristicPolynomial
	^ self scalars polynomials coefficients: self berkowitz reversed! !

!Matrix methodsFor: 'operations' stamp: 'len 8/25/2016 06:41'!
characteristicPolynomial2
	| P x |
	P _ self scalars polynomials.
	x _ P x.
	^ (P ** self dimension
		evaluating: [:i :j| i == j ifTrue: [x - (P constant: (self at: i @ j))] ifFalse: [P constant: (self at: i @ j) negated]]) determinant! !

!Matrix methodsFor: 'operations' stamp: 'len 12/22/2015 21:23'!
characteristicPolynomial3
	"COHEN Algorithm 2.2.7. (Characteristic Polynomial and Anjoint Matrix) O(n^4)."
	| n i I C a |
	n _ self numberOfRows.
	i _ 0. I _ self species identity. C _ I. a _ OrderedCollection new: n.
	a add: self scalars one.
	[(i _ i + 1) = n
		ifTrue:
			[a add: (self * C) trace negated / n.
			^ self scalars polynomials coefficients: a reversed. "adj _ (-1)**(n-1) * C"].
	C _ self * C.
	a add: C trace negated / i.
	C _ C + (I * a last)] repeat! !

!Matrix methodsFor: 'operations' stamp: 'len 11/5/2015 06:08'!
cofactor: aPoint
	"Answer the cofactor i@j of the receiver."

	^ (aPoint x + aPoint y) even
		ifTrue: [(self minor: aPoint) determinant]
		ifFalse: [(self minor: aPoint) determinant negated]! !

!Matrix methodsFor: 'subspaces' stamp: 'len 2/22/2016 06:07'!
coimage
	^ self rowSpace! !

!Matrix methodsFor: 'subspaces' stamp: 'len 2/22/2016 06:08'!
cokernel
	^ self image perp! !

!Matrix methodsFor: 'iterating' stamp: 'len 3/23/2016 00:23'!
collect: aBlock
	^ self species evaluating: [:i :j| aBlock value: (self at: i@j)]! !

!Matrix methodsFor: 'accessing' stamp: 'len 3/5/2016 22:28'!
columnAt: i put: aTuple
	self flag: #fix.
	aTuple withIndexDo: [:each :k| self at: k@i put: each] "note: this will fail with sparse tuples"! !

!Matrix methodsFor: 'operations' stamp: 'len 7/20/2016 03:09'!
columnAugmented: aMatrix
	"Answer the receiver augmented with the columns of aMatrix."
	| n m m` |
	n _ self numberOfRows.
	m _ self numberOfColumns.
	(aMatrix is: #Tuple)
		ifTrue:
			[aMatrix size = n ifFalse: [^ DomainError signal: 'dimensions don''t match'].
			^ self species scalars ** (n @ (m+1)) rows: ((1 to: n) collect: [:i| (self rowAt: i), (aMatrix at: i)])].
	m` _ aMatrix numberOfColumns.
	aMatrix numberOfRows = n ifFalse: [^ DomainError signal: 'dimensions don''t match'].
	^ self species scalars ** (n @ (m+m`)) rows: ((1 to: n) collect: [:i| (self rowAt: i), (aMatrix rowAt: i)])! !

!Matrix methodsFor: 'subspaces' stamp: 'len 2/22/2016 00:55'!
columnSpace
	^ (self scalars ** self numberOfRows) span: self columns! !

!Matrix methodsFor: 'accessing' stamp: 'len 7/2/2016 17:13'!
columns
	^ (1 to: self numberOfColumns) collect: [:i| self columnAt: i]! !

!Matrix methodsFor: 'iterating' stamp: 'len 11/4/2015 23:07'!
columnsDo: aBlock
	1 to: self numberOfColumns do: [ :i | aBlock value: (self columnAt: i) ]! !

!Matrix methodsFor: 'operations' stamp: 'len 12/11/2015 00:20'!
comatrix
	"Answer the co-matrix (or cofactor matrix) of the receiver, i.e. the matrix '(a{ij})' where 'a{ij}' is the cofactor 'ij'."
	^ self adjugate transposed! !

!Matrix methodsFor: 'arithmetic' stamp: 'len 6/23/2016 23:27'!
conjugated
	^ self collect: [:each| each conjugated]! !

!Matrix methodsFor: 'copying' stamp: 'len 11/26/2015 04:28'!
copyFrom: aPoint to: anotherPoint
	"Answer the submatrix of the receiver from aPoint to anotherPoint."

	| start |
	start _ aPoint - (1@1).
	^ self scalars ** (anotherPoint - start)
		evaluating: [:i :j| self at: start + (i@j)]! !

!Matrix methodsFor: 'operations' stamp: 'len 3/17/2016 04:46'!
determinant
	self scalars isField
		ifTrue: [^ (GaussianElimination on: self copy) determinant].
	self scalars isIntegralDomain
		ifFalse: [self characteristicPolynomial independentCoefficient].
	"^ self determinant2"
	^ self characteristicPolynomial independentCoefficient! !

!Matrix methodsFor: 'operations' stamp: 'len 12/27/2015 02:25'!
determinant1
	^ self characteristicPolynomial independentCoefficient! !

!Matrix methodsFor: 'operations' stamp: 'len 12/27/2015 02:44'!
determinant2
	"COHEN Algorithm 2.2.6. (Determinant using Gauss-Bareiss). O(n^3)"
	| n M k c s p i t |
	self assert: self species scalars isIntegralDomain.
	self assert: self isSquare.
	n _ self numberOfRows.
	M _ self copy.
	k _ 0. c _ self scalars one. s _ self scalars one.
	[k _ k + 1.
	k = n ifTrue: [^ s * (M at: n@n)].
	p _ M at: k@k. i _ k.
	p isZero ifTrue: [i _ (k+1 to: n) detect: [:j| (M at: j@k) isZero not] ifNone: [^ self scalars zero]].
	k to: n do: [:j| t _ M at: i@j. M at: i@j put: (M at: k@j). M at: k@j put: t].
	s _ s negated.
	p _ M at: k@k.
	"the division t/c is exact, must use Euclidean division and discard the remainder"
	c | t ifFalse: [self halt].
	k+1 to: n do: [:j| t _ p * (M at: i@j) - ((M at: i@k) * (M at: k@j)). M at: i@j put: t/c].
	c _ p] repeat! !

!Matrix methodsFor: 'operations' stamp: 'len 12/27/2015 02:24'!
determinant3
	^ (GaussianElimination on: self copy) determinant! !

!Matrix methodsFor: 'accessing' stamp: 'len 4/22/2016 21:38'!
diagonal
	"Answer the diagonal of the receiver as a tuple."
	^ self scalars
		tuple: (self numberOfRows min: self numberOfColumns)
		evaluating: [:i| self at: i@i]! !

!Matrix methodsFor: 'iterating' stamp: 'len 1/7/2016 23:38'!
diagonalDo: aBlock
	| i |
	i _ 1.
	self rowsDo: [:each| aBlock value: (each at: i). i _ i + 1]! !

!Matrix methodsFor: 'accessing' stamp: 'len 11/5/2015 16:57'!
dimension
	^ self numberOfRows @ self numberOfColumns! !

!Matrix methodsFor: 'iterating' stamp: 'len 7/8/2016 04:30'!
do: aBlock
	self rowsDo: [:each| each do: aBlock ]! !

!Matrix methodsFor: 'arithmetic' stamp: 'len 3/28/2016 01:23'!
dot: aMatrix
	self numberOfColumns = aMatrix numberOfRows ifFalse: [^ DomainError signal: 'matrices dimensions don''t match'].
	self scalars = aMatrix scalars ifFalse: [^ DomainError signal: 'scalars don''t match'].
	^ self scalars ** (self numberOfRows @ aMatrix numberOfColumns)
		evaluating: [:i :j| (self rowAt: i) dot: (aMatrix columnAt: j)]! !

!Matrix methodsFor: 'arithmetic' stamp: 'len 4/16/2016 07:39'!
dotProductWithTuple: aTuple
	self numberOfColumns = aTuple size ifFalse: [^ self error: 'dimensions don''t match'].
	^ self scalars tuple: self numberOfRows evaluating: [:i| (self rowAt: i) dot: aTuple]! !

!Matrix methodsFor: 'eigenvalues' stamp: 'len 2/6/2016 21:32'!
eigenspaceAt: anEigenvalue
	^ (self - (self species scalar: anEigenvalue)) kernel! !

!Matrix methodsFor: 'eigenvalues' stamp: 'len 2/6/2016 19:39'!
eigenvalues
	^ self spectrum asSet! !

!Matrix methodsFor: 'comparing' stamp: 'len 6/28/2016 09:33'!
hash
	| answer |
	answer _ 0.
	1 to: self numberOfRows do: [:i|
		1 to: self numberOfColumns do: [:j|
			answer _ answer hashMultiply + (self at: i@j) hash]].
	^ answer! !

!Matrix methodsFor: 'constants' stamp: 'len 11/26/2015 03:46'!
identity
	^ self species identity! !

!Matrix methodsFor: 'subspaces' stamp: 'len 2/22/2016 06:07'!
image
	^ self columnSpace! !

!Matrix methodsFor: 'operations' stamp: 'len 11/5/2015 03:12'!
immanant
	^ self notYetImplemented! !

!Matrix methodsFor: 'arithmetic' stamp: 'len 12/26/2015 18:54'!
inverse
	"Answer the multiplicative inverse of the receiver."
	self species scalars isField
		ifTrue: [^ (self reducerWith: self species identity) extension].
	^ self adjugate / self determinant! !

!Matrix methodsFor: 'testing' stamp: 'len 11/26/2015 01:40'!
is: aSymbol
	^ aSymbol == #Matrix or: [super is: aSymbol]! !

!Matrix methodsFor: 'testing' stamp: 'len 11/2/2015 06:04'!
isDiagonal
	^ self isLowerTriangular and: [ self isUpperTriangular ]! !

!Matrix methodsFor: 'testing' stamp: 'len 5/23/2016 19:55'!
isFullRank
	^ self rank = (self numberOfColumns min: self numberOfRows)! !

!Matrix methodsFor: 'testing' stamp: 'len 7/16/2016 01:00'!
isHNF
	"Answer true if the receiver is in (row) Hermite normal form."
	self isUpperTriangular ifFalse: [^ false].
	1 to: (self numberOfRows min: self numberOfColumns) do: [:j|
		| pivot |
		((pivot _ self at: j@j) isInteger and: [pivot > 0]) ifFalse: [^ false].
		1 to: j-1 do: [:i|
			| x |
			((x _ self at: i@j) isInteger and: [x >= 0 and: [x < pivot]])
				ifFalse: [^ false]]].
	self numberOfColumns + 1 to: self numberOfRows do: [:i|
		(self rowAt: i) isZero ifFalse: [^ false]].
	^ true! !

!Matrix methodsFor: 'testing' stamp: 'len 6/23/2016 23:25'!
isHermitian
	"Answer true if the receiver is Hermitian (or self-adjoint)."
	^ self = self adjoint! !

!Matrix methodsFor: 'testing' stamp: 'len 12/11/2015 00:32'!
isIdentity
	^ self = self species identity! !

!Matrix methodsFor: 'testing' stamp: 'len 2/11/2016 21:27'!
isInvertible
	self scalars isField ifFalse: [^ self error: 'scalars must be a field'].
	^ self isSingular not! !

!Matrix methodsFor: 'testing' stamp: 'len 11/4/2015 23:35'!
isLowerTriangular
	| n |
	n _ self numberOfRows min: self numberOfColumns.
	1 to: n do: [ :i | i+1 to: n do: [ :j | (self at: i at: j) isZero ifFalse: [ ^ false ] ] ].
	^ true! !

!Matrix methodsFor: 'testing' stamp: 'len 12/31/2015 05:52'!
isNormal
	^ self adjoint * self = (self * self adjoint)! !

!Matrix methodsFor: 'testing' stamp: 'len 2/6/2016 20:15'!
isOrthogonal
	"A real square matrix Q is orthogonal if Q^t * Q = I (the transposed is the inverse).
	Equivalently:
		- Q has orthonormal columns and rows;
		- For all v, ||Qv|| = ||v||."
	^ self isSquare and: [(self * self transposed) isIdentity]! !

!Matrix methodsFor: 'testing' stamp: 'len 5/23/2016 19:55'!
isRankDeficient
	^ self isFullRank not! !

!Matrix methodsFor: 'testing' stamp: 'len 2/11/2016 06:24'!
isScalar
	self isDiagonal ifFalse: [^ false].
	2 to: self numberOfRows do: [:i|
		(self at: i@i) = (self at: 1@1) ifFalse: [^ false]].
	^ true! !

!Matrix methodsFor: 'testing' stamp: 'len 3/17/2016 05:12'!
isSemisimple
	^ self minimalPolynomial isSquareFree! !

!Matrix methodsFor: 'testing' stamp: 'len 12/31/2015 05:53'!
isSingular
	"Answer true if the receiver is a singular matrix."
	^ self determinant isZero! !

!Matrix methodsFor: 'testing' stamp: 'len 12/31/2015 05:51'!
isSkewHermitian
	"Answer true if the receiver is skew-Hermitian (or antihermitian)."
	^ self = self adjoint negated! !

!Matrix methodsFor: 'testing' stamp: 'len 12/31/2015 05:53'!
isSkewSymmetric
	"Answer true if the receiver is a skew-symmetric matrix."
	^ self negated = self transposed! !

!Matrix methodsFor: 'testing' stamp: 'len 11/3/2015 21:34'!
isSquare
	^ self numberOfRows = self numberOfColumns! !

!Matrix methodsFor: 'testing' stamp: 'len 11/5/2015 06:13'!
isSymmetric
	"Answer true if the receiver is a symmetric matrix."

	^ self = self transposed! !

!Matrix methodsFor: 'testing' stamp: 'len 11/2/2015 06:06'!
isTriangular
	^ self isLowerTriangular or: [ self isUpperTriangular ]! !

!Matrix methodsFor: 'testing' stamp: 'len 2/8/2016 20:37'!
isUnimodular
	^ self determinant = self scalars one! !

!Matrix methodsFor: 'testing' stamp: 'len 2/6/2016 20:16'!
isUnitary
	"A complex square matrix U is unitary if U* * U = I (the adjoint is the inverse).
	Equivalently:
		- U has orthonormal columns and rows;
		- For all v, ||Uv|| = ||v||."
	^ self isSquare and: [(self * self adjoint) isIdentity]! !

!Matrix methodsFor: 'testing' stamp: 'len 11/2/2015 06:04'!
isUpperTriangular
	^ self transposed isLowerTriangular! !

!Matrix methodsFor: 'testing' stamp: 'len 3/23/2016 00:27'!
isZero
	self do: [:each| each isZero ifFalse: [^ false]].
	^ true! !

!Matrix methodsFor: 'reduction' stamp: 'len 3/21/2016 09:38'!
jordan
	"Answer the Jordan blocks of the receiver's Jordan Normal Form."
	^ JordanNormalForm new matrix: self; blocks! !

!Matrix methodsFor: 'subspaces' stamp: 'len 2/22/2016 07:59'!
kernel
	| n reducer vectors |
	n _ self numberOfColumns.
	"reduce the agumented matrix [A^t | I], then a linear basis of the kernel is given by the rows of the extension corresponding to zero rows in the reduced matrix."
	reducer _ self transposed reducerWith: (self scalars ** (n @ n)) identity.
	vectors _ OrderedCollection new.
	reducer reduced rows withIndexDo: [:row :i|
		row isZero ifTrue: [vectors add: (reducer extension rowAt: i)]].
	^ self scalars ** n span: vectors! !

!Matrix methodsFor: 'subspaces' stamp: 'len 2/22/2016 08:03'!
kernel2
	^ self coimage perp "an alternetive implementation, but much slower"! !

!Matrix methodsFor: 'arithmetic' stamp: 'len 11/27/2015 04:28'!
kronecker: aMatrix
	"Answer the Kronecker product of the receiver by the argument."
	| m n p q |
	m _ self numberOfRows.
	n _ self numberOfColumns.
	p _ aMatrix numberOfRows.
	q _ aMatrix numberOfColumns.
	^ self scalars ** ((m*p) @ (n*q))
		evaluating: [:i :j|
			(self at: (i-1)*m//(m*p)+1 @ ((j-1)*n//(n*q)+1)) *
			(aMatrix at: (i-1)\\p+1 @ ((j-1)\\q+1))]! !

!Matrix methodsFor: 'accessing' stamp: 'len 11/7/2015 03:06'!
lastColumn
	^ self columnAt: self numberOfColumns! !

!Matrix methodsFor: 'arithmetic' stamp: 'len 12/10/2015 23:50'!
leftInverse
	| T |
	T _ self transposed.
	^ (T * self) inverse * T! !

!Matrix methodsFor: 'operations' stamp: 'len 2/27/2016 07:18'!
minimal: aTuple
	"Answer the minimal polynomial of aTuple with respect to the receiver."
	| matrix power reducer d |
	matrix _ self species new.
	matrix addRow: aTuple.
	power _ self identity.
	self numberOfRows
		timesRepeat: [matrix addRow: (power _ power * self) * aTuple].
	reducer _ matrix transposed reducer.
	d _ reducer dependentColumns first.
	^ self scalars polynomials
		coefficients: (((reducer reduced columnAt: d) negated copyFrom: 1 to: d - 1) asArray copyWith: self scalars one)! !

!Matrix methodsFor: 'operations' stamp: 'len 12/11/2015 05:55'!
minimalPolynomial
	| answer |
	self rowSpace basis do: [:each|
		answer _ answer isNil
			ifTrue: [self minimal: each]
			ifFalse: [answer lcm: (self minimal: each)]].
	^ answer! !

!Matrix methodsFor: 'operations' stamp: 'len 7/8/2016 23:45'!
minimalPolynomial2
	^ self characteristicPolynomial squareFree! !

!Matrix methodsFor: 'operations' stamp: 'len 12/12/2015 21:28'!
minor: aPoint
	"Answer the matrix obtained removing the column y and the row x from the receiver, where aPoint is x@y."
	^ self scalars ** (self numberOfRows - 1 @ (self numberOfColumns - 1))
		evaluating: [:i :j|
			| x y |
			i < aPoint x ifTrue: [x _ i] ifFalse: [x _ i + 1].
			j < aPoint y ifTrue: [y _ j] ifFalse: [y _ j + 1].
			self at: x@y]! !

!Matrix methodsFor: 'arithmetic' stamp: 'len 3/23/2016 00:23'!
negated
	^ self collect: [:each| each negated]! !

!Matrix methodsFor: 'operations' stamp: 'len 3/21/2016 09:19'!
nullity
	^ self numberOfRows - self rank! !

!Matrix methodsFor: 'constants' stamp: 'len 3/2/2016 20:54'!
one
	^ self identity! !

!Matrix methodsFor: 'accessing' stamp: 'len 10/6/2016 15:30'!
parent
	^ parent! !

!Matrix methodsFor: 'initialization' stamp: 'len 10/6/2016 15:31'!
parent: aMatrixSpace
	parent _ aMatrixSpace! !

!Matrix methodsFor: 'operations' stamp: 'len 11/5/2015 02:51'!
permanent
	^ self notYetImplemented! !

!Matrix methodsFor: 'printing' stamp: 'len 7/16/2016 05:22'!
printBitsOn: aStream
	self rows do: [:row|
		aStream nextPut: $[.
		row do: [:bit| aStream nextPut: (bit isZero ifTrue: [$0] ifFalse: [$1])].
		aStream nextPut: $]] separatedBy: [aStream cr]! !

!Matrix methodsFor: 'printing' stamp: 'len 7/16/2016 23:09'!
printOn: aStream
	| pads string pad |
	aStream cr.
	self scalars size = 2 ifTrue: [^ self printBitsOn: aStream].
	pads _ (1 to: self numberOfColumns) collect: [:each| 0].
	self rows do: [:each|
		1 to: each dimension do: [ :index |
			pads at: index put: ((pads at: index) max: (each at: index) printString size)]].
	self rows do: [:each|
		aStream nextPut: $[.
		1 to: each size - 1 do: [ :index |
			string _ (each at: index) printString.
			pad _ (pads at: index) - string size.
			pad // 2 timesRepeat: [aStream space].
			aStream nextPutAll: string.
			pad // 2 + (pad \\ 2) + 3 timesRepeat: [aStream space]].
		string _ (each at: each size) printString.
		pad _ (pads at: each size) - string size.
		pad // 2 timesRepeat: [aStream space].
		aStream nextPutAll: string.
		pad // 2 + (pad \\ 2) timesRepeat: [aStream space].
		aStream nextPut: $]] separatedBy: [aStream cr]! !

!Matrix methodsFor: 'printing' stamp: 'len 7/15/2016 03:44'!
printTeXOn: aStream
	aStream nextPutAll: '\pmatrix'; cr.
	self rows do: [:each|
		1 to: each size - 1 do: [:index|
			aStream print: (each at: index); nextPutAll: ' & '].
		aStream print: (each at: each size); nextPutAll: ' \cr'; cr].
	aStream nextPutAll: '\endmatrix'! !

!Matrix methodsFor: 'arithmetic' stamp: 'len 12/11/2015 00:14'!
pseudoInverse
	"Answer the Moore-Penrose pseudoinverse matrix of the receiver."
	^ self notYetImplemented! !

!Matrix methodsFor: 'operations' stamp: 'len 12/3/2015 04:38'!
rank
	^ self reducer rank! !

!Matrix methodsFor: 'arithmetic' stamp: 'len 12/10/2015 23:51'!
reciprocal
	^ self inverse! !

!Matrix methodsFor: 'reduction' stamp: 'len 7/20/2016 02:40'!
reducer
	self scalars isField ifTrue: [^ GaussianElimination on: self copy].
	(self scalars isRing and: [self scalars isCommutative]) ifTrue: [^ GaussBareiss on: self copy].
	^ DomainError signal! !

!Matrix methodsFor: 'reduction' stamp: 'len 7/20/2016 02:40'!
reducerWith: aMatrix
	self scalars isField ifTrue: [^ GaussianElimination on: self copy extension: aMatrix copy].
	(self scalars isRing and: [self scalars isCommutative]) ifTrue: [^ GaussBareiss on: self copy extension: aMatrix copy].
	^ DomainError signal! !

!Matrix methodsFor: 'arithmetic' stamp: 'len 12/10/2015 23:50'!
rightInverse
	| T |
	T _ self transposed.
	^ T * (self * T) inverse! !

!Matrix methodsFor: 'accessing' stamp: 'len 3/23/2016 02:55'!
rowAt: i put: aTuple
	self flag: #fix.
	aTuple withIndexDo: [:each :k| self at: i@k put: each] "note: this will fail with sparse tuples"! !

!Matrix methodsFor: 'operations' stamp: 'len 7/15/2016 05:09'!
rowAugmented: aMatrix
	"Answer the receiver augmented with the rows of aMatrix."
	| n n` m |
	n _ self numberOfRows.
	m _ self numberOfColumns.
	(aMatrix is: #Tuple)
		ifTrue:
			[aMatrix size = m ifFalse: [^ DomainError signal: 'dimensions don''t match'].
			^ self species scalars ** (n+1 @ m) rows: (self rows copyWith: aMatrix)].
	n` _ aMatrix numberOfRows.
	aMatrix numberOfColumns = m ifFalse: [^ DomainError signal: 'dimensions don''t match'].
	^ self species scalars ** (n+n` @ m) rows: self rows, aMatrix rows! !

!Matrix methodsFor: 'subspaces' stamp: 'len 2/22/2016 00:56'!
rowSpace
	^ (self scalars ** self numberOfColumns) span: self rows! !

!Matrix methodsFor: 'accessing' stamp: 'len 7/2/2016 17:12'!
rows
	^ (1 to: self numberOfRows) collect: [:i| self rowAt: i]! !

!Matrix methodsFor: 'accessing' stamp: 'len 10/6/2016 15:29'!
scalars
	^ self parent scalars! !

!Matrix methodsFor: 'private' stamp: 'len 10/6/2016 15:39'!
species
	^ self parent! !

!Matrix methodsFor: 'eigenvalues' stamp: 'len 2/6/2016 19:45'!
spectralRadius
	(self scalars isReal or: [self scalars isComplex])
		ifFalse: [^ DomainError signal: 'spectral radius defined for matrices with complex scalars'].
	^ self spectrum max: [:each| each abs]! !

!Matrix methodsFor: 'eigenvalues' stamp: 'len 2/6/2016 19:38'!
spectrum
	^ self characteristicPolynomial roots! !

!Matrix methodsFor: 'arithmetic' stamp: 'len 11/3/2015 20:35'!
squared
	^ self * self! !

!Matrix methodsFor: 'operations' stamp: 'len 1/5/2016 23:47'!
trace
	| answer |
	self isSquare ifFalse: [^ self error: 'the matrix is not square'].
	answer _ self scalars zero.
	1 to: self numberOfRows do: [:i| answer _ answer + (self at: i at: i)].
	^ answer! !

!Matrix methodsFor: 'operations' stamp: 'len 7/15/2016 05:09'!
transposed
	^ self species transposed rows: self columns! !

!Matrix methodsFor: 'constants' stamp: 'len 12/11/2015 00:39'!
zero
	^ self species zero! !

!ColumnMatrix methodsFor: 'arithmetic' stamp: 'len 7/16/2016 03:46'!
% anInteger
	^ self species columns: (self columns collect: [:each| each % anInteger])! !

!ColumnMatrix methodsFor: 'arithmetic' stamp: 'len 7/15/2016 05:07'!
+ aMatrix
	^ self species columns: columns + aMatrix columns! !

!ColumnMatrix methodsFor: 'arithmetic' stamp: 'len 7/15/2016 05:07'!
- aMatrix
	^ self species columns: columns - aMatrix columns! !

!ColumnMatrix methodsFor: 'accessing' stamp: 'len 3/23/2016 02:45'!
addColumn: aTuple
	^ columns add: aTuple! !

!ColumnMatrix methodsFor: 'accessing' stamp: 'len 3/23/2016 02:45'!
at: i at: j
	^ (columns at: j) at: i! !

!ColumnMatrix methodsFor: 'accessing' stamp: 'len 3/23/2016 02:46'!
at: i at: j put: anObject
	^ (columns at: j) at: i put: anObject! !

!ColumnMatrix methodsFor: 'iterating' stamp: 'len 7/15/2016 05:07'!
collect: aBlock
	^ self species columns: (columns collect: [:each| each collect: aBlock])! !

!ColumnMatrix methodsFor: 'accessing' stamp: 'len 3/23/2016 02:53'!
columnAt: j
	^ columns at: j! !

!ColumnMatrix methodsFor: 'accessing' stamp: 'len 3/23/2016 02:54'!
columnAt: i put: aTuple
	^ columns at: i put: aTuple! !

!ColumnMatrix methodsFor: 'accessing' stamp: 'len 3/23/2016 02:55'!
columns
	^ columns! !

!ColumnMatrix methodsFor: 'accessing' stamp: 'len 3/23/2016 02:56'!
columns: anArray
	columns _ anArray! !

!ColumnMatrix methodsFor: 'iterating' stamp: 'len 3/23/2016 02:57'!
columnsDo: aBlock
	columns do: aBlock! !

!ColumnMatrix methodsFor: 'copying' stamp: 'len 7/15/2016 05:07'!
copy
	^ self species columns: (columns collect: [ :each | each copy])! !

!ColumnMatrix methodsFor: 'testing' stamp: 'len 3/23/2016 02:44'!
isZero
	^ columns allSatisfy: [:each| each isZero]! !

!ColumnMatrix methodsFor: 'arithmetic' stamp: 'len 7/15/2016 05:07'!
negated
	^ self species columns: columns negated! !

!ColumnMatrix methodsFor: 'accessing' stamp: 'len 3/23/2016 02:52'!
numberOfColumns
	^ columns size! !

!ColumnMatrix methodsFor: 'accessing' stamp: 'len 3/23/2016 02:52'!
numberOfRows
	columns isEmpty ifTrue: [^ 0].
	^ columns first size! !

!ColumnMatrix methodsFor: 'accessing' stamp: 'len 4/22/2016 21:54'!
rowAt: i
	^ self scalars tuple: (columns collect: [:each | each at: i])! !

!ColumnMatrix class methodsFor: 'instance creation' stamp: 'len 7/15/2016 05:08'!
columns: anArray
	^ self basicNew columns: anArray! !

!ColumnMatrix class methodsFor: 'instance creation' stamp: 'len 7/15/2016 05:07'!
new
	^ self columns: OrderedCollection new! !

!RowMatrix methodsFor: 'arithmetic' stamp: 'len 7/16/2016 03:46'!
% anInteger
	^ self species rows: (self rows collect: [:each| each % anInteger])! !

!RowMatrix methodsFor: 'arithmetic' stamp: 'len 7/15/2016 05:11'!
+ aMatrix
	self species = aMatrix species ifFalse: [^ DomainError signal: 'matrices of different species'].
	^ self species rows: rows + aMatrix rows! !

!RowMatrix methodsFor: 'arithmetic' stamp: 'len 7/15/2016 05:11'!
- aMatrix
	self species = aMatrix species ifFalse: [^ DomainError signal: 'matrices of different species'].
	^ self species rows: rows - aMatrix rows! !

!RowMatrix methodsFor: 'reduction-operations' stamp: 'len 3/23/2016 00:17'!
addColumn: i multipliedBy: factor toColumn: j
	rows do: [:each| each at: j put: (each at: i) * factor + (each at: j)]! !

!RowMatrix methodsFor: 'accessing' stamp: 'len 3/23/2016 00:19'!
addRow: aTuple
	^ rows add: aTuple! !

!RowMatrix methodsFor: 'reduction-operations' stamp: 'len 3/23/2016 00:20'!
addRow: i multipliedBy: factor toRow: j
	rows at: j put: (rows at: i) * factor + (rows at: j)! !

!RowMatrix methodsFor: 'accessing' stamp: 'len 3/23/2016 02:46'!
at: i at: j
	^ (rows at: i) at: j! !

!RowMatrix methodsFor: 'accessing' stamp: 'len 3/23/2016 02:46'!
at: i at: j put: anObject
	^ (rows at: i) at: j put: anObject! !

!RowMatrix methodsFor: 'iterating' stamp: 'len 7/15/2016 05:11'!
collect: aBlock
	^ self species rows: (rows collect: [:each| each collect: aBlock])! !

!RowMatrix methodsFor: 'accessing' stamp: 'len 4/22/2016 21:40'!
columnAt: j
	^ self scalars tuple: rows size evaluating: [:i| (rows at: i) at: j ifAbsent: [self scalars zero]]! !

!RowMatrix methodsFor: 'copying' stamp: 'len 7/15/2016 05:11'!
copy
	^ self species rows: (rows collect: [ :each | each copy])! !

!RowMatrix methodsFor: 'testing' stamp: 'len 3/23/2016 00:19'!
isZero
	^ rows allSatisfy: [:each| each isZero]! !

!RowMatrix methodsFor: 'reduction-operations' stamp: 'len 3/23/2016 00:19'!
multiplyColumn: i by: factor
	rows do: [:each| each at: i put: (each at: i) * factor]! !

!RowMatrix methodsFor: 'reduction-operations' stamp: 'len 3/23/2016 00:18'!
multiplyRow: i by: factor
	rows at: i put: (rows at: i) * factor! !

!RowMatrix methodsFor: 'arithmetic' stamp: 'len 7/15/2016 05:11'!
negated
	^ self species rows: rows negated! !

!RowMatrix methodsFor: 'accessing' stamp: 'len 3/23/2016 02:52'!
numberOfColumns
	rows isEmpty ifTrue: [^ 0].
	^ rows first size! !

!RowMatrix methodsFor: 'accessing' stamp: 'len 3/23/2016 00:18'!
numberOfRows
	^ rows size! !

!RowMatrix methodsFor: 'accessing' stamp: 'len 3/23/2016 00:16'!
rowAt: i
	^ rows at: i! !

!RowMatrix methodsFor: 'accessing' stamp: 'len 3/23/2016 00:18'!
rowAt: i put: aTuple
	^ rows at: i put: aTuple! !

!RowMatrix methodsFor: 'accessing' stamp: 'len 3/23/2016 00:17'!
rows
	^ rows! !

!RowMatrix methodsFor: 'initialization' stamp: 'len 3/23/2016 00:20'!
rows: anArray
	rows _ anArray! !

!RowMatrix methodsFor: 'iterating' stamp: 'len 3/23/2016 00:18'!
rowsDo: aBlock
	rows do: aBlock! !

!RowMatrix methodsFor: 'reduction-operations' stamp: 'len 3/23/2016 00:20'!
swapColumn: i with: j
	rows do: [:each| each swap: i with: j]! !

!RowMatrix methodsFor: 'reduction-operations' stamp: 'len 3/23/2016 00:17'!
swapRow: i with: j
	rows swap: i with: j! !

!RowMatrix class methodsFor: 'instance creation' stamp: 'len 7/15/2016 05:11'!
new
	^ self rows: OrderedCollection new! !

!RowMatrix class methodsFor: 'instance creation' stamp: 'len 7/15/2016 05:12'!
rows: anArray
	^ self basicNew rows: anArray! !

!SparseMatrix methodsFor: 'as yet unclassified' stamp: 'len 7/8/2016 05:30'!
+ aMatrix
	self species = aMatrix species ifFalse: [^ DomainError signal: 'matrices of different species'].
	aMatrix class = self class ifTrue: [^ self species sparse: self coefficients + aMatrix coefficients].
	^ self species evaluating: [:i :j| (self at: i@j) + (aMatrix at: i@j)]! !

!SparseMatrix methodsFor: 'as yet unclassified' stamp: 'len 7/8/2016 05:31'!
- aMatrix
	self species = aMatrix species ifFalse: [^ DomainError signal: 'matrices of different species'].
	aMatrix class = self class ifTrue: [^ self species sparse: self coefficients - aMatrix coefficients].
	^ self species evaluating: [:i :j| (self at: i@j) - (aMatrix at: i@j)]! !

!SparseMatrix methodsFor: 'as yet unclassified' stamp: 'len 10/6/2016 15:30'!
at: i at: j
	^ coefficients at: i@j ifAbsent: [parent scalars zero]! !

!SparseMatrix methodsFor: 'as yet unclassified' stamp: 'len 7/8/2016 04:10'!
at: i at: j put: anObject
	^ coefficients at: i@j put: anObject! !

!SparseMatrix methodsFor: 'as yet unclassified' stamp: 'len 7/8/2016 04:12'!
coefficients: aSparseTuple
	coefficients _ aSparseTuple! !

!SparseMatrix methodsFor: 'as yet unclassified' stamp: 'len 10/6/2016 15:32'!
parent: aMatrixSpace
	super parent: aMatrixSpace.
	coefficients isNil ifTrue: [coefficients _ SparseTuple zero: aMatrixSpace scalars zero]! !

!LinearEquation methodsFor: 'accessing' stamp: 'len 11/20/2015 06:16'!
, anObject
	"Answer the LinearSystem with the receiver and the argument."

	^ LinearSystem new add: self; , anObject! !

!LinearEquation methodsFor: 'accessing' stamp: 'len 5/23/2016 19:29'!
ambient
	"Answer the ambient vector space (where solutions live)."
	^ form domain ambient! !

!LinearEquation methodsFor: 'converting' stamp: 'len 6/3/2016 02:37'!
asPolynomialEquation
	^ form asPolynomial eq: value! !

!LinearEquation methodsFor: 'converting' stamp: 'len 2/21/2016 06:50'!
asTuple
	"Answer a Tuple with the coefficients of the receiver."
	^ form asTuple, value! !

!LinearEquation methodsFor: 'accessing' stamp: 'len 11/20/2015 06:09'!
form
	"Answer the left side of the receiver (the linear form)."
	^ form! !

!LinearEquation methodsFor: 'accessing-private' stamp: 'len 8/20/97 21:01'!
form: aLinearForm
	form _ aLinearForm! !

!LinearEquation methodsFor: 'operations' stamp: 'len 11/19/2015 19:39'!
homogeneous
	"Answer the homogeneous equation associated to the receiver."

	^ self class form: self form value: self value zero! !

!LinearEquation methodsFor: 'testing' stamp: 'len 11/19/2015 18:50'!
isHomogeneous
	"Answer true if the receiver is an homogeneous equation."

	^ self value isZero! !

!LinearEquation methodsFor: 'testing' stamp: 'len 11/24/2015 06:13'!
isSolution: aVector
	"Answer true if the argument is a solution of the receiver."

	^ (self form value: aVector) = self value! !

!LinearEquation methodsFor: 'printing' stamp: 'len 8/20/97 21:22'!
printOn: aStream
	"Print a representation of the receiver on the stream aStream."

	aStream print: self form; nextPutAll: ' = '; print: self value! !

!LinearEquation methodsFor: 'operations' stamp: 'len 11/20/2015 06:15'!
solutions
	^ LinearSystem new add: self; solutions! !

!LinearEquation methodsFor: 'accessing' stamp: 'len 8/20/97 21:20'!
value
	"Answer the right side of the receiver (the independent term)."

	^ value! !

!LinearEquation methodsFor: 'accessing-private' stamp: 'len 8/20/97 21:01'!
value: anObject
	value _ anObject! !

!LinearEquation class methodsFor: 'instance creation' stamp: 'len 8/20/97 21:02'!
form: aLinearForm value: anObject
	"Answer a new instance of the receiver representing
	the equation 'aLinearForm = anObject'."

	^ self new form: aLinearForm; value: anObject! !

!LinearSystem methodsFor: 'accessing' stamp: 'len 11/25/97 01:50'!
, anObject
	"Answer a copy of the receiver concatenated with the argument."

	| answer |
	answer _ self copy.
	anObject class == self class
		ifTrue: [answer addAll: anObject]
		ifFalse: [answer add: anObject].
	^ answer! !

!LinearSystem methodsFor: 'accessing' stamp: 'len 11/20/2015 06:12'!
add: aLinearEquation
	^ equations add: aLinearEquation! !

!LinearSystem methodsFor: 'accessing' stamp: 'len 11/20/2015 06:12'!
addAll: aCollection
	^ equations addAll: aCollection! !

!LinearSystem methodsFor: 'accessing' stamp: 'len 5/23/2016 19:29'!
ambient
	"Answer the ambient vector space (where solutions live)."
	^ equations first ambient! !

!LinearSystem methodsFor: 'converting' stamp: 'len 6/3/2016 02:59'!
asPolynomialSystem
	| answer |
	answer _ PolynomialSystem new.
	equations do: [:each| answer add: each asPolynomialEquation].
	^ answer! !

!LinearSystem methodsFor: 'copying' stamp: 'len 11/20/2015 06:13'!
copy
	^ self class new addAll: equations; yourself! !

!LinearSystem methodsFor: 'iterating' stamp: 'len 11/20/2015 06:13'!
do: aBlock 
	equations do: aBlock! !

!LinearSystem methodsFor: 'operations' stamp: 'len 5/13/2016 07:43'!
homogeneous
	"Answer the homogeneous system associated to the receiver."

	| answer |
	answer _ self class new.
	self do: [:each| answer add: each homogeneous].
	^ answer! !

!LinearSystem methodsFor: 'initialization' stamp: 'len 5/13/2016 07:37'!
initialize
	equations _ OrderedCollection new! !

!LinearSystem methodsFor: 'testing' stamp: 'len 8/20/97 21:35'!
isHomogeneous
	"Answer true if the receiver is an homogeneous system."

	self do: [ :each | each isHomogeneous ifFalse: [^ false]].
	^ true! !

!LinearSystem methodsFor: 'testing' stamp: 'len 12/28/2015 03:03'!
isInconsistent
	^ self particular isNil! !

!LinearSystem methodsFor: 'testing' stamp: 'len 11/8/2015 03:55'!
isSolution: aVector
	"Answer true if the argument is a solution of the receiver."

	self do: [ :each | (each isSolution: aVector) ifFalse: [^ false]].
	^ true! !

!LinearSystem methodsFor: 'operations' stamp: 'len 2/29/2016 01:06'!
kernel
	^ self kernelBasis span! !

!LinearSystem methodsFor: 'operations' stamp: 'len 5/23/2016 04:26'!
kernel2
	^ self matrix2 kernel apply: self ambient basis vectorAt! !

!LinearSystem methodsFor: 'operations' stamp: 'len 11/8/2015 03:55'!
kernelBasis
	^ self solver kernelBasis! !

!LinearSystem methodsFor: 'operations' stamp: 'len 7/16/2016 03:47'!
matrix
	| answer |
	answer _ (self ambient scalars ** (self size @ self ambient dimension)) new.
	self do: [:each| answer addRow: each asTuple].
	^ answer! !

!LinearSystem methodsFor: 'operations' stamp: 'len 5/23/2016 04:27'!
matrix2
	| answer |
	answer _ (self ambient scalars ** (self size @ self ambient dimension)) new.
	self do: [:each| answer addRow: each form asTuple].
	^ answer! !

!LinearSystem methodsFor: 'operations' stamp: 'len 2/29/2016 02:49'!
particular
	"Answer a particular solution of the receiver, and nil if the system is not solvable."
	^ self solver particular! !

!LinearSystem methodsFor: 'printing' stamp: 'len 6/3/2016 02:48'!
printOn: aStream 
	aStream nextPut: ${.
	equations do: [:each| aStream print: each] separatedBy: [aStream nextPutAll: '; '].
	aStream nextPut: $}! !

!LinearSystem methodsFor: 'printing' stamp: 'len 11/8/2015 04:51'!
printTeXOn: aStream
	self size = 1 ifTrue: [self first printOn: aStream. ^ self].

	aStream nextPutAll: '\eqalign{'; cr.
	self do: [ :each |
		aStream
			print: each form;
			nextPutAll: ' &= ';
			print: each value; cr].
	aStream nextPut: $}; cr! !

!LinearSystem methodsFor: 'accessing' stamp: 'len 11/20/2015 06:13'!
size
	^ equations size! !

!LinearSystem methodsFor: 'operations' stamp: 'len 8/30/2016 05:48'!
solutions
	"Answer the manifold of solution of the receiver,
	or nil if the system has no solutions."

	^ self particular isNil
		ifFalse: [AffineLinearSpace representative: self particular direction: self kernel]! !

!LinearSystem methodsFor: 'private' stamp: 'len 11/8/2015 03:58'!
solver
	^ solver ifNil: [solver _ LinearSystemSolver system: self]! !

!LinearSystem class methodsFor: 'instance creation' stamp: 'len 10/17/97 03:44'!
new
	^ super new initialize! !

!GramSchmidt methodsFor: 'accessing-private' stamp: 'len 12/13/2015 00:31'!
basis: aLinearBasis
	basis _ aLinearBasis! !

!GramSchmidt methodsFor: 'accessing-private' stamp: 'len 12/23/2015 05:09'!
innerProduct: aFunction
	innerProduct _ aFunction! !

!GramSchmidt methodsFor: 'accessing' stamp: 'len 12/23/2015 05:18'!
matrix
	"Answer the matrix computed by the orthogonalization process."
	matrix isNil ifTrue: [matrix _ basis changeTo: self orthogonalBasis].
	^ matrix! !

!GramSchmidt methodsFor: 'accessing' stamp: 'len 12/23/2015 05:18'!
orthogonalBasis
	"Answer the orthogonalized basis."
	orthogonalBasis isNil ifTrue: [self orthogonalize].
	^ orthogonalBasis! !

!GramSchmidt methodsFor: 'operations' stamp: 'len 5/23/2016 04:47'!
orthogonalize
	"Orthogonalize the basis."
	| u uv vv |
	orthogonalBasis _ LinearBasis on: basis ambient.
	basis do: [:each|
		u _ each.
		orthogonalBasis do: [:v|
			uv _ innerProduct value: {u. v}.
			vv _ innerProduct value: {v. v}.
			u _ u - (v * uv / vv)].
		orthogonalBasis add: u]! !

!GramSchmidt methodsFor: 'accessing' stamp: 'len 2/6/2016 20:37'!
orthonormalBasis
	^ self orthogonalBasis collect: [:each| each / (innerProduct value: each value: each) squareRoot]! !

!GramSchmidt class methodsFor: 'instance creation' stamp: 'len 5/23/2016 04:46'!
basis: aLinearBasis
	"Answer a new instance of the receiver to orthogonalize aLinearBasis."
	^ self basis: aLinearBasis innerProduct: aLinearBasis ambient innerProduct! !

!GramSchmidt class methodsFor: 'instance creation' stamp: 'len 12/13/2015 00:24'!
basis: aLinearBasis innerProduct: aFunction
	"Answer a new instance of the receiver to orthogonalize aLinearBasis with the inner product aFunction."
	^ self new basis: aLinearBasis; innerProduct: aFunction! !

!HermiteNormalForm2 methodsFor: 'as yet unclassified' stamp: 'len 3/5/2016 22:52'!
matrix
	^ matrix! !

!HermiteNormalForm2 methodsFor: 'as yet unclassified' stamp: 'len 3/6/2016 04:14'!
matrix: aMatrix
	matrix _ aMatrix! !

!HermiteNormalForm2 methodsFor: 'as yet unclassified' stamp: 'len 3/21/2016 05:07'!
reduceStep2: i k: k
	| j0 b |
	"2. Row finished?"
	[(1 to: k-1) allSatisfy: [:j| (matrix at: i@j) = 0] ::
		ifTrue:
			[(matrix at: i@k) < 0 ifTrue: [matrix multiplyColumn: k by: -1].
			^ self "go to step 5"].
	"3. Choose non-zero entry:"
	j0 _ (1 to: k) argmin: [:j| (matrix at: i@j) abs].
	j0 < k ifTrue: [matrix swapColumn: j0 with: k].
	(matrix at: i@k) < 0 ifTrue: [matrix multiplyColumn: k by: -1].
	b _ matrix at: i@k.
	"4. Reduce:"
	1 to: k-1 do: [:j| | q |
"		q _ ((matrix at: i@j) / b) rounded."
		q _ (matrix at: i@j) // b.
		matrix addColumn: k multipliedBy: q negated toColumn: j]] repeat! !

!HermiteNormalForm2 methodsFor: 'as yet unclassified' stamp: 'len 3/21/2016 05:02'!
reduceStep: i k: k
	| j0 b |
	"2. Row finished?"
	[(1 to: k-1) allSatisfy: [:j| (matrix at: i@j) = 0] ::
		ifTrue:
			[(matrix at: i@k) < 0 ifTrue: [matrix multiplyColumn: k by: -1].
			^ self "go to step 5"].
	"3. Choose non-zero entry:"
	j0 _ (1 to: k) argmin: [:j| (matrix at: i@j) abs].
	j0 < k ifTrue: [matrix swapColumn: j0 with: k].
	(matrix at: i@k) < 0 ifTrue: [matrix multiplyColumn: k by: -1].
	b _ matrix at: i@k.
	"4. Reduce:"
	1 to: k-1 do: [:j| | q |
"		q _ ((matrix at: i@j) / b) rounded."
		q _ (matrix at: i@j) // b.
		matrix addColumn: k multipliedBy: q negated toColumn: j]] repeat! !

!HermiteNormalForm2 methodsFor: 'as yet unclassified' stamp: 'len 3/21/2016 05:02'!
run
	| n m i k l b |
	m _ matrix numberOfRows.
	n _ matrix numberOfColumns.
	"1. Initialize:"
	i _ m.
	k _ n.
	l _ m <= n ifTrue: [1] ifFalse: [m-n+1].
	[self reduceStep: i k: k.
	"5. Final reductions:"
	b _ matrix at: i@k.
	b = 0
		ifTrue:
			[k _ k + 1]
		ifFalse:
			[k+1 to: n do: [:j| | q |
			"	q _ ((matrix at: i@j) / b) floor." "or rounded or truncated?"
				q _ (matrix at: i@j) // b.
				matrix addColumn: k multipliedBy: q negated toColumn: j]].
	"6. Finished?"
	i = l] whileFalse: [i _ i - 1. k _ k - 1].
	^ matrix copyFrom: 1@k to: m@n! !

!HermiteNormalFormCRT methodsFor: 'as yet unclassified' stamp: 'len 7/16/2016 04:10'!
addColumn: a to: B
	^ (B columnAugmented: a) HNF columnAt: B numberOfColumns + 1! !

!HermiteNormalFormCRT methodsFor: 'as yet unclassified' stamp: 'len 7/16/2016 04:46'!
addRow: b to: H
	| H0 |
	H0 _ H isSquare
		ifTrue: [H]
		ifFalse:
			[H rowAugmented: (H scalars ** (H numberOfColumns - 1) :: zero, (H rowAugmented: b) determinant)].
	"..."! !

!HermiteNormalFormCRT methodsFor: 'as yet unclassified' stamp: 'len 7/16/2016 01:28'!
matrix: aMatrix
	matrix _ aMatrix! !

!HermiteNormalFormCRT methodsFor: 'as yet unclassified' stamp: 'len 7/16/2016 03:50'!
probablePivotsOf: aMatrix
	^ aMatrix % (10007 to: 46000) atRandom nextPrime :: reducer pivots
! !

!HermiteNormalFormCRT methodsFor: 'as yet unclassified' stamp: 'len 7/16/2016 04:35'!
run
"
	HNF _ matrix zero.
	HNF at: 1@1 put: (matrix at: 1@1).
	2 to: matrix numberOfColumns do: [:j|
		a _ matrix columnAt: j.
		x _ self addColumn: a.
		HNF _ addRow: a to: HNF | x
"! !

!JordanNormalForm methodsFor: 'as yet unclassified' stamp: 'len 3/21/2016 09:36'!
block: eigenvalue size: n
	| K one zero |
	K _ matrix scalars.
	one _ K one.
	zero _ K zero.
	^ K ** (n@n) evaluating: [:i :j| i=j ifTrue: [eigenvalue] ifFalse: [j-1=i ifTrue: [one] ifFalse: [zero]]]! !

!JordanNormalForm methodsFor: 'as yet unclassified' stamp: 'len 3/21/2016 09:13'!
blocks
	blocks isNil ifTrue: [self run].
	^ blocks! !

!JordanNormalForm methodsFor: 'as yet unclassified' stamp: 'len 3/21/2016 08:40'!
matrix: aMatrix
	matrix _ aMatrix! !

!JordanNormalForm methodsFor: 'as yet unclassified' stamp: 'len 3/21/2016 09:37'!
run
	| spectrum |
	spectrum _ matrix spectrum.
	spectrum size = matrix numberOfRows ifFalse: [^ self error: 'the characteristic polynomial doesn''t split'].
"	I _ matrix species identity."
	blocks _ Bag new.
	spectrum asSet do: [:eigenvalue|
		| multiplicity dimensions X T count |
		multiplicity _ spectrum occurrencesOf: eigenvalue.
		dimensions _ OrderedCollection new.
		X _ matrix - (matrix species scalar: eigenvalue).
		T _ X.
		[(dimensions add: T nullity) < multiplicity] whileTrue: [T _ T * X].
		count _ 0.
		dimensions size to: 1 by: -1 do: [:i| | k |
			k _ (dimensions at: i) - (dimensions at: i-1 ifAbsent: [0]).
			blocks add: (self block: eigenvalue size: i) withOccurrences: k - count.
			count _ count + k]]! !

!LinearSystemSolver methodsFor: 'testing' stamp: 'len 5/23/2016 04:27'!
isSolvable
	"Answer true if the system has any solution."
	^ reducer dependentColumns includes: system ambient dimension + 1! !

!LinearSystemSolver methodsFor: 'accessing' stamp: 'len 12/26/2015 19:39'!
kernelBasis
	^ kernelBasis! !

!LinearSystemSolver methodsFor: 'accessing' stamp: 'len 12/26/2015 19:39'!
particular
	"Answer a particular solution of the receiver."
	^ particular! !

!LinearSystemSolver methodsFor: 'private' stamp: 'len 5/23/2016 04:27'!
solve
	| V T basis index depCols indepCols lastCol part v scalar |
	V _ system ambient.
	basis _ LinearBasis on: V.
	T _ V scalars ** V dimension.
	index _ 0.
	indepCols _ reducer independentColumns
		collect: [:each| index _ index + 1. index -> each].
	depCols _ reducer dependentColumns.
	depCols size > 1 ifTrue: [
		(depCols copyFrom: 1 to: depCols size - 1) do: [ :each |
			v _ V e: each.
			indepCols do: [ :some |
				scalar _ reducer reduced at: some key @ each.
				v _ v - ((V e: some value) * scalar)].
			basis add: v]].
	kernelBasis _ basis.
	indepCols isEmpty
		ifTrue: [particular _ V zero]
		ifFalse: [indepCols last value <= V dimension ifTrue: [
					lastCol _ reducer reduced lastColumn.
					part _ T zero.
					indepCols do: [:some|
						part _ part + ((T e: some value) * (lastCol at: some key))].
					particular _ (V vectorAt: part)]]! !

!LinearSystemSolver methodsFor: 'initialization' stamp: 'len 12/26/2015 19:39'!
system: aLinearSystem
	system _ aLinearSystem.
	reducer _ aLinearSystem matrix reducer.
	self solve! !

!LinearSystemSolver class methodsFor: 'instance creation' stamp: 'len 11/8/2015 04:14'!
system: aLinearSystem
	"Answer a new instance of the receiver for solving aLinearSystem."
	^ self new system: aLinearSystem! !

!MatrixReducer methodsFor: 'accessing' stamp: 'len 11/6/2015 04:59'!
addPivot: aPoint
	currentPivot _ aPoint.
	^ pivots add: aPoint! !

!MatrixReducer methodsFor: 'private' stamp: 'len 12/26/2015 05:52'!
addRow: i0 multipliedBy: anObject toRow: i1
	"Add a row multiplied by anObject to another row."
	self currentPivot x to: matrix numberOfColumns do: [:j|
		matrix
			at: i1 @ j
			put: (matrix at: i1 @ j) +
				((matrix at: i0 @ j) * anObject)].
	extension notNil ifTrue: [extension addRow: i0 multipliedBy: anObject toRow: i1]! !

!MatrixReducer methodsFor: 'accessing' stamp: 'len 11/6/2015 04:50'!
currentPivot
	^ currentPivot! !

!MatrixReducer methodsFor: 'accessing' stamp: 'len 12/26/2015 05:52'!
dependentColumns
	"Answer the collection of indexes of dependent columns."
	| independent first answer |
	independent _ self independentColumns.
	first _ 1.
	answer _ OrderedCollection new: matrix numberOfColumns - independent size.
	independent do: [:each| answer addAll: (first to: each - 1). first _ each + 1].
	answer addAll: (first to: matrix numberOfColumns).
	^ answer! !

!MatrixReducer methodsFor: 'accessing' stamp: 'len 12/27/2015 03:03'!
determinant
	"Answer the determinant of the matrix."
	| determinant |
	determinant _ matrix scalars one.
	1 to: matrix numberOfRows do: [:i|
		determinant _ determinant * (matrix at: i@i)].
	^ determinant / determinantFactor! !

!MatrixReducer methodsFor: 'accessing' stamp: 'len 12/26/2015 05:38'!
extension
	^ extension! !

!MatrixReducer methodsFor: 'accessing' stamp: 'len 12/26/2015 05:49'!
independentColumns
	"Answer the collection of indexes of independent columns."
	^ self pivots collect: [:each| each x]! !

!MatrixReducer methodsFor: 'accessing' stamp: 'len 11/6/2015 05:02'!
matrix
	^ matrix! !

!MatrixReducer methodsFor: 'initialization' stamp: 'len 12/27/2015 03:06'!
matrix: aMatrix extension: anotherMatrix
	matrix _ aMatrix.
	extension _ anotherMatrix.
	determinantFactor _ aMatrix scalars one.
	pivots _ (OrderedCollection new: aMatrix numberOfRows).
	currentPivot _ 0 @ 0.
	self reduce! !

!MatrixReducer methodsFor: 'private' stamp: 'len 12/27/2015 03:04'!
multiplyRow: i by: anObject
	"Multiply the i-th row by anObject."
	self currentPivot x to: matrix numberOfColumns do: [:j|
		matrix
			at: i @ j
			put: (matrix at: i @ j) * anObject].
	extension notNil ifTrue: [extension multiplyRow: i by: anObject].
	determinantFactor _ determinantFactor * anObject! !

!MatrixReducer methodsFor: 'private' stamp: 'len 3/5/2016 20:40'!
nextPivot
	"Advance the position to the next available pivot."
	| col |
	col _ currentPivot x + 1.
	[col <= matrix numberOfColumns]
		whileTrue:
			[1 to: matrix numberOfRows do: [ :each |
				((self pivots detect: [ :one | one y = each] ifNone: [])
					notNil or: [(matrix at: each @ col) isZero])
						ifFalse: [^ self addPivot: col @ each]].
			col _ col + 1].
	^ nil! !

!MatrixReducer methodsFor: 'accessing' stamp: 'len 11/6/2015 04:52'!
pivots
	"Answer the collection of positions used by pivots."

	^ pivots! !

!MatrixReducer methodsFor: 'accessing' stamp: 'len 12/26/2015 03:23'!
rank
	^ self pivots size! !

!MatrixReducer methodsFor: 'private' stamp: 'len 12/26/2015 03:20'!
reduce
	| row |
	row _ 1.
	[self nextPivot isNil]
		whileFalse:
			[self swapRow: row.
			row _ row + 1.
			self reduceStep]! !

!MatrixReducer methodsFor: 'private' stamp: 'len 11/6/2015 04:54'!
reduceStep
	"Perform one step in the reduction of the matrix at the current pivot."
	self subclassResponsibility! !

!MatrixReducer methodsFor: 'accessing' stamp: 'len 12/26/2015 03:23'!
reduced
	"Answer the reduced matrix."
	^ matrix! !

!MatrixReducer methodsFor: 'private' stamp: 'len 12/26/2015 04:55'!
swapRow: i
	"Swap the anInteger-th row with the row at the current pivot."
	i = self currentPivot y ifTrue: [^ self].
	self swapRow: i with: self currentPivot y.
	self pivots removeLast.
	self addPivot: self currentPivot x @ i! !

!MatrixReducer methodsFor: 'private' stamp: 'len 12/27/2015 03:04'!
swapRow: i with: j
	matrix swapRow: i with: j.
	extension notNil ifTrue: [extension swapRow: i with: j].
	determinantFactor _ determinantFactor negated! !

!MatrixReducer class methodsFor: 'instance creation' stamp: 'len 12/26/2015 05:41'!
on: aMatrix
	^ self on: aMatrix extension: nil! !

!MatrixReducer class methodsFor: 'instance creation' stamp: 'len 12/26/2015 05:15'!
on: aMatrix extension: anotherMatrix
	^ self new matrix: aMatrix extension: anotherMatrix! !

!GaussBareiss methodsFor: 'private' stamp: 'len 12/26/2015 05:51'!
reduceStep
	"Perform one step reduction of the matrix using the current pivot."
	| row col pivot value |
	row _ self currentPivot y.
	col _ self currentPivot x.
	pivot _ matrix at: row @ col.
	1 to: matrix numberOfRows do: [:i|
		(i = row or: [(value _ matrix at: i @ col) isZero])
			ifFalse:
				[self multiplyRow: i by: pivot.
				self addRow: row multipliedBy: value negated toRow: i]]! !

!GaussianElimination methodsFor: 'private' stamp: 'len 12/26/2015 05:51'!
reduceStep
	"Perform one step in the reduction of the matrix using the current pivot."
	| row col value |
	row _ self currentPivot y.
	col _ self currentPivot x.
	self multiplyRow: row by: (matrix at: row @ col) reciprocal.
	1 to: matrix numberOfRows do: [ :each |
		(each = row or: [(value _ matrix at: each @ col) isZero])
			ifFalse: [self addRow: row multipliedBy: value negated toRow: each]]! !

!QRDecomposition methodsFor: 'as yet unclassified' stamp: 'len 3/21/2016 22:11'!
Q
	Q isNil ifTrue: [self run].
	^ Q! !

!QRDecomposition methodsFor: 'as yet unclassified' stamp: 'len 3/21/2016 22:11'!
R
	R isNil ifTrue: [self run].
	^ R! !

!QRDecomposition methodsFor: 'as yet unclassified' stamp: 'len 3/21/2016 22:06'!
matrix: aMatrix
	matrix _ aMatrix! !

!QRDecomposition methodsFor: 'as yet unclassified' stamp: 'len 7/19/2016 08:51'!
run
	| K n basis ortho |
	K _ matrix scalars "algebraicClosure".
	n _ matrix numberOfRows.
	self flag: #fix. "we're assuming the columns are independent"
	basis _ LinearBasis on: K ** n vectors: matrix columns.
	ortho _ basis orthonormalized.
	Q _ matrix species columns: ortho.
"	zero _ K zero.
	R _ matrix species evaluating: [:i :j| i > j ifTrue: [zero] ifFalse: [(basis at: i) dotProduct: (ortho at: j)]]"
	R _ Q transposed * matrix! !

!QRDecomposition methodsFor: 'as yet unclassified' stamp: 'len 3/21/2016 22:15'!
verify
	^ matrix = (self Q * self R)! !

!SmithNormalForm methodsFor: 'accessing' stamp: 'len 3/21/2016 03:34'!
diagonal
	diagonal isNil ifTrue: [self run].
	^ diagonal! !

!SmithNormalForm methodsFor: 'accessing' stamp: 'len 3/20/2016 23:35'!
matrix
	^ matrix! !

!SmithNormalForm methodsFor: 'accessing' stamp: 'len 3/20/2016 23:35'!
matrix: aMatrix
	matrix _ aMatrix! !

!SmithNormalForm methodsFor: 'private' stamp: 'len 3/21/2016 03:30'!
reduceStep: i mod: R
	| j c euclid B Ai Aj |
	"2. Initialize j for row reduction:"
	[j _ i-1. c _ 0.
	"3. Check zero:"
	[[j >= 1 and: [(matrix at: i@j) isZero]] whileTrue: [j _ j - 1].
	j >= 1]
		whileTrue: "4. Euclidean step:"
			[euclid _ ExtendedEuclid on: {matrix at: i@i. matrix at: i@j}.
"			euclid verifyMinimal ifFalse: [self halt]."
			B _ (Ai _ matrix columnAt: i) * euclid combination first + ((Aj _ matrix columnAt: j) * euclid combination second).
			matrix columnAt: j put: Aj * ((matrix at: i@i) / euclid gcd) - (Ai * ((matrix at: i@j) / euclid gcd)) \\ R.
			matrix columnAt: i put: B \\ R.
			j _ j - 1].
	"5. Initialize j for column reduction:"
	j _ i-1.
	"6. Check zero (find pivot):"
	[[j >= 1 and: [(matrix at: j@i) isZero]] whileTrue: [j _ j - 1].
	j >= 1]
		whileTrue: "7. Euclidean step:"
			[euclid _ ExtendedEuclid on: {matrix at: i@i. matrix at: j@i}.
"			euclid verifyMinimal ifFalse: [self halt]."
			B _ (Ai _ matrix rowAt: i) * euclid combination first + ((Aj _ matrix rowAt: j) * euclid combination second).
			matrix rowAt: j put: Aj * ((matrix at: i@i) / euclid gcd) - (Ai * ((matrix at: j@i) / euclid gcd)) \\ R.
			matrix rowAt: i put: B \\ R.
			j _ j - 1.
			c _ c + 1].
	c > 0] whileTrue "8. Repeat stage i?"! !

!SmithNormalForm methodsFor: 'private' stamp: 'len 7/16/2016 04:23'!
run
	| n i R b k |
	n _ matrix numberOfRows.
	diagonal _ OrderedCollection new: n.
	"1. Initialize i:"
	i _ n.
	R _ matrix determinant.
	(matrix scalars isKindOf: Integers) ifTrue: [R _ R abs]. "not sure why take abs"
	n = 1 ifTrue: [diagonal add: R. ^ self].
	"2-9. Reduction:"
	[[self reduceStep: i mod: R.
	"9. Check the rest of the matrix:"
	b _ matrix at: i@i.
	k _ (1 to: i-1) detect: [:k0| ((1 to: i-1) allSatisfy: [:l| b | (matrix at: k0@l)]) not] ifNone: [].
	k isNil]
		whileFalse: [matrix rowAt: i put: (matrix rowAt: i) + (matrix rowAt: k)].
	"10. Next stage:"
	diagonal add: ((matrix at: i@i) gcd: R).
	R _ R / diagonal last.
	i = 2]
		whileFalse: [i _ i - 1].
	diagonal add: ((matrix at: 1@1) gcd: R).
	diagonal _ matrix scalars tuple: diagonal! !

!SimpleTensor methodsFor: 'as yet unclassified' stamp: 'len 6/19/2016 02:53'!
@ aSimpleTensor
	^ self class left: left @ aSimpleTensor left right: right @ aSimpleTensor right! !

!SimpleTensor methodsFor: 'as yet unclassified' stamp: 'len 9/21/2016 16:59'!
 aSimpleTensor
	^ self class left: left  aSimpleTensor left right: right  aSimpleTensor right! !

!SimpleTensor methodsFor: 'as yet unclassified' stamp: 'len 6/19/2016 02:49'!
at: anInteger
	anInteger = 1 ifTrue: [^ left].
	anInteger = 2 ifTrue: [^ right].
	^ self error: 'index out of bounds'! !

!SimpleTensor methodsFor: 'as yet unclassified' stamp: 'len 6/19/2016 02:53'!
inverse
	^ self class left: left inverse right: right inverse! !

!SimpleTensor methodsFor: 'as yet unclassified' stamp: 'len 11/27/2015 04:50'!
left
	^ left! !

!SimpleTensor methodsFor: 'as yet unclassified' stamp: 'len 11/27/2015 04:51'!
left: aVector
	left _ aVector! !

!SimpleTensor methodsFor: 'as yet unclassified' stamp: 'len 11/27/2015 05:08'!
order
	^ 2! !

!SimpleTensor methodsFor: 'as yet unclassified' stamp: 'len 6/19/2016 02:34'!
printOn: aStream
	aStream print: left; nextPut: Character otimes; print: right! !

!SimpleTensor methodsFor: 'as yet unclassified' stamp: 'len 11/27/2015 05:05'!
rank
	^ 1! !

!SimpleTensor methodsFor: 'as yet unclassified' stamp: 'len 11/27/2015 04:50'!
right
	^ right! !

!SimpleTensor methodsFor: 'as yet unclassified' stamp: 'len 11/27/2015 04:51'!
right: aVector
	right _ aVector! !

!SimpleTensor methodsFor: 'as yet unclassified' stamp: 'len 11/27/2015 04:51'!
scalars
	^ left scalars! !

!SimpleTensor methodsFor: 'as yet unclassified' stamp: 'len 6/19/2016 04:06'!
value: aCovector
	^ (aCovector value: left) * right! !

!SimpleTensor class methodsFor: 'as yet unclassified' stamp: 'len 6/19/2016 02:43'!
left: aVector right: anotherVector
	^ self new left: aVector; right: anotherVector! !

!Tensor methodsFor: 'accessing' stamp: 'len 6/19/2016 02:22'!
add: aVector
	^ components add: aVector! !

!Tensor methodsFor: 'accessing' stamp: 'len 11/27/2015 05:52'!
at: anIndex
	^ components at: anIndex! !

!Tensor methodsFor: 'initialization' stamp: 'len 11/27/2015 05:50'!
initialize
	components _ OrderedCollection new! !

!Tensor methodsFor: 'printing' stamp: 'len 6/19/2016 02:22'!
printOn: aStream
	components do: [:each| aStream print: each] separatedBy: [aStream nextPut: '  ']! !

!Tensor methodsFor: 'accessing' stamp: 'len 11/27/2015 05:52'!
size
	^ components size! !

!Tensor class methodsFor: 'instance creation' stamp: 'len 11/27/2015 05:53'!
new
	^ super new initialize! !

!Monomial methodsFor: 'operations' stamp: 'len 6/29/2016 05:14'!
* aMonomial
	| a an b bn c |
"	^ self class exponents: exponents + aMonomial exponents"
	(an _ self lastIndeterminate) <= (bn _ aMonomial lastIndeterminate)
		ifTrue: [a _ exponents. b _ aMonomial exponents]
		ifFalse: [| t | a _ aMonomial exponents. b _ exponents. t _ an. an _ bn. bn _ t].
	c _ Array new: bn.
	1 to: an do: [:i| c at: i put: (a at: i) + (b at: i)].
	c replaceFrom: an+1 to: bn with: b startingAt: an+1.
	^ self class exponents: c! !

!Monomial methodsFor: 'operations' stamp: 'len 6/29/2016 04:14'!
/ aMonomial
	"Answer the exact division of the receiver by the argument."
"	^ self class exponents: exponents - aMonomial exponents"
	^ self class exponents: ((1 to: (self lastIndeterminate max: aMonomial lastIndeterminate)) collect: [:i| (self at: i) - (aMonomial at: i)])! !

!Monomial methodsFor: 'comparing' stamp: 'len 10/22/97 23:58'!
< aMonomialLiteral
	"Answer the receiver is below the argument."

	^ (self >= aMonomialLiteral) not! !

!Monomial methodsFor: 'comparing' stamp: 'len 10/23/97 00:00'!
<= aMonomialLiteral
	"Answer the receiver is below or equal to the argument."

	^ (self > aMonomialLiteral) not! !

!Monomial methodsFor: 'comparing' stamp: 'len 6/6/2016 07:03'!
= aMonomial
	| exponents2 n |
	aMonomial isInteger ifTrue: [^ self degree = aMonomial].
	(n _ self lastIndeterminate) = aMonomial lastIndeterminate ifFalse: [^ false].
	exponents2 _ aMonomial exponents.
	1 to: n do: [:i| (exponents at: i) = (exponents2 at: i) ifFalse: [^ false]].
	^ true! !

!Monomial methodsFor: 'comparing' stamp: 'len 6/6/2016 07:03'!
> aMonomial
	"Answer true if the receiver is greater than the argument in the total lexicographic ordering."

	| n m |
	(n _ self degree) > (m _ aMonomial degree) ifTrue: [^ true].
	n < m ifTrue: [^ false].
	1 to: (self lastIndeterminate max: aMonomial lastIndeterminate) do: [:i|
		(self at: i) < (aMonomial at: i) ifTrue: [^ false].
		(self at: i) > (aMonomial at: i) ifTrue: [^ true]].
	^ false! !

!Monomial methodsFor: 'comparing' stamp: 'len 3/16/2016 20:52'!
>= aMonomial
	"Answer true if the receiver is greater than or equal to the argument in the total lexicographic ordering."

	^ self = aMonomial or: [self > aMonomial]! !

!Monomial methodsFor: 'testing' stamp: 'len 7/3/2016 00:29'!
| aMonomial
	"Answer true if the receiver divides the argument."
	1 to: exponents size do: [:i|
		(exponents at: i) > (aMonomial at: i) ifTrue: [^ false]].
	^ true! !

!Monomial methodsFor: 'accessing' stamp: 'len 7/2/2016 23:00'!
at: anIndeterminate
	"Answer the exponent of the anInteger-th indeterminate."
	anIndeterminate > exponents size ifTrue: [^ 0].
	^ exponents at: anIndeterminate! !

!Monomial methodsFor: 'accessing-private' stamp: 'len 5/22/2016 22:59'!
at: anIndeterminate put: anInteger
	"Set the exponent of the anInteger-th indeterminate to anotherInteger. Answer anotherInteger."
	anIndeterminate isInteger ifFalse: [self error: 'not integer indeterminate'].
	^ exponents at: anIndeterminate put: anInteger! !

!Monomial methodsFor: 'accessing' stamp: 'len 3/16/2016 20:03'!
bitSize
	^ exponents inject: 0 into: [:x :each| x + each bitSize]! !

!Monomial methodsFor: 'operations' stamp: 'len 6/6/2016 07:11'!
complete: anInteger in: anIndeterminate
	"Answer a copy of the receiver of degree anInteger completing with a power of the indeterminate anotherInteger."

	| n d |
	(n _ self degree) = anInteger ifTrue: [^ self].
	d _ (anInteger - n + (self at: anIndeterminate)).
	anIndeterminate <= exponents size
		ifTrue: [^ self copy at: anIndeterminate put: d; yourself].
	^ self class exponents:
		((Array new: anIndeterminate)
			replaceFrom: 1 to: exponents size with: exponents;
			from: exponents size + 1 to: anIndeterminate - 1 put: 0;
			at: anIndeterminate put: d;
			yourself)! !

!Monomial methodsFor: 'copying' stamp: 'len 3/17/2016 00:21'!
copy
	^ self class exponents: exponents copy! !

!Monomial methodsFor: 'copying' stamp: 'len 6/6/2016 07:06'!
copyWith: anIndeterminate to: anInteger
	anIndeterminate <= exponents size
		ifTrue: [^ self copy at: anIndeterminate put: anInteger; yourself].
	^ self class exponents:
		((Array new: anIndeterminate)
			replaceFrom: 1 to: exponents size with: exponents;
			from: exponents size + 1 to: anIndeterminate - 1 put: 0;
			at: anIndeterminate put: anInteger;
			yourself)! !

!Monomial methodsFor: 'copying' stamp: 'len 3/17/2016 00:21'!
copyWithout: anIndeterminate
	"Answer a copy of the receiver with the given indeterminate removed."

	^ self copy at: anIndeterminate put: 0; yourself! !

!Monomial methodsFor: 'operations' stamp: 'len 6/6/2016 04:25'!
degree
	"Answer the total degree of the receiver."
	exponents isEmpty ifTrue: [^ 0].
	^ exponents sum! !

!Monomial methodsFor: 'operations' stamp: 'len 3/17/2016 00:25'!
degreeIn: anIndeterminate
	"Answer the degree of the receiver in the given indeterminate, i.e. the power to which the indeterminate appears in the receiver."

	^ self at: anIndeterminate! !

!Monomial methodsFor: 'accessing' stamp: 'len 3/16/2016 20:05'!
exponents
	^ exponents! !

!Monomial methodsFor: 'accessing-private' stamp: 'len 3/16/2016 20:04'!
exponents: anArray
	exponents _ anArray! !

!Monomial methodsFor: 'operations' stamp: 'len 6/6/2016 08:43'!
gcd: aMonomial
	"Answer the greatest common divisor of the receiver and the argument."
	exponents size <= aMonomial exponents size ifFalse: [^ aMonomial gcd: self].
	^ self class exponents: (exponents withIndexCollect: [:each :i| each min: (aMonomial at: i)])! !

!Monomial methodsFor: 'testing' stamp: 'len 12/5/2015 22:34'!
has: anIndeterminate
	^ (self at: anIndeterminate) ~= 0! !

!Monomial methodsFor: 'comparing' stamp: 'len 6/11/2016 08:05'!
hash
	| answer |
	answer _ 0.
	exponents do: [:each| each == 0 ifFalse: [answer _ answer hashMultiply + each]].
	^ answer! !

!Monomial methodsFor: 'accessing' stamp: 'len 6/6/2016 08:40'!
indeterminates
	^ (1 to: exponents size) select: [:i| (exponents at: i) ~= 0]! !

!Monomial methodsFor: 'testing' stamp: 'len 6/6/2016 02:50'!
isIdentity
	^ exponents allSatisfy: [:each| each = 0]! !

!Monomial methodsFor: 'testing' stamp: 'len 6/6/2016 05:03'!
isUnivariateIn: anIndeterminate
	^ exponents isEmpty or: [(self at: anIndeterminate) = self degree]! !

!Monomial methodsFor: 'accessing' stamp: 'len 6/6/2016 07:00'!
lastIndeterminate
	"Answer the leading indeterminate of the receiver (the last indeterminate effectively present)."
	^ exponents findLast: [:one| one ~= 0]! !

!Monomial methodsFor: 'operations' stamp: 'len 6/6/2016 08:44'!
lcm: aMonomial
	"Answer the least common multiple of the receiver and the argument."
	exponents size >= aMonomial exponents size ifFalse: [^ aMonomial lcm: self].
	^ self class exponents: (exponents withIndexCollect: [:each :i| each max: (aMonomial at: i)])! !

!Monomial methodsFor: 'operations' stamp: 'len 7/4/2016 03:20'!
permutedBy: aPermutation
	"Permute the variables of the receiver. The argument can be an Array (permutation in 'image format'). For example given a monomial in x,z,y, #(1 2 3) doesn't change anything, #(2 1 3) exchanges variables x and y."
	^ self class exponents: ((1 to: exponents size) collect: [:i| self at: (aPermutation at: i)])! !

!Monomial methodsFor: 'printing' stamp: 'len 6/7/2016 21:48'!
printExponent: anInteger on: aStream
	| exponent |
	(exponent _ anInteger printString) = '1'
		ifTrue: [^ self].
	aStream isText
		ifTrue:
			[aStream nextPutAll: exponent super.
			^ self].
	aStream nextPut: $^.
	exponent size = 1
		ifTrue: [aStream nextPutAll: exponent]
		ifFalse: [aStream nextPut: ${; nextPutAll: exponent; nextPut: $}]! !

!Monomial methodsFor: 'printing' stamp: 'len 6/7/2016 21:49'!
printIndeterminate: indeterminate on: aStream
	indeterminate isInteger
		ifFalse: [aStream nextPutAll: indeterminate displayStringOrText. ^ self].
	aStream isText
		ifTrue: [aStream nextPut: $x; nextPutAll: indeterminate printString sub]
		ifFalse:[aStream nextPutAll: '{x', indeterminate printString, '}']! !

!Monomial methodsFor: 'printing' stamp: 'len 6/30/2016 00:16'!
printOn: aStream
	self degree = 0 ifTrue: [aStream print: 1. ^ self].
	(self indeterminates select: [:each| (self at: each) ~= 0])
		asSortedCollection do: [:each|
			self printIndeterminate: each on: aStream.
			self printExponent: (self degreeIn: each) on: aStream]! !

!Monomial methodsFor: 'printing' stamp: 'len 6/6/2016 08:36'!
printOn: aStream as: aPolynomials
	self degree = 0 ifTrue: [aStream print: 1. ^ self].
	(aPolynomials ordering indeterminates select: [:i| (self at: i) ~= 0])
		do: [:i|
			| x |
			x _ aPolynomials indeterminateNames ifNil: [i] ifNotNil: [:names| names at: i ifAbsent: [i]].
			self printIndeterminate: x on: aStream.
			self printExponent: (self at: i) on: aStream]! !

!Monomial methodsFor: 'printing' stamp: 'len 6/30/2016 00:17'!
printOn: aStream withNames: namesDictionary
	self degree = 0 ifTrue: [aStream print: 1. ^ self].
	(self indeterminates select: [:each| (self at: each) ~= 0])
		asSortedCollection do: [:each|
			self printIndeterminate: each on: aStream withNames: namesDictionary.
			self printExponent: (self degreeIn: each) on: aStream]! !

!Monomial methodsFor: 'operations' stamp: 'len 5/23/2016 00:04'!
root: anInteger
	^ self class exponents: exponents / anInteger! !

!Monomial methodsFor: 'operations' stamp: 'len 6/6/2016 04:28'!
root: anInteger in: anIndeterminate
	^ self copy at: anIndeterminate put: (self at: anIndeterminate) / anInteger; yourself! !

!Monomial methodsFor: 'operations' stamp: 'len 6/6/2016 04:29'!
value: anObject
	| answer next |
	exponents withIndexDo: [:exp :i|
		next _ (anObject at: i) ** exp.
		answer _ answer isNil ifTrue: [next] ifFalse: [next * answer]].
	^ answer! !

!Monomial methodsFor: 'operations' stamp: 'len 6/6/2016 04:45'!
without: anIndeterminate
	^ (self has: anIndeterminate) ifFalse: [self] ifTrue: [self copyWithout: anIndeterminate]! !

!Monomial class methodsFor: 'instance creation' stamp: 'len 6/29/2016 03:58'!
exponents: anArray
	^ self basicNew exponents: anArray "(anArray as: Tuple)"! !

!Monomial class methodsFor: 'instance creation' stamp: 'len 6/6/2016 02:43'!
identity
	"Answer the identity monomial (i.e., the monomial without indeterminates, or with all exponents 0)."
	^ self new: 0! !

!Monomial class methodsFor: 'instance creation' stamp: 'len 6/6/2016 02:45'!
new
	^ self new: 0! !

!Monomial class methodsFor: 'instance creation' stamp: 'len 6/6/2016 02:45'!
new: anInteger
	^ self exponents: ((Array new: anInteger) atAllPut: 0; yourself)! !

!Monomial class methodsFor: 'instance creation' stamp: 'len 11/6/2015 04:08'!
x: i
	"Answer a new instance of the receiver with only one indeterminate: the argument."

	^ self x: i to: 1! !

!Monomial class methodsFor: 'instance creation' stamp: 'len 6/6/2016 02:46'!
x: i to: k
	"Answer a new instance of the receiver with only one indeterminate, xi, raised to n."

	^ (self new: i) at: i put: k; yourself! !

!MonomialOrdering methodsFor: 'accessing' stamp: 'len 3/1/2016 19:49'!
comparisonBlock
	^ [:a :b| self is: a gneq: b]! !

!MonomialOrdering methodsFor: 'ordering' stamp: 'len 7/2/2016 23:19'!
headOf: aPolynomial
	"Answer the head monomial of aPolynomial according to this ordering."
	| answer |
	aPolynomial monomialsDo: [:each|
		answer _ (answer isNil or: [self is: each gneq: answer])
			ifTrue: [each] ifFalse: [answer]].
	^ answer! !

!MonomialOrdering methodsFor: 'accessing' stamp: 'len 7/4/2016 00:40'!
indeterminates
	^ indeterminates! !

!MonomialOrdering methodsFor: 'accessing-private' stamp: 'len 7/4/2016 00:39'!
indeterminates: anArray
	indeterminates _ anArray! !

!MonomialOrdering methodsFor: 'ordering' stamp: 'len 7/2/2016 23:29'!
is: aMonomial gneq: anotherMonomial
	"Answer true if the first argument is greater than the second."
	^ self subclassResponsibility! !

!MonomialOrdering methodsFor: 'as yet unclassified' stamp: 'len 7/6/2016 08:26'!
isGraded
	^ false! !

!MonomialOrdering methodsFor: 'ordering' stamp: 'len 3/16/2016 07:21'!
leadingCoefficientOf: aPolynomial
	^ aPolynomial coefficientAt: (self leadingMonomialOf: aPolynomial)! !

!MonomialOrdering methodsFor: 'ordering' stamp: 'len 3/16/2016 07:19'!
leadingMonomialOf: aPolynomial
	"Answer the leading (head) monomial of aPolynomial according to this ordering."
	| answer |
	aPolynomial monomialsDo: [:each|
		answer _ (answer isNil or: [self is: each gneq: answer])
			ifTrue: [each] ifFalse: [answer]].
	^ answer! !

!MonomialOrdering methodsFor: 'ordering' stamp: 'len 3/16/2016 07:21'!
leadingTermOf: aPolynomial
	^ aPolynomial termAt: (self leadingMonomialOf: aPolynomial)! !

!MonomialOrdering methodsFor: 'printing' stamp: 'len 7/4/2016 06:26'!
printOn: aStream
	self type isNil
		ifTrue: [super printOn: aStream]
		ifFalse: [aStream nextPutAll: self type].
	aStream nextPut: $[.
	self indeterminates do: [:i| aStream print: (Monomial x: i)] separatedBy: [aStream nextPut: $,].
	aStream nextPut: $]! !

!MonomialOrdering methodsFor: 'accessing' stamp: 'len 7/4/2016 00:40'!
rank
	^ indeterminates size! !

!MonomialOrdering methodsFor: 'accessing' stamp: 'len 7/2/2016 23:33'!
type
	^ nil! !

!MonomialOrdering methodsFor: 'ordering' stamp: 'len 7/7/2016 05:36'!
value: aMonomial value: anotherMonomial
	"Answer true if the first argument is greater than the second."
	^ self subclassResponsibility! !

!MonomialOrdering class methodsFor: 'instance creation' stamp: 'len 7/4/2016 00:51'!
indeterminates: anArray
	anArray isInteger ifTrue: [^ self new indeterminates: (1 to: anArray) asArray].
	^ self new indeterminates: anArray! !

!MonomialOrdering class methodsFor: 'examples' stamp: 'len 7/4/2016 00:45'!
lex: anArray
	^ LexicographicOrdering indeterminates: anArray! !

!MonomialOrdering class methodsFor: 'instance creation' stamp: 'len 7/4/2016 00:39'!
new: anInteger
	^ self indeterminates: (1 to: anInteger) asArray! !

!MonomialOrdering class methodsFor: 'examples' stamp: 'len 7/4/2016 00:45'!
revlex: anArray
	^ ReverseLexicographicOrdering indeterminates: anArray! !

!MonomialOrdering class methodsFor: 'examples' stamp: 'len 7/4/2016 00:45'!
tlex: anArray
	^ TotalLexicographicOrdering indeterminates: anArray! !

!MonomialOrdering class methodsFor: 'examples' stamp: 'len 7/4/2016 00:45'!
trevlex: anArray
	^ TotalReverseLexicographicOrdering indeterminates: anArray! !

!LexicographicOrdering methodsFor: 'ordering' stamp: 'len 7/4/2016 00:41'!
is: aMonomial gneq: anotherMonomial
	"Answer true if the first argument is greater than the second."
	| e1 e2 |
	e1 _ aMonomial "exponents".
	e2 _ anotherMonomial "exponents".
	1 to: indeterminates size do: [:i|
		| xi a b |
		a _ e1 at: (xi _ indeterminates at: i).
		b _ e2 at: xi.
		a > b ifTrue: [^ true].
		a = b ifFalse: [^ false]].
	^ false! !

!LexicographicOrdering methodsFor: 'accessing' stamp: 'len 7/2/2016 23:26'!
type
	^ #lex! !

!ReverseLexicographicOrdering methodsFor: 'ordering' stamp: 'len 7/8/2016 20:07'!
is: aMonomial gneq: anotherMonomial
	"Answer true if the first argument is greater than the second."
	| e1 e2 |
	e1 _ aMonomial "exponents".
	e2 _ anotherMonomial "exponents".
	indeterminates size to: 1 by: -1 do: [:i|
		| xi a b |
		a _ e1 at: (xi _ indeterminates at: i).
		b _ e2 at: xi.
		a < b ifTrue: [^ true].
		a = b ifFalse: [^ false]].
	^ false! !

!ReverseLexicographicOrdering methodsFor: 'accessing' stamp: 'len 7/3/2016 00:41'!
type
	^ #revlex! !

!TotalLexicographicOrdering methodsFor: 'ordering' stamp: 'len 7/4/2016 00:42'!
is: aMonomial gneq: anotherMonomial
	"Answer true if the first argument is greater than the second."
	| d1 d2 e1 e2 |
	(d1 _ aMonomial degree) > (d2 _ anotherMonomial degree) ifTrue: [^ true].
	d1 = d2 ifFalse: [^ false].
	e1 _ aMonomial "exponents".
	e2 _ anotherMonomial "exponents".
	1 to: indeterminates size do: [:i|
		| xi a b |
		a _ e1 at: (xi _ indeterminates at: i).
		b _ e2 at: xi.
		a > b ifTrue: [^ true].
		a = b ifFalse: [^ false]].
	^ false! !

!TotalLexicographicOrdering methodsFor: 'as yet unclassified' stamp: 'len 7/6/2016 08:27'!
isGraded
	^ true! !

!TotalLexicographicOrdering methodsFor: 'accessing' stamp: 'len 7/2/2016 23:54'!
type
	^ #tlex! !

!TotalReverseLexicographicOrdering methodsFor: 'ordering' stamp: 'len 7/4/2016 00:42'!
is: aMonomial gneq: anotherMonomial
	"Answer true if the first argument is greater than the second."
	| d1 d2 e1 e2 |
	(d1 _ aMonomial degree) > (d2 _ anotherMonomial degree) ifTrue: [^ true].
	d1 = d2 ifFalse: [^ false].
	e1 _ aMonomial "exponents".
	e2 _ anotherMonomial "exponents".
	indeterminates size to: 1 by: -1 do: [:i|
		| xi a b |
		a _ e1 at: (xi _ indeterminates at: i).
		b _ e2 at: xi.
		a < b ifTrue: [^ true].
		a = b ifFalse: [^ false]].
	^ false! !

!TotalReverseLexicographicOrdering methodsFor: 'as yet unclassified' stamp: 'len 7/6/2016 08:27'!
isGraded
	^ true! !

!TotalReverseLexicographicOrdering methodsFor: 'accessing' stamp: 'len 7/3/2016 00:43'!
type
	^ #trevlex! !

!WeightedMonomialOrdering methodsFor: 'arithmetic' stamp: 'len 7/3/2016 02:24'!
* aMonomialOrdering
	| newWeights zero |
	newWeights _ OrderedCollection new.
	zero _ aMonomialOrdering weights first zero.
	weights do: [:each| newWeights add: each, zero].
	zero _ weights first zero.
	aMonomialOrdering weights do: [:each| newWeights add: zero, each].
	^ self class
		new: self rank + aMonomialOrdering rank
		weights: newWeights! !

!WeightedMonomialOrdering methodsFor: 'arithmetic' stamp: 'len 7/3/2016 02:50'!
, aMonomialOrdering
	"Answer the concatenation of the recever and the argument."

	self rank = aMonomialOrdering rank ifFalse: [^ self error: 'cannot concatenate monomial orderings of different rank'].
	^ self class
		new: self rank
		weights: (self weights copy addAll: aMonomialOrdering weights; yourself)! !

!WeightedMonomialOrdering methodsFor: 'ordering' stamp: 'len 7/4/2016 00:44'!
headOf: aPolynomial
	"Answer the head monomial of aPolynomial according to this ordering."
	| head headTuple |
	headTuple _ FloatArray new: indeterminates size.
	aPolynomial monomialsDo: [:each|
		| t a b |
		t _ FloatArray new: indeterminates size.
		1 to: indeterminates size do: [:i| t at: i put: (each at: (indeterminates at: i))].
		head isNil
			ifTrue: [head _ each. headTuple _ t]
			ifFalse: [self weights anySatisfy: [:w|
				a _ w dot: t.
				b _ w dot: headTuple. "could be precomputed up to some extent"
				a ~= b] :: ifTrue: [a > b ifTrue: [head _ each. headTuple _ t]]]].
	^ head! !

!WeightedMonomialOrdering methodsFor: 'arithmetic' stamp: 'len 7/3/2016 02:23'!
inverse
	^ self class
		new: self rank
		weights: (self weights collect: [:each| each reversed])! !

!WeightedMonomialOrdering methodsFor: 'ordering' stamp: 'len 7/4/2016 00:43'!
is: aMonomial gneq: anotherMonomial
	"Answer true if the first argument is greater than the second."
	| t1 t2 |
	t1 _ FloatArray new: indeterminates size.
	t2 _ t1 copy.
	1 to: indeterminates size do: [:i| | xi |
		t1 at: i put: (aMonomial at: (xi _ indeterminates at: i)).
		t2 at: i put: (anotherMonomial at: xi)].
	self weights do: [:w|
		| a b |
		a _ w dot: t1.
		b _ w dot: t2.
		a = b ifFalse: [^ a > b]].
	^ false! !

!WeightedMonomialOrdering methodsFor: 'printing' stamp: 'len 7/4/2016 06:26'!
printOn: aStream
	super printOn: aStream.
	aStream space.
	self weights do: [:each| aStream print: each] separatedBy: [aStream space]! !

!WeightedMonomialOrdering methodsFor: 'arithmetic' stamp: 'len 7/3/2016 02:22'!
reverse
	^ self class
		new: self rank
		weights: (self weights collect: [:each| each negated])! !

!WeightedMonomialOrdering methodsFor: 'accessing' stamp: 'len 7/4/2016 06:23'!
type
	^ #weighted! !

!WeightedMonomialOrdering methodsFor: 'accessing' stamp: 'len 7/2/2016 23:18'!
weights
	^ weights! !

!WeightedMonomialOrdering methodsFor: 'accessing-private' stamp: 'len 7/2/2016 23:18'!
weights: aCollectionOfTuples
	weights _ aCollectionOfTuples collect: [:each| each as: FloatArray]! !

!WeightedMonomialOrdering class methodsFor: 'as yet unclassified' stamp: 'len 7/3/2016 02:27'!
indeterminates: indeterminates weights: weights
	weights isSequenceable ifFalse: [self error: 'the indeterminates are unordered'].
	^ self new: indeterminates size weights: (weights collect: [:each| each withIndexCollect: [:x :i| each at: (indeterminates indexOf: i)]])! !

!WeightedMonomialOrdering class methodsFor: 'as yet unclassified' stamp: 'len 7/3/2016 02:29'!
lex: aCollection
	"Answer the lexicographic order with the indeterminates of aCollection."
	| weighs n |
	n _ aCollection size.
	weighs _ (1 to: n) collect: [:i| Tuple new: n evaluating: [:k| k==i ifTrue:[1] ifFalse: [0]]].
	^ self indeterminates: aCollection weights: weighs! !

!WeightedMonomialOrdering class methodsFor: 'as yet unclassified' stamp: 'len 7/3/2016 02:44'!
new: anInteger weights: anArray
	^ (self new: anInteger) weights: anArray! !

!WeightedMonomialOrdering class methodsFor: 'as yet unclassified' stamp: 'len 7/3/2016 02:43'!
revlex: aCollection
	"Answer the reverse lexicographic ordering with the indeterminates of aCollection."
	^ (self lex: aCollection) reverse! !

!WeightedMonomialOrdering class methodsFor: 'as yet unclassified' stamp: 'len 7/3/2016 02:48'!
tlex: aCollection
	"Answer the total (or graded) lexicographic ordering with the indeterminates of aCollection."
	| weights |
	weights _ OrderedCollection new.
	weights add: (Tuple new: aCollection size evaluating: [:each| 1]).
	weights addAll: (self lex: aCollection) weights.
	^ self new: aCollection size weights: weights! !

!WeightedMonomialOrdering class methodsFor: 'as yet unclassified' stamp: 'len 7/3/2016 02:49'!
trevlex: aCollection
	"Answer the total (or graded) reverse lexicographic ordering with the indeterminates of aCollection."
	| weights |
	weights _ OrderedCollection new.
	weights add: (Tuple new: aCollection size evaluating: [:each| 1]).
	weights addAll: (self revlex: aCollection) weights.
	^ self new: aCollection size weights: weights! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 7/17/2016 21:37'!
% anInteger
	^ (self species over: (self scalars % anInteger)) coefficients: self coefficients % anInteger! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 3/23/2016 07:25'!
* anObject
	(self species includes: anObject)
		ifTrue:
			[^ self species coefficients: (self coefficients convolution: anObject coefficients)].
	((self scalars includes: anObject) or: [anObject isInteger])
		ifTrue: [^ self coefficientsApply: [:each| each * anObject]].
	(anObject isKindOf: Monomial)
		ifTrue: [^ self multiplyByMonomial: anObject].
	((anObject isKindOf: Polynomial) and: [anObject scalars includes: self])
		ifTrue: [^ anObject coefficientsApply: [:each| self * each]].
	^ DomainError signal! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 7/8/2016 05:40'!
** anInteger
	"Answer the receiver raised to the power anInteger."
	anInteger = 1 ifTrue: [^ self].
	anInteger = 0 ifTrue: [^ self one].
	anInteger < 0 ifTrue: [^ (self ** anInteger negated) reciprocal].
	^ self squared ** (anInteger // 2) * (self ** (anInteger \\ 2))! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 3/23/2016 04:05'!
+ anObject
	(self species includes: anObject)
		ifTrue: [^ self species coefficients: self coefficients + anObject coefficients].
	((self scalars includes: anObject) or: [anObject isInteger])
		ifTrue: [^ self + (self one * anObject)].
	^ DomainError signal! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 3/23/2016 04:06'!
- anObject
	(self species includes: anObject)
		ifTrue: [^ self species coefficients: self coefficients - anObject coefficients].
	^ self + anObject negated! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 3/23/2016 04:40'!
/ anObject
	(anObject isKindOf: Monomial)
		ifTrue:
			[^ self exactDivideByMonomial: anObject].
	(self species includes: anObject)
		ifTrue: [^ self exactDivideBy: anObject].
	(self scalars includes: anObject)
		ifTrue: [^ self coefficientsApply: [:each| each / anObject]]. "warning: this could be slow, potentially computing reciprocal for each coefficient"
	^ self * anObject reciprocal! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 3/22/2016 23:26'!
// anObject
	"Answer the quotient of the division of the receiver by the argument."

	(self scalars includes: anObject)
		ifTrue: [^ self coefficientsApply: [:each| each // anObject]].
	^ (self divideBy: anObject) quotient! !

!Polynomial methodsFor: 'comparing' stamp: 'len 3/1/2016 17:55'!
= anObject
	^ self species = anObject species and: [self coefficients = anObject coefficients]! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 10/10/2016 15:13'!
@ anObject
	"Answer the composition of the receiver with the argument."
	anObject isBlock ifTrue: [^ [:x| self value: (anObject value: x)]].
	^ self value: anObject! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 3/22/2016 23:26'!
\\ anObject
	"Answer the remainder of the division of the receiver by the argument."

	(self scalars includes: anObject)
		ifTrue: [^ self coefficientsApply: [:each| each \\ anObject]].
	^ (self divideBy: anObject) remainder! !

!Polynomial methodsFor: 'testing' stamp: 'len 12/27/2015 02:44'!
| aPolynomial
	"Answer true if the receiver divides aPolynomial."
	self scalars isField ifTrue: [^ (aPolynomial \\ self) isZero].
	^ (aPolynomial pseudoRem: self) isZero! !

!Polynomial methodsFor: 'converting' stamp: 'len 1/13/2016 21:14'!
adaptToComplex: rcvr andSend: selector
	"If I am involved in arithmetic with a number, convert it to a Polynomial."
	self halt.
	^ (self species constant: rcvr) perform: selector with: self! !

!Polynomial methodsFor: 'converting' stamp: 'len 11/26/2015 03:25'!
adaptToNumber: rcvr andSend: selector
	"If I am involved in arithmetic with a Number, convert it to a Polynomial."
	^ (self species constant: rcvr) perform: selector with: self! !

!Polynomial methodsFor: 'operations' stamp: 'len 3/27/2016 08:06'!
affinizedIn: anIndeterminate
	"Answer the affinization of the receiver in the given indeterminate."
	^ self monomialsApply: [:each| each copyWithout: anIndeterminate]! !

!Polynomial methodsFor: 'operations' stamp: 'len 7/8/2016 04:37'!
apply: aMorphism
	"Apply a homomorphism to the coefficients of the receiver."
	(aMorphism isBlock or: [aMorphism domain = self scalars]) ifTrue: [^ self coefficientsApply: aMorphism].
	^ DomainError signal! !

!Polynomial methodsFor: 'converting' stamp: 'len 6/1/2016 20:17'!
asBilinearForm
	(self degree = 2 and: [self isHomogeneous]) ifFalse: [^ self error: 'not homogeneous of degree 2'].
	self species rank even ifFalse: [^ self error: 'not even rank'].
	^ BilinearForm fromHalf: (self scalars ** (self species rank / 2)) evaluating: [:each| self value: each first, each second]! !

!Polynomial methodsFor: 'converting' stamp: 'len 6/8/2016 23:44'!
asIdeal
	"Answer the ideal generated by the receiver."
	^ self species * self! !

!Polynomial methodsFor: 'converting' stamp: 'len 6/1/2016 19:54'!
asLinearForm
	self isLinear ifFalse: [^ self error: 'not a linear polynomial'].
	^ (self scalars ** self species rank) dual evaluating: self! !

!Polynomial methodsFor: 'converting' stamp: 'len 7/19/2016 01:12'!
asMultivariate
	"Convert a polynomial in R[x][y][z] to a polynomial in R[x,y,z]."
	| R R` answer |
	((R _ self scalars) isKindOf: PolynomialRing) ifFalse: [^ self].
	self species isUnivariate ifFalse: [^ self].
	R` _ self species asMultivariate.
	answer _ R` zero.
	self monomialsAndCoefficientsDo: [:key :value|
		answer _ answer + ((value as: R`) * (R` x: R rank + 1 to: key degree))].
	^ answer! !

!Polynomial methodsFor: 'converting' stamp: 'len 11/19/2015 19:33'!
asRationalFunction
	"Answer the rational function representing the receiver."

	^ RationalFunction
		numerator: self
		denominator: self one! !

!Polynomial methodsFor: 'converting' stamp: 'len 3/22/2016 23:17'!
asScalar
	self isConstant ifFalse: [^ self error: 'not a constant polynomial'].
	self coefficients do: [:each| each isZero ifFalse: [^ each]].
	^ self species scalars zero! !

!Polynomial methodsFor: 'converting' stamp: 'len 6/6/2016 04:41'!
asUnivariate
	"Answer the receiver as univariate in the last indeterminate, e.g. go from R[x,y,z] to R[x,y][z]."
	| term n d newCoefficients newSpecies |
	self species isUnivariate ifTrue: [^ self].
	n _ self species rank.
	newSpecies _ self species asUnivariate.
	(d _ self degreeIn: n) <= 0
		ifTrue: [^ newSpecies constant: (self as: newSpecies scalars)].
	newCoefficients _ Array new: d+1.
	newCoefficients atAllPut: newSpecies scalars zero.
	self monomialsAndCoefficientsDo: [:key :value|
		term _ newSpecies scalars coefficient: value monomial: (key without: n).
		newCoefficients at: (key degreeIn: n)+1 add: term].
	^ newSpecies coefficients: newCoefficients! !

!Polynomial methodsFor: 'converting' stamp: 'len 5/30/2016 03:02'!
asUnivariateIn: anIndeterminate
	"Answer the receiver as univariate in the given indeterminate, e.g. go from R[x,y,z] to R[x,y][z]."
	| |
	(self species isUnivariate and: [self species indeterminate = anIndeterminate]) ifTrue: [^ self].
	"(self isUnivariateIn: anIndeterminate) ifTrue: [^ self]."
	(self species indeterminates includes: anIndeterminate) ifFalse: [self error: 'unknown indeterminate'].
	anIndeterminate = self species rank ifFalse: [self error: 'bad indeterminate'].
	^ self asUnivariate
"	newScalars _ self scalars polynomialsIn: self species rank - 1.
	(self species indeterminates copyWithout: anIndeterminate).
	newSpecies _ newScalars polynomialsIn: {anIndeterminate}.
	(n _ self degreeIn: anIndeterminate) < 0
		ifTrue: [^ newSpecies zero].
	newCoefficients _ Array new: n+1.
	newCoefficients atAllPut: newScalars zero.
	self monomialsAndCoefficientsDo: [:key :value|
		term _ newScalars coefficient: value monomial: (key copyWithout: anIndeterminate).
		newCoefficients at: (key degreeIn: anIndeterminate)+1 add: term].
	^ newSpecies coefficients: newCoefficients"! !

!Polynomial methodsFor: 'accessing' stamp: 'len 3/1/2016 16:01'!
bitSize
	^ self coefficients bitSize! !

!Polynomial methodsFor: 'roots' stamp: 'len 3/1/2016 19:19'!
cauchyRootBound
	| max a0 an |
	max _ 0.
	self coefficients do: [:each| max _ max max: each abs].
	a0 _ self independentCoefficient abs.
	an _ self leadingCoefficient abs.
	^ Array with: a0 / (a0 + max) with: an + max / an! !

!Polynomial methodsFor: 'accessing indeterminates' stamp: 'len 3/25/2016 03:53'!
classIndeterminate
	"Answer the 'class' of the polynomial, i.e. the index of the last indeterminate present in the receiver."
	self flag: #fix. "same as leadingIndeterminate?"
	self species rank to: 1 by: -1 do: [:i| (self has: i) ifTrue: [^ i]].
	^ 0! !

!Polynomial methodsFor: 'accessing coefficients' stamp: 'len 3/22/2016 23:29'!
coefficientAtDegree: anInteger
	"Answer the coefficient of the degree given by the argument. For univiariate polynomials."
	^ self coefficientAt: (Monomial x: self leadingIndeterminate to: anInteger)! !

!Polynomial methodsFor: 'accessing coefficients' stamp: 'len 5/20/2016 06:21'!
coefficientAtDegree: anInteger in: anotherInteger
	"Answer the coefficient of degree anInteger looking at the receiver as univariate in the anotherInteger-th indeterminate."
	self flag: #fix. "slow and ugly"
	^ (self asUnivariateIn: anotherInteger) coefficientAtDegree: anInteger! !

!Polynomial methodsFor: 'iterating' stamp: 'len 9/26/2016 16:41'!
coefficientsApply: aMorphism
	"Answer a new polynomial with coefficients obtainted by applying aMorphism to the coefficients of the receiver. This morphism is a ring homomorphism from the scalars ring.
	If aMorphism is a block we assume the species doesn't change, i.e. the block must evaluate to values within the scalars ring of the receiver."

	| newSpecies |
	newSpecies _ aMorphism isBlock
		ifTrue: [self species]
		ifFalse: [self species over: aMorphism codomain].
	^ newSpecies coefficients: (self coefficients collect: aMorphism)! !

!Polynomial methodsFor: 'factorization' stamp: 'len 3/9/2016 02:03'!
content
	"Answer the GCD of the coefficients of the receiver.
	In a field, it is convenient to define the content as 1.
	For example, 2x^2 + 4 has content 2 in Z[x] and 1 in Q[x]."
	| answer |
	self isZero ifTrue: [^ self scalars zero].
	self scalars isField
		ifTrue:
			[self scalars isFractionField
				ifTrue:
					[| c |
					c _ self coefficients inject: self scalars one into: [:lcm :each| lcm lcm: each denominator].
					^ (self coefficients inject: self scalars zero into: [:gcd :each | gcd gcd: each * c]) / c]
				ifFalse: [^ self scalars one]].
	answer _ self scalars zero.
	self coefficients do: [:each| answer _ answer gcd: each].
	^ answer! !

!Polynomial methodsFor: 'copying' stamp: 'len 3/22/2016 23:22'!
copy
	^ self species coefficients: self coefficients copy! !

!Polynomial methodsFor: 'accessing monomials' stamp: 'len 3/3/2016 02:07'!
degree
	self isZero ifTrue: [^ Infinity negative].
	^ self monomials max: [:each| each degree]
"	^ self leadingMonomial degree"

	"ALTERNATIVE: some people define 'degree' as:
	^ self degreeIn: self main"! !

!Polynomial methodsFor: 'accessing monomials' stamp: 'len 3/2/2016 23:47'!
degreeIn: anIndeterminate
	"Answer the degree of the receiver in the given indeterminate."
	self isZero ifTrue: [^ Infinity negative].
	^ self monomials max: [:each| each degreeIn: anIndeterminate]! !

!Polynomial methodsFor: 'operations' stamp: 'len 12/19/2015 20:22'!
descendentPower: n
	"Answer the descendent power of the recever raised to the integer argument."
	| mid |
	n = 0 ifTrue: [^ self one].
	n = 1 ifTrue: [^ self].
	n negative ifTrue: [^ (self descendentPower: n negated) reciprocal].
	mid _ n bitShift: -1.
	^ n even
		ifTrue: [(self - (self scalars one * mid) descendentPower: mid) *
				(self descendentPower: mid)]
		ifFalse: [(self - (self scalars one * mid) descendentPower: mid + 1) *
				(self descendentPower: mid)]! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 7/8/2016 23:53'!
divideBy: aPolynomial
	"Answer a division algorithm to divide the receiver by aPolynomial."
	self scalars isField ifFalse: [^ self pseudoDivideBy: aPolynomial].
	^ (self isUnivariate and: [aPolynomial isUnivariate])
		ifTrue: [PolynomialDivision divide: self by: aPolynomial]
		ifFalse: [MultiPolynomialDivision divide: self by: {aPolynomial}]! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 3/15/2016 21:28'!
divideBy: anArray ordering: aMonomialOrdering
	^ MultiPolynomialDivision divide: self by: anArray ordering: aMonomialOrdering! !

!Polynomial methodsFor: 'remainder sequences' stamp: 'len 3/9/2016 00:07'!
eprs: aPolynomial
	"Answer the (Pseudo) Euclidean Polynomial Remainder Sequence of the receiver with the argument."
	| answer f0 f1 r |
	answer _ OrderedCollection new.
	f1 _ self.
	answer add: f1.
	r _ aPolynomial.
	[r isZero]
		whileFalse:
			[answer add: r.
			f0 _ f1.
			f1 _ r.
			r _ f0 pseudoRem: f1].
	^ answer! !

!Polynomial methodsFor: 'equations' stamp: 'len 11/22/97 19:20'!
eq: anObject
	"Answer the equation 'self = anObject'."

	^ PolynomialEquation polynomial: self - anObject! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 7/8/2016 23:53'!
exactDivideBy: aPolynomial
	"Answer the exact division of the receiver by the argument.
	Apply the Schonhage-Jabelean algorithm, for polynomials of degree at most 2n and n with coefficients in a field. When necesary conditions don't hold, do the ordinary division.
	Ref: 'Algorithms With Exact Divisions Made Faster', Arnold Schonhage,
	INRIA Research Report Nro. 2381, Algorithms Seminar 1993-1994, p. 51."

	| shift f g m n h l k cg q |
	self isZero
		ifTrue: [^ self].
	aPolynomial isConstant
		ifTrue: [| lc | lc _ aPolynomial leadingCoefficient. ^ self coefficientsApply: [:each| each / lc]].
	(self isUnivariate and: [aPolynomial isUnivariate])
		ifFalse: [^ (MultiPolynomialDivision divide: self by: {aPolynomial}) quotient].
	self scalars isField
		ifFalse: [^ (PolynomialPseudoDivision divide: self by: aPolynomial) exactQuotient].
	(shift _ aPolynomial lowestDegree negated) < 0 ifTrue: [^ (self shift: shift) exactDivideBy: (aPolynomial shift: shift)].
	f _ self denseCoefficients.
	g _ aPolynomial denseCoefficients.
	m _ f size.
	n _ g size.
	m = n ifTrue: [^ self species constant: f last / g last].
 	n * 2 > m ifFalse: [^ (self divideBy: aPolynomial) quotient].

	h _ f size // 2.
	l _ h // 2.
	k _ h - l.

	q _ Array new: m-n+1.
	
	"Jebelean division for the lowest half:"
	cg _ g first reciprocal. "reciprocal of the independent coefficient"
	0 to: l do: [:i|
		| qi |
		qi _ q at: i+1 put: (f at: i+1) * cg.
		1 to: l-i do: [:j|
			f at: i+j+1 put: (f at: i+j+1) - (qi*(g at: j+1))]]. "optimize negated"
	
	"Schonhage division for the other half:"
	cg _ g last reciprocal. "reciprocal of the leading coefficient"
	m-n to: m-n-k+1 by: -1 do: [:i|
		| qi |
		qi _ q at: i+1 put: (f at: i+n) * cg.
		n-2 to: m-k-i by: -1 do: [:j|
			f at: i+j+1 put: (f at: i+j+1) - (qi*(g at: j+1))]].

	^ self species coefficients: q! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 3/23/2016 04:40'!
exactDivideByMonomial: aMonomial
	^ self monomialsApply: [:each| each / aMonomial]! !

!Polynomial methodsFor: 'factorization' stamp: 'len 2/24/2016 22:52'!
factorizer
	(self species scalars isField and: [self species scalars isFinite and: [self isUnivariate]])
		ifTrue: [^ FiniteFieldPolynomialFactorizer new polynomial: self].
	^ self error: 'not yet implemented'! !

!Polynomial methodsFor: 'factorization' stamp: 'len 2/8/2016 18:19'!
factors
	^ self factorizer factors! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 7/8/2016 23:53'!
gcd: aPolynomial
	"Answer the greatest common divisor of the receiver and aPolynomial."
	| a b r |
	aPolynomial isZero ifTrue: [^ self].
	(self isUnivariate and: [aPolynomial isUnivariate])
		ifFalse: "Multivariate case:"
			[self scalars isUFD ifFalse: [^ DomainError signal: 'not an UFD'].
			a _ self asUnivariate.
			b _ aPolynomial asUnivariate.
			^ (((a primitive gcd: b primitive) * (a content gcd: b content)) asMultivariate as: self species) primitive].
	self scalars isField
		ifFalse: "If it's not a field we use the primitive PRS algorithm:"
			[a _ self primitive.
			b _ aPolynomial primitive.
			[b isZero] whileFalse: [r _ (a pseudoRem: b) primitive. a _ b. b _ r].
			a isConstant ifTrue: [a _ self one].
			^ a * (self content gcd: aPolynomial content)].
	a _ self.
	b _ aPolynomial.
	[(r _ a \\ b) isZero] whileFalse: [a _ b. b _ r].
	^ b * b leadingCoefficient reciprocal! !

!Polynomial methodsFor: 'equations' stamp: 'len 12/18/97 19:18'!
geq: anObject
	"Answer the inequality 'self >= anObject'."

	^ (self gneq: anObject) | (self eq: anObject)! !

!Polynomial methodsFor: 'equations' stamp: 'len 1/12/98 23:59'!
gneq: anObject
	"Answer the inequality 'self > anObject'."

	^ self negated lneq: anObject negated! !

!Polynomial methodsFor: 'operations' stamp: 'len 6/6/2016 08:37'!
gradient
	^ self species indeterminates collect: [:each| self derivativeIn: each]! !

!Polynomial methodsFor: 'accessing indeterminates' stamp: 'len 3/1/2016 16:31'!
has: anIndeterminate
	"Answer true if anIndeterminate is effectively present in the receiver."
	^ self monomials anySatisfy: [:any| any has: anIndeterminate]! !

!Polynomial methodsFor: 'comparing' stamp: 'len 3/22/2016 23:20'!
hash
	^ self coefficients hash! !

!Polynomial methodsFor: 'operations' stamp: 'len 6/1/2016 21:01'!
hessian
	"Answer the Hessian matrix of the receiver."
	| n |
	self flag: #fix. "optimize"
	n _ self species rank.
	^ self species ** (n @ n) evaluating: [:i :j| (self derivativeIn: i) derivativeIn: j]! !

!Polynomial methodsFor: 'operations' stamp: 'len 5/20/2016 03:43'!
homogenized
	"Answer the homogenization of the receiver introducing a new indeterminate."
	| R R` |
	R _ self species.
	R` _ R scalars polynomialsIn: R rank + 1.
	^ (self as: R`) homogenizedIn: R` rank! !

!Polynomial methodsFor: 'operations' stamp: 'len 3/22/2016 23:19'!
homogenizedIn: anIndeterminate
	"Answer the homogenization of the receiver in the given indeterminate.
	Assume the indeterminate is in its species (not a new indeterminate)."
	| degree |
	degree _ self degree.
	^ self monomialsApply: [:each| each complete: degree in: anIndeterminate]! !

!Polynomial methodsFor: 'accessing coefficients' stamp: 'len 3/1/2016 16:31'!
independentCoefficient
	"Answer the coefficient of the constant monomial of the receiver."

	^ self coefficientAt: Monomial identity! !

!Polynomial methodsFor: 'accessing indeterminates' stamp: 'len 12/21/2015 03:19'!
indeterminates
	"Answer the indeterminates effectively present in the receiver."
	^ self species indeterminates select: [:each| self has: each]! !

!Polynomial methodsFor: 'factorization' stamp: 'len 3/1/2016 19:22'!
integerContent
	"Answer the integer content of the receiver.
	NOTE: the receiver is a polynomial over the rational numbers."

	| num den |
	self isZero ifTrue: [^ self].
	num _ self leadingCoefficient numerator.
	den _ self leadingCoefficient denominator.
	self coefficients do: [:each|
		num _ num gcd: each numerator.
		den _ den lcm: each denominator].
	^ (num / den) abs! !

!Polynomial methodsFor: 'factorization' stamp: 'len 12/6/2015 04:15'!
integerPrimitive
	"Answer the integer primitive polynomial associated to the receiver.
	Remove the integer content and the sign.
	NOTE: the receiver is a polynomial over the rational numbers."

	self isZero ifTrue: [^ self].
	^ self / (self integerContent * self sign)! !

!Polynomial methodsFor: 'testing' stamp: 'len 11/26/2015 01:41'!
is: aSymbol
	^ aSymbol == #Polynomial or: [super is: aSymbol]! !

!Polynomial methodsFor: 'testing' stamp: 'len 3/1/2016 17:33'!
isBinomial
	^ self coefficients size = 2! !

!Polynomial methodsFor: 'printing' stamp: 'len 3/26/2016 23:12'!
isBroken
	self monomials do: [:each|
		each indeterminates do: [:i| (self species has: i) ifFalse: [^ true]]].
	^ self coefficients anySatisfy: [:any| (self species scalars includes: any) not]! !

!Polynomial methodsFor: 'testing' stamp: 'len 11/11/2015 03:24'!
isConstant
	^ self degree < 1! !

!Polynomial methodsFor: 'testing' stamp: 'len 3/1/2016 17:33'!
isHomogeneous
	| n |
	n _ self degree.
	self monomials do: [ :each | each degree = n ifFalse: [^ false]].
	^ true! !

!Polynomial methodsFor: 'testing' stamp: 'len 2/24/2016 23:11'!
isIrreducible
	^ self factorizer isIrreducible
	"Ben-Or Irreducibility Test algorithm for polynomials in field of characteristic q."
	"| q x one |
	q _ self scalars characteristic.
	q = 0 ifTrue: [^ self factors size = 1].
	x _ self species x.
	one _ self one.
	1 to: self degree // 2 do: [:i|
		(self gcd: x**(q**i) - x \\ self) = one ifTrue: [^ false]].
	^ true"! !

!Polynomial methodsFor: 'factorization' stamp: 'len 11/24/2015 06:15'!
isIrreducibleHeuristic2: anInteger
	"Answer an Integer or nil. If the answer is an Integer, the
	receiver is irreducible iff that integer is prime, and in fact the
	integer will be prime with a very high probability (a probabilistic
	test is used here). If the answer is nil, the heuristic test has failed,
	and nothing can be said about the irreducibility of the receiver."

	"This is a probabilistic test for irreudcibility of rational univariate
	polynomials. It works looking for a prime evaluation of the polynomial.
	If it finds such a prime, then it's returned, and nil otherwise. The
	argument anInteger is the upper bound for the looking for primes."

	"Reference: 'A Heuristic Polynomial Irreducibility Test', Michael
	Monagan, J. Symbolic Comp., (1992) Vol. 13, No. 1, pp 47-57."

	| f g bg bound val try gcd |
	f _ self integerPrimitive.
	g _ f reversed.
	(bg _ g norm1 / g leadingCoefficient abs + 1) <
	(bound _ f norm1 / f leadingCoefficient abs + 1)
		ifTrue: [f _ g. bound _ bg].
	bound to: anInteger - 1 / 2 do: [ :each |
		val _ (f value: each) abs.
		gcd _ val gcd: 355929487585205167172661547995662840887819680000.
		(gcd <= (each - bound) squared and: [(try _ val / gcd) isPrime])
			ifTrue: [^ try].
		val _ (f value: each negated) abs.
		gcd _ val gcd: 355929487585205167172661547995662840887819680000.
		(gcd <= (each - bound) squared and: [(try _ val / gcd) isPrime])
			ifTrue: [^ try]
	].
	^ nil! !

!Polynomial methodsFor: 'factorization' stamp: 'len 11/24/2015 06:15'!
isIrreducibleHeuristic: anInteger
	"Answer an Integer or nil. If the answer is an Integer, the
	receiver is irreducible iff that integer is prime, and in fact the
	integer will be prime with a very high probability (a probabilistic
	test is used here). If the answer is nil, the heuristic test has failed,
	and nothing can be said about the irreducibility of the receiver."

	"This is a probabilistic test for irreudcibility of rational univariate
	polynomials. It works looking for a prime evaluation of the polynomial.
	If it finds such a prime, then it's returned, and nil otherwise. The
	argument anInteger is the upper bound for the looking for primes."

	| f val bound interval |
	f _ self integerPrimitive.
	bound _ f cauchyRootBound first floor abs.
	bound even ifTrue: [bound _ 0 max: bound - 1].
	interval _ f independentCoefficient odd
		ifTrue: [bound to: bound + (anInteger // 2)]
		ifFalse: [bound to: bound + anInteger by: 2].
	interval do: [ :each |
		val _ (f value: each) abs.
		val isPrime ifTrue: [^ val].
		val _ (f value: each negated) abs.
		val isPrime ifTrue: [^ val]
	].
	^ nil! !

!Polynomial methodsFor: 'testing' stamp: 'len 11/11/2015 03:25'!
isLinear
	^ self degree < 2! !

!Polynomial methodsFor: 'testing' stamp: 'len 11/25/2015 23:26'!
isMonic
	^ self leadingCoefficient = self scalars one! !

!Polynomial methodsFor: 'testing' stamp: 'len 3/9/2016 02:55'!
isPrimitive
	"A polynomial is primitive if it has content unity."
	^ self content = self scalars one! !

!Polynomial methodsFor: 'testing' stamp: 'len 1/10/2016 23:22'!
isSeparable
	"A polynomial over a field K is separable if it's roots are distinct in an algebraic closure of K."
	^ (self gcd: self derivative) isConstant! !

!Polynomial methodsFor: 'testing' stamp: 'len 7/8/2016 23:55'!
isSquareFree
	^ self isZero not and: [(self gcd: self derivative) isConstant]! !

!Polynomial methodsFor: 'testing' stamp: 'len 7/8/2016 23:35'!
isUnivariate
	^ self species isUnivariate! !

!Polynomial methodsFor: 'testing' stamp: 'len 3/24/2016 06:32'!
isUnivariateIn: anInteger
	"Answer true if the receiver is an univariate polynomial in the anInteger-th indeterminate."
	(anInteger = 1 and: [self species isUnivariate]) ifTrue: [^ true].
	self monomialsDo: [:each| (each isUnivariateIn: anInteger) ifFalse: [^ false]].
	^ true! !

!Polynomial methodsFor: 'testing' stamp: 'len 3/22/2016 23:22'!
isZero
	^ self coefficients isZero! !

!Polynomial methodsFor: 'arithmetic-private' stamp: 'len 12/22/2015 21:54'!
karatsubaMultiplyBy: aPolynomial
	"Ref: Zippel pp 119. O(n^1.56)"
	| n h f0 f1 g0 g1 f0g0 f1g1 |
	n _ self degree.
"	self assert: aPolynomial degree = n."
	self assert: self isUnivariate.
	h _ n // 2.
	f0 _ self >> h. f1 _ self - (f0 << h).
	g0 _ aPolynomial >> h. g1 _ aPolynomial - (g0 << h).
	f0g0 _ f0 * g0.
	f1g1 _ f1 * g1.
	^ f0g0 << (2*h) + ((f1+f0)*(g1+g0) - f0g0 - f1g1 << h) + f1g1! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 3/7/2016 07:01'!
lcm: aPolynomial
	"Answer the least common multiple of the receiver and aPolynomial."

	^ (self exactDivideBy: (self gcd: aPolynomial)) * aPolynomial! !

!Polynomial methodsFor: 'accessing coefficients' stamp: 'len 3/2/2016 02:46'!
leadingCoefficient
	^ self isZero ifTrue: [self scalars zero] ifFalse: [self coefficientAt: self leadingMonomial]! !

!Polynomial methodsFor: 'accessing coefficients' stamp: 'len 5/20/2016 06:21'!
leadingCoefficientIn: anIndeterminate
	"Answer the leading coefficient of the receiver as univariate polynomial in the given indeterminate."
	self flag: #fix. "slow and ugly"
	^ (self asUnivariateIn: anIndeterminate) leadingCoefficient! !

!Polynomial methodsFor: 'accessing indeterminates' stamp: 'len 6/6/2016 08:37'!
leadingIndeterminate
	"Answer the main (or leading) indeterminate of the receiver (according to a monomial ordering)."
	| indeterminates |
	indeterminates _ self species ordering indeterminates.
	indeterminates reverseDo: [:i| (self has: i) ifTrue: [^ i]].
	^ indeterminates first! !

!Polynomial methodsFor: 'accessing monomials' stamp: 'len 3/28/2016 03:48'!
leadingMonomial
	^ self species ordering headOf: self! !

!Polynomial methodsFor: 'accessing terms' stamp: 'len 3/1/2016 22:11'!
leadingTerm
	"Answer the first term of the receiver."

	^ self isZero
		 ifTrue: [self]
		 ifFalse: [self termAt: self leadingMonomial]! !

!Polynomial methodsFor: 'equations' stamp: 'len 12/18/97 19:18'!
leq: anObject
	"Answer the inequality 'self <= anObject'."

	^ (self lneq: anObject) | (self eq: anObject)! !

!Polynomial methodsFor: 'equations' stamp: 'len 12/18/97 19:17'!
lneq: anObject
	"Answer the inequality 'self < anObject'."

	^ PolynomialInequality polynomial: self - anObject! !

!Polynomial methodsFor: 'accessing monomials' stamp: 'len 3/3/2016 05:29'!
lowestDegree
	"Answer the lowest degree of the receiver's monomials (for univariate polynomials)."

	^ self isZero ifTrue: [Infinity negative] ifFalse: [self monomials min: [:each| each degree]]! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 1/2/2016 04:12'!
mod: aPolynomial
	self species = aPolynomial species ifFalse: [DomainError signal].
	^ (self species mod: aPolynomial) project: self! !

!Polynomial methodsFor: 'accessing monomials' stamp: 'len 3/23/2016 04:12'!
monomials
	^ Iterator on: self performing: #monomialsDo:! !

!Polynomial methodsFor: 'accessing monomials' stamp: 'len 3/1/2016 19:48'!
monomialsSorted
	^ self monomials asSortedCollection: self species ordering comparisonBlock! !

!Polynomial methodsFor: 'roots' stamp: 'len 11/24/2015 06:15'!
multiplicityAt: anObject
	"Answer the multiplicity of anObject as zero of the receiver."

	| answer f |
	self isZero ifTrue: [^ Infinity positive].
	answer _ 0.
	f _ self.
	[(f value: anObject) isZero]
		whileTrue:
			[answer _ answer + 1.
			f _ f derivative].
	^ answer! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 3/23/2016 05:54'!
multiplyByMonomial: aMonomial
	^ self monomialsApply: [:each| each * aMonomial]! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 3/30/2016 02:32'!
negated
	"Answer the additive inverse of the receiver."
	^ self species coefficients: self coefficients negated! !

!Polynomial methodsFor: 'equations' stamp: 'len 12/18/97 19:18'!
neq: anObject
	"Answer the inequation 'self ~= anObject'."

	^ (self lneq: anObject) | (self gneq: anObject)! !

!Polynomial methodsFor: 'operations' stamp: 'len 3/3/2016 01:01'!
norm
	"Answer the euclidean norm of the receiver."
	^ self norm2 squareRoot! !

!Polynomial methodsFor: 'operations' stamp: 'len 3/2/2016 23:55'!
norm1
	"Answer the 1-norm (or taxicab norm, or Manhattan norm) of the receiver."
	^ self coefficients inject: self scalars zero into: [:x :each| x + each abs]! !

!Polynomial methodsFor: 'operations' stamp: 'len 3/2/2016 23:49'!
norm2
	"Answer the squared norm of the receiver."
	^ self coefficients inject: self scalars zero into: [:x :each| x + each squared]! !

!Polynomial methodsFor: 'operations' stamp: 'len 3/2/2016 23:54'!
normInfinite
	"Answer the infinite norm of the receiver.
	(In finite-dimensional vector spaces it's the same as the maximum norm)."
	^ self normMax! !

!Polynomial methodsFor: 'operations' stamp: 'len 3/2/2016 23:52'!
normMax
	"Answer the maximum norm of the receiver."
	^ self coefficients inject: self scalars zero into: [:x :each| x max: each abs]! !

!Polynomial methodsFor: 'constants' stamp: 'len 11/26/2015 03:38'!
one
	^ self species one! !

!Polynomial methodsFor: 'converting' stamp: 'len 10/6/2016 15:34'!
orderedBy: aMonomialOrdering
	"Answer a copy of the receiver with a different monomial ordering."
	^ self copy parent: (parent copy ordering: aMonomialOrdering)! !

!Polynomial methodsFor: 'accessing-private' stamp: 'len 10/6/2016 15:34'!
parent
	^ parent! !

!Polynomial methodsFor: 'accessing-private' stamp: 'len 10/6/2016 15:35'!
parent: aPolynomialRing
	parent _ aPolynomialRing! !

!Polynomial methodsFor: 'operations' stamp: 'len 7/4/2016 03:20'!
permutedBy: aPermutation
	"Permute the variables of the receiver. The argument can be an Array (permutation in 'image format'). For example given a polynomial in x,z,y, #(1 2 3) doesn't change anything, #(2 1 3) exchanges variables x and y."
	^ self monomialsApply: [:each| each permutedBy: aPermutation]! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 12/20/2015 03:24'!
pgcd: aPolynomial
	"Answer the greatest common divisor of the receiver and aPolynomial using a probabilistic algorithm."
	| f g maps samples n |
	(self species scalars isKindOf: Integers) ifFalse: [^ DomainError signal: 'polynomial not in Z[x]'].
	f _ self integerPrimitive.
	g _ aPolynomial integerPrimitive.
	n _ f degree max: g degree.
	maps _ OrderedCollection new: n + 1.
	samples _ 1 to: n.
	samples do:
		[:each| maps add: each -> ((f value: each) gcd: (g value: each))].
	^ self species interpolate: maps! !

!Polynomial methodsFor: 'remainder sequences' stamp: 'len 3/9/2016 00:07'!
pprs: aPolynomial
	"Answer the Primitive Polynomial Remainder Sequence of the receiver with the argument."
	| answer f0 f1 r |
	answer _ OrderedCollection new.
	f1 _ self.
	answer add: f1.
	r _ aPolynomial.
	[r isZero]
		whileFalse:
			[answer add: r.
			f0 _ f1.
			f1 _ r.
			r _ (f0 pseudoRem: f1) primitive].
	^ answer! !

!Polynomial methodsFor: 'factorization' stamp: 'len 3/23/2016 05:23'!
primitive
	"Answer the primitive part of the receiver."
	| content |
	self isZero ifTrue: [^ self]. self flag: #fix. "is this right?"
	content _ self content.
	^ self coefficientsApply: [:each| each / content]! !

!Polynomial methodsFor: 'printing' stamp: 'len 6/25/2016 01:45'!
printCoefficient: coefficient on: aStream
	"Print the coefficient of the receiver on the stream aStream."

	| c |
	((c _ coefficient) printString first = $- "or: [coefficient isNumber and: [coefficient negative]]")
		ifTrue: [aStream nextPut: $-. c _ c negated].
	(c printString allSatisfy: [:each| each isAlphaNumeric or: ['{}()/' includes: each]])
		ifTrue: [aStream print: c]
		ifFalse: [aStream nextPut: $(; print: c; nextPut: $)]! !

!Polynomial methodsFor: 'printing' stamp: 'len 6/25/2016 01:46'!
printOn: aStream
	| monomials leadingMonomial c |
	self isBroken ifTrue: [aStream nextPutAll: '(broken) '].
	self isConstant ifTrue: [aStream print: self leadingCoefficient. ^ self].
	monomials _ self monomialsSorted.
	c _ self coefficientAt: (leadingMonomial _ monomials first).
	(c printString first = $- or: [c isNumber and: [c negative]])
		ifTrue: [c _ c negated. aStream nextPut: $-].
	(c ~= c one or: [leadingMonomial degree = 0]) ifTrue: [self printCoefficient: c on: aStream].
	leadingMonomial degree > 0 ifTrue: [leadingMonomial printOn: aStream as: self species].
	monomials allButFirst do: [:m|
		c _ self coefficientAt: m.
		(c printString first = $- or: [c isNumber and: [c negative]])
			ifTrue: [aStream nextPutAll: ' - '. c _ c negated]
			ifFalse: [aStream nextPutAll: ' + '].
		(c ~= c one or: [m degree = 0]) ifTrue: [self printCoefficient: c on: aStream].
		m degree > 0 ifTrue: [m printOn: aStream as: self species]]! !

!Polynomial methodsFor: 'remainder sequences' stamp: 'len 3/9/2016 00:08'!
prs: aPolynomial
	"Answer the Polynomial Remainder Sequence of the receiver with the argument."
	| answer f0 f1 r |
	self species scalars isField ifFalse: [^ DomainError signal: 'scalars are not a field'].
	answer _ OrderedCollection new.
	f1 _ self.
	answer add: f1.
	r _ aPolynomial.
	[r isZero]
		whileFalse:
			[answer add: r.
			f0 _ f1.
			f1 _ r.
			r _ f0 \\ f1].
	^ answer! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 12/16/2015 03:11'!
pseudoDivideBy: aPolynomial
	"Answer a pseudo-division algorithm to divide the receiver by aPolynomial."
	self isUnivariate ifFalse: [^ DomainError signal: 'polynomial is not univariate'].
	^ PolynomialPseudoDivision divide: self by: aPolynomial! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 12/11/2015 07:06'!
pseudoDivideBy: aPolynomial in: anIndeterminate
	^ (self asUnivariateIn: anIndeterminate) pseudoDivideBy: (aPolynomial asUnivariateIn: anIndeterminate)! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 3/9/2016 05:05'!
pseudoQuo: aPolynomial
	"Answer the quotient of the pseudo-division of the receiver by the argument."
	self isUnivariate ifFalse: [^ (self pseudoDivideBy: aPolynomial in: self leadingIndeterminate) quotient asMultivariate].
	^ (self pseudoDivideBy: aPolynomial) quotient! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 3/3/2016 05:35'!
pseudoRem2: aPolynomial
	"Answer the remainder of the pseudo-division of the receiver by the argument."
	self isUnivariate ifFalse: [^ (self pseudoDivideBy: aPolynomial in: self leadingIndeterminate) remainder asMultivariate].
	^ (self pseudoDivideBy: aPolynomial) remainder! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 3/3/2016 05:35'!
pseudoRem3: aPolynomial
	"Answer the remainder of the pseudo-division of the receiver by the argument."
	| n d b w k |
	self isUnivariate ifFalse: [^ (self pseudoDivideBy: aPolynomial in: self leadingIndeterminate) remainder asMultivariate].
	"^ (self pseudoDivideBy: aPolynomial) remainder"
	self degree < (n _ aPolynomial degree) ifTrue: [^ self].
	w _ self.
	d _ self degree - n + 1.
	b _ aPolynomial leadingCoefficient.
	[k _ w degree - n.
	w _ b * w - ((self species coefficient: w leadingCoefficient degree: k)*aPolynomial).
	w isZero ifTrue: [^ w].
	w degree < n ifTrue: [^ w * (b ** k)].
	k > d ifTrue: [w _ w * (b ** (k - d))]] repeat! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 3/8/2016 22:04'!
pseudoRem4: aPolynomial
	"Answer the remainder of the pseudo-division of the receiver by the argument."
	| n b w e k |
	self isUnivariate ifFalse: [^ (self pseudoDivideBy: aPolynomial in: self leadingIndeterminate) remainder asMultivariate].
	"^ (self pseudoDivideBy: aPolynomial) remainder"
	self degree < (n _ aPolynomial degree) ifTrue: [^ self].
	w _ self.
	e _ self degree - n + 1.
	b _ aPolynomial leadingCoefficient.
	[k _ w degree - n.
	w _ w * b - ((aPolynomial shift: k) * w leadingCoefficient).
	w isZero ifTrue: [^ w].
	w degree < n ifTrue: [^ w * (b ** k)].
	k > e ifTrue: [w _ w * (b ** (k - e))]] repeat! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 3/8/2016 22:04'!
pseudoRem: aPolynomial
	"Answer the remainder of the pseudo-division of the receiver by the argument."
	self isUnivariate ifFalse: [^ (self pseudoDivideBy: aPolynomial in: self leadingIndeterminate) remainder asMultivariate].
	^ (self pseudoDivideBy: aPolynomial) remainder! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 3/23/2016 08:37'!
raisedTo2: anInteger modulo: anObject
	"Answer the receiver raised to the power anInteger modulo anObject.
	The argument anInteger must be positive."

	| result y n |
	result _ self one.
	n _ anInteger abs.
	y _ self \\ anObject.
	[n > 0]
		whileTrue:
			[n odd ifTrue: [result _ result * y \\ anObject].
			y _ y squared \\ anObject.
			n _ n // 2].
	^ anInteger negative ifTrue: [result reciprocal] ifFalse: [result]! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 3/23/2016 08:36'!
raisedTo: anInteger modulo: anObject
	"Answer the receiver raised to the power anInteger modulo anObject.
	The argument anInteger must be positive."

	anInteger = 0 ifTrue: [^ 1].
	anInteger = 1 ifTrue: [^ self \\ anObject].
	^ (self squared \\ anObject raisedTo: anInteger // 2 modulo: anObject) * (self raisedTo: anInteger \\ 2 modulo: anObject) \\ anObject! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 2/14/2016 21:05'!
reciprocal
	self isConstant ifTrue: [^ self coefficientsApply: [:each| each reciprocal]]. "assuming we're in a field"
	^ self asRationalFunction reciprocal! !

!Polynomial methodsFor: 'operations' stamp: 'len 6/1/2016 20:43'!
rename: anInteger to: anotherInteger
	"Rename the anInteger-th indeterminate of the receiver to anotherInteger."
	(self indeterminates includes: anotherInteger) ifFalse: [^ self error: 'unknown indeterminate'].
	^ self value: ((1 to: self species rank) collect: [:i| self species x: (i = anInteger ifTrue: [anotherInteger] ifFalse: [i])])! !

!Polynomial methodsFor: 'deprecated' stamp: 'len 7/8/2016 05:45'!
resultant: aPolynomial in: anIndeterminate
	"Answer the resultant of the receiver with aPolynomial in the anInteger-th indeterminate."

	self flag: #fix. self flag: #deprecated.
	(self degreeIn: anIndeterminate) = 0
		ifTrue: [^ aPolynomial ** self degree].
	(aPolynomial degreeIn: anIndeterminate) = 0 ifTrue: [
		^ (self degree even or: [aPolynomial degree even])
			ifTrue: [(self ** aPolynomial degree)]
			ifFalse: [(self ** aPolynomial degree) negated]].

	^ (self sylvester: aPolynomial in: anIndeterminate) determinant! !

!Polynomial methodsFor: 'operations' stamp: 'len 3/22/2016 23:19'!
reversedIn: anIndeterminate
	"Answer the reverse of the receiver as univariate polynomial in the given indeterminate."

	| n |
	n _ self degreeIn: anIndeterminate.
	^ self monomialsApply: [:each| each copy at: anIndeterminate put: n - (each degreeIn: anIndeterminate); yourself]! !

!Polynomial methodsFor: 'roots' stamp: 'len 2/26/2016 03:40'!
roots
	"Answer the roots (counted with multiplicity) in the coefficients ring or field."
	^ self rootsIn: self scalars! !

!Polynomial methodsFor: 'roots' stamp: 'len 9/26/2016 17:57'!
rootsIn: aField
	"Answer the roots (conted with multiplicaity) in the given domain."
	(aField isField and: [aField isFinite and: [aField characteristic even not]]) ifTrue: [^ (FiniteFieldRootFinder polynomial: self) roots].
	(aField isKindOf: Rationals) ifTrue: [^ (RationalRootFinder polynomial: self) roots].
	((aField isKindOf: AlgebraicNumbers) or: [aField isKindOf: ComplexNumbers]) ifTrue: [^ (ComplexRootFinder polynomial: self) roots].
	((aField isKindOf: RealAlgebraicNumbers) or: [aField isKindOf: Reals]) ifTrue: [^ (RealRootFinder polynomial: self) roots].
	(aField isKindOf: Integers) ifTrue: [^ (RationalRootFinder polynomial: self) roots select: [:each| each isInteger]].
	self flag: #fix. "count multiplicity, implement more efficient algorithm"
	aField isFinite ifTrue: [^ aField elements select: [:each| (self value: each) isZero]].
	^ self error: 'unknown domain'! !

!Polynomial methodsFor: 'accessing' stamp: 'len 10/6/2016 15:34'!
scalars
	^ parent scalars! !

!Polynomial methodsFor: 'operations' stamp: 'len 3/24/2016 03:02'!
shift: anInteger in: anIndeterminate
	"Answer the receiver shifted anInteger places as univariate polynomial in the given indeterminate."
	^ self multiplyByMonomial: (Monomial x: anIndeterminate to: anInteger)! !

!Polynomial methodsFor: 'factorization' stamp: 'len 3/1/2016 16:25'!
sign
	"Answer the sign of the receiver, i.e. the sign if its head coefficient."

	^ self leadingCoefficient sign! !

!Polynomial methodsFor: 'roots' stamp: 'len 2/26/2016 03:42'!
signature
	"Answer the signature (r1,r2) of the receiver, where r1 is the number of real roots and 2*r2 is the number of non-real roots. Assume the receiver's coefficients are integers. Throw an error if the receiver is not square-free.
	Ref: COHEN Algorithm 4.1.11 (Sturm)."
	| A B g h s n t r1 d R |
	self isZero ifTrue: [^ #(0 0)].
	A _ self primitive.
	B _ self derivative primitive.
	g _ 1.
	h _ 1.
	s _ A sign.
	n _ A degree.
	t _ n even ifTrue: [s negated] ifFalse: [s].
	r1 _ 1.
	[d _ A degree - B degree.
	R _ A pseudoRem: B.
	R isZero ifTrue: [^ self error: 'polynomial is not square-free'].
	(d odd or: [B leadingCoefficient > 0])
		ifTrue: [R _ R negated].
	"Use Sturm:"
	R sign ~= s ifTrue: [s _ s negated. r1 _ r1 - 1].
	R sign ~= ((-1) ** R degree * t) ifTrue: [t _ t negated. r1 _ r1 + 1].
	"Finished?"
	R isConstant]
		whileFalse:
			[A _ B.
			B _ R / (h ** d * g).
			g _ A leadingCoefficient abs.
			h _ h ** (1 - d) * (g ** d)].
	^ {r1. n - r1 / 2}! !

!Polynomial methodsFor: 'private' stamp: 'len 10/6/2016 15:40'!
species
	^ self parent! !

!Polynomial methodsFor: 'remainder sequences' stamp: 'len 3/9/2016 06:32'!
sprs2: aPolynomial
	"Answer the Subresultant Polynomial Remainder Sequence of the receiver with the argument."
	| delta b phi beta f1 f2 r answer |
	self assert: self scalars isUFD.
	self assert: self degree >= aPolynomial degree.
	delta _ self degree - aPolynomial degree + 1.
	b _ aPolynomial leadingCoefficient.
	phi _ b ** (delta - 1).
	beta _ (-1) ** delta.
	answer _ OrderedCollection new.
	answer add: self; add: aPolynomial.
	f1 _ aPolynomial. f2 _ self. "f1 is F_{i-1}, f2 is F_{i-2}, r is F_i"
	[r _ (f2 pseudoRem: f1) / beta.
	r isZero ifTrue: [^ answer].
	answer add: r. f2 _ f1. f1 _ r.
	delta _ f1 degree - r degree + 1.
	beta _ (-1) ** delta * (phi ** (delta - 1)) * b.
	b _ r leadingCoefficient.
	phi _ phi * ((b / phi) ** (delta - 1))] repeat! !

!Polynomial methodsFor: 'remainder sequences' stamp: 'len 3/9/2016 06:56'!
sprs: aPolynomial
	"Answer the Subresultant Polynomial Remainder Sequence of the receiver with the argument."
	| delta phi beta f1 f2 r answer |
	self assert: self scalars isUFD.
	self assert: self degree >= aPolynomial degree.
	f2 _ self. f1 _ aPolynomial."f1 is F_{i-1}, f2 is F_{i-2}, r is F_i"
	phi _ self scalars one.
	answer _ OrderedCollection new.
	answer add: f2.
	[f1 isZero]
		whileFalse:
			[answer add: f1.
			delta _ f2 degree - f1 degree + 1.
			beta _ (-1) ** delta * (phi ** (delta - 1)) * f2 leadingCoefficient.
			phi _ phi * ((f1 leadingCoefficient / phi) ** (delta - 1)).
			r _ (f2 pseudoRem: f1) / beta.
			f2 _ f1. f1 _ r].
	^ answer! !

!Polynomial methodsFor: 'operations' stamp: 'len 7/8/2016 23:44'!
squareFree
	"Answer the maximal square-free divisor of the receiver."
	| g |
	self species scalars characteristic = 0 ifFalse: [^ DomainError signal: 'field must include Q (i.e., must be of characteristic 0)'].
	g _ self.
	self indeterminates do: [:each| g _ g gcd: (self derivativeIn: each)].
	^ self / g! !

!Polynomial methodsFor: 'factorization' stamp: 'len 11/26/2015 03:29'!
squareFreeFactorization
	"Answer a square free factorization of the receiver.
	Use Yun's algorithm. Assume the coefficients are in a unique
	factorization domain or in a field of characteristic 0."

	| p q gcd count answer lc |
	((self scalars isField and: [self scalars characteristic = 0]) or: [self scalars isUFD])
		ifFalse: [ ^ self notYetImplemented ].
	answer _ Bag new.
	count _ 1.
	lc _ self leadingCoefficient.
	lc = self scalars one
		ifFalse: [answer add: (self species constant: lc)].
	p _ self / lc.
	q _ p derivative.
	gcd _ p gcd: q.
	gcd degree > 0
		ifTrue:
			[p _ p // gcd.
			q _ q // gcd - p derivative.
			[q isZero]
				whileFalse:
					[gcd _ p gcd: q.
					gcd degree > 0 ifTrue: [answer add: gcd withOccurrences: count].
					count _ count + 1.
					p _ p // gcd.
					q _ q // gcd - p derivative]].
	^ answer add: p withOccurrences: count; yourself! !

!Polynomial methodsFor: 'factorization' stamp: 'len 11/22/97 21:47'!
squareFreeFactorizationOLD
	"Answer a square free factorization of the receiver."

	| f gcd answer |

	answer _ Bag new.
	f _ self.
	[(gcd _ f gcd: f derivative) isConstant] whileFalse: [
		answer add: f // gcd. f _ gcd
	].
	^ answer add: f // gcd; add: gcd; yourself! !

!Polynomial methodsFor: 'arithmetic' stamp: 'len 11/11/2015 02:29'!
squared
	^ self * self! !

!Polynomial methodsFor: 'deprecated' stamp: 'len 7/8/2016 05:46'!
subresultant: i with: aPolynomial in: anIndeterminate
	"Answer the i-th subresultant of the receiver with the aPolynomial in the given indeterminate."

	| lambda mu n m c matrix tuple t |
	self flag: #fix. self flag: #deprecated.
	m _ self degreeIn: anIndeterminate.
	n _ aPolynomial degreeIn: anIndeterminate.
	lambda _ m min: n.
	mu _ (m max: n) - 1.
	i = lambda
		ifTrue:
			[self degree + 1 < aPolynomial degree
				ifTrue: [c _ self]
				ifFalse:
					[aPolynomial degree + 1 < self degree
						ifTrue: [c _ aPolynomial] ifFalse: [^ nil]].
			^ c * ((c leadingCoefficientIn: anIndeterminate) ** ((m - n) abs - 1))].
	(i between: lambda and: mu) ifTrue: [^ self zero].
	(i between: 0 and: lambda - 1) ifFalse: [self error: 'index out of range'].
	t _ m + n - (2*i).
	matrix _ (self scalars ** (t@t)) new.
	tuple _ self scalars tuple: m + n - (2*i) evaluating: [:each|
				self coefficientAtDegree: m - each + 1 in: anIndeterminate].
	n - i timesRepeat: [matrix addRow: tuple. tuple _ tuple shift: 1].
	tuple _ self scalars tuple: m + n - (2*i) evaluating: [ :each |
				aPolynomial coefficientAtDegree: n - each + 1 in: anIndeterminate].
	m - i timesRepeat: [matrix addRow: tuple. tuple _ tuple shift: 1].
	1 to: n - i do: [:each|
		matrix atRow: each column: m + n - (2*i)
				put: (self shift: n - i - each in: anIndeterminate)].
	1 to: m - i do: [:each|
		matrix atRow: n - i + each column: m + n - (2*i)
				put: (aPolynomial shift: m - i - each in: anIndeterminate)].
	^ matrix determinant! !

!Polynomial methodsFor: 'deprecated' stamp: 'len 7/15/2016 05:11'!
sylvester: aPolynomial in: anIndeterminate
	"Answer the Sylvester matrix of the receiver with the argument in the anInteger-th indeterminate.
	If p,q polynomials of degrees m and n:
		det S(p,q) = res (p,q)
		deg (gcd(p,q)) = m - n + rank (S(p,q))
	Also the kernel of the transposed Sylvester matrix gives all solutions of the Bezout equation:
		f*p + g*q = 0
	"
	| m n rows p q |
	self flag: #fix. self flag: #deprecated.
	m _ self degreeIn: anIndeterminate.
	n _ aPolynomial degreeIn: anIndeterminate.
	rows _ OrderedCollection new: m+n.
	p _ self scalars tuple: ((1 to: m+n) collect: [ :i | self coefficientAtDegree: m-i+1 in: anIndeterminate ]).
	n timesRepeat: [ rows add: p. p _ p shift: 1 ].
	q _ self scalars tuple: ((1 to: m+n) collect: [ :i | aPolynomial coefficientAtDegree: n-i+1 in: anIndeterminate]).
	m timesRepeat: [ rows add: q. q _ q shift: 1 ].
	^ (self scalars ** (rows size @ rows first size)) rows: rows! !

!Polynomial methodsFor: 'accessing terms' stamp: 'len 3/1/2016 22:08'!
tail
	^ self - self leadingTerm! !

!Polynomial methodsFor: 'accessing terms' stamp: 'len 3/27/2016 03:03'!
termAt: aMonomial
	^ self species coefficient: (self coefficientAt: aMonomial) monomial: aMonomial! !

!Polynomial methodsFor: 'accessing terms' stamp: 'len 3/22/2016 23:33'!
terms
	self flag: #fix.
	^ self monomials collect: [:each| self termAt: each] "inefficient"! !

!Polynomial methodsFor: 'operations' stamp: 'len 7/8/2016 05:46'!
value2: anObject in: anIndeterminate
	"Answer the value of the receiver at the argument, as univariate polynomial in the given indeterminate.
	Use Horner's method, doing n multiplications and n additions for a dense polynomial of degree n."
	| answer f lastDegree monomials one |
	self isZero ifTrue: [^ anObject zero].
	"(self has: anIndeterminate) ifFalse: [^ self]."
	one _ anObject one.
	answer _ anObject zero.
	f _ self asUnivariateIn: anIndeterminate.
	monomials _ f monomials asSortedCollection: [:a :b| a degree > b degree].
	lastDegree _ monomials first degree + 1.
	monomials do: [:monomial|
		| coefficient |
		coefficient _ f coefficientAt: monomial.
		answer _ answer * (anObject ** (lastDegree - (lastDegree _ monomial degree))) + (one * coefficient)].
	lastDegree = 0 ifFalse: [answer _ answer * (anObject ** lastDegree)].
	^ answer! !

!Polynomial methodsFor: 'operations' stamp: 'len 7/8/2016 05:47'!
value3: anObject in: anIndeterminate
	"Answer the value of the receiver at the argument, as univariate polynomial in the given indeterminate."
	| answer v |
	self isZero ifTrue: [^ anObject zero].
	"(self has: anIndeterminate) ifFalse: [^ self]."
	answer _ nil.
	(self asUnivariateIn: anIndeterminate) monomialsAndCoefficientsDo: [:key :value|
		v _ (anObject ** key degree) * value.
		answer _ answer isNil ifTrue: [v] ifFalse: [answer + v]].
	^ answer! !

!Polynomial methodsFor: 'operations' stamp: 'len 3/30/2016 03:56'!
value4: anObject in: anIndeterminate
	"Answer the value of the receiver at the argument, as univariate polynomial in the given indeterminate."
	| answer one |
	self isZero ifTrue: [^ anObject zero].
	answer _ anObject zero.
	one _ anObject one.
	(self asUnivariateIn: anIndeterminate) denseCoefficients
		reverseDo: [:each| answer _ anObject * answer + (one * each)].
	^ answer! !

!Polynomial methodsFor: 'operations' stamp: 'len 7/4/2016 01:47'!
value: anObject
	"Answer the value of the receiver at the argument. For multivariate polynomials, a Tuple or Array is expected."
	| answer |
	((anObject is: #Tuple) or: [anObject is: #Array])
		ifFalse: [^ self value: anObject in: self leadingIndeterminate].
	anObject size = self species rank ifFalse: [self error: 'the arity of the argument should match the number of indeterminates'].
	answer _ (anObject at: 1) zero.
	self monomialsAndCoefficientsDo: [:key :value|
		answer _ (key isIdentity ifTrue: [value] ifFalse: [(key value: anObject) * value]) + answer].
	^ answer! !

!Polynomial methodsFor: 'operations' stamp: 'len 3/30/2016 03:56'!
value: anObject in: anIndeterminate
	"Answer the value of the receiver at the argument, as univariate polynomial in the given indeterminate."
	| answer one |
	self isZero ifTrue: [^ anObject zero].
	answer _ anObject zero.
	one _ anObject one.
	(self asUnivariateIn: anIndeterminate) denseCoefficients
		reverseDo: [:each| answer _ anObject * answer + (one * each)].
	^ answer! !

!Polynomial methodsFor: 'constants' stamp: 'len 11/26/2015 03:20'!
zero
	^ self species zero! !

!Polynomial methodsFor: 'roots' stamp: 'len 7/15/2016 05:11'!
zeroAddition: aPolynomial
	"Answer a polynomial whose zeros are the addition of the receiver zeros with the zeros of the argument."

	| f g R R` y X Y m |
	self degree <= aPolynomial degree
		ifTrue: [f _ self. g _ aPolynomial]
		ifFalse: [g _ self. f _ aPolynomial].
	R _ self species.
	y _ R rank + 1.
	R` _ self scalars polynomialsIn: R rank + 1.
	X _ R` x: R indeterminate.
	Y _ R` x: y.
	m _ f companion.
	self flag: #fix. "use as:"
	m _ self scalars polynomials ** m dimension rows: m rows.
	^ ((g value: X - Y) value: m in: y) determinant as: R! !

!Polynomial methodsFor: 'roots' stamp: 'len 3/30/2016 03:57'!
zeroNegation
	"Answer a polynomial whose zeros are the receiver zeros negated."

	^ self species coefficients: (self denseCoefficients withIndexCollect: [:each :i| i odd ifTrue: [each negated] ifFalse: [each]])! !

!Polynomial methodsFor: 'roots' stamp: 'len 7/15/2016 05:11'!
zeroProduct: aPolynomial
	"Answer a polynomial whose zeros are the product of the receiver zeros by the zeros of the argument."
	| f g m |
	self degree <= aPolynomial degree
		ifTrue: [f _ self. g _ aPolynomial]
		ifFalse: [g _ self. f _ aPolynomial].
	m _ f companion.
	m _ self scalars polynomials ** m dimension rows: m rows.
	^ (g homogenized asUnivariate value: m) determinant asMultivariate as: self species! !

!Polynomial methodsFor: 'roots' stamp: 'len 11/22/97 23:36'!
zeroReciprocal
	"Answer a polynomial whose zeros are the reciprocals of the receiver's zeros."

	^ self reversed! !

!MultivariatePolynomial methodsFor: 'accessing coefficients' stamp: 'len 3/22/2016 23:27'!
coefficientAt: aMonomial
	"Answer the coefficient of the monomial given by the argument."
	^ coefficients at: aMonomial ifAbsent: [self scalars zero]! !

!MultivariatePolynomial methodsFor: 'accessing coefficients' stamp: 'len 3/28/2016 03:55'!
coefficientAt: aMonomial add: value
	^ coefficients at: aMonomial add: value! !

!MultivariatePolynomial methodsFor: 'accessing coefficients' stamp: 'len 6/24/2016 21:35'!
coefficientAt: aMonomial put: value
	^ coefficients at: aMonomial put: value! !

!MultivariatePolynomial methodsFor: 'accessing coefficients' stamp: 'len 3/22/2016 23:33'!
coefficients
	^ coefficients! !

!MultivariatePolynomial methodsFor: 'accessing-private' stamp: 'len 3/22/2016 23:33'!
coefficients: aSparseTuple
	coefficients _ aSparseTuple! !

!MultivariatePolynomial methodsFor: 'accessing coefficients' stamp: 'len 5/20/2016 01:45'!
denseCoefficients
	"Answer a dense array of the receivers coefficients ordered by degree.
	Makes sense for univariate polynomails."
	| answer |
	self isZero ifTrue: [^ #()].
	answer _ Array new: self degree+1.
	answer atAllPut: self scalars zero.
	coefficients keysAndValuesDo: [:key :value|
		answer at: key degree + 1 put: value].
	^ answer! !

!MultivariatePolynomial methodsFor: 'private' stamp: 'len 3/22/2016 23:31'!
density
	"Answer a measure of the density/sparsity of the receiver."
	self isZero ifTrue: [^ 0].
	^ coefficients size / (self monomials max: [:each| each degree])! !

!MultivariatePolynomial methodsFor: 'operations' stamp: 'len 3/22/2016 23:37'!
derivativeIn: anIndeterminate
	| answer |
	answer _ self species new.
	coefficients keysAndValuesDo: [:key :value| | degree |
		degree _ key degreeIn: anIndeterminate.
		degree > 0
			ifTrue:
				[answer coefficientAt: (key copy at: anIndeterminate put: degree - 1; yourself) put: value * degree]].
	^ answer! !

!MultivariatePolynomial methodsFor: 'operations' stamp: 'len 3/22/2016 23:38'!
evenIn: anIndeterminate
	"Decompose the receiver in the form f(x^2)x + g(x^2) and answer g(x), where 'x' is the given indeterminate."
	| answer monomial d |
	answer _ self species new.
	coefficients keysAndValuesDo: [:key :value|
		(d _ key degreeIn: anIndeterminate) even
			ifTrue:
				[monomial _ key copy.
				monomial at: anIndeterminate put: d // 2.
				answer coefficientAt: monomial add: value]].
	^ answer! !

!MultivariatePolynomial methodsFor: 'operations' stamp: 'len 3/22/2016 23:37'!
homogeneousComponentAt: anInteger
	"Answer the receiver's homogeneous component of degree anInteger."

	^ self species coefficients: (coefficients selectByKey: [ :each | each degree = anInteger])! !

!MultivariatePolynomial methodsFor: 'initialization' stamp: 'len 3/22/2016 23:38'!
initialize
	coefficients _ SparseTuple new! !

!MultivariatePolynomial methodsFor: 'iterating' stamp: 'len 3/23/2016 05:08'!
monomialsAndCoefficientsDo: aBlock
	coefficients keysAndValuesDo: aBlock! !

!MultivariatePolynomial methodsFor: 'iterating' stamp: 'len 3/23/2016 04:17'!
monomialsApply: aBlock
	| answer |
	answer _ self species new.
	coefficients keysAndValuesDo: [:monomial :coefficient|
		answer coefficientAt: (aBlock value: monomial) add: coefficient].
	^ answer! !

!MultivariatePolynomial methodsFor: 'iterating' stamp: 'len 3/22/2016 23:37'!
monomialsDo: aBlock
	coefficients keysDo: aBlock! !

!MultivariatePolynomial methodsFor: 'operations' stamp: 'len 3/22/2016 23:39'!
oddIn: anIndeterminate
	"Decompose the receiver in the form f(x^2)x + g(x^2) and answer f(x), where 'x' is the given indeterminate."
	| answer monomial d |
	answer _ self species new.
	coefficients keysAndValuesDo: [:key :value|
		(d _ key degreeIn: anIndeterminate) odd
			ifTrue:
				[monomial _ key copy.
				monomial at: anIndeterminate put: d // 2.
				answer coefficientAt: monomial add: value]].
	^ answer! !

!MultivariatePolynomial methodsFor: 'operations' stamp: 'len 3/22/2016 23:39'!
shift: anInteger in: anIndeterminate
	"Answer the receiver shifted anInteger places as univariate polynomial in the given indeterminate."

	| answer monomial d |
	answer _ self species new.
	coefficients keysAndValuesDo: [:key :value|
		d _ (key degreeIn: anIndeterminate) + anInteger.
		d negative ifFalse:
			[monomial _ key copy.
			monomial at: anIndeterminate put: d.
			answer coefficientAt: monomial add: value]].
	^ answer! !

!MultivariatePolynomial class methodsFor: 'instance creation' stamp: 'len 3/26/2016 22:56'!
coefficients: aSparseTuple
	^ self basicNew coefficients: aSparseTuple! !

!MultivariatePolynomial class methodsFor: 'instance creation' stamp: 'len 3/22/2016 23:44'!
new
	^ super new initialize! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 7/9/2016 03:05'!
<< anInteger
	^ self shift: anInteger! !

!UnivariatePolynomial methodsFor: 'comparing' stamp: 'len 7/9/2016 03:00'!
= anObject
	(anObject isKindOf: UnivariatePolynomial) ifFalse: [^ false].
	^ self coefficients = anObject coefficients
"	self degree = anObject degree ifFalse: [^ false].
	0 to: self degree do: [:i| (self coefficientAtDegree: i) = (anObject coefficientAtDegree: i) ifFalse: [^ false]].
	^ true"! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 7/9/2016 03:05'!
>> anInteger
	^ self << anInteger negated! !

!UnivariatePolynomial methodsFor: 'converting' stamp: 'len 7/19/2016 01:09'!
asSparsePolynomial
	^ MultivariatePolynomial coefficients: (SparseTuple accumulate: [:aBlock| self monomialsAndCoefficientsDo: [:key :value| aBlock value: key -> value]])! !

!UnivariatePolynomial methodsFor: 'accessing coefficients' stamp: 'len 3/23/2016 04:08'!
coefficientAt: aMonomial
	^ self coefficientAtDegree: aMonomial degree! !

!UnivariatePolynomial methodsFor: 'accessing coefficients' stamp: 'len 3/26/2016 23:44'!
coefficientAt: aMonomial put: value
	coefficients at: aMonomial degree + 1 put: value.
	(value isZero and: [aMonomial degree + 1 = coefficients size])
		ifTrue: [self normalize].
	^ value! !

!UnivariatePolynomial methodsFor: 'accessing coefficients' stamp: 'len 3/22/2016 23:57'!
coefficientAtDegree: i
	^ coefficients at: i+1 ifAbsent: [self scalars zero]! !

!UnivariatePolynomial methodsFor: 'accessing coefficients' stamp: 'len 3/23/2016 00:04'!
coefficients
	^ coefficients! !

!UnivariatePolynomial methodsFor: 'accessing-private' stamp: 'len 3/29/2016 20:37'!
coefficients: aTuple
	coefficients _ aTuple.
	self normalize! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 7/9/2016 03:05'!
companion
	"Answer the Frobenius companion matrix of the receiver.
	The characteristic polynomial as well as minimal polynomial of the companion matrix C(p) is p.
	Also, given a linear recursive sequence with characteristic polynomial p, the transpose companion matrix of p generates the sequence."
	| n |
	self isMonic ifFalse: [^ DomainError signal: 'Undefined for non-monic polynomials'].
	n _ self degree.
	^ self scalars ** (n@n)
		evaluating: [:i :j| i-1 = j ifTrue: [self scalars one] ifFalse: [j < n ifTrue: [self scalars zero] ifFalse: [(self coefficientAtDegree: i-1) negated]]]! !

!UnivariatePolynomial methodsFor: 'accessing coefficients' stamp: 'len 3/24/2016 03:50'!
degree
	coefficients isEmpty ifTrue: [^ Infinity negative].
	^ coefficients size - 1! !

!UnivariatePolynomial methodsFor: 'accessing coefficients' stamp: 'len 3/30/2016 03:58'!
denseCoefficients
	"Answer a dense tuple of the receivers coefficients ordered by degree."
	^ coefficients! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 3/29/2016 18:10'!
derivative
	| newCoefficients |
	self isZero ifTrue: [^ self].
	newCoefficients _ Array new: self degree.
	1 to: self degree do: [ :i | newCoefficients at: i put: (self coefficientAtDegree: i) * i ].
	^ self species coefficients: newCoefficients! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 3/26/2016 23:05'!
derivativeIn: anIndeterminate
	^ (self has: anIndeterminate) ifTrue: [self derivative] ifFalse: [self zero]! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 7/9/2016 03:06'!
discriminant
	"Answer the (standard) discriminant of the receiver."
	| n |
	n _ self degree.
	^ (-1) ** (n*(n-1)/2) / self leadingCoefficient * (self resultant: self derivative)! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 7/9/2016 03:06'!
discriminant0
	"Answer the (normalized) discriminant of the receiver."
	| n |
	n _ self degree.
	^ (-1) ** (n*(n-1)/2) / (self leadingCoefficient ** (2*n-1)) * (self resultant: self derivative)! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 3/27/2016 03:10'!
even
	"Decompose the receiver in the form f(x^2)x + g(x^2) and answer g(x)."
	^ self species coefficients: ((1 to: self coefficients size by: 2) collect: [:each| coefficients at: each])! !

!UnivariatePolynomial methodsFor: 'arithmetic' stamp: 'len 3/23/2016 04:40'!
exactDivideByMonomial: aMonomial
	^ self shift: aMonomial degree negated! !

!UnivariatePolynomial methodsFor: 'testing' stamp: 'len 3/26/2016 23:08'!
has: anIndeterminate
	^ self degree > 0 and: [self species has: anIndeterminate]! !

!UnivariatePolynomial methodsFor: 'comparing' stamp: 'len 4/11/2016 05:13'!
hash
	| answer |
	self isZero ifTrue: [^ 0].
	answer _ self degree.
	0 to: self degree do: [:i| answer _ answer + (self coefficientAtDegree: i) hash].
	^ answer! !

!UnivariatePolynomial methodsFor: 'accessing coefficients' stamp: 'len 3/23/2016 00:01'!
independentCoefficient
	^ self coefficientAtDegree: 0! !

!UnivariatePolynomial methodsFor: 'testing' stamp: 'len 3/27/2016 07:56'!
isUnivariate
	^ true! !

!UnivariatePolynomial methodsFor: 'testing' stamp: 'len 3/22/2016 23:55'!
isZero
	^ coefficients allSatisfy: [:each| each isZero]! !

!UnivariatePolynomial methodsFor: 'accessing coefficients' stamp: 'len 3/23/2016 00:01'!
leadingCoefficient
	^ self coefficientAtDegree: self degree! !

!UnivariatePolynomial methodsFor: 'iterating' stamp: 'len 3/27/2016 01:40'!
monomialsAndCoefficientsDo: aBlock
	| x |
	x _ self species indeterminate.
	coefficients keysAndValuesDo: [:key :value| value isZero ifFalse: [aBlock value: (Monomial x: x to: key-1) value: value]]! !

!UnivariatePolynomial methodsFor: 'iterating' stamp: 'len 5/19/2016 07:29'!
monomialsApply: aBlock
	| x monomials n newCoefficients |
	x _ self species indeterminate.
	monomials _ (1 to: coefficients size) collect: [:i|
		(aBlock value: (Monomial x: x to: i-1)) -> (coefficients at: i)].
	n _ monomials max: [:each| each key degree].
	newCoefficients _ Array new: n+1 :: atAllPut: self scalars zero.
	monomials do: [:each| newCoefficients at: each key degree + 1 add: each value].
	^ self species coefficients: newCoefficients ! !

!UnivariatePolynomial methodsFor: 'iterating' stamp: 'len 3/26/2016 23:50'!
monomialsDo: aBlock
	| x |
	x _ self species indeterminate.
	1 to: coefficients size do: [:i|
		(coefficients at: i) isZero
			ifFalse: [aBlock value: (Monomial x: x to: i-1)]]! !

!UnivariatePolynomial methodsFor: 'arithmetic' stamp: 'len 3/23/2016 05:55'!
multiplyByMonomial: aMonomial
	^ self shift: aMonomial degree! !

!UnivariatePolynomial methodsFor: 'accessing-private' stamp: 'len 3/26/2016 23:46'!
normalize
	| n |
	n _ coefficients findLast: [:one| one isZero not].
	n < coefficients size ifTrue: [coefficients _ coefficients copyFrom: 1 to: n]! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 3/27/2016 03:09'!
odd
	"Decompose the receiver in the form f(x^2)x + g(x^2) and answer f(x)."
	^ self species coefficients: ((2 to: self coefficients size by: 2) collect: [:each| coefficients at: each])! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 7/9/2016 03:07'!
psc2: anInteger with: aPolynomial
	"Answer the anInteger-th principal subresultant coefficient of the receiver with aPolynomial."

	| f g n m t matrix tuple |
	f _ self.
	g _ aPolynomial.
	m _ f degree.
	n _ g degree.
	t _ m + n - anInteger - anInteger.
	t = 0 ifTrue: [^ f one].
	matrix _ (f scalars ** (t@t)) new.
	tuple _ self scalars tuple: t evaluating: [:i| f coefficientAtDegree: m - i + 1].
	n - anInteger timesRepeat: [matrix addRow: tuple. tuple _ tuple shift: 1].
	tuple _ self scalars tuple: t evaluating: [:i| g coefficientAtDegree: n - i + 1].
	m - anInteger timesRepeat: [matrix addRow: tuple. tuple _ tuple shift: 1].
	^ matrix determinant! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 7/9/2016 03:07'!
psc3: i with: aPolynomial
	"Answer the anInteger-th principal subresultant coefficient of the receiver with aPolynomial."
	self flag: #fix. "user version 2, more efficient, but must test"
	^ (self subresultant: i with: aPolynomial) leadingCoefficient "WTF, sometimes subresultant returns nil, SemialgebraicSet circle"! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 7/9/2016 03:07'!
psc: anInteger with: aPolynomial
	"Answer the anInteger-th principal subresultant coefficient of the receiver with aPolynomial."

	| f g n m t matrix tuple |
	f _ self.
	g _ aPolynomial.
	m _ f degree.
	n _ g degree.
	t _ m + n - anInteger - anInteger.
	t <= 0 ifTrue: [^ self scalars one].
	matrix _ (f scalars ** (t@t)) new.
	tuple _ self scalars tuple: t evaluating: [:i| f coefficientAtDegree: m - i + 1].
	n - anInteger timesRepeat: [matrix addRow: tuple. tuple _ tuple shift: 1].
	tuple _ self scalars tuple: t evaluating: [:i| g coefficientAtDegree: n - i + 1].
	m - anInteger timesRepeat: [matrix addRow: tuple. tuple _ tuple shift: 1].
	^ matrix determinant! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 7/9/2016 03:07'!
resultant2: aPolynomial
	"Answer the resultant of the receiver with the argument."
	| f g mult |
	self degree <= aPolynomial degree
		ifTrue: [f _ self. g _ aPolynomial]
		ifFalse: [f _ aPolynomial. g _ self].
	f isConstant ifTrue: [^ (f ** g degree)].
	f isMonic
		ifTrue:
			[mult _ f leadingCoefficient]
		ifFalse:
			[mult _ f leadingCoefficient ** g degree.
			f _ f / f leadingCoefficient].
	^ (g value: f companion) determinant * mult! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 7/9/2016 03:07'!
resultant3: aPolynomial
	"Answer the resultant of the receiver with the argument."

	| f g answer negate |
	self degree > aPolynomial degree
		ifTrue: [f _ aPolynomial. g _ self. negate _ true]
		ifFalse: [f _ self. g _ aPolynomial. negate _ false].
	answer _ f isConstant
		ifTrue: [f ** g degree]
		ifFalse:
			[(f resultant3: g \\ f) * (f leadingCoefficient ** (g degree - f degree + 1))].
	^ negate ifTrue: [answer negated] ifFalse: [answer]! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 7/9/2016 03:07'!
resultant: aPolynomial
	"Answer the resultant of the receiver with aPolynomial."
	self degree = 0
		ifTrue: [^ aPolynomial ** self degree].
	aPolynomial degree = 0
		ifTrue:
			[^ (self degree even or: [aPolynomial degree even])
					ifTrue: [(self ** aPolynomial degree)]
					ifFalse: [(self ** aPolynomial degree) negated]].
	^ (self sylvester: aPolynomial) determinant! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 7/2/2016 06:00'!
reversed
	"Answer the reverse of the receiver."

	^ self species coefficients: coefficients reversed! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 3/29/2016 18:17'!
shift: anInteger
	| n |
	self isZero ifTrue: [^ self].
	n _ self degree + anInteger.
	n >= 0 ifFalse: [^ self zero].
	^ self species coefficients: coefficients >>> anInteger! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 7/9/2016 03:08'!
subresultant: i with: aPolynomial
	"Answer the i-th subresultant of the receiver with aPolynomial."
	| lambda mu n m c matrix tuple t |
	self isUnivariate ifFalse: [^ DomainError signal: 'polynomial is not univariate'].
	m _ self degree.
	n _ aPolynomial degree.
	lambda _ m min: n.
	mu _ (m max: n) - 1.
	i = lambda
		ifTrue:
			[m + 1 < n
				ifTrue: [c _ self]
				ifFalse:
					[n + 1 < m
						ifTrue: [c _ aPolynomial] ifFalse: [^ nil]].
			^ c * (c leadingCoefficient ** ((m - n) abs - 1))].
	(i between: lambda and: mu) ifTrue: [^ self zero].
	(i between: 0 and: lambda - 1) ifFalse: [self error: 'index out of range'].
	t _ m + n - (2*i).
	matrix _ (self species ** (t@t)) new.
	tuple _ self scalars tuple: m + n - (2*i) evaluating: [:k| self species constant: (self coefficientAtDegree: m - k + 1)].
	n - i timesRepeat: [matrix addRow: tuple. tuple _ tuple shift: 1].
	tuple _ self scalars tuple: m + n - (2*i) evaluating: [:k| self species constant: (aPolynomial coefficientAtDegree: n - k + 1)].
	m - i timesRepeat: [matrix addRow: tuple. tuple _ tuple shift: 1].
	1 to: n - i do: [:k|
		matrix at: k @ (m + n - (2*i)) put: (self shift: n - i - k)].
	1 to: m - i do: [:k|
		matrix at: n - i + k @ (m + n - (2*i)) put: (aPolynomial shift: m - i - k)].
	^ matrix determinant! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 7/9/2016 03:08'!
subresultantChain: aPolynomial
	"Answer the Subresultant Chain of the receiver with the argument."
	| n answer |
	n _ self degree > aPolynomial degree ifTrue: [self degree - 1] ifFalse: [aPolynomial degree].
	answer _ OrderedCollection new: n + 2.
	answer add: self; add: aPolynomial.
	n - 1 to: 0 by: -1 do: [:i|
		answer add: (self subresultant: i with: aPolynomial)].
	^ answer! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 7/15/2016 05:11'!
sylvester: aPolynomial
	"Answer the Sylvester matrix of the receiver with the argument.
	If p,q polynomials of degrees m and n:
		det S(p,q) = res (p,q)
		deg (gcd(p,q)) = m - n + rank (S(p,q))
	Also the kernel of the transposed Sylvester matrix gives all solutions of the Bezout equation:
		f*p + g*q = 0
	"
	| m n rows p q |
	m _ self degree.
	n _ aPolynomial degree.
	rows _ OrderedCollection new: m+n.
	p _ self scalars tuple: ((1 to: m+n) collect: [:i| self coefficientAtDegree: m-i+1]).
	n timesRepeat: [rows add: p. p _ p shift: 1].
	q _ self scalars tuple: ((1 to: m+n) collect: [ :i | aPolynomial coefficientAtDegree: n-i+1]).
	m timesRepeat: [rows add: q. q _ q shift: 1].
	^ (self scalars ** (m+n @ (m+n))) rows: rows! !

!UnivariatePolynomial methodsFor: 'operations' stamp: 'len 3/30/2016 07:13'!
value: anObject
	"Evaluate the receiver at the given argument using Horner's method."
	| v answer one |
	v _ ((anObject is: #Tuple) or: [anObject isKindOf: Array])
		ifTrue: [anObject at: 1] ifFalse: [anObject].
	answer _ v zero.
	one _ v one.
	coefficients reverseDo: [:each| answer _ v * answer + (one * each)].
	^ answer! !

!UnivariatePolynomial class methodsFor: 'instance creation' stamp: 'len 3/29/2016 20:38'!
coefficients: aTuple
	(aTuple isKindOf: SparseTuple) ifTrue: [self halt].
	^ self basicNew coefficients: aTuple! !

!UnivariatePolynomial class methodsFor: 'instance creation' stamp: 'len 3/23/2016 05:20'!
new
	^ self shouldNotImplement! !

!FiniteFieldPolynomialFactorizer methodsFor: 'private' stamp: 'len 3/23/2016 08:34'!
distinctDegreeFactorization: aPolynomial
	"Answer the distinct-degree factorization of a monic square-free polynomial.
	The factorization is a Dictionary g -> d, where g is the product of all irreducible factors of degree d."
	| answer i f f` one q x |
	answer _ Dictionary new.
	f _ aPolynomial.
	x _ f species x.
	one _ f species one.
	q _ f species characteristic.
	i _ 1.
	f` _ f.
	[f` degree >= (2*i)]
		whileTrue:
			[ | g | g _ f` gcd: (x raisedTo: q**i modulo: f`) - x.
			g ~= one ifTrue: [answer at: i put: g. f` _ f` // g].
			i _ i + 1].
	f` ~= one ifTrue: [answer at: f` degree put: f`].
	answer isEmpty ifTrue: [answer at: 1 put: f].
	^ answer! !

!FiniteFieldPolynomialFactorizer methodsFor: 'private' stamp: 'len 3/23/2016 08:35'!
equalDegreeFactorization: aPolynomial r: r d: d
	"Cantor-Zassenhaus algorithm. Answer the equal-degree factorization of a monic squarefree univariate polynomial which has r>=2 pairwise distinct irreducible factors each of degree d."
	| f Fx F q h g one factors c |
	f _ aPolynomial.
	Fx _ f species.
	F _ Fx scalars.
	q _ F size.
	q even ifTrue: [^ self error: 'order not odd'].
	one _ Fx one.
	factors _ OrderedCollection with: f.
	[factors size < r]
		whileTrue:
			[h _ Fx atRandomMaxDegree: 2*d-1. "should be monic? should: d <= deg(h) <= 2d-1"
			g _ h raisedTo: q**d - 1 / 2 modulo: f.
			factors do: [:u|
				u degree > d
					ifTrue:
						[c _ g gcd: u.
						(c ~= one and: [c ~= u])
							ifTrue:
								[factors _ factors copyWithout: u.
								factors add: c; add: u // c]]]].
	^ factors! !

!FiniteFieldPolynomialFactorizer methodsFor: 'factorization' stamp: 'len 12/6/2015 06:03'!
factors
	| answer sff |
	answer _ Bag new.
	sff _ self squareFreeFactorization.
	sff asSet do: [:f| | ddf multiplicity |
		multiplicity _ sff occurrencesOf: f.
		ddf _ self distinctDegreeFactorization: f.
		ddf keysDo: [:d| | g r |
			g _ ddf at: d.
			r _ g degree / d.
			(self equalDegreeFactorization: g r: r d: d)
				do: [:each| answer add: each withOccurrences: multiplicity]]].
	^ answer! !

!FiniteFieldPolynomialFactorizer methodsFor: 'factorization' stamp: 'len 3/23/2016 08:35'!
isIrreducible
	| Fx x one f n h g q |
	factors notNil ifTrue: [^ factors size = 1].
	(polynomial independentCoefficient isZero and: [polynomial degree > 1]) ifTrue: [^ false].
	"Rabin's algorithm:"
	f _ polynomial.
	Fx _ f species.
	q _ Fx scalars size.
	x _ Fx x.
	one _ Fx one.
	n _ f degree.
	n factors asSet do: [:p|
		h _ (x raisedTo: q**(n/p) modulo: f) - x \\ f.
		g _ f gcd: h.
		g ~= one ifTrue: [^ false]].
	g _ (x raisedTo: q**n modulo: f) - x \\ f.
	g isZero ifFalse: [^ false].
	factors _ {polynomial}.
	^ true! !

!FiniteFieldPolynomialFactorizer methodsFor: 'initialization' stamp: 'len 12/6/2015 00:02'!
polynomial: aPolynomial
	polynomial _ aPolynomial! !

!FiniteFieldPolynomialFactorizer methodsFor: 'printing' stamp: 'len 1/15/2016 06:11'!
printOn: aStream
	aStream print: polynomial; nextPutAll: ' = '.
	self factors asSet
		do: [:each| | d |
			aStream nextPut: $(; print: each; nextPut: $).
			(d _ self factors occurrencesOf: each) > 1
				ifTrue: [aStream nextPut: $^; print: d]]! !

!FiniteFieldPolynomialFactorizer methodsFor: 'factorization' stamp: 'len 3/22/2016 23:19'!
squareFreeFactorization
	"Answer the Square-Free Factorization of a monic polynomial."
	| answer f one p i g c w y z |
	answer _ Bag new.
	f _ polynomial.
	one _ f one.
	p _ f scalars characteristic.
	i _ 1. g _ f derivative.
	g isZero
		ifTrue:
			[f _ f monomialsApply: [:m| m root: p].
			(self class new polynomial: f) squareFreeFactorization asSet
				do: [:each| answer add: each withOccurrences: p]]
		ifFalse:
			[c _ f gcd: g.
			w _ f // c.
			[w = one]
				whileFalse:
					[y _ w gcd: c. z _ w // y.
					z ** i = one ifFalse: [answer add: z withOccurrences: i].
					i _ i + 1.
					w _ y. c _ c // y].
			c = one
				ifFalse:
					[c _ c monomialsApply: [:m| m root: p].
					(self class new polynomial: c) squareFreeFactorization
						do: [:each| answer add: each withOccurrences: p]]].
	^ answer! !

!IntegerPolynomialFactorizer methodsFor: 'as yet unclassified' stamp: 'len 12/6/2015 21:32'!
squareFreeFactorization
	"Answer a squarefree factorization of the polynomial.
	Use Yun's algorithm. Assume the coefficients are in a unique factorization domain or in a field of characteristic 0."

	| f Rx R p q gcd count answer lc |
	f _ polynomial.
	Rx _ f species.
	R _ Rx scalars.
	((R isField and: [R characteristic = 0]) or: [R isUFD])
		ifFalse: [^ self notYetImplemented].
	answer _ Bag new.
	count _ 1.
	lc _ f leadingCoefficient.
	lc = f scalars one
		ifFalse: [answer add: (Rx constant: lc)].
	p _ f / lc.
	q _ p derivative.
	gcd _ p gcd: q.
	gcd degree > 0
		ifTrue:
			[p _ p // gcd.
			q _ q // gcd - p derivative.
			[q isZero]
				whileFalse:
					[gcd _ p gcd: q.
					gcd degree > 0 ifTrue: [answer add: gcd withOccurrences: count].
					count _ count + 1.
					p _ p // gcd.
					q _ q // gcd - p derivative]].
	^ answer add: p withOccurrences: count; yourself! !

!MultiPolynomialDivision methodsFor: 'private' stamp: 'len 7/7/2016 04:11'!
divide
	"Perform the division algorithm computing quotients and remainder."
	| p s zero fi q headp headfi t heads i |
	zero _ dividend zero.
	quotients _ (1 to: divisors size) collect: [:each| zero].
	remainder _ zero.
	s _ divisors size.
	p _ dividend.
	heads _ Array new: divisors size.
	[p isZero] whileFalse:
		[headp _ self ordering headOf: p.
		t _ p termAt: headp.
		i _ 1.
		[headfi _ (heads at: i) ifNil: [heads at: i put: (self ordering headOf: (fi _ divisors at: i))].
		(headfi | headp) or: [(i _ i + 1) > s]] whileFalse.
		i <= s "i.e. found fi such that headfi | headp"
			ifTrue:
				[fi _ divisors at: i.
				q _ t / headfi / (fi coefficientAt: headfi).
				quotients at: i put: (quotients at: i) + q.
				p _ p - (fi * q)]
			ifFalse:
				[remainder _ remainder + t.
				p _ p - t]]! !

!MultiPolynomialDivision methodsFor: 'initialization' stamp: 'len 12/6/2015 19:03'!
divide: aPolynomial by: anArrayOfPolynomials
	dividend _ aPolynomial.
	divisors _ anArrayOfPolynomials! !

!MultiPolynomialDivision methodsFor: 'accessing' stamp: 'len 12/2/2015 02:48'!
dividend
	^ dividend! !

!MultiPolynomialDivision methodsFor: 'accessing' stamp: 'len 12/2/2015 02:48'!
divisors
	^ divisors! !

!MultiPolynomialDivision methodsFor: 'accessing' stamp: 'len 2/5/98 01:06'!
ordering
	"Answer the monomial ordering used by the receiver."

	^ ordering! !

!MultiPolynomialDivision methodsFor: 'accessing' stamp: 'len 2/5/98 01:06'!
ordering: aMonomialOrdering
	"Change the monomial ordering used by the receiver."

	ordering _ aMonomialOrdering! !

!MultiPolynomialDivision methodsFor: 'printing' stamp: 'len 1/24/98 12:49'!
printOn: aStream
	"Print a representation of the receiver on the stream aStream."

	aStream print: self dividend; nextPutAll: ' = '.
	(1 to: self divisors size) do: [ :each |
		aStream
			nextPut: $(; print: (self quotients at: each); nextPut: $);
			nextPut: $(; print: (self divisors at: each); nextPut: $);
			nextPutAll: ' + '].
	aStream print: self remainder! !

!MultiPolynomialDivision methodsFor: 'accessing' stamp: 'len 3/9/2016 07:55'!
quotient
	self quotients size = 1 ifFalse: [self error: 'not just one quotient'].
	^ self quotients first! !

!MultiPolynomialDivision methodsFor: 'accessing' stamp: 'len 12/6/2015 06:13'!
quotients
	quotients isNil ifTrue: [self divide].
	^ quotients! !

!MultiPolynomialDivision methodsFor: 'accessing' stamp: 'len 12/6/2015 06:13'!
remainder
	remainder isNil ifTrue: [self divide].
	^ remainder! !

!MultiPolynomialDivision methodsFor: 'private' stamp: 'len 7/7/2016 04:12'!
verify
	| total |
	total _ self remainder.
	self divisors with: self quotients do: [:f :q| total _ total + (f*q)].
	total = self dividend ifFalse: [^ false halt].

	self divisors with: self quotients do: [:f :q|
		(q isZero not and: [ordering is: (ordering headOf: f*q) gneq: (ordering headOf: self dividend)])
			ifTrue: [^ false halt]].
	
	self remainder monomials do: [:each| (divisors noneSatisfy: [:f| (ordering headOf: f) | each]) ifFalse: [^ false halt]].
	^ true ! !

!MultiPolynomialDivision class methodsFor: 'instance creation' stamp: 'len 3/9/2016 21:46'!
divide: aPolynomial by: anArrayOfPolynomials
	^ self divide: aPolynomial by: anArrayOfPolynomials ordering: aPolynomial species ordering "default ordering"! !

!MultiPolynomialDivision class methodsFor: 'instance creation' stamp: 'len 3/9/2016 07:49'!
divide: aPolynomial by: anArrayOfPolynomials ordering: aMonomialOrdering
	^ self new
		ordering: aMonomialOrdering;
		divide: aPolynomial by: anArrayOfPolynomials! !

!PolynomialDivision methodsFor: 'private' stamp: 'len 6/30/2016 07:25'!
divide
	"Compute the quotient and the remainder polynomials."
	| quo rem lc n m term |
	divisor isZero ifTrue: [^ (ZeroDivide dividend: dividend) signal].
	divisor degree = 0
		ifTrue: [quotient _ dividend * divisor leadingCoefficient reciprocal.
					remainder _ dividend zero.
					^ self].
	dividend degree < (m _ divisor degree)
		ifTrue: [quotient _ dividend zero. remainder _ dividend.
					^ self].
"	indeterminate _ divisor leadingIndeterminate."
	quo _ dividend species zero.
	rem _ dividend copy.
	lc _ divisor leadingCoefficient.
	[(n _ rem degree) >= m]
		whileTrue:
			[term _ dividend species coefficient: rem leadingCoefficient / lc degree: n-m.
			rem _ rem + (divisor * term negated).
			"or optimized as:
			divisor monomialsAndCoefficientsDo: [:key :value|
				rem coefficientAt: key * monomial add: value * minusC]."
			quo _ quo + term.
			" or optimized as:
			quo coefficientAt: monomial add: c"].
	quotient _ quo. remainder _ rem! !

!PolynomialDivision methodsFor: 'initialization' stamp: 'len 12/6/2015 06:19'!
divide: aPolynomial by: anotherPolynomial
	dividend _ aPolynomial.
	divisor _ anotherPolynomial! !

!PolynomialDivision methodsFor: 'accessing' stamp: 'len 12/2/2015 02:43'!
dividend
	^ dividend! !

!PolynomialDivision methodsFor: 'accessing' stamp: 'len 12/2/2015 02:44'!
divisor
	^ divisor! !

!PolynomialDivision methodsFor: 'printing' stamp: 'len 1/24/98 12:43'!
printOn: aStream
	"Print a representation of the receiver on the stream aStream."

	aStream
		print: self dividend;
		nextPutAll: ' = (';
		print: self quotient;
		nextPutAll: ')(';
		print: self divisor;
		nextPutAll: ') + ';
		print: self remainder! !

!PolynomialDivision methodsFor: 'accessing' stamp: 'len 12/6/2015 06:19'!
quotient
	quotient isNil ifTrue: [self divide].
	^ quotient! !

!PolynomialDivision methodsFor: 'accessing' stamp: 'len 12/6/2015 06:19'!
remainder
	remainder isNil ifTrue: [self divide].
	^ remainder! !

!PolynomialDivision class methodsFor: 'instance creation' stamp: 'len 1/23/98 16:03'!
divide: aPolynomial by: anotherPolynomial
	"Answer a division algorithm to divide aPolynomial by anotherPolynomial."

	^ self new divide: aPolynomial by: anotherPolynomial! !

!PolynomialInterpolator methodsFor: 'accessing' stamp: 'len 11/17/97 18:21'!
corrector
	"Answer the correction polynoial."

	^ corrector! !

!PolynomialInterpolator methodsFor: 'accessing-private' stamp: 'len 11/17/97 18:20'!
corrector: aPolynomial
	corrector _ aPolynomial! !

!PolynomialInterpolator methodsFor: 'initialization' stamp: 'len 7/19/2016 01:03'!
initialize
	self flag: #fix.
	self polynomial: Polynomial null.
	self corrector: Polynomial identity! !

!PolynomialInterpolator methodsFor: 'operations' stamp: 'len 11/24/2015 06:16'!
map: aNumber to: anotherNumber
	"Change the interpolation polynomial to map aNumber to anotherNumber."

	| f q m |
	f _ self polynomial.
	q _ self corrector.
	m _ anotherNumber - (f value: aNumber) / (q value: aNumber).
	f _ q * m + f.
	q _ q * aNumber negated + (q shift: 1).
	self polynomial: f.
	self corrector: q.
	^ anotherNumber! !

!PolynomialInterpolator methodsFor: 'accessing' stamp: 'len 11/17/97 18:20'!
polynomial
	"Answer the interpolation polynoial."

	^ polynomial! !

!PolynomialInterpolator methodsFor: 'accessing-private' stamp: 'len 11/17/97 18:20'!
polynomial: aPolynomial
	polynomial _ aPolynomial! !

!PolynomialInterpolator class methodsFor: 'instance creation' stamp: 'len 11/17/97 18:30'!
new
	^ super new initialize! !

!PolynomialPseudoDivision methodsFor: 'accessing' stamp: 'len 3/8/2016 22:39'!
delta
	"Answer an integer delta such that the dividend multiplied by the divisor's leading coeficient raised to the delta equals the product of the quotient by the divisor plus the remainder (the pseudo-division relation)."
	^ self dividend degree - self divisor degree + 1 max: 0! !

!PolynomialPseudoDivision methodsFor: 'private' stamp: 'len 3/8/2016 22:32'!
divide
	"COHEN Algorithm 3.1.2 (Pseudo-Division)."
	| P m n d e lc s |
	divisor isZero ifTrue: [^ (ZeroDivide dividend: dividend) signal].
	P _ dividend species.
	(m _ dividend degree) < (n _ divisor degree)
		ifTrue: [quotient _ P zero. remainder _ dividend. ^ self].
	d _ divisor leadingCoefficient.
	remainder _ dividend.
	quotient _ P zero.
	e _ m - n + 1.
	[remainder degree < n
		ifTrue: [| q | q _ d ** e. quotient _ quotient * q. remainder _ remainder * q. ^ self].
	lc _ remainder leadingCoefficient.
	m _ remainder degree.
	s _ P coefficient: lc degree: remainder degree - n.
	quotient _ quotient * d + s.
	remainder _ remainder * d - (divisor * s).
	e _ e - 1] repeat! !

!PolynomialPseudoDivision methodsFor: 'initialization' stamp: 'len 12/11/2015 06:56'!
divide: aPolynomial by: anotherPolynomial
	dividend _ aPolynomial.
	divisor _ anotherPolynomial! !

!PolynomialPseudoDivision methodsFor: 'accessing' stamp: 'len 12/11/2015 06:55'!
dividend
	^ dividend! !

!PolynomialPseudoDivision methodsFor: 'accessing' stamp: 'len 12/2/2015 02:51'!
divisor
	^ divisor! !

!PolynomialPseudoDivision methodsFor: 'accessing' stamp: 'len 3/30/2016 06:34'!
exactQuotient
	"Answer the quotient of an exact division."
	^ self quotient / (divisor leadingCoefficient ** self delta)! !

!PolynomialPseudoDivision methodsFor: 'printing' stamp: 'len 7/8/2016 05:47'!
printOn: aStream
	"Print a representation of the receiver on the stream aStream."

	aStream
		print: (self divisor leadingCoefficient ** self delta);
		nextPut: $(;
		print: self dividend;
		nextPutAll: ') = (';
		print: self quotient;
		nextPutAll: ')(';
		print: self divisor;
		nextPutAll: ') + ';
		print: self remainder! !

!PolynomialPseudoDivision methodsFor: 'accessing' stamp: 'len 12/6/2015 07:30'!
quotient
	quotient isNil ifTrue: [self divide].
	^ quotient! !

!PolynomialPseudoDivision methodsFor: 'accessing' stamp: 'len 12/6/2015 07:31'!
remainder
	remainder isNil ifTrue: [self divide].
	^ remainder! !

!PolynomialPseudoDivision methodsFor: 'private' stamp: 'len 7/4/2016 04:37'!
verify
	| a b |
	a _ dividend * (divisor leadingCoefficient ** self delta).
	b _ self quotient * divisor + self remainder.
	^ a = b! !

!PolynomialPseudoDivision class methodsFor: 'instance creation' stamp: 'len 12/11/2015 06:57'!
divide: aPolynomial by: anotherPolynomial
	"Answer a pseudo-division algorithm to divide aPolynomial by anotherPolynomial."
	^ self new divide: aPolynomial by: anotherPolynomial! !

!ProbabilisticPolynomialFactorizer methodsFor: 'private' stamp: 'len 12/2/2015 02:31'!
computeIrreducibility
	self subclassResponsibility! !

!ProbabilisticPolynomialFactorizer methodsFor: 'accessing' stamp: 'len 12/2/2015 02:32'!
done
	^ done! !

!ProbabilisticPolynomialFactorizer methodsFor: 'accessing-private' stamp: 'len 8/23/97 21:57'!
done: aBoolean
	done _ aBoolean! !

!ProbabilisticPolynomialFactorizer methodsFor: 'operations' stamp: 'len 12/2/2015 02:31'!
factorize
	self subclassResponsibility! !

!ProbabilisticPolynomialFactorizer methodsFor: 'accessing' stamp: 'len 12/2/2015 02:32'!
factors
	self factorize.
	^ factors! !

!ProbabilisticPolynomialFactorizer methodsFor: 'accessing' stamp: 'len 12/2/2015 02:32'!
irreducible
	"Answer a fraction 'q' representing that the polynomial is irreducible with probability of error less than 'q'."

	^ irreducible! !

!ProbabilisticPolynomialFactorizer methodsFor: 'accessing-private' stamp: 'len 8/23/97 17:46'!
irreducible: anInteger
	irreducible _ anInteger! !

!ProbabilisticPolynomialFactorizer methodsFor: 'testing' stamp: 'len 8/23/97 17:53'!
isIrreducible
	"Answer true if the polynomial is irreducible."

	(self irreducible = 0 or: [self irreducible = 1])
		ifFalse: [self computeIrreducibility].
	^ self irreducible = 1! !

!ProbabilisticPolynomialFactorizer methodsFor: 'testing' stamp: 'len 12/2/2015 02:33'!
isIrreducibleProbabilistic: anInteger
	"Answer true if the polynomial is irreducible with probability of error less than '1/2^anInteger'."

	^ self isIrreducible! !

!ProbabilisticPolynomialFactorizer methodsFor: 'accessing' stamp: 'len 12/2/2015 02:32'!
polynomial
	^ polynomial! !

!ProbabilisticPolynomialFactorizer methodsFor: 'initialization' stamp: 'len 12/2/2015 02:29'!
polynomial: aPolynomial
	polynomial _ aPolynomial.
	factors _ Bag new.
	done _ false! !

!ProbabilisticPolynomialFactorizer methodsFor: 'printing' stamp: 'len 12/2/2015 02:33'!
printOn: aStream
	aStream nextPutAll: self class name; nextPutAll: ' on '; print: self polynomial! !

!ProbabilisticPolynomialFactorizer class methodsFor: 'instance creation' stamp: 'len 11/6/97 21:12'!
polynomial: aPolynomial
	"Answer a new instance of the receiver to factorize aPolynomial."

	^ self new polynomial: aPolynomial! !

!RootFinder methodsFor: 'accessing' stamp: 'len 1/11/2016 04:30'!
polynomial
	^ polynomial! !

!RootFinder methodsFor: 'accessing-private' stamp: 'len 6/5/2016 04:55'!
polynomial: aPolynomial	
	polynomial _ aPolynomial! !

!RootFinder methodsFor: 'printing' stamp: 'len 1/11/2016 04:30'!
printOn: aStream
	aStream nextPutAll: self class name; nextPutAll: ' on '; print: self polynomial! !

!RootFinder methodsFor: 'accessing' stamp: 'len 6/5/2016 05:21'!
roots
	^ self subclassResponsibility! !

!RootFinder class methodsFor: 'instance creation' stamp: 'len 11/6/97 21:11'!
polynomial: aPolynomial
	"Answer a new instance of the receiver to find the roots of aPolynomial."

	^ self new polynomial: aPolynomial! !

!ComplexRootFinder methodsFor: 'as yet unclassified' stamp: 'len 6/5/2016 21:30'!
T: K at: m radius: r
	| t |
	t _ 0.
	1 to: self derivatives size do: [:j|
		| f |
		f _ derivatives at: j.
		t _ (f value: m) abs * (r ** j) / j factorial + t].
	^ (squareFreePolynomial value: m) abs > (K * t)! !

!ComplexRootFinder methodsFor: 'as yet unclassified' stamp: 'len 6/5/2016 21:32'!
T`: K at: m radius: r
	| t |
	t _ 0.
	1 to: self derivatives size - 1 do: [:j|
		| f |
		f _ derivatives at: j+1.
		t _ (f value: m) abs * (r ** j) / j factorial + t].
	^ (derivatives first value: m) abs > (K * t)! !

!ComplexRootFinder methodsFor: 'as yet unclassified' stamp: 'len 6/5/2016 05:07'!
bigBounds
	"Compute and answer a first estimate of a box containing all the complex roots."
	| bound |
	bound _ self polynomial norm1 / self polynomial leadingCoefficient.
	bound _ bound max: 1.
	^ ComplexBox center: 0 radius: bound! !

!ComplexRootFinder methodsFor: 'as yet unclassified' stamp: 'len 6/5/2016 21:26'!
derivatives
	| f |
	derivatives ifNotNil: [^ derivatives].
	f _ squareFreePolynomial.
	derivatives _ OrderedCollection new: f degree.
	f degree timesRepeat: [derivatives add: (f _ f derivative)].
	^ derivatives! !

!ComplexRootFinder methodsFor: 'as yet unclassified' stamp: 'len 6/5/2016 22:28'!
eightPointTest: m width: w
	| N NE E SE S SW W NW points values imaginaryCrossings realCrossings |
	N _ 1 i.
	NE _ 20/29 + (21/29) i.
	E _ 1.
	SE _ 20/29 - (21/29) i.
	S _ -1 i.
	SW _ -20/29 - (21/29) i.
	W _ -1.
	NW _ -20/29 + (21/29) i.
	points _ {N. NE. E. SE. S. SW. W. NW} collect: [:p| w*p + m].
	values _ points collect: [:p| squareFreePolynomial value: p].
	realCrossings _ (1 to: values size) select: [:j| (values at: j) real isZero or: [(values at: j) real * (values atWrap: j+1) real < 0]].
	realCrossings size = 2 ifFalse: [^ false].
	imaginaryCrossings _ (1 to: values size) select: [:j| (values at: j) imaginary isZero or: [(values at: j) imaginary * (values atWrap: j+1) imaginary < 0]].
	imaginaryCrossings size = 2 ifFalse: [^ false].
	realCrossings first < imaginaryCrossings first
		ifTrue: [^ realCrossings second < imaginaryCrossings second].
	^ realCrossings first > imaginaryCrossings first
		and: [realCrossings second > imaginaryCrossings second]! !

!ComplexRootFinder methodsFor: 'as yet unclassified' stamp: 'len 6/5/2016 20:40'!
moreThanOneRootIn: aDisk
	"if this holds, there's at most one root in aDisk."
	^ self T`: 3/2 at: aDisk center radius: aDisk radius
"	^ (self rootsIn: aBox) size > 1"! !

!ComplexRootFinder methodsFor: 'as yet unclassified' stamp: 'len 6/5/2016 05:08'!
polynomial: aPolynomial
	polynomial _ aPolynomial.
	self flag: #fix. "this could be exact division, also doing the same in class side via #reduced"
	squareFreePolynomial _ (aPolynomial // (aPolynomial gcd: aPolynomial derivative)) integerPrimitive! !

!ComplexRootFinder methodsFor: 'as yet unclassified' stamp: 'len 6/5/2016 05:16'!
roots
	"Separate the roots in disks each of them containing one isolated root."
	^ self rootsIn: self bigBounds! !

!ComplexRootFinder methodsFor: 'as yet unclassified' stamp: 'len 6/5/2016 22:32'!
rootsIn: aBox
	"Separate the roots in disks each of them containing one isolated root."
	| queue disks |
	queue _ OrderedCollection with: aBox.
	disks _ OrderedCollection new.
	[queue isEmpty]
		whileFalse:
			[| B m delta |
			B _ queue removeFirst.
			m _ B midpoint.
			delta _ B width * 3 / 4. "> B radius, and a dyadic fraction"
			(self T: 1 at: m radius: delta)
				"if holds, then D(m,delta) constains no roots"
				ifFalse:
					[((self T`: 6 at: m radius: 4*delta) and: [self T`: 3/2 at: m radius: 8*delta])
						"if the second holds, then D(m,8*delta) contains at most one root"
						"the first is required so that if two disks overlap, we can discard any one of them"
						ifTrue:
							[(self eightPointTest: m width: B width)
								ifTrue:
									[| D i D` |
									D _ ComplexDisk center: m radius: 4*delta.
									(i _ (1 to: disks size) detect: [:j| (D` _ disks at: j) intersects: D] ifNone: [])
									 isNil
										ifTrue: [disks add: D]
										ifFalse: [D` radius < D radius ifTrue: [disks at: i put: D]]]]
						ifFalse:
							[queue addAll: B quarters]]].
	^ disks collect: [:each| AlgebraicNumber polynomial: squareFreePolynomial approximation: each center radius: each radius]! !

!ComplexRootFinder methodsFor: 'as yet unclassified' stamp: 'len 6/5/2016 05:09'!
squareFreePolynomial: aPolynomial
	polynomial _ aPolynomial.
	squareFreePolynomial _ aPolynomial! !

!FiniteFieldRootFinder methodsFor: 'accessing' stamp: 'len 6/5/2016 05:17'!
roots
	| roots |
	roots _ OrderedCollection new.
	(FiniteFieldPolynomialFactorizer new polynomial: self polynomial; factors)
		do: [:each|
			each degree = 1
				ifTrue: [roots add: each independentCoefficient negated / each leadingCoefficient]].
	^ roots! !

!NumericComplexRootFinder methodsFor: 'private' stamp: 'len 1/13/2016 03:01'!
initialValue
	^ 1.3 + 0.314159 i! !

!NumericComplexRootFinder methodsFor: 'initialization' stamp: 'len 1/15/2016 06:09'!
initialize
	super initialize.
	tolerance _ 0.1! !

!NumericComplexRootFinder methodsFor: 'accessing' stamp: 'len 1/13/2016 05:37'!
rootNear: aComplex
"	[self roots do: [:each| (each approximation - aComplex) abs < epsilon ifTrue: [^ each]].
	self roots do: [:each| each refine]] repeat"
	^ self roots detectMin: [:each| (each approximation - aComplex) abs]! !

!NumericComplexRootFinder methodsFor: 'private' stamp: 'len 6/5/2016 05:19'!
roots
	| roots X P Q P` Q` n x v m c dx x1 v1 m1 realCoefficients |
	X _ polynomial species x.
	P _ polynomial.
	Q _ P.
	P` _ P derivative.
	Q` _ P`.
	n _ P degree.
	roots _ OrderedCollection new: n.
	realCoefficients _ P coefficients allSatisfy: [:each| (each isKindOf: Number) or: [each imaginary isZero]].
	["Initialize root finding:"
	x _ self initialValue.
	v _ Q value: x.
	m _ v norm2.
	"Initialize recursion:"
	c _ 0. dx _ v / (Q` value: x).
	[dx abs < tolerance]
		whileFalse:
			[x1 _ x - dx.
			v1 _ Q value: x1.
			m1 _ v1 norm2.
			m1 < m
				ifTrue: [x _ x1. v _ v1. m _ m1. c _ 0. dx _ v / (Q` value: x)]
				ifFalse: [c _ c + 1. dx _ dx / 4. c > 20 ifTrue: [self error: 'failed']]].
	"Polish root:"
	2 timesRepeat: [x _ x - ((P value: x) / (P` value: x))].
	"Divide:"
	((realCoefficients not or: [n = 1]) or: [x imaginary abs < tolerance "###"])
		ifTrue: "found one root"
			[x imaginary abs < tolerance ifTrue: [x _ x real]. "###"
			roots add: (AlgebraicNumber polynomial: P approximation: x radius: tolerance).
			Q _ Q // (X - x).
			Q` _ Q derivative. "###"
			n _ n - 1]
		ifFalse: "found a root and (if the root is not real) also found its conjugate"
			[roots
				add: (AlgebraicNumber polynomial: P approximation: x radius: tolerance);
				add: (AlgebraicNumber polynomial: P approximation: x conjugated radius: tolerance).
			Q _ Q // (X**2 - (X * (x real * 2)) + x abs squared).
			Q` _ Q derivative. "###"
			n _ n - 2].
	n > 0] whileTrue.
	^ roots! !

!NumericComplexRootFinder methodsFor: 'accessing' stamp: 'len 1/15/2016 05:57'!
tolerance
	^ tolerance! !

!NumericComplexRootFinder methodsFor: 'accessing' stamp: 'len 1/15/2016 05:53'!
tolerance: aNumber
	tolerance _ aNumber! !

!NumericComplexRootFinder class methodsFor: 'instance creation' stamp: 'len 1/17/2016 01:40'!
polynomial: aPolynomial
	^ self squareFreePolynomial: aPolynomial // (aPolynomial gcd: aPolynomial derivative)! !

!NumericComplexRootFinder class methodsFor: 'instance creation' stamp: 'len 1/17/2016 01:41'!
squareFreePolynomial: aPolynomial
	^ super polynomial: aPolynomial! !

!RationalRootFinder methodsFor: 'private' stamp: 'len 6/28/2016 19:20'!
multiplicityAt: aRoot fourier: fourier
	| count |
	count _ 0.
	fourier do: [:each| (each value: aRoot) isZero ifFalse: [^ count]. count _ count + 1].
	[fourier last isConstant]
		whileFalse:
			[((fourier add: fourier last derivative) value: aRoot) isZero ifFalse: [^ count]. count _ count + 1].
	^ count! !

!RationalRootFinder methodsFor: 'accessing' stamp: 'len 6/28/2016 19:23'!
roots
	"Separate the (real) rational roots of the polynomial."
	| roots f n k tau visited fourier |
	roots _ Bag new.
	f _ self polynomial integerPrimitive.
	n _ f degree.
	(k _ f lowestDegree) > 0 ifTrue: [roots add: 0 withOccurrences: k. f _ f shift: k negated].
	f isConstant ifTrue: [^ roots].
	visited _ Set2 new.
	fourier _ OrderedCollection with: f.
	f independentCoefficient divisorsDo: [:each|
		f leadingCoefficient divisorsDo: [:one|
			tau _ each / one.
			visited add: tau ifAbsent:
					[(f value: tau) isZero
						ifTrue: [roots add: tau withOccurrences: (self multiplicityAt: tau fourier: fourier). roots size = n ifTrue: [^ roots]].
					tau _ tau negated.
					(f value: tau) isZero
						ifTrue: [roots add: tau withOccurrences: (self multiplicityAt: tau fourier: fourier). roots size = n ifTrue: [^ roots]]]]].
	^ roots! !

!RealRootFinder methodsFor: 'private' stamp: 'len 6/5/2016 05:57'!
bigBounds
	"Compute and answer a first estimate of an interval containing all the real roots."
	| bound |
	bound _ squareFreePolynomial norm1 / squareFreePolynomial leadingCoefficient.
	bound _ bound max: 1.
"	bound _ DyadicFraction fromInteger: bound."
	^ RealInterval closed: bound negated closed: bound! !

!RealRootFinder methodsFor: 'private' stamp: 'len 6/5/2016 05:57'!
computeFourier
	"Compute the Budan-Fourier sequence for the polynomial of the receiver."
	| f |
	f _ squareFreePolynomial.
	fourier _ (OrderedCollection new: f degree + 1) add: f; yourself.
	f degree timesRepeat: [fourier add: (f _ f derivative)]! !

!RealRootFinder methodsFor: 'private' stamp: 'len 6/5/2016 05:57'!
computeSturm
	"Compute a sturmian sequence for the receiver."
	| f g r |
	f _ squareFreePolynomial.
	g _ f derivative.
	sturm _ (OrderedCollection new: f degree + 1) add: f; add: g; yourself.
	[g degree > 0]
		whileTrue:
			[r _ sturm add: (f \\ g) negated.
			f _ g.
			g _ r]! !

!RealRootFinder methodsFor: 'accessing' stamp: 'len 11/18/97 00:38'!
fourier
	"Answer the Budan-Fourier sequence for the polynomial of the receiver."

	fourier isNil ifTrue: [self computeFourier].
	^ fourier! !

!RealRootFinder methodsFor: 'private' stamp: 'len 6/5/2016 05:57'!
heuristicDetectOneRootBetween: leftBound and: rightBound
	| first |
	first _ squareFreePolynomial value: leftBound.
	2 to: 10 do: [:each|
		first ~= (squareFreePolynomial value: (rightBound - leftBound) / each) sign
			ifTrue: [^ true]].
	^ false! !

!RealRootFinder methodsFor: 'couting roots' stamp: 'len 6/5/2016 06:00'!
lowerBoundNumberOfRootsBetween: leftBound and: rightBound
	"Answer a lower bound for the number of real roots in the open interval (leftBound, rightBound)."
	| answer last sign |
	answer _ 0.
	last _ 0.
	1 to: squareFreePolynomial degree * 2 do: [:each|
		sign _ (squareFreePolynomial value: (rightBound - leftBound) / each) sign.
		(last ~= sign and: [sign ~= 0]) ifTrue: [answer _ answer + 1].
		last _ sign].
	^ answer! !

!RealRootFinder methodsFor: 'couting roots' stamp: 'len 1/16/2016 08:33'!
moreThanOneRootBetween: leftBound and: rightBound
	"Answer true if there are only one root in the interval (leftBound, rightBound]."

	| upper lower |
	sturm isNil "if the Sturm chain was not yet computed, first try some bounds and heuristics"
		ifTrue:
			[(upper _ self upperBoundNumberOfRootsBetween: leftBound and: rightBound) < 2
				ifTrue: [^ false].
			(upper even and: [self heuristicDetectOneRootBetween: leftBound and: rightBound])
				ifTrue: [^ true].
			lower _ self lowerBoundNumberOfRootsBetween: leftBound and: rightBound.
			lower > 1 ifTrue: [^ true].
			(upper even and: [lower > 0]) ifTrue: [^ true]].

	^ (self numberOfRootsBetween: leftBound and: rightBound) > 1! !

!RealRootFinder methodsFor: 'couting roots' stamp: 'len 6/5/2016 06:00'!
numberOfNegativeRoots
	"Answer the number of negative roots."
	| fix |
	fix _ (squareFreePolynomial value: 0) = 0 ifTrue: [1] ifFalse: [0].
	^ (self numberOfRootsBetween: self bigBounds min and: 0) - fix! !

!RealRootFinder methodsFor: 'couting roots' stamp: 'len 1/15/2016 02:41'!
numberOfPositiveRoots
	"Answer the number of positive roots."
	^ self numberOfRootsBetween: 0 and: self bigBounds max! !

!RealRootFinder methodsFor: 'couting roots' stamp: 'len 1/15/2016 02:41'!
numberOfRoots
	"Answer the number of real roots of the receiver."

	| interval |
	interval _ self bigBounds.
	^ self numberOfRootsBetween: interval min and: interval max! !

!RealRootFinder methodsFor: 'couting roots' stamp: 'len 1/16/2016 08:03'!
numberOfRootsBetween: leftBound and: rightBound
	"Answer the number of real roots in the left open interval (leftBound, rightBound]."

	| leftSignChanges rightSignChanges a b |
	a _ leftBound asFraction.
	b _ rightBound asFraction.
	leftSignChanges _ 0.
	(self sturm collect: [ :each | (each value: a) sign])
		inject: 0 into: [ :lastSign :each |
			(lastSign ~= each and: [each ~= 0])
				ifTrue: [leftSignChanges _ leftSignChanges + 1].
			each].

	rightSignChanges _ 0.
	(self sturm collect: [ :each | (each value: b) sign])
		inject: 0 into: [ :lastSign :each |
			(lastSign ~= each and: [each ~= 0])
				ifTrue: [rightSignChanges _ rightSignChanges + 1].
			each].

	^ leftSignChanges - rightSignChanges! !

!RealRootFinder methodsFor: 'initialization' stamp: 'len 6/5/2016 05:04'!
polynomial: aPolynomial
	polynomial _ aPolynomial.
	self flag: #fix. "this could be exact division, also doing the same in class side via #reduced"
	squareFreePolynomial _ (aPolynomial // (aPolynomial gcd: aPolynomial derivative)) integerPrimitive! !

!RealRootFinder methodsFor: 'accessing' stamp: 'len 6/5/2016 04:47'!
roots
	"Answer a collection with the roots of the polynomial."
	roots isNil ifTrue: [self separateRoots].
	^ roots! !

!RealRootFinder methodsFor: 'operations' stamp: 'len 6/5/2016 04:47'!
separateRoots
	"Separate the roots in intervals each of them including an isolated root."

	| bounds |
	roots _ SortedCollection sortBlock: [ :one :other | one leftBound <= other leftBound].
	bounds _ self bigBounds.
	self separateRootsBetween: bounds min and: bounds max! !

!RealRootFinder methodsFor: 'operations' stamp: 'len 6/5/2016 05:59'!
separateRootsBetween: leftBound and: rightBound
	"Separate the roots in the real interval given by the arguments."
	| r mid |
	(r _ self numberOfRootsBetween: leftBound and: rightBound) = 0
		ifTrue: [^ self].

	r = 1 ifTrue:
		[roots add:
			(RealAlgebraicNumber
				polynomial: squareFreePolynomial
				bounds: (RealInterval closed: leftBound closed: rightBound)).
		^ self].

	mid _ leftBound + rightBound / 2.
	self separateRootsBetween: leftBound and: mid.
	self separateRootsBetween: mid and: rightBound! !

!RealRootFinder methodsFor: 'initialization' stamp: 'len 6/5/2016 04:46'!
squareFreePolynomial: aPolynomial
	polynomial _ aPolynomial.
	squareFreePolynomial _ aPolynomial! !

!RealRootFinder methodsFor: 'accessing' stamp: 'len 8/23/97 18:10'!
sturm
	"Answer a sturm sequence for the polynomial of the receiver."

	sturm isNil ifTrue: [self computeSturm].
	^ sturm! !

!RealRootFinder methodsFor: 'couting roots' stamp: 'len 1/15/2016 02:42'!
upperBoundNumberOfRoots
	"Answer an upper bound for the number of real roots of the receiver."
	| interval |
	interval _ self bigBounds.
	^ self upperBoundNumberOfRootsBetween: interval min and: interval max! !

!RealRootFinder methodsFor: 'couting roots' stamp: 'len 11/24/2015 06:10'!
upperBoundNumberOfRootsBetween: leftBound and: rightBound
	"Answer an upper bound for the number of real roots
	in the open interval (leftBound, rightBound)."

	| leftSignChanges rightSignChanges |

	leftSignChanges _ 0.
	(self fourier collect: [ :each | (each value: leftBound) sign])
		inject: 0 into: [ :lastSign :each |
			(lastSign ~= each and: [each ~= 0])
				ifTrue: [leftSignChanges _ leftSignChanges + 1].
			each].

	rightSignChanges _ 0.
	(self fourier collect: [ :each | (each value: rightBound) sign])
		inject: 0 into: [ :lastSign :each |
			(lastSign ~= each and: [each ~= 0])
				ifTrue: [rightSignChanges _ rightSignChanges + 1].
			each].

	^ leftSignChanges - rightSignChanges! !

!RealRootFinder class methodsFor: 'instance creation' stamp: 'len 7/8/2016 23:45'!
polynomial: aPolynomial
	^ self squareFreePolynomial: aPolynomial squareFree! !

!RealRootFinder class methodsFor: 'instance creation' stamp: 'len 6/5/2016 04:58'!
squareFreePolynomial: aPolynomial
	^ self new squareFreePolynomial: aPolynomial! !

!AlgebraicNumber methodsFor: 'arithmetic' stamp: 'len 6/5/2016 20:58'!
* aNumber
	| roots |
	aNumber class = self class
		ifFalse: [^ aNumber adaptToAlgebraic: self andSend: #*].
	aNumber isZero ifTrue: [^ aNumber].
	self isZero ifTrue: [^ self].
	roots _ (ComplexRootFinder polynomial: (self polynomial zeroProduct: aNumber polynomial)) roots.
	[roots _ roots select: [:each| each bounds includes: self approximation * aNumber approximation].
	roots size = 1]
		whileFalse:
			[roots do: [:each| self refineWith: each].
			self refineWith: aNumber].
	^ roots anyOne! !

!AlgebraicNumber methodsFor: 'arithmetic' stamp: 'len 6/5/2016 20:41'!
+ aNumber
	| f disk |
	aNumber class = self class
		ifFalse: [^ aNumber adaptToAlgebraic: self andSend: #+].
	aNumber isZero ifTrue: [^ self].
	self isZero ifTrue: [^ aNumber].
	f _ ComplexRootFinder polynomial:
		(self polynomial zeroAddition: aNumber polynomial).
	[disk _ self bounds + aNumber bounds.
	f moreThanOneRootIn: disk]
		whileTrue:
			[self refineWith: aNumber].
	^ self class polynomial: f polynomial bounds: disk! !

!AlgebraicNumber methodsFor: 'arithmetic' stamp: 'len 1/12/2016 03:38'!
- anObject
	^ self + anObject negated! !

!AlgebraicNumber methodsFor: 'arithmetic' stamp: 'len 1/12/2016 03:38'!
/ anObject
	^ self * anObject reciprocal! !

!AlgebraicNumber methodsFor: 'comparing' stamp: 'len 6/4/2016 22:32'!
= anObject
	self == anObject ifTrue: [^ true].
	anObject isNumber ifFalse: [^ false].
	anObject class = self class
		ifFalse: [^ anObject adaptToAlgebraic: self andSend: #=].
	(self bounds intersects: anObject bounds) ifFalse: [^ false].
	(self polynomial gcd: anObject polynomial) isConstant
		ifTrue: [^ false].
	^ (self - anObject) isZero! !

!AlgebraicNumber methodsFor: 'approximating' stamp: 'len 6/5/2016 19:35'!
absoluteError
	^ radius! !

!AlgebraicNumber methodsFor: 'converting' stamp: 'len 1/13/2016 03:41'!
adaptToFloat: rcvr andSend: selector
	^ rcvr perform: selector with: self asFloat! !

!AlgebraicNumber methodsFor: 'converting' stamp: 'len 1/13/2016 03:42'!
adaptToFraction: rcvr andSend: selector
	^ (self class fromRational: rcvr) perform: selector with: self! !

!AlgebraicNumber methodsFor: 'converting' stamp: 'len 1/13/2016 03:42'!
adaptToInteger: rcvr andSend: selector
	^ (self class fromRational: rcvr) perform: selector with: self! !

!AlgebraicNumber methodsFor: 'approximating' stamp: 'len 6/4/2016 21:20'!
approximation
	"Answre a rational or float current approximation of the receiver."
	^ approximation "bounds midpoint"! !

!AlgebraicNumber methodsFor: 'accessing-private' stamp: 'len 1/15/2016 02:07'!
approximation: aNumber radius: anotherNumber
	approximation _ aNumber.
	radius _ anotherNumber! !

!AlgebraicNumber methodsFor: 'converting' stamp: 'len 1/13/2016 03:59'!
asComplexFloat
	"Answer a Float approximation of the receiver."
	self refineTo: 0.000001.
	^ approximation asFloat! !

!AlgebraicNumber methodsFor: 'converting' stamp: 'len 6/4/2016 22:16'!
asFloat
	"Answer a Float approximation of the receiver."
	self refineTo: 0.000001.
	^ self approximation asFloat! !

!AlgebraicNumber methodsFor: 'converting' stamp: 'len 3/21/2016 22:51'!
asRational
	"Convert the receiver to Fraction or Integer."
	| alpha |
	radius = 0 ifTrue: [^ approximation]. "could be float!!"
	polynomial degree < 2
		ifTrue:
			[alpha _ polynomial independentCoefficient negated / polynomial leadingCoefficient.
			approximation _ alpha. radius _ 0.
			^ alpha].
	(RationalRootFinder polynomial: polynomial)
		roots do: [:each| 
			(each - approximation) abs < radius
				ifTrue: [approximation _ each. radius _ 0. ^ each]].
	self error: 'the number is irrational'! !

!AlgebraicNumber methodsFor: 'approximating' stamp: 'len 6/5/2016 20:59'!
bounds
	"Answer a disk in the complex plane where the receiver is located, isolated from all other roots of its minimal polynomial."
	^ ComplexDisk center: approximation radius: radius! !

!AlgebraicNumber methodsFor: 'accessing' stamp: 'len 1/13/2016 05:40'!
conjugates
	"The conjugates of an algebraic number with minimal polynomial of degree n are all its n-th roots."
	^ self notYetImplemented! !

!AlgebraicNumber methodsFor: 'accessing' stamp: 'len 5/27/2016 02:03'!
denominator
	"The denominator of an algebraic number is the smallest positive integer that multiplied by the algebraic number is an algebraic integer."
	^ self minimalPolynomial coefficients inject: 1 into: [:denominator :each| denominator lcm: each denominator]! !

!AlgebraicNumber methodsFor: 'comparing' stamp: 'len 1/17/2016 02:05'!
hash
	^ self truncated hash! !

!AlgebraicNumber methodsFor: 'arithmetic' stamp: 'len 1/13/2016 04:01'!
i
	^ self * self class i! !

!AlgebraicNumber methodsFor: 'testing' stamp: 'len 1/13/2016 03:33'!
isAlgebraic
	^ true! !

!AlgebraicNumber methodsFor: 'testing' stamp: 'len 5/27/2016 02:06'!
isAlgebraicInteger
	"An algebraic number is an 'algebraic integer' if it's the root of a monic polynomial in Z[x], in particular if it's minimal polynomial has integer coefficients."
	^ self minimalPolynomial coefficients allSatisfy: [:each| each isInteger]! !

!AlgebraicNumber methodsFor: 'testing' stamp: 'len 1/13/2016 03:33'!
isNumber
	^ true! !

!AlgebraicNumber methodsFor: 'testing' stamp: 'len 1/15/2016 02:08'!
isRational
	polynomial degree < 2 ifTrue: [^ true].
	radius = 0 ifTrue: [^ true].
	(RationalRootFinder polynomial: self polynomial)
		roots do: [:each|
			(each - approximation) abs < radius
				ifTrue: [approximation _ each. radius _ 0. ^ true]].
	^ false! !

!AlgebraicNumber methodsFor: 'testing' stamp: 'len 1/15/2016 02:08'!
isZero
	^ approximation abs < radius and: [(polynomial value: 0) = 0]! !

!AlgebraicNumber methodsFor: 'accessing' stamp: 'len 6/4/2016 22:10'!
minimalPolynomial
	irreducible ifTrue: [^ polynomial].
	polynomial _ polynomial factors asSet detect: [:one| (one value: self) isZero].
	irreducible _ true.
	^ polynomial! !

!AlgebraicNumber methodsFor: 'accessing-private' stamp: 'len 1/12/2016 03:59'!
minimalPolynomial: aPolynomial
	polynomial _ aPolynomial.
	irreducible _ true! !

!AlgebraicNumber methodsFor: 'arithmetic' stamp: 'len 6/4/2016 22:33'!
negated
	"Answer the additive inverse of the receiver."
	^ self class
		polynomial: polynomial zeroNegation
		irreducible: irreducible
		approximation: self approximation negated
		radius: self radius! !

!AlgebraicNumber methodsFor: 'operations' stamp: 'len 1/10/2016 20:46'!
norm
	^ self conjugates product! !

!AlgebraicNumber methodsFor: 'constants' stamp: 'len 6/4/2016 21:18'!
one
	^ 1! !

!AlgebraicNumber methodsFor: 'accessing' stamp: 'len 1/12/2016 04:00'!
polynomial
	^ polynomial! !

!AlgebraicNumber methodsFor: 'accessing-private' stamp: 'len 1/12/2016 04:00'!
polynomial: aPolynomial
	polynomial _ aPolynomial.
	irreducible _ false! !

!AlgebraicNumber methodsFor: 'printing' stamp: 'len 1/11/2016 06:44'!
printOn: aStream
	self printOn: aStream base: 10! !

!AlgebraicNumber methodsFor: 'printing' stamp: 'len 6/4/2016 22:19'!
printOn: aStream base: base
	| real imaginary |
	self refineTo: self printPrecision.
	self approximation isComplex
		ifFalse: [(self approximation roundTo: self printPrecision) printOn: aStream base: base. aStream nextPutAll: '..'. ^ self].
	self approximation real isZero
		ifTrue: [(self approximation imaginary roundTo: self printPrecision) printOn: aStream base: base. aStream nextPutAll: 'i..'. ^ self].
	real _ self approximation real asFloat roundTo: self printPrecision.
	imaginary _ self approximation imaginary asFloat roundTo: self printPrecision.
	real printOn: aStream base: base.
	aStream nextPutAll: (0 <= imaginary ifTrue: [' + '] ifFalse: [' - ']).
	imaginary abs printOn: aStream base: base.
	aStream nextPutAll: 'i..'! !

!AlgebraicNumber methodsFor: 'printing' stamp: 'len 1/13/2016 01:09'!
printPrecision
	^ 0.00001! !

!AlgebraicNumber methodsFor: 'arithmetic' stamp: 'len 6/5/2016 21:00'!
reciprocal
	"Answer the multiplicative inverse of the receiver."
	self isZero ifTrue: [^ ZeroDivide signal].
	^ self class
		polynomial: polynomial zeroReciprocal
		irreducible: irreducible
		bounds: self bounds reciprocal! !

!AlgebraicNumber methodsFor: 'approximating' stamp: 'len 6/5/2016 23:02'!
refine
	| P Q P` Q` m x v c dx y v1 m1 |
	radius _ radius / 2.
	P _ polynomial.
	Q _ P.
	P` _ P derivative.
	Q` _ P`.
	x _ approximation.
	v _ Q value: x.
	m _ v norm2.
	c _ 0. dx _ v / (Q` value: x).
	[dx abs >= radius]
		whileTrue:
			[y _ x - dx.
			v1 _ Q value: y.
			m1 _ v1 norm2.
			m1 < m
				ifTrue: [x _ y. v _ v1. m _ m1. c _ 0. dx _ v / (Q` value: x)]
				ifFalse: [c _ c + 1. dx _ dx / 4. c > 20 ifTrue: [self error: 'failed']]].
	"Polish root:"
	2 timesRepeat: [x _ x - ((P value: x) / (P` value: x))].
	approximation _ x! !

!AlgebraicNumber methodsFor: 'approximating' stamp: 'len 6/5/2016 23:05'!
refineTo: aNumber
	"Refine the receiver up to get an approximation error < aNumber."
	[self absoluteError >= aNumber] whileTrue: [self refine]! !

!AlgebraicNumber methodsFor: 'approximating' stamp: 'len 6/5/2016 19:26'!
refineWith: aRealAlgebraicNumber
	"Refine the rational interval approximation of either the receiver or the argument, depending on which is less precise at the moment."
	self relativeError > aRealAlgebraicNumber relativeError
		ifTrue: [self refine]
		ifFalse: [aRealAlgebraicNumber refine]! !

!AlgebraicNumber methodsFor: 'approximating' stamp: 'len 6/4/2016 23:10'!
relativeError
	"Answer the relative error in the current rational approximation."
	self isZero ifTrue: [^ 0].
	^ self absoluteError / self approximation norm2 "this should be norm or abs, but then it would be float"! !

!AlgebraicNumber methodsFor: 'arithmetic' stamp: 'len 1/13/2016 04:02'!
squared
	^ self * self! !

!AlgebraicNumber methodsFor: 'operations' stamp: 'len 1/10/2016 20:46'!
trace
	^ self conjugates sum! !

!AlgebraicNumber methodsFor: 'constants' stamp: 'len 6/4/2016 21:18'!
zero
	^ 0! !

!AlgebraicNumber class methodsFor: 'instance creation' stamp: 'len 1/15/2016 02:04'!
approximation: approximateValue radius: approximationError maxDegree: n
	"Answer an algebraic number with the given approximate value, approximation error, with minimal polynomial of degree at most n."
	^ self notYetImplemented! !

!AlgebraicNumber class methodsFor: 'instance creation' stamp: 'len 7/15/2016 18:30'!
fromRational: anIntegerOrFraction
	"Answer an instance of the receiver representing the rational number anIntegerOrFraction."
	| q x |
	q _ anIntegerOrFraction asFraction.
	x _ QQ polynomials x.
	^ self
		minimalPolynomial: x * q denominator - q numerator
 		approximation: anIntegerOrFraction
		radius: 0! !

!AlgebraicNumber class methodsFor: 'examples' stamp: 'len 7/15/2016 18:30'!
i
	| x |
	x _ QQ polynomials x.
	^ self minimalPolynomial: x**2 - 1 approximation: 1 i radius: 0! !

!AlgebraicNumber class methodsFor: 'instance creation' stamp: 'len 1/15/2016 02:05'!
minimalPolynomial: aPolynomial approximation: aComplex radius: aNumber
	^ self new
		minimalPolynomial: aPolynomial;
		approximation: aComplex radius: aNumber! !

!AlgebraicNumber class methodsFor: 'examples' stamp: 'len 7/15/2016 18:31'!
phi
	"Answer the Phidias number or Golden Ratio."
	| x |
	x _ QQ polynomials x.
	^ self minimalPolynomial: (x**2 - x - 1) approximation: 2.0 radius: 1! !

!AlgebraicNumber class methodsFor: 'instance creation' stamp: 'len 1/15/2016 02:04'!
polynomial: aPolynomial approximation: aComplex radius: aNumber
	^ self new
		polynomial: aPolynomial;
		approximation: aComplex radius: aNumber! !

!AlgebraicNumber class methodsFor: 'instance creation' stamp: 'len 6/4/2016 22:34'!
polynomial: aPolynomial irreducible: aBoolean approximation: aComplex radius: aNumber
	^ self new
		polynomial: aPolynomial;
		irreducible: aBoolean;
		approximation: aComplex radius: aNumber! !

!AlgebraicNumber class methodsFor: 'examples' stamp: 'len 7/15/2016 18:31'!
sqrt2
	"Answer an instance of the receiver representing the square root of 2."

	^ self
		minimalPolynomial: QQ polynomials x squared - 2
 		approximation: 1.5
		radius: 0.1! !

!AlgebraicNumber class methodsFor: 'examples' stamp: 'len 7/15/2016 18:31'!
sqrt: anIntegerOrFraction
	"Answer a square root of the rational argument."
	^ self
		minimalPolynomial: QQ polynomials x squared - anIntegerOrFraction
 		approximation: anIntegerOrFraction sqrt radius: 0.00001! !

!DirichletSeries methodsFor: 'arithmetic' stamp: 'len 12/28/2015 19:28'!
* anObject
	(self scalars includes: anObject)
		ifTrue: [^ self class coefficients: coefficients * anObject].
	(anObject isKindOf: self class)
		ifTrue: [^ self class coefficients: (coefficients dirichlet: anObject coefficients)].
	^ DomainError signal! !

!DirichletSeries methodsFor: 'arithmetic' stamp: 'len 12/28/2015 19:29'!
+ anObject
	^ self class coefficients: coefficients + anObject coefficients! !

!DirichletSeries methodsFor: 'arithmetic' stamp: 'len 12/28/2015 19:29'!
- anObject
	^ self + anObject negated! !

!DirichletSeries methodsFor: 'arithmetic' stamp: 'len 12/28/2015 19:30'!
/ anObject
	^ self * anObject reciprocal! !

!DirichletSeries methodsFor: 'comparing' stamp: 'len 12/28/2015 19:46'!
= anObject
	^ (anObject isKindOf: DirichletSeries) and: [self coefficients = anObject coefficients]! !

!DirichletSeries methodsFor: 'accessing' stamp: 'len 12/28/2015 19:26'!
coefficients
	^ coefficients! !

!DirichletSeries methodsFor: 'accessing' stamp: 'len 12/28/2015 19:26'!
coefficients: aSequence
	coefficients _ aSequence! !

!DirichletSeries methodsFor: 'comparing' stamp: 'len 12/28/2015 19:46'!
hash
	^ coefficients hash! !

!DirichletSeries methodsFor: 'accessing' stamp: 'len 12/28/2015 19:26'!
indeterminate
	^ 1! !

!DirichletSeries methodsFor: 'arithmetic' stamp: 'len 12/28/2015 19:30'!
negated
	^ self class coefficients: coefficients negated! !

!DirichletSeries methodsFor: 'printing' stamp: 'len 12/28/2015 21:44'!
printOn: aStream
	| c n first |
	first _ true.
	(coefficients startIndex to: coefficients printLimit) do: [:i|
		c _ (coefficients at: i).
		c isZero
			ifFalse:
				[n _ i - coefficients startIndex + 1.
				c printString first = $-
					ifTrue: [first ifFalse: [aStream nextPutAll: ' - '].
								c _ c negated]
					ifFalse: [first ifFalse: [aStream nextPutAll: ' + ']].
				c printOn: aStream. first _ false.
				n > 1 ifTrue: [aStream nextPutAll: '/('; print: n; nextPutAll: '^x)']]].
	aStream nextPutAll: ' + ...'! !

!DirichletSeries methodsFor: 'accessing' stamp: 'len 12/28/2015 19:26'!
scalars
	^ coefficients codomain! !

!DirichletSeries methodsFor: 'arithmetic' stamp: 'len 12/28/2015 19:30'!
squared
	^ self * self! !

!DirichletSeries class methodsFor: 'instance creation' stamp: 'len 12/28/2015 19:54'!
coefficients: aSequence
	^ self new coefficients: aSequence! !

!DirichletSeries class methodsFor: 'examples' stamp: 'len 12/28/2015 21:30'!
zeta
	^ self coefficients: (LinearRecursiveSequence constant: 1)! !

!PowerSeries methodsFor: 'arithmetic' stamp: 'len 12/27/2015 16:11'!
* anObject
	(self scalars includes: anObject)
		ifTrue: [^ self class coefficients: coefficients * anObject].
	(anObject isKindOf: self class)
		ifTrue: [^ self class coefficients: (coefficients convolution: anObject coefficients)].
	(anObject isKindOf: Polynomial)
		ifTrue: [^ self * (self class fromPolynomial: anObject)].
	^ DomainError signal! !

!PowerSeries methodsFor: 'arithmetic' stamp: 'len 7/8/2016 05:40'!
** anInteger
	"Answer the receiver raised to the power anInteger."
	anInteger = 1 ifTrue: [^ self].
	anInteger = 0 ifTrue: [^ self one].
	anInteger < 0 ifTrue: [^ (self ** anInteger negated) reciprocal].
	^ self squared ** (anInteger // 2) * (self ** (anInteger \\ 2))! !

!PowerSeries methodsFor: 'arithmetic' stamp: 'len 12/30/2015 05:45'!
+ anObject
	(self scalars includes: anObject)
		ifTrue: [^ self class coefficients: coefficients + (LinearRecursiveSequence to: self scalars initialValues: {anObject} periodic: {anObject zero})].
	(anObject isKindOf: self class)
		ifTrue: [^ self class coefficients: coefficients + anObject coefficients].
	(anObject isKindOf: Polynomial)
		ifTrue: [^ self + (self class fromPolynomial: anObject)].
	^ DomainError signal! !

!PowerSeries methodsFor: 'arithmetic' stamp: 'len 12/27/2015 16:12'!
- anObject
	^ self + anObject negated! !

!PowerSeries methodsFor: 'arithmetic' stamp: 'len 12/27/2015 16:13'!
/ anObject
	^ self * anObject reciprocal! !

!PowerSeries methodsFor: 'comparing' stamp: 'len 12/28/2015 19:46'!
= anObject
	^ (anObject isKindOf: PowerSeries) and: [self coefficients = anObject coefficients]! !

!PowerSeries methodsFor: 'converting' stamp: 'len 12/27/2015 19:09'!
asRationalFunction
	^ coefficients generatingFunction! !

!PowerSeries methodsFor: 'accessing' stamp: 'len 12/27/2015 15:45'!
coefficients
	^ coefficients! !

!PowerSeries methodsFor: 'accessing' stamp: 'len 12/27/2015 15:46'!
coefficients: aSequence
	coefficients _ aSequence! !

!PowerSeries methodsFor: 'operations' stamp: 'len 12/27/2015 19:44'!
derivative
	^ self class coefficients: coefficients << 1 * LinearRecursiveSequence identity! !

!PowerSeries methodsFor: 'iterating' stamp: 'len 3/1/2016 22:14'!
do: aBlock
	self flag: #fix. "deprecated"
	self terms do: aBlock! !

!PowerSeries methodsFor: 'comparing' stamp: 'len 12/28/2015 19:45'!
hash
	^ coefficients hash! !

!PowerSeries methodsFor: 'accessing' stamp: 'len 12/27/2015 15:45'!
indeterminate
	^ 1! !

!PowerSeries methodsFor: 'arithmetic' stamp: 'len 12/28/2015 05:47'!
inverse
	| b1 a |
	a _ coefficients.
	b1 _ (a at: 1) reciprocal.
	^ self class coefficients:
		(Sequence
			to: self scalars
			recurrence:
				[:b :n|
				n=1
					ifTrue: [b1]
					ifFalse: [b1 negated * ((2 to: n) sum: [:i| (a at: i+1) * (b at: n-i+1)])]])! !

!PowerSeries methodsFor: 'testing' stamp: 'len 6/30/2016 04:01'!
isInvertible
	^ self scalars isUnit: (coefficients at: 1)! !

!PowerSeries methodsFor: 'testing' stamp: 'len 4/11/2016 23:09'!
isZero
	^ coefficients isZero! !

!PowerSeries methodsFor: 'arithmetic' stamp: 'len 12/27/2015 16:14'!
negated
	^ self class coefficients: coefficients negated! !

!PowerSeries methodsFor: 'printing' stamp: 'len 7/7/2016 08:00'!
printOn: aStream
	| P f n |
	n _ coefficients printLimit.
	P _ coefficients codomain polynomials.
	f _ P coefficients: (coefficients copyFrom: coefficients startIndex to: coefficients startIndex + n) :: orderedBy: #revlex.
	aStream print: f; nextPutAll: ' + O('; print: P x ** (n+1); nextPut: $)! !

!PowerSeries methodsFor: 'arithmetic' stamp: 'len 12/28/2015 05:48'!
reciprocal
	| b1 a |
	self flag: #fix. "this is composition inverse?"
	a _ coefficients.
	b1 _ (a at: 1) reciprocal.
	^ self class coefficients:
		(Sequence
			to: self scalars
			recurrence:
				[:b :n|
				n=1
					ifTrue: [b1]
					ifFalse: [b1 negated * ((2 to: n) sum: [:i| (a at: i+1) * (b at: n-i+1)])]])! !

!PowerSeries methodsFor: 'accessing' stamp: 'len 12/28/2015 04:12'!
scalars
	^ coefficients codomain! !

!PowerSeries methodsFor: 'arithmetic' stamp: 'len 12/27/2015 16:14'!
squared
	^ self * self! !

!PowerSeries methodsFor: 'accessing' stamp: 'len 3/1/2016 22:14'!
terms
	| P |
	P _ self scalars polynomials.
	^ Sequence evaluating: [:i| P coefficient: (coefficients at: i) degree: i-1]! !

!PowerSeries methodsFor: 'operations' stamp: 'len 2/29/2016 04:58'!
value: anObject upTo: n
	| answer |
	answer _ anObject zero.
	self terms do: [:each| each degree > n ifTrue: [^ answer]. answer _ answer + (each value: anObject)].
	^ answer! !

!PowerSeries class methodsFor: 'instance creation' stamp: 'len 12/27/2015 16:21'!
coefficients: aSequence
	^ self new coefficients: aSequence! !

!PowerSeries class methodsFor: 'examples' stamp: 'len 7/15/2016 18:36'!
cos
	^ self coefficients: (Sequence to: QQ evaluating: [:n| n even ifTrue: [0] ifFalse: [|k| k _ n-1/2. (-1)**k / (2*k) factorial]])! !

!PowerSeries class methodsFor: 'examples' stamp: 'len 7/15/2016 18:36'!
exp
	^ self coefficients: (Sequence to: QQ evaluating: [:n| 1 / n factorial])! !

!PowerSeries class methodsFor: 'instance creation' stamp: 'len 3/30/2016 03:58'!
fromPolynomial: aPolynomial
	^ self coefficients: (LinearRecursiveSequence to: aPolynomial scalars initialValues: aPolynomial denseCoefficients periodic: {aPolynomial scalars zero})! !

!PowerSeries class methodsFor: 'examples' stamp: 'len 7/15/2016 18:36'!
sin
	^ self coefficients: (Sequence to: QQ evaluating: [:n| n odd ifTrue: [0] ifFalse: [|k| k _ n/2-1. (-1)**k / (2*k+1) factorial]])! !

!PowerSeries class methodsFor: 'examples' stamp: 'len 7/30/2016 07:19'!
taylorSeriesOf: aFunction at: x0
	| f n |
	f _ aFunction.
	n _ 0.
	^ self coefficients:
		(Sequence
			to: aFunction codomain
			streamming:
				[| value |
				value _ (f value: x0) / n factorial.
				f _ f derivative.
				n _ n + 1.
				value])! !

!LLL methodsFor: 'initialization' stamp: 'len 12/26/2015 21:06'!
basis: aCollection
	| d |
	basis _ Array withAll: aCollection.
	d _ basis size.
	delta _ 3/4 "(4/3 + 0.0000000001)**((d-1)/2)"! !

!LLL methodsFor: 'private' stamp: 'len 7/15/2016 18:26'!
computeMu
	| n bi oj |
	n _ basis size.
	mu _ ZZ ** (n@n) evaluating: [:i :j|
		bi _ basis at: i.
		oj _ orthogonalBasis at: j.
		(bi dot: oj) / (oj dot: oj)]! !

!LLL methodsFor: 'private' stamp: 'len 3/28/2016 01:23'!
computeOrthogonalBasis
	| k vi vj vectors |
	vectors _ Array withAll: basis.
	k _ vectors size.
	1 to: k do: [ :i |
		vi _ vectors at: i.
		i+1 to: k do: [ :j |
			vj _ vectors at: j.
			vj _ vj - (vi * ((vj dot: vi) / (vi dot: vi))).
			vectors at: j put: vj ] ].
	orthogonalBasis _ vectors! !

!LLL methodsFor: 'private' stamp: 'len 12/26/2015 21:00'!
computeReducedBasis
	| k mukj bj bk a b |
	self computeOrthogonalBasis; computeMu.
	k _ 1.
	[k < basis size] whileTrue:
		[k-1 to: 0 by: -1 do: [ :j |
			mukj _ mu at: k+1 @ (j+1).
			bj _ basis at: j+1.
			bk _ basis at: k+1.
			mukj abs > (1/2) ifTrue:
				[basis at: k+1 put: bk - (bj * mukj rounded).
				self update: k+1]].
		a _ (orthogonalBasis at: k+1) norm2.
		b _ (orthogonalBasis at: k) norm2.
		a >= ((delta - (mu at: k+1 @ k) squared) * b)
			ifTrue: [k _ k + 1]
			ifFalse:
				[basis swap: k+1 with: k.
				self update: k+1.
				k _ k-1 max: 1]].
	^ basis! !

!LLL methodsFor: 'accessing' stamp: 'len 12/23/2015 03:01'!
reducedBasis
	orthogonalBasis notNil ifFalse: [self computeReducedBasis].
	^ basis! !

!LLL methodsFor: 'private' stamp: 'len 2/23/2016 07:33'!
update: k
	self flag: #fix. "don't need to recompute all"
	self computeOrthogonalBasis; computeMu! !

!LLL class methodsFor: 'instance creation' stamp: 'len 12/23/2015 03:04'!
basis: aCollection
	^ self new basis: aCollection! !

!LLL class methodsFor: 'instance creation' stamp: 'len 12/9/2015 01:59'!
example
	| b1 b2 b3 lll |
	b1 _ (1, 1, 1).
	b2 _ (-1, 0, 2).
	b3 _ (3, 5, 6).
	lll _ self basis: { b1. b2. b3 }.
	^ lll reducedBasis inspect! !

!LLL class methodsFor: 'instance creation' stamp: 'len 12/6/2015 19:30'!
example2
	"Find polynomial x^2 - x - 1 that has the golden ratio phi as root."
	| r b1 b2 b3 lll |
	r _ 1.618034.
	b1 _ (1, 0, 0, (10000 * r squared)).
	b2 _ (0, 1, 0, (10000 * r)).
	b3 _ (0, 0, 1, 10000).
	lll _ self basis: { b1. b2. b3 }.
	^ lll run inspect! !

!LatticeCovering methodsFor: 'accessing' stamp: 'len 1/1/2016 00:40'!
normalizedThinkness
	"Answer the normalized thickness (or central density) of the covering."
	^ self radius ** lattice rank / lattice fundamentalVolume! !

!LatticeCovering methodsFor: 'accessing' stamp: 'len 1/1/2016 00:40'!
radius
	"Answer the covering radius. This is known to be NP-complete."
	^ lattice coveringRadius! !

!LatticeCovering methodsFor: 'accessing' stamp: 'len 12/30/2015 20:51'!
sphereVolume
	| n Vn pi p |
	pi _ Float pi.
	n _ lattice rank.
	Vn _ n even
		ifTrue: [pi ** (n/2) / (n/2) factorial]
		ifFalse: [2**n * pi ** ((n-1)/2) * ((n-1)/2) factorial / n factorial].
	p _ self radius.
	^ p ** n * Vn! !

!LatticeCovering methodsFor: 'accessing' stamp: 'len 12/30/2015 20:51'!
thickness
	"Answer the thickness of the covering, i.e. the average number of spheres that contain a point of space. The thickness is also called the density or the sparsity of the covering."
	^ self sphereVolume / lattice fundamentalVolume! !

!LatticePacking methodsFor: 'accessing' stamp: 'len 1/1/2016 00:39'!
centerDensity
	^ lattice packingRadius ** lattice rank / lattice fundamentalVolume! !

!LatticePacking methodsFor: 'accessing' stamp: 'len 12/30/2015 20:47'!
density
	"Answer the density of the lattice packing, i.e. the volume of a sphere / the volume of the fundamental region."
	^ self sphereVolume / lattice fundamentalVolume! !

!LatticePacking methodsFor: 'accessing' stamp: 'len 1/1/2016 00:39'!
radius
	"Answer the packing radius. This is known to be NP-hard."
	^ lattice packingRadius! !

!LatticePacking methodsFor: 'accessing' stamp: 'len 12/30/2015 20:48'!
sphereVolume
	| n Vn pi p |
	pi _ Float pi.
	n _ lattice rank.
	Vn _ n even
		ifTrue: [pi ** (n/2) / (n/2) factorial]
		ifFalse: [2**n * pi ** ((n-1)/2) * ((n-1)/2) factorial / n factorial].
	p _ self radius.
	^ p ** n * Vn! !

!GraphNode methodsFor: 'comparing' stamp: 'timestamp) (no'!
= anObject
	"Comparison is delegated to the value of the node.
	Argument and receiver are reversed to dereference through other GraphNodes."
	^anObject = value! !

!GraphNode methodsFor: 'statistics' stamp: 'len 5/7/2016 04:09'!
clusteringCoefficient
	| links k |
	links _ Set new.
	self neighborsDo: [:n1 |
		self neighborsDo: [:n2 |
			(n1 ~= n2 and: [n1 hasEdgeTo: n2])
				ifTrue: [links add: {n1 value. n2 value}]]].
	k _ self neighbors size.
	^ links size / (k * (k - 1))! !

!GraphNode methodsFor: 'accessing edges' stamp: 'timestamp) (no'!
degree
	"How many edges does this node have?"
	self subclassResponsibility! !

!GraphNode methodsFor: 'testing edges' stamp: 'timestamp) (no'!
hasEdgeTo: anObject
	"Is there an edge from this node to anObject?"
	self subclassResponsibility! !

!GraphNode methodsFor: 'testing edges' stamp: 'len 2/26/2016 20:20'!
hasLoop
	^ self hasEdgeTo: self! !

!GraphNode methodsFor: 'comparing' stamp: 'timestamp) (no'!
hash
	^value hash! !

!GraphNode methodsFor: 'testing edges' stamp: 'timestamp) (no'!
isLeaf
	^self degree = 0! !

!GraphNode methodsFor: 'testing edges' stamp: 'len 2/16/2016 03:39'!
isReflexive
	^ self hasEdgeTo: self! !

!GraphNode methodsFor: 'testing edges' stamp: 'len 5/7/2016 04:09'!
isSimple
	^ self neighbors asSet size = self neighbors size and: [self hasLoop not]! !

!GraphNode methodsFor: 'testing edges' stamp: 'len 2/16/2016 03:40'!
isSymmetric
	self neighborsDo: [:each| (each hasEdgeTo: self) ifFalse: [^ false]].
	^ true! !

!GraphNode methodsFor: 'testing edges' stamp: 'len 2/17/2016 03:37'!
isTransitive
	self neighborsDo: [:each|
		each neighborsDo: [:other| (other hasEdgeTo: self) ifFalse: [^ false]]].
	^ true! !

!GraphNode methodsFor: 'iterating' stamp: 'len 6/27/2016 23:19'!
markDo: aBlock
	"Visit each node in the graph once, applying aBlock.
	A node is only visited after at least one of its predecessors, but not necessarily after all the predecessors."
	| todo visited |
	todo _ Set2 with: self.
	visited _ Set2 new.
	[todo isEmpty] whileFalse:
		[| node |
		node _ todo anyOne.
		visited add: node.
		aBlock value: node.
		node neighborsDo:
			[ :child |
				(visited includes: child)
					ifFalse: [todo add: child]].
		todo remove: node]! !

!GraphNode methodsFor: 'accessing edges' stamp: 'len 5/7/2016 04:14'!
neighbors
	"Return a collection of nodes connected to outgoing edges."
	self subclassResponsibility! !

!GraphNode methodsFor: 'accessing edges' stamp: 'timestamp) (no'!
neighborsAndLabelsDo: aBlock
	"Evaluate aBlock for each node connected to an outgoing edge, and the label on that edge (nil if no label)."
	"The default definition assumes no labels are present."
	self neighborsDo: [ :n | aBlock value: n value: nil]! !

!GraphNode methodsFor: 'accessing edges' stamp: 'timestamp) (no'!
neighborsDo: aBlock
	"Evaluate aBlock for each node connected to an outgoing edge."
	self subclassResponsibility! !

!GraphNode methodsFor: 'printing' stamp: 'len 2/14/2003 23:38'!
printOn: aStream
	aStream nextPut: $[; print: value; nextPut: $]! !

!GraphNode methodsFor: 'operations' stamp: 'len 7/20/2016 08:48'!
span
	"Answer the spanning tree of the receiver."
	| tree |
	tree _ RootedDigraph ordered.
	tree roots: (Set with: self).
	self markDo: [:each| tree add: each].
	^ tree! !

!GraphNode methodsFor: 'accessing value' stamp: 'timestamp) (no'!
value
	^value! !

!GraphNode methodsFor: 'accessing value' stamp: 'len 2/14/2016 22:31'!
value: anObject
	value _ anObject! !

!GraphNode methodsFor: 'iterating' stamp: 'len 2/14/2003 20:05'!
walkPre: preBlock post: postBlock
	"Recursively walk the subtree rooted at me.  Apply preBlock to each node, then walk the subtree below node, then apply postBlock to the node."
	preBlock value: self.
	self neighborsDo: [ :child | child walkPre: preBlock post: postBlock].
	postBlock value: self! !

!ExplicitGraphNode methodsFor: 'private' stamp: 'len 2/26/2016 22:44'!
addInNeighborNoCheck: aNode
	^ inNeighbors add: aNode! !

!ExplicitGraphNode methodsFor: 'changing edges' stamp: 'len 5/9/2016 17:10'!
addNeighbor: aNode 
	outNeighbors add: aNode.
	aNode addInNeighborNoCheck: self.
	^ aNode
"	self flag: #fix.
	(outNeighbors includes: aNode)
		ifFalse: 
			[outNeighbors add: aNode.
			aNode addInNeighborNoCheck: self].
	^aNode"! !

!ExplicitGraphNode methodsFor: 'changing edges' stamp: 'len 5/7/2016 04:19'!
addNeighbor: aNode at: index 
	"pre: self isOrdered"
	outNeighbors at: index put: aNode.
	aNode addInNeighborNoCheck: self.
	^aNode! !

!ExplicitGraphNode methodsFor: 'copying' stamp: 'len 2/28/2016 17:02'!
copy
	^ super copy setNeighbors: outNeighbors copy; setInNeighbors: inNeighbors copy! !

!ExplicitGraphNode methodsFor: 'accessing edges' stamp: 'len 5/7/2016 04:03'!
degree
	"If I am in my neighborhood, don't count the loop edge"

	^ (outNeighbors includes: self) 
		ifTrue: [outNeighbors size - 1]
		ifFalse: [outNeighbors size]! !

!ExplicitGraphNode methodsFor: 'testing edges' stamp: 'timestamp) (no'!
hasEdgeTo: anObject 
	^outNeighbors includes: anObject! !

!ExplicitGraphNode methodsFor: 'accessing edges' stamp: 'timestamp) (no'!
inDegree
	"If I am in my neighborhood, don't count the loop edge"
	(inNeighbors includes: self)
		ifTrue: [^ inNeighbors size - 1]
		ifFalse: [^ inNeighbors size]
! !

!ExplicitGraphNode methodsFor: 'accessing edges' stamp: 'Samir Saidani 9/25/2003 14:14'!
inNeighbors
	^inNeighbors! !

!ExplicitGraphNode methodsFor: 'initialize' stamp: 'len 7/14/2016 00:12'!
initializeFixed: arity 
	outNeighbors _ Array new: arity.
	inNeighbors _ Bag new! !

!ExplicitGraphNode methodsFor: 'initialize' stamp: 'len 7/14/2016 00:12'!
initializeOrdered
	outNeighbors _ OrderedCollection new.
	inNeighbors _ Bag new! !

!ExplicitGraphNode methodsFor: 'initialize' stamp: 'len 7/14/2016 00:12'!
initializeUnordered
	outNeighbors _ Bag new.
	inNeighbors _ Bag new! !

!ExplicitGraphNode methodsFor: 'testing' stamp: 'sam 2/9/2004 15:30'!
isAnExtremity
	^ self isFinal | self isInitial | self isExtremal! !

!ExplicitGraphNode methodsFor: 'testing' stamp: 'len 5/7/2016 04:06'!
isExtremal
	"o<-->..."
	^ self degree = 1 and: [self inNeighbors asSet = self neighbors asSet]! !

!ExplicitGraphNode methodsFor: 'testing' stamp: 'len 5/7/2016 04:04'!
isFinal
" o<--..."
	^ self inDegree = 1 and: [self degree = 0]! !

!ExplicitGraphNode methodsFor: 'testing' stamp: 'len 5/7/2016 04:05'!
isInitial
	"o-->..."
	^ self inDegree = 0 and: [self degree = 1]! !

!ExplicitGraphNode methodsFor: 'testing' stamp: 'len 9/1/2016 07:51'!
isMiddle
	"..--o--..."
	^ (self inDegree + self degree between: 2 and: 4)
		and: [(self inNeighbors  self neighbors) size = 2]! !

!ExplicitGraphNode methodsFor: 'testing' stamp: 'timestamp) (no'!
isOrdered
	^outNeighbors isSequenceable! !

!ExplicitGraphNode methodsFor: 'accessing edges' stamp: 'len 5/7/2016 04:07'!
neighbors
	^outNeighbors! !

!ExplicitGraphNode methodsFor: 'accessing edges' stamp: 'len 5/7/2016 04:07'!
neighborsDo: aBlock 
	outNeighbors do: aBlock! !

!ExplicitGraphNode methodsFor: 'changing edges' stamp: 'len 2/26/2016 22:46'!
removeInNeighbor: aNode 
	^ inNeighbors remove: aNode ifAbsent: [aNode]! !

!ExplicitGraphNode methodsFor: 'changing edges' stamp: 'len 2/26/2016 22:54'!
removeNeighbor: aNode
	aNode removeInNeighbor: self.
	^outNeighbors remove: aNode! !

!ExplicitGraphNode methodsFor: 'private' stamp: 'len 2/28/2016 17:02'!
setInNeighbors: aCollection
	inNeighbors _ aCollection! !

!ExplicitGraphNode methodsFor: 'private' stamp: 'len 2/28/2016 17:02'!
setNeighbors: aCollection
	outNeighbors _ aCollection! !

!ExplicitGraphNode methodsFor: 'accessing edges' stamp: 'len 2/15/2016 01:54'!
strictInNeighbors
	(inNeighbors includes: self) ifTrue: [^ inNeighbors copyWithout: self].
	^ inNeighbors! !

!ExplicitGraphNode methodsFor: 'accessing edges' stamp: 'len 5/7/2016 04:15'!
strictNeighbors
	(outNeighbors includes: self) ifTrue: [^ outNeighbors copyWithout: self].
	^ outNeighbors! !

!ExplicitGraphNode class methodsFor: 'instance creation' stamp: 'timestamp) (no'!
arity: n
	"Create a new ordered node with fixed arity n."
	^super new initializeFixed: n! !

!ExplicitGraphNode class methodsFor: 'instance creation' stamp: 'timestamp) (no'!
binary
	"Create a new binary node."
	^super new initializeFixed: 2! !

!ExplicitGraphNode class methodsFor: 'instance creation' stamp: 'len 2/12/2003 21:40'!
binary: value
	"Create a new binary node, and given value."
	^super new initializeFixed: 2; value: value! !

!ExplicitGraphNode class methodsFor: 'instance creation' stamp: 'timestamp) (no'!
new
	"Create a new unordered node."
	^super new initializeUnordered! !

!ExplicitGraphNode class methodsFor: 'instance creation' stamp: 'len 2/12/2003 21:40'!
newOn: value
	"Create a new unordered node, and given value."
	^super new initializeUnordered; value: value! !

!ExplicitGraphNode class methodsFor: 'instance creation' stamp: 'len 2/12/2003 21:40'!
on: value arity: n
	"Create a new ordered node with fixed arity n, and given value."
	^super new initializeFixed: n; value: value! !

!ExplicitGraphNode class methodsFor: 'instance creation' stamp: 'timestamp) (no'!
ordered
	"Create a new ordered node."
	^super new initializeOrdered! !

!ExplicitGraphNode class methodsFor: 'instance creation' stamp: 'len 2/12/2003 21:40'!
ordered: value
	"Create a new ordered node, and given value."
	^super new initializeOrdered; value: value! !

!LabeledExplicitGraphNode methodsFor: 'comparing' stamp: 'len 7/25/2016 08:25'!
= anObject
	anObject class = self class ifTrue: [^ value = anObject value and: [label = anObject label]].
	^ super = anObject! !

!LabeledExplicitGraphNode methodsFor: 'changing edges' stamp: 'timestamp) (no'!
addNeighbor: aNode
	self shouldNotImplement! !

!LabeledExplicitGraphNode methodsFor: 'changing edges' stamp: 'timestamp) (no'!
addNeighbor: aNode at: index
	self shouldNotImplement! !

!LabeledExplicitGraphNode methodsFor: 'changing edges' stamp: 'len 2/15/2016 06:02'!
addNeighbor: aNode at: index label: label
	"pre: self isOrdered"
	outNeighbors at: index put: aNode -> label.
	^ aNode! !

!LabeledExplicitGraphNode methodsFor: 'changing edges' stamp: 'len 5/7/2016 04:21'!
addNeighbor: aNode label: label
	self flag: #fix.
	(outNeighbors includes: aNode) "inefficient"
		ifFalse: 
			[outNeighbors add: aNode -> label.
			aNode addInNeighborNoCheck: self].
	^aNode! !

!LabeledExplicitGraphNode methodsFor: 'testing edges' stamp: 'timestamp) (no'!
hasEdgeTo: anObject 
	^outNeighbors anySatisfy: [:assoc | assoc key = anObject]! !

!LabeledExplicitGraphNode methodsFor: 'accessing' stamp: 'len 2/19/2016 18:49'!
label
	^ label! !

!LabeledExplicitGraphNode methodsFor: 'accessing' stamp: 'len 2/19/2016 18:49'!
label: anObject
	label _ anObject! !

!LabeledExplicitGraphNode methodsFor: 'accessing edges' stamp: 'timestamp) (no'!
labelOfEdgeTo: anObject 
	"Return the label associated with the edge to anObject; otherwise signal an error."

	^(outNeighbors detect: [:assoc | assoc key = anObject]) value! !

!LabeledExplicitGraphNode methodsFor: 'accessing edges' stamp: 'timestamp) (no'!
labelOfEdgeTo: anObject ifNone: aBlock 
	"Return the label associated with the edge to anObject; return the value of the block is no such edge exists."

	^(outNeighbors detect: [:assoc | assoc key = anObject]
		ifNone: [^aBlock value]) value! !

!LabeledExplicitGraphNode methodsFor: 'accessing edges' stamp: 'len 5/7/2016 04:11'!
neighbors
	^outNeighbors collect: [:assoc | assoc key]! !

!LabeledExplicitGraphNode methodsFor: 'accessing edges' stamp: 'timestamp) (no'!
neighborsAndLabelsDo: aBlock 
	"Evaluate aBlock for each node connected to an outgoing edge, and the label on that edge (nil if no label)."

	^outNeighbors do: [:assoc | aBlock value: assoc key value: assoc value]! !

!LabeledExplicitGraphNode methodsFor: 'accessing edges' stamp: 'timestamp) (no'!
neighborsDo: aBlock 
	^outNeighbors do: [:assoc | aBlock value: assoc key]! !

!LabeledExplicitGraphNode methodsFor: 'changing edges' stamp: 'timestamp) (no'!
removeNeighbor: aNode 
	outNeighbors remove: (outNeighbors detect: [:assoc | assoc key = aNode])! !

!ImplicitGraphNode methodsFor: 'accessing edges' stamp: 'len 5/7/2016 04:09'!
neighbors
	^OrderedCollection accumulate: [:incBlock | self neighborsDo: incBlock]! !

!ImplicitGraphNode methodsFor: 'accessing edges' stamp: 'len 5/7/2016 04:09'!
neighborsDo: aBlock 
	self neighbors do: aBlock! !

!ImplicitGraphNode class methodsFor: 'instance creation' stamp: 'sam 2/15/2005 01:02'!
on: aValue collectionBlock: aBlock
	^ImplicitGraphNodeCollection on: aValue collectionBlock: aBlock! !

!ImplicitGraphNode class methodsFor: 'instance creation' stamp: 'timestamp) (no'!
on: aValue iterator: anIterator
	^ImplicitGraphNodeIterator on: aValue iterator: anIterator! !

!ImplicitGraphNode class methodsFor: 'instance creation' stamp: 'timestamp) (no'!
on: aValue iteratorBlock: iteratorBlock
	^ImplicitGraphNodeIterator on: aValue iteratorBlock: iteratorBlock! !

!ImplicitGraphNodeCollection methodsFor: 'initialisation' stamp: 'len 2/28/2016 20:32'!
collectionBlock: aBlock
	collectionBlock _ aBlock! !

!ImplicitGraphNodeCollection methodsFor: 'accessing edges' stamp: 'len 5/7/2016 04:10'!
degree
	^self neighbors size! !

!ImplicitGraphNodeCollection methodsFor: 'testing edges' stamp: 'len 5/7/2016 04:10'!
hasEdgeTo: anObject 
	^self neighbors includes: anObject! !

!ImplicitGraphNodeCollection methodsFor: 'accessing edges' stamp: 'len 5/7/2016 04:10'!
neighbors
	^collectionBlock value! !

!ImplicitGraphNodeCollection class methodsFor: 'instance creation' stamp: 'len 2/15/2016 05:20'!
on: aValue collectionBlock: aBlock 
	^ self new value: aValue; collectionBlock: aBlock! !

!ImplicitGraphNodeIterator methodsFor: 'accessing edges' stamp: 'timestamp) (no'!
degree
	^iterator size! !

!ImplicitGraphNodeIterator methodsFor: 'testing edges' stamp: 'timestamp) (no'!
hasEdgeTo: anObject
	^iterator includes: anObject! !

!ImplicitGraphNodeIterator methodsFor: 'initialisation' stamp: 'len 2/28/2016 20:32'!
iterator: anIterator
	iterator _ anIterator! !

!ImplicitGraphNodeIterator methodsFor: 'accessing edges' stamp: 'timestamp) (no'!
neighborsDo: aBlock
	iterator do: aBlock! !

!ImplicitGraphNodeIterator class methodsFor: 'instance creation' stamp: 'timestamp) (no'!
on: aValue iterator: anIterator
	^(self new) value: aValue ; iterator: anIterator! !

!ImplicitGraphNodeIterator class methodsFor: 'instance creation' stamp: 'timestamp) (no'!
on: aValue iteratorBlock: iteratorBlock
	^self on: aValue iterator: (Iterator on: iteratorBlock)! !

!DAGFrontier methodsFor: 'accessing' stamp: 'timestamp) (no'!
frontier
	^frontier! !

!DAGFrontier methodsFor: 'initialization' stamp: 'timestamp) (no'!
frontier: f bag: remaining
	frontier := f.
	bag := remaining! !

!DAGFrontier methodsFor: 'advancing' stamp: 'len 6/24/2016 17:11'!
remove: frontierObject
	frontier remove: frontierObject.
	frontierObject neighborsDo:
		[ :neighbor |
			(bag remove: neighbor) = 0
				ifTrue: [frontier add: neighbor]].
	^frontierObject! !

!DAGFrontier methodsFor: 'advancing' stamp: 'timestamp) (no'!
removeAll: collection
	collection do: [ :n | self remove: n]! !

!DAGFrontier class methodsFor: 'instance creation' stamp: 'len 2/17/2016 01:20'!
on: rootedGraph
	"Create a frontier object to enumerate the graph."
	| remaining frontier |
	"Build a Bag of non-root nodes, each node once in the Bag for every predecessor."
	frontier _ rootedGraph rootNodes asOrderedCollection.
	remaining _ Bag new.
	rootedGraph nodesDo: [:node| node neighborsDo: [:n| remaining add: n]].
	^ self new frontier: frontier bag: remaining! !

!Dijkstra methodsFor: 'accessing' stamp: 'len 2/15/2016 06:47'!
distanceTo: anObject
	^ distance at: anObject! !

!Dijkstra methodsFor: 'accessing' stamp: 'len 2/13/2003 21:56'!
eccentricity
	"Answer the eccentricity of the source vertex.
	The eccentricity of a vertex is the length of the longest minimal path from that vertex to some vertex in the graph. You can think of the eccentricity of a vertex as the longest distance in the graph from there to somewhere."

	^ distance max! !

!Dijkstra methodsFor: 'initialization' stamp: 'len 2/15/2003 18:52'!
graph: aGraph source: aNode
	graph _ aGraph.
	source _ aNode.
	self run! !

!Dijkstra methodsFor: 'private' stamp: 'len 6/27/2016 23:12'!
run
	| queue u estimate |
	predecessor _ Dictionary2 new.
	distance _ Dictionary2 new.
	graph nodesDo: [:each |
		distance at: each put: Float infinity.
		predecessor at: each put: nil].
	distance at: source put: 0.
	queue _ Heap sortBlock: [:a :b| (distance at: a) <= (distance at: b)].
	queue addAll: graph.
	[queue isEmpty]
		whileFalse:
			[u _ queue removeFirst.
			(graph nodeAt: u) neighborsAndLabelsDo: [:each :weight|
				estimate _ (distance at: u) + 1 "(weight ifNil: [1])".
				(distance at: each) > estimate
					ifTrue: [distance at: each put: estimate.
					predecessor at: each put: u]]]! !

!Dijkstra methodsFor: 'accessing' stamp: 'len 2/26/2016 23:18'!
shortestPathTo: anObject
	| answer node predecessorNode |
	anObject = source ifTrue: [^ #()].
	answer _ OrderedCollection new.
	node _ graph nodeAt: anObject.
	[answer add: node value.
	predecessorNode _ predecessor at: node.
	predecessorNode = source]
		whileFalse: [node _ predecessorNode].
	^ answer reversed! !

!Dijkstra class methodsFor: 'instance creation' stamp: 'len 2/14/2016 22:38'!
graph: aGraph source: aNode
	^ self new graph: aGraph source: aNode! !

!FloydWarshall methodsFor: 'accessing' stamp: 'len 2/17/2016 07:24'!
diameter
	^ distances max! !

!FloydWarshall methodsFor: 'accessing' stamp: 'len 2/17/2016 07:21'!
distanceFrom: source to: target
	^ distances at: {source. target}! !

!FloydWarshall methodsFor: 'initialization' stamp: 'len 2/17/2016 07:04'!
graph: aGraph
	graph _ aGraph.
	self run! !

!FloydWarshall methodsFor: 'accessing' stamp: 'len 2/17/2016 07:24'!
radius
	^ distances min! !

!FloydWarshall methodsFor: 'private' stamp: 'len 2/17/2016 07:18'!
run
	distances _ Dictionary new.
	graph nodesDo: [:x| distances at: {x.x} put: 0].
	graph edgesAndLabelsDo: [:each :label|
		distances at: {each key. each value} put: (label ifNil: [1])].
	graph nodesDo: [:k|
		graph nodesDo: [:i|
			graph nodesDo: [:j|
				| d |
				(d _ (distances at: {i.k}) + (distances at: {k.j})) > (distances at: {i.j})
				 	ifTrue: [distances at: {i.j} put: d]]]]! !

!FloydWarshall class methodsFor: 'instance creation' stamp: 'len 2/17/2016 07:22'!
graph: aGraph
	^ self new graph: aGraph! !

!AffineFrame methodsFor: 'accessing' stamp: 'len 1/3/2016 03:44'!
basis
	^ basis! !

!AffineFrame methodsFor: 'accessing-private' stamp: 'len 1/3/2016 03:44'!
basis: aLinearBasis
	basis _ aLinearBasis! !

!AffineFrame methodsFor: 'coordinates' stamp: 'len 1/3/2016 03:41'!
coordinatesOf: aPoint
	^ basis coordinatesOf: aPoint - origin! !

!AffineFrame methodsFor: 'accessing' stamp: 'len 1/3/2016 03:44'!
origin
	^ origin! !

!AffineFrame methodsFor: 'accessing-private' stamp: 'len 1/3/2016 03:45'!
origin: aPoint
	origin _ aPoint! !

!AffineFrame methodsFor: 'coordinates' stamp: 'len 1/3/2016 03:40'!
pointAt: aTuple
	^ (basis vectorAt: aTuple) + origin! !

!AffineFrame methodsFor: 'printing' stamp: 'len 1/3/2016 03:46'!
printOn: aStream
	aStream nextPut: ${.
	aStream print: origin; nextPutAll: '; '.
	basis do: [:v| aStream print: v] separatedBy: [aStream nextPutAll: ', '].
	aStream nextPut: $}! !

!AffineFrame methodsFor: 'accessing' stamp: 'len 8/30/2016 05:47'!
span
	^ AffineLinearSpace representative: origin direction: basis span! !

!AffineFrame class methodsFor: 'instance creation' stamp: 'len 1/3/2016 03:43'!
origin: aPoint basis: aLinearBasis
	^ self new origin: aPoint; basis: aLinearBasis! !

!HomogeneousTuple methodsFor: 'comparing' stamp: 'len 6/29/2016 05:24'!
= aHomogeneousTuple
	| index |
	index _ self firstNonZero.
	(aHomogeneousTuple at: index) isZero ifTrue: [^ false].
	^ self coordinates / (self at: index) = (aHomogeneousTuple coordinates / (aHomogeneousTuple at: index))! !

!HomogeneousTuple methodsFor: 'converting' stamp: 'len 11/7/97 01:42'!
affinized
	"Answer the affinization of the receiver."

	^ self affinizedIn: self size! !

!HomogeneousTuple methodsFor: 'converting' stamp: 'len 12/13/2015 23:39'!
affinizedIn: anInteger
	"Answer the affinization of the receiver with respect to the anInteger-th coordinate."

	| scalar |
	scalar _ self at: anInteger.
	^ Tuple
		new: self coordinates size - 1
		evaluating: [:i| (i < anInteger ifTrue: [self at: i] ifFalse: [self at: i + 1]) / scalar]! !

!HomogeneousTuple methodsFor: 'converting' stamp: 'len 11/8/2015 00:18'!
asTuple
	"Answer a Tuple with the coordinates of the receiver."

	^ self coordinates! !

!HomogeneousTuple methodsFor: 'accessing' stamp: 'len 11/20/2015 16:14'!
at: anInteger
	"Answer the anInteger-th coordinate of the receiver."

	^ coordinates at: anInteger! !

!HomogeneousTuple methodsFor: 'accessing' stamp: 'len 11/9/2015 07:14'!
coordinates
	^ coordinates! !

!HomogeneousTuple methodsFor: 'accessing-private' stamp: 'len 1/5/98 20:31'!
coordinates: aTuple
	coordinates _ aTuple! !

!HomogeneousTuple methodsFor: 'private' stamp: 'len 6/29/2016 05:23'!
firstNonZero
	^ (1 to: self size) detect: [ :each | (self at: each) isZero not]! !

!HomogeneousTuple methodsFor: 'comparing' stamp: 'len 6/29/2016 05:24'!
hash
	^ (coordinates / (self at: self firstNonZero)) hash! !

!HomogeneousTuple methodsFor: 'printing' stamp: 'len 6/29/2016 05:25'!
printOn: aStream
	aStream nextPut: $[.
	self coordinates do: [:each| each printOn: aStream] separatedBy: [aStream nextPut: $:].
	aStream nextPut: $]! !

!HomogeneousTuple methodsFor: 'accessing' stamp: 'len 11/20/2015 16:14'!
size
	^ coordinates size! !

!HomogeneousTuple methodsFor: 'accessing' stamp: 'len 11/20/2015 16:14'!
x
	"Answer the x coordinate of the receiver."

	^ coordinates x! !

!HomogeneousTuple methodsFor: 'accessing' stamp: 'len 11/20/2015 16:14'!
y
	"Answer the y coordinate of the receiver."

	^ coordinates y! !

!HomogeneousTuple methodsFor: 'accessing' stamp: 'len 11/20/2015 16:14'!
z
	"Answer the z coordinate of the receiver."

	^ coordinates z! !

!HomogeneousTuple class methodsFor: 'instance creation' stamp: 'len 11/28/97 02:43'!
coordinates: aTuple
	"Answer a new instance of the receiver with the given coordinates."

	^ self new coordinates: aTuple! !

!HomogeneousTuple class methodsFor: 'instance creation' stamp: 'len 11/28/97 02:04'!
x: x y: y z: z
	"Answer a new instance of the receiver with the given coordinates."

	^ self coordinates: (Tuple x: x y: y z: z)! !

!ProjectiveChart methodsFor: 'accessing' stamp: 'len 8/30/2016 05:48'!
affine
	"Answer the affine space associated to the receiver."
	| parallel |
	parallel _ LinearBasis on: frame space vectorSpace.
	1 to: index - 1 do: [:i|
		parallel add: (frame space vectorFromPoint: (frame at: i))].
	self index + 1 to: frame size do: [:i|
		parallel add: (frame space vectorFromPoint: (frame at: i))].
	^ AffineLinearSpace representative: origin direction: parallel span! !

!ProjectiveChart methodsFor: 'coordinates' stamp: 'len 1/3/2016 05:20'!
coordinatesOf: aPoint
	"Answer the coordinates of the argument in the receiver. The argument is a linear subspace of dimension 1."
	^ (frame coordinatesOf: aPoint) affinizedIn: index! !

!ProjectiveChart methodsFor: 'accessing' stamp: 'len 1/3/2016 05:22'!
frame
	^ frame! !

!ProjectiveChart methodsFor: 'accessing-private' stamp: 'len 1/3/2016 05:22'!
frame: aProjectiveFrame
	frame _ aProjectiveFrame! !

!ProjectiveChart methodsFor: 'accessing' stamp: 'len 11/20/2015 16:17'!
index
	^ index! !

!ProjectiveChart methodsFor: 'accessing-private' stamp: 'len 2/28/98 21:44'!
index: anInteger
	index _ anInteger! !

!ProjectiveChart methodsFor: 'accessing' stamp: 'len 3/18/2016 05:12'!
infinity
	"Answer the hyperplane at infinity."

	| h |
	h _ ProjectiveFrame on: frame space.
	1 to: self index - 1 do: [:each| h add: (frame at: each)].
	self index + 1 to: frame size do: [:each| h add: (frame at: each)].
	^ h span! !

!ProjectiveChart methodsFor: 'accessing' stamp: 'len 1/3/2016 05:21'!
origin
	^ origin! !

!ProjectiveChart methodsFor: 'accessing-private' stamp: 'len 3/2/98 03:17'!
origin: anObject
	origin _ anObject! !

!ProjectiveChart methodsFor: 'coordinates' stamp: 'len 1/3/2016 05:19'!
pointAt: aTuple
	"Answer the point with coordinates aTuple in the receiver."
	| extended |
	extended _ Tuple new: aTuple dimension + 1.
	1 to: index - 1 do: [:i|
		extended at: i put: (aTuple at: i)].
	extended at: index put: frame space scalars one.
	self index + 1 to: aTuple dimension + 1 do: [:i|
		extended at: i put: (aTuple at: i - 1)].
	^ frame pointAt: extended homogeneous! !

!ProjectiveChart methodsFor: 'printing' stamp: 'len 6/2/2016 18:55'!
printOn: aStream
	aStream
		nextPutAll: self class name;
		space; print: index;
		space; print: frame! !

!ProjectiveChart methodsFor: 'coordinates' stamp: 'len 9/1/2016 08:01'!
vectorFromPoint: aPoint
	"Answer a vector associated to the projective point aPoint (which is a linear subspace of dimension 1)."
	^ (aPoint vectorSpace asAffineSpace  self affine) representative! !

!ProjectiveChart class methodsFor: 'instance creation' stamp: 'len 1/3/2016 05:22'!
frame: aProjectiveFrame index: anInteger origin: anObject
	"Answer a new instance of the receiver representing the anInteger-th chart with basis aProjectiveBasis and origin anObject."
	^ self new frame: aProjectiveFrame; index: anInteger; origin: anObject! !

!ProjectiveFrame methodsFor: 'accessing' stamp: 'len 3/23/2016 22:01'!
add: aPoint
	^ points add: aPoint! !

!ProjectiveFrame methodsFor: 'accessing' stamp: 'len 11/8/2015 00:05'!
at: anInteger
	^ points at: anInteger! !

!ProjectiveFrame methodsFor: 'operations' stamp: 'len 6/3/2016 23:33'!
changeTo: aProjectiveFrame
	"Answer the homography for changing from the receiver to aProjectiveFrame."
	^ self notYetImplemented! !

!ProjectiveFrame methodsFor: 'private' stamp: 'len 6/4/2016 01:38'!
computeUnit
	unit _ self space vectorSpace null.
	self do: [:each| unit _ unit + (self space vectorFromPoint: each)].
	unit _ self space project: unit! !

!ProjectiveFrame methodsFor: 'coordinates' stamp: 'len 11/22/2015 05:38'!
coordinatesOf: anObject
	"Answer the coordinates of the argument in the receiver."

	| linear coords ucoords |
	linear _ LinearBasis on: self space vectorSpace.
	self do: [ :each | linear add: (self space vectorFromPoint: each)].
	coords _ linear coordinatesOf: (self space vectorFromPoint: anObject).
	ucoords _ linear coordinatesOf: (self space vectorFromPoint: self unit).
	1 to: coords size do: [ :each |
		coords at: each put: (coords at: each) / (ucoords at: each)].
	^ coords homogeneous! !

!ProjectiveFrame methodsFor: 'accessing' stamp: 'len 11/8/2015 00:03'!
dimension
	^ self size - 1! !

!ProjectiveFrame methodsFor: 'enumerating' stamp: 'len 11/8/2015 00:06'!
do: aBlock
	points do: aBlock! !

!ProjectiveFrame methodsFor: 'initialization' stamp: 'len 11/8/2015 00:06'!
initialize
	self points: OrderedCollection new! !

!ProjectiveFrame methodsFor: 'coordinates' stamp: 'len 6/4/2016 01:38'!
pointAt: anHomogeneousTuple
	"Answer point with coordinates aProjectiveTuple in the receiver."

	| B |
	B _ LinearBasis on: self space vectorSpace.
	self do: [:each| B add: (self space vectorFromPoint: each)].
	^ self space
		project:
			(B vectorAt: anHomogeneousTuple asTuple)! !

!ProjectiveFrame methodsFor: 'accessing-private' stamp: 'len 11/8/2015 00:04'!
points: aCollection
	points _ aCollection! !

!ProjectiveFrame methodsFor: 'printing' stamp: 'len 6/2/2016 18:56'!
printOn: aStream
	aStream nextPut: ${.
	self do: [:each| aStream print: each] separatedBy: [aStream nextPutAll: '; '].
	aStream nextPut: $}! !

!ProjectiveFrame methodsFor: 'accessing' stamp: 'len 11/8/2015 00:06'!
size
	^ points size! !

!ProjectiveFrame methodsFor: 'accessing-private' stamp: 'len 11/8/2015 00:01'!
space
	^ space! !

!ProjectiveFrame methodsFor: 'accessing-private' stamp: 'len 11/8/2015 00:01'!
space: aProjectiveSpace
	space _ aProjectiveSpace! !

!ProjectiveFrame methodsFor: 'accessing' stamp: 'len 6/10/2016 05:37'!
span
	| basis |
	basis _ LinearBasis on: space vectorSpace.
	self do: [:each| basis add: (space vectorFromPoint: each)].
	^ basis span projective! !

!ProjectiveFrame methodsFor: 'accessing' stamp: 'len 3/2/98 03:02'!
unit
	"Answer the unit point of the receiver."

	unit isNil ifTrue: [self computeUnit].
	^ unit! !

!ProjectiveFrame methodsFor: 'accessing-private' stamp: 'len 3/1/98 04:46'!
unit: anObject
	unit _ anObject! !

!ProjectiveFrame class methodsFor: 'instance creation' stamp: 'len 2/25/98 22:25'!
new
	^ super new initialize! !

!ProjectiveFrame class methodsFor: 'instance creation' stamp: 'len 1/3/2016 05:23'!
on: aProjectiveSpace
	^ self new space: aProjectiveSpace! !

!PolynomialSystem methodsFor: 'accessing' stamp: 'pdm 4/19/98 23:08'!
, anObject
	"Answer a copy of the receiver concatenated with the argument."
	| answer |
	answer _ self copy.
	anObject class == self class
		ifTrue: [answer addAll: anObject]
		ifFalse: [answer add: anObject].
	^ answer! !

!PolynomialSystem methodsFor: 'accessing' stamp: 'len 5/13/2016 07:36'!
add: aPolynomialEquation 
	^ equations add: aPolynomialEquation! !

!PolynomialSystem methodsFor: 'accessing' stamp: 'pdm 3/9/98 16:37'!
addAll: aCollection 
	"Add all the elements in argument to the equations of the 
	receiver. Answer the argument."
	aCollection do: [:each | self add: each].
	^ aCollection! !

!PolynomialSystem methodsFor: 'copying' stamp: 'pdm 3/9/98 16:37'!
copy
	"Answer a copy of the receiver."
	^ self class new addAll: self;
	 yourself! !

!PolynomialSystem methodsFor: 'enumerating' stamp: 'len 5/13/2016 07:36'!
do: aBlock 
	equations do: aBlock! !

!PolynomialSystem methodsFor: 'accessing' stamp: 'len 6/3/2016 02:45'!
ideal
	| generators R |
	generators _ equations collect: [:each| each polynomial].
	R _ generators anyOne species.
	^ R * generators! !

!PolynomialSystem methodsFor: 'initialization' stamp: 'len 5/13/2016 07:37'!
initialize
	equations _ OrderedCollection new! !

!PolynomialSystem methodsFor: 'testing' stamp: 'len 12/23/2015 00:13'!
isHomogeneous
	^ equations allSatisfy: [:each| each isHomogeneous]! !

!PolynomialSystem methodsFor: 'testing' stamp: 'len 11/26/2015 23:51'!
isInconsistent
	^ self solutions isEmpty! !

!PolynomialSystem methodsFor: 'testing' stamp: 'len 5/13/2016 07:36'!
isOverdetermined
	^ equations size > self indeterminates size! !

!PolynomialSystem methodsFor: 'testing' stamp: 'len 11/26/2015 23:52'!
isPositiveDimensional
	^ self solutions isEmpty not and: [self solutions isFinite not]! !

!PolynomialSystem methodsFor: 'testing' stamp: 'pdm 3/9/98 16:37'!
isSolution: anObject 
	"Answer true if the argument is a solutions of the receiver."
	self do: [:each | (each isSolution: anObject)
			ifFalse: [^ false]].
	^ true! !

!PolynomialSystem methodsFor: 'testing' stamp: 'len 11/26/2015 23:51'!
isZeroDimensional
	^ self solutions isFinite! !

!PolynomialSystem methodsFor: 'printing' stamp: 'len 6/3/2016 02:47'!
printOn: aStream 
	aStream nextPut: ${.
	equations do: [:each| aStream print: each] separatedBy: [aStream nextPutAll: '; '].
	aStream nextPut: $}! !

!PolynomialSystem methodsFor: 'accessing' stamp: 'len 6/3/2016 02:45'!
solutions
	"Answer the set of solutions of the receiver (an algebraic set)."
	^ self ideal variety! !

!PolynomialSystem class methodsFor: 'examples' stamp: 'len 7/15/2016 18:35'!
cyclic: n
	"Answer the cyclic n-root polynomial system, commonly used for benchmarks in computer algebra."
	| Q P answer f |
	Q _ QQ.
	P _ Q polynomialsIn: n.
	answer _ self new.
	0 to: n-2 do: [:k|
		f _ P zero.
		1 to: n do: [:i|
			| m |
			m _ P one.
			i to: i+k do: [:j| m _ m * (P x: j \\ n + 1)].
			f _ f + m].
		answer add: (f eq: P zero)].
	f _ P one.
	1 to: n do: [:i| f _ f * (P x: i)].
	f _ f - P one.
	answer add: (f eq: P zero).
	^ answer! !

!PolynomialSystem class methodsFor: 'instance creation' stamp: 'len 10/22/97 01:00'!
new
	^ super new initialize! !

!SchemePoint methodsFor: 'as yet unclassified' stamp: 'len 10/3/2016 09:06'!
scheme
	^ morphism codomain! !

!CylindricalAlgebraicDecomposition methodsFor: 'accessing' stamp: 'len 5/30/2016 03:40'!
components
	components isNil ifTrue: [self decompose].
	^ components! !

!CylindricalAlgebraicDecomposition methodsFor: 'private' stamp: 'len 6/7/2016 00:21'!
decompose
	"Perform the cylindrical algebraic decomposition."

	| x Rx cells roots point functions f |
	self dimension < 1 ifTrue: [^ components _ #()].
	self dimension = 1 ifTrue: [^ self decomposeUnivariate].
	Rx _ RealAlgebraicNumbers new polynomials.
	x _ Rx x.
	cells _ OrderedCollection new.
	(self class polynomials: self phi) do: [:each|
		point _ ((each sample collect: [:s| Rx constant: s]), x).
		roots _ Set new.
		self polynomials do: [:some|
			f _ (some value: point) coefficientsApply: [:coeff|
					coeff isAlgebraic ifTrue: [coeff asRational] ifFalse: [coeff]].
			roots addAll: (RealRootFinder polynomial: f) roots].
		roots isEmpty
			ifTrue: [cells add:
						(SemialgebraicCell
							projection: each
							between: Infinity negative and: Infinity positive)]
			ifFalse: [functions _ (1 to: roots size)
						collect: [ :some | RealRootFunction
											polynomials: self polynomials index: some].
					cells add: (SemialgebraicCell
								projection: each
								between: Infinity negative
								and: functions first).
					1 to: functions size - 1 do: [ :index |
						cells
							add: (SemialgebraicCell
									projection: each
									between: (functions at: index)
									and: (functions at: index));
							add: (SemialgebraicCell
									projection: each
									between: (functions at: index)
									and: (functions at: index + 1))].
					cells add: (SemialgebraicCell
								projection: each
								between: functions last
								and: functions last).
					cells add: (SemialgebraicCell
								projection: each
								between: functions last
								and: Infinity positive)]].
	^ components _ cells! !

!CylindricalAlgebraicDecomposition methodsFor: 'private' stamp: 'len 5/30/2016 18:57'!
decomposeUnivariate
	"Perform the cylindrical algebraic decomposition in the univariate case.
	It's easy. Suppose we have to find the CAD of R with respect to the polynomial set {f1, ..., fn}.
	Then we find all the real roots of f1, ..., fn, a1 < a2 < ... < am, and the CAD we were looking for is:
		[-infinity, a1), [a1, a1], (a1, a2), [a2, a2], ... [am, am], (am, +infinity]."

	| roots intervals |
	roots _ Set new.
	self polynomials do: [ :each |
		roots addAll: (RealRootFinder polynomial: each) roots].
	roots isEmpty
		ifTrue: [^ components _ {SemialgebraicInterval between: Infinity negative and: Infinity positive}].
	roots _ roots asSortedCollection.
	intervals _ OrderedCollection new.
	intervals add: (SemialgebraicInterval between: Infinity negative and: roots first).
	1 to: roots size - 1 do: [ :each |
		intervals
			add: (SemialgebraicInterval between: (roots at: each) and: (roots at: each));
			add: (SemialgebraicInterval between: (roots at: each) and: (roots at: each + 1))].
	intervals
		add: (SemialgebraicInterval between: roots last and: roots last);
		add: (SemialgebraicInterval between: roots last and: Infinity positive).
	^ components _ intervals! !

!CylindricalAlgebraicDecomposition methodsFor: 'accessing' stamp: 'len 5/30/2016 05:52'!
dimension
	"Answer the dimension of the ambient of the receiver."
	
	^ polynomials anyOne species rank! !

!CylindricalAlgebraicDecomposition methodsFor: 'enumerating' stamp: 'len 12/12/97 20:11'!
do: aBlock
	"Enumerate the components of the receiver."

	self components do: aBlock! !

!CylindricalAlgebraicDecomposition methodsFor: 'private' stamp: 'len 5/30/2016 05:39'!
phi
	"Answer a set of polynomials in n-1 indeterminates which completly characterize the connected maximal F-delineable subsets of R^{n-1}. (where F is the polynomial set of the receiver and n is the number of indeterminates). See >>decompose."

	| answer f g |
	answer _ Set new.
	self polynomials do: [:each|
		| f` |
		f _ each asUnivariate.
		answer addAll: f coefficients.
		f` _ f derivative.
		0 to: f degree - 1 do: [:i| answer add: (f psc: i with: f`)]].
	1 to: self polynomials size - 1 do: [:i|
		i + 1 to: self polynomials size do: [:j|
			f _ (self polynomials at: i) asUnivariate.
			g _ (self polynomials at: j) asUnivariate.
			0 to: (f degree min: g degree) do: [:m|
				answer add: (f psc: m with: g)]]].
	^ answer select: [:each| each isZero not] :: collect: [ :each | each / each leadingCoefficient] :: asArray! !

!CylindricalAlgebraicDecomposition methodsFor: 'accessing' stamp: 'len 12/12/97 23:32'!
polynomials
	"Answer the polynomial set defining the receiver."

	^ polynomials! !

!CylindricalAlgebraicDecomposition methodsFor: 'accessing-private' stamp: 'len 5/30/2016 05:31'!
polynomials: aPolynomialSet
	polynomials _ aPolynomialSet.
	aPolynomialSet isEmpty ifTrue: [self error: 'empty polynomial set']. "when could it be empty?"! !

!CylindricalAlgebraicDecomposition class methodsFor: 'instance creation' stamp: 'len 5/30/2016 05:47'!
polynomials: aPolynomialSet
	"Answer a new instance of the receiver representing the cylindrical algebraic decomposition of R^n in cells sign-invariant by aPolynomialSet (of polynomials in R[x1,..,xn])."

	^ self new polynomials: aPolynomialSet! !

!SemialgebraicCell methodsFor: 'comparing' stamp: 'len 3/18/2016 06:43'!
= anObject
	^ self class == anObject class
		and: [self projection = anObject projection
			and: [self left = anObject left and: [self right = anObject right]]]! !

!SemialgebraicCell methodsFor: 'morphisms' stamp: 'len 6/2/2016 02:26'!
boundary
	| answer |
	answer _ SemialgebraicSet new.
	self projection boundary do: [ :each |
		answer
			add: (self class projection: each between: self left and: self left);
			add: (self class projection: each between: self left and: self right);
			add: (self class projection: each between: self right and: self right)].
	answer
		add: (self class projection: self projection between: self left and: self left);
		add: (self class projection: self projection between: self right and: self right).
	^ answer! !

!SemialgebraicCell methodsFor: 'accessing' stamp: 'len 5/30/2016 18:56'!
boundsAt: aTuple
	"Answer the bounds of the last component of the receiver when the first components are aTuple."

	| lbound rbound |
	lbound _ (self left isInfinity or: [self left isNumber])
		ifTrue: [self left]
		ifFalse: [self left value: aTuple].
	rbound _ (self right isInfinity or: [self right isNumber])
		ifTrue: [self right]
		ifFalse: [self right value: aTuple].
	^ SemialgebraicInterval between: lbound and: rbound! !

!SemialgebraicCell methodsFor: 'morphisms' stamp: 'len 6/2/2016 08:08'!
closure
	| answer |
	answer _ SemialgebraicSet new.
	self projection closure do: [:each|
		answer
			add: (self class projection: each between: self left and: self left);
			add: (self class projection: each between: self left and: self right);
			add: (self class projection: each between: self right and: self right)].
	answer
		add: (self class projection: self projection between: self left and: self left);
		add: self;
		add: (self class projection: self projection between: self right and: self right).
	^ answer! !

!SemialgebraicCell methodsFor: 'accessing' stamp: 'len 3/17/2016 03:44'!
dimension
	"Answer the dimension of the receiver."

	^ self left = self right
		ifTrue: [self projection dimension]
		ifFalse: [self projection dimension + 1]! !

!SemialgebraicCell methodsFor: 'comparing' stamp: 'len 6/28/2016 09:35'!
hash
	^ self projection hash + self left hash + self right hash hashMultiply! !

!SemialgebraicCell methodsFor: 'testing' stamp: 'len 1/17/98 14:23'!
includes: aTuple
	"Answer true if the receiver includes the argument."

	| pi |
	pi _ aTuple copyFrom: 1 to: aTuple size - 1.
	^ (self projection includes: pi) and: [(self boundsAt: pi) includes: aTuple last]! !

!SemialgebraicCell methodsFor: 'morphisms' stamp: 'len 6/2/2016 08:09'!
interior
	^ self closure \ self boundary! !

!SemialgebraicCell methodsFor: 'morphisms' stamp: 'len 6/2/2016 07:38'!
interior2
	"Answer the interior of the receiver."

	^ self closure copyWithoutAll: self boundary! !

!SemialgebraicCell methodsFor: 'testing' stamp: 'len 12/14/97 22:06'!
isBounded
	"Answer true if the receiver is bounded."

	^ self projection isBounded and: [(self left isInfinity or: [self right isInfinity]) not]! !

!SemialgebraicCell methodsFor: 'testing' stamp: 'len 6/2/2016 07:33'!
isClosed
	^ self projection isClosed and: [self left = self right]! !

!SemialgebraicCell methodsFor: 'testing' stamp: 'len 2/6/98 13:33'!
isCylindricalOver: aCell
	"Answer true if the receiver is cylindrical over aCell."

	^ self = aCell or: [self projection isCylindricalOver: aCell]! !

!SemialgebraicCell methodsFor: 'testing' stamp: 'len 6/2/2016 05:09'!
isFinite
	^ self projection isFinite and: [self left = self right]! !

!SemialgebraicCell methodsFor: 'testing' stamp: 'len 6/2/2016 07:35'!
isOpen
	^ self projection isOpen and: [self left ~= self right]! !

!SemialgebraicCell methodsFor: 'accessing-private' stamp: 'len 12/14/97 21:33'!
left
	^ left! !

!SemialgebraicCell methodsFor: 'accessing-private' stamp: 'len 12/14/97 21:33'!
left: anObject
	left _ anObject! !

!SemialgebraicCell methodsFor: 'accessing' stamp: 'len 7/15/2016 18:37'!
polynomials
	"Answer the polynomials defining the receiver."

	| R answer |
	answer _ Set new.
	self left isInfinity ifFalse: [answer addAll: self left polynomials].
	self right isInfinity ifFalse: [answer addAll: self right polynomials].
	R _ answer isEmpty ifTrue: [QQ polynomialsIn: self rank] ifFalse: [answer anyOne species].
	self projection polynomials do: [:each| answer add: (each as: R)].
	^ answer! !

!SemialgebraicCell methodsFor: 'printing' stamp: 'len 6/2/2016 02:09'!
printOn: aStream
	"aStream nextPut: ${; print: self sentence; nextPut: $}"
	self dimension >= 0
		ifFalse: [aStream nextPut: Character emptySet. ^ self].
	self dimension = 0
		ifTrue: [aStream nextPut: ${; print: self sample; nextPut: $}. ^ self].
	aStream print: self dimension; nextPutAll: '-cell'; print: self sample! !

!SemialgebraicCell methodsFor: 'accessing' stamp: 'len 12/14/97 21:01'!
projection
	"Answer the projection of the receiver (all but the last component)."

	^ projection! !

!SemialgebraicCell methodsFor: 'accessing-private' stamp: 'len 12/14/97 20:59'!
projection: aCell
	projection _ aCell! !

!SemialgebraicCell methodsFor: 'accessing' stamp: 'len 2/6/98 12:50'!
projectionAt: anInteger
	"Answer the first anInteger components of the receiver."

	| projections cell |
	projections _ OrderedCollection with: self.
	cell _ self.
	[(cell _ cell projection) notNil] whileTrue: [projections addFirst: cell].
	^ projections at: anInteger! !

!SemialgebraicCell methodsFor: 'accessing' stamp: 'len 6/1/2016 23:32'!
rank
	"Answer the number of indeterminates involved to define the receiver."
	^ self projection rank + 1! !

!SemialgebraicCell methodsFor: 'accessing-private' stamp: 'len 12/14/97 21:33'!
right
	^ right! !

!SemialgebraicCell methodsFor: 'accessing-private' stamp: 'len 12/14/97 21:33'!
right: anObject
	right _ anObject! !

!SemialgebraicCell methodsFor: 'accessing' stamp: 'len 1/17/98 14:23'!
sample
	"Answer a sample point in the receiver."

	| alpha |
	^ (alpha _ self projection sample), (self boundsAt: alpha) sample! !

!SemialgebraicCell methodsFor: 'accessing' stamp: 'len 5/30/2016 19:00'!
sentence
	"Answer a quantifier-free defining sentence for the receiver."
	
	| answer sample sign sentence |
	self flag: #fix. "this is the same as SemialgebraicInterval>>sentence, fix"
	sample _ self sample.
	self polynomials do: [:each|
		sentence _
			(sign _ (each value: sample) sign) = 0
				ifTrue: [each eq: 0]
				ifFalse: [sign = -1 ifTrue: [each lneq: 0] ifFalse: [each gneq: 0]].
		answer _ answer isNil ifTrue: [sentence] ifFalse: [answer & sentence]].
	^ answer! !

!SemialgebraicCell class methodsFor: 'instance creation' stamp: 'len 12/14/97 21:45'!
projection: aCell between: leftBound and: rightBound
	"Answer a new instance of the receiver representing the cell
	whose projection is aCell and whose last component is bounded
	by the given bounds."

	^ self new projection: aCell; left: leftBound; right: rightBound! !

!BooleanConnective methodsFor: 'arithmetic' stamp: 'len 12/18/97 19:44'!
& anObject
	"Answer the conjunction of the receiver with the argument."

	^ ConjunctionConnective left: self right: anObject! !

!BooleanConnective methodsFor: 'arithmetic' stamp: 'len 12/18/97 19:48'!
-> anObject
	"Answer the implication of the argument from the receiver."

	^ ImplicationConnective left: self right: anObject! !

!BooleanConnective methodsFor: 'arithmetic' stamp: 'len 12/18/97 19:45'!
| anObject
	"Answer the disjunction of the receiver with the argument."

	^ DisjunctionConnective left: self right: anObject! !

!BooleanConnective methodsFor: 'accessing' stamp: 'len 12/31/97 02:44'!
bounded
	"Answer the collection of bounded indeterminates."

	^ self left bounded addAll: self right bounded; yourself! !

!BooleanConnective methodsFor: 'arithmetic' stamp: 'len 12/21/97 21:24'!
exists: anInteger
	"Answer the quantification of the reciever by the
	existential quantifier in the anInteger-th indeterminate."

	^ QuantifiedSentence quantifier: (Quantifier exists: anInteger) matrix: self! !

!BooleanConnective methodsFor: 'arithmetic' stamp: 'len 12/21/97 21:25'!
forAll: anInteger
	"Answer the quantification of the reciever by the
	universal quantifier in the anInteger-th indeterminate."

	^ QuantifiedSentence quantifier: (Quantifier forAll: anInteger) matrix: self! !

!BooleanConnective methodsFor: 'accessing' stamp: 'len 12/31/97 02:44'!
free
	"Answer the collection of free indeterminates."

	| answer |
	answer _ self indeterminates.
	self bounded do: [ :each | answer remove: each ifAbsent: []].
	^ answer! !

!BooleanConnective methodsFor: 'accessing' stamp: 'len 12/18/97 20:41'!
indeterminates
	"Answer the indeterminates of the receiver."

	^ self left indeterminates addAll: self right indeterminates; yourself! !

!BooleanConnective methodsFor: 'testing' stamp: 'len 12/18/97 20:27'!
isQuantifierFree
	"Answer true if the receiver is quantifier-free."

	^ self left isQuantifierFree and: [self right isQuantifierFree]! !

!BooleanConnective methodsFor: 'testing' stamp: 'len 12/18/97 19:43'!
isSolution: anObject
	"Answer true if the argument is solution of the receiver."

	self subclassResponsibility! !

!BooleanConnective methodsFor: 'accessing' stamp: 'len 12/18/97 19:42'!
left
	"Answer the left component of the receiver."

	^ left! !

!BooleanConnective methodsFor: 'accessing-private' stamp: 'len 12/18/97 19:42'!
left: anObject
	left _ anObject! !

!BooleanConnective methodsFor: 'operations' stamp: 'len 12/26/97 18:46'!
normalized
	"Answer a copy of the receiver with the indeterminates renamed
	such that the same indeterminate does not ocur as free and bound."

	| last bounded answer |
	last _ self indeterminates asSortedCollection last.
	bounded _ self right bounded.
	answer _ self copy.
	(self left free select: [ :some | bounded includes: some])
			do: [ :each | answer rename: each to: (last _ last + 1)].
	^ answer! !

!BooleanConnective methodsFor: 'arithmetic' stamp: 'len 12/18/97 19:49'!
not
	"Answer the negation of the receiver."

	self subclassResponsibility! !

!BooleanConnective methodsFor: 'accessing' stamp: 'len 12/19/97 21:47'!
polynomials
	"Answer the polynomial set of the receiver."

	^ self left polynomials addAll: self right polynomials; yourself! !

!BooleanConnective methodsFor: 'operations' stamp: 'len 12/31/97 02:19'!
prenex
	"Answer the prenex form of the receiver."

	^ self reduced normalized privatePrenex! !

!BooleanConnective methodsFor: 'printing' stamp: 'len 6/2/2016 01:40'!
printOn: aStream
	left class = self class
		ifTrue: [aStream print: left]
		ifFalse: [aStream nextPut: $(; print: left; nextPut: $)].
	aStream space; nextPutAll: self operatorName bold; space.
	right class = self class
		ifTrue: [aStream print: right]
		ifFalse: [aStream nextPut: $(; print: right; nextPut: $)]
! !

!BooleanConnective methodsFor: 'private' stamp: 'len 12/31/97 02:26'!
privatePrenex
	"Answer the prenex form of the receiver.
	Assume the receiver is reduced and normalized."

	| lp rp prefix matrix |
	lp _ self left privatePrenex.
	rp _ self right privatePrenex.
	prefix _ lp prefix copy addAll: rp prefix; yourself.
	matrix _ self class left: lp matrix right: rp matrix.
	^ QuantifiedSentence prefix: prefix matrix: matrix! !

!BooleanConnective methodsFor: 'operations' stamp: 'len 12/26/97 18:38'!
reduced
	"Answer a copy of the receiver with the redundant quantifiers removed."

	^ self class left: self left reduced right: self right reduced! !

!BooleanConnective methodsFor: 'operations' stamp: 'len 12/26/97 18:48'!
rename: anInteger to: anotherInteger
	"Rename the anInteger-th indeterminate of the receiver to anotherInteger."

	self left rename: anInteger to: anotherInteger.
	self right rename: anInteger to: anotherInteger! !

!BooleanConnective methodsFor: 'accessing' stamp: 'len 12/18/97 19:42'!
right
	"Answer the right component of the receiver."

	^ right! !

!BooleanConnective methodsFor: 'accessing-private' stamp: 'len 12/18/97 19:42'!
right: anObject
	right _ anObject! !

!BooleanConnective class methodsFor: 'instance creation' stamp: 'len 12/18/97 19:46'!
left: anObject right: anotherObject
	"Answer a new instance of the receiver with left
	and right components given by the arguments."

	^ self new left: anObject; right: anotherObject! !

!ConjunctionConnective methodsFor: 'testing' stamp: 'len 12/18/97 19:43'!
isSolution: anObject
	"Answer true if the argument is solution of the receiver."

	^ (self left isSolution: anObject) and: [self right isSolution: anObject]! !

!ConjunctionConnective methodsFor: 'arithmetic' stamp: 'len 12/18/97 19:49'!
not
	"Answer the negation of the receiver."

	^ self left not | self right not! !

!ConjunctionConnective methodsFor: 'printing' stamp: 'len 6/2/2016 01:34'!
operatorName
	^ '&'! !

!DisjunctionConnective methodsFor: 'testing' stamp: 'len 12/18/97 19:44'!
isSolution: anObject
	"Answer true if the argument is solution of the receiver."

	^ (self left isSolution: anObject) or: [self right isSolution: anObject]! !

!DisjunctionConnective methodsFor: 'arithmetic' stamp: 'len 12/18/97 19:50'!
not
	"Answer the negation of the receiver."

	^ self left not & self right not! !

!DisjunctionConnective methodsFor: 'printing' stamp: 'len 6/2/2016 01:34'!
operatorName
	^ '|'! !

!ImplicationConnective methodsFor: 'testing' stamp: 'len 12/18/97 19:47'!
isSolution: anObject
	"Answer true if the argument is solution of the receiver."

	^ (self left isSolution: anObject) = (self right isSolution: anObject)! !

!ImplicationConnective methodsFor: 'arithmetic' stamp: 'len 12/18/97 19:52'!
not
	"Answer the negation of the receiver."

	^ self left -> self right not! !

!ImplicationConnective methodsFor: 'printing' stamp: 'len 6/2/2016 00:28'!
operatorName
	^ '->'! !

!PolynomialEquation methodsFor: 'arithmetic' stamp: 'len 12/18/97 19:56'!
& anObject
	"Answer the conjunction of the receiver with the argument."

	^ ConjunctionConnective left: self right: anObject! !

!PolynomialEquation methodsFor: 'arithmetic' stamp: 'len 12/18/97 19:57'!
-> anObject
	"Answer the implication of the argument from the receiver."

	^ ImplicationConnective left: self right: anObject! !

!PolynomialEquation methodsFor: 'arithmetic' stamp: 'len 12/18/97 19:56'!
| anObject
	"Answer the disjunction of the receiver with the argument."

	^ DisjunctionConnective left: self right: anObject! !

!PolynomialEquation methodsFor: 'converting' stamp: 'len 3/24/2016 06:20'!
asLinearEquation
	| P V b |
	polynomial isLinear ifFalse: [^ DomainError signal: 'the polynomial is not linear'].
	P _ polynomial species.
	V _ P scalars ** P rank.
	b _ polynomial value: V zero.
	^ (LinearForm from: V evaluating: [:v| (polynomial value: v) - b]) eq: b negated! !

!PolynomialEquation methodsFor: 'accessing' stamp: 'len 12/21/97 21:06'!
bounded
	"Answer the collection of bounded indeterminates."

	^ Set new! !

!PolynomialEquation methodsFor: 'copying' stamp: 'len 12/19/97 02:48'!
copy
	"Answer a copy of the receiver."

	^ self class polynomial: self polynomial copy! !

!PolynomialEquation methodsFor: 'arithmetic' stamp: 'len 12/21/97 21:26'!
exists: anInteger
	"Answer the quantification of the reciever by the
	existential quantifier in the anInteger-th indeterminate."

	^ QuantifiedSentence quantifier: (Quantifier exists: anInteger) matrix: self! !

!PolynomialEquation methodsFor: 'arithmetic' stamp: 'len 12/21/97 21:26'!
forAll: anInteger
	"Answer the quantification of the reciever by the
	universal quantifier in the anInteger-th indeterminate."

	^ QuantifiedSentence quantifier: (Quantifier forAll: anInteger) matrix: self! !

!PolynomialEquation methodsFor: 'accessing' stamp: 'len 12/21/97 21:06'!
free
	"Answer the collection of free indeterminates."

	^ self indeterminates! !

!PolynomialEquation methodsFor: 'accessing' stamp: 'len 12/18/97 20:34'!
indeterminates
	"Answer the indeterminates of the receiver."

	^ self polynomial indeterminates! !

!PolynomialEquation methodsFor: 'testing' stamp: 'len 12/23/2015 00:14'!
isHomogeneous
	^ polynomial isHomogeneous! !

!PolynomialEquation methodsFor: 'testing' stamp: 'len 12/18/97 20:28'!
isQuantifierFree
	"Answer true if the receiver is quantifier-free."

	^ true! !

!PolynomialEquation methodsFor: 'testing' stamp: 'len 11/24/2015 06:16'!
isSolution: anObject
	"Answer true if the argument satisfies the receiver."

	^ (self polynomial value: anObject) isZero! !

!PolynomialEquation methodsFor: 'operations' stamp: 'len 12/26/97 18:46'!
normalized
	"Answer a copy of the receiver with the indeterminates renamed
	such that the same indeterminate does not ocur as free and bound."

	^ self copy! !

!PolynomialEquation methodsFor: 'arithmetic' stamp: 'len 11/19/2015 19:43'!
not
	"Answer the negation of the receiver."

	^ (self polynomial lneq: self polynomial zero)
		| (self polynomial gneq: self polynomial zero)! !

!PolynomialEquation methodsFor: 'accessing' stamp: 'len 7/30/97 23:47'!
polynomial
	"Answer the polynomial that defines the receiver."

	^ polynomial! !

!PolynomialEquation methodsFor: 'accessing-private' stamp: 'len 3/1/2016 19:24'!
polynomial: aPolynomial
	aPolynomial coefficients do: [:each|
		each isRational
			ifFalse: [polynomial _ aPolynomial. ^ self]].
	polynomial _ aPolynomial integerPrimitive! !

!PolynomialEquation methodsFor: 'accessing' stamp: 'len 3/17/2016 04:20'!
polynomials
	"Answer the polynomial set of the receiver."

	^ {self polynomial}! !

!PolynomialEquation methodsFor: 'operations' stamp: 'len 12/31/97 02:26'!
prenex
	"Answer the prenex form of the receiver."

	^ self reduced normalized privatePrenex! !

!PolynomialEquation methodsFor: 'printing' stamp: 'len 6/2/2016 01:43'!
printOn: aStream
	aStream print: self polynomial - self polynomial independentCoefficient; nextPutAll: ' = '; print: self polynomial independentCoefficient negated! !

!PolynomialEquation methodsFor: 'private' stamp: 'len 12/31/97 02:27'!
privatePrenex
	"Answer the prenex form of the receiver.
	Assume the receiver is reduced and normalized."

	^ QuantifiedSentence matrix: self! !

!PolynomialEquation methodsFor: 'operations' stamp: 'len 12/26/97 18:38'!
reduced
	"Answer a copy of the receiver with the redundant quantifiers removed."

	^ self copy! !

!PolynomialEquation methodsFor: 'operations' stamp: 'len 6/1/2016 23:18'!
rename: anInteger to: anotherInteger 
	"Rename the anInteger-th indeterminate of the receiver to anotherInteger."
	self polynomial: (self polynomial rename: anInteger to: anotherInteger)! !

!PolynomialEquation class methodsFor: 'instance creation' stamp: 'len 7/30/97 23:45'!
polynomial: aPolynomial
	"Answer an instance of the receiver representing
	the equation 'aPolynomial = 0'."

	^ self new polynomial: aPolynomial! !

!PolynomialInequality methodsFor: 'arithmetic' stamp: 'len 12/18/97 20:07'!
& anObject
	"Answer the conjunction of the receiver with the argument."

	^ ConjunctionConnective left: self right: anObject! !

!PolynomialInequality methodsFor: 'arithmetic' stamp: 'len 12/18/97 20:07'!
-> anObject
	"Answer the implication of the argument from the receiver."

	^ ImplicationConnective left: self right: anObject! !

!PolynomialInequality methodsFor: 'arithmetic' stamp: 'len 12/18/97 20:07'!
| anObject
	"Answer the disjunction of the receiver with the argument."

	^ DisjunctionConnective left: self right: anObject! !

!PolynomialInequality methodsFor: 'accessing' stamp: 'len 12/21/97 21:06'!
bounded
	"Answer the collection of bounded indeterminates."

	^ Set new! !

!PolynomialInequality methodsFor: 'copying' stamp: 'len 12/19/97 02:47'!
copy
	"Answer a copy of the receiver."

	^ self class polynomial: self polynomial copy! !

!PolynomialInequality methodsFor: 'arithmetic' stamp: 'len 12/21/97 21:26'!
exists: anInteger
	"Answer the quantification of the reciever by the
	existential quantifier in the anInteger-th indeterminate."

	^ QuantifiedSentence quantifier: (Quantifier exists: anInteger) matrix: self! !

!PolynomialInequality methodsFor: 'arithmetic' stamp: 'len 12/21/97 21:27'!
forAll: anInteger
	"Answer the quantification of the reciever by the
	universal quantifier in the anInteger-th indeterminate."

	^ QuantifiedSentence quantifier: (Quantifier forAll: anInteger) matrix: self! !

!PolynomialInequality methodsFor: 'accessing' stamp: 'len 12/21/97 21:07'!
free
	"Answer the collection of free indeterminates."

	^ self indeterminates! !

!PolynomialInequality methodsFor: 'accessing' stamp: 'len 12/18/97 20:34'!
indeterminates
	"Answer the indeterminates of the receiver."

	^ self polynomial indeterminates! !

!PolynomialInequality methodsFor: 'testing' stamp: 'len 12/18/97 20:28'!
isQuantifierFree
	"Answer true if the receiver is quantifier-free."

	^ true! !

!PolynomialInequality methodsFor: 'testing' stamp: 'len 11/24/2015 06:16'!
isSolution: anObject
	"Answer true if the argument satisfies the receiver."

	^ (self polynomial value: anObject) negative! !

!PolynomialInequality methodsFor: 'operations' stamp: 'len 12/26/97 18:46'!
normalized
	"Answer a copy of the receiver with the indeterminates renamed
	such that the same indeterminate does not ocur as free and bound."

	^ self copy! !

!PolynomialInequality methodsFor: 'arithmetic' stamp: 'len 11/19/2015 19:43'!
not
	"Answer the negation of the receiver."

	^ (self polynomial eq: self polynomial zero) |
		(self polynomial gneq: self polynomial zero)! !

!PolynomialInequality methodsFor: 'accessing' stamp: 'len 12/15/97 23:57'!
polynomial
	"Answer the polynomial that defines the receiver."

	^ polynomial! !

!PolynomialInequality methodsFor: 'accessing-private' stamp: 'len 3/1/2016 19:28'!
polynomial: aPolynomial
	aPolynomial coefficients do: [:each|
		each isRational
			ifFalse: [polynomial _ aPolynomial. ^ self]].
	polynomial _ aPolynomial / aPolynomial integerContent abs! !

!PolynomialInequality methodsFor: 'accessing' stamp: 'len 3/17/2016 04:20'!
polynomials
	"Answer the polynomial set of the receiver."

	^ {self polynomial}! !

!PolynomialInequality methodsFor: 'operations' stamp: 'len 12/31/97 02:26'!
prenex
	"Answer the prenex form of the receiver."

	^ self reduced normalized privatePrenex! !

!PolynomialInequality methodsFor: 'printing' stamp: 'len 6/2/2016 01:45'!
printOn: aStream
	"Print a representation of the receiver on the stream aStream."

	| f ineq |
	self polynomial leadingCoefficient negative
		ifTrue: [f _ self polynomial negated. ineq _ ' > ']
		ifFalse: [f _ self polynomial. ineq _ ' < '].
	aStream print: f - f independentCoefficient; nextPutAll: ineq; print: f independentCoefficient negated! !

!PolynomialInequality methodsFor: 'private' stamp: 'len 12/31/97 02:27'!
privatePrenex
	"Answer the prenex form of the receiver.
	Assume the receiver is reduced and normalized."

	^ QuantifiedSentence matrix: self! !

!PolynomialInequality methodsFor: 'operations' stamp: 'len 12/26/97 18:38'!
reduced
	"Answer a copy of the receiver with the redundant quantifiers removed."

	^ self copy! !

!PolynomialInequality methodsFor: 'operations' stamp: 'len 6/1/2016 23:19'!
rename: anInteger to: anotherInteger 
	"Rename the anInteger-th indeterminate of the receiver to anotherInteger."
	self polynomial: (self polynomial rename: anInteger to: anotherInteger)! !

!PolynomialInequality class methodsFor: 'instance creation' stamp: 'len 12/16/97 00:00'!
polynomial: aPolynomial
	"Answer an instance of the receiver representing
	the inequation 'aPolynomial < 0'."

	^ self new polynomial: aPolynomial! !

!QuantifiedSentence methodsFor: 'arithmetic' stamp: 'len 12/21/97 21:09'!
& anObject
	"Answer the conjunction of the receiver with the argument."

	^ ConjunctionConnective left: self right: anObject! !

!QuantifiedSentence methodsFor: 'arithmetic' stamp: 'len 12/21/97 21:09'!
-> anObject
	"Answer the implication of the argument from the receiver."

	^ ImplicationConnective left: self right: anObject! !

!QuantifiedSentence methodsFor: 'arithmetic' stamp: 'len 12/21/97 21:09'!
| anObject
	"Answer the disjunction of the receiver with the argument."

	^ DisjunctionConnective left: self right: anObject! !

!QuantifiedSentence methodsFor: 'accessing' stamp: 'len 2/6/98 12:33'!
add: aQuantifier
	"Add the quantifier aQuantifier to the receiver. Answer aQuantifier."

	^ self prefix add: aQuantifier! !

!QuantifiedSentence methodsFor: 'accessing' stamp: 'len 12/31/97 02:46'!
bounded
	"Answer the collection of bounded indeterminates."

	| answer |
	answer _ self matrix bounded.
	self prefix do: [ :each | answer add: each indeterminate].
	^ answer! !

!QuantifiedSentence methodsFor: 'copying' stamp: 'len 2/14/98 13:31'!
copy
	"Answer a copy of the receiver."

	^ self class
		prefix: (self prefix collect: [ :each | each copy])
		matrix: self matrix copy! !

!QuantifiedSentence methodsFor: 'arithmetic' stamp: 'len 12/21/97 21:24'!
exists: anInteger
	"Answer the quantification of the reciever by the
	existential quantifier in the anInteger-th indeterminate."

	^ self copy add: (Quantifier exists: anInteger); yourself! !

!QuantifiedSentence methodsFor: 'arithmetic' stamp: 'len 2/6/98 12:32'!
forAll: anInteger
	"Answer the quantification of the reciever by the
	universal quantifier in the anInteger-th indeterminate."

	^ self copy add: (Quantifier forAll: anInteger); yourself! !

!QuantifiedSentence methodsFor: 'accessing' stamp: 'len 12/31/97 02:45'!
free
	"Answer the collection of free indeterminates."

	| answer |
	answer _ self indeterminates.
	self bounded do: [ :each | answer remove: each ifAbsent: []].
	^ answer! !

!QuantifiedSentence methodsFor: 'accessing' stamp: 'len 12/19/97 22:00'!
indeterminates
	"Answer the indeterminates set of the receiver."

	| answer |
	answer _ self matrix indeterminates.
	self prefix do: [ :each | answer add: each indeterminate].
	^ answer! !

!QuantifiedSentence methodsFor: 'initialization' stamp: 'len 2/7/98 15:26'!
initialize
	self prefix: OrderedCollection new! !

!QuantifiedSentence methodsFor: 'testing' stamp: 'len 12/21/97 20:42'!
isQuantifierFree
	"Answer true if the receiver is a quantifier-free sentence."

	^ self prefix isEmpty and: [self matrix isQuantifierFree]! !

!QuantifiedSentence methodsFor: 'accessing' stamp: 'len 12/21/97 21:03'!
matrix
	"Answer the matrix of the receiver: the sentence being quantified."

	^ matrix! !

!QuantifiedSentence methodsFor: 'accessing-private' stamp: 'len 12/19/97 21:30'!
matrix: anObject
	matrix _ anObject! !

!QuantifiedSentence methodsFor: 'operations' stamp: 'len 12/26/97 18:47'!
normalized
	"Answer a copy of the receiver with the indeterminates renamed
	such that the same indeterminate does not ocur as free and bound."

	^ self class prefix: self prefix matrix: self matrix normalized! !

!QuantifiedSentence methodsFor: 'arithmetic' stamp: 'len 12/21/97 21:10'!
not
	"Answer the negation of the receiver."

	^ self class prefix: (self prefix collect: [ :each | each not]) matrix: self matrix not! !

!QuantifiedSentence methodsFor: 'accessing' stamp: 'len 12/19/97 21:46'!
polynomials
	"Answer the polynomial set of the receiver."

	^ self matrix polynomials! !

!QuantifiedSentence methodsFor: 'accessing' stamp: 'len 12/21/97 21:02'!
prefix
	"Answer the prefix of the receiver: a collection with quantifiers."

	^ prefix! !

!QuantifiedSentence methodsFor: 'accessing-private' stamp: 'len 12/19/97 21:30'!
prefix: aCollection
	prefix _ aCollection! !

!QuantifiedSentence methodsFor: 'operations' stamp: 'len 12/31/97 02:26'!
prenex
	"Answer the prenex form of the receiver."

	^ self reduced normalized privatePrenex! !

!QuantifiedSentence methodsFor: 'printing' stamp: 'len 5/30/2016 21:36'!
printOn: aStream
	"Print a representation of the receiver on the stream aStream."

	| names |
	names _ self matrix polynomial species indeterminateNames.
	self prefix do: [ :each | | name | each printOn: aStream withNames: names].
	aStream nextPut: $[; print: self matrix; nextPut: $]! !

!QuantifiedSentence methodsFor: 'private' stamp: 'len 12/31/97 02:25'!
privatePrenex
	"Answer the prenex form of the receiver.
	Assume the receiver is reduced and normalized."

	| mp newPrefix newMatrix |
	mp _ self matrix privatePrenex.
	newPrefix _ self prefix copy addAll: mp prefix; yourself.
	newMatrix _ mp matrix.
	^ self class prefix: newPrefix matrix: newMatrix! !

!QuantifiedSentence methodsFor: 'operations' stamp: 'len 12/31/97 02:52'!
reduced
	"Answer a copy of the receiver with the redundant quantifiers removed."

	| indets quantifiers reducedMatrix |
	reducedMatrix _ self matrix reduced.
	indets _ reducedMatrix indeterminates.
	quantifiers _ self prefix select: [ :each | indets includes: each indeterminate].
	^ quantifiers isEmpty
		ifTrue: [reducedMatrix]
		ifFalse: [self class prefix: quantifiers matrix: reducedMatrix]! !

!QuantifiedSentence methodsFor: 'operations' stamp: 'len 12/26/97 18:52'!
rename: anInteger to: anotherInteger
	"Rename the anInteger-th indeterminate of the receiver to anotherInteger."

	self prefix do: [ :each | each rename: anInteger to: anotherInteger].
	self matrix rename: anInteger to: anotherInteger! !

!QuantifiedSentence methodsFor: 'operations' stamp: 'len 2/7/98 19:04'!
resorted
	"Answer a copy of the receiver with the indeterminates resorted and renamed."

	| answer last |
	answer _ self copy.
	last _ 0.
	self prefix do: [ :each | last _ each indeterminate max: last].
	last _ last + 1.
	1 to: self prefix size do: [ :each |
		answer rename: (self prefix at: each) indeterminate to: last + each].
	1 to: self prefix size do: [ :each |
		answer rename: last + each to: each].
	^ answer! !

!QuantifiedSentence methodsFor: 'accessing' stamp: 'len 2/7/98 19:16'!
truth
	"Answer the truth value of the receiver, true or false."

	| prenex cad |
	prenex _ self prenex resorted.
	cad _ SemialgebraicSet cad: prenex polynomials.
	^ prenex truthRestrictedTo: cad! !

!QuantifiedSentence methodsFor: 'private' stamp: 'len 2/7/98 18:52'!
truthRestrictedTo: aSemialgebraicSet
	"Answer the truth value of the receiver, true or false,
	when restricted to aSemialgebraicSet. Assume that the
	receiver is in prenex form."

	| sentence quantifier |
	aSemialgebraicSet isEmpty
		ifTrue: [self prefix do: [ :each | each isExistential ifTrue: [^ false]].
				^ true].
	self isQuantifierFree
		ifTrue: [aSemialgebraicSet do: [ :each |
					(self matrix isSolution: each sample) ifFalse: [^ false]].
				^ true].
	sentence _ self class prefix: (self prefix copy removeFirst; yourself) matrix: self matrix.
	quantifier _ self prefix first.
	^ quantifier isExistential
		ifTrue: [(aSemialgebraicSet projectionAt: quantifier indeterminate)
					do: [ :each |
						(sentence truthRestrictedTo: (aSemialgebraicSet cylinderAt: each))
							ifTrue: [^ true]].
				false]
		ifFalse: [(aSemialgebraicSet projectionAt: quantifier indeterminate)
					do: [ :each |
						(sentence truthRestrictedTo: (aSemialgebraicSet cylinderAt: each))
							ifFalse: [^ false]].
				true]! !

!QuantifiedSentence class methodsFor: 'instance creation' stamp: 'len 2/5/98 20:29'!
matrix: anObject
	"Answer a new instance of the receiver with no
	quantifiers and with the matrix given by the argument."

	^ self new matrix: anObject! !

!QuantifiedSentence class methodsFor: 'instance creation' stamp: 'len 12/19/97 21:32'!
new
	^ super new initialize! !

!QuantifiedSentence class methodsFor: 'instance creation' stamp: 'len 2/5/98 20:32'!
prefix: aCollection matrix: anObject
	"Answer a new instance of the receiver with
	the prefix and matrix given by the arguments."

	| answer |
	answer _ self matrix: anObject.
	answer prefix addAll: aCollection.
	^ answer! !

!QuantifiedSentence class methodsFor: 'instance creation' stamp: 'len 6/1/2016 23:15'!
quantifier: aQuantifier matrix: anObject
	"Answer a new instance of the receiver with the quantifier and matrix given by the arguments."

	^ self prefix: {aQuantifier} matrix: anObject! !

!Quantifier methodsFor: 'copying' stamp: 'len 2/14/98 13:30'!
copy
	"Answer a copy of the receiver."

	^ self class indeterminate: self indeterminate! !

!Quantifier methodsFor: 'accessing' stamp: 'len 12/18/97 20:35'!
indeterminate
	"Answer the quantified indeterminate of the reiceiver."

	^ indeterminate! !

!Quantifier methodsFor: 'accessing-private' stamp: 'len 12/18/97 20:18'!
indeterminate: anInteger
	indeterminate _ anInteger! !

!Quantifier methodsFor: 'testing' stamp: 'len 2/5/98 21:26'!
isExistential
	"Answer true if the receiver is an existential quantifier."
	^ false! !

!Quantifier methodsFor: 'testing' stamp: 'len 2/5/98 21:27'!
isUniversal
	"Answer true if the receiver is an universal quantifier."
	^ false! !

!Quantifier methodsFor: 'printing' stamp: 'len 5/30/2016 09:19'!
printOn: aStream
	"Print a representation of the receiver on the stream aStream."

	self printOn: aStream withNames: Dictionary new! !

!Quantifier methodsFor: 'printing' stamp: 'len 12/31/97 03:02'!
printOn: aStream withNames: aDictionary
	"Print a representation of the receiver on the stream aStream
	using the indeterminate names from aDictionary."

	self subclassResponsibility! !

!Quantifier methodsFor: 'operations' stamp: 'len 12/26/97 18:53'!
rename: anInteger to: anotherInteger
	"Rename the anInteger-th indeterminate of the receiver to anotherInteger."

	self indeterminate = anInteger ifTrue: [self indeterminate: anotherInteger]! !

!Quantifier class methodsFor: 'instance creation' stamp: 'len 12/19/97 21:50'!
exists: anInteger
	"Answer the existential quantifier in the anInteger-th indeterminate."

	^ ExistentialQuantifier indeterminate: anInteger! !

!Quantifier class methodsFor: 'instance creation' stamp: 'len 12/19/97 21:50'!
forAll: anInteger
	"Answer the universal quantifier in the anInteger-th indeterminate."

	^ UniversalQuantifier indeterminate: anInteger! !

!Quantifier class methodsFor: 'instance creation' stamp: 'len 12/19/97 21:35'!
indeterminate: anInteger
	"Answer a new instance of the receiver representing
	the quantifier in the anInteger-th indeterminate."

	^ self new indeterminate: anInteger! !

!ExistentialQuantifier methodsFor: 'testing' stamp: 'len 2/5/98 21:28'!
isExistential
	"Answer true if the receiver is an existential quantifier."
	^ true! !

!ExistentialQuantifier methodsFor: 'arithmetic' stamp: 'len 12/21/97 21:13'!
not
	"Answer the negation of the receiver."

	^ UniversalQuantifier indeterminate: self indeterminate! !

!ExistentialQuantifier methodsFor: 'printing' stamp: 'len 5/31/2016 05:42'!
printOn: aStream withNames: aDictionary
	"Print a representation of the receiver on the stream aStream
	using the indeterminate names from aDictionary."

	| name |
	name _ aDictionary
				at: self indeterminate
				ifAbsent: ['x' asText, self indeterminate printString sub].
	aStream nextPut: Character exists; nextPutAll: name! !

!UniversalQuantifier methodsFor: 'testing' stamp: 'len 2/5/98 21:27'!
isUniversal
	"Answer true if the receiver is an universal quantifier."
	^ true! !

!UniversalQuantifier methodsFor: 'arithmetic' stamp: 'len 12/21/97 21:13'!
not
	"Answer the negation of the receiver."

	^ ExistentialQuantifier indeterminate: self indeterminate! !

!UniversalQuantifier methodsFor: 'printing' stamp: 'len 5/31/2016 05:43'!
printOn: aStream withNames: aDictionary
	"Print a representation of the receiver on the stream aStream
	using the indeterminate names from aDictionary."

	| name |
	name _ aDictionary
				at: self indeterminate
				ifAbsent: ['x' asText, self indeterminate printString sub].
	aStream nextPut: Character forAll; nextPutAll: name! !

!YoungDiagram methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 03:17'!
hookLengthAt: aPoint
	| answer |
	answer _ (shape at: aPoint x) - aPoint y. "boxes to the right"
	aPoint x + 1 to: shape size do: [:i|
		(shape at: i) >= aPoint y
			ifFalse: [^ answer].
		answer _ answer + 1].
	^ answer! !

!YoungDiagram methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 03:20'!
printOn: aStream
	self shape do: [:k|
		aStream nextPut: $[.
		(1 to: k) do: [:ignore| aStream space] separatedBy: [aStream nextPut: $|].
		aStream nextPut: $]] separatedBy: [aStream cr; space]! !

!YoungDiagram methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 03:12'!
shape
	^ shape! !

!YoungDiagram methodsFor: 'as yet unclassified' stamp: 'len 8/1/2016 03:12'!
shape: aPartition
	shape _ aPartition! !

!YoungDiagram class methodsFor: 'instance creation' stamp: 'len 8/1/2016 03:13'!
shape: aPartition
	^ self new shape: aPartition! !

!Simplex methodsFor: 'comparing' stamp: 'len 6/13/2016 09:34'!
< aSimplex
	"Answer true if the receiver is strictly contained in aSimplex as a face."
	^ aSimplex > self! !

!Simplex methodsFor: 'comparing' stamp: 'len 6/13/2016 09:33'!
<= aSimplex
	"Answer true if the receiver is contained in aSimplex as a face."
	^ aSimplex >= self! !

!Simplex methodsFor: 'comparing' stamp: 'len 3/3/2016 23:32'!
= aSimplex
	| ip p |
	points isEmpty ifTrue: [^ aSimplex points isEmpty].
	p _ points first.
	ip _ aSimplex points indexOf: p ifAbsent: [^ false].
	points withIndexDo: [:each :i|
		each = (aSimplex points atWrap: i+ip-1) ifFalse: [^ false]].
	^ true! !

!Simplex methodsFor: 'comparing' stamp: 'len 6/13/2016 09:33'!
> aSimplex
	"Answer true if the receiver strictly containes aSimplex as a face."
	^ self dimension > aSimplex dimension and: [points includesAllOf: aSimplex points]! !

!Simplex methodsFor: 'comparing' stamp: 'len 6/13/2016 09:33'!
>= aSimplex
	"Answer true if the receiver containes aSimplex as a face."
	^ self dimension >= aSimplex dimension and: [points includesAllOf: aSimplex points]! !

!Simplex methodsFor: 'morphisms' stamp: 'len 9/1/2016 07:55'!
 aSimplex
	"Answer the face common to the receiver and aSimplex, which could be {}."
	^ self class points: (self points  aSimplex points)! !

!Simplex methodsFor: 'converting' stamp: 'len 5/25/2016 03:46'!
asSkeletonGraph
	| graph |
	graph _ Graph unordered.
	graph addAll: self facets.
	self facets do: [:x|
		self facets do: [:y|
			graph addEdgeFrom: x to: y]].
	^ graph! !

!Simplex methodsFor: 'morphisms' stamp: 'len 6/13/2016 00:11'!
boundary
	"Answer the union of all facets of the receiver. The boundary of a n-simplex is a (n-1)-chain with coefficients 1 and -1."
	| answer |
	answer _ SimplicialChain new.
	1 to: points size do: [:i|
		answer coefficientAt: (self class points: (points copyWithoutIndex: i)) add: (-1)**i].
	^ answer! !

!Simplex methodsFor: 'morphisms' stamp: 'len 6/11/2016 23:57'!
closure
	| simplices |
	simplices _ Set with: self.
	-1 to: self dimension do: [:i|
		self faces: i do: [:each| simplices add: each]].
	^ SimplicialComplex newFrom: simplices! !

!Simplex methodsFor: 'accessing' stamp: 'len 2/23/2016 03:04'!
dimension
	^ points size - 1! !

!Simplex methodsFor: 'subobjects' stamp: 'len 2/23/2016 02:02'!
edges
	^ self faces: 1! !

!Simplex methodsFor: 'subobjects' stamp: 'len 6/13/2016 00:00'!
faces
	"Answer all faces of the receiver (including the empty set and the receiver)."
	^ Iterator on: [:aBlock| self facesDo: aBlock]! !

!Simplex methodsFor: 'subobjects' stamp: 'len 2/23/2016 02:00'!
faces: m
	^ Iterator on: [:aBlock| self faces: m do: aBlock]! !

!Simplex methodsFor: 'subobjects' stamp: 'len 6/13/2016 00:40'!
faces: m do: aBlock
	"Iterate over the m-faces of the receiver."
	m = -1 ifTrue: [^ aBlock value: (self class points: #())].
	points isEmpty ifTrue: [^ self].
	points combinations: m+1 atATimeDo: [:each|
		aBlock value: (self class points: each copy)]! !

!Simplex methodsFor: 'subobjects' stamp: 'len 6/12/2016 23:59'!
facesDo: aBlock
	"Iterate over all faces of the receiver (including the empty set and the receiver)."
	-1 to: self dimension do: [:i| self faces: i do: aBlock]! !

!Simplex methodsFor: 'subobjects' stamp: 'len 6/13/2016 00:09'!
facets
	"Answer the boundary faces of the receiver."
	^ self faces: self dimension - 1! !

!Simplex methodsFor: 'comparing' stamp: 'len 6/12/2016 21:37'!
hash
	^ points inject: self class hash into: [:sum :each| sum + each hash hashMultiply]! !

!Simplex methodsFor: 'morphisms' stamp: 'len 6/13/2016 00:16'!
interior
	"Answer the interior of the receiver (sometimes called 'open simplex')."
	^ (SimplicialChain with: self) - self boundary! !

!Simplex methodsFor: 'testing' stamp: 'len 5/9/2016 21:05'!
isTrivial
	^ points isEmpty! !

!Simplex methodsFor: 'arithmetic' stamp: 'len 6/13/2016 00:08'!
negated
	"Answer the oppositely oriented simplex."
	^ self opposite! !

!Simplex methodsFor: 'morphisms' stamp: 'len 6/13/2016 00:08'!
opposite
	"Answer the oppositely oriented simplex."
	^ self class points: (points copy swap: 1 with: 2; yourself)! !

!Simplex methodsFor: 'accessing' stamp: 'len 2/23/2016 01:38'!
points
	^ points! !

!Simplex methodsFor: 'accessing-private' stamp: 'len 2/23/2016 01:38'!
points: aCollection
	points _ aCollection! !

!Simplex methodsFor: 'printing' stamp: 'len 4/23/2016 05:25'!
printOn: aStream
"	aStream print: self dimension; nextPutAll: '-simplex '."
	self shortPrintOn: aStream! !

!Simplex methodsFor: 'subobjects' stamp: 'len 6/12/2016 23:59'!
properFaces
	"Answer all proper faces of the receiver of any dimension (including the empty set)."
	^ Iterator on: [:aBlock| self properFacesDo: aBlock]! !

!Simplex methodsFor: 'subobjects' stamp: 'len 6/12/2016 23:59'!
properFacesDo: aBlock
	"Iterate over all proper faces of the receiver (including the empty set)."
	-1 to: self dimension - 1 do: [:i| self faces: i do: aBlock]! !

!Simplex methodsFor: 'subobjects' stamp: 'len 2/27/2016 08:15'!
ridges
	^ self faces: self dimension - 2! !

!Simplex methodsFor: 'printing' stamp: 'len 4/21/2016 04:05'!
shortPrintOn: aStream
	aStream nextPut: ${.
	self points do: [:each| aStream print: each] separatedBy: [aStream nextPut: $,].
	aStream nextPut: $}! !

!Simplex methodsFor: 'subobjects' stamp: 'len 2/23/2016 02:01'!
vertices
	^ self faces: 0! !

!Simplex methodsFor: 'accessing' stamp: 'len 2/23/2016 02:13'!
volume
	^ self notYetImplemented "see wikipedia"! !

!Simplex class methodsFor: 'instance creation' stamp: 'len 6/13/2016 00:53'!
new: n
	"Answer the standard n-simplex {1,...,n}."
	^ self points: (1 to: n+1)! !

!Simplex class methodsFor: 'instance creation' stamp: 'len 4/23/2016 05:21'!
newFrom: aCollection
	^ self points: aCollection! !

!Simplex class methodsFor: 'instance creation' stamp: 'len 3/1/2016 02:13'!
points: aCollection
	^ self new points: aCollection! !

!BerlekampMassey methodsFor: 'as yet unclassified' stamp: 'len 3/22/2016 23:58'!
run
	| F Fx x C L N m B d b s |
	x _ Fx x.
	C _ Fx one.
	L _ 0. "current number of errors"
	N _ 100. "total number of syndromes"
	B _ C.
	b _ F one. "copy of the last discrepancy d"
	m _ 1. "number of iterations since last update"
	0 to: N do: [:n|
		"calculate discrepancy:"
		d _ (s coefficientAtDegree: n) + ((1 to: L) sum: [:i| (C coefficientAtDegree: i) * (s coefficientAtDegree: n-i)]).
		d = 0
			ifTrue: [m _ m + 1]
			ifFalse: [2*L <= n
				ifTrue:
					[|t|
					t _ C.
					C _ C - ((x**m)*(d/b)*B).
					B _ t.
					L _ n + 1 - L.
					b _ d.
					m _ 1]
				ifFalse:
					[C _ C - ((x**m)*(d/b)*B).
					m _ m + 1]]].
	^ L! !

!CRT methodsFor: 'initialization' stamp: 'len 3/21/2016 03:02'!
moduli: anArray
	| one k mj p euclid d |
	moduli _ anArray.
	"Precomputations:"
	one _ moduli first one.
	k _ moduli size.
	C _ Array new: k.
	C at: 1 put: one.
	2 to: k do: [:j|
		mj _ moduli at: j.
		p _ one. 1 to: j-1 do: [:i| p _ p * (moduli at: i) \\ mj].
		euclid _ ExtendedEuclid on: {p. mj}.
		d _ euclid gcd.
		d ~= one ifTrue: [^ self error: 'the moduli are not coprime'].
		euclid verify ifFalse: [self error: 'failed'].
		C at: j put: euclid combination first]! !

!CRT methodsFor: 'computing' stamp: 'len 12/24/2015 00:05'!
solutionFor: remainders
	| k mj y yj x |
	k _ moduli size.
	y _ Array new: k.
	y at: 1 put: (remainders at: 1) \\ (moduli at: 1).
	2 to: k do: [:j|
		mj _ moduli at: j.
		yj _ y at: j-1.
		j-2 to: 1 by: -1 do: [:i| yj _ yj * (moduli at: i) + (y at: i) \\ mj].
		yj _ ((remainders at: j) - yj) * (C at: j) \\ mj.
		y at: j put: yj].
	x _ y at: k.
	k-1 to: 1 by: -1 do: [:i| x _ x * (moduli at: i) + (y at: i)].
	^ x "it would be more correct to return the residue class mod m1*m2*..*mk"! !

!CRT class methodsFor: 'instance creation' stamp: 'len 2/23/2016 22:44'!
mod: anArray
	^ self new moduli: anArray! !

!DFT methodsFor: 'as yet unclassified' stamp: 'len 5/12/2016 08:20'!
value: aTuple
	^ ring tuple: n evaluating: [:k| (1 to: n) sum: [:j| (aTuple at: j) * (alpha ** (j*k))]]! !

!ExtendedEuclid methodsFor: 'accessing' stamp: 'len 12/23/2015 20:10'!
combination
	combination isNil ifTrue: [self run].
	^ combination! !

!ExtendedEuclid methodsFor: 'accessing-private' stamp: 'len 12/23/2015 20:09'!
elements: anArray
	elements _ anArray! !

!ExtendedEuclid methodsFor: 'accessing' stamp: 'len 12/23/2015 19:49'!
gcd
	gcd isNil ifTrue: [self run].
	^ gcd! !

!ExtendedEuclid methodsFor: 'printing' stamp: 'len 3/21/2016 00:27'!
printOn: aStream
	(1 to: elements size)
		do: [:i| aStream print: (elements at: i); nextPut: $*; print: (self combination at: i)]
		separatedBy: [aStream nextPutAll: ' + '].
	aStream nextPutAll: ' = '; print: self gcd.
	self verify ifFalse: [aStream nextPutAll: ' (broken)'].
	self verifyMinimal ifFalse: [aStream nextPutAll: ' (not minimal)']! !

!ExtendedEuclid methodsFor: 'private' stamp: 'len 3/21/2016 03:05'!
run
	| a b zero one s t s` t` r r` |
	self assert: elements size = 2.
	a _ elements first. b _ elements second.
	zero _ a zero. one _ a one.
	s _ zero. s` _ one.
	t _ one. t` _ zero.
	a isInteger
		ifTrue: [r _ a abs. r` _ b abs]
		ifFalse: [r _ a. r` _ b].
	[r isZero]
		whileFalse:
			[ | q temp |
			q _ r` // r.
			temp _ r. r _ r` - (q * r). r` _ temp.
			temp _ s. s _ s` - (q * s). s` _ temp.
			temp _ t. t _ t` - (q * t). t` _ temp].
	gcd _ r`.
	a isInteger ifTrue: [s` _ s` * b sign. t` _ t` * a sign].
	(gcd isKindOf: Polynomial) "make the gcd monic, otherwise it's not unique"
		ifTrue:
			[| lc |
			lc _ gcd leadingCoefficient.
			s` _ s` / lc.
			t` _ t` / lc.
			gcd _ gcd / gcd leadingCoefficient].
	combination _ {t`. s`}.
! !

!ExtendedEuclid methodsFor: 'private' stamp: 'len 12/23/2015 20:10'!
verify
	^ (elements * self combination) sum = self gcd! !

!ExtendedEuclid methodsFor: 'private' stamp: 'len 3/6/2016 21:44'!
verify2
	| a b d u v |
	a _ elements at: 1.
	b _ elements at: 2.
	u _ self combination at: 1.
	v _ self combination at: 2.
	d _ self gcd.
	(a abs negated / d < (v * b sign) and: [v * b sign <= 0])
		ifFalse: [^ false].
	b = 0 ifTrue: [^ true].
	(1 <= (u * a sign) and: [u * a sign <= (b abs / d)])
		ifFalse: [^ false].
	^ true! !

!ExtendedEuclid methodsFor: 'private' stamp: 'len 3/29/2016 18:05'!
verifyMinimal
	| a b d u v |
	(elements allSatisfy: [:each| each isInteger]) ifFalse: [^ true].
	a _ elements first.
	b _ elements second.
	d _ self gcd.
	u _ self combination first.
	v _ self combination last.
	a abs / d negated < (v * b sign) ifFalse: [^ false].
	v * b sign <= 0 ifFalse: [^ false].
	1 <= (u * a sign) ifFalse: [^ false].
	u * a sign <= (b abs / d) ifFalse: [^ false].
	^ true! !

!ExtendedEuclid class methodsFor: 'instance creation' stamp: 'len 12/23/2015 20:09'!
on: anArray
	^ self new elements: anArray! !

!LagrangeGaussReduction methodsFor: 'as yet unclassified' stamp: 'len 12/12/2015 21:55'!
computeShortVector
	| innerProduct a b A B t T n r |
	innerProduct _ vectorSpace innerProduct. "Euclidean inner product"

	"Initialization:"
	a _ v1. b _ v2.
	A _ innerProduct value: {a. a}.
	B _ innerProduct value: {b. b}.
	A < B ifTrue: [b _ v1. a _ v2. t _ A. A _ B. B _ t].
	
	["Euclidean step:"
	n _ innerProduct value: {a. b}.
	r _ (n/B) rounded. "nearest integer"
	T _ A - (2*r*n) + (r*r*B).
	T >= B]
		whileFalse:
			[t _ a - (r*b).
			a _ b.
			b _ t.
			A _ B.
			B _ T].
	
	shortVector _ b! !

!LagrangeGaussReduction methodsFor: 'as yet unclassified' stamp: 'len 12/12/2015 21:55'!
shortVector
	shortVector isNil ifTrue: [self computeShortVector].
	^ shortVector! !

!ModifiedBerlekampMassey methodsFor: 'accessing' stamp: 'len 11/29/2015 16:02'!
field: aField
	field _ aField! !

!ModifiedBerlekampMassey methodsFor: 'accessing' stamp: 'len 12/27/2015 05:01'!
input: anArray
	input _ anArray.
	minimalPolynomial _ nil! !

!ModifiedBerlekampMassey methodsFor: 'accessing' stamp: 'len 12/27/2015 04:59'!
minimalPolynomial
	minimalPolynomial isNil ifTrue: [self run].
	^ minimalPolynomial! !

!ModifiedBerlekampMassey methodsFor: 'private' stamp: 'len 12/27/2015 04:59'!
run
	"Modified Berlekamp-Massey from 'The Berlekamp-Massey Algorithm revisited', Nadie Ben Atti, Gema M Diaz-Toca, Henri Lombardi."
	| Fx x R0 R1 V V0 V1 n m |
	n _ input size // 2.
	m _ 2*n - 1.
	Fx _ field polynomials.
	x _ Fx x.
	R0 _ x**(2*n). R1 _ (0 to: m) sum: [:i| x**i*(input at: m-i+1)].
	V0 _ Fx zero. V1 _ Fx one.
	[n <= R1 degree]
		whileTrue:
			[ | division |
			division _ R0 divideBy: R1.
			V _ V0 - (division quotient * V1).
			V0 _ V1. V1 _ V. R0 _ R1. R1 _ division remainder].
	minimalPolynomial _ V1 / V1 leadingCoefficient! !

!NTT methodsFor: 'running' stamp: 'len 5/12/2016 08:57'!
inverseValue: input
	"naive algorithm, O(n^2)"
	^ 1 to: input size :: collect: [:i| 1 to: input size :: sum: [:j| (primitive negated raisedTo: i*j modulo: modulus) * (input at: j) \\ modulus] :: \\ 7]! !

!NTT methodsFor: 'accessing' stamp: 'len 4/25/2016 00:28'!
modulus
	^ modulus! !

!NTT methodsFor: 'initialization' stamp: 'len 4/25/2016 00:29'!
modulus: anInteger
	self modulus: anInteger primitive: anInteger primitiveRoot! !

!NTT methodsFor: 'initialization' stamp: 'len 4/25/2016 00:29'!
modulus: anInteger primitive: anotherInteger
	modulus _ anInteger.
	primitive _ anotherInteger! !

!NTT methodsFor: 'accessing' stamp: 'len 3/23/2016 21:06'!
primitive
	^ primitive! !

!NTT methodsFor: 'running' stamp: 'len 4/25/2016 00:29'!
value: input
	"naive algorithm, O(n^2)"
	^ 1 to: input size :: collect: [:i| 1 to: input size :: sum: [:j| (primitive raisedTo: i*j modulo: modulus) * (input at: j) \\ modulus] :: \\ 7]! !

!NTT class methodsFor: 'instance creation' stamp: 'len 4/25/2016 00:30'!
modulo: anInteger
	"anInteger must be prime"
	^ self new modulus: anInteger! !

!WuRittProcess methodsFor: 'as yet unclassified' stamp: 'len 12/30/2015 05:31'!
characteristicSet
	characteristicSet isNil ifTrue: [self run].
	^ characteristicSet! !

!WuRittProcess methodsFor: 'as yet unclassified' stamp: 'len 12/30/2015 05:30'!
polynomials: aCollection
	polynomials _ aCollection! !

!WuRittProcess methodsFor: 'as yet unclassified' stamp: 'len 9/1/2016 07:51'!
run
	| F G R F` r |
	F _ polynomials.
	G _ Set new. R _ Set new.
	[F _ F  R. F` _ R. R _ Set new.
	[F` notEmpty] whileTrue: ["..."].
	F do: [:f| ((G includes: f) or: [(r _ G pseudoRemainderOf: f) isZero]) ifFalse: [R add: r]].
	R isEmpty] whileFalse.
	^ characteristicSet _ G! !

!AutomaticPalette methodsFor: 'as yet unclassified' stamp: 'len 7/31/2016 04:52'!
at: anObject
	| i n |
	i _ map at: anObject ifAbsentPut: [map size].
	n _ map size.
	^ Color h: i * 360.0 / (n + 1) s: 0.65 v: 0.95! !

!AutomaticPalette methodsFor: 'as yet unclassified' stamp: 'len 7/31/2016 04:44'!
initialize
	map _ Dictionary new! !

!AutomaticPalette class methodsFor: 'as yet unclassified' stamp: 'len 7/31/2016 04:44'!
new
	^ super new initialize! !

!ContinuousPalette methodsFor: 'as yet unclassified' stamp: 'len 8/17/2016 23:35'!
at: aNumber
	| v |
	v _ (aNumber max: min) min: max.
	^ colors at: (colors size - 1 * (v - min) / (max - min)) truncated + 1! !

!ContinuousPalette methodsFor: 'as yet unclassified' stamp: 'len 2/26/2016 06:43'!
colors: anArray
	colors _ anArray! !

!ContinuousPalette methodsFor: 'as yet unclassified' stamp: 'len 8/17/2016 23:33'!
max: aNumber
	max _ aNumber! !

!ContinuousPalette methodsFor: 'as yet unclassified' stamp: 'len 8/17/2016 23:33'!
min: aNumber
	min _ aNumber! !

!ContinuousPalette class methodsFor: 'as yet unclassified' stamp: 'len 8/26/2016 05:56'!
default
	| blue green red |
	red _ QQ polynomials interpolate: {"0 -> 0.0." 40 -> 0. 65 -> 0.8. "90 -> 0." 100 -> 0. 150 -> 0.5. 200 -> 0.9. 215 -> 1. 255 -> 0.95}.
	green _ QQ polynomials interpolate: {0 -> 0.2. 50 -> 0.48. 100 -> 0.68. 150 -> 0.75. 200 -> 0.70. 255 -> 1}.
	blue _ QQ polynomials interpolate: {0 -> 0.5. 35 -> 0.9. 85 -> 0.8. 115 -> 0.7. 150 -> 0.5. 200 -> 0.3. 255 -> 0}.
	^ self new colors: ((0 to: 255) collect: [:x| Color fromArray: ({x < 80 ifTrue: [0] ifFalse: [red value: x]. green value: x. blue value: x} collect: [:y| y abs min: 1.0])]); min: 0.0; max: 1.0! !

!ContinuousPalette class methodsFor: 'as yet unclassified' stamp: 'len 8/18/2016 07:30'!
grayscale
	^ (self new: 100 interpolating: {Color darkGray darker. Color white}) min: 0.0; max: 1.0! !

!ContinuousPalette class methodsFor: 'as yet unclassified' stamp: 'len 8/18/2016 07:21'!
new: anInteger interpolating: anArray
	^ self new colors: ((0 to: anInteger-1) collect: [:i|
			| mu |
			mu _ i * anArray size / (anInteger-1).
			(anArray atPin: mu floor + 1) mixed: mu - mu floor with: (anArray atPin: mu ceiling + 1)])! !

!DiscretePalette methodsFor: 'as yet unclassified' stamp: 'len 2/18/2016 23:38'!
at: anObject
	^ map at: anObject ifAbsentPut: [self newColor]! !

!DiscretePalette methodsFor: 'as yet unclassified' stamp: 'len 2/18/2016 23:42'!
colors: anArray
	colors _ anArray.
	map _ Dictionary new! !

!DiscretePalette methodsFor: 'as yet unclassified' stamp: 'len 7/31/2016 04:32'!
newColor
	| a b answer |
	map size < colors size ifTrue: [^ colors at: map size + 1].
	[a _ colors atRandom.
	[b _ colors atRandom. a = b] whileTrue.
	answer _ a mixed: 0.5 with: b.
	colors includes: answer] whileTrue.
	^ answer! !

!DiscretePalette class methodsFor: 'as yet unclassified' stamp: 'len 2/18/2016 23:42'!
colors: anArray
	^ self new colors: anArray! !

!DiscretePalette class methodsFor: 'as yet unclassified' stamp: 'len 5/2/2016 07:36'!
default
	^ self colors: (#("brightGreen" periwinkle seaGreen hotPink lightYellow cyan lightPink lightOrange  "lightGreen" "lightRed"  "mustard" ) collect: [:each| Color exactColorNamed: each]) "shuffled"! !

!CoxeterDiagram methodsFor: 'as yet unclassified' stamp: 'len 2/11/2016 22:11'!
gramMatrix
	^ matrix collect: [:x| -2 * (Float pi / x) cos]! !

!CoxeterDiagram methodsFor: 'as yet unclassified' stamp: 'len 2/11/2016 22:14'!
isConnected
	^ self notYetImplemented! !

!CoxeterDiagram methodsFor: 'as yet unclassified' stamp: 'len 2/11/2016 22:14'!
isElliptic
	^ self notYetImplemented! !

!CoxeterDiagram methodsFor: 'as yet unclassified' stamp: 'len 2/11/2016 22:41'!
isHyperbolic
	^ (self gramMatrix spectrum count: [:each| each negative]) = 1! !

!CoxeterDiagram methodsFor: 'as yet unclassified' stamp: 'len 2/11/2016 22:22'!
isLannerDiagram
	^ self isConnected and: [self isElliptic not and: [self gramMatrix determinant < 0]]! !

!CoxeterDiagram methodsFor: 'as yet unclassified' stamp: 'len 2/11/2016 22:23'!
isParabolic
	| spectrum |
	spectrum _ self gramMatrix spectrum.
	^ (spectrum occurrencesOf: 0) = 1 and: [spectrum allSatisfy: [:each| each >= 0]]! !

!RootSystem methodsFor: 'accessing' stamp: 'len 5/23/2016 05:00'!
ambient
	"Answer the ambient space of the receiver."
	^ ambient! !

!RootSystem methodsFor: 'accessing-private' stamp: 'len 5/23/2016 05:00'!
ambient: aVectorSpace
	ambient _ aVectorSpace! !

!RootSystem methodsFor: 'roots' stamp: 'len 5/23/2016 05:00'!
coroots
	^ roots collect: [:v| v * 2 / (ambient innerProduct value: {v.v})]! !

!RootSystem methodsFor: 'operations' stamp: 'len 5/23/2016 04:59'!
coxeterElement
	| O answer |
	O _ ambient automorphisms orthogonal.
	answer _ ambient id.
	self simpleRoots do: [:each| answer _ answer @ (O reflectionAt: each)].
	^ answer! !

!RootSystem methodsFor: 'operations' stamp: 'len 5/23/2016 04:59'!
coxeterMatrix
	"Answer the Coxeter matrix of the receiver.
	Given a basis a_i of simple roots, the Coxeter matrix m_ij is defined by <a_i,a_j> = -2 cos(pi / m_ij)."
	| S |
	S _ self normalized simpleRoots.
	^ ambient scalars ** (S size @ S size)
		evaluating: [:i :j| Float pi / ((ambient innerProduct value: {(S at: i). (S at: j)}) / -2) arcCos]! !

!RootSystem methodsFor: 'operations' stamp: 'len 6/18/2016 17:14'!
coxeterNumber
	^ self weylGroup orderOf: self coxeterElement! !

!RootSystem methodsFor: 'roots' stamp: 'len 1/6/2016 05:01'!
degreeOf: aPositiveRoot
	"Answer the degree of the given positive root."
	^ (self simpleRoots coordinatesOf: aPositiveRoot) asArray sum! !

!RootSystem methodsFor: 'operations' stamp: 'len 5/23/2016 04:59'!
dual
	^ self class on: ambient roots: self coroots! !

!RootSystem methodsFor: 'operations' stamp: 'len 2/11/2016 20:59'!
exponents
	"Answer the 'sequence of exponents' of the root system."
	| h |
	self flag: #fix. "complex eigenvalues, but how about finite fields?"
	h _ self coxeterNumber.
	^ self coxeterElement eigenvalues collect: [:each| each log / (Float pi * 2 i / h)]! !

!RootSystem methodsFor: 'testing' stamp: 'len 5/23/2016 04:59'!
isCrystallographic
	^ self roots allSatisfy: [:x|
		self coroots allSatisfy: [:y|
			(ambient innerProduct value: {x. y}) isInteger]]! !

!RootSystem methodsFor: 'testing' stamp: 'len 2/11/2016 21:16'!
isIntegral
	^ self isCrystallographic! !

!RootSystem methodsFor: 'testing' stamp: 'len 2/11/2016 20:46'!
isIrreducible
	^ self coxeterDiagram isConnected! !

!RootSystem methodsFor: 'testing' stamp: 'len 5/23/2016 05:01'!
isNormalized
	^ roots allSatisfy: [:each| (ambient innerProduct value: {each.each}) = 2]! !

!RootSystem methodsFor: 'operations' stamp: 'len 5/20/2016 23:59'!
lattice
	"Answer the root lattice, the Z-submodule spanned by roots of the receiver."
	^ Lattice basis: self simpleRoots! !

!RootSystem methodsFor: 'roots' stamp: 'len 1/6/2016 03:52'!
negativeRoots
	^ self positiveRoots negated! !

!RootSystem methodsFor: 'operations' stamp: 'len 5/23/2016 05:01'!
normalized
	^ self class on: ambient roots: (roots collect: [:x| x * (2 / (ambient innerProduct value: {x.x}))])! !

!RootSystem methodsFor: 'roots' stamp: 'len 6/25/2016 23:08'!
positiveRoots
	| answer |
	answer _ Set new.
	roots do: [:a| (answer includes: a negated)
		ifFalse:
			[answer add: a.
			answer copy do: [:b| (roots includes: a+b) ifTrue: [answer add: b]]]].
	^ answer! !

!RootSystem methodsFor: 'roots' stamp: 'len 1/6/2016 04:51'!
positiveRootsSorted
	^ self positiveRoots asSortedCollection: [:a :b| (self simpleRoots coordinatesOf: b - a) asArray allSatisfy: [:each| each positive]]! !

!RootSystem methodsFor: 'operations' stamp: 'len 2/10/2016 23:01'!
positiveWeylChamber
	"Answer the positive Weyl chamber that is choosen in the receiver to define the positive roots."
	^ self notYetImplemented! !

!RootSystem methodsFor: 'printing' stamp: 'len 2/11/2016 01:34'!
printOn: aStream
	aStream nextPut: ${.
	roots do: [:each| aStream print: each] separatedBy: [aStream nextPut: $,].
	aStream nextPut: $}! !

!RootSystem methodsFor: 'accessing' stamp: 'len 5/23/2016 04:59'!
rank
	^ ambient dimension! !

!RootSystem methodsFor: 'accessing' stamp: 'len 1/6/2016 04:46'!
roots
	^ roots! !

!RootSystem methodsFor: 'accessing-private' stamp: 'len 2/11/2016 19:21'!
roots: aCollection
	roots _ aCollection! !

!RootSystem methodsFor: 'roots' stamp: 'len 5/23/2016 04:59'!
simpleRoots
	| answer |
	answer _ LinearBasis on: ambient.
	self positiveRoots do: [:v|
		(answer generates: v) ifFalse: [answer add: v].
		answer size = self rank ifTrue: [^ answer]].
	^ answer! !

!RootSystem methodsFor: 'operations' stamp: 'len 1/7/2016 05:07'!
weightLattice
	"Answer the lattice spanned by the weights of the receiver. This lattice is invariant under the Weyl group and also under the map v -> -v. Also, the root lattice is contained in the weight lattice."
	^ Lattice basis: self weights! !

!RootSystem methodsFor: 'operations' stamp: 'len 1/7/2016 05:42'!
weights
	"Answer the fundamental weights of the receiver.
	A vector v is integral iff it can be expressed as integer linear combination of the fundamental weights."
	^ self notYetImplemented! !

!RootSystem methodsFor: 'operations' stamp: 'len 4/19/2016 03:43'!
weylAction
	| W |
	W _ self weylGroup.
	W name: 'W'.
	^ GroupAction from: (W, self roots) to: self roots evaluating: [:each| each first value: each second]! !

!RootSystem methodsFor: 'operations' stamp: 'len 6/18/2016 17:22'!
weylGroup
	"Answer the Weyl group of the root system, i.e. the (finite) group of isometries of the ambient vector space generated by reflections through hyperplanes perpendicular to the roots. The Weyl group W(R) is the subgroup of GL(V) (and more specifically O(V)) generated by the reflections {s_r} that act on each root r by -1: s_r(r) = -r."
	| O W |
	O _ ambient automorphisms orthogonal.
	W _ Group compositive generators: (self roots collect: [:each| O reflectionAt: each]).
"	W name: 'W'."
	^ W! !

!RootSystem methodsFor: 'operations' stamp: 'len 1/6/2016 00:00'!
weylVector
	^ self positiveRoots sum / 2! !

!RootSystem class methodsFor: 'examples' stamp: 'len 7/14/2016 00:09'!
A: V
	| roots |
	roots _ Set new.
	1 to: V dimension do: [:i|
		i to: V dimension do: [:j|
			roots add: (V e: i) - (V e: j)]].
	^ self on: V roots: roots! !

!RootSystem class methodsFor: 'examples' stamp: 'len 7/14/2016 00:09'!
B: V
	| roots |
	roots _ Set new.
	1 to: V dimension do: [:i|
		roots add: (V e: i).
		i to: V dimension do: [:j|
			roots add: (V e: i) - (V e: j); add: (V e: i) + (V e: j)]].
	^ self on: V roots: roots! !

!RootSystem class methodsFor: 'examples' stamp: 'len 7/14/2016 00:09'!
C: V
	| roots |
	roots _ Set new.
	1 to: V dimension do: [:i|
		roots add: (V e: i)*2.
		i to: V dimension do: [:j|
			roots add: (V e: i) - (V e: j); add: (V e: i) + (V e: j)]].
	^ self on: V roots: roots! !

!RootSystem class methodsFor: 'examples' stamp: 'len 7/14/2016 00:09'!
D: V
	| roots |
	roots _ Set new.
	1 to: V dimension do: [:i|
		i to: V dimension do: [:j|
			roots add: (V e: i) - (V e: j); add: (V e: i) + (V e: j)]].
	^ self on: V roots: roots! !

!RootSystem class methodsFor: 'examples' stamp: 'len 7/15/2016 18:37'!
example1
	"This is a normalized root system in R^n. The Weyl group associated to it is the symmetric group S_n."
	| V roots |
	V _ QQ ** 3.
	roots _ Set new.
	1 to: V dimension do: [:i|
		1 to: i-1 do: [:j|
			roots add: (V e: i) - (V e: j); add: (V e: j) - (V e: i)]].
	^ RootSystem on: V roots: roots! !

!RootSystem class methodsFor: 'examples' stamp: 'len 4/29/2016 07:51'!
example2
	"This is a normalized root system in R^n. The Weyl group associated to it is the hyperoctahedral group."
	| V roots |
	V _ RealAlgebraicNumbers new ** 3.
	roots _ Set new.
	1 to: V dimension do: [:i|
		1 to: i-1 do: [:j|
			roots
				add: (V e: i) * (RealAlgebraicNumber sqrt: 2);
				add: (V e: i) * (RealAlgebraicNumber sqrt: 2) negated;
				add: (V e: i) - (V e: j);
				add: (V e: j) - (V e: i);
				add: (V e: i) + (V e: j);
				add: ((V e: i) + (V e: j)) negated]].
	^ RootSystem on: V roots: roots! !

!RootSystem class methodsFor: 'examples' stamp: 'len 7/15/2016 18:37'!
example3
	"This is a normalized root system in R^n. The Weyl group associated to it is an index 2 subgroup of the hyperoctahedral group."
	| V roots |
	V _ QQ ** 3.
	roots _ Set new.
	1 to: 3 do: [:i|
		1 to: i-1 do: [:j|
			roots
				add: (V e: i) - (V e: j);
				add: (V e: j) - (V e: i);
				add: (V e: i) + (V e: j);
				add: ((V e: i) + (V e: j)) negated]].
	^ RootSystem on: V roots: roots! !

!RootSystem class methodsFor: 'examples' stamp: 'len 7/15/2016 18:37'!
hexagonal
	^ self A: QQ ** 2! !

!RootSystem class methodsFor: 'instance creation' stamp: 'len 5/23/2016 05:00'!
on: aVectorSpace roots: aCollection
	^ self new ambient: aVectorSpace; roots: aCollection! !

!Expression methodsFor: 'as yet unclassified' stamp: 'len 3/22/2016 21:16'!
* anExpression
	| expression |
	expression _ (anExpression isKindOf: Expression)
		ifTrue: [anExpression] ifFalse: [ConstantExpression new constant: anExpression].
	(expression isKindOf: ConstantExpression)
		ifTrue: [expression value = 0 ifTrue: [^ expression].
					expression value = 1 ifTrue: [^ self]].
	^ ProductExpression new factors: {self. expression}! !

!Expression methodsFor: 'as yet unclassified' stamp: 'len 3/22/2016 18:29'!
+ anExpression
	| expression |
	expression _ (anExpression isKindOf: Expression)
		ifTrue: [anExpression] ifFalse: [ConstantExpression new constant: anExpression].
	^ SumExpression new terms: {self. expression}! !

!Expression methodsFor: 'as yet unclassified' stamp: 'len 3/22/2016 18:22'!
- anExpression
	^ self + anExpression negated! !

!Expression methodsFor: 'as yet unclassified' stamp: 'len 3/22/2016 18:24'!
negated
	^ self * -1! !

!Expression methodsFor: 'as yet unclassified' stamp: 'len 3/22/2016 18:37'!
value
	^ self value: Dictionary new! !

!Expression methodsFor: 'as yet unclassified' stamp: 'len 3/22/2016 18:37'!
value: aDictionary
	^ self subclassResponsibility! !

!Expression class methodsFor: 'as yet unclassified' stamp: 'len 7/27/2016 00:02'!
constant: anObject
	^ ConstantExpression constant: anObject! !

!ConstantExpression methodsFor: 'as yet unclassified' stamp: 'len 3/22/2016 21:09'!
* anExpression
	constant isZero ifTrue: [^ self].
	constant = 1 ifTrue: [^ anExpression].
	^ super * anExpression! !

!ConstantExpression methodsFor: 'as yet unclassified' stamp: 'len 3/22/2016 21:07'!
+ anExpression
	constant isZero ifTrue: [^ anExpression].
	^ super + anExpression! !

!ConstantExpression methodsFor: 'as yet unclassified' stamp: 'len 3/22/2016 18:29'!
constant: anObject
	constant _ anObject! !

!ConstantExpression methodsFor: 'as yet unclassified' stamp: 'len 3/22/2016 18:29'!
printOn: aStream
	aStream print: constant! !

!ConstantExpression methodsFor: 'as yet unclassified' stamp: 'len 3/22/2016 18:36'!
value: aDictionary
	^ constant! !

!ConstantExpression class methodsFor: 'as yet unclassified' stamp: 'len 7/27/2016 00:02'!
constant: anObject
	^ self new constant: anObject! !

!FunctionExpression methodsFor: 'as yet unclassified' stamp: 'len 3/22/2016 18:20'!
arguments: aCollection
	arguments _ aCollection! !

!FunctionExpression methodsFor: 'as yet unclassified' stamp: 'len 3/22/2016 18:20'!
function: aFunction
	function _ aFunction! !

!FunctionExpression methodsFor: 'as yet unclassified' stamp: 'len 3/22/2016 18:17'!
printOn: aStream
	aStream print: function; nextPut: $(.
	arguments do: [:each| aStream print: each] separatedBy: [aStream nextPut: $,].
	aStream nextPut: $)! !

!FunctionExpression methodsFor: 'as yet unclassified' stamp: 'len 3/22/2016 18:38'!
value: aDictionary
	^ function value: (arguments collect: [:each| each value: aDictionary])! !

!PowerExpression methodsFor: 'as yet unclassified' stamp: 'len 7/27/2016 00:01'!
printOn: aStream
	aStream nextPut: $(; print: base; nextPut: $).
	exponent printString = '1'
		ifTrue: [^ self].
	aStream isText
		ifTrue: [aStream nextPutAll: exponent super. ^ self].
	aStream nextPut: $^.
	exponent size = 1
		ifTrue: [aStream nextPutAll: exponent]
		ifFalse: [aStream nextPut: ${; nextPutAll: exponent; nextPut: $}]! !

!ProductExpression methodsFor: 'as yet unclassified' stamp: 'len 3/22/2016 18:20'!
factors: aCollection
	factors _ aCollection! !

!ProductExpression methodsFor: 'as yet unclassified' stamp: 'len 3/22/2016 21:12'!
printOn: aStream
	factors do: [:each| each printString isAlphaNumeric ifTrue: [aStream print: each] ifFalse: [aStream nextPut: $(; print: each; nextPut: $)]]! !

!ProductExpression methodsFor: 'as yet unclassified' stamp: 'len 3/22/2016 18:37'!
value: aDictionary
	^ factors product: [:each| each value: aDictionary]! !

!SumExpression methodsFor: 'as yet unclassified' stamp: 'len 3/22/2016 18:15'!
printOn: aStream
	terms do: [:each| aStream print: each] separatedBy: [aStream nextPutAll: ' + ']! !

!SumExpression methodsFor: 'as yet unclassified' stamp: 'len 3/22/2016 18:19'!
terms: aCollection
	terms _ aCollection! !

!SumExpression methodsFor: 'as yet unclassified' stamp: 'len 3/22/2016 18:38'!
value: aDictionary
	^ terms sum: [:each| each value: aDictionary]! !

!VariableExpression methodsFor: 'as yet unclassified' stamp: 'len 3/22/2016 18:25'!
name: aString
	name _ aString! !

!VariableExpression methodsFor: 'as yet unclassified' stamp: 'len 3/22/2016 18:25'!
printOn: aStream
	aStream nextPutAll: name! !

!VariableExpression methodsFor: 'as yet unclassified' stamp: 'len 3/22/2016 18:36'!
value: aDictionary
	^ aDictionary at: name ifAbsent: [self]! !

!DocumentationGenerator methodsFor: 'as yet unclassified' stamp: 'len 8/18/2016 03:30'!
copy: aString replaceAll: oldSubstring with: newSubstring
	^ aString lines
		collect: [:each| (each includesSubString: 'http') ifTrue: [each] ifFalse: [each copyReplaceTokens: oldSubstring with: newSubstring]]
		andFold: [:a :b| a, Character lf asString, b]! !

!DocumentationGenerator methodsFor: 'as yet unclassified' stamp: 'len 9/3/2016 07:17'!
escape: aString
	| output |
	output _ aString.
	'\[]*{}#<>' do: [:each|
"	'\[]*_{}()#<>' do: [:each|"
		(output includes: each) ifTrue: [output _ output copyReplaceAll: each asString with: '\', each asString]].
	output _ output copyReplaceAll: Character tab asString with: '&nbsp;&nbsp;&nbsp;&nbsp;'.
	output _ output copyReplaceAll: Character oplus asString with: '&oplus;'.
	^ output! !

!DocumentationGenerator methodsFor: 'as yet unclassified' stamp: 'len 10/9/2016 21:22'!
generate
	| blacklist classes |
	blacklist _ #('Mathematics-Kernel-Elements' 'Mathematics-Geometry-Polytopes' 'Mathematics-Morphic' 'Mathematics-Lie' 'Mathematics-Expressions' 'Mathematics-ETC' 'Mathematics-Kernel-Categories').
	classes _ Object withAllSubclasses select: [:each| each class ~= Metaclass and: [(each allSuperclasses includes: Morph) not and: [(each category beginsWith: 'Mathematics-') and: [(blacklist includes: each category) not]]]].
	self generateForClasses: classes! !

!DocumentationGenerator methodsFor: 'as yet unclassified' stamp: 'len 8/18/2016 02:57'!
generate: comment references: tokens
	^ self generate: comment references: tokens except: nil! !

!DocumentationGenerator methodsFor: 'as yet unclassified' stamp: 'len 9/3/2016 07:12'!
generate: aString references: tokens except: currentToken
	| output |
	output _ self escape: aString.
	tokens do: [:each|
		output _ self copy: output replaceAll: each with: '[',each,'](',each,')'.
		(tokens includes: each, 's') ifFalse:
			[output _ self copy: output replaceAll: each, 's' with: '[',each,'s](',each,')']]
				without: currentToken.
	output _ output copyReplaceAll: Character lf asString with: '  ', Character lf asString.
	^ output! !

!DocumentationGenerator methodsFor: 'as yet unclassified' stamp: 'len 9/3/2016 07:20'!
generateForClasses: classes
	| tokens |
	tokens _ classes collect: [:each| each name].
	classes do: [:class|
		| output i file |
		output _ '' writeStream.
		class withAllSuperclasses reversed do: [:each|
			| generated |
			generated _ each == class
				ifTrue: ['**', each name, '**']
				ifFalse: [self generate: each name references: tokens].
			output nextPutAll: generated]
			separatedBy: [output nextPutAll: ' > '].
		output lf; lf.
		class hasComment ifTrue: [output nextPutAll: (self generate: class comment references: tokens except: class name); lf; lf].
		output nextPutAll: '***'; lf.
"		class organization categories do: [:category|
			((category includesSubString: 'private') or: [category includesSubString: 'initializ'])
				ifFalse:
					[output nextPutAll: '*', category withBlanksTrimmed, '*  '; lf.
					(class organization listAtCategoryNamed: category)
						do: [:selector|
							| methodComment |
							output nextPutAll: '&nbsp;&nbsp;**',(self escape: (class sourceCodeAt: selector) lines first withBlanksTrimmed),'**  '; lf.
							(methodComment _ class firstCommentAt: selector) isEmpty
								ifFalse: [methodComment lines do: [:line| output nextPutAll: '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', (self escape: line withBlanksTrimmed), '  '; lf]].
							output lf]]].
		output nextPutAll: '***'; lf."
		i _ 0.
		class allSuperclasses reversed do: [:each|
			i*2 timesRepeat: [output nextPutAll: '&nbsp;'].
			output nextPutAll: (self generate: each name references: tokens).
			output nextPutAll: '  '; lf.
			i _ i + 1].
		class allSubclassesWithLevelDo: [:subclass :level|
			| generated |
			(level+i)*2 timesRepeat: [output nextPutAll: '&nbsp;'].
			generated _ subclass == class
				ifTrue: ['**', subclass name, '**']
				ifFalse: [self generate: subclass name references: tokens].
			output nextPutAll: generated.
			output nextPutAll: '  '; lf] startingLevel: 0.
		file _ self path,class name,'.md' :: asFileEntry.
		file assureExistence; fileContents: output contents]! !

!DocumentationGenerator methodsFor: 'as yet unclassified' stamp: 'len 8/11/2016 21:58'!
path
	^ '/home/guest/cuis/Cuis-Mathematics.wiki/doc/'! !

!ElementaryTensorOld methodsFor: 'arithmetic' stamp: 'len 11/9/2015 03:09'!
* anObject
	| answer |
	anObject isTensor
		ifFalse: [^ self class left: self left * anObject right: self right * anObject identity].
	anObject do: [ :each |
		answer _ answer isNil
			ifTrue: [self class
						left: self left * each left
						right: self right * each right]
			ifFalse: [answer + (self class
						left: self left * each left
						right: self right * each right)]].
	^ answer! !

!ElementaryTensorOld methodsFor: 'arithmetic' stamp: 'len 11/27/2015 04:44'!
+ aTensor
	^ TensorOld new add: self; add: aTensor; yourself! !

!ElementaryTensorOld methodsFor: 'arithmetic' stamp: 'len 11/9/2015 03:09'!
- anObject
	^ self + anObject negated! !

!ElementaryTensorOld methodsFor: 'comparing' stamp: 'len 11/19/2015 18:49'!
= anObject
	^ self class == anObject class and: [(self + anObject negated) isZero]! !

!ElementaryTensorOld methodsFor: 'arithmetic' stamp: 'len 12/3/97 02:28'!
addLeft: anObject
	"Answer the left addition of anObject to the receiver."

	^ self class left: self left + anObject right: self right! !

!ElementaryTensorOld methodsFor: 'arithmetic' stamp: 'len 12/3/97 02:28'!
addRight: anObject
	"Answer the right addition of anObject to the receiver."

	^ self class left: self left right: self right + anObject! !

!ElementaryTensorOld methodsFor: 'copying' stamp: 'len 11/9/2015 03:10'!
copy
	^ self class left: self left copy right: self right copy! !

!ElementaryTensorOld methodsFor: 'enumerating' stamp: 'len 11/9/2015 03:10'!
do: aBlock
	aBlock value: self! !

!ElementaryTensorOld methodsFor: 'comparing' stamp: 'len 11/9/2015 03:11'!
hash
	^ (self ambient coordinatesOf: self) hash! !

!ElementaryTensorOld methodsFor: 'testing' stamp: 'len 11/9/2015 03:11'!
isTensor
	^ true! !

!ElementaryTensorOld methodsFor: 'accessing' stamp: 'len 12/3/97 02:18'!
left
	"Answer the left component of the receiver."

	^ left! !

!ElementaryTensorOld methodsFor: 'arithmetic' stamp: 'len 11/9/2015 03:11'!
negated
	^ self class left: self left negated right: self right! !

!ElementaryTensorOld methodsFor: 'printing' stamp: 'len 11/9/2015 03:11'!
printOn: aStream
	aStream print: self left; nextPutAll: 'x'; print: self right! !

!ElementaryTensorOld methodsFor: 'accessing' stamp: 'len 12/3/97 02:18'!
right
	"Answer the right component of the receiver."

	^ right! !

!ElementaryTensorOld methodsFor: 'initialization' stamp: 'len 12/3/97 01:48'!
setLeft: anObject right: anotherObject
	left _ anObject.
	right _ anotherObject! !

!ElementaryTensorOld methodsFor: 'accessing' stamp: 'len 11/27/2015 04:40'!
space
	^ self left space tensor: self right space! !

!ElementaryTensorOld class methodsFor: 'instance creation' stamp: 'len 12/3/97 01:49'!
left: anObject right: anotherObject
	"Answer a new instance of the receiver with left
	and right components given by the arguments."

	^ self new setLeft: anObject right: anotherObject! !

!GaussianElimination2 methodsFor: 'inquiries' stamp: 'len 11/5/2015 01:24'!
dependentColumns
	| independent |
	independent _ self independentColumns.
	^ (1 to: matrix numberOfColumns) reject: [:j | independent includes: j]! !

!GaussianElimination2 methodsFor: 'inquiries' stamp: 'len 11/4/2015 23:57'!
determinant
	matrix isSquare ifFalse: [^ nil].
	^ self rank = matrix numberOfRows
		ifTrue: [determinant]
		ifFalse: [matrix scalars zero]! !

!GaussianElimination2 methodsFor: 'accessing'!
extension
	^ extension! !

!GaussianElimination2 methodsFor: 'extension inquiries'!
extensionDependentColumns
	extension isNil ifTrue: [^ nil].
	^ subreducer dependentColumns! !

!GaussianElimination2 methodsFor: 'extension inquiries'!
extensionIndependentColumns
	extension isNil ifTrue: [^ nil].
	^ subreducer independentColumns! !

!GaussianElimination2 methodsFor: 'extension inquiries'!
extensionIsDependent
	^ self extensionDependentColumns isEmpty not
! !

!GaussianElimination2 methodsFor: 'inquiries'!
independentColumns
	^ pivots collect: [:each | each y]! !

!GaussianElimination2 methodsFor: 'computing' stamp: 'len 11/5/2015 01:17'!
killColumn
	| piv |
	piv _ pivots last.
	1 to: piv x - 1 do: [:i | self killRow: i].
	piv x + 1 to: matrix numberOfRows do: [:i | self killRow: i]
! !

!GaussianElimination2 methodsFor: 'computing' stamp: 'len 12/22/2015 20:38'!
killRow: i
	| piv r coef pos  j a |
	piv _ pivots last.
	(coef _ (matrix at: i @ piv y) negated) isZero ifTrue: [^ self].
	r _ piv x.

	"Kill the element"
	matrix at: i @ piv y put: matrix scalars zero.

	"Repeat the computation on the row"
	pos _ columns position.
	[columns atEnd]
		whileFalse:
			[j _ columns next.
			a _ matrix at: i at: j.
			matrix at: i @ j put: (matrix at: r @ j) * coef + a].
	columns position: pos.

	"Do the same on the inverse"
	inverse addRow: r multipliedBy: coef toRow: i.

	"Do the same on the extension, if any"
	extension notNil ifTrue: [extension addRow: r multipliedBy: coef toRow: i]! !

!GaussianElimination2 methodsFor: 'inquiries'!
leftInverse
	^ inverse! !

!GaussianElimination2 methodsFor: 'computing'!
nextColumn
	^ columns atEnd ifFalse: [columns next]! !

!GaussianElimination2 methodsFor: 'computing' stamp: 'len 12/22/2015 20:37'!
nextPivot
	| col n r k |
	n _ matrix numberOfRows.
	r _ self rowNumber + 1.
	[col _ self nextColumn ifNil: [^ nil].
	(k _ (r to: n)
		detect: [:i| (matrix at: i @ col) isZero not]
		ifNone: []) isNil] whileTrue.
	^ k @ col! !

!GaussianElimination2 methodsFor: 'computing' stamp: 'len 11/6/2015 06:18'!
normalize
	| piv factor coef index |
	matrix scalars isField ifFalse: [ ^ self ].
	piv _ pivots last.
	index _ piv x.
	coef _ matrix at: index @ piv y.
	coef = self scalars one ifTrue: [^ self].
	factor _ coef reciprocal.
	matrix multiplyRow: index by: factor.
	inverse multiplyRow: index by: factor.
	extension notNil ifTrue: [extension multiplyRow: index by: factor].
	determinant _ determinant * coef "or multiply by factor?!!!!!!"! !

!GaussianElimination2 methodsFor: 'inquiries'!
rank
	^ pivots size! !

!GaussianElimination2 methodsFor: 'processing' stamp: 'len 12/26/2015 03:24'!
reduce
	| i piv |
	i _ 0.
	[(piv _ self nextPivot) isNil]
		whileFalse:
			[i _ i + 1.
			pivots add: i @ piv y.
			self
				swap: piv x;
				normalize;
				killColumn].
	extension notNil
		ifTrue:
			[subreducer _ self class on: self subextension].
"	matrix scalars isField
		ifFalse:
			[1 to: (matrix numberOfRows min: matrix numberOfColumns)
				do: [ :k | determinant _ determinant * (matrix at: k at: k) ]]"! !

!GaussianElimination2 methodsFor: 'inquiries' stamp: 'len 12/26/2015 04:40'!
reduced
	^ matrix! !

!GaussianElimination2 methodsFor: 'inquiries' stamp: 'len 11/5/2015 00:12'!
rowIndexOfPivotAtColumn: j
	^ (pivots detect: [:one | one y = j]) x! !

!GaussianElimination2 methodsFor: 'computing' stamp: 'len 11/4/2015 23:59'!
rowNumber
	^ pivots isEmpty ifTrue: [0] ifFalse: [pivots last x]! !

!GaussianElimination2 methodsFor: 'accessing'!
scalars
	^ matrix scalars! !

!GaussianElimination2 methodsFor: 'initialization' stamp: 'len 7/15/2016 05:08'!
setMatrix: aMatrix extension: extMatrix
	aMatrix scalars isField ifFalse: [^ DomainError signal: 'scalars are not a field'].
	matrix _ aMatrix.
	extension _ (extMatrix isKindOf: Tuple)
		ifTrue: [matrix species columns: {extMatrix}]
		ifFalse: [extMatrix].
	columns _ ReadStream on: (1 to: aMatrix numberOfColumns) asArray.
	inverse _ aMatrix species identity.
	pivots _ OrderedCollection new.
	determinant _ aMatrix scalars one.
	self reduce! !

!GaussianElimination2 methodsFor: 'extension inquiries' stamp: 'len 11/5/2015 00:26'!
subextension
	^ extension submatrix: self rowNumber + 1 by: 1 to: matrix numberOfRows by: extension numberOfColumns! !

!GaussianElimination2 methodsFor: 'extension inquiries'!
subreducer
	^ subreducer! !

!GaussianElimination2 methodsFor: 'computing' stamp: 'len 11/5/2015 05:20'!
swap: i
	| r |
	r _ self rowNumber.
	i = r ifTrue: [ ^ self ].
	matrix swapRow: i with: r.
	inverse swapRow: i with: r.
	extension notNil ifTrue: [extension swapRow: i with: r].
	determinant _ determinant negated! !

!GaussianElimination2 class methodsFor: 'examples'!
examples
	" MatrixReducer examples "

'

	vandermonde :=
			''1  1   1
			 3  5	7
			 9  25 49'' asMatrix.
	reducer _ MatrixReducer input: vandermonde copy.
	reducer reduce.
	reducer rank.
	reducer det.
	inverse _ reducer leftInverse.
	inverse * vandermonde.
	vandermonde scalars.
	vandermonde columnAmbient.

	extReducer _ MatrixReducer input: vandermonde copy extension: (1, -1, 17).
	extReducer reduce.
	extReducer extension.
	extReducer subextension.
	extReducer extensionDependentColumns.
	extReducer extensionIndependentColumns.
	extReducer extensionIsDependent.
	extReducer extension.
	coordinates _ extReducer extension column: 1.

	columns _ vandermonde columnIndexes
		inject: OrderedCollection new
		into: [:result :j | result add: (vandermonde column: j); yourself].
	basis _ LinearBasis generators: columns ambient: (vandermonde columnAmbient).
	basis coordinatesOf: (1, -1, 17)

' edit
			! !

!GaussianElimination2 class methodsFor: 'instance creation' stamp: 'len 11/5/2015 00:00'!
on: aMatrix
	^ self on: aMatrix extension: nil! !

!GaussianElimination2 class methodsFor: 'instance creation' stamp: 'len 11/5/2015 00:00'!
on: aMatrix extension: extMatrix
	^ self new setMatrix: aMatrix extension: extMatrix! !

!Maxel methodsFor: 'as yet unclassified' stamp: 'len 2/13/2016 17:55'!
* anInteger
	^ self notYetImplemented! !

!Maxel methodsFor: 'as yet unclassified' stamp: 'len 9/1/2016 07:51'!
+ aMaxel
	^ self class pixels: (pixels  aMaxel pixels)! !

!Maxel methodsFor: 'as yet unclassified' stamp: 'len 9/1/2016 08:05'!
 aMaxel
	^ self notYetImplemented! !

!Maxel methodsFor: 'as yet unclassified' stamp: 'len 9/1/2016 07:57'!
 aMaxel
	^ self notYetImplemented! !

!Maxel methodsFor: 'as yet unclassified' stamp: 'len 2/13/2016 17:46'!
extent
	^ Pixel row: (pixels max: [:each| each row]) column: (pixels max: [:each| each column])! !

!Maxel methodsFor: 'as yet unclassified' stamp: 'len 2/13/2016 17:51'!
isDiagonal
	^ pixels allSatisfy: [:each| each isDiagonal]! !

!Maxel methodsFor: 'as yet unclassified' stamp: 'len 2/13/2016 17:49'!
isEmpty
	^ self size = 0! !

!Maxel methodsFor: 'as yet unclassified' stamp: 'len 2/13/2016 17:47'!
isSymmetric
	^ self transposed = self! !

!Maxel methodsFor: 'as yet unclassified' stamp: 'len 2/13/2016 17:44'!
size
	^ pixels size! !

!Maxel methodsFor: 'as yet unclassified' stamp: 'len 2/13/2016 17:48'!
trasposed
	^ self class pixels: (pixels collect: [:each| each transposed])! !

!Maxel class methodsFor: 'as yet unclassified' stamp: 'len 2/13/2016 17:51'!
pixels: aCollection
	^ self new pixels: aCollection! !

!OEIS methodsFor: 'as yet unclassified' stamp: 'len 4/27/2016 07:02'!
initialize
	entries _ OrderedCollection new.
	'oeis.txt' asFileEntry readStream: [:aStream|
		[aStream atEnd]
			whileFalse:
				[| line |
				line _ aStream nextLine.
				line first = $#
					ifFalse:
						[| name tokens |
						tokens _ line findTokens: ','.
						name _ tokens first allButLast.
						entries add: name -> (tokens allButFirst collect: [:each| each asInteger]) asArray]]].
	entries _ entries asArray sort: [:a :b| a value size >= b value size]! !

!OEIS methodsFor: 'as yet unclassified' stamp: 'len 4/27/2016 07:02'!
longestEntrySize
	^ entries first value size! !

!OEIS methodsFor: 'as yet unclassified' stamp: 'len 4/20/2016 21:41'!
lookup2: anArray
	'oeis.txt' asFileEntry readStream: [:aStream|
		[aStream atEnd]
			whileFalse:
				[| line |
				line _ aStream nextLine.
				line first = $#
					ifFalse:
						[| name tokens |
						tokens _ line findTokens: ','.
						name _ tokens first allButLast.
						((1 to: (tokens size - 1 min: anArray size))
							allSatisfy: [:i| (tokens at: i+1) asInteger = (anArray at: i)])
								ifTrue: [^ name]]]].
		^ nil! !

!OEIS methodsFor: 'as yet unclassified' stamp: 'len 4/27/2016 07:04'!
lookup: anArray
	| array |
	array _ (anArray is: #Sequence) ifTrue: [anArray copyFrom: 1 to: self longestEntrySize] ifFalse: [anArray].
	entries do: [:each|
		each value size = 0 ifTrue: [^ nil].
		((1 to: (each value size min: array size))
			allSatisfy: [:i| (each value at: i) = (array at: i)])
				ifTrue: [^ each key]].			
	^ nil! !

!OEIS class methodsFor: 'as yet unclassified' stamp: 'len 4/25/2016 07:16'!
default
	^ Default ifNil: [Default _ self new]! !

!OEIS class methodsFor: 'as yet unclassified' stamp: 'len 4/20/2016 21:34'!
new
	^ super new initialize! !

!Pixel methodsFor: 'as yet unclassified' stamp: 'len 2/13/2016 17:49'!
column
	^ column! !

!Pixel methodsFor: 'as yet unclassified' stamp: 'len 2/13/2016 17:48'!
column: anInteger
	column _ anInteger! !

!Pixel methodsFor: 'as yet unclassified' stamp: 'len 2/13/2016 17:47'!
isDiagonal
	^ row = column! !

!Pixel methodsFor: 'as yet unclassified' stamp: 'len 2/13/2016 17:45'!
printOn: aStream
	aStream nextPut: $[; print: row; nextPut: $,; print: column; nextPut: $]! !

!Pixel methodsFor: 'as yet unclassified' stamp: 'len 2/13/2016 17:48'!
row
	^ row! !

!Pixel methodsFor: 'as yet unclassified' stamp: 'len 2/13/2016 17:48'!
row: anInteger
	row _ anInteger! !

!Pixel methodsFor: 'as yet unclassified' stamp: 'len 2/13/2016 17:47'!
transpose
	^ self class row: column column: row! !

!Pixel class methodsFor: 'as yet unclassified' stamp: 'len 2/13/2016 17:50'!
row: anInteger column: anotherInteger
	^ self new row: anInteger; column: anotherInteger! !

!SturmChain methodsFor: 'as yet unclassified' stamp: 'len 11/3/2015 06:50'!
countSignChanges: signs
	| x count |
	x _ signs first.
	count _ 0.
	signs do: [ :each | each sign ~= x ifTrue: [ count _ count + 1 ]. x _ each sign ].
	^ count! !

!SturmChain methodsFor: 'as yet unclassified' stamp: 'len 11/3/2015 06:44'!
numberOfRealRoots
	^ self numberOfSignChangesAtMinusInfinity - self numberOfSignChangesAtInfinity! !

!SturmChain methodsFor: 'as yet unclassified' stamp: 'len 11/3/2015 06:51'!
numberOfSignChangesAt: aNumber
	^ self countSignChanges: (chain collect: [ :each | (each value: aNumber) sign])! !

!SturmChain methodsFor: 'as yet unclassified' stamp: 'len 11/3/2015 06:51'!
numberOfSignChangesAtInfinity
	^ self countSignChanges: (chain collect: [ :each | each leadingCoefficient sign ])! !

!SturmChain methodsFor: 'as yet unclassified' stamp: 'len 11/3/2015 06:51'!
numberOfSignChangesAtMinusInfinity
	^ self countSignChanges: (chain collect: [ :each | each leadingCoefficient sign * (each degree odd ifTrue: [-1] ifFalse: [1])])! !

!SturmChain methodsFor: 'as yet unclassified' stamp: 'len 11/3/2015 20:45'!
polynomial
	^ chain first! !

!SturmChain methodsFor: 'as yet unclassified' stamp: 'len 1/15/2016 06:27'!
polynomial: aPolynomial
	chain _ OrderedCollection with: aPolynomial with: aPolynomial derivative.
	[ chain last degree > 0 ] whileTrue: [ chain add: ((chain at: chain size - 1) \\ chain last) negated ]! !

!SturmChain class methodsFor: 'as yet unclassified' stamp: 'len 11/3/2015 06:46'!
on: aPolynomial
	^ self basicNew setPolynomial: aPolynomial! !

!TensorOld methodsFor: 'arithmetic' stamp: 'len 11/9/2015 03:12'!
* anObject
	| answer |
	anObject isTensor ifFalse: [^ self collect: [ :each | each * anObject]].
	answer _ self class new.
	self do: [ :each |
		anObject do: [ :other | answer add: each * other]].
	^ answer! !

!TensorOld methodsFor: 'arithmetic' stamp: 'len 11/9/2015 03:12'!
+ anObject
	^ self copy addAll: anObject! !

!TensorOld methodsFor: 'arithmetic' stamp: 'len 11/9/2015 03:12'!
- anObject
	^ self + anObject negated! !

!TensorOld methodsFor: 'accessing' stamp: 'len 11/9/2015 03:12'!
add: anElementaryTensor
	^ self contents add: anElementaryTensor! !

!TensorOld methodsFor: 'accessing' stamp: 'len 11/9/2015 03:12'!
addAll: aCollection
	aCollection do: [ :each | self add: each].
	^ aCollection! !

!TensorOld methodsFor: 'enumerating' stamp: 'len 11/9/2015 03:12'!
collect: aBlock
	| answer |
	answer _ self class new.
	self do: [ :each | answer add: (aBlock value: each)].
	^ answer! !

!TensorOld methodsFor: 'accessing-private' stamp: 'len 12/3/97 02:03'!
contents
	^ contents! !

!TensorOld methodsFor: 'accessing-private' stamp: 'len 12/3/97 02:02'!
contents: aCollection
	contents _ aCollection! !

!TensorOld methodsFor: 'copying' stamp: 'len 11/9/2015 03:12'!
copy
	^ self class basicNew contents: (self contents collect: [ :each | each copy])! !

!TensorOld methodsFor: 'enumerating' stamp: 'len 11/9/2015 03:13'!
do: aBlock
	self contents do: aBlock! !

!TensorOld methodsFor: 'initialization' stamp: 'len 12/3/97 02:01'!
initialize
	self contents: OrderedCollection new! !

!TensorOld methodsFor: 'testing' stamp: 'len 11/9/2015 03:13'!
isTensor
	^ true! !

!TensorOld methodsFor: 'arithmetic' stamp: 'len 11/9/2015 03:13'!
negated
	^ self collect: [ :each | each negated]! !

!TensorOld methodsFor: 'private' stamp: 'len 12/3/97 02:15'!
normalize
	self normalizeLeft.
	self normalizeRight! !

!TensorOld methodsFor: 'private' stamp: 'len 11/27/2015 04:44'!
normalizeLeft
	"Normalize the receiver eliminating redundant components on the left side."

	| vectors V matrix reducer dep pivots newContents |
	vectors _ self contents collect: [ :each | each left].
	V _ vectors first space.
	matrix _ Matrix new.
	vectors do: [ :each | matrix addRow: (V coordinatesOf: each)].
	matrix _ matrix transposed.
	reducer _ matrix reducer.
	pivots _ reducer pivots.
	dep _ reducer dependentColumns.
	matrix _ reducer reduced.
	dep do: [ :eachCol |
		pivots do: [ :pivot |
			(matrix at: eachCol @ pivot y) isZero
				ifFalse: [self contents
							at: pivot x
							put: ((self contents at: pivot x)
									addRight: (contents at: eachCol) right
												* (matrix at: eachCol @ pivot y))]]].
	newContents _ OrderedCollection new.
	pivots do: [ :each | newContents add: (self contents at: each x)].
	self contents: newContents! !

!TensorOld methodsFor: 'private' stamp: 'len 1/25/98 02:16'!
normalizeRight
	"Normalize the receiver eliminating redundant components on the left side."

	self notYetImplemented! !

!TensorOld methodsFor: 'printing' stamp: 'len 11/9/2015 03:14'!
printOn: aStream
	| first |
	self normalize.
	first _ true.
	self do: [ :each |
		first ifFalse: [aStream nextPutAll: ' + '].
		first _ false.
		aStream print: each].
	first ifTrue: [aStream nextPut: $0]! !

!TensorOld methodsFor: 'accessing' stamp: 'len 11/27/2015 04:40'!
space
	self do: [ :one | ^ one space].
	self error: 'empty tensor'! !

!TensorOld class methodsFor: 'instance creation' stamp: 'len 12/3/97 02:01'!
new
	^ super new initialize! !
BitTuple initialize!
Digraph initialize!
Integers initialize!
ComplexNumbers initialize!
Reals initialize!
Rationals initialize!
Naturals initialize!
